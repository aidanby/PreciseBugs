{"buggy_code": ["import json as simplejson\nimport logging\nimport os\nfrom pathlib import Path\nfrom posixpath import expandvars\nimport sys\nimport time\nimport warnings\n\nimport click\nimport dotenv\nimport pipfile\nimport vistir\n\nfrom pipenv import environments, exceptions, pep508checker, progress\nfrom pipenv._compat import decode_for_output, fix_utf8\nfrom pipenv.patched import crayons\nfrom pipenv.utils import (\n    cmd_list_to_shell, convert_deps_to_pip, create_spinner, download_file,\n    find_python, get_canonical_names, get_source_list, is_pinned,\n    is_python_command, is_required_version, is_star, is_valid_url,\n    parse_indexes, pep423_name, prepare_pip_source_args, proper_case,\n    python_version, run_command, subprocess_run, venv_resolve_deps\n)\n\n\nif environments.is_type_checking():\n    from typing import Dict, List, Optional, Union\n\n    from pipenv.project import Project\n    from pipenv.vendor.requirementslib.models.requirements import Requirement\n    TSourceDict = Dict[str, Union[str, bool]]\n\n\n# Packages that should be ignored later.\nBAD_PACKAGES = (\n    \"distribute\",\n    \"packaging\",\n    \"pip\",\n    \"pkg-resources\",\n    \"setuptools\",\n    \"wheel\",\n)\n\nFIRST_PACKAGES = (\"cython\",)\n\nif not environments.PIPENV_HIDE_EMOJIS:\n    now = time.localtime()\n    # Halloween easter-egg.\n    if ((now.tm_mon == 10) and (now.tm_mday == 30)) or (\n        (now.tm_mon == 10) and (now.tm_mday == 31)\n    ):\n        INSTALL_LABEL = \"\ud83c\udf83   \"\n    # Christmas easter-egg.\n    elif ((now.tm_mon == 12) and (now.tm_mday == 24)) or (\n        (now.tm_mon == 12) and (now.tm_mday == 25)\n    ):\n        INSTALL_LABEL = \"\ud83c\udf85   \"\n    else:\n        INSTALL_LABEL = \"\ud83d\udc0d   \"\n    INSTALL_LABEL2 = crayons.normal(\"\u2624  \", bold=True)\n    STARTING_LABEL = \"    \"\nelse:\n    INSTALL_LABEL = \"   \"\n    INSTALL_LABEL2 = \"   \"\n    STARTING_LABEL = \"   \"\n\n# Disable colors, for the color blind and others who do not prefer colors.\nif environments.PIPENV_COLORBLIND:\n    crayons.disable()\n\n\ndef do_clear(project):\n    click.echo(crayons.normal(fix_utf8(\"Clearing caches...\"), bold=True))\n    try:\n        from pip._internal import locations\n    except ImportError:  # pip 9.\n        from pip import locations\n\n    try:\n        vistir.path.rmtree(project.s.PIPENV_CACHE_DIR, onerror=vistir.path.handle_remove_readonly)\n        # Other processes may be writing into this directory simultaneously.\n        vistir.path.rmtree(\n            locations.USER_CACHE_DIR,\n            ignore_errors=environments.PIPENV_IS_CI,\n            onerror=vistir.path.handle_remove_readonly\n        )\n    except OSError as e:\n        # Ignore FileNotFoundError. This is needed for Python 2.7.\n        import errno\n\n        if e.errno == errno.ENOENT:\n            pass\n        raise\n\n\ndef load_dot_env(project, as_dict=False):\n    \"\"\"Loads .env file into sys.environ.\"\"\"\n    if not project.s.PIPENV_DONT_LOAD_ENV:\n        # If the project doesn't exist yet, check current directory for a .env file\n        project_directory = project.project_directory or \".\"\n        dotenv_file = project.s.PIPENV_DOTENV_LOCATION or os.sep.join(\n            [project_directory, \".env\"]\n        )\n\n        if os.path.isfile(dotenv_file):\n            click.echo(\n                crayons.normal(fix_utf8(\"Loading .env environment variables...\"), bold=True),\n                err=True,\n            )\n        else:\n            if project.s.PIPENV_DOTENV_LOCATION:\n                click.echo(\n                    \"{}: file {}={} does not exist!!\\n{}\".format(\n                        crayons.red(\"Warning\", bold=True),\n                        crayons.normal(\"PIPENV_DOTENV_LOCATION\", bold=True),\n                        crayons.normal(project.s.PIPENV_DOTENV_LOCATION, bold=True),\n                        crayons.red(\"Not loading environment variables.\", bold=True),\n                    ),\n                    err=True,\n                )\n        if as_dict:\n            return dotenv.dotenv_values(dotenv_file)\n        else:\n            dotenv.load_dotenv(dotenv_file, override=True)\n            project.s.initialize()\n\n\ndef cleanup_virtualenv(project, bare=True):\n    \"\"\"Removes the virtualenv directory from the system.\"\"\"\n    if not bare:\n        click.echo(crayons.red(\"Environment creation aborted.\"))\n    try:\n        # Delete the virtualenv.\n        vistir.path.rmtree(project.virtualenv_location)\n    except OSError as e:\n        click.echo(\n            \"{} An error occurred while removing {}!\".format(\n                crayons.red(\"Error: \", bold=True),\n                crayons.green(project.virtualenv_location),\n            ),\n            err=True,\n        )\n        click.echo(crayons.cyan(e), err=True)\n\n\ndef import_requirements(project, r=None, dev=False):\n    from pipenv.patched.notpip._vendor import requests as pip_requests\n    from pipenv.patched.notpip._internal.req.constructors import install_req_from_parsed_requirement\n    from pipenv.vendor.pip_shims.shims import parse_requirements\n\n    # Parse requirements.txt file with Pip's parser.\n    # Pip requires a `PipSession` which is a subclass of requests.Session.\n    # Since we're not making any network calls, it's initialized to nothing.\n    if r:\n        assert os.path.isfile(r)\n    # Default path, if none is provided.\n    if r is None:\n        r = project.requirements_location\n    with open(r) as f:\n        contents = f.read()\n    indexes = []\n    trusted_hosts = []\n    # Find and add extra indexes.\n    for line in contents.split(\"\\n\"):\n        index, extra_index, trusted_host, _ = parse_indexes(line.strip(), strict=True)\n        if index:\n            indexes = [index]\n        if extra_index:\n            indexes.append(extra_index)\n        if trusted_host:\n            trusted_hosts.append(trusted_host)\n    indexes = sorted(set(indexes))\n    trusted_hosts = sorted(set(trusted_hosts))\n    reqs = [install_req_from_parsed_requirement(f) for f in parse_requirements(r, session=pip_requests)]\n    for package in reqs:\n        if package.name not in BAD_PACKAGES:\n            if package.link is not None:\n                package_string = (\n                    f\"-e {package.link}\"\n                    if package.editable\n                    else str(package.link)\n                )\n                project.add_package_to_pipfile(package_string, dev=dev)\n            else:\n                project.add_package_to_pipfile(str(package.req), dev=dev)\n    for index in indexes:\n        trusted = index in trusted_hosts\n        project.add_index_to_pipfile(index, verify_ssl=trusted)\n    project.recase_pipfile()\n\n\ndef ensure_environment():\n    # Skip this on Windows...\n    if os.name != \"nt\":\n        if \"LANG\" not in os.environ:\n            click.echo(\n                \"{}: the environment variable {} is not set!\"\n                \"\\nWe recommend setting this in {} (or equivalent) for \"\n                \"proper expected behavior.\".format(\n                    crayons.red(\"Warning\", bold=True),\n                    crayons.normal(\"LANG\", bold=True),\n                    crayons.green(\"~/.profile\"),\n                ),\n                err=True,\n            )\n\n\ndef import_from_code(path=\".\"):\n    from pipreqs import pipreqs\n\n    rs = []\n    try:\n        for r in pipreqs.get_all_imports(\n            path, encoding=\"utf-8\", extra_ignore_dirs=[\".venv\"]\n        ):\n            if r not in BAD_PACKAGES:\n                rs.append(r)\n        pkg_names = pipreqs.get_pkg_names(rs)\n        return [proper_case(r) for r in pkg_names]\n\n    except Exception:\n        return []\n\n\ndef ensure_pipfile(project, validate=True, skip_requirements=False, system=False):\n    \"\"\"Creates a Pipfile for the project, if it doesn't exist.\"\"\"\n\n    # Assert Pipfile exists.\n    python = project._which(\"python\") if not (project.s.USING_DEFAULT_PYTHON or system) else None\n    if project.pipfile_is_empty:\n        # Show an error message and exit if system is passed and no pipfile exists\n        if system and not project.s.PIPENV_VIRTUALENV:\n            raise exceptions.PipenvOptionsError(\n                \"--system\",\n                \"--system is intended to be used for pre-existing Pipfile \"\n                \"installation, not installation of specific packages. Aborting.\"\n            )\n        # If there's a requirements file, but no Pipfile...\n        if project.requirements_exists and not skip_requirements:\n            click.echo(\n                crayons.normal(\n                    fix_utf8(\"requirements.txt found, instead of Pipfile! Converting...\"),\n                    bold=True,\n                )\n            )\n            # Create a Pipfile...\n            project.create_pipfile(python=python)\n            with create_spinner(\"Importing requirements...\", project.s) as sp:\n                # Import requirements.txt.\n                try:\n                    import_requirements(project)\n                except Exception:\n                    sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Failed...\"))\n                else:\n                    sp.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Success!\"))\n            # Warn the user of side-effects.\n            click.echo(\n                \"{0}: Your {1} now contains pinned versions, if your {2} did. \\n\"\n                \"We recommend updating your {1} to specify the {3} version, instead.\"\n                \"\".format(\n                    crayons.red(\"Warning\", bold=True),\n                    crayons.normal(\"Pipfile\", bold=True),\n                    crayons.normal(\"requirements.txt\", bold=True),\n                    crayons.normal('\"*\"', bold=True),\n                )\n            )\n        else:\n            click.echo(\n                crayons.normal(fix_utf8(\"Creating a Pipfile for this project...\"), bold=True),\n                err=True,\n            )\n            # Create the pipfile if it doesn't exist.\n            project.create_pipfile(python=python)\n    # Validate the Pipfile's contents.\n    if validate and project.virtualenv_exists and not project.s.PIPENV_SKIP_VALIDATION:\n        # Ensure that Pipfile is using proper casing.\n        p = project.parsed_pipfile\n        changed = project.ensure_proper_casing()\n        # Write changes out to disk.\n        if changed:\n            click.echo(\n                crayons.normal(\"Fixing package names in Pipfile...\", bold=True), err=True\n            )\n            project.write_toml(p)\n\n\ndef find_a_system_python(line):\n    \"\"\"Find a Python installation from a given line.\n\n    This tries to parse the line in various of ways:\n\n    * Looks like an absolute path? Use it directly.\n    * Looks like a py.exe call? Use py.exe to get the executable.\n    * Starts with \"py\" something? Looks like a python command. Try to find it\n      in PATH, and use it directly.\n    * Search for \"python\" and \"pythonX.Y\" executables in PATH to find a match.\n    * Nothing fits, return None.\n    \"\"\"\n\n    from .vendor.pythonfinder import Finder\n    finder = Finder(system=False, global_search=True)\n    if not line:\n        return next(iter(finder.find_all_python_versions()), None)\n    # Use the windows finder executable\n    if (line.startswith(\"py \") or line.startswith(\"py.exe \")) and os.name == \"nt\":\n        line = line.split(\" \", 1)[1].lstrip(\"-\")\n    python_entry = find_python(finder, line)\n    return python_entry\n\n\ndef ensure_python(project, three=None, python=None):\n    # Runtime import is necessary due to the possibility that the environments module may have been reloaded.\n    if project.s.PIPENV_PYTHON and python is False and three is None:\n        python = project.s.PIPENV_PYTHON\n\n    def abort(msg=''):\n        click.echo(\n            \"{}\\nYou can specify specific versions of Python with:\\n{}\".format(\n                crayons.red(msg),\n                crayons.yellow(\n                    \"$ pipenv --python {}\".format(\n                        os.sep.join((\"path\", \"to\", \"python\"))\n                    )\n                )\n            ),\n            err=True,\n        )\n        sys.exit(1)\n\n    project.s.USING_DEFAULT_PYTHON = three is None and not python\n    # Find out which python is desired.\n    if not python:\n        python = convert_three_to_python(three, python)\n    if not python:\n        python = project.required_python_version\n    if not python:\n        python = project.s.PIPENV_DEFAULT_PYTHON_VERSION\n    path_to_python = find_a_system_python(python)\n    if project.s.is_verbose():\n        click.echo(f\"Using python: {python}\", err=True)\n        click.echo(f\"Path to python: {path_to_python}\", err=True)\n    if not path_to_python and python is not None:\n        # We need to install Python.\n        click.echo(\n            \"{}: Python {} {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                crayons.cyan(python),\n                fix_utf8(\"was not found on your system...\"),\n            ),\n            err=True,\n        )\n        # check for python installers\n        from .installers import Asdf, InstallerError, InstallerNotFound, Pyenv\n\n        # prefer pyenv if both pyenv and asdf are installed as it's\n        # dedicated to python installs so probably the preferred\n        # method of the user for new python installs.\n        installer = None\n        if not project.s.PIPENV_DONT_USE_PYENV:\n            try:\n                installer = Pyenv(project)\n            except InstallerNotFound:\n                pass\n        if installer is None and not project.s.PIPENV_DONT_USE_ASDF:\n            try:\n                installer = Asdf(project)\n            except InstallerNotFound:\n                pass\n\n        if not installer:\n            abort(\"Neither 'pyenv' nor 'asdf' could be found to install Python.\")\n        else:\n            if environments.SESSION_IS_INTERACTIVE or project.s.PIPENV_YES:\n                try:\n                    version = installer.find_version_to_install(python)\n                except ValueError:\n                    abort()\n                except InstallerError as e:\n                    abort(f'Something went wrong while installing Python:\\n{e.err}')\n                s = \"{} {} {}\".format(\n                    \"Would you like us to install\",\n                    crayons.green(f\"CPython {version}\"),\n                    f\"with {installer}?\",\n                )\n                # Prompt the user to continue...\n                if not (project.s.PIPENV_YES or click.confirm(s, default=True)):\n                    abort()\n                else:\n                    # Tell the user we're installing Python.\n                    click.echo(\n                        \"{} {} {} {}{}\".format(\n                            crayons.normal(\"Installing\", bold=True),\n                            crayons.green(f\"CPython {version}\", bold=True),\n                            crayons.normal(f\"with {installer.cmd}\", bold=True),\n                            crayons.normal(\"(this may take a few minutes)\"),\n                            crayons.normal(\"...\", bold=True),\n                        )\n                    )\n                    with create_spinner(\"Installing python...\", project.s) as sp:\n                        try:\n                            c = installer.install(version)\n                        except InstallerError as e:\n                            sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\n                                \"Failed...\")\n                            )\n                            click.echo(fix_utf8(\"Something went wrong...\"), err=True)\n                            click.echo(crayons.cyan(e.err), err=True)\n                        else:\n                            sp.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Success!\"))\n                            # Print the results, in a beautiful blue...\n                            click.echo(crayons.cyan(c.stdout), err=True)\n                            # Clear the pythonfinder caches\n                            from .vendor.pythonfinder import Finder\n                            finder = Finder(system=False, global_search=True)\n                            finder.find_python_version.cache_clear()\n                            finder.find_all_python_versions.cache_clear()\n                    # Find the newly installed Python, hopefully.\n                    version = str(version)\n                    path_to_python = find_a_system_python(version)\n                    try:\n                        assert python_version(path_to_python) == version\n                    except AssertionError:\n                        click.echo(\n                            \"{}: The Python you just installed is not available on your {}, apparently.\"\n                            \"\".format(\n                                crayons.red(\"Warning\", bold=True),\n                                crayons.normal(\"PATH\", bold=True),\n                            ),\n                            err=True,\n                        )\n                        sys.exit(1)\n    return path_to_python\n\n\ndef ensure_virtualenv(project, three=None, python=None, site_packages=None, pypi_mirror=None):\n    \"\"\"Creates a virtualenv, if one doesn't exist.\"\"\"\n\n    def abort():\n        sys.exit(1)\n\n    if not project.virtualenv_exists:\n        try:\n            # Ensure environment variables are set properly.\n            ensure_environment()\n            # Ensure Python is available.\n            python = ensure_python(project, three=three, python=python)\n            if python is not None and not isinstance(python, str):\n                python = python.path.as_posix()\n            # Create the virtualenv.\n            # Abort if --system (or running in a virtualenv).\n            if project.s.PIPENV_USE_SYSTEM:\n                click.echo(\n                    crayons.red(\n                        \"You are attempting to re\u2013create a virtualenv that \"\n                        \"Pipenv did not create. Aborting.\"\n                    )\n                )\n                sys.exit(1)\n            do_create_virtualenv(\n                project, python=python, site_packages=site_packages, pypi_mirror=pypi_mirror\n            )\n        except KeyboardInterrupt:\n            # If interrupted, cleanup the virtualenv.\n            cleanup_virtualenv(project, bare=False)\n            sys.exit(1)\n    # If --three, --two, or --python were passed...\n    elif (python) or (three is not None) or (site_packages is not None):\n        project.s.USING_DEFAULT_PYTHON = False\n        # Ensure python is installed before deleting existing virtual env\n        python = ensure_python(project, three=three, python=python)\n        if python is not None and not isinstance(python, str):\n            python = python.path.as_posix()\n\n        click.echo(crayons.red(\"Virtualenv already exists!\"), err=True)\n        # If VIRTUAL_ENV is set, there is a possibility that we are\n        # going to remove the active virtualenv that the user cares\n        # about, so confirm first.\n        if \"VIRTUAL_ENV\" in os.environ:\n            if not (\n                project.s.PIPENV_YES or click.confirm(\"Remove existing virtualenv?\", default=True)\n            ):\n                abort()\n        click.echo(\n            crayons.normal(fix_utf8(\"Removing existing virtualenv...\"), bold=True), err=True\n        )\n        # Remove the virtualenv.\n        cleanup_virtualenv(project, bare=True)\n        # Call this function again.\n        ensure_virtualenv(\n            project,\n            three=three,\n            python=python,\n            site_packages=site_packages,\n            pypi_mirror=pypi_mirror,\n        )\n\n\ndef ensure_project(\n    project,\n    three=None,\n    python=None,\n    validate=True,\n    system=False,\n    warn=True,\n    site_packages=None,\n    deploy=False,\n    skip_requirements=False,\n    pypi_mirror=None,\n    clear=False,\n):\n    \"\"\"Ensures both Pipfile and virtualenv exist for the project.\"\"\"\n\n    # Automatically use an activated virtualenv.\n    if project.s.PIPENV_USE_SYSTEM:\n        system = True\n    if not project.pipfile_exists and deploy:\n        raise exceptions.PipfileNotFound\n    # Skip virtualenv creation when --system was used.\n    if not system:\n        ensure_virtualenv(\n            project,\n            three=three,\n            python=python,\n            site_packages=site_packages,\n            pypi_mirror=pypi_mirror,\n        )\n        if warn:\n            # Warn users if they are using the wrong version of Python.\n            if project.required_python_version:\n                path_to_python = project._which(\"python\") or project._which(\"py\")\n                if path_to_python and project.required_python_version not in (\n                    python_version(path_to_python) or \"\"\n                ):\n                    click.echo(\n                        \"{}: Your Pipfile requires {} {}, \"\n                        \"but you are using {} ({}).\".format(\n                            crayons.red(\"Warning\", bold=True),\n                            crayons.normal(\"python_version\", bold=True),\n                            crayons.cyan(project.required_python_version),\n                            crayons.cyan(python_version(path_to_python) or \"unknown\"),\n                            crayons.green(shorten_path(path_to_python)),\n                        ),\n                        err=True,\n                    )\n                    click.echo(\n                        \"  {} and rebuilding the virtual environment \"\n                        \"may resolve the issue.\".format(crayons.green(\"$ pipenv --rm\")),\n                        err=True,\n                    )\n                    if not deploy:\n                        click.echo(\n                            \"  {} will surely fail.\"\n                            \"\".format(crayons.yellow(\"$ pipenv check\")),\n                            err=True,\n                        )\n                    else:\n                        raise exceptions.DeployException\n    # Ensure the Pipfile exists.\n    ensure_pipfile(\n        project, validate=validate, skip_requirements=skip_requirements, system=system\n    )\n\n\ndef shorten_path(location, bold=False):\n    \"\"\"Returns a visually shorter representation of a given system path.\"\"\"\n    original = location\n    short = os.sep.join(\n        [s[0] if len(s) > (len(\"2long4\")) else s for s in location.split(os.sep)]\n    )\n    short = short.split(os.sep)\n    short[-1] = original.split(os.sep)[-1]\n    if bold:\n        short[-1] = str(crayons.normal(short[-1], bold=True))\n    return os.sep.join(short)\n\n\n# return short\ndef do_where(project, virtualenv=False, bare=True):\n    \"\"\"Executes the where functionality.\"\"\"\n    if not virtualenv:\n        if not project.pipfile_exists:\n            click.echo(\n                \"No Pipfile present at project home. Consider running \"\n                \"{} first to automatically generate a Pipfile for you.\"\n                \"\".format(crayons.green(\"`pipenv install`\")),\n                err=True,\n            )\n            return\n        location = project.pipfile_location\n        # Shorten the virtual display of the path to the virtualenv.\n        if not bare:\n            location = shorten_path(location)\n            click.echo(\n                \"Pipfile found at {}.\\n  Considering this to be the project home.\"\n                \"\".format(crayons.green(location)),\n                err=True,\n            )\n        else:\n            click.echo(project.project_directory)\n    else:\n        location = project.virtualenv_location\n        if not bare:\n            click.echo(\n                f\"Virtualenv location: {crayons.green(location)}\", err=True\n            )\n        else:\n            click.echo(location)\n\n\ndef _cleanup_procs(project, procs, failed_deps_queue, retry=True):\n    while not procs.empty():\n        c = procs.get()\n        try:\n            out, err = c.communicate()\n        except AttributeError:\n            out, err = c.stdout, c.stderr\n        failed = c.returncode != 0\n        if \"Ignoring\" in out:\n            click.echo(crayons.yellow(out.strip()))\n        elif project.s.is_verbose():\n            click.echo(crayons.cyan(out.strip() or err.strip()))\n        # The Installation failed...\n        if failed:\n            # If there is a mismatch in installed locations or the install fails\n            # due to wrongful disabling of pep517, we should allow for\n            # additional passes at installation\n            if \"does not match installed location\" in err:\n                project.environment.expand_egg_links()\n                click.echo(\"{}\".format(\n                    crayons.yellow(\n                        \"Failed initial installation: Failed to overwrite existing \"\n                        \"package, likely due to path aliasing. Expanding and trying \"\n                        \"again!\"\n                    )\n                ))\n                dep = c.dep.copy()\n                dep.use_pep517 = True\n            elif \"Disabling PEP 517 processing is invalid\" in err:\n                dep = c.dep.copy()\n                dep.use_pep517 = True\n            elif not retry:\n                # The Installation failed...\n                # We echo both c.stdout and c.stderr because pip returns error details on out.\n                err = err.strip().splitlines() if err else []\n                out = out.strip().splitlines() if out else []\n                err_lines = [line for message in [out, err] for line in message]\n                # Return the subprocess' return code.\n                raise exceptions.InstallError(c.dep.name, extra=err_lines)\n            else:\n                # Alert the user.\n                dep = c.dep.copy()\n                dep.use_pep517 = False\n                click.echo(\n                    \"{} {}! Will try again.\".format(\n                        crayons.red(\"An error occurred while installing\"),\n                        crayons.green(dep.as_line()),\n                    ), err=True\n                )\n            # Save the Failed Dependency for later.\n            failed_deps_queue.put(dep)\n\n\ndef batch_install(project, deps_list, procs, failed_deps_queue,\n                  requirements_dir, no_deps=True, ignore_hashes=False,\n                  allow_global=False, blocking=False, pypi_mirror=None,\n                  retry=True, sequential_deps=None):\n    from .vendor.requirementslib.models.utils import (\n        strip_extras_markers_from_requirement\n    )\n    if sequential_deps is None:\n        sequential_deps = []\n    failed = (not retry)\n    install_deps = not no_deps\n    if not failed:\n        label = INSTALL_LABEL if not environments.PIPENV_HIDE_EMOJIS else \"\"\n    else:\n        label = INSTALL_LABEL2\n\n    deps_to_install = deps_list[:]\n    deps_to_install.extend(sequential_deps)\n    deps_to_install = [\n        dep for dep in deps_to_install if not project.environment.is_satisfied(dep)\n    ]\n    sequential_dep_names = [d.name for d in sequential_deps]\n\n    deps_list_bar = progress.bar(\n        deps_to_install, width=32,\n        label=label\n    )\n\n    trusted_hosts = []\n    # Install these because\n    for dep in deps_list_bar:\n        extra_indexes = []\n        if dep.req.req:\n            dep.req.req = strip_extras_markers_from_requirement(dep.req.req)\n        if dep.markers:\n            dep.markers = str(strip_extras_markers_from_requirement(dep.get_markers()))\n        # Install the module.\n        is_artifact = False\n        if dep.is_file_or_url and (dep.is_direct_url or any(\n            dep.req.uri.endswith(ext) for ext in [\"zip\", \"tar.gz\"]\n        )):\n            is_artifact = True\n        elif dep.is_vcs:\n            is_artifact = True\n        if not project.s.PIPENV_RESOLVE_VCS and is_artifact and not dep.editable:\n            install_deps = True\n            no_deps = False\n\n        with vistir.contextmanagers.temp_environ():\n            if not allow_global:\n                os.environ[\"PIP_USER\"] = vistir.compat.fs_str(\"0\")\n                if \"PYTHONHOME\" in os.environ:\n                    del os.environ[\"PYTHONHOME\"]\n            if \"GIT_CONFIG\" in os.environ and dep.is_vcs:\n                del os.environ[\"GIT_CONFIG\"]\n            use_pep517 = True\n            if failed and not dep.is_vcs:\n                use_pep517 = getattr(dep, \"use_pep517\", False)\n\n            is_sequential = sequential_deps and dep.name in sequential_dep_names\n            is_blocking = any([dep.editable, dep.is_vcs, blocking, is_sequential])\n            c = pip_install(\n                project,\n                dep,\n                ignore_hashes=any([ignore_hashes, dep.editable, dep.is_vcs]),\n                allow_global=allow_global,\n                no_deps=not install_deps,\n                block=is_blocking,\n                index=dep.index,\n                requirements_dir=requirements_dir,\n                pypi_mirror=pypi_mirror,\n                trusted_hosts=trusted_hosts,\n                extra_indexes=extra_indexes,\n                use_pep517=use_pep517,\n            )\n            c.dep = dep\n\n            procs.put(c)\n            if procs.full() or procs.qsize() == len(deps_list) or is_sequential:\n                _cleanup_procs(project, procs, failed_deps_queue, retry=retry)\n\n\ndef do_install_dependencies(\n    project,\n    dev=False,\n    dev_only=False,\n    bare=False,\n    emit_requirements=False,\n    allow_global=False,\n    ignore_hashes=False,\n    skip_lock=False,\n    concurrent=True,\n    requirements_dir=None,\n    pypi_mirror=None,\n):\n    \"\"\"\"\n    Executes the install functionality.\n\n    If emit_requirements is True, simply spits out a requirements format to stdout.\n    \"\"\"\n\n    import queue\n    if emit_requirements:\n        bare = True\n    # Load the lockfile if it exists, or if dev_only is being used.\n    if skip_lock or not project.lockfile_exists:\n        if not bare:\n            click.echo(\n                crayons.normal(fix_utf8(\"Installing dependencies from Pipfile...\"), bold=True)\n            )\n        # skip_lock should completely bypass the lockfile (broken in 4dac1676)\n        lockfile = project.get_or_create_lockfile(from_pipfile=True)\n    else:\n        lockfile = project.get_or_create_lockfile()\n        if not bare:\n            click.echo(\n                crayons.normal(\n                    fix_utf8(\"Installing dependencies from Pipfile.lock ({})...\".format(\n                        lockfile[\"_meta\"].get(\"hash\", {}).get(\"sha256\")[-6:]\n                    )),\n                    bold=True,\n                )\n            )\n    # Allow pip to resolve dependencies when in skip-lock mode.\n    no_deps = not skip_lock  # skip_lock true, no_deps False, pip resolves deps\n    dev = dev or dev_only\n    deps_list = list(lockfile.get_requirements(dev=dev, only=dev_only))\n    if emit_requirements:\n        index_args = prepare_pip_source_args(\n            get_source_list(project, pypi_mirror=pypi_mirror)\n        )\n        index_args = \" \".join(index_args).replace(\" -\", \"\\n-\")\n        deps = [\n            req.as_line(sources=False, include_hashes=False) for req in deps_list\n        ]\n        click.echo(index_args)\n        click.echo(\"\\n\".join(sorted(deps)))\n        sys.exit(0)\n    if concurrent:\n        nprocs = project.s.PIPENV_MAX_SUBPROCESS\n    else:\n        nprocs = 1\n    procs = queue.Queue(maxsize=nprocs)\n    failed_deps_queue = queue.Queue()\n    if skip_lock:\n        ignore_hashes = True\n    editable_or_vcs_deps = [dep for dep in deps_list if (dep.editable or dep.vcs)]\n    normal_deps = [dep for dep in deps_list if not (dep.editable or dep.vcs)]\n    install_kwargs = {\n        \"no_deps\": no_deps, \"ignore_hashes\": ignore_hashes, \"allow_global\": allow_global,\n        \"blocking\": not concurrent, \"pypi_mirror\": pypi_mirror,\n        \"sequential_deps\": editable_or_vcs_deps\n    }\n\n    batch_install(\n        project, normal_deps, procs, failed_deps_queue, requirements_dir, **install_kwargs\n    )\n\n    if not procs.empty():\n        _cleanup_procs(project, procs, failed_deps_queue)\n\n    # click.echo(crayons.normal(\n    #     decode_for_output(\"Installing editable and vcs dependencies...\"), bold=True\n    # ))\n\n    # install_kwargs.update({\"blocking\": True})\n    # # XXX: All failed and editable/vcs deps should be installed in sequential mode!\n    # procs = queue.Queue(maxsize=1)\n    # batch_install(\n    #     editable_or_vcs_deps, procs, failed_deps_queue, requirements_dir,\n    #     **install_kwargs\n    # )\n\n    # Iterate over the hopefully-poorly-packaged dependencies...\n    if not failed_deps_queue.empty():\n        click.echo(\n            crayons.normal(fix_utf8(\"Installing initially failed dependencies...\"), bold=True)\n        )\n        retry_list = []\n        while not failed_deps_queue.empty():\n            failed_dep = failed_deps_queue.get()\n            retry_list.append(failed_dep)\n        install_kwargs.update({\"retry\": False})\n        batch_install(\n            project, retry_list, procs, failed_deps_queue, requirements_dir, **install_kwargs\n        )\n    if not procs.empty():\n        _cleanup_procs(project, procs, failed_deps_queue, retry=False)\n\n\ndef convert_three_to_python(three, python):\n    \"\"\"Converts a Three flag into a Python flag, and raises customer warnings\n    in the process, if needed.\n    \"\"\"\n    if not python:\n        if three is False:\n            return \"2\"\n\n        elif three is True:\n            return \"3\"\n\n    else:\n        return python\n\n\ndef do_create_virtualenv(project, python=None, site_packages=None, pypi_mirror=None):\n    \"\"\"Creates a virtualenv.\"\"\"\n\n    click.echo(\n        crayons.normal(fix_utf8(\"Creating a virtualenv for this project...\"), bold=True), err=True\n    )\n    click.echo(\n        f\"Pipfile: {crayons.yellow(project.pipfile_location, bold=True)}\",\n        err=True,\n    )\n\n    # Default to using sys.executable, if Python wasn't provided.\n    using_string = \"Using\"\n    if not python:\n        python = sys.executable\n        using_string = \"Using default python from\"\n    click.echo(\n        \"{0} {1} {3} {2}\".format(\n            crayons.normal(using_string, bold=True),\n            crayons.yellow(python, bold=True),\n            crayons.normal(fix_utf8(\"to create virtualenv...\"), bold=True),\n            crayons.green(f\"({python_version(python)})\"),\n        ),\n        err=True,\n    )\n\n    cmd = [\n        Path(sys.executable).absolute().as_posix(),\n        \"-m\",\n        \"virtualenv\",\n        f\"--prompt={project.name}\",\n        f\"--python={python}\",\n        project.get_location_for_virtualenv(),\n    ]\n\n    # Pass site-packages flag to virtualenv, if desired...\n    if site_packages:\n        click.echo(\n            crayons.normal(fix_utf8(\"Making site-packages available...\"), bold=True), err=True\n        )\n        cmd.append(\"--system-site-packages\")\n\n    if pypi_mirror:\n        pip_config = {\"PIP_INDEX_URL\": vistir.misc.fs_str(pypi_mirror)}\n    else:\n        pip_config = {}\n\n    # Actually create the virtualenv.\n    error = None\n    with create_spinner(\"Creating virtual environment...\", project.s) as sp:\n        c = subprocess_run(cmd, env=pip_config)\n        click.echo(crayons.cyan(f\"{c.stdout}\"), err=True)\n        if c.returncode != 0:\n            error = c.stderr if project.s.is_verbose() else exceptions.prettify_exc(c.stderr)\n            sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Failed creating virtual environment\"))\n        else:\n            sp.green.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Successfully created virtual environment!\"))\n    if error is not None:\n        raise exceptions.VirtualenvCreationException(\n            extra=crayons.red(f\"{error}\")\n        )\n\n    # Associate project directory with the environment.\n    # This mimics Pew's \"setproject\".\n    project_file_name = os.path.join(project.virtualenv_location, \".project\")\n    with open(project_file_name, \"w\") as f:\n        f.write(vistir.misc.fs_str(project.project_directory))\n    from .environment import Environment\n    sources = project.pipfile_sources\n    # project.get_location_for_virtualenv is only for if we are creating a new virtualenv\n    # whereas virtualenv_location is for the current path to the runtime\n    project._environment = Environment(\n        prefix=project.virtualenv_location,\n        is_venv=True,\n        sources=sources,\n        pipfile=project.parsed_pipfile,\n        project=project\n    )\n    project._environment.add_dist(\"pipenv\")\n    # Say where the virtualenv is.\n    do_where(project, virtualenv=True, bare=False)\n\n\ndef parse_download_fname(fname, name):\n    fname, fextension = os.path.splitext(fname)\n    if fextension == \".whl\":\n        fname = \"-\".join(fname.split(\"-\")[:-3])\n    if fname.endswith(\".tar\"):\n        fname, _ = os.path.splitext(fname)\n    # Substring out package name (plus dash) from file name to get version.\n    version = fname[len(name) + 1 :]\n    # Ignore implicit post releases in version number.\n    if \"-\" in version and version.split(\"-\")[1].isdigit():\n        version = version.split(\"-\")[0]\n    return version\n\n\ndef get_downloads_info(project, names_map, section):\n    from .vendor.requirementslib.models.requirements import Requirement\n\n    info = []\n    p = project.parsed_pipfile\n    for fname in os.listdir(project.download_location):\n        # Get name from filename mapping.\n        name = Requirement.from_line(names_map[fname]).name\n        # Get the version info from the filenames.\n        version = parse_download_fname(fname, name)\n        # Get the hash of each file.\n        cmd = [\n            which_pip(project),\n            \"hash\",\n            os.sep.join([project.download_location, fname]),\n        ]\n        c = subprocess_run(cmd)\n        hash = c.stdout.split(\"--hash=\")[1].strip()\n        # Verify we're adding the correct version from Pipfile\n        # and not one from a dependency.\n        specified_version = p[section].get(name, \"\")\n        if is_required_version(version, specified_version):\n            info.append(dict(name=name, version=version, hash=hash))\n    return info\n\n\ndef overwrite_dev(prod, dev):\n    dev_keys = set(list(dev.keys()))\n    prod_keys = set(list(prod.keys()))\n    for pkg in dev_keys & prod_keys:\n        dev[pkg] = prod[pkg]\n    return dev\n\n\ndef do_lock(\n    project,\n    ctx=None,\n    system=False,\n    clear=False,\n    pre=False,\n    keep_outdated=False,\n    write=True,\n    pypi_mirror=None,\n):\n    \"\"\"Executes the freeze functionality.\"\"\"\n\n    cached_lockfile = {}\n    if not pre:\n        pre = project.settings.get(\"allow_prereleases\")\n    if keep_outdated:\n        if not project.lockfile_exists:\n            raise exceptions.PipenvOptionsError(\n                \"--keep-outdated\", ctx=ctx,\n                message=\"Pipfile.lock must exist to use --keep-outdated!\"\n            )\n        cached_lockfile = project.lockfile_content\n    # Create the lockfile.\n    lockfile = project._lockfile\n    # Cleanup lockfile.\n    for section in (\"default\", \"develop\"):\n        for k, v in lockfile[section].copy().items():\n            if not hasattr(v, \"keys\"):\n                del lockfile[section][k]\n    # Ensure that develop inherits from default.\n    dev_packages = project.dev_packages.copy()\n    dev_packages = overwrite_dev(project.packages, dev_packages)\n    # Resolve dev-package dependencies, with pip-tools.\n    for is_dev in [True, False]:\n        pipfile_section = \"dev-packages\" if is_dev else \"packages\"\n        if project.pipfile_exists:\n            packages = project.parsed_pipfile.get(pipfile_section, {})\n        else:\n            packages = getattr(project, pipfile_section.replace(\"-\", \"_\"))\n\n        if write:\n            # Alert the user of progress.\n            click.echo(\n                \"{} {} {}\".format(\n                    crayons.normal(\"Locking\"),\n                    crayons.yellow(\"[{}]\".format(pipfile_section.replace(\"_\", \"-\"))),\n                    crayons.normal(fix_utf8(\"dependencies...\")),\n                ),\n                err=True,\n            )\n\n        # Mutates the lockfile\n        venv_resolve_deps(\n            packages,\n            which=project._which,\n            project=project,\n            dev=is_dev,\n            clear=clear,\n            pre=pre,\n            allow_global=system,\n            pypi_mirror=pypi_mirror,\n            pipfile=packages,\n            lockfile=lockfile,\n            keep_outdated=keep_outdated\n        )\n\n    # Support for --keep-outdated...\n    if keep_outdated:\n        from pipenv.vendor.packaging.utils import canonicalize_name\n        for section_name, section in (\n            (\"default\", project.packages),\n            (\"develop\", project.dev_packages),\n        ):\n            for package_specified in section.keys():\n                if not is_pinned(section[package_specified]):\n                    canonical_name = canonicalize_name(package_specified)\n                    if canonical_name in cached_lockfile[section_name]:\n                        lockfile[section_name][canonical_name] = cached_lockfile[\n                            section_name\n                        ][canonical_name].copy()\n            for key in [\"default\", \"develop\"]:\n                packages = set(cached_lockfile[key].keys())\n                new_lockfile = set(lockfile[key].keys())\n                missing = packages - new_lockfile\n                for missing_pkg in missing:\n                    lockfile[key][missing_pkg] = cached_lockfile[key][missing_pkg].copy()\n    # Overwrite any develop packages with default packages.\n    lockfile[\"develop\"].update(overwrite_dev(lockfile.get(\"default\", {}), lockfile[\"develop\"]))\n    if write:\n        project.write_lockfile(lockfile)\n        click.echo(\n            \"{}\".format(\n                crayons.normal(\n                    \"Updated Pipfile.lock ({})!\".format(\n                        lockfile[\"_meta\"].get(\"hash\", {}).get(\"sha256\")[-6:]\n                    ),\n                    bold=True,\n                )\n            ),\n            err=True,\n        )\n    else:\n        return lockfile\n\n\ndef do_purge(project, bare=False, downloads=False, allow_global=False):\n    \"\"\"Executes the purge functionality.\"\"\"\n\n    if downloads:\n        if not bare:\n            click.echo(crayons.normal(fix_utf8(\"Clearing out downloads directory...\"), bold=True))\n        vistir.path.rmtree(project.download_location)\n        return\n\n    # Remove comments from the output, if any.\n    installed = {\n        pep423_name(pkg.project_name) for pkg in project.environment.get_installed_packages()\n    }\n    bad_pkgs = {pep423_name(pkg) for pkg in BAD_PACKAGES}\n    # Remove setuptools, pip, etc from targets for removal\n    to_remove = installed - bad_pkgs\n\n    # Skip purging if there is no packages which needs to be removed\n    if not to_remove:\n        if not bare:\n            click.echo(\"Found 0 installed package, skip purging.\")\n            click.echo(crayons.green(\"Environment now purged and fresh!\"))\n        return installed\n\n    if not bare:\n        click.echo(\n            fix_utf8(f\"Found {len(to_remove)} installed package(s), purging...\")\n        )\n\n    command = [\n        which_pip(project, allow_global=allow_global),\n        \"uninstall\", \"-y\",\n    ] + list(to_remove)\n    if project.s.is_verbose():\n        click.echo(f\"$ {cmd_list_to_shell(command)}\")\n    c = subprocess_run(command)\n    if c.returncode != 0:\n        raise exceptions.UninstallError(installed, cmd_list_to_shell(command), c.stdout + c.stderr, c.returncode)\n    if not bare:\n        click.echo(crayons.cyan(c.stdout))\n        click.echo(crayons.green(\"Environment now purged and fresh!\"))\n    return installed\n\n\ndef do_init(\n    project,\n    dev=False,\n    dev_only=False,\n    emit_requirements=False,\n    allow_global=False,\n    ignore_pipfile=False,\n    skip_lock=False,\n    system=False,\n    concurrent=True,\n    deploy=False,\n    pre=False,\n    keep_outdated=False,\n    requirements_dir=None,\n    pypi_mirror=None,\n):\n    \"\"\"Executes the init functionality.\"\"\"\n\n    python = None\n    if project.s.PIPENV_PYTHON is not None:\n        python = project.s.PIPENV_PYTHON\n    elif project.s.PIPENV_DEFAULT_PYTHON_VERSION is not None:\n        python = project.s.PIPENV_DEFAULT_PYTHON_VERSION\n\n    if not system and not project.s.PIPENV_USE_SYSTEM:\n        if not project.virtualenv_exists:\n            try:\n                do_create_virtualenv(project, python=python, three=None, pypi_mirror=pypi_mirror)\n            except KeyboardInterrupt:\n                cleanup_virtualenv(project, bare=False)\n                sys.exit(1)\n    # Ensure the Pipfile exists.\n    if not deploy:\n        ensure_pipfile(project, system=system)\n    if not requirements_dir:\n        requirements_dir = vistir.path.create_tracked_tempdir(\n            suffix=\"-requirements\", prefix=\"pipenv-\"\n        )\n    # Write out the lockfile if it doesn't exist, but not if the Pipfile is being ignored\n    if (project.lockfile_exists and not ignore_pipfile) and not skip_lock:\n        old_hash = project.get_lockfile_hash()\n        new_hash = project.calculate_pipfile_hash()\n        if new_hash != old_hash:\n            if deploy:\n                click.echo(\n                    crayons.red(\n                        \"Your Pipfile.lock ({}) is out of date. Expected: ({}).\".format(\n                            old_hash[-6:], new_hash[-6:]\n                        )\n                    )\n                )\n                raise exceptions.DeployException\n                sys.exit(1)\n            elif (system or allow_global) and not (project.s.PIPENV_VIRTUALENV):\n                click.echo(\n                    crayons.yellow(fix_utf8(\n                        \"Pipfile.lock ({}) out of date, but installation \"\n                        \"uses {} re-building lockfile must happen in \"\n                        \"isolation. Please rebuild lockfile in a virtualenv. \"\n                        \"Continuing anyway...\".format(\n                            old_hash[-6:], \"--system\"\n                        ))\n                    ),\n                    err=True,\n                )\n            else:\n                if old_hash:\n                    msg = fix_utf8(\"Pipfile.lock ({0}) out of date, updating to ({1})...\")\n                else:\n                    msg = fix_utf8(\"Pipfile.lock is corrupted, replaced with ({1})...\")\n                click.echo(\n                    crayons.yellow(msg.format(old_hash[-6:], new_hash[-6:]), bold=True),\n                    err=True,\n                )\n                do_lock(\n                    project,\n                    system=system,\n                    pre=pre,\n                    keep_outdated=keep_outdated,\n                    write=True,\n                    pypi_mirror=pypi_mirror,\n                )\n    # Write out the lockfile if it doesn't exist.\n    if not project.lockfile_exists and not skip_lock:\n        # Unless we're in a virtualenv not managed by pipenv, abort if we're\n        # using the system's python.\n        if (system or allow_global) and not (project.s.PIPENV_VIRTUALENV):\n            raise exceptions.PipenvOptionsError(\n                \"--system\",\n                \"--system is intended to be used for Pipfile installation, \"\n                \"not installation of specific packages. Aborting.\\n\"\n                \"See also: --deploy flag.\"\n            )\n        else:\n            click.echo(\n                crayons.normal(fix_utf8(\"Pipfile.lock not found, creating...\"), bold=True),\n                err=True,\n            )\n            do_lock(\n                project,\n                system=system,\n                pre=pre,\n                keep_outdated=keep_outdated,\n                write=True,\n                pypi_mirror=pypi_mirror,\n            )\n    do_install_dependencies(\n        project,\n        dev=dev,\n        dev_only=dev_only,\n        emit_requirements=emit_requirements,\n        allow_global=allow_global,\n        skip_lock=skip_lock,\n        concurrent=concurrent,\n        requirements_dir=requirements_dir,\n        pypi_mirror=pypi_mirror,\n    )\n\n    # Hint the user what to do to activate the virtualenv.\n    if not allow_global and not deploy and \"PIPENV_ACTIVE\" not in os.environ:\n        click.echo(\n            \"To activate this project's virtualenv, run {}.\\n\"\n            \"Alternatively, run a command \"\n            \"inside the virtualenv with {}.\".format(\n                crayons.yellow(\"pipenv shell\"), crayons.yellow(\"pipenv run\")\n            )\n        )\n\n\ndef get_pip_args(\n    project,\n    pre=False,  # type: bool\n    verbose=False,  # type: bool\n    upgrade=False,  # type: bool\n    require_hashes=False,  # type: bool\n    no_build_isolation=False,  # type: bool\n    no_use_pep517=False,  # type: bool\n    no_deps=False,  # type: bool\n    selective_upgrade=False,  # type: bool\n    src_dir=None,  # type: Optional[str]\n):\n    # type: (...) -> List[str]\n    from .vendor.packaging.version import parse as parse_version\n    arg_map = {\n        \"pre\": [\"--pre\"],\n        \"verbose\": [\"--verbose\"],\n        \"upgrade\": [\"--upgrade\"],\n        \"require_hashes\": [\"--require-hashes\"],\n        \"no_build_isolation\": [\"--no-build-isolation\"],\n        \"no_use_pep517\": [],\n        \"no_deps\": [\"--no-deps\"],\n        \"selective_upgrade\": [\n            \"--upgrade-strategy=only-if-needed\",\n            \"--exists-action={}\".format(project.s.PIP_EXISTS_ACTION or \"i\")\n        ],\n        \"src_dir\": src_dir,\n    }\n    if project.environment.pip_version >= parse_version(\"19.0\"):\n        arg_map[\"no_use_pep517\"].append(\"--no-use-pep517\")\n    if project.environment.pip_version < parse_version(\"19.1\"):\n        arg_map[\"no_use_pep517\"].append(\"--no-build-isolation\")\n    arg_set = []\n    for key in arg_map.keys():\n        if key in locals() and locals().get(key):\n            arg_set.extend(arg_map.get(key))\n        elif key == \"selective_upgrade\" and not locals().get(key):\n            arg_set.append(\"--exists-action=i\")\n    return list(vistir.misc.dedup(arg_set))\n\n\ndef get_requirement_line(\n    requirement,  # type: Requirement\n    src_dir=None,  # type: Optional[str]\n    include_hashes=True,  # type: bool\n    format_for_file=False,  # type: bool\n):\n    # type: (...) -> Union[List[str], str]\n    line = None\n    if requirement.vcs or requirement.is_file_or_url:\n        if src_dir and requirement.line_instance.wheel_kwargs:\n            requirement.line_instance._wheel_kwargs.update({\n                \"src_dir\": src_dir\n            })\n        requirement.line_instance.vcsrepo\n        line = requirement.line_instance.line\n        if requirement.line_instance.markers:\n            line = f'{line}; {requirement.line_instance.markers}'\n            if not format_for_file:\n                line = f'\"{line}\"'\n        if requirement.editable:\n            if not format_for_file:\n                return [\"-e\", line]\n            return f'-e {line}'\n        if not format_for_file:\n            return [line]\n        return line\n    return requirement.as_line(include_hashes=include_hashes, as_list=not format_for_file)\n\n\ndef write_requirement_to_file(\n    project,  # type: Project\n    requirement,  # type: Requirement\n    requirements_dir=None,  # type: Optional[str]\n    src_dir=None,  # type: Optional[str]\n    include_hashes=True  # type: bool\n):\n    # type: (...) -> str\n    if not requirements_dir:\n        requirements_dir = vistir.path.create_tracked_tempdir(\n            prefix=\"pipenv\", suffix=\"requirements\")\n    line = requirement.line_instance.get_line(\n        with_prefix=True, with_hashes=include_hashes, with_markers=True, as_list=False\n    )\n\n    f = vistir.compat.NamedTemporaryFile(\n        prefix=\"pipenv-\", suffix=\"-requirement.txt\", dir=requirements_dir,\n        delete=False\n    )\n    if project.s.is_verbose():\n        click.echo(\n            f\"Writing supplied requirement line to temporary file: {line!r}\",\n            err=True\n        )\n    f.write(vistir.misc.to_bytes(line))\n    r = f.name\n    f.close()\n    return r\n\n\ndef pip_install(\n    project,\n    requirement=None,\n    r=None,\n    allow_global=False,\n    ignore_hashes=False,\n    no_deps=None,\n    block=True,\n    index=None,\n    pre=False,\n    selective_upgrade=False,\n    requirements_dir=None,\n    extra_indexes=None,\n    pypi_mirror=None,\n    trusted_hosts=None,\n    use_pep517=True\n):\n    piplogger = logging.getLogger(\"pipenv.patched.notpip._internal.commands.install\")\n    src_dir = None\n    if not trusted_hosts:\n        trusted_hosts = []\n\n    trusted_hosts.extend(os.environ.get(\"PIP_TRUSTED_HOSTS\", []))\n    if not allow_global:\n        src_dir = os.getenv(\"PIP_SRC\", os.getenv(\"PIP_SRC_DIR\", project.virtualenv_src_location))\n    else:\n        src_dir = os.getenv(\"PIP_SRC\", os.getenv(\"PIP_SRC_DIR\"))\n    if requirement:\n        if requirement.editable or not requirement.hashes:\n            ignore_hashes = True\n        elif not (requirement.is_vcs or requirement.editable or requirement.vcs):\n            ignore_hashes = False\n    line = None\n    # Try installing for each source in project.sources.\n    if not index and requirement.index:\n        index = requirement.index\n    if index and not extra_indexes:\n        extra_indexes = list(project.sources)\n    if requirement and requirement.vcs or requirement.editable:\n        requirement.index = None\n        # Install dependencies when a package is a non-editable VCS dependency.\n        # Don't specify a source directory when using --system.\n        if not requirement.editable and no_deps is not True:\n            # Leave this off becauase old lockfiles don't have all deps included\n            # TODO: When can it be turned back on?\n            no_deps = False\n        elif requirement.editable and no_deps is None:\n            no_deps = True\n\n    r = write_requirement_to_file(\n        project, requirement, requirements_dir=requirements_dir, src_dir=src_dir,\n        include_hashes=not ignore_hashes\n    )\n    sources = get_source_list(\n        project, index, extra_indexes=extra_indexes, trusted_hosts=trusted_hosts,\n        pypi_mirror=pypi_mirror\n    )\n    if r:\n        with open(r, \"r\") as fh:\n            if \"--hash\" not in fh.read():\n                ignore_hashes = True\n    if project.s.is_verbose():\n        piplogger.setLevel(logging.WARN)\n        if requirement:\n            click.echo(\n                crayons.normal(f\"Installing {requirement.name!r}\", bold=True),\n                err=True,\n            )\n\n    pip_command = [project._which(\"python\", allow_global=allow_global), \"-m\", \"pip\", \"install\"]\n    pip_args = get_pip_args(\n        project, pre=pre, verbose=project.s.is_verbose(), upgrade=True,\n        selective_upgrade=selective_upgrade, no_use_pep517=not use_pep517,\n        no_deps=no_deps, require_hashes=not ignore_hashes,\n    )\n    pip_command.extend(pip_args)\n    if r:\n        pip_command.extend([\"-r\", vistir.path.normalize_path(r)])\n    elif line:\n        pip_command.extend(line)\n    pip_command.extend(prepare_pip_source_args(sources))\n    if project.s.is_verbose():\n        click.echo(f\"$ {cmd_list_to_shell(pip_command)}\", err=True)\n    cache_dir = Path(project.s.PIPENV_CACHE_DIR)\n    DEFAULT_EXISTS_ACTION = \"w\"\n    if selective_upgrade:\n        DEFAULT_EXISTS_ACTION = \"i\"\n    exists_action = vistir.misc.fs_str(project.s.PIP_EXISTS_ACTION or DEFAULT_EXISTS_ACTION)\n    pip_config = {\n        \"PIP_CACHE_DIR\": vistir.misc.fs_str(cache_dir.as_posix()),\n        \"PIP_WHEEL_DIR\": vistir.misc.fs_str(cache_dir.joinpath(\"wheels\").as_posix()),\n        \"PIP_DESTINATION_DIR\": vistir.misc.fs_str(\n            cache_dir.joinpath(\"pkgs\").as_posix()\n        ),\n        \"PIP_EXISTS_ACTION\": exists_action,\n        \"PATH\": vistir.misc.fs_str(os.environ.get(\"PATH\")),\n    }\n    if src_dir:\n        if project.s.is_verbose():\n            click.echo(f\"Using source directory: {src_dir!r}\", err=True)\n        pip_config.update(\n            {\"PIP_SRC\": vistir.misc.fs_str(src_dir)}\n        )\n    c = subprocess_run(pip_command, block=block, env=pip_config)\n    c.env = pip_config\n    return c\n\n\ndef pip_download(project, package_name):\n    cache_dir = Path(project.s.PIPENV_CACHE_DIR)\n    pip_config = {\n        \"PIP_CACHE_DIR\": vistir.misc.fs_str(cache_dir.as_posix()),\n        \"PIP_WHEEL_DIR\": vistir.misc.fs_str(cache_dir.joinpath(\"wheels\").as_posix()),\n        \"PIP_DESTINATION_DIR\": vistir.misc.fs_str(\n            cache_dir.joinpath(\"pkgs\").as_posix()\n        ),\n    }\n    for source in project.sources:\n        cmd = [\n            which_pip(project),\n            \"download\",\n            package_name,\n            \"-i\", source[\"url\"],\n            \"-d\", project.download_location,\n        ]\n        c = subprocess_run(cmd, env=pip_config)\n        if c.returncode == 0:\n            break\n\n    return c\n\n\ndef fallback_which(command, location=None, allow_global=False, system=False):\n    \"\"\"\n    A fallback implementation of the `which` utility command that relies exclusively on\n    searching the path for commands.\n\n    :param str command: The command to search for, optional\n    :param str location: The search location to prioritize (prepend to path), defaults to None\n    :param bool allow_global: Whether to search the global path, defaults to False\n    :param bool system: Whether to use the system python instead of pipenv's python, defaults to False\n    :raises ValueError: Raised if no command is provided\n    :raises TypeError: Raised if the command provided is not a string\n    :return: A path to the discovered command location\n    :rtype: str\n    \"\"\"\n\n    from .vendor.pythonfinder import Finder\n    if not command:\n        raise ValueError(\"fallback_which: Must provide a command to search for...\")\n    if not isinstance(command, str):\n        raise TypeError(f\"Provided command must be a string, received {command!r}\")\n    global_search = system or allow_global\n    if location is None:\n        global_search = True\n    finder = Finder(system=False, global_search=global_search, path=location)\n    if is_python_command(command):\n        result = find_python(finder, command)\n        if result:\n            return result\n    result = finder.which(command)\n    if result:\n        return result.path.as_posix()\n    return \"\"\n\n\ndef which_pip(project, allow_global=False):\n    \"\"\"Returns the location of virtualenv-installed pip.\"\"\"\n\n    location = None\n    if \"VIRTUAL_ENV\" in os.environ:\n        location = os.environ[\"VIRTUAL_ENV\"]\n    if allow_global:\n        if location:\n            pip = project._which(\"pip\", location=location)\n            if pip:\n                return pip\n\n        for p in (\"pip\", \"pip3\", \"pip2\"):\n            where = system_which(p)\n            if where:\n                return where\n\n    pip = project._which(\"pip\")\n    if not pip:\n        pip = fallback_which(\"pip\", allow_global=allow_global, location=location)\n    return pip\n\n\ndef system_which(command, path=None):\n    \"\"\"Emulates the system's which. Returns None if not found.\"\"\"\n    import shutil\n\n    result = shutil.which(command, path=path)\n    if result is None:\n        _which = \"where\" if os.name == \"nt\" else \"which -a\"\n        env = {'PATH': path} if path else None\n        c = subprocess_run(f\"{_which} {command}\", shell=True, env=env)\n        if c.returncode == 127:\n            click.echo(\n                \"{}: the {} system utility is required for Pipenv to find Python installations properly.\"\n                \"\\n  Please install it.\".format(\n                    crayons.red(\"Warning\", bold=True), crayons.yellow(_which)\n                ),\n                err=True,\n            )\n        if c.returncode == 0:\n            result = next(iter(c.stdout.splitlines()), None)\n    return result\n\n\ndef format_help(help):\n    \"\"\"Formats the help string.\"\"\"\n    help = help.replace(\"Options:\", str(crayons.normal(\"Options:\", bold=True)))\n    help = help.replace(\n        \"Usage: pipenv\", str(\"Usage: {}\".format(crayons.normal(\"pipenv\", bold=True)))\n    )\n    help = help.replace(\"  check\", str(crayons.red(\"  check\", bold=True)))\n    help = help.replace(\"  clean\", str(crayons.red(\"  clean\", bold=True)))\n    help = help.replace(\"  graph\", str(crayons.red(\"  graph\", bold=True)))\n    help = help.replace(\"  install\", str(crayons.magenta(\"  install\", bold=True)))\n    help = help.replace(\"  lock\", str(crayons.green(\"  lock\", bold=True)))\n    help = help.replace(\"  open\", str(crayons.red(\"  open\", bold=True)))\n    help = help.replace(\"  run\", str(crayons.yellow(\"  run\", bold=True)))\n    help = help.replace(\"  shell\", str(crayons.yellow(\"  shell\", bold=True)))\n    help = help.replace(\"  scripts\", str(crayons.yellow(\"  scripts\", bold=True)))\n    help = help.replace(\"  sync\", str(crayons.green(\"  sync\", bold=True)))\n    help = help.replace(\"  uninstall\", str(crayons.magenta(\"  uninstall\", bold=True)))\n    help = help.replace(\"  update\", str(crayons.green(\"  update\", bold=True)))\n    additional_help = \"\"\"\nUsage Examples:\n   Create a new project using Python 3.7, specifically:\n   $ {}\n\n   Remove project virtualenv (inferred from current directory):\n   $ {}\n\n   Install all dependencies for a project (including dev):\n   $ {}\n\n   Create a lockfile containing pre-releases:\n   $ {}\n\n   Show a graph of your installed dependencies:\n   $ {}\n\n   Check your installed dependencies for security vulnerabilities:\n   $ {}\n\n   Install a local setup.py into your virtual environment/Pipfile:\n   $ {}\n\n   Use a lower-level pip command:\n   $ {}\n\nCommands:\"\"\".format(\n        crayons.yellow(\"pipenv --python 3.7\"),\n        crayons.yellow(\"pipenv --rm\"),\n        crayons.yellow(\"pipenv install --dev\"),\n        crayons.yellow(\"pipenv lock --pre\"),\n        crayons.yellow(\"pipenv graph\"),\n        crayons.yellow(\"pipenv check\"),\n        crayons.yellow(\"pipenv install -e .\"),\n        crayons.yellow(\"pipenv run pip freeze\"),\n    )\n    help = help.replace(\"Commands:\", additional_help)\n    return help\n\n\ndef format_pip_error(error):\n    error = error.replace(\"Expected\", str(crayons.green(\"Expected\", bold=True)))\n    error = error.replace(\"Got\", str(crayons.red(\"Got\", bold=True)))\n    error = error.replace(\n        \"THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS FILE\",\n        str(\n            crayons.red(\n                \"THESE PACKAGES DO NOT MATCH THE HASHES FROM Pipfile.lock!\", bold=True\n            )\n        ),\n    )\n    error = error.replace(\n        \"someone may have tampered with them\",\n        str(crayons.red(\"someone may have tampered with them\")),\n    )\n    error = error.replace(\"option to pip install\", \"option to 'pipenv install'\")\n    return error\n\n\ndef format_pip_output(out, r=None):\n    def gen(out):\n        for line in out.split(\"\\n\"):\n            # Remove requirements file information from pip9 output.\n            if \"(from -r\" in line:\n                yield line[: line.index(\"(from -r\")]\n\n            else:\n                yield line\n\n    out = \"\\n\".join([line for line in gen(out)])\n    return out\n\n\ndef warn_in_virtualenv(project):\n    # Only warn if pipenv isn't already active.\n    if environments.is_in_virtualenv() and not project.s.is_quiet():\n        click.echo(\n            \"{}: Pipenv found itself running within a virtual environment, \"\n            \"so it will automatically use that environment, instead of \"\n            \"creating its own for any project. You can set \"\n            \"{} to force pipenv to ignore that environment and create \"\n            \"its own instead. You can set {} to suppress this \"\n            \"warning.\".format(\n                crayons.green(\"Courtesy Notice\"),\n                crayons.normal(\"PIPENV_IGNORE_VIRTUALENVS=1\", bold=True),\n                crayons.normal(\"PIPENV_VERBOSITY=-1\", bold=True),\n            ),\n            err=True,\n        )\n\n\ndef ensure_lockfile(project, keep_outdated=False, pypi_mirror=None):\n    \"\"\"Ensures that the lockfile is up-to-date.\"\"\"\n    if not keep_outdated:\n        keep_outdated = project.settings.get(\"keep_outdated\")\n    # Write out the lockfile if it doesn't exist, but not if the Pipfile is being ignored\n    if project.lockfile_exists:\n        old_hash = project.get_lockfile_hash()\n        new_hash = project.calculate_pipfile_hash()\n        if new_hash != old_hash:\n            click.echo(\n                crayons.yellow(\n                    fix_utf8(\"Pipfile.lock ({}) out of date, updating to ({})...\".format(\n                        old_hash[-6:], new_hash[-6:]\n                    )),\n                    bold=True,\n                ),\n                err=True,\n            )\n            do_lock(project, keep_outdated=keep_outdated, pypi_mirror=pypi_mirror)\n    else:\n        do_lock(project, keep_outdated=keep_outdated, pypi_mirror=pypi_mirror)\n\n\ndef do_py(project, ctx=None, system=False):\n    if not project.virtualenv_exists:\n        click.echo(\n            \"{}({}){}\".format(\n                crayons.red(\"No virtualenv has been created for this project \"),\n                crayons.yellow(project.project_directory, bold=True),\n                crayons.red(\" yet!\")\n            ),\n            err=True,\n        )\n        ctx.abort()\n\n    try:\n        click.echo(project._which(\"python\", allow_global=system))\n    except AttributeError:\n        click.echo(crayons.red(\"No project found!\"))\n\n\ndef do_outdated(project, pypi_mirror=None, pre=False, clear=False):\n    # TODO: Allow --skip-lock here?\n    from collections import namedtuple\n\n    from .vendor.packaging.utils import canonicalize_name\n    from .vendor.requirementslib.models.requirements import Requirement\n    from .vendor.requirementslib.models.utils import get_version\n    from .vendor.vistir.compat import Mapping\n\n    packages = {}\n    package_info = namedtuple(\"PackageInfo\", [\"name\", \"installed\", \"available\"])\n\n    installed_packages = project.environment.get_installed_packages()\n    outdated_packages = {\n        canonicalize_name(pkg.project_name): package_info\n        (pkg.project_name, pkg.parsed_version, pkg.latest_version)\n        for pkg in project.environment.get_outdated_packages()\n    }\n    reverse_deps = {\n        canonicalize_name(name): deps\n        for name, deps in project.environment.reverse_dependencies().items()\n    }\n    for result in installed_packages:\n        dep = Requirement.from_line(str(result.as_requirement()))\n        packages.update(dep.as_pipfile())\n    updated_packages = {}\n    lockfile = do_lock(project, clear=clear, pre=pre, write=False, pypi_mirror=pypi_mirror)\n    for section in (\"develop\", \"default\"):\n        for package in lockfile[section]:\n            try:\n                updated_packages[package] = lockfile[section][package][\"version\"]\n            except KeyError:\n                pass\n    outdated = []\n    skipped = []\n    for package in packages:\n        norm_name = pep423_name(package)\n        if norm_name in updated_packages:\n            if updated_packages[norm_name] != packages[package]:\n                outdated.append(\n                    package_info(package, updated_packages[norm_name], packages[package])\n                )\n            elif canonicalize_name(package) in outdated_packages:\n                skipped.append(outdated_packages[canonicalize_name(package)])\n    for package, old_version, new_version in skipped:\n        name_in_pipfile = project.get_package_name_in_pipfile(package)\n        pipfile_version_text = \"\"\n        required = \"\"\n        version = None\n        if name_in_pipfile:\n            version = get_version(project.packages[name_in_pipfile])\n            rdeps = reverse_deps.get(canonicalize_name(package))\n            if isinstance(rdeps, Mapping) and \"required\" in rdeps:\n                required = \" {} required\".format(rdeps[\"required\"])\n            if version:\n                pipfile_version_text = f\" ({version} set in Pipfile)\"\n            else:\n                pipfile_version_text = \" (Unpinned in Pipfile)\"\n        click.echo(\n            crayons.yellow(\n                \"Skipped Update of Package {!s}: {!s} installed,{!s}{!s}, \"\n                \"{!s} available.\".format(\n                    package, old_version, required, pipfile_version_text, new_version\n                )\n            ), err=True\n        )\n    if not outdated:\n        click.echo(crayons.green(\"All packages are up to date!\", bold=True))\n        sys.exit(0)\n    for package, new_version, old_version in outdated:\n        click.echo(\n            \"Package {!r} out-of-date: {!r} installed, {!r} available.\".format(\n                package, old_version, new_version\n            )\n        )\n    sys.exit(bool(outdated))\n\n\ndef do_install(\n    project,\n    packages=False,\n    editable_packages=False,\n    index_url=False,\n    extra_index_url=False,\n    dev=False,\n    three=False,\n    python=False,\n    pypi_mirror=None,\n    system=False,\n    lock=True,\n    ignore_pipfile=False,\n    skip_lock=False,\n    requirementstxt=False,\n    sequential=False,\n    pre=False,\n    code=False,\n    deploy=False,\n    keep_outdated=False,\n    selective_upgrade=False,\n    site_packages=None,\n):\n    from .vendor.pip_shims.shims import PipError\n\n    requirements_directory = vistir.path.create_tracked_tempdir(\n        suffix=\"-requirements\", prefix=\"pipenv-\"\n    )\n    warnings.filterwarnings(\"default\", category=vistir.compat.ResourceWarning)\n    if selective_upgrade:\n        keep_outdated = True\n    packages = packages if packages else []\n    editable_packages = editable_packages if editable_packages else []\n    package_args = [p for p in packages if p] + [p for p in editable_packages if p]\n    skip_requirements = False\n    # Don't search for requirements.txt files if the user provides one\n    if requirementstxt or package_args or project.pipfile_exists:\n        skip_requirements = True\n    concurrent = not sequential\n    # Ensure that virtualenv is available and pipfile are available\n    ensure_project(\n        project,\n        three=three,\n        python=python,\n        system=system,\n        warn=True,\n        deploy=deploy,\n        skip_requirements=skip_requirements,\n        pypi_mirror=pypi_mirror,\n        site_packages=site_packages,\n    )\n    # Don't attempt to install develop and default packages if Pipfile is missing\n    if not project.pipfile_exists and not (package_args or dev) and not code:\n        if not (ignore_pipfile or deploy):\n            raise exceptions.PipfileNotFound(project.path_to(\"Pipfile\"))\n        elif ((skip_lock and deploy) or ignore_pipfile) and not project.lockfile_exists:\n            raise exceptions.LockfileNotFound(project.path_to(\"Pipfile.lock\"))\n    # Load the --pre settings from the Pipfile.\n    if not pre:\n        pre = project.settings.get(\"allow_prereleases\")\n    if not keep_outdated:\n        keep_outdated = project.settings.get(\"keep_outdated\")\n    remote = requirementstxt and is_valid_url(requirementstxt)\n    # Warn and exit if --system is used without a pipfile.\n    if (system and package_args) and not project.s.PIPENV_VIRTUALENV:\n        raise exceptions.SystemUsageError\n    # Automatically use an activated virtualenv.\n    if project.s.PIPENV_USE_SYSTEM:\n        system = True\n    if system:\n        project.s.PIPENV_USE_SYSTEM = True\n        os.environ[\"PIPENV_USE_SYSTEM\"] = \"1\"\n    # Check if the file is remote or not\n    if remote:\n        click.echo(\n            crayons.normal(\n                fix_utf8(\"Remote requirements file provided! Downloading...\"), bold=True\n            ),\n            err=True,\n        )\n        fd = vistir.path.create_tracked_tempfile(\n            prefix=\"pipenv-\", suffix=\"-requirement.txt\", dir=requirements_directory\n        )\n        temp_reqs = fd.name\n        requirements_url = requirementstxt\n        # Download requirements file\n        try:\n            download_file(requirements_url, temp_reqs, project.s.PIPENV_MAX_RETRIES)\n        except OSError:\n            fd.close()\n            os.unlink(temp_reqs)\n            click.echo(\n                crayons.red(\n                    \"Unable to find requirements file at {}.\".format(\n                        crayons.normal(requirements_url)\n                    )\n                ),\n                err=True,\n            )\n            sys.exit(1)\n        finally:\n            fd.close()\n        # Replace the url with the temporary requirements file\n        requirementstxt = temp_reqs\n        remote = True\n    if requirementstxt:\n        error, traceback = None, None\n        click.echo(\n            crayons.normal(\n                fix_utf8(\"Requirements file provided! Importing into Pipfile...\"), bold=True\n            ),\n            err=True,\n        )\n        try:\n            import_requirements(project, r=project.path_to(requirementstxt), dev=dev)\n        except (UnicodeDecodeError, PipError) as e:\n            # Don't print the temp file path if remote since it will be deleted.\n            req_path = requirements_url if remote else project.path_to(requirementstxt)\n            error = (\n                \"Unexpected syntax in {}. Are you sure this is a \"\n                \"requirements.txt style file?\".format(req_path)\n            )\n            traceback = e\n        except AssertionError as e:\n            error = (\n                \"Requirements file doesn't appear to exist. Please ensure the file exists in your \"\n                \"project directory or you provided the correct path.\"\n            )\n            traceback = e\n        finally:\n            # If requirements file was provided by remote url delete the temporary file\n            if remote:\n                fd.close()  # Close for windows to allow file cleanup.\n                os.remove(temp_reqs)\n            if error and traceback:\n                click.echo(crayons.red(error))\n                click.echo(crayons.yellow(str(traceback)), err=True)\n                sys.exit(1)\n    if code:\n        click.echo(\n            crayons.normal(fix_utf8(\"Discovering imports from local codebase...\"), bold=True)\n        )\n        for req in import_from_code(code):\n            click.echo(f\"  Found {crayons.green(req)}!\")\n            project.add_package_to_pipfile(req)\n    # Allow more than one package to be provided.\n    package_args = [p for p in packages] + [\n        f\"-e {pkg}\" for pkg in editable_packages\n    ]\n    # Support for --selective-upgrade.\n    # We should do this part first to make sure that we actually do selectively upgrade\n    # the items specified\n    if selective_upgrade:\n        from .vendor.requirementslib.models.requirements import Requirement\n\n        for i, package in enumerate(package_args[:]):\n            section = project.packages if not dev else project.dev_packages\n            package = Requirement.from_line(package)\n            package__name, package__val = package.pipfile_entry\n            try:\n                if not is_star(section[package__name]) and is_star(package__val):\n                    # Support for VCS dependencies.\n                    package_args[i] = convert_deps_to_pip(\n                        {package__name: section[package__name]}, project=project, r=False\n                    )[0]\n            except KeyError:\n                pass\n    # Install all dependencies, if none was provided.\n    # This basically ensures that we have a pipfile and lockfile, then it locks and\n    # installs from the lockfile\n    if not packages and not editable_packages:\n        # Update project settings with pre preference.\n        if pre:\n            project.update_settings({\"allow_prereleases\": pre})\n        do_init(\n            project,\n            dev=dev,\n            allow_global=system,\n            ignore_pipfile=ignore_pipfile,\n            system=system,\n            skip_lock=skip_lock,\n            concurrent=concurrent,\n            deploy=deploy,\n            pre=pre,\n            requirements_dir=requirements_directory,\n            pypi_mirror=pypi_mirror,\n            keep_outdated=keep_outdated\n        )\n\n    # This is for if the user passed in dependencies, then we want to make sure we\n    else:\n        from .vendor.requirementslib.models.requirements import Requirement\n\n        # make a tuple of (display_name, entry)\n        pkg_list = packages + [f'-e {pkg}' for pkg in editable_packages]\n        if not system and not project.virtualenv_exists:\n            do_init(\n                project,\n                dev=dev,\n                system=system,\n                allow_global=system,\n                concurrent=concurrent,\n                keep_outdated=keep_outdated,\n                requirements_dir=requirements_directory,\n                deploy=deploy,\n                pypi_mirror=pypi_mirror,\n                skip_lock=skip_lock,\n            )\n        pip_shims_module = os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n        for pkg_line in pkg_list:\n            click.echo(\n                crayons.normal(\n                    fix_utf8(f\"Installing {crayons.green(pkg_line, bold=True)}...\"),\n                    bold=True,\n                )\n            )\n            # pip install:\n            with vistir.contextmanagers.temp_environ(), create_spinner(\"Installing...\", project.s) as sp:\n                if not system:\n                    os.environ[\"PIP_USER\"] = vistir.compat.fs_str(\"0\")\n                    if \"PYTHONHOME\" in os.environ:\n                        del os.environ[\"PYTHONHOME\"]\n                sp.text = f\"Resolving {pkg_line}...\"\n                try:\n                    pkg_requirement = Requirement.from_line(pkg_line)\n                except ValueError as e:\n                    sp.write_err(vistir.compat.fs_str(\"{}: {}\".format(crayons.red(\"WARNING\"), e)))\n                    sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Installation Failed\"))\n                    sys.exit(1)\n                no_deps = False\n                sp.text = \"Installing...\"\n                try:\n                    sp.text = f\"Installing {pkg_requirement.name}...\"\n                    if project.s.is_verbose():\n                        sp.hide_and_write(f\"Installing package: {pkg_requirement.as_line(include_hashes=False)}\")\n                    c = pip_install(\n                        project,\n                        pkg_requirement,\n                        ignore_hashes=True,\n                        allow_global=system,\n                        selective_upgrade=selective_upgrade,\n                        no_deps=no_deps,\n                        pre=pre,\n                        requirements_dir=requirements_directory,\n                        index=index_url,\n                        extra_indexes=extra_index_url,\n                        pypi_mirror=pypi_mirror,\n                    )\n                    if c.returncode:\n                        sp.write_err(\n                            \"{} An error occurred while installing {}!\".format(\n                                crayons.red(\"Error: \", bold=True), crayons.green(pkg_line)\n                            ),\n                        )\n                        sp.write_err(\n                            vistir.compat.fs_str(f\"Error text: {c.stdout}\")\n                        )\n                        sp.write_err(crayons.cyan(vistir.compat.fs_str(format_pip_error(c.stderr))))\n                        if project.s.is_verbose():\n                            sp.write_err(crayons.cyan(vistir.compat.fs_str(format_pip_output(c.stdout))))\n                        if \"setup.py egg_info\" in c.stderr:\n                            sp.write_err(vistir.compat.fs_str(\n                                \"This is likely caused by a bug in {}. \"\n                                \"Report this to its maintainers.\".format(\n                                    crayons.green(pkg_requirement.name)\n                                )\n                            ))\n                        sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Installation Failed\"))\n                        sys.exit(1)\n                except (ValueError, RuntimeError) as e:\n                    sp.write_err(vistir.compat.fs_str(\n                        \"{}: {}\".format(crayons.red(\"WARNING\"), e),\n                    ))\n                    sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\n                        \"Installation Failed\",\n                    ))\n                    sys.exit(1)\n                # Warn if --editable wasn't passed.\n                if pkg_requirement.is_vcs and not pkg_requirement.editable and not project.s.PIPENV_RESOLVE_VCS:\n                    sp.write_err(\n                        \"{}: You installed a VCS dependency in non-editable mode. \"\n                        \"This will work fine, but sub-dependencies will not be resolved by {}.\"\n                        \"\\n  To enable this sub-dependency functionality, specify that this dependency is editable.\"\n                        \"\".format(\n                            crayons.red(\"Warning\", bold=True),\n                            crayons.yellow(\"$ pipenv lock\"),\n                        )\n                    )\n                sp.write(vistir.compat.fs_str(\n                    \"{} {} {} {}{}\".format(\n                        crayons.normal(\"Adding\", bold=True),\n                        crayons.green(f\"{pkg_requirement.name}\", bold=True),\n                        crayons.normal(\"to Pipfile's\", bold=True),\n                        crayons.yellow(\"[dev-packages]\" if dev else \"[packages]\", bold=True),\n                        crayons.normal(fix_utf8(\"...\"), bold=True),\n                    )\n                ))\n                # Add the package to the Pipfile.\n                indexes = list(filter(None, [index_url, *extra_index_url]))\n                for index in indexes:\n                    index_name = project.add_index_to_pipfile(\n                        index, verify_ssl=index.startswith(\"https:\")\n                    )\n                    if index_url and not extra_index_url:\n                        pkg_requirement.index = index_name\n                try:\n                    project.add_package_to_pipfile(pkg_requirement, dev)\n                except ValueError:\n                    import traceback\n                    sp.write_err(\n                        \"{} {}\".format(\n                            crayons.red(\"Error:\", bold=True), traceback.format_exc()\n                        )\n                    )\n                    sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\n                        \"Failed adding package to Pipfile\"\n                    ))\n                sp.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Installation Succeeded\"))\n            # Update project settings with pre preference.\n            if pre:\n                project.update_settings({\"allow_prereleases\": pre})\n        if pip_shims_module:\n            os.environ[\"PIP_SHIMS_BASE_MODULE\"] = pip_shims_module\n        do_init(\n            project,\n            dev=dev,\n            system=system,\n            allow_global=system,\n            concurrent=concurrent,\n            keep_outdated=keep_outdated,\n            requirements_dir=requirements_directory,\n            deploy=deploy,\n            pypi_mirror=pypi_mirror,\n            skip_lock=skip_lock,\n        )\n    sys.exit(0)\n\n\ndef do_uninstall(\n    project,\n    packages=False,\n    editable_packages=False,\n    three=None,\n    python=False,\n    system=False,\n    lock=False,\n    all_dev=False,\n    all=False,\n    keep_outdated=False,\n    pypi_mirror=None,\n    ctx=None\n):\n    from .vendor.packaging.utils import canonicalize_name\n    from .vendor.requirementslib.models.requirements import Requirement\n\n    # Automatically use an activated virtualenv.\n    if project.s.PIPENV_USE_SYSTEM:\n        system = True\n    # Ensure that virtualenv is available.\n    # TODO: We probably shouldn't ensure a project exists if the outcome will be to just\n    # install things in order to remove them... maybe tell the user to install first?\n    ensure_project(project, three=three, python=python, pypi_mirror=pypi_mirror)\n    # Un-install all dependencies, if --all was provided.\n    if not any([packages, editable_packages, all_dev, all]):\n        raise exceptions.PipenvUsageError(\"No package provided!\", ctx=ctx)\n    editable_pkgs = [\n        Requirement.from_line(f\"-e {p}\").name for p in editable_packages if p\n    ]\n    packages += editable_pkgs\n    package_names = {p for p in packages if p}\n    package_map = {\n        canonicalize_name(p): p for p in packages if p\n    }\n    installed_package_names = project.installed_package_names\n    # Intelligently detect if --dev should be used or not.\n    lockfile_packages = set()\n    if project.lockfile_exists:\n        project_pkg_names = project.lockfile_package_names\n    else:\n        project_pkg_names = project.pipfile_package_names\n    pipfile_remove = True\n    # Uninstall [dev-packages], if --dev was provided.\n    if all_dev:\n        if \"dev-packages\" not in project.parsed_pipfile and not project_pkg_names[\"dev\"]:\n            click.echo(\n                crayons.normal(\n                    \"No {} to uninstall.\".format(crayons.yellow(\"[dev-packages]\")),\n                    bold=True,\n                )\n            )\n            return\n        click.echo(\n            crayons.normal(\n                fix_utf8(\"Un-installing {}...\".format(crayons.yellow(\"[dev-packages]\"))), bold=True\n            )\n        )\n        package_names = set(project_pkg_names[\"dev\"]) - set(project_pkg_names[\"default\"])\n\n    # Remove known \"bad packages\" from the list.\n    bad_pkgs = get_canonical_names(BAD_PACKAGES)\n    ignored_packages = bad_pkgs & set(list(package_map.keys()))\n    for ignored_pkg in ignored_packages:\n        if project.s.is_verbose():\n            click.echo(f\"Ignoring {ignored_pkg}.\", err=True)\n        package_names.discard(package_map[ignored_pkg])\n\n    used_packages = project_pkg_names[\"combined\"] & installed_package_names\n    failure = False\n    if all:\n        click.echo(\n            crayons.normal(\n                fix_utf8(\"Un-installing all {} and {}...\".format(\n                    crayons.yellow(\"[dev-packages]\"),\n                    crayons.yellow(\"[packages]\"),\n                )), bold=True\n            )\n        )\n        do_purge(project, bare=False, allow_global=system)\n        sys.exit(0)\n\n    selected_pkg_map = {\n        canonicalize_name(p): p for p in package_names\n    }\n    packages_to_remove = [\n        p for normalized, p in selected_pkg_map.items()\n        if normalized in (used_packages - bad_pkgs)\n    ]\n    pip_path = None\n    for normalized, package_name in selected_pkg_map.items():\n        click.echo(\n            crayons.normal(\n                fix_utf8(f\"Uninstalling {crayons.green(package_name)}...\"), bold=True\n            )\n        )\n        # Uninstall the package.\n        if package_name in packages_to_remove:\n            with project.environment.activated():\n                if pip_path is None:\n                    pip_path = which_pip(project, allow_global=system)\n                cmd = [pip_path, \"uninstall\", package_name, \"-y\"]\n                c = run_command(cmd, is_verbose=project.s.is_verbose())\n                click.echo(crayons.cyan(c.stdout))\n                if c.returncode != 0:\n                    failure = True\n        if not failure and pipfile_remove:\n            in_packages = project.get_package_name_in_pipfile(package_name, dev=False)\n            in_dev_packages = project.get_package_name_in_pipfile(\n                package_name, dev=True\n            )\n            if normalized in lockfile_packages:\n                click.echo(\"{} {} {} {}\".format(\n                    crayons.cyan(\"Removing\"),\n                    crayons.green(package_name),\n                    crayons.cyan(\"from\"),\n                    crayons.white(fix_utf8(\"Pipfile.lock...\")))\n                )\n                lockfile = project.get_or_create_lockfile()\n                if normalized in lockfile.default:\n                    del lockfile.default[normalized]\n                if normalized in lockfile.develop:\n                    del lockfile.develop[normalized]\n                lockfile.write()\n            if not (in_dev_packages or in_packages):\n                if normalized in lockfile_packages:\n                    continue\n                click.echo(\n                    \"No package {} to remove from Pipfile.\".format(\n                        crayons.green(package_name)\n                    )\n                )\n                continue\n\n            click.echo(\n                fix_utf8(f\"Removing {crayons.green(package_name)} from Pipfile...\")\n            )\n            # Remove package from both packages and dev-packages.\n            if in_dev_packages:\n                project.remove_package_from_pipfile(package_name, dev=True)\n            if in_packages:\n                project.remove_package_from_pipfile(package_name, dev=False)\n    if lock:\n        do_lock(project, system=system, keep_outdated=keep_outdated, pypi_mirror=pypi_mirror)\n    sys.exit(int(failure))\n\n\ndef do_shell(project, three=None, python=False, fancy=False, shell_args=None, pypi_mirror=None):\n    # Ensure that virtualenv is available.\n    ensure_project(\n        project, three=three, python=python, validate=False, pypi_mirror=pypi_mirror,\n    )\n\n    # Support shell compatibility mode.\n    if project.s.PIPENV_SHELL_FANCY:\n        fancy = True\n\n    from .shells import choose_shell\n\n    shell = choose_shell(project)\n    click.echo(fix_utf8(\"Launching subshell in virtual environment...\"), err=True)\n\n    fork_args = (\n        project.virtualenv_location,\n        project.project_directory,\n        shell_args,\n    )\n\n    # Set an environment variable, so we know we're in the environment.\n    # Only set PIPENV_ACTIVE after finishing reading virtualenv_location\n    # otherwise its value will be changed\n    os.environ[\"PIPENV_ACTIVE\"] = vistir.misc.fs_str(\"1\")\n\n    os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n\n    if fancy:\n        shell.fork(*fork_args)\n        return\n\n    try:\n        shell.fork_compat(*fork_args)\n    except (AttributeError, ImportError):\n        click.echo(fix_utf8(\n            \"Compatibility mode not supported. \"\n            \"Trying to continue as well-configured shell...\"),\n            err=True,\n        )\n        shell.fork(*fork_args)\n\n\ndef _inline_activate_virtualenv(project):\n    try:\n        activate_this = project._which(\"activate_this.py\")\n        if not activate_this or not os.path.exists(activate_this):\n            raise exceptions.VirtualenvActivationException()\n        with open(activate_this) as f:\n            code = compile(f.read(), activate_this, \"exec\")\n            exec(code, dict(__file__=activate_this))\n    # Catch all errors, just in case.\n    except Exception:\n        click.echo(\n            \"{}: There was an unexpected error while activating your \"\n            \"virtualenv. Continuing anyway...\".format(\n                crayons.red(\"Warning\", bold=True)\n            ),\n            err=True,\n        )\n\n\ndef _inline_activate_venv(project):\n    \"\"\"Built-in venv doesn't have activate_this.py, but doesn't need it anyway.\n\n    As long as we find the correct executable, built-in venv sets up the\n    environment automatically.\n\n    See: https://bugs.python.org/issue21496#msg218455\n    \"\"\"\n    components = []\n    for name in (\"bin\", \"Scripts\"):\n        bindir = os.path.join(project.virtualenv_location, name)\n        if os.path.exists(bindir):\n            components.append(bindir)\n    if \"PATH\" in os.environ:\n        components.append(os.environ[\"PATH\"])\n    os.environ[\"PATH\"] = os.pathsep.join(components)\n\n\ndef inline_activate_virtual_environment(project):\n    root = project.virtualenv_location\n    if os.path.exists(os.path.join(root, \"pyvenv.cfg\")):\n        _inline_activate_venv(project)\n    else:\n        _inline_activate_virtualenv(project)\n    if \"VIRTUAL_ENV\" not in os.environ:\n        os.environ[\"VIRTUAL_ENV\"] = vistir.misc.fs_str(root)\n\n\ndef _launch_windows_subprocess(script, env):\n    import subprocess\n\n    path = env.get(\"PATH\", \"\")\n    command = system_which(script.command, path=path)\n\n    options = {\"universal_newlines\": True, \"env\": env}\n    script.cmd_args[1:] = [expandvars(arg) for arg in script.args]\n\n    # Command not found, maybe this is a shell built-in?\n    if not command:\n        return subprocess.Popen(script.cmdify(), shell=True, **options)\n\n    # Try to use CreateProcess directly if possible. Specifically catch\n    # Windows error 193 \"Command is not a valid Win32 application\" to handle\n    # a \"command\" that is non-executable. See pypa/pipenv#2727.\n    try:\n        return subprocess.Popen([command] + script.args, **options)\n    except OSError as e:\n        if e.winerror != 193:\n            raise\n\n    # Try shell mode to use Windows's file association for file launch.\n    return subprocess.Popen(script.cmdify(), shell=True, **options)\n\n\ndef do_run_nt(project, script, env):\n    p = _launch_windows_subprocess(script, env)\n    p.communicate()\n    sys.exit(p.returncode)\n\n\ndef do_run_posix(project, script, command, env):\n    path = env.get(\"PATH\")\n    command_path = system_which(script.command, path=path)\n    if not command_path:\n        if project.has_script(command):\n            click.echo(\n                \"{}: the command {} (from {}) could not be found within {}.\"\n                \"\".format(\n                    crayons.red(\"Error\", bold=True),\n                    crayons.yellow(script.command),\n                    crayons.normal(command, bold=True),\n                    crayons.normal(\"PATH\", bold=True),\n                ),\n                err=True,\n            )\n        else:\n            click.echo(\n                \"{}: the command {} could not be found within {} or Pipfile's {}.\"\n                \"\".format(\n                    crayons.red(\"Error\", bold=True),\n                    crayons.yellow(command),\n                    crayons.normal(\"PATH\", bold=True),\n                    crayons.normal(\"[scripts]\", bold=True),\n                ),\n                err=True,\n            )\n        sys.exit(1)\n    os.execve(\n        command_path,\n        [command_path, *(os.path.expandvars(arg) for arg in script.args)],\n        env\n    )\n\n\ndef do_run(project, command, args, three=None, python=False, pypi_mirror=None):\n    \"\"\"Attempt to run command either pulling from project or interpreting as executable.\n\n    Args are appended to the command in [scripts] section of project if found.\n    \"\"\"\n    from .cmdparse import ScriptEmptyError\n\n    # Ensure that virtualenv is available.\n    ensure_project(\n        project, three=three, python=python, validate=False, pypi_mirror=pypi_mirror,\n    )\n\n    env = os.environ.copy()\n    env.update(load_dot_env(project, as_dict=True) or {})\n    env.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n\n    path = env.get('PATH', '')\n    if project.virtualenv_location:\n        new_path = os.path.join(project.virtualenv_location, 'Scripts' if os.name == 'nt' else 'bin')\n        paths = path.split(os.pathsep)\n        paths.insert(0, new_path)\n        path = os.pathsep.join(paths)\n        env[\"VIRTUAL_ENV\"] = project.virtualenv_location\n    env[\"PATH\"] = path\n\n    # Set an environment variable, so we know we're in the environment.\n    # Only set PIPENV_ACTIVE after finishing reading virtualenv_location\n    # such as in inline_activate_virtual_environment\n    # otherwise its value will be changed\n    env[\"PIPENV_ACTIVE\"] = vistir.misc.fs_str(\"1\")\n    env.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n\n    try:\n        script = project.build_script(command, args)\n        cmd_string = cmd_list_to_shell([script.command] + script.args)\n        if project.s.is_verbose():\n            click.echo(crayons.normal(f\"$ {cmd_string}\"), err=True)\n    except ScriptEmptyError:\n        click.echo(\"Can't run script {0!r}-it's empty?\", err=True)\n    run_args = [project, script]\n    run_kwargs = {'env': env}\n    # We're using `do_run_nt` on CI (even if we're running on a non-nt machine)\n    # as a workaround for https://github.com/pypa/pipenv/issues/4909.\n    if os.name == \"nt\" or environments.PIPENV_IS_CI:\n        run_fn = do_run_nt\n    else:\n        run_fn = do_run_posix\n        run_kwargs.update({\"command\": command})\n    run_fn(*run_args, **run_kwargs)\n\n\ndef do_check(\n    project,\n    three=None,\n    python=False,\n    system=False,\n    unused=False,\n    db=None,\n    ignore=None,\n    output=\"default\",\n    key=None,\n    quiet=False,\n    args=None,\n    pypi_mirror=None\n):\n    from pipenv.vendor.first import first\n    from pipenv.vendor.vistir.compat import JSONDecodeError\n\n    if not system:\n        # Ensure that virtualenv is available.\n        ensure_project(\n            project,\n            three=three,\n            python=python,\n            validate=False,\n            warn=False,\n            pypi_mirror=pypi_mirror,\n        )\n    if not args:\n        args = []\n    if unused:\n        deps_required = [k.lower() for k in project.packages.keys()]\n        deps_needed = [k.lower() for k in import_from_code(unused)]\n        for dep in deps_needed:\n            try:\n                deps_required.remove(dep)\n            except ValueError:\n                pass\n        if deps_required:\n            if not quiet and not project.s.is_quiet():\n                click.echo(\n                    crayons.normal(\n                        \"The following dependencies appear unused, and may be safe for removal:\"\n                    )\n                )\n                for dep in deps_required:\n                    click.echo(f\"  - {crayons.green(dep)}\")\n                sys.exit(1)\n        else:\n            sys.exit(0)\n    if not quiet and not project.s.is_quiet():\n        click.echo(crayons.normal(decode_for_output(\"Checking PEP 508 requirements...\"), bold=True))\n    pep508checker_path = pep508checker.__file__.rstrip(\"cdo\")\n    safety_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"patched\", \"safety\"\n    )\n    if not system:\n        python = project._which(\"python\")\n    else:\n        python = first(system_which(p) for p in (\"python\", \"python3\", \"python2\"))\n    if not python:\n        click.echo(crayons.red(\"The Python interpreter can't be found.\"), err=True)\n        sys.exit(1)\n    _cmd = [Path(python).as_posix()]\n    # Run the PEP 508 checker in the virtualenv.\n    cmd = _cmd + [Path(pep508checker_path).as_posix()]\n    c = run_command(cmd, is_verbose=project.s.is_verbose())\n    if c.returncode is not None:\n        try:\n            results = simplejson.loads(c.stdout.strip())\n        except JSONDecodeError:\n            click.echo(\"{}\\n{}\\n{}\".format(\n                crayons.white(decode_for_output(\"Failed parsing pep508 results: \"), bold=True),\n                c.stdout.strip(),\n                c.stderr.strip()\n            ))\n            sys.exit(1)\n    # Load the pipfile.\n    p = pipfile.Pipfile.load(project.pipfile_location)\n    failed = False\n    # Assert each specified requirement.\n    for marker, specifier in p.data[\"_meta\"][\"requires\"].items():\n        if marker in results:\n            try:\n                assert results[marker] == specifier\n            except AssertionError:\n                failed = True\n                click.echo(\n                    \"Specifier {} does not match {} ({}).\"\n                    \"\".format(\n                        crayons.green(marker),\n                        crayons.cyan(specifier),\n                        crayons.yellow(results[marker]),\n                    ),\n                    err=True,\n                )\n    if failed:\n        click.echo(crayons.red(\"Failed!\"), err=True)\n        sys.exit(1)\n    else:\n        if not quiet and not project.s.is_quiet():\n            click.echo(crayons.green(\"Passed!\"))\n    if not quiet and not project.s.is_quiet():\n        click.echo(crayons.normal(\n            decode_for_output(\"Checking installed package safety...\"), bold=True)\n        )\n    if ignore:\n        if not isinstance(ignore, (tuple, list)):\n            ignore = [ignore]\n        ignored = [[\"--ignore\", cve] for cve in ignore]\n        if not quiet and not project.s.is_quiet():\n            click.echo(\n                crayons.normal(\n                    \"Notice: Ignoring CVE(s) {}\".format(crayons.yellow(\", \".join(ignore)))\n                ),\n                err=True,\n            )\n    else:\n        ignored = []\n\n    switch = output\n    if output == \"default\":\n        switch = \"json\"\n\n    cmd = _cmd + [safety_path, \"check\", f\"--{switch}\"]\n    if db:\n        if not quiet and not project.s.is_quiet():\n            click.echo(crayons.normal(f\"Using local database {db}\"))\n        cmd.append(f\"--db={db}\")\n    elif key or project.s.PIPENV_PYUP_API_KEY:\n        cmd = cmd + [f\"--key={key or project.s.PIPENV_PYUP_API_KEY}\"]\n    if ignored:\n        for cve in ignored:\n            cmd += cve\n    c = run_command(cmd, catch_exceptions=False, is_verbose=project.s.is_verbose())\n    if output == \"default\":\n        try:\n            results = simplejson.loads(c.stdout)\n        except (ValueError, JSONDecodeError):\n            raise exceptions.JSONParseError(c.stdout, c.stderr)\n        except Exception:\n            raise exceptions.PipenvCmdError(cmd_list_to_shell(c.args), c.stdout, c.stderr, c.returncode)\n        for (package, resolved, installed, description, vuln, *_) in results:\n            click.echo(\n                \"{}: {} {} resolved ({} installed)!\".format(\n                    crayons.normal(vuln, bold=True),\n                    crayons.green(package),\n                    crayons.yellow(resolved, bold=False),\n                    crayons.yellow(installed, bold=True),\n                )\n            )\n            click.echo(f\"{description}\")\n            click.echo()\n        if c.returncode == 0:\n            click.echo(crayons.green(\"All good!\"))\n            sys.exit(0)\n        else:\n            sys.exit(1)\n    else:\n        click.echo(c.stdout)\n        sys.exit(c.returncode)\n\n\ndef do_graph(project, bare=False, json=False, json_tree=False, reverse=False):\n    from pipenv.vendor import pipdeptree\n    from pipenv.vendor.vistir.compat import JSONDecodeError\n    pipdeptree_path = pipdeptree.__file__.rstrip(\"cdo\")\n    try:\n        python_path = project._which(\"python\")\n    except AttributeError:\n        click.echo(\n            \"{}: {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                \"Unable to display currently-installed dependency graph information here. \"\n                \"Please run within a Pipenv project.\",\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    except RuntimeError:\n        pass\n    else:\n        if not os.name == 'nt':    # bugfix #4388\n            python_path = Path(python_path).as_posix()\n            pipdeptree_path = Path(pipdeptree_path).as_posix()\n\n    if reverse and json:\n        click.echo(\n            \"{}: {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                \"Using both --reverse and --json together is not supported. \"\n                \"Please select one of the two options.\",\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    if reverse and json_tree:\n        click.echo(\n            \"{}: {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                \"Using both --reverse and --json-tree together is not supported. \"\n                \"Please select one of the two options.\",\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    if json and json_tree:\n        click.echo(\n            \"{}: {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                \"Using both --json and --json-tree together is not supported. \"\n                \"Please select one of the two options.\",\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    flag = \"\"\n    if json:\n        flag = \"--json\"\n    if json_tree:\n        flag = \"--json-tree\"\n    if reverse:\n        flag = \"--reverse\"\n    if not project.virtualenv_exists:\n        click.echo(\n            \"{}: No virtualenv has been created for this project yet! Consider \"\n            \"running {} first to automatically generate one for you or see \"\n            \"{} for further instructions.\".format(\n                crayons.red(\"Warning\", bold=True),\n                crayons.green(\"`pipenv install`\"),\n                crayons.green(\"`pipenv install --help`\"),\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    cmd_args = [python_path, pipdeptree_path, \"-l\"]\n    if flag:\n        cmd_args.append(flag)\n    c = run_command(cmd_args, is_verbose=project.s.is_verbose())\n    # Run dep-tree.\n    if not bare:\n        if json:\n            data = []\n            try:\n                parsed = simplejson.loads(c.stdout.strip())\n            except JSONDecodeError:\n                raise exceptions.JSONParseError(c.stdout, c.stderr)\n            else:\n                for d in parsed:\n                    if d[\"package\"][\"key\"] not in BAD_PACKAGES:\n                        data.append(d)\n            click.echo(simplejson.dumps(data, indent=4))\n            sys.exit(0)\n        elif json_tree:\n\n            def traverse(obj):\n                if isinstance(obj, list):\n                    return [\n                        traverse(package)\n                        for package in obj\n                        if package[\"key\"] not in BAD_PACKAGES\n                    ]\n                else:\n                    obj[\"dependencies\"] = traverse(obj[\"dependencies\"])\n                    return obj\n\n            try:\n                parsed = simplejson.loads(c.stdout.strip())\n            except JSONDecodeError:\n                raise exceptions.JSONParseError(c.stdout, c.stderr)\n            else:\n                data = traverse(parsed)\n                click.echo(simplejson.dumps(data, indent=4))\n                sys.exit(0)\n        else:\n            for line in c.stdout.strip().split(\"\\n\"):\n                # Ignore bad packages as top level.\n                # TODO: This should probably be a \"==\" in + line.partition\n                if line.split(\"==\")[0] in BAD_PACKAGES and not reverse:\n                    continue\n\n                # Bold top-level packages.\n                if not line.startswith(\" \"):\n                    click.echo(crayons.normal(line, bold=True))\n                # Echo the rest.\n                else:\n                    click.echo(crayons.normal(line, bold=False))\n    else:\n        click.echo(c.stdout)\n    if c.returncode != 0:\n        click.echo(\n            \"{} {}\".format(\n                crayons.red(\"ERROR: \", bold=True),\n                crayons.white(f\"{c.stderr}\"),\n            ),\n            err=True,\n        )\n    # Return its return code.\n    sys.exit(c.returncode)\n\n\ndef do_sync(\n    project,\n    dev=False,\n    three=None,\n    python=None,\n    bare=False,\n    dont_upgrade=False,\n    user=False,\n    clear=False,\n    unused=False,\n    sequential=False,\n    pypi_mirror=None,\n    system=False,\n    deploy=False,\n):\n    # The lock file needs to exist because sync won't write to it.\n    if not project.lockfile_exists:\n        raise exceptions.LockfileNotFound(\"Pipfile.lock\")\n\n    # Ensure that virtualenv is available if not system.\n    ensure_project(\n        project,\n        three=three,\n        python=python,\n        validate=False,\n        system=system,\n        deploy=deploy,\n        pypi_mirror=pypi_mirror,\n        clear=clear,\n    )\n\n    # Install everything.\n    requirements_dir = vistir.path.create_tracked_tempdir(\n        suffix=\"-requirements\", prefix=\"pipenv-\"\n    )\n    if system:\n        project.s.PIPENV_USE_SYSTEM = True\n        os.environ[\"PIPENV_USE_SYSTEM\"] = \"1\"\n    do_init(\n        project,\n        dev=dev,\n        allow_global=system,\n        concurrent=(not sequential),\n        requirements_dir=requirements_dir,\n        ignore_pipfile=True,  # Don't check if Pipfile and lock match.\n        pypi_mirror=pypi_mirror,\n        deploy=deploy,\n        system=system,\n    )\n    if not bare:\n        click.echo(crayons.green(\"All dependencies are now up-to-date!\"))\n\n\ndef do_clean(\n    project, three=None, python=None, dry_run=False, bare=False, pypi_mirror=None,\n    system=False\n):\n    # Ensure that virtualenv is available.\n    from packaging.utils import canonicalize_name\n    ensure_project(project, three=three, python=python, validate=False, pypi_mirror=pypi_mirror)\n    ensure_lockfile(project, pypi_mirror=pypi_mirror)\n    # Make sure that the virtualenv's site packages are configured correctly\n    # otherwise we may end up removing from the global site packages directory\n    installed_package_names = project.installed_package_names.copy()\n    # Remove known \"bad packages\" from the list.\n    for bad_package in BAD_PACKAGES:\n        if canonicalize_name(bad_package) in installed_package_names:\n            if project.s.is_verbose():\n                click.echo(f\"Ignoring {bad_package}.\", err=True)\n            installed_package_names.remove(canonicalize_name(bad_package))\n    # Intelligently detect if --dev should be used or not.\n    locked_packages = {\n        canonicalize_name(pkg) for pkg in project.lockfile_package_names[\"combined\"]\n    }\n    for used_package in locked_packages:\n        if used_package in installed_package_names:\n            installed_package_names.remove(used_package)\n    failure = False\n    cmd = [which_pip(project, allow_global=system), \"uninstall\", \"-y\", \"-qq\"]\n    for apparent_bad_package in installed_package_names:\n        if dry_run and not bare:\n            click.echo(apparent_bad_package)\n        else:\n            if not bare:\n                click.echo(\n                    crayons.white(\n                        fix_utf8(f\"Uninstalling {apparent_bad_package}...\"), bold=True\n                    )\n                )\n            # Uninstall the package.\n            cmd = [which_pip(project), \"uninstall\", apparent_bad_package, \"-y\"]\n            c = run_command(cmd, is_verbose=project.s.is_verbose())\n            if c.returncode != 0:\n                failure = True\n    sys.exit(int(failure))\n", "import contextlib\nimport errno\nimport logging\nimport os\nimport posixpath\nimport re\nimport shlex\nimport hashlib\nimport shutil\nimport signal\nimport stat\nimport subprocess\nimport sys\nimport warnings\n\nfrom contextlib import contextmanager\nfrom distutils.spawn import find_executable\nfrom pathlib import Path\nfrom urllib.parse import urlparse\n\nimport crayons\nimport parse\nimport toml\nimport tomlkit\n\nfrom click import echo as click_echo\n\nfrom pipenv import environments\nfrom pipenv.exceptions import (\n    PipenvCmdError, PipenvUsageError, RequirementError, ResolutionFailure\n)\nfrom pipenv.pep508checker import lookup\nfrom pipenv.vendor.packaging.markers import Marker\nfrom pipenv.vendor.urllib3 import util as urllib3_util\nfrom pipenv.vendor.vistir.compat import (\n    Mapping, ResourceWarning, Sequence, Set, TemporaryDirectory, lru_cache\n)\nfrom pipenv.vendor.vistir.misc import fs_str, run\nfrom pipenv.vendor.vistir.contextmanagers import open_file\n\n\nif environments.MYPY_RUNNING:\n    from typing import Any, Dict, List, Optional, Text, Tuple, Union\n\n    from pipenv.project import Project, TSource\n    from pipenv.vendor.requirementslib.models.pipfile import Pipfile\n    from pipenv.vendor.requirementslib.models.requirements import (\n        Line, Requirement\n    )\n\n\nlogging.basicConfig(level=logging.ERROR)\n\nspecifiers = [k for k in lookup.keys()]\n# List of version control systems we support.\nVCS_LIST = (\"git\", \"svn\", \"hg\", \"bzr\")\nSCHEME_LIST = (\"http://\", \"https://\", \"ftp://\", \"ftps://\", \"file://\")\nrequests_session = None  # type: ignore\n\n\ndef _get_requests_session(max_retries=1):\n    \"\"\"Load requests lazily.\"\"\"\n    global requests_session\n    if requests_session is not None:\n        return requests_session\n    import requests\n\n    requests_session = requests.Session()\n    adapter = requests.adapters.HTTPAdapter(max_retries=max_retries)\n    requests_session.mount(\"https://pypi.org/pypi\", adapter)\n    return requests_session\n\n\ndef cleanup_toml(tml):\n    toml = tml.split(\"\\n\")\n    new_toml = []\n    # Remove all empty lines from TOML.\n    for line in toml:\n        if line.strip():\n            new_toml.append(line)\n    toml = \"\\n\".join(new_toml)\n    new_toml = []\n    # Add newlines between TOML sections.\n    for i, line in enumerate(toml.split(\"\\n\")):\n        # Skip the first line.\n        if line.startswith(\"[\"):\n            if i > 0:\n                # Insert a newline before the heading.\n                new_toml.append(\"\")\n        new_toml.append(line)\n    # adding new line at the end of the TOML file\n    new_toml.append(\"\")\n    toml = \"\\n\".join(new_toml)\n    return toml\n\n\ndef convert_toml_outline_tables(parsed):\n    \"\"\"Converts all outline tables to inline tables.\"\"\"\n    def convert_tomlkit_table(section):\n        if isinstance(section, tomlkit.items.Table):\n            body = section.value._body\n        else:\n            body = section._body\n        for key, value in body:\n            if not key:\n                continue\n            if hasattr(value, \"keys\") and not isinstance(value, tomlkit.items.InlineTable):\n                table = tomlkit.inline_table()\n                table.update(value.value)\n                section[key.key] = table\n\n    def convert_toml_table(section):\n        for package, value in section.items():\n            if hasattr(value, \"keys\") and not isinstance(value, toml.decoder.InlineTableDict):\n                table = toml.TomlDecoder().get_empty_inline_table()\n                table.update(value)\n                section[package] = table\n\n    is_tomlkit_parsed = isinstance(parsed, tomlkit.container.Container)\n    for section in (\"packages\", \"dev-packages\"):\n        table_data = parsed.get(section, {})\n        if not table_data:\n            continue\n        if is_tomlkit_parsed:\n            convert_tomlkit_table(table_data)\n        else:\n            convert_toml_table(table_data)\n\n    return parsed\n\n\ndef run_command(cmd, *args, is_verbose=False, **kwargs):\n    \"\"\"\n    Take an input command and run it, handling exceptions and error codes and returning\n    its stdout and stderr.\n\n    :param cmd: The list of command and arguments.\n    :type cmd: list\n    :returns: A 2-tuple of the output and error from the command\n    :rtype: Tuple[str, str]\n    :raises: exceptions.PipenvCmdError\n    \"\"\"\n\n    from ._compat import decode_for_output\n    from .cmdparse import Script\n    catch_exceptions = kwargs.pop(\"catch_exceptions\", True)\n    if isinstance(cmd, ((str,), list, tuple)):\n        cmd = Script.parse(cmd)\n    if not isinstance(cmd, Script):\n        raise TypeError(\"Command input must be a string, list or tuple\")\n    if \"env\" not in kwargs:\n        kwargs[\"env\"] = os.environ.copy()\n    kwargs[\"env\"][\"PYTHONIOENCODING\"] = \"UTF-8\"\n    command = [cmd.command, *cmd.args]\n    if is_verbose:\n        click_echo(f\"Running command: $ {cmd.cmdify()}\")\n    c = subprocess_run(command, *args, **kwargs)\n    if is_verbose:\n        click_echo(\"Command output: {}\".format(\n            crayons.cyan(decode_for_output(c.stdout))\n        ), err=True)\n    if c.returncode and catch_exceptions:\n        raise PipenvCmdError(cmd.cmdify(), c.stdout, c.stderr, c.returncode)\n    return c\n\n\ndef parse_python_version(output):\n    \"\"\"Parse a Python version output returned by `python --version`.\n\n    Return a dict with three keys: major, minor, and micro. Each value is a\n    string containing a version part.\n\n    Note: The micro part would be `'0'` if it's missing from the input string.\n    \"\"\"\n    version_line = output.split(\"\\n\", 1)[0]\n    version_pattern = re.compile(\n        r\"\"\"\n        ^                   # Beginning of line.\n        Python              # Literally \"Python\".\n        \\s                  # Space.\n        (?P<major>\\d+)      # Major = one or more digits.\n        \\.                  # Dot.\n        (?P<minor>\\d+)      # Minor = one or more digits.\n        (?:                 # Unnamed group for dot-micro.\n            \\.              # Dot.\n            (?P<micro>\\d+)  # Micro = one or more digit.\n        )?                  # Micro is optional because pypa/pipenv#1893.\n        .*                  # Trailing garbage.\n        $                   # End of line.\n    \"\"\",\n        re.VERBOSE,\n    )\n\n    match = version_pattern.match(version_line)\n    if not match:\n        return None\n    return match.groupdict(default=\"0\")\n\n\ndef python_version(path_to_python):\n    from .vendor.pythonfinder.utils import get_python_version\n\n    if not path_to_python:\n        return None\n    try:\n        version = get_python_version(path_to_python)\n    except Exception:\n        return None\n    return version\n\n\ndef escape_grouped_arguments(s):\n    \"\"\"Prepares a string for the shell (on Windows too!)\n\n    Only for use on grouped arguments (passed as a string to Popen)\n    \"\"\"\n    if s is None:\n        return None\n\n    # Additional escaping for windows paths\n    if os.name == \"nt\":\n        s = \"{}\".format(s.replace(\"\\\\\", \"\\\\\\\\\"))\n    return '\"' + s.replace(\"'\", \"'\\\\''\") + '\"'\n\n\ndef clean_pkg_version(version):\n    \"\"\"Uses pip to prepare a package version string, from our internal version.\"\"\"\n    return pep440_version(str(version).replace(\"==\", \"\"))\n\n\nclass HackedPythonVersion:\n    \"\"\"A Beautiful hack, which allows us to tell pip which version of Python we're using.\"\"\"\n\n    def __init__(self, python_version, python_path):\n        self.python_version = python_version\n        self.python_path = python_path\n\n    def __enter__(self):\n        # Only inject when the value is valid\n        if self.python_version:\n            os.environ[\"PIPENV_REQUESTED_PYTHON_VERSION\"] = str(self.python_version)\n        if self.python_path:\n            os.environ[\"PIP_PYTHON_PATH\"] = str(self.python_path)\n\n    def __exit__(self, *args):\n        # Restore original Python version information.\n        try:\n            del os.environ[\"PIPENV_REQUESTED_PYTHON_VERSION\"]\n        except KeyError:\n            pass\n\n\ndef prepare_pip_source_args(sources, pip_args=None):\n    if pip_args is None:\n        pip_args = []\n    if sources:\n        # Add the source to notpip.\n        package_url = sources[0].get(\"url\")\n        if not package_url:\n            raise PipenvUsageError(\"[[source]] section does not contain a URL.\")\n        pip_args.extend([\"-i\", package_url])\n        # Trust the host if it's not verified.\n        if not sources[0].get(\"verify_ssl\", True):\n            url_parts = urllib3_util.parse_url(package_url)\n            url_port = f\":{url_parts.port}\" if url_parts.port else \"\"\n            pip_args.extend(\n                [\"--trusted-host\", f\"{url_parts.host}{url_port}\"]\n            )\n        # Add additional sources as extra indexes.\n        if len(sources) > 1:\n            for source in sources[1:]:\n                url = source.get(\"url\")\n                if not url:  # not harmless, just don't continue\n                    continue\n                pip_args.extend([\"--extra-index-url\", url])\n                # Trust the host if it's not verified.\n                if not source.get(\"verify_ssl\", True):\n                    url_parts = urllib3_util.parse_url(url)\n                    url_port = f\":{url_parts.port}\" if url_parts.port else \"\"\n                    pip_args.extend(\n                        [\"--trusted-host\", f\"{url_parts.host}{url_port}\"]\n                    )\n    return pip_args\n\n\ndef get_project_index(project, index=None, trusted_hosts=None):\n    # type: (Optional[Union[str, TSource]], Optional[List[str]], Optional[Project]) -> TSource\n    from .project import SourceNotFound\n    if trusted_hosts is None:\n        trusted_hosts = []\n    if isinstance(index, Mapping):\n        return project.find_source(index.get(\"url\"))\n    try:\n        source = project.find_source(index)\n    except SourceNotFound:\n        index_url = urllib3_util.parse_url(index)\n        src_name = project.src_name_from_url(index)\n        verify_ssl = index_url.host not in trusted_hosts\n        source = {\"url\": index, \"verify_ssl\": verify_ssl, \"name\": src_name}\n    return source\n\n\ndef get_source_list(\n    project,  # type: Project\n    index=None,  # type: Optional[Union[str, TSource]]\n    extra_indexes=None,  # type: Optional[List[str]]\n    trusted_hosts=None,  # type: Optional[List[str]]\n    pypi_mirror=None,  # type: Optional[str]\n):\n    # type: (...) -> List[TSource]\n    sources = []  # type: List[TSource]\n    if index:\n        sources.append(get_project_index(project, index))\n    if extra_indexes:\n        if isinstance(extra_indexes, str):\n            extra_indexes = [extra_indexes]\n        for source in extra_indexes:\n            extra_src = get_project_index(project, source)\n            if not sources or extra_src[\"url\"] != sources[0][\"url\"]:\n                sources.append(extra_src)\n        else:\n            for source in project.pipfile_sources:\n                if not sources or source[\"url\"] != sources[0][\"url\"]:\n                    sources.append(source)\n    if not sources:\n        sources = project.pipfile_sources[:]\n    if pypi_mirror:\n        sources = [\n            create_mirror_source(pypi_mirror) if is_pypi_url(source[\"url\"]) else source\n            for source in sources\n        ]\n    return sources\n\n\ndef get_indexes_from_requirement(req, project, index=None, extra_indexes=None, trusted_hosts=None, pypi_mirror=None):\n    # type: (Requirement, Project, Optional[Text], Optional[List[Text]], Optional[List[Text]], Optional[Text]) -> Tuple[TSource, List[TSource], List[Text]]\n    index_sources = []  # type: List[TSource]\n    if not trusted_hosts:\n        trusted_hosts = []  # type: List[Text]\n    if extra_indexes is None:\n        extra_indexes = []\n    project_indexes = project.pipfile_sources[:]\n    indexes = []\n    if req.index:\n        indexes.append(req.index)\n    if getattr(req, \"extra_indexes\", None):\n        if not isinstance(req.extra_indexes, list):\n            indexes.append(req.extra_indexes)\n        else:\n            indexes.extend(req.extra_indexes)\n    indexes.extend(project_indexes)\n    if len(indexes) > 1:\n        index, extra_indexes = indexes[0], indexes[1:]\n    index_sources = get_source_list(project, index=index, extra_indexes=extra_indexes, trusted_hosts=trusted_hosts, pypi_mirror=pypi_mirror)\n    if len(index_sources) > 1:\n        index_source, extra_index_sources = index_sources[0], index_sources[1:]\n    else:\n        index_source, extra_index_sources = index_sources[0], []\n    return index_source, extra_index_sources\n\n\n@lru_cache()\ndef get_pipenv_sitedir():\n    # type: () -> Optional[str]\n    import pkg_resources\n    site_dir = next(\n        iter(d for d in pkg_resources.working_set if d.key.lower() == \"pipenv\"), None\n    )\n    if site_dir is not None:\n        return site_dir.location\n    return None\n\n\nclass HashCacheMixin:\n\n    \"\"\"Caches hashes of PyPI artifacts so we do not need to re-download them.\n\n    Hashes are only cached when the URL appears to contain a hash in it and the\n    cache key includes the hash value returned from the server). This ought to\n    avoid issues where the location on the server changes.\n    \"\"\"\n    def __init__(self, directory, session):\n        self.session = session\n        if not os.path.isdir(directory):\n            os.makedirs(directory, exist_ok=True)\n        super().__init__(directory=directory)\n\n    def get_hash(self, link):\n        # If there is no link hash (i.e., md5, sha256, etc.), we don't want\n        # to store it.\n        hash_value = self.get(link.url)\n        if not hash_value:\n            hash_value = self._get_file_hash(link).encode()\n            self.set(link.url, hash_value)\n        return hash_value.decode(\"utf8\")\n\n    def _get_file_hash(self, link):\n        from pipenv.vendor.pip_shims import shims\n\n        h = hashlib.new(shims.FAVORITE_HASH)\n        with open_file(link.url, self.session) as fp:\n            for chunk in iter(lambda: fp.read(8096), b\"\"):\n                h.update(chunk)\n        return \":\".join([h.name, h.hexdigest()])\n\n\nclass Resolver:\n    def __init__(\n        self, constraints, req_dir, project, sources, index_lookup=None,\n        markers_lookup=None, skipped=None, clear=False, pre=False\n    ):\n        self.initial_constraints = constraints\n        self.req_dir = req_dir\n        self.project = project\n        self.sources = sources\n        self.resolved_tree = set()\n        self.hashes = {}\n        self.clear = clear\n        self.pre = pre\n        self.results = None\n        self.markers_lookup = markers_lookup if markers_lookup is not None else {}\n        self.index_lookup = index_lookup if index_lookup is not None else {}\n        self.skipped = skipped if skipped is not None else {}\n        self.markers = {}\n        self.requires_python_markers = {}\n        self._pip_args = None\n        self._constraints = None\n        self._parsed_constraints = None\n        self._resolver = None\n        self._finder = None\n        self._ignore_compatibility_finder = None\n        self._session = None\n        self._constraint_file = None\n        self._pip_options = None\n        self._pip_command = None\n        self._retry_attempts = 0\n        self._hash_cache = None\n\n    def __repr__(self):\n        return (\n            \"<Resolver (constraints={self.initial_constraints}, req_dir={self.req_dir}, \"\n            \"sources={self.sources})>\".format(self=self)\n        )\n\n    @staticmethod\n    @lru_cache()\n    def _get_pip_command():\n        from pipenv.vendor.pip_shims import shims\n\n        return shims.InstallCommand()\n\n    @property\n    def hash_cache(self):\n        from pipenv.vendor.pip_shims import shims\n\n        if not self._hash_cache:\n            self._hash_cache = type(\"HashCache\", (HashCacheMixin, shims.SafeFileCache), {})(\n                os.path.join(self.project.s.PIPENV_CACHE_DIR, \"hashes\"), self.session\n            )\n        return self._hash_cache\n\n    @classmethod\n    def get_metadata(\n        cls,\n        deps,  # type: List[str]\n        index_lookup,  # type: Dict[str, str]\n        markers_lookup,  # type: Dict[str, str]\n        project,  # type: Project\n        sources,  # type: Dict[str, str]\n        req_dir=None,  # type: Optional[str]\n        pre=False,  # type: bool\n        clear=False,  # type: bool\n    ):\n        # type: (...) -> Tuple[Set[str], Dict[str, Dict[str, Union[str, bool, List[str]]]], Dict[str, str], Dict[str, str]]\n        constraints = set()  # type: Set[str]\n        skipped = dict()  # type: Dict[str, Dict[str, Union[str, bool, List[str]]]]\n        if index_lookup is None:\n            index_lookup = {}\n        if markers_lookup is None:\n            markers_lookup = {}\n        if not req_dir:\n            from .vendor.vistir.path import create_tracked_tempdir\n            req_dir = create_tracked_tempdir(prefix=\"pipenv-\", suffix=\"-reqdir\")\n        transient_resolver = cls(\n            [], req_dir, project, sources, index_lookup=index_lookup,\n            markers_lookup=markers_lookup, clear=clear, pre=pre\n        )\n        for dep in deps:\n            if not dep:\n                continue\n            req, req_idx, markers_idx = cls.parse_line(\n                dep, index_lookup=index_lookup, markers_lookup=markers_lookup, project=project\n            )\n            index_lookup.update(req_idx)\n            markers_lookup.update(markers_idx)\n            # Add dependencies of any file (e.g. wheels/tarballs), source, or local\n            # directories into the initial constraint pool to be resolved with the\n            # rest of the dependencies, while adding the files/vcs deps/paths themselves\n            # to the lockfile directly\n            constraint_update, lockfile_update = cls.get_deps_from_req(\n                req, resolver=transient_resolver, resolve_vcs=project.s.PIPENV_RESOLVE_VCS\n            )\n            constraints |= constraint_update\n            skipped.update(lockfile_update)\n        return constraints, skipped, index_lookup, markers_lookup\n\n    @classmethod\n    def parse_line(\n        cls,\n        line,  # type: str\n        index_lookup=None,  # type: Dict[str, str]\n        markers_lookup=None,  # type: Dict[str, str]\n        project=None  # type: Optional[Project]\n    ):\n        # type: (...) -> Tuple[Requirement, Dict[str, str], Dict[str, str]]\n        from .vendor.requirementslib.models.requirements import Requirement\n        from .vendor.requirementslib.models.utils import DIRECT_URL_RE\n        if index_lookup is None:\n            index_lookup = {}\n        if markers_lookup is None:\n            markers_lookup = {}\n        if project is None:\n            from .project import Project\n            project = Project()\n        index, extra_index, trust_host, remainder = parse_indexes(line)\n        line = \" \".join(remainder)\n        req = None  # type: Requirement\n        try:\n            req = Requirement.from_line(line)\n        except ValueError:\n            direct_url = DIRECT_URL_RE.match(line)\n            if direct_url:\n                line = \"{}#egg={}\".format(line, direct_url.groupdict()[\"name\"])\n                try:\n                    req = Requirement.from_line(line)\n                except ValueError:\n                    raise ResolutionFailure(f\"Failed to resolve requirement from line: {line!s}\")\n            else:\n                raise ResolutionFailure(f\"Failed to resolve requirement from line: {line!s}\")\n        if index:\n            try:\n                index_lookup[req.normalized_name] = project.get_source(\n                    url=index, refresh=True).get(\"name\")\n            except TypeError:\n                pass\n        try:\n            req.normalized_name\n        except TypeError:\n            raise RequirementError(req=req)\n        # strip the marker and re-add it later after resolution\n        # but we will need a fallback in case resolution fails\n        # eg pypiwin32\n        if req.markers:\n            markers_lookup[req.normalized_name] = req.markers.replace('\"', \"'\")\n        return req, index_lookup, markers_lookup\n\n    @classmethod\n    def get_deps_from_req(cls, req, resolver=None, resolve_vcs=True):\n        # type: (Requirement, Optional[\"Resolver\"], bool) -> Tuple[Set[str], Dict[str, Dict[str, Union[str, bool, List[str]]]]]\n        from .vendor.requirementslib.models.requirements import Requirement\n        from .vendor.requirementslib.models.utils import (\n            _requirement_to_str_lowercase_name\n        )\n        from .vendor.requirementslib.utils import is_installable_dir\n\n        # TODO: this is way too complex, refactor this\n        constraints = set()  # type: Set[str]\n        locked_deps = dict()  # type: Dict[str, Dict[str, Union[str, bool, List[str]]]]\n        if (req.is_file_or_url or req.is_vcs) and not req.is_wheel:\n            # for local packages with setup.py files and potential direct url deps:\n            if req.is_vcs:\n                req_list, lockfile = get_vcs_deps(reqs=[req])\n                req = next(iter(req for req in req_list if req is not None), req_list)\n                entry = lockfile[pep423_name(req.normalized_name)]\n            else:\n                _, entry = req.pipfile_entry\n            parsed_line = req.req.parsed_line  # type: Line\n            setup_info = None  # type: Any\n            try:\n                name = req.normalized_name\n            except TypeError:\n                raise RequirementError(req=req)\n            setup_info = req.req.setup_info\n            setup_info.get_info()\n            locked_deps[pep423_name(name)] = entry\n            requirements = []\n            # Allow users to toggle resolution off for non-editable VCS packages\n            # but leave it on for local, installable folders on the filesystem\n            if resolve_vcs or (\n                req.editable or parsed_line.is_wheel or (\n                    req.is_file_or_url and parsed_line.is_local\n                    and is_installable_dir(parsed_line.path)\n                )\n            ):\n                requirements = [v for v in getattr(setup_info, \"requires\", {}).values()]\n            for r in requirements:\n                if getattr(r, \"url\", None) and not getattr(r, \"editable\", False):\n                    if r is not None:\n                        if not r.url:\n                            continue\n                        line = _requirement_to_str_lowercase_name(r)\n                        new_req, _, _ = cls.parse_line(line)\n                        if r.marker and not r.marker.evaluate():\n                            new_constraints = {}\n                            _, new_entry = req.pipfile_entry\n                            new_lock = {\n                                pep423_name(new_req.normalized_name): new_entry\n                            }\n                        else:\n                            new_constraints, new_lock = cls.get_deps_from_req(\n                                new_req, resolver\n                            )\n                        locked_deps.update(new_lock)\n                        constraints |= new_constraints\n                # if there is no marker or there is a valid marker, add the constraint line\n                elif r and (not r.marker or (r.marker and r.marker.evaluate())):\n                    line = _requirement_to_str_lowercase_name(r)\n                    constraints.add(line)\n            # ensure the top level entry remains as provided\n            # note that we shouldn't pin versions for editable vcs deps\n            if not req.is_vcs:\n                if req.specifiers:\n                    locked_deps[name][\"version\"] = req.specifiers\n                elif parsed_line.setup_info and parsed_line.setup_info.version:\n                    locked_deps[name][\"version\"] = \"=={}\".format(\n                        parsed_line.setup_info.version\n                    )\n            # if not req.is_vcs:\n            locked_deps.update({name: entry})\n        else:\n            # if the dependency isn't installable, don't add it to constraints\n            # and instead add it directly to the lock\n            if req and req.requirement and (\n                req.requirement.marker and not req.requirement.marker.evaluate()\n            ):\n                pypi = resolver.finder if resolver else None\n                ireq = req.ireq\n                best_match = pypi.find_best_candidate(ireq.name, ireq.specifier).best_candidate if pypi else None\n                if best_match:\n                    ireq.req.specifier = ireq.specifier.__class__(f\"=={best_match.version}\")\n                    hashes = resolver.collect_hashes(ireq) if resolver else []\n                    new_req = Requirement.from_ireq(ireq)\n                    new_req = new_req.add_hashes(hashes)\n                    name, entry = new_req.pipfile_entry\n                    locked_deps[pep423_name(name)] = translate_markers(entry)\n                    click_echo(\n                        \"{} doesn't match your environment, \"\n                        \"its dependencies won't be resolved.\".format(req.as_line()),\n                        err=True\n                    )\n                else:\n                    click_echo(\n                        \"Could not find a version of {} that matches your environment, \"\n                        \"it will be skipped.\".format(req.as_line()),\n                        err=True\n                    )\n                return constraints, locked_deps\n            constraints.add(req.constraint_line)\n            return constraints, locked_deps\n        return constraints, locked_deps\n\n    @classmethod\n    def create(\n        cls,\n        deps,  # type: List[str]\n        project,  # type: Project\n        index_lookup=None,  # type: Dict[str, str]\n        markers_lookup=None,  # type: Dict[str, str]\n        sources=None,  # type: List[str]\n        req_dir=None,  # type: str\n        clear=False,  # type: bool\n        pre=False  # type: bool\n    ):\n        # type: (...) -> \"Resolver\"\n        from pipenv.vendor.vistir.path import create_tracked_tempdir\n        if not req_dir:\n            req_dir = create_tracked_tempdir(suffix=\"-requirements\", prefix=\"pipenv-\")\n        if index_lookup is None:\n            index_lookup = {}\n        if markers_lookup is None:\n            markers_lookup = {}\n        if sources is None:\n            sources = project.sources\n        constraints, skipped, index_lookup, markers_lookup = cls.get_metadata(\n            deps, index_lookup, markers_lookup, project, sources, req_dir=req_dir,\n            pre=pre, clear=clear\n        )\n        return Resolver(\n            constraints, req_dir, project, sources, index_lookup=index_lookup,\n            markers_lookup=markers_lookup, skipped=skipped, clear=clear, pre=pre\n        )\n\n    @classmethod\n    def from_pipfile(cls, project, pipfile=None, dev=False, pre=False, clear=False):\n        # type: (Optional[Project], Optional[Pipfile], bool, bool, bool) -> \"Resolver\"\n        from pipenv.vendor.vistir.path import create_tracked_tempdir\n        if not pipfile:\n            pipfile = project._pipfile\n        req_dir = create_tracked_tempdir(suffix=\"-requirements\", prefix=\"pipenv-\")\n        index_lookup, markers_lookup = {}, {}\n        deps = set()\n        if dev:\n            deps.update({req.as_line() for req in pipfile.dev_packages})\n        deps.update({req.as_line() for req in pipfile.packages})\n        constraints, skipped, index_lookup, markers_lookup = cls.get_metadata(\n            list(deps), index_lookup, markers_lookup, project, project.sources,\n            req_dir=req_dir, pre=pre, clear=clear\n        )\n        return Resolver(\n            constraints, req_dir, project, project.sources, index_lookup=index_lookup,\n            markers_lookup=markers_lookup, skipped=skipped, clear=clear, pre=pre\n        )\n\n    @property\n    def pip_command(self):\n        if self._pip_command is None:\n            self._pip_command = self._get_pip_command()\n        return self._pip_command\n\n    def prepare_pip_args(self, use_pep517=None, build_isolation=True):\n        pip_args = []\n        if self.sources:\n            pip_args = prepare_pip_source_args(self.sources, pip_args)\n        if use_pep517 is False:\n            pip_args.append(\"--no-use-pep517\")\n        if build_isolation is False:\n            pip_args.append(\"--no-build-isolation\")\n        if self.pre:\n            pip_args.append(\"--pre\")\n        pip_args.extend([\"--cache-dir\", self.project.s.PIPENV_CACHE_DIR])\n        return pip_args\n\n    @property\n    def pip_args(self):\n        use_pep517 = environments.get_from_env(\"USE_PEP517\", prefix=\"PIP\")\n        build_isolation = environments.get_from_env(\"BUILD_ISOLATION\", prefix=\"PIP\")\n        if self._pip_args is None:\n            self._pip_args = self.prepare_pip_args(\n                use_pep517=use_pep517, build_isolation=build_isolation\n            )\n        return self._pip_args\n\n    def prepare_constraint_file(self):\n        from pipenv.vendor.vistir.path import create_tracked_tempfile\n        constraints_file = create_tracked_tempfile(\n            mode=\"w\",\n            prefix=\"pipenv-\",\n            suffix=\"-constraints.txt\",\n            dir=self.req_dir,\n            delete=False,\n        )\n        skip_args = (\"build-isolation\", \"use-pep517\", \"cache-dir\")\n        args_to_add = [\n            arg for arg in self.pip_args\n            if not any(bad_arg in arg for bad_arg in skip_args)\n        ]\n        if self.sources:\n            requirementstxt_sources = \" \".join(args_to_add) if args_to_add else \"\"\n            requirementstxt_sources = requirementstxt_sources.replace(\" --\", \"\\n--\")\n            constraints_file.write(f\"{requirementstxt_sources}\\n\")\n        constraints = self.initial_constraints\n        constraints_file.write(\"\\n\".join([c for c in constraints]))\n        constraints_file.close()\n        return constraints_file.name\n\n    @property\n    def constraint_file(self):\n        if self._constraint_file is None:\n            self._constraint_file = self.prepare_constraint_file()\n        return self._constraint_file\n\n    @property\n    def pip_options(self):\n        if self._pip_options is None:\n            pip_options, _ = self.pip_command.parser.parse_args(self.pip_args)\n            pip_options.cache_dir = self.project.s.PIPENV_CACHE_DIR\n            pip_options.no_python_version_warning = True\n            pip_options.no_input = True\n            pip_options.progress_bar = \"off\"\n            pip_options.ignore_requires_python = True\n            pip_options.pre = self.pre or self.project.settings.get(\"allow_prereleases\", False)\n            self._pip_options = pip_options\n        return self._pip_options\n\n    @property\n    def session(self):\n        if self._session is None:\n            self._session = self.pip_command._build_session(self.pip_options)\n        return self._session\n\n    @property\n    def finder(self):\n        from pipenv.vendor.pip_shims import shims\n        if self._finder is None:\n            self._finder = shims.get_package_finder(\n                install_cmd=self.pip_command,\n                options=self.pip_options,\n                session=self.session\n            )\n        return self._finder\n\n    @property\n    def ignore_compatibility_finder(self):\n        from pipenv.vendor.pip_shims import shims\n        if self._ignore_compatibility_finder is None:\n            ignore_compatibility_finder = shims.get_package_finder(\n                install_cmd=self.pip_command,\n                options=self.pip_options,\n                session=self.session,\n            )\n            # It would be nice if `shims.get_package_finder` took an\n            # `ignore_compatibility` parameter, but that's some vendorered code\n            # we'd rather avoid touching.\n            ignore_compatibility_finder._ignore_compatibility = True\n            self._ignore_compatibility_finder = ignore_compatibility_finder\n        return self._ignore_compatibility_finder\n\n    @property\n    def parsed_constraints(self):\n        from pipenv.vendor.pip_shims import shims\n\n        if self._parsed_constraints is None:\n            self._parsed_constraints = shims.parse_requirements(\n                self.constraint_file, finder=self.finder, session=self.session,\n                options=self.pip_options\n            )\n        return self._parsed_constraints\n\n    @property\n    def constraints(self):\n        from pipenv.patched.notpip._internal.req.constructors import install_req_from_parsed_requirement\n\n        if self._constraints is None:\n            self._constraints = [\n                install_req_from_parsed_requirement(\n                    c, isolated=self.pip_options.build_isolation,\n                    use_pep517=self.pip_options.use_pep517, user_supplied=True\n                )\n                for c in self.parsed_constraints\n            ]\n        return self._constraints\n\n    @contextlib.contextmanager\n    def get_resolver(self, clear=False):\n        from pipenv.vendor.pip_shims.shims import (\n            WheelCache, get_requirement_tracker, global_tempdir_manager\n        )\n\n        with global_tempdir_manager(), get_requirement_tracker() as req_tracker, TemporaryDirectory(suffix=\"-build\", prefix=\"pipenv-\") as directory:\n            pip_options = self.pip_options\n            finder = self.finder\n            wheel_cache = WheelCache(pip_options.cache_dir, pip_options.format_control)\n            directory.path = directory.name\n            preparer = self.pip_command.make_requirement_preparer(\n                temp_build_dir=directory,\n                options=pip_options,\n                req_tracker=req_tracker,\n                session=self.session,\n                finder=finder,\n                use_user_site=False,\n            )\n            resolver = self.pip_command.make_resolver(\n                preparer=preparer,\n                finder=finder,\n                options=pip_options,\n                wheel_cache=wheel_cache,\n                use_user_site=False,\n                ignore_installed=True,\n                ignore_requires_python=pip_options.ignore_requires_python,\n                force_reinstall=pip_options.force_reinstall,\n                upgrade_strategy=\"to-satisfy-only\",\n                use_pep517=pip_options.use_pep517,\n            )\n            yield resolver\n\n    def resolve(self):\n        from pipenv.vendor.pip_shims.shims import InstallationError\n        from pipenv.exceptions import ResolutionFailure\n\n        with temp_environ(), self.get_resolver() as resolver:\n            try:\n                results = resolver.resolve(self.constraints, check_supported_wheels=False)\n            except InstallationError as e:\n                raise ResolutionFailure(message=str(e))\n            else:\n                self.results = set(results.all_requirements)\n                self.resolved_tree.update(self.results)\n        return self.resolved_tree\n\n    def resolve_constraints(self):\n        from .vendor.requirementslib.models.markers import marker_from_specifier\n        new_tree = set()\n        for result in self.resolved_tree:\n            if result.markers:\n                self.markers[result.name] = result.markers\n            else:\n                candidate = self.finder.find_best_candidate(result.name, result.specifier).best_candidate\n                if candidate:\n                    requires_python = candidate.link.requires_python\n                    if requires_python:\n                        marker = marker_from_specifier(requires_python)\n                        self.markers[result.name] = marker\n                        result.markers = marker\n                        if result.req:\n                            result.req.marker = marker\n            new_tree.add(result)\n        self.resolved_tree = new_tree\n\n    @classmethod\n    def prepend_hash_types(cls, checksums, hash_type):\n        cleaned_checksums = set()\n        for checksum in checksums:\n            if not checksum:\n                continue\n            if not checksum.startswith(f\"{hash_type}:\"):\n                checksum = f\"{hash_type}:{checksum}\"\n            cleaned_checksums.add(checksum)\n        return cleaned_checksums\n\n    def _get_hashes_from_pypi(self, ireq):\n        from pipenv.vendor.pip_shims import shims\n\n        pkg_url = f\"https://pypi.org/pypi/{ireq.name}/json\"\n        session = _get_requests_session(self.project.s.PIPENV_MAX_RETRIES)\n        try:\n            collected_hashes = set()\n            # Grab the hashes from the new warehouse API.\n            r = session.get(pkg_url, timeout=10)\n            api_releases = r.json()[\"releases\"]\n            cleaned_releases = {}\n            for api_version, api_info in api_releases.items():\n                api_version = clean_pkg_version(api_version)\n                cleaned_releases[api_version] = api_info\n            version = \"\"\n            if ireq.specifier:\n                spec = next(iter(s for s in ireq.specifier), None)\n                if spec:\n                    version = spec.version\n            for release in cleaned_releases[version]:\n                collected_hashes.add(release[\"digests\"][shims.FAVORITE_HASH])\n            return self.prepend_hash_types(collected_hashes, shims.FAVORITE_HASH)\n        except (ValueError, KeyError, ConnectionError):\n            if self.project.s.is_verbose():\n                click_echo(\n                    \"{}: Error generating hash for {}\".format(\n                        crayons.red(\"Warning\", bold=True), ireq.name\n                    ), err=True\n                )\n            return None\n\n    def collect_hashes(self, ireq):\n        if ireq.link:\n            link = ireq.link\n            if link.is_vcs or (link.is_file and link.is_existing_dir()):\n                return set()\n            if ireq.original_link:\n                return {self._get_hash_from_link(ireq.original_link)}\n\n        if not is_pinned_requirement(ireq):\n            return set()\n\n        if any(\n            \"python.org\" in source[\"url\"] or \"pypi.org\" in source[\"url\"]\n            for source in self.sources\n        ):\n            hashes = self._get_hashes_from_pypi(ireq)\n            if hashes:\n                return hashes\n\n        applicable_candidates = self.ignore_compatibility_finder.find_best_candidate(\n            ireq.name, ireq.specifier\n        ).iter_applicable()\n        return {\n            self._get_hash_from_link(candidate.link)\n            for candidate in applicable_candidates\n        }\n\n    def resolve_hashes(self):\n        if self.results is not None:\n            for ireq in self.results:\n                self.hashes[ireq] = self.collect_hashes(ireq)\n        return self.hashes\n\n    def _get_hash_from_link(self, link):\n        from pipenv.vendor.pip_shims import shims\n\n        if link.hash and link.hash_name == shims.FAVORITE_HASH:\n            return f\"{link.hash_name}:{link.hash}\"\n\n        return self.hash_cache.get_hash(link)\n\n    def _clean_skipped_result(self, req, value):\n        ref = None\n        if req.is_vcs:\n            ref = req.commit_hash\n        ireq = req.as_ireq()\n        entry = value.copy()\n        entry[\"name\"] = req.name\n        if entry.get(\"editable\", False) and entry.get(\"version\"):\n            del entry[\"version\"]\n        ref = ref if ref is not None else entry.get(\"ref\")\n        if ref:\n            entry[\"ref\"] = ref\n        collected_hashes = self.collect_hashes(ireq)\n        if collected_hashes:\n            entry[\"hashes\"] = sorted(set(collected_hashes))\n        return req.name, entry\n\n    def clean_results(self):\n        from pipenv.vendor.requirementslib.models.requirements import (\n            Requirement\n        )\n        reqs = [(Requirement.from_ireq(ireq), ireq) for ireq in self.resolved_tree]\n        results = {}\n        for req, ireq in reqs:\n            if (req.vcs and req.editable and not req.is_direct_url):\n                continue\n            elif req.normalized_name in self.skipped.keys():\n                continue\n            collected_hashes = self.hashes.get(ireq, set())\n            req = req.add_hashes(collected_hashes)\n            if collected_hashes:\n                collected_hashes = sorted(collected_hashes)\n            name, entry = format_requirement_for_lockfile(\n                req, self.markers_lookup, self.index_lookup, collected_hashes\n            )\n            entry = translate_markers(entry)\n            if name in results:\n                results[name].update(entry)\n            else:\n                results[name] = entry\n        for k in list(self.skipped.keys()):\n            req = Requirement.from_pipfile(k, self.skipped[k])\n            name, entry = self._clean_skipped_result(req, self.skipped[k])\n            entry = translate_markers(entry)\n            if name in results:\n                results[name].update(entry)\n            else:\n                results[name] = entry\n        results = list(results.values())\n        return results\n\n\ndef format_requirement_for_lockfile(req, markers_lookup, index_lookup, hashes=None):\n    if req.specifiers:\n        version = str(req.get_version())\n    else:\n        version = None\n    index = index_lookup.get(req.normalized_name)\n    markers = markers_lookup.get(req.normalized_name)\n    req.index = index\n    name, pf_entry = req.pipfile_entry\n    name = pep423_name(req.name)\n    entry = {}\n    if isinstance(pf_entry, str):\n        entry[\"version\"] = pf_entry.lstrip(\"=\")\n    else:\n        entry.update(pf_entry)\n        if version is not None and not req.is_vcs:\n            entry[\"version\"] = version\n        if req.line_instance.is_direct_url and not req.is_vcs:\n            entry[\"file\"] = req.req.uri\n    if hashes:\n        entry[\"hashes\"] = sorted(set(hashes))\n    entry[\"name\"] = name\n    if index:\n        entry.update({\"index\": index})\n    if markers:\n        entry.update({\"markers\": markers})\n    entry = translate_markers(entry)\n    if req.vcs or req.editable:\n        for key in (\"index\", \"version\", \"file\"):\n            try:\n                del entry[key]\n            except KeyError:\n                pass\n    return name, entry\n\n\ndef _show_warning(message, category, filename, lineno, line):\n    warnings.showwarning(message=message, category=category, filename=filename,\n                         lineno=lineno, file=sys.stderr, line=line)\n    sys.stderr.flush()\n\n\ndef actually_resolve_deps(\n    deps,\n    index_lookup,\n    markers_lookup,\n    project,\n    sources,\n    clear,\n    pre,\n    req_dir=None,\n):\n    from pipenv.vendor.vistir.path import create_tracked_tempdir\n\n    if not req_dir:\n        req_dir = create_tracked_tempdir(suffix=\"-requirements\", prefix=\"pipenv-\")\n    warning_list = []\n\n    with warnings.catch_warnings(record=True) as warning_list:\n        resolver = Resolver.create(\n            deps, project, index_lookup, markers_lookup, sources, req_dir, clear, pre\n        )\n        resolver.resolve()\n        hashes = resolver.resolve_hashes()\n        resolver.resolve_constraints()\n        results = resolver.clean_results()\n    for warning in warning_list:\n        _show_warning(warning.message, warning.category, warning.filename, warning.lineno,\n                      warning.line)\n    return (results, hashes, resolver.markers_lookup, resolver, resolver.skipped)\n\n\n@contextlib.contextmanager\ndef create_spinner(text, setting, nospin=None, spinner_name=None):\n    from .vendor.vistir import spin\n    from .vendor.vistir.misc import fs_str\n    if not spinner_name:\n        spinner_name = setting.PIPENV_SPINNER\n    if nospin is None:\n        nospin = setting.PIPENV_NOSPIN\n    with spin.create_spinner(\n        spinner_name=spinner_name,\n        start_text=fs_str(text),\n        nospin=nospin, write_to_stdout=False\n    ) as sp:\n        yield sp\n\n\ndef resolve(cmd, sp, project):\n    from ._compat import decode_output\n    from .cmdparse import Script\n    from .vendor.vistir.misc import echo\n    c = subprocess_run(Script.parse(cmd).cmd_args, block=False, env=os.environ.copy())\n    is_verbose = project.s.is_verbose()\n    err = \"\"\n    for line in iter(c.stderr.readline, \"\"):\n        line = decode_output(line)\n        if not line.rstrip():\n            continue\n        err += line\n        if is_verbose:\n            sp.hide_and_write(line.rstrip())\n\n    c.wait()\n    returncode = c.poll()\n    out = c.stdout.read()\n    if returncode != 0:\n        sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\n            \"Locking Failed!\"\n        ))\n        echo(out.strip(), err=True)\n        if not is_verbose:\n            echo(err, err=True)\n        sys.exit(returncode)\n    if is_verbose:\n        echo(out.strip(), err=True)\n    return subprocess.CompletedProcess(c.args, returncode, out, err)\n\n\ndef get_locked_dep(dep, pipfile_section, prefer_pipfile=True):\n    # the prefer pipfile flag is not used yet, but we are introducing\n    # it now for development purposes\n    # TODO: Is this implementation clear? How can it be improved?\n    entry = None\n    cleaner_kwargs = {\n        \"is_top_level\": False,\n        \"pipfile_entry\": None\n    }\n    if isinstance(dep, Mapping) and dep.get(\"name\", \"\"):\n        dep_name = pep423_name(dep[\"name\"])\n        name = next(iter(\n            k for k in pipfile_section.keys()\n            if pep423_name(k) == dep_name\n        ), None)\n        entry = pipfile_section[name] if name else None\n\n    if entry:\n        cleaner_kwargs.update({\"is_top_level\": True, \"pipfile_entry\": entry})\n    lockfile_entry = clean_resolved_dep(dep, **cleaner_kwargs)\n    if entry and isinstance(entry, Mapping):\n        version = entry.get(\"version\", \"\") if entry else \"\"\n    else:\n        version = entry if entry else \"\"\n    lockfile_name, lockfile_dict = lockfile_entry.copy().popitem()\n    lockfile_version = lockfile_dict.get(\"version\", \"\")\n    # Keep pins from the lockfile\n    if prefer_pipfile and lockfile_version != version and version.startswith(\"==\") and \"*\" not in version:\n        lockfile_dict[\"version\"] = version\n    lockfile_entry[lockfile_name] = lockfile_dict\n    return lockfile_entry\n\n\ndef prepare_lockfile(results, pipfile, lockfile):\n    # from .vendor.requirementslib.utils import is_vcs\n    for dep in results:\n        if not dep:\n            continue\n        # Merge in any relevant information from the pipfile entry, including\n        # markers, normalized names, URL info, etc that we may have dropped during lock\n        # if not is_vcs(dep):\n        lockfile_entry = get_locked_dep(dep, pipfile)\n        name = next(iter(k for k in lockfile_entry.keys()))\n        current_entry = lockfile.get(name)\n        if current_entry:\n            if not isinstance(current_entry, Mapping):\n                lockfile[name] = lockfile_entry[name]\n            else:\n                lockfile[name].update(lockfile_entry[name])\n                lockfile[name] = translate_markers(lockfile[name])\n        else:\n            lockfile[name] = lockfile_entry[name]\n    return lockfile\n\n\ndef venv_resolve_deps(\n    deps,\n    which,\n    project,\n    pre=False,\n    clear=False,\n    allow_global=False,\n    pypi_mirror=None,\n    dev=False,\n    pipfile=None,\n    lockfile=None,\n    keep_outdated=False\n):\n    \"\"\"\n    Resolve dependencies for a pipenv project, acts as a portal to the target environment.\n\n    Regardless of whether a virtual environment is present or not, this will spawn\n    a subproces which is isolated to the target environment and which will perform\n    dependency resolution.  This function reads the output of that call and mutates\n    the provided lockfile accordingly, returning nothing.\n\n    :param List[:class:`~requirementslib.Requirement`] deps: A list of dependencies to resolve.\n    :param Callable which: [description]\n    :param project: The pipenv Project instance to use during resolution\n    :param Optional[bool] pre: Whether to resolve pre-release candidates, defaults to False\n    :param Optional[bool] clear: Whether to clear the cache during resolution, defaults to False\n    :param Optional[bool] allow_global: Whether to use *sys.executable* as the python binary, defaults to False\n    :param Optional[str] pypi_mirror: A URL to substitute any time *pypi.org* is encountered, defaults to None\n    :param Optional[bool] dev: Whether to target *dev-packages* or not, defaults to False\n    :param pipfile: A Pipfile section to operate on, defaults to None\n    :type pipfile: Optional[Dict[str, Union[str, Dict[str, bool, List[str]]]]]\n    :param Dict[str, Any] lockfile: A project lockfile to mutate, defaults to None\n    :param bool keep_outdated: Whether to retain outdated dependencies and resolve with them in mind, defaults to False\n    :raises RuntimeError: Raised on resolution failure\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    import json\n\n    from . import resolver\n    from ._compat import decode_for_output\n    from .vendor.vistir.compat import JSONDecodeError, NamedTemporaryFile, Path\n    from .vendor.vistir.misc import fs_str\n    from .vendor.vistir.path import create_tracked_tempdir\n\n    results = []\n    pipfile_section = \"dev-packages\" if dev else \"packages\"\n    lockfile_section = \"develop\" if dev else \"default\"\n    if not deps:\n        if not project.pipfile_exists:\n            return None\n        deps = project.parsed_pipfile.get(pipfile_section, {})\n    if not deps:\n        return None\n\n    if not pipfile:\n        pipfile = getattr(project, pipfile_section, {})\n    if not lockfile:\n        lockfile = project._lockfile\n    req_dir = create_tracked_tempdir(prefix=\"pipenv\", suffix=\"requirements\")\n    cmd = [\n        which(\"python\", allow_global=allow_global),\n        Path(resolver.__file__.rstrip(\"co\")).as_posix()\n    ]\n    if pre:\n        cmd.append(\"--pre\")\n    if clear:\n        cmd.append(\"--clear\")\n    if allow_global:\n        cmd.append(\"--system\")\n    if dev:\n        cmd.append(\"--dev\")\n    target_file = NamedTemporaryFile(prefix=\"resolver\", suffix=\".json\", delete=False)\n    target_file.close()\n    cmd.extend([\"--write\", make_posix(target_file.name)])\n    with temp_environ():\n        os.environ.update({fs_str(k): fs_str(val) for k, val in os.environ.items()})\n        if pypi_mirror:\n            os.environ[\"PIPENV_PYPI_MIRROR\"] = str(pypi_mirror)\n        os.environ[\"PIPENV_VERBOSITY\"] = str(project.s.PIPENV_VERBOSITY)\n        os.environ[\"PIPENV_REQ_DIR\"] = fs_str(req_dir)\n        os.environ[\"PIP_NO_INPUT\"] = fs_str(\"1\")\n        pipenv_site_dir = get_pipenv_sitedir()\n        if pipenv_site_dir is not None:\n            os.environ[\"PIPENV_SITE_DIR\"] = pipenv_site_dir\n        else:\n            os.environ.pop(\"PIPENV_SITE_DIR\", None)\n        if keep_outdated:\n            os.environ[\"PIPENV_KEEP_OUTDATED\"] = fs_str(\"1\")\n        with create_spinner(text=decode_for_output(\"Locking...\"), setting=project.s) as sp:\n            # This conversion is somewhat slow on local and file-type requirements since\n            # we now download those requirements / make temporary folders to perform\n            # dependency resolution on them, so we are including this step inside the\n            # spinner context manager for the UX improvement\n            sp.write(decode_for_output(\"Building requirements...\"))\n            deps = convert_deps_to_pip(\n                deps, project, r=False, include_index=True\n            )\n            constraints = set(deps)\n            os.environ[\"PIPENV_PACKAGES\"] = str(\"\\n\".join(constraints))\n            sp.write(decode_for_output(\"Resolving dependencies...\"))\n            c = resolve(cmd, sp, project=project)\n            results = c.stdout.strip()\n            if c.returncode == 0:\n                sp.green.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Success!\"))\n                if not project.s.is_verbose() and c.stderr.strip():\n                    click_echo(crayons.yellow(f\"Warning: {c.stderr.strip()}\"), err=True)\n            else:\n                sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Locking Failed!\"))\n                click_echo(f\"Output: {c.stdout.strip()}\", err=True)\n                click_echo(f\"Error: {c.stderr.strip()}\", err=True)\n    try:\n        with open(target_file.name) as fh:\n            results = json.load(fh)\n    except (IndexError, JSONDecodeError):\n        click_echo(c.stdout.strip(), err=True)\n        click_echo(c.stderr.strip(), err=True)\n        if os.path.exists(target_file.name):\n            os.unlink(target_file.name)\n        raise RuntimeError(\"There was a problem with locking.\")\n    if os.path.exists(target_file.name):\n        os.unlink(target_file.name)\n    if lockfile_section not in lockfile:\n        lockfile[lockfile_section] = {}\n    prepare_lockfile(results, pipfile, lockfile[lockfile_section])\n\n\ndef resolve_deps(\n    deps,\n    which,\n    project,\n    sources=None,\n    python=False,\n    clear=False,\n    pre=False,\n    allow_global=False,\n    req_dir=None\n):\n    \"\"\"Given a list of dependencies, return a resolved list of dependencies,\n    using pip-tools -- and their hashes, using the warehouse API / pip.\n    \"\"\"\n    index_lookup = {}\n    markers_lookup = {}\n    python_path = which(\"python\", allow_global=allow_global)\n    if not os.environ.get(\"PIP_SRC\"):\n        os.environ[\"PIP_SRC\"] = project.virtualenv_src_location\n    backup_python_path = sys.executable\n    results = []\n    resolver = None\n    if not deps:\n        return results, resolver\n    # First (proper) attempt:\n    req_dir = req_dir if req_dir else os.environ.get(\"req_dir\", None)\n    if not req_dir:\n        from .vendor.vistir.path import create_tracked_tempdir\n        req_dir = create_tracked_tempdir(prefix=\"pipenv-\", suffix=\"-requirements\")\n    with HackedPythonVersion(python_version=python, python_path=python_path):\n        try:\n            results, hashes, markers_lookup, resolver, skipped = actually_resolve_deps(\n                deps,\n                index_lookup,\n                markers_lookup,\n                project,\n                sources,\n                clear,\n                pre,\n                req_dir=req_dir,\n            )\n        except RuntimeError:\n            # Don't exit here, like usual.\n            results = None\n    # Second (last-resort) attempt:\n    if results is None:\n        with HackedPythonVersion(\n            python_version=\".\".join([str(s) for s in sys.version_info[:3]]),\n            python_path=backup_python_path,\n        ):\n            try:\n                # Attempt to resolve again, with different Python version information,\n                # particularly for particularly particular packages.\n                results, hashes, markers_lookup, resolver, skipped = actually_resolve_deps(\n                    deps,\n                    index_lookup,\n                    markers_lookup,\n                    project,\n                    sources,\n                    clear,\n                    pre,\n                    req_dir=req_dir,\n                )\n            except RuntimeError:\n                sys.exit(1)\n    return results, resolver\n\n\ndef is_star(val):\n    return isinstance(val, str) and val == \"*\"\n\n\ndef is_pinned(val):\n    if isinstance(val, Mapping):\n        val = val.get(\"version\")\n    return isinstance(val, str) and val.startswith(\"==\")\n\n\ndef is_pinned_requirement(ireq):\n    \"\"\"\n    Returns whether an InstallRequirement is a \"pinned\" requirement.\n    \"\"\"\n    if ireq.editable:\n        return False\n\n    if ireq.req is None or len(ireq.specifier) != 1:\n        return False\n\n    spec = next(iter(ireq.specifier))\n    return spec.operator in {\"==\", \"===\"} and not spec.version.endswith(\".*\")\n\n\ndef convert_deps_to_pip(deps, project=None, r=True, include_index=True):\n    \"\"\"\"Converts a Pipfile-formatted dependency to a pip-formatted one.\"\"\"\n    from .vendor.requirementslib.models.requirements import Requirement\n\n    dependencies = []\n    for dep_name, dep in deps.items():\n        if project:\n            project.clear_pipfile_cache()\n        indexes = getattr(project, \"pipfile_sources\", []) if project is not None else []\n        new_dep = Requirement.from_pipfile(dep_name, dep)\n        if new_dep.index:\n            include_index = True\n        req = new_dep.as_line(sources=indexes if include_index else None).strip()\n        dependencies.append(req)\n    if not r:\n        return dependencies\n\n    # Write requirements.txt to tmp directory.\n    from .vendor.vistir.path import create_tracked_tempfile\n    f = create_tracked_tempfile(suffix=\"-requirements.txt\", delete=False)\n    f.write(\"\\n\".join(dependencies).encode(\"utf-8\"))\n    f.close()\n    return f.name\n\n\ndef mkdir_p(newdir):\n    \"\"\"works the way a good mkdir should :)\n        - already exists, silently complete\n        - regular file in the way, raise an exception\n        - parent directory(ies) does not exist, make them as well\n        From: http://code.activestate.com/recipes/82465-a-friendly-mkdir/\n    \"\"\"\n    if os.path.isdir(newdir):\n        pass\n    elif os.path.isfile(newdir):\n        raise OSError(\n            \"a file with the same name as the desired dir, '{}', already exists.\".format(\n                newdir\n            )\n        )\n\n    else:\n        head, tail = os.path.split(newdir)\n        if head and not os.path.isdir(head):\n            mkdir_p(head)\n        if tail:\n            # Even though we've checked that the directory doesn't exist above, it might exist\n            # now if some other process has created it between now and the time we checked it.\n            try:\n                os.mkdir(newdir)\n            except OSError as exn:\n                # If we failed because the directory does exist, that's not a problem -\n                # that's what we were trying to do anyway. Only re-raise the exception\n                # if we failed for some other reason.\n                if exn.errno != errno.EEXIST:\n                    raise\n\n\ndef is_required_version(version, specified_version):\n    \"\"\"Check to see if there's a hard requirement for version\n    number provided in the Pipfile.\n    \"\"\"\n    # Certain packages may be defined with multiple values.\n    if isinstance(specified_version, dict):\n        specified_version = specified_version.get(\"version\", \"\")\n    if specified_version.startswith(\"==\"):\n        return version.strip() == specified_version.split(\"==\")[1].strip()\n\n    return True\n\n\ndef is_editable(pipfile_entry):\n    if hasattr(pipfile_entry, \"get\"):\n        return pipfile_entry.get(\"editable\", False) and any(\n            pipfile_entry.get(key) for key in (\"file\", \"path\") + VCS_LIST\n        )\n    return False\n\n\ndef is_installable_file(path):\n    \"\"\"Determine if a path can potentially be installed\"\"\"\n    from .patched.notpip._internal.utils.packaging import specifiers\n    from .vendor.pip_shims.shims import is_archive_file, is_installable_dir\n\n    if hasattr(path, \"keys\") and any(\n        key for key in path.keys() if key in [\"file\", \"path\"]\n    ):\n        path = urlparse(path[\"file\"]).path if \"file\" in path else path[\"path\"]\n    if not isinstance(path, str) or path == \"*\":\n        return False\n\n    # If the string starts with a valid specifier operator, test if it is a valid\n    # specifier set before making a path object (to avoid breaking windows)\n    if any(path.startswith(spec) for spec in \"!=<>~\"):\n        try:\n            specifiers.SpecifierSet(path)\n        # If this is not a valid specifier, just move on and try it as a path\n        except specifiers.InvalidSpecifier:\n            pass\n        else:\n            return False\n\n    if not os.path.exists(os.path.abspath(path)):\n        return False\n\n    lookup_path = Path(path)\n    absolute_path = f\"{lookup_path.absolute()}\"\n    if lookup_path.is_dir() and is_installable_dir(absolute_path):\n        return True\n\n    elif lookup_path.is_file() and is_archive_file(absolute_path):\n        return True\n\n    return False\n\n\ndef is_file(package):\n    \"\"\"Determine if a package name is for a File dependency.\"\"\"\n    if hasattr(package, \"keys\"):\n        return any(key for key in package.keys() if key in [\"file\", \"path\"])\n\n    if os.path.exists(str(package)):\n        return True\n\n    for start in SCHEME_LIST:\n        if str(package).startswith(start):\n            return True\n\n    return False\n\n\ndef pep440_version(version):\n    \"\"\"Normalize version to PEP 440 standards\"\"\"\n    # Use pip built-in version parser.\n    from pipenv.vendor.pip_shims import shims\n\n    return str(shims.parse_version(version))\n\n\ndef pep423_name(name):\n    \"\"\"Normalize package name to PEP 423 style standard.\"\"\"\n    name = name.lower()\n    if any(i not in name for i in (VCS_LIST + SCHEME_LIST)):\n        return name.replace(\"_\", \"-\")\n\n    else:\n        return name\n\n\ndef proper_case(package_name):\n    \"\"\"Properly case project name from pypi.org.\"\"\"\n    # Hit the simple API.\n    r = _get_requests_session().get(\n        f\"https://pypi.org/pypi/{package_name}/json\", timeout=0.3, stream=True\n    )\n    if not r.ok:\n        raise OSError(\n            f\"Unable to find package {package_name} in PyPI repository.\"\n        )\n\n    r = parse.parse(\"https://pypi.org/pypi/{name}/json\", r.url)\n    good_name = r[\"name\"]\n    return good_name\n\n\ndef get_windows_path(*args):\n    \"\"\"Sanitize a path for windows environments\n\n    Accepts an arbitrary list of arguments and makes a clean windows path\"\"\"\n    return os.path.normpath(os.path.join(*args))\n\n\ndef find_windows_executable(bin_path, exe_name):\n    \"\"\"Given an executable name, search the given location for an executable\"\"\"\n    requested_path = get_windows_path(bin_path, exe_name)\n    if os.path.isfile(requested_path):\n        return requested_path\n\n    try:\n        pathext = os.environ[\"PATHEXT\"]\n    except KeyError:\n        pass\n    else:\n        for ext in pathext.split(os.pathsep):\n            path = get_windows_path(bin_path, exe_name + ext.strip().lower())\n            if os.path.isfile(path):\n                return path\n\n    return find_executable(exe_name)\n\n\ndef path_to_url(path):\n\n    return Path(normalize_drive(os.path.abspath(path))).as_uri()\n\n\ndef normalize_path(path):\n    return os.path.expandvars(os.path.expanduser(\n        os.path.normcase(os.path.normpath(os.path.abspath(str(path))))\n    ))\n\n\ndef get_url_name(url):\n    if not isinstance(url, str):\n        return\n    return urllib3_util.parse_url(url).host\n\n\ndef get_canonical_names(packages):\n    \"\"\"Canonicalize a list of packages and return a set of canonical names\"\"\"\n    from .vendor.packaging.utils import canonicalize_name\n\n    if not isinstance(packages, Sequence):\n        if not isinstance(packages, str):\n            return packages\n        packages = [packages]\n    return {canonicalize_name(pkg) for pkg in packages if pkg}\n\n\ndef walk_up(bottom):\n    \"\"\"Mimic os.walk, but walk 'up' instead of down the directory tree.\n    From: https://gist.github.com/zdavkeos/1098474\n    \"\"\"\n    bottom = os.path.realpath(bottom)\n    # Get files in current dir.\n    try:\n        names = os.listdir(bottom)\n    except Exception:\n        return\n\n    dirs, nondirs = [], []\n    for name in names:\n        if os.path.isdir(os.path.join(bottom, name)):\n            dirs.append(name)\n        else:\n            nondirs.append(name)\n    yield bottom, dirs, nondirs\n\n    new_path = os.path.realpath(os.path.join(bottom, \"..\"))\n    # See if we are at the top.\n    if new_path == bottom:\n        return\n\n    yield from walk_up(new_path)\n\n\ndef find_requirements(max_depth=3):\n    \"\"\"Returns the path of a requirements.txt file in parent directories.\"\"\"\n    i = 0\n    for c, d, f in walk_up(os.getcwd()):\n        i += 1\n        if i < max_depth:\n            r = os.path.join(c, \"requirements.txt\")\n            if os.path.isfile(r):\n                return r\n\n    raise RuntimeError(\"No requirements.txt found!\")\n\n\n# Borrowed from Pew.\n# See https://github.com/berdario/pew/blob/master/pew/_utils.py#L82\n@contextmanager\ndef temp_environ():\n    \"\"\"Allow the ability to set os.environ temporarily\"\"\"\n    environ = dict(os.environ)\n    try:\n        yield\n\n    finally:\n        os.environ.clear()\n        os.environ.update(environ)\n\n\n@contextmanager\ndef temp_path():\n    \"\"\"Allow the ability to set os.environ temporarily\"\"\"\n    path = [p for p in sys.path]\n    try:\n        yield\n    finally:\n        sys.path = [p for p in path]\n\n\ndef load_path(python):\n    import json\n\n    from pathlib import Path\n    python = Path(python).as_posix()\n    json_dump_commmand = '\"import json, sys; print(json.dumps(sys.path));\"'\n    c = subprocess_run([python, \"-c\", json_dump_commmand])\n    if c.returncode == 0:\n        return json.loads(c.stdout.strip())\n    else:\n        return []\n\n\ndef is_valid_url(url):\n    \"\"\"Checks if a given string is an url\"\"\"\n    pieces = urlparse(url)\n    return all([pieces.scheme, pieces.netloc])\n\n\ndef is_pypi_url(url):\n    return bool(re.match(r\"^http[s]?:\\/\\/pypi(?:\\.python)?\\.org\\/simple[\\/]?$\", url))\n\n\ndef replace_pypi_sources(sources, pypi_replacement_source):\n    return [pypi_replacement_source] + [\n        source for source in sources if not is_pypi_url(source[\"url\"])\n    ]\n\n\ndef create_mirror_source(url):\n    return {\n        \"url\": url,\n        \"verify_ssl\": url.startswith(\"https://\"),\n        \"name\": urlparse(url).hostname,\n    }\n\n\ndef download_file(url, filename, max_retries=1):\n    \"\"\"Downloads file from url to a path with filename\"\"\"\n    r = _get_requests_session(max_retries).get(url, stream=True)\n    if not r.ok:\n        raise OSError(\"Unable to download file\")\n\n    with open(filename, \"wb\") as f:\n        f.write(r.content)\n\n\ndef normalize_drive(path):\n    \"\"\"Normalize drive in path so they stay consistent.\n\n    This currently only affects local drives on Windows, which can be\n    identified with either upper or lower cased drive names. The case is\n    always converted to uppercase because it seems to be preferred.\n\n    See: <https://github.com/pypa/pipenv/issues/1218>\n    \"\"\"\n    if os.name != \"nt\" or not isinstance(path, str):\n        return path\n\n    drive, tail = os.path.splitdrive(path)\n    # Only match (lower cased) local drives (e.g. 'c:'), not UNC mounts.\n    if drive.islower() and len(drive) == 2 and drive[1] == \":\":\n        return f\"{drive.upper()}{tail}\"\n\n    return path\n\n\ndef is_readonly_path(fn):\n    \"\"\"Check if a provided path exists and is readonly.\n\n    Permissions check is `bool(path.stat & stat.S_IREAD)` or `not os.access(path, os.W_OK)`\n    \"\"\"\n    if os.path.exists(fn):\n        return (os.stat(fn).st_mode & stat.S_IREAD) or not os.access(fn, os.W_OK)\n\n    return False\n\n\ndef set_write_bit(fn):\n    if isinstance(fn, str) and not os.path.exists(fn):\n        return\n    os.chmod(fn, stat.S_IWRITE | stat.S_IWUSR | stat.S_IRUSR)\n    return\n\n\ndef rmtree(directory, ignore_errors=False):\n    shutil.rmtree(\n        directory, ignore_errors=ignore_errors, onerror=handle_remove_readonly\n    )\n\n\ndef handle_remove_readonly(func, path, exc):\n    \"\"\"Error handler for shutil.rmtree.\n\n    Windows source repo folders are read-only by default, so this error handler\n    attempts to set them as writeable and then proceed with deletion.\"\"\"\n    # Check for read-only attribute\n    default_warning_message = (\n        \"Unable to remove file due to permissions restriction: {!r}\"\n    )\n    # split the initial exception out into its type, exception, and traceback\n    exc_type, exc_exception, exc_tb = exc\n    if is_readonly_path(path):\n        # Apply write permission and call original function\n        set_write_bit(path)\n        try:\n            func(path)\n        except OSError as e:\n            if e.errno in [errno.EACCES, errno.EPERM]:\n                warnings.warn(default_warning_message.format(path), ResourceWarning)\n                return\n\n    if exc_exception.errno in [errno.EACCES, errno.EPERM]:\n        warnings.warn(default_warning_message.format(path), ResourceWarning)\n        return\n\n    raise exc\n\n\ndef escape_cmd(cmd):\n    if any(special_char in cmd for special_char in [\"<\", \">\", \"&\", \".\", \"^\", \"|\", \"?\"]):\n        cmd = f'\\\"{cmd}\\\"'\n    return cmd\n\n\ndef safe_expandvars(value):\n    \"\"\"Call os.path.expandvars if value is a string, otherwise do nothing.\n    \"\"\"\n    if isinstance(value, str):\n        return os.path.expandvars(value)\n    return value\n\n\ndef get_vcs_deps(\n    project=None,\n    dev=False,\n    pypi_mirror=None,\n    packages=None,\n    reqs=None\n):\n    from .vendor.requirementslib.models.requirements import Requirement\n\n    section = \"vcs_dev_packages\" if dev else \"vcs_packages\"\n    if reqs is None:\n        reqs = []\n    lockfile = {}\n    if not reqs:\n        if not project and not packages:\n            raise ValueError(\n                \"Must supply either a project or a pipfile section to lock vcs dependencies.\"\n            )\n        if not packages:\n            try:\n                packages = getattr(project, section)\n            except AttributeError:\n                return [], []\n        reqs = [Requirement.from_pipfile(name, entry) for name, entry in packages.items()]\n    result = []\n    for requirement in reqs:\n        name = requirement.normalized_name\n        commit_hash = None\n        if requirement.is_vcs:\n            try:\n                with temp_path(), locked_repository(requirement) as repo:\n                    from pipenv.vendor.requirementslib.models.requirements import (\n                        Requirement\n                    )\n\n                    # from distutils.sysconfig import get_python_lib\n                    # sys.path = [repo.checkout_directory, \"\", \".\", get_python_lib(plat_specific=0)]\n                    commit_hash = repo.get_commit_hash()\n                    name = requirement.normalized_name\n                    lockfile[name] = requirement.pipfile_entry[1]\n                    lockfile[name]['ref'] = commit_hash\n                    result.append(requirement)\n            except OSError:\n                continue\n    return result, lockfile\n\n\ndef translate_markers(pipfile_entry):\n    \"\"\"Take a pipfile entry and normalize its markers\n\n    Provide a pipfile entry which may have 'markers' as a key or it may have\n    any valid key from `packaging.markers.marker_context.keys()` and standardize\n    the format into {'markers': 'key == \"some_value\"'}.\n\n    :param pipfile_entry: A dictionariy of keys and values representing a pipfile entry\n    :type pipfile_entry: dict\n    :returns: A normalized dictionary with cleaned marker entries\n    \"\"\"\n    if not isinstance(pipfile_entry, Mapping):\n        raise TypeError(\"Entry is not a pipfile formatted mapping.\")\n    from .vendor.packaging.markers import default_environment\n    from .vendor.vistir.misc import dedup\n\n    allowed_marker_keys = [\"markers\"] + list(default_environment().keys())\n    provided_keys = list(pipfile_entry.keys()) if hasattr(pipfile_entry, \"keys\") else []\n    pipfile_markers = set(provided_keys) & set(allowed_marker_keys)\n    new_pipfile = dict(pipfile_entry).copy()\n    marker_set = set()\n    if \"markers\" in new_pipfile:\n        marker_str = new_pipfile.pop(\"markers\")\n        if marker_str:\n            marker = str(Marker(marker_str))\n            if 'extra' not in marker:\n                marker_set.add(marker)\n    for m in pipfile_markers:\n        entry = f\"{pipfile_entry[m]}\"\n        if m != \"markers\":\n            marker_set.add(str(Marker(f\"{m} {entry}\")))\n            new_pipfile.pop(m)\n    if marker_set:\n        new_pipfile[\"markers\"] = str(Marker(\" or \".join(\n            f\"{s}\" if \" and \" in s else s\n            for s in sorted(dedup(marker_set))\n        ))).replace('\"', \"'\")\n    return new_pipfile\n\n\ndef clean_resolved_dep(dep, is_top_level=False, pipfile_entry=None):\n    from .vendor.requirementslib.utils import is_vcs\n    name = pep423_name(dep[\"name\"])\n    lockfile = {}\n    # We use this to determine if there are any markers on top level packages\n    # So we can make sure those win out during resolution if the packages reoccur\n    if \"version\" in dep and dep[\"version\"] and not dep.get(\"editable\", False):\n        version = \"{}\".format(dep[\"version\"])\n        if not version.startswith(\"==\"):\n            version = f\"=={version}\"\n        lockfile[\"version\"] = version\n    if is_vcs(dep):\n        ref = dep.get(\"ref\", None)\n        if ref is not None:\n            lockfile[\"ref\"] = ref\n        vcs_type = next(iter(k for k in dep.keys() if k in VCS_LIST), None)\n        if vcs_type:\n            lockfile[vcs_type] = dep[vcs_type]\n        if \"subdirectory\" in dep:\n            lockfile[\"subdirectory\"] = dep[\"subdirectory\"]\n    for key in [\"hashes\", \"index\", \"extras\", \"editable\"]:\n        if key in dep:\n            lockfile[key] = dep[key]\n    # In case we lock a uri or a file when the user supplied a path\n    # remove the uri or file keys from the entry and keep the path\n    fs_key = next(iter(k for k in [\"path\", \"file\"] if k in dep), None)\n    pipfile_fs_key = None\n    if pipfile_entry:\n        pipfile_fs_key = next(iter(k for k in [\"path\", \"file\"] if k in pipfile_entry), None)\n    if fs_key and pipfile_fs_key and fs_key != pipfile_fs_key:\n        lockfile[pipfile_fs_key] = pipfile_entry[pipfile_fs_key]\n    elif fs_key is not None:\n        lockfile[fs_key] = dep[fs_key]\n\n    # If a package is **PRESENT** in the pipfile but has no markers, make sure we\n    # **NEVER** include markers in the lockfile\n    if \"markers\" in dep and dep.get(\"markers\", \"\").strip():\n        # First, handle the case where there is no top level dependency in the pipfile\n        if not is_top_level:\n            translated = translate_markers(dep).get(\"markers\", \"\").strip()\n            if translated:\n                try:\n                    lockfile[\"markers\"] = translated\n                except TypeError:\n                    pass\n        # otherwise make sure we are prioritizing whatever the pipfile says about the markers\n        # If the pipfile says nothing, then we should put nothing in the lockfile\n        else:\n            try:\n                pipfile_entry = translate_markers(pipfile_entry)\n                lockfile[\"markers\"] = pipfile_entry.get(\"markers\")\n            except TypeError:\n                pass\n    return {name: lockfile}\n\n\ndef get_workon_home():\n    workon_home = os.environ.get(\"WORKON_HOME\")\n    if not workon_home:\n        if os.name == \"nt\":\n            workon_home = \"~/.virtualenvs\"\n        else:\n            workon_home = os.path.join(\n                os.environ.get(\"XDG_DATA_HOME\", \"~/.local/share\"), \"virtualenvs\"\n            )\n    # Create directory if it does not already exist\n    expanded_path = Path(os.path.expandvars(workon_home)).expanduser()\n    mkdir_p(str(expanded_path))\n    return expanded_path\n\n\ndef is_virtual_environment(path):\n    \"\"\"Check if a given path is a virtual environment's root.\n\n    This is done by checking if the directory contains a Python executable in\n    its bin/Scripts directory. Not technically correct, but good enough for\n    general usage.\n    \"\"\"\n    if not path.is_dir():\n        return False\n    for bindir_name in ('bin', 'Scripts'):\n        for python in path.joinpath(bindir_name).glob('python*'):\n            try:\n                exeness = python.is_file() and os.access(str(python), os.X_OK)\n            except OSError:\n                exeness = False\n            if exeness:\n                return True\n    return False\n\n\n@contextmanager\ndef locked_repository(requirement):\n    from .vendor.vistir.path import create_tracked_tempdir\n    if not requirement.is_vcs:\n        return\n    original_base = os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n    os.environ[\"PIP_SHIMS_BASE_MODULE\"] = fs_str(\"pipenv.patched.notpip\")\n    src_dir = create_tracked_tempdir(prefix=\"pipenv-\", suffix=\"-src\")\n    try:\n        with requirement.req.locked_vcs_repo(src_dir=src_dir) as repo:\n            yield repo\n    finally:\n        if original_base:\n            os.environ[\"PIP_SHIMS_BASE_MODULE\"] = original_base\n\n\n@contextmanager\ndef chdir(path):\n    \"\"\"Context manager to change working directories.\"\"\"\n    if not path:\n        return\n    prev_cwd = Path.cwd().as_posix()\n    if isinstance(path, Path):\n        path = path.as_posix()\n    os.chdir(str(path))\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)\n\n\ndef looks_like_dir(path):\n    seps = (sep for sep in (os.path.sep, os.path.altsep) if sep is not None)\n    return any(sep in path for sep in seps)\n\n\ndef parse_indexes(line, strict=False):\n    from argparse import ArgumentParser\n\n    comment_re = re.compile(r\"(?:^|\\s+)#.*$\")\n    line = comment_re.sub(\"\", line)\n    parser = ArgumentParser(\"indexes\", allow_abbrev=False)\n    parser.add_argument(\"-i\", \"--index-url\", dest=\"index\")\n    parser.add_argument(\"--extra-index-url\", dest=\"extra_index\")\n    parser.add_argument(\"--trusted-host\", dest=\"trusted_host\")\n    args, remainder = parser.parse_known_args(line.split())\n    index = args.index\n    extra_index = args.extra_index\n    trusted_host = args.trusted_host\n    if strict and sum(\n        bool(arg) for arg in (index, extra_index, trusted_host, remainder)\n    ) > 1:\n        raise ValueError(\"Index arguments must be on their own lines.\")\n    return index, extra_index, trusted_host, remainder\n\n\n@contextmanager\ndef sys_version(version_tuple):\n    \"\"\"\n    Set a temporary sys.version_info tuple\n\n    :param version_tuple: a fake sys.version_info tuple\n    \"\"\"\n\n    old_version = sys.version_info\n    sys.version_info = version_tuple\n    yield\n    sys.version_info = old_version\n\n\ndef add_to_set(original_set, element):\n    \"\"\"Given a set and some arbitrary element, add the element(s) to the set\"\"\"\n    if not element:\n        return original_set\n    if isinstance(element, Set):\n        original_set |= element\n    elif isinstance(element, (list, tuple)):\n        original_set |= set(element)\n    else:\n        original_set.add(element)\n    return original_set\n\n\ndef is_url_equal(url, other_url):\n    # type: (str, str) -> bool\n    \"\"\"\n    Compare two urls by scheme, host, and path, ignoring auth\n\n    :param str url: The initial URL to compare\n    :param str url: Second url to compare to the first\n    :return: Whether the URLs are equal without **auth**, **query**, and **fragment**\n    :rtype: bool\n\n    >>> is_url_equal(\"https://user:pass@mydomain.com/some/path?some_query\",\n                     \"https://user2:pass2@mydomain.com/some/path\")\n    True\n\n    >>> is_url_equal(\"https://user:pass@mydomain.com/some/path?some_query\",\n                 \"https://mydomain.com/some?some_query\")\n    False\n    \"\"\"\n    if not isinstance(url, str):\n        raise TypeError(f\"Expected string for url, received {url!r}\")\n    if not isinstance(other_url, str):\n        raise TypeError(f\"Expected string for url, received {other_url!r}\")\n    parsed_url = urllib3_util.parse_url(url)\n    parsed_other_url = urllib3_util.parse_url(other_url)\n    unparsed = parsed_url._replace(auth=None, query=None, fragment=None).url\n    unparsed_other = parsed_other_url._replace(auth=None, query=None, fragment=None).url\n    return unparsed == unparsed_other\n\n\n@lru_cache()\ndef make_posix(path):\n    # type: (str) -> str\n    \"\"\"\n    Convert a path with possible windows-style separators to a posix-style path\n    (with **/** separators instead of **\\\\** separators).\n\n    :param Text path: A path to convert.\n    :return: A converted posix-style path\n    :rtype: Text\n\n    >>> make_posix(\"c:/users/user/venvs/some_venv\\\\Lib\\\\site-packages\")\n    \"c:/users/user/venvs/some_venv/Lib/site-packages\"\n\n    >>> make_posix(\"c:\\\\users\\\\user\\\\venvs\\\\some_venv\")\n    \"c:/users/user/venvs/some_venv\"\n    \"\"\"\n    if not isinstance(path, str):\n        raise TypeError(f\"Expected a string for path, received {path!r}...\")\n    starts_with_sep = path.startswith(os.path.sep)\n    separated = normalize_path(path).split(os.path.sep)\n    if isinstance(separated, (list, tuple)):\n        path = posixpath.join(*separated)\n        if starts_with_sep:\n            path = f\"/{path}\"\n    return path\n\n\ndef get_pipenv_dist(pkg=\"pipenv\", pipenv_site=None):\n    from .resolver import find_site_path\n    pipenv_libdir = os.path.dirname(os.path.abspath(__file__))\n    if pipenv_site is None:\n        pipenv_site = os.path.dirname(pipenv_libdir)\n    pipenv_dist, _ = find_site_path(pkg, site_dir=pipenv_site)\n    return pipenv_dist\n\n\ndef find_python(finder, line=None):\n    \"\"\"\n    Given a `pythonfinder.Finder` instance and an optional line, find a corresponding python\n\n    :param finder: A :class:`pythonfinder.Finder` instance to use for searching\n    :type finder: :class:pythonfinder.Finder`\n    :param str line: A version, path, name, or nothing, defaults to None\n    :return: A path to python\n    :rtype: str\n    \"\"\"\n\n    if line and not isinstance(line, str):\n        raise TypeError(\n            f\"Invalid python search type: expected string, received {line!r}\"\n        )\n    if line and os.path.isabs(line):\n        if os.name == \"nt\":\n            line = make_posix(line)\n        return line\n    if not finder:\n        from pipenv.vendor.pythonfinder import Finder\n        finder = Finder(global_search=True)\n    if not line:\n        result = next(iter(finder.find_all_python_versions()), None)\n    elif line and line[0].isdigit() or re.match(r'[\\d\\.]+', line):\n        result = finder.find_python_version(line)\n    else:\n        result = finder.find_python_version(name=line)\n    if not result:\n        result = finder.which(line)\n    if not result and not line.startswith(\"python\"):\n        line = f\"python{line}\"\n        result = find_python(finder, line)\n\n    if result:\n        if not isinstance(result, str):\n            return result.path.as_posix()\n        return result\n    return\n\n\ndef is_python_command(line):\n    \"\"\"\n    Given an input, checks whether the input is a request for python or notself.\n\n    This can be a version, a python runtime name, or a generic 'python' or 'pythonX.Y'\n\n    :param str line: A potential request to find python\n    :returns: Whether the line is a python lookup\n    :rtype: bool\n    \"\"\"\n\n    if not isinstance(line, str):\n        raise TypeError(f\"Not a valid command to check: {line!r}\")\n\n    from pipenv.vendor.pythonfinder.utils import PYTHON_IMPLEMENTATIONS\n    is_version = re.match(r'\\d+(\\.\\d+)*', line)\n    if (line.startswith(\"python\") or is_version\n            or any(line.startswith(v) for v in PYTHON_IMPLEMENTATIONS)):\n        return True\n    # we are less sure about this but we can guess\n    if line.startswith(\"py\"):\n        return True\n    return False\n\n\n@contextlib.contextmanager\ndef interrupt_handled_subprocess(\n    cmd, verbose=False, return_object=True, write_to_stdout=False, combine_stderr=True,\n    block=True, nospin=True, env=None\n):\n    \"\"\"Given a :class:`subprocess.Popen` instance, wrap it in exception handlers.\n\n    Terminates the subprocess when and if a `SystemExit` or `KeyboardInterrupt` are\n    processed.\n\n    Arguments:\n        :param str cmd: A command to run\n        :param bool verbose: Whether to run with verbose mode enabled, default False\n        :param bool return_object: Whether to return a subprocess instance or a 2-tuple, default True\n        :param bool write_to_stdout: Whether to write directly to stdout, default False\n        :param bool combine_stderr: Whether to combine stdout and stderr, default True\n        :param bool block: Whether the subprocess should be a blocking subprocess, default True\n        :param bool nospin: Whether to suppress the spinner with the subprocess, default True\n        :param Optional[Dict[str, str]] env: A dictionary to merge into the subprocess environment\n        :return: A subprocess, wrapped in exception handlers, as a context manager\n        :rtype: :class:`subprocess.Popen` obj: An instance of a running subprocess\n    \"\"\"\n    obj = run(\n        cmd, verbose=verbose, return_object=True, write_to_stdout=False,\n        combine_stderr=False, block=True, nospin=True, env=env,\n    )\n    try:\n        yield obj\n    except (SystemExit, KeyboardInterrupt):\n        if os.name == \"nt\":\n            os.kill(obj.pid, signal.CTRL_BREAK_EVENT)\n        else:\n            os.kill(obj.pid, signal.SIGINT)\n        obj.wait()\n        raise\n\n\ndef subprocess_run(\n    args, *, block=True, text=True, capture_output=True,\n    encoding=\"utf-8\", env=None, **other_kwargs\n):\n    \"\"\"A backward compatible version of subprocess.run().\n\n    It outputs text with default encoding, and store all outputs in the returned object instead of\n    printing onto stdout.\n    \"\"\"\n    _env = os.environ.copy()\n    _env[\"PYTHONIOENCODING\"] = encoding\n    if env:\n        _env.update(env)\n    other_kwargs[\"env\"] = _env\n    if capture_output:\n        other_kwargs['stdout'] = subprocess.PIPE\n        other_kwargs['stderr'] = subprocess.PIPE\n    if block:\n        return subprocess.run(\n            args, universal_newlines=text,\n            encoding=encoding, **other_kwargs\n        )\n    else:\n        return subprocess.Popen(\n            args, universal_newlines=text,\n            encoding=encoding, **other_kwargs\n        )\n\n\ndef cmd_list_to_shell(args):\n    \"\"\"Convert a list of arguments to a quoted shell command.\"\"\"\n    return \" \".join(shlex.quote(str(token)) for token in args)\n", "import os\n\nimport pytest\n\nimport pipenv.utils\nfrom pipenv.exceptions import PipenvUsageError\n\n\n# Pipfile format <-> requirements.txt format.\nDEP_PIP_PAIRS = [\n    ({\"requests\": \"*\"}, \"requests\"),\n    ({\"requests\": {\"extras\": [\"socks\"], \"version\": \"*\"}}, \"requests[socks]\"),\n    ({\"django\": \">1.10\"}, \"django>1.10\"),\n    ({\"Django\": \">1.10\"}, \"Django>1.10\"),\n    ({\"requests\": {\"extras\": [\"socks\"], \"version\": \">1.10\"}}, \"requests[socks]>1.10\"),\n    ({\"requests\": {\"extras\": [\"socks\"], \"version\": \"==1.10\"}}, \"requests[socks]==1.10\"),\n    (\n        {\n            \"pinax\": {\n                \"git\": \"git://github.com/pinax/pinax.git\",\n                \"ref\": \"1.4\",\n                \"editable\": True,\n            }\n        },\n        \"-e git+git://github.com/pinax/pinax.git@1.4#egg=pinax\",\n    ),\n    (\n        {\"pinax\": {\"git\": \"git://github.com/pinax/pinax.git\", \"ref\": \"1.4\"}},\n        \"git+git://github.com/pinax/pinax.git@1.4#egg=pinax\",\n    ),\n    (  # Mercurial.\n        {\n            \"MyProject\": {\n                \"hg\": \"http://hg.myproject.org/MyProject\",\n                \"ref\": \"da39a3ee5e6b\",\n            }\n        },\n        \"hg+http://hg.myproject.org/MyProject@da39a3ee5e6b#egg=MyProject\",\n    ),\n    (  # SVN.\n        {\n            \"MyProject\": {\n                \"svn\": \"svn://svn.myproject.org/svn/MyProject\",\n                \"editable\": True,\n            }\n        },\n        \"-e svn+svn://svn.myproject.org/svn/MyProject#egg=MyProject\",\n    ),\n    (\n        # Extras in url\n        {\n            \"discord.py\": {\n                \"file\": \"https://github.com/Rapptz/discord.py/archive/async.zip\",\n                \"extras\": [\"voice\"],\n            }\n        },\n        \"https://github.com/Rapptz/discord.py/archive/async.zip#egg=discord.py[voice]\",\n    ),\n    (\n        {\n            \"requests\": {\n                \"git\": \"https://github.com/requests/requests.git\",\n                \"ref\": \"master\",\n                \"extras\": [\"security\"],\n                \"editable\": False,\n            }\n        },\n        \"git+https://github.com/requests/requests.git@master#egg=requests[security]\",\n    ),\n]\n\n\ndef mock_unpack(link, source_dir, download_dir, only_download=False, session=None,\n                hashes=None, progress_bar=\"off\"):\n    return\n\n\n@pytest.mark.utils\n@pytest.mark.parametrize(\"deps, expected\", DEP_PIP_PAIRS)\n@pytest.mark.needs_internet\ndef test_convert_deps_to_pip(monkeypatch, deps, expected):\n    with monkeypatch.context() as m:\n        import pip_shims\n        m.setattr(pip_shims.shims, \"unpack_url\", mock_unpack)\n        if expected.startswith(\"Django\"):\n            expected = expected.lower()\n        assert pipenv.utils.convert_deps_to_pip(deps, r=False) == [expected]\n\n\n@pytest.mark.utils\n@pytest.mark.parametrize(\n    \"deps, expected\",\n    [\n        # This one should be collapsed and treated as {'requests': '*'}.\n        ({\"requests\": {}}, \"requests\"),\n        # Hash value should be passed into the result.\n        (\n            {\n                \"FooProject\": {\n                    \"version\": \"==1.2\",\n                    \"hash\": \"sha256:2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n                }\n            },\n            \"FooProject==1.2 --hash=sha256:2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n        ),\n        (\n            {\n                \"FooProject\": {\n                    \"version\": \"==1.2\",\n                    \"extras\": [\"stuff\"],\n                    \"hash\": \"sha256:2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n                }\n            },\n            \"FooProject[stuff]==1.2 --hash=sha256:2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n        ),\n        (\n            {\n                \"requests\": {\n                    \"git\": \"https://github.com/requests/requests.git\",\n                    \"ref\": \"master\",\n                    \"extras\": [\"security\"],\n                }\n            },\n            \"git+https://github.com/requests/requests.git@master#egg=requests[security]\",\n        ),\n    ],\n)\ndef test_convert_deps_to_pip_one_way(deps, expected):\n    assert pipenv.utils.convert_deps_to_pip(deps, r=False) == [expected.lower()]\n\n\n@pytest.mark.skipif(isinstance(\"\", str), reason=\"don't need to test if unicode is str\")\n@pytest.mark.utils\ndef test_convert_deps_to_pip_unicode():\n    deps = {\"django\": \"==1.10\"}\n    deps = pipenv.utils.convert_deps_to_pip(deps, r=False)\n    assert deps[0] == \"django==1.10\"\n\n\n@pytest.mark.parametrize(\"line,result\", [\n    (\"-i https://example.com/simple/\", (\"https://example.com/simple/\", None, None, [])),\n    (\"--extra-index-url=https://example.com/simple/\", (None, \"https://example.com/simple/\", None, [])),\n    (\"--trusted-host=example.com\", (None, None, \"example.com\", [])),\n    (\"# -i https://example.com/simple/\", (None, None, None, [])),\n    (\"requests\", (None, None, None, [\"requests\"]))\n])\n@pytest.mark.utils\ndef test_parse_indexes(line, result):\n    assert pipenv.utils.parse_indexes(line) == result\n\n\n@pytest.mark.parametrize(\"line\", [\n    \"-i https://example.com/simple/ --extra-index-url=https://extra.com/simple/\",\n    \"--extra-index-url https://example.com/simple/ --trusted-host=example.com\",\n    \"requests -i https://example.com/simple/\",\n])\n@pytest.mark.utils\ndef test_parse_indexes_individual_lines(line):\n    with pytest.raises(ValueError):\n        pipenv.utils.parse_indexes(line, strict=True)\n\n\nclass TestUtils:\n    \"\"\"Test utility functions in pipenv\"\"\"\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"version, specified_ver, expected\",\n        [\n            (\"*\", \"*\", True),\n            (\"2.1.6\", \"==2.1.4\", False),\n            (\"20160913\", \">=20140815\", True),\n            (\n                \"1.4\",\n                {\"svn\": \"svn://svn.myproj.org/svn/MyProj\", \"version\": \"==1.4\"},\n                True,\n            ),\n            (\"2.13.0\", {\"extras\": [\"socks\"], \"version\": \"==2.12.4\"}, False),\n        ],\n    )\n    def test_is_required_version(self, version, specified_ver, expected):\n        assert pipenv.utils.is_required_version(version, specified_ver) is expected\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"entry, expected\",\n        [\n            ({\"git\": \"package.git\", \"ref\": \"v0.0.1\"}, True),\n            ({\"hg\": \"https://package.com/package\", \"ref\": \"v1.2.3\"}, True),\n            (\"*\", False),\n            ({\"some_value\": 5, \"other_value\": object()}, False),\n            (\"package\", False),\n            (\"git+https://github.com/requests/requests.git#egg=requests\", True),\n            (\"git+git@github.com:requests/requests.git#egg=requests\", True),\n            (\"gitdb2\", False),\n        ],\n    )\n    @pytest.mark.vcs\n    def test_is_vcs(self, entry, expected):\n        from pipenv.vendor.requirementslib.utils import is_vcs\n        assert is_vcs(entry) is expected\n\n    @pytest.mark.utils\n    def test_python_version_from_bad_path(self):\n        assert pipenv.utils.python_version(\"/fake/path\") is None\n\n    @pytest.mark.utils\n    def test_python_version_from_non_python(self):\n        assert pipenv.utils.python_version(\"/dev/null\") is None\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"version_output, version\",\n        [\n            (\"Python 3.6.2\", \"3.6.2\"),\n            (\"Python 3.6.2 :: Continuum Analytics, Inc.\", \"3.6.2\"),\n            (\"Python 3.6.20 :: Continuum Analytics, Inc.\", \"3.6.20\"),\n            (\n                \"Python 3.5.3 (3f6eaa010fce78cc7973bdc1dfdb95970f08fed2, Jan 13 2018, 18:14:01)\\n[PyPy 5.10.1 with GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]\",\n                \"3.5.3\",\n            ),\n        ],\n    )\n    # @patch(\".vendor.pythonfinder.utils.get_python_version\")\n    def test_python_version_output_variants(\n        self, monkeypatch, version_output, version\n    ):\n        def mock_version(path):\n            return version_output.split()[1]\n        monkeypatch.setattr(\"pipenv.vendor.pythonfinder.utils.get_python_version\", mock_version)\n        assert pipenv.utils.python_version(\"some/path\") == version\n\n    @pytest.mark.utils\n    @pytest.mark.windows\n    @pytest.mark.skipif(os.name != \"nt\", reason=\"Windows test only\")\n    def test_windows_shellquote(self):\n        test_path = r\"C:\\Program Files\\Python36\\python.exe\"\n        expected_path = '\"C:\\\\\\\\Program Files\\\\\\\\Python36\\\\\\\\python.exe\"'\n        assert pipenv.utils.escape_grouped_arguments(test_path) == expected_path\n\n    @pytest.mark.utils\n    def test_is_valid_url(self):\n        url = \"https://github.com/psf/requests.git\"\n        not_url = \"something_else\"\n        assert pipenv.utils.is_valid_url(url)\n        assert pipenv.utils.is_valid_url(not_url) is False\n\n    @pytest.mark.utils\n    @pytest.mark.needs_internet\n    def test_download_file(self):\n        url = \"https://github.com/pypa/pipenv/blob/master/README.md\"\n        output = \"test_download.md\"\n        pipenv.utils.download_file(url, output)\n        assert os.path.exists(output)\n        os.remove(output)\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize('line, expected', [\n        (\"python\", True),\n        (\"python3.7\", True),\n        (\"python2.7\", True),\n        (\"python2\", True),\n        (\"python3\", True),\n        (\"pypy3\", True),\n        (\"anaconda3-5.3.0\", True),\n        (\"which\", False),\n        (\"vim\", False),\n        (\"miniconda\", True),\n        (\"micropython\", True),\n        (\"ironpython\", True),\n        (\"jython3.5\", True),\n        (\"2\", True),\n        (\"2.7\", True),\n        (\"3.7\", True),\n        (\"3\", True)\n    ])\n    def test_is_python_command(self, line, expected):\n        assert pipenv.utils.is_python_command(line) == expected\n\n    @pytest.mark.utils\n    def test_new_line_end_of_toml_file(this):\n        # toml file that needs clean up\n        toml = \"\"\"\n[dev-packages]\n\n\"flake8\" = \">=3.3.0,<4\"\npytest = \"*\"\nmock = \"*\"\nsphinx = \"<=1.5.5\"\n\"-e .\" = \"*\"\ntwine = \"*\"\n\"sphinx-click\" = \"*\"\n\"pytest-xdist\" = \"*\"\n        \"\"\"\n        new_toml = pipenv.utils.cleanup_toml(toml)\n        # testing if the end of the generated file contains a newline\n        assert new_toml[-1] == \"\\n\"\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"input_path, expected\",\n        [\n            (\n                \"c:\\\\Program Files\\\\Python36\\\\python.exe\",\n                \"C:\\\\Program Files\\\\Python36\\\\python.exe\",\n            ),\n            (\n                \"C:\\\\Program Files\\\\Python36\\\\python.exe\",\n                \"C:\\\\Program Files\\\\Python36\\\\python.exe\",\n            ),\n            (\"\\\\\\\\host\\\\share\\\\file.zip\", \"\\\\\\\\host\\\\share\\\\file.zip\"),\n            (\"artifacts\\\\file.zip\", \"artifacts\\\\file.zip\"),\n            (\".\\\\artifacts\\\\file.zip\", \".\\\\artifacts\\\\file.zip\"),\n            (\"..\\\\otherproject\\\\file.zip\", \"..\\\\otherproject\\\\file.zip\"),\n        ],\n    )\n    @pytest.mark.skipif(os.name != \"nt\", reason=\"Windows file paths tested\")\n    def test_win_normalize_drive(self, input_path, expected):\n        assert pipenv.utils.normalize_drive(input_path) == expected\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"input_path, expected\",\n        [\n            (\"/usr/local/bin/python\", \"/usr/local/bin/python\"),\n            (\"artifacts/file.zip\", \"artifacts/file.zip\"),\n            (\"./artifacts/file.zip\", \"./artifacts/file.zip\"),\n            (\"../otherproject/file.zip\", \"../otherproject/file.zip\"),\n        ],\n    )\n    @pytest.mark.skipif(os.name == \"nt\", reason=\"*nix file paths tested\")\n    def test_nix_normalize_drive(self, input_path, expected):\n        assert pipenv.utils.normalize_drive(input_path) == expected\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"sources, expected_args\",\n        [\n            (\n                [{\"url\": \"https://test.example.com/simple\", \"verify_ssl\": True}],\n                [\"-i\", \"https://test.example.com/simple\"],\n            ),\n            (\n                [{\"url\": \"https://test.example.com/simple\", \"verify_ssl\": False}],\n                [\n                    \"-i\",\n                    \"https://test.example.com/simple\",\n                    \"--trusted-host\",\n                    \"test.example.com\",\n                ],\n            ),\n            (\n                [{\"url\": \"https://test.example.com:12345/simple\", \"verify_ssl\": False}],\n                [\n                    \"-i\",\n                    \"https://test.example.com:12345/simple\",\n                    \"--trusted-host\",\n                    \"test.example.com:12345\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\"url\": \"https://custom.example.com/simple\"},\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://custom.example.com/simple\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\"url\": \"https://custom.example.com/simple\", \"verify_ssl\": False},\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://custom.example.com/simple\",\n                    \"--trusted-host\",\n                    \"custom.example.com\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\"url\": \"https://custom.example.com:12345/simple\", \"verify_ssl\": False},\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://custom.example.com:12345/simple\",\n                    \"--trusted-host\",\n                    \"custom.example.com:12345\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\n                        \"url\": \"https://user:password@custom.example.com/simple\",\n                        \"verify_ssl\": False,\n                    },\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://user:password@custom.example.com/simple\",\n                    \"--trusted-host\",\n                    \"custom.example.com\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\"url\": \"https://user:password@custom.example.com/simple\"},\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://user:password@custom.example.com/simple\",\n                ],\n            ),\n            (\n                [\n                    {\n                        \"url\": \"https://user:password@custom.example.com/simple\",\n                        \"verify_ssl\": False,\n                    },\n                ],\n                [\n                    \"-i\",\n                    \"https://user:password@custom.example.com/simple\",\n                    \"--trusted-host\",\n                    \"custom.example.com\",\n                ],\n            ),\n        ],\n    )\n    def test_prepare_pip_source_args(self, sources, expected_args):\n        assert (\n            pipenv.utils.prepare_pip_source_args(sources, pip_args=None)\n            == expected_args\n        )\n\n    @pytest.mark.utils\n    def test_invalid_prepare_pip_source_args(self):\n        sources = [{}]\n        with pytest.raises(PipenvUsageError):\n            pipenv.utils.prepare_pip_source_args(sources, pip_args=None)\n\n    @pytest.mark.utils\n    def test_parse_python_version(self):\n        ver = pipenv.utils.parse_python_version(\"Python 3.6.5\\n\")\n        assert ver == {\"major\": \"3\", \"minor\": \"6\", \"micro\": \"5\"}\n\n    @pytest.mark.utils\n    def test_parse_python_version_suffix(self):\n        ver = pipenv.utils.parse_python_version(\"Python 3.6.5rc1\\n\")\n        assert ver == {\"major\": \"3\", \"minor\": \"6\", \"micro\": \"5\"}\n\n    @pytest.mark.utils\n    def test_parse_python_version_270(self):\n        ver = pipenv.utils.parse_python_version(\"Python 2.7\\n\")\n        assert ver == {\"major\": \"2\", \"minor\": \"7\", \"micro\": \"0\"}\n\n    @pytest.mark.utils\n    def test_parse_python_version_270_garbage(self):\n        ver = pipenv.utils.parse_python_version(\"Python 2.7+\\n\")\n        assert ver == {\"major\": \"2\", \"minor\": \"7\", \"micro\": \"0\"}\n"], "fixing_code": ["import json as simplejson\nimport logging\nimport os\nfrom pathlib import Path\nfrom posixpath import expandvars\nimport sys\nimport time\nimport warnings\n\nimport click\nimport dotenv\nimport pipfile\nimport vistir\n\nfrom pipenv import environments, exceptions, pep508checker, progress\nfrom pipenv._compat import decode_for_output, fix_utf8\nfrom pipenv.patched import crayons\nfrom pipenv.utils import (\n    cmd_list_to_shell, convert_deps_to_pip, create_spinner, download_file,\n    find_python, get_canonical_names, get_host_and_port, get_source_list, is_pinned,\n    is_python_command, is_required_version, is_star, is_valid_url,\n    parse_indexes, pep423_name, prepare_pip_source_args, proper_case,\n    python_version, run_command, subprocess_run, venv_resolve_deps\n)\n\n\nif environments.is_type_checking():\n    from typing import Dict, List, Optional, Union\n\n    from pipenv.project import Project\n    from pipenv.vendor.requirementslib.models.requirements import Requirement\n    TSourceDict = Dict[str, Union[str, bool]]\n\n\n# Packages that should be ignored later.\nBAD_PACKAGES = (\n    \"distribute\",\n    \"packaging\",\n    \"pip\",\n    \"pkg-resources\",\n    \"setuptools\",\n    \"wheel\",\n)\n\nFIRST_PACKAGES = (\"cython\",)\n\nif not environments.PIPENV_HIDE_EMOJIS:\n    now = time.localtime()\n    # Halloween easter-egg.\n    if ((now.tm_mon == 10) and (now.tm_mday == 30)) or (\n        (now.tm_mon == 10) and (now.tm_mday == 31)\n    ):\n        INSTALL_LABEL = \"\ud83c\udf83   \"\n    # Christmas easter-egg.\n    elif ((now.tm_mon == 12) and (now.tm_mday == 24)) or (\n        (now.tm_mon == 12) and (now.tm_mday == 25)\n    ):\n        INSTALL_LABEL = \"\ud83c\udf85   \"\n    else:\n        INSTALL_LABEL = \"\ud83d\udc0d   \"\n    INSTALL_LABEL2 = crayons.normal(\"\u2624  \", bold=True)\n    STARTING_LABEL = \"    \"\nelse:\n    INSTALL_LABEL = \"   \"\n    INSTALL_LABEL2 = \"   \"\n    STARTING_LABEL = \"   \"\n\n# Disable colors, for the color blind and others who do not prefer colors.\nif environments.PIPENV_COLORBLIND:\n    crayons.disable()\n\n\ndef do_clear(project):\n    click.echo(crayons.normal(fix_utf8(\"Clearing caches...\"), bold=True))\n    try:\n        from pip._internal import locations\n    except ImportError:  # pip 9.\n        from pip import locations\n\n    try:\n        vistir.path.rmtree(project.s.PIPENV_CACHE_DIR, onerror=vistir.path.handle_remove_readonly)\n        # Other processes may be writing into this directory simultaneously.\n        vistir.path.rmtree(\n            locations.USER_CACHE_DIR,\n            ignore_errors=environments.PIPENV_IS_CI,\n            onerror=vistir.path.handle_remove_readonly\n        )\n    except OSError as e:\n        # Ignore FileNotFoundError. This is needed for Python 2.7.\n        import errno\n\n        if e.errno == errno.ENOENT:\n            pass\n        raise\n\n\ndef load_dot_env(project, as_dict=False):\n    \"\"\"Loads .env file into sys.environ.\"\"\"\n    if not project.s.PIPENV_DONT_LOAD_ENV:\n        # If the project doesn't exist yet, check current directory for a .env file\n        project_directory = project.project_directory or \".\"\n        dotenv_file = project.s.PIPENV_DOTENV_LOCATION or os.sep.join(\n            [project_directory, \".env\"]\n        )\n\n        if os.path.isfile(dotenv_file):\n            click.echo(\n                crayons.normal(fix_utf8(\"Loading .env environment variables...\"), bold=True),\n                err=True,\n            )\n        else:\n            if project.s.PIPENV_DOTENV_LOCATION:\n                click.echo(\n                    \"{}: file {}={} does not exist!!\\n{}\".format(\n                        crayons.red(\"Warning\", bold=True),\n                        crayons.normal(\"PIPENV_DOTENV_LOCATION\", bold=True),\n                        crayons.normal(project.s.PIPENV_DOTENV_LOCATION, bold=True),\n                        crayons.red(\"Not loading environment variables.\", bold=True),\n                    ),\n                    err=True,\n                )\n        if as_dict:\n            return dotenv.dotenv_values(dotenv_file)\n        else:\n            dotenv.load_dotenv(dotenv_file, override=True)\n            project.s.initialize()\n\n\ndef cleanup_virtualenv(project, bare=True):\n    \"\"\"Removes the virtualenv directory from the system.\"\"\"\n    if not bare:\n        click.echo(crayons.red(\"Environment creation aborted.\"))\n    try:\n        # Delete the virtualenv.\n        vistir.path.rmtree(project.virtualenv_location)\n    except OSError as e:\n        click.echo(\n            \"{} An error occurred while removing {}!\".format(\n                crayons.red(\"Error: \", bold=True),\n                crayons.green(project.virtualenv_location),\n            ),\n            err=True,\n        )\n        click.echo(crayons.cyan(e), err=True)\n\n\ndef import_requirements(project, r=None, dev=False):\n    from pipenv.patched.notpip._vendor import requests as pip_requests\n    from pipenv.patched.notpip._internal.req.constructors import install_req_from_parsed_requirement\n    from pipenv.vendor.pip_shims.shims import parse_requirements\n\n    # Parse requirements.txt file with Pip's parser.\n    # Pip requires a `PipSession` which is a subclass of requests.Session.\n    # Since we're not making any network calls, it's initialized to nothing.\n    if r:\n        assert os.path.isfile(r)\n    # Default path, if none is provided.\n    if r is None:\n        r = project.requirements_location\n    with open(r) as f:\n        contents = f.read()\n    indexes = []\n    trusted_hosts = []\n    # Find and add extra indexes.\n    for line in contents.split(\"\\n\"):\n        index, extra_index, trusted_host, _ = parse_indexes(line.strip(), strict=True)\n        if index:\n            indexes = [index]\n        if extra_index:\n            indexes.append(extra_index)\n        if trusted_host:\n            trusted_hosts.append(get_host_and_port(trusted_host))\n    indexes = sorted(set(indexes))\n    trusted_hosts = sorted(set(trusted_hosts))\n    reqs = [install_req_from_parsed_requirement(f) for f in parse_requirements(r, session=pip_requests)]\n    for package in reqs:\n        if package.name not in BAD_PACKAGES:\n            if package.link is not None:\n                package_string = (\n                    f\"-e {package.link}\"\n                    if package.editable\n                    else str(package.link)\n                )\n                project.add_package_to_pipfile(package_string, dev=dev)\n            else:\n                project.add_package_to_pipfile(str(package.req), dev=dev)\n    for index in indexes:\n        # don't require HTTPS for trusted hosts (see: https://pip.pypa.io/en/stable/cli/pip/#cmdoption-trusted-host)\n        host_and_port = get_host_and_port(index)\n        require_valid_https = not any((v in trusted_hosts for v in (\n            host_and_port,\n            host_and_port.partition(':')[0],  # also check if hostname without port is in trusted_hosts\n        )))\n        project.add_index_to_pipfile(index, verify_ssl=require_valid_https)\n    project.recase_pipfile()\n\n\ndef ensure_environment():\n    # Skip this on Windows...\n    if os.name != \"nt\":\n        if \"LANG\" not in os.environ:\n            click.echo(\n                \"{}: the environment variable {} is not set!\"\n                \"\\nWe recommend setting this in {} (or equivalent) for \"\n                \"proper expected behavior.\".format(\n                    crayons.red(\"Warning\", bold=True),\n                    crayons.normal(\"LANG\", bold=True),\n                    crayons.green(\"~/.profile\"),\n                ),\n                err=True,\n            )\n\n\ndef import_from_code(path=\".\"):\n    from pipreqs import pipreqs\n\n    rs = []\n    try:\n        for r in pipreqs.get_all_imports(\n            path, encoding=\"utf-8\", extra_ignore_dirs=[\".venv\"]\n        ):\n            if r not in BAD_PACKAGES:\n                rs.append(r)\n        pkg_names = pipreqs.get_pkg_names(rs)\n        return [proper_case(r) for r in pkg_names]\n\n    except Exception:\n        return []\n\n\ndef ensure_pipfile(project, validate=True, skip_requirements=False, system=False):\n    \"\"\"Creates a Pipfile for the project, if it doesn't exist.\"\"\"\n\n    # Assert Pipfile exists.\n    python = project._which(\"python\") if not (project.s.USING_DEFAULT_PYTHON or system) else None\n    if project.pipfile_is_empty:\n        # Show an error message and exit if system is passed and no pipfile exists\n        if system and not project.s.PIPENV_VIRTUALENV:\n            raise exceptions.PipenvOptionsError(\n                \"--system\",\n                \"--system is intended to be used for pre-existing Pipfile \"\n                \"installation, not installation of specific packages. Aborting.\"\n            )\n        # If there's a requirements file, but no Pipfile...\n        if project.requirements_exists and not skip_requirements:\n            click.echo(\n                crayons.normal(\n                    fix_utf8(\"requirements.txt found, instead of Pipfile! Converting...\"),\n                    bold=True,\n                )\n            )\n            # Create a Pipfile...\n            project.create_pipfile(python=python)\n            with create_spinner(\"Importing requirements...\", project.s) as sp:\n                # Import requirements.txt.\n                try:\n                    import_requirements(project)\n                except Exception:\n                    sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Failed...\"))\n                else:\n                    sp.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Success!\"))\n            # Warn the user of side-effects.\n            click.echo(\n                \"{0}: Your {1} now contains pinned versions, if your {2} did. \\n\"\n                \"We recommend updating your {1} to specify the {3} version, instead.\"\n                \"\".format(\n                    crayons.red(\"Warning\", bold=True),\n                    crayons.normal(\"Pipfile\", bold=True),\n                    crayons.normal(\"requirements.txt\", bold=True),\n                    crayons.normal('\"*\"', bold=True),\n                )\n            )\n        else:\n            click.echo(\n                crayons.normal(fix_utf8(\"Creating a Pipfile for this project...\"), bold=True),\n                err=True,\n            )\n            # Create the pipfile if it doesn't exist.\n            project.create_pipfile(python=python)\n    # Validate the Pipfile's contents.\n    if validate and project.virtualenv_exists and not project.s.PIPENV_SKIP_VALIDATION:\n        # Ensure that Pipfile is using proper casing.\n        p = project.parsed_pipfile\n        changed = project.ensure_proper_casing()\n        # Write changes out to disk.\n        if changed:\n            click.echo(\n                crayons.normal(\"Fixing package names in Pipfile...\", bold=True), err=True\n            )\n            project.write_toml(p)\n\n\ndef find_a_system_python(line):\n    \"\"\"Find a Python installation from a given line.\n\n    This tries to parse the line in various of ways:\n\n    * Looks like an absolute path? Use it directly.\n    * Looks like a py.exe call? Use py.exe to get the executable.\n    * Starts with \"py\" something? Looks like a python command. Try to find it\n      in PATH, and use it directly.\n    * Search for \"python\" and \"pythonX.Y\" executables in PATH to find a match.\n    * Nothing fits, return None.\n    \"\"\"\n\n    from .vendor.pythonfinder import Finder\n    finder = Finder(system=False, global_search=True)\n    if not line:\n        return next(iter(finder.find_all_python_versions()), None)\n    # Use the windows finder executable\n    if (line.startswith(\"py \") or line.startswith(\"py.exe \")) and os.name == \"nt\":\n        line = line.split(\" \", 1)[1].lstrip(\"-\")\n    python_entry = find_python(finder, line)\n    return python_entry\n\n\ndef ensure_python(project, three=None, python=None):\n    # Runtime import is necessary due to the possibility that the environments module may have been reloaded.\n    if project.s.PIPENV_PYTHON and python is False and three is None:\n        python = project.s.PIPENV_PYTHON\n\n    def abort(msg=''):\n        click.echo(\n            \"{}\\nYou can specify specific versions of Python with:\\n{}\".format(\n                crayons.red(msg),\n                crayons.yellow(\n                    \"$ pipenv --python {}\".format(\n                        os.sep.join((\"path\", \"to\", \"python\"))\n                    )\n                )\n            ),\n            err=True,\n        )\n        sys.exit(1)\n\n    project.s.USING_DEFAULT_PYTHON = three is None and not python\n    # Find out which python is desired.\n    if not python:\n        python = convert_three_to_python(three, python)\n    if not python:\n        python = project.required_python_version\n    if not python:\n        python = project.s.PIPENV_DEFAULT_PYTHON_VERSION\n    path_to_python = find_a_system_python(python)\n    if project.s.is_verbose():\n        click.echo(f\"Using python: {python}\", err=True)\n        click.echo(f\"Path to python: {path_to_python}\", err=True)\n    if not path_to_python and python is not None:\n        # We need to install Python.\n        click.echo(\n            \"{}: Python {} {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                crayons.cyan(python),\n                fix_utf8(\"was not found on your system...\"),\n            ),\n            err=True,\n        )\n        # check for python installers\n        from .installers import Asdf, InstallerError, InstallerNotFound, Pyenv\n\n        # prefer pyenv if both pyenv and asdf are installed as it's\n        # dedicated to python installs so probably the preferred\n        # method of the user for new python installs.\n        installer = None\n        if not project.s.PIPENV_DONT_USE_PYENV:\n            try:\n                installer = Pyenv(project)\n            except InstallerNotFound:\n                pass\n        if installer is None and not project.s.PIPENV_DONT_USE_ASDF:\n            try:\n                installer = Asdf(project)\n            except InstallerNotFound:\n                pass\n\n        if not installer:\n            abort(\"Neither 'pyenv' nor 'asdf' could be found to install Python.\")\n        else:\n            if environments.SESSION_IS_INTERACTIVE or project.s.PIPENV_YES:\n                try:\n                    version = installer.find_version_to_install(python)\n                except ValueError:\n                    abort()\n                except InstallerError as e:\n                    abort(f'Something went wrong while installing Python:\\n{e.err}')\n                s = \"{} {} {}\".format(\n                    \"Would you like us to install\",\n                    crayons.green(f\"CPython {version}\"),\n                    f\"with {installer}?\",\n                )\n                # Prompt the user to continue...\n                if not (project.s.PIPENV_YES or click.confirm(s, default=True)):\n                    abort()\n                else:\n                    # Tell the user we're installing Python.\n                    click.echo(\n                        \"{} {} {} {}{}\".format(\n                            crayons.normal(\"Installing\", bold=True),\n                            crayons.green(f\"CPython {version}\", bold=True),\n                            crayons.normal(f\"with {installer.cmd}\", bold=True),\n                            crayons.normal(\"(this may take a few minutes)\"),\n                            crayons.normal(\"...\", bold=True),\n                        )\n                    )\n                    with create_spinner(\"Installing python...\", project.s) as sp:\n                        try:\n                            c = installer.install(version)\n                        except InstallerError as e:\n                            sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\n                                \"Failed...\")\n                            )\n                            click.echo(fix_utf8(\"Something went wrong...\"), err=True)\n                            click.echo(crayons.cyan(e.err), err=True)\n                        else:\n                            sp.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Success!\"))\n                            # Print the results, in a beautiful blue...\n                            click.echo(crayons.cyan(c.stdout), err=True)\n                            # Clear the pythonfinder caches\n                            from .vendor.pythonfinder import Finder\n                            finder = Finder(system=False, global_search=True)\n                            finder.find_python_version.cache_clear()\n                            finder.find_all_python_versions.cache_clear()\n                    # Find the newly installed Python, hopefully.\n                    version = str(version)\n                    path_to_python = find_a_system_python(version)\n                    try:\n                        assert python_version(path_to_python) == version\n                    except AssertionError:\n                        click.echo(\n                            \"{}: The Python you just installed is not available on your {}, apparently.\"\n                            \"\".format(\n                                crayons.red(\"Warning\", bold=True),\n                                crayons.normal(\"PATH\", bold=True),\n                            ),\n                            err=True,\n                        )\n                        sys.exit(1)\n    return path_to_python\n\n\ndef ensure_virtualenv(project, three=None, python=None, site_packages=None, pypi_mirror=None):\n    \"\"\"Creates a virtualenv, if one doesn't exist.\"\"\"\n\n    def abort():\n        sys.exit(1)\n\n    if not project.virtualenv_exists:\n        try:\n            # Ensure environment variables are set properly.\n            ensure_environment()\n            # Ensure Python is available.\n            python = ensure_python(project, three=three, python=python)\n            if python is not None and not isinstance(python, str):\n                python = python.path.as_posix()\n            # Create the virtualenv.\n            # Abort if --system (or running in a virtualenv).\n            if project.s.PIPENV_USE_SYSTEM:\n                click.echo(\n                    crayons.red(\n                        \"You are attempting to re\u2013create a virtualenv that \"\n                        \"Pipenv did not create. Aborting.\"\n                    )\n                )\n                sys.exit(1)\n            do_create_virtualenv(\n                project, python=python, site_packages=site_packages, pypi_mirror=pypi_mirror\n            )\n        except KeyboardInterrupt:\n            # If interrupted, cleanup the virtualenv.\n            cleanup_virtualenv(project, bare=False)\n            sys.exit(1)\n    # If --three, --two, or --python were passed...\n    elif (python) or (three is not None) or (site_packages is not None):\n        project.s.USING_DEFAULT_PYTHON = False\n        # Ensure python is installed before deleting existing virtual env\n        python = ensure_python(project, three=three, python=python)\n        if python is not None and not isinstance(python, str):\n            python = python.path.as_posix()\n\n        click.echo(crayons.red(\"Virtualenv already exists!\"), err=True)\n        # If VIRTUAL_ENV is set, there is a possibility that we are\n        # going to remove the active virtualenv that the user cares\n        # about, so confirm first.\n        if \"VIRTUAL_ENV\" in os.environ:\n            if not (\n                project.s.PIPENV_YES or click.confirm(\"Remove existing virtualenv?\", default=True)\n            ):\n                abort()\n        click.echo(\n            crayons.normal(fix_utf8(\"Removing existing virtualenv...\"), bold=True), err=True\n        )\n        # Remove the virtualenv.\n        cleanup_virtualenv(project, bare=True)\n        # Call this function again.\n        ensure_virtualenv(\n            project,\n            three=three,\n            python=python,\n            site_packages=site_packages,\n            pypi_mirror=pypi_mirror,\n        )\n\n\ndef ensure_project(\n    project,\n    three=None,\n    python=None,\n    validate=True,\n    system=False,\n    warn=True,\n    site_packages=None,\n    deploy=False,\n    skip_requirements=False,\n    pypi_mirror=None,\n    clear=False,\n):\n    \"\"\"Ensures both Pipfile and virtualenv exist for the project.\"\"\"\n\n    # Automatically use an activated virtualenv.\n    if project.s.PIPENV_USE_SYSTEM:\n        system = True\n    if not project.pipfile_exists and deploy:\n        raise exceptions.PipfileNotFound\n    # Skip virtualenv creation when --system was used.\n    if not system:\n        ensure_virtualenv(\n            project,\n            three=three,\n            python=python,\n            site_packages=site_packages,\n            pypi_mirror=pypi_mirror,\n        )\n        if warn:\n            # Warn users if they are using the wrong version of Python.\n            if project.required_python_version:\n                path_to_python = project._which(\"python\") or project._which(\"py\")\n                if path_to_python and project.required_python_version not in (\n                    python_version(path_to_python) or \"\"\n                ):\n                    click.echo(\n                        \"{}: Your Pipfile requires {} {}, \"\n                        \"but you are using {} ({}).\".format(\n                            crayons.red(\"Warning\", bold=True),\n                            crayons.normal(\"python_version\", bold=True),\n                            crayons.cyan(project.required_python_version),\n                            crayons.cyan(python_version(path_to_python) or \"unknown\"),\n                            crayons.green(shorten_path(path_to_python)),\n                        ),\n                        err=True,\n                    )\n                    click.echo(\n                        \"  {} and rebuilding the virtual environment \"\n                        \"may resolve the issue.\".format(crayons.green(\"$ pipenv --rm\")),\n                        err=True,\n                    )\n                    if not deploy:\n                        click.echo(\n                            \"  {} will surely fail.\"\n                            \"\".format(crayons.yellow(\"$ pipenv check\")),\n                            err=True,\n                        )\n                    else:\n                        raise exceptions.DeployException\n    # Ensure the Pipfile exists.\n    ensure_pipfile(\n        project, validate=validate, skip_requirements=skip_requirements, system=system\n    )\n\n\ndef shorten_path(location, bold=False):\n    \"\"\"Returns a visually shorter representation of a given system path.\"\"\"\n    original = location\n    short = os.sep.join(\n        [s[0] if len(s) > (len(\"2long4\")) else s for s in location.split(os.sep)]\n    )\n    short = short.split(os.sep)\n    short[-1] = original.split(os.sep)[-1]\n    if bold:\n        short[-1] = str(crayons.normal(short[-1], bold=True))\n    return os.sep.join(short)\n\n\n# return short\ndef do_where(project, virtualenv=False, bare=True):\n    \"\"\"Executes the where functionality.\"\"\"\n    if not virtualenv:\n        if not project.pipfile_exists:\n            click.echo(\n                \"No Pipfile present at project home. Consider running \"\n                \"{} first to automatically generate a Pipfile for you.\"\n                \"\".format(crayons.green(\"`pipenv install`\")),\n                err=True,\n            )\n            return\n        location = project.pipfile_location\n        # Shorten the virtual display of the path to the virtualenv.\n        if not bare:\n            location = shorten_path(location)\n            click.echo(\n                \"Pipfile found at {}.\\n  Considering this to be the project home.\"\n                \"\".format(crayons.green(location)),\n                err=True,\n            )\n        else:\n            click.echo(project.project_directory)\n    else:\n        location = project.virtualenv_location\n        if not bare:\n            click.echo(\n                f\"Virtualenv location: {crayons.green(location)}\", err=True\n            )\n        else:\n            click.echo(location)\n\n\ndef _cleanup_procs(project, procs, failed_deps_queue, retry=True):\n    while not procs.empty():\n        c = procs.get()\n        try:\n            out, err = c.communicate()\n        except AttributeError:\n            out, err = c.stdout, c.stderr\n        failed = c.returncode != 0\n        if \"Ignoring\" in out:\n            click.echo(crayons.yellow(out.strip()))\n        elif project.s.is_verbose():\n            click.echo(crayons.cyan(out.strip() or err.strip()))\n        # The Installation failed...\n        if failed:\n            # If there is a mismatch in installed locations or the install fails\n            # due to wrongful disabling of pep517, we should allow for\n            # additional passes at installation\n            if \"does not match installed location\" in err:\n                project.environment.expand_egg_links()\n                click.echo(\"{}\".format(\n                    crayons.yellow(\n                        \"Failed initial installation: Failed to overwrite existing \"\n                        \"package, likely due to path aliasing. Expanding and trying \"\n                        \"again!\"\n                    )\n                ))\n                dep = c.dep.copy()\n                dep.use_pep517 = True\n            elif \"Disabling PEP 517 processing is invalid\" in err:\n                dep = c.dep.copy()\n                dep.use_pep517 = True\n            elif not retry:\n                # The Installation failed...\n                # We echo both c.stdout and c.stderr because pip returns error details on out.\n                err = err.strip().splitlines() if err else []\n                out = out.strip().splitlines() if out else []\n                err_lines = [line for message in [out, err] for line in message]\n                # Return the subprocess' return code.\n                raise exceptions.InstallError(c.dep.name, extra=err_lines)\n            else:\n                # Alert the user.\n                dep = c.dep.copy()\n                dep.use_pep517 = False\n                click.echo(\n                    \"{} {}! Will try again.\".format(\n                        crayons.red(\"An error occurred while installing\"),\n                        crayons.green(dep.as_line()),\n                    ), err=True\n                )\n            # Save the Failed Dependency for later.\n            failed_deps_queue.put(dep)\n\n\ndef batch_install(project, deps_list, procs, failed_deps_queue,\n                  requirements_dir, no_deps=True, ignore_hashes=False,\n                  allow_global=False, blocking=False, pypi_mirror=None,\n                  retry=True, sequential_deps=None):\n    from .vendor.requirementslib.models.utils import (\n        strip_extras_markers_from_requirement\n    )\n    if sequential_deps is None:\n        sequential_deps = []\n    failed = (not retry)\n    install_deps = not no_deps\n    if not failed:\n        label = INSTALL_LABEL if not environments.PIPENV_HIDE_EMOJIS else \"\"\n    else:\n        label = INSTALL_LABEL2\n\n    deps_to_install = deps_list[:]\n    deps_to_install.extend(sequential_deps)\n    deps_to_install = [\n        dep for dep in deps_to_install if not project.environment.is_satisfied(dep)\n    ]\n    sequential_dep_names = [d.name for d in sequential_deps]\n\n    deps_list_bar = progress.bar(\n        deps_to_install, width=32,\n        label=label\n    )\n\n    trusted_hosts = []\n    # Install these because\n    for dep in deps_list_bar:\n        extra_indexes = []\n        if dep.req.req:\n            dep.req.req = strip_extras_markers_from_requirement(dep.req.req)\n        if dep.markers:\n            dep.markers = str(strip_extras_markers_from_requirement(dep.get_markers()))\n        # Install the module.\n        is_artifact = False\n        if dep.is_file_or_url and (dep.is_direct_url or any(\n            dep.req.uri.endswith(ext) for ext in [\"zip\", \"tar.gz\"]\n        )):\n            is_artifact = True\n        elif dep.is_vcs:\n            is_artifact = True\n        if not project.s.PIPENV_RESOLVE_VCS and is_artifact and not dep.editable:\n            install_deps = True\n            no_deps = False\n\n        with vistir.contextmanagers.temp_environ():\n            if not allow_global:\n                os.environ[\"PIP_USER\"] = vistir.compat.fs_str(\"0\")\n                if \"PYTHONHOME\" in os.environ:\n                    del os.environ[\"PYTHONHOME\"]\n            if \"GIT_CONFIG\" in os.environ and dep.is_vcs:\n                del os.environ[\"GIT_CONFIG\"]\n            use_pep517 = True\n            if failed and not dep.is_vcs:\n                use_pep517 = getattr(dep, \"use_pep517\", False)\n\n            is_sequential = sequential_deps and dep.name in sequential_dep_names\n            is_blocking = any([dep.editable, dep.is_vcs, blocking, is_sequential])\n            c = pip_install(\n                project,\n                dep,\n                ignore_hashes=any([ignore_hashes, dep.editable, dep.is_vcs]),\n                allow_global=allow_global,\n                no_deps=not install_deps,\n                block=is_blocking,\n                index=dep.index,\n                requirements_dir=requirements_dir,\n                pypi_mirror=pypi_mirror,\n                trusted_hosts=trusted_hosts,\n                extra_indexes=extra_indexes,\n                use_pep517=use_pep517,\n            )\n            c.dep = dep\n\n            procs.put(c)\n            if procs.full() or procs.qsize() == len(deps_list) or is_sequential:\n                _cleanup_procs(project, procs, failed_deps_queue, retry=retry)\n\n\ndef do_install_dependencies(\n    project,\n    dev=False,\n    dev_only=False,\n    bare=False,\n    emit_requirements=False,\n    allow_global=False,\n    ignore_hashes=False,\n    skip_lock=False,\n    concurrent=True,\n    requirements_dir=None,\n    pypi_mirror=None,\n):\n    \"\"\"\"\n    Executes the install functionality.\n\n    If emit_requirements is True, simply spits out a requirements format to stdout.\n    \"\"\"\n\n    import queue\n    if emit_requirements:\n        bare = True\n    # Load the lockfile if it exists, or if dev_only is being used.\n    if skip_lock or not project.lockfile_exists:\n        if not bare:\n            click.echo(\n                crayons.normal(fix_utf8(\"Installing dependencies from Pipfile...\"), bold=True)\n            )\n        # skip_lock should completely bypass the lockfile (broken in 4dac1676)\n        lockfile = project.get_or_create_lockfile(from_pipfile=True)\n    else:\n        lockfile = project.get_or_create_lockfile()\n        if not bare:\n            click.echo(\n                crayons.normal(\n                    fix_utf8(\"Installing dependencies from Pipfile.lock ({})...\".format(\n                        lockfile[\"_meta\"].get(\"hash\", {}).get(\"sha256\")[-6:]\n                    )),\n                    bold=True,\n                )\n            )\n    # Allow pip to resolve dependencies when in skip-lock mode.\n    no_deps = not skip_lock  # skip_lock true, no_deps False, pip resolves deps\n    dev = dev or dev_only\n    deps_list = list(lockfile.get_requirements(dev=dev, only=dev_only))\n    if emit_requirements:\n        index_args = prepare_pip_source_args(\n            get_source_list(project, pypi_mirror=pypi_mirror)\n        )\n        index_args = \" \".join(index_args).replace(\" -\", \"\\n-\")\n        deps = [\n            req.as_line(sources=False, include_hashes=False) for req in deps_list\n        ]\n        click.echo(index_args)\n        click.echo(\"\\n\".join(sorted(deps)))\n        sys.exit(0)\n    if concurrent:\n        nprocs = project.s.PIPENV_MAX_SUBPROCESS\n    else:\n        nprocs = 1\n    procs = queue.Queue(maxsize=nprocs)\n    failed_deps_queue = queue.Queue()\n    if skip_lock:\n        ignore_hashes = True\n    editable_or_vcs_deps = [dep for dep in deps_list if (dep.editable or dep.vcs)]\n    normal_deps = [dep for dep in deps_list if not (dep.editable or dep.vcs)]\n    install_kwargs = {\n        \"no_deps\": no_deps, \"ignore_hashes\": ignore_hashes, \"allow_global\": allow_global,\n        \"blocking\": not concurrent, \"pypi_mirror\": pypi_mirror,\n        \"sequential_deps\": editable_or_vcs_deps\n    }\n\n    batch_install(\n        project, normal_deps, procs, failed_deps_queue, requirements_dir, **install_kwargs\n    )\n\n    if not procs.empty():\n        _cleanup_procs(project, procs, failed_deps_queue)\n\n    # click.echo(crayons.normal(\n    #     decode_for_output(\"Installing editable and vcs dependencies...\"), bold=True\n    # ))\n\n    # install_kwargs.update({\"blocking\": True})\n    # # XXX: All failed and editable/vcs deps should be installed in sequential mode!\n    # procs = queue.Queue(maxsize=1)\n    # batch_install(\n    #     editable_or_vcs_deps, procs, failed_deps_queue, requirements_dir,\n    #     **install_kwargs\n    # )\n\n    # Iterate over the hopefully-poorly-packaged dependencies...\n    if not failed_deps_queue.empty():\n        click.echo(\n            crayons.normal(fix_utf8(\"Installing initially failed dependencies...\"), bold=True)\n        )\n        retry_list = []\n        while not failed_deps_queue.empty():\n            failed_dep = failed_deps_queue.get()\n            retry_list.append(failed_dep)\n        install_kwargs.update({\"retry\": False})\n        batch_install(\n            project, retry_list, procs, failed_deps_queue, requirements_dir, **install_kwargs\n        )\n    if not procs.empty():\n        _cleanup_procs(project, procs, failed_deps_queue, retry=False)\n\n\ndef convert_three_to_python(three, python):\n    \"\"\"Converts a Three flag into a Python flag, and raises customer warnings\n    in the process, if needed.\n    \"\"\"\n    if not python:\n        if three is False:\n            return \"2\"\n\n        elif three is True:\n            return \"3\"\n\n    else:\n        return python\n\n\ndef do_create_virtualenv(project, python=None, site_packages=None, pypi_mirror=None):\n    \"\"\"Creates a virtualenv.\"\"\"\n\n    click.echo(\n        crayons.normal(fix_utf8(\"Creating a virtualenv for this project...\"), bold=True), err=True\n    )\n    click.echo(\n        f\"Pipfile: {crayons.yellow(project.pipfile_location, bold=True)}\",\n        err=True,\n    )\n\n    # Default to using sys.executable, if Python wasn't provided.\n    using_string = \"Using\"\n    if not python:\n        python = sys.executable\n        using_string = \"Using default python from\"\n    click.echo(\n        \"{0} {1} {3} {2}\".format(\n            crayons.normal(using_string, bold=True),\n            crayons.yellow(python, bold=True),\n            crayons.normal(fix_utf8(\"to create virtualenv...\"), bold=True),\n            crayons.green(f\"({python_version(python)})\"),\n        ),\n        err=True,\n    )\n\n    cmd = [\n        Path(sys.executable).absolute().as_posix(),\n        \"-m\",\n        \"virtualenv\",\n        f\"--prompt={project.name}\",\n        f\"--python={python}\",\n        project.get_location_for_virtualenv(),\n    ]\n\n    # Pass site-packages flag to virtualenv, if desired...\n    if site_packages:\n        click.echo(\n            crayons.normal(fix_utf8(\"Making site-packages available...\"), bold=True), err=True\n        )\n        cmd.append(\"--system-site-packages\")\n\n    if pypi_mirror:\n        pip_config = {\"PIP_INDEX_URL\": vistir.misc.fs_str(pypi_mirror)}\n    else:\n        pip_config = {}\n\n    # Actually create the virtualenv.\n    error = None\n    with create_spinner(\"Creating virtual environment...\", project.s) as sp:\n        c = subprocess_run(cmd, env=pip_config)\n        click.echo(crayons.cyan(f\"{c.stdout}\"), err=True)\n        if c.returncode != 0:\n            error = c.stderr if project.s.is_verbose() else exceptions.prettify_exc(c.stderr)\n            sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Failed creating virtual environment\"))\n        else:\n            sp.green.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Successfully created virtual environment!\"))\n    if error is not None:\n        raise exceptions.VirtualenvCreationException(\n            extra=crayons.red(f\"{error}\")\n        )\n\n    # Associate project directory with the environment.\n    # This mimics Pew's \"setproject\".\n    project_file_name = os.path.join(project.virtualenv_location, \".project\")\n    with open(project_file_name, \"w\") as f:\n        f.write(vistir.misc.fs_str(project.project_directory))\n    from .environment import Environment\n    sources = project.pipfile_sources\n    # project.get_location_for_virtualenv is only for if we are creating a new virtualenv\n    # whereas virtualenv_location is for the current path to the runtime\n    project._environment = Environment(\n        prefix=project.virtualenv_location,\n        is_venv=True,\n        sources=sources,\n        pipfile=project.parsed_pipfile,\n        project=project\n    )\n    project._environment.add_dist(\"pipenv\")\n    # Say where the virtualenv is.\n    do_where(project, virtualenv=True, bare=False)\n\n\ndef parse_download_fname(fname, name):\n    fname, fextension = os.path.splitext(fname)\n    if fextension == \".whl\":\n        fname = \"-\".join(fname.split(\"-\")[:-3])\n    if fname.endswith(\".tar\"):\n        fname, _ = os.path.splitext(fname)\n    # Substring out package name (plus dash) from file name to get version.\n    version = fname[len(name) + 1 :]\n    # Ignore implicit post releases in version number.\n    if \"-\" in version and version.split(\"-\")[1].isdigit():\n        version = version.split(\"-\")[0]\n    return version\n\n\ndef get_downloads_info(project, names_map, section):\n    from .vendor.requirementslib.models.requirements import Requirement\n\n    info = []\n    p = project.parsed_pipfile\n    for fname in os.listdir(project.download_location):\n        # Get name from filename mapping.\n        name = Requirement.from_line(names_map[fname]).name\n        # Get the version info from the filenames.\n        version = parse_download_fname(fname, name)\n        # Get the hash of each file.\n        cmd = [\n            which_pip(project),\n            \"hash\",\n            os.sep.join([project.download_location, fname]),\n        ]\n        c = subprocess_run(cmd)\n        hash = c.stdout.split(\"--hash=\")[1].strip()\n        # Verify we're adding the correct version from Pipfile\n        # and not one from a dependency.\n        specified_version = p[section].get(name, \"\")\n        if is_required_version(version, specified_version):\n            info.append(dict(name=name, version=version, hash=hash))\n    return info\n\n\ndef overwrite_dev(prod, dev):\n    dev_keys = set(list(dev.keys()))\n    prod_keys = set(list(prod.keys()))\n    for pkg in dev_keys & prod_keys:\n        dev[pkg] = prod[pkg]\n    return dev\n\n\ndef do_lock(\n    project,\n    ctx=None,\n    system=False,\n    clear=False,\n    pre=False,\n    keep_outdated=False,\n    write=True,\n    pypi_mirror=None,\n):\n    \"\"\"Executes the freeze functionality.\"\"\"\n\n    cached_lockfile = {}\n    if not pre:\n        pre = project.settings.get(\"allow_prereleases\")\n    if keep_outdated:\n        if not project.lockfile_exists:\n            raise exceptions.PipenvOptionsError(\n                \"--keep-outdated\", ctx=ctx,\n                message=\"Pipfile.lock must exist to use --keep-outdated!\"\n            )\n        cached_lockfile = project.lockfile_content\n    # Create the lockfile.\n    lockfile = project._lockfile\n    # Cleanup lockfile.\n    for section in (\"default\", \"develop\"):\n        for k, v in lockfile[section].copy().items():\n            if not hasattr(v, \"keys\"):\n                del lockfile[section][k]\n    # Ensure that develop inherits from default.\n    dev_packages = project.dev_packages.copy()\n    dev_packages = overwrite_dev(project.packages, dev_packages)\n    # Resolve dev-package dependencies, with pip-tools.\n    for is_dev in [True, False]:\n        pipfile_section = \"dev-packages\" if is_dev else \"packages\"\n        if project.pipfile_exists:\n            packages = project.parsed_pipfile.get(pipfile_section, {})\n        else:\n            packages = getattr(project, pipfile_section.replace(\"-\", \"_\"))\n\n        if write:\n            # Alert the user of progress.\n            click.echo(\n                \"{} {} {}\".format(\n                    crayons.normal(\"Locking\"),\n                    crayons.yellow(\"[{}]\".format(pipfile_section.replace(\"_\", \"-\"))),\n                    crayons.normal(fix_utf8(\"dependencies...\")),\n                ),\n                err=True,\n            )\n\n        # Mutates the lockfile\n        venv_resolve_deps(\n            packages,\n            which=project._which,\n            project=project,\n            dev=is_dev,\n            clear=clear,\n            pre=pre,\n            allow_global=system,\n            pypi_mirror=pypi_mirror,\n            pipfile=packages,\n            lockfile=lockfile,\n            keep_outdated=keep_outdated\n        )\n\n    # Support for --keep-outdated...\n    if keep_outdated:\n        from pipenv.vendor.packaging.utils import canonicalize_name\n        for section_name, section in (\n            (\"default\", project.packages),\n            (\"develop\", project.dev_packages),\n        ):\n            for package_specified in section.keys():\n                if not is_pinned(section[package_specified]):\n                    canonical_name = canonicalize_name(package_specified)\n                    if canonical_name in cached_lockfile[section_name]:\n                        lockfile[section_name][canonical_name] = cached_lockfile[\n                            section_name\n                        ][canonical_name].copy()\n            for key in [\"default\", \"develop\"]:\n                packages = set(cached_lockfile[key].keys())\n                new_lockfile = set(lockfile[key].keys())\n                missing = packages - new_lockfile\n                for missing_pkg in missing:\n                    lockfile[key][missing_pkg] = cached_lockfile[key][missing_pkg].copy()\n    # Overwrite any develop packages with default packages.\n    lockfile[\"develop\"].update(overwrite_dev(lockfile.get(\"default\", {}), lockfile[\"develop\"]))\n    if write:\n        project.write_lockfile(lockfile)\n        click.echo(\n            \"{}\".format(\n                crayons.normal(\n                    \"Updated Pipfile.lock ({})!\".format(\n                        lockfile[\"_meta\"].get(\"hash\", {}).get(\"sha256\")[-6:]\n                    ),\n                    bold=True,\n                )\n            ),\n            err=True,\n        )\n    else:\n        return lockfile\n\n\ndef do_purge(project, bare=False, downloads=False, allow_global=False):\n    \"\"\"Executes the purge functionality.\"\"\"\n\n    if downloads:\n        if not bare:\n            click.echo(crayons.normal(fix_utf8(\"Clearing out downloads directory...\"), bold=True))\n        vistir.path.rmtree(project.download_location)\n        return\n\n    # Remove comments from the output, if any.\n    installed = {\n        pep423_name(pkg.project_name) for pkg in project.environment.get_installed_packages()\n    }\n    bad_pkgs = {pep423_name(pkg) for pkg in BAD_PACKAGES}\n    # Remove setuptools, pip, etc from targets for removal\n    to_remove = installed - bad_pkgs\n\n    # Skip purging if there is no packages which needs to be removed\n    if not to_remove:\n        if not bare:\n            click.echo(\"Found 0 installed package, skip purging.\")\n            click.echo(crayons.green(\"Environment now purged and fresh!\"))\n        return installed\n\n    if not bare:\n        click.echo(\n            fix_utf8(f\"Found {len(to_remove)} installed package(s), purging...\")\n        )\n\n    command = [\n        which_pip(project, allow_global=allow_global),\n        \"uninstall\", \"-y\",\n    ] + list(to_remove)\n    if project.s.is_verbose():\n        click.echo(f\"$ {cmd_list_to_shell(command)}\")\n    c = subprocess_run(command)\n    if c.returncode != 0:\n        raise exceptions.UninstallError(installed, cmd_list_to_shell(command), c.stdout + c.stderr, c.returncode)\n    if not bare:\n        click.echo(crayons.cyan(c.stdout))\n        click.echo(crayons.green(\"Environment now purged and fresh!\"))\n    return installed\n\n\ndef do_init(\n    project,\n    dev=False,\n    dev_only=False,\n    emit_requirements=False,\n    allow_global=False,\n    ignore_pipfile=False,\n    skip_lock=False,\n    system=False,\n    concurrent=True,\n    deploy=False,\n    pre=False,\n    keep_outdated=False,\n    requirements_dir=None,\n    pypi_mirror=None,\n):\n    \"\"\"Executes the init functionality.\"\"\"\n\n    python = None\n    if project.s.PIPENV_PYTHON is not None:\n        python = project.s.PIPENV_PYTHON\n    elif project.s.PIPENV_DEFAULT_PYTHON_VERSION is not None:\n        python = project.s.PIPENV_DEFAULT_PYTHON_VERSION\n\n    if not system and not project.s.PIPENV_USE_SYSTEM:\n        if not project.virtualenv_exists:\n            try:\n                do_create_virtualenv(project, python=python, three=None, pypi_mirror=pypi_mirror)\n            except KeyboardInterrupt:\n                cleanup_virtualenv(project, bare=False)\n                sys.exit(1)\n    # Ensure the Pipfile exists.\n    if not deploy:\n        ensure_pipfile(project, system=system)\n    if not requirements_dir:\n        requirements_dir = vistir.path.create_tracked_tempdir(\n            suffix=\"-requirements\", prefix=\"pipenv-\"\n        )\n    # Write out the lockfile if it doesn't exist, but not if the Pipfile is being ignored\n    if (project.lockfile_exists and not ignore_pipfile) and not skip_lock:\n        old_hash = project.get_lockfile_hash()\n        new_hash = project.calculate_pipfile_hash()\n        if new_hash != old_hash:\n            if deploy:\n                click.echo(\n                    crayons.red(\n                        \"Your Pipfile.lock ({}) is out of date. Expected: ({}).\".format(\n                            old_hash[-6:], new_hash[-6:]\n                        )\n                    )\n                )\n                raise exceptions.DeployException\n                sys.exit(1)\n            elif (system or allow_global) and not (project.s.PIPENV_VIRTUALENV):\n                click.echo(\n                    crayons.yellow(fix_utf8(\n                        \"Pipfile.lock ({}) out of date, but installation \"\n                        \"uses {} re-building lockfile must happen in \"\n                        \"isolation. Please rebuild lockfile in a virtualenv. \"\n                        \"Continuing anyway...\".format(\n                            old_hash[-6:], \"--system\"\n                        ))\n                    ),\n                    err=True,\n                )\n            else:\n                if old_hash:\n                    msg = fix_utf8(\"Pipfile.lock ({0}) out of date, updating to ({1})...\")\n                else:\n                    msg = fix_utf8(\"Pipfile.lock is corrupted, replaced with ({1})...\")\n                click.echo(\n                    crayons.yellow(msg.format(old_hash[-6:], new_hash[-6:]), bold=True),\n                    err=True,\n                )\n                do_lock(\n                    project,\n                    system=system,\n                    pre=pre,\n                    keep_outdated=keep_outdated,\n                    write=True,\n                    pypi_mirror=pypi_mirror,\n                )\n    # Write out the lockfile if it doesn't exist.\n    if not project.lockfile_exists and not skip_lock:\n        # Unless we're in a virtualenv not managed by pipenv, abort if we're\n        # using the system's python.\n        if (system or allow_global) and not (project.s.PIPENV_VIRTUALENV):\n            raise exceptions.PipenvOptionsError(\n                \"--system\",\n                \"--system is intended to be used for Pipfile installation, \"\n                \"not installation of specific packages. Aborting.\\n\"\n                \"See also: --deploy flag.\"\n            )\n        else:\n            click.echo(\n                crayons.normal(fix_utf8(\"Pipfile.lock not found, creating...\"), bold=True),\n                err=True,\n            )\n            do_lock(\n                project,\n                system=system,\n                pre=pre,\n                keep_outdated=keep_outdated,\n                write=True,\n                pypi_mirror=pypi_mirror,\n            )\n    do_install_dependencies(\n        project,\n        dev=dev,\n        dev_only=dev_only,\n        emit_requirements=emit_requirements,\n        allow_global=allow_global,\n        skip_lock=skip_lock,\n        concurrent=concurrent,\n        requirements_dir=requirements_dir,\n        pypi_mirror=pypi_mirror,\n    )\n\n    # Hint the user what to do to activate the virtualenv.\n    if not allow_global and not deploy and \"PIPENV_ACTIVE\" not in os.environ:\n        click.echo(\n            \"To activate this project's virtualenv, run {}.\\n\"\n            \"Alternatively, run a command \"\n            \"inside the virtualenv with {}.\".format(\n                crayons.yellow(\"pipenv shell\"), crayons.yellow(\"pipenv run\")\n            )\n        )\n\n\ndef get_pip_args(\n    project,\n    pre=False,  # type: bool\n    verbose=False,  # type: bool\n    upgrade=False,  # type: bool\n    require_hashes=False,  # type: bool\n    no_build_isolation=False,  # type: bool\n    no_use_pep517=False,  # type: bool\n    no_deps=False,  # type: bool\n    selective_upgrade=False,  # type: bool\n    src_dir=None,  # type: Optional[str]\n):\n    # type: (...) -> List[str]\n    from .vendor.packaging.version import parse as parse_version\n    arg_map = {\n        \"pre\": [\"--pre\"],\n        \"verbose\": [\"--verbose\"],\n        \"upgrade\": [\"--upgrade\"],\n        \"require_hashes\": [\"--require-hashes\"],\n        \"no_build_isolation\": [\"--no-build-isolation\"],\n        \"no_use_pep517\": [],\n        \"no_deps\": [\"--no-deps\"],\n        \"selective_upgrade\": [\n            \"--upgrade-strategy=only-if-needed\",\n            \"--exists-action={}\".format(project.s.PIP_EXISTS_ACTION or \"i\")\n        ],\n        \"src_dir\": src_dir,\n    }\n    if project.environment.pip_version >= parse_version(\"19.0\"):\n        arg_map[\"no_use_pep517\"].append(\"--no-use-pep517\")\n    if project.environment.pip_version < parse_version(\"19.1\"):\n        arg_map[\"no_use_pep517\"].append(\"--no-build-isolation\")\n    arg_set = []\n    for key in arg_map.keys():\n        if key in locals() and locals().get(key):\n            arg_set.extend(arg_map.get(key))\n        elif key == \"selective_upgrade\" and not locals().get(key):\n            arg_set.append(\"--exists-action=i\")\n    return list(vistir.misc.dedup(arg_set))\n\n\ndef get_requirement_line(\n    requirement,  # type: Requirement\n    src_dir=None,  # type: Optional[str]\n    include_hashes=True,  # type: bool\n    format_for_file=False,  # type: bool\n):\n    # type: (...) -> Union[List[str], str]\n    line = None\n    if requirement.vcs or requirement.is_file_or_url:\n        if src_dir and requirement.line_instance.wheel_kwargs:\n            requirement.line_instance._wheel_kwargs.update({\n                \"src_dir\": src_dir\n            })\n        requirement.line_instance.vcsrepo\n        line = requirement.line_instance.line\n        if requirement.line_instance.markers:\n            line = f'{line}; {requirement.line_instance.markers}'\n            if not format_for_file:\n                line = f'\"{line}\"'\n        if requirement.editable:\n            if not format_for_file:\n                return [\"-e\", line]\n            return f'-e {line}'\n        if not format_for_file:\n            return [line]\n        return line\n    return requirement.as_line(include_hashes=include_hashes, as_list=not format_for_file)\n\n\ndef write_requirement_to_file(\n    project,  # type: Project\n    requirement,  # type: Requirement\n    requirements_dir=None,  # type: Optional[str]\n    src_dir=None,  # type: Optional[str]\n    include_hashes=True  # type: bool\n):\n    # type: (...) -> str\n    if not requirements_dir:\n        requirements_dir = vistir.path.create_tracked_tempdir(\n            prefix=\"pipenv\", suffix=\"requirements\")\n    line = requirement.line_instance.get_line(\n        with_prefix=True, with_hashes=include_hashes, with_markers=True, as_list=False\n    )\n\n    f = vistir.compat.NamedTemporaryFile(\n        prefix=\"pipenv-\", suffix=\"-requirement.txt\", dir=requirements_dir,\n        delete=False\n    )\n    if project.s.is_verbose():\n        click.echo(\n            f\"Writing supplied requirement line to temporary file: {line!r}\",\n            err=True\n        )\n    f.write(vistir.misc.to_bytes(line))\n    r = f.name\n    f.close()\n    return r\n\n\ndef pip_install(\n    project,\n    requirement=None,\n    r=None,\n    allow_global=False,\n    ignore_hashes=False,\n    no_deps=None,\n    block=True,\n    index=None,\n    pre=False,\n    selective_upgrade=False,\n    requirements_dir=None,\n    extra_indexes=None,\n    pypi_mirror=None,\n    trusted_hosts=None,\n    use_pep517=True\n):\n    piplogger = logging.getLogger(\"pipenv.patched.notpip._internal.commands.install\")\n    src_dir = None\n    if not trusted_hosts:\n        trusted_hosts = []\n\n    trusted_hosts.extend(os.environ.get(\"PIP_TRUSTED_HOSTS\", []))\n    if not allow_global:\n        src_dir = os.getenv(\"PIP_SRC\", os.getenv(\"PIP_SRC_DIR\", project.virtualenv_src_location))\n    else:\n        src_dir = os.getenv(\"PIP_SRC\", os.getenv(\"PIP_SRC_DIR\"))\n    if requirement:\n        if requirement.editable or not requirement.hashes:\n            ignore_hashes = True\n        elif not (requirement.is_vcs or requirement.editable or requirement.vcs):\n            ignore_hashes = False\n    line = None\n    # Try installing for each source in project.sources.\n    if not index and requirement.index:\n        index = requirement.index\n    if index and not extra_indexes:\n        extra_indexes = list(project.sources)\n    if requirement and requirement.vcs or requirement.editable:\n        requirement.index = None\n        # Install dependencies when a package is a non-editable VCS dependency.\n        # Don't specify a source directory when using --system.\n        if not requirement.editable and no_deps is not True:\n            # Leave this off becauase old lockfiles don't have all deps included\n            # TODO: When can it be turned back on?\n            no_deps = False\n        elif requirement.editable and no_deps is None:\n            no_deps = True\n\n    r = write_requirement_to_file(\n        project, requirement, requirements_dir=requirements_dir, src_dir=src_dir,\n        include_hashes=not ignore_hashes\n    )\n    sources = get_source_list(\n        project, index, extra_indexes=extra_indexes, trusted_hosts=trusted_hosts,\n        pypi_mirror=pypi_mirror\n    )\n    if r:\n        with open(r, \"r\") as fh:\n            if \"--hash\" not in fh.read():\n                ignore_hashes = True\n    if project.s.is_verbose():\n        piplogger.setLevel(logging.WARN)\n        if requirement:\n            click.echo(\n                crayons.normal(f\"Installing {requirement.name!r}\", bold=True),\n                err=True,\n            )\n\n    pip_command = [project._which(\"python\", allow_global=allow_global), \"-m\", \"pip\", \"install\"]\n    pip_args = get_pip_args(\n        project, pre=pre, verbose=project.s.is_verbose(), upgrade=True,\n        selective_upgrade=selective_upgrade, no_use_pep517=not use_pep517,\n        no_deps=no_deps, require_hashes=not ignore_hashes,\n    )\n    pip_command.extend(pip_args)\n    if r:\n        pip_command.extend([\"-r\", vistir.path.normalize_path(r)])\n    elif line:\n        pip_command.extend(line)\n    pip_command.extend(prepare_pip_source_args(sources))\n    if project.s.is_verbose():\n        click.echo(f\"$ {cmd_list_to_shell(pip_command)}\", err=True)\n    cache_dir = Path(project.s.PIPENV_CACHE_DIR)\n    DEFAULT_EXISTS_ACTION = \"w\"\n    if selective_upgrade:\n        DEFAULT_EXISTS_ACTION = \"i\"\n    exists_action = vistir.misc.fs_str(project.s.PIP_EXISTS_ACTION or DEFAULT_EXISTS_ACTION)\n    pip_config = {\n        \"PIP_CACHE_DIR\": vistir.misc.fs_str(cache_dir.as_posix()),\n        \"PIP_WHEEL_DIR\": vistir.misc.fs_str(cache_dir.joinpath(\"wheels\").as_posix()),\n        \"PIP_DESTINATION_DIR\": vistir.misc.fs_str(\n            cache_dir.joinpath(\"pkgs\").as_posix()\n        ),\n        \"PIP_EXISTS_ACTION\": exists_action,\n        \"PATH\": vistir.misc.fs_str(os.environ.get(\"PATH\")),\n    }\n    if src_dir:\n        if project.s.is_verbose():\n            click.echo(f\"Using source directory: {src_dir!r}\", err=True)\n        pip_config.update(\n            {\"PIP_SRC\": vistir.misc.fs_str(src_dir)}\n        )\n    c = subprocess_run(pip_command, block=block, env=pip_config)\n    c.env = pip_config\n    return c\n\n\ndef pip_download(project, package_name):\n    cache_dir = Path(project.s.PIPENV_CACHE_DIR)\n    pip_config = {\n        \"PIP_CACHE_DIR\": vistir.misc.fs_str(cache_dir.as_posix()),\n        \"PIP_WHEEL_DIR\": vistir.misc.fs_str(cache_dir.joinpath(\"wheels\").as_posix()),\n        \"PIP_DESTINATION_DIR\": vistir.misc.fs_str(\n            cache_dir.joinpath(\"pkgs\").as_posix()\n        ),\n    }\n    for source in project.sources:\n        cmd = [\n            which_pip(project),\n            \"download\",\n            package_name,\n            \"-i\", source[\"url\"],\n            \"-d\", project.download_location,\n        ]\n        c = subprocess_run(cmd, env=pip_config)\n        if c.returncode == 0:\n            break\n\n    return c\n\n\ndef fallback_which(command, location=None, allow_global=False, system=False):\n    \"\"\"\n    A fallback implementation of the `which` utility command that relies exclusively on\n    searching the path for commands.\n\n    :param str command: The command to search for, optional\n    :param str location: The search location to prioritize (prepend to path), defaults to None\n    :param bool allow_global: Whether to search the global path, defaults to False\n    :param bool system: Whether to use the system python instead of pipenv's python, defaults to False\n    :raises ValueError: Raised if no command is provided\n    :raises TypeError: Raised if the command provided is not a string\n    :return: A path to the discovered command location\n    :rtype: str\n    \"\"\"\n\n    from .vendor.pythonfinder import Finder\n    if not command:\n        raise ValueError(\"fallback_which: Must provide a command to search for...\")\n    if not isinstance(command, str):\n        raise TypeError(f\"Provided command must be a string, received {command!r}\")\n    global_search = system or allow_global\n    if location is None:\n        global_search = True\n    finder = Finder(system=False, global_search=global_search, path=location)\n    if is_python_command(command):\n        result = find_python(finder, command)\n        if result:\n            return result\n    result = finder.which(command)\n    if result:\n        return result.path.as_posix()\n    return \"\"\n\n\ndef which_pip(project, allow_global=False):\n    \"\"\"Returns the location of virtualenv-installed pip.\"\"\"\n\n    location = None\n    if \"VIRTUAL_ENV\" in os.environ:\n        location = os.environ[\"VIRTUAL_ENV\"]\n    if allow_global:\n        if location:\n            pip = project._which(\"pip\", location=location)\n            if pip:\n                return pip\n\n        for p in (\"pip\", \"pip3\", \"pip2\"):\n            where = system_which(p)\n            if where:\n                return where\n\n    pip = project._which(\"pip\")\n    if not pip:\n        pip = fallback_which(\"pip\", allow_global=allow_global, location=location)\n    return pip\n\n\ndef system_which(command, path=None):\n    \"\"\"Emulates the system's which. Returns None if not found.\"\"\"\n    import shutil\n\n    result = shutil.which(command, path=path)\n    if result is None:\n        _which = \"where\" if os.name == \"nt\" else \"which -a\"\n        env = {'PATH': path} if path else None\n        c = subprocess_run(f\"{_which} {command}\", shell=True, env=env)\n        if c.returncode == 127:\n            click.echo(\n                \"{}: the {} system utility is required for Pipenv to find Python installations properly.\"\n                \"\\n  Please install it.\".format(\n                    crayons.red(\"Warning\", bold=True), crayons.yellow(_which)\n                ),\n                err=True,\n            )\n        if c.returncode == 0:\n            result = next(iter(c.stdout.splitlines()), None)\n    return result\n\n\ndef format_help(help):\n    \"\"\"Formats the help string.\"\"\"\n    help = help.replace(\"Options:\", str(crayons.normal(\"Options:\", bold=True)))\n    help = help.replace(\n        \"Usage: pipenv\", str(\"Usage: {}\".format(crayons.normal(\"pipenv\", bold=True)))\n    )\n    help = help.replace(\"  check\", str(crayons.red(\"  check\", bold=True)))\n    help = help.replace(\"  clean\", str(crayons.red(\"  clean\", bold=True)))\n    help = help.replace(\"  graph\", str(crayons.red(\"  graph\", bold=True)))\n    help = help.replace(\"  install\", str(crayons.magenta(\"  install\", bold=True)))\n    help = help.replace(\"  lock\", str(crayons.green(\"  lock\", bold=True)))\n    help = help.replace(\"  open\", str(crayons.red(\"  open\", bold=True)))\n    help = help.replace(\"  run\", str(crayons.yellow(\"  run\", bold=True)))\n    help = help.replace(\"  shell\", str(crayons.yellow(\"  shell\", bold=True)))\n    help = help.replace(\"  scripts\", str(crayons.yellow(\"  scripts\", bold=True)))\n    help = help.replace(\"  sync\", str(crayons.green(\"  sync\", bold=True)))\n    help = help.replace(\"  uninstall\", str(crayons.magenta(\"  uninstall\", bold=True)))\n    help = help.replace(\"  update\", str(crayons.green(\"  update\", bold=True)))\n    additional_help = \"\"\"\nUsage Examples:\n   Create a new project using Python 3.7, specifically:\n   $ {}\n\n   Remove project virtualenv (inferred from current directory):\n   $ {}\n\n   Install all dependencies for a project (including dev):\n   $ {}\n\n   Create a lockfile containing pre-releases:\n   $ {}\n\n   Show a graph of your installed dependencies:\n   $ {}\n\n   Check your installed dependencies for security vulnerabilities:\n   $ {}\n\n   Install a local setup.py into your virtual environment/Pipfile:\n   $ {}\n\n   Use a lower-level pip command:\n   $ {}\n\nCommands:\"\"\".format(\n        crayons.yellow(\"pipenv --python 3.7\"),\n        crayons.yellow(\"pipenv --rm\"),\n        crayons.yellow(\"pipenv install --dev\"),\n        crayons.yellow(\"pipenv lock --pre\"),\n        crayons.yellow(\"pipenv graph\"),\n        crayons.yellow(\"pipenv check\"),\n        crayons.yellow(\"pipenv install -e .\"),\n        crayons.yellow(\"pipenv run pip freeze\"),\n    )\n    help = help.replace(\"Commands:\", additional_help)\n    return help\n\n\ndef format_pip_error(error):\n    error = error.replace(\"Expected\", str(crayons.green(\"Expected\", bold=True)))\n    error = error.replace(\"Got\", str(crayons.red(\"Got\", bold=True)))\n    error = error.replace(\n        \"THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS FILE\",\n        str(\n            crayons.red(\n                \"THESE PACKAGES DO NOT MATCH THE HASHES FROM Pipfile.lock!\", bold=True\n            )\n        ),\n    )\n    error = error.replace(\n        \"someone may have tampered with them\",\n        str(crayons.red(\"someone may have tampered with them\")),\n    )\n    error = error.replace(\"option to pip install\", \"option to 'pipenv install'\")\n    return error\n\n\ndef format_pip_output(out, r=None):\n    def gen(out):\n        for line in out.split(\"\\n\"):\n            # Remove requirements file information from pip9 output.\n            if \"(from -r\" in line:\n                yield line[: line.index(\"(from -r\")]\n\n            else:\n                yield line\n\n    out = \"\\n\".join([line for line in gen(out)])\n    return out\n\n\ndef warn_in_virtualenv(project):\n    # Only warn if pipenv isn't already active.\n    if environments.is_in_virtualenv() and not project.s.is_quiet():\n        click.echo(\n            \"{}: Pipenv found itself running within a virtual environment, \"\n            \"so it will automatically use that environment, instead of \"\n            \"creating its own for any project. You can set \"\n            \"{} to force pipenv to ignore that environment and create \"\n            \"its own instead. You can set {} to suppress this \"\n            \"warning.\".format(\n                crayons.green(\"Courtesy Notice\"),\n                crayons.normal(\"PIPENV_IGNORE_VIRTUALENVS=1\", bold=True),\n                crayons.normal(\"PIPENV_VERBOSITY=-1\", bold=True),\n            ),\n            err=True,\n        )\n\n\ndef ensure_lockfile(project, keep_outdated=False, pypi_mirror=None):\n    \"\"\"Ensures that the lockfile is up-to-date.\"\"\"\n    if not keep_outdated:\n        keep_outdated = project.settings.get(\"keep_outdated\")\n    # Write out the lockfile if it doesn't exist, but not if the Pipfile is being ignored\n    if project.lockfile_exists:\n        old_hash = project.get_lockfile_hash()\n        new_hash = project.calculate_pipfile_hash()\n        if new_hash != old_hash:\n            click.echo(\n                crayons.yellow(\n                    fix_utf8(\"Pipfile.lock ({}) out of date, updating to ({})...\".format(\n                        old_hash[-6:], new_hash[-6:]\n                    )),\n                    bold=True,\n                ),\n                err=True,\n            )\n            do_lock(project, keep_outdated=keep_outdated, pypi_mirror=pypi_mirror)\n    else:\n        do_lock(project, keep_outdated=keep_outdated, pypi_mirror=pypi_mirror)\n\n\ndef do_py(project, ctx=None, system=False):\n    if not project.virtualenv_exists:\n        click.echo(\n            \"{}({}){}\".format(\n                crayons.red(\"No virtualenv has been created for this project \"),\n                crayons.yellow(project.project_directory, bold=True),\n                crayons.red(\" yet!\")\n            ),\n            err=True,\n        )\n        ctx.abort()\n\n    try:\n        click.echo(project._which(\"python\", allow_global=system))\n    except AttributeError:\n        click.echo(crayons.red(\"No project found!\"))\n\n\ndef do_outdated(project, pypi_mirror=None, pre=False, clear=False):\n    # TODO: Allow --skip-lock here?\n    from collections import namedtuple\n\n    from .vendor.packaging.utils import canonicalize_name\n    from .vendor.requirementslib.models.requirements import Requirement\n    from .vendor.requirementslib.models.utils import get_version\n    from .vendor.vistir.compat import Mapping\n\n    packages = {}\n    package_info = namedtuple(\"PackageInfo\", [\"name\", \"installed\", \"available\"])\n\n    installed_packages = project.environment.get_installed_packages()\n    outdated_packages = {\n        canonicalize_name(pkg.project_name): package_info\n        (pkg.project_name, pkg.parsed_version, pkg.latest_version)\n        for pkg in project.environment.get_outdated_packages()\n    }\n    reverse_deps = {\n        canonicalize_name(name): deps\n        for name, deps in project.environment.reverse_dependencies().items()\n    }\n    for result in installed_packages:\n        dep = Requirement.from_line(str(result.as_requirement()))\n        packages.update(dep.as_pipfile())\n    updated_packages = {}\n    lockfile = do_lock(project, clear=clear, pre=pre, write=False, pypi_mirror=pypi_mirror)\n    for section in (\"develop\", \"default\"):\n        for package in lockfile[section]:\n            try:\n                updated_packages[package] = lockfile[section][package][\"version\"]\n            except KeyError:\n                pass\n    outdated = []\n    skipped = []\n    for package in packages:\n        norm_name = pep423_name(package)\n        if norm_name in updated_packages:\n            if updated_packages[norm_name] != packages[package]:\n                outdated.append(\n                    package_info(package, updated_packages[norm_name], packages[package])\n                )\n            elif canonicalize_name(package) in outdated_packages:\n                skipped.append(outdated_packages[canonicalize_name(package)])\n    for package, old_version, new_version in skipped:\n        name_in_pipfile = project.get_package_name_in_pipfile(package)\n        pipfile_version_text = \"\"\n        required = \"\"\n        version = None\n        if name_in_pipfile:\n            version = get_version(project.packages[name_in_pipfile])\n            rdeps = reverse_deps.get(canonicalize_name(package))\n            if isinstance(rdeps, Mapping) and \"required\" in rdeps:\n                required = \" {} required\".format(rdeps[\"required\"])\n            if version:\n                pipfile_version_text = f\" ({version} set in Pipfile)\"\n            else:\n                pipfile_version_text = \" (Unpinned in Pipfile)\"\n        click.echo(\n            crayons.yellow(\n                \"Skipped Update of Package {!s}: {!s} installed,{!s}{!s}, \"\n                \"{!s} available.\".format(\n                    package, old_version, required, pipfile_version_text, new_version\n                )\n            ), err=True\n        )\n    if not outdated:\n        click.echo(crayons.green(\"All packages are up to date!\", bold=True))\n        sys.exit(0)\n    for package, new_version, old_version in outdated:\n        click.echo(\n            \"Package {!r} out-of-date: {!r} installed, {!r} available.\".format(\n                package, old_version, new_version\n            )\n        )\n    sys.exit(bool(outdated))\n\n\ndef do_install(\n    project,\n    packages=False,\n    editable_packages=False,\n    index_url=False,\n    extra_index_url=False,\n    dev=False,\n    three=False,\n    python=False,\n    pypi_mirror=None,\n    system=False,\n    lock=True,\n    ignore_pipfile=False,\n    skip_lock=False,\n    requirementstxt=False,\n    sequential=False,\n    pre=False,\n    code=False,\n    deploy=False,\n    keep_outdated=False,\n    selective_upgrade=False,\n    site_packages=None,\n):\n    from .vendor.pip_shims.shims import PipError\n\n    requirements_directory = vistir.path.create_tracked_tempdir(\n        suffix=\"-requirements\", prefix=\"pipenv-\"\n    )\n    warnings.filterwarnings(\"default\", category=vistir.compat.ResourceWarning)\n    if selective_upgrade:\n        keep_outdated = True\n    packages = packages if packages else []\n    editable_packages = editable_packages if editable_packages else []\n    package_args = [p for p in packages if p] + [p for p in editable_packages if p]\n    skip_requirements = False\n    # Don't search for requirements.txt files if the user provides one\n    if requirementstxt or package_args or project.pipfile_exists:\n        skip_requirements = True\n    concurrent = not sequential\n    # Ensure that virtualenv is available and pipfile are available\n    ensure_project(\n        project,\n        three=three,\n        python=python,\n        system=system,\n        warn=True,\n        deploy=deploy,\n        skip_requirements=skip_requirements,\n        pypi_mirror=pypi_mirror,\n        site_packages=site_packages,\n    )\n    # Don't attempt to install develop and default packages if Pipfile is missing\n    if not project.pipfile_exists and not (package_args or dev) and not code:\n        if not (ignore_pipfile or deploy):\n            raise exceptions.PipfileNotFound(project.path_to(\"Pipfile\"))\n        elif ((skip_lock and deploy) or ignore_pipfile) and not project.lockfile_exists:\n            raise exceptions.LockfileNotFound(project.path_to(\"Pipfile.lock\"))\n    # Load the --pre settings from the Pipfile.\n    if not pre:\n        pre = project.settings.get(\"allow_prereleases\")\n    if not keep_outdated:\n        keep_outdated = project.settings.get(\"keep_outdated\")\n    remote = requirementstxt and is_valid_url(requirementstxt)\n    # Warn and exit if --system is used without a pipfile.\n    if (system and package_args) and not project.s.PIPENV_VIRTUALENV:\n        raise exceptions.SystemUsageError\n    # Automatically use an activated virtualenv.\n    if project.s.PIPENV_USE_SYSTEM:\n        system = True\n    if system:\n        project.s.PIPENV_USE_SYSTEM = True\n        os.environ[\"PIPENV_USE_SYSTEM\"] = \"1\"\n    # Check if the file is remote or not\n    if remote:\n        click.echo(\n            crayons.normal(\n                fix_utf8(\"Remote requirements file provided! Downloading...\"), bold=True\n            ),\n            err=True,\n        )\n        fd = vistir.path.create_tracked_tempfile(\n            prefix=\"pipenv-\", suffix=\"-requirement.txt\", dir=requirements_directory\n        )\n        temp_reqs = fd.name\n        requirements_url = requirementstxt\n        # Download requirements file\n        try:\n            download_file(requirements_url, temp_reqs, project.s.PIPENV_MAX_RETRIES)\n        except OSError:\n            fd.close()\n            os.unlink(temp_reqs)\n            click.echo(\n                crayons.red(\n                    \"Unable to find requirements file at {}.\".format(\n                        crayons.normal(requirements_url)\n                    )\n                ),\n                err=True,\n            )\n            sys.exit(1)\n        finally:\n            fd.close()\n        # Replace the url with the temporary requirements file\n        requirementstxt = temp_reqs\n        remote = True\n    if requirementstxt:\n        error, traceback = None, None\n        click.echo(\n            crayons.normal(\n                fix_utf8(\"Requirements file provided! Importing into Pipfile...\"), bold=True\n            ),\n            err=True,\n        )\n        try:\n            import_requirements(project, r=project.path_to(requirementstxt), dev=dev)\n        except (UnicodeDecodeError, PipError) as e:\n            # Don't print the temp file path if remote since it will be deleted.\n            req_path = requirements_url if remote else project.path_to(requirementstxt)\n            error = (\n                \"Unexpected syntax in {}. Are you sure this is a \"\n                \"requirements.txt style file?\".format(req_path)\n            )\n            traceback = e\n        except AssertionError as e:\n            error = (\n                \"Requirements file doesn't appear to exist. Please ensure the file exists in your \"\n                \"project directory or you provided the correct path.\"\n            )\n            traceback = e\n        finally:\n            # If requirements file was provided by remote url delete the temporary file\n            if remote:\n                fd.close()  # Close for windows to allow file cleanup.\n                os.remove(temp_reqs)\n            if error and traceback:\n                click.echo(crayons.red(error))\n                click.echo(crayons.yellow(str(traceback)), err=True)\n                sys.exit(1)\n    if code:\n        click.echo(\n            crayons.normal(fix_utf8(\"Discovering imports from local codebase...\"), bold=True)\n        )\n        for req in import_from_code(code):\n            click.echo(f\"  Found {crayons.green(req)}!\")\n            project.add_package_to_pipfile(req)\n    # Allow more than one package to be provided.\n    package_args = [p for p in packages] + [\n        f\"-e {pkg}\" for pkg in editable_packages\n    ]\n    # Support for --selective-upgrade.\n    # We should do this part first to make sure that we actually do selectively upgrade\n    # the items specified\n    if selective_upgrade:\n        from .vendor.requirementslib.models.requirements import Requirement\n\n        for i, package in enumerate(package_args[:]):\n            section = project.packages if not dev else project.dev_packages\n            package = Requirement.from_line(package)\n            package__name, package__val = package.pipfile_entry\n            try:\n                if not is_star(section[package__name]) and is_star(package__val):\n                    # Support for VCS dependencies.\n                    package_args[i] = convert_deps_to_pip(\n                        {package__name: section[package__name]}, project=project, r=False\n                    )[0]\n            except KeyError:\n                pass\n    # Install all dependencies, if none was provided.\n    # This basically ensures that we have a pipfile and lockfile, then it locks and\n    # installs from the lockfile\n    if not packages and not editable_packages:\n        # Update project settings with pre preference.\n        if pre:\n            project.update_settings({\"allow_prereleases\": pre})\n        do_init(\n            project,\n            dev=dev,\n            allow_global=system,\n            ignore_pipfile=ignore_pipfile,\n            system=system,\n            skip_lock=skip_lock,\n            concurrent=concurrent,\n            deploy=deploy,\n            pre=pre,\n            requirements_dir=requirements_directory,\n            pypi_mirror=pypi_mirror,\n            keep_outdated=keep_outdated\n        )\n\n    # This is for if the user passed in dependencies, then we want to make sure we\n    else:\n        from .vendor.requirementslib.models.requirements import Requirement\n\n        # make a tuple of (display_name, entry)\n        pkg_list = packages + [f'-e {pkg}' for pkg in editable_packages]\n        if not system and not project.virtualenv_exists:\n            do_init(\n                project,\n                dev=dev,\n                system=system,\n                allow_global=system,\n                concurrent=concurrent,\n                keep_outdated=keep_outdated,\n                requirements_dir=requirements_directory,\n                deploy=deploy,\n                pypi_mirror=pypi_mirror,\n                skip_lock=skip_lock,\n            )\n        pip_shims_module = os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n        for pkg_line in pkg_list:\n            click.echo(\n                crayons.normal(\n                    fix_utf8(f\"Installing {crayons.green(pkg_line, bold=True)}...\"),\n                    bold=True,\n                )\n            )\n            # pip install:\n            with vistir.contextmanagers.temp_environ(), create_spinner(\"Installing...\", project.s) as sp:\n                if not system:\n                    os.environ[\"PIP_USER\"] = vistir.compat.fs_str(\"0\")\n                    if \"PYTHONHOME\" in os.environ:\n                        del os.environ[\"PYTHONHOME\"]\n                sp.text = f\"Resolving {pkg_line}...\"\n                try:\n                    pkg_requirement = Requirement.from_line(pkg_line)\n                except ValueError as e:\n                    sp.write_err(vistir.compat.fs_str(\"{}: {}\".format(crayons.red(\"WARNING\"), e)))\n                    sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Installation Failed\"))\n                    sys.exit(1)\n                no_deps = False\n                sp.text = \"Installing...\"\n                try:\n                    sp.text = f\"Installing {pkg_requirement.name}...\"\n                    if project.s.is_verbose():\n                        sp.hide_and_write(f\"Installing package: {pkg_requirement.as_line(include_hashes=False)}\")\n                    c = pip_install(\n                        project,\n                        pkg_requirement,\n                        ignore_hashes=True,\n                        allow_global=system,\n                        selective_upgrade=selective_upgrade,\n                        no_deps=no_deps,\n                        pre=pre,\n                        requirements_dir=requirements_directory,\n                        index=index_url,\n                        extra_indexes=extra_index_url,\n                        pypi_mirror=pypi_mirror,\n                    )\n                    if c.returncode:\n                        sp.write_err(\n                            \"{} An error occurred while installing {}!\".format(\n                                crayons.red(\"Error: \", bold=True), crayons.green(pkg_line)\n                            ),\n                        )\n                        sp.write_err(\n                            vistir.compat.fs_str(f\"Error text: {c.stdout}\")\n                        )\n                        sp.write_err(crayons.cyan(vistir.compat.fs_str(format_pip_error(c.stderr))))\n                        if project.s.is_verbose():\n                            sp.write_err(crayons.cyan(vistir.compat.fs_str(format_pip_output(c.stdout))))\n                        if \"setup.py egg_info\" in c.stderr:\n                            sp.write_err(vistir.compat.fs_str(\n                                \"This is likely caused by a bug in {}. \"\n                                \"Report this to its maintainers.\".format(\n                                    crayons.green(pkg_requirement.name)\n                                )\n                            ))\n                        sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Installation Failed\"))\n                        sys.exit(1)\n                except (ValueError, RuntimeError) as e:\n                    sp.write_err(vistir.compat.fs_str(\n                        \"{}: {}\".format(crayons.red(\"WARNING\"), e),\n                    ))\n                    sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\n                        \"Installation Failed\",\n                    ))\n                    sys.exit(1)\n                # Warn if --editable wasn't passed.\n                if pkg_requirement.is_vcs and not pkg_requirement.editable and not project.s.PIPENV_RESOLVE_VCS:\n                    sp.write_err(\n                        \"{}: You installed a VCS dependency in non-editable mode. \"\n                        \"This will work fine, but sub-dependencies will not be resolved by {}.\"\n                        \"\\n  To enable this sub-dependency functionality, specify that this dependency is editable.\"\n                        \"\".format(\n                            crayons.red(\"Warning\", bold=True),\n                            crayons.yellow(\"$ pipenv lock\"),\n                        )\n                    )\n                sp.write(vistir.compat.fs_str(\n                    \"{} {} {} {}{}\".format(\n                        crayons.normal(\"Adding\", bold=True),\n                        crayons.green(f\"{pkg_requirement.name}\", bold=True),\n                        crayons.normal(\"to Pipfile's\", bold=True),\n                        crayons.yellow(\"[dev-packages]\" if dev else \"[packages]\", bold=True),\n                        crayons.normal(fix_utf8(\"...\"), bold=True),\n                    )\n                ))\n                # Add the package to the Pipfile.\n                indexes = list(filter(None, [index_url, *extra_index_url]))\n                for index in indexes:\n                    index_name = project.add_index_to_pipfile(\n                        index, verify_ssl=index.startswith(\"https:\")\n                    )\n                    if index_url and not extra_index_url:\n                        pkg_requirement.index = index_name\n                try:\n                    project.add_package_to_pipfile(pkg_requirement, dev)\n                except ValueError:\n                    import traceback\n                    sp.write_err(\n                        \"{} {}\".format(\n                            crayons.red(\"Error:\", bold=True), traceback.format_exc()\n                        )\n                    )\n                    sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\n                        \"Failed adding package to Pipfile\"\n                    ))\n                sp.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Installation Succeeded\"))\n            # Update project settings with pre preference.\n            if pre:\n                project.update_settings({\"allow_prereleases\": pre})\n        if pip_shims_module:\n            os.environ[\"PIP_SHIMS_BASE_MODULE\"] = pip_shims_module\n        do_init(\n            project,\n            dev=dev,\n            system=system,\n            allow_global=system,\n            concurrent=concurrent,\n            keep_outdated=keep_outdated,\n            requirements_dir=requirements_directory,\n            deploy=deploy,\n            pypi_mirror=pypi_mirror,\n            skip_lock=skip_lock,\n        )\n    sys.exit(0)\n\n\ndef do_uninstall(\n    project,\n    packages=False,\n    editable_packages=False,\n    three=None,\n    python=False,\n    system=False,\n    lock=False,\n    all_dev=False,\n    all=False,\n    keep_outdated=False,\n    pypi_mirror=None,\n    ctx=None\n):\n    from .vendor.packaging.utils import canonicalize_name\n    from .vendor.requirementslib.models.requirements import Requirement\n\n    # Automatically use an activated virtualenv.\n    if project.s.PIPENV_USE_SYSTEM:\n        system = True\n    # Ensure that virtualenv is available.\n    # TODO: We probably shouldn't ensure a project exists if the outcome will be to just\n    # install things in order to remove them... maybe tell the user to install first?\n    ensure_project(project, three=three, python=python, pypi_mirror=pypi_mirror)\n    # Un-install all dependencies, if --all was provided.\n    if not any([packages, editable_packages, all_dev, all]):\n        raise exceptions.PipenvUsageError(\"No package provided!\", ctx=ctx)\n    editable_pkgs = [\n        Requirement.from_line(f\"-e {p}\").name for p in editable_packages if p\n    ]\n    packages += editable_pkgs\n    package_names = {p for p in packages if p}\n    package_map = {\n        canonicalize_name(p): p for p in packages if p\n    }\n    installed_package_names = project.installed_package_names\n    # Intelligently detect if --dev should be used or not.\n    lockfile_packages = set()\n    if project.lockfile_exists:\n        project_pkg_names = project.lockfile_package_names\n    else:\n        project_pkg_names = project.pipfile_package_names\n    pipfile_remove = True\n    # Uninstall [dev-packages], if --dev was provided.\n    if all_dev:\n        if \"dev-packages\" not in project.parsed_pipfile and not project_pkg_names[\"dev\"]:\n            click.echo(\n                crayons.normal(\n                    \"No {} to uninstall.\".format(crayons.yellow(\"[dev-packages]\")),\n                    bold=True,\n                )\n            )\n            return\n        click.echo(\n            crayons.normal(\n                fix_utf8(\"Un-installing {}...\".format(crayons.yellow(\"[dev-packages]\"))), bold=True\n            )\n        )\n        package_names = set(project_pkg_names[\"dev\"]) - set(project_pkg_names[\"default\"])\n\n    # Remove known \"bad packages\" from the list.\n    bad_pkgs = get_canonical_names(BAD_PACKAGES)\n    ignored_packages = bad_pkgs & set(list(package_map.keys()))\n    for ignored_pkg in ignored_packages:\n        if project.s.is_verbose():\n            click.echo(f\"Ignoring {ignored_pkg}.\", err=True)\n        package_names.discard(package_map[ignored_pkg])\n\n    used_packages = project_pkg_names[\"combined\"] & installed_package_names\n    failure = False\n    if all:\n        click.echo(\n            crayons.normal(\n                fix_utf8(\"Un-installing all {} and {}...\".format(\n                    crayons.yellow(\"[dev-packages]\"),\n                    crayons.yellow(\"[packages]\"),\n                )), bold=True\n            )\n        )\n        do_purge(project, bare=False, allow_global=system)\n        sys.exit(0)\n\n    selected_pkg_map = {\n        canonicalize_name(p): p for p in package_names\n    }\n    packages_to_remove = [\n        p for normalized, p in selected_pkg_map.items()\n        if normalized in (used_packages - bad_pkgs)\n    ]\n    pip_path = None\n    for normalized, package_name in selected_pkg_map.items():\n        click.echo(\n            crayons.normal(\n                fix_utf8(f\"Uninstalling {crayons.green(package_name)}...\"), bold=True\n            )\n        )\n        # Uninstall the package.\n        if package_name in packages_to_remove:\n            with project.environment.activated():\n                if pip_path is None:\n                    pip_path = which_pip(project, allow_global=system)\n                cmd = [pip_path, \"uninstall\", package_name, \"-y\"]\n                c = run_command(cmd, is_verbose=project.s.is_verbose())\n                click.echo(crayons.cyan(c.stdout))\n                if c.returncode != 0:\n                    failure = True\n        if not failure and pipfile_remove:\n            in_packages = project.get_package_name_in_pipfile(package_name, dev=False)\n            in_dev_packages = project.get_package_name_in_pipfile(\n                package_name, dev=True\n            )\n            if normalized in lockfile_packages:\n                click.echo(\"{} {} {} {}\".format(\n                    crayons.cyan(\"Removing\"),\n                    crayons.green(package_name),\n                    crayons.cyan(\"from\"),\n                    crayons.white(fix_utf8(\"Pipfile.lock...\")))\n                )\n                lockfile = project.get_or_create_lockfile()\n                if normalized in lockfile.default:\n                    del lockfile.default[normalized]\n                if normalized in lockfile.develop:\n                    del lockfile.develop[normalized]\n                lockfile.write()\n            if not (in_dev_packages or in_packages):\n                if normalized in lockfile_packages:\n                    continue\n                click.echo(\n                    \"No package {} to remove from Pipfile.\".format(\n                        crayons.green(package_name)\n                    )\n                )\n                continue\n\n            click.echo(\n                fix_utf8(f\"Removing {crayons.green(package_name)} from Pipfile...\")\n            )\n            # Remove package from both packages and dev-packages.\n            if in_dev_packages:\n                project.remove_package_from_pipfile(package_name, dev=True)\n            if in_packages:\n                project.remove_package_from_pipfile(package_name, dev=False)\n    if lock:\n        do_lock(project, system=system, keep_outdated=keep_outdated, pypi_mirror=pypi_mirror)\n    sys.exit(int(failure))\n\n\ndef do_shell(project, three=None, python=False, fancy=False, shell_args=None, pypi_mirror=None):\n    # Ensure that virtualenv is available.\n    ensure_project(\n        project, three=three, python=python, validate=False, pypi_mirror=pypi_mirror,\n    )\n\n    # Support shell compatibility mode.\n    if project.s.PIPENV_SHELL_FANCY:\n        fancy = True\n\n    from .shells import choose_shell\n\n    shell = choose_shell(project)\n    click.echo(fix_utf8(\"Launching subshell in virtual environment...\"), err=True)\n\n    fork_args = (\n        project.virtualenv_location,\n        project.project_directory,\n        shell_args,\n    )\n\n    # Set an environment variable, so we know we're in the environment.\n    # Only set PIPENV_ACTIVE after finishing reading virtualenv_location\n    # otherwise its value will be changed\n    os.environ[\"PIPENV_ACTIVE\"] = vistir.misc.fs_str(\"1\")\n\n    os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n\n    if fancy:\n        shell.fork(*fork_args)\n        return\n\n    try:\n        shell.fork_compat(*fork_args)\n    except (AttributeError, ImportError):\n        click.echo(fix_utf8(\n            \"Compatibility mode not supported. \"\n            \"Trying to continue as well-configured shell...\"),\n            err=True,\n        )\n        shell.fork(*fork_args)\n\n\ndef _inline_activate_virtualenv(project):\n    try:\n        activate_this = project._which(\"activate_this.py\")\n        if not activate_this or not os.path.exists(activate_this):\n            raise exceptions.VirtualenvActivationException()\n        with open(activate_this) as f:\n            code = compile(f.read(), activate_this, \"exec\")\n            exec(code, dict(__file__=activate_this))\n    # Catch all errors, just in case.\n    except Exception:\n        click.echo(\n            \"{}: There was an unexpected error while activating your \"\n            \"virtualenv. Continuing anyway...\".format(\n                crayons.red(\"Warning\", bold=True)\n            ),\n            err=True,\n        )\n\n\ndef _inline_activate_venv(project):\n    \"\"\"Built-in venv doesn't have activate_this.py, but doesn't need it anyway.\n\n    As long as we find the correct executable, built-in venv sets up the\n    environment automatically.\n\n    See: https://bugs.python.org/issue21496#msg218455\n    \"\"\"\n    components = []\n    for name in (\"bin\", \"Scripts\"):\n        bindir = os.path.join(project.virtualenv_location, name)\n        if os.path.exists(bindir):\n            components.append(bindir)\n    if \"PATH\" in os.environ:\n        components.append(os.environ[\"PATH\"])\n    os.environ[\"PATH\"] = os.pathsep.join(components)\n\n\ndef inline_activate_virtual_environment(project):\n    root = project.virtualenv_location\n    if os.path.exists(os.path.join(root, \"pyvenv.cfg\")):\n        _inline_activate_venv(project)\n    else:\n        _inline_activate_virtualenv(project)\n    if \"VIRTUAL_ENV\" not in os.environ:\n        os.environ[\"VIRTUAL_ENV\"] = vistir.misc.fs_str(root)\n\n\ndef _launch_windows_subprocess(script, env):\n    import subprocess\n\n    path = env.get(\"PATH\", \"\")\n    command = system_which(script.command, path=path)\n\n    options = {\"universal_newlines\": True, \"env\": env}\n    script.cmd_args[1:] = [expandvars(arg) for arg in script.args]\n\n    # Command not found, maybe this is a shell built-in?\n    if not command:\n        return subprocess.Popen(script.cmdify(), shell=True, **options)\n\n    # Try to use CreateProcess directly if possible. Specifically catch\n    # Windows error 193 \"Command is not a valid Win32 application\" to handle\n    # a \"command\" that is non-executable. See pypa/pipenv#2727.\n    try:\n        return subprocess.Popen([command] + script.args, **options)\n    except OSError as e:\n        if e.winerror != 193:\n            raise\n\n    # Try shell mode to use Windows's file association for file launch.\n    return subprocess.Popen(script.cmdify(), shell=True, **options)\n\n\ndef do_run_nt(project, script, env):\n    p = _launch_windows_subprocess(script, env)\n    p.communicate()\n    sys.exit(p.returncode)\n\n\ndef do_run_posix(project, script, command, env):\n    path = env.get(\"PATH\")\n    command_path = system_which(script.command, path=path)\n    if not command_path:\n        if project.has_script(command):\n            click.echo(\n                \"{}: the command {} (from {}) could not be found within {}.\"\n                \"\".format(\n                    crayons.red(\"Error\", bold=True),\n                    crayons.yellow(script.command),\n                    crayons.normal(command, bold=True),\n                    crayons.normal(\"PATH\", bold=True),\n                ),\n                err=True,\n            )\n        else:\n            click.echo(\n                \"{}: the command {} could not be found within {} or Pipfile's {}.\"\n                \"\".format(\n                    crayons.red(\"Error\", bold=True),\n                    crayons.yellow(command),\n                    crayons.normal(\"PATH\", bold=True),\n                    crayons.normal(\"[scripts]\", bold=True),\n                ),\n                err=True,\n            )\n        sys.exit(1)\n    os.execve(\n        command_path,\n        [command_path, *(os.path.expandvars(arg) for arg in script.args)],\n        env\n    )\n\n\ndef do_run(project, command, args, three=None, python=False, pypi_mirror=None):\n    \"\"\"Attempt to run command either pulling from project or interpreting as executable.\n\n    Args are appended to the command in [scripts] section of project if found.\n    \"\"\"\n    from .cmdparse import ScriptEmptyError\n\n    # Ensure that virtualenv is available.\n    ensure_project(\n        project, three=three, python=python, validate=False, pypi_mirror=pypi_mirror,\n    )\n\n    env = os.environ.copy()\n    env.update(load_dot_env(project, as_dict=True) or {})\n    env.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n\n    path = env.get('PATH', '')\n    if project.virtualenv_location:\n        new_path = os.path.join(project.virtualenv_location, 'Scripts' if os.name == 'nt' else 'bin')\n        paths = path.split(os.pathsep)\n        paths.insert(0, new_path)\n        path = os.pathsep.join(paths)\n        env[\"VIRTUAL_ENV\"] = project.virtualenv_location\n    env[\"PATH\"] = path\n\n    # Set an environment variable, so we know we're in the environment.\n    # Only set PIPENV_ACTIVE after finishing reading virtualenv_location\n    # such as in inline_activate_virtual_environment\n    # otherwise its value will be changed\n    env[\"PIPENV_ACTIVE\"] = vistir.misc.fs_str(\"1\")\n    env.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n\n    try:\n        script = project.build_script(command, args)\n        cmd_string = cmd_list_to_shell([script.command] + script.args)\n        if project.s.is_verbose():\n            click.echo(crayons.normal(f\"$ {cmd_string}\"), err=True)\n    except ScriptEmptyError:\n        click.echo(\"Can't run script {0!r}-it's empty?\", err=True)\n    run_args = [project, script]\n    run_kwargs = {'env': env}\n    # We're using `do_run_nt` on CI (even if we're running on a non-nt machine)\n    # as a workaround for https://github.com/pypa/pipenv/issues/4909.\n    if os.name == \"nt\" or environments.PIPENV_IS_CI:\n        run_fn = do_run_nt\n    else:\n        run_fn = do_run_posix\n        run_kwargs.update({\"command\": command})\n    run_fn(*run_args, **run_kwargs)\n\n\ndef do_check(\n    project,\n    three=None,\n    python=False,\n    system=False,\n    unused=False,\n    db=None,\n    ignore=None,\n    output=\"default\",\n    key=None,\n    quiet=False,\n    args=None,\n    pypi_mirror=None\n):\n    from pipenv.vendor.first import first\n    from pipenv.vendor.vistir.compat import JSONDecodeError\n\n    if not system:\n        # Ensure that virtualenv is available.\n        ensure_project(\n            project,\n            three=three,\n            python=python,\n            validate=False,\n            warn=False,\n            pypi_mirror=pypi_mirror,\n        )\n    if not args:\n        args = []\n    if unused:\n        deps_required = [k.lower() for k in project.packages.keys()]\n        deps_needed = [k.lower() for k in import_from_code(unused)]\n        for dep in deps_needed:\n            try:\n                deps_required.remove(dep)\n            except ValueError:\n                pass\n        if deps_required:\n            if not quiet and not project.s.is_quiet():\n                click.echo(\n                    crayons.normal(\n                        \"The following dependencies appear unused, and may be safe for removal:\"\n                    )\n                )\n                for dep in deps_required:\n                    click.echo(f\"  - {crayons.green(dep)}\")\n                sys.exit(1)\n        else:\n            sys.exit(0)\n    if not quiet and not project.s.is_quiet():\n        click.echo(crayons.normal(decode_for_output(\"Checking PEP 508 requirements...\"), bold=True))\n    pep508checker_path = pep508checker.__file__.rstrip(\"cdo\")\n    safety_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"patched\", \"safety\"\n    )\n    if not system:\n        python = project._which(\"python\")\n    else:\n        python = first(system_which(p) for p in (\"python\", \"python3\", \"python2\"))\n    if not python:\n        click.echo(crayons.red(\"The Python interpreter can't be found.\"), err=True)\n        sys.exit(1)\n    _cmd = [Path(python).as_posix()]\n    # Run the PEP 508 checker in the virtualenv.\n    cmd = _cmd + [Path(pep508checker_path).as_posix()]\n    c = run_command(cmd, is_verbose=project.s.is_verbose())\n    if c.returncode is not None:\n        try:\n            results = simplejson.loads(c.stdout.strip())\n        except JSONDecodeError:\n            click.echo(\"{}\\n{}\\n{}\".format(\n                crayons.white(decode_for_output(\"Failed parsing pep508 results: \"), bold=True),\n                c.stdout.strip(),\n                c.stderr.strip()\n            ))\n            sys.exit(1)\n    # Load the pipfile.\n    p = pipfile.Pipfile.load(project.pipfile_location)\n    failed = False\n    # Assert each specified requirement.\n    for marker, specifier in p.data[\"_meta\"][\"requires\"].items():\n        if marker in results:\n            try:\n                assert results[marker] == specifier\n            except AssertionError:\n                failed = True\n                click.echo(\n                    \"Specifier {} does not match {} ({}).\"\n                    \"\".format(\n                        crayons.green(marker),\n                        crayons.cyan(specifier),\n                        crayons.yellow(results[marker]),\n                    ),\n                    err=True,\n                )\n    if failed:\n        click.echo(crayons.red(\"Failed!\"), err=True)\n        sys.exit(1)\n    else:\n        if not quiet and not project.s.is_quiet():\n            click.echo(crayons.green(\"Passed!\"))\n    if not quiet and not project.s.is_quiet():\n        click.echo(crayons.normal(\n            decode_for_output(\"Checking installed package safety...\"), bold=True)\n        )\n    if ignore:\n        if not isinstance(ignore, (tuple, list)):\n            ignore = [ignore]\n        ignored = [[\"--ignore\", cve] for cve in ignore]\n        if not quiet and not project.s.is_quiet():\n            click.echo(\n                crayons.normal(\n                    \"Notice: Ignoring CVE(s) {}\".format(crayons.yellow(\", \".join(ignore)))\n                ),\n                err=True,\n            )\n    else:\n        ignored = []\n\n    switch = output\n    if output == \"default\":\n        switch = \"json\"\n\n    cmd = _cmd + [safety_path, \"check\", f\"--{switch}\"]\n    if db:\n        if not quiet and not project.s.is_quiet():\n            click.echo(crayons.normal(f\"Using local database {db}\"))\n        cmd.append(f\"--db={db}\")\n    elif key or project.s.PIPENV_PYUP_API_KEY:\n        cmd = cmd + [f\"--key={key or project.s.PIPENV_PYUP_API_KEY}\"]\n    if ignored:\n        for cve in ignored:\n            cmd += cve\n    c = run_command(cmd, catch_exceptions=False, is_verbose=project.s.is_verbose())\n    if output == \"default\":\n        try:\n            results = simplejson.loads(c.stdout)\n        except (ValueError, JSONDecodeError):\n            raise exceptions.JSONParseError(c.stdout, c.stderr)\n        except Exception:\n            raise exceptions.PipenvCmdError(cmd_list_to_shell(c.args), c.stdout, c.stderr, c.returncode)\n        for (package, resolved, installed, description, vuln, *_) in results:\n            click.echo(\n                \"{}: {} {} resolved ({} installed)!\".format(\n                    crayons.normal(vuln, bold=True),\n                    crayons.green(package),\n                    crayons.yellow(resolved, bold=False),\n                    crayons.yellow(installed, bold=True),\n                )\n            )\n            click.echo(f\"{description}\")\n            click.echo()\n        if c.returncode == 0:\n            click.echo(crayons.green(\"All good!\"))\n            sys.exit(0)\n        else:\n            sys.exit(1)\n    else:\n        click.echo(c.stdout)\n        sys.exit(c.returncode)\n\n\ndef do_graph(project, bare=False, json=False, json_tree=False, reverse=False):\n    from pipenv.vendor import pipdeptree\n    from pipenv.vendor.vistir.compat import JSONDecodeError\n    pipdeptree_path = pipdeptree.__file__.rstrip(\"cdo\")\n    try:\n        python_path = project._which(\"python\")\n    except AttributeError:\n        click.echo(\n            \"{}: {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                \"Unable to display currently-installed dependency graph information here. \"\n                \"Please run within a Pipenv project.\",\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    except RuntimeError:\n        pass\n    else:\n        if not os.name == 'nt':    # bugfix #4388\n            python_path = Path(python_path).as_posix()\n            pipdeptree_path = Path(pipdeptree_path).as_posix()\n\n    if reverse and json:\n        click.echo(\n            \"{}: {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                \"Using both --reverse and --json together is not supported. \"\n                \"Please select one of the two options.\",\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    if reverse and json_tree:\n        click.echo(\n            \"{}: {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                \"Using both --reverse and --json-tree together is not supported. \"\n                \"Please select one of the two options.\",\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    if json and json_tree:\n        click.echo(\n            \"{}: {}\".format(\n                crayons.red(\"Warning\", bold=True),\n                \"Using both --json and --json-tree together is not supported. \"\n                \"Please select one of the two options.\",\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    flag = \"\"\n    if json:\n        flag = \"--json\"\n    if json_tree:\n        flag = \"--json-tree\"\n    if reverse:\n        flag = \"--reverse\"\n    if not project.virtualenv_exists:\n        click.echo(\n            \"{}: No virtualenv has been created for this project yet! Consider \"\n            \"running {} first to automatically generate one for you or see \"\n            \"{} for further instructions.\".format(\n                crayons.red(\"Warning\", bold=True),\n                crayons.green(\"`pipenv install`\"),\n                crayons.green(\"`pipenv install --help`\"),\n            ),\n            err=True,\n        )\n        sys.exit(1)\n    cmd_args = [python_path, pipdeptree_path, \"-l\"]\n    if flag:\n        cmd_args.append(flag)\n    c = run_command(cmd_args, is_verbose=project.s.is_verbose())\n    # Run dep-tree.\n    if not bare:\n        if json:\n            data = []\n            try:\n                parsed = simplejson.loads(c.stdout.strip())\n            except JSONDecodeError:\n                raise exceptions.JSONParseError(c.stdout, c.stderr)\n            else:\n                for d in parsed:\n                    if d[\"package\"][\"key\"] not in BAD_PACKAGES:\n                        data.append(d)\n            click.echo(simplejson.dumps(data, indent=4))\n            sys.exit(0)\n        elif json_tree:\n\n            def traverse(obj):\n                if isinstance(obj, list):\n                    return [\n                        traverse(package)\n                        for package in obj\n                        if package[\"key\"] not in BAD_PACKAGES\n                    ]\n                else:\n                    obj[\"dependencies\"] = traverse(obj[\"dependencies\"])\n                    return obj\n\n            try:\n                parsed = simplejson.loads(c.stdout.strip())\n            except JSONDecodeError:\n                raise exceptions.JSONParseError(c.stdout, c.stderr)\n            else:\n                data = traverse(parsed)\n                click.echo(simplejson.dumps(data, indent=4))\n                sys.exit(0)\n        else:\n            for line in c.stdout.strip().split(\"\\n\"):\n                # Ignore bad packages as top level.\n                # TODO: This should probably be a \"==\" in + line.partition\n                if line.split(\"==\")[0] in BAD_PACKAGES and not reverse:\n                    continue\n\n                # Bold top-level packages.\n                if not line.startswith(\" \"):\n                    click.echo(crayons.normal(line, bold=True))\n                # Echo the rest.\n                else:\n                    click.echo(crayons.normal(line, bold=False))\n    else:\n        click.echo(c.stdout)\n    if c.returncode != 0:\n        click.echo(\n            \"{} {}\".format(\n                crayons.red(\"ERROR: \", bold=True),\n                crayons.white(f\"{c.stderr}\"),\n            ),\n            err=True,\n        )\n    # Return its return code.\n    sys.exit(c.returncode)\n\n\ndef do_sync(\n    project,\n    dev=False,\n    three=None,\n    python=None,\n    bare=False,\n    dont_upgrade=False,\n    user=False,\n    clear=False,\n    unused=False,\n    sequential=False,\n    pypi_mirror=None,\n    system=False,\n    deploy=False,\n):\n    # The lock file needs to exist because sync won't write to it.\n    if not project.lockfile_exists:\n        raise exceptions.LockfileNotFound(\"Pipfile.lock\")\n\n    # Ensure that virtualenv is available if not system.\n    ensure_project(\n        project,\n        three=three,\n        python=python,\n        validate=False,\n        system=system,\n        deploy=deploy,\n        pypi_mirror=pypi_mirror,\n        clear=clear,\n    )\n\n    # Install everything.\n    requirements_dir = vistir.path.create_tracked_tempdir(\n        suffix=\"-requirements\", prefix=\"pipenv-\"\n    )\n    if system:\n        project.s.PIPENV_USE_SYSTEM = True\n        os.environ[\"PIPENV_USE_SYSTEM\"] = \"1\"\n    do_init(\n        project,\n        dev=dev,\n        allow_global=system,\n        concurrent=(not sequential),\n        requirements_dir=requirements_dir,\n        ignore_pipfile=True,  # Don't check if Pipfile and lock match.\n        pypi_mirror=pypi_mirror,\n        deploy=deploy,\n        system=system,\n    )\n    if not bare:\n        click.echo(crayons.green(\"All dependencies are now up-to-date!\"))\n\n\ndef do_clean(\n    project, three=None, python=None, dry_run=False, bare=False, pypi_mirror=None,\n    system=False\n):\n    # Ensure that virtualenv is available.\n    from packaging.utils import canonicalize_name\n    ensure_project(project, three=three, python=python, validate=False, pypi_mirror=pypi_mirror)\n    ensure_lockfile(project, pypi_mirror=pypi_mirror)\n    # Make sure that the virtualenv's site packages are configured correctly\n    # otherwise we may end up removing from the global site packages directory\n    installed_package_names = project.installed_package_names.copy()\n    # Remove known \"bad packages\" from the list.\n    for bad_package in BAD_PACKAGES:\n        if canonicalize_name(bad_package) in installed_package_names:\n            if project.s.is_verbose():\n                click.echo(f\"Ignoring {bad_package}.\", err=True)\n            installed_package_names.remove(canonicalize_name(bad_package))\n    # Intelligently detect if --dev should be used or not.\n    locked_packages = {\n        canonicalize_name(pkg) for pkg in project.lockfile_package_names[\"combined\"]\n    }\n    for used_package in locked_packages:\n        if used_package in installed_package_names:\n            installed_package_names.remove(used_package)\n    failure = False\n    cmd = [which_pip(project, allow_global=system), \"uninstall\", \"-y\", \"-qq\"]\n    for apparent_bad_package in installed_package_names:\n        if dry_run and not bare:\n            click.echo(apparent_bad_package)\n        else:\n            if not bare:\n                click.echo(\n                    crayons.white(\n                        fix_utf8(f\"Uninstalling {apparent_bad_package}...\"), bold=True\n                    )\n                )\n            # Uninstall the package.\n            cmd = [which_pip(project), \"uninstall\", apparent_bad_package, \"-y\"]\n            c = run_command(cmd, is_verbose=project.s.is_verbose())\n            if c.returncode != 0:\n                failure = True\n    sys.exit(int(failure))\n", "import contextlib\nimport errno\nimport logging\nimport os\nimport posixpath\nimport re\nimport shlex\nimport hashlib\nimport shutil\nimport signal\nimport stat\nimport subprocess\nimport sys\nimport warnings\n\nfrom contextlib import contextmanager\nfrom distutils.spawn import find_executable\nfrom pathlib import Path\nfrom urllib.parse import urlparse\n\nimport crayons\nimport parse\nimport toml\nimport tomlkit\n\nfrom click import echo as click_echo\n\nfrom pipenv import environments\nfrom pipenv.exceptions import (\n    PipenvCmdError, PipenvUsageError, RequirementError, ResolutionFailure\n)\nfrom pipenv.pep508checker import lookup\nfrom pipenv.vendor.packaging.markers import Marker\nfrom pipenv.vendor.urllib3 import util as urllib3_util\nfrom pipenv.vendor.vistir.compat import (\n    Mapping, ResourceWarning, Sequence, Set, TemporaryDirectory, lru_cache\n)\nfrom pipenv.vendor.vistir.misc import fs_str, run\nfrom pipenv.vendor.vistir.contextmanagers import open_file\n\n\nif environments.MYPY_RUNNING:\n    from typing import Any, Dict, List, Optional, Text, Tuple, Union\n\n    from pipenv.project import Project, TSource\n    from pipenv.vendor.requirementslib.models.pipfile import Pipfile\n    from pipenv.vendor.requirementslib.models.requirements import (\n        Line, Requirement\n    )\n\n\nlogging.basicConfig(level=logging.ERROR)\n\nspecifiers = [k for k in lookup.keys()]\n# List of version control systems we support.\nVCS_LIST = (\"git\", \"svn\", \"hg\", \"bzr\")\nSCHEME_LIST = (\"http://\", \"https://\", \"ftp://\", \"ftps://\", \"file://\")\nrequests_session = None  # type: ignore\n\n\ndef _get_requests_session(max_retries=1):\n    \"\"\"Load requests lazily.\"\"\"\n    global requests_session\n    if requests_session is not None:\n        return requests_session\n    import requests\n\n    requests_session = requests.Session()\n    adapter = requests.adapters.HTTPAdapter(max_retries=max_retries)\n    requests_session.mount(\"https://pypi.org/pypi\", adapter)\n    return requests_session\n\n\ndef cleanup_toml(tml):\n    toml = tml.split(\"\\n\")\n    new_toml = []\n    # Remove all empty lines from TOML.\n    for line in toml:\n        if line.strip():\n            new_toml.append(line)\n    toml = \"\\n\".join(new_toml)\n    new_toml = []\n    # Add newlines between TOML sections.\n    for i, line in enumerate(toml.split(\"\\n\")):\n        # Skip the first line.\n        if line.startswith(\"[\"):\n            if i > 0:\n                # Insert a newline before the heading.\n                new_toml.append(\"\")\n        new_toml.append(line)\n    # adding new line at the end of the TOML file\n    new_toml.append(\"\")\n    toml = \"\\n\".join(new_toml)\n    return toml\n\n\ndef convert_toml_outline_tables(parsed):\n    \"\"\"Converts all outline tables to inline tables.\"\"\"\n    def convert_tomlkit_table(section):\n        if isinstance(section, tomlkit.items.Table):\n            body = section.value._body\n        else:\n            body = section._body\n        for key, value in body:\n            if not key:\n                continue\n            if hasattr(value, \"keys\") and not isinstance(value, tomlkit.items.InlineTable):\n                table = tomlkit.inline_table()\n                table.update(value.value)\n                section[key.key] = table\n\n    def convert_toml_table(section):\n        for package, value in section.items():\n            if hasattr(value, \"keys\") and not isinstance(value, toml.decoder.InlineTableDict):\n                table = toml.TomlDecoder().get_empty_inline_table()\n                table.update(value)\n                section[package] = table\n\n    is_tomlkit_parsed = isinstance(parsed, tomlkit.container.Container)\n    for section in (\"packages\", \"dev-packages\"):\n        table_data = parsed.get(section, {})\n        if not table_data:\n            continue\n        if is_tomlkit_parsed:\n            convert_tomlkit_table(table_data)\n        else:\n            convert_toml_table(table_data)\n\n    return parsed\n\n\ndef run_command(cmd, *args, is_verbose=False, **kwargs):\n    \"\"\"\n    Take an input command and run it, handling exceptions and error codes and returning\n    its stdout and stderr.\n\n    :param cmd: The list of command and arguments.\n    :type cmd: list\n    :returns: A 2-tuple of the output and error from the command\n    :rtype: Tuple[str, str]\n    :raises: exceptions.PipenvCmdError\n    \"\"\"\n\n    from ._compat import decode_for_output\n    from .cmdparse import Script\n    catch_exceptions = kwargs.pop(\"catch_exceptions\", True)\n    if isinstance(cmd, ((str,), list, tuple)):\n        cmd = Script.parse(cmd)\n    if not isinstance(cmd, Script):\n        raise TypeError(\"Command input must be a string, list or tuple\")\n    if \"env\" not in kwargs:\n        kwargs[\"env\"] = os.environ.copy()\n    kwargs[\"env\"][\"PYTHONIOENCODING\"] = \"UTF-8\"\n    command = [cmd.command, *cmd.args]\n    if is_verbose:\n        click_echo(f\"Running command: $ {cmd.cmdify()}\")\n    c = subprocess_run(command, *args, **kwargs)\n    if is_verbose:\n        click_echo(\"Command output: {}\".format(\n            crayons.cyan(decode_for_output(c.stdout))\n        ), err=True)\n    if c.returncode and catch_exceptions:\n        raise PipenvCmdError(cmd.cmdify(), c.stdout, c.stderr, c.returncode)\n    return c\n\n\ndef parse_python_version(output):\n    \"\"\"Parse a Python version output returned by `python --version`.\n\n    Return a dict with three keys: major, minor, and micro. Each value is a\n    string containing a version part.\n\n    Note: The micro part would be `'0'` if it's missing from the input string.\n    \"\"\"\n    version_line = output.split(\"\\n\", 1)[0]\n    version_pattern = re.compile(\n        r\"\"\"\n        ^                   # Beginning of line.\n        Python              # Literally \"Python\".\n        \\s                  # Space.\n        (?P<major>\\d+)      # Major = one or more digits.\n        \\.                  # Dot.\n        (?P<minor>\\d+)      # Minor = one or more digits.\n        (?:                 # Unnamed group for dot-micro.\n            \\.              # Dot.\n            (?P<micro>\\d+)  # Micro = one or more digit.\n        )?                  # Micro is optional because pypa/pipenv#1893.\n        .*                  # Trailing garbage.\n        $                   # End of line.\n    \"\"\",\n        re.VERBOSE,\n    )\n\n    match = version_pattern.match(version_line)\n    if not match:\n        return None\n    return match.groupdict(default=\"0\")\n\n\ndef python_version(path_to_python):\n    from .vendor.pythonfinder.utils import get_python_version\n\n    if not path_to_python:\n        return None\n    try:\n        version = get_python_version(path_to_python)\n    except Exception:\n        return None\n    return version\n\n\ndef escape_grouped_arguments(s):\n    \"\"\"Prepares a string for the shell (on Windows too!)\n\n    Only for use on grouped arguments (passed as a string to Popen)\n    \"\"\"\n    if s is None:\n        return None\n\n    # Additional escaping for windows paths\n    if os.name == \"nt\":\n        s = \"{}\".format(s.replace(\"\\\\\", \"\\\\\\\\\"))\n    return '\"' + s.replace(\"'\", \"'\\\\''\") + '\"'\n\n\ndef clean_pkg_version(version):\n    \"\"\"Uses pip to prepare a package version string, from our internal version.\"\"\"\n    return pep440_version(str(version).replace(\"==\", \"\"))\n\n\nclass HackedPythonVersion:\n    \"\"\"A Beautiful hack, which allows us to tell pip which version of Python we're using.\"\"\"\n\n    def __init__(self, python_version, python_path):\n        self.python_version = python_version\n        self.python_path = python_path\n\n    def __enter__(self):\n        # Only inject when the value is valid\n        if self.python_version:\n            os.environ[\"PIPENV_REQUESTED_PYTHON_VERSION\"] = str(self.python_version)\n        if self.python_path:\n            os.environ[\"PIP_PYTHON_PATH\"] = str(self.python_path)\n\n    def __exit__(self, *args):\n        # Restore original Python version information.\n        try:\n            del os.environ[\"PIPENV_REQUESTED_PYTHON_VERSION\"]\n        except KeyError:\n            pass\n\n\ndef prepare_pip_source_args(sources, pip_args=None):\n    if pip_args is None:\n        pip_args = []\n    if sources:\n        # Add the source to notpip.\n        package_url = sources[0].get(\"url\")\n        if not package_url:\n            raise PipenvUsageError(\"[[source]] section does not contain a URL.\")\n        pip_args.extend([\"-i\", package_url])\n        # Trust the host if it's not verified.\n        if not sources[0].get(\"verify_ssl\", True):\n            url_parts = urllib3_util.parse_url(package_url)\n            url_port = f\":{url_parts.port}\" if url_parts.port else \"\"\n            pip_args.extend(\n                [\"--trusted-host\", f\"{url_parts.host}{url_port}\"]\n            )\n        # Add additional sources as extra indexes.\n        if len(sources) > 1:\n            for source in sources[1:]:\n                url = source.get(\"url\")\n                if not url:  # not harmless, just don't continue\n                    continue\n                pip_args.extend([\"--extra-index-url\", url])\n                # Trust the host if it's not verified.\n                if not source.get(\"verify_ssl\", True):\n                    url_parts = urllib3_util.parse_url(url)\n                    url_port = f\":{url_parts.port}\" if url_parts.port else \"\"\n                    pip_args.extend(\n                        [\"--trusted-host\", f\"{url_parts.host}{url_port}\"]\n                    )\n    return pip_args\n\n\ndef get_project_index(project, index=None, trusted_hosts=None):\n    # type: (Optional[Union[str, TSource]], Optional[List[str]], Optional[Project]) -> TSource\n    from .project import SourceNotFound\n    if trusted_hosts is None:\n        trusted_hosts = []\n    if isinstance(index, Mapping):\n        return project.find_source(index.get(\"url\"))\n    try:\n        source = project.find_source(index)\n    except SourceNotFound:\n        index_url = urllib3_util.parse_url(index)\n        src_name = project.src_name_from_url(index)\n        verify_ssl = index_url.host not in trusted_hosts\n        source = {\"url\": index, \"verify_ssl\": verify_ssl, \"name\": src_name}\n    return source\n\n\ndef get_source_list(\n    project,  # type: Project\n    index=None,  # type: Optional[Union[str, TSource]]\n    extra_indexes=None,  # type: Optional[List[str]]\n    trusted_hosts=None,  # type: Optional[List[str]]\n    pypi_mirror=None,  # type: Optional[str]\n):\n    # type: (...) -> List[TSource]\n    sources = []  # type: List[TSource]\n    if index:\n        sources.append(get_project_index(project, index))\n    if extra_indexes:\n        if isinstance(extra_indexes, str):\n            extra_indexes = [extra_indexes]\n        for source in extra_indexes:\n            extra_src = get_project_index(project, source)\n            if not sources or extra_src[\"url\"] != sources[0][\"url\"]:\n                sources.append(extra_src)\n        else:\n            for source in project.pipfile_sources:\n                if not sources or source[\"url\"] != sources[0][\"url\"]:\n                    sources.append(source)\n    if not sources:\n        sources = project.pipfile_sources[:]\n    if pypi_mirror:\n        sources = [\n            create_mirror_source(pypi_mirror) if is_pypi_url(source[\"url\"]) else source\n            for source in sources\n        ]\n    return sources\n\n\ndef get_indexes_from_requirement(req, project, index=None, extra_indexes=None, trusted_hosts=None, pypi_mirror=None):\n    # type: (Requirement, Project, Optional[Text], Optional[List[Text]], Optional[List[Text]], Optional[Text]) -> Tuple[TSource, List[TSource], List[Text]]\n    index_sources = []  # type: List[TSource]\n    if not trusted_hosts:\n        trusted_hosts = []  # type: List[Text]\n    if extra_indexes is None:\n        extra_indexes = []\n    project_indexes = project.pipfile_sources[:]\n    indexes = []\n    if req.index:\n        indexes.append(req.index)\n    if getattr(req, \"extra_indexes\", None):\n        if not isinstance(req.extra_indexes, list):\n            indexes.append(req.extra_indexes)\n        else:\n            indexes.extend(req.extra_indexes)\n    indexes.extend(project_indexes)\n    if len(indexes) > 1:\n        index, extra_indexes = indexes[0], indexes[1:]\n    index_sources = get_source_list(project, index=index, extra_indexes=extra_indexes, trusted_hosts=trusted_hosts, pypi_mirror=pypi_mirror)\n    if len(index_sources) > 1:\n        index_source, extra_index_sources = index_sources[0], index_sources[1:]\n    else:\n        index_source, extra_index_sources = index_sources[0], []\n    return index_source, extra_index_sources\n\n\n@lru_cache()\ndef get_pipenv_sitedir():\n    # type: () -> Optional[str]\n    import pkg_resources\n    site_dir = next(\n        iter(d for d in pkg_resources.working_set if d.key.lower() == \"pipenv\"), None\n    )\n    if site_dir is not None:\n        return site_dir.location\n    return None\n\n\nclass HashCacheMixin:\n\n    \"\"\"Caches hashes of PyPI artifacts so we do not need to re-download them.\n\n    Hashes are only cached when the URL appears to contain a hash in it and the\n    cache key includes the hash value returned from the server). This ought to\n    avoid issues where the location on the server changes.\n    \"\"\"\n    def __init__(self, directory, session):\n        self.session = session\n        if not os.path.isdir(directory):\n            os.makedirs(directory, exist_ok=True)\n        super().__init__(directory=directory)\n\n    def get_hash(self, link):\n        # If there is no link hash (i.e., md5, sha256, etc.), we don't want\n        # to store it.\n        hash_value = self.get(link.url)\n        if not hash_value:\n            hash_value = self._get_file_hash(link).encode()\n            self.set(link.url, hash_value)\n        return hash_value.decode(\"utf8\")\n\n    def _get_file_hash(self, link):\n        from pipenv.vendor.pip_shims import shims\n\n        h = hashlib.new(shims.FAVORITE_HASH)\n        with open_file(link.url, self.session) as fp:\n            for chunk in iter(lambda: fp.read(8096), b\"\"):\n                h.update(chunk)\n        return \":\".join([h.name, h.hexdigest()])\n\n\nclass Resolver:\n    def __init__(\n        self, constraints, req_dir, project, sources, index_lookup=None,\n        markers_lookup=None, skipped=None, clear=False, pre=False\n    ):\n        self.initial_constraints = constraints\n        self.req_dir = req_dir\n        self.project = project\n        self.sources = sources\n        self.resolved_tree = set()\n        self.hashes = {}\n        self.clear = clear\n        self.pre = pre\n        self.results = None\n        self.markers_lookup = markers_lookup if markers_lookup is not None else {}\n        self.index_lookup = index_lookup if index_lookup is not None else {}\n        self.skipped = skipped if skipped is not None else {}\n        self.markers = {}\n        self.requires_python_markers = {}\n        self._pip_args = None\n        self._constraints = None\n        self._parsed_constraints = None\n        self._resolver = None\n        self._finder = None\n        self._ignore_compatibility_finder = None\n        self._session = None\n        self._constraint_file = None\n        self._pip_options = None\n        self._pip_command = None\n        self._retry_attempts = 0\n        self._hash_cache = None\n\n    def __repr__(self):\n        return (\n            \"<Resolver (constraints={self.initial_constraints}, req_dir={self.req_dir}, \"\n            \"sources={self.sources})>\".format(self=self)\n        )\n\n    @staticmethod\n    @lru_cache()\n    def _get_pip_command():\n        from pipenv.vendor.pip_shims import shims\n\n        return shims.InstallCommand()\n\n    @property\n    def hash_cache(self):\n        from pipenv.vendor.pip_shims import shims\n\n        if not self._hash_cache:\n            self._hash_cache = type(\"HashCache\", (HashCacheMixin, shims.SafeFileCache), {})(\n                os.path.join(self.project.s.PIPENV_CACHE_DIR, \"hashes\"), self.session\n            )\n        return self._hash_cache\n\n    @classmethod\n    def get_metadata(\n        cls,\n        deps,  # type: List[str]\n        index_lookup,  # type: Dict[str, str]\n        markers_lookup,  # type: Dict[str, str]\n        project,  # type: Project\n        sources,  # type: Dict[str, str]\n        req_dir=None,  # type: Optional[str]\n        pre=False,  # type: bool\n        clear=False,  # type: bool\n    ):\n        # type: (...) -> Tuple[Set[str], Dict[str, Dict[str, Union[str, bool, List[str]]]], Dict[str, str], Dict[str, str]]\n        constraints = set()  # type: Set[str]\n        skipped = dict()  # type: Dict[str, Dict[str, Union[str, bool, List[str]]]]\n        if index_lookup is None:\n            index_lookup = {}\n        if markers_lookup is None:\n            markers_lookup = {}\n        if not req_dir:\n            from .vendor.vistir.path import create_tracked_tempdir\n            req_dir = create_tracked_tempdir(prefix=\"pipenv-\", suffix=\"-reqdir\")\n        transient_resolver = cls(\n            [], req_dir, project, sources, index_lookup=index_lookup,\n            markers_lookup=markers_lookup, clear=clear, pre=pre\n        )\n        for dep in deps:\n            if not dep:\n                continue\n            req, req_idx, markers_idx = cls.parse_line(\n                dep, index_lookup=index_lookup, markers_lookup=markers_lookup, project=project\n            )\n            index_lookup.update(req_idx)\n            markers_lookup.update(markers_idx)\n            # Add dependencies of any file (e.g. wheels/tarballs), source, or local\n            # directories into the initial constraint pool to be resolved with the\n            # rest of the dependencies, while adding the files/vcs deps/paths themselves\n            # to the lockfile directly\n            constraint_update, lockfile_update = cls.get_deps_from_req(\n                req, resolver=transient_resolver, resolve_vcs=project.s.PIPENV_RESOLVE_VCS\n            )\n            constraints |= constraint_update\n            skipped.update(lockfile_update)\n        return constraints, skipped, index_lookup, markers_lookup\n\n    @classmethod\n    def parse_line(\n        cls,\n        line,  # type: str\n        index_lookup=None,  # type: Dict[str, str]\n        markers_lookup=None,  # type: Dict[str, str]\n        project=None  # type: Optional[Project]\n    ):\n        # type: (...) -> Tuple[Requirement, Dict[str, str], Dict[str, str]]\n        from .vendor.requirementslib.models.requirements import Requirement\n        from .vendor.requirementslib.models.utils import DIRECT_URL_RE\n        if index_lookup is None:\n            index_lookup = {}\n        if markers_lookup is None:\n            markers_lookup = {}\n        if project is None:\n            from .project import Project\n            project = Project()\n        index, extra_index, trust_host, remainder = parse_indexes(line)\n        line = \" \".join(remainder)\n        req = None  # type: Requirement\n        try:\n            req = Requirement.from_line(line)\n        except ValueError:\n            direct_url = DIRECT_URL_RE.match(line)\n            if direct_url:\n                line = \"{}#egg={}\".format(line, direct_url.groupdict()[\"name\"])\n                try:\n                    req = Requirement.from_line(line)\n                except ValueError:\n                    raise ResolutionFailure(f\"Failed to resolve requirement from line: {line!s}\")\n            else:\n                raise ResolutionFailure(f\"Failed to resolve requirement from line: {line!s}\")\n        if index:\n            try:\n                index_lookup[req.normalized_name] = project.get_source(\n                    url=index, refresh=True).get(\"name\")\n            except TypeError:\n                pass\n        try:\n            req.normalized_name\n        except TypeError:\n            raise RequirementError(req=req)\n        # strip the marker and re-add it later after resolution\n        # but we will need a fallback in case resolution fails\n        # eg pypiwin32\n        if req.markers:\n            markers_lookup[req.normalized_name] = req.markers.replace('\"', \"'\")\n        return req, index_lookup, markers_lookup\n\n    @classmethod\n    def get_deps_from_req(cls, req, resolver=None, resolve_vcs=True):\n        # type: (Requirement, Optional[\"Resolver\"], bool) -> Tuple[Set[str], Dict[str, Dict[str, Union[str, bool, List[str]]]]]\n        from .vendor.requirementslib.models.requirements import Requirement\n        from .vendor.requirementslib.models.utils import (\n            _requirement_to_str_lowercase_name\n        )\n        from .vendor.requirementslib.utils import is_installable_dir\n\n        # TODO: this is way too complex, refactor this\n        constraints = set()  # type: Set[str]\n        locked_deps = dict()  # type: Dict[str, Dict[str, Union[str, bool, List[str]]]]\n        if (req.is_file_or_url or req.is_vcs) and not req.is_wheel:\n            # for local packages with setup.py files and potential direct url deps:\n            if req.is_vcs:\n                req_list, lockfile = get_vcs_deps(reqs=[req])\n                req = next(iter(req for req in req_list if req is not None), req_list)\n                entry = lockfile[pep423_name(req.normalized_name)]\n            else:\n                _, entry = req.pipfile_entry\n            parsed_line = req.req.parsed_line  # type: Line\n            setup_info = None  # type: Any\n            try:\n                name = req.normalized_name\n            except TypeError:\n                raise RequirementError(req=req)\n            setup_info = req.req.setup_info\n            setup_info.get_info()\n            locked_deps[pep423_name(name)] = entry\n            requirements = []\n            # Allow users to toggle resolution off for non-editable VCS packages\n            # but leave it on for local, installable folders on the filesystem\n            if resolve_vcs or (\n                req.editable or parsed_line.is_wheel or (\n                    req.is_file_or_url and parsed_line.is_local\n                    and is_installable_dir(parsed_line.path)\n                )\n            ):\n                requirements = [v for v in getattr(setup_info, \"requires\", {}).values()]\n            for r in requirements:\n                if getattr(r, \"url\", None) and not getattr(r, \"editable\", False):\n                    if r is not None:\n                        if not r.url:\n                            continue\n                        line = _requirement_to_str_lowercase_name(r)\n                        new_req, _, _ = cls.parse_line(line)\n                        if r.marker and not r.marker.evaluate():\n                            new_constraints = {}\n                            _, new_entry = req.pipfile_entry\n                            new_lock = {\n                                pep423_name(new_req.normalized_name): new_entry\n                            }\n                        else:\n                            new_constraints, new_lock = cls.get_deps_from_req(\n                                new_req, resolver\n                            )\n                        locked_deps.update(new_lock)\n                        constraints |= new_constraints\n                # if there is no marker or there is a valid marker, add the constraint line\n                elif r and (not r.marker or (r.marker and r.marker.evaluate())):\n                    line = _requirement_to_str_lowercase_name(r)\n                    constraints.add(line)\n            # ensure the top level entry remains as provided\n            # note that we shouldn't pin versions for editable vcs deps\n            if not req.is_vcs:\n                if req.specifiers:\n                    locked_deps[name][\"version\"] = req.specifiers\n                elif parsed_line.setup_info and parsed_line.setup_info.version:\n                    locked_deps[name][\"version\"] = \"=={}\".format(\n                        parsed_line.setup_info.version\n                    )\n            # if not req.is_vcs:\n            locked_deps.update({name: entry})\n        else:\n            # if the dependency isn't installable, don't add it to constraints\n            # and instead add it directly to the lock\n            if req and req.requirement and (\n                req.requirement.marker and not req.requirement.marker.evaluate()\n            ):\n                pypi = resolver.finder if resolver else None\n                ireq = req.ireq\n                best_match = pypi.find_best_candidate(ireq.name, ireq.specifier).best_candidate if pypi else None\n                if best_match:\n                    ireq.req.specifier = ireq.specifier.__class__(f\"=={best_match.version}\")\n                    hashes = resolver.collect_hashes(ireq) if resolver else []\n                    new_req = Requirement.from_ireq(ireq)\n                    new_req = new_req.add_hashes(hashes)\n                    name, entry = new_req.pipfile_entry\n                    locked_deps[pep423_name(name)] = translate_markers(entry)\n                    click_echo(\n                        \"{} doesn't match your environment, \"\n                        \"its dependencies won't be resolved.\".format(req.as_line()),\n                        err=True\n                    )\n                else:\n                    click_echo(\n                        \"Could not find a version of {} that matches your environment, \"\n                        \"it will be skipped.\".format(req.as_line()),\n                        err=True\n                    )\n                return constraints, locked_deps\n            constraints.add(req.constraint_line)\n            return constraints, locked_deps\n        return constraints, locked_deps\n\n    @classmethod\n    def create(\n        cls,\n        deps,  # type: List[str]\n        project,  # type: Project\n        index_lookup=None,  # type: Dict[str, str]\n        markers_lookup=None,  # type: Dict[str, str]\n        sources=None,  # type: List[str]\n        req_dir=None,  # type: str\n        clear=False,  # type: bool\n        pre=False  # type: bool\n    ):\n        # type: (...) -> \"Resolver\"\n        from pipenv.vendor.vistir.path import create_tracked_tempdir\n        if not req_dir:\n            req_dir = create_tracked_tempdir(suffix=\"-requirements\", prefix=\"pipenv-\")\n        if index_lookup is None:\n            index_lookup = {}\n        if markers_lookup is None:\n            markers_lookup = {}\n        if sources is None:\n            sources = project.sources\n        constraints, skipped, index_lookup, markers_lookup = cls.get_metadata(\n            deps, index_lookup, markers_lookup, project, sources, req_dir=req_dir,\n            pre=pre, clear=clear\n        )\n        return Resolver(\n            constraints, req_dir, project, sources, index_lookup=index_lookup,\n            markers_lookup=markers_lookup, skipped=skipped, clear=clear, pre=pre\n        )\n\n    @classmethod\n    def from_pipfile(cls, project, pipfile=None, dev=False, pre=False, clear=False):\n        # type: (Optional[Project], Optional[Pipfile], bool, bool, bool) -> \"Resolver\"\n        from pipenv.vendor.vistir.path import create_tracked_tempdir\n        if not pipfile:\n            pipfile = project._pipfile\n        req_dir = create_tracked_tempdir(suffix=\"-requirements\", prefix=\"pipenv-\")\n        index_lookup, markers_lookup = {}, {}\n        deps = set()\n        if dev:\n            deps.update({req.as_line() for req in pipfile.dev_packages})\n        deps.update({req.as_line() for req in pipfile.packages})\n        constraints, skipped, index_lookup, markers_lookup = cls.get_metadata(\n            list(deps), index_lookup, markers_lookup, project, project.sources,\n            req_dir=req_dir, pre=pre, clear=clear\n        )\n        return Resolver(\n            constraints, req_dir, project, project.sources, index_lookup=index_lookup,\n            markers_lookup=markers_lookup, skipped=skipped, clear=clear, pre=pre\n        )\n\n    @property\n    def pip_command(self):\n        if self._pip_command is None:\n            self._pip_command = self._get_pip_command()\n        return self._pip_command\n\n    def prepare_pip_args(self, use_pep517=None, build_isolation=True):\n        pip_args = []\n        if self.sources:\n            pip_args = prepare_pip_source_args(self.sources, pip_args)\n        if use_pep517 is False:\n            pip_args.append(\"--no-use-pep517\")\n        if build_isolation is False:\n            pip_args.append(\"--no-build-isolation\")\n        if self.pre:\n            pip_args.append(\"--pre\")\n        pip_args.extend([\"--cache-dir\", self.project.s.PIPENV_CACHE_DIR])\n        return pip_args\n\n    @property\n    def pip_args(self):\n        use_pep517 = environments.get_from_env(\"USE_PEP517\", prefix=\"PIP\")\n        build_isolation = environments.get_from_env(\"BUILD_ISOLATION\", prefix=\"PIP\")\n        if self._pip_args is None:\n            self._pip_args = self.prepare_pip_args(\n                use_pep517=use_pep517, build_isolation=build_isolation\n            )\n        return self._pip_args\n\n    def prepare_constraint_file(self):\n        from pipenv.vendor.vistir.path import create_tracked_tempfile\n        constraints_file = create_tracked_tempfile(\n            mode=\"w\",\n            prefix=\"pipenv-\",\n            suffix=\"-constraints.txt\",\n            dir=self.req_dir,\n            delete=False,\n        )\n        skip_args = (\"build-isolation\", \"use-pep517\", \"cache-dir\")\n        args_to_add = [\n            arg for arg in self.pip_args\n            if not any(bad_arg in arg for bad_arg in skip_args)\n        ]\n        if self.sources:\n            requirementstxt_sources = \" \".join(args_to_add) if args_to_add else \"\"\n            requirementstxt_sources = requirementstxt_sources.replace(\" --\", \"\\n--\")\n            constraints_file.write(f\"{requirementstxt_sources}\\n\")\n        constraints = self.initial_constraints\n        constraints_file.write(\"\\n\".join([c for c in constraints]))\n        constraints_file.close()\n        return constraints_file.name\n\n    @property\n    def constraint_file(self):\n        if self._constraint_file is None:\n            self._constraint_file = self.prepare_constraint_file()\n        return self._constraint_file\n\n    @property\n    def pip_options(self):\n        if self._pip_options is None:\n            pip_options, _ = self.pip_command.parser.parse_args(self.pip_args)\n            pip_options.cache_dir = self.project.s.PIPENV_CACHE_DIR\n            pip_options.no_python_version_warning = True\n            pip_options.no_input = True\n            pip_options.progress_bar = \"off\"\n            pip_options.ignore_requires_python = True\n            pip_options.pre = self.pre or self.project.settings.get(\"allow_prereleases\", False)\n            self._pip_options = pip_options\n        return self._pip_options\n\n    @property\n    def session(self):\n        if self._session is None:\n            self._session = self.pip_command._build_session(self.pip_options)\n        return self._session\n\n    @property\n    def finder(self):\n        from pipenv.vendor.pip_shims import shims\n        if self._finder is None:\n            self._finder = shims.get_package_finder(\n                install_cmd=self.pip_command,\n                options=self.pip_options,\n                session=self.session\n            )\n        return self._finder\n\n    @property\n    def ignore_compatibility_finder(self):\n        from pipenv.vendor.pip_shims import shims\n        if self._ignore_compatibility_finder is None:\n            ignore_compatibility_finder = shims.get_package_finder(\n                install_cmd=self.pip_command,\n                options=self.pip_options,\n                session=self.session,\n            )\n            # It would be nice if `shims.get_package_finder` took an\n            # `ignore_compatibility` parameter, but that's some vendorered code\n            # we'd rather avoid touching.\n            ignore_compatibility_finder._ignore_compatibility = True\n            self._ignore_compatibility_finder = ignore_compatibility_finder\n        return self._ignore_compatibility_finder\n\n    @property\n    def parsed_constraints(self):\n        from pipenv.vendor.pip_shims import shims\n\n        if self._parsed_constraints is None:\n            self._parsed_constraints = shims.parse_requirements(\n                self.constraint_file, finder=self.finder, session=self.session,\n                options=self.pip_options\n            )\n        return self._parsed_constraints\n\n    @property\n    def constraints(self):\n        from pipenv.patched.notpip._internal.req.constructors import install_req_from_parsed_requirement\n\n        if self._constraints is None:\n            self._constraints = [\n                install_req_from_parsed_requirement(\n                    c, isolated=self.pip_options.build_isolation,\n                    use_pep517=self.pip_options.use_pep517, user_supplied=True\n                )\n                for c in self.parsed_constraints\n            ]\n        return self._constraints\n\n    @contextlib.contextmanager\n    def get_resolver(self, clear=False):\n        from pipenv.vendor.pip_shims.shims import (\n            WheelCache, get_requirement_tracker, global_tempdir_manager\n        )\n\n        with global_tempdir_manager(), get_requirement_tracker() as req_tracker, TemporaryDirectory(suffix=\"-build\", prefix=\"pipenv-\") as directory:\n            pip_options = self.pip_options\n            finder = self.finder\n            wheel_cache = WheelCache(pip_options.cache_dir, pip_options.format_control)\n            directory.path = directory.name\n            preparer = self.pip_command.make_requirement_preparer(\n                temp_build_dir=directory,\n                options=pip_options,\n                req_tracker=req_tracker,\n                session=self.session,\n                finder=finder,\n                use_user_site=False,\n            )\n            resolver = self.pip_command.make_resolver(\n                preparer=preparer,\n                finder=finder,\n                options=pip_options,\n                wheel_cache=wheel_cache,\n                use_user_site=False,\n                ignore_installed=True,\n                ignore_requires_python=pip_options.ignore_requires_python,\n                force_reinstall=pip_options.force_reinstall,\n                upgrade_strategy=\"to-satisfy-only\",\n                use_pep517=pip_options.use_pep517,\n            )\n            yield resolver\n\n    def resolve(self):\n        from pipenv.vendor.pip_shims.shims import InstallationError\n        from pipenv.exceptions import ResolutionFailure\n\n        with temp_environ(), self.get_resolver() as resolver:\n            try:\n                results = resolver.resolve(self.constraints, check_supported_wheels=False)\n            except InstallationError as e:\n                raise ResolutionFailure(message=str(e))\n            else:\n                self.results = set(results.all_requirements)\n                self.resolved_tree.update(self.results)\n        return self.resolved_tree\n\n    def resolve_constraints(self):\n        from .vendor.requirementslib.models.markers import marker_from_specifier\n        new_tree = set()\n        for result in self.resolved_tree:\n            if result.markers:\n                self.markers[result.name] = result.markers\n            else:\n                candidate = self.finder.find_best_candidate(result.name, result.specifier).best_candidate\n                if candidate:\n                    requires_python = candidate.link.requires_python\n                    if requires_python:\n                        marker = marker_from_specifier(requires_python)\n                        self.markers[result.name] = marker\n                        result.markers = marker\n                        if result.req:\n                            result.req.marker = marker\n            new_tree.add(result)\n        self.resolved_tree = new_tree\n\n    @classmethod\n    def prepend_hash_types(cls, checksums, hash_type):\n        cleaned_checksums = set()\n        for checksum in checksums:\n            if not checksum:\n                continue\n            if not checksum.startswith(f\"{hash_type}:\"):\n                checksum = f\"{hash_type}:{checksum}\"\n            cleaned_checksums.add(checksum)\n        return cleaned_checksums\n\n    def _get_hashes_from_pypi(self, ireq):\n        from pipenv.vendor.pip_shims import shims\n\n        pkg_url = f\"https://pypi.org/pypi/{ireq.name}/json\"\n        session = _get_requests_session(self.project.s.PIPENV_MAX_RETRIES)\n        try:\n            collected_hashes = set()\n            # Grab the hashes from the new warehouse API.\n            r = session.get(pkg_url, timeout=10)\n            api_releases = r.json()[\"releases\"]\n            cleaned_releases = {}\n            for api_version, api_info in api_releases.items():\n                api_version = clean_pkg_version(api_version)\n                cleaned_releases[api_version] = api_info\n            version = \"\"\n            if ireq.specifier:\n                spec = next(iter(s for s in ireq.specifier), None)\n                if spec:\n                    version = spec.version\n            for release in cleaned_releases[version]:\n                collected_hashes.add(release[\"digests\"][shims.FAVORITE_HASH])\n            return self.prepend_hash_types(collected_hashes, shims.FAVORITE_HASH)\n        except (ValueError, KeyError, ConnectionError):\n            if self.project.s.is_verbose():\n                click_echo(\n                    \"{}: Error generating hash for {}\".format(\n                        crayons.red(\"Warning\", bold=True), ireq.name\n                    ), err=True\n                )\n            return None\n\n    def collect_hashes(self, ireq):\n        if ireq.link:\n            link = ireq.link\n            if link.is_vcs or (link.is_file and link.is_existing_dir()):\n                return set()\n            if ireq.original_link:\n                return {self._get_hash_from_link(ireq.original_link)}\n\n        if not is_pinned_requirement(ireq):\n            return set()\n\n        if any(\n            \"python.org\" in source[\"url\"] or \"pypi.org\" in source[\"url\"]\n            for source in self.sources\n        ):\n            hashes = self._get_hashes_from_pypi(ireq)\n            if hashes:\n                return hashes\n\n        applicable_candidates = self.ignore_compatibility_finder.find_best_candidate(\n            ireq.name, ireq.specifier\n        ).iter_applicable()\n        return {\n            self._get_hash_from_link(candidate.link)\n            for candidate in applicable_candidates\n        }\n\n    def resolve_hashes(self):\n        if self.results is not None:\n            for ireq in self.results:\n                self.hashes[ireq] = self.collect_hashes(ireq)\n        return self.hashes\n\n    def _get_hash_from_link(self, link):\n        from pipenv.vendor.pip_shims import shims\n\n        if link.hash and link.hash_name == shims.FAVORITE_HASH:\n            return f\"{link.hash_name}:{link.hash}\"\n\n        return self.hash_cache.get_hash(link)\n\n    def _clean_skipped_result(self, req, value):\n        ref = None\n        if req.is_vcs:\n            ref = req.commit_hash\n        ireq = req.as_ireq()\n        entry = value.copy()\n        entry[\"name\"] = req.name\n        if entry.get(\"editable\", False) and entry.get(\"version\"):\n            del entry[\"version\"]\n        ref = ref if ref is not None else entry.get(\"ref\")\n        if ref:\n            entry[\"ref\"] = ref\n        collected_hashes = self.collect_hashes(ireq)\n        if collected_hashes:\n            entry[\"hashes\"] = sorted(set(collected_hashes))\n        return req.name, entry\n\n    def clean_results(self):\n        from pipenv.vendor.requirementslib.models.requirements import (\n            Requirement\n        )\n        reqs = [(Requirement.from_ireq(ireq), ireq) for ireq in self.resolved_tree]\n        results = {}\n        for req, ireq in reqs:\n            if (req.vcs and req.editable and not req.is_direct_url):\n                continue\n            elif req.normalized_name in self.skipped.keys():\n                continue\n            collected_hashes = self.hashes.get(ireq, set())\n            req = req.add_hashes(collected_hashes)\n            if collected_hashes:\n                collected_hashes = sorted(collected_hashes)\n            name, entry = format_requirement_for_lockfile(\n                req, self.markers_lookup, self.index_lookup, collected_hashes\n            )\n            entry = translate_markers(entry)\n            if name in results:\n                results[name].update(entry)\n            else:\n                results[name] = entry\n        for k in list(self.skipped.keys()):\n            req = Requirement.from_pipfile(k, self.skipped[k])\n            name, entry = self._clean_skipped_result(req, self.skipped[k])\n            entry = translate_markers(entry)\n            if name in results:\n                results[name].update(entry)\n            else:\n                results[name] = entry\n        results = list(results.values())\n        return results\n\n\ndef format_requirement_for_lockfile(req, markers_lookup, index_lookup, hashes=None):\n    if req.specifiers:\n        version = str(req.get_version())\n    else:\n        version = None\n    index = index_lookup.get(req.normalized_name)\n    markers = markers_lookup.get(req.normalized_name)\n    req.index = index\n    name, pf_entry = req.pipfile_entry\n    name = pep423_name(req.name)\n    entry = {}\n    if isinstance(pf_entry, str):\n        entry[\"version\"] = pf_entry.lstrip(\"=\")\n    else:\n        entry.update(pf_entry)\n        if version is not None and not req.is_vcs:\n            entry[\"version\"] = version\n        if req.line_instance.is_direct_url and not req.is_vcs:\n            entry[\"file\"] = req.req.uri\n    if hashes:\n        entry[\"hashes\"] = sorted(set(hashes))\n    entry[\"name\"] = name\n    if index:\n        entry.update({\"index\": index})\n    if markers:\n        entry.update({\"markers\": markers})\n    entry = translate_markers(entry)\n    if req.vcs or req.editable:\n        for key in (\"index\", \"version\", \"file\"):\n            try:\n                del entry[key]\n            except KeyError:\n                pass\n    return name, entry\n\n\ndef _show_warning(message, category, filename, lineno, line):\n    warnings.showwarning(message=message, category=category, filename=filename,\n                         lineno=lineno, file=sys.stderr, line=line)\n    sys.stderr.flush()\n\n\ndef actually_resolve_deps(\n    deps,\n    index_lookup,\n    markers_lookup,\n    project,\n    sources,\n    clear,\n    pre,\n    req_dir=None,\n):\n    from pipenv.vendor.vistir.path import create_tracked_tempdir\n\n    if not req_dir:\n        req_dir = create_tracked_tempdir(suffix=\"-requirements\", prefix=\"pipenv-\")\n    warning_list = []\n\n    with warnings.catch_warnings(record=True) as warning_list:\n        resolver = Resolver.create(\n            deps, project, index_lookup, markers_lookup, sources, req_dir, clear, pre\n        )\n        resolver.resolve()\n        hashes = resolver.resolve_hashes()\n        resolver.resolve_constraints()\n        results = resolver.clean_results()\n    for warning in warning_list:\n        _show_warning(warning.message, warning.category, warning.filename, warning.lineno,\n                      warning.line)\n    return (results, hashes, resolver.markers_lookup, resolver, resolver.skipped)\n\n\n@contextlib.contextmanager\ndef create_spinner(text, setting, nospin=None, spinner_name=None):\n    from .vendor.vistir import spin\n    from .vendor.vistir.misc import fs_str\n    if not spinner_name:\n        spinner_name = setting.PIPENV_SPINNER\n    if nospin is None:\n        nospin = setting.PIPENV_NOSPIN\n    with spin.create_spinner(\n        spinner_name=spinner_name,\n        start_text=fs_str(text),\n        nospin=nospin, write_to_stdout=False\n    ) as sp:\n        yield sp\n\n\ndef resolve(cmd, sp, project):\n    from ._compat import decode_output\n    from .cmdparse import Script\n    from .vendor.vistir.misc import echo\n    c = subprocess_run(Script.parse(cmd).cmd_args, block=False, env=os.environ.copy())\n    is_verbose = project.s.is_verbose()\n    err = \"\"\n    for line in iter(c.stderr.readline, \"\"):\n        line = decode_output(line)\n        if not line.rstrip():\n            continue\n        err += line\n        if is_verbose:\n            sp.hide_and_write(line.rstrip())\n\n    c.wait()\n    returncode = c.poll()\n    out = c.stdout.read()\n    if returncode != 0:\n        sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\n            \"Locking Failed!\"\n        ))\n        echo(out.strip(), err=True)\n        if not is_verbose:\n            echo(err, err=True)\n        sys.exit(returncode)\n    if is_verbose:\n        echo(out.strip(), err=True)\n    return subprocess.CompletedProcess(c.args, returncode, out, err)\n\n\ndef get_locked_dep(dep, pipfile_section, prefer_pipfile=True):\n    # the prefer pipfile flag is not used yet, but we are introducing\n    # it now for development purposes\n    # TODO: Is this implementation clear? How can it be improved?\n    entry = None\n    cleaner_kwargs = {\n        \"is_top_level\": False,\n        \"pipfile_entry\": None\n    }\n    if isinstance(dep, Mapping) and dep.get(\"name\", \"\"):\n        dep_name = pep423_name(dep[\"name\"])\n        name = next(iter(\n            k for k in pipfile_section.keys()\n            if pep423_name(k) == dep_name\n        ), None)\n        entry = pipfile_section[name] if name else None\n\n    if entry:\n        cleaner_kwargs.update({\"is_top_level\": True, \"pipfile_entry\": entry})\n    lockfile_entry = clean_resolved_dep(dep, **cleaner_kwargs)\n    if entry and isinstance(entry, Mapping):\n        version = entry.get(\"version\", \"\") if entry else \"\"\n    else:\n        version = entry if entry else \"\"\n    lockfile_name, lockfile_dict = lockfile_entry.copy().popitem()\n    lockfile_version = lockfile_dict.get(\"version\", \"\")\n    # Keep pins from the lockfile\n    if prefer_pipfile and lockfile_version != version and version.startswith(\"==\") and \"*\" not in version:\n        lockfile_dict[\"version\"] = version\n    lockfile_entry[lockfile_name] = lockfile_dict\n    return lockfile_entry\n\n\ndef prepare_lockfile(results, pipfile, lockfile):\n    # from .vendor.requirementslib.utils import is_vcs\n    for dep in results:\n        if not dep:\n            continue\n        # Merge in any relevant information from the pipfile entry, including\n        # markers, normalized names, URL info, etc that we may have dropped during lock\n        # if not is_vcs(dep):\n        lockfile_entry = get_locked_dep(dep, pipfile)\n        name = next(iter(k for k in lockfile_entry.keys()))\n        current_entry = lockfile.get(name)\n        if current_entry:\n            if not isinstance(current_entry, Mapping):\n                lockfile[name] = lockfile_entry[name]\n            else:\n                lockfile[name].update(lockfile_entry[name])\n                lockfile[name] = translate_markers(lockfile[name])\n        else:\n            lockfile[name] = lockfile_entry[name]\n    return lockfile\n\n\ndef venv_resolve_deps(\n    deps,\n    which,\n    project,\n    pre=False,\n    clear=False,\n    allow_global=False,\n    pypi_mirror=None,\n    dev=False,\n    pipfile=None,\n    lockfile=None,\n    keep_outdated=False\n):\n    \"\"\"\n    Resolve dependencies for a pipenv project, acts as a portal to the target environment.\n\n    Regardless of whether a virtual environment is present or not, this will spawn\n    a subproces which is isolated to the target environment and which will perform\n    dependency resolution.  This function reads the output of that call and mutates\n    the provided lockfile accordingly, returning nothing.\n\n    :param List[:class:`~requirementslib.Requirement`] deps: A list of dependencies to resolve.\n    :param Callable which: [description]\n    :param project: The pipenv Project instance to use during resolution\n    :param Optional[bool] pre: Whether to resolve pre-release candidates, defaults to False\n    :param Optional[bool] clear: Whether to clear the cache during resolution, defaults to False\n    :param Optional[bool] allow_global: Whether to use *sys.executable* as the python binary, defaults to False\n    :param Optional[str] pypi_mirror: A URL to substitute any time *pypi.org* is encountered, defaults to None\n    :param Optional[bool] dev: Whether to target *dev-packages* or not, defaults to False\n    :param pipfile: A Pipfile section to operate on, defaults to None\n    :type pipfile: Optional[Dict[str, Union[str, Dict[str, bool, List[str]]]]]\n    :param Dict[str, Any] lockfile: A project lockfile to mutate, defaults to None\n    :param bool keep_outdated: Whether to retain outdated dependencies and resolve with them in mind, defaults to False\n    :raises RuntimeError: Raised on resolution failure\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    import json\n\n    from . import resolver\n    from ._compat import decode_for_output\n    from .vendor.vistir.compat import JSONDecodeError, NamedTemporaryFile, Path\n    from .vendor.vistir.misc import fs_str\n    from .vendor.vistir.path import create_tracked_tempdir\n\n    results = []\n    pipfile_section = \"dev-packages\" if dev else \"packages\"\n    lockfile_section = \"develop\" if dev else \"default\"\n    if not deps:\n        if not project.pipfile_exists:\n            return None\n        deps = project.parsed_pipfile.get(pipfile_section, {})\n    if not deps:\n        return None\n\n    if not pipfile:\n        pipfile = getattr(project, pipfile_section, {})\n    if not lockfile:\n        lockfile = project._lockfile\n    req_dir = create_tracked_tempdir(prefix=\"pipenv\", suffix=\"requirements\")\n    cmd = [\n        which(\"python\", allow_global=allow_global),\n        Path(resolver.__file__.rstrip(\"co\")).as_posix()\n    ]\n    if pre:\n        cmd.append(\"--pre\")\n    if clear:\n        cmd.append(\"--clear\")\n    if allow_global:\n        cmd.append(\"--system\")\n    if dev:\n        cmd.append(\"--dev\")\n    target_file = NamedTemporaryFile(prefix=\"resolver\", suffix=\".json\", delete=False)\n    target_file.close()\n    cmd.extend([\"--write\", make_posix(target_file.name)])\n    with temp_environ():\n        os.environ.update({fs_str(k): fs_str(val) for k, val in os.environ.items()})\n        if pypi_mirror:\n            os.environ[\"PIPENV_PYPI_MIRROR\"] = str(pypi_mirror)\n        os.environ[\"PIPENV_VERBOSITY\"] = str(project.s.PIPENV_VERBOSITY)\n        os.environ[\"PIPENV_REQ_DIR\"] = fs_str(req_dir)\n        os.environ[\"PIP_NO_INPUT\"] = fs_str(\"1\")\n        pipenv_site_dir = get_pipenv_sitedir()\n        if pipenv_site_dir is not None:\n            os.environ[\"PIPENV_SITE_DIR\"] = pipenv_site_dir\n        else:\n            os.environ.pop(\"PIPENV_SITE_DIR\", None)\n        if keep_outdated:\n            os.environ[\"PIPENV_KEEP_OUTDATED\"] = fs_str(\"1\")\n        with create_spinner(text=decode_for_output(\"Locking...\"), setting=project.s) as sp:\n            # This conversion is somewhat slow on local and file-type requirements since\n            # we now download those requirements / make temporary folders to perform\n            # dependency resolution on them, so we are including this step inside the\n            # spinner context manager for the UX improvement\n            sp.write(decode_for_output(\"Building requirements...\"))\n            deps = convert_deps_to_pip(\n                deps, project, r=False, include_index=True\n            )\n            constraints = set(deps)\n            os.environ[\"PIPENV_PACKAGES\"] = str(\"\\n\".join(constraints))\n            sp.write(decode_for_output(\"Resolving dependencies...\"))\n            c = resolve(cmd, sp, project=project)\n            results = c.stdout.strip()\n            if c.returncode == 0:\n                sp.green.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Success!\"))\n                if not project.s.is_verbose() and c.stderr.strip():\n                    click_echo(crayons.yellow(f\"Warning: {c.stderr.strip()}\"), err=True)\n            else:\n                sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Locking Failed!\"))\n                click_echo(f\"Output: {c.stdout.strip()}\", err=True)\n                click_echo(f\"Error: {c.stderr.strip()}\", err=True)\n    try:\n        with open(target_file.name) as fh:\n            results = json.load(fh)\n    except (IndexError, JSONDecodeError):\n        click_echo(c.stdout.strip(), err=True)\n        click_echo(c.stderr.strip(), err=True)\n        if os.path.exists(target_file.name):\n            os.unlink(target_file.name)\n        raise RuntimeError(\"There was a problem with locking.\")\n    if os.path.exists(target_file.name):\n        os.unlink(target_file.name)\n    if lockfile_section not in lockfile:\n        lockfile[lockfile_section] = {}\n    prepare_lockfile(results, pipfile, lockfile[lockfile_section])\n\n\ndef resolve_deps(\n    deps,\n    which,\n    project,\n    sources=None,\n    python=False,\n    clear=False,\n    pre=False,\n    allow_global=False,\n    req_dir=None\n):\n    \"\"\"Given a list of dependencies, return a resolved list of dependencies,\n    using pip-tools -- and their hashes, using the warehouse API / pip.\n    \"\"\"\n    index_lookup = {}\n    markers_lookup = {}\n    python_path = which(\"python\", allow_global=allow_global)\n    if not os.environ.get(\"PIP_SRC\"):\n        os.environ[\"PIP_SRC\"] = project.virtualenv_src_location\n    backup_python_path = sys.executable\n    results = []\n    resolver = None\n    if not deps:\n        return results, resolver\n    # First (proper) attempt:\n    req_dir = req_dir if req_dir else os.environ.get(\"req_dir\", None)\n    if not req_dir:\n        from .vendor.vistir.path import create_tracked_tempdir\n        req_dir = create_tracked_tempdir(prefix=\"pipenv-\", suffix=\"-requirements\")\n    with HackedPythonVersion(python_version=python, python_path=python_path):\n        try:\n            results, hashes, markers_lookup, resolver, skipped = actually_resolve_deps(\n                deps,\n                index_lookup,\n                markers_lookup,\n                project,\n                sources,\n                clear,\n                pre,\n                req_dir=req_dir,\n            )\n        except RuntimeError:\n            # Don't exit here, like usual.\n            results = None\n    # Second (last-resort) attempt:\n    if results is None:\n        with HackedPythonVersion(\n            python_version=\".\".join([str(s) for s in sys.version_info[:3]]),\n            python_path=backup_python_path,\n        ):\n            try:\n                # Attempt to resolve again, with different Python version information,\n                # particularly for particularly particular packages.\n                results, hashes, markers_lookup, resolver, skipped = actually_resolve_deps(\n                    deps,\n                    index_lookup,\n                    markers_lookup,\n                    project,\n                    sources,\n                    clear,\n                    pre,\n                    req_dir=req_dir,\n                )\n            except RuntimeError:\n                sys.exit(1)\n    return results, resolver\n\n\ndef is_star(val):\n    return isinstance(val, str) and val == \"*\"\n\n\ndef is_pinned(val):\n    if isinstance(val, Mapping):\n        val = val.get(\"version\")\n    return isinstance(val, str) and val.startswith(\"==\")\n\n\ndef is_pinned_requirement(ireq):\n    \"\"\"\n    Returns whether an InstallRequirement is a \"pinned\" requirement.\n    \"\"\"\n    if ireq.editable:\n        return False\n\n    if ireq.req is None or len(ireq.specifier) != 1:\n        return False\n\n    spec = next(iter(ireq.specifier))\n    return spec.operator in {\"==\", \"===\"} and not spec.version.endswith(\".*\")\n\n\ndef convert_deps_to_pip(deps, project=None, r=True, include_index=True):\n    \"\"\"\"Converts a Pipfile-formatted dependency to a pip-formatted one.\"\"\"\n    from .vendor.requirementslib.models.requirements import Requirement\n\n    dependencies = []\n    for dep_name, dep in deps.items():\n        if project:\n            project.clear_pipfile_cache()\n        indexes = getattr(project, \"pipfile_sources\", []) if project is not None else []\n        new_dep = Requirement.from_pipfile(dep_name, dep)\n        if new_dep.index:\n            include_index = True\n        req = new_dep.as_line(sources=indexes if include_index else None).strip()\n        dependencies.append(req)\n    if not r:\n        return dependencies\n\n    # Write requirements.txt to tmp directory.\n    from .vendor.vistir.path import create_tracked_tempfile\n    f = create_tracked_tempfile(suffix=\"-requirements.txt\", delete=False)\n    f.write(\"\\n\".join(dependencies).encode(\"utf-8\"))\n    f.close()\n    return f.name\n\n\ndef mkdir_p(newdir):\n    \"\"\"works the way a good mkdir should :)\n        - already exists, silently complete\n        - regular file in the way, raise an exception\n        - parent directory(ies) does not exist, make them as well\n        From: http://code.activestate.com/recipes/82465-a-friendly-mkdir/\n    \"\"\"\n    if os.path.isdir(newdir):\n        pass\n    elif os.path.isfile(newdir):\n        raise OSError(\n            \"a file with the same name as the desired dir, '{}', already exists.\".format(\n                newdir\n            )\n        )\n\n    else:\n        head, tail = os.path.split(newdir)\n        if head and not os.path.isdir(head):\n            mkdir_p(head)\n        if tail:\n            # Even though we've checked that the directory doesn't exist above, it might exist\n            # now if some other process has created it between now and the time we checked it.\n            try:\n                os.mkdir(newdir)\n            except OSError as exn:\n                # If we failed because the directory does exist, that's not a problem -\n                # that's what we were trying to do anyway. Only re-raise the exception\n                # if we failed for some other reason.\n                if exn.errno != errno.EEXIST:\n                    raise\n\n\ndef is_required_version(version, specified_version):\n    \"\"\"Check to see if there's a hard requirement for version\n    number provided in the Pipfile.\n    \"\"\"\n    # Certain packages may be defined with multiple values.\n    if isinstance(specified_version, dict):\n        specified_version = specified_version.get(\"version\", \"\")\n    if specified_version.startswith(\"==\"):\n        return version.strip() == specified_version.split(\"==\")[1].strip()\n\n    return True\n\n\ndef is_editable(pipfile_entry):\n    if hasattr(pipfile_entry, \"get\"):\n        return pipfile_entry.get(\"editable\", False) and any(\n            pipfile_entry.get(key) for key in (\"file\", \"path\") + VCS_LIST\n        )\n    return False\n\n\ndef is_installable_file(path):\n    \"\"\"Determine if a path can potentially be installed\"\"\"\n    from .patched.notpip._internal.utils.packaging import specifiers\n    from .vendor.pip_shims.shims import is_archive_file, is_installable_dir\n\n    if hasattr(path, \"keys\") and any(\n        key for key in path.keys() if key in [\"file\", \"path\"]\n    ):\n        path = urlparse(path[\"file\"]).path if \"file\" in path else path[\"path\"]\n    if not isinstance(path, str) or path == \"*\":\n        return False\n\n    # If the string starts with a valid specifier operator, test if it is a valid\n    # specifier set before making a path object (to avoid breaking windows)\n    if any(path.startswith(spec) for spec in \"!=<>~\"):\n        try:\n            specifiers.SpecifierSet(path)\n        # If this is not a valid specifier, just move on and try it as a path\n        except specifiers.InvalidSpecifier:\n            pass\n        else:\n            return False\n\n    if not os.path.exists(os.path.abspath(path)):\n        return False\n\n    lookup_path = Path(path)\n    absolute_path = f\"{lookup_path.absolute()}\"\n    if lookup_path.is_dir() and is_installable_dir(absolute_path):\n        return True\n\n    elif lookup_path.is_file() and is_archive_file(absolute_path):\n        return True\n\n    return False\n\n\ndef is_file(package):\n    \"\"\"Determine if a package name is for a File dependency.\"\"\"\n    if hasattr(package, \"keys\"):\n        return any(key for key in package.keys() if key in [\"file\", \"path\"])\n\n    if os.path.exists(str(package)):\n        return True\n\n    for start in SCHEME_LIST:\n        if str(package).startswith(start):\n            return True\n\n    return False\n\n\ndef pep440_version(version):\n    \"\"\"Normalize version to PEP 440 standards\"\"\"\n    # Use pip built-in version parser.\n    from pipenv.vendor.pip_shims import shims\n\n    return str(shims.parse_version(version))\n\n\ndef pep423_name(name):\n    \"\"\"Normalize package name to PEP 423 style standard.\"\"\"\n    name = name.lower()\n    if any(i not in name for i in (VCS_LIST + SCHEME_LIST)):\n        return name.replace(\"_\", \"-\")\n\n    else:\n        return name\n\n\ndef proper_case(package_name):\n    \"\"\"Properly case project name from pypi.org.\"\"\"\n    # Hit the simple API.\n    r = _get_requests_session().get(\n        f\"https://pypi.org/pypi/{package_name}/json\", timeout=0.3, stream=True\n    )\n    if not r.ok:\n        raise OSError(\n            f\"Unable to find package {package_name} in PyPI repository.\"\n        )\n\n    r = parse.parse(\"https://pypi.org/pypi/{name}/json\", r.url)\n    good_name = r[\"name\"]\n    return good_name\n\n\ndef get_windows_path(*args):\n    \"\"\"Sanitize a path for windows environments\n\n    Accepts an arbitrary list of arguments and makes a clean windows path\"\"\"\n    return os.path.normpath(os.path.join(*args))\n\n\ndef find_windows_executable(bin_path, exe_name):\n    \"\"\"Given an executable name, search the given location for an executable\"\"\"\n    requested_path = get_windows_path(bin_path, exe_name)\n    if os.path.isfile(requested_path):\n        return requested_path\n\n    try:\n        pathext = os.environ[\"PATHEXT\"]\n    except KeyError:\n        pass\n    else:\n        for ext in pathext.split(os.pathsep):\n            path = get_windows_path(bin_path, exe_name + ext.strip().lower())\n            if os.path.isfile(path):\n                return path\n\n    return find_executable(exe_name)\n\n\ndef path_to_url(path):\n\n    return Path(normalize_drive(os.path.abspath(path))).as_uri()\n\n\ndef normalize_path(path):\n    return os.path.expandvars(os.path.expanduser(\n        os.path.normcase(os.path.normpath(os.path.abspath(str(path))))\n    ))\n\n\ndef get_url_name(url):\n    if not isinstance(url, str):\n        return\n    return urllib3_util.parse_url(url).host\n\n\ndef get_host_and_port(url):\n    \"\"\"Get the host, or the host:port pair if port is explicitly included, for the given URL.\n\n    Examples:\n    >>> get_host_and_port('example.com')\n    'example.com'\n    >>> get_host_and_port('example.com:443')\n    'example.com:443'\n    >>> get_host_and_port('http://example.com')\n    'example.com'\n    >>> get_host_and_port('https://example.com/')\n    'example.com'\n    >>> get_host_and_port('https://example.com:8081')\n    'example.com:8081'\n    >>> get_host_and_port('ssh://example.com')\n    'example.com'\n\n    :param url: the URL string to parse\n    :return: a string with the host:port pair if the URL includes port number explicitly; otherwise, returns host only\n    \"\"\"\n    url = urllib3_util.parse_url(url)\n    return '{}:{}'.format(url.host, url.port) if url.port else url.host\n\n\ndef get_canonical_names(packages):\n    \"\"\"Canonicalize a list of packages and return a set of canonical names\"\"\"\n    from .vendor.packaging.utils import canonicalize_name\n\n    if not isinstance(packages, Sequence):\n        if not isinstance(packages, str):\n            return packages\n        packages = [packages]\n    return {canonicalize_name(pkg) for pkg in packages if pkg}\n\n\ndef walk_up(bottom):\n    \"\"\"Mimic os.walk, but walk 'up' instead of down the directory tree.\n    From: https://gist.github.com/zdavkeos/1098474\n    \"\"\"\n    bottom = os.path.realpath(bottom)\n    # Get files in current dir.\n    try:\n        names = os.listdir(bottom)\n    except Exception:\n        return\n\n    dirs, nondirs = [], []\n    for name in names:\n        if os.path.isdir(os.path.join(bottom, name)):\n            dirs.append(name)\n        else:\n            nondirs.append(name)\n    yield bottom, dirs, nondirs\n\n    new_path = os.path.realpath(os.path.join(bottom, \"..\"))\n    # See if we are at the top.\n    if new_path == bottom:\n        return\n\n    yield from walk_up(new_path)\n\n\ndef find_requirements(max_depth=3):\n    \"\"\"Returns the path of a requirements.txt file in parent directories.\"\"\"\n    i = 0\n    for c, d, f in walk_up(os.getcwd()):\n        i += 1\n        if i < max_depth:\n            r = os.path.join(c, \"requirements.txt\")\n            if os.path.isfile(r):\n                return r\n\n    raise RuntimeError(\"No requirements.txt found!\")\n\n\n# Borrowed from Pew.\n# See https://github.com/berdario/pew/blob/master/pew/_utils.py#L82\n@contextmanager\ndef temp_environ():\n    \"\"\"Allow the ability to set os.environ temporarily\"\"\"\n    environ = dict(os.environ)\n    try:\n        yield\n\n    finally:\n        os.environ.clear()\n        os.environ.update(environ)\n\n\n@contextmanager\ndef temp_path():\n    \"\"\"Allow the ability to set os.environ temporarily\"\"\"\n    path = [p for p in sys.path]\n    try:\n        yield\n    finally:\n        sys.path = [p for p in path]\n\n\ndef load_path(python):\n    import json\n\n    from pathlib import Path\n    python = Path(python).as_posix()\n    json_dump_commmand = '\"import json, sys; print(json.dumps(sys.path));\"'\n    c = subprocess_run([python, \"-c\", json_dump_commmand])\n    if c.returncode == 0:\n        return json.loads(c.stdout.strip())\n    else:\n        return []\n\n\ndef is_valid_url(url):\n    \"\"\"Checks if a given string is an url\"\"\"\n    pieces = urlparse(url)\n    return all([pieces.scheme, pieces.netloc])\n\n\ndef is_pypi_url(url):\n    return bool(re.match(r\"^http[s]?:\\/\\/pypi(?:\\.python)?\\.org\\/simple[\\/]?$\", url))\n\n\ndef replace_pypi_sources(sources, pypi_replacement_source):\n    return [pypi_replacement_source] + [\n        source for source in sources if not is_pypi_url(source[\"url\"])\n    ]\n\n\ndef create_mirror_source(url):\n    return {\n        \"url\": url,\n        \"verify_ssl\": url.startswith(\"https://\"),\n        \"name\": urlparse(url).hostname,\n    }\n\n\ndef download_file(url, filename, max_retries=1):\n    \"\"\"Downloads file from url to a path with filename\"\"\"\n    r = _get_requests_session(max_retries).get(url, stream=True)\n    if not r.ok:\n        raise OSError(\"Unable to download file\")\n\n    with open(filename, \"wb\") as f:\n        f.write(r.content)\n\n\ndef normalize_drive(path):\n    \"\"\"Normalize drive in path so they stay consistent.\n\n    This currently only affects local drives on Windows, which can be\n    identified with either upper or lower cased drive names. The case is\n    always converted to uppercase because it seems to be preferred.\n\n    See: <https://github.com/pypa/pipenv/issues/1218>\n    \"\"\"\n    if os.name != \"nt\" or not isinstance(path, str):\n        return path\n\n    drive, tail = os.path.splitdrive(path)\n    # Only match (lower cased) local drives (e.g. 'c:'), not UNC mounts.\n    if drive.islower() and len(drive) == 2 and drive[1] == \":\":\n        return f\"{drive.upper()}{tail}\"\n\n    return path\n\n\ndef is_readonly_path(fn):\n    \"\"\"Check if a provided path exists and is readonly.\n\n    Permissions check is `bool(path.stat & stat.S_IREAD)` or `not os.access(path, os.W_OK)`\n    \"\"\"\n    if os.path.exists(fn):\n        return (os.stat(fn).st_mode & stat.S_IREAD) or not os.access(fn, os.W_OK)\n\n    return False\n\n\ndef set_write_bit(fn):\n    if isinstance(fn, str) and not os.path.exists(fn):\n        return\n    os.chmod(fn, stat.S_IWRITE | stat.S_IWUSR | stat.S_IRUSR)\n    return\n\n\ndef rmtree(directory, ignore_errors=False):\n    shutil.rmtree(\n        directory, ignore_errors=ignore_errors, onerror=handle_remove_readonly\n    )\n\n\ndef handle_remove_readonly(func, path, exc):\n    \"\"\"Error handler for shutil.rmtree.\n\n    Windows source repo folders are read-only by default, so this error handler\n    attempts to set them as writeable and then proceed with deletion.\"\"\"\n    # Check for read-only attribute\n    default_warning_message = (\n        \"Unable to remove file due to permissions restriction: {!r}\"\n    )\n    # split the initial exception out into its type, exception, and traceback\n    exc_type, exc_exception, exc_tb = exc\n    if is_readonly_path(path):\n        # Apply write permission and call original function\n        set_write_bit(path)\n        try:\n            func(path)\n        except OSError as e:\n            if e.errno in [errno.EACCES, errno.EPERM]:\n                warnings.warn(default_warning_message.format(path), ResourceWarning)\n                return\n\n    if exc_exception.errno in [errno.EACCES, errno.EPERM]:\n        warnings.warn(default_warning_message.format(path), ResourceWarning)\n        return\n\n    raise exc\n\n\ndef escape_cmd(cmd):\n    if any(special_char in cmd for special_char in [\"<\", \">\", \"&\", \".\", \"^\", \"|\", \"?\"]):\n        cmd = f'\\\"{cmd}\\\"'\n    return cmd\n\n\ndef safe_expandvars(value):\n    \"\"\"Call os.path.expandvars if value is a string, otherwise do nothing.\n    \"\"\"\n    if isinstance(value, str):\n        return os.path.expandvars(value)\n    return value\n\n\ndef get_vcs_deps(\n    project=None,\n    dev=False,\n    pypi_mirror=None,\n    packages=None,\n    reqs=None\n):\n    from .vendor.requirementslib.models.requirements import Requirement\n\n    section = \"vcs_dev_packages\" if dev else \"vcs_packages\"\n    if reqs is None:\n        reqs = []\n    lockfile = {}\n    if not reqs:\n        if not project and not packages:\n            raise ValueError(\n                \"Must supply either a project or a pipfile section to lock vcs dependencies.\"\n            )\n        if not packages:\n            try:\n                packages = getattr(project, section)\n            except AttributeError:\n                return [], []\n        reqs = [Requirement.from_pipfile(name, entry) for name, entry in packages.items()]\n    result = []\n    for requirement in reqs:\n        name = requirement.normalized_name\n        commit_hash = None\n        if requirement.is_vcs:\n            try:\n                with temp_path(), locked_repository(requirement) as repo:\n                    from pipenv.vendor.requirementslib.models.requirements import (\n                        Requirement\n                    )\n\n                    # from distutils.sysconfig import get_python_lib\n                    # sys.path = [repo.checkout_directory, \"\", \".\", get_python_lib(plat_specific=0)]\n                    commit_hash = repo.get_commit_hash()\n                    name = requirement.normalized_name\n                    lockfile[name] = requirement.pipfile_entry[1]\n                    lockfile[name]['ref'] = commit_hash\n                    result.append(requirement)\n            except OSError:\n                continue\n    return result, lockfile\n\n\ndef translate_markers(pipfile_entry):\n    \"\"\"Take a pipfile entry and normalize its markers\n\n    Provide a pipfile entry which may have 'markers' as a key or it may have\n    any valid key from `packaging.markers.marker_context.keys()` and standardize\n    the format into {'markers': 'key == \"some_value\"'}.\n\n    :param pipfile_entry: A dictionariy of keys and values representing a pipfile entry\n    :type pipfile_entry: dict\n    :returns: A normalized dictionary with cleaned marker entries\n    \"\"\"\n    if not isinstance(pipfile_entry, Mapping):\n        raise TypeError(\"Entry is not a pipfile formatted mapping.\")\n    from .vendor.packaging.markers import default_environment\n    from .vendor.vistir.misc import dedup\n\n    allowed_marker_keys = [\"markers\"] + list(default_environment().keys())\n    provided_keys = list(pipfile_entry.keys()) if hasattr(pipfile_entry, \"keys\") else []\n    pipfile_markers = set(provided_keys) & set(allowed_marker_keys)\n    new_pipfile = dict(pipfile_entry).copy()\n    marker_set = set()\n    if \"markers\" in new_pipfile:\n        marker_str = new_pipfile.pop(\"markers\")\n        if marker_str:\n            marker = str(Marker(marker_str))\n            if 'extra' not in marker:\n                marker_set.add(marker)\n    for m in pipfile_markers:\n        entry = f\"{pipfile_entry[m]}\"\n        if m != \"markers\":\n            marker_set.add(str(Marker(f\"{m} {entry}\")))\n            new_pipfile.pop(m)\n    if marker_set:\n        new_pipfile[\"markers\"] = str(Marker(\" or \".join(\n            f\"{s}\" if \" and \" in s else s\n            for s in sorted(dedup(marker_set))\n        ))).replace('\"', \"'\")\n    return new_pipfile\n\n\ndef clean_resolved_dep(dep, is_top_level=False, pipfile_entry=None):\n    from .vendor.requirementslib.utils import is_vcs\n    name = pep423_name(dep[\"name\"])\n    lockfile = {}\n    # We use this to determine if there are any markers on top level packages\n    # So we can make sure those win out during resolution if the packages reoccur\n    if \"version\" in dep and dep[\"version\"] and not dep.get(\"editable\", False):\n        version = \"{}\".format(dep[\"version\"])\n        if not version.startswith(\"==\"):\n            version = f\"=={version}\"\n        lockfile[\"version\"] = version\n    if is_vcs(dep):\n        ref = dep.get(\"ref\", None)\n        if ref is not None:\n            lockfile[\"ref\"] = ref\n        vcs_type = next(iter(k for k in dep.keys() if k in VCS_LIST), None)\n        if vcs_type:\n            lockfile[vcs_type] = dep[vcs_type]\n        if \"subdirectory\" in dep:\n            lockfile[\"subdirectory\"] = dep[\"subdirectory\"]\n    for key in [\"hashes\", \"index\", \"extras\", \"editable\"]:\n        if key in dep:\n            lockfile[key] = dep[key]\n    # In case we lock a uri or a file when the user supplied a path\n    # remove the uri or file keys from the entry and keep the path\n    fs_key = next(iter(k for k in [\"path\", \"file\"] if k in dep), None)\n    pipfile_fs_key = None\n    if pipfile_entry:\n        pipfile_fs_key = next(iter(k for k in [\"path\", \"file\"] if k in pipfile_entry), None)\n    if fs_key and pipfile_fs_key and fs_key != pipfile_fs_key:\n        lockfile[pipfile_fs_key] = pipfile_entry[pipfile_fs_key]\n    elif fs_key is not None:\n        lockfile[fs_key] = dep[fs_key]\n\n    # If a package is **PRESENT** in the pipfile but has no markers, make sure we\n    # **NEVER** include markers in the lockfile\n    if \"markers\" in dep and dep.get(\"markers\", \"\").strip():\n        # First, handle the case where there is no top level dependency in the pipfile\n        if not is_top_level:\n            translated = translate_markers(dep).get(\"markers\", \"\").strip()\n            if translated:\n                try:\n                    lockfile[\"markers\"] = translated\n                except TypeError:\n                    pass\n        # otherwise make sure we are prioritizing whatever the pipfile says about the markers\n        # If the pipfile says nothing, then we should put nothing in the lockfile\n        else:\n            try:\n                pipfile_entry = translate_markers(pipfile_entry)\n                lockfile[\"markers\"] = pipfile_entry.get(\"markers\")\n            except TypeError:\n                pass\n    return {name: lockfile}\n\n\ndef get_workon_home():\n    workon_home = os.environ.get(\"WORKON_HOME\")\n    if not workon_home:\n        if os.name == \"nt\":\n            workon_home = \"~/.virtualenvs\"\n        else:\n            workon_home = os.path.join(\n                os.environ.get(\"XDG_DATA_HOME\", \"~/.local/share\"), \"virtualenvs\"\n            )\n    # Create directory if it does not already exist\n    expanded_path = Path(os.path.expandvars(workon_home)).expanduser()\n    mkdir_p(str(expanded_path))\n    return expanded_path\n\n\ndef is_virtual_environment(path):\n    \"\"\"Check if a given path is a virtual environment's root.\n\n    This is done by checking if the directory contains a Python executable in\n    its bin/Scripts directory. Not technically correct, but good enough for\n    general usage.\n    \"\"\"\n    if not path.is_dir():\n        return False\n    for bindir_name in ('bin', 'Scripts'):\n        for python in path.joinpath(bindir_name).glob('python*'):\n            try:\n                exeness = python.is_file() and os.access(str(python), os.X_OK)\n            except OSError:\n                exeness = False\n            if exeness:\n                return True\n    return False\n\n\n@contextmanager\ndef locked_repository(requirement):\n    from .vendor.vistir.path import create_tracked_tempdir\n    if not requirement.is_vcs:\n        return\n    original_base = os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\n    os.environ[\"PIP_SHIMS_BASE_MODULE\"] = fs_str(\"pipenv.patched.notpip\")\n    src_dir = create_tracked_tempdir(prefix=\"pipenv-\", suffix=\"-src\")\n    try:\n        with requirement.req.locked_vcs_repo(src_dir=src_dir) as repo:\n            yield repo\n    finally:\n        if original_base:\n            os.environ[\"PIP_SHIMS_BASE_MODULE\"] = original_base\n\n\n@contextmanager\ndef chdir(path):\n    \"\"\"Context manager to change working directories.\"\"\"\n    if not path:\n        return\n    prev_cwd = Path.cwd().as_posix()\n    if isinstance(path, Path):\n        path = path.as_posix()\n    os.chdir(str(path))\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)\n\n\ndef looks_like_dir(path):\n    seps = (sep for sep in (os.path.sep, os.path.altsep) if sep is not None)\n    return any(sep in path for sep in seps)\n\n\ndef parse_indexes(line, strict=False):\n    from argparse import ArgumentParser\n\n    comment_re = re.compile(r\"(?:^|\\s+)#.*$\")\n    line = comment_re.sub(\"\", line)\n    parser = ArgumentParser(\"indexes\", allow_abbrev=False)\n    parser.add_argument(\"-i\", \"--index-url\", dest=\"index\")\n    parser.add_argument(\"--extra-index-url\", dest=\"extra_index\")\n    parser.add_argument(\"--trusted-host\", dest=\"trusted_host\")\n    args, remainder = parser.parse_known_args(line.split())\n    index = args.index\n    extra_index = args.extra_index\n    trusted_host = args.trusted_host\n    if strict and sum(\n        bool(arg) for arg in (index, extra_index, trusted_host, remainder)\n    ) > 1:\n        raise ValueError(\"Index arguments must be on their own lines.\")\n    return index, extra_index, trusted_host, remainder\n\n\n@contextmanager\ndef sys_version(version_tuple):\n    \"\"\"\n    Set a temporary sys.version_info tuple\n\n    :param version_tuple: a fake sys.version_info tuple\n    \"\"\"\n\n    old_version = sys.version_info\n    sys.version_info = version_tuple\n    yield\n    sys.version_info = old_version\n\n\ndef add_to_set(original_set, element):\n    \"\"\"Given a set and some arbitrary element, add the element(s) to the set\"\"\"\n    if not element:\n        return original_set\n    if isinstance(element, Set):\n        original_set |= element\n    elif isinstance(element, (list, tuple)):\n        original_set |= set(element)\n    else:\n        original_set.add(element)\n    return original_set\n\n\ndef is_url_equal(url, other_url):\n    # type: (str, str) -> bool\n    \"\"\"\n    Compare two urls by scheme, host, and path, ignoring auth\n\n    :param str url: The initial URL to compare\n    :param str url: Second url to compare to the first\n    :return: Whether the URLs are equal without **auth**, **query**, and **fragment**\n    :rtype: bool\n\n    >>> is_url_equal(\"https://user:pass@mydomain.com/some/path?some_query\",\n                     \"https://user2:pass2@mydomain.com/some/path\")\n    True\n\n    >>> is_url_equal(\"https://user:pass@mydomain.com/some/path?some_query\",\n                 \"https://mydomain.com/some?some_query\")\n    False\n    \"\"\"\n    if not isinstance(url, str):\n        raise TypeError(f\"Expected string for url, received {url!r}\")\n    if not isinstance(other_url, str):\n        raise TypeError(f\"Expected string for url, received {other_url!r}\")\n    parsed_url = urllib3_util.parse_url(url)\n    parsed_other_url = urllib3_util.parse_url(other_url)\n    unparsed = parsed_url._replace(auth=None, query=None, fragment=None).url\n    unparsed_other = parsed_other_url._replace(auth=None, query=None, fragment=None).url\n    return unparsed == unparsed_other\n\n\n@lru_cache()\ndef make_posix(path):\n    # type: (str) -> str\n    \"\"\"\n    Convert a path with possible windows-style separators to a posix-style path\n    (with **/** separators instead of **\\\\** separators).\n\n    :param Text path: A path to convert.\n    :return: A converted posix-style path\n    :rtype: Text\n\n    >>> make_posix(\"c:/users/user/venvs/some_venv\\\\Lib\\\\site-packages\")\n    \"c:/users/user/venvs/some_venv/Lib/site-packages\"\n\n    >>> make_posix(\"c:\\\\users\\\\user\\\\venvs\\\\some_venv\")\n    \"c:/users/user/venvs/some_venv\"\n    \"\"\"\n    if not isinstance(path, str):\n        raise TypeError(f\"Expected a string for path, received {path!r}...\")\n    starts_with_sep = path.startswith(os.path.sep)\n    separated = normalize_path(path).split(os.path.sep)\n    if isinstance(separated, (list, tuple)):\n        path = posixpath.join(*separated)\n        if starts_with_sep:\n            path = f\"/{path}\"\n    return path\n\n\ndef get_pipenv_dist(pkg=\"pipenv\", pipenv_site=None):\n    from .resolver import find_site_path\n    pipenv_libdir = os.path.dirname(os.path.abspath(__file__))\n    if pipenv_site is None:\n        pipenv_site = os.path.dirname(pipenv_libdir)\n    pipenv_dist, _ = find_site_path(pkg, site_dir=pipenv_site)\n    return pipenv_dist\n\n\ndef find_python(finder, line=None):\n    \"\"\"\n    Given a `pythonfinder.Finder` instance and an optional line, find a corresponding python\n\n    :param finder: A :class:`pythonfinder.Finder` instance to use for searching\n    :type finder: :class:pythonfinder.Finder`\n    :param str line: A version, path, name, or nothing, defaults to None\n    :return: A path to python\n    :rtype: str\n    \"\"\"\n\n    if line and not isinstance(line, str):\n        raise TypeError(\n            f\"Invalid python search type: expected string, received {line!r}\"\n        )\n    if line and os.path.isabs(line):\n        if os.name == \"nt\":\n            line = make_posix(line)\n        return line\n    if not finder:\n        from pipenv.vendor.pythonfinder import Finder\n        finder = Finder(global_search=True)\n    if not line:\n        result = next(iter(finder.find_all_python_versions()), None)\n    elif line and line[0].isdigit() or re.match(r'[\\d\\.]+', line):\n        result = finder.find_python_version(line)\n    else:\n        result = finder.find_python_version(name=line)\n    if not result:\n        result = finder.which(line)\n    if not result and not line.startswith(\"python\"):\n        line = f\"python{line}\"\n        result = find_python(finder, line)\n\n    if result:\n        if not isinstance(result, str):\n            return result.path.as_posix()\n        return result\n    return\n\n\ndef is_python_command(line):\n    \"\"\"\n    Given an input, checks whether the input is a request for python or notself.\n\n    This can be a version, a python runtime name, or a generic 'python' or 'pythonX.Y'\n\n    :param str line: A potential request to find python\n    :returns: Whether the line is a python lookup\n    :rtype: bool\n    \"\"\"\n\n    if not isinstance(line, str):\n        raise TypeError(f\"Not a valid command to check: {line!r}\")\n\n    from pipenv.vendor.pythonfinder.utils import PYTHON_IMPLEMENTATIONS\n    is_version = re.match(r'\\d+(\\.\\d+)*', line)\n    if (line.startswith(\"python\") or is_version\n            or any(line.startswith(v) for v in PYTHON_IMPLEMENTATIONS)):\n        return True\n    # we are less sure about this but we can guess\n    if line.startswith(\"py\"):\n        return True\n    return False\n\n\n@contextlib.contextmanager\ndef interrupt_handled_subprocess(\n    cmd, verbose=False, return_object=True, write_to_stdout=False, combine_stderr=True,\n    block=True, nospin=True, env=None\n):\n    \"\"\"Given a :class:`subprocess.Popen` instance, wrap it in exception handlers.\n\n    Terminates the subprocess when and if a `SystemExit` or `KeyboardInterrupt` are\n    processed.\n\n    Arguments:\n        :param str cmd: A command to run\n        :param bool verbose: Whether to run with verbose mode enabled, default False\n        :param bool return_object: Whether to return a subprocess instance or a 2-tuple, default True\n        :param bool write_to_stdout: Whether to write directly to stdout, default False\n        :param bool combine_stderr: Whether to combine stdout and stderr, default True\n        :param bool block: Whether the subprocess should be a blocking subprocess, default True\n        :param bool nospin: Whether to suppress the spinner with the subprocess, default True\n        :param Optional[Dict[str, str]] env: A dictionary to merge into the subprocess environment\n        :return: A subprocess, wrapped in exception handlers, as a context manager\n        :rtype: :class:`subprocess.Popen` obj: An instance of a running subprocess\n    \"\"\"\n    obj = run(\n        cmd, verbose=verbose, return_object=True, write_to_stdout=False,\n        combine_stderr=False, block=True, nospin=True, env=env,\n    )\n    try:\n        yield obj\n    except (SystemExit, KeyboardInterrupt):\n        if os.name == \"nt\":\n            os.kill(obj.pid, signal.CTRL_BREAK_EVENT)\n        else:\n            os.kill(obj.pid, signal.SIGINT)\n        obj.wait()\n        raise\n\n\ndef subprocess_run(\n    args, *, block=True, text=True, capture_output=True,\n    encoding=\"utf-8\", env=None, **other_kwargs\n):\n    \"\"\"A backward compatible version of subprocess.run().\n\n    It outputs text with default encoding, and store all outputs in the returned object instead of\n    printing onto stdout.\n    \"\"\"\n    _env = os.environ.copy()\n    _env[\"PYTHONIOENCODING\"] = encoding\n    if env:\n        _env.update(env)\n    other_kwargs[\"env\"] = _env\n    if capture_output:\n        other_kwargs['stdout'] = subprocess.PIPE\n        other_kwargs['stderr'] = subprocess.PIPE\n    if block:\n        return subprocess.run(\n            args, universal_newlines=text,\n            encoding=encoding, **other_kwargs\n        )\n    else:\n        return subprocess.Popen(\n            args, universal_newlines=text,\n            encoding=encoding, **other_kwargs\n        )\n\n\ndef cmd_list_to_shell(args):\n    \"\"\"Convert a list of arguments to a quoted shell command.\"\"\"\n    return \" \".join(shlex.quote(str(token)) for token in args)\n", "import os\n\nimport pytest\n\nimport pipenv.utils\nfrom pipenv.exceptions import PipenvUsageError\n\n\n# Pipfile format <-> requirements.txt format.\nDEP_PIP_PAIRS = [\n    ({\"requests\": \"*\"}, \"requests\"),\n    ({\"requests\": {\"extras\": [\"socks\"], \"version\": \"*\"}}, \"requests[socks]\"),\n    ({\"django\": \">1.10\"}, \"django>1.10\"),\n    ({\"Django\": \">1.10\"}, \"Django>1.10\"),\n    ({\"requests\": {\"extras\": [\"socks\"], \"version\": \">1.10\"}}, \"requests[socks]>1.10\"),\n    ({\"requests\": {\"extras\": [\"socks\"], \"version\": \"==1.10\"}}, \"requests[socks]==1.10\"),\n    (\n        {\n            \"pinax\": {\n                \"git\": \"git://github.com/pinax/pinax.git\",\n                \"ref\": \"1.4\",\n                \"editable\": True,\n            }\n        },\n        \"-e git+git://github.com/pinax/pinax.git@1.4#egg=pinax\",\n    ),\n    (\n        {\"pinax\": {\"git\": \"git://github.com/pinax/pinax.git\", \"ref\": \"1.4\"}},\n        \"git+git://github.com/pinax/pinax.git@1.4#egg=pinax\",\n    ),\n    (  # Mercurial.\n        {\n            \"MyProject\": {\n                \"hg\": \"http://hg.myproject.org/MyProject\",\n                \"ref\": \"da39a3ee5e6b\",\n            }\n        },\n        \"hg+http://hg.myproject.org/MyProject@da39a3ee5e6b#egg=MyProject\",\n    ),\n    (  # SVN.\n        {\n            \"MyProject\": {\n                \"svn\": \"svn://svn.myproject.org/svn/MyProject\",\n                \"editable\": True,\n            }\n        },\n        \"-e svn+svn://svn.myproject.org/svn/MyProject#egg=MyProject\",\n    ),\n    (\n        # Extras in url\n        {\n            \"discord.py\": {\n                \"file\": \"https://github.com/Rapptz/discord.py/archive/async.zip\",\n                \"extras\": [\"voice\"],\n            }\n        },\n        \"https://github.com/Rapptz/discord.py/archive/async.zip#egg=discord.py[voice]\",\n    ),\n    (\n        {\n            \"requests\": {\n                \"git\": \"https://github.com/requests/requests.git\",\n                \"ref\": \"master\",\n                \"extras\": [\"security\"],\n                \"editable\": False,\n            }\n        },\n        \"git+https://github.com/requests/requests.git@master#egg=requests[security]\",\n    ),\n]\n\n\ndef mock_unpack(link, source_dir, download_dir, only_download=False, session=None,\n                hashes=None, progress_bar=\"off\"):\n    return\n\n\n@pytest.mark.utils\n@pytest.mark.parametrize(\"deps, expected\", DEP_PIP_PAIRS)\n@pytest.mark.needs_internet\ndef test_convert_deps_to_pip(monkeypatch, deps, expected):\n    with monkeypatch.context() as m:\n        import pip_shims\n        m.setattr(pip_shims.shims, \"unpack_url\", mock_unpack)\n        if expected.startswith(\"Django\"):\n            expected = expected.lower()\n        assert pipenv.utils.convert_deps_to_pip(deps, r=False) == [expected]\n\n\n@pytest.mark.utils\n@pytest.mark.parametrize(\n    \"deps, expected\",\n    [\n        # This one should be collapsed and treated as {'requests': '*'}.\n        ({\"requests\": {}}, \"requests\"),\n        # Hash value should be passed into the result.\n        (\n            {\n                \"FooProject\": {\n                    \"version\": \"==1.2\",\n                    \"hash\": \"sha256:2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n                }\n            },\n            \"FooProject==1.2 --hash=sha256:2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n        ),\n        (\n            {\n                \"FooProject\": {\n                    \"version\": \"==1.2\",\n                    \"extras\": [\"stuff\"],\n                    \"hash\": \"sha256:2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n                }\n            },\n            \"FooProject[stuff]==1.2 --hash=sha256:2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n        ),\n        (\n            {\n                \"requests\": {\n                    \"git\": \"https://github.com/requests/requests.git\",\n                    \"ref\": \"master\",\n                    \"extras\": [\"security\"],\n                }\n            },\n            \"git+https://github.com/requests/requests.git@master#egg=requests[security]\",\n        ),\n    ],\n)\ndef test_convert_deps_to_pip_one_way(deps, expected):\n    assert pipenv.utils.convert_deps_to_pip(deps, r=False) == [expected.lower()]\n\n\n@pytest.mark.skipif(isinstance(\"\", str), reason=\"don't need to test if unicode is str\")\n@pytest.mark.utils\ndef test_convert_deps_to_pip_unicode():\n    deps = {\"django\": \"==1.10\"}\n    deps = pipenv.utils.convert_deps_to_pip(deps, r=False)\n    assert deps[0] == \"django==1.10\"\n\n\n@pytest.mark.parametrize(\"line,result\", [\n    (\"-i https://example.com/simple/\", (\"https://example.com/simple/\", None, None, [])),\n    (\"--extra-index-url=https://example.com/simple/\", (None, \"https://example.com/simple/\", None, [])),\n    (\"--trusted-host=example.com\", (None, None, \"example.com\", [])),\n    (\"# -i https://example.com/simple/\", (None, None, None, [])),\n    (\"requests # -i https://example.com/simple/\", (None, None, None, [\"requests\"])),\n])\n@pytest.mark.utils\ndef test_parse_indexes(line, result):\n    assert pipenv.utils.parse_indexes(line) == result\n\n\n@pytest.mark.parametrize(\"line\", [\n    \"-i https://example.com/simple/ --extra-index-url=https://extra.com/simple/\",\n    \"--extra-index-url https://example.com/simple/ --trusted-host=example.com\",\n    \"requests -i https://example.com/simple/\",\n])\n@pytest.mark.utils\ndef test_parse_indexes_individual_lines(line):\n    with pytest.raises(ValueError):\n        pipenv.utils.parse_indexes(line, strict=True)\n\n\nclass TestUtils:\n    \"\"\"Test utility functions in pipenv\"\"\"\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"version, specified_ver, expected\",\n        [\n            (\"*\", \"*\", True),\n            (\"2.1.6\", \"==2.1.4\", False),\n            (\"20160913\", \">=20140815\", True),\n            (\n                \"1.4\",\n                {\"svn\": \"svn://svn.myproj.org/svn/MyProj\", \"version\": \"==1.4\"},\n                True,\n            ),\n            (\"2.13.0\", {\"extras\": [\"socks\"], \"version\": \"==2.12.4\"}, False),\n        ],\n    )\n    def test_is_required_version(self, version, specified_ver, expected):\n        assert pipenv.utils.is_required_version(version, specified_ver) is expected\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"entry, expected\",\n        [\n            ({\"git\": \"package.git\", \"ref\": \"v0.0.1\"}, True),\n            ({\"hg\": \"https://package.com/package\", \"ref\": \"v1.2.3\"}, True),\n            (\"*\", False),\n            ({\"some_value\": 5, \"other_value\": object()}, False),\n            (\"package\", False),\n            (\"git+https://github.com/requests/requests.git#egg=requests\", True),\n            (\"git+git@github.com:requests/requests.git#egg=requests\", True),\n            (\"gitdb2\", False),\n        ],\n    )\n    @pytest.mark.vcs\n    def test_is_vcs(self, entry, expected):\n        from pipenv.vendor.requirementslib.utils import is_vcs\n        assert is_vcs(entry) is expected\n\n    @pytest.mark.utils\n    def test_python_version_from_bad_path(self):\n        assert pipenv.utils.python_version(\"/fake/path\") is None\n\n    @pytest.mark.utils\n    def test_python_version_from_non_python(self):\n        assert pipenv.utils.python_version(\"/dev/null\") is None\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"version_output, version\",\n        [\n            (\"Python 3.6.2\", \"3.6.2\"),\n            (\"Python 3.6.2 :: Continuum Analytics, Inc.\", \"3.6.2\"),\n            (\"Python 3.6.20 :: Continuum Analytics, Inc.\", \"3.6.20\"),\n            (\n                \"Python 3.5.3 (3f6eaa010fce78cc7973bdc1dfdb95970f08fed2, Jan 13 2018, 18:14:01)\\n[PyPy 5.10.1 with GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]\",\n                \"3.5.3\",\n            ),\n        ],\n    )\n    # @patch(\".vendor.pythonfinder.utils.get_python_version\")\n    def test_python_version_output_variants(\n        self, monkeypatch, version_output, version\n    ):\n        def mock_version(path):\n            return version_output.split()[1]\n        monkeypatch.setattr(\"pipenv.vendor.pythonfinder.utils.get_python_version\", mock_version)\n        assert pipenv.utils.python_version(\"some/path\") == version\n\n    @pytest.mark.utils\n    @pytest.mark.windows\n    @pytest.mark.skipif(os.name != \"nt\", reason=\"Windows test only\")\n    def test_windows_shellquote(self):\n        test_path = r\"C:\\Program Files\\Python36\\python.exe\"\n        expected_path = '\"C:\\\\\\\\Program Files\\\\\\\\Python36\\\\\\\\python.exe\"'\n        assert pipenv.utils.escape_grouped_arguments(test_path) == expected_path\n\n    @pytest.mark.utils\n    def test_is_valid_url(self):\n        url = \"https://github.com/psf/requests.git\"\n        not_url = \"something_else\"\n        assert pipenv.utils.is_valid_url(url)\n        assert pipenv.utils.is_valid_url(not_url) is False\n\n    @pytest.mark.utils\n    @pytest.mark.needs_internet\n    def test_download_file(self):\n        url = \"https://github.com/pypa/pipenv/blob/master/README.md\"\n        output = \"test_download.md\"\n        pipenv.utils.download_file(url, output)\n        assert os.path.exists(output)\n        os.remove(output)\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize('line, expected', [\n        (\"python\", True),\n        (\"python3.7\", True),\n        (\"python2.7\", True),\n        (\"python2\", True),\n        (\"python3\", True),\n        (\"pypy3\", True),\n        (\"anaconda3-5.3.0\", True),\n        (\"which\", False),\n        (\"vim\", False),\n        (\"miniconda\", True),\n        (\"micropython\", True),\n        (\"ironpython\", True),\n        (\"jython3.5\", True),\n        (\"2\", True),\n        (\"2.7\", True),\n        (\"3.7\", True),\n        (\"3\", True)\n    ])\n    def test_is_python_command(self, line, expected):\n        assert pipenv.utils.is_python_command(line) == expected\n\n    @pytest.mark.utils\n    def test_new_line_end_of_toml_file(this):\n        # toml file that needs clean up\n        toml = \"\"\"\n[dev-packages]\n\n\"flake8\" = \">=3.3.0,<4\"\npytest = \"*\"\nmock = \"*\"\nsphinx = \"<=1.5.5\"\n\"-e .\" = \"*\"\ntwine = \"*\"\n\"sphinx-click\" = \"*\"\n\"pytest-xdist\" = \"*\"\n        \"\"\"\n        new_toml = pipenv.utils.cleanup_toml(toml)\n        # testing if the end of the generated file contains a newline\n        assert new_toml[-1] == \"\\n\"\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"input_path, expected\",\n        [\n            (\n                \"c:\\\\Program Files\\\\Python36\\\\python.exe\",\n                \"C:\\\\Program Files\\\\Python36\\\\python.exe\",\n            ),\n            (\n                \"C:\\\\Program Files\\\\Python36\\\\python.exe\",\n                \"C:\\\\Program Files\\\\Python36\\\\python.exe\",\n            ),\n            (\"\\\\\\\\host\\\\share\\\\file.zip\", \"\\\\\\\\host\\\\share\\\\file.zip\"),\n            (\"artifacts\\\\file.zip\", \"artifacts\\\\file.zip\"),\n            (\".\\\\artifacts\\\\file.zip\", \".\\\\artifacts\\\\file.zip\"),\n            (\"..\\\\otherproject\\\\file.zip\", \"..\\\\otherproject\\\\file.zip\"),\n        ],\n    )\n    @pytest.mark.skipif(os.name != \"nt\", reason=\"Windows file paths tested\")\n    def test_win_normalize_drive(self, input_path, expected):\n        assert pipenv.utils.normalize_drive(input_path) == expected\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"input_path, expected\",\n        [\n            (\"/usr/local/bin/python\", \"/usr/local/bin/python\"),\n            (\"artifacts/file.zip\", \"artifacts/file.zip\"),\n            (\"./artifacts/file.zip\", \"./artifacts/file.zip\"),\n            (\"../otherproject/file.zip\", \"../otherproject/file.zip\"),\n        ],\n    )\n    @pytest.mark.skipif(os.name == \"nt\", reason=\"*nix file paths tested\")\n    def test_nix_normalize_drive(self, input_path, expected):\n        assert pipenv.utils.normalize_drive(input_path) == expected\n\n    @pytest.mark.utils\n    @pytest.mark.parametrize(\n        \"sources, expected_args\",\n        [\n            (\n                [{\"url\": \"https://test.example.com/simple\", \"verify_ssl\": True}],\n                [\"-i\", \"https://test.example.com/simple\"],\n            ),\n            (\n                [{\"url\": \"https://test.example.com/simple\", \"verify_ssl\": False}],\n                [\n                    \"-i\",\n                    \"https://test.example.com/simple\",\n                    \"--trusted-host\",\n                    \"test.example.com\",\n                ],\n            ),\n            (\n                [{\"url\": \"https://test.example.com:12345/simple\", \"verify_ssl\": False}],\n                [\n                    \"-i\",\n                    \"https://test.example.com:12345/simple\",\n                    \"--trusted-host\",\n                    \"test.example.com:12345\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\"url\": \"https://custom.example.com/simple\"},\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://custom.example.com/simple\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\"url\": \"https://custom.example.com/simple\", \"verify_ssl\": False},\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://custom.example.com/simple\",\n                    \"--trusted-host\",\n                    \"custom.example.com\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\"url\": \"https://custom.example.com:12345/simple\", \"verify_ssl\": False},\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://custom.example.com:12345/simple\",\n                    \"--trusted-host\",\n                    \"custom.example.com:12345\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\n                        \"url\": \"https://user:password@custom.example.com/simple\",\n                        \"verify_ssl\": False,\n                    },\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://user:password@custom.example.com/simple\",\n                    \"--trusted-host\",\n                    \"custom.example.com\",\n                ],\n            ),\n            (\n                [\n                    {\"url\": \"https://pypi.org/simple\"},\n                    {\"url\": \"https://user:password@custom.example.com/simple\"},\n                ],\n                [\n                    \"-i\",\n                    \"https://pypi.org/simple\",\n                    \"--extra-index-url\",\n                    \"https://user:password@custom.example.com/simple\",\n                ],\n            ),\n            (\n                [\n                    {\n                        \"url\": \"https://user:password@custom.example.com/simple\",\n                        \"verify_ssl\": False,\n                    },\n                ],\n                [\n                    \"-i\",\n                    \"https://user:password@custom.example.com/simple\",\n                    \"--trusted-host\",\n                    \"custom.example.com\",\n                ],\n            ),\n        ],\n    )\n    def test_prepare_pip_source_args(self, sources, expected_args):\n        assert (\n            pipenv.utils.prepare_pip_source_args(sources, pip_args=None)\n            == expected_args\n        )\n\n    @pytest.mark.utils\n    def test_invalid_prepare_pip_source_args(self):\n        sources = [{}]\n        with pytest.raises(PipenvUsageError):\n            pipenv.utils.prepare_pip_source_args(sources, pip_args=None)\n\n    @pytest.mark.utils\n    def test_parse_python_version(self):\n        ver = pipenv.utils.parse_python_version(\"Python 3.6.5\\n\")\n        assert ver == {\"major\": \"3\", \"minor\": \"6\", \"micro\": \"5\"}\n\n    @pytest.mark.utils\n    def test_parse_python_version_suffix(self):\n        ver = pipenv.utils.parse_python_version(\"Python 3.6.5rc1\\n\")\n        assert ver == {\"major\": \"3\", \"minor\": \"6\", \"micro\": \"5\"}\n\n    @pytest.mark.utils\n    def test_parse_python_version_270(self):\n        ver = pipenv.utils.parse_python_version(\"Python 2.7\\n\")\n        assert ver == {\"major\": \"2\", \"minor\": \"7\", \"micro\": \"0\"}\n\n    @pytest.mark.utils\n    def test_parse_python_version_270_garbage(self):\n        ver = pipenv.utils.parse_python_version(\"Python 2.7+\\n\")\n        assert ver == {\"major\": \"2\", \"minor\": \"7\", \"micro\": \"0\"}\n"], "filenames": ["pipenv/core.py", "pipenv/utils.py", "tests/unit/test_utils.py"], "buggy_code_start_loc": [20, 1645, 145], "buggy_code_end_loc": [190, 1645, 146], "fixing_code_start_loc": [20, 1646, 145], "fixing_code_end_loc": [195, 1670, 146], "type": "CWE-20", "message": "pipenv is a Python development workflow tool. Starting with version 2018.10.9 and prior to version 2022.1.8, a flaw in pipenv's parsing of requirements files allows an attacker to insert a specially crafted string inside a comment anywhere within a requirements.txt file, which will cause victims who use pipenv to install the requirements file to download dependencies from a package index server controlled by the attacker. By embedding malicious code in packages served from their malicious index server, the attacker can trigger arbitrary remote code execution (RCE) on the victims' systems. If an attacker is able to hide a malicious `--index-url` option in a requirements file that a victim installs with pipenv, the attacker can embed arbitrary malicious code in packages served from their malicious index server that will be executed on the victim's host during installation (remote code execution/RCE). When pip installs from a source distribution, any code in the setup.py is executed by the install process. This issue is patched in version 2022.1.8. The GitHub Security Advisory contains more information about this vulnerability.", "other": {"cve": {"id": "CVE-2022-21668", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-10T21:15:07.853", "lastModified": "2022-04-25T17:58:32.650", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "pipenv is a Python development workflow tool. Starting with version 2018.10.9 and prior to version 2022.1.8, a flaw in pipenv's parsing of requirements files allows an attacker to insert a specially crafted string inside a comment anywhere within a requirements.txt file, which will cause victims who use pipenv to install the requirements file to download dependencies from a package index server controlled by the attacker. By embedding malicious code in packages served from their malicious index server, the attacker can trigger arbitrary remote code execution (RCE) on the victims' systems. If an attacker is able to hide a malicious `--index-url` option in a requirements file that a victim installs with pipenv, the attacker can embed arbitrary malicious code in packages served from their malicious index server that will be executed on the victim's host during installation (remote code execution/RCE). When pip installs from a source distribution, any code in the setup.py is executed by the install process. This issue is patched in version 2022.1.8. The GitHub Security Advisory contains more information about this vulnerability."}, {"lang": "es", "value": "pipenv es una herramienta de flujo de trabajo de desarrollo de Python. A partir de la versi\u00f3n 2018.10.9 y versiones anteriores a 2022.1.8, un defecto en el an\u00e1lisis de archivos de requisitos de pipenv permite a un atacante insertar una cadena especialmente dise\u00f1ada dentro de un comentario en cualquier lugar dentro de un archivo requirements.txt, lo que causar\u00e1 que las v\u00edctimas que usan pipenv para instalar el archivo de requisitos descarguen dependencias de un servidor de \u00edndice de paquetes controlado por el atacante. Al insertar c\u00f3digo malicioso en los paquetes servidos desde su servidor de \u00edndice malicioso, el atacante puede desencadenar una ejecuci\u00f3n de c\u00f3digo remota (RCE) arbitraria en los sistemas de las v\u00edctimas. Si un atacante es capaz de ocultar una opci\u00f3n maliciosa \"--index-url\" en un archivo de requisitos que una v\u00edctima instala con pipenv, el atacante puede insertar c\u00f3digo malicioso arbitrario en paquetes servidos desde su servidor de \u00edndice malicioso que ser\u00e1 ejecutado en el host de la v\u00edctima durante la instalaci\u00f3n (ejecuci\u00f3n de c\u00f3digo remota/RCE). Cuando pip instala desde una distribuci\u00f3n de origen, cualquier c\u00f3digo en el archivo setup.py es ejecutado por el proceso de instalaci\u00f3n. Este problema est\u00e1 parcheado en versi\u00f3n 2022.1.8. El aviso de seguridad de GitHub contiene m\u00e1s informaci\u00f3n sobre esta vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-427"}, {"lang": "en", "value": "CWE-77"}, {"lang": "en", "value": "CWE-78"}, {"lang": "en", "value": "CWE-791"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pypa:pipenv:*:*:*:*:*:*:*:*", "versionStartIncluding": "2018.10.9", "versionEndExcluding": "2022.1.8", "matchCriteriaId": "1E34F343-93E1-4EB7-A3AC-C89D14AA14EF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/pypa/pipenv/commit/439782a8ae36c4762c88e43d5f0d8e563371b46f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pypa/pipenv/releases/tag/v2022.1.8", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/pypa/pipenv/security/advisories/GHSA-qc9x-gjcv-465w", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/56HBA3EOSLEDNCCBJVHE6DO34P56EOUM/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KCROBYHUS6DKQPCXBRPCZ5CDBNQTYAWT/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QHQRIWKDP3SVJABAPEXBIQPKDI6UP7G4/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pypa/pipenv/commit/439782a8ae36c4762c88e43d5f0d8e563371b46f"}}