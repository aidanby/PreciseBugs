{"buggy_code": ["'use strict'\n\nconst Buffer = require('safe-buffer').Buffer\n\nconst crypto = require('crypto')\nconst Transform = require('stream').Transform\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/]+(?:=?=?))([?\\x21-\\x7E]*)$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    const strict = !!(opts && opts.strict)\n    this.source = hash.trim()\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n      ? STRICT_SRI_REGEX\n      : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : []\n  }\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    if (opts && opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        (this.options || []).every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n    ? `?${this.options.join('?')}`\n    : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    opts = opts || {}\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n  concat (integrity, opts) {\n    const other = typeof integrity === 'string'\n    ? integrity\n    : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n  hexDigest () {\n    return parse(this, {single: true}).hexDigest()\n  }\n  match (integrity, opts) {\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n  pickAlgorithm (opts) {\n    const pickAlgorithm = (opts && opts.pickAlgorithm) || getPrioritizedHash\n    const keys = Object.keys(this)\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${\n        JSON.stringify(this.toString())\n      }`)\n    }\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  opts = opts || {}\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  const optString = (opts && opts.options && opts.options.length)\n  ? `?${opts.options.join('?')}`\n  : ''\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = opts || {}\n  const algorithms = opts.algorithms || ['sha512']\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n       opts\n    )\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = opts || {}\n  const P = opts.Promise || Promise\n  const istream = integrityStream(opts)\n  return new P((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = opts || {}\n  sri = parse(sri, opts)\n  if (!Object.keys(sri).length) { return false }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  return parse({algorithm, digest}).match(sri, opts)\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = opts || {}\n  const P = opts.Promise || Promise\n  const checker = integrityStream(Object.assign({}, opts, {\n    integrity: sri\n  }))\n  return new P((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts) {\n  opts = opts || {}\n  // For verification\n  const sri = opts.integrity && parse(opts.integrity, opts)\n  const goodSri = sri && Object.keys(sri).length\n  const algorithm = goodSri && sri.pickAlgorithm(opts)\n  const digests = goodSri && sri[algorithm]\n  // Calculating stream\n  const algorithms = (opts.algorithms || ['sha512'])\n  .concat(algorithm ? [algorithm] : [])\n  const hashes = algorithms.map(crypto.createHash)\n  let streamSize = 0\n  const stream = new Transform({\n    transform (chunk, enc, cb) {\n      streamSize += chunk.length\n      hashes.forEach(h => h.update(chunk, enc))\n      cb(null, chunk, enc)\n    }\n  }).on('end', () => {\n    const optString = (opts.options && opts.options.length)\n    ? `?${opts.options.join('?')}`\n    : ''\n    const newSri = parse(hashes.map((h, i) => {\n      return `${algorithms[i]}-${h.digest('base64')}${optString}`\n    }).join(' '), opts)\n    // Integrity verification mode\n    const match = goodSri && newSri.match(sri, opts)\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`)\n      err.code = 'EBADSIZE'\n      err.found = streamSize\n      err.expected = opts.size\n      err.sri = sri\n      stream.emit('error', err)\n    } else if (opts.integrity && !match) {\n      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = digests\n      err.algorithm = algorithm\n      err.sri = sri\n      stream.emit('error', err)\n    } else {\n      stream.emit('size', streamSize)\n      stream.emit('integrity', newSri)\n      match && stream.emit('verified', match)\n    }\n  })\n  return stream\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = opts || {}\n  const algorithms = opts.algorithms || ['sha512']\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\n// This is a Best Effort\u2122 at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n]\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n  ? algo1\n  : algo2\n}\n", "'use strict'\n\nconst Buffer = require('safe-buffer').Buffer\n\nconst test = require('tap').test\n\nconst ssri = require('..')\n\ntest('toString()', t => {\n  const sri = ssri.parse('sha512-foo sha256-bar!')\n  t.equal(\n    sri.toString(),\n    'sha512-foo sha256-bar!',\n    'integrity objects from ssri.parse() can use toString()'\n  )\n  t.equal(\n    sri.toString({strict: true}),\n    'sha512-foo',\n    'accepts strict mode option'\n  )\n  t.equal(\n    sri.toString({sep: '\\n'}),\n    'sha512-foo\\nsha256-bar!',\n    'accepts separator option'\n  )\n  t.done()\n})\n\ntest('toJSON()', t => {\n  const sri = ssri.parse('sha512-foo sha256-bar!')\n  t.equal(\n    sri.toJSON(),\n    'sha512-foo sha256-bar!',\n    'integrity objects from ssri.parse() can use toJSON()'\n  )\n  t.equal(\n    sri.sha512[0].toJSON(),\n    'sha512-foo',\n    'hash objects should toJSON also'\n  )\n  t.done()\n})\n\ntest('concat()', t => {\n  const sri = ssri.parse('sha512-foo')\n  t.equal(\n    sri.concat('sha512-bar').toString(),\n    'sha512-foo sha512-bar',\n    'concatenates with a string'\n  )\n  t.equal(\n    sri.concat({digest: 'bar', algorithm: 'sha384'}).toString(),\n    'sha512-foo sha384-bar',\n    'concatenates with an Hash-like'\n  )\n  t.equal(\n    sri.concat({\n      'sha384': [{digest: 'bar', algorithm: 'sha384'}],\n      'sha1': [{digest: 'baz', algorithm: 'sha1'}]\n    }).toString(),\n    'sha512-foo sha384-bar sha1-baz',\n    'concatenates with an Integrity-like'\n  )\n  t.equal(\n    sri.concat(\n      {digest: 'bar', algorithm: 'sha1'}\n    ).concat(\n      'sha1-baz'\n    ).concat(\n      'sha512-quux'\n    ).toString(),\n    'sha512-foo sha512-quux sha1-bar sha1-baz',\n    'preserves relative order for algorithms between different concatenations'\n  )\n  t.equal(\n    sri.concat('sha1-bar!', {strict: true}).toString(),\n    'sha512-foo',\n    'accepts strict mode option'\n  )\n  t.done()\n})\n\ntest('match()', t => {\n  const sri = ssri.parse('sha1-foo sha512-bar')\n  t.similar(sri.match('sha1-foo'), {\n    algorithm: 'sha1',\n    digest: 'foo'\n  }, 'returns the matching hash')\n  t.similar(sri.match(ssri.parse('sha1-foo')), {\n    algorithm: 'sha1',\n    digest: 'foo'\n  }, 'accepts other Integrity objects')\n  t.similar(sri.match(ssri.parse('sha1-foo')), {\n    algorithm: 'sha1',\n    digest: 'foo'\n  }, 'accepts other Hash objects')\n  t.similar(sri.match({digest: 'foo', algorithm: 'sha1'}), {\n    algorithm: 'sha1',\n    digest: 'foo'\n  }, 'accepts Hash-like objects')\n  t.similar(sri.match('sha1-bar sha512-bar'), {\n    algorithm: 'sha512',\n    digest: 'bar'\n  }, 'returns the strongest match')\n  t.notOk(sri.match('sha512-foo'), 'falsy when match fails')\n  t.notOk(sri.match('sha384-foo'), 'falsy when match fails')\n  t.done()\n})\n\ntest('pickAlgorithm()', t => {\n  const sri = ssri.parse('sha1-foo sha512-bar sha384-baz')\n  t.equal(sri.pickAlgorithm(), 'sha512', 'picked best algorithm')\n  t.equal(\n    ssri.parse('unknown-deadbeef uncertain-bada55').pickAlgorithm(),\n    'unknown',\n    'unrecognized algorithm returned if none others known'\n  )\n  t.equal(\n    sri.pickAlgorithm({\n      pickAlgorithm: (a, b) => 'sha384'\n    }),\n    'sha384',\n    'custom pickAlgorithm function accepted'\n  )\n  t.throws(() => {\n    ssri.parse('').pickAlgorithm()\n  }, /No algorithms available/, 'SRIs without algorithms are invalid')\n  t.done()\n})\n\ntest('hexDigest()', t => {\n  t.equal(\n    ssri.parse('sha512-foo').hexDigest(),\n    Buffer.from('foo', 'base64').toString('hex'),\n    'returned hex version of base64 digest')\n  t.equal(\n    ssri.parse('sha512-bar', {single: true}).hexDigest(),\n    Buffer.from('bar', 'base64').toString('hex'),\n    'returned hex version of base64 digest')\n  t.done()\n})\n\ntest('isIntegrity and isHash', t => {\n  const sri = ssri.parse('sha512-bar')\n  t.ok(sri.isIntegrity, 'full sri has !!.isIntegrity')\n  t.ok(\n    sri['sha512'][0].isHash,\n    'sri hash has !!.isHash'\n  )\n  t.done()\n})\n\ntest('semi-private', t => {\n  t.equal(ssri.Integrity, undefined, 'Integrity class is module-private.')\n  t.done()\n})\n", "'use strict'\n\nconst crypto = require('crypto')\nconst fs = require('fs')\nconst test = require('tap').test\n\nconst ssri = require('..')\n\nconst TEST_DATA = fs.readFileSync(__filename)\n\nfunction hash (data, algorithm) {\n  return crypto.createHash(algorithm).update(data).digest('base64')\n}\n\ntest('serializes Integrity-likes', t => {\n  const sriLike = {\n    'sha512': [{\n      digest: 'foo',\n      algorithm: 'sha512',\n      options: ['ayy', 'woo']\n    }, {\n      digest: 'bar',\n      algorithm: 'sha512'\n    }],\n    'whirlpool': [{\n      digest: 'wut',\n      algorithm: 'whirlpool'\n    }]\n  }\n  t.equal(\n    ssri.stringify(sriLike),\n    'sha512-foo?ayy?woo sha512-bar whirlpool-wut',\n    'stringification contains correct data for all entries'\n  )\n  t.done()\n})\n\ntest('serializes Hash-likes', t => {\n  const sriLike = {\n    digest: 'foo',\n    algorithm: 'sha512'\n  }\n  t.equal(\n    ssri.stringify(sriLike),\n    'sha512-foo',\n    'serialization has correct data'\n  )\n  t.done()\n})\n\ntest('serialized plain strings into a valid parsed version', t => {\n  const sri = ' \\tsha512-foo?bar    \\n\\n\\nsha1-nope\\r'\n  t.equal(\n    ssri.stringify(sri),\n    'sha512-foo?bar sha1-nope',\n    'cleaned-up string with identical contents generated'\n  )\n  t.done()\n})\n\ntest('accepts a separator opt', t => {\n  const sriLike = {\n    'sha512': [{\n      algorithm: 'sha512',\n      digest: 'foo'\n    }, {\n      algorithm: 'sha512',\n      digest: 'bar'\n    }]\n  }\n  t.equal(\n    ssri.stringify(sriLike, {sep: '\\n'}),\n    'sha512-foo\\nsha512-bar'\n  )\n  t.equal(\n    ssri.stringify(sriLike, {sep: ' | '}),\n    'sha512-foo | sha512-bar'\n  )\n  t.done()\n})\n\ntest('support strict serialization', t => {\n  const sriLike = {\n    // only sha256, sha384, and sha512 are allowed by the spec\n    'sha1': [{\n      algorithm: 'sha1',\n      digest: 'feh'\n    }],\n    'sha256': [{\n      algorithm: 'sha256',\n      // Must be valid base64\n      digest: 'wut!!!??!!??!'\n    }, {\n      algorithm: 'sha256',\n      digest: hash(TEST_DATA, 'sha256'),\n      options: ['foo']\n    }],\n    'sha512': [{\n      algorithm: 'sha512',\n      digest: hash(TEST_DATA, 'sha512'),\n      // Options must use VCHAR\n      options: ['\\x01']\n    }]\n  }\n  t.equal(\n    ssri.stringify(sriLike, {strict: true}),\n    `sha256-${hash(TEST_DATA, 'sha256')}?foo`,\n    'entries that do not conform to strict spec interpretation removed'\n  )\n  t.equal(\n    ssri.stringify('sha512-foo sha256-bar', {sep: ' \\r|\\n\\t', strict: true}),\n    'sha512-foo \\r \\n\\tsha256-bar',\n    'strict mode replaces non-whitespace characters in separator with space'\n  )\n  t.done()\n})\n"], "fixing_code": ["'use strict'\n\nconst Buffer = require('safe-buffer').Buffer\n\nconst crypto = require('crypto')\nconst Transform = require('stream').Transform\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)*$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    const strict = !!(opts && opts.strict)\n    this.source = hash.trim()\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n      ? STRICT_SRI_REGEX\n      : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : []\n  }\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    if (opts && opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        (this.options || []).every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n    ? `?${this.options.join('?')}`\n    : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    opts = opts || {}\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n  concat (integrity, opts) {\n    const other = typeof integrity === 'string'\n    ? integrity\n    : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n  hexDigest () {\n    return parse(this, {single: true}).hexDigest()\n  }\n  match (integrity, opts) {\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n  pickAlgorithm (opts) {\n    const pickAlgorithm = (opts && opts.pickAlgorithm) || getPrioritizedHash\n    const keys = Object.keys(this)\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${\n        JSON.stringify(this.toString())\n      }`)\n    }\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  opts = opts || {}\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  const optString = (opts && opts.options && opts.options.length)\n  ? `?${opts.options.join('?')}`\n  : ''\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = opts || {}\n  const algorithms = opts.algorithms || ['sha512']\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n       opts\n    )\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = opts || {}\n  const P = opts.Promise || Promise\n  const istream = integrityStream(opts)\n  return new P((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = opts || {}\n  sri = parse(sri, opts)\n  if (!Object.keys(sri).length) { return false }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  return parse({algorithm, digest}).match(sri, opts)\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = opts || {}\n  const P = opts.Promise || Promise\n  const checker = integrityStream(Object.assign({}, opts, {\n    integrity: sri\n  }))\n  return new P((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts) {\n  opts = opts || {}\n  // For verification\n  const sri = opts.integrity && parse(opts.integrity, opts)\n  const goodSri = sri && Object.keys(sri).length\n  const algorithm = goodSri && sri.pickAlgorithm(opts)\n  const digests = goodSri && sri[algorithm]\n  // Calculating stream\n  const algorithms = (opts.algorithms || ['sha512'])\n  .concat(algorithm ? [algorithm] : [])\n  const hashes = algorithms.map(crypto.createHash)\n  let streamSize = 0\n  const stream = new Transform({\n    transform (chunk, enc, cb) {\n      streamSize += chunk.length\n      hashes.forEach(h => h.update(chunk, enc))\n      cb(null, chunk, enc)\n    }\n  }).on('end', () => {\n    const optString = (opts.options && opts.options.length)\n    ? `?${opts.options.join('?')}`\n    : ''\n    const newSri = parse(hashes.map((h, i) => {\n      return `${algorithms[i]}-${h.digest('base64')}${optString}`\n    }).join(' '), opts)\n    // Integrity verification mode\n    const match = goodSri && newSri.match(sri, opts)\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`)\n      err.code = 'EBADSIZE'\n      err.found = streamSize\n      err.expected = opts.size\n      err.sri = sri\n      stream.emit('error', err)\n    } else if (opts.integrity && !match) {\n      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = digests\n      err.algorithm = algorithm\n      err.sri = sri\n      stream.emit('error', err)\n    } else {\n      stream.emit('size', streamSize)\n      stream.emit('integrity', newSri)\n      match && stream.emit('verified', match)\n    }\n  })\n  return stream\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = opts || {}\n  const algorithms = opts.algorithms || ['sha512']\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\n// This is a Best Effort\u2122 at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n]\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n  ? algo1\n  : algo2\n}\n", "'use strict'\n\nconst Buffer = require('safe-buffer').Buffer\n\nconst test = require('tap').test\n\nconst ssri = require('..')\n\ntest('toString()', t => {\n  const sri = ssri.parse('sha1-eUN/Xt2hP5wGabl43XqQZt0gWfE= sha256-Qhx213Vjr6GRSEawEL0WTzlb00whAuXpngy5zxc8HYc=')\n  t.equal(\n    sri.toString(),\n    'sha1-eUN/Xt2hP5wGabl43XqQZt0gWfE= sha256-Qhx213Vjr6GRSEawEL0WTzlb00whAuXpngy5zxc8HYc=',\n    'integrity objects from ssri.parse() can use toString()'\n  )\n  t.equal(\n    sri.toString({strict: true}),\n    'sha256-Qhx213Vjr6GRSEawEL0WTzlb00whAuXpngy5zxc8HYc=',\n    'accepts strict mode option'\n  )\n  t.equal(\n    sri.toString({sep: '\\n'}),\n    'sha1-eUN/Xt2hP5wGabl43XqQZt0gWfE=\\nsha256-Qhx213Vjr6GRSEawEL0WTzlb00whAuXpngy5zxc8HYc=',\n    'accepts separator option'\n  )\n  t.done()\n})\n\ntest('toJSON()', t => {\n  const sri = ssri.parse('sha512-foo sha256-bar!')\n  t.equal(\n    sri.toJSON(),\n    'sha512-foo sha256-bar!',\n    'integrity objects from ssri.parse() can use toJSON()'\n  )\n  t.equal(\n    sri.sha512[0].toJSON(),\n    'sha512-foo',\n    'hash objects should toJSON also'\n  )\n  t.done()\n})\n\ntest('concat()', t => {\n  const sri = ssri.parse('sha512-foo')\n  t.equal(\n    sri.concat('sha512-bar').toString(),\n    'sha512-foo sha512-bar',\n    'concatenates with a string'\n  )\n  t.equal(\n    sri.concat({digest: 'bar', algorithm: 'sha384'}).toString(),\n    'sha512-foo sha384-bar',\n    'concatenates with an Hash-like'\n  )\n  t.equal(\n    sri.concat({\n      'sha384': [{digest: 'bar', algorithm: 'sha384'}],\n      'sha1': [{digest: 'baz', algorithm: 'sha1'}]\n    }).toString(),\n    'sha512-foo sha384-bar sha1-baz',\n    'concatenates with an Integrity-like'\n  )\n  t.equal(\n    sri.concat(\n      {digest: 'bar', algorithm: 'sha1'}\n    ).concat(\n      'sha1-baz'\n    ).concat(\n      'sha512-quux'\n    ).toString(),\n    'sha512-foo sha512-quux sha1-bar sha1-baz',\n    'preserves relative order for algorithms between different concatenations'\n  )\n  const strictSri = ssri.parse('sha512-WrLorGiX4iEWOOOaJSiCrmDIamA47exH+Bz7tVwIPb4sCU8w4iNqGCqYuspMMeU5pgz/sU7koP5u8W3RCUojGw==')\n  t.equal(\n    strictSri.concat('sha1-eUN/Xt2hP5wGabl43XqQZt0gWfE=', {\n      strict: true\n    }).toString(),\n    'sha512-WrLorGiX4iEWOOOaJSiCrmDIamA47exH+Bz7tVwIPb4sCU8w4iNqGCqYuspMMeU5pgz/sU7koP5u8W3RCUojGw==',\n    'accepts strict mode option'\n  )\n  t.done()\n})\n\ntest('match()', t => {\n  const sri = ssri.parse('sha1-foo sha512-bar')\n  t.similar(sri.match('sha1-foo'), {\n    algorithm: 'sha1',\n    digest: 'foo'\n  }, 'returns the matching hash')\n  t.similar(sri.match(ssri.parse('sha1-foo')), {\n    algorithm: 'sha1',\n    digest: 'foo'\n  }, 'accepts other Integrity objects')\n  t.similar(sri.match(ssri.parse('sha1-foo')), {\n    algorithm: 'sha1',\n    digest: 'foo'\n  }, 'accepts other Hash objects')\n  t.similar(sri.match({digest: 'foo', algorithm: 'sha1'}), {\n    algorithm: 'sha1',\n    digest: 'foo'\n  }, 'accepts Hash-like objects')\n  t.similar(sri.match('sha1-bar sha512-bar'), {\n    algorithm: 'sha512',\n    digest: 'bar'\n  }, 'returns the strongest match')\n  t.notOk(sri.match('sha512-foo'), 'falsy when match fails')\n  t.notOk(sri.match('sha384-foo'), 'falsy when match fails')\n  t.done()\n})\n\ntest('pickAlgorithm()', t => {\n  const sri = ssri.parse('sha1-foo sha512-bar sha384-baz')\n  t.equal(sri.pickAlgorithm(), 'sha512', 'picked best algorithm')\n  t.equal(\n    ssri.parse('unknown-deadbeef uncertain-bada55').pickAlgorithm(),\n    'unknown',\n    'unrecognized algorithm returned if none others known'\n  )\n  t.equal(\n    sri.pickAlgorithm({\n      pickAlgorithm: (a, b) => 'sha384'\n    }),\n    'sha384',\n    'custom pickAlgorithm function accepted'\n  )\n  t.throws(() => {\n    ssri.parse('').pickAlgorithm()\n  }, /No algorithms available/, 'SRIs without algorithms are invalid')\n  t.done()\n})\n\ntest('hexDigest()', t => {\n  t.equal(\n    ssri.parse('sha512-foo').hexDigest(),\n    Buffer.from('foo', 'base64').toString('hex'),\n    'returned hex version of base64 digest')\n  t.equal(\n    ssri.parse('sha512-bar', {single: true}).hexDigest(),\n    Buffer.from('bar', 'base64').toString('hex'),\n    'returned hex version of base64 digest')\n  t.done()\n})\n\ntest('isIntegrity and isHash', t => {\n  const sri = ssri.parse('sha512-bar')\n  t.ok(sri.isIntegrity, 'full sri has !!.isIntegrity')\n  t.ok(\n    sri['sha512'][0].isHash,\n    'sri hash has !!.isHash'\n  )\n  t.done()\n})\n\ntest('semi-private', t => {\n  t.equal(ssri.Integrity, undefined, 'Integrity class is module-private.')\n  t.done()\n})\n", "'use strict'\n\nconst crypto = require('crypto')\nconst fs = require('fs')\nconst test = require('tap').test\n\nconst ssri = require('..')\n\nconst TEST_DATA = fs.readFileSync(__filename)\n\nfunction hash (data, algorithm) {\n  return crypto.createHash(algorithm).update(data).digest('base64')\n}\n\ntest('serializes Integrity-likes', t => {\n  const sriLike = {\n    'sha512': [{\n      digest: 'foo',\n      algorithm: 'sha512',\n      options: ['ayy', 'woo']\n    }, {\n      digest: 'bar',\n      algorithm: 'sha512'\n    }],\n    'whirlpool': [{\n      digest: 'wut',\n      algorithm: 'whirlpool'\n    }]\n  }\n  t.equal(\n    ssri.stringify(sriLike),\n    'sha512-foo?ayy?woo sha512-bar whirlpool-wut',\n    'stringification contains correct data for all entries'\n  )\n  t.done()\n})\n\ntest('serializes Hash-likes', t => {\n  const sriLike = {\n    digest: 'foo',\n    algorithm: 'sha512'\n  }\n  t.equal(\n    ssri.stringify(sriLike),\n    'sha512-foo',\n    'serialization has correct data'\n  )\n  t.done()\n})\n\ntest('serialized plain strings into a valid parsed version', t => {\n  const sri = ' \\tsha512-foo?bar    \\n\\n\\nsha1-nope\\r'\n  t.equal(\n    ssri.stringify(sri),\n    'sha512-foo?bar sha1-nope',\n    'cleaned-up string with identical contents generated'\n  )\n  t.done()\n})\n\ntest('accepts a separator opt', t => {\n  const sriLike = {\n    'sha512': [{\n      algorithm: 'sha512',\n      digest: 'foo'\n    }, {\n      algorithm: 'sha512',\n      digest: 'bar'\n    }]\n  }\n  t.equal(\n    ssri.stringify(sriLike, {sep: '\\n'}),\n    'sha512-foo\\nsha512-bar'\n  )\n  t.equal(\n    ssri.stringify(sriLike, {sep: ' | '}),\n    'sha512-foo | sha512-bar'\n  )\n  t.done()\n})\n\ntest('support strict serialization', t => {\n  const sriLike = {\n    // only sha256, sha384, and sha512 are allowed by the spec\n    'sha1': [{\n      algorithm: 'sha1',\n      digest: 'feh'\n    }],\n    'sha256': [{\n      algorithm: 'sha256',\n      // Must be valid base64\n      digest: 'wut!!!??!!??!'\n    }, {\n      algorithm: 'sha256',\n      digest: hash(TEST_DATA, 'sha256'),\n      options: ['foo']\n    }],\n    'sha512': [{\n      algorithm: 'sha512',\n      digest: hash(TEST_DATA, 'sha512'),\n      // Options must use VCHAR\n      options: ['\\x01']\n    }]\n  }\n  t.equal(\n    ssri.stringify(sriLike, {strict: true}),\n    `sha256-${hash(TEST_DATA, 'sha256')}?foo`,\n    'entries that do not conform to strict spec interpretation removed'\n  )\n  t.equal(\n    ssri.stringify('sha512-WrLorGiX4iEWOOOaJSiCrmDIamA47exH+Bz7tVwIPb4sCU8w4iNqGCqYuspMMeU5pgz/sU7koP5u8W3RCUojGw== sha256-Qhx213Vjr6GRSEawEL0WTzlb00whAuXpngy5zxc8HYc=', {sep: ' \\r|\\n\\t', strict: true}),\n    'sha512-WrLorGiX4iEWOOOaJSiCrmDIamA47exH+Bz7tVwIPb4sCU8w4iNqGCqYuspMMeU5pgz/sU7koP5u8W3RCUojGw== \\r \\n\\tsha256-Qhx213Vjr6GRSEawEL0WTzlb00whAuXpngy5zxc8HYc=',\n    'strict mode replaces non-whitespace characters in separator with space'\n  )\n  t.done()\n})\n"], "filenames": ["index.js", "test/integrity.js", "test/stringify.js"], "buggy_code_start_loc": [12, 10, 111], "buggy_code_end_loc": [13, 78, 113], "fixing_code_start_loc": [12, 10, 111], "fixing_code_end_loc": [13, 81, 113], "type": "CWE-400", "message": "index.js in the ssri module before 5.2.2 for Node.js is prone to a regular expression denial of service vulnerability in strict mode functionality via a long base64 hash string.", "other": {"cve": {"id": "CVE-2018-7651", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-04T01:29:00.347", "lastModified": "2018-03-27T14:46:13.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "index.js in the ssri module before 5.2.2 for Node.js is prone to a regular expression denial of service vulnerability in strict mode functionality via a long base64 hash string."}, {"lang": "es", "value": "index.js en el m\u00f3dulo ssri en versiones anteriores a la 5.2.2 para Node.js es propenso a una vulnerabilidad de denegaci\u00f3n de servicio de expresi\u00f3n regular (DoS) en funcionalidad de modo estricto mediante una cadena de hash larga en base64."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ssri_project:ssri:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.2.2", "matchCriteriaId": "82F10CD9-3D61-4153-99B3-9F13D63BA334"}]}]}], "references": [{"url": "https://github.com/zkat/ssri/commit/d0ebcdc22cb5c8f47f89716d08b3518b2485d65d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zkat/ssri/issues/10", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://nodesecurity.io/advisories/565", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zkat/ssri/commit/d0ebcdc22cb5c8f47f89716d08b3518b2485d65d"}}