{"buggy_code": ["# frozen_string_literal: true\n\nclass Search\n  DIACRITICS ||= /([\\u0300-\\u036f]|[\\u1AB0-\\u1AFF]|[\\u1DC0-\\u1DFF]|[\\u20D0-\\u20FF])/\n  HIGHLIGHT_CSS_CLASS = 'search-highlight'\n\n  cattr_accessor :preloaded_topic_custom_fields\n  self.preloaded_topic_custom_fields = Set.new\n\n  def self.on_preload(&blk)\n    (@preload ||= Set.new) << blk\n  end\n\n  def self.preload(results, object)\n    if @preload\n      @preload.each { |preload| preload.call(results, object) }\n    end\n  end\n\n  def self.per_facet\n    5\n  end\n\n  def self.strip_diacritics(str)\n    s = str.unicode_normalize(:nfkd)\n    s.gsub!(DIACRITICS, \"\")\n    s.strip!\n    s\n  end\n\n  def self.per_filter\n    50\n  end\n\n  def self.facets\n    %w(topic category user private_messages tags all_topics exclude_topics)\n  end\n\n  def self.ts_config(locale = SiteSetting.default_locale)\n    # if adding a text search configuration, you should check PG beforehand:\n    # SELECT cfgname FROM pg_ts_config;\n    # As an aside, dictionaries can be listed by `\\dFd`, the\n    # physical locations are in /usr/share/postgresql/<version>/tsearch_data.\n    # But it may not appear there based on pg extension configuration.\n    # base docker config\n    #\n    case locale.split(\"_\")[0].to_sym\n    when :da then 'danish'\n    when :nl then 'dutch'\n    when :en then 'english'\n    when :fi then 'finnish'\n    when :fr then 'french'\n    when :de then 'german'\n    when :hu then 'hungarian'\n    when :it then 'italian'\n    when :nb then 'norwegian'\n    when :pt then 'portuguese'\n    when :ro then 'romanian'\n    when :ru then 'russian'\n    when :es then 'spanish'\n    when :sv then 'swedish'\n    when :tr then 'turkish'\n    else 'simple' # use the 'simple' stemmer for other languages\n    end\n  end\n\n  def self.segment_cjk?\n    ['zh_TW', 'zh_CN', 'ja'].include?(SiteSetting.default_locale) ||\n      SiteSetting.search_tokenize_chinese_japanese_korean\n  end\n\n  def self.prepare_data(search_data, purpose = nil)\n    data = search_data.dup\n    data.force_encoding(\"UTF-8\")\n\n    if purpose != :topic\n      # TODO cppjieba_rb is designed for chinese, we need something else for Japanese\n      # Korean appears to be safe cause words are already space separated\n      # For Japanese we should investigate using kakasi\n      if segment_cjk?\n        require 'cppjieba_rb' unless defined? CppjiebaRb\n        data = CppjiebaRb.segment(search_data, mode: :mix)\n\n        # TODO: we still want to tokenize here but the current stopword list is too wide\n        # in cppjieba leading to words such as volume to be skipped. PG already has an English\n        # stopword list so use that vs relying on cppjieba\n        if ts_config != 'english'\n          data = CppjiebaRb.filter_stop_word(data)\n        else\n          data = data.filter { |s| s.present? }\n        end\n\n        data = data.join(' ')\n      else\n        data.squish!\n      end\n\n      if SiteSetting.search_ignore_accents\n        data = strip_diacritics(data)\n      end\n    end\n\n    data.gsub!(/\\S+/) do |str|\n      if str =~ /^[\"]?((https?:\\/\\/)[\\S]+)[\"]?$/\n        begin\n          uri = URI.parse(Regexp.last_match[1])\n          uri.query = nil\n          str = uri.to_s\n        rescue URI::Error\n          # don't fail if uri does not parse\n        end\n      end\n\n      str\n    end\n\n    data\n  end\n\n  def self.word_to_date(str)\n\n    if str =~ /^[0-9]{1,3}$/\n      return Time.zone.now.beginning_of_day.days_ago(str.to_i)\n    end\n\n    if str =~ /^([12][0-9]{3})(-([0-1]?[0-9]))?(-([0-3]?[0-9]))?$/\n      year = $1.to_i\n      month = $2 ? $3.to_i : 1\n      day = $4 ? $5.to_i : 1\n\n      return if day == 0 || month == 0 || day > 31 || month > 12\n\n      return begin\n        Time.zone.parse(\"#{year}-#{month}-#{day}\")\n      rescue ArgumentError\n      end\n    end\n\n    if str.downcase == \"yesterday\"\n      return Time.zone.now.beginning_of_day.yesterday\n    end\n\n    titlecase = str.downcase.titlecase\n\n    if Date::DAYNAMES.include?(titlecase)\n      return Time.zone.now.beginning_of_week(str.downcase.to_sym)\n    end\n\n    if idx = (Date::MONTHNAMES.find_index(titlecase) ||\n              Date::ABBR_MONTHNAMES.find_index(titlecase))\n      delta = Time.zone.now.month - idx\n      delta += 12 if delta < 0\n      Time.zone.now.beginning_of_month.months_ago(delta)\n    end\n  end\n\n  def self.min_post_id_no_cache\n    return 0 unless SiteSetting.search_prefer_recent_posts?\n\n    offset, has_more = Post.unscoped\n      .order('id desc')\n      .offset(SiteSetting.search_recent_posts_size - 1)\n      .limit(2)\n      .pluck(:id)\n\n    has_more ? offset : 0\n  end\n\n  def self.min_post_id(opts = nil)\n    return 0 unless SiteSetting.search_prefer_recent_posts?\n\n    # It can be quite slow to count all the posts so let's cache it\n    Discourse.cache.fetch(\"search-min-post-id:#{SiteSetting.search_recent_posts_size}\", expires_in: 1.week) do\n      min_post_id_no_cache\n    end\n  end\n\n  attr_accessor :term\n  attr_reader :clean_term, :guardian\n\n  def initialize(term, opts = nil)\n    @opts = opts || {}\n    @guardian = @opts[:guardian] || Guardian.new\n    @search_context = @opts[:search_context]\n    @blurb_length = @opts[:blurb_length]\n    @valid = true\n    @page = @opts[:page]\n    @search_all_pms = false\n\n    term = term.to_s.dup\n\n    # Removes any zero-width characters from search terms\n    term.gsub!(/[\\u200B-\\u200D\\uFEFF]/, '')\n    # Replace curly quotes to regular quotes\n    term.gsub!(/[\\u201c\\u201d]/, '\"')\n\n    @clean_term = term\n    @in_title = false\n\n    term = process_advanced_search!(term)\n\n    if term.present?\n      @term = Search.prepare_data(term, Topic === @search_context ? :topic : nil)\n      @original_term = Search.escape_string(@term)\n    end\n\n    if @search_pms || @search_all_pms || @opts[:type_filter] == 'private_messages'\n      @opts[:type_filter] = \"private_messages\"\n      @search_context ||= @guardian.user\n\n      unless @search_context.present? && @guardian.can_see_private_messages?(@search_context.id)\n        raise Discourse::InvalidAccess.new\n      end\n    end\n\n    if @search_all_topics && @guardian.user\n      @opts[:type_filter] = \"all_topics\"\n    end\n\n    @results = GroupedSearchResults.new(\n      type_filter: @opts[:type_filter],\n      term: clean_term,\n      blurb_term: term,\n      search_context: @search_context,\n      blurb_length: @blurb_length\n    )\n  end\n\n  def limit\n    if @opts[:type_filter].present? && @opts[:type_filter] != \"exclude_topics\"\n      Search.per_filter + 1\n    else\n      Search.per_facet + 1\n    end\n  end\n\n  def offset\n    if @page && @opts[:type_filter].present?\n      (@page - 1) * Search.per_filter\n    else\n      0\n    end\n  end\n\n  def valid?\n    @valid\n  end\n\n  def self.execute(term, opts = nil)\n    self.new(term, opts).execute\n  end\n\n  # Query a term\n  def execute(readonly_mode: Discourse.readonly_mode?)\n    if log_query?(readonly_mode)\n      status, search_log_id = SearchLog.log(\n        term: @clean_term,\n        search_type: @opts[:search_type],\n        ip_address: @opts[:ip_address],\n        user_id: @opts[:user_id]\n      )\n      @results.search_log_id = search_log_id unless status == :error\n    end\n\n    unless @filters.present? || @opts[:search_for_id]\n      min_length = @opts[:min_search_term_length] || SiteSetting.min_search_term_length\n      terms = (@term || '').split(/\\s(?=(?:[^\"]|\"[^\"]*\")*$)/).reject { |t| t.length < min_length }\n\n      if terms.blank?\n        @term = ''\n        @valid = false\n        return\n      end\n    end\n\n    # If the term is a number or url to a topic, just include that topic\n    if @opts[:search_for_id] && ['topic', 'private_messages', 'all_topics'].include?(@results.type_filter)\n      if @term =~ /^\\d+$/\n        single_topic(@term.to_i)\n      else\n        if route = Discourse.route_for(@term)\n          if route[:controller] == \"topics\" && route[:action] == \"show\"\n            topic_id = (route[:id] || route[:topic_id]).to_i\n            single_topic(topic_id) if topic_id > 0\n          end\n        end\n      end\n    end\n\n    find_grouped_results if @results.posts.blank?\n\n    if preloaded_topic_custom_fields.present? && @results.posts.present?\n      topics = @results.posts.map(&:topic)\n      Topic.preload_custom_fields(topics, preloaded_topic_custom_fields)\n    end\n\n    Search.preload(@results, self)\n\n    @results\n  end\n\n  def self.advanced_order(trigger, &block)\n    (@advanced_orders ||= {})[trigger] = block\n  end\n\n  def self.advanced_orders\n    @advanced_orders\n  end\n\n  def self.advanced_filter(trigger, &block)\n    (@advanced_filters ||= {})[trigger] = block\n  end\n\n  def self.advanced_filters\n    @advanced_filters\n  end\n\n  def self.custom_topic_eager_load(tables = nil, &block)\n    (@custom_topic_eager_loads ||= []) << (tables || block)\n  end\n\n  def self.custom_topic_eager_loads\n    Array.wrap(@custom_topic_eager_loads)\n  end\n\n  advanced_filter(/^in:personal-direct$/i) do |posts|\n    if @guardian.user\n      posts\n        .joins(\"LEFT JOIN topic_allowed_groups tg ON posts.topic_id = tg.topic_id\")\n        .where(<<~SQL, user_id: @guardian.user.id)\n          tg.id IS NULL\n          AND posts.topic_id IN (\n            SELECT tau.topic_id\n            FROM topic_allowed_users tau\n            JOIN topic_allowed_users tau2\n            ON tau2.topic_id = tau.topic_id\n            AND tau2.id != tau.id\n            WHERE tau.user_id = :user_id\n            GROUP BY tau.topic_id\n            HAVING COUNT(*) = 1\n          )\n        SQL\n    end\n  end\n\n  advanced_filter(/^in:all-pms$/i) do |posts|\n    posts.private_posts if @guardian.is_admin?\n  end\n\n  advanced_filter(/^in:tagged$/i) do |posts|\n    posts\n      .where('EXISTS (SELECT 1 FROM topic_tags WHERE topic_tags.topic_id = posts.topic_id)')\n  end\n\n  advanced_filter(/^in:untagged$/i) do |posts|\n    posts\n      .joins(\"LEFT JOIN topic_tags ON\n        topic_tags.topic_id = posts.topic_id\")\n      .where(\"topic_tags.id IS NULL\")\n  end\n\n  advanced_filter(/^status:open$/i) do |posts|\n    posts.where('NOT topics.closed AND NOT topics.archived')\n  end\n\n  advanced_filter(/^status:closed$/i) do |posts|\n    posts.where('topics.closed')\n  end\n\n  advanced_filter(/^status:public$/i) do |posts|\n    category_ids = Category\n      .where(read_restricted: false)\n      .pluck(:id)\n\n    posts.where(\"topics.category_id in (?)\", category_ids)\n  end\n\n  advanced_filter(/^status:archived$/i) do |posts|\n    posts.where('topics.archived')\n  end\n\n  advanced_filter(/^status:noreplies$/i) do |posts|\n    posts.where(\"topics.posts_count = 1\")\n  end\n\n  advanced_filter(/^status:single_user$/i) do |posts|\n    posts.where(\"topics.participant_count = 1\")\n  end\n\n  advanced_filter(/^posts_count:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.posts_count = ?\", match.to_i)\n  end\n\n  advanced_filter(/^min_post_count:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.posts_count >= ?\", match.to_i)\n  end\n\n  advanced_filter(/^min_posts:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.posts_count >= ?\", match.to_i)\n  end\n\n  advanced_filter(/^max_posts:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.posts_count <= ?\", match.to_i)\n  end\n\n  advanced_filter(/^in:first|^f$/i) do |posts|\n    posts.where(\"posts.post_number = 1\")\n  end\n\n  advanced_filter(/^in:pinned$/i) do |posts|\n    posts.where(\"topics.pinned_at IS NOT NULL\")\n  end\n\n  advanced_filter(/^in:wiki$/i) do |posts, match|\n    posts.where(wiki: true)\n  end\n\n  advanced_filter(/^badge:(.*)$/i) do |posts, match|\n    badge_id = Badge.where('name ilike ? OR id = ?', match, match.to_i).pluck_first(:id)\n    if badge_id\n      posts.where('posts.user_id IN (SELECT ub.user_id FROM user_badges ub WHERE ub.badge_id = ?)', badge_id)\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  def post_action_type_filter(posts, post_action_type)\n    posts.where(\"posts.id IN (\n      SELECT pa.post_id FROM post_actions pa\n      WHERE pa.user_id = #{@guardian.user.id} AND\n            pa.post_action_type_id = #{post_action_type} AND\n            deleted_at IS NULL\n    )\")\n  end\n\n  advanced_filter(/^in:(likes)$/i) do |posts, match|\n    if @guardian.user\n      post_action_type_filter(posts, PostActionType.types[:like])\n    end\n  end\n\n  advanced_filter(/^in:(bookmarks)$/i) do |posts, match|\n    if @guardian.user\n      posts.where(\"posts.id IN (SELECT post_id FROM bookmarks WHERE bookmarks.user_id = #{@guardian.user.id})\")\n    end\n  end\n\n  advanced_filter(/^in:posted$/i) do |posts|\n    posts.where(\"posts.user_id = #{@guardian.user.id}\") if @guardian.user\n  end\n\n  advanced_filter(/^in:(created|mine)$/i) do |posts|\n    posts.where(user_id: @guardian.user.id, post_number: 1) if @guardian.user\n  end\n\n  advanced_filter(/^created:@(.*)$/i) do |posts, match|\n    user_id = User.where(username: match.downcase).pluck_first(:id)\n    posts.where(user_id: user_id, post_number: 1)\n  end\n\n  advanced_filter(/^in:(watching|tracking)$/i) do |posts, match|\n    if @guardian.user\n      level = TopicUser.notification_levels[match.downcase.to_sym]\n      posts.where(\"posts.topic_id IN (\n                    SELECT tu.topic_id FROM topic_users tu\n                    WHERE tu.user_id = :user_id AND\n                          tu.notification_level >= :level\n                   )\", user_id: @guardian.user.id, level: level)\n\n    end\n  end\n\n  advanced_filter(/^in:seen$/i) do |posts|\n    if @guardian.user\n      posts\n        .joins(\"INNER JOIN post_timings ON\n          post_timings.topic_id = posts.topic_id\n          AND post_timings.post_number = posts.post_number\n          AND post_timings.user_id = #{ActiveRecord::Base.connection.quote(@guardian.user.id)}\n        \")\n    end\n  end\n\n  advanced_filter(/^in:unseen$/i) do |posts|\n    if @guardian.user\n      posts\n        .joins(\"LEFT JOIN post_timings ON\n          post_timings.topic_id = posts.topic_id\n          AND post_timings.post_number = posts.post_number\n          AND post_timings.user_id = #{ActiveRecord::Base.connection.quote(@guardian.user.id)}\n        \")\n        .where(\"post_timings.user_id IS NULL\")\n    end\n  end\n\n  advanced_filter(/^with:images$/i) do |posts|\n    posts.where(\"posts.image_upload_id IS NOT NULL\")\n  end\n\n  advanced_filter(/^category:(.+)$/i) do |posts, match|\n    exact = false\n\n    if match[0] == \"=\"\n      exact = true\n      match = match[1..-1]\n    end\n\n    category_ids = Category.where('slug ilike ? OR name ilike ? OR id = ?',\n                                  match, match, match.to_i).pluck(:id)\n    if category_ids.present?\n      category_ids += Category.subcategory_ids(category_ids.first) unless exact\n      @category_filter_matched ||= true\n      posts.where(\"topics.category_id IN (?)\", category_ids)\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  advanced_filter(/^\\#([\\p{L}\\p{M}0-9\\-:=]+)$/i) do |posts, match|\n    category_slug, subcategory_slug = match.to_s.split(\":\")\n    next unless category_slug\n\n    exact = true\n    if category_slug[0] == \"=\"\n      category_slug = category_slug[1..-1]\n    else\n      exact = false\n    end\n\n    category_id = if subcategory_slug\n      Category\n        .where('lower(slug) = ?', subcategory_slug.downcase)\n        .where(parent_category_id: Category.where('lower(slug) = ?', category_slug.downcase).select(:id))\n        .pluck_first(:id)\n    else\n      Category\n        .where('lower(slug) = ?', category_slug.downcase)\n        .order('case when parent_category_id is null then 0 else 1 end')\n        .pluck_first(:id)\n    end\n\n    if category_id\n      category_ids = [category_id]\n      category_ids += Category.subcategory_ids(category_id) if !exact\n\n      @category_filter_matched ||= true\n      posts.where(\"topics.category_id IN (?)\", category_ids)\n    else\n      # try a possible tag match\n      tag_id = Tag.where_name(category_slug).pluck_first(:id)\n      if (tag_id)\n        posts.where(<<~SQL, tag_id)\n          topics.id IN (\n            SELECT DISTINCT(tt.topic_id)\n            FROM topic_tags tt\n            WHERE tt.tag_id = ?\n          )\n        SQL\n      else\n        if tag_group_id = TagGroup.find_id_by_slug(category_slug)\n          posts.where(<<~SQL, tag_group_id)\n            topics.id IN (\n              SELECT DISTINCT(tt.topic_id)\n              FROM topic_tags tt\n              WHERE tt.tag_id in (\n                SELECT tag_id\n                FROM tag_group_memberships\n                WHERE tag_group_id = ?\n              )\n            )\n          SQL\n\n        # a bit yucky but we got to add the term back in\n        elsif match.to_s.length >= SiteSetting.min_search_term_length\n          posts.where <<~SQL\n            posts.id IN (\n              SELECT post_id FROM post_search_data pd1\n              WHERE pd1.search_data @@ #{Search.ts_query(term: \"##{match}\")})\n          SQL\n        end\n      end\n    end\n  end\n\n  advanced_filter(/^group:(.+)$/i) do |posts, match|\n    group_id = Group.where('name ilike ? OR (id = ? AND id > 0)', match, match.to_i).pluck_first(:id)\n    if group_id\n      posts.where(\"posts.user_id IN (select gu.user_id from group_users gu where gu.group_id = ?)\", group_id)\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  advanced_filter(/^user:(.+)$/i) do |posts, match|\n    user_id = User.where(staged: false).where('username_lower = ? OR id = ?', match.downcase, match.to_i).pluck_first(:id)\n    if user_id\n      posts.where(\"posts.user_id = #{user_id}\")\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  advanced_filter(/^\\@([a-zA-Z0-9_\\-.]+)$/i) do |posts, match|\n    username = match.downcase\n\n    user_id = User.where(staged: false).where(username_lower: username).pluck_first(:id)\n\n    if !user_id && username == \"me\"\n      user_id = @guardian.user&.id\n    end\n\n    if user_id\n      posts.where(\"posts.user_id = #{user_id}\")\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  advanced_filter(/^before:(.*)$/i) do |posts, match|\n    if date = Search.word_to_date(match)\n      posts.where(\"posts.created_at < ?\", date)\n    else\n      posts\n    end\n  end\n\n  advanced_filter(/^after:(.*)$/i) do |posts, match|\n    if date = Search.word_to_date(match)\n      posts.where(\"posts.created_at > ?\", date)\n    else\n      posts\n    end\n  end\n\n  advanced_filter(/^tags?:([\\p{L}\\p{M}0-9,\\-_+]+)$/i) do |posts, match|\n    search_tags(posts, match, positive: true)\n  end\n\n  advanced_filter(/^\\-tags?:([\\p{L}\\p{M}0-9,\\-_+]+)$/i) do |posts, match|\n    search_tags(posts, match, positive: false)\n  end\n\n  advanced_filter(/^filetypes?:([a-zA-Z0-9,\\-_]+)$/i) do |posts, match|\n    file_extensions = match.split(\",\").map(&:downcase)\n    posts.where(\"posts.id IN (\n      SELECT post_id\n        FROM topic_links\n       WHERE extension IN (:file_extensions)\n\n      UNION\n\n      SELECT post_uploads.post_id\n        FROM uploads\n        JOIN post_uploads ON post_uploads.upload_id = uploads.id\n       WHERE lower(uploads.extension) IN (:file_extensions)\n    )\", file_extensions: file_extensions)\n  end\n\n  advanced_filter(/^min_views:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.views >= ?\", match.to_i)\n  end\n\n  advanced_filter(/^max_views:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.views <= ?\", match.to_i)\n  end\n\n  private\n\n  def search_tags(posts, match, positive:)\n    return if match.nil?\n    match.downcase!\n    modifier = positive ? \"\" : \"NOT\"\n\n    if match.include?('+')\n      tags = match.split('+')\n\n      posts.where(\"topics.id #{modifier} IN (\n        SELECT tt.topic_id\n        FROM topic_tags tt, tags\n        WHERE tt.tag_id = tags.id\n        GROUP BY tt.topic_id\n        HAVING to_tsvector(#{default_ts_config}, array_to_string(array_agg(lower(tags.name)), ' ')) @@ to_tsquery(#{default_ts_config}, ?)\n      )\", tags.join('&'))\n    else\n      tags = match.split(\",\")\n\n      posts.where(\"topics.id #{modifier} IN (\n        SELECT DISTINCT(tt.topic_id)\n        FROM topic_tags tt, tags\n        WHERE tt.tag_id = tags.id AND lower(tags.name) IN (?)\n      )\", tags)\n    end\n  end\n\n  def process_advanced_search!(term)\n    term.to_s.scan(/(([^\" \\t\\n\\x0B\\f\\r]+)?((\"[^\"]+\")?))/).to_a.map do |(word, _)|\n      next if word.blank?\n\n      found = false\n\n      Search.advanced_filters.each do |matcher, block|\n        cleaned = word.gsub(/[\"']/, \"\")\n        if cleaned =~ matcher\n          (@filters ||= []) << [block, $1]\n          found = true\n        end\n      end\n\n      if word == 'l'\n        @order = :latest\n        nil\n      elsif word =~ /^order:\\w+$/i\n        @order = word.downcase.gsub('order:', '').to_sym\n        nil\n      elsif word =~ /^in:title$/i || word == 't'\n        @in_title = true\n        nil\n      elsif word =~ /^topic:(\\d+)$/i\n        topic_id = $1.to_i\n        if topic_id > 1\n          topic = Topic.find_by(id: topic_id)\n          if @guardian.can_see?(topic)\n            @search_context = topic\n          end\n        end\n        nil\n      elsif word =~ /^in:all$/i\n        @search_all_topics = true\n        nil\n      elsif word =~ /^in:personal$/i\n        @search_pms = true\n        nil\n      elsif word =~ /^in:personal-direct$/i\n        @search_pms = true\n        nil\n      elsif word =~ /^in:all-pms$/i\n        @search_all_pms = true\n        nil\n      elsif word =~ /^personal_messages:(.+)$/i\n        if user = User.find_by_username($1)\n          @search_pms = true\n          @search_context = user\n        end\n\n        nil\n      else\n        found ? nil : word\n      end\n    end.compact.join(' ')\n  end\n\n  def find_grouped_results\n    if @results.type_filter.present?\n      raise Discourse::InvalidAccess.new(\"invalid type filter\") unless Search.facets.include?(@results.type_filter)\n      # calling protected methods\n      send(\"#{@results.type_filter}_search\")\n    else\n      if @term.present? && !@search_context\n        user_search\n        category_search\n        tags_search\n        groups_search\n      end\n      topic_search\n    end\n\n    @results\n  rescue ActiveRecord::StatementInvalid\n    # In the event of a PG:Error return nothing, it is likely they used a foreign language whose\n    # locale is not supported by postgres\n  end\n\n  # If we're searching for a single topic\n  def single_topic(id)\n    if @opts[:restrict_to_archetype].present?\n      archetype = @opts[:restrict_to_archetype] == Archetype.default ? Archetype.default : Archetype.private_message\n\n      post = posts_scope\n        .joins(:topic)\n        .find_by(\n          \"topics.id = :id AND topics.archetype = :archetype AND posts.post_number = 1\",\n          id: id,\n          archetype: archetype\n        )\n    else\n      post = posts_scope.find_by(topic_id: id, post_number: 1)\n    end\n\n    return nil unless @guardian.can_see?(post)\n\n    @results.add(post)\n    @results\n  end\n\n  def secure_category_ids\n    return @secure_category_ids unless @secure_category_ids.nil?\n    @secure_category_ids = @guardian.secure_category_ids\n  end\n\n  def category_search\n    # scope is leaking onto Category, this is not good and probably a bug in Rails\n    # the secure_category_ids will invoke the same method on User, it calls Category.where\n    # however the scope from the query below is leaking in to Category, this works around\n    # the issue while we figure out what is up in Rails\n    secure_category_ids\n\n    categories = Category.includes(:category_search_data)\n      .where(\"category_search_data.search_data @@ #{ts_query}\")\n      .references(:category_search_data)\n      .order(\"topics_month DESC\")\n      .secured(@guardian)\n      .limit(limit)\n\n    categories.each do |category|\n      @results.add(category)\n    end\n  end\n\n  def user_search\n    return if SiteSetting.hide_user_profiles_from_public && !@guardian.user\n\n    users = User\n      .includes(:user_search_data)\n      .references(:user_search_data)\n      .where(active: true)\n      .where(staged: false)\n      .where(\"user_search_data.search_data @@ #{ts_query(\"simple\")}\")\n      .order(\"CASE WHEN username_lower = '#{@original_term.downcase}' THEN 0 ELSE 1 END\")\n      .order(\"last_posted_at DESC\")\n      .limit(limit)\n\n    if !SiteSetting.enable_listing_suspended_users_on_search && !@guardian.user&.admin\n      users = users.where(suspended_at: nil)\n    end\n\n    users_custom_data_query = DB.query(<<~SQL, user_ids: users.pluck(:id), term: \"%#{@original_term.downcase}%\")\n      SELECT user_custom_fields.user_id, user_fields.name, user_custom_fields.value FROM user_custom_fields\n      INNER JOIN user_fields ON user_fields.id = REPLACE(user_custom_fields.name, 'user_field_', '')::INTEGER AND user_fields.searchable IS TRUE\n      WHERE user_id IN (:user_ids)\n      AND user_custom_fields.name LIKE 'user_field_%'\n      AND user_custom_fields.value ILIKE :term\n    SQL\n    users_custom_data = users_custom_data_query.reduce({}) do |acc, row|\n      acc[row.user_id] =\n        Array.wrap(acc[row.user_id]) << {\n          name: row.name,\n          value: row.value\n        }\n      acc\n    end\n\n    users.each do |user|\n      user.custom_data = users_custom_data[user.id] || []\n      @results.add(user)\n    end\n  end\n\n  def groups_search\n    groups = Group\n      .visible_groups(@guardian.user, \"name ASC\", include_everyone: false)\n      .where(\"name ILIKE :term OR full_name ILIKE :term\", term: \"%#{@term}%\")\n      .limit(limit)\n\n    groups.each { |group| @results.add(group) }\n  end\n\n  def tags_search\n    return unless SiteSetting.tagging_enabled\n    tags = Tag.includes(:tag_search_data)\n      .where(\"tag_search_data.search_data @@ #{ts_query}\")\n      .references(:tag_search_data)\n      .order(\"name asc\")\n      .limit(limit)\n\n    hidden_tag_names = DiscourseTagging.hidden_tag_names(@guardian)\n\n    tags.each do |tag|\n      @results.add(tag) if !hidden_tag_names.include?(tag.name)\n    end\n  end\n\n  def exclude_topics_search\n    if @term.present?\n      user_search\n      category_search\n      tags_search\n      groups_search\n    end\n  end\n\n  PHRASE_MATCH_REGEXP_PATTERN = '\"([^\"]+)\"'\n\n  def posts_query(limit, type_filter: nil, aggregate_search: false)\n    posts = Post.where(post_type: Topic.visible_post_types(@guardian.user))\n      .joins(:post_search_data, :topic)\n\n    if type_filter != \"private_messages\"\n      posts = posts.joins(\"LEFT JOIN categories ON categories.id = topics.category_id\")\n    end\n\n    is_topic_search = @search_context.present? && @search_context.is_a?(Topic)\n    posts = posts.where(\"topics.visible\") unless is_topic_search\n\n    if type_filter == \"private_messages\" || (is_topic_search && @search_context.private_message?)\n      posts = posts\n        .where(\n          \"topics.archetype = ? AND post_search_data.private_message\",\n          Archetype.private_message\n        )\n\n      unless @guardian.is_admin?\n        posts = posts.private_posts_for_user(@guardian.user)\n      end\n    elsif type_filter == \"all_topics\"\n      private_posts = posts\n        .where(\n          \"topics.archetype = ? AND post_search_data.private_message\",\n          Archetype.private_message\n          )\n        .private_posts_for_user(@guardian.user)\n\n      posts = posts\n        .where(\n          \"topics.archetype <> ? AND NOT post_search_data.private_message\",\n          Archetype.private_message\n        )\n        .or(private_posts)\n    else\n      posts = posts.where(\n        \"topics.archetype <> ? AND NOT post_search_data.private_message\",\n        Archetype.private_message\n      )\n    end\n\n    if @term.present?\n      if is_topic_search\n\n        term_without_quote = @term\n        if @term =~ /\"(.+)\"/\n          term_without_quote = $1\n        end\n\n        if @term =~ /'(.+)'/\n          term_without_quote = $1\n        end\n\n        posts = posts.joins('JOIN users u ON u.id = posts.user_id')\n        posts = posts.where(\"posts.raw  || ' ' || u.username || ' ' || COALESCE(u.name, '') ilike ?\", \"%#{term_without_quote}%\")\n      else\n        # A is for title\n        # B is for category\n        # C is for tags\n        # D is for cooked\n        weights = @in_title ? 'A' : (SiteSetting.tagging_enabled ? 'ABCD' : 'ABD')\n        posts = posts.where(post_number: 1) if @in_title\n        posts = posts.where(\"post_search_data.search_data @@ #{ts_query(weight_filter: weights)}\")\n        exact_terms = @term.scan(Regexp.new(PHRASE_MATCH_REGEXP_PATTERN)).flatten\n\n        exact_terms.each do |exact|\n          posts = posts.where(\"posts.raw ilike :exact OR topics.title ilike :exact\", exact: \"%#{exact}%\")\n        end\n      end\n    end\n\n    @filters.each do |block, match|\n      if block.arity == 1\n        posts = instance_exec(posts, &block) || posts\n      else\n        posts = instance_exec(posts, match, &block) || posts\n      end\n    end if @filters\n\n    # If we have a search context, prioritize those posts first\n    posts =\n      if @search_context.present?\n        if @search_context.is_a?(User)\n          if type_filter == \"private_messages\"\n            if @guardian.is_admin? && !@search_all_pms\n              posts.private_posts_for_user(@search_context)\n            else\n              posts\n            end\n          else\n            posts.where(\"posts.user_id = #{@search_context.id}\")\n          end\n        elsif @search_context.is_a?(Category)\n          category_ids = Category\n            .where(parent_category_id: @search_context.id)\n            .pluck(:id)\n            .push(@search_context.id)\n\n          posts.where(\"topics.category_id in (?)\", category_ids)\n        elsif is_topic_search\n          posts.where(\"topics.id = #{@search_context.id}\")\n            .order(\"posts.post_number #{@order == :latest ? \"DESC\" : \"\"}\")\n        elsif @search_context.is_a?(Tag)\n          posts = posts\n            .joins(\"LEFT JOIN topic_tags ON topic_tags.topic_id = topics.id\")\n            .joins(\"LEFT JOIN tags ON tags.id = topic_tags.tag_id\")\n          posts.where(\"tags.id = #{@search_context.id}\")\n        end\n      else\n        posts = categories_ignored(posts) unless @category_filter_matched\n        posts\n      end\n\n    if @order == :latest\n      if aggregate_search\n        posts = posts.order(\"MAX(posts.created_at) DESC\")\n      else\n        posts = posts.reorder(\"posts.created_at DESC\")\n      end\n    elsif @order == :latest_topic\n      if aggregate_search\n        posts = posts.order(\"MAX(topics.created_at) DESC\")\n      else\n        posts = posts.order(\"topics.created_at DESC\")\n      end\n    elsif @order == :views\n      if aggregate_search\n        posts = posts.order(\"MAX(topics.views) DESC\")\n      else\n        posts = posts.order(\"topics.views DESC\")\n      end\n    elsif @order == :likes\n      if aggregate_search\n        posts = posts.order(\"MAX(posts.like_count) DESC\")\n      else\n        posts = posts.order(\"posts.like_count DESC\")\n      end\n    elsif !is_topic_search\n      rank = <<~SQL\n      TS_RANK_CD(\n        post_search_data.search_data,\n        #{@term.blank? ? '' : ts_query(weight_filter: weights)},\n        #{SiteSetting.search_ranking_normalization}|32\n      )\n      SQL\n\n      if type_filter != \"private_messages\"\n        category_search_priority = <<~SQL\n        (\n          CASE categories.search_priority\n          WHEN #{Searchable::PRIORITIES[:very_high]}\n          THEN 3\n          WHEN #{Searchable::PRIORITIES[:very_low]}\n          THEN 1\n          ELSE 2\n          END\n        )\n        SQL\n\n        category_priority_weights = <<~SQL\n        (\n          CASE categories.search_priority\n          WHEN #{Searchable::PRIORITIES[:low]}\n          THEN #{SiteSetting.category_search_priority_low_weight}\n          WHEN #{Searchable::PRIORITIES[:high]}\n          THEN #{SiteSetting.category_search_priority_high_weight}\n          ELSE\n            CASE WHEN topics.closed\n            THEN 0.9\n            ELSE 1\n            END\n          END\n        )\n        SQL\n\n        data_ranking =\n          if @term.blank?\n            \"(#{category_priority_weights})\"\n          else\n            \"(#{rank} * #{category_priority_weights})\"\n          end\n\n        posts =\n          if aggregate_search\n            posts.order(\"MAX(#{category_search_priority}) DESC\", \"MAX(#{data_ranking}) DESC\")\n          else\n            posts.order(\"#{category_search_priority} DESC\", \"#{data_ranking} DESC\")\n          end\n      end\n\n      posts = posts.order(\"topics.bumped_at DESC\")\n    end\n\n    if type_filter != \"private_messages\"\n      posts =\n        if secure_category_ids.present?\n          posts.where(\"(categories.id IS NULL) OR (NOT categories.read_restricted) OR (categories.id IN (?))\", secure_category_ids).references(:categories)\n        else\n          posts.where(\"(categories.id IS NULL) OR (NOT categories.read_restricted)\").references(:categories)\n        end\n    end\n\n    if @order\n      advanced_order = Search.advanced_orders&.fetch(@order, nil)\n      posts = advanced_order.call(posts) if advanced_order\n    end\n\n    posts = posts.offset(offset)\n    posts.limit(limit)\n  end\n\n  def categories_ignored(posts)\n    posts.where(<<~SQL, Searchable::PRIORITIES[:ignore])\n    (categories.search_priority IS NULL OR categories.search_priority IS NOT NULL AND categories.search_priority <> ?)\n    SQL\n  end\n\n  def self.default_ts_config\n    \"'#{Search.ts_config}'\"\n  end\n\n  def default_ts_config\n    self.class.default_ts_config\n  end\n\n  def self.ts_query(term: , ts_config:  nil, joiner: nil, weight_filter: nil)\n    to_tsquery(\n      ts_config: ts_config,\n      term: set_tsquery_weight_filter(term, weight_filter),\n      joiner: joiner\n    )\n  end\n\n  def self.to_tsquery(ts_config: nil, term:, joiner: nil)\n    ts_config = ActiveRecord::Base.connection.quote(ts_config) if ts_config\n    tsquery = \"TO_TSQUERY(#{ts_config || default_ts_config}, '#{self.escape_string(term)}')\"\n    tsquery = \"REPLACE(#{tsquery}::text, '&', '#{self.escape_string(joiner)}')::tsquery\" if joiner\n    tsquery\n  end\n\n  def self.set_tsquery_weight_filter(term, weight_filter)\n    \"'#{self.escape_string(term)}':*#{weight_filter}\"\n  end\n\n  def self.escape_string(term)\n    PG::Connection.escape_string(term).gsub('\\\\', '\\\\\\\\\\\\')\n  end\n\n  def ts_query(ts_config = nil, weight_filter: nil)\n    @ts_query_cache ||= {}\n    @ts_query_cache[\"#{ts_config || default_ts_config} #{@term} #{weight_filter}\"] ||=\n      Search.ts_query(term: @term, ts_config: ts_config, weight_filter: weight_filter)\n  end\n\n  def wrap_rows(query)\n    \"SELECT *, row_number() over() row_number FROM (#{query.to_sql}) xxx\"\n  end\n\n  def aggregate_post_sql(opts)\n    default_opts = {\n      type_filter: opts[:type_filter]\n    }\n\n    min_id =\n      if SiteSetting.search_recent_regular_posts_offset_post_id > 0\n        if %w{all_topics private_message}.include?(opts[:type_filter])\n          0\n        else\n          SiteSetting.search_recent_regular_posts_offset_post_id\n        end\n      else\n        # This is kept around for backwards compatibility.\n        # TODO: Drop this code path after Discourse 2.7 has been released.\n        Search.min_post_id\n      end\n\n    min_or_max = @order == :latest ? \"max\" : \"min\"\n\n    query =\n      if @order == :likes\n        # likes are a pain to aggregate so skip\n        posts_query(limit, type_filter: opts[:type_filter])\n          .select('topics.id', \"posts.post_number\")\n      else\n        posts_query(limit, aggregate_search: true, type_filter: opts[:type_filter])\n          .select('topics.id', \"#{min_or_max}(posts.post_number) post_number\")\n          .group('topics.id')\n      end\n\n    if min_id > 0\n      low_set = query.dup.where(\"post_search_data.post_id < #{min_id}\")\n      high_set = query.where(\"post_search_data.post_id >= #{min_id}\")\n\n      return { default: wrap_rows(high_set), remaining: wrap_rows(low_set) }\n    end\n\n    # double wrapping so we get correct row numbers\n    { default: wrap_rows(query) }\n  end\n\n  def aggregate_posts(post_sql)\n    return [] unless post_sql\n\n    posts_scope(posts_eager_loads(Post))\n      .joins(\"JOIN (#{post_sql}) x ON x.id = posts.topic_id AND x.post_number = posts.post_number\")\n      .order('row_number')\n  end\n\n  def aggregate_search(opts = {})\n    post_sql = aggregate_post_sql(opts)\n\n    added = 0\n\n    aggregate_posts(post_sql[:default]).each do |p|\n      @results.add(p)\n      added += 1\n    end\n\n    if added < limit\n      aggregate_posts(post_sql[:remaining]).each { |p| @results.add(p) }\n    end\n  end\n\n  def private_messages_search\n    raise Discourse::InvalidAccess.new(\"anonymous can not search PMs\") unless @guardian.user\n\n    aggregate_search(type_filter: \"private_messages\")\n  end\n\n  def all_topics_search\n    aggregate_search(type_filter: \"all_topics\")\n  end\n\n  def topic_search\n    if @search_context.is_a?(Topic)\n      posts = posts_scope(posts_eager_loads(posts_query(limit)))\n        .where('posts.topic_id = ?', @search_context.id)\n\n      posts.each do |post|\n        @results.add(post)\n      end\n    else\n      aggregate_search\n    end\n  end\n\n  def posts_eager_loads(query)\n    query = query.includes(:user, :post_search_data)\n    topic_eager_loads = [:category]\n\n    if SiteSetting.tagging_enabled\n      topic_eager_loads << :tags\n    end\n\n    Search.custom_topic_eager_loads.each do |custom_loads|\n      topic_eager_loads.concat(custom_loads.is_a?(Array) ? custom_loads : custom_loads.call(search_pms: @search_pms).to_a)\n    end\n\n    query.includes(topic: topic_eager_loads)\n  end\n\n  # Limited for performance reasons since `TS_HEADLINE` is slow when the text\n  # document is too long.\n  MAX_LENGTH_FOR_HEADLINE = 2500\n\n  def posts_scope(default_scope = Post.all)\n    if SiteSetting.use_pg_headlines_for_excerpt\n      search_term = @term.present? ? Search.escape_string(@term) : nil\n      ts_config = default_ts_config\n\n      default_scope\n        .joins(\"INNER JOIN post_search_data pd ON pd.post_id = posts.id\")\n        .joins(\"INNER JOIN topics t1 ON t1.id = posts.topic_id\")\n        .select(\n          \"TS_HEADLINE(\n            #{ts_config},\n            t1.fancy_title,\n            PLAINTO_TSQUERY(#{ts_config}, '#{search_term}'),\n            'StartSel=''<span class=\\\"#{HIGHLIGHT_CSS_CLASS}\\\">'', StopSel=''</span>'', HighlightAll=true'\n          ) AS topic_title_headline\",\n          \"TS_HEADLINE(\n            #{ts_config},\n            LEFT(\n              TS_HEADLINE(\n                #{ts_config},\n                LEFT(pd.raw_data, #{MAX_LENGTH_FOR_HEADLINE}),\n                PLAINTO_TSQUERY(#{ts_config}, '#{search_term}'),\n                'ShortWord=0, MaxFragments=1, MinWords=50, MaxWords=51, StartSel='''', StopSel='''''\n              ),\n              #{Search::GroupedSearchResults::BLURB_LENGTH}\n            ),\n            PLAINTO_TSQUERY(#{ts_config}, '#{search_term}'),\n            'HighlightAll=true, StartSel=''<span class=\\\"#{HIGHLIGHT_CSS_CLASS}\\\">'', StopSel=''</span>'''\n          ) AS headline\",\n          \"LEFT(pd.raw_data, 50) AS leading_raw_data\",\n          \"RIGHT(pd.raw_data, 50) AS trailing_raw_data\",\n          default_scope.arel.projections\n        )\n    else\n      default_scope\n    end\n  end\n\n  def log_query?(readonly_mode)\n    SiteSetting.log_search_queries? &&\n    @opts[:search_type].present? &&\n    !readonly_mode &&\n    @opts[:type_filter] != \"exclude_topics\"\n  end\nend\n", "# encoding: utf-8\n# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe Search do\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:topic) { Fabricate(:topic) }\n\n  before do\n    SearchIndexer.enable\n    Jobs.run_immediately!\n  end\n\n  context 'post indexing' do\n    fab!(:category) { Fabricate(:category_with_definition, name: 'america') }\n    fab!(:topic) { Fabricate(:topic, title: 'sam saffron test topic', category: category) }\n    let!(:post) { Fabricate(:post, topic: topic, raw: 'this <b>fun test</b> <img src=\"bla\" title=\"my image\">') }\n    let!(:post2) { Fabricate(:post, topic: topic) }\n\n    it \"should index correctly\" do\n      search_data = post.post_search_data.search_data\n\n      expect(search_data).to match(/fun/)\n      expect(search_data).to match(/sam/)\n      expect(search_data).to match(/america/)\n\n      expect do\n        topic.update!(title: \"harpi is the new title\")\n      end.to change { post2.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n\n      expect(post.post_search_data.reload.search_data).to match(/harpi/)\n    end\n\n    it 'should update posts index when topic category changes' do\n      expect do\n        topic.update!(category: Fabricate(:category))\n      end.to change { post.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n        .and change { post2.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n    end\n\n    it 'should update posts index when topic tags changes' do\n      SiteSetting.tagging_enabled = true\n      tag = Fabricate(:tag)\n\n      expect do\n        DiscourseTagging.tag_topic_by_names(topic, Guardian.new(admin), [tag.name])\n        topic.save!\n      end.to change { post.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n        .and change { post2.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n\n      expect(topic.tags).to eq([tag])\n    end\n  end\n\n  context 'user indexing' do\n    before do\n      @user = Fabricate(:user, username: 'fred', name: 'bob jones')\n      @indexed = @user.user_search_data.search_data\n    end\n\n    it \"should pick up on data\" do\n      expect(@indexed).to match(/fred/)\n      expect(@indexed).to match(/jone/)\n    end\n  end\n\n  context 'category indexing' do\n    let!(:category) { Fabricate(:category_with_definition, name: 'america') }\n    let!(:topic) { Fabricate(:topic, category: category) }\n    let!(:post) { Fabricate(:post, topic: topic) }\n    let!(:post2) { Fabricate(:post, topic: topic) }\n    let!(:post3) { Fabricate(:post) }\n\n    it \"should index correctly\" do\n      expect(category.category_search_data.search_data).to match(/america/)\n    end\n\n    it 'should update posts index when category name changes' do\n      expect do\n        category.update!(name: 'some new name')\n      end.to change { post.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n        .and change { post2.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n\n      expect(post3.post_search_data.version).to eq(SearchIndexer::POST_INDEX_VERSION)\n    end\n  end\n\n  it 'strips zero-width characters from search terms' do\n    term = \"\\u0063\\u0061\\u0070\\u0079\\u200b\\u200c\\u200d\\ufeff\\u0062\\u0061\\u0072\\u0061\".encode(\"UTF-8\")\n\n    expect(term == 'capybara').to eq(false)\n\n    search = Search.new(term)\n    expect(search.valid?).to eq(true)\n    expect(search.term).to eq('capybara')\n    expect(search.clean_term).to eq('capybara')\n  end\n\n  it 'replaces curly quotes to regular quotes in search terms' do\n    term = '\u201cdiscourse\u201d'\n\n    expect(term == '\"discourse\"').to eq(false)\n\n    search = Search.new(term)\n    expect(search.valid?).to eq(true)\n    expect(search.term).to eq('\"discourse\"')\n    expect(search.clean_term).to eq('\"discourse\"')\n  end\n\n  it 'does not search when the search term is too small' do\n    search = Search.new('evil', min_search_term_length: 5)\n    search.execute\n    expect(search.valid?).to eq(false)\n    expect(search.term).to eq('')\n  end\n\n  it 'needs at least one term that hits the length' do\n    search = Search.new('a b c d', min_search_term_length: 5)\n    search.execute\n    expect(search.valid?).to eq(false)\n    expect(search.term).to eq('')\n  end\n\n  it 'searches for quoted short terms' do\n    search = Search.new('\"a b c d\"', min_search_term_length: 5)\n    search.execute\n    expect(search.valid?).to eq(true)\n    expect(search.term).to eq('\"a b c d\"')\n  end\n\n  it 'searches for short terms if one hits the length' do\n    search = Search.new('a b c okaylength', min_search_term_length: 5)\n    search.execute\n    expect(search.valid?).to eq(true)\n    expect(search.term).to eq('a b c okaylength')\n  end\n\n  context 'query sanitization' do\n    let!(:post) { Fabricate(:post, raw: 'hello world') }\n\n    it 'escapes backslash' do\n      expect(Search.execute('hello\\\\').posts).to contain_exactly(post)\n    end\n\n    it 'escapes single quote' do\n      expect(Search.execute(\"hello'\").posts).to contain_exactly(post)\n    end\n\n    it 'escapes non-alphanumeric characters' do\n      expect(Search.execute('hello :!$);}]>@\\#\\\"\\'').posts).to contain_exactly(post)\n    end\n  end\n\n  it 'works when given two terms with spaces' do\n    expect { Search.execute('evil trout') }.not_to raise_error\n  end\n\n  context 'users' do\n    let!(:user) { Fabricate(:user) }\n    let(:result) { Search.execute('bruce', type_filter: 'user') }\n\n    it 'returns a result' do\n      expect(result.users.length).to eq(1)\n      expect(result.users[0].id).to eq(user.id)\n    end\n\n    context 'hiding user profiles' do\n      before { SiteSetting.hide_user_profiles_from_public = true }\n\n      it 'returns no result for anon' do\n        expect(result.users.length).to eq(0)\n      end\n\n      it 'returns a result for logged in users' do\n        result = Search.execute('bruce', type_filter: 'user', guardian: Guardian.new(user))\n        expect(result.users.length).to eq(1)\n      end\n\n    end\n\n  end\n\n  context 'inactive users' do\n    let!(:inactive_user) { Fabricate(:inactive_user, active: false) }\n    let(:result) { Search.execute('bruce') }\n\n    it 'does not return a result' do\n      expect(result.users.length).to eq(0)\n    end\n  end\n\n  context 'staged users' do\n    let(:staged) { Fabricate(:staged) }\n    let(:result) { Search.execute(staged.username) }\n\n    it 'does not return a result' do\n      expect(result.users.length).to eq(0)\n    end\n  end\n\n  context 'private messages' do\n    let!(:post) { Fabricate(:private_message_post) }\n\n    let(:topic) { post.topic }\n\n    let!(:reply) do\n      Fabricate(:private_message_post,\n        topic: post.topic,\n        raw: 'hello from mars, we just landed',\n        user: post.user\n      )\n    end\n\n    let!(:post2) do\n      Fabricate(:private_message_post,\n        raw: 'another secret pm from mars, testing'\n      )\n    end\n\n    it 'searches correctly as an admin' do\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        guardian: Guardian.new(admin)\n      )\n\n      expect(results.posts).to eq([])\n    end\n\n    it \"searches correctly as an admin given another user's context\" do\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        search_context: reply.user,\n        guardian: Guardian.new(admin)\n      )\n\n      expect(results.posts).to contain_exactly(reply)\n    end\n\n    it \"raises the right error when a normal user searches for another user's context\" do\n      expect do\n        Search.execute(\n          'mars',\n          search_context: reply.user,\n          type_filter: 'private_messages',\n          guardian: Guardian.new(Fabricate(:user))\n        )\n      end.to raise_error(Discourse::InvalidAccess)\n    end\n\n    it 'searches correctly as a user' do\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        guardian: Guardian.new(reply.user)\n      )\n\n      expect(results.posts).to contain_exactly(reply)\n    end\n\n    it 'searches correctly for a user with no private messages' do\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        guardian: Guardian.new(Fabricate(:user))\n       )\n\n      expect(results.posts).to eq([])\n    end\n\n    it 'searches correctly' do\n      expect do\n        Search.execute('mars', type_filter: 'private_messages')\n      end.to raise_error(Discourse::InvalidAccess)\n\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        guardian: Guardian.new(reply.user)\n      )\n\n      expect(results.posts).to contain_exactly(reply)\n\n      results = Search.execute(\n        'mars',\n        search_context: topic,\n        guardian: Guardian.new(reply.user)\n      )\n\n      expect(results.posts).to contain_exactly(reply)\n\n      # can search group PMs as well as non admin\n      #\n      user = Fabricate(:user)\n      group = Fabricate.build(:group)\n      group.add(user)\n      group.save!\n\n      TopicAllowedGroup.create!(group_id: group.id, topic_id: topic.id)\n\n      [\"mars in:personal\", \"mars IN:PERSONAL\"].each do |query|\n        results = Search.execute(query, guardian: Guardian.new(user))\n        expect(results.posts).to contain_exactly(reply)\n      end\n    end\n\n    context 'personal_messages filter' do\n      it 'does not allow a normal user to search for personal messages of another user' do\n        expect do\n          Search.execute(\n            \"mars personal_messages:#{post.user.username}\",\n            guardian: Guardian.new(Fabricate(:user))\n          )\n        end.to raise_error(Discourse::InvalidAccess)\n      end\n\n      it 'searches correctly for the PM of the given user' do\n        results = Search.execute(\n          \"mars personal_messages:#{post.user.username}\",\n          guardian: Guardian.new(admin)\n        )\n\n        expect(results.posts).to contain_exactly(reply)\n      end\n\n      it 'returns the right results if username is invalid' do\n        results = Search.execute(\n          \"mars personal_messages:random_username\",\n          guardian: Guardian.new(admin)\n        )\n\n        expect(results.posts).to eq([])\n      end\n    end\n\n    context 'all-pms flag' do\n      it 'returns matching PMs if the user is an admin' do\n        results = Search.execute('mars in:all-pms', guardian: Guardian.new(admin))\n\n        expect(results.posts).to include(reply, post2)\n      end\n\n      it 'returns nothing if the user is not an admin' do\n        results = Search.execute('mars in:all-pms', guardian: Guardian.new(Fabricate(:user)))\n\n        expect(results.posts).to be_empty\n      end\n\n      it 'returns nothing if the user is a moderator' do\n        results = Search.execute('mars in:all-pms', guardian: Guardian.new(Fabricate(:moderator)))\n\n        expect(results.posts).to be_empty\n      end\n    end\n\n    context 'personal-direct flag' do\n      let(:current) { Fabricate(:user, admin: true, username: \"current_user\") }\n      let(:participant) { Fabricate(:user, username: \"participant_1\") }\n      let(:participant_2) { Fabricate(:user, username: \"participant_2\") }\n\n      let(:group) do\n        group = Fabricate(:group, has_messages: true)\n        group.add(current)\n        group.add(participant)\n        group\n      end\n\n      def create_pm(users:, group: nil)\n        pm = Fabricate(:private_message_post_one_user, user: users.first).topic\n        users[1..-1].each do |u|\n          pm.invite(users.first, u.username)\n          Fabricate(:post, user: u, topic: pm)\n        end\n        if group\n          pm.invite_group(users.first, group)\n          group.users.each do |u|\n            Fabricate(:post, user: u, topic: pm)\n          end\n        end\n        pm.reload\n      end\n\n      it 'can find all direct PMs of the current user' do\n        pm = create_pm(users: [current, participant])\n        _pm_2 = create_pm(users: [participant_2, participant])\n        pm_3 = create_pm(users: [participant, current])\n        pm_4 = create_pm(users: [participant_2, current])\n\n        [\"in:personal-direct\", \"In:PeRsOnAl-DiReCt\"].each do |query|\n          results = Search.execute(query, guardian: Guardian.new(current))\n          expect(results.posts.size).to eq(3)\n          expect(results.posts.map(&:topic_id)).to eq([pm_4.id, pm_3.id, pm.id])\n        end\n      end\n\n      it 'can filter direct PMs by @username' do\n        pm = create_pm(users: [current, participant])\n        pm_2 = create_pm(users: [participant, current])\n        pm_3 = create_pm(users: [participant_2, current])\n        [\n          \"@#{participant.username} in:personal-direct\",\n          \"@#{participant.username} iN:pErSoNaL-dIrEcT\",\n        ].each do |query|\n          results = Search.execute(query, guardian: Guardian.new(current))\n          expect(results.posts.size).to eq(2)\n          expect(results.posts.map(&:topic_id)).to contain_exactly(pm_2.id, pm.id)\n          expect(results.posts.map(&:user_id).uniq).to eq([participant.id])\n        end\n\n        results = Search.execute(\"@me in:personal-direct\", guardian: Guardian.new(current))\n        expect(results.posts.size).to eq(3)\n        expect(results.posts.map(&:topic_id)).to contain_exactly(pm_3.id, pm_2.id, pm.id)\n        expect(results.posts.map(&:user_id).uniq).to eq([current.id])\n      end\n\n      it \"doesn't include PMs that have more than 2 participants\" do\n        _pm = create_pm(users: [current, participant, participant_2])\n        results = Search.execute(\"@#{participant.username} in:personal-direct\", guardian: Guardian.new(current))\n        expect(results.posts.size).to eq(0)\n      end\n\n      it \"doesn't include PMs that have groups\" do\n        _pm = create_pm(users: [current, participant], group: group)\n        results = Search.execute(\"@#{participant.username} in:personal-direct\", guardian: Guardian.new(current))\n        expect(results.posts.size).to eq(0)\n      end\n    end\n\n    context 'all topics' do\n\n      let!(:u1) { Fabricate(:user, username: 'fred', name: 'bob jones', email: 'foo+1@bar.baz') }\n      let!(:u2) { Fabricate(:user, username: 'bob', name: 'fred jones', email: 'foo+2@bar.baz') }\n      let!(:u3) { Fabricate(:user, username: 'jones', name: 'bob fred', email: 'foo+3@bar.baz') }\n      let!(:u4) { Fabricate(:user, username: 'alice', name: 'bob fred', email: 'foo+4@bar.baz', admin: true) }\n\n      let!(:public_topic) { Fabricate(:topic, user: u1) }\n      let!(:public_post1) { Fabricate(:post, topic: public_topic, raw: \"what do you want for breakfast?  ham and eggs?\", user: u1) }\n      let!(:public_post2) { Fabricate(:post, topic: public_topic, raw: \"ham and spam\", user: u2) }\n\n      let!(:private_topic) { Fabricate(:topic, user: u1, category_id: nil, archetype: 'private_message') }\n      let!(:private_post1) { Fabricate(:post, topic: private_topic, raw: \"what do you want for lunch?  ham and cheese?\", user: u1) }\n      let!(:private_post2) { Fabricate(:post, topic: private_topic, raw: \"cheese and spam\", user: u2) }\n\n      it 'finds private messages' do\n        TopicAllowedUser.create!(user_id: u1.id, topic_id: private_topic.id)\n        TopicAllowedUser.create!(user_id: u2.id, topic_id: private_topic.id)\n\n        # case insensitive only\n        results = Search.execute('iN:aLL cheese', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(private_post1)\n\n        # private only\n        results = Search.execute('in:all cheese', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(private_post1)\n\n        # public only\n        results = Search.execute('in:all eggs', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(public_post1)\n\n        # both\n        results = Search.execute('in:all spam', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(public_post2, private_post2)\n\n        # for anon\n        results = Search.execute('in:all spam', guardian: Guardian.new)\n        expect(results.posts).to contain_exactly(public_post2)\n\n        # nonparticipatory user\n        results = Search.execute('in:all cheese', guardian: Guardian.new(u3))\n        expect(results.posts.empty?).to eq(true)\n\n        results = Search.execute('in:all eggs', guardian: Guardian.new(u3))\n        expect(results.posts).to contain_exactly(public_post1)\n\n        results = Search.execute('in:all spam', guardian: Guardian.new(u3))\n        expect(results.posts).to contain_exactly(public_post2)\n\n        # Admin doesn't see private topic\n        results = Search.execute('in:all spam', guardian: Guardian.new(u4))\n        expect(results.posts).to contain_exactly(public_post2)\n\n        # same keyword for different users\n        results = Search.execute('in:all ham', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(public_post1, private_post1)\n\n        results = Search.execute('in:all ham', guardian: Guardian.new(u2))\n        expect(results.posts).to contain_exactly(public_post1, private_post1)\n\n        results = Search.execute('in:all ham', guardian: Guardian.new(u3))\n        expect(results.posts).to contain_exactly(public_post1)\n      end\n    end\n  end\n\n  context 'posts' do\n    fab!(:post) do\n      SearchIndexer.enable\n      Fabricate(:post)\n    end\n\n    let(:topic) { post.topic }\n\n    let!(:reply) do\n      Fabricate(:post_with_long_raw_content,\n        topic: topic,\n        user: topic.user,\n      ).tap { |post| post.update!(raw: \"#{post.raw} elephant\") }\n    end\n\n    let(:expected_blurb) do\n      \"#{Search::GroupedSearchResults::OMISSION}hundred characters to satisfy any test conditions that require content longer than the typical test post raw content. It really is some long content, folks. <span class=\\\"#{Search::HIGHLIGHT_CSS_CLASS}\\\">elephant</span>\"\n    end\n\n    it 'returns the post' do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      result = Search.execute('elephant',\n        type_filter: 'topic',\n        include_blurbs: true\n      )\n\n      expect(result.posts.map(&:id)).to contain_exactly(reply.id)\n\n      post = result.posts.first\n\n      expect(result.blurb(post)).to eq(expected_blurb)\n      expect(post.topic_title_headline).to eq(topic.fancy_title)\n    end\n\n    it \"only applies highlighting to the first #{Search::MAX_LENGTH_FOR_HEADLINE} characters\" do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      reply.update!(raw: \"#{'a' * Search::MAX_LENGTH_FOR_HEADLINE} #{reply.raw}\")\n\n      result = Search.execute('elephant')\n\n      expect(result.posts.map(&:id)).to contain_exactly(reply.id)\n\n      post = result.posts.first\n\n      expect(post.headline.include?('elephant')).to eq(false)\n    end\n\n    it \"does not truncate topic title when applying highlights\" do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      topic = reply.topic\n      topic.update!(title: \"#{'very ' * 7}long topic title with our search term in the middle of the title\")\n\n      result = Search.execute('search term')\n\n      expect(result.posts.first.topic_title_headline).to eq(<<~TITLE.chomp)\n      Very very very very very very very long topic title with our <span class=\\\"#{Search::HIGHLIGHT_CSS_CLASS}\\\">search</span> <span class=\\\"#{Search::HIGHLIGHT_CSS_CLASS}\\\">term</span> in the middle of the title\n      TITLE\n    end\n\n    it \"limits the search headline to #{Search::GroupedSearchResults::BLURB_LENGTH} characters\" do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      reply.update!(raw: \"#{'a' * Search::GroupedSearchResults::BLURB_LENGTH} elephant\")\n\n      result = Search.execute('elephant')\n\n      expect(result.posts.map(&:id)).to contain_exactly(reply.id)\n\n      post = result.posts.first\n\n      expect(result.blurb(post)).to eq(\"#{'a' * Search::GroupedSearchResults::BLURB_LENGTH}#{Search::GroupedSearchResults::OMISSION}\")\n    end\n\n    it 'returns the right post and blurb for searches with phrase' do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      result = Search.execute('\"elephant\"',\n        type_filter: 'topic',\n        include_blurbs: true\n      )\n\n      expect(result.posts.map(&:id)).to contain_exactly(reply.id)\n      expect(result.blurb(result.posts.first)).to eq(expected_blurb)\n    end\n\n    it 'applies a small penalty to closed topic when ranking' do\n      post = Fabricate(:post,\n        raw: \"My weekly update\",\n        topic: Fabricate(:topic,\n          title: \"A topic that will be closed\",\n          closed: true\n        )\n      )\n\n      post2 = Fabricate(:post,\n        raw: \"My weekly update\",\n        topic: Fabricate(:topic,\n          title: \"A topic that will be open\"\n        )\n      )\n\n      result = Search.execute('weekly update')\n      expect(result.posts.pluck(:id)).to eq([post2.id, post.id])\n    end\n\n    it 'aggregates searches in a topic by returning the post with the lowest post number' do\n      post = Fabricate(:post, topic: topic, raw: \"this is a play post\")\n      post2 = Fabricate(:post, topic: topic, raw: \"play play playing played play\")\n      post3 = Fabricate(:post, raw: \"this is a play post\")\n\n      5.times do\n        Fabricate(:post, topic: topic, raw: \"play playing played\")\n      end\n\n      results = Search.execute('play')\n\n      expect(results.posts.map(&:id)).to eq([\n        post.id,\n        post3.id\n      ])\n    end\n\n    it \"is able to search with an offset when configured\" do\n      post_1 = Fabricate(:post, raw: \"this is a play post\")\n      SiteSetting.search_recent_regular_posts_offset_post_id = post_1.id + 1\n\n      results = Search.execute('play post')\n\n      expect(results.posts).to eq([post_1])\n\n      post_2 = Fabricate(:post, raw: \"this is another play post\")\n\n      SiteSetting.search_recent_regular_posts_offset_post_id = post_2.id\n\n      results = Search.execute('play post')\n\n      expect(results.posts.map(&:id)).to eq([\n        post_2.id,\n        post_1.id\n      ])\n    end\n\n    it 'allows staff to search for whispers' do\n      post.update!(post_type: Post.types[:whisper], raw: 'this is a tiger')\n\n      results = Search.execute('tiger')\n\n      expect(results.posts).to eq([])\n\n      results = Search.execute('tiger', guardian: Guardian.new(admin))\n\n      expect(results.posts).to eq([post])\n    end\n  end\n\n  context 'topics' do\n    let(:post) { Fabricate(:post) }\n    let(:topic) { post.topic }\n\n    context 'search within topic' do\n\n      def new_post(raw, topic = nil, created_at: nil)\n        topic ||= Fabricate(:topic)\n        Fabricate(:post, topic: topic, topic_id: topic.id, user: topic.user, raw: raw, created_at: created_at)\n      end\n\n      it 'works in Chinese' do\n        SiteSetting.search_tokenize_chinese_japanese_korean = true\n        post = new_post('I am not in English \u4f55\u70b9\u306b\u306a\u308b\u3068\u601d\u3044\u307e\u3059\u304b')\n\n        results = Search.execute('\u4f55\u70b9\u306b\u306a\u308b\u3068\u601d', search_context: post.topic)\n        expect(results.posts.map(&:id)).to eq([post.id])\n      end\n\n      it 'displays multiple results within a topic' do\n        topic2 = Fabricate(:topic)\n\n        new_post('this is the other post I am posting', topic2, created_at: 6.minutes.ago)\n        new_post('this is my fifth post I am posting', topic2, created_at: 5.minutes.ago)\n\n        post1 = new_post('this is the other post I am posting', topic, created_at: 4.minutes.ago)\n        post2 = new_post('this is my first post I am posting', topic, created_at: 3.minutes.ago)\n        post3 = new_post('this is a real long and complicated bla this is my second post I am Posting birds with more stuff bla bla', topic, created_at: 2.minutes.ago)\n        post4 = new_post('this is my fourth post I am posting', topic, created_at: 1.minute.ago)\n\n        # update posts_count\n        topic.reload\n\n        results = Search.execute('posting', search_context: post1.topic)\n        expect(results.posts.map(&:id)).to eq([post1.id, post2.id, post3.id, post4.id])\n\n        results = Search.execute('posting l', search_context: post1.topic)\n        expect(results.posts.map(&:id)).to eq([post4.id, post3.id, post2.id, post1.id])\n\n        # stop words should work\n        results = Search.execute('this', search_context: post1.topic)\n        expect(results.posts.length).to eq(4)\n\n        # phrase search works as expected\n        results = Search.execute('\"fourth post I am posting\"', search_context: post1.topic)\n        expect(results.posts.length).to eq(1)\n      end\n\n      it \"works for unlisted topics\" do\n        topic.update(visible: false)\n        _post = new_post('discourse is awesome', topic)\n        results = Search.execute('discourse', search_context: topic)\n        expect(results.posts.length).to eq(1)\n      end\n    end\n\n    context 'searching the OP' do\n      let!(:post) { Fabricate(:post_with_long_raw_content) }\n      let(:result) { Search.execute('hundred', type_filter: 'topic') }\n\n      it 'returns a result correctly' do\n        expect(result.posts.length).to eq(1)\n        expect(result.posts[0].id).to eq(post.id)\n      end\n    end\n\n    context 'searching for quoted title' do\n      it \"can find quoted title\" do\n        create_post(raw: \"this is the raw body\", title: \"I am a title yeah\")\n        result = Search.execute('\"a title yeah\"')\n\n        expect(result.posts.length).to eq(1)\n      end\n\n    end\n\n    context \"search for a topic by id\" do\n      let(:result) { Search.execute(topic.id, type_filter: 'topic', search_for_id: true, min_search_term_length: 1) }\n\n      it 'returns the topic' do\n        expect(result.posts.length).to eq(1)\n        expect(result.posts.first.id).to eq(post.id)\n      end\n    end\n\n    context \"search for a topic by url\" do\n      it 'returns the topic' do\n        result = Search.execute(topic.relative_url, search_for_id: true, type_filter: 'topic')\n        expect(result.posts.length).to eq(1)\n        expect(result.posts.first.id).to eq(post.id)\n      end\n\n      context 'restrict_to_archetype' do\n        let(:personal_message) { Fabricate(:private_message_topic) }\n        let!(:p1) { Fabricate(:post, topic: personal_message, post_number: 1) }\n\n        it 'restricts result to topics' do\n          result = Search.execute(personal_message.relative_url, search_for_id: true, type_filter: 'topic', restrict_to_archetype: Archetype.default)\n          expect(result.posts.length).to eq(0)\n\n          result = Search.execute(topic.relative_url, search_for_id: true, type_filter: 'topic', restrict_to_archetype: Archetype.default)\n          expect(result.posts.length).to eq(1)\n        end\n\n        it 'restricts result to messages' do\n          result = Search.execute(topic.relative_url, search_for_id: true, type_filter: 'private_messages', guardian: Guardian.new(admin), restrict_to_archetype: Archetype.private_message)\n          expect(result.posts.length).to eq(0)\n\n          result = Search.execute(personal_message.relative_url, search_for_id: true, type_filter: 'private_messages', guardian: Guardian.new(admin), restrict_to_archetype: Archetype.private_message)\n          expect(result.posts.length).to eq(1)\n        end\n      end\n    end\n\n    context 'security' do\n\n      def result(current_user)\n        Search.execute('hello', guardian: Guardian.new(current_user))\n      end\n\n      it 'secures results correctly' do\n        category = Fabricate(:category_with_definition)\n\n        topic.category_id = category.id\n        topic.save\n\n        category.set_permissions(staff: :full)\n        category.save\n\n        expect(result(nil).posts).not_to be_present\n        expect(result(Fabricate(:user)).posts).not_to be_present\n        expect(result(admin).posts).to be_present\n\n      end\n    end\n\n  end\n\n  context 'cyrillic topic' do\n    let!(:cyrillic_topic) {\n      Fabricate(:topic) do\n        user\n        title { sequence(:title) { |i| \"\u0422\u0435\u0441\u0442\u043e\u0432\u0430\u044f \u0437\u0430\u043f\u0438\u0441\u044c #{i}\" } }\n      end\n    }\n\n    let!(:post) { Fabricate(:post, topic: cyrillic_topic, user: cyrillic_topic.user) }\n    let(:result) { Search.execute('\u0437\u0430\u043f\u0438\u0441\u044c') }\n\n    it 'finds something when given cyrillic query' do\n      expect(result.posts).to contain_exactly(post)\n    end\n  end\n\n  it 'does not tokenize search term' do\n    Fabricate(:post, raw: 'thing is canned should still be found!')\n    expect(Search.execute('canned').posts).to be_present\n  end\n\n  context 'categories' do\n    let(:category) { Fabricate(:category_with_definition, name: \"monkey Category 2\") }\n    let(:topic) { Fabricate(:topic, category: category) }\n    let!(:post) { Fabricate(:post, topic: topic, raw: \"snow monkey\") }\n\n    let!(:ignored_category) do\n      Fabricate(:category_with_definition,\n        name: \"monkey Category 1\",\n        slug: \"test\",\n        search_priority: Searchable::PRIORITIES[:ignore]\n      )\n    end\n\n    it \"should return the right categories\" do\n      search = Search.execute(\"monkey\")\n\n      expect(search.categories).to contain_exactly(\n        category, ignored_category\n      )\n\n      expect(search.posts).to eq([category.topic.first_post, post])\n\n      search = Search.execute(\"monkey #test\")\n\n      expect(search.posts).to eq([ignored_category.topic.first_post])\n    end\n\n    describe \"with child categories\" do\n      let!(:child_of_ignored_category) do\n        Fabricate(:category_with_definition,\n          name: \"monkey Category 3\",\n          parent_category: ignored_category\n        )\n      end\n\n      let!(:post2) do\n        Fabricate(:post,\n          topic: Fabricate(:topic, category: child_of_ignored_category),\n          raw: \"snow monkey park\"\n        )\n      end\n\n      it 'returns the right results' do\n        search = Search.execute(\"monkey\")\n\n        expect(search.categories).to contain_exactly(\n          category, ignored_category, child_of_ignored_category\n        )\n\n        expect(search.posts.map(&:id)).to eq([\n          child_of_ignored_category.topic.first_post,\n          category.topic.first_post,\n          post2,\n          post\n        ].map(&:id))\n\n        search = Search.execute(\"snow\")\n        expect(search.posts.map(&:id)).to eq([post2.id, post.id])\n\n        category.set_permissions({})\n        category.save!\n        search = Search.execute(\"monkey\")\n\n        expect(search.categories).to contain_exactly(\n          ignored_category, child_of_ignored_category\n        )\n\n        expect(search.posts.map(&:id)).to eq([\n          child_of_ignored_category.topic.first_post,\n          post2\n        ].map(&:id))\n      end\n    end\n\n    describe 'categories with different priorities' do\n      let(:category2) { Fabricate(:category_with_definition) }\n\n      it \"should return posts in the right order\" do\n        raw = \"The pure genuine evian\"\n        post = Fabricate(:post, topic: category.topic, raw: raw)\n        post2 = Fabricate(:post, topic: category2.topic, raw: raw)\n        post2.topic.update!(bumped_at: 10.seconds.from_now)\n\n        search = Search.execute(raw)\n\n        expect(search.posts.map(&:id)).to eq([post2.id, post.id])\n\n        category.update!(search_priority: Searchable::PRIORITIES[:high])\n\n        search = Search.execute(raw)\n\n        expect(search.posts.map(&:id)).to eq([post.id, post2.id])\n      end\n    end\n\n  end\n\n  context 'groups' do\n    def search(user = Fabricate(:user))\n      Search.execute(group.name, guardian: Guardian.new(user))\n    end\n\n    let!(:group) { Group[:trust_level_0] }\n\n    it 'shows group' do\n      expect(search.groups.map(&:name)).to eq([group.name])\n    end\n\n    context 'group visibility' do\n      let!(:group) { Fabricate(:group) }\n\n      before do\n        group.update!(visibility_level: 3)\n      end\n\n      context 'staff logged in' do\n        it 'shows group' do\n          expect(search(admin).groups.map(&:name)).to eq([group.name])\n        end\n      end\n\n      context 'non staff logged in' do\n        it 'shows doesn\u2019t show group' do\n          expect(search.groups.map(&:name)).to be_empty\n        end\n      end\n    end\n  end\n\n  context 'tags' do\n    def search\n      Search.execute(tag.name)\n    end\n\n    let!(:tag) { Fabricate(:tag) }\n    let!(:uppercase_tag) { Fabricate(:tag, name: \"HeLlO\") }\n    let(:tag_group) { Fabricate(:tag_group) }\n    let(:category) { Fabricate(:category_with_definition) }\n\n    context 'post searching' do\n      before do\n        SiteSetting.tagging_enabled = true\n        DiscourseTagging.tag_topic_by_names(post.topic, Guardian.new(Fabricate.build(:admin)), [tag.name, uppercase_tag.name])\n        post.topic.save\n      end\n\n      let(:post) { Fabricate(:post, raw: 'I am special post') }\n\n      it 'can find posts with tags' do\n        # we got to make this index (it is deferred)\n        Jobs::ReindexSearch.new.rebuild_posts\n\n        result = Search.execute(tag.name)\n        expect(result.posts.length).to eq(1)\n\n        result = Search.execute(\"hElLo\")\n        expect(result.posts.length).to eq(1)\n\n        SiteSetting.tagging_enabled = false\n\n        result = Search.execute(tag.name)\n        expect(result.posts.length).to eq(0)\n      end\n\n      it 'can find posts with tag synonyms' do\n        synonym = Fabricate(:tag, name: 'synonym', target_tag: tag)\n        Jobs::ReindexSearch.new.rebuild_posts\n        result = Search.execute(synonym.name)\n        expect(result.posts.length).to eq(1)\n      end\n    end\n\n    context 'tagging is disabled' do\n      before { SiteSetting.tagging_enabled = false }\n\n      it 'does not include tags' do\n        expect(search.tags).to_not be_present\n      end\n    end\n\n    context 'tagging is enabled' do\n      before { SiteSetting.tagging_enabled = true }\n\n      it 'returns the tag in the result' do\n        expect(search.tags).to eq([tag])\n      end\n\n      it 'shows staff tags' do\n        create_staff_only_tags([\"#{tag.name}9\"])\n\n        expect(Search.execute(tag.name, guardian: Guardian.new(admin)).tags.map(&:name)).to eq([tag.name, \"#{tag.name}9\"])\n        expect(search.tags.map(&:name)).to eq([tag.name, \"#{tag.name}9\"])\n      end\n\n      it 'includes category-restricted tags' do\n        category_tag = Fabricate(:tag, name: \"#{tag.name}9\")\n        tag_group.tags = [category_tag]\n        category.set_permissions(admins: :full)\n        category.allowed_tag_groups = [tag_group.name]\n        category.save!\n\n        expect(Search.execute(tag.name, guardian: Guardian.new(admin)).tags).to eq([tag, category_tag])\n        expect(search.tags).to eq([tag, category_tag])\n      end\n    end\n  end\n\n  context 'type_filter' do\n\n    let!(:user) { Fabricate(:user, username: 'amazing', email: 'amazing@amazing.com') }\n    let!(:category) { Fabricate(:category_with_definition, name: 'amazing category', user: user) }\n\n    context 'user filter' do\n      let(:results) { Search.execute('amazing', type_filter: 'user') }\n\n      it \"returns a user result\" do\n        expect(results.categories.length).to eq(0)\n        expect(results.posts.length).to eq(0)\n        expect(results.users.length).to eq(1)\n      end\n\n    end\n\n    context 'category filter' do\n      let(:results) { Search.execute('amazing', type_filter: 'category') }\n\n      it \"returns a category result\" do\n        expect(results.categories.length).to eq(1)\n        expect(results.posts.length).to eq(0)\n        expect(results.users.length).to eq(0)\n      end\n\n    end\n\n  end\n\n  context 'search_context' do\n\n    it 'can find a user when using search context' do\n\n      coding_horror = Fabricate(:coding_horror)\n      post = Fabricate(:post)\n\n      Fabricate(:post, user: coding_horror)\n\n      result = Search.execute('hello', search_context: post.user)\n\n      result.posts.first.topic_id = post.topic_id\n      expect(result.posts.length).to eq(1)\n    end\n\n    it 'can use category as a search context' do\n      category = Fabricate(:category_with_definition,\n        search_priority: Searchable::PRIORITIES[:ignore]\n      )\n\n      topic = Fabricate(:topic, category: category)\n      topic_no_cat = Fabricate(:topic)\n\n      # includes subcategory in search\n      subcategory = Fabricate(:category_with_definition, parent_category_id: category.id)\n      sub_topic = Fabricate(:topic, category: subcategory)\n\n      post = Fabricate(:post, topic: topic, user: topic.user)\n      Fabricate(:post, topic: topic_no_cat, user: topic.user)\n      sub_post = Fabricate(:post, raw: 'I am saying hello from a subcategory', topic: sub_topic, user: topic.user)\n\n      search = Search.execute('hello', search_context: category)\n      expect(search.posts.map(&:id)).to match_array([post.id, sub_post.id])\n      expect(search.posts.length).to eq(2)\n    end\n\n    it 'can use tag as a search context' do\n      tag = Fabricate(:tag, name: 'important-stuff')\n\n      topic_no_tag = Fabricate(:topic)\n      Fabricate(:topic_tag, tag: tag, topic: topic)\n\n      post = Fabricate(:post, topic: topic, user: topic.user, raw: 'This is my hello')\n      Fabricate(:post, topic: topic_no_tag, user: topic.user)\n\n      search = Search.execute('hello', search_context: tag)\n      expect(search.posts.map(&:id)).to contain_exactly(post.id)\n      expect(search.posts.length).to eq(1)\n    end\n\n  end\n\n  describe 'Chinese search' do\n    let(:sentence) { 'Discourse\u4e2d\u56fd\u7684\u57fa\u7840\u8bbe\u65bd\u7f51\u7edc\u6b63\u5728\u7ec4\u88c5' }\n    let(:sentence_t) { 'Discourse\u592a\u5e73\u5c71\u68ee\u6797\u904a\u6a02\u5340' }\n\n    it 'splits English / Chinese and filter out stop words' do\n      SiteSetting.default_locale = 'zh_CN'\n      data = Search.prepare_data(sentence).split(' ')\n      expect(data).to eq([\"Discourse\", \"\u4e2d\u56fd\", \"\u57fa\u7840\u8bbe\u65bd\", \"\u7f51\u7edc\", \"\u6b63\u5728\", \"\u7ec4\u88c5\"])\n    end\n\n    it 'splits for indexing and filter out stop words' do\n      SiteSetting.default_locale = 'zh_CN'\n      data = Search.prepare_data(sentence, :index).split(' ')\n      expect(data).to eq([\"Discourse\", \"\u4e2d\u56fd\", \"\u57fa\u7840\u8bbe\u65bd\", \"\u7f51\u7edc\", \"\u6b63\u5728\", \"\u7ec4\u88c5\"])\n    end\n\n    it 'splits English / Traditional Chinese and filter out stop words' do\n      SiteSetting.default_locale = 'zh_TW'\n      data = Search.prepare_data(sentence_t).split(' ')\n      expect(data).to eq([\"Discourse\", \"\u592a\u5e73\u5c71\", \"\u68ee\u6797\", \"\u904a\u6a02\u5340\"])\n    end\n\n    it 'finds chinese topic based on title' do\n      skip(\"skipped until pg app installs the db correctly\") if RbConfig::CONFIG[\"arch\"] =~ /darwin/\n\n      SiteSetting.default_locale = 'zh_TW'\n      SiteSetting.min_search_term_length = 1\n      topic = Fabricate(:topic, title: 'My Title Discourse\u793e\u5340\u6307\u5357')\n      post = Fabricate(:post, topic: topic)\n\n      expect(Search.execute('\u793e\u5340\u6307\u5357').posts.first.id).to eq(post.id)\n      expect(Search.execute('\u6307\u5357').posts.first.id).to eq(post.id)\n    end\n\n    it 'finds chinese topic based on title if tokenization is forced' do\n      skip(\"skipped until pg app installs the db correctly\") if RbConfig::CONFIG[\"arch\"] =~ /darwin/\n\n      SiteSetting.search_tokenize_chinese_japanese_korean = true\n      SiteSetting.min_search_term_length = 1\n\n      topic = Fabricate(:topic, title: 'My Title Discourse\u793e\u5340\u6307\u5357')\n      post = Fabricate(:post, topic: topic)\n\n      expect(Search.execute('\u793e\u5340\u6307\u5357').posts.first.id).to eq(post.id)\n      expect(Search.execute('\u6307\u5357').posts.first.id).to eq(post.id)\n    end\n  end\n\n  describe 'Advanced search' do\n\n    it 'supports pinned' do\n      Fabricate(:post, raw: 'hi this is a test 123 123', topic: topic)\n      _post = Fabricate(:post, raw: 'boom boom shake the room', topic: topic)\n\n      topic.update_pinned(true)\n\n      expect(Search.execute('boom in:pinned').posts.length).to eq(1)\n      expect(Search.execute('boom IN:PINNED').posts.length).to eq(1)\n    end\n\n    it 'supports wiki' do\n      topic_2 = Fabricate(:topic)\n      post = Fabricate(:post, raw: 'this is a test 248', wiki: true, topic: topic)\n      Fabricate(:post, raw: 'this is a test 248', wiki: false, topic: topic_2)\n\n      expect(Search.execute('test 248').posts.length).to eq(2)\n      expect(Search.execute('test 248 in:wiki').posts.first).to eq(post)\n      expect(Search.execute('test 248 IN:WIKI').posts.first).to eq(post)\n    end\n\n    it 'supports searching for posts that the user has seen/unseen' do\n      topic_2 = Fabricate(:topic)\n      post = Fabricate(:post, raw: 'logan is longan', topic: topic)\n      post_2 = Fabricate(:post, raw: 'longan is logan', topic: topic_2)\n\n      [post.user, topic.user].each do |user|\n        PostTiming.create!(\n          post_number: post.post_number,\n          topic: topic,\n          user: user,\n          msecs: 1\n        )\n      end\n\n      expect(post.seen?(post.user)).to eq(true)\n\n      expect(Search.execute('longan').posts.sort).to eq([post, post_2])\n\n      expect(Search.execute('longan in:seen', guardian: Guardian.new(post.user)).posts)\n        .to eq([post])\n\n      expect(Search.execute('longan IN:SEEN', guardian: Guardian.new(post.user)).posts)\n        .to eq([post])\n\n      expect(Search.execute('longan in:seen').posts.sort).to eq([post, post_2])\n\n      expect(Search.execute('longan in:seen', guardian: Guardian.new(post_2.user)).posts)\n        .to eq([])\n\n      expect(Search.execute('longan', guardian: Guardian.new(post_2.user)).posts.sort)\n        .to eq([post, post_2])\n\n      expect(Search.execute('longan in:unseen', guardian: Guardian.new(post_2.user)).posts.sort)\n        .to eq([post, post_2])\n\n      expect(Search.execute('longan in:unseen', guardian: Guardian.new(post.user)).posts)\n        .to eq([post_2])\n\n      expect(Search.execute('longan IN:UNSEEN', guardian: Guardian.new(post.user)).posts)\n        .to eq([post_2])\n    end\n\n    it 'supports before and after filters' do\n      time = Time.zone.parse('2001-05-20 2:55')\n      freeze_time(time)\n\n      post_1 = Fabricate(:post, raw: 'hi this is a test 123 123', created_at: time.months_ago(2))\n      post_2 = Fabricate(:post, raw: 'boom boom shake the room test')\n\n      expect(Search.execute('test before:1').posts).to contain_exactly(post_1)\n      expect(Search.execute('test before:2001-04-20').posts).to contain_exactly(post_1)\n      expect(Search.execute('test before:2001').posts).to eq([])\n      expect(Search.execute('test after:2001').posts).to contain_exactly(post_1, post_2)\n      expect(Search.execute('test before:monday').posts).to contain_exactly(post_1)\n      expect(Search.execute('test after:jan').posts).to contain_exactly(post_1, post_2)\n    end\n\n    it 'supports in:first, user:, @username' do\n      post_1 = Fabricate(:post, raw: 'hi this is a test 123 123', topic: topic)\n      post_2 = Fabricate(:post, raw: 'boom boom shake the room test', topic: topic)\n\n      expect(Search.execute('test in:first').posts).to contain_exactly(post_1)\n      expect(Search.execute('test IN:FIRST').posts).to contain_exactly(post_1)\n\n      expect(Search.execute('boom').posts).to contain_exactly(post_2)\n\n      expect(Search.execute('boom in:first').posts).to eq([])\n      expect(Search.execute('boom f').posts).to eq([])\n\n      expect(Search.execute('123 in:first').posts).to contain_exactly(post_1)\n      expect(Search.execute('123 f').posts).to contain_exactly(post_1)\n\n      expect(Search.execute('user:nobody').posts).to eq([])\n      expect(Search.execute(\"user:#{post_1.user.username}\").posts).to contain_exactly(post_1)\n      expect(Search.execute(\"user:#{post_1.user_id}\").posts).to contain_exactly(post_1)\n\n      expect(Search.execute(\"@#{post_1.user.username}\").posts).to contain_exactly(post_1)\n    end\n\n    it 'supports group' do\n      topic = Fabricate(:topic, created_at: 3.months.ago)\n      post = Fabricate(:post, raw: 'hi this is a test 123 123', topic: topic)\n\n      group = Group.create!(name: \"Like_a_Boss\")\n      GroupUser.create!(user_id: post.user_id, group_id: group.id)\n\n      expect(Search.execute('group:like_a_boss').posts.length).to eq(1)\n      expect(Search.execute('group:\"like a brick\"').posts.length).to eq(0)\n    end\n\n    it 'supports badge' do\n\n      topic = Fabricate(:topic, created_at: 3.months.ago)\n      post = Fabricate(:post, raw: 'hi this is a test 123 123', topic: topic)\n\n      badge = Badge.create!(name: \"Like a Boss\", badge_type_id: 1)\n      UserBadge.create!(user_id: post.user_id, badge_id: badge.id, granted_at: 1.minute.ago, granted_by_id: -1)\n\n      expect(Search.execute('badge:\"like a boss\"').posts.length).to eq(1)\n      expect(Search.execute('BADGE:\"LIKE A BOSS\"').posts.length).to eq(1)\n      expect(Search.execute('badge:\"test\"').posts.length).to eq(0)\n    end\n\n    it 'can match exact phrases' do\n      post = Fabricate(:post, raw: %{this is a test post with 'a URL https://some.site.com/search?q=test.test.test some random text I have to add})\n      post2 = Fabricate(:post, raw: 'test URL post with')\n\n      expect(Search.execute(\"test post with 'a URL).posts\").posts).to eq([post2, post])\n      expect(Search.execute(%{\"test post with 'a URL\"}).posts).to eq([post])\n      expect(Search.execute(%{\"https://some.site.com/search?q=test.test.test\"}).posts).to eq([post])\n      expect(Search.execute(%{\" with 'a URL https://some.site.com/search?q=test.test.test\"}).posts).to eq([post])\n    end\n\n    it 'can search numbers correctly, and match exact phrases' do\n      post = Fabricate(:post, raw: '3.0 eta is in 2 days horrah')\n      post2 = Fabricate(:post, raw: '3.0 is eta in 2 days horrah')\n\n      expect(Search.execute('3.0 eta').posts).to eq([post, post2])\n      expect(Search.execute(\"'3.0 eta'\").posts).to eq([post, post2])\n      expect(Search.execute(\"\\\"3.0 eta\\\"\").posts).to contain_exactly(post)\n      expect(Search.execute('\"3.0, eta is\"').posts).to eq([])\n    end\n\n    it 'can find by status' do\n      public_category = Fabricate(:category, read_restricted: false)\n      post = Fabricate(:post, raw: 'hi this is a test 123 123')\n      topic = post.topic\n      topic.update(category: public_category)\n\n      private_category = Fabricate(:category, read_restricted: true)\n      post2 = Fabricate(:post, raw: 'hi this is another test 123 123')\n      second_topic = post2.topic\n      second_topic.update(category: private_category)\n\n      _post3 = Fabricate(:post, raw: \"another test!\", user: topic.user, topic: second_topic)\n\n      expect(Search.execute('test status:public').posts.length).to eq(1)\n      expect(Search.execute('test status:closed').posts.length).to eq(0)\n      expect(Search.execute('test status:open').posts.length).to eq(1)\n      expect(Search.execute('test STATUS:OPEN').posts.length).to eq(1)\n      expect(Search.execute('test posts_count:1').posts.length).to eq(1)\n      expect(Search.execute('test min_post_count:1').posts.length).to eq(1)\n      expect(Search.execute('test min_posts:1').posts.length).to eq(1)\n      expect(Search.execute('test max_posts:2').posts.length).to eq(1)\n\n      topic.update(closed: true)\n      second_topic.update(category: public_category)\n\n      expect(Search.execute('test status:public').posts.length).to eq(2)\n      expect(Search.execute('test status:closed').posts.length).to eq(1)\n      expect(Search.execute('status:closed').posts.length).to eq(1)\n      expect(Search.execute('test status:open').posts.length).to eq(1)\n\n      topic.update(archived: true, closed: false)\n      second_topic.update(closed: true)\n\n      expect(Search.execute('test status:archived').posts.length).to eq(1)\n      expect(Search.execute('test status:open').posts.length).to eq(0)\n\n      expect(Search.execute('test status:noreplies').posts.length).to eq(1)\n\n      expect(Search.execute('test in:likes', guardian: Guardian.new(topic.user)).posts.length).to eq(0)\n\n      expect(Search.execute('test in:posted', guardian: Guardian.new(topic.user)).posts.length).to eq(2)\n      expect(Search.execute('test In:PoStEd', guardian: Guardian.new(topic.user)).posts.length).to eq(2)\n\n      in_created = Search.execute('test in:created', guardian: Guardian.new(topic.user)).posts\n      created_by_user = Search.execute(\"test created:@#{topic.user.username}\", guardian: Guardian.new(topic.user)).posts\n      expect(in_created.length).to eq(1)\n      expect(created_by_user.length).to eq(1)\n      expect(in_created).to eq(created_by_user)\n\n      expect(Search.execute(\"test created:@#{second_topic.user.username}\", guardian: Guardian.new(topic.user)).posts.length).to eq(1)\n\n      new_user = Fabricate(:user)\n      expect(Search.execute(\"test created:@#{new_user.username}\", guardian: Guardian.new(topic.user)).posts.length).to eq(0)\n\n      TopicUser.change(topic.user.id, topic.id, notification_level: TopicUser.notification_levels[:tracking])\n      expect(Search.execute('test in:watching', guardian: Guardian.new(topic.user)).posts.length).to eq(0)\n      expect(Search.execute('test in:tracking', guardian: Guardian.new(topic.user)).posts.length).to eq(1)\n    end\n\n    it 'can find posts with images' do\n      post_uploaded = Fabricate(:post_with_uploaded_image)\n      Fabricate(:post)\n\n      CookedPostProcessor.new(post_uploaded).update_post_image\n\n      expect(Search.execute('with:images').posts.map(&:id)).to contain_exactly(post_uploaded.id)\n    end\n\n    it 'can find by latest' do\n      topic1 = Fabricate(:topic, title: 'I do not like that Sam I am')\n      post1 = Fabricate(:post, topic: topic1, created_at: 10.minutes.ago)\n      post2 = Fabricate(:post, raw: 'that Sam I am, that Sam I am', created_at: 5.minutes.ago)\n\n      expect(Search.execute('sam').posts.map(&:id)).to eq([post1.id, post2.id])\n      expect(Search.execute('sam ORDER:LATEST').posts.map(&:id)).to eq([post2.id, post1.id])\n      expect(Search.execute('sam l').posts.map(&:id)).to eq([post2.id, post1.id])\n      expect(Search.execute('l sam').posts.map(&:id)).to eq([post2.id, post1.id])\n    end\n\n    it 'can order by topic creation' do\n      today        = Date.today\n      yesterday    = 1.day.ago\n      two_days_ago = 2.days.ago\n      category = Fabricate(:category_with_definition)\n\n      old_topic = Fabricate(:topic,\n        title: 'First Topic, testing the created_at sort',\n        created_at: two_days_ago,\n        category: category\n      )\n\n      latest_topic = Fabricate(:topic,\n        title: 'Second Topic, testing the created_at sort',\n        created_at: yesterday,\n        category: category\n      )\n\n      old_relevant_topic_post = Fabricate(:post,\n        topic: old_topic,\n        created_at: yesterday,\n        raw: 'Relevant Relevant Topic'\n      )\n\n      latest_irrelevant_topic_post = Fabricate(:post,\n        topic: latest_topic,\n        created_at: today,\n        raw: 'Not Relevant'\n      )\n\n      # Expecting the default results\n      expect(Search.execute('Topic').posts.map(&:id)).to eq([\n        old_relevant_topic_post.id,\n        latest_irrelevant_topic_post.id,\n        category.topic.first_post.id\n      ])\n\n      # Expecting the ordered by topic creation results\n      expect(Search.execute('Topic order:latest_topic').posts.map(&:id)).to eq([\n        category.topic.first_post.id,\n        latest_irrelevant_topic_post.id,\n        old_relevant_topic_post.id\n      ])\n    end\n\n    it 'can order by topic views' do\n      topic = Fabricate(:topic, views: 1)\n      topic2 = Fabricate(:topic, views: 2)\n      post = Fabricate(:post, raw: 'Topic', topic: topic)\n      post2 = Fabricate(:post, raw: 'Topic', topic: topic2)\n\n      expect(Search.execute('Topic order:views').posts.map(&:id)).to eq([\n        post2.id,\n        post.id\n      ])\n    end\n\n    it 'can filter by topic views' do\n      topic = Fabricate(:topic, views: 100)\n      topic2 = Fabricate(:topic, views: 200)\n      post = Fabricate(:post, raw: 'Topic', topic: topic)\n      post2 = Fabricate(:post, raw: 'Topic', topic: topic2)\n\n      expect(Search.execute('Topic min_views:150').posts.map(&:id)).to eq([post2.id])\n      expect(Search.execute('Topic max_views:150').posts.map(&:id)).to eq([post.id])\n    end\n\n    it 'can search for terms with dots' do\n      post = Fabricate(:post, raw: 'Will.2000 Will.Bob.Bill...')\n      expect(Search.execute('bill').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('bob').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('2000').posts.map(&:id)).to eq([post.id])\n    end\n\n    it 'can search URLS correctly' do\n      post = Fabricate(:post, raw: 'i like http://wb.camra.org.uk/latest#test so yay')\n\n      expect(Search.execute('http://wb.camra.org.uk/latest#test').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('camra').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('http://wb').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('wb.camra').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('wb.camra.org').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('org.uk').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('camra.org.uk').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('wb.camra.org.uk').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('wb.camra.org.uk/latest').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('/latest#test').posts.map(&:id)).to eq([post.id])\n    end\n\n    it 'supports category slug and tags' do\n      # main category\n      category = Fabricate(:category_with_definition, name: 'category 24', slug: 'cateGory-24')\n      topic = Fabricate(:topic, created_at: 3.months.ago, category: category)\n      post = Fabricate(:post, raw: 'Sams first post', topic: topic)\n\n      expect(Search.execute('sams post #categoRy-24').posts.length).to eq(1)\n      expect(Search.execute(\"sams post category:#{category.id}\").posts.length).to eq(1)\n      expect(Search.execute('sams post #categoRy-25').posts.length).to eq(0)\n\n      sub_category = Fabricate(:category_with_definition, name: 'sub category', slug: 'sub-category', parent_category_id: category.id)\n      second_topic = Fabricate(:topic, created_at: 3.months.ago, category: sub_category)\n      Fabricate(:post, raw: 'sams second post', topic: second_topic)\n\n      expect(Search.execute(\"sams post category:categoRY-24\").posts.length).to eq(2)\n      expect(Search.execute(\"sams post category:=cAtegory-24\").posts.length).to eq(1)\n\n      expect(Search.execute(\"sams post #category-24\").posts.length).to eq(2)\n      expect(Search.execute(\"sams post #=category-24\").posts.length).to eq(1)\n      expect(Search.execute(\"sams post #sub-category\").posts.length).to eq(1)\n\n      expect(Search.execute(\"sams post #categoRY-24:SUB-category\").posts.length)\n        .to eq(1)\n\n      # tags\n      topic.tags = [Fabricate(:tag, name: 'alpha'), Fabricate(:tag, name: '\u043f\u0440\u0438\u0432\u0435\u0442'), Fabricate(:tag, name: 'HeLlO')]\n      expect(Search.execute('this is a test #alpha').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('this is a test #\u043f\u0440\u0438\u0432\u0435\u0442').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('this is a test #hElLo').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('this is a test #beta').posts.size).to eq(0)\n    end\n\n    it 'supports sub-sub category slugs' do\n\n      SiteSetting.max_category_nesting = 3\n\n      category = Fabricate(:category, name: 'top', slug: 'top')\n      sub = Fabricate(:category, name: 'middle', slug: 'middle', parent_category_id: category.id)\n      leaf = Fabricate(:category, name: 'leaf', slug: 'leaf', parent_category_id: sub.id)\n\n      topic = Fabricate(:topic, created_at: 3.months.ago, category: leaf)\n      _post = Fabricate(:post, raw: 'Sams first post', topic: topic)\n\n      expect(Search.execute('#Middle:leaf first post').posts.size).to eq(1)\n    end\n\n    it 'correctly handles #symbol when no tag or category match' do\n      Fabricate(:post, raw: 'testing #1 #9998')\n      results = Search.new('testing #1').execute\n      expect(results.posts.length).to eq(1)\n\n      results = Search.new('#9998').execute\n      expect(results.posts.length).to eq(1)\n\n      results = Search.new('#777').execute\n      expect(results.posts.length).to eq(0)\n\n      results = Search.new('xxx #:').execute\n      expect(results.posts.length).to eq(0)\n    end\n\n    context 'tags' do\n      fab!(:tag1) { Fabricate(:tag, name: 'lunch') }\n      fab!(:tag2) { Fabricate(:tag, name: 'eggs') }\n      fab!(:tag3) { Fabricate(:tag, name: 'sandwiches') }\n\n      fab!(:tag_group) do\n        group = TagGroup.create!(name: 'mid day')\n        TagGroupMembership.create!(tag_id: tag1.id, tag_group_id: group.id)\n        TagGroupMembership.create!(tag_id: tag3.id, tag_group_id: group.id)\n        group\n      end\n\n      fab!(:topic1) { Fabricate(:topic, tags: [tag2, Fabricate(:tag)]) }\n      fab!(:topic2) { Fabricate(:topic, tags: [tag2]) }\n      fab!(:topic3) { Fabricate(:topic, tags: [tag1, tag2]) }\n      fab!(:topic4) { Fabricate(:topic, tags: [tag1, tag2, tag3]) }\n      fab!(:topic5) { Fabricate(:topic, tags: [tag2, tag3]) }\n\n      def indexed_post(*args)\n        SearchIndexer.enable\n        Fabricate(:post, *args)\n      end\n\n      fab!(:post1) { indexed_post(topic: topic1) }\n      fab!(:post2) { indexed_post(topic: topic2) }\n      fab!(:post3) { indexed_post(topic: topic3) }\n      fab!(:post4) { indexed_post(topic: topic4) }\n      fab!(:post5) { indexed_post(topic: topic5) }\n\n      it 'can find posts by tag group' do\n        expect(Search.execute('#mid-day').posts.map(&:id)).to eq([\n          post5, post4, post3\n        ].map(&:id))\n      end\n\n      it 'can find posts with tag' do\n        post4 = Fabricate(:post, topic: topic3, raw: \"It probably doesn't help that they're green...\")\n\n        expect(Search.execute('green tags:eggs').posts.map(&:id)).to eq([post4.id])\n        expect(Search.execute('tags:plants').posts.size).to eq(0)\n      end\n\n      it 'can find posts with non-latin tag' do\n        topic.tags = [Fabricate(:tag, name: '\u3055\u3088\u3046\u306a\u3089')]\n        post = Fabricate(:post, raw: 'Testing post', topic: topic)\n\n        expect(Search.execute('tags:\u3055\u3088\u3046\u306a\u3089').posts.map(&:id)).to eq([post.id])\n      end\n\n      it 'can find posts with thai tag' do\n        topic.tags = [Fabricate(:tag, name: '\u0e40\u0e23\u0e0b\u0e34\u0e48\u0e19')]\n        post = Fabricate(:post, raw: 'Testing post', topic: topic)\n\n        expect(Search.execute('tags:\u0e40\u0e23\u0e0b\u0e34\u0e48\u0e19').posts.map(&:id)).to eq([post.id])\n      end\n\n      it 'can find posts with any tag from multiple tags' do\n        expect(Search.execute('tags:eggs,lunch').posts.map(&:id).sort).to eq([post1.id, post2.id, post3.id, post4.id, post5.id].sort)\n      end\n\n      it 'can find posts which contains all provided tags' do\n        expect(Search.execute('tags:lunch+eggs+sandwiches').posts.map(&:id)).to eq([post4.id].sort)\n        expect(Search.execute('tags:eggs+lunch+sandwiches').posts.map(&:id)).to eq([post4.id].sort)\n      end\n\n      it 'can find posts which contains provided tags and does not contain selected ones' do\n        expect(Search.execute('tags:eggs -tags:lunch').posts.map(&:id))\n          .to eq([post5, post2, post1].map(&:id))\n\n        expect(Search.execute('tags:eggs -tags:lunch+sandwiches').posts.map(&:id))\n          .to eq([post5, post3, post2, post1].map(&:id))\n\n        expect(Search.execute('tags:eggs -tags:lunch,sandwiches').posts.map(&:id))\n          .to eq([post2, post1].map(&:id))\n      end\n\n      it 'orders posts correctly when combining tags with categories or terms' do\n        cat1 = Fabricate(:category_with_definition, name: 'food')\n        topic6 = Fabricate(:topic, tags: [tag1, tag2], category: cat1)\n        topic7 = Fabricate(:topic, tags: [tag1, tag2, tag3], category: cat1)\n        post7 = Fabricate(:post, topic: topic6, raw: \"Wakey, wakey, eggs and bakey.\", like_count: 5, created_at: 2.minutes.ago)\n        post8 = Fabricate(:post, topic: topic7, raw: \"Bakey, bakey, eggs to makey.\", like_count: 2, created_at: 1.minute.ago)\n\n        expect(Search.execute('bakey tags:lunch order:latest').posts.map(&:id))\n          .to eq([post8.id, post7.id])\n\n        expect(Search.execute('#food tags:lunch order:latest').posts.map(&:id))\n          .to eq([post8.id, post7.id])\n\n        expect(Search.execute('#food tags:lunch order:likes').posts.map(&:id))\n          .to eq([post7.id, post8.id])\n      end\n\n    end\n\n    it \"can find posts which contains filetypes\" do\n      post1 = Fabricate(:post, raw: \"http://example.com/image.png\")\n\n      post2 = Fabricate(:post,\n        raw: \"Discourse logo\\n\"\\\n          \"http://example.com/logo.png\\n\"\\\n          \"http://example.com/vector_image.svg\"\n      )\n\n      post_with_upload = Fabricate(:post, uploads: [Fabricate(:upload)])\n      Fabricate(:post)\n\n      TopicLink.extract_from(post1)\n      TopicLink.extract_from(post2)\n\n      expect(Search.execute('filetype:svg').posts).to eq([post2])\n\n      expect(Search.execute('filetype:png').posts.map(&:id)).to eq([\n        post_with_upload, post2, post1\n      ].map(&:id))\n\n      expect(Search.execute('logo filetype:png').posts).to eq([post2])\n    end\n  end\n\n  context '#ts_query' do\n    it 'can parse complex strings using ts_query helper' do\n      str = +\" grigio:babel deprecated? \"\n      str << \"page page on Atmosphere](https://atmospherejs.com/grigio/babel)xxx: aaa.js:222 aaa'\\\"bbb\"\n\n      ts_query = Search.ts_query(term: str, ts_config: \"simple\")\n      expect { DB.exec(+\"SELECT to_tsvector('bbb') @@ \" << ts_query) }.to_not raise_error\n\n      ts_query = Search.ts_query(term: \"foo.bar/'&baz\", ts_config: \"simple\")\n      expect { DB.exec(+\"SELECT to_tsvector('bbb') @@ \" << ts_query) }.to_not raise_error\n      expect(ts_query).to include(\"baz\")\n    end\n\n    it 'escapes the term correctly' do\n      expect(Search.ts_query(term: 'Title with trailing backslash\\\\'))\n        .to eq(\"TO_TSQUERY('english', '''Title with trailing backslash\\\\\\\\\\\\\\\\'':*')\")\n\n      expect(Search.ts_query(term: \"Title with trailing quote'\"))\n        .to eq(\"TO_TSQUERY('english', '''Title with trailing quote'''''':*')\")\n    end\n  end\n\n  context '#word_to_date' do\n    it 'parses relative dates correctly' do\n      time = Time.zone.parse('2001-02-20 2:55')\n      freeze_time(time)\n\n      expect(Search.word_to_date('yesterday')).to eq(time.beginning_of_day.yesterday)\n      expect(Search.word_to_date('suNday')).to eq(Time.zone.parse('2001-02-18'))\n      expect(Search.word_to_date('thursday')).to eq(Time.zone.parse('2001-02-15'))\n      expect(Search.word_to_date('deCember')).to eq(Time.zone.parse('2000-12-01'))\n      expect(Search.word_to_date('deC')).to eq(Time.zone.parse('2000-12-01'))\n      expect(Search.word_to_date('january')).to eq(Time.zone.parse('2001-01-01'))\n      expect(Search.word_to_date('jan')).to eq(Time.zone.parse('2001-01-01'))\n\n      expect(Search.word_to_date('100')).to eq(time.beginning_of_day.days_ago(100))\n\n      expect(Search.word_to_date('invalid')).to eq(nil)\n    end\n\n    it 'parses absolute dates correctly' do\n      expect(Search.word_to_date('2001-1-20')).to eq(Time.zone.parse('2001-01-20'))\n      expect(Search.word_to_date('2030-10-2')).to eq(Time.zone.parse('2030-10-02'))\n      expect(Search.word_to_date('2030-10')).to eq(Time.zone.parse('2030-10-01'))\n      expect(Search.word_to_date('2030')).to eq(Time.zone.parse('2030-01-01'))\n      expect(Search.word_to_date('2030-01-32')).to eq(nil)\n      expect(Search.word_to_date('10000')).to eq(nil)\n    end\n  end\n\n  context \"#min_post_id\" do\n    it \"returns 0 when prefer_recent_posts is disabled\" do\n      SiteSetting.search_prefer_recent_posts = false\n      expect(Search.min_post_id_no_cache).to eq(0)\n    end\n\n    it \"returns a value when prefer_recent_posts is enabled\" do\n      SiteSetting.search_prefer_recent_posts = true\n      SiteSetting.search_recent_posts_size = 1\n\n      Fabricate(:post)\n      p2 = Fabricate(:post)\n\n      expect(Search.min_post_id_no_cache).to eq(p2.id)\n    end\n  end\n\n  context \"search_log_id\" do\n    it \"returns an id when the search succeeds\" do\n      s = Search.new(\n        'indiana jones',\n        search_type: :header,\n        ip_address: '127.0.0.1'\n      )\n      results = s.execute\n      expect(results.search_log_id).to be_present\n    end\n\n    it \"does not log search if search_type is not present\" do\n      s = Search.new('foo bar', ip_address: '127.0.0.1')\n      results = s.execute\n      expect(results.search_log_id).not_to be_present\n    end\n  end\n\n  context 'in:title' do\n    it 'allows for search in title' do\n      topic = Fabricate(:topic, title: 'I am testing a title search')\n      _post2 = Fabricate(:post, topic: topic, raw: 'this is the second post', post_number: 2)\n      post = Fabricate(:post, topic: topic, raw: 'this is the first post', post_number: 1)\n\n      results = Search.execute('title in:title')\n      expect(results.posts.map(&:id)).to eq([post.id])\n\n      results = Search.execute('title iN:tItLe')\n      expect(results.posts.map(&:id)).to eq([post.id])\n\n      results = Search.execute('first in:title')\n      expect(results.posts).to eq([])\n    end\n\n    it 'works irrespective of the order' do\n      topic = Fabricate(:topic, title: \"A topic about Discourse\")\n      Fabricate(:post, topic: topic, raw: \"This is another post\")\n      topic2 = Fabricate(:topic, title: \"This is another topic\")\n      Fabricate(:post, topic: topic2, raw: \"Discourse is awesome\")\n\n      results = Search.execute('Discourse in:title status:open')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('in:title status:open Discourse')\n      expect(results.posts.length).to eq(1)\n    end\n  end\n\n  context 'ignore_diacritics' do\n    before { SiteSetting.search_ignore_accents = true }\n    let!(:post1) { Fabricate(:post, raw: '\u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35 R\u00e1gis hello') }\n\n    it ('allows strips correctly') do\n      results = Search.execute('hello', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('ragis', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('R\u00e1gis', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      # TODO: this is a test we need to fix!\n      #expect(results.blurb(results.posts.first)).to include('R\u00e1gis')\n\n      results = Search.execute('\u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n    end\n  end\n\n  context 'CJK segmentation' do\n    before do\n      SiteSetting.search_tokenize_chinese_japanese_korean = true\n      SiteSetting.min_search_term_length = 1\n    end\n\n    let!(:post1) do\n      Fabricate(:post, raw: '\u5834\u30b5\u30a2\u30de\u30cd\u7e54\u4f01\u3046\u3044\u304b\u305b\u7af9\u57df\u30f1\u30a4\u30de\u7a42\u57fa\u30db\u795e3\u4e88\u8aad\u305a\u306d\u3044\u3071\u677e\u67fb\u30b9\u7981\u591a\u30b5\u30a6\u63d0\u61f8\u30a4\u3075\u5f15\u5c0f43\u6539\u3053\u3087\u30c9\u3081\u3002\u6df1\u3068\u3064\u3050\u4e3b\u601d\u6599\u8fb2\u305e\u304b\u30eb\u8005\u676f\u691c\u3081\u308b\u6d3b\u5206\u3048\u307b\u3065\u307c\u767d\u72a0')\n    end\n\n    it('does not include superfluous spaces in blurbs') do\n\n      results = Search.execute('\u3046\u3044\u304b\u305b\u7af9\u57df', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      expect(results.blurb(results.posts.first)).to include('\u3046\u3044\u304b\u305b\u7af9\u57df')\n\n    end\n\n  end\n\n  context 'include_diacritics' do\n    before { SiteSetting.search_ignore_accents = false }\n    let!(:post1) { Fabricate(:post, raw: '\u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35 R\u00e9gis hello') }\n\n    it ('allows strips correctly') do\n      results = Search.execute('hello', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('regis', type_filter: 'topic')\n      expect(results.posts.length).to eq(0)\n\n      results = Search.execute('R\u00e9gis', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      expect(results.blurb(results.posts.first)).to include('R\u00e9gis')\n\n      results = Search.execute('\u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n    end\n  end\n\n  context 'pagination' do\n    let(:number_of_results) { 2 }\n    let!(:post1) { Fabricate(:post, raw: 'hello hello hello hello hello') }\n    let!(:post2) { Fabricate(:post, raw: 'hello hello hello hello') }\n    let!(:post3) { Fabricate(:post, raw: 'hello hello hello') }\n    let!(:post4) { Fabricate(:post, raw: 'hello hello') }\n    let!(:post5) { Fabricate(:post, raw: 'hello') }\n    before do\n      Search.stubs(:per_filter).returns(number_of_results)\n    end\n\n    it 'returns more results flag' do\n      results = Search.execute('hello', type_filter: 'topic')\n      results2 = Search.execute('hello', type_filter: 'topic', page: 2)\n\n      expect(results.posts.length).to eq(number_of_results)\n      expect(results.posts.map(&:id)).to eq([post1.id, post2.id])\n      expect(results.more_full_page_results).to eq(true)\n      expect(results2.posts.length).to eq(number_of_results)\n      expect(results2.posts.map(&:id)).to eq([post3.id, post4.id])\n      expect(results2.more_full_page_results).to eq(true)\n    end\n\n    it 'correctly search with page parameter' do\n      search = Search.new('hello', type_filter: 'topic', page: 3)\n      results = search.execute\n\n      expect(search.offset).to eq(2 * number_of_results)\n      expect(results.posts.length).to eq(1)\n      expect(results.posts).to eq([post5])\n      expect(results.more_full_page_results).to eq(nil)\n    end\n\n  end\n\n  context 'in:tagged' do\n    it 'allows for searching by presence of any tags' do\n      topic = Fabricate(:topic, title: 'I am testing a tagged search')\n      _post = Fabricate(:post, topic: topic, raw: 'this is the first post')\n      tag = Fabricate(:tag)\n      _topic_tag = Fabricate(:topic_tag, topic: topic, tag: tag)\n\n      results = Search.execute('in:untagged')\n      expect(results.posts.length).to eq(0)\n\n      results = Search.execute('in:tagged')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('In:TaGgEd')\n      expect(results.posts.length).to eq(1)\n    end\n  end\n\n  context 'in:untagged' do\n    it 'allows for searching by presence of no tags' do\n      topic = Fabricate(:topic, title: 'I am testing a untagged search')\n      _post = Fabricate(:post, topic: topic, raw: 'this is the first post')\n\n      results = Search.execute('iN:uNtAgGeD')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('in:tagged')\n      expect(results.posts.length).to eq(0)\n    end\n  end\n\n  context 'plugin extensions' do\n    let!(:post0) { Fabricate(:post, raw: 'this is the first post about advanced filter with length more than 50 chars') }\n    let!(:post1) { Fabricate(:post, raw: 'this is the second post about advanced filter') }\n\n    it 'allows to define custom filter' do\n      expect(Search.new(\"advanced\").execute.posts).to eq([post1, post0])\n      Search.advanced_filter(/^min_chars:(\\d+)$/) do |posts, match|\n        posts.where(\"(SELECT LENGTH(p2.raw) FROM posts p2 WHERE p2.id = posts.id) >= ?\", match.to_i)\n      end\n      expect(Search.new(\"advanced min_chars:50\").execute.posts).to eq([post0])\n    end\n\n    it 'allows to define custom order' do\n      expect(Search.new(\"advanced\").execute.posts).to eq([post1, post0])\n\n      Search.advanced_order(:chars) do |posts|\n        posts.reorder(\"MAX(LENGTH(posts.raw)) DESC\")\n      end\n\n      expect(Search.new(\"advanced order:chars\").execute.posts).to eq([post0, post1])\n    end\n  end\n\n  context 'exclude_topics filter' do\n    before { SiteSetting.tagging_enabled = true }\n    let!(:user) { Fabricate(:user) }\n    fab!(:group) { Fabricate(:group, name: 'bruce-world-fans') }\n    fab!(:topic) { Fabricate(:topic, title: 'Bruce topic not a result') }\n\n    it 'works' do\n      category = Fabricate(:category_with_definition, name: 'bruceland', user: user)\n      tag = Fabricate(:tag, name: 'brucealicious')\n\n      result = Search.execute('bruce', type_filter: 'exclude_topics')\n\n      expect(result.users.map(&:id)).to contain_exactly(user.id)\n\n      expect(result.categories.map(&:id)).to contain_exactly(category.id)\n\n      expect(result.groups.map(&:id)).to contain_exactly(group.id)\n\n      expect(result.tags.map(&:id)).to contain_exactly(tag.id)\n\n      expect(result.posts.length).to eq(0)\n    end\n\n    it 'does not fail when parsed term is empty' do\n      result = Search.execute('#cat ', type_filter: 'exclude_topics')\n      expect(result.categories.length).to eq(0)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass Search\n  DIACRITICS ||= /([\\u0300-\\u036f]|[\\u1AB0-\\u1AFF]|[\\u1DC0-\\u1DFF]|[\\u20D0-\\u20FF])/\n  HIGHLIGHT_CSS_CLASS = 'search-highlight'\n\n  cattr_accessor :preloaded_topic_custom_fields\n  self.preloaded_topic_custom_fields = Set.new\n\n  def self.on_preload(&blk)\n    (@preload ||= Set.new) << blk\n  end\n\n  def self.preload(results, object)\n    if @preload\n      @preload.each { |preload| preload.call(results, object) }\n    end\n  end\n\n  def self.per_facet\n    5\n  end\n\n  def self.strip_diacritics(str)\n    s = str.unicode_normalize(:nfkd)\n    s.gsub!(DIACRITICS, \"\")\n    s.strip!\n    s\n  end\n\n  def self.per_filter\n    50\n  end\n\n  def self.facets\n    %w(topic category user private_messages tags all_topics exclude_topics)\n  end\n\n  def self.ts_config(locale = SiteSetting.default_locale)\n    # if adding a text search configuration, you should check PG beforehand:\n    # SELECT cfgname FROM pg_ts_config;\n    # As an aside, dictionaries can be listed by `\\dFd`, the\n    # physical locations are in /usr/share/postgresql/<version>/tsearch_data.\n    # But it may not appear there based on pg extension configuration.\n    # base docker config\n    #\n    case locale.split(\"_\")[0].to_sym\n    when :da then 'danish'\n    when :nl then 'dutch'\n    when :en then 'english'\n    when :fi then 'finnish'\n    when :fr then 'french'\n    when :de then 'german'\n    when :hu then 'hungarian'\n    when :it then 'italian'\n    when :nb then 'norwegian'\n    when :pt then 'portuguese'\n    when :ro then 'romanian'\n    when :ru then 'russian'\n    when :es then 'spanish'\n    when :sv then 'swedish'\n    when :tr then 'turkish'\n    else 'simple' # use the 'simple' stemmer for other languages\n    end\n  end\n\n  def self.segment_cjk?\n    ['zh_TW', 'zh_CN', 'ja'].include?(SiteSetting.default_locale) ||\n      SiteSetting.search_tokenize_chinese_japanese_korean\n  end\n\n  def self.prepare_data(search_data, purpose = nil)\n    data = search_data.dup\n    data.force_encoding(\"UTF-8\")\n\n    if purpose != :topic\n      # TODO cppjieba_rb is designed for chinese, we need something else for Japanese\n      # Korean appears to be safe cause words are already space separated\n      # For Japanese we should investigate using kakasi\n      if segment_cjk?\n        require 'cppjieba_rb' unless defined? CppjiebaRb\n        data = CppjiebaRb.segment(search_data, mode: :mix)\n\n        # TODO: we still want to tokenize here but the current stopword list is too wide\n        # in cppjieba leading to words such as volume to be skipped. PG already has an English\n        # stopword list so use that vs relying on cppjieba\n        if ts_config != 'english'\n          data = CppjiebaRb.filter_stop_word(data)\n        else\n          data = data.filter { |s| s.present? }\n        end\n\n        data = data.join(' ')\n      else\n        data.squish!\n      end\n\n      if SiteSetting.search_ignore_accents\n        data = strip_diacritics(data)\n      end\n    end\n\n    data.gsub!(/\\S+/) do |str|\n      if str =~ /^[\"]?((https?:\\/\\/)[\\S]+)[\"]?$/\n        begin\n          uri = URI.parse(Regexp.last_match[1])\n          uri.query = nil\n          str = uri.to_s\n        rescue URI::Error\n          # don't fail if uri does not parse\n        end\n      end\n\n      str\n    end\n\n    data\n  end\n\n  def self.word_to_date(str)\n\n    if str =~ /^[0-9]{1,3}$/\n      return Time.zone.now.beginning_of_day.days_ago(str.to_i)\n    end\n\n    if str =~ /^([12][0-9]{3})(-([0-1]?[0-9]))?(-([0-3]?[0-9]))?$/\n      year = $1.to_i\n      month = $2 ? $3.to_i : 1\n      day = $4 ? $5.to_i : 1\n\n      return if day == 0 || month == 0 || day > 31 || month > 12\n\n      return begin\n        Time.zone.parse(\"#{year}-#{month}-#{day}\")\n      rescue ArgumentError\n      end\n    end\n\n    if str.downcase == \"yesterday\"\n      return Time.zone.now.beginning_of_day.yesterday\n    end\n\n    titlecase = str.downcase.titlecase\n\n    if Date::DAYNAMES.include?(titlecase)\n      return Time.zone.now.beginning_of_week(str.downcase.to_sym)\n    end\n\n    if idx = (Date::MONTHNAMES.find_index(titlecase) ||\n              Date::ABBR_MONTHNAMES.find_index(titlecase))\n      delta = Time.zone.now.month - idx\n      delta += 12 if delta < 0\n      Time.zone.now.beginning_of_month.months_ago(delta)\n    end\n  end\n\n  def self.min_post_id_no_cache\n    return 0 unless SiteSetting.search_prefer_recent_posts?\n\n    offset, has_more = Post.unscoped\n      .order('id desc')\n      .offset(SiteSetting.search_recent_posts_size - 1)\n      .limit(2)\n      .pluck(:id)\n\n    has_more ? offset : 0\n  end\n\n  def self.min_post_id(opts = nil)\n    return 0 unless SiteSetting.search_prefer_recent_posts?\n\n    # It can be quite slow to count all the posts so let's cache it\n    Discourse.cache.fetch(\"search-min-post-id:#{SiteSetting.search_recent_posts_size}\", expires_in: 1.week) do\n      min_post_id_no_cache\n    end\n  end\n\n  attr_accessor :term\n  attr_reader :clean_term, :guardian\n\n  def initialize(term, opts = nil)\n    @opts = opts || {}\n    @guardian = @opts[:guardian] || Guardian.new\n    @search_context = @opts[:search_context]\n    @blurb_length = @opts[:blurb_length]\n    @valid = true\n    @page = @opts[:page]\n    @search_all_pms = false\n\n    term = term.to_s.dup\n\n    # Removes any zero-width characters from search terms\n    term.gsub!(/[\\u200B-\\u200D\\uFEFF]/, '')\n    # Replace curly quotes to regular quotes\n    term.gsub!(/[\\u201c\\u201d]/, '\"')\n\n    @clean_term = term\n    @in_title = false\n\n    term = process_advanced_search!(term)\n\n    if term.present?\n      @term = Search.prepare_data(term, Topic === @search_context ? :topic : nil)\n      @original_term = Search.escape_string(@term)\n    end\n\n    if @search_pms || @search_all_pms || @opts[:type_filter] == 'private_messages'\n      @opts[:type_filter] = \"private_messages\"\n      @search_context ||= @guardian.user\n\n      unless @search_context.present? && @guardian.can_see_private_messages?(@search_context.id)\n        raise Discourse::InvalidAccess.new\n      end\n    end\n\n    if @search_all_topics && @guardian.user\n      @opts[:type_filter] = \"all_topics\"\n    end\n\n    @results = GroupedSearchResults.new(\n      type_filter: @opts[:type_filter],\n      term: clean_term,\n      blurb_term: term,\n      search_context: @search_context,\n      blurb_length: @blurb_length\n    )\n  end\n\n  def limit\n    if @opts[:type_filter].present? && @opts[:type_filter] != \"exclude_topics\"\n      Search.per_filter + 1\n    else\n      Search.per_facet + 1\n    end\n  end\n\n  def offset\n    if @page && @opts[:type_filter].present?\n      (@page - 1) * Search.per_filter\n    else\n      0\n    end\n  end\n\n  def valid?\n    @valid\n  end\n\n  def self.execute(term, opts = nil)\n    self.new(term, opts).execute\n  end\n\n  # Query a term\n  def execute(readonly_mode: Discourse.readonly_mode?)\n    if log_query?(readonly_mode)\n      status, search_log_id = SearchLog.log(\n        term: @clean_term,\n        search_type: @opts[:search_type],\n        ip_address: @opts[:ip_address],\n        user_id: @opts[:user_id]\n      )\n      @results.search_log_id = search_log_id unless status == :error\n    end\n\n    unless @filters.present? || @opts[:search_for_id]\n      min_length = @opts[:min_search_term_length] || SiteSetting.min_search_term_length\n      terms = (@term || '').split(/\\s(?=(?:[^\"]|\"[^\"]*\")*$)/).reject { |t| t.length < min_length }\n\n      if terms.blank?\n        @term = ''\n        @valid = false\n        return\n      end\n    end\n\n    # If the term is a number or url to a topic, just include that topic\n    if @opts[:search_for_id] && ['topic', 'private_messages', 'all_topics'].include?(@results.type_filter)\n      if @term =~ /^\\d+$/\n        single_topic(@term.to_i)\n      else\n        if route = Discourse.route_for(@term)\n          if route[:controller] == \"topics\" && route[:action] == \"show\"\n            topic_id = (route[:id] || route[:topic_id]).to_i\n            single_topic(topic_id) if topic_id > 0\n          end\n        end\n      end\n    end\n\n    find_grouped_results if @results.posts.blank?\n\n    if preloaded_topic_custom_fields.present? && @results.posts.present?\n      topics = @results.posts.map(&:topic)\n      Topic.preload_custom_fields(topics, preloaded_topic_custom_fields)\n    end\n\n    Search.preload(@results, self)\n\n    @results\n  end\n\n  def self.advanced_order(trigger, &block)\n    (@advanced_orders ||= {})[trigger] = block\n  end\n\n  def self.advanced_orders\n    @advanced_orders\n  end\n\n  def self.advanced_filter(trigger, &block)\n    (@advanced_filters ||= {})[trigger] = block\n  end\n\n  def self.advanced_filters\n    @advanced_filters\n  end\n\n  def self.custom_topic_eager_load(tables = nil, &block)\n    (@custom_topic_eager_loads ||= []) << (tables || block)\n  end\n\n  def self.custom_topic_eager_loads\n    Array.wrap(@custom_topic_eager_loads)\n  end\n\n  advanced_filter(/^in:personal-direct$/i) do |posts|\n    if @guardian.user\n      posts\n        .joins(\"LEFT JOIN topic_allowed_groups tg ON posts.topic_id = tg.topic_id\")\n        .where(<<~SQL, user_id: @guardian.user.id)\n          tg.id IS NULL\n          AND posts.topic_id IN (\n            SELECT tau.topic_id\n            FROM topic_allowed_users tau\n            JOIN topic_allowed_users tau2\n            ON tau2.topic_id = tau.topic_id\n            AND tau2.id != tau.id\n            WHERE tau.user_id = :user_id\n            GROUP BY tau.topic_id\n            HAVING COUNT(*) = 1\n          )\n        SQL\n    end\n  end\n\n  advanced_filter(/^in:all-pms$/i) do |posts|\n    posts.private_posts if @guardian.is_admin?\n  end\n\n  advanced_filter(/^in:tagged$/i) do |posts|\n    posts\n      .where('EXISTS (SELECT 1 FROM topic_tags WHERE topic_tags.topic_id = posts.topic_id)')\n  end\n\n  advanced_filter(/^in:untagged$/i) do |posts|\n    posts\n      .joins(\"LEFT JOIN topic_tags ON\n        topic_tags.topic_id = posts.topic_id\")\n      .where(\"topic_tags.id IS NULL\")\n  end\n\n  advanced_filter(/^status:open$/i) do |posts|\n    posts.where('NOT topics.closed AND NOT topics.archived')\n  end\n\n  advanced_filter(/^status:closed$/i) do |posts|\n    posts.where('topics.closed')\n  end\n\n  advanced_filter(/^status:public$/i) do |posts|\n    category_ids = Category\n      .where(read_restricted: false)\n      .pluck(:id)\n\n    posts.where(\"topics.category_id in (?)\", category_ids)\n  end\n\n  advanced_filter(/^status:archived$/i) do |posts|\n    posts.where('topics.archived')\n  end\n\n  advanced_filter(/^status:noreplies$/i) do |posts|\n    posts.where(\"topics.posts_count = 1\")\n  end\n\n  advanced_filter(/^status:single_user$/i) do |posts|\n    posts.where(\"topics.participant_count = 1\")\n  end\n\n  advanced_filter(/^posts_count:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.posts_count = ?\", match.to_i)\n  end\n\n  advanced_filter(/^min_post_count:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.posts_count >= ?\", match.to_i)\n  end\n\n  advanced_filter(/^min_posts:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.posts_count >= ?\", match.to_i)\n  end\n\n  advanced_filter(/^max_posts:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.posts_count <= ?\", match.to_i)\n  end\n\n  advanced_filter(/^in:first|^f$/i) do |posts|\n    posts.where(\"posts.post_number = 1\")\n  end\n\n  advanced_filter(/^in:pinned$/i) do |posts|\n    posts.where(\"topics.pinned_at IS NOT NULL\")\n  end\n\n  advanced_filter(/^in:wiki$/i) do |posts, match|\n    posts.where(wiki: true)\n  end\n\n  advanced_filter(/^badge:(.*)$/i) do |posts, match|\n    badge_id = Badge.where('name ilike ? OR id = ?', match, match.to_i).pluck_first(:id)\n    if badge_id\n      posts.where('posts.user_id IN (SELECT ub.user_id FROM user_badges ub WHERE ub.badge_id = ?)', badge_id)\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  def post_action_type_filter(posts, post_action_type)\n    posts.where(\"posts.id IN (\n      SELECT pa.post_id FROM post_actions pa\n      WHERE pa.user_id = #{@guardian.user.id} AND\n            pa.post_action_type_id = #{post_action_type} AND\n            deleted_at IS NULL\n    )\")\n  end\n\n  advanced_filter(/^in:(likes)$/i) do |posts, match|\n    if @guardian.user\n      post_action_type_filter(posts, PostActionType.types[:like])\n    end\n  end\n\n  advanced_filter(/^in:(bookmarks)$/i) do |posts, match|\n    if @guardian.user\n      posts.where(\"posts.id IN (SELECT post_id FROM bookmarks WHERE bookmarks.user_id = #{@guardian.user.id})\")\n    end\n  end\n\n  advanced_filter(/^in:posted$/i) do |posts|\n    posts.where(\"posts.user_id = #{@guardian.user.id}\") if @guardian.user\n  end\n\n  advanced_filter(/^in:(created|mine)$/i) do |posts|\n    posts.where(user_id: @guardian.user.id, post_number: 1) if @guardian.user\n  end\n\n  advanced_filter(/^created:@(.*)$/i) do |posts, match|\n    user_id = User.where(username: match.downcase).pluck_first(:id)\n    posts.where(user_id: user_id, post_number: 1)\n  end\n\n  advanced_filter(/^in:(watching|tracking)$/i) do |posts, match|\n    if @guardian.user\n      level = TopicUser.notification_levels[match.downcase.to_sym]\n      posts.where(\"posts.topic_id IN (\n                    SELECT tu.topic_id FROM topic_users tu\n                    WHERE tu.user_id = :user_id AND\n                          tu.notification_level >= :level\n                   )\", user_id: @guardian.user.id, level: level)\n\n    end\n  end\n\n  advanced_filter(/^in:seen$/i) do |posts|\n    if @guardian.user\n      posts\n        .joins(\"INNER JOIN post_timings ON\n          post_timings.topic_id = posts.topic_id\n          AND post_timings.post_number = posts.post_number\n          AND post_timings.user_id = #{ActiveRecord::Base.connection.quote(@guardian.user.id)}\n        \")\n    end\n  end\n\n  advanced_filter(/^in:unseen$/i) do |posts|\n    if @guardian.user\n      posts\n        .joins(\"LEFT JOIN post_timings ON\n          post_timings.topic_id = posts.topic_id\n          AND post_timings.post_number = posts.post_number\n          AND post_timings.user_id = #{ActiveRecord::Base.connection.quote(@guardian.user.id)}\n        \")\n        .where(\"post_timings.user_id IS NULL\")\n    end\n  end\n\n  advanced_filter(/^with:images$/i) do |posts|\n    posts.where(\"posts.image_upload_id IS NOT NULL\")\n  end\n\n  advanced_filter(/^category:(.+)$/i) do |posts, match|\n    exact = false\n\n    if match[0] == \"=\"\n      exact = true\n      match = match[1..-1]\n    end\n\n    category_ids = Category.where('slug ilike ? OR name ilike ? OR id = ?',\n                                  match, match, match.to_i).pluck(:id)\n    if category_ids.present?\n      category_ids += Category.subcategory_ids(category_ids.first) unless exact\n      @category_filter_matched ||= true\n      posts.where(\"topics.category_id IN (?)\", category_ids)\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  advanced_filter(/^\\#([\\p{L}\\p{M}0-9\\-:=]+)$/i) do |posts, match|\n    category_slug, subcategory_slug = match.to_s.split(\":\")\n    next unless category_slug\n\n    exact = true\n    if category_slug[0] == \"=\"\n      category_slug = category_slug[1..-1]\n    else\n      exact = false\n    end\n\n    category_id = if subcategory_slug\n      Category\n        .where('lower(slug) = ?', subcategory_slug.downcase)\n        .where(parent_category_id: Category.where('lower(slug) = ?', category_slug.downcase).select(:id))\n        .pluck_first(:id)\n    else\n      Category\n        .where('lower(slug) = ?', category_slug.downcase)\n        .order('case when parent_category_id is null then 0 else 1 end')\n        .pluck_first(:id)\n    end\n\n    if category_id\n      category_ids = [category_id]\n      category_ids += Category.subcategory_ids(category_id) if !exact\n\n      @category_filter_matched ||= true\n      posts.where(\"topics.category_id IN (?)\", category_ids)\n    else\n      # try a possible tag match\n      tag_id = Tag.where_name(category_slug).pluck_first(:id)\n      if (tag_id)\n        posts.where(<<~SQL, tag_id)\n          topics.id IN (\n            SELECT DISTINCT(tt.topic_id)\n            FROM topic_tags tt\n            WHERE tt.tag_id = ?\n          )\n        SQL\n      else\n        if tag_group_id = TagGroup.find_id_by_slug(category_slug)\n          posts.where(<<~SQL, tag_group_id)\n            topics.id IN (\n              SELECT DISTINCT(tt.topic_id)\n              FROM topic_tags tt\n              WHERE tt.tag_id in (\n                SELECT tag_id\n                FROM tag_group_memberships\n                WHERE tag_group_id = ?\n              )\n            )\n          SQL\n\n        # a bit yucky but we got to add the term back in\n        elsif match.to_s.length >= SiteSetting.min_search_term_length\n          posts.where <<~SQL\n            posts.id IN (\n              SELECT post_id FROM post_search_data pd1\n              WHERE pd1.search_data @@ #{Search.ts_query(term: \"##{match}\")})\n          SQL\n        end\n      end\n    end\n  end\n\n  advanced_filter(/^group:(.+)$/i) do |posts, match|\n    group_id = Group\n      .visible_groups(@guardian.user)\n      .members_visible_groups(@guardian.user)\n      .where('name ilike ? OR (id = ? AND id > 0)', match, match.to_i).pluck_first(:id)\n\n    if group_id\n      posts.where(\"posts.user_id IN (select gu.user_id from group_users gu where gu.group_id = ?)\", group_id)\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  advanced_filter(/^user:(.+)$/i) do |posts, match|\n    user_id = User.where(staged: false).where('username_lower = ? OR id = ?', match.downcase, match.to_i).pluck_first(:id)\n    if user_id\n      posts.where(\"posts.user_id = #{user_id}\")\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  advanced_filter(/^\\@([a-zA-Z0-9_\\-.]+)$/i) do |posts, match|\n    username = match.downcase\n\n    user_id = User.where(staged: false).where(username_lower: username).pluck_first(:id)\n\n    if !user_id && username == \"me\"\n      user_id = @guardian.user&.id\n    end\n\n    if user_id\n      posts.where(\"posts.user_id = #{user_id}\")\n    else\n      posts.where(\"1 = 0\")\n    end\n  end\n\n  advanced_filter(/^before:(.*)$/i) do |posts, match|\n    if date = Search.word_to_date(match)\n      posts.where(\"posts.created_at < ?\", date)\n    else\n      posts\n    end\n  end\n\n  advanced_filter(/^after:(.*)$/i) do |posts, match|\n    if date = Search.word_to_date(match)\n      posts.where(\"posts.created_at > ?\", date)\n    else\n      posts\n    end\n  end\n\n  advanced_filter(/^tags?:([\\p{L}\\p{M}0-9,\\-_+]+)$/i) do |posts, match|\n    search_tags(posts, match, positive: true)\n  end\n\n  advanced_filter(/^\\-tags?:([\\p{L}\\p{M}0-9,\\-_+]+)$/i) do |posts, match|\n    search_tags(posts, match, positive: false)\n  end\n\n  advanced_filter(/^filetypes?:([a-zA-Z0-9,\\-_]+)$/i) do |posts, match|\n    file_extensions = match.split(\",\").map(&:downcase)\n    posts.where(\"posts.id IN (\n      SELECT post_id\n        FROM topic_links\n       WHERE extension IN (:file_extensions)\n\n      UNION\n\n      SELECT post_uploads.post_id\n        FROM uploads\n        JOIN post_uploads ON post_uploads.upload_id = uploads.id\n       WHERE lower(uploads.extension) IN (:file_extensions)\n    )\", file_extensions: file_extensions)\n  end\n\n  advanced_filter(/^min_views:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.views >= ?\", match.to_i)\n  end\n\n  advanced_filter(/^max_views:(\\d+)$/i) do |posts, match|\n    posts.where(\"topics.views <= ?\", match.to_i)\n  end\n\n  private\n\n  def search_tags(posts, match, positive:)\n    return if match.nil?\n    match.downcase!\n    modifier = positive ? \"\" : \"NOT\"\n\n    if match.include?('+')\n      tags = match.split('+')\n\n      posts.where(\"topics.id #{modifier} IN (\n        SELECT tt.topic_id\n        FROM topic_tags tt, tags\n        WHERE tt.tag_id = tags.id\n        GROUP BY tt.topic_id\n        HAVING to_tsvector(#{default_ts_config}, array_to_string(array_agg(lower(tags.name)), ' ')) @@ to_tsquery(#{default_ts_config}, ?)\n      )\", tags.join('&'))\n    else\n      tags = match.split(\",\")\n\n      posts.where(\"topics.id #{modifier} IN (\n        SELECT DISTINCT(tt.topic_id)\n        FROM topic_tags tt, tags\n        WHERE tt.tag_id = tags.id AND lower(tags.name) IN (?)\n      )\", tags)\n    end\n  end\n\n  def process_advanced_search!(term)\n    term.to_s.scan(/(([^\" \\t\\n\\x0B\\f\\r]+)?((\"[^\"]+\")?))/).to_a.map do |(word, _)|\n      next if word.blank?\n\n      found = false\n\n      Search.advanced_filters.each do |matcher, block|\n        cleaned = word.gsub(/[\"']/, \"\")\n        if cleaned =~ matcher\n          (@filters ||= []) << [block, $1]\n          found = true\n        end\n      end\n\n      if word == 'l'\n        @order = :latest\n        nil\n      elsif word =~ /^order:\\w+$/i\n        @order = word.downcase.gsub('order:', '').to_sym\n        nil\n      elsif word =~ /^in:title$/i || word == 't'\n        @in_title = true\n        nil\n      elsif word =~ /^topic:(\\d+)$/i\n        topic_id = $1.to_i\n        if topic_id > 1\n          topic = Topic.find_by(id: topic_id)\n          if @guardian.can_see?(topic)\n            @search_context = topic\n          end\n        end\n        nil\n      elsif word =~ /^in:all$/i\n        @search_all_topics = true\n        nil\n      elsif word =~ /^in:personal$/i\n        @search_pms = true\n        nil\n      elsif word =~ /^in:personal-direct$/i\n        @search_pms = true\n        nil\n      elsif word =~ /^in:all-pms$/i\n        @search_all_pms = true\n        nil\n      elsif word =~ /^personal_messages:(.+)$/i\n        if user = User.find_by_username($1)\n          @search_pms = true\n          @search_context = user\n        end\n\n        nil\n      else\n        found ? nil : word\n      end\n    end.compact.join(' ')\n  end\n\n  def find_grouped_results\n    if @results.type_filter.present?\n      raise Discourse::InvalidAccess.new(\"invalid type filter\") unless Search.facets.include?(@results.type_filter)\n      # calling protected methods\n      send(\"#{@results.type_filter}_search\")\n    else\n      if @term.present? && !@search_context\n        user_search\n        category_search\n        tags_search\n        groups_search\n      end\n      topic_search\n    end\n\n    @results\n  rescue ActiveRecord::StatementInvalid\n    # In the event of a PG:Error return nothing, it is likely they used a foreign language whose\n    # locale is not supported by postgres\n  end\n\n  # If we're searching for a single topic\n  def single_topic(id)\n    if @opts[:restrict_to_archetype].present?\n      archetype = @opts[:restrict_to_archetype] == Archetype.default ? Archetype.default : Archetype.private_message\n\n      post = posts_scope\n        .joins(:topic)\n        .find_by(\n          \"topics.id = :id AND topics.archetype = :archetype AND posts.post_number = 1\",\n          id: id,\n          archetype: archetype\n        )\n    else\n      post = posts_scope.find_by(topic_id: id, post_number: 1)\n    end\n\n    return nil unless @guardian.can_see?(post)\n\n    @results.add(post)\n    @results\n  end\n\n  def secure_category_ids\n    return @secure_category_ids unless @secure_category_ids.nil?\n    @secure_category_ids = @guardian.secure_category_ids\n  end\n\n  def category_search\n    # scope is leaking onto Category, this is not good and probably a bug in Rails\n    # the secure_category_ids will invoke the same method on User, it calls Category.where\n    # however the scope from the query below is leaking in to Category, this works around\n    # the issue while we figure out what is up in Rails\n    secure_category_ids\n\n    categories = Category.includes(:category_search_data)\n      .where(\"category_search_data.search_data @@ #{ts_query}\")\n      .references(:category_search_data)\n      .order(\"topics_month DESC\")\n      .secured(@guardian)\n      .limit(limit)\n\n    categories.each do |category|\n      @results.add(category)\n    end\n  end\n\n  def user_search\n    return if SiteSetting.hide_user_profiles_from_public && !@guardian.user\n\n    users = User\n      .includes(:user_search_data)\n      .references(:user_search_data)\n      .where(active: true)\n      .where(staged: false)\n      .where(\"user_search_data.search_data @@ #{ts_query(\"simple\")}\")\n      .order(\"CASE WHEN username_lower = '#{@original_term.downcase}' THEN 0 ELSE 1 END\")\n      .order(\"last_posted_at DESC\")\n      .limit(limit)\n\n    if !SiteSetting.enable_listing_suspended_users_on_search && !@guardian.user&.admin\n      users = users.where(suspended_at: nil)\n    end\n\n    users_custom_data_query = DB.query(<<~SQL, user_ids: users.pluck(:id), term: \"%#{@original_term.downcase}%\")\n      SELECT user_custom_fields.user_id, user_fields.name, user_custom_fields.value FROM user_custom_fields\n      INNER JOIN user_fields ON user_fields.id = REPLACE(user_custom_fields.name, 'user_field_', '')::INTEGER AND user_fields.searchable IS TRUE\n      WHERE user_id IN (:user_ids)\n      AND user_custom_fields.name LIKE 'user_field_%'\n      AND user_custom_fields.value ILIKE :term\n    SQL\n    users_custom_data = users_custom_data_query.reduce({}) do |acc, row|\n      acc[row.user_id] =\n        Array.wrap(acc[row.user_id]) << {\n          name: row.name,\n          value: row.value\n        }\n      acc\n    end\n\n    users.each do |user|\n      user.custom_data = users_custom_data[user.id] || []\n      @results.add(user)\n    end\n  end\n\n  def groups_search\n    groups = Group\n      .visible_groups(@guardian.user, \"name ASC\", include_everyone: false)\n      .where(\"name ILIKE :term OR full_name ILIKE :term\", term: \"%#{@term}%\")\n      .limit(limit)\n\n    groups.each { |group| @results.add(group) }\n  end\n\n  def tags_search\n    return unless SiteSetting.tagging_enabled\n    tags = Tag.includes(:tag_search_data)\n      .where(\"tag_search_data.search_data @@ #{ts_query}\")\n      .references(:tag_search_data)\n      .order(\"name asc\")\n      .limit(limit)\n\n    hidden_tag_names = DiscourseTagging.hidden_tag_names(@guardian)\n\n    tags.each do |tag|\n      @results.add(tag) if !hidden_tag_names.include?(tag.name)\n    end\n  end\n\n  def exclude_topics_search\n    if @term.present?\n      user_search\n      category_search\n      tags_search\n      groups_search\n    end\n  end\n\n  PHRASE_MATCH_REGEXP_PATTERN = '\"([^\"]+)\"'\n\n  def posts_query(limit, type_filter: nil, aggregate_search: false)\n    posts = Post.where(post_type: Topic.visible_post_types(@guardian.user))\n      .joins(:post_search_data, :topic)\n\n    if type_filter != \"private_messages\"\n      posts = posts.joins(\"LEFT JOIN categories ON categories.id = topics.category_id\")\n    end\n\n    is_topic_search = @search_context.present? && @search_context.is_a?(Topic)\n    posts = posts.where(\"topics.visible\") unless is_topic_search\n\n    if type_filter == \"private_messages\" || (is_topic_search && @search_context.private_message?)\n      posts = posts\n        .where(\n          \"topics.archetype = ? AND post_search_data.private_message\",\n          Archetype.private_message\n        )\n\n      unless @guardian.is_admin?\n        posts = posts.private_posts_for_user(@guardian.user)\n      end\n    elsif type_filter == \"all_topics\"\n      private_posts = posts\n        .where(\n          \"topics.archetype = ? AND post_search_data.private_message\",\n          Archetype.private_message\n          )\n        .private_posts_for_user(@guardian.user)\n\n      posts = posts\n        .where(\n          \"topics.archetype <> ? AND NOT post_search_data.private_message\",\n          Archetype.private_message\n        )\n        .or(private_posts)\n    else\n      posts = posts.where(\n        \"topics.archetype <> ? AND NOT post_search_data.private_message\",\n        Archetype.private_message\n      )\n    end\n\n    if @term.present?\n      if is_topic_search\n\n        term_without_quote = @term\n        if @term =~ /\"(.+)\"/\n          term_without_quote = $1\n        end\n\n        if @term =~ /'(.+)'/\n          term_without_quote = $1\n        end\n\n        posts = posts.joins('JOIN users u ON u.id = posts.user_id')\n        posts = posts.where(\"posts.raw  || ' ' || u.username || ' ' || COALESCE(u.name, '') ilike ?\", \"%#{term_without_quote}%\")\n      else\n        # A is for title\n        # B is for category\n        # C is for tags\n        # D is for cooked\n        weights = @in_title ? 'A' : (SiteSetting.tagging_enabled ? 'ABCD' : 'ABD')\n        posts = posts.where(post_number: 1) if @in_title\n        posts = posts.where(\"post_search_data.search_data @@ #{ts_query(weight_filter: weights)}\")\n        exact_terms = @term.scan(Regexp.new(PHRASE_MATCH_REGEXP_PATTERN)).flatten\n\n        exact_terms.each do |exact|\n          posts = posts.where(\"posts.raw ilike :exact OR topics.title ilike :exact\", exact: \"%#{exact}%\")\n        end\n      end\n    end\n\n    @filters.each do |block, match|\n      if block.arity == 1\n        posts = instance_exec(posts, &block) || posts\n      else\n        posts = instance_exec(posts, match, &block) || posts\n      end\n    end if @filters\n\n    # If we have a search context, prioritize those posts first\n    posts =\n      if @search_context.present?\n        if @search_context.is_a?(User)\n          if type_filter == \"private_messages\"\n            if @guardian.is_admin? && !@search_all_pms\n              posts.private_posts_for_user(@search_context)\n            else\n              posts\n            end\n          else\n            posts.where(\"posts.user_id = #{@search_context.id}\")\n          end\n        elsif @search_context.is_a?(Category)\n          category_ids = Category\n            .where(parent_category_id: @search_context.id)\n            .pluck(:id)\n            .push(@search_context.id)\n\n          posts.where(\"topics.category_id in (?)\", category_ids)\n        elsif is_topic_search\n          posts.where(\"topics.id = #{@search_context.id}\")\n            .order(\"posts.post_number #{@order == :latest ? \"DESC\" : \"\"}\")\n        elsif @search_context.is_a?(Tag)\n          posts = posts\n            .joins(\"LEFT JOIN topic_tags ON topic_tags.topic_id = topics.id\")\n            .joins(\"LEFT JOIN tags ON tags.id = topic_tags.tag_id\")\n          posts.where(\"tags.id = #{@search_context.id}\")\n        end\n      else\n        posts = categories_ignored(posts) unless @category_filter_matched\n        posts\n      end\n\n    if @order == :latest\n      if aggregate_search\n        posts = posts.order(\"MAX(posts.created_at) DESC\")\n      else\n        posts = posts.reorder(\"posts.created_at DESC\")\n      end\n    elsif @order == :latest_topic\n      if aggregate_search\n        posts = posts.order(\"MAX(topics.created_at) DESC\")\n      else\n        posts = posts.order(\"topics.created_at DESC\")\n      end\n    elsif @order == :views\n      if aggregate_search\n        posts = posts.order(\"MAX(topics.views) DESC\")\n      else\n        posts = posts.order(\"topics.views DESC\")\n      end\n    elsif @order == :likes\n      if aggregate_search\n        posts = posts.order(\"MAX(posts.like_count) DESC\")\n      else\n        posts = posts.order(\"posts.like_count DESC\")\n      end\n    elsif !is_topic_search\n      rank = <<~SQL\n      TS_RANK_CD(\n        post_search_data.search_data,\n        #{@term.blank? ? '' : ts_query(weight_filter: weights)},\n        #{SiteSetting.search_ranking_normalization}|32\n      )\n      SQL\n\n      if type_filter != \"private_messages\"\n        category_search_priority = <<~SQL\n        (\n          CASE categories.search_priority\n          WHEN #{Searchable::PRIORITIES[:very_high]}\n          THEN 3\n          WHEN #{Searchable::PRIORITIES[:very_low]}\n          THEN 1\n          ELSE 2\n          END\n        )\n        SQL\n\n        category_priority_weights = <<~SQL\n        (\n          CASE categories.search_priority\n          WHEN #{Searchable::PRIORITIES[:low]}\n          THEN #{SiteSetting.category_search_priority_low_weight}\n          WHEN #{Searchable::PRIORITIES[:high]}\n          THEN #{SiteSetting.category_search_priority_high_weight}\n          ELSE\n            CASE WHEN topics.closed\n            THEN 0.9\n            ELSE 1\n            END\n          END\n        )\n        SQL\n\n        data_ranking =\n          if @term.blank?\n            \"(#{category_priority_weights})\"\n          else\n            \"(#{rank} * #{category_priority_weights})\"\n          end\n\n        posts =\n          if aggregate_search\n            posts.order(\"MAX(#{category_search_priority}) DESC\", \"MAX(#{data_ranking}) DESC\")\n          else\n            posts.order(\"#{category_search_priority} DESC\", \"#{data_ranking} DESC\")\n          end\n      end\n\n      posts = posts.order(\"topics.bumped_at DESC\")\n    end\n\n    if type_filter != \"private_messages\"\n      posts =\n        if secure_category_ids.present?\n          posts.where(\"(categories.id IS NULL) OR (NOT categories.read_restricted) OR (categories.id IN (?))\", secure_category_ids).references(:categories)\n        else\n          posts.where(\"(categories.id IS NULL) OR (NOT categories.read_restricted)\").references(:categories)\n        end\n    end\n\n    if @order\n      advanced_order = Search.advanced_orders&.fetch(@order, nil)\n      posts = advanced_order.call(posts) if advanced_order\n    end\n\n    posts = posts.offset(offset)\n    posts.limit(limit)\n  end\n\n  def categories_ignored(posts)\n    posts.where(<<~SQL, Searchable::PRIORITIES[:ignore])\n    (categories.search_priority IS NULL OR categories.search_priority IS NOT NULL AND categories.search_priority <> ?)\n    SQL\n  end\n\n  def self.default_ts_config\n    \"'#{Search.ts_config}'\"\n  end\n\n  def default_ts_config\n    self.class.default_ts_config\n  end\n\n  def self.ts_query(term: , ts_config:  nil, joiner: nil, weight_filter: nil)\n    to_tsquery(\n      ts_config: ts_config,\n      term: set_tsquery_weight_filter(term, weight_filter),\n      joiner: joiner\n    )\n  end\n\n  def self.to_tsquery(ts_config: nil, term:, joiner: nil)\n    ts_config = ActiveRecord::Base.connection.quote(ts_config) if ts_config\n    tsquery = \"TO_TSQUERY(#{ts_config || default_ts_config}, '#{self.escape_string(term)}')\"\n    tsquery = \"REPLACE(#{tsquery}::text, '&', '#{self.escape_string(joiner)}')::tsquery\" if joiner\n    tsquery\n  end\n\n  def self.set_tsquery_weight_filter(term, weight_filter)\n    \"'#{self.escape_string(term)}':*#{weight_filter}\"\n  end\n\n  def self.escape_string(term)\n    PG::Connection.escape_string(term).gsub('\\\\', '\\\\\\\\\\\\')\n  end\n\n  def ts_query(ts_config = nil, weight_filter: nil)\n    @ts_query_cache ||= {}\n    @ts_query_cache[\"#{ts_config || default_ts_config} #{@term} #{weight_filter}\"] ||=\n      Search.ts_query(term: @term, ts_config: ts_config, weight_filter: weight_filter)\n  end\n\n  def wrap_rows(query)\n    \"SELECT *, row_number() over() row_number FROM (#{query.to_sql}) xxx\"\n  end\n\n  def aggregate_post_sql(opts)\n    default_opts = {\n      type_filter: opts[:type_filter]\n    }\n\n    min_id =\n      if SiteSetting.search_recent_regular_posts_offset_post_id > 0\n        if %w{all_topics private_message}.include?(opts[:type_filter])\n          0\n        else\n          SiteSetting.search_recent_regular_posts_offset_post_id\n        end\n      else\n        # This is kept around for backwards compatibility.\n        # TODO: Drop this code path after Discourse 2.7 has been released.\n        Search.min_post_id\n      end\n\n    min_or_max = @order == :latest ? \"max\" : \"min\"\n\n    query =\n      if @order == :likes\n        # likes are a pain to aggregate so skip\n        posts_query(limit, type_filter: opts[:type_filter])\n          .select('topics.id', \"posts.post_number\")\n      else\n        posts_query(limit, aggregate_search: true, type_filter: opts[:type_filter])\n          .select('topics.id', \"#{min_or_max}(posts.post_number) post_number\")\n          .group('topics.id')\n      end\n\n    if min_id > 0\n      low_set = query.dup.where(\"post_search_data.post_id < #{min_id}\")\n      high_set = query.where(\"post_search_data.post_id >= #{min_id}\")\n\n      return { default: wrap_rows(high_set), remaining: wrap_rows(low_set) }\n    end\n\n    # double wrapping so we get correct row numbers\n    { default: wrap_rows(query) }\n  end\n\n  def aggregate_posts(post_sql)\n    return [] unless post_sql\n\n    posts_scope(posts_eager_loads(Post))\n      .joins(\"JOIN (#{post_sql}) x ON x.id = posts.topic_id AND x.post_number = posts.post_number\")\n      .order('row_number')\n  end\n\n  def aggregate_search(opts = {})\n    post_sql = aggregate_post_sql(opts)\n\n    added = 0\n\n    aggregate_posts(post_sql[:default]).each do |p|\n      @results.add(p)\n      added += 1\n    end\n\n    if added < limit\n      aggregate_posts(post_sql[:remaining]).each { |p| @results.add(p) }\n    end\n  end\n\n  def private_messages_search\n    raise Discourse::InvalidAccess.new(\"anonymous can not search PMs\") unless @guardian.user\n\n    aggregate_search(type_filter: \"private_messages\")\n  end\n\n  def all_topics_search\n    aggregate_search(type_filter: \"all_topics\")\n  end\n\n  def topic_search\n    if @search_context.is_a?(Topic)\n      posts = posts_scope(posts_eager_loads(posts_query(limit)))\n        .where('posts.topic_id = ?', @search_context.id)\n\n      posts.each do |post|\n        @results.add(post)\n      end\n    else\n      aggregate_search\n    end\n  end\n\n  def posts_eager_loads(query)\n    query = query.includes(:user, :post_search_data)\n    topic_eager_loads = [:category]\n\n    if SiteSetting.tagging_enabled\n      topic_eager_loads << :tags\n    end\n\n    Search.custom_topic_eager_loads.each do |custom_loads|\n      topic_eager_loads.concat(custom_loads.is_a?(Array) ? custom_loads : custom_loads.call(search_pms: @search_pms).to_a)\n    end\n\n    query.includes(topic: topic_eager_loads)\n  end\n\n  # Limited for performance reasons since `TS_HEADLINE` is slow when the text\n  # document is too long.\n  MAX_LENGTH_FOR_HEADLINE = 2500\n\n  def posts_scope(default_scope = Post.all)\n    if SiteSetting.use_pg_headlines_for_excerpt\n      search_term = @term.present? ? Search.escape_string(@term) : nil\n      ts_config = default_ts_config\n\n      default_scope\n        .joins(\"INNER JOIN post_search_data pd ON pd.post_id = posts.id\")\n        .joins(\"INNER JOIN topics t1 ON t1.id = posts.topic_id\")\n        .select(\n          \"TS_HEADLINE(\n            #{ts_config},\n            t1.fancy_title,\n            PLAINTO_TSQUERY(#{ts_config}, '#{search_term}'),\n            'StartSel=''<span class=\\\"#{HIGHLIGHT_CSS_CLASS}\\\">'', StopSel=''</span>'', HighlightAll=true'\n          ) AS topic_title_headline\",\n          \"TS_HEADLINE(\n            #{ts_config},\n            LEFT(\n              TS_HEADLINE(\n                #{ts_config},\n                LEFT(pd.raw_data, #{MAX_LENGTH_FOR_HEADLINE}),\n                PLAINTO_TSQUERY(#{ts_config}, '#{search_term}'),\n                'ShortWord=0, MaxFragments=1, MinWords=50, MaxWords=51, StartSel='''', StopSel='''''\n              ),\n              #{Search::GroupedSearchResults::BLURB_LENGTH}\n            ),\n            PLAINTO_TSQUERY(#{ts_config}, '#{search_term}'),\n            'HighlightAll=true, StartSel=''<span class=\\\"#{HIGHLIGHT_CSS_CLASS}\\\">'', StopSel=''</span>'''\n          ) AS headline\",\n          \"LEFT(pd.raw_data, 50) AS leading_raw_data\",\n          \"RIGHT(pd.raw_data, 50) AS trailing_raw_data\",\n          default_scope.arel.projections\n        )\n    else\n      default_scope\n    end\n  end\n\n  def log_query?(readonly_mode)\n    SiteSetting.log_search_queries? &&\n    @opts[:search_type].present? &&\n    !readonly_mode &&\n    @opts[:type_filter] != \"exclude_topics\"\n  end\nend\n", "# encoding: utf-8\n# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe Search do\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:topic) { Fabricate(:topic) }\n\n  before do\n    SearchIndexer.enable\n    Jobs.run_immediately!\n  end\n\n  context 'post indexing' do\n    fab!(:category) { Fabricate(:category_with_definition, name: 'america') }\n    fab!(:topic) { Fabricate(:topic, title: 'sam saffron test topic', category: category) }\n    let!(:post) { Fabricate(:post, topic: topic, raw: 'this <b>fun test</b> <img src=\"bla\" title=\"my image\">') }\n    let!(:post2) { Fabricate(:post, topic: topic) }\n\n    it \"should index correctly\" do\n      search_data = post.post_search_data.search_data\n\n      expect(search_data).to match(/fun/)\n      expect(search_data).to match(/sam/)\n      expect(search_data).to match(/america/)\n\n      expect do\n        topic.update!(title: \"harpi is the new title\")\n      end.to change { post2.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n\n      expect(post.post_search_data.reload.search_data).to match(/harpi/)\n    end\n\n    it 'should update posts index when topic category changes' do\n      expect do\n        topic.update!(category: Fabricate(:category))\n      end.to change { post.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n        .and change { post2.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n    end\n\n    it 'should update posts index when topic tags changes' do\n      SiteSetting.tagging_enabled = true\n      tag = Fabricate(:tag)\n\n      expect do\n        DiscourseTagging.tag_topic_by_names(topic, Guardian.new(admin), [tag.name])\n        topic.save!\n      end.to change { post.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n        .and change { post2.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n\n      expect(topic.tags).to eq([tag])\n    end\n  end\n\n  context 'user indexing' do\n    before do\n      @user = Fabricate(:user, username: 'fred', name: 'bob jones')\n      @indexed = @user.user_search_data.search_data\n    end\n\n    it \"should pick up on data\" do\n      expect(@indexed).to match(/fred/)\n      expect(@indexed).to match(/jone/)\n    end\n  end\n\n  context 'category indexing' do\n    let!(:category) { Fabricate(:category_with_definition, name: 'america') }\n    let!(:topic) { Fabricate(:topic, category: category) }\n    let!(:post) { Fabricate(:post, topic: topic) }\n    let!(:post2) { Fabricate(:post, topic: topic) }\n    let!(:post3) { Fabricate(:post) }\n\n    it \"should index correctly\" do\n      expect(category.category_search_data.search_data).to match(/america/)\n    end\n\n    it 'should update posts index when category name changes' do\n      expect do\n        category.update!(name: 'some new name')\n      end.to change { post.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n        .and change { post2.reload.post_search_data.version }.from(SearchIndexer::POST_INDEX_VERSION).to(SearchIndexer::REINDEX_VERSION)\n\n      expect(post3.post_search_data.version).to eq(SearchIndexer::POST_INDEX_VERSION)\n    end\n  end\n\n  it 'strips zero-width characters from search terms' do\n    term = \"\\u0063\\u0061\\u0070\\u0079\\u200b\\u200c\\u200d\\ufeff\\u0062\\u0061\\u0072\\u0061\".encode(\"UTF-8\")\n\n    expect(term == 'capybara').to eq(false)\n\n    search = Search.new(term)\n    expect(search.valid?).to eq(true)\n    expect(search.term).to eq('capybara')\n    expect(search.clean_term).to eq('capybara')\n  end\n\n  it 'replaces curly quotes to regular quotes in search terms' do\n    term = '\u201cdiscourse\u201d'\n\n    expect(term == '\"discourse\"').to eq(false)\n\n    search = Search.new(term)\n    expect(search.valid?).to eq(true)\n    expect(search.term).to eq('\"discourse\"')\n    expect(search.clean_term).to eq('\"discourse\"')\n  end\n\n  it 'does not search when the search term is too small' do\n    search = Search.new('evil', min_search_term_length: 5)\n    search.execute\n    expect(search.valid?).to eq(false)\n    expect(search.term).to eq('')\n  end\n\n  it 'needs at least one term that hits the length' do\n    search = Search.new('a b c d', min_search_term_length: 5)\n    search.execute\n    expect(search.valid?).to eq(false)\n    expect(search.term).to eq('')\n  end\n\n  it 'searches for quoted short terms' do\n    search = Search.new('\"a b c d\"', min_search_term_length: 5)\n    search.execute\n    expect(search.valid?).to eq(true)\n    expect(search.term).to eq('\"a b c d\"')\n  end\n\n  it 'searches for short terms if one hits the length' do\n    search = Search.new('a b c okaylength', min_search_term_length: 5)\n    search.execute\n    expect(search.valid?).to eq(true)\n    expect(search.term).to eq('a b c okaylength')\n  end\n\n  context 'query sanitization' do\n    let!(:post) { Fabricate(:post, raw: 'hello world') }\n\n    it 'escapes backslash' do\n      expect(Search.execute('hello\\\\').posts).to contain_exactly(post)\n    end\n\n    it 'escapes single quote' do\n      expect(Search.execute(\"hello'\").posts).to contain_exactly(post)\n    end\n\n    it 'escapes non-alphanumeric characters' do\n      expect(Search.execute('hello :!$);}]>@\\#\\\"\\'').posts).to contain_exactly(post)\n    end\n  end\n\n  it 'works when given two terms with spaces' do\n    expect { Search.execute('evil trout') }.not_to raise_error\n  end\n\n  context 'users' do\n    let!(:user) { Fabricate(:user) }\n    let(:result) { Search.execute('bruce', type_filter: 'user') }\n\n    it 'returns a result' do\n      expect(result.users.length).to eq(1)\n      expect(result.users[0].id).to eq(user.id)\n    end\n\n    context 'hiding user profiles' do\n      before { SiteSetting.hide_user_profiles_from_public = true }\n\n      it 'returns no result for anon' do\n        expect(result.users.length).to eq(0)\n      end\n\n      it 'returns a result for logged in users' do\n        result = Search.execute('bruce', type_filter: 'user', guardian: Guardian.new(user))\n        expect(result.users.length).to eq(1)\n      end\n\n    end\n\n  end\n\n  context 'inactive users' do\n    let!(:inactive_user) { Fabricate(:inactive_user, active: false) }\n    let(:result) { Search.execute('bruce') }\n\n    it 'does not return a result' do\n      expect(result.users.length).to eq(0)\n    end\n  end\n\n  context 'staged users' do\n    let(:staged) { Fabricate(:staged) }\n    let(:result) { Search.execute(staged.username) }\n\n    it 'does not return a result' do\n      expect(result.users.length).to eq(0)\n    end\n  end\n\n  context 'private messages' do\n    let!(:post) { Fabricate(:private_message_post) }\n\n    let(:topic) { post.topic }\n\n    let!(:reply) do\n      Fabricate(:private_message_post,\n        topic: post.topic,\n        raw: 'hello from mars, we just landed',\n        user: post.user\n      )\n    end\n\n    let!(:post2) do\n      Fabricate(:private_message_post,\n        raw: 'another secret pm from mars, testing'\n      )\n    end\n\n    it 'searches correctly as an admin' do\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        guardian: Guardian.new(admin)\n      )\n\n      expect(results.posts).to eq([])\n    end\n\n    it \"searches correctly as an admin given another user's context\" do\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        search_context: reply.user,\n        guardian: Guardian.new(admin)\n      )\n\n      expect(results.posts).to contain_exactly(reply)\n    end\n\n    it \"raises the right error when a normal user searches for another user's context\" do\n      expect do\n        Search.execute(\n          'mars',\n          search_context: reply.user,\n          type_filter: 'private_messages',\n          guardian: Guardian.new(Fabricate(:user))\n        )\n      end.to raise_error(Discourse::InvalidAccess)\n    end\n\n    it 'searches correctly as a user' do\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        guardian: Guardian.new(reply.user)\n      )\n\n      expect(results.posts).to contain_exactly(reply)\n    end\n\n    it 'searches correctly for a user with no private messages' do\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        guardian: Guardian.new(Fabricate(:user))\n       )\n\n      expect(results.posts).to eq([])\n    end\n\n    it 'searches correctly' do\n      expect do\n        Search.execute('mars', type_filter: 'private_messages')\n      end.to raise_error(Discourse::InvalidAccess)\n\n      results = Search.execute(\n        'mars',\n        type_filter: 'private_messages',\n        guardian: Guardian.new(reply.user)\n      )\n\n      expect(results.posts).to contain_exactly(reply)\n\n      results = Search.execute(\n        'mars',\n        search_context: topic,\n        guardian: Guardian.new(reply.user)\n      )\n\n      expect(results.posts).to contain_exactly(reply)\n\n      # can search group PMs as well as non admin\n      #\n      user = Fabricate(:user)\n      group = Fabricate.build(:group)\n      group.add(user)\n      group.save!\n\n      TopicAllowedGroup.create!(group_id: group.id, topic_id: topic.id)\n\n      [\"mars in:personal\", \"mars IN:PERSONAL\"].each do |query|\n        results = Search.execute(query, guardian: Guardian.new(user))\n        expect(results.posts).to contain_exactly(reply)\n      end\n    end\n\n    context 'personal_messages filter' do\n      it 'does not allow a normal user to search for personal messages of another user' do\n        expect do\n          Search.execute(\n            \"mars personal_messages:#{post.user.username}\",\n            guardian: Guardian.new(Fabricate(:user))\n          )\n        end.to raise_error(Discourse::InvalidAccess)\n      end\n\n      it 'searches correctly for the PM of the given user' do\n        results = Search.execute(\n          \"mars personal_messages:#{post.user.username}\",\n          guardian: Guardian.new(admin)\n        )\n\n        expect(results.posts).to contain_exactly(reply)\n      end\n\n      it 'returns the right results if username is invalid' do\n        results = Search.execute(\n          \"mars personal_messages:random_username\",\n          guardian: Guardian.new(admin)\n        )\n\n        expect(results.posts).to eq([])\n      end\n    end\n\n    context 'all-pms flag' do\n      it 'returns matching PMs if the user is an admin' do\n        results = Search.execute('mars in:all-pms', guardian: Guardian.new(admin))\n\n        expect(results.posts).to include(reply, post2)\n      end\n\n      it 'returns nothing if the user is not an admin' do\n        results = Search.execute('mars in:all-pms', guardian: Guardian.new(Fabricate(:user)))\n\n        expect(results.posts).to be_empty\n      end\n\n      it 'returns nothing if the user is a moderator' do\n        results = Search.execute('mars in:all-pms', guardian: Guardian.new(Fabricate(:moderator)))\n\n        expect(results.posts).to be_empty\n      end\n    end\n\n    context 'personal-direct flag' do\n      let(:current) { Fabricate(:user, admin: true, username: \"current_user\") }\n      let(:participant) { Fabricate(:user, username: \"participant_1\") }\n      let(:participant_2) { Fabricate(:user, username: \"participant_2\") }\n\n      let(:group) do\n        group = Fabricate(:group, has_messages: true)\n        group.add(current)\n        group.add(participant)\n        group\n      end\n\n      def create_pm(users:, group: nil)\n        pm = Fabricate(:private_message_post_one_user, user: users.first).topic\n        users[1..-1].each do |u|\n          pm.invite(users.first, u.username)\n          Fabricate(:post, user: u, topic: pm)\n        end\n        if group\n          pm.invite_group(users.first, group)\n          group.users.each do |u|\n            Fabricate(:post, user: u, topic: pm)\n          end\n        end\n        pm.reload\n      end\n\n      it 'can find all direct PMs of the current user' do\n        pm = create_pm(users: [current, participant])\n        _pm_2 = create_pm(users: [participant_2, participant])\n        pm_3 = create_pm(users: [participant, current])\n        pm_4 = create_pm(users: [participant_2, current])\n\n        [\"in:personal-direct\", \"In:PeRsOnAl-DiReCt\"].each do |query|\n          results = Search.execute(query, guardian: Guardian.new(current))\n          expect(results.posts.size).to eq(3)\n          expect(results.posts.map(&:topic_id)).to eq([pm_4.id, pm_3.id, pm.id])\n        end\n      end\n\n      it 'can filter direct PMs by @username' do\n        pm = create_pm(users: [current, participant])\n        pm_2 = create_pm(users: [participant, current])\n        pm_3 = create_pm(users: [participant_2, current])\n        [\n          \"@#{participant.username} in:personal-direct\",\n          \"@#{participant.username} iN:pErSoNaL-dIrEcT\",\n        ].each do |query|\n          results = Search.execute(query, guardian: Guardian.new(current))\n          expect(results.posts.size).to eq(2)\n          expect(results.posts.map(&:topic_id)).to contain_exactly(pm_2.id, pm.id)\n          expect(results.posts.map(&:user_id).uniq).to eq([participant.id])\n        end\n\n        results = Search.execute(\"@me in:personal-direct\", guardian: Guardian.new(current))\n        expect(results.posts.size).to eq(3)\n        expect(results.posts.map(&:topic_id)).to contain_exactly(pm_3.id, pm_2.id, pm.id)\n        expect(results.posts.map(&:user_id).uniq).to eq([current.id])\n      end\n\n      it \"doesn't include PMs that have more than 2 participants\" do\n        _pm = create_pm(users: [current, participant, participant_2])\n        results = Search.execute(\"@#{participant.username} in:personal-direct\", guardian: Guardian.new(current))\n        expect(results.posts.size).to eq(0)\n      end\n\n      it \"doesn't include PMs that have groups\" do\n        _pm = create_pm(users: [current, participant], group: group)\n        results = Search.execute(\"@#{participant.username} in:personal-direct\", guardian: Guardian.new(current))\n        expect(results.posts.size).to eq(0)\n      end\n    end\n\n    context 'all topics' do\n\n      let!(:u1) { Fabricate(:user, username: 'fred', name: 'bob jones', email: 'foo+1@bar.baz') }\n      let!(:u2) { Fabricate(:user, username: 'bob', name: 'fred jones', email: 'foo+2@bar.baz') }\n      let!(:u3) { Fabricate(:user, username: 'jones', name: 'bob fred', email: 'foo+3@bar.baz') }\n      let!(:u4) { Fabricate(:user, username: 'alice', name: 'bob fred', email: 'foo+4@bar.baz', admin: true) }\n\n      let!(:public_topic) { Fabricate(:topic, user: u1) }\n      let!(:public_post1) { Fabricate(:post, topic: public_topic, raw: \"what do you want for breakfast?  ham and eggs?\", user: u1) }\n      let!(:public_post2) { Fabricate(:post, topic: public_topic, raw: \"ham and spam\", user: u2) }\n\n      let!(:private_topic) { Fabricate(:topic, user: u1, category_id: nil, archetype: 'private_message') }\n      let!(:private_post1) { Fabricate(:post, topic: private_topic, raw: \"what do you want for lunch?  ham and cheese?\", user: u1) }\n      let!(:private_post2) { Fabricate(:post, topic: private_topic, raw: \"cheese and spam\", user: u2) }\n\n      it 'finds private messages' do\n        TopicAllowedUser.create!(user_id: u1.id, topic_id: private_topic.id)\n        TopicAllowedUser.create!(user_id: u2.id, topic_id: private_topic.id)\n\n        # case insensitive only\n        results = Search.execute('iN:aLL cheese', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(private_post1)\n\n        # private only\n        results = Search.execute('in:all cheese', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(private_post1)\n\n        # public only\n        results = Search.execute('in:all eggs', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(public_post1)\n\n        # both\n        results = Search.execute('in:all spam', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(public_post2, private_post2)\n\n        # for anon\n        results = Search.execute('in:all spam', guardian: Guardian.new)\n        expect(results.posts).to contain_exactly(public_post2)\n\n        # nonparticipatory user\n        results = Search.execute('in:all cheese', guardian: Guardian.new(u3))\n        expect(results.posts.empty?).to eq(true)\n\n        results = Search.execute('in:all eggs', guardian: Guardian.new(u3))\n        expect(results.posts).to contain_exactly(public_post1)\n\n        results = Search.execute('in:all spam', guardian: Guardian.new(u3))\n        expect(results.posts).to contain_exactly(public_post2)\n\n        # Admin doesn't see private topic\n        results = Search.execute('in:all spam', guardian: Guardian.new(u4))\n        expect(results.posts).to contain_exactly(public_post2)\n\n        # same keyword for different users\n        results = Search.execute('in:all ham', guardian: Guardian.new(u1))\n        expect(results.posts).to contain_exactly(public_post1, private_post1)\n\n        results = Search.execute('in:all ham', guardian: Guardian.new(u2))\n        expect(results.posts).to contain_exactly(public_post1, private_post1)\n\n        results = Search.execute('in:all ham', guardian: Guardian.new(u3))\n        expect(results.posts).to contain_exactly(public_post1)\n      end\n    end\n  end\n\n  context 'posts' do\n    fab!(:post) do\n      SearchIndexer.enable\n      Fabricate(:post)\n    end\n\n    let(:topic) { post.topic }\n\n    let!(:reply) do\n      Fabricate(:post_with_long_raw_content,\n        topic: topic,\n        user: topic.user,\n      ).tap { |post| post.update!(raw: \"#{post.raw} elephant\") }\n    end\n\n    let(:expected_blurb) do\n      \"#{Search::GroupedSearchResults::OMISSION}hundred characters to satisfy any test conditions that require content longer than the typical test post raw content. It really is some long content, folks. <span class=\\\"#{Search::HIGHLIGHT_CSS_CLASS}\\\">elephant</span>\"\n    end\n\n    it 'returns the post' do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      result = Search.execute('elephant',\n        type_filter: 'topic',\n        include_blurbs: true\n      )\n\n      expect(result.posts.map(&:id)).to contain_exactly(reply.id)\n\n      post = result.posts.first\n\n      expect(result.blurb(post)).to eq(expected_blurb)\n      expect(post.topic_title_headline).to eq(topic.fancy_title)\n    end\n\n    it \"only applies highlighting to the first #{Search::MAX_LENGTH_FOR_HEADLINE} characters\" do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      reply.update!(raw: \"#{'a' * Search::MAX_LENGTH_FOR_HEADLINE} #{reply.raw}\")\n\n      result = Search.execute('elephant')\n\n      expect(result.posts.map(&:id)).to contain_exactly(reply.id)\n\n      post = result.posts.first\n\n      expect(post.headline.include?('elephant')).to eq(false)\n    end\n\n    it \"does not truncate topic title when applying highlights\" do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      topic = reply.topic\n      topic.update!(title: \"#{'very ' * 7}long topic title with our search term in the middle of the title\")\n\n      result = Search.execute('search term')\n\n      expect(result.posts.first.topic_title_headline).to eq(<<~TITLE.chomp)\n      Very very very very very very very long topic title with our <span class=\\\"#{Search::HIGHLIGHT_CSS_CLASS}\\\">search</span> <span class=\\\"#{Search::HIGHLIGHT_CSS_CLASS}\\\">term</span> in the middle of the title\n      TITLE\n    end\n\n    it \"limits the search headline to #{Search::GroupedSearchResults::BLURB_LENGTH} characters\" do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      reply.update!(raw: \"#{'a' * Search::GroupedSearchResults::BLURB_LENGTH} elephant\")\n\n      result = Search.execute('elephant')\n\n      expect(result.posts.map(&:id)).to contain_exactly(reply.id)\n\n      post = result.posts.first\n\n      expect(result.blurb(post)).to eq(\"#{'a' * Search::GroupedSearchResults::BLURB_LENGTH}#{Search::GroupedSearchResults::OMISSION}\")\n    end\n\n    it 'returns the right post and blurb for searches with phrase' do\n      SiteSetting.use_pg_headlines_for_excerpt = true\n\n      result = Search.execute('\"elephant\"',\n        type_filter: 'topic',\n        include_blurbs: true\n      )\n\n      expect(result.posts.map(&:id)).to contain_exactly(reply.id)\n      expect(result.blurb(result.posts.first)).to eq(expected_blurb)\n    end\n\n    it 'applies a small penalty to closed topic when ranking' do\n      post = Fabricate(:post,\n        raw: \"My weekly update\",\n        topic: Fabricate(:topic,\n          title: \"A topic that will be closed\",\n          closed: true\n        )\n      )\n\n      post2 = Fabricate(:post,\n        raw: \"My weekly update\",\n        topic: Fabricate(:topic,\n          title: \"A topic that will be open\"\n        )\n      )\n\n      result = Search.execute('weekly update')\n      expect(result.posts.pluck(:id)).to eq([post2.id, post.id])\n    end\n\n    it 'aggregates searches in a topic by returning the post with the lowest post number' do\n      post = Fabricate(:post, topic: topic, raw: \"this is a play post\")\n      post2 = Fabricate(:post, topic: topic, raw: \"play play playing played play\")\n      post3 = Fabricate(:post, raw: \"this is a play post\")\n\n      5.times do\n        Fabricate(:post, topic: topic, raw: \"play playing played\")\n      end\n\n      results = Search.execute('play')\n\n      expect(results.posts.map(&:id)).to eq([\n        post.id,\n        post3.id\n      ])\n    end\n\n    it \"is able to search with an offset when configured\" do\n      post_1 = Fabricate(:post, raw: \"this is a play post\")\n      SiteSetting.search_recent_regular_posts_offset_post_id = post_1.id + 1\n\n      results = Search.execute('play post')\n\n      expect(results.posts).to eq([post_1])\n\n      post_2 = Fabricate(:post, raw: \"this is another play post\")\n\n      SiteSetting.search_recent_regular_posts_offset_post_id = post_2.id\n\n      results = Search.execute('play post')\n\n      expect(results.posts.map(&:id)).to eq([\n        post_2.id,\n        post_1.id\n      ])\n    end\n\n    it 'allows staff to search for whispers' do\n      post.update!(post_type: Post.types[:whisper], raw: 'this is a tiger')\n\n      results = Search.execute('tiger')\n\n      expect(results.posts).to eq([])\n\n      results = Search.execute('tiger', guardian: Guardian.new(admin))\n\n      expect(results.posts).to eq([post])\n    end\n  end\n\n  context 'topics' do\n    let(:post) { Fabricate(:post) }\n    let(:topic) { post.topic }\n\n    context 'search within topic' do\n\n      def new_post(raw, topic = nil, created_at: nil)\n        topic ||= Fabricate(:topic)\n        Fabricate(:post, topic: topic, topic_id: topic.id, user: topic.user, raw: raw, created_at: created_at)\n      end\n\n      it 'works in Chinese' do\n        SiteSetting.search_tokenize_chinese_japanese_korean = true\n        post = new_post('I am not in English \u4f55\u70b9\u306b\u306a\u308b\u3068\u601d\u3044\u307e\u3059\u304b')\n\n        results = Search.execute('\u4f55\u70b9\u306b\u306a\u308b\u3068\u601d', search_context: post.topic)\n        expect(results.posts.map(&:id)).to eq([post.id])\n      end\n\n      it 'displays multiple results within a topic' do\n        topic2 = Fabricate(:topic)\n\n        new_post('this is the other post I am posting', topic2, created_at: 6.minutes.ago)\n        new_post('this is my fifth post I am posting', topic2, created_at: 5.minutes.ago)\n\n        post1 = new_post('this is the other post I am posting', topic, created_at: 4.minutes.ago)\n        post2 = new_post('this is my first post I am posting', topic, created_at: 3.minutes.ago)\n        post3 = new_post('this is a real long and complicated bla this is my second post I am Posting birds with more stuff bla bla', topic, created_at: 2.minutes.ago)\n        post4 = new_post('this is my fourth post I am posting', topic, created_at: 1.minute.ago)\n\n        # update posts_count\n        topic.reload\n\n        results = Search.execute('posting', search_context: post1.topic)\n        expect(results.posts.map(&:id)).to eq([post1.id, post2.id, post3.id, post4.id])\n\n        results = Search.execute('posting l', search_context: post1.topic)\n        expect(results.posts.map(&:id)).to eq([post4.id, post3.id, post2.id, post1.id])\n\n        # stop words should work\n        results = Search.execute('this', search_context: post1.topic)\n        expect(results.posts.length).to eq(4)\n\n        # phrase search works as expected\n        results = Search.execute('\"fourth post I am posting\"', search_context: post1.topic)\n        expect(results.posts.length).to eq(1)\n      end\n\n      it \"works for unlisted topics\" do\n        topic.update(visible: false)\n        _post = new_post('discourse is awesome', topic)\n        results = Search.execute('discourse', search_context: topic)\n        expect(results.posts.length).to eq(1)\n      end\n    end\n\n    context 'searching the OP' do\n      let!(:post) { Fabricate(:post_with_long_raw_content) }\n      let(:result) { Search.execute('hundred', type_filter: 'topic') }\n\n      it 'returns a result correctly' do\n        expect(result.posts.length).to eq(1)\n        expect(result.posts[0].id).to eq(post.id)\n      end\n    end\n\n    context 'searching for quoted title' do\n      it \"can find quoted title\" do\n        create_post(raw: \"this is the raw body\", title: \"I am a title yeah\")\n        result = Search.execute('\"a title yeah\"')\n\n        expect(result.posts.length).to eq(1)\n      end\n\n    end\n\n    context \"search for a topic by id\" do\n      let(:result) { Search.execute(topic.id, type_filter: 'topic', search_for_id: true, min_search_term_length: 1) }\n\n      it 'returns the topic' do\n        expect(result.posts.length).to eq(1)\n        expect(result.posts.first.id).to eq(post.id)\n      end\n    end\n\n    context \"search for a topic by url\" do\n      it 'returns the topic' do\n        result = Search.execute(topic.relative_url, search_for_id: true, type_filter: 'topic')\n        expect(result.posts.length).to eq(1)\n        expect(result.posts.first.id).to eq(post.id)\n      end\n\n      context 'restrict_to_archetype' do\n        let(:personal_message) { Fabricate(:private_message_topic) }\n        let!(:p1) { Fabricate(:post, topic: personal_message, post_number: 1) }\n\n        it 'restricts result to topics' do\n          result = Search.execute(personal_message.relative_url, search_for_id: true, type_filter: 'topic', restrict_to_archetype: Archetype.default)\n          expect(result.posts.length).to eq(0)\n\n          result = Search.execute(topic.relative_url, search_for_id: true, type_filter: 'topic', restrict_to_archetype: Archetype.default)\n          expect(result.posts.length).to eq(1)\n        end\n\n        it 'restricts result to messages' do\n          result = Search.execute(topic.relative_url, search_for_id: true, type_filter: 'private_messages', guardian: Guardian.new(admin), restrict_to_archetype: Archetype.private_message)\n          expect(result.posts.length).to eq(0)\n\n          result = Search.execute(personal_message.relative_url, search_for_id: true, type_filter: 'private_messages', guardian: Guardian.new(admin), restrict_to_archetype: Archetype.private_message)\n          expect(result.posts.length).to eq(1)\n        end\n      end\n    end\n\n    context 'security' do\n\n      def result(current_user)\n        Search.execute('hello', guardian: Guardian.new(current_user))\n      end\n\n      it 'secures results correctly' do\n        category = Fabricate(:category_with_definition)\n\n        topic.category_id = category.id\n        topic.save\n\n        category.set_permissions(staff: :full)\n        category.save\n\n        expect(result(nil).posts).not_to be_present\n        expect(result(Fabricate(:user)).posts).not_to be_present\n        expect(result(admin).posts).to be_present\n\n      end\n    end\n\n  end\n\n  context 'cyrillic topic' do\n    let!(:cyrillic_topic) {\n      Fabricate(:topic) do\n        user\n        title { sequence(:title) { |i| \"\u0422\u0435\u0441\u0442\u043e\u0432\u0430\u044f \u0437\u0430\u043f\u0438\u0441\u044c #{i}\" } }\n      end\n    }\n\n    let!(:post) { Fabricate(:post, topic: cyrillic_topic, user: cyrillic_topic.user) }\n    let(:result) { Search.execute('\u0437\u0430\u043f\u0438\u0441\u044c') }\n\n    it 'finds something when given cyrillic query' do\n      expect(result.posts).to contain_exactly(post)\n    end\n  end\n\n  it 'does not tokenize search term' do\n    Fabricate(:post, raw: 'thing is canned should still be found!')\n    expect(Search.execute('canned').posts).to be_present\n  end\n\n  context 'categories' do\n    let(:category) { Fabricate(:category_with_definition, name: \"monkey Category 2\") }\n    let(:topic) { Fabricate(:topic, category: category) }\n    let!(:post) { Fabricate(:post, topic: topic, raw: \"snow monkey\") }\n\n    let!(:ignored_category) do\n      Fabricate(:category_with_definition,\n        name: \"monkey Category 1\",\n        slug: \"test\",\n        search_priority: Searchable::PRIORITIES[:ignore]\n      )\n    end\n\n    it \"should return the right categories\" do\n      search = Search.execute(\"monkey\")\n\n      expect(search.categories).to contain_exactly(\n        category, ignored_category\n      )\n\n      expect(search.posts).to eq([category.topic.first_post, post])\n\n      search = Search.execute(\"monkey #test\")\n\n      expect(search.posts).to eq([ignored_category.topic.first_post])\n    end\n\n    describe \"with child categories\" do\n      let!(:child_of_ignored_category) do\n        Fabricate(:category_with_definition,\n          name: \"monkey Category 3\",\n          parent_category: ignored_category\n        )\n      end\n\n      let!(:post2) do\n        Fabricate(:post,\n          topic: Fabricate(:topic, category: child_of_ignored_category),\n          raw: \"snow monkey park\"\n        )\n      end\n\n      it 'returns the right results' do\n        search = Search.execute(\"monkey\")\n\n        expect(search.categories).to contain_exactly(\n          category, ignored_category, child_of_ignored_category\n        )\n\n        expect(search.posts.map(&:id)).to eq([\n          child_of_ignored_category.topic.first_post,\n          category.topic.first_post,\n          post2,\n          post\n        ].map(&:id))\n\n        search = Search.execute(\"snow\")\n        expect(search.posts.map(&:id)).to eq([post2.id, post.id])\n\n        category.set_permissions({})\n        category.save!\n        search = Search.execute(\"monkey\")\n\n        expect(search.categories).to contain_exactly(\n          ignored_category, child_of_ignored_category\n        )\n\n        expect(search.posts.map(&:id)).to eq([\n          child_of_ignored_category.topic.first_post,\n          post2\n        ].map(&:id))\n      end\n    end\n\n    describe 'categories with different priorities' do\n      let(:category2) { Fabricate(:category_with_definition) }\n\n      it \"should return posts in the right order\" do\n        raw = \"The pure genuine evian\"\n        post = Fabricate(:post, topic: category.topic, raw: raw)\n        post2 = Fabricate(:post, topic: category2.topic, raw: raw)\n        post2.topic.update!(bumped_at: 10.seconds.from_now)\n\n        search = Search.execute(raw)\n\n        expect(search.posts.map(&:id)).to eq([post2.id, post.id])\n\n        category.update!(search_priority: Searchable::PRIORITIES[:high])\n\n        search = Search.execute(raw)\n\n        expect(search.posts.map(&:id)).to eq([post.id, post2.id])\n      end\n    end\n\n  end\n\n  context 'groups' do\n    def search(user = Fabricate(:user))\n      Search.execute(group.name, guardian: Guardian.new(user))\n    end\n\n    let!(:group) { Group[:trust_level_0] }\n\n    it 'shows group' do\n      expect(search.groups.map(&:name)).to eq([group.name])\n    end\n\n    context 'group visibility' do\n      let!(:group) { Fabricate(:group) }\n\n      before do\n        group.update!(visibility_level: 3)\n      end\n\n      context 'staff logged in' do\n        it 'shows group' do\n          expect(search(admin).groups.map(&:name)).to eq([group.name])\n        end\n      end\n\n      context 'non staff logged in' do\n        it 'shows doesn\u2019t show group' do\n          expect(search.groups.map(&:name)).to be_empty\n        end\n      end\n    end\n  end\n\n  context 'tags' do\n    def search\n      Search.execute(tag.name)\n    end\n\n    let!(:tag) { Fabricate(:tag) }\n    let!(:uppercase_tag) { Fabricate(:tag, name: \"HeLlO\") }\n    let(:tag_group) { Fabricate(:tag_group) }\n    let(:category) { Fabricate(:category_with_definition) }\n\n    context 'post searching' do\n      before do\n        SiteSetting.tagging_enabled = true\n        DiscourseTagging.tag_topic_by_names(post.topic, Guardian.new(Fabricate.build(:admin)), [tag.name, uppercase_tag.name])\n        post.topic.save\n      end\n\n      let(:post) { Fabricate(:post, raw: 'I am special post') }\n\n      it 'can find posts with tags' do\n        # we got to make this index (it is deferred)\n        Jobs::ReindexSearch.new.rebuild_posts\n\n        result = Search.execute(tag.name)\n        expect(result.posts.length).to eq(1)\n\n        result = Search.execute(\"hElLo\")\n        expect(result.posts.length).to eq(1)\n\n        SiteSetting.tagging_enabled = false\n\n        result = Search.execute(tag.name)\n        expect(result.posts.length).to eq(0)\n      end\n\n      it 'can find posts with tag synonyms' do\n        synonym = Fabricate(:tag, name: 'synonym', target_tag: tag)\n        Jobs::ReindexSearch.new.rebuild_posts\n        result = Search.execute(synonym.name)\n        expect(result.posts.length).to eq(1)\n      end\n    end\n\n    context 'tagging is disabled' do\n      before { SiteSetting.tagging_enabled = false }\n\n      it 'does not include tags' do\n        expect(search.tags).to_not be_present\n      end\n    end\n\n    context 'tagging is enabled' do\n      before { SiteSetting.tagging_enabled = true }\n\n      it 'returns the tag in the result' do\n        expect(search.tags).to eq([tag])\n      end\n\n      it 'shows staff tags' do\n        create_staff_only_tags([\"#{tag.name}9\"])\n\n        expect(Search.execute(tag.name, guardian: Guardian.new(admin)).tags.map(&:name)).to eq([tag.name, \"#{tag.name}9\"])\n        expect(search.tags.map(&:name)).to eq([tag.name, \"#{tag.name}9\"])\n      end\n\n      it 'includes category-restricted tags' do\n        category_tag = Fabricate(:tag, name: \"#{tag.name}9\")\n        tag_group.tags = [category_tag]\n        category.set_permissions(admins: :full)\n        category.allowed_tag_groups = [tag_group.name]\n        category.save!\n\n        expect(Search.execute(tag.name, guardian: Guardian.new(admin)).tags).to eq([tag, category_tag])\n        expect(search.tags).to eq([tag, category_tag])\n      end\n    end\n  end\n\n  context 'type_filter' do\n\n    let!(:user) { Fabricate(:user, username: 'amazing', email: 'amazing@amazing.com') }\n    let!(:category) { Fabricate(:category_with_definition, name: 'amazing category', user: user) }\n\n    context 'user filter' do\n      let(:results) { Search.execute('amazing', type_filter: 'user') }\n\n      it \"returns a user result\" do\n        expect(results.categories.length).to eq(0)\n        expect(results.posts.length).to eq(0)\n        expect(results.users.length).to eq(1)\n      end\n\n    end\n\n    context 'category filter' do\n      let(:results) { Search.execute('amazing', type_filter: 'category') }\n\n      it \"returns a category result\" do\n        expect(results.categories.length).to eq(1)\n        expect(results.posts.length).to eq(0)\n        expect(results.users.length).to eq(0)\n      end\n\n    end\n\n  end\n\n  context 'search_context' do\n\n    it 'can find a user when using search context' do\n\n      coding_horror = Fabricate(:coding_horror)\n      post = Fabricate(:post)\n\n      Fabricate(:post, user: coding_horror)\n\n      result = Search.execute('hello', search_context: post.user)\n\n      result.posts.first.topic_id = post.topic_id\n      expect(result.posts.length).to eq(1)\n    end\n\n    it 'can use category as a search context' do\n      category = Fabricate(:category_with_definition,\n        search_priority: Searchable::PRIORITIES[:ignore]\n      )\n\n      topic = Fabricate(:topic, category: category)\n      topic_no_cat = Fabricate(:topic)\n\n      # includes subcategory in search\n      subcategory = Fabricate(:category_with_definition, parent_category_id: category.id)\n      sub_topic = Fabricate(:topic, category: subcategory)\n\n      post = Fabricate(:post, topic: topic, user: topic.user)\n      Fabricate(:post, topic: topic_no_cat, user: topic.user)\n      sub_post = Fabricate(:post, raw: 'I am saying hello from a subcategory', topic: sub_topic, user: topic.user)\n\n      search = Search.execute('hello', search_context: category)\n      expect(search.posts.map(&:id)).to match_array([post.id, sub_post.id])\n      expect(search.posts.length).to eq(2)\n    end\n\n    it 'can use tag as a search context' do\n      tag = Fabricate(:tag, name: 'important-stuff')\n\n      topic_no_tag = Fabricate(:topic)\n      Fabricate(:topic_tag, tag: tag, topic: topic)\n\n      post = Fabricate(:post, topic: topic, user: topic.user, raw: 'This is my hello')\n      Fabricate(:post, topic: topic_no_tag, user: topic.user)\n\n      search = Search.execute('hello', search_context: tag)\n      expect(search.posts.map(&:id)).to contain_exactly(post.id)\n      expect(search.posts.length).to eq(1)\n    end\n\n  end\n\n  describe 'Chinese search' do\n    let(:sentence) { 'Discourse\u4e2d\u56fd\u7684\u57fa\u7840\u8bbe\u65bd\u7f51\u7edc\u6b63\u5728\u7ec4\u88c5' }\n    let(:sentence_t) { 'Discourse\u592a\u5e73\u5c71\u68ee\u6797\u904a\u6a02\u5340' }\n\n    it 'splits English / Chinese and filter out stop words' do\n      SiteSetting.default_locale = 'zh_CN'\n      data = Search.prepare_data(sentence).split(' ')\n      expect(data).to eq([\"Discourse\", \"\u4e2d\u56fd\", \"\u57fa\u7840\u8bbe\u65bd\", \"\u7f51\u7edc\", \"\u6b63\u5728\", \"\u7ec4\u88c5\"])\n    end\n\n    it 'splits for indexing and filter out stop words' do\n      SiteSetting.default_locale = 'zh_CN'\n      data = Search.prepare_data(sentence, :index).split(' ')\n      expect(data).to eq([\"Discourse\", \"\u4e2d\u56fd\", \"\u57fa\u7840\u8bbe\u65bd\", \"\u7f51\u7edc\", \"\u6b63\u5728\", \"\u7ec4\u88c5\"])\n    end\n\n    it 'splits English / Traditional Chinese and filter out stop words' do\n      SiteSetting.default_locale = 'zh_TW'\n      data = Search.prepare_data(sentence_t).split(' ')\n      expect(data).to eq([\"Discourse\", \"\u592a\u5e73\u5c71\", \"\u68ee\u6797\", \"\u904a\u6a02\u5340\"])\n    end\n\n    it 'finds chinese topic based on title' do\n      skip(\"skipped until pg app installs the db correctly\") if RbConfig::CONFIG[\"arch\"] =~ /darwin/\n\n      SiteSetting.default_locale = 'zh_TW'\n      SiteSetting.min_search_term_length = 1\n      topic = Fabricate(:topic, title: 'My Title Discourse\u793e\u5340\u6307\u5357')\n      post = Fabricate(:post, topic: topic)\n\n      expect(Search.execute('\u793e\u5340\u6307\u5357').posts.first.id).to eq(post.id)\n      expect(Search.execute('\u6307\u5357').posts.first.id).to eq(post.id)\n    end\n\n    it 'finds chinese topic based on title if tokenization is forced' do\n      skip(\"skipped until pg app installs the db correctly\") if RbConfig::CONFIG[\"arch\"] =~ /darwin/\n\n      SiteSetting.search_tokenize_chinese_japanese_korean = true\n      SiteSetting.min_search_term_length = 1\n\n      topic = Fabricate(:topic, title: 'My Title Discourse\u793e\u5340\u6307\u5357')\n      post = Fabricate(:post, topic: topic)\n\n      expect(Search.execute('\u793e\u5340\u6307\u5357').posts.first.id).to eq(post.id)\n      expect(Search.execute('\u6307\u5357').posts.first.id).to eq(post.id)\n    end\n  end\n\n  describe 'Advanced search' do\n\n    it 'supports pinned' do\n      Fabricate(:post, raw: 'hi this is a test 123 123', topic: topic)\n      _post = Fabricate(:post, raw: 'boom boom shake the room', topic: topic)\n\n      topic.update_pinned(true)\n\n      expect(Search.execute('boom in:pinned').posts.length).to eq(1)\n      expect(Search.execute('boom IN:PINNED').posts.length).to eq(1)\n    end\n\n    it 'supports wiki' do\n      topic_2 = Fabricate(:topic)\n      post = Fabricate(:post, raw: 'this is a test 248', wiki: true, topic: topic)\n      Fabricate(:post, raw: 'this is a test 248', wiki: false, topic: topic_2)\n\n      expect(Search.execute('test 248').posts.length).to eq(2)\n      expect(Search.execute('test 248 in:wiki').posts.first).to eq(post)\n      expect(Search.execute('test 248 IN:WIKI').posts.first).to eq(post)\n    end\n\n    it 'supports searching for posts that the user has seen/unseen' do\n      topic_2 = Fabricate(:topic)\n      post = Fabricate(:post, raw: 'logan is longan', topic: topic)\n      post_2 = Fabricate(:post, raw: 'longan is logan', topic: topic_2)\n\n      [post.user, topic.user].each do |user|\n        PostTiming.create!(\n          post_number: post.post_number,\n          topic: topic,\n          user: user,\n          msecs: 1\n        )\n      end\n\n      expect(post.seen?(post.user)).to eq(true)\n\n      expect(Search.execute('longan').posts.sort).to eq([post, post_2])\n\n      expect(Search.execute('longan in:seen', guardian: Guardian.new(post.user)).posts)\n        .to eq([post])\n\n      expect(Search.execute('longan IN:SEEN', guardian: Guardian.new(post.user)).posts)\n        .to eq([post])\n\n      expect(Search.execute('longan in:seen').posts.sort).to eq([post, post_2])\n\n      expect(Search.execute('longan in:seen', guardian: Guardian.new(post_2.user)).posts)\n        .to eq([])\n\n      expect(Search.execute('longan', guardian: Guardian.new(post_2.user)).posts.sort)\n        .to eq([post, post_2])\n\n      expect(Search.execute('longan in:unseen', guardian: Guardian.new(post_2.user)).posts.sort)\n        .to eq([post, post_2])\n\n      expect(Search.execute('longan in:unseen', guardian: Guardian.new(post.user)).posts)\n        .to eq([post_2])\n\n      expect(Search.execute('longan IN:UNSEEN', guardian: Guardian.new(post.user)).posts)\n        .to eq([post_2])\n    end\n\n    it 'supports before and after filters' do\n      time = Time.zone.parse('2001-05-20 2:55')\n      freeze_time(time)\n\n      post_1 = Fabricate(:post, raw: 'hi this is a test 123 123', created_at: time.months_ago(2))\n      post_2 = Fabricate(:post, raw: 'boom boom shake the room test')\n\n      expect(Search.execute('test before:1').posts).to contain_exactly(post_1)\n      expect(Search.execute('test before:2001-04-20').posts).to contain_exactly(post_1)\n      expect(Search.execute('test before:2001').posts).to eq([])\n      expect(Search.execute('test after:2001').posts).to contain_exactly(post_1, post_2)\n      expect(Search.execute('test before:monday').posts).to contain_exactly(post_1)\n      expect(Search.execute('test after:jan').posts).to contain_exactly(post_1, post_2)\n    end\n\n    it 'supports in:first, user:, @username' do\n      post_1 = Fabricate(:post, raw: 'hi this is a test 123 123', topic: topic)\n      post_2 = Fabricate(:post, raw: 'boom boom shake the room test', topic: topic)\n\n      expect(Search.execute('test in:first').posts).to contain_exactly(post_1)\n      expect(Search.execute('test IN:FIRST').posts).to contain_exactly(post_1)\n\n      expect(Search.execute('boom').posts).to contain_exactly(post_2)\n\n      expect(Search.execute('boom in:first').posts).to eq([])\n      expect(Search.execute('boom f').posts).to eq([])\n\n      expect(Search.execute('123 in:first').posts).to contain_exactly(post_1)\n      expect(Search.execute('123 f').posts).to contain_exactly(post_1)\n\n      expect(Search.execute('user:nobody').posts).to eq([])\n      expect(Search.execute(\"user:#{post_1.user.username}\").posts).to contain_exactly(post_1)\n      expect(Search.execute(\"user:#{post_1.user_id}\").posts).to contain_exactly(post_1)\n\n      expect(Search.execute(\"@#{post_1.user.username}\").posts).to contain_exactly(post_1)\n    end\n\n    context \"searching for posts made by users of a group\" do\n      fab!(:topic) { Fabricate(:topic, created_at: 3.months.ago) }\n      fab!(:user) { Fabricate(:user) }\n      fab!(:user_2) { Fabricate(:user) }\n      fab!(:user_3) { Fabricate(:user) }\n      fab!(:group) { Fabricate(:group, name: \"Like_a_Boss\").tap { |g| g.add(user) } }\n      fab!(:group_2) { Fabricate(:group).tap { |g| g.add(user_2) } }\n      let!(:post) { Fabricate(:post, raw: 'hi this is a test 123 123', topic: topic, user: user) }\n      let!(:post_2) { Fabricate(:post, user: user_2) }\n\n      it 'should not return any posts if group does not exist' do\n        group.update!(\n          visibility_level: Group.visibility_levels[:public],\n          members_visibility_level: Group.visibility_levels[:public]\n        )\n\n        expect(Search.execute('group:99999').posts).to eq([])\n      end\n\n      it 'should return the right posts for a public group' do\n        group.update!(\n          visibility_level: Group.visibility_levels[:public],\n          members_visibility_level: Group.visibility_levels[:public]\n        )\n\n        expect(Search.execute('group:like_a_boss').posts).to contain_exactly(post)\n        expect(Search.execute(\"group:#{group.id}\").posts).to contain_exactly(post)\n      end\n\n      it \"should return the right posts for a public group with members' visibility restricted to logged on users\" do\n        group.update!(\n          visibility_level: Group.visibility_levels[:public],\n          members_visibility_level: Group.visibility_levels[:logged_on_users]\n        )\n\n        expect(Search.execute(\"group:#{group.id}\").posts).to eq([])\n        expect(Search.execute(\"group:#{group.id}\", guardian: Guardian.new(user_3)).posts).to contain_exactly(post)\n      end\n\n      it \"should return the right posts for a group with visibility restricted to logged on users with members' visibility restricted to members\" do\n        group.update!(\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          members_visibility_level: Group.visibility_levels[:members]\n        )\n\n        expect(Search.execute(\"group:#{group.id}\").posts).to eq([])\n        expect(Search.execute(\"group:#{group.id}\", guardian: Guardian.new(user_3)).posts).to eq([])\n        expect(Search.execute(\"group:#{group.id}\", guardian: Guardian.new(user)).posts).to contain_exactly(post)\n      end\n    end\n\n    it 'supports badge' do\n\n      topic = Fabricate(:topic, created_at: 3.months.ago)\n      post = Fabricate(:post, raw: 'hi this is a test 123 123', topic: topic)\n\n      badge = Badge.create!(name: \"Like a Boss\", badge_type_id: 1)\n      UserBadge.create!(user_id: post.user_id, badge_id: badge.id, granted_at: 1.minute.ago, granted_by_id: -1)\n\n      expect(Search.execute('badge:\"like a boss\"').posts.length).to eq(1)\n      expect(Search.execute('BADGE:\"LIKE A BOSS\"').posts.length).to eq(1)\n      expect(Search.execute('badge:\"test\"').posts.length).to eq(0)\n    end\n\n    it 'can match exact phrases' do\n      post = Fabricate(:post, raw: %{this is a test post with 'a URL https://some.site.com/search?q=test.test.test some random text I have to add})\n      post2 = Fabricate(:post, raw: 'test URL post with')\n\n      expect(Search.execute(\"test post with 'a URL).posts\").posts).to eq([post2, post])\n      expect(Search.execute(%{\"test post with 'a URL\"}).posts).to eq([post])\n      expect(Search.execute(%{\"https://some.site.com/search?q=test.test.test\"}).posts).to eq([post])\n      expect(Search.execute(%{\" with 'a URL https://some.site.com/search?q=test.test.test\"}).posts).to eq([post])\n    end\n\n    it 'can search numbers correctly, and match exact phrases' do\n      post = Fabricate(:post, raw: '3.0 eta is in 2 days horrah')\n      post2 = Fabricate(:post, raw: '3.0 is eta in 2 days horrah')\n\n      expect(Search.execute('3.0 eta').posts).to eq([post, post2])\n      expect(Search.execute(\"'3.0 eta'\").posts).to eq([post, post2])\n      expect(Search.execute(\"\\\"3.0 eta\\\"\").posts).to contain_exactly(post)\n      expect(Search.execute('\"3.0, eta is\"').posts).to eq([])\n    end\n\n    it 'can find by status' do\n      public_category = Fabricate(:category, read_restricted: false)\n      post = Fabricate(:post, raw: 'hi this is a test 123 123')\n      topic = post.topic\n      topic.update(category: public_category)\n\n      private_category = Fabricate(:category, read_restricted: true)\n      post2 = Fabricate(:post, raw: 'hi this is another test 123 123')\n      second_topic = post2.topic\n      second_topic.update(category: private_category)\n\n      _post3 = Fabricate(:post, raw: \"another test!\", user: topic.user, topic: second_topic)\n\n      expect(Search.execute('test status:public').posts.length).to eq(1)\n      expect(Search.execute('test status:closed').posts.length).to eq(0)\n      expect(Search.execute('test status:open').posts.length).to eq(1)\n      expect(Search.execute('test STATUS:OPEN').posts.length).to eq(1)\n      expect(Search.execute('test posts_count:1').posts.length).to eq(1)\n      expect(Search.execute('test min_post_count:1').posts.length).to eq(1)\n      expect(Search.execute('test min_posts:1').posts.length).to eq(1)\n      expect(Search.execute('test max_posts:2').posts.length).to eq(1)\n\n      topic.update(closed: true)\n      second_topic.update(category: public_category)\n\n      expect(Search.execute('test status:public').posts.length).to eq(2)\n      expect(Search.execute('test status:closed').posts.length).to eq(1)\n      expect(Search.execute('status:closed').posts.length).to eq(1)\n      expect(Search.execute('test status:open').posts.length).to eq(1)\n\n      topic.update(archived: true, closed: false)\n      second_topic.update(closed: true)\n\n      expect(Search.execute('test status:archived').posts.length).to eq(1)\n      expect(Search.execute('test status:open').posts.length).to eq(0)\n\n      expect(Search.execute('test status:noreplies').posts.length).to eq(1)\n\n      expect(Search.execute('test in:likes', guardian: Guardian.new(topic.user)).posts.length).to eq(0)\n\n      expect(Search.execute('test in:posted', guardian: Guardian.new(topic.user)).posts.length).to eq(2)\n      expect(Search.execute('test In:PoStEd', guardian: Guardian.new(topic.user)).posts.length).to eq(2)\n\n      in_created = Search.execute('test in:created', guardian: Guardian.new(topic.user)).posts\n      created_by_user = Search.execute(\"test created:@#{topic.user.username}\", guardian: Guardian.new(topic.user)).posts\n      expect(in_created.length).to eq(1)\n      expect(created_by_user.length).to eq(1)\n      expect(in_created).to eq(created_by_user)\n\n      expect(Search.execute(\"test created:@#{second_topic.user.username}\", guardian: Guardian.new(topic.user)).posts.length).to eq(1)\n\n      new_user = Fabricate(:user)\n      expect(Search.execute(\"test created:@#{new_user.username}\", guardian: Guardian.new(topic.user)).posts.length).to eq(0)\n\n      TopicUser.change(topic.user.id, topic.id, notification_level: TopicUser.notification_levels[:tracking])\n      expect(Search.execute('test in:watching', guardian: Guardian.new(topic.user)).posts.length).to eq(0)\n      expect(Search.execute('test in:tracking', guardian: Guardian.new(topic.user)).posts.length).to eq(1)\n    end\n\n    it 'can find posts with images' do\n      post_uploaded = Fabricate(:post_with_uploaded_image)\n      Fabricate(:post)\n\n      CookedPostProcessor.new(post_uploaded).update_post_image\n\n      expect(Search.execute('with:images').posts.map(&:id)).to contain_exactly(post_uploaded.id)\n    end\n\n    it 'can find by latest' do\n      topic1 = Fabricate(:topic, title: 'I do not like that Sam I am')\n      post1 = Fabricate(:post, topic: topic1, created_at: 10.minutes.ago)\n      post2 = Fabricate(:post, raw: 'that Sam I am, that Sam I am', created_at: 5.minutes.ago)\n\n      expect(Search.execute('sam').posts.map(&:id)).to eq([post1.id, post2.id])\n      expect(Search.execute('sam ORDER:LATEST').posts.map(&:id)).to eq([post2.id, post1.id])\n      expect(Search.execute('sam l').posts.map(&:id)).to eq([post2.id, post1.id])\n      expect(Search.execute('l sam').posts.map(&:id)).to eq([post2.id, post1.id])\n    end\n\n    it 'can order by topic creation' do\n      today        = Date.today\n      yesterday    = 1.day.ago\n      two_days_ago = 2.days.ago\n      category = Fabricate(:category_with_definition)\n\n      old_topic = Fabricate(:topic,\n        title: 'First Topic, testing the created_at sort',\n        created_at: two_days_ago,\n        category: category\n      )\n\n      latest_topic = Fabricate(:topic,\n        title: 'Second Topic, testing the created_at sort',\n        created_at: yesterday,\n        category: category\n      )\n\n      old_relevant_topic_post = Fabricate(:post,\n        topic: old_topic,\n        created_at: yesterday,\n        raw: 'Relevant Relevant Topic'\n      )\n\n      latest_irrelevant_topic_post = Fabricate(:post,\n        topic: latest_topic,\n        created_at: today,\n        raw: 'Not Relevant'\n      )\n\n      # Expecting the default results\n      expect(Search.execute('Topic').posts.map(&:id)).to eq([\n        old_relevant_topic_post.id,\n        latest_irrelevant_topic_post.id,\n        category.topic.first_post.id\n      ])\n\n      # Expecting the ordered by topic creation results\n      expect(Search.execute('Topic order:latest_topic').posts.map(&:id)).to eq([\n        category.topic.first_post.id,\n        latest_irrelevant_topic_post.id,\n        old_relevant_topic_post.id\n      ])\n    end\n\n    it 'can order by topic views' do\n      topic = Fabricate(:topic, views: 1)\n      topic2 = Fabricate(:topic, views: 2)\n      post = Fabricate(:post, raw: 'Topic', topic: topic)\n      post2 = Fabricate(:post, raw: 'Topic', topic: topic2)\n\n      expect(Search.execute('Topic order:views').posts.map(&:id)).to eq([\n        post2.id,\n        post.id\n      ])\n    end\n\n    it 'can filter by topic views' do\n      topic = Fabricate(:topic, views: 100)\n      topic2 = Fabricate(:topic, views: 200)\n      post = Fabricate(:post, raw: 'Topic', topic: topic)\n      post2 = Fabricate(:post, raw: 'Topic', topic: topic2)\n\n      expect(Search.execute('Topic min_views:150').posts.map(&:id)).to eq([post2.id])\n      expect(Search.execute('Topic max_views:150').posts.map(&:id)).to eq([post.id])\n    end\n\n    it 'can search for terms with dots' do\n      post = Fabricate(:post, raw: 'Will.2000 Will.Bob.Bill...')\n      expect(Search.execute('bill').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('bob').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('2000').posts.map(&:id)).to eq([post.id])\n    end\n\n    it 'can search URLS correctly' do\n      post = Fabricate(:post, raw: 'i like http://wb.camra.org.uk/latest#test so yay')\n\n      expect(Search.execute('http://wb.camra.org.uk/latest#test').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('camra').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('http://wb').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('wb.camra').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('wb.camra.org').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('org.uk').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('camra.org.uk').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('wb.camra.org.uk').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('wb.camra.org.uk/latest').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('/latest#test').posts.map(&:id)).to eq([post.id])\n    end\n\n    it 'supports category slug and tags' do\n      # main category\n      category = Fabricate(:category_with_definition, name: 'category 24', slug: 'cateGory-24')\n      topic = Fabricate(:topic, created_at: 3.months.ago, category: category)\n      post = Fabricate(:post, raw: 'Sams first post', topic: topic)\n\n      expect(Search.execute('sams post #categoRy-24').posts.length).to eq(1)\n      expect(Search.execute(\"sams post category:#{category.id}\").posts.length).to eq(1)\n      expect(Search.execute('sams post #categoRy-25').posts.length).to eq(0)\n\n      sub_category = Fabricate(:category_with_definition, name: 'sub category', slug: 'sub-category', parent_category_id: category.id)\n      second_topic = Fabricate(:topic, created_at: 3.months.ago, category: sub_category)\n      Fabricate(:post, raw: 'sams second post', topic: second_topic)\n\n      expect(Search.execute(\"sams post category:categoRY-24\").posts.length).to eq(2)\n      expect(Search.execute(\"sams post category:=cAtegory-24\").posts.length).to eq(1)\n\n      expect(Search.execute(\"sams post #category-24\").posts.length).to eq(2)\n      expect(Search.execute(\"sams post #=category-24\").posts.length).to eq(1)\n      expect(Search.execute(\"sams post #sub-category\").posts.length).to eq(1)\n\n      expect(Search.execute(\"sams post #categoRY-24:SUB-category\").posts.length)\n        .to eq(1)\n\n      # tags\n      topic.tags = [Fabricate(:tag, name: 'alpha'), Fabricate(:tag, name: '\u043f\u0440\u0438\u0432\u0435\u0442'), Fabricate(:tag, name: 'HeLlO')]\n      expect(Search.execute('this is a test #alpha').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('this is a test #\u043f\u0440\u0438\u0432\u0435\u0442').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('this is a test #hElLo').posts.map(&:id)).to eq([post.id])\n      expect(Search.execute('this is a test #beta').posts.size).to eq(0)\n    end\n\n    it 'supports sub-sub category slugs' do\n\n      SiteSetting.max_category_nesting = 3\n\n      category = Fabricate(:category, name: 'top', slug: 'top')\n      sub = Fabricate(:category, name: 'middle', slug: 'middle', parent_category_id: category.id)\n      leaf = Fabricate(:category, name: 'leaf', slug: 'leaf', parent_category_id: sub.id)\n\n      topic = Fabricate(:topic, created_at: 3.months.ago, category: leaf)\n      _post = Fabricate(:post, raw: 'Sams first post', topic: topic)\n\n      expect(Search.execute('#Middle:leaf first post').posts.size).to eq(1)\n    end\n\n    it 'correctly handles #symbol when no tag or category match' do\n      Fabricate(:post, raw: 'testing #1 #9998')\n      results = Search.new('testing #1').execute\n      expect(results.posts.length).to eq(1)\n\n      results = Search.new('#9998').execute\n      expect(results.posts.length).to eq(1)\n\n      results = Search.new('#777').execute\n      expect(results.posts.length).to eq(0)\n\n      results = Search.new('xxx #:').execute\n      expect(results.posts.length).to eq(0)\n    end\n\n    context 'tags' do\n      fab!(:tag1) { Fabricate(:tag, name: 'lunch') }\n      fab!(:tag2) { Fabricate(:tag, name: 'eggs') }\n      fab!(:tag3) { Fabricate(:tag, name: 'sandwiches') }\n\n      fab!(:tag_group) do\n        group = TagGroup.create!(name: 'mid day')\n        TagGroupMembership.create!(tag_id: tag1.id, tag_group_id: group.id)\n        TagGroupMembership.create!(tag_id: tag3.id, tag_group_id: group.id)\n        group\n      end\n\n      fab!(:topic1) { Fabricate(:topic, tags: [tag2, Fabricate(:tag)]) }\n      fab!(:topic2) { Fabricate(:topic, tags: [tag2]) }\n      fab!(:topic3) { Fabricate(:topic, tags: [tag1, tag2]) }\n      fab!(:topic4) { Fabricate(:topic, tags: [tag1, tag2, tag3]) }\n      fab!(:topic5) { Fabricate(:topic, tags: [tag2, tag3]) }\n\n      def indexed_post(*args)\n        SearchIndexer.enable\n        Fabricate(:post, *args)\n      end\n\n      fab!(:post1) { indexed_post(topic: topic1) }\n      fab!(:post2) { indexed_post(topic: topic2) }\n      fab!(:post3) { indexed_post(topic: topic3) }\n      fab!(:post4) { indexed_post(topic: topic4) }\n      fab!(:post5) { indexed_post(topic: topic5) }\n\n      it 'can find posts by tag group' do\n        expect(Search.execute('#mid-day').posts.map(&:id)).to eq([\n          post5, post4, post3\n        ].map(&:id))\n      end\n\n      it 'can find posts with tag' do\n        post4 = Fabricate(:post, topic: topic3, raw: \"It probably doesn't help that they're green...\")\n\n        expect(Search.execute('green tags:eggs').posts.map(&:id)).to eq([post4.id])\n        expect(Search.execute('tags:plants').posts.size).to eq(0)\n      end\n\n      it 'can find posts with non-latin tag' do\n        topic.tags = [Fabricate(:tag, name: '\u3055\u3088\u3046\u306a\u3089')]\n        post = Fabricate(:post, raw: 'Testing post', topic: topic)\n\n        expect(Search.execute('tags:\u3055\u3088\u3046\u306a\u3089').posts.map(&:id)).to eq([post.id])\n      end\n\n      it 'can find posts with thai tag' do\n        topic.tags = [Fabricate(:tag, name: '\u0e40\u0e23\u0e0b\u0e34\u0e48\u0e19')]\n        post = Fabricate(:post, raw: 'Testing post', topic: topic)\n\n        expect(Search.execute('tags:\u0e40\u0e23\u0e0b\u0e34\u0e48\u0e19').posts.map(&:id)).to eq([post.id])\n      end\n\n      it 'can find posts with any tag from multiple tags' do\n        expect(Search.execute('tags:eggs,lunch').posts.map(&:id).sort).to eq([post1.id, post2.id, post3.id, post4.id, post5.id].sort)\n      end\n\n      it 'can find posts which contains all provided tags' do\n        expect(Search.execute('tags:lunch+eggs+sandwiches').posts.map(&:id)).to eq([post4.id].sort)\n        expect(Search.execute('tags:eggs+lunch+sandwiches').posts.map(&:id)).to eq([post4.id].sort)\n      end\n\n      it 'can find posts which contains provided tags and does not contain selected ones' do\n        expect(Search.execute('tags:eggs -tags:lunch').posts.map(&:id))\n          .to eq([post5, post2, post1].map(&:id))\n\n        expect(Search.execute('tags:eggs -tags:lunch+sandwiches').posts.map(&:id))\n          .to eq([post5, post3, post2, post1].map(&:id))\n\n        expect(Search.execute('tags:eggs -tags:lunch,sandwiches').posts.map(&:id))\n          .to eq([post2, post1].map(&:id))\n      end\n\n      it 'orders posts correctly when combining tags with categories or terms' do\n        cat1 = Fabricate(:category_with_definition, name: 'food')\n        topic6 = Fabricate(:topic, tags: [tag1, tag2], category: cat1)\n        topic7 = Fabricate(:topic, tags: [tag1, tag2, tag3], category: cat1)\n        post7 = Fabricate(:post, topic: topic6, raw: \"Wakey, wakey, eggs and bakey.\", like_count: 5, created_at: 2.minutes.ago)\n        post8 = Fabricate(:post, topic: topic7, raw: \"Bakey, bakey, eggs to makey.\", like_count: 2, created_at: 1.minute.ago)\n\n        expect(Search.execute('bakey tags:lunch order:latest').posts.map(&:id))\n          .to eq([post8.id, post7.id])\n\n        expect(Search.execute('#food tags:lunch order:latest').posts.map(&:id))\n          .to eq([post8.id, post7.id])\n\n        expect(Search.execute('#food tags:lunch order:likes').posts.map(&:id))\n          .to eq([post7.id, post8.id])\n      end\n\n    end\n\n    it \"can find posts which contains filetypes\" do\n      post1 = Fabricate(:post, raw: \"http://example.com/image.png\")\n\n      post2 = Fabricate(:post,\n        raw: \"Discourse logo\\n\"\\\n          \"http://example.com/logo.png\\n\"\\\n          \"http://example.com/vector_image.svg\"\n      )\n\n      post_with_upload = Fabricate(:post, uploads: [Fabricate(:upload)])\n      Fabricate(:post)\n\n      TopicLink.extract_from(post1)\n      TopicLink.extract_from(post2)\n\n      expect(Search.execute('filetype:svg').posts).to eq([post2])\n\n      expect(Search.execute('filetype:png').posts.map(&:id)).to eq([\n        post_with_upload, post2, post1\n      ].map(&:id))\n\n      expect(Search.execute('logo filetype:png').posts).to eq([post2])\n    end\n  end\n\n  context '#ts_query' do\n    it 'can parse complex strings using ts_query helper' do\n      str = +\" grigio:babel deprecated? \"\n      str << \"page page on Atmosphere](https://atmospherejs.com/grigio/babel)xxx: aaa.js:222 aaa'\\\"bbb\"\n\n      ts_query = Search.ts_query(term: str, ts_config: \"simple\")\n      expect { DB.exec(+\"SELECT to_tsvector('bbb') @@ \" << ts_query) }.to_not raise_error\n\n      ts_query = Search.ts_query(term: \"foo.bar/'&baz\", ts_config: \"simple\")\n      expect { DB.exec(+\"SELECT to_tsvector('bbb') @@ \" << ts_query) }.to_not raise_error\n      expect(ts_query).to include(\"baz\")\n    end\n\n    it 'escapes the term correctly' do\n      expect(Search.ts_query(term: 'Title with trailing backslash\\\\'))\n        .to eq(\"TO_TSQUERY('english', '''Title with trailing backslash\\\\\\\\\\\\\\\\'':*')\")\n\n      expect(Search.ts_query(term: \"Title with trailing quote'\"))\n        .to eq(\"TO_TSQUERY('english', '''Title with trailing quote'''''':*')\")\n    end\n  end\n\n  context '#word_to_date' do\n    it 'parses relative dates correctly' do\n      time = Time.zone.parse('2001-02-20 2:55')\n      freeze_time(time)\n\n      expect(Search.word_to_date('yesterday')).to eq(time.beginning_of_day.yesterday)\n      expect(Search.word_to_date('suNday')).to eq(Time.zone.parse('2001-02-18'))\n      expect(Search.word_to_date('thursday')).to eq(Time.zone.parse('2001-02-15'))\n      expect(Search.word_to_date('deCember')).to eq(Time.zone.parse('2000-12-01'))\n      expect(Search.word_to_date('deC')).to eq(Time.zone.parse('2000-12-01'))\n      expect(Search.word_to_date('january')).to eq(Time.zone.parse('2001-01-01'))\n      expect(Search.word_to_date('jan')).to eq(Time.zone.parse('2001-01-01'))\n\n      expect(Search.word_to_date('100')).to eq(time.beginning_of_day.days_ago(100))\n\n      expect(Search.word_to_date('invalid')).to eq(nil)\n    end\n\n    it 'parses absolute dates correctly' do\n      expect(Search.word_to_date('2001-1-20')).to eq(Time.zone.parse('2001-01-20'))\n      expect(Search.word_to_date('2030-10-2')).to eq(Time.zone.parse('2030-10-02'))\n      expect(Search.word_to_date('2030-10')).to eq(Time.zone.parse('2030-10-01'))\n      expect(Search.word_to_date('2030')).to eq(Time.zone.parse('2030-01-01'))\n      expect(Search.word_to_date('2030-01-32')).to eq(nil)\n      expect(Search.word_to_date('10000')).to eq(nil)\n    end\n  end\n\n  context \"#min_post_id\" do\n    it \"returns 0 when prefer_recent_posts is disabled\" do\n      SiteSetting.search_prefer_recent_posts = false\n      expect(Search.min_post_id_no_cache).to eq(0)\n    end\n\n    it \"returns a value when prefer_recent_posts is enabled\" do\n      SiteSetting.search_prefer_recent_posts = true\n      SiteSetting.search_recent_posts_size = 1\n\n      Fabricate(:post)\n      p2 = Fabricate(:post)\n\n      expect(Search.min_post_id_no_cache).to eq(p2.id)\n    end\n  end\n\n  context \"search_log_id\" do\n    it \"returns an id when the search succeeds\" do\n      s = Search.new(\n        'indiana jones',\n        search_type: :header,\n        ip_address: '127.0.0.1'\n      )\n      results = s.execute\n      expect(results.search_log_id).to be_present\n    end\n\n    it \"does not log search if search_type is not present\" do\n      s = Search.new('foo bar', ip_address: '127.0.0.1')\n      results = s.execute\n      expect(results.search_log_id).not_to be_present\n    end\n  end\n\n  context 'in:title' do\n    it 'allows for search in title' do\n      topic = Fabricate(:topic, title: 'I am testing a title search')\n      _post2 = Fabricate(:post, topic: topic, raw: 'this is the second post', post_number: 2)\n      post = Fabricate(:post, topic: topic, raw: 'this is the first post', post_number: 1)\n\n      results = Search.execute('title in:title')\n      expect(results.posts.map(&:id)).to eq([post.id])\n\n      results = Search.execute('title iN:tItLe')\n      expect(results.posts.map(&:id)).to eq([post.id])\n\n      results = Search.execute('first in:title')\n      expect(results.posts).to eq([])\n    end\n\n    it 'works irrespective of the order' do\n      topic = Fabricate(:topic, title: \"A topic about Discourse\")\n      Fabricate(:post, topic: topic, raw: \"This is another post\")\n      topic2 = Fabricate(:topic, title: \"This is another topic\")\n      Fabricate(:post, topic: topic2, raw: \"Discourse is awesome\")\n\n      results = Search.execute('Discourse in:title status:open')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('in:title status:open Discourse')\n      expect(results.posts.length).to eq(1)\n    end\n  end\n\n  context 'ignore_diacritics' do\n    before { SiteSetting.search_ignore_accents = true }\n    let!(:post1) { Fabricate(:post, raw: '\u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35 R\u00e1gis hello') }\n\n    it ('allows strips correctly') do\n      results = Search.execute('hello', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('ragis', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('R\u00e1gis', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      # TODO: this is a test we need to fix!\n      #expect(results.blurb(results.posts.first)).to include('R\u00e1gis')\n\n      results = Search.execute('\u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n    end\n  end\n\n  context 'CJK segmentation' do\n    before do\n      SiteSetting.search_tokenize_chinese_japanese_korean = true\n      SiteSetting.min_search_term_length = 1\n    end\n\n    let!(:post1) do\n      Fabricate(:post, raw: '\u5834\u30b5\u30a2\u30de\u30cd\u7e54\u4f01\u3046\u3044\u304b\u305b\u7af9\u57df\u30f1\u30a4\u30de\u7a42\u57fa\u30db\u795e3\u4e88\u8aad\u305a\u306d\u3044\u3071\u677e\u67fb\u30b9\u7981\u591a\u30b5\u30a6\u63d0\u61f8\u30a4\u3075\u5f15\u5c0f43\u6539\u3053\u3087\u30c9\u3081\u3002\u6df1\u3068\u3064\u3050\u4e3b\u601d\u6599\u8fb2\u305e\u304b\u30eb\u8005\u676f\u691c\u3081\u308b\u6d3b\u5206\u3048\u307b\u3065\u307c\u767d\u72a0')\n    end\n\n    it('does not include superfluous spaces in blurbs') do\n\n      results = Search.execute('\u3046\u3044\u304b\u305b\u7af9\u57df', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      expect(results.blurb(results.posts.first)).to include('\u3046\u3044\u304b\u305b\u7af9\u57df')\n\n    end\n\n  end\n\n  context 'include_diacritics' do\n    before { SiteSetting.search_ignore_accents = false }\n    let!(:post1) { Fabricate(:post, raw: '\u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35 R\u00e9gis hello') }\n\n    it ('allows strips correctly') do\n      results = Search.execute('hello', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('regis', type_filter: 'topic')\n      expect(results.posts.length).to eq(0)\n\n      results = Search.execute('R\u00e9gis', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n\n      expect(results.blurb(results.posts.first)).to include('R\u00e9gis')\n\n      results = Search.execute('\u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35', type_filter: 'topic')\n      expect(results.posts.length).to eq(1)\n    end\n  end\n\n  context 'pagination' do\n    let(:number_of_results) { 2 }\n    let!(:post1) { Fabricate(:post, raw: 'hello hello hello hello hello') }\n    let!(:post2) { Fabricate(:post, raw: 'hello hello hello hello') }\n    let!(:post3) { Fabricate(:post, raw: 'hello hello hello') }\n    let!(:post4) { Fabricate(:post, raw: 'hello hello') }\n    let!(:post5) { Fabricate(:post, raw: 'hello') }\n    before do\n      Search.stubs(:per_filter).returns(number_of_results)\n    end\n\n    it 'returns more results flag' do\n      results = Search.execute('hello', type_filter: 'topic')\n      results2 = Search.execute('hello', type_filter: 'topic', page: 2)\n\n      expect(results.posts.length).to eq(number_of_results)\n      expect(results.posts.map(&:id)).to eq([post1.id, post2.id])\n      expect(results.more_full_page_results).to eq(true)\n      expect(results2.posts.length).to eq(number_of_results)\n      expect(results2.posts.map(&:id)).to eq([post3.id, post4.id])\n      expect(results2.more_full_page_results).to eq(true)\n    end\n\n    it 'correctly search with page parameter' do\n      search = Search.new('hello', type_filter: 'topic', page: 3)\n      results = search.execute\n\n      expect(search.offset).to eq(2 * number_of_results)\n      expect(results.posts.length).to eq(1)\n      expect(results.posts).to eq([post5])\n      expect(results.more_full_page_results).to eq(nil)\n    end\n\n  end\n\n  context 'in:tagged' do\n    it 'allows for searching by presence of any tags' do\n      topic = Fabricate(:topic, title: 'I am testing a tagged search')\n      _post = Fabricate(:post, topic: topic, raw: 'this is the first post')\n      tag = Fabricate(:tag)\n      _topic_tag = Fabricate(:topic_tag, topic: topic, tag: tag)\n\n      results = Search.execute('in:untagged')\n      expect(results.posts.length).to eq(0)\n\n      results = Search.execute('in:tagged')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('In:TaGgEd')\n      expect(results.posts.length).to eq(1)\n    end\n  end\n\n  context 'in:untagged' do\n    it 'allows for searching by presence of no tags' do\n      topic = Fabricate(:topic, title: 'I am testing a untagged search')\n      _post = Fabricate(:post, topic: topic, raw: 'this is the first post')\n\n      results = Search.execute('iN:uNtAgGeD')\n      expect(results.posts.length).to eq(1)\n\n      results = Search.execute('in:tagged')\n      expect(results.posts.length).to eq(0)\n    end\n  end\n\n  context 'plugin extensions' do\n    let!(:post0) { Fabricate(:post, raw: 'this is the first post about advanced filter with length more than 50 chars') }\n    let!(:post1) { Fabricate(:post, raw: 'this is the second post about advanced filter') }\n\n    it 'allows to define custom filter' do\n      expect(Search.new(\"advanced\").execute.posts).to eq([post1, post0])\n      Search.advanced_filter(/^min_chars:(\\d+)$/) do |posts, match|\n        posts.where(\"(SELECT LENGTH(p2.raw) FROM posts p2 WHERE p2.id = posts.id) >= ?\", match.to_i)\n      end\n      expect(Search.new(\"advanced min_chars:50\").execute.posts).to eq([post0])\n    end\n\n    it 'allows to define custom order' do\n      expect(Search.new(\"advanced\").execute.posts).to eq([post1, post0])\n\n      Search.advanced_order(:chars) do |posts|\n        posts.reorder(\"MAX(LENGTH(posts.raw)) DESC\")\n      end\n\n      expect(Search.new(\"advanced order:chars\").execute.posts).to eq([post0, post1])\n    end\n  end\n\n  context 'exclude_topics filter' do\n    before { SiteSetting.tagging_enabled = true }\n    let!(:user) { Fabricate(:user) }\n    fab!(:group) { Fabricate(:group, name: 'bruce-world-fans') }\n    fab!(:topic) { Fabricate(:topic, title: 'Bruce topic not a result') }\n\n    it 'works' do\n      category = Fabricate(:category_with_definition, name: 'bruceland', user: user)\n      tag = Fabricate(:tag, name: 'brucealicious')\n\n      result = Search.execute('bruce', type_filter: 'exclude_topics')\n\n      expect(result.users.map(&:id)).to contain_exactly(user.id)\n\n      expect(result.categories.map(&:id)).to contain_exactly(category.id)\n\n      expect(result.groups.map(&:id)).to contain_exactly(group.id)\n\n      expect(result.tags.map(&:id)).to contain_exactly(tag.id)\n\n      expect(result.posts.length).to eq(0)\n    end\n\n    it 'does not fail when parsed term is empty' do\n      result = Search.execute('#cat ', type_filter: 'exclude_topics')\n      expect(result.categories.length).to eq(0)\n    end\n  end\nend\n"], "filenames": ["lib/search.rb", "spec/components/search_spec.rb"], "buggy_code_start_loc": [586, 1251], "buggy_code_end_loc": [587, 1260], "fixing_code_start_loc": [586, 1251], "fixing_code_end_loc": [591, 1300], "type": "CWE-200", "message": "Discourse is an open source discussion platform. Discourse groups can be configured with varying visibility levels for the group as well as the group members. By default, a newly created group has its visibility set to public and the group's members visibility set to public as well. However, a group's visibility and the group's members visibility can be configured such that it is restricted to logged on users, members of the group or staff users. A vulnerability has been discovered in versions prior to 2.7.13 and 2.8.0.beta11 where the group advanced search option does not respect the group's visibility and members visibility level. As such, a group with restricted visibility or members visibility can be revealed through search with the right search option. This issue is patched in `stable` version 2.7.13, `beta` version 2.8.0.beta11, and `tests-passed` version 2.8.0.beta11 versions of Discourse. There are no workarounds aside from upgrading.", "other": {"cve": {"id": "CVE-2022-21677", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-14T17:15:13.153", "lastModified": "2022-01-21T14:23:27.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. Discourse groups can be configured with varying visibility levels for the group as well as the group members. By default, a newly created group has its visibility set to public and the group's members visibility set to public as well. However, a group's visibility and the group's members visibility can be configured such that it is restricted to logged on users, members of the group or staff users. A vulnerability has been discovered in versions prior to 2.7.13 and 2.8.0.beta11 where the group advanced search option does not respect the group's visibility and members visibility level. As such, a group with restricted visibility or members visibility can be revealed through search with the right search option. This issue is patched in `stable` version 2.7.13, `beta` version 2.8.0.beta11, and `tests-passed` version 2.8.0.beta11 versions of Discourse. There are no workarounds aside from upgrading."}, {"lang": "es", "value": "Discourse es una plataforma de discusi\u00f3n de c\u00f3digo abierto. Los grupos de Discourse pueden ser configurados con diferentes niveles de visibilidad para el grupo as\u00ed como para los miembros del grupo. Por defecto, un grupo reci\u00e9n creado presenta su visibilidad establecida como p\u00fablica y la de los miembros del grupo tambi\u00e9n. Sin embargo, la visibilidad de un grupo y la de sus miembros puede configurarse de forma que restrinja a usuarios conectados, a los miembros del grupo o a usuarios del personal. Se ha detectado una vulnerabilidad en las versiones anteriores a la 2.7.13 y 2.8.0.beta11 en la que la opci\u00f3n de b\u00fasqueda avanzada de grupos no respeta el nivel de visibilidad del grupo y de los miembros. De este modo, un grupo con visibilidad restringida o con visibilidad de miembros puede ser revelado mediante una b\u00fasqueda con la opci\u00f3n de b\u00fasqueda correcta. Este problema est\u00e1 parcheado en las versiones \"stable\" 2.7.13, \"beta\" 2.8.0.beta11 y \"tests-passed\" 2.8.0.beta11 de Discourse. No se presentan medidas de mitigaci\u00f3n adicionales aparte de la actualizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.7.12", "matchCriteriaId": "90644EF6-8581-4711-A415-1886D3199768"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "9E7F8AC4-35D1-45E5-8A3A-B0205000A5D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "7A24507D-6D4B-4992-BCFE-232AF3BFCC30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "B9AE12FE-0396-4843-8D30-D8C44FAE01DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "F101AEAB-4FB7-4BE3-931B-595702D616C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "F6878B7F-2691-4D3F-8116-CB282FDAAAC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "76EABAB9-BEA4-48D4-ADBA-D00746B29C52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "82A255A2-4658-41AD-A4DE-A7F8D018028D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "E5804585-2EA4-4677-8EC1-5F561D5C7D7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "082A6871-080A-4AA7-AF4A-D664EA46488A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "8A280205-A2DC-4E30-937B-5564C779FD5A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/fff8b98485561b12d070c0a8c39f4e503813ab44", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-768r-ppv4-5r27", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/fff8b98485561b12d070c0a8c39f4e503813ab44"}}