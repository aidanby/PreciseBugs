{"buggy_code": ["/*\n * Copyright (c) 2014-2015 Hisilicon Limited.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/delay.h>\n#include <linux/of_mdio.h>\n#include \"hns_dsaf_main.h\"\n#include \"hns_dsaf_mac.h\"\n#include \"hns_dsaf_gmac.h\"\n\nstatic const struct mac_stats_string g_gmac_stats_string[] = {\n\t{\"gmac_rx_octets_total_ok\", MAC_STATS_FIELD_OFF(rx_good_bytes)},\n\t{\"gmac_rx_octets_bad\", MAC_STATS_FIELD_OFF(rx_bad_bytes)},\n\t{\"gmac_rx_uc_pkts\", MAC_STATS_FIELD_OFF(rx_uc_pkts)},\n\t{\"gmac_rx_mc_pkts\", MAC_STATS_FIELD_OFF(rx_mc_pkts)},\n\t{\"gmac_rx_bc_pkts\", MAC_STATS_FIELD_OFF(rx_bc_pkts)},\n\t{\"gmac_rx_pkts_64octets\", MAC_STATS_FIELD_OFF(rx_64bytes)},\n\t{\"gmac_rx_pkts_65to127\", MAC_STATS_FIELD_OFF(rx_65to127)},\n\t{\"gmac_rx_pkts_128to255\", MAC_STATS_FIELD_OFF(rx_128to255)},\n\t{\"gmac_rx_pkts_256to511\", MAC_STATS_FIELD_OFF(rx_256to511)},\n\t{\"gmac_rx_pkts_512to1023\", MAC_STATS_FIELD_OFF(rx_512to1023)},\n\t{\"gmac_rx_pkts_1024to1518\", MAC_STATS_FIELD_OFF(rx_1024to1518)},\n\t{\"gmac_rx_pkts_1519tomax\", MAC_STATS_FIELD_OFF(rx_1519tomax)},\n\t{\"gmac_rx_fcs_errors\", MAC_STATS_FIELD_OFF(rx_fcs_err)},\n\t{\"gmac_rx_tagged\", MAC_STATS_FIELD_OFF(rx_vlan_pkts)},\n\t{\"gmac_rx_data_err\", MAC_STATS_FIELD_OFF(rx_data_err)},\n\t{\"gmac_rx_align_errors\", MAC_STATS_FIELD_OFF(rx_align_err)},\n\t{\"gmac_rx_long_errors\", MAC_STATS_FIELD_OFF(rx_oversize)},\n\t{\"gmac_rx_jabber_errors\", MAC_STATS_FIELD_OFF(rx_jabber_err)},\n\t{\"gmac_rx_pause_maccontrol\", MAC_STATS_FIELD_OFF(rx_pfc_tc0)},\n\t{\"gmac_rx_unknown_maccontrol\", MAC_STATS_FIELD_OFF(rx_unknown_ctrl)},\n\t{\"gmac_rx_very_long_err\", MAC_STATS_FIELD_OFF(rx_long_err)},\n\t{\"gmac_rx_runt_err\", MAC_STATS_FIELD_OFF(rx_minto64)},\n\t{\"gmac_rx_short_err\", MAC_STATS_FIELD_OFF(rx_under_min)},\n\t{\"gmac_rx_filt_pkt\", MAC_STATS_FIELD_OFF(rx_filter_pkts)},\n\t{\"gmac_rx_octets_total_filt\", MAC_STATS_FIELD_OFF(rx_filter_bytes)},\n\t{\"gmac_rx_overrun_cnt\", MAC_STATS_FIELD_OFF(rx_fifo_overrun_err)},\n\t{\"gmac_rx_length_err\", MAC_STATS_FIELD_OFF(rx_len_err)},\n\t{\"gmac_rx_fail_comma\", MAC_STATS_FIELD_OFF(rx_comma_err)},\n\n\t{\"gmac_tx_octets_ok\", MAC_STATS_FIELD_OFF(tx_good_bytes)},\n\t{\"gmac_tx_octets_bad\", MAC_STATS_FIELD_OFF(tx_bad_bytes)},\n\t{\"gmac_tx_uc_pkts\", MAC_STATS_FIELD_OFF(tx_uc_pkts)},\n\t{\"gmac_tx_mc_pkts\", MAC_STATS_FIELD_OFF(tx_mc_pkts)},\n\t{\"gmac_tx_bc_pkts\", MAC_STATS_FIELD_OFF(tx_bc_pkts)},\n\t{\"gmac_tx_pkts_64octets\", MAC_STATS_FIELD_OFF(tx_64bytes)},\n\t{\"gmac_tx_pkts_65to127\", MAC_STATS_FIELD_OFF(tx_65to127)},\n\t{\"gmac_tx_pkts_128to255\", MAC_STATS_FIELD_OFF(tx_128to255)},\n\t{\"gmac_tx_pkts_256to511\", MAC_STATS_FIELD_OFF(tx_256to511)},\n\t{\"gmac_tx_pkts_512to1023\", MAC_STATS_FIELD_OFF(tx_512to1023)},\n\t{\"gmac_tx_pkts_1024to1518\", MAC_STATS_FIELD_OFF(tx_1024to1518)},\n\t{\"gmac_tx_pkts_1519tomax\", MAC_STATS_FIELD_OFF(tx_1519tomax)},\n\t{\"gmac_tx_excessive_length_drop\", MAC_STATS_FIELD_OFF(tx_jabber_err)},\n\t{\"gmac_tx_underrun\", MAC_STATS_FIELD_OFF(tx_underrun_err)},\n\t{\"gmac_tx_tagged\", MAC_STATS_FIELD_OFF(tx_vlan)},\n\t{\"gmac_tx_crc_error\", MAC_STATS_FIELD_OFF(tx_crc_err)},\n\t{\"gmac_tx_pause_frames\", MAC_STATS_FIELD_OFF(tx_pfc_tc0)}\n};\n\nstatic void hns_gmac_enable(void *mac_drv, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t/*enable GE rX/tX */\n\tif ((mode == MAC_COMM_MODE_TX) || (mode == MAC_COMM_MODE_RX_AND_TX))\n\t\tdsaf_set_dev_bit(drv, GMAC_PORT_EN_REG, GMAC_PORT_TX_EN_B, 1);\n\n\tif ((mode == MAC_COMM_MODE_RX) || (mode == MAC_COMM_MODE_RX_AND_TX))\n\t\tdsaf_set_dev_bit(drv, GMAC_PORT_EN_REG, GMAC_PORT_RX_EN_B, 1);\n}\n\nstatic void hns_gmac_disable(void *mac_drv, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t/*disable GE rX/tX */\n\tif ((mode == MAC_COMM_MODE_TX) || (mode == MAC_COMM_MODE_RX_AND_TX))\n\t\tdsaf_set_dev_bit(drv, GMAC_PORT_EN_REG, GMAC_PORT_TX_EN_B, 0);\n\n\tif ((mode == MAC_COMM_MODE_RX) || (mode == MAC_COMM_MODE_RX_AND_TX))\n\t\tdsaf_set_dev_bit(drv, GMAC_PORT_EN_REG, GMAC_PORT_RX_EN_B, 0);\n}\n\n/* hns_gmac_get_en - get port enable\n * @mac_drv:mac device\n * @rx:rx enable\n * @tx:tx enable\n */\nstatic void hns_gmac_get_en(void *mac_drv, u32 *rx, u32 *tx)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 porten;\n\n\tporten = dsaf_read_dev(drv, GMAC_PORT_EN_REG);\n\t*tx = dsaf_get_bit(porten, GMAC_PORT_TX_EN_B);\n\t*rx = dsaf_get_bit(porten, GMAC_PORT_RX_EN_B);\n}\n\nstatic void hns_gmac_free(void *mac_drv)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct dsaf_device *dsaf_dev\n\t\t= (struct dsaf_device *)dev_get_drvdata(drv->dev);\n\n\tu32 mac_id = drv->mac_id;\n\n\tdsaf_dev->misc_op->ge_srst(dsaf_dev, mac_id, 0);\n}\n\nstatic void hns_gmac_set_tx_auto_pause_frames(void *mac_drv, u16 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_field(drv, GMAC_FC_TX_TIMER_REG, GMAC_FC_TX_TIMER_M,\n\t\t\t   GMAC_FC_TX_TIMER_S, newval);\n}\n\nstatic void hns_gmac_get_tx_auto_pause_frames(void *mac_drv, u16 *newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*newval = dsaf_get_dev_field(drv, GMAC_FC_TX_TIMER_REG,\n\t\t\t\t     GMAC_FC_TX_TIMER_M, GMAC_FC_TX_TIMER_S);\n}\n\nstatic void hns_gmac_set_rx_auto_pause_frames(void *mac_drv, u32 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_PAUSE_EN_REG,\n\t\t\t GMAC_PAUSE_EN_RX_FDFC_B, !!newval);\n}\n\nstatic void hns_gmac_config_max_frame_length(void *mac_drv, u16 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_field(drv, GMAC_MAX_FRM_SIZE_REG, GMAC_MAX_FRM_SIZE_M,\n\t\t\t   GMAC_MAX_FRM_SIZE_S, newval);\n\n\tdsaf_set_dev_field(drv, GAMC_RX_MAX_FRAME, GMAC_MAX_FRM_SIZE_M,\n\t\t\t   GMAC_MAX_FRM_SIZE_S, newval);\n}\n\nstatic void hns_gmac_config_pad_and_crc(void *mac_drv, u8 newval)\n{\n\tu32 tx_ctrl;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\ttx_ctrl = dsaf_read_dev(drv, GMAC_TRANSMIT_CONTROL_REG);\n\tdsaf_set_bit(tx_ctrl, GMAC_TX_PAD_EN_B, !!newval);\n\tdsaf_set_bit(tx_ctrl, GMAC_TX_CRC_ADD_B, !!newval);\n\tdsaf_write_dev(drv, GMAC_TRANSMIT_CONTROL_REG, tx_ctrl);\n}\n\nstatic void hns_gmac_config_an_mode(void *mac_drv, u8 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_TRANSMIT_CONTROL_REG,\n\t\t\t GMAC_TX_AN_EN_B, !!newval);\n}\n\nstatic void hns_gmac_tx_loop_pkt_dis(void *mac_drv)\n{\n\tu32 tx_loop_pkt_pri;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\ttx_loop_pkt_pri = dsaf_read_dev(drv, GMAC_TX_LOOP_PKT_PRI_REG);\n\tdsaf_set_bit(tx_loop_pkt_pri, GMAC_TX_LOOP_PKT_EN_B, 1);\n\tdsaf_set_bit(tx_loop_pkt_pri, GMAC_TX_LOOP_PKT_HIG_PRI_B, 0);\n\tdsaf_write_dev(drv, GMAC_TX_LOOP_PKT_PRI_REG, tx_loop_pkt_pri);\n}\n\nstatic void hns_gmac_set_duplex_type(void *mac_drv, u8 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_DUPLEX_TYPE_REG,\n\t\t\t GMAC_DUPLEX_TYPE_B, !!newval);\n}\n\nstatic void hns_gmac_get_duplex_type(void *mac_drv,\n\t\t\t\t     enum hns_gmac_duplex_mdoe *duplex_mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*duplex_mode = (enum hns_gmac_duplex_mdoe)dsaf_get_dev_bit(\n\t\tdrv, GMAC_DUPLEX_TYPE_REG, GMAC_DUPLEX_TYPE_B);\n}\n\nstatic void hns_gmac_get_port_mode(void *mac_drv, enum hns_port_mode *port_mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*port_mode = (enum hns_port_mode)dsaf_get_dev_field(\n\t\tdrv, GMAC_PORT_MODE_REG, GMAC_PORT_MODE_M, GMAC_PORT_MODE_S);\n}\n\nstatic void hns_gmac_port_mode_get(void *mac_drv,\n\t\t\t\t   struct hns_gmac_port_mode_cfg *port_mode)\n{\n\tu32 tx_ctrl;\n\tu32 recv_ctrl;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tport_mode->port_mode = (enum hns_port_mode)dsaf_get_dev_field(\n\t\tdrv, GMAC_PORT_MODE_REG, GMAC_PORT_MODE_M, GMAC_PORT_MODE_S);\n\n\ttx_ctrl = dsaf_read_dev(drv, GMAC_TRANSMIT_CONTROL_REG);\n\trecv_ctrl = dsaf_read_dev(drv, GMAC_RECV_CONTROL_REG);\n\n\tport_mode->max_frm_size =\n\t\tdsaf_get_dev_field(drv, GMAC_MAX_FRM_SIZE_REG,\n\t\t\t\t   GMAC_MAX_FRM_SIZE_M, GMAC_MAX_FRM_SIZE_S);\n\tport_mode->short_runts_thr =\n\t\tdsaf_get_dev_field(drv, GMAC_SHORT_RUNTS_THR_REG,\n\t\t\t\t   GMAC_SHORT_RUNTS_THR_M,\n\t\t\t\t   GMAC_SHORT_RUNTS_THR_S);\n\n\tport_mode->pad_enable = dsaf_get_bit(tx_ctrl, GMAC_TX_PAD_EN_B);\n\tport_mode->crc_add = dsaf_get_bit(tx_ctrl, GMAC_TX_CRC_ADD_B);\n\tport_mode->an_enable = dsaf_get_bit(tx_ctrl, GMAC_TX_AN_EN_B);\n\n\tport_mode->runt_pkt_en =\n\t\tdsaf_get_bit(recv_ctrl, GMAC_RECV_CTRL_RUNT_PKT_EN_B);\n\tport_mode->strip_pad_en =\n\t\tdsaf_get_bit(recv_ctrl, GMAC_RECV_CTRL_STRIP_PAD_EN_B);\n}\n\nstatic void hns_gmac_pause_frm_cfg(void *mac_drv, u32 rx_pause_en,\n\t\t\t\t   u32 tx_pause_en)\n{\n\tu32 pause_en;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tpause_en = dsaf_read_dev(drv, GMAC_PAUSE_EN_REG);\n\tdsaf_set_bit(pause_en, GMAC_PAUSE_EN_RX_FDFC_B, !!rx_pause_en);\n\tdsaf_set_bit(pause_en, GMAC_PAUSE_EN_TX_FDFC_B, !!tx_pause_en);\n\tdsaf_write_dev(drv, GMAC_PAUSE_EN_REG, pause_en);\n}\n\nstatic void hns_gmac_get_pausefrm_cfg(void *mac_drv, u32 *rx_pause_en,\n\t\t\t\t      u32 *tx_pause_en)\n{\n\tu32 pause_en;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tpause_en = dsaf_read_dev(drv, GMAC_PAUSE_EN_REG);\n\n\t*rx_pause_en = dsaf_get_bit(pause_en, GMAC_PAUSE_EN_RX_FDFC_B);\n\t*tx_pause_en = dsaf_get_bit(pause_en, GMAC_PAUSE_EN_TX_FDFC_B);\n}\n\nstatic int hns_gmac_adjust_link(void *mac_drv, enum mac_speed speed,\n\t\t\t\tu32 full_duplex)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_DUPLEX_TYPE_REG,\n\t\t\t GMAC_DUPLEX_TYPE_B, !!full_duplex);\n\n\tswitch (speed) {\n\tcase MAC_SPEED_10:\n\t\tdsaf_set_dev_field(\n\t\t\tdrv, GMAC_PORT_MODE_REG,\n\t\t\tGMAC_PORT_MODE_M, GMAC_PORT_MODE_S, 0x6);\n\t\tbreak;\n\tcase MAC_SPEED_100:\n\t\tdsaf_set_dev_field(\n\t\t\tdrv, GMAC_PORT_MODE_REG,\n\t\t\tGMAC_PORT_MODE_M, GMAC_PORT_MODE_S, 0x7);\n\t\tbreak;\n\tcase MAC_SPEED_1000:\n\t\tdsaf_set_dev_field(\n\t\t\tdrv, GMAC_PORT_MODE_REG,\n\t\t\tGMAC_PORT_MODE_M, GMAC_PORT_MODE_S, 0x8);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(drv->dev,\n\t\t\t\"hns_gmac_adjust_link fail, speed%d mac%d\\n\",\n\t\t\tspeed, drv->mac_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hns_gmac_set_uc_match(void *mac_drv, u16 en)\n{\n\tstruct mac_driver *drv = mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_REC_FILT_CONTROL_REG,\n\t\t\t GMAC_UC_MATCH_EN_B, !en);\n\tdsaf_set_dev_bit(drv, GMAC_STATION_ADDR_HIGH_2_REG,\n\t\t\t GMAC_ADDR_EN_B, !en);\n}\n\nstatic void hns_gmac_set_promisc(void *mac_drv, u8 en)\n{\n\tstruct mac_driver *drv = mac_drv;\n\n\tif (drv->mac_cb->mac_type == HNAE_PORT_DEBUG)\n\t\thns_gmac_set_uc_match(mac_drv, en);\n}\n\nstatic void hns_gmac_init(void *mac_drv)\n{\n\tu32 port;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct dsaf_device *dsaf_dev\n\t\t= (struct dsaf_device *)dev_get_drvdata(drv->dev);\n\n\tport = drv->mac_id;\n\n\tdsaf_dev->misc_op->ge_srst(dsaf_dev, port, 0);\n\tmdelay(10);\n\tdsaf_dev->misc_op->ge_srst(dsaf_dev, port, 1);\n\tmdelay(10);\n\thns_gmac_disable(mac_drv, MAC_COMM_MODE_RX_AND_TX);\n\thns_gmac_tx_loop_pkt_dis(mac_drv);\n\tif (drv->mac_cb->mac_type == HNAE_PORT_DEBUG)\n\t\thns_gmac_set_uc_match(mac_drv, 0);\n\n\thns_gmac_config_pad_and_crc(mac_drv, 1);\n\n\tdsaf_set_dev_bit(drv, GMAC_MODE_CHANGE_EN_REG,\n\t\t\t GMAC_MODE_CHANGE_EB_B, 1);\n\n\t/* reduce gmac tx water line to avoid gmac hang-up\n\t * in speed 100M and duplex half.\n\t */\n\tdsaf_set_dev_field(drv, GMAC_TX_WATER_LINE_REG, GMAC_TX_WATER_LINE_MASK,\n\t\t\t   GMAC_TX_WATER_LINE_SHIFT, 8);\n}\n\nvoid hns_gmac_update_stats(void *mac_drv)\n{\n\tstruct mac_hw_stats *hw_stats = NULL;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\thw_stats = &drv->mac_cb->hw_stats;\n\n\t/* RX */\n\thw_stats->rx_good_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_RX_OCTETS_TOTAL_OK_REG);\n\thw_stats->rx_bad_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_RX_OCTETS_BAD_REG);\n\thw_stats->rx_uc_pkts += dsaf_read_dev(drv, GMAC_RX_UC_PKTS_REG);\n\thw_stats->rx_mc_pkts += dsaf_read_dev(drv, GMAC_RX_MC_PKTS_REG);\n\thw_stats->rx_bc_pkts += dsaf_read_dev(drv, GMAC_RX_BC_PKTS_REG);\n\thw_stats->rx_64bytes\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_64OCTETS_REG);\n\thw_stats->rx_65to127\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_65TO127OCTETS_REG);\n\thw_stats->rx_128to255\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_128TO255OCTETS_REG);\n\thw_stats->rx_256to511\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_255TO511OCTETS_REG);\n\thw_stats->rx_512to1023\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_512TO1023OCTETS_REG);\n\thw_stats->rx_1024to1518\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_1024TO1518OCTETS_REG);\n\thw_stats->rx_1519tomax\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_1519TOMAXOCTETS_REG);\n\thw_stats->rx_fcs_err += dsaf_read_dev(drv, GMAC_RX_FCS_ERRORS_REG);\n\thw_stats->rx_vlan_pkts += dsaf_read_dev(drv, GMAC_RX_TAGGED_REG);\n\thw_stats->rx_data_err += dsaf_read_dev(drv, GMAC_RX_DATA_ERR_REG);\n\thw_stats->rx_align_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_ALIGN_ERRORS_REG);\n\thw_stats->rx_oversize\n\t\t+= dsaf_read_dev(drv, GMAC_RX_LONG_ERRORS_REG);\n\thw_stats->rx_jabber_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_JABBER_ERRORS_REG);\n\thw_stats->rx_pfc_tc0\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PAUSE_MACCTRL_FRAM_REG);\n\thw_stats->rx_unknown_ctrl\n\t\t+= dsaf_read_dev(drv, GMAC_RX_UNKNOWN_MACCTRL_FRAM_REG);\n\thw_stats->rx_long_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_VERY_LONG_ERR_CNT_REG);\n\thw_stats->rx_minto64\n\t\t+= dsaf_read_dev(drv, GMAC_RX_RUNT_ERR_CNT_REG);\n\thw_stats->rx_under_min\n\t\t+= dsaf_read_dev(drv, GMAC_RX_SHORT_ERR_CNT_REG);\n\thw_stats->rx_filter_pkts\n\t\t+= dsaf_read_dev(drv, GMAC_RX_FILT_PKT_CNT_REG);\n\thw_stats->rx_filter_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_RX_OCTETS_TOTAL_FILT_REG);\n\thw_stats->rx_fifo_overrun_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_OVERRUN_CNT_REG);\n\thw_stats->rx_len_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_LENGTHFIELD_ERR_CNT_REG);\n\thw_stats->rx_comma_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_FAIL_COMMA_CNT_REG);\n\n\t/* TX */\n\thw_stats->tx_good_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_OCTETS_TRANSMITTED_OK_REG);\n\thw_stats->tx_bad_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_OCTETS_TRANSMITTED_BAD_REG);\n\thw_stats->tx_uc_pkts += dsaf_read_dev(drv, GMAC_TX_UC_PKTS_REG);\n\thw_stats->tx_mc_pkts += dsaf_read_dev(drv, GMAC_TX_MC_PKTS_REG);\n\thw_stats->tx_bc_pkts += dsaf_read_dev(drv, GMAC_TX_BC_PKTS_REG);\n\thw_stats->tx_64bytes\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_64OCTETS_REG);\n\thw_stats->tx_65to127\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_65TO127OCTETS_REG);\n\thw_stats->tx_128to255\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_128TO255OCTETS_REG);\n\thw_stats->tx_256to511\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_255TO511OCTETS_REG);\n\thw_stats->tx_512to1023\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_512TO1023OCTETS_REG);\n\thw_stats->tx_1024to1518\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_1024TO1518OCTETS_REG);\n\thw_stats->tx_1519tomax\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_1519TOMAXOCTETS_REG);\n\thw_stats->tx_jabber_err\n\t\t+= dsaf_read_dev(drv, GMAC_TX_EXCESSIVE_LENGTH_DROP_REG);\n\thw_stats->tx_underrun_err\n\t\t+= dsaf_read_dev(drv, GMAC_TX_UNDERRUN_REG);\n\thw_stats->tx_vlan += dsaf_read_dev(drv, GMAC_TX_TAGGED_REG);\n\thw_stats->tx_crc_err += dsaf_read_dev(drv, GMAC_TX_CRC_ERROR_REG);\n\thw_stats->tx_pfc_tc0\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PAUSE_FRAMES_REG);\n}\n\nstatic void hns_gmac_set_mac_addr(void *mac_drv, char *mac_addr)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tu32 high_val = mac_addr[1] | (mac_addr[0] << 8);\n\n\tu32 low_val = mac_addr[5] | (mac_addr[4] << 8)\n\t\t| (mac_addr[3] << 16) | (mac_addr[2] << 24);\n\n\tu32 val = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG);\n\tu32 sta_addr_en = dsaf_get_bit(val, GMAC_ADDR_EN_B);\n\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_LOW_2_REG, low_val);\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG,\n\t\t       high_val | (sta_addr_en << GMAC_ADDR_EN_B));\n}\n\nstatic int hns_gmac_config_loopback(void *mac_drv, enum hnae_loop loop_mode,\n\t\t\t\t    u8 enable)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tswitch (loop_mode) {\n\tcase MAC_INTERNALLOOP_MAC:\n\t\tdsaf_set_dev_bit(drv, GMAC_LOOP_REG, GMAC_LP_REG_CF2MI_LP_EN_B,\n\t\t\t\t !!enable);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(drv->dev, \"loop_mode error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hns_gmac_get_info(void *mac_drv, struct mac_info *mac_info)\n{\n\tenum hns_gmac_duplex_mdoe duplex;\n\tenum hns_port_mode speed;\n\tu32 rx_pause;\n\tu32 tx_pause;\n\tu32 rx;\n\tu32 tx;\n\tu16 fc_tx_timer;\n\tstruct hns_gmac_port_mode_cfg port_mode = { GMAC_10M_MII, 0 };\n\n\thns_gmac_port_mode_get(mac_drv, &port_mode);\n\tmac_info->pad_and_crc_en = port_mode.crc_add && port_mode.pad_enable;\n\tmac_info->auto_neg = port_mode.an_enable;\n\n\thns_gmac_get_tx_auto_pause_frames(mac_drv, &fc_tx_timer);\n\tmac_info->tx_pause_time = fc_tx_timer;\n\n\thns_gmac_get_en(mac_drv, &rx, &tx);\n\tmac_info->port_en = rx && tx;\n\n\thns_gmac_get_duplex_type(mac_drv, &duplex);\n\tmac_info->duplex = duplex;\n\n\thns_gmac_get_port_mode(mac_drv, &speed);\n\tswitch (speed) {\n\tcase GMAC_10M_SGMII:\n\t\tmac_info->speed = MAC_SPEED_10;\n\t\tbreak;\n\tcase GMAC_100M_SGMII:\n\t\tmac_info->speed = MAC_SPEED_100;\n\t\tbreak;\n\tcase GMAC_1000M_SGMII:\n\t\tmac_info->speed = MAC_SPEED_1000;\n\t\tbreak;\n\tdefault:\n\t\tmac_info->speed = 0;\n\t\tbreak;\n\t}\n\n\thns_gmac_get_pausefrm_cfg(mac_drv, &rx_pause, &tx_pause);\n\tmac_info->rx_pause_en = rx_pause;\n\tmac_info->tx_pause_en = tx_pause;\n}\n\nstatic void hns_gmac_autoneg_stat(void *mac_drv, u32 *enable)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*enable = dsaf_get_dev_bit(drv, GMAC_TRANSMIT_CONTROL_REG,\n\t\t\t\t   GMAC_TX_AN_EN_B);\n}\n\nstatic void hns_gmac_get_link_status(void *mac_drv, u32 *link_stat)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*link_stat = dsaf_get_dev_bit(drv, GMAC_AN_NEG_STATE_REG,\n\t\t\t\t      GMAC_AN_NEG_STAT_RX_SYNC_OK_B);\n}\n\nstatic void hns_gmac_get_regs(void *mac_drv, void *data)\n{\n\tu32 *regs = data;\n\tint i;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t/* base config registers */\n\tregs[0] = dsaf_read_dev(drv, GMAC_DUPLEX_TYPE_REG);\n\tregs[1] = dsaf_read_dev(drv, GMAC_FD_FC_TYPE_REG);\n\tregs[2] = dsaf_read_dev(drv, GMAC_FC_TX_TIMER_REG);\n\tregs[3] = dsaf_read_dev(drv, GMAC_FD_FC_ADDR_LOW_REG);\n\tregs[4] = dsaf_read_dev(drv, GMAC_FD_FC_ADDR_HIGH_REG);\n\tregs[5] = dsaf_read_dev(drv, GMAC_IPG_TX_TIMER_REG);\n\tregs[6] = dsaf_read_dev(drv, GMAC_PAUSE_THR_REG);\n\tregs[7] = dsaf_read_dev(drv, GMAC_MAX_FRM_SIZE_REG);\n\tregs[8] = dsaf_read_dev(drv, GMAC_PORT_MODE_REG);\n\tregs[9] = dsaf_read_dev(drv, GMAC_PORT_EN_REG);\n\tregs[10] = dsaf_read_dev(drv, GMAC_PAUSE_EN_REG);\n\tregs[11] = dsaf_read_dev(drv, GMAC_SHORT_RUNTS_THR_REG);\n\tregs[12] = dsaf_read_dev(drv, GMAC_AN_NEG_STATE_REG);\n\tregs[13] = dsaf_read_dev(drv, GMAC_TX_LOCAL_PAGE_REG);\n\tregs[14] = dsaf_read_dev(drv, GMAC_TRANSMIT_CONTROL_REG);\n\tregs[15] = dsaf_read_dev(drv, GMAC_REC_FILT_CONTROL_REG);\n\tregs[16] = dsaf_read_dev(drv, GMAC_PTP_CONFIG_REG);\n\n\t/* rx static registers */\n\tregs[17] = dsaf_read_dev(drv, GMAC_RX_OCTETS_TOTAL_OK_REG);\n\tregs[18] = dsaf_read_dev(drv, GMAC_RX_OCTETS_BAD_REG);\n\tregs[19] = dsaf_read_dev(drv, GMAC_RX_UC_PKTS_REG);\n\tregs[20] = dsaf_read_dev(drv, GMAC_RX_MC_PKTS_REG);\n\tregs[21] = dsaf_read_dev(drv, GMAC_RX_BC_PKTS_REG);\n\tregs[22] = dsaf_read_dev(drv, GMAC_RX_PKTS_64OCTETS_REG);\n\tregs[23] = dsaf_read_dev(drv, GMAC_RX_PKTS_65TO127OCTETS_REG);\n\tregs[24] = dsaf_read_dev(drv, GMAC_RX_PKTS_128TO255OCTETS_REG);\n\tregs[25] = dsaf_read_dev(drv, GMAC_RX_PKTS_255TO511OCTETS_REG);\n\tregs[26] = dsaf_read_dev(drv, GMAC_RX_PKTS_512TO1023OCTETS_REG);\n\tregs[27] = dsaf_read_dev(drv, GMAC_RX_PKTS_1024TO1518OCTETS_REG);\n\tregs[28] = dsaf_read_dev(drv, GMAC_RX_PKTS_1519TOMAXOCTETS_REG);\n\tregs[29] = dsaf_read_dev(drv, GMAC_RX_FCS_ERRORS_REG);\n\tregs[30] = dsaf_read_dev(drv, GMAC_RX_TAGGED_REG);\n\tregs[31] = dsaf_read_dev(drv, GMAC_RX_DATA_ERR_REG);\n\tregs[32] = dsaf_read_dev(drv, GMAC_RX_ALIGN_ERRORS_REG);\n\tregs[33] = dsaf_read_dev(drv, GMAC_RX_LONG_ERRORS_REG);\n\tregs[34] = dsaf_read_dev(drv, GMAC_RX_JABBER_ERRORS_REG);\n\tregs[35] = dsaf_read_dev(drv, GMAC_RX_PAUSE_MACCTRL_FRAM_REG);\n\tregs[36] = dsaf_read_dev(drv, GMAC_RX_UNKNOWN_MACCTRL_FRAM_REG);\n\tregs[37] = dsaf_read_dev(drv, GMAC_RX_VERY_LONG_ERR_CNT_REG);\n\tregs[38] = dsaf_read_dev(drv, GMAC_RX_RUNT_ERR_CNT_REG);\n\tregs[39] = dsaf_read_dev(drv, GMAC_RX_SHORT_ERR_CNT_REG);\n\tregs[40] = dsaf_read_dev(drv, GMAC_RX_FILT_PKT_CNT_REG);\n\tregs[41] = dsaf_read_dev(drv, GMAC_RX_OCTETS_TOTAL_FILT_REG);\n\n\t/* tx static registers */\n\tregs[42] = dsaf_read_dev(drv, GMAC_OCTETS_TRANSMITTED_OK_REG);\n\tregs[43] = dsaf_read_dev(drv, GMAC_OCTETS_TRANSMITTED_BAD_REG);\n\tregs[44] = dsaf_read_dev(drv, GMAC_TX_UC_PKTS_REG);\n\tregs[45] = dsaf_read_dev(drv, GMAC_TX_MC_PKTS_REG);\n\tregs[46] = dsaf_read_dev(drv, GMAC_TX_BC_PKTS_REG);\n\tregs[47] = dsaf_read_dev(drv, GMAC_TX_PKTS_64OCTETS_REG);\n\tregs[48] = dsaf_read_dev(drv, GMAC_TX_PKTS_65TO127OCTETS_REG);\n\tregs[49] = dsaf_read_dev(drv, GMAC_TX_PKTS_128TO255OCTETS_REG);\n\tregs[50] = dsaf_read_dev(drv, GMAC_TX_PKTS_255TO511OCTETS_REG);\n\tregs[51] = dsaf_read_dev(drv, GMAC_TX_PKTS_512TO1023OCTETS_REG);\n\tregs[52] = dsaf_read_dev(drv, GMAC_TX_PKTS_1024TO1518OCTETS_REG);\n\tregs[53] = dsaf_read_dev(drv, GMAC_TX_PKTS_1519TOMAXOCTETS_REG);\n\tregs[54] = dsaf_read_dev(drv, GMAC_TX_EXCESSIVE_LENGTH_DROP_REG);\n\tregs[55] = dsaf_read_dev(drv, GMAC_TX_UNDERRUN_REG);\n\tregs[56] = dsaf_read_dev(drv, GMAC_TX_TAGGED_REG);\n\tregs[57] = dsaf_read_dev(drv, GMAC_TX_CRC_ERROR_REG);\n\tregs[58] = dsaf_read_dev(drv, GMAC_TX_PAUSE_FRAMES_REG);\n\n\tregs[59] = dsaf_read_dev(drv, GAMC_RX_MAX_FRAME);\n\tregs[60] = dsaf_read_dev(drv, GMAC_LINE_LOOP_BACK_REG);\n\tregs[61] = dsaf_read_dev(drv, GMAC_CF_CRC_STRIP_REG);\n\tregs[62] = dsaf_read_dev(drv, GMAC_MODE_CHANGE_EN_REG);\n\tregs[63] = dsaf_read_dev(drv, GMAC_SIXTEEN_BIT_CNTR_REG);\n\tregs[64] = dsaf_read_dev(drv, GMAC_LD_LINK_COUNTER_REG);\n\tregs[65] = dsaf_read_dev(drv, GMAC_LOOP_REG);\n\tregs[66] = dsaf_read_dev(drv, GMAC_RECV_CONTROL_REG);\n\tregs[67] = dsaf_read_dev(drv, GMAC_VLAN_CODE_REG);\n\tregs[68] = dsaf_read_dev(drv, GMAC_RX_OVERRUN_CNT_REG);\n\tregs[69] = dsaf_read_dev(drv, GMAC_RX_LENGTHFIELD_ERR_CNT_REG);\n\tregs[70] = dsaf_read_dev(drv, GMAC_RX_FAIL_COMMA_CNT_REG);\n\n\tregs[71] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_0_REG);\n\tregs[72] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_0_REG);\n\tregs[73] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_1_REG);\n\tregs[74] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_1_REG);\n\tregs[75] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_2_REG);\n\tregs[76] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG);\n\tregs[77] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_3_REG);\n\tregs[78] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_3_REG);\n\tregs[79] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_4_REG);\n\tregs[80] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_4_REG);\n\tregs[81] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_5_REG);\n\tregs[82] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_5_REG);\n\tregs[83] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_MSK_0_REG);\n\tregs[84] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_MSK_0_REG);\n\tregs[85] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_MSK_1_REG);\n\tregs[86] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_MSK_1_REG);\n\tregs[87] = dsaf_read_dev(drv, GMAC_MAC_SKIP_LEN_REG);\n\tregs[88] = dsaf_read_dev(drv, GMAC_TX_LOOP_PKT_PRI_REG);\n\n\t/* mark end of mac regs */\n\tfor (i = 89; i < 96; i++)\n\t\tregs[i] = 0xaaaaaaaa;\n}\n\nstatic void hns_gmac_get_stats(void *mac_drv, u64 *data)\n{\n\tu32 i;\n\tu64 *buf = data;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct mac_hw_stats *hw_stats = NULL;\n\n\thw_stats = &drv->mac_cb->hw_stats;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_gmac_stats_string); i++) {\n\t\tbuf[i] = DSAF_STATS_READ(hw_stats,\n\t\t\tg_gmac_stats_string[i].offset);\n\t}\n}\n\nstatic void hns_gmac_get_strings(u32 stringset, u8 *data)\n{\n\tchar *buff = (char *)data;\n\tu32 i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_gmac_stats_string); i++) {\n\t\tsnprintf(buff, ETH_GSTRING_LEN, \"%s\",\n\t\t\t g_gmac_stats_string[i].desc);\n\t\tbuff = buff + ETH_GSTRING_LEN;\n\t}\n}\n\nstatic int hns_gmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_gmac_stats_string);\n\n\treturn 0;\n}\n\nstatic int hns_gmac_get_regs_count(void)\n{\n\treturn ETH_GMAC_DUMP_NUM;\n}\n\nvoid *hns_gmac_config(struct hns_mac_cb *mac_cb, struct mac_params *mac_param)\n{\n\tstruct mac_driver *mac_drv;\n\n\tmac_drv = devm_kzalloc(mac_cb->dev, sizeof(*mac_drv), GFP_KERNEL);\n\tif (!mac_drv)\n\t\treturn NULL;\n\n\tmac_drv->mac_init = hns_gmac_init;\n\tmac_drv->mac_enable = hns_gmac_enable;\n\tmac_drv->mac_disable = hns_gmac_disable;\n\tmac_drv->mac_free = hns_gmac_free;\n\tmac_drv->adjust_link = hns_gmac_adjust_link;\n\tmac_drv->set_tx_auto_pause_frames = hns_gmac_set_tx_auto_pause_frames;\n\tmac_drv->config_max_frame_length = hns_gmac_config_max_frame_length;\n\tmac_drv->mac_pausefrm_cfg = hns_gmac_pause_frm_cfg;\n\n\tmac_drv->mac_id = mac_param->mac_id;\n\tmac_drv->mac_mode = mac_param->mac_mode;\n\tmac_drv->io_base = mac_param->vaddr;\n\tmac_drv->dev = mac_param->dev;\n\tmac_drv->mac_cb = mac_cb;\n\n\tmac_drv->set_mac_addr = hns_gmac_set_mac_addr;\n\tmac_drv->set_an_mode = hns_gmac_config_an_mode;\n\tmac_drv->config_loopback = hns_gmac_config_loopback;\n\tmac_drv->config_pad_and_crc = hns_gmac_config_pad_and_crc;\n\tmac_drv->config_half_duplex = hns_gmac_set_duplex_type;\n\tmac_drv->set_rx_ignore_pause_frames = hns_gmac_set_rx_auto_pause_frames;\n\tmac_drv->get_info = hns_gmac_get_info;\n\tmac_drv->autoneg_stat = hns_gmac_autoneg_stat;\n\tmac_drv->get_pause_enable = hns_gmac_get_pausefrm_cfg;\n\tmac_drv->get_link_status = hns_gmac_get_link_status;\n\tmac_drv->get_regs = hns_gmac_get_regs;\n\tmac_drv->get_regs_count = hns_gmac_get_regs_count;\n\tmac_drv->get_ethtool_stats = hns_gmac_get_stats;\n\tmac_drv->get_sset_count = hns_gmac_get_sset_count;\n\tmac_drv->get_strings = hns_gmac_get_strings;\n\tmac_drv->update_stats = hns_gmac_update_stats;\n\tmac_drv->set_promiscuous = hns_gmac_set_promisc;\n\n\treturn (void *)mac_drv;\n}\n", "/*\n * Copyright (c) 2014-2015 Hisilicon Limited.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n\n#include \"hns_dsaf_ppe.h\"\n\nvoid hns_ppe_set_tso_enable(struct hns_ppe_cb *ppe_cb, u32 value)\n{\n\tdsaf_set_dev_bit(ppe_cb, PPEV2_CFG_TSO_EN_REG, 0, !!value);\n}\n\nvoid hns_ppe_set_rss_key(struct hns_ppe_cb *ppe_cb,\n\t\t\t const u32 rss_key[HNS_PPEV2_RSS_KEY_NUM])\n{\n\tu32 key_item;\n\n\tfor (key_item = 0; key_item < HNS_PPEV2_RSS_KEY_NUM; key_item++)\n\t\tdsaf_write_dev(ppe_cb, PPEV2_RSS_KEY_REG + key_item * 0x4,\n\t\t\t       rss_key[key_item]);\n}\n\nvoid hns_ppe_set_indir_table(struct hns_ppe_cb *ppe_cb,\n\t\t\t     const u32 rss_tab[HNS_PPEV2_RSS_IND_TBL_SIZE])\n{\n\tint i;\n\tint reg_value;\n\n\tfor (i = 0; i < (HNS_PPEV2_RSS_IND_TBL_SIZE / 4); i++) {\n\t\treg_value = dsaf_read_dev(ppe_cb,\n\t\t\t\t\t  PPEV2_INDRECTION_TBL_REG + i * 0x4);\n\n\t\tdsaf_set_field(reg_value, PPEV2_CFG_RSS_TBL_4N0_M,\n\t\t\t       PPEV2_CFG_RSS_TBL_4N0_S,\n\t\t\t       rss_tab[i * 4 + 0] & 0x1F);\n\t\tdsaf_set_field(reg_value, PPEV2_CFG_RSS_TBL_4N1_M,\n\t\t\t       PPEV2_CFG_RSS_TBL_4N1_S,\n\t\t\t\trss_tab[i * 4 + 1] & 0x1F);\n\t\tdsaf_set_field(reg_value, PPEV2_CFG_RSS_TBL_4N2_M,\n\t\t\t       PPEV2_CFG_RSS_TBL_4N2_S,\n\t\t\t\trss_tab[i * 4 + 2] & 0x1F);\n\t\tdsaf_set_field(reg_value, PPEV2_CFG_RSS_TBL_4N3_M,\n\t\t\t       PPEV2_CFG_RSS_TBL_4N3_S,\n\t\t\t\trss_tab[i * 4 + 3] & 0x1F);\n\t\tdsaf_write_dev(\n\t\t\tppe_cb, PPEV2_INDRECTION_TBL_REG + i * 0x4, reg_value);\n\t}\n}\n\nstatic void __iomem *\nhns_ppe_common_get_ioaddr(struct ppe_common_cb *ppe_common)\n{\n\treturn ppe_common->dsaf_dev->ppe_base + PPE_COMMON_REG_OFFSET;\n}\n\n/**\n * hns_ppe_common_get_cfg - get ppe common config\n * @dsaf_dev: dasf device\n * comm_index: common index\n * retuen 0 - success , negative --fail\n */\nint hns_ppe_common_get_cfg(struct dsaf_device *dsaf_dev, int comm_index)\n{\n\tstruct ppe_common_cb *ppe_common;\n\tint ppe_num;\n\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev))\n\t\tppe_num = HNS_PPE_SERVICE_NW_ENGINE_NUM;\n\telse\n\t\tppe_num = HNS_PPE_DEBUG_NW_ENGINE_NUM;\n\n\tppe_common = devm_kzalloc(dsaf_dev->dev, sizeof(*ppe_common) +\n\t\tppe_num * sizeof(struct hns_ppe_cb), GFP_KERNEL);\n\tif (!ppe_common)\n\t\treturn -ENOMEM;\n\n\tppe_common->ppe_num = ppe_num;\n\tppe_common->dsaf_dev = dsaf_dev;\n\tppe_common->comm_index = comm_index;\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev))\n\t\tppe_common->ppe_mode = PPE_COMMON_MODE_SERVICE;\n\telse\n\t\tppe_common->ppe_mode = PPE_COMMON_MODE_DEBUG;\n\tppe_common->dev = dsaf_dev->dev;\n\n\tppe_common->io_base = hns_ppe_common_get_ioaddr(ppe_common);\n\n\tdsaf_dev->ppe_common[comm_index] = ppe_common;\n\n\treturn 0;\n}\n\nvoid hns_ppe_common_free_cfg(struct dsaf_device *dsaf_dev, u32 comm_index)\n{\n\tdsaf_dev->ppe_common[comm_index] = NULL;\n}\n\nstatic void __iomem *hns_ppe_get_iobase(struct ppe_common_cb *ppe_common,\n\t\t\t\t\tint ppe_idx)\n{\n\treturn ppe_common->dsaf_dev->ppe_base + ppe_idx * PPE_REG_OFFSET;\n}\n\nstatic void hns_ppe_get_cfg(struct ppe_common_cb *ppe_common)\n{\n\tu32 i;\n\tstruct hns_ppe_cb *ppe_cb;\n\tu32 ppe_num = ppe_common->ppe_num;\n\n\tfor (i = 0; i < ppe_num; i++) {\n\t\tppe_cb = &ppe_common->ppe_cb[i];\n\t\tppe_cb->dev = ppe_common->dev;\n\t\tppe_cb->next = NULL;\n\t\tppe_cb->ppe_common_cb = ppe_common;\n\t\tppe_cb->index = i;\n\t\tppe_cb->io_base = hns_ppe_get_iobase(ppe_common, i);\n\t\tppe_cb->virq = 0;\n\t}\n}\n\nstatic void hns_ppe_cnt_clr_ce(struct hns_ppe_cb *ppe_cb)\n{\n\tdsaf_set_dev_bit(ppe_cb, PPE_TNL_0_5_CNT_CLR_CE_REG,\n\t\t\t PPE_CNT_CLR_CE_B, 1);\n}\n\nstatic void hns_ppe_set_vlan_strip(struct hns_ppe_cb *ppe_cb, int en)\n{\n\tdsaf_write_dev(ppe_cb, PPEV2_VLAN_STRIP_EN_REG, en);\n}\n\n/**\n * hns_ppe_checksum_hw - set ppe checksum caculate\n * @ppe_device: ppe device\n * @value: value\n */\nstatic void hns_ppe_checksum_hw(struct hns_ppe_cb *ppe_cb, u32 value)\n{\n\tdsaf_set_dev_field(ppe_cb, PPE_CFG_PRO_CHECK_EN_REG,\n\t\t\t   0xfffffff, 0, value);\n}\n\nstatic void hns_ppe_set_qid_mode(struct ppe_common_cb *ppe_common,\n\t\t\t\t enum ppe_qid_mode qid_mdoe)\n{\n\tdsaf_set_dev_field(ppe_common, PPE_COM_CFG_QID_MODE_REG,\n\t\t\t   PPE_CFG_QID_MODE_CF_QID_MODE_M,\n\t\t\t   PPE_CFG_QID_MODE_CF_QID_MODE_S, qid_mdoe);\n}\n\n/**\n * hns_ppe_set_qid - set ppe qid\n * @ppe_common: ppe common device\n * @qid: queue id\n */\nstatic void hns_ppe_set_qid(struct ppe_common_cb *ppe_common, u32 qid)\n{\n\tu32 qid_mod = dsaf_read_dev(ppe_common, PPE_COM_CFG_QID_MODE_REG);\n\n\tif (!dsaf_get_field(qid_mod, PPE_CFG_QID_MODE_DEF_QID_M,\n\t\t\t    PPE_CFG_QID_MODE_DEF_QID_S)) {\n\t\tdsaf_set_field(qid_mod, PPE_CFG_QID_MODE_DEF_QID_M,\n\t\t\t       PPE_CFG_QID_MODE_DEF_QID_S, qid);\n\t\tdsaf_write_dev(ppe_common, PPE_COM_CFG_QID_MODE_REG, qid_mod);\n\t}\n}\n\n/**\n * hns_ppe_set_port_mode - set port mode\n * @ppe_device: ppe device\n * @mode: port mode\n */\nstatic void hns_ppe_set_port_mode(struct hns_ppe_cb *ppe_cb,\n\t\t\t\t  enum ppe_port_mode mode)\n{\n\tdsaf_write_dev(ppe_cb, PPE_CFG_XGE_MODE_REG, mode);\n}\n\n/**\n * hns_ppe_common_init_hw - init ppe common device\n * @ppe_common: ppe common device\n *\n * Return 0 on success, negative on failure\n */\nstatic int hns_ppe_common_init_hw(struct ppe_common_cb *ppe_common)\n{\n\tenum ppe_qid_mode qid_mode;\n\tstruct dsaf_device *dsaf_dev = ppe_common->dsaf_dev;\n\tenum dsaf_mode dsaf_mode = dsaf_dev->dsaf_mode;\n\n\tdsaf_dev->misc_op->ppe_comm_srst(dsaf_dev, 0);\n\tmdelay(100);\n\tdsaf_dev->misc_op->ppe_comm_srst(dsaf_dev, 1);\n\tmdelay(100);\n\n\tif (ppe_common->ppe_mode == PPE_COMMON_MODE_SERVICE) {\n\t\tswitch (dsaf_mode) {\n\t\tcase DSAF_MODE_ENABLE_FIX:\n\t\tcase DSAF_MODE_DISABLE_FIX:\n\t\t\tqid_mode = PPE_QID_MODE0;\n\t\t\thns_ppe_set_qid(ppe_common, 0);\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_0VM:\n\t\tcase DSAF_MODE_DISABLE_2PORT_64VM:\n\t\t\tqid_mode = PPE_QID_MODE3;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_8VM:\n\t\tcase DSAF_MODE_DISABLE_2PORT_16VM:\n\t\t\tqid_mode = PPE_QID_MODE4;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_16VM:\n\t\tcase DSAF_MODE_DISABLE_6PORT_0VM:\n\t\t\tqid_mode = PPE_QID_MODE5;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_32VM:\n\t\tcase DSAF_MODE_DISABLE_6PORT_16VM:\n\t\t\tqid_mode = PPE_QID_MODE2;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_128VM:\n\t\tcase DSAF_MODE_DISABLE_6PORT_4VM:\n\t\t\tqid_mode = PPE_QID_MODE1;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_DISABLE_2PORT_8VM:\n\t\t\tqid_mode = PPE_QID_MODE7;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_DISABLE_6PORT_2VM:\n\t\t\tqid_mode = PPE_QID_MODE6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(ppe_common->dev,\n\t\t\t\t\"get ppe queue mode failed! dsaf_mode=%d\\n\",\n\t\t\t\tdsaf_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\thns_ppe_set_qid_mode(ppe_common, qid_mode);\n\t}\n\n\tdsaf_set_dev_bit(ppe_common, PPE_COM_COMMON_CNT_CLR_CE_REG,\n\t\t\t PPE_COMMON_CNT_CLR_CE_B, 1);\n\n\treturn 0;\n}\n\n/*clr ppe exception irq*/\nstatic void hns_ppe_exc_irq_en(struct hns_ppe_cb *ppe_cb, int en)\n{\n\tu32 clr_vlue = 0xfffffffful;\n\tu32 msk_vlue = en ? 0xfffffffful : 0; /*1 is en, 0 is dis*/\n\tu32 vld_msk = 0;\n\n\t/*only care bit 0,1,7*/\n\tdsaf_set_bit(vld_msk, 0, 1);\n\tdsaf_set_bit(vld_msk, 1, 1);\n\tdsaf_set_bit(vld_msk, 7, 1);\n\n\t/*clr sts**/\n\tdsaf_write_dev(ppe_cb, PPE_RINT_REG, clr_vlue);\n\n\t/*for some reserved bits, so set 0**/\n\tdsaf_write_dev(ppe_cb, PPE_INTEN_REG, msk_vlue & vld_msk);\n}\n\n/**\n * ppe_init_hw - init ppe\n * @ppe_cb: ppe device\n */\nstatic void hns_ppe_init_hw(struct hns_ppe_cb *ppe_cb)\n{\n\tstruct ppe_common_cb *ppe_common_cb = ppe_cb->ppe_common_cb;\n\tu32 port = ppe_cb->index;\n\tstruct dsaf_device *dsaf_dev = ppe_common_cb->dsaf_dev;\n\tint i;\n\n\t/* get default RSS key */\n\tnetdev_rss_key_fill(ppe_cb->rss_key, HNS_PPEV2_RSS_KEY_SIZE);\n\n\tdsaf_dev->misc_op->ppe_srst(dsaf_dev, port, 0);\n\tmdelay(10);\n\tdsaf_dev->misc_op->ppe_srst(dsaf_dev, port, 1);\n\n\t/* clr and msk except irq*/\n\thns_ppe_exc_irq_en(ppe_cb, 0);\n\n\tif (ppe_common_cb->ppe_mode == PPE_COMMON_MODE_DEBUG) {\n\t\thns_ppe_set_port_mode(ppe_cb, PPE_MODE_GE);\n\t\tdsaf_write_dev(ppe_cb, PPE_CFG_PAUSE_IDLE_CNT_REG, 0);\n\t} else {\n\t\thns_ppe_set_port_mode(ppe_cb, PPE_MODE_XGE);\n\t}\n\n\thns_ppe_checksum_hw(ppe_cb, 0xffffffff);\n\thns_ppe_cnt_clr_ce(ppe_cb);\n\n\tif (!AE_IS_VER1(dsaf_dev->dsaf_ver)) {\n\t\thns_ppe_set_vlan_strip(ppe_cb, 0);\n\n\t\tdsaf_write_dev(ppe_cb, PPE_CFG_MAX_FRAME_LEN_REG,\n\t\t\t       HNS_PPEV2_MAX_FRAME_LEN);\n\n\t\t/* set default RSS key in h/w */\n\t\thns_ppe_set_rss_key(ppe_cb, ppe_cb->rss_key);\n\n\t\t/* Set default indrection table in h/w */\n\t\tfor (i = 0; i < HNS_PPEV2_RSS_IND_TBL_SIZE; i++)\n\t\t\tppe_cb->rss_indir_table[i] = i;\n\t\thns_ppe_set_indir_table(ppe_cb, ppe_cb->rss_indir_table);\n\t}\n}\n\n/**\n * ppe_uninit_hw - uninit ppe\n * @ppe_device: ppe device\n */\nstatic void hns_ppe_uninit_hw(struct hns_ppe_cb *ppe_cb)\n{\n\tu32 port;\n\n\tif (ppe_cb->ppe_common_cb) {\n\t\tstruct dsaf_device *dsaf_dev = ppe_cb->ppe_common_cb->dsaf_dev;\n\n\t\tport = ppe_cb->index;\n\t\tdsaf_dev->misc_op->ppe_srst(dsaf_dev, port, 0);\n\t}\n}\n\nvoid hns_ppe_uninit_ex(struct ppe_common_cb *ppe_common)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ppe_common->ppe_num; i++) {\n\t\tif (ppe_common->dsaf_dev->mac_cb[i])\n\t\t\thns_ppe_uninit_hw(&ppe_common->ppe_cb[i]);\n\t\tmemset(&ppe_common->ppe_cb[i], 0, sizeof(struct hns_ppe_cb));\n\t}\n}\n\nvoid hns_ppe_uninit(struct dsaf_device *dsaf_dev)\n{\n\tu32 i;\n\n\tfor (i = 0; i < HNS_PPE_COM_NUM; i++) {\n\t\tif (dsaf_dev->ppe_common[i])\n\t\t\thns_ppe_uninit_ex(dsaf_dev->ppe_common[i]);\n\t\thns_rcb_common_free_cfg(dsaf_dev, i);\n\t\thns_ppe_common_free_cfg(dsaf_dev, i);\n\t}\n}\n\n/**\n * hns_ppe_reset - reinit ppe/rcb hw\n * @dsaf_dev: dasf device\n * retuen void\n */\nvoid hns_ppe_reset_common(struct dsaf_device *dsaf_dev, u8 ppe_common_index)\n{\n\tu32 i;\n\tint ret;\n\tstruct ppe_common_cb *ppe_common;\n\n\tppe_common = dsaf_dev->ppe_common[ppe_common_index];\n\tret = hns_ppe_common_init_hw(ppe_common);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < ppe_common->ppe_num; i++) {\n\t\t/* We only need to initiate ppe when the port exists */\n\t\tif (dsaf_dev->mac_cb[i])\n\t\t\thns_ppe_init_hw(&ppe_common->ppe_cb[i]);\n\t}\n\n\tret = hns_rcb_common_init_hw(dsaf_dev->rcb_common[ppe_common_index]);\n\tif (ret)\n\t\treturn;\n\n\thns_rcb_common_init_commit_hw(dsaf_dev->rcb_common[ppe_common_index]);\n}\n\nvoid hns_ppe_update_stats(struct hns_ppe_cb *ppe_cb)\n{\n\tstruct hns_ppe_hw_stats *hw_stats = &ppe_cb->hw_stats;\n\n\thw_stats->rx_pkts_from_sw\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_SW_PKT_CNT_REG);\n\thw_stats->rx_pkts\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_WR_BD_OK_PKT_CNT_REG);\n\thw_stats->rx_drop_no_bd\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_NO_BUF_CNT_REG);\n\thw_stats->rx_alloc_buf_fail\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_APP_BUF_FAIL_CNT_REG);\n\thw_stats->rx_alloc_buf_wait\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_APP_BUF_WAIT_CNT_REG);\n\thw_stats->rx_drop_no_buf\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_DROP_FUL_CNT_REG);\n\thw_stats->rx_err_fifo_full\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_DROP_PRT_CNT_REG);\n\n\thw_stats->tx_bd_form_rcb\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_BD_CNT_REG);\n\thw_stats->tx_pkts_from_rcb\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_CNT_REG);\n\thw_stats->tx_pkts\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_OK_CNT_REG);\n\thw_stats->tx_err_fifo_empty\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_EPT_CNT_REG);\n\thw_stats->tx_err_checksum\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_CS_FAIL_CNT_REG);\n}\n\nint hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}\n\nint hns_ppe_get_regs_count(void)\n{\n\treturn ETH_PPE_DUMP_NUM;\n}\n\n/**\n * ppe_get_strings - get ppe srting\n * @ppe_device: ppe device\n * @stringset: string set type\n * @data: output string\n */\nvoid hns_ppe_get_strings(struct hns_ppe_cb *ppe_cb, int stringset, u8 *data)\n{\n\tchar *buff = (char *)data;\n\tint index = ppe_cb->index;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_sw_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_pkt_ok\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_drop_pkt_no_bd\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_alloc_buf_fail\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_alloc_buf_wait\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_pkt_drop_no_buf\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_pkt_err_fifo_full\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_bd\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_pkt_ok\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_pkt_err_fifo_empty\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_pkt_err_csum_fail\", index);\n}\n\nvoid hns_ppe_get_stats(struct hns_ppe_cb *ppe_cb, u64 *data)\n{\n\tu64 *regs_buff = data;\n\tstruct hns_ppe_hw_stats *hw_stats = &ppe_cb->hw_stats;\n\n\tregs_buff[0] = hw_stats->rx_pkts_from_sw;\n\tregs_buff[1] = hw_stats->rx_pkts;\n\tregs_buff[2] = hw_stats->rx_drop_no_bd;\n\tregs_buff[3] = hw_stats->rx_alloc_buf_fail;\n\tregs_buff[4] = hw_stats->rx_alloc_buf_wait;\n\tregs_buff[5] = hw_stats->rx_drop_no_buf;\n\tregs_buff[6] = hw_stats->rx_err_fifo_full;\n\n\tregs_buff[7] = hw_stats->tx_bd_form_rcb;\n\tregs_buff[8] = hw_stats->tx_pkts_from_rcb;\n\tregs_buff[9] = hw_stats->tx_pkts;\n\tregs_buff[10] = hw_stats->tx_err_fifo_empty;\n\tregs_buff[11] = hw_stats->tx_err_checksum;\n}\n\n/**\n * hns_ppe_init - init ppe device\n * @dsaf_dev: dasf device\n * retuen 0 - success , negative --fail\n */\nint hns_ppe_init(struct dsaf_device *dsaf_dev)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < HNS_PPE_COM_NUM; i++) {\n\t\tret = hns_ppe_common_get_cfg(dsaf_dev, i);\n\t\tif (ret)\n\t\t\tgoto get_cfg_fail;\n\n\t\tret = hns_rcb_common_get_cfg(dsaf_dev, i);\n\t\tif (ret)\n\t\t\tgoto get_cfg_fail;\n\n\t\thns_ppe_get_cfg(dsaf_dev->ppe_common[i]);\n\n\t\tret = hns_rcb_get_cfg(dsaf_dev->rcb_common[i]);\n\t\tif (ret)\n\t\t\tgoto get_cfg_fail;\n\t}\n\n\tfor (i = 0; i < HNS_PPE_COM_NUM; i++)\n\t\thns_ppe_reset_common(dsaf_dev, i);\n\n\treturn 0;\n\nget_cfg_fail:\n\tfor (i = 0; i < HNS_PPE_COM_NUM; i++) {\n\t\thns_rcb_common_free_cfg(dsaf_dev, i);\n\t\thns_ppe_common_free_cfg(dsaf_dev, i);\n\t}\n\n\treturn ret;\n}\n\nvoid hns_ppe_get_regs(struct hns_ppe_cb *ppe_cb, void *data)\n{\n\tstruct ppe_common_cb *ppe_common = ppe_cb->ppe_common_cb;\n\tu32 *regs = data;\n\tu32 i;\n\tu32 offset;\n\n\t/* ppe common registers */\n\tregs[0] = dsaf_read_dev(ppe_common, PPE_COM_CFG_QID_MODE_REG);\n\tregs[1] = dsaf_read_dev(ppe_common, PPE_COM_INTEN_REG);\n\tregs[2] = dsaf_read_dev(ppe_common, PPE_COM_RINT_REG);\n\tregs[3] = dsaf_read_dev(ppe_common, PPE_COM_INTSTS_REG);\n\tregs[4] = dsaf_read_dev(ppe_common, PPE_COM_COMMON_CNT_CLR_CE_REG);\n\n\tfor (i = 0; i < DSAF_TOTAL_QUEUE_NUM; i++) {\n\t\toffset = PPE_COM_HIS_RX_PKT_QID_DROP_CNT_REG + 0x4 * i;\n\t\tregs[5 + i] = dsaf_read_dev(ppe_common, offset);\n\t\toffset = PPE_COM_HIS_RX_PKT_QID_OK_CNT_REG + 0x4 * i;\n\t\tregs[5 + i + DSAF_TOTAL_QUEUE_NUM]\n\t\t\t\t= dsaf_read_dev(ppe_common, offset);\n\t\toffset = PPE_COM_HIS_TX_PKT_QID_ERR_CNT_REG + 0x4 * i;\n\t\tregs[5 + i + DSAF_TOTAL_QUEUE_NUM * 2]\n\t\t\t\t= dsaf_read_dev(ppe_common, offset);\n\t\toffset = PPE_COM_HIS_TX_PKT_QID_OK_CNT_REG + 0x4 * i;\n\t\tregs[5 + i + DSAF_TOTAL_QUEUE_NUM * 3]\n\t\t\t\t= dsaf_read_dev(ppe_common, offset);\n\t}\n\n\t/* mark end of ppe regs */\n\tfor (i = 521; i < 524; i++)\n\t\tregs[i] = 0xeeeeeeee;\n\n\t/* ppe channel registers */\n\tregs[525] = dsaf_read_dev(ppe_cb, PPE_CFG_TX_FIFO_THRSLD_REG);\n\tregs[526] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_FIFO_THRSLD_REG);\n\tregs[527] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_FIFO_PAUSE_THRSLD_REG);\n\tregs[528] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_FIFO_SW_BP_THRSLD_REG);\n\tregs[529] = dsaf_read_dev(ppe_cb, PPE_CFG_PAUSE_IDLE_CNT_REG);\n\tregs[530] = dsaf_read_dev(ppe_cb, PPE_CFG_BUS_CTRL_REG);\n\tregs[531] = dsaf_read_dev(ppe_cb, PPE_CFG_TNL_TO_BE_RST_REG);\n\tregs[532] = dsaf_read_dev(ppe_cb, PPE_CURR_TNL_CAN_RST_REG);\n\n\tregs[533] = dsaf_read_dev(ppe_cb, PPE_CFG_XGE_MODE_REG);\n\tregs[534] = dsaf_read_dev(ppe_cb, PPE_CFG_MAX_FRAME_LEN_REG);\n\tregs[535] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_PKT_MODE_REG);\n\tregs[536] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_VLAN_TAG_REG);\n\tregs[537] = dsaf_read_dev(ppe_cb, PPE_CFG_TAG_GEN_REG);\n\tregs[538] = dsaf_read_dev(ppe_cb, PPE_CFG_PARSE_TAG_REG);\n\tregs[539] = dsaf_read_dev(ppe_cb, PPE_CFG_PRO_CHECK_EN_REG);\n\n\tregs[540] = dsaf_read_dev(ppe_cb, PPE_INTEN_REG);\n\tregs[541] = dsaf_read_dev(ppe_cb, PPE_RINT_REG);\n\tregs[542] = dsaf_read_dev(ppe_cb, PPE_INTSTS_REG);\n\tregs[543] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_PKT_INT_REG);\n\n\tregs[544] = dsaf_read_dev(ppe_cb, PPE_CFG_HEAT_DECT_TIME0_REG);\n\tregs[545] = dsaf_read_dev(ppe_cb, PPE_CFG_HEAT_DECT_TIME1_REG);\n\n\t/* ppe static */\n\tregs[546] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_SW_PKT_CNT_REG);\n\tregs[547] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_WR_BD_OK_PKT_CNT_REG);\n\tregs[548] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_NO_BUF_CNT_REG);\n\tregs[549] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_BD_CNT_REG);\n\tregs[550] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_CNT_REG);\n\tregs[551] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_OK_CNT_REG);\n\tregs[552] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_EPT_CNT_REG);\n\tregs[553] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_CS_FAIL_CNT_REG);\n\tregs[554] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_APP_BUF_FAIL_CNT_REG);\n\tregs[555] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_APP_BUF_WAIT_CNT_REG);\n\tregs[556] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_DROP_FUL_CNT_REG);\n\tregs[557] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_DROP_PRT_CNT_REG);\n\n\tregs[558] = dsaf_read_dev(ppe_cb, PPE_TNL_0_5_CNT_CLR_CE_REG);\n\tregs[559] = dsaf_read_dev(ppe_cb, PPE_CFG_AXI_DBG_REG);\n\tregs[560] = dsaf_read_dev(ppe_cb, PPE_HIS_PRO_ERR_REG);\n\tregs[561] = dsaf_read_dev(ppe_cb, PPE_HIS_TNL_FIFO_ERR_REG);\n\tregs[562] = dsaf_read_dev(ppe_cb, PPE_CURR_CFF_DATA_NUM_REG);\n\tregs[563] = dsaf_read_dev(ppe_cb, PPE_CURR_RX_ST_REG);\n\tregs[564] = dsaf_read_dev(ppe_cb, PPE_CURR_TX_ST_REG);\n\tregs[565] = dsaf_read_dev(ppe_cb, PPE_CURR_RX_FIFO0_REG);\n\tregs[566] = dsaf_read_dev(ppe_cb, PPE_CURR_RX_FIFO1_REG);\n\tregs[567] = dsaf_read_dev(ppe_cb, PPE_CURR_TX_FIFO0_REG);\n\tregs[568] = dsaf_read_dev(ppe_cb, PPE_CURR_TX_FIFO1_REG);\n\tregs[569] = dsaf_read_dev(ppe_cb, PPE_ECO0_REG);\n\tregs[570] = dsaf_read_dev(ppe_cb, PPE_ECO1_REG);\n\tregs[571] = dsaf_read_dev(ppe_cb, PPE_ECO2_REG);\n\n\t/* mark end of ppe regs */\n\tfor (i = 572; i < 576; i++)\n\t\tregs[i] = 0xeeeeeeee;\n}\n", "/*\n * Copyright (c) 2014-2015 Hisilicon Limited.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/cdev.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <asm/cacheflush.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n#include <linux/spinlock.h>\n\n#include \"hns_dsaf_main.h\"\n#include \"hns_dsaf_ppe.h\"\n#include \"hns_dsaf_rcb.h\"\n\n#define RCB_COMMON_REG_OFFSET 0x80000\n#define TX_RING 0\n#define RX_RING 1\n\n#define RCB_RESET_WAIT_TIMES 30\n#define RCB_RESET_TRY_TIMES 10\n\n/* Because default mtu is 1500, rcb buffer size is set to 2048 enough */\n#define RCB_DEFAULT_BUFFER_SIZE 2048\n\n/**\n *hns_rcb_wait_fbd_clean - clean fbd\n *@qs: ring struct pointer array\n *@qnum: num of array\n *@flag: tx or rx flag\n */\nvoid hns_rcb_wait_fbd_clean(struct hnae_queue **qs, int q_num, u32 flag)\n{\n\tint i, wait_cnt;\n\tu32 fbd_num;\n\n\tfor (wait_cnt = i = 0; i < q_num; wait_cnt++) {\n\t\tusleep_range(200, 300);\n\t\tfbd_num = 0;\n\t\tif (flag & RCB_INT_FLAG_TX)\n\t\t\tfbd_num += dsaf_read_dev(qs[i],\n\t\t\t\t\t\t RCB_RING_TX_RING_FBDNUM_REG);\n\t\tif (flag & RCB_INT_FLAG_RX)\n\t\t\tfbd_num += dsaf_read_dev(qs[i],\n\t\t\t\t\t\t RCB_RING_RX_RING_FBDNUM_REG);\n\t\tif (!fbd_num)\n\t\t\ti++;\n\t\tif (wait_cnt >= 10000)\n\t\t\tbreak;\n\t}\n\n\tif (i < q_num)\n\t\tdev_err(qs[i]->handle->owner_dev,\n\t\t\t\"queue(%d) wait fbd(%d) clean fail!!\\n\", i, fbd_num);\n}\n\n/**\n *hns_rcb_reset_ring_hw - ring reset\n *@q: ring struct pointer\n */\nvoid hns_rcb_reset_ring_hw(struct hnae_queue *q)\n{\n\tu32 wait_cnt;\n\tu32 try_cnt = 0;\n\tu32 could_ret;\n\n\tu32 tx_fbd_num;\n\n\twhile (try_cnt++ < RCB_RESET_TRY_TIMES) {\n\t\tusleep_range(100, 200);\n\t\ttx_fbd_num = dsaf_read_dev(q, RCB_RING_TX_RING_FBDNUM_REG);\n\t\tif (tx_fbd_num)\n\t\t\tcontinue;\n\n\t\tdsaf_write_dev(q, RCB_RING_PREFETCH_EN_REG, 0);\n\n\t\tdsaf_write_dev(q, RCB_RING_T0_BE_RST, 1);\n\n\t\tmsleep(20);\n\t\tcould_ret = dsaf_read_dev(q, RCB_RING_COULD_BE_RST);\n\n\t\twait_cnt = 0;\n\t\twhile (!could_ret && (wait_cnt < RCB_RESET_WAIT_TIMES)) {\n\t\t\tdsaf_write_dev(q, RCB_RING_T0_BE_RST, 0);\n\n\t\t\tdsaf_write_dev(q, RCB_RING_T0_BE_RST, 1);\n\n\t\t\tmsleep(20);\n\t\t\tcould_ret = dsaf_read_dev(q, RCB_RING_COULD_BE_RST);\n\n\t\t\twait_cnt++;\n\t\t}\n\n\t\tdsaf_write_dev(q, RCB_RING_T0_BE_RST, 0);\n\n\t\tif (could_ret)\n\t\t\tbreak;\n\t}\n\n\tif (try_cnt >= RCB_RESET_TRY_TIMES)\n\t\tdev_err(q->dev->dev, \"port%d reset ring fail\\n\",\n\t\t\thns_ae_get_vf_cb(q->handle)->port_index);\n}\n\n/**\n *hns_rcb_int_ctrl_hw - rcb irq enable control\n *@q: hnae queue struct pointer\n *@flag:ring flag tx or rx\n *@mask:mask\n */\nvoid hns_rcb_int_ctrl_hw(struct hnae_queue *q, u32 flag, u32 mask)\n{\n\tu32 int_mask_en = !!mask;\n\n\tif (flag & RCB_INT_FLAG_TX) {\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_TXWL_REG, int_mask_en);\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_TX_OVERTIME_REG,\n\t\t\t       int_mask_en);\n\t}\n\n\tif (flag & RCB_INT_FLAG_RX) {\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_RXWL_REG, int_mask_en);\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_RX_OVERTIME_REG,\n\t\t\t       int_mask_en);\n\t}\n}\n\nvoid hns_rcb_int_clr_hw(struct hnae_queue *q, u32 flag)\n{\n\tif (flag & RCB_INT_FLAG_TX) {\n\t\tdsaf_write_dev(q, RCB_RING_INTSTS_TX_RING_REG, 1);\n\t\tdsaf_write_dev(q, RCB_RING_INTSTS_TX_OVERTIME_REG, 1);\n\t}\n\n\tif (flag & RCB_INT_FLAG_RX) {\n\t\tdsaf_write_dev(q, RCB_RING_INTSTS_RX_RING_REG, 1);\n\t\tdsaf_write_dev(q, RCB_RING_INTSTS_RX_OVERTIME_REG, 1);\n\t}\n}\n\nvoid hns_rcbv2_int_ctrl_hw(struct hnae_queue *q, u32 flag, u32 mask)\n{\n\tu32 int_mask_en = !!mask;\n\n\tif (flag & RCB_INT_FLAG_TX)\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_TXWL_REG, int_mask_en);\n\n\tif (flag & RCB_INT_FLAG_RX)\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_RXWL_REG, int_mask_en);\n}\n\nvoid hns_rcbv2_int_clr_hw(struct hnae_queue *q, u32 flag)\n{\n\tif (flag & RCB_INT_FLAG_TX)\n\t\tdsaf_write_dev(q, RCBV2_TX_RING_INT_STS_REG, 1);\n\n\tif (flag & RCB_INT_FLAG_RX)\n\t\tdsaf_write_dev(q, RCBV2_RX_RING_INT_STS_REG, 1);\n}\n\n/**\n *hns_rcb_ring_enable_hw - enable ring\n *@ring: rcb ring\n */\nvoid hns_rcb_ring_enable_hw(struct hnae_queue *q, u32 val)\n{\n\tdsaf_write_dev(q, RCB_RING_PREFETCH_EN_REG, !!val);\n}\n\nvoid hns_rcb_start(struct hnae_queue *q, u32 val)\n{\n\thns_rcb_ring_enable_hw(q, val);\n}\n\n/**\n *hns_rcb_common_init_commit_hw - make rcb common init completed\n *@rcb_common: rcb common device\n */\nvoid hns_rcb_common_init_commit_hw(struct rcb_common_cb *rcb_common)\n{\n\twmb();\t/* Sync point before breakpoint */\n\tdsaf_write_dev(rcb_common, RCB_COM_CFG_SYS_FSH_REG, 1);\n\twmb();\t/* Sync point after breakpoint */\n}\n\n/* hns_rcb_set_tx_ring_bs - init rcb ring buf size regester\n *@q: hnae_queue\n *@buf_size: buffer size set to hw\n */\nvoid hns_rcb_set_tx_ring_bs(struct hnae_queue *q, u32 buf_size)\n{\n\tu32 bd_size_type = hns_rcb_buf_size2type(buf_size);\n\n\tdsaf_write_dev(q, RCB_RING_TX_RING_BD_LEN_REG,\n\t\t       bd_size_type);\n}\n\n/* hns_rcb_set_rx_ring_bs - init rcb ring buf size regester\n *@q: hnae_queue\n *@buf_size: buffer size set to hw\n */\nvoid hns_rcb_set_rx_ring_bs(struct hnae_queue *q, u32 buf_size)\n{\n\tu32 bd_size_type = hns_rcb_buf_size2type(buf_size);\n\n\tdsaf_write_dev(q, RCB_RING_RX_RING_BD_LEN_REG,\n\t\t       bd_size_type);\n}\n\n/**\n *hns_rcb_ring_init - init rcb ring\n *@ring_pair: ring pair control block\n *@ring_type: ring type, RX_RING or TX_RING\n */\nstatic void hns_rcb_ring_init(struct ring_pair_cb *ring_pair, int ring_type)\n{\n\tstruct hnae_queue *q = &ring_pair->q;\n\tstruct hnae_ring *ring =\n\t\t(ring_type == RX_RING) ? &q->rx_ring : &q->tx_ring;\n\tdma_addr_t dma = ring->desc_dma_addr;\n\n\tif (ring_type == RX_RING) {\n\t\tdsaf_write_dev(q, RCB_RING_RX_RING_BASEADDR_L_REG,\n\t\t\t       (u32)dma);\n\t\tdsaf_write_dev(q, RCB_RING_RX_RING_BASEADDR_H_REG,\n\t\t\t       (u32)((dma >> 31) >> 1));\n\n\t\thns_rcb_set_rx_ring_bs(q, ring->buf_size);\n\n\t\tdsaf_write_dev(q, RCB_RING_RX_RING_BD_NUM_REG,\n\t\t\t       ring_pair->port_id_in_comm);\n\t\tdsaf_write_dev(q, RCB_RING_RX_RING_PKTLINE_REG,\n\t\t\t       ring_pair->port_id_in_comm);\n\t} else {\n\t\tdsaf_write_dev(q, RCB_RING_TX_RING_BASEADDR_L_REG,\n\t\t\t       (u32)dma);\n\t\tdsaf_write_dev(q, RCB_RING_TX_RING_BASEADDR_H_REG,\n\t\t\t       (u32)((dma >> 31) >> 1));\n\n\t\thns_rcb_set_tx_ring_bs(q, ring->buf_size);\n\n\t\tdsaf_write_dev(q, RCB_RING_TX_RING_BD_NUM_REG,\n\t\t\t       ring_pair->port_id_in_comm);\n\t\tdsaf_write_dev(q, RCB_RING_TX_RING_PKTLINE_REG,\n\t\t\tring_pair->port_id_in_comm + HNS_RCB_TX_PKTLINE_OFFSET);\n\t}\n}\n\n/**\n *hns_rcb_init_hw - init rcb hardware\n *@ring: rcb ring\n */\nvoid hns_rcb_init_hw(struct ring_pair_cb *ring)\n{\n\thns_rcb_ring_init(ring, RX_RING);\n\thns_rcb_ring_init(ring, TX_RING);\n}\n\n/**\n *hns_rcb_set_port_desc_cnt - set rcb port description num\n *@rcb_common: rcb_common device\n *@port_idx:port index\n *@desc_cnt:BD num\n */\nstatic void hns_rcb_set_port_desc_cnt(struct rcb_common_cb *rcb_common,\n\t\t\t\t      u32 port_idx, u32 desc_cnt)\n{\n\tdsaf_write_dev(rcb_common, RCB_CFG_BD_NUM_REG + port_idx * 4,\n\t\t       desc_cnt);\n}\n\nstatic void hns_rcb_set_port_timeout(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx, u32 timeout)\n{\n\tif (AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver)) {\n\t\tdsaf_write_dev(rcb_common, RCB_CFG_OVERTIME_REG,\n\t\t\t       timeout * HNS_RCB_CLK_FREQ_MHZ);\n\t} else if (!HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev)) {\n\t\tif (timeout > HNS_RCB_DEF_GAP_TIME_USECS)\n\t\t\tdsaf_write_dev(rcb_common,\n\t\t\t\t       RCB_PORT_INT_GAPTIME_REG + port_idx * 4,\n\t\t\t\t       HNS_RCB_DEF_GAP_TIME_USECS);\n\t\telse\n\t\t\tdsaf_write_dev(rcb_common,\n\t\t\t\t       RCB_PORT_INT_GAPTIME_REG + port_idx * 4,\n\t\t\t\t       timeout);\n\n\t\tdsaf_write_dev(rcb_common,\n\t\t\t       RCB_PORT_CFG_OVERTIME_REG + port_idx * 4,\n\t\t\t       timeout);\n\t} else {\n\t\tdsaf_write_dev(rcb_common,\n\t\t\t       RCB_PORT_CFG_OVERTIME_REG + port_idx * 4,\n\t\t\t       timeout);\n\t}\n}\n\nstatic int hns_rcb_common_get_port_num(struct rcb_common_cb *rcb_common)\n{\n\tif (!HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev))\n\t\treturn HNS_RCB_SERVICE_NW_ENGINE_NUM;\n\telse\n\t\treturn HNS_RCB_DEBUG_NW_ENGINE_NUM;\n}\n\n/*clr rcb comm exception irq**/\nstatic void hns_rcb_comm_exc_irq_en(\n\t\t\tstruct rcb_common_cb *rcb_common, int en)\n{\n\tu32 clr_vlue = 0xfffffffful;\n\tu32 msk_vlue = en ? 0 : 0xfffffffful;\n\n\t/* clr int*/\n\tdsaf_write_dev(rcb_common, RCB_COM_INTSTS_ECC_ERR_REG, clr_vlue);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_SF_CFG_RING_STS, clr_vlue);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_SF_CFG_BD_RINT_STS, clr_vlue);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_RINT_TX_PKT_REG, clr_vlue);\n\tdsaf_write_dev(rcb_common, RCB_COM_AXI_ERR_STS, clr_vlue);\n\n\t/*en msk*/\n\tdsaf_write_dev(rcb_common, RCB_COM_INTMASK_ECC_ERR_REG, msk_vlue);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_SF_CFG_INTMASK_RING, msk_vlue);\n\n\t/*for tx bd neednot cacheline, so msk sf_txring_fbd_intmask (bit 1)**/\n\tdsaf_write_dev(rcb_common, RCB_COM_SF_CFG_INTMASK_BD, msk_vlue | 2);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_INTMSK_TX_PKT_REG, msk_vlue);\n\tdsaf_write_dev(rcb_common, RCB_COM_AXI_WR_ERR_INTMASK, msk_vlue);\n}\n\n/**\n *hns_rcb_common_init_hw - init rcb common hardware\n *@rcb_common: rcb_common device\n *retuen 0 - success , negative --fail\n */\nint hns_rcb_common_init_hw(struct rcb_common_cb *rcb_common)\n{\n\tu32 reg_val;\n\tint i;\n\tint port_num = hns_rcb_common_get_port_num(rcb_common);\n\n\thns_rcb_comm_exc_irq_en(rcb_common, 0);\n\n\treg_val = dsaf_read_dev(rcb_common, RCB_COM_CFG_INIT_FLAG_REG);\n\tif (0x1 != (reg_val & 0x1)) {\n\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\"RCB_COM_CFG_INIT_FLAG_REG reg = 0x%x\\n\", reg_val);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < port_num; i++) {\n\t\thns_rcb_set_port_desc_cnt(rcb_common, i, rcb_common->desc_num);\n\t\thns_rcb_set_rx_coalesced_frames(\n\t\t\trcb_common, i, HNS_RCB_DEF_RX_COALESCED_FRAMES);\n\t\tif (!AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver) &&\n\t\t    !HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev))\n\t\t\thns_rcb_set_tx_coalesced_frames(\n\t\t\t\trcb_common, i, HNS_RCB_DEF_TX_COALESCED_FRAMES);\n\t\thns_rcb_set_port_timeout(\n\t\t\trcb_common, i, HNS_RCB_DEF_COALESCED_USECS);\n\t}\n\n\tdsaf_write_dev(rcb_common, RCB_COM_CFG_ENDIAN_REG,\n\t\t       HNS_RCB_COMMON_ENDIAN);\n\n\tif (AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver)) {\n\t\tdsaf_write_dev(rcb_common, RCB_COM_CFG_FNA_REG, 0x0);\n\t\tdsaf_write_dev(rcb_common, RCB_COM_CFG_FA_REG, 0x1);\n\t} else {\n\t\tdsaf_set_dev_bit(rcb_common, RCBV2_COM_CFG_USER_REG,\n\t\t\t\t RCB_COM_CFG_FNA_B, false);\n\t\tdsaf_set_dev_bit(rcb_common, RCBV2_COM_CFG_USER_REG,\n\t\t\t\t RCB_COM_CFG_FA_B, true);\n\t\tdsaf_set_dev_bit(rcb_common, RCBV2_COM_CFG_TSO_MODE_REG,\n\t\t\t\t RCB_COM_TSO_MODE_B, HNS_TSO_MODE_8BD_32K);\n\t}\n\n\treturn 0;\n}\n\nint hns_rcb_buf_size2type(u32 buf_size)\n{\n\tint bd_size_type;\n\n\tswitch (buf_size) {\n\tcase 512:\n\t\tbd_size_type = HNS_BD_SIZE_512_TYPE;\n\t\tbreak;\n\tcase 1024:\n\t\tbd_size_type = HNS_BD_SIZE_1024_TYPE;\n\t\tbreak;\n\tcase 2048:\n\t\tbd_size_type = HNS_BD_SIZE_2048_TYPE;\n\t\tbreak;\n\tcase 4096:\n\t\tbd_size_type = HNS_BD_SIZE_4096_TYPE;\n\t\tbreak;\n\tdefault:\n\t\tbd_size_type = -EINVAL;\n\t}\n\n\treturn bd_size_type;\n}\n\nstatic void hns_rcb_ring_get_cfg(struct hnae_queue *q, int ring_type)\n{\n\tstruct hnae_ring *ring;\n\tstruct rcb_common_cb *rcb_common;\n\tstruct ring_pair_cb *ring_pair_cb;\n\tu16 desc_num, mdnum_ppkt;\n\tbool irq_idx, is_ver1;\n\n\tring_pair_cb = container_of(q, struct ring_pair_cb, q);\n\tis_ver1 = AE_IS_VER1(ring_pair_cb->rcb_common->dsaf_dev->dsaf_ver);\n\tif (ring_type == RX_RING) {\n\t\tring = &q->rx_ring;\n\t\tring->io_base = ring_pair_cb->q.io_base;\n\t\tirq_idx = HNS_RCB_IRQ_IDX_RX;\n\t\tmdnum_ppkt = HNS_RCB_RING_MAX_BD_PER_PKT;\n\t} else {\n\t\tring = &q->tx_ring;\n\t\tring->io_base = (u8 __iomem *)ring_pair_cb->q.io_base +\n\t\t\tHNS_RCB_TX_REG_OFFSET;\n\t\tirq_idx = HNS_RCB_IRQ_IDX_TX;\n\t\tmdnum_ppkt = is_ver1 ? HNS_RCB_RING_MAX_TXBD_PER_PKT :\n\t\t\t\t HNS_RCBV2_RING_MAX_TXBD_PER_PKT;\n\t}\n\n\trcb_common = ring_pair_cb->rcb_common;\n\tdesc_num = rcb_common->dsaf_dev->desc_num;\n\n\tring->desc = NULL;\n\tring->desc_cb = NULL;\n\n\tring->irq = ring_pair_cb->virq[irq_idx];\n\tring->desc_dma_addr = 0;\n\n\tring->buf_size = RCB_DEFAULT_BUFFER_SIZE;\n\tring->desc_num = desc_num;\n\tring->max_desc_num_per_pkt = mdnum_ppkt;\n\tring->max_raw_data_sz_per_desc = HNS_RCB_MAX_PKT_SIZE;\n\tring->max_pkt_size = HNS_RCB_MAX_PKT_SIZE;\n\tring->next_to_use = 0;\n\tring->next_to_clean = 0;\n}\n\nstatic void hns_rcb_ring_pair_get_cfg(struct ring_pair_cb *ring_pair_cb)\n{\n\tring_pair_cb->q.handle = NULL;\n\n\thns_rcb_ring_get_cfg(&ring_pair_cb->q, RX_RING);\n\thns_rcb_ring_get_cfg(&ring_pair_cb->q, TX_RING);\n}\n\nstatic int hns_rcb_get_port_in_comm(\n\tstruct rcb_common_cb *rcb_common, int ring_idx)\n{\n\treturn ring_idx / (rcb_common->max_q_per_vf * rcb_common->max_vfn);\n}\n\n#define SERVICE_RING_IRQ_IDX(v1) \\\n\t((v1) ? HNS_SERVICE_RING_IRQ_IDX : HNSV2_SERVICE_RING_IRQ_IDX)\nstatic int hns_rcb_get_base_irq_idx(struct rcb_common_cb *rcb_common)\n{\n\tbool is_ver1 = AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver);\n\n\tif (!HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev))\n\t\treturn SERVICE_RING_IRQ_IDX(is_ver1);\n\telse\n\t\treturn  HNS_DEBUG_RING_IRQ_IDX;\n}\n\n#define RCB_COMM_BASE_TO_RING_BASE(base, ringid)\\\n\t((base) + 0x10000 + HNS_RCB_REG_OFFSET * (ringid))\n/**\n *hns_rcb_get_cfg - get rcb config\n *@rcb_common: rcb common device\n */\nint hns_rcb_get_cfg(struct rcb_common_cb *rcb_common)\n{\n\tstruct ring_pair_cb *ring_pair_cb;\n\tu32 i;\n\tu32 ring_num = rcb_common->ring_num;\n\tint base_irq_idx = hns_rcb_get_base_irq_idx(rcb_common);\n\tstruct platform_device *pdev =\n\t\tto_platform_device(rcb_common->dsaf_dev->dev);\n\tbool is_ver1 = AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver);\n\n\tfor (i = 0; i < ring_num; i++) {\n\t\tring_pair_cb = &rcb_common->ring_pair_cb[i];\n\t\tring_pair_cb->rcb_common = rcb_common;\n\t\tring_pair_cb->dev = rcb_common->dsaf_dev->dev;\n\t\tring_pair_cb->index = i;\n\t\tring_pair_cb->q.io_base =\n\t\t\tRCB_COMM_BASE_TO_RING_BASE(rcb_common->io_base, i);\n\t\tring_pair_cb->port_id_in_comm =\n\t\t\thns_rcb_get_port_in_comm(rcb_common, i);\n\t\tring_pair_cb->virq[HNS_RCB_IRQ_IDX_TX] =\n\t\tis_ver1 ? platform_get_irq(pdev, base_irq_idx + i * 2) :\n\t\t\t  platform_get_irq(pdev, base_irq_idx + i * 3 + 1);\n\t\tring_pair_cb->virq[HNS_RCB_IRQ_IDX_RX] =\n\t\tis_ver1 ? platform_get_irq(pdev, base_irq_idx + i * 2 + 1) :\n\t\t\t  platform_get_irq(pdev, base_irq_idx + i * 3);\n\t\tif ((ring_pair_cb->virq[HNS_RCB_IRQ_IDX_TX] == -EPROBE_DEFER) ||\n\t\t    (ring_pair_cb->virq[HNS_RCB_IRQ_IDX_RX] == -EPROBE_DEFER))\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tring_pair_cb->q.phy_base =\n\t\t\tRCB_COMM_BASE_TO_RING_BASE(rcb_common->phy_base, i);\n\t\thns_rcb_ring_pair_get_cfg(ring_pair_cb);\n\t}\n\n\treturn 0;\n}\n\n/**\n *hns_rcb_get_rx_coalesced_frames - get rcb port rx coalesced frames\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *\n *Returns: coalesced_frames\n */\nu32 hns_rcb_get_rx_coalesced_frames(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx)\n{\n\treturn dsaf_read_dev(rcb_common, RCB_CFG_PKTLINE_REG + port_idx * 4);\n}\n\n/**\n *hns_rcb_get_tx_coalesced_frames - get rcb port tx coalesced frames\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *\n *Returns: coalesced_frames\n */\nu32 hns_rcb_get_tx_coalesced_frames(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx)\n{\n\tu64 reg;\n\n\treg = RCB_CFG_PKTLINE_REG + (port_idx + HNS_RCB_TX_PKTLINE_OFFSET) * 4;\n\treturn dsaf_read_dev(rcb_common, reg);\n}\n\n/**\n *hns_rcb_get_coalesce_usecs - get rcb port coalesced time_out\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *\n *Returns: time_out\n */\nu32 hns_rcb_get_coalesce_usecs(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx)\n{\n\tif (AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver))\n\t\treturn dsaf_read_dev(rcb_common, RCB_CFG_OVERTIME_REG) /\n\t\t       HNS_RCB_CLK_FREQ_MHZ;\n\telse\n\t\treturn dsaf_read_dev(rcb_common,\n\t\t\t\t     RCB_PORT_CFG_OVERTIME_REG + port_idx * 4);\n}\n\n/**\n *hns_rcb_set_coalesce_usecs - set rcb port coalesced time_out\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *@timeout:tx/rx time for coalesced time_out\n *\n * Returns:\n * Zero for success, or an error code in case of failure\n */\nint hns_rcb_set_coalesce_usecs(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx, u32 timeout)\n{\n\tu32 old_timeout = hns_rcb_get_coalesce_usecs(rcb_common, port_idx);\n\n\tif (timeout == old_timeout)\n\t\treturn 0;\n\n\tif (AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver)) {\n\t\tif (!HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev)) {\n\t\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\t\"error: not support coalesce_usecs setting!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (timeout > HNS_RCB_MAX_COALESCED_USECS || timeout == 0) {\n\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\"error: coalesce_usecs setting supports 1~1023us\\n\");\n\t\treturn -EINVAL;\n\t}\n\thns_rcb_set_port_timeout(rcb_common, port_idx, timeout);\n\treturn 0;\n}\n\n/**\n *hns_rcb_set_tx_coalesced_frames - set rcb coalesced frames\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *@coalesced_frames:tx/rx BD num for coalesced frames\n *\n * Returns:\n * Zero for success, or an error code in case of failure\n */\nint hns_rcb_set_tx_coalesced_frames(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx, u32 coalesced_frames)\n{\n\tu32 old_waterline =\n\t\thns_rcb_get_tx_coalesced_frames(rcb_common, port_idx);\n\tu64 reg;\n\n\tif (coalesced_frames == old_waterline)\n\t\treturn 0;\n\n\tif (coalesced_frames != 1) {\n\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\"error: not support tx coalesce_frames setting!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = RCB_CFG_PKTLINE_REG + (port_idx + HNS_RCB_TX_PKTLINE_OFFSET) * 4;\n\tdsaf_write_dev(rcb_common, reg,\tcoalesced_frames);\n\treturn 0;\n}\n\n/**\n *hns_rcb_set_rx_coalesced_frames - set rcb rx coalesced frames\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *@coalesced_frames:tx/rx BD num for coalesced frames\n *\n * Returns:\n * Zero for success, or an error code in case of failure\n */\nint hns_rcb_set_rx_coalesced_frames(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx, u32 coalesced_frames)\n{\n\tu32 old_waterline =\n\t\thns_rcb_get_rx_coalesced_frames(rcb_common, port_idx);\n\n\tif (coalesced_frames == old_waterline)\n\t\treturn 0;\n\n\tif (coalesced_frames >= rcb_common->desc_num ||\n\t    coalesced_frames > HNS_RCB_MAX_COALESCED_FRAMES ||\n\t    coalesced_frames < HNS_RCB_MIN_COALESCED_FRAMES) {\n\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\"error: not support coalesce_frames setting!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdsaf_write_dev(rcb_common, RCB_CFG_PKTLINE_REG + port_idx * 4,\n\t\t       coalesced_frames);\n\treturn 0;\n}\n\n/**\n *hns_rcb_get_queue_mode - get max VM number and max ring number per VM\n *\t\t\t\t\t\taccordding to dsaf mode\n *@dsaf_mode: dsaf mode\n *@max_vfn : max vfn number\n *@max_q_per_vf:max ring number per vm\n */\nvoid hns_rcb_get_queue_mode(enum dsaf_mode dsaf_mode, u16 *max_vfn,\n\t\t\t    u16 *max_q_per_vf)\n{\n\tswitch (dsaf_mode) {\n\tcase DSAF_MODE_DISABLE_6PORT_0VM:\n\t\t*max_vfn = 1;\n\t\t*max_q_per_vf = 16;\n\t\tbreak;\n\tcase DSAF_MODE_DISABLE_FIX:\n\tcase DSAF_MODE_DISABLE_SP:\n\t\t*max_vfn = 1;\n\t\t*max_q_per_vf = 1;\n\t\tbreak;\n\tcase DSAF_MODE_DISABLE_2PORT_64VM:\n\t\t*max_vfn = 64;\n\t\t*max_q_per_vf = 1;\n\t\tbreak;\n\tcase DSAF_MODE_DISABLE_6PORT_16VM:\n\t\t*max_vfn = 16;\n\t\t*max_q_per_vf = 1;\n\t\tbreak;\n\tdefault:\n\t\t*max_vfn = 1;\n\t\t*max_q_per_vf = 16;\n\t\tbreak;\n\t}\n}\n\nint hns_rcb_get_ring_num(struct dsaf_device *dsaf_dev)\n{\n\tswitch (dsaf_dev->dsaf_mode) {\n\tcase DSAF_MODE_ENABLE_FIX:\n\tcase DSAF_MODE_DISABLE_SP:\n\t\treturn 1;\n\n\tcase DSAF_MODE_DISABLE_FIX:\n\t\treturn 6;\n\n\tcase DSAF_MODE_ENABLE_0VM:\n\t\treturn 32;\n\n\tcase DSAF_MODE_DISABLE_6PORT_0VM:\n\tcase DSAF_MODE_ENABLE_16VM:\n\tcase DSAF_MODE_DISABLE_6PORT_2VM:\n\tcase DSAF_MODE_DISABLE_6PORT_16VM:\n\tcase DSAF_MODE_DISABLE_6PORT_4VM:\n\tcase DSAF_MODE_ENABLE_8VM:\n\t\treturn 96;\n\n\tcase DSAF_MODE_DISABLE_2PORT_16VM:\n\tcase DSAF_MODE_DISABLE_2PORT_8VM:\n\tcase DSAF_MODE_ENABLE_32VM:\n\tcase DSAF_MODE_DISABLE_2PORT_64VM:\n\tcase DSAF_MODE_ENABLE_128VM:\n\t\treturn 128;\n\n\tdefault:\n\t\tdev_warn(dsaf_dev->dev,\n\t\t\t \"get ring num fail,use default!dsaf_mode=%d\\n\",\n\t\t\t dsaf_dev->dsaf_mode);\n\t\treturn 128;\n\t}\n}\n\nvoid __iomem *hns_rcb_common_get_vaddr(struct rcb_common_cb *rcb_common)\n{\n\tstruct dsaf_device *dsaf_dev = rcb_common->dsaf_dev;\n\n\treturn dsaf_dev->ppe_base + RCB_COMMON_REG_OFFSET;\n}\n\nstatic phys_addr_t hns_rcb_common_get_paddr(struct rcb_common_cb *rcb_common)\n{\n\tstruct dsaf_device *dsaf_dev = rcb_common->dsaf_dev;\n\n\treturn dsaf_dev->ppe_paddr + RCB_COMMON_REG_OFFSET;\n}\n\nint hns_rcb_common_get_cfg(struct dsaf_device *dsaf_dev,\n\t\t\t   int comm_index)\n{\n\tstruct rcb_common_cb *rcb_common;\n\tenum dsaf_mode dsaf_mode = dsaf_dev->dsaf_mode;\n\tu16 max_vfn;\n\tu16 max_q_per_vf;\n\tint ring_num = hns_rcb_get_ring_num(dsaf_dev);\n\n\trcb_common =\n\t\tdevm_kzalloc(dsaf_dev->dev, sizeof(*rcb_common) +\n\t\t\tring_num * sizeof(struct ring_pair_cb), GFP_KERNEL);\n\tif (!rcb_common) {\n\t\tdev_err(dsaf_dev->dev, \"rcb common devm_kzalloc fail!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trcb_common->comm_index = comm_index;\n\trcb_common->ring_num = ring_num;\n\trcb_common->dsaf_dev = dsaf_dev;\n\n\trcb_common->desc_num = dsaf_dev->desc_num;\n\n\thns_rcb_get_queue_mode(dsaf_mode, &max_vfn, &max_q_per_vf);\n\trcb_common->max_vfn = max_vfn;\n\trcb_common->max_q_per_vf = max_q_per_vf;\n\n\trcb_common->io_base = hns_rcb_common_get_vaddr(rcb_common);\n\trcb_common->phy_base = hns_rcb_common_get_paddr(rcb_common);\n\n\tdsaf_dev->rcb_common[comm_index] = rcb_common;\n\treturn 0;\n}\n\nvoid hns_rcb_common_free_cfg(struct dsaf_device *dsaf_dev,\n\t\t\t     u32 comm_index)\n{\n\tdsaf_dev->rcb_common[comm_index] = NULL;\n}\n\nvoid hns_rcb_update_stats(struct hnae_queue *queue)\n{\n\tstruct ring_pair_cb *ring =\n\t\tcontainer_of(queue, struct ring_pair_cb, q);\n\tstruct dsaf_device *dsaf_dev = ring->rcb_common->dsaf_dev;\n\tstruct ppe_common_cb *ppe_common\n\t\t= dsaf_dev->ppe_common[ring->rcb_common->comm_index];\n\tstruct hns_ring_hw_stats *hw_stats = &ring->hw_stats;\n\n\thw_stats->rx_pkts += dsaf_read_dev(queue,\n\t\t\t RCB_RING_RX_RING_PKTNUM_RECORD_REG);\n\tdsaf_write_dev(queue, RCB_RING_RX_RING_PKTNUM_RECORD_REG, 0x1);\n\n\thw_stats->ppe_rx_ok_pkts += dsaf_read_dev(ppe_common,\n\t\t\t PPE_COM_HIS_RX_PKT_QID_OK_CNT_REG + 4 * ring->index);\n\thw_stats->ppe_rx_drop_pkts += dsaf_read_dev(ppe_common,\n\t\t\t PPE_COM_HIS_RX_PKT_QID_DROP_CNT_REG + 4 * ring->index);\n\n\thw_stats->tx_pkts += dsaf_read_dev(queue,\n\t\t\t RCB_RING_TX_RING_PKTNUM_RECORD_REG);\n\tdsaf_write_dev(queue, RCB_RING_TX_RING_PKTNUM_RECORD_REG, 0x1);\n\n\thw_stats->ppe_tx_ok_pkts += dsaf_read_dev(ppe_common,\n\t\t\t PPE_COM_HIS_TX_PKT_QID_OK_CNT_REG + 4 * ring->index);\n\thw_stats->ppe_tx_drop_pkts += dsaf_read_dev(ppe_common,\n\t\t\t PPE_COM_HIS_TX_PKT_QID_ERR_CNT_REG + 4 * ring->index);\n}\n\n/**\n *hns_rcb_get_stats - get rcb statistic\n *@ring: rcb ring\n *@data:statistic value\n */\nvoid hns_rcb_get_stats(struct hnae_queue *queue, u64 *data)\n{\n\tu64 *regs_buff = data;\n\tstruct ring_pair_cb *ring =\n\t\tcontainer_of(queue, struct ring_pair_cb, q);\n\tstruct hns_ring_hw_stats *hw_stats = &ring->hw_stats;\n\n\tregs_buff[0] = hw_stats->tx_pkts;\n\tregs_buff[1] = hw_stats->ppe_tx_ok_pkts;\n\tregs_buff[2] = hw_stats->ppe_tx_drop_pkts;\n\tregs_buff[3] =\n\t\tdsaf_read_dev(queue, RCB_RING_TX_RING_FBDNUM_REG);\n\n\tregs_buff[4] = queue->tx_ring.stats.tx_pkts;\n\tregs_buff[5] = queue->tx_ring.stats.tx_bytes;\n\tregs_buff[6] = queue->tx_ring.stats.tx_err_cnt;\n\tregs_buff[7] = queue->tx_ring.stats.io_err_cnt;\n\tregs_buff[8] = queue->tx_ring.stats.sw_err_cnt;\n\tregs_buff[9] = queue->tx_ring.stats.seg_pkt_cnt;\n\tregs_buff[10] = queue->tx_ring.stats.restart_queue;\n\tregs_buff[11] = queue->tx_ring.stats.tx_busy;\n\n\tregs_buff[12] = hw_stats->rx_pkts;\n\tregs_buff[13] = hw_stats->ppe_rx_ok_pkts;\n\tregs_buff[14] = hw_stats->ppe_rx_drop_pkts;\n\tregs_buff[15] =\n\t\tdsaf_read_dev(queue, RCB_RING_RX_RING_FBDNUM_REG);\n\n\tregs_buff[16] = queue->rx_ring.stats.rx_pkts;\n\tregs_buff[17] = queue->rx_ring.stats.rx_bytes;\n\tregs_buff[18] = queue->rx_ring.stats.rx_err_cnt;\n\tregs_buff[19] = queue->rx_ring.stats.io_err_cnt;\n\tregs_buff[20] = queue->rx_ring.stats.sw_err_cnt;\n\tregs_buff[21] = queue->rx_ring.stats.seg_pkt_cnt;\n\tregs_buff[22] = queue->rx_ring.stats.reuse_pg_cnt;\n\tregs_buff[23] = queue->rx_ring.stats.err_pkt_len;\n\tregs_buff[24] = queue->rx_ring.stats.non_vld_descs;\n\tregs_buff[25] = queue->rx_ring.stats.err_bd_num;\n\tregs_buff[26] = queue->rx_ring.stats.l2_err;\n\tregs_buff[27] = queue->rx_ring.stats.l3l4_csum_err;\n}\n\n/**\n *hns_rcb_get_ring_sset_count - rcb string set count\n *@stringset:ethtool cmd\n *return rcb ring string set count\n */\nint hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}\n\n/**\n *hns_rcb_get_common_regs_count - rcb common regs count\n *return regs count\n */\nint hns_rcb_get_common_regs_count(void)\n{\n\treturn HNS_RCB_COMMON_DUMP_REG_NUM;\n}\n\n/**\n *rcb_get_sset_count - rcb ring regs count\n *return regs count\n */\nint hns_rcb_get_ring_regs_count(void)\n{\n\treturn HNS_RCB_RING_DUMP_REG_NUM;\n}\n\n/**\n *hns_rcb_get_strings - get rcb string set\n *@stringset:string set index\n *@data:strings name value\n *@index:queue index\n */\nvoid hns_rcb_get_strings(int stringset, u8 *data, int index)\n{\n\tchar *buff = (char *)data;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_rcb_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_ppe_tx_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_ppe_drop_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_fbd_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_bytes\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_err_cnt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_io_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_sw_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_seg_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_restart_queue\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_tx_busy\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_rcb_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_ppe_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_ppe_drop_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_fbd_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_bytes\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_err_cnt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_io_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_sw_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_seg_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_reuse_pg\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_len_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_non_vld_desc_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_bd_num_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_l2_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_l3l4csum_err\", index);\n}\n\nvoid hns_rcb_get_common_regs(struct rcb_common_cb *rcb_com, void *data)\n{\n\tu32 *regs = data;\n\tbool is_ver1 = AE_IS_VER1(rcb_com->dsaf_dev->dsaf_ver);\n\tbool is_dbg = HNS_DSAF_IS_DEBUG(rcb_com->dsaf_dev);\n\tu32 reg_tmp;\n\tu32 reg_num_tmp;\n\tu32 i = 0;\n\n\t/*rcb common registers */\n\tregs[0] = dsaf_read_dev(rcb_com, RCB_COM_CFG_ENDIAN_REG);\n\tregs[1] = dsaf_read_dev(rcb_com, RCB_COM_CFG_SYS_FSH_REG);\n\tregs[2] = dsaf_read_dev(rcb_com, RCB_COM_CFG_INIT_FLAG_REG);\n\n\tregs[3] = dsaf_read_dev(rcb_com, RCB_COM_CFG_PKT_REG);\n\tregs[4] = dsaf_read_dev(rcb_com, RCB_COM_CFG_RINVLD_REG);\n\tregs[5] = dsaf_read_dev(rcb_com, RCB_COM_CFG_FNA_REG);\n\tregs[6] = dsaf_read_dev(rcb_com, RCB_COM_CFG_FA_REG);\n\tregs[7] = dsaf_read_dev(rcb_com, RCB_COM_CFG_PKT_TC_BP_REG);\n\tregs[8] = dsaf_read_dev(rcb_com, RCB_COM_CFG_PPE_TNL_CLKEN_REG);\n\n\tregs[9] = dsaf_read_dev(rcb_com, RCB_COM_INTMSK_TX_PKT_REG);\n\tregs[10] = dsaf_read_dev(rcb_com, RCB_COM_RINT_TX_PKT_REG);\n\tregs[11] = dsaf_read_dev(rcb_com, RCB_COM_INTMASK_ECC_ERR_REG);\n\tregs[12] = dsaf_read_dev(rcb_com, RCB_COM_INTSTS_ECC_ERR_REG);\n\tregs[13] = dsaf_read_dev(rcb_com, RCB_COM_EBD_SRAM_ERR_REG);\n\tregs[14] = dsaf_read_dev(rcb_com, RCB_COM_RXRING_ERR_REG);\n\tregs[15] = dsaf_read_dev(rcb_com, RCB_COM_TXRING_ERR_REG);\n\tregs[16] = dsaf_read_dev(rcb_com, RCB_COM_TX_FBD_ERR_REG);\n\tregs[17] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK_EN_REG);\n\tregs[18] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK0_REG);\n\tregs[19] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK1_REG);\n\tregs[20] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK2_REG);\n\tregs[21] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK3_REG);\n\tregs[22] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK4_REG);\n\tregs[23] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK5_REG);\n\tregs[24] = dsaf_read_dev(rcb_com, RCB_ECC_ERR_ADDR0_REG);\n\tregs[25] = dsaf_read_dev(rcb_com, RCB_ECC_ERR_ADDR3_REG);\n\tregs[26] = dsaf_read_dev(rcb_com, RCB_ECC_ERR_ADDR4_REG);\n\tregs[27] = dsaf_read_dev(rcb_com, RCB_ECC_ERR_ADDR5_REG);\n\n\tregs[28] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_INTMASK_RING);\n\tregs[29] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_RING_STS);\n\tregs[30] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_RING);\n\tregs[31] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_INTMASK_BD);\n\tregs[32] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_BD_RINT_STS);\n\tregs[33] = dsaf_read_dev(rcb_com, RCB_COM_RCB_RD_BD_BUSY);\n\tregs[34] = dsaf_read_dev(rcb_com, RCB_COM_RCB_FBD_CRT_EN);\n\tregs[35] = dsaf_read_dev(rcb_com, RCB_COM_AXI_WR_ERR_INTMASK);\n\tregs[36] = dsaf_read_dev(rcb_com, RCB_COM_AXI_ERR_STS);\n\tregs[37] = dsaf_read_dev(rcb_com, RCB_COM_CHK_TX_FBD_NUM_REG);\n\n\t/* rcb common entry registers */\n\tfor (i = 0; i < 16; i++) { /* total 16 model registers */\n\t\tregs[38 + i]\n\t\t\t= dsaf_read_dev(rcb_com, RCB_CFG_BD_NUM_REG + 4 * i);\n\t\tregs[54 + i]\n\t\t\t= dsaf_read_dev(rcb_com, RCB_CFG_PKTLINE_REG + 4 * i);\n\t}\n\n\treg_tmp = is_ver1 ? RCB_CFG_OVERTIME_REG : RCB_PORT_CFG_OVERTIME_REG;\n\treg_num_tmp = (is_ver1 || is_dbg) ? 1 : 6;\n\tfor (i = 0; i < reg_num_tmp; i++)\n\t\tregs[70 + i] = dsaf_read_dev(rcb_com, reg_tmp);\n\n\tregs[76] = dsaf_read_dev(rcb_com, RCB_CFG_PKTLINE_INT_NUM_REG);\n\tregs[77] = dsaf_read_dev(rcb_com, RCB_CFG_OVERTIME_INT_NUM_REG);\n\n\t/* mark end of rcb common regs */\n\tfor (i = 78; i < 80; i++)\n\t\tregs[i] = 0xcccccccc;\n}\n\nvoid hns_rcb_get_ring_regs(struct hnae_queue *queue, void *data)\n{\n\tu32 *regs = data;\n\tstruct ring_pair_cb *ring_pair\n\t\t= container_of(queue, struct ring_pair_cb, q);\n\tu32 i = 0;\n\n\t/*rcb ring registers */\n\tregs[0] = dsaf_read_dev(queue, RCB_RING_RX_RING_BASEADDR_L_REG);\n\tregs[1] = dsaf_read_dev(queue, RCB_RING_RX_RING_BASEADDR_H_REG);\n\tregs[2] = dsaf_read_dev(queue, RCB_RING_RX_RING_BD_NUM_REG);\n\tregs[3] = dsaf_read_dev(queue, RCB_RING_RX_RING_BD_LEN_REG);\n\tregs[4] = dsaf_read_dev(queue, RCB_RING_RX_RING_PKTLINE_REG);\n\tregs[5] = dsaf_read_dev(queue, RCB_RING_RX_RING_TAIL_REG);\n\tregs[6] = dsaf_read_dev(queue, RCB_RING_RX_RING_HEAD_REG);\n\tregs[7] = dsaf_read_dev(queue, RCB_RING_RX_RING_FBDNUM_REG);\n\tregs[8] = dsaf_read_dev(queue, RCB_RING_RX_RING_PKTNUM_RECORD_REG);\n\n\tregs[9] = dsaf_read_dev(queue, RCB_RING_TX_RING_BASEADDR_L_REG);\n\tregs[10] = dsaf_read_dev(queue, RCB_RING_TX_RING_BASEADDR_H_REG);\n\tregs[11] = dsaf_read_dev(queue, RCB_RING_TX_RING_BD_NUM_REG);\n\tregs[12] = dsaf_read_dev(queue, RCB_RING_TX_RING_BD_LEN_REG);\n\tregs[13] = dsaf_read_dev(queue, RCB_RING_TX_RING_PKTLINE_REG);\n\tregs[15] = dsaf_read_dev(queue, RCB_RING_TX_RING_TAIL_REG);\n\tregs[16] = dsaf_read_dev(queue, RCB_RING_TX_RING_HEAD_REG);\n\tregs[17] = dsaf_read_dev(queue, RCB_RING_TX_RING_FBDNUM_REG);\n\tregs[18] = dsaf_read_dev(queue, RCB_RING_TX_RING_OFFSET_REG);\n\tregs[19] = dsaf_read_dev(queue, RCB_RING_TX_RING_PKTNUM_RECORD_REG);\n\n\tregs[20] = dsaf_read_dev(queue, RCB_RING_PREFETCH_EN_REG);\n\tregs[21] = dsaf_read_dev(queue, RCB_RING_CFG_VF_NUM_REG);\n\tregs[22] = dsaf_read_dev(queue, RCB_RING_ASID_REG);\n\tregs[23] = dsaf_read_dev(queue, RCB_RING_RX_VM_REG);\n\tregs[24] = dsaf_read_dev(queue, RCB_RING_T0_BE_RST);\n\tregs[25] = dsaf_read_dev(queue, RCB_RING_COULD_BE_RST);\n\tregs[26] = dsaf_read_dev(queue, RCB_RING_WRR_WEIGHT_REG);\n\n\tregs[27] = dsaf_read_dev(queue, RCB_RING_INTMSK_RXWL_REG);\n\tregs[28] = dsaf_read_dev(queue, RCB_RING_INTSTS_RX_RING_REG);\n\tregs[29] = dsaf_read_dev(queue, RCB_RING_INTMSK_TXWL_REG);\n\tregs[30] = dsaf_read_dev(queue, RCB_RING_INTSTS_TX_RING_REG);\n\tregs[31] = dsaf_read_dev(queue, RCB_RING_INTMSK_RX_OVERTIME_REG);\n\tregs[32] = dsaf_read_dev(queue, RCB_RING_INTSTS_RX_OVERTIME_REG);\n\tregs[33] = dsaf_read_dev(queue, RCB_RING_INTMSK_TX_OVERTIME_REG);\n\tregs[34] = dsaf_read_dev(queue, RCB_RING_INTSTS_TX_OVERTIME_REG);\n\n\t/* mark end of ring regs */\n\tfor (i = 35; i < 40; i++)\n\t\tregs[i] = 0xcccccc00 + ring_pair->index;\n}\n", "/*\n * Copyright (c) 2014-2015 Hisilicon Limited.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/io-64-nonatomic-hi-lo.h>\n#include <linux/of_mdio.h>\n#include \"hns_dsaf_main.h\"\n#include \"hns_dsaf_mac.h\"\n#include \"hns_dsaf_xgmac.h\"\n#include \"hns_dsaf_reg.h\"\n\nstatic const struct mac_stats_string g_xgmac_stats_string[] = {\n\t{\"xgmac_tx_bad_pkts_minto64\", MAC_STATS_FIELD_OFF(tx_fragment_err)},\n\t{\"xgmac_tx_good_pkts_minto64\", MAC_STATS_FIELD_OFF(tx_undersize)},\n\t{\"xgmac_tx_total_pkts_minto64\",\tMAC_STATS_FIELD_OFF(tx_under_min_pkts)},\n\t{\"xgmac_tx_pkts_64\", MAC_STATS_FIELD_OFF(tx_64bytes)},\n\t{\"xgmac_tx_pkts_65to127\", MAC_STATS_FIELD_OFF(tx_65to127)},\n\t{\"xgmac_tx_pkts_128to255\", MAC_STATS_FIELD_OFF(tx_128to255)},\n\t{\"xgmac_tx_pkts_256to511\", MAC_STATS_FIELD_OFF(tx_256to511)},\n\t{\"xgmac_tx_pkts_512to1023\", MAC_STATS_FIELD_OFF(tx_512to1023)},\n\t{\"xgmac_tx_pkts_1024to1518\", MAC_STATS_FIELD_OFF(tx_1024to1518)},\n\t{\"xgmac_tx_pkts_1519tomax\", MAC_STATS_FIELD_OFF(tx_1519tomax)},\n\t{\"xgmac_tx_good_pkts_1519tomax\",\n\t\tMAC_STATS_FIELD_OFF(tx_1519tomax_good)},\n\t{\"xgmac_tx_good_pkts_untralmax\", MAC_STATS_FIELD_OFF(tx_oversize)},\n\t{\"xgmac_tx_bad_pkts_untralmax\", MAC_STATS_FIELD_OFF(tx_jabber_err)},\n\t{\"xgmac_tx_good_pkts_all\", MAC_STATS_FIELD_OFF(tx_good_pkts)},\n\t{\"xgmac_tx_good_byte_all\", MAC_STATS_FIELD_OFF(tx_good_bytes)},\n\t{\"xgmac_tx_total_pkt\", MAC_STATS_FIELD_OFF(tx_total_pkts)},\n\t{\"xgmac_tx_total_byt\", MAC_STATS_FIELD_OFF(tx_total_bytes)},\n\t{\"xgmac_tx_uc_pkt\", MAC_STATS_FIELD_OFF(tx_uc_pkts)},\n\t{\"xgmac_tx_mc_pkt\", MAC_STATS_FIELD_OFF(tx_mc_pkts)},\n\t{\"xgmac_tx_bc_pkt\", MAC_STATS_FIELD_OFF(tx_bc_pkts)},\n\t{\"xgmac_tx_pause_frame_num\", MAC_STATS_FIELD_OFF(tx_pfc_tc0)},\n\t{\"xgmac_tx_pfc_per_1pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc1)},\n\t{\"xgmac_tx_pfc_per_2pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc2)},\n\t{\"xgmac_tx_pfc_per_3pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc3)},\n\t{\"xgmac_tx_pfc_per_4pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc4)},\n\t{\"xgmac_tx_pfc_per_5pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc5)},\n\t{\"xgmac_tx_pfc_per_6pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc6)},\n\t{\"xgmac_tx_pfc_per_7pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc7)},\n\t{\"xgmac_tx_mac_ctrol_frame\", MAC_STATS_FIELD_OFF(tx_ctrl)},\n\t{\"xgmac_tx_1731_pkts\", MAC_STATS_FIELD_OFF(tx_1731_pkts)},\n\t{\"xgmac_tx_1588_pkts\", MAC_STATS_FIELD_OFF(tx_1588_pkts)},\n\t{\"xgmac_rx_good_pkt_from_dsaf\", MAC_STATS_FIELD_OFF(rx_good_from_sw)},\n\t{\"xgmac_rx_bad_pkt_from_dsaf\", MAC_STATS_FIELD_OFF(rx_bad_from_sw)},\n\t{\"xgmac_tx_bad_pkt_64tomax\", MAC_STATS_FIELD_OFF(tx_bad_pkts)},\n\n\t{\"xgmac_rx_bad_pkts_minto64\", MAC_STATS_FIELD_OFF(rx_fragment_err)},\n\t{\"xgmac_rx_good_pkts_minto64\", MAC_STATS_FIELD_OFF(rx_undersize)},\n\t{\"xgmac_rx_total_pkts_minto64\", MAC_STATS_FIELD_OFF(rx_under_min)},\n\t{\"xgmac_rx_pkt_64\", MAC_STATS_FIELD_OFF(rx_64bytes)},\n\t{\"xgmac_rx_pkt_65to127\", MAC_STATS_FIELD_OFF(rx_65to127)},\n\t{\"xgmac_rx_pkt_128to255\", MAC_STATS_FIELD_OFF(rx_128to255)},\n\t{\"xgmac_rx_pkt_256to511\", MAC_STATS_FIELD_OFF(rx_256to511)},\n\t{\"xgmac_rx_pkt_512to1023\", MAC_STATS_FIELD_OFF(rx_512to1023)},\n\t{\"xgmac_rx_pkt_1024to1518\", MAC_STATS_FIELD_OFF(rx_1024to1518)},\n\t{\"xgmac_rx_pkt_1519tomax\", MAC_STATS_FIELD_OFF(rx_1519tomax)},\n\t{\"xgmac_rx_good_pkt_1519tomax\",\tMAC_STATS_FIELD_OFF(rx_1519tomax_good)},\n\t{\"xgmac_rx_good_pkt_untramax\", MAC_STATS_FIELD_OFF(rx_oversize)},\n\t{\"xgmac_rx_bad_pkt_untramax\", MAC_STATS_FIELD_OFF(rx_jabber_err)},\n\t{\"xgmac_rx_good_pkt\", MAC_STATS_FIELD_OFF(rx_good_pkts)},\n\t{\"xgmac_rx_good_byt\", MAC_STATS_FIELD_OFF(rx_good_bytes)},\n\t{\"xgmac_rx_pkt\", MAC_STATS_FIELD_OFF(rx_total_pkts)},\n\t{\"xgmac_rx_byt\", MAC_STATS_FIELD_OFF(rx_total_bytes)},\n\t{\"xgmac_rx_uc_pkt\", MAC_STATS_FIELD_OFF(rx_uc_pkts)},\n\t{\"xgmac_rx_mc_pkt\", MAC_STATS_FIELD_OFF(rx_mc_pkts)},\n\t{\"xgmac_rx_bc_pkt\", MAC_STATS_FIELD_OFF(rx_bc_pkts)},\n\t{\"xgmac_rx_pause_frame_num\", MAC_STATS_FIELD_OFF(rx_pfc_tc0)},\n\t{\"xgmac_rx_pfc_per_1pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc1)},\n\t{\"xgmac_rx_pfc_per_2pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc2)},\n\t{\"xgmac_rx_pfc_per_3pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc3)},\n\t{\"xgmac_rx_pfc_per_4pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc4)},\n\t{\"xgmac_rx_pfc_per_5pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc5)},\n\t{\"xgmac_rx_pfc_per_6pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc6)},\n\t{\"xgmac_rx_pfc_per_7pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc7)},\n\t{\"xgmac_rx_mac_control\", MAC_STATS_FIELD_OFF(rx_unknown_ctrl)},\n\t{\"xgmac_tx_good_pkt_todsaf\", MAC_STATS_FIELD_OFF(tx_good_to_sw)},\n\t{\"xgmac_tx_bad_pkt_todsaf\", MAC_STATS_FIELD_OFF(tx_bad_to_sw)},\n\t{\"xgmac_rx_1731_pkt\", MAC_STATS_FIELD_OFF(rx_1731_pkts)},\n\t{\"xgmac_rx_symbol_err_pkt\", MAC_STATS_FIELD_OFF(rx_symbol_err)},\n\t{\"xgmac_rx_fcs_pkt\", MAC_STATS_FIELD_OFF(rx_fcs_err)}\n};\n\n/**\n *hns_xgmac_tx_enable - xgmac port tx enable\n *@drv: mac driver\n *@value: value of enable\n */\nstatic void hns_xgmac_tx_enable(struct mac_driver *drv, u32 value)\n{\n\tdsaf_set_dev_bit(drv, XGMAC_MAC_ENABLE_REG, XGMAC_ENABLE_TX_B, !!value);\n}\n\n/**\n *hns_xgmac_rx_enable - xgmac port rx enable\n *@drv: mac driver\n *@value: value of enable\n */\nstatic void hns_xgmac_rx_enable(struct mac_driver *drv, u32 value)\n{\n\tdsaf_set_dev_bit(drv, XGMAC_MAC_ENABLE_REG, XGMAC_ENABLE_RX_B, !!value);\n}\n\n/**\n * hns_xgmac_tx_lf_rf_insert - insert lf rf control about xgmac\n * @mac_drv: mac driver\n * @mode: inserf rf or lf\n */\nstatic void hns_xgmac_lf_rf_insert(struct mac_driver *mac_drv, u32 mode)\n{\n\tdsaf_set_dev_field(mac_drv, XGMAC_MAC_TX_LF_RF_CONTROL_REG,\n\t\t\t   XGMAC_LF_RF_INSERT_M, XGMAC_LF_RF_INSERT_S, mode);\n}\n\n/**\n * hns_xgmac__lf_rf_control_init - initial the lf rf control register\n * @mac_drv: mac driver\n */\nstatic void hns_xgmac_lf_rf_control_init(struct mac_driver *mac_drv)\n{\n\tu32 val = 0;\n\n\tdsaf_set_bit(val, XGMAC_UNIDIR_EN_B, 0);\n\tdsaf_set_bit(val, XGMAC_RF_TX_EN_B, 1);\n\tdsaf_set_field(val, XGMAC_LF_RF_INSERT_M, XGMAC_LF_RF_INSERT_S, 0);\n\tdsaf_write_reg(mac_drv, XGMAC_MAC_TX_LF_RF_CONTROL_REG, val);\n}\n\n/**\n *hns_xgmac_enable - enable xgmac port\n *@drv: mac driver\n *@mode: mode of mac port\n */\nstatic void hns_xgmac_enable(void *mac_drv, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\thns_xgmac_lf_rf_insert(drv, HNS_XGMAC_NO_LF_RF_INSERT);\n\n\t/*enable XGE rX/tX */\n\tif (mode == MAC_COMM_MODE_TX) {\n\t\thns_xgmac_tx_enable(drv, 1);\n\t} else if (mode == MAC_COMM_MODE_RX) {\n\t\thns_xgmac_rx_enable(drv, 1);\n\t} else if (mode == MAC_COMM_MODE_RX_AND_TX) {\n\t\thns_xgmac_tx_enable(drv, 1);\n\t\thns_xgmac_rx_enable(drv, 1);\n\t} else {\n\t\tdev_err(drv->dev, \"error mac mode:%d\\n\", mode);\n\t}\n}\n\n/**\n *hns_xgmac_disable - disable xgmac port\n *@mac_drv: mac driver\n *@mode: mode of mac port\n */\nstatic void hns_xgmac_disable(void *mac_drv, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tif (mode == MAC_COMM_MODE_TX) {\n\t\thns_xgmac_tx_enable(drv, 0);\n\t} else if (mode == MAC_COMM_MODE_RX) {\n\t\thns_xgmac_rx_enable(drv, 0);\n\t} else if (mode == MAC_COMM_MODE_RX_AND_TX) {\n\t\thns_xgmac_tx_enable(drv, 0);\n\t\thns_xgmac_rx_enable(drv, 0);\n\t}\n\thns_xgmac_lf_rf_insert(drv, HNS_XGMAC_LF_INSERT);\n}\n\n/**\n *hns_xgmac_pma_fec_enable - xgmac PMA FEC enable\n *@drv: mac driver\n *@tx_value: tx value\n *@rx_value: rx value\n *return status\n */\nstatic void hns_xgmac_pma_fec_enable(struct mac_driver *drv, u32 tx_value,\n\t\t\t\t     u32 rx_value)\n{\n\tu32 origin = dsaf_read_dev(drv, XGMAC_PMA_FEC_CONTROL_REG);\n\n\tdsaf_set_bit(origin, XGMAC_PMA_FEC_CTL_TX_B, !!tx_value);\n\tdsaf_set_bit(origin, XGMAC_PMA_FEC_CTL_RX_B, !!rx_value);\n\tdsaf_write_dev(drv, XGMAC_PMA_FEC_CONTROL_REG, origin);\n}\n\n/* clr exc irq for xge*/\nstatic void hns_xgmac_exc_irq_en(struct mac_driver *drv, u32 en)\n{\n\tu32 clr_vlue = 0xfffffffful;\n\tu32 msk_vlue = en ? 0xfffffffful : 0; /*1 is en, 0 is dis*/\n\n\tdsaf_write_dev(drv, XGMAC_INT_STATUS_REG, clr_vlue);\n\tdsaf_write_dev(drv, XGMAC_INT_ENABLE_REG, msk_vlue);\n}\n\n/**\n *hns_xgmac_init - initialize XGE\n *@mac_drv: mac driver\n */\nstatic void hns_xgmac_init(void *mac_drv)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct dsaf_device *dsaf_dev\n\t\t= (struct dsaf_device *)dev_get_drvdata(drv->dev);\n\tu32 port = drv->mac_id;\n\n\tdsaf_dev->misc_op->xge_srst(dsaf_dev, port, 0);\n\tmdelay(100);\n\tdsaf_dev->misc_op->xge_srst(dsaf_dev, port, 1);\n\n\tmdelay(100);\n\thns_xgmac_lf_rf_control_init(drv);\n\thns_xgmac_exc_irq_en(drv, 0);\n\n\thns_xgmac_pma_fec_enable(drv, 0x0, 0x0);\n\n\thns_xgmac_disable(mac_drv, MAC_COMM_MODE_RX_AND_TX);\n}\n\n/**\n *hns_xgmac_config_pad_and_crc - set xgmac pad and crc enable the same time\n *@mac_drv: mac driver\n *@newval:enable of pad and crc\n */\nstatic void hns_xgmac_config_pad_and_crc(void *mac_drv, u8 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 origin = dsaf_read_dev(drv, XGMAC_MAC_CONTROL_REG);\n\n\tdsaf_set_bit(origin, XGMAC_CTL_TX_PAD_B, !!newval);\n\tdsaf_set_bit(origin, XGMAC_CTL_TX_FCS_B, !!newval);\n\tdsaf_set_bit(origin, XGMAC_CTL_RX_FCS_B, !!newval);\n\tdsaf_write_dev(drv, XGMAC_MAC_CONTROL_REG, origin);\n}\n\n/**\n *hns_xgmac_pausefrm_cfg - set pause param about xgmac\n *@mac_drv: mac driver\n *@newval:enable of pad and crc\n */\nstatic void hns_xgmac_pausefrm_cfg(void *mac_drv, u32 rx_en, u32 tx_en)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 origin = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG);\n\n\tdsaf_set_bit(origin, XGMAC_PAUSE_CTL_TX_B, !!tx_en);\n\tdsaf_set_bit(origin, XGMAC_PAUSE_CTL_RX_B, !!rx_en);\n\tdsaf_write_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG, origin);\n}\n\nstatic void hns_xgmac_set_pausefrm_mac_addr(void *mac_drv, char *mac_addr)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tu32 high_val = mac_addr[1] | (mac_addr[0] << 8);\n\tu32 low_val = mac_addr[5] | (mac_addr[4] << 8)\n\t\t| (mac_addr[3] << 16) | (mac_addr[2] << 24);\n\tdsaf_write_dev(drv, XGMAC_MAC_PAUSE_LOCAL_MAC_L_REG, low_val);\n\tdsaf_write_dev(drv, XGMAC_MAC_PAUSE_LOCAL_MAC_H_REG, high_val);\n}\n\n/**\n *hns_xgmac_set_rx_ignore_pause_frames - set rx pause param about xgmac\n *@mac_drv: mac driver\n *@enable:enable rx pause param\n */\nstatic void hns_xgmac_set_rx_ignore_pause_frames(void *mac_drv, u32 enable)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, XGMAC_MAC_PAUSE_CTRL_REG,\n\t\t\t XGMAC_PAUSE_CTL_RX_B, !!enable);\n}\n\n/**\n *hns_xgmac_set_tx_auto_pause_frames - set tx pause param about xgmac\n *@mac_drv: mac driver\n *@enable:enable tx pause param\n */\nstatic void hns_xgmac_set_tx_auto_pause_frames(void *mac_drv, u16 enable)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, XGMAC_MAC_PAUSE_CTRL_REG,\n\t\t\t XGMAC_PAUSE_CTL_TX_B, !!enable);\n\n\t/*if enable is not zero ,set tx pause time */\n\tif (enable)\n\t\tdsaf_write_dev(drv, XGMAC_MAC_PAUSE_TIME_REG, enable);\n}\n\n/**\n *hns_xgmac_config_max_frame_length - set xgmac max frame length\n *@mac_drv: mac driver\n *@newval:xgmac max frame length\n */\nstatic void hns_xgmac_config_max_frame_length(void *mac_drv, u16 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_write_dev(drv, XGMAC_MAC_MAX_PKT_SIZE_REG, newval);\n}\n\nvoid hns_xgmac_update_stats(void *mac_drv)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct mac_hw_stats *hw_stats = &drv->mac_cb->hw_stats;\n\n\t/* TX */\n\thw_stats->tx_fragment_err\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_FRAGMENT);\n\thw_stats->tx_undersize\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_UNDERSIZE);\n\thw_stats->tx_under_min_pkts\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_UNDERMIN);\n\thw_stats->tx_64bytes = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_64OCTETS);\n\thw_stats->tx_65to127\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_65TO127OCTETS);\n\thw_stats->tx_128to255\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_128TO255OCTETS);\n\thw_stats->tx_256to511\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_256TO511OCTETS);\n\thw_stats->tx_512to1023\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_512TO1023OCTETS);\n\thw_stats->tx_1024to1518\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1024TO1518OCTETS);\n\thw_stats->tx_1519tomax\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1519TOMAXOCTETS);\n\thw_stats->tx_1519tomax_good\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1519TOMAXOCTETSOK);\n\thw_stats->tx_oversize = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_OVERSIZE);\n\thw_stats->tx_jabber_err = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_JABBER);\n\thw_stats->tx_good_pkts = hns_mac_reg_read64(drv, XGMAC_TX_GOODPKTS);\n\thw_stats->tx_good_bytes = hns_mac_reg_read64(drv, XGMAC_TX_GOODOCTETS);\n\thw_stats->tx_total_pkts = hns_mac_reg_read64(drv, XGMAC_TX_TOTAL_PKTS);\n\thw_stats->tx_total_bytes\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_TOTALOCTETS);\n\thw_stats->tx_uc_pkts = hns_mac_reg_read64(drv, XGMAC_TX_UNICASTPKTS);\n\thw_stats->tx_mc_pkts = hns_mac_reg_read64(drv, XGMAC_TX_MULTICASTPKTS);\n\thw_stats->tx_bc_pkts = hns_mac_reg_read64(drv, XGMAC_TX_BROADCASTPKTS);\n\thw_stats->tx_pfc_tc0 = hns_mac_reg_read64(drv, XGMAC_TX_PRI0PAUSEPKTS);\n\thw_stats->tx_pfc_tc1 = hns_mac_reg_read64(drv, XGMAC_TX_PRI1PAUSEPKTS);\n\thw_stats->tx_pfc_tc2 = hns_mac_reg_read64(drv, XGMAC_TX_PRI2PAUSEPKTS);\n\thw_stats->tx_pfc_tc3 = hns_mac_reg_read64(drv, XGMAC_TX_PRI3PAUSEPKTS);\n\thw_stats->tx_pfc_tc4 = hns_mac_reg_read64(drv, XGMAC_TX_PRI4PAUSEPKTS);\n\thw_stats->tx_pfc_tc5 = hns_mac_reg_read64(drv, XGMAC_TX_PRI5PAUSEPKTS);\n\thw_stats->tx_pfc_tc6 = hns_mac_reg_read64(drv, XGMAC_TX_PRI6PAUSEPKTS);\n\thw_stats->tx_pfc_tc7 = hns_mac_reg_read64(drv, XGMAC_TX_PRI7PAUSEPKTS);\n\thw_stats->tx_ctrl = hns_mac_reg_read64(drv, XGMAC_TX_MACCTRLPKTS);\n\thw_stats->tx_1731_pkts = hns_mac_reg_read64(drv, XGMAC_TX_1731PKTS);\n\thw_stats->tx_1588_pkts = hns_mac_reg_read64(drv, XGMAC_TX_1588PKTS);\n\thw_stats->rx_good_from_sw\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_FROMAPPGOODPKTS);\n\thw_stats->rx_bad_from_sw\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_FROMAPPBADPKTS);\n\thw_stats->tx_bad_pkts = hns_mac_reg_read64(drv, XGMAC_TX_ERRALLPKTS);\n\n\t/* RX */\n\thw_stats->rx_fragment_err\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_FRAGMENT);\n\thw_stats->rx_undersize\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTSUNDERSIZE);\n\thw_stats->rx_under_min\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_UNDERMIN);\n\thw_stats->rx_64bytes = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_64OCTETS);\n\thw_stats->rx_65to127\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_65TO127OCTETS);\n\thw_stats->rx_128to255\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_128TO255OCTETS);\n\thw_stats->rx_256to511\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_256TO511OCTETS);\n\thw_stats->rx_512to1023\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_512TO1023OCTETS);\n\thw_stats->rx_1024to1518\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1024TO1518OCTETS);\n\thw_stats->rx_1519tomax\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1519TOMAXOCTETS);\n\thw_stats->rx_1519tomax_good\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1519TOMAXOCTETSOK);\n\thw_stats->rx_oversize = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_OVERSIZE);\n\thw_stats->rx_jabber_err = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_JABBER);\n\thw_stats->rx_good_pkts = hns_mac_reg_read64(drv, XGMAC_RX_GOODPKTS);\n\thw_stats->rx_good_bytes = hns_mac_reg_read64(drv, XGMAC_RX_GOODOCTETS);\n\thw_stats->rx_total_pkts = hns_mac_reg_read64(drv, XGMAC_RX_TOTAL_PKTS);\n\thw_stats->rx_total_bytes\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_TOTALOCTETS);\n\thw_stats->rx_uc_pkts = hns_mac_reg_read64(drv, XGMAC_RX_UNICASTPKTS);\n\thw_stats->rx_mc_pkts = hns_mac_reg_read64(drv, XGMAC_RX_MULTICASTPKTS);\n\thw_stats->rx_bc_pkts = hns_mac_reg_read64(drv, XGMAC_RX_BROADCASTPKTS);\n\thw_stats->rx_pfc_tc0 = hns_mac_reg_read64(drv, XGMAC_RX_PRI0PAUSEPKTS);\n\thw_stats->rx_pfc_tc1 = hns_mac_reg_read64(drv, XGMAC_RX_PRI1PAUSEPKTS);\n\thw_stats->rx_pfc_tc2 = hns_mac_reg_read64(drv, XGMAC_RX_PRI2PAUSEPKTS);\n\thw_stats->rx_pfc_tc3 = hns_mac_reg_read64(drv, XGMAC_RX_PRI3PAUSEPKTS);\n\thw_stats->rx_pfc_tc4 = hns_mac_reg_read64(drv, XGMAC_RX_PRI4PAUSEPKTS);\n\thw_stats->rx_pfc_tc5 = hns_mac_reg_read64(drv, XGMAC_RX_PRI5PAUSEPKTS);\n\thw_stats->rx_pfc_tc6 = hns_mac_reg_read64(drv, XGMAC_RX_PRI6PAUSEPKTS);\n\thw_stats->rx_pfc_tc7 = hns_mac_reg_read64(drv, XGMAC_RX_PRI7PAUSEPKTS);\n\n\thw_stats->rx_unknown_ctrl\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_MACCTRLPKTS);\n\thw_stats->tx_good_to_sw\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_SENDAPPGOODPKTS);\n\thw_stats->tx_bad_to_sw\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_SENDAPPBADPKTS);\n\thw_stats->rx_1731_pkts = hns_mac_reg_read64(drv, XGMAC_RX_1731PKTS);\n\thw_stats->rx_symbol_err\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_SYMBOLERRPKTS);\n\thw_stats->rx_fcs_err = hns_mac_reg_read64(drv, XGMAC_RX_FCSERRPKTS);\n}\n\n/**\n *hns_xgmac_free - free xgmac driver\n *@mac_drv: mac driver\n */\nstatic void hns_xgmac_free(void *mac_drv)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct dsaf_device *dsaf_dev\n\t\t= (struct dsaf_device *)dev_get_drvdata(drv->dev);\n\n\tu32 mac_id = drv->mac_id;\n\n\tdsaf_dev->misc_op->xge_srst(dsaf_dev, mac_id, 0);\n}\n\n/**\n *hns_xgmac_get_info - get xgmac information\n *@mac_drv: mac driver\n *@mac_info:mac information\n */\nstatic void hns_xgmac_get_info(void *mac_drv, struct mac_info *mac_info)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 pause_time, pause_ctrl, port_mode, ctrl_val;\n\n\tctrl_val = dsaf_read_dev(drv, XGMAC_MAC_CONTROL_REG);\n\tmac_info->pad_and_crc_en = dsaf_get_bit(ctrl_val, XGMAC_CTL_TX_PAD_B);\n\tmac_info->auto_neg = 0;\n\n\tpause_time = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_TIME_REG);\n\tmac_info->tx_pause_time = pause_time;\n\n\tport_mode = dsaf_read_dev(drv, XGMAC_PORT_MODE_REG);\n\tmac_info->port_en = dsaf_get_field(port_mode, XGMAC_PORT_MODE_TX_M,\n\t\t\t\t\t   XGMAC_PORT_MODE_TX_S) &&\n\t\t\t\tdsaf_get_field(port_mode, XGMAC_PORT_MODE_RX_M,\n\t\t\t\t\t       XGMAC_PORT_MODE_RX_S);\n\tmac_info->duplex = 1;\n\tmac_info->speed = MAC_SPEED_10000;\n\n\tpause_ctrl = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG);\n\tmac_info->rx_pause_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_RX_B);\n\tmac_info->tx_pause_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_TX_B);\n}\n\n/**\n *hns_xgmac_get_pausefrm_cfg - get xgmac pause param\n *@mac_drv: mac driver\n *@rx_en:xgmac rx pause enable\n *@tx_en:xgmac tx pause enable\n */\nstatic void hns_xgmac_get_pausefrm_cfg(void *mac_drv, u32 *rx_en, u32 *tx_en)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 pause_ctrl;\n\n\tpause_ctrl = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG);\n\t*rx_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_RX_B);\n\t*tx_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_TX_B);\n}\n\n/**\n *hns_xgmac_get_link_status - get xgmac link status\n *@mac_drv: mac driver\n *@link_stat: xgmac link stat\n */\nstatic void hns_xgmac_get_link_status(void *mac_drv, u32 *link_stat)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*link_stat = dsaf_read_dev(drv, XGMAC_LINK_STATUS_REG);\n}\n\n/**\n *hns_xgmac_get_regs - dump xgmac regs\n *@mac_drv: mac driver\n *@cmd:ethtool cmd\n *@data:data for value of regs\n */\nstatic void hns_xgmac_get_regs(void *mac_drv, void *data)\n{\n\tu32 i = 0;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 *regs = data;\n\tu64 qtmp;\n\n\t/* base config registers */\n\tregs[0] = dsaf_read_dev(drv, XGMAC_INT_STATUS_REG);\n\tregs[1] = dsaf_read_dev(drv, XGMAC_INT_ENABLE_REG);\n\tregs[2] = dsaf_read_dev(drv, XGMAC_INT_SET_REG);\n\tregs[3] = dsaf_read_dev(drv, XGMAC_IERR_U_INFO_REG);\n\tregs[4] = dsaf_read_dev(drv, XGMAC_OVF_INFO_REG);\n\tregs[5] = dsaf_read_dev(drv, XGMAC_OVF_CNT_REG);\n\tregs[6] = dsaf_read_dev(drv, XGMAC_PORT_MODE_REG);\n\tregs[7] = dsaf_read_dev(drv, XGMAC_CLK_ENABLE_REG);\n\tregs[8] = dsaf_read_dev(drv, XGMAC_RESET_REG);\n\tregs[9] = dsaf_read_dev(drv, XGMAC_LINK_CONTROL_REG);\n\tregs[10] = dsaf_read_dev(drv, XGMAC_LINK_STATUS_REG);\n\n\tregs[11] = dsaf_read_dev(drv, XGMAC_SPARE_REG);\n\tregs[12] = dsaf_read_dev(drv, XGMAC_SPARE_CNT_REG);\n\tregs[13] = dsaf_read_dev(drv, XGMAC_MAC_ENABLE_REG);\n\tregs[14] = dsaf_read_dev(drv, XGMAC_MAC_CONTROL_REG);\n\tregs[15] = dsaf_read_dev(drv, XGMAC_MAC_IPG_REG);\n\tregs[16] = dsaf_read_dev(drv, XGMAC_MAC_MSG_CRC_EN_REG);\n\tregs[17] = dsaf_read_dev(drv, XGMAC_MAC_MSG_IMG_REG);\n\tregs[18] = dsaf_read_dev(drv, XGMAC_MAC_MSG_FC_CFG_REG);\n\tregs[19] = dsaf_read_dev(drv, XGMAC_MAC_MSG_TC_CFG_REG);\n\tregs[20] = dsaf_read_dev(drv, XGMAC_MAC_PAD_SIZE_REG);\n\tregs[21] = dsaf_read_dev(drv, XGMAC_MAC_MIN_PKT_SIZE_REG);\n\tregs[22] = dsaf_read_dev(drv, XGMAC_MAC_MAX_PKT_SIZE_REG);\n\tregs[23] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG);\n\tregs[24] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_TIME_REG);\n\tregs[25] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_GAP_REG);\n\tregs[26] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_LOCAL_MAC_H_REG);\n\tregs[27] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_LOCAL_MAC_L_REG);\n\tregs[28] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_PEER_MAC_H_REG);\n\tregs[29] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_PEER_MAC_L_REG);\n\tregs[30] = dsaf_read_dev(drv, XGMAC_MAC_PFC_PRI_EN_REG);\n\tregs[31] = dsaf_read_dev(drv, XGMAC_MAC_1588_CTRL_REG);\n\tregs[32] = dsaf_read_dev(drv, XGMAC_MAC_1588_TX_PORT_DLY_REG);\n\tregs[33] = dsaf_read_dev(drv, XGMAC_MAC_1588_RX_PORT_DLY_REG);\n\tregs[34] = dsaf_read_dev(drv, XGMAC_MAC_1588_ASYM_DLY_REG);\n\tregs[35] = dsaf_read_dev(drv, XGMAC_MAC_1588_ADJUST_CFG_REG);\n\n\tregs[36] = dsaf_read_dev(drv, XGMAC_MAC_Y1731_ETH_TYPE_REG);\n\tregs[37] = dsaf_read_dev(drv, XGMAC_MAC_MIB_CONTROL_REG);\n\tregs[38] = dsaf_read_dev(drv, XGMAC_MAC_WAN_RATE_ADJUST_REG);\n\tregs[39] = dsaf_read_dev(drv, XGMAC_MAC_TX_ERR_MARK_REG);\n\tregs[40] = dsaf_read_dev(drv, XGMAC_MAC_TX_LF_RF_CONTROL_REG);\n\tregs[41] = dsaf_read_dev(drv, XGMAC_MAC_RX_LF_RF_STATUS_REG);\n\tregs[42] = dsaf_read_dev(drv, XGMAC_MAC_TX_RUNT_PKT_CNT_REG);\n\tregs[43] = dsaf_read_dev(drv, XGMAC_MAC_RX_RUNT_PKT_CNT_REG);\n\tregs[44] = dsaf_read_dev(drv, XGMAC_MAC_RX_PREAM_ERR_PKT_CNT_REG);\n\tregs[45] = dsaf_read_dev(drv, XGMAC_MAC_TX_LF_RF_TERM_PKT_CNT_REG);\n\tregs[46] = dsaf_read_dev(drv, XGMAC_MAC_TX_SN_MISMATCH_PKT_CNT_REG);\n\tregs[47] = dsaf_read_dev(drv, XGMAC_MAC_RX_ERR_MSG_CNT_REG);\n\tregs[48] = dsaf_read_dev(drv, XGMAC_MAC_RX_ERR_EFD_CNT_REG);\n\tregs[49] = dsaf_read_dev(drv, XGMAC_MAC_ERR_INFO_REG);\n\tregs[50] = dsaf_read_dev(drv, XGMAC_MAC_DBG_INFO_REG);\n\n\tregs[51] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SYNC_THD_REG);\n\tregs[52] = dsaf_read_dev(drv, XGMAC_PCS_STATUS1_REG);\n\tregs[53] = dsaf_read_dev(drv, XGMAC_PCS_BASER_STATUS1_REG);\n\tregs[54] = dsaf_read_dev(drv, XGMAC_PCS_BASER_STATUS2_REG);\n\tregs[55] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SEEDA_0_REG);\n\tregs[56] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SEEDA_1_REG);\n\tregs[57] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SEEDB_0_REG);\n\tregs[58] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SEEDB_1_REG);\n\tregs[59] = dsaf_read_dev(drv, XGMAC_PCS_BASER_TEST_CONTROL_REG);\n\tregs[60] = dsaf_read_dev(drv, XGMAC_PCS_BASER_TEST_ERR_CNT_REG);\n\tregs[61] = dsaf_read_dev(drv, XGMAC_PCS_DBG_INFO_REG);\n\tregs[62] = dsaf_read_dev(drv, XGMAC_PCS_DBG_INFO1_REG);\n\tregs[63] = dsaf_read_dev(drv, XGMAC_PCS_DBG_INFO2_REG);\n\tregs[64] = dsaf_read_dev(drv, XGMAC_PCS_DBG_INFO3_REG);\n\n\tregs[65] = dsaf_read_dev(drv, XGMAC_PMA_ENABLE_REG);\n\tregs[66] = dsaf_read_dev(drv, XGMAC_PMA_CONTROL_REG);\n\tregs[67] = dsaf_read_dev(drv, XGMAC_PMA_SIGNAL_STATUS_REG);\n\tregs[68] = dsaf_read_dev(drv, XGMAC_PMA_DBG_INFO_REG);\n\tregs[69] = dsaf_read_dev(drv, XGMAC_PMA_FEC_ABILITY_REG);\n\tregs[70] = dsaf_read_dev(drv, XGMAC_PMA_FEC_CONTROL_REG);\n\tregs[71] = dsaf_read_dev(drv, XGMAC_PMA_FEC_CORR_BLOCK_CNT__REG);\n\tregs[72] = dsaf_read_dev(drv, XGMAC_PMA_FEC_UNCORR_BLOCK_CNT__REG);\n\n\t/* status registers */\n#define hns_xgmac_cpy_q(p, q) \\\n\tdo {\\\n\t\t*(p) = (u32)(q);\\\n\t\t*((p) + 1) = (u32)((q) >> 32);\\\n\t} while (0)\n\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_FRAGMENT);\n\thns_xgmac_cpy_q(&regs[73], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_UNDERSIZE);\n\thns_xgmac_cpy_q(&regs[75], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_UNDERMIN);\n\thns_xgmac_cpy_q(&regs[77], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_64OCTETS);\n\thns_xgmac_cpy_q(&regs[79], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_65TO127OCTETS);\n\thns_xgmac_cpy_q(&regs[81], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_128TO255OCTETS);\n\thns_xgmac_cpy_q(&regs[83], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_256TO511OCTETS);\n\thns_xgmac_cpy_q(&regs[85], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_512TO1023OCTETS);\n\thns_xgmac_cpy_q(&regs[87], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1024TO1518OCTETS);\n\thns_xgmac_cpy_q(&regs[89], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1519TOMAXOCTETS);\n\thns_xgmac_cpy_q(&regs[91], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1519TOMAXOCTETSOK);\n\thns_xgmac_cpy_q(&regs[93], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_OVERSIZE);\n\thns_xgmac_cpy_q(&regs[95], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_JABBER);\n\thns_xgmac_cpy_q(&regs[97], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_GOODPKTS);\n\thns_xgmac_cpy_q(&regs[99], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_GOODOCTETS);\n\thns_xgmac_cpy_q(&regs[101], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_TOTAL_PKTS);\n\thns_xgmac_cpy_q(&regs[103], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_TOTALOCTETS);\n\thns_xgmac_cpy_q(&regs[105], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_UNICASTPKTS);\n\thns_xgmac_cpy_q(&regs[107], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_MULTICASTPKTS);\n\thns_xgmac_cpy_q(&regs[109], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_BROADCASTPKTS);\n\thns_xgmac_cpy_q(&regs[111], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI0PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[113], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI1PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[115], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI2PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[117], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI3PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[119], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI4PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[121], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI5PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[123], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI6PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[125], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI7PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[127], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_MACCTRLPKTS);\n\thns_xgmac_cpy_q(&regs[129], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_1731PKTS);\n\thns_xgmac_cpy_q(&regs[131], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_1588PKTS);\n\thns_xgmac_cpy_q(&regs[133], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_FROMAPPGOODPKTS);\n\thns_xgmac_cpy_q(&regs[135], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_FROMAPPBADPKTS);\n\thns_xgmac_cpy_q(&regs[137], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_ERRALLPKTS);\n\thns_xgmac_cpy_q(&regs[139], qtmp);\n\n\t/* RX */\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_FRAGMENT);\n\thns_xgmac_cpy_q(&regs[141], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTSUNDERSIZE);\n\thns_xgmac_cpy_q(&regs[143], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_UNDERMIN);\n\thns_xgmac_cpy_q(&regs[145], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_64OCTETS);\n\thns_xgmac_cpy_q(&regs[147], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_65TO127OCTETS);\n\thns_xgmac_cpy_q(&regs[149], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_128TO255OCTETS);\n\thns_xgmac_cpy_q(&regs[151], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_256TO511OCTETS);\n\thns_xgmac_cpy_q(&regs[153], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_512TO1023OCTETS);\n\thns_xgmac_cpy_q(&regs[155], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1024TO1518OCTETS);\n\thns_xgmac_cpy_q(&regs[157], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1519TOMAXOCTETS);\n\thns_xgmac_cpy_q(&regs[159], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1519TOMAXOCTETSOK);\n\thns_xgmac_cpy_q(&regs[161], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_OVERSIZE);\n\thns_xgmac_cpy_q(&regs[163], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_JABBER);\n\thns_xgmac_cpy_q(&regs[165], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_GOODPKTS);\n\thns_xgmac_cpy_q(&regs[167], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_GOODOCTETS);\n\thns_xgmac_cpy_q(&regs[169], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_TOTAL_PKTS);\n\thns_xgmac_cpy_q(&regs[171], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_TOTALOCTETS);\n\thns_xgmac_cpy_q(&regs[173], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_UNICASTPKTS);\n\thns_xgmac_cpy_q(&regs[175], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_MULTICASTPKTS);\n\thns_xgmac_cpy_q(&regs[177], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_BROADCASTPKTS);\n\thns_xgmac_cpy_q(&regs[179], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI0PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[181], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI1PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[183], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI2PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[185], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI3PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[187], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI4PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[189], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI5PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[191], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI6PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[193], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI7PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[195], qtmp);\n\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_MACCTRLPKTS);\n\thns_xgmac_cpy_q(&regs[197], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_SENDAPPGOODPKTS);\n\thns_xgmac_cpy_q(&regs[199], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_SENDAPPBADPKTS);\n\thns_xgmac_cpy_q(&regs[201], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_1731PKTS);\n\thns_xgmac_cpy_q(&regs[203], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_SYMBOLERRPKTS);\n\thns_xgmac_cpy_q(&regs[205], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_FCSERRPKTS);\n\thns_xgmac_cpy_q(&regs[207], qtmp);\n\n\t/* mark end of mac regs */\n\tfor (i = 208; i < 214; i++)\n\t\tregs[i] = 0xaaaaaaaa;\n}\n\n/**\n *hns_xgmac_get_stats - get xgmac statistic\n *@mac_drv: mac driver\n *@data:data for value of stats regs\n */\nstatic void hns_xgmac_get_stats(void *mac_drv, u64 *data)\n{\n\tu32 i;\n\tu64 *buf = data;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct mac_hw_stats *hw_stats = NULL;\n\n\thw_stats = &drv->mac_cb->hw_stats;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_xgmac_stats_string); i++) {\n\t\tbuf[i] = DSAF_STATS_READ(hw_stats,\n\t\t\tg_xgmac_stats_string[i].offset);\n\t}\n}\n\n/**\n *hns_xgmac_get_strings - get xgmac strings name\n *@stringset: type of values in data\n *@data:data for value of string name\n */\nstatic void hns_xgmac_get_strings(u32 stringset, u8 *data)\n{\n\tchar *buff = (char *)data;\n\tu32 i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_xgmac_stats_string); i++) {\n\t\tsnprintf(buff, ETH_GSTRING_LEN, g_xgmac_stats_string[i].desc);\n\t\tbuff = buff + ETH_GSTRING_LEN;\n\t}\n}\n\n/**\n *hns_xgmac_get_sset_count - get xgmac string set count\n *@stringset: type of values in data\n *return xgmac string set count\n */\nstatic int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}\n\n/**\n *hns_xgmac_get_regs_count - get xgmac regs count\n *return xgmac regs count\n */\nstatic int hns_xgmac_get_regs_count(void)\n{\n\treturn HNS_XGMAC_DUMP_NUM;\n}\n\nvoid *hns_xgmac_config(struct hns_mac_cb *mac_cb, struct mac_params *mac_param)\n{\n\tstruct mac_driver *mac_drv;\n\n\tmac_drv = devm_kzalloc(mac_cb->dev, sizeof(*mac_drv), GFP_KERNEL);\n\tif (!mac_drv)\n\t\treturn NULL;\n\n\tmac_drv->mac_init = hns_xgmac_init;\n\tmac_drv->mac_enable = hns_xgmac_enable;\n\tmac_drv->mac_disable = hns_xgmac_disable;\n\n\tmac_drv->mac_id = mac_param->mac_id;\n\tmac_drv->mac_mode = mac_param->mac_mode;\n\tmac_drv->io_base = mac_param->vaddr;\n\tmac_drv->dev = mac_param->dev;\n\tmac_drv->mac_cb = mac_cb;\n\n\tmac_drv->set_mac_addr = hns_xgmac_set_pausefrm_mac_addr;\n\tmac_drv->set_an_mode = NULL;\n\tmac_drv->config_loopback = NULL;\n\tmac_drv->config_pad_and_crc = hns_xgmac_config_pad_and_crc;\n\tmac_drv->config_half_duplex = NULL;\n\tmac_drv->set_rx_ignore_pause_frames =\n\t\thns_xgmac_set_rx_ignore_pause_frames;\n\tmac_drv->mac_free = hns_xgmac_free;\n\tmac_drv->adjust_link = NULL;\n\tmac_drv->set_tx_auto_pause_frames = hns_xgmac_set_tx_auto_pause_frames;\n\tmac_drv->config_max_frame_length = hns_xgmac_config_max_frame_length;\n\tmac_drv->mac_pausefrm_cfg = hns_xgmac_pausefrm_cfg;\n\tmac_drv->autoneg_stat = NULL;\n\tmac_drv->get_info = hns_xgmac_get_info;\n\tmac_drv->get_pause_enable = hns_xgmac_get_pausefrm_cfg;\n\tmac_drv->get_link_status = hns_xgmac_get_link_status;\n\tmac_drv->get_regs = hns_xgmac_get_regs;\n\tmac_drv->get_ethtool_stats = hns_xgmac_get_stats;\n\tmac_drv->get_sset_count = hns_xgmac_get_sset_count;\n\tmac_drv->get_regs_count = hns_xgmac_get_regs_count;\n\tmac_drv->get_strings = hns_xgmac_get_strings;\n\tmac_drv->update_stats = hns_xgmac_update_stats;\n\n\treturn (void *)mac_drv;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2014-2015 Hisilicon Limited.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/delay.h>\n#include <linux/of_mdio.h>\n#include \"hns_dsaf_main.h\"\n#include \"hns_dsaf_mac.h\"\n#include \"hns_dsaf_gmac.h\"\n\nstatic const struct mac_stats_string g_gmac_stats_string[] = {\n\t{\"gmac_rx_octets_total_ok\", MAC_STATS_FIELD_OFF(rx_good_bytes)},\n\t{\"gmac_rx_octets_bad\", MAC_STATS_FIELD_OFF(rx_bad_bytes)},\n\t{\"gmac_rx_uc_pkts\", MAC_STATS_FIELD_OFF(rx_uc_pkts)},\n\t{\"gmac_rx_mc_pkts\", MAC_STATS_FIELD_OFF(rx_mc_pkts)},\n\t{\"gmac_rx_bc_pkts\", MAC_STATS_FIELD_OFF(rx_bc_pkts)},\n\t{\"gmac_rx_pkts_64octets\", MAC_STATS_FIELD_OFF(rx_64bytes)},\n\t{\"gmac_rx_pkts_65to127\", MAC_STATS_FIELD_OFF(rx_65to127)},\n\t{\"gmac_rx_pkts_128to255\", MAC_STATS_FIELD_OFF(rx_128to255)},\n\t{\"gmac_rx_pkts_256to511\", MAC_STATS_FIELD_OFF(rx_256to511)},\n\t{\"gmac_rx_pkts_512to1023\", MAC_STATS_FIELD_OFF(rx_512to1023)},\n\t{\"gmac_rx_pkts_1024to1518\", MAC_STATS_FIELD_OFF(rx_1024to1518)},\n\t{\"gmac_rx_pkts_1519tomax\", MAC_STATS_FIELD_OFF(rx_1519tomax)},\n\t{\"gmac_rx_fcs_errors\", MAC_STATS_FIELD_OFF(rx_fcs_err)},\n\t{\"gmac_rx_tagged\", MAC_STATS_FIELD_OFF(rx_vlan_pkts)},\n\t{\"gmac_rx_data_err\", MAC_STATS_FIELD_OFF(rx_data_err)},\n\t{\"gmac_rx_align_errors\", MAC_STATS_FIELD_OFF(rx_align_err)},\n\t{\"gmac_rx_long_errors\", MAC_STATS_FIELD_OFF(rx_oversize)},\n\t{\"gmac_rx_jabber_errors\", MAC_STATS_FIELD_OFF(rx_jabber_err)},\n\t{\"gmac_rx_pause_maccontrol\", MAC_STATS_FIELD_OFF(rx_pfc_tc0)},\n\t{\"gmac_rx_unknown_maccontrol\", MAC_STATS_FIELD_OFF(rx_unknown_ctrl)},\n\t{\"gmac_rx_very_long_err\", MAC_STATS_FIELD_OFF(rx_long_err)},\n\t{\"gmac_rx_runt_err\", MAC_STATS_FIELD_OFF(rx_minto64)},\n\t{\"gmac_rx_short_err\", MAC_STATS_FIELD_OFF(rx_under_min)},\n\t{\"gmac_rx_filt_pkt\", MAC_STATS_FIELD_OFF(rx_filter_pkts)},\n\t{\"gmac_rx_octets_total_filt\", MAC_STATS_FIELD_OFF(rx_filter_bytes)},\n\t{\"gmac_rx_overrun_cnt\", MAC_STATS_FIELD_OFF(rx_fifo_overrun_err)},\n\t{\"gmac_rx_length_err\", MAC_STATS_FIELD_OFF(rx_len_err)},\n\t{\"gmac_rx_fail_comma\", MAC_STATS_FIELD_OFF(rx_comma_err)},\n\n\t{\"gmac_tx_octets_ok\", MAC_STATS_FIELD_OFF(tx_good_bytes)},\n\t{\"gmac_tx_octets_bad\", MAC_STATS_FIELD_OFF(tx_bad_bytes)},\n\t{\"gmac_tx_uc_pkts\", MAC_STATS_FIELD_OFF(tx_uc_pkts)},\n\t{\"gmac_tx_mc_pkts\", MAC_STATS_FIELD_OFF(tx_mc_pkts)},\n\t{\"gmac_tx_bc_pkts\", MAC_STATS_FIELD_OFF(tx_bc_pkts)},\n\t{\"gmac_tx_pkts_64octets\", MAC_STATS_FIELD_OFF(tx_64bytes)},\n\t{\"gmac_tx_pkts_65to127\", MAC_STATS_FIELD_OFF(tx_65to127)},\n\t{\"gmac_tx_pkts_128to255\", MAC_STATS_FIELD_OFF(tx_128to255)},\n\t{\"gmac_tx_pkts_256to511\", MAC_STATS_FIELD_OFF(tx_256to511)},\n\t{\"gmac_tx_pkts_512to1023\", MAC_STATS_FIELD_OFF(tx_512to1023)},\n\t{\"gmac_tx_pkts_1024to1518\", MAC_STATS_FIELD_OFF(tx_1024to1518)},\n\t{\"gmac_tx_pkts_1519tomax\", MAC_STATS_FIELD_OFF(tx_1519tomax)},\n\t{\"gmac_tx_excessive_length_drop\", MAC_STATS_FIELD_OFF(tx_jabber_err)},\n\t{\"gmac_tx_underrun\", MAC_STATS_FIELD_OFF(tx_underrun_err)},\n\t{\"gmac_tx_tagged\", MAC_STATS_FIELD_OFF(tx_vlan)},\n\t{\"gmac_tx_crc_error\", MAC_STATS_FIELD_OFF(tx_crc_err)},\n\t{\"gmac_tx_pause_frames\", MAC_STATS_FIELD_OFF(tx_pfc_tc0)}\n};\n\nstatic void hns_gmac_enable(void *mac_drv, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t/*enable GE rX/tX */\n\tif ((mode == MAC_COMM_MODE_TX) || (mode == MAC_COMM_MODE_RX_AND_TX))\n\t\tdsaf_set_dev_bit(drv, GMAC_PORT_EN_REG, GMAC_PORT_TX_EN_B, 1);\n\n\tif ((mode == MAC_COMM_MODE_RX) || (mode == MAC_COMM_MODE_RX_AND_TX))\n\t\tdsaf_set_dev_bit(drv, GMAC_PORT_EN_REG, GMAC_PORT_RX_EN_B, 1);\n}\n\nstatic void hns_gmac_disable(void *mac_drv, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t/*disable GE rX/tX */\n\tif ((mode == MAC_COMM_MODE_TX) || (mode == MAC_COMM_MODE_RX_AND_TX))\n\t\tdsaf_set_dev_bit(drv, GMAC_PORT_EN_REG, GMAC_PORT_TX_EN_B, 0);\n\n\tif ((mode == MAC_COMM_MODE_RX) || (mode == MAC_COMM_MODE_RX_AND_TX))\n\t\tdsaf_set_dev_bit(drv, GMAC_PORT_EN_REG, GMAC_PORT_RX_EN_B, 0);\n}\n\n/* hns_gmac_get_en - get port enable\n * @mac_drv:mac device\n * @rx:rx enable\n * @tx:tx enable\n */\nstatic void hns_gmac_get_en(void *mac_drv, u32 *rx, u32 *tx)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 porten;\n\n\tporten = dsaf_read_dev(drv, GMAC_PORT_EN_REG);\n\t*tx = dsaf_get_bit(porten, GMAC_PORT_TX_EN_B);\n\t*rx = dsaf_get_bit(porten, GMAC_PORT_RX_EN_B);\n}\n\nstatic void hns_gmac_free(void *mac_drv)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct dsaf_device *dsaf_dev\n\t\t= (struct dsaf_device *)dev_get_drvdata(drv->dev);\n\n\tu32 mac_id = drv->mac_id;\n\n\tdsaf_dev->misc_op->ge_srst(dsaf_dev, mac_id, 0);\n}\n\nstatic void hns_gmac_set_tx_auto_pause_frames(void *mac_drv, u16 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_field(drv, GMAC_FC_TX_TIMER_REG, GMAC_FC_TX_TIMER_M,\n\t\t\t   GMAC_FC_TX_TIMER_S, newval);\n}\n\nstatic void hns_gmac_get_tx_auto_pause_frames(void *mac_drv, u16 *newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*newval = dsaf_get_dev_field(drv, GMAC_FC_TX_TIMER_REG,\n\t\t\t\t     GMAC_FC_TX_TIMER_M, GMAC_FC_TX_TIMER_S);\n}\n\nstatic void hns_gmac_set_rx_auto_pause_frames(void *mac_drv, u32 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_PAUSE_EN_REG,\n\t\t\t GMAC_PAUSE_EN_RX_FDFC_B, !!newval);\n}\n\nstatic void hns_gmac_config_max_frame_length(void *mac_drv, u16 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_field(drv, GMAC_MAX_FRM_SIZE_REG, GMAC_MAX_FRM_SIZE_M,\n\t\t\t   GMAC_MAX_FRM_SIZE_S, newval);\n\n\tdsaf_set_dev_field(drv, GAMC_RX_MAX_FRAME, GMAC_MAX_FRM_SIZE_M,\n\t\t\t   GMAC_MAX_FRM_SIZE_S, newval);\n}\n\nstatic void hns_gmac_config_pad_and_crc(void *mac_drv, u8 newval)\n{\n\tu32 tx_ctrl;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\ttx_ctrl = dsaf_read_dev(drv, GMAC_TRANSMIT_CONTROL_REG);\n\tdsaf_set_bit(tx_ctrl, GMAC_TX_PAD_EN_B, !!newval);\n\tdsaf_set_bit(tx_ctrl, GMAC_TX_CRC_ADD_B, !!newval);\n\tdsaf_write_dev(drv, GMAC_TRANSMIT_CONTROL_REG, tx_ctrl);\n}\n\nstatic void hns_gmac_config_an_mode(void *mac_drv, u8 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_TRANSMIT_CONTROL_REG,\n\t\t\t GMAC_TX_AN_EN_B, !!newval);\n}\n\nstatic void hns_gmac_tx_loop_pkt_dis(void *mac_drv)\n{\n\tu32 tx_loop_pkt_pri;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\ttx_loop_pkt_pri = dsaf_read_dev(drv, GMAC_TX_LOOP_PKT_PRI_REG);\n\tdsaf_set_bit(tx_loop_pkt_pri, GMAC_TX_LOOP_PKT_EN_B, 1);\n\tdsaf_set_bit(tx_loop_pkt_pri, GMAC_TX_LOOP_PKT_HIG_PRI_B, 0);\n\tdsaf_write_dev(drv, GMAC_TX_LOOP_PKT_PRI_REG, tx_loop_pkt_pri);\n}\n\nstatic void hns_gmac_set_duplex_type(void *mac_drv, u8 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_DUPLEX_TYPE_REG,\n\t\t\t GMAC_DUPLEX_TYPE_B, !!newval);\n}\n\nstatic void hns_gmac_get_duplex_type(void *mac_drv,\n\t\t\t\t     enum hns_gmac_duplex_mdoe *duplex_mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*duplex_mode = (enum hns_gmac_duplex_mdoe)dsaf_get_dev_bit(\n\t\tdrv, GMAC_DUPLEX_TYPE_REG, GMAC_DUPLEX_TYPE_B);\n}\n\nstatic void hns_gmac_get_port_mode(void *mac_drv, enum hns_port_mode *port_mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*port_mode = (enum hns_port_mode)dsaf_get_dev_field(\n\t\tdrv, GMAC_PORT_MODE_REG, GMAC_PORT_MODE_M, GMAC_PORT_MODE_S);\n}\n\nstatic void hns_gmac_port_mode_get(void *mac_drv,\n\t\t\t\t   struct hns_gmac_port_mode_cfg *port_mode)\n{\n\tu32 tx_ctrl;\n\tu32 recv_ctrl;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tport_mode->port_mode = (enum hns_port_mode)dsaf_get_dev_field(\n\t\tdrv, GMAC_PORT_MODE_REG, GMAC_PORT_MODE_M, GMAC_PORT_MODE_S);\n\n\ttx_ctrl = dsaf_read_dev(drv, GMAC_TRANSMIT_CONTROL_REG);\n\trecv_ctrl = dsaf_read_dev(drv, GMAC_RECV_CONTROL_REG);\n\n\tport_mode->max_frm_size =\n\t\tdsaf_get_dev_field(drv, GMAC_MAX_FRM_SIZE_REG,\n\t\t\t\t   GMAC_MAX_FRM_SIZE_M, GMAC_MAX_FRM_SIZE_S);\n\tport_mode->short_runts_thr =\n\t\tdsaf_get_dev_field(drv, GMAC_SHORT_RUNTS_THR_REG,\n\t\t\t\t   GMAC_SHORT_RUNTS_THR_M,\n\t\t\t\t   GMAC_SHORT_RUNTS_THR_S);\n\n\tport_mode->pad_enable = dsaf_get_bit(tx_ctrl, GMAC_TX_PAD_EN_B);\n\tport_mode->crc_add = dsaf_get_bit(tx_ctrl, GMAC_TX_CRC_ADD_B);\n\tport_mode->an_enable = dsaf_get_bit(tx_ctrl, GMAC_TX_AN_EN_B);\n\n\tport_mode->runt_pkt_en =\n\t\tdsaf_get_bit(recv_ctrl, GMAC_RECV_CTRL_RUNT_PKT_EN_B);\n\tport_mode->strip_pad_en =\n\t\tdsaf_get_bit(recv_ctrl, GMAC_RECV_CTRL_STRIP_PAD_EN_B);\n}\n\nstatic void hns_gmac_pause_frm_cfg(void *mac_drv, u32 rx_pause_en,\n\t\t\t\t   u32 tx_pause_en)\n{\n\tu32 pause_en;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tpause_en = dsaf_read_dev(drv, GMAC_PAUSE_EN_REG);\n\tdsaf_set_bit(pause_en, GMAC_PAUSE_EN_RX_FDFC_B, !!rx_pause_en);\n\tdsaf_set_bit(pause_en, GMAC_PAUSE_EN_TX_FDFC_B, !!tx_pause_en);\n\tdsaf_write_dev(drv, GMAC_PAUSE_EN_REG, pause_en);\n}\n\nstatic void hns_gmac_get_pausefrm_cfg(void *mac_drv, u32 *rx_pause_en,\n\t\t\t\t      u32 *tx_pause_en)\n{\n\tu32 pause_en;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tpause_en = dsaf_read_dev(drv, GMAC_PAUSE_EN_REG);\n\n\t*rx_pause_en = dsaf_get_bit(pause_en, GMAC_PAUSE_EN_RX_FDFC_B);\n\t*tx_pause_en = dsaf_get_bit(pause_en, GMAC_PAUSE_EN_TX_FDFC_B);\n}\n\nstatic int hns_gmac_adjust_link(void *mac_drv, enum mac_speed speed,\n\t\t\t\tu32 full_duplex)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_DUPLEX_TYPE_REG,\n\t\t\t GMAC_DUPLEX_TYPE_B, !!full_duplex);\n\n\tswitch (speed) {\n\tcase MAC_SPEED_10:\n\t\tdsaf_set_dev_field(\n\t\t\tdrv, GMAC_PORT_MODE_REG,\n\t\t\tGMAC_PORT_MODE_M, GMAC_PORT_MODE_S, 0x6);\n\t\tbreak;\n\tcase MAC_SPEED_100:\n\t\tdsaf_set_dev_field(\n\t\t\tdrv, GMAC_PORT_MODE_REG,\n\t\t\tGMAC_PORT_MODE_M, GMAC_PORT_MODE_S, 0x7);\n\t\tbreak;\n\tcase MAC_SPEED_1000:\n\t\tdsaf_set_dev_field(\n\t\t\tdrv, GMAC_PORT_MODE_REG,\n\t\t\tGMAC_PORT_MODE_M, GMAC_PORT_MODE_S, 0x8);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(drv->dev,\n\t\t\t\"hns_gmac_adjust_link fail, speed%d mac%d\\n\",\n\t\t\tspeed, drv->mac_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hns_gmac_set_uc_match(void *mac_drv, u16 en)\n{\n\tstruct mac_driver *drv = mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_REC_FILT_CONTROL_REG,\n\t\t\t GMAC_UC_MATCH_EN_B, !en);\n\tdsaf_set_dev_bit(drv, GMAC_STATION_ADDR_HIGH_2_REG,\n\t\t\t GMAC_ADDR_EN_B, !en);\n}\n\nstatic void hns_gmac_set_promisc(void *mac_drv, u8 en)\n{\n\tstruct mac_driver *drv = mac_drv;\n\n\tif (drv->mac_cb->mac_type == HNAE_PORT_DEBUG)\n\t\thns_gmac_set_uc_match(mac_drv, en);\n}\n\nstatic void hns_gmac_init(void *mac_drv)\n{\n\tu32 port;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct dsaf_device *dsaf_dev\n\t\t= (struct dsaf_device *)dev_get_drvdata(drv->dev);\n\n\tport = drv->mac_id;\n\n\tdsaf_dev->misc_op->ge_srst(dsaf_dev, port, 0);\n\tmdelay(10);\n\tdsaf_dev->misc_op->ge_srst(dsaf_dev, port, 1);\n\tmdelay(10);\n\thns_gmac_disable(mac_drv, MAC_COMM_MODE_RX_AND_TX);\n\thns_gmac_tx_loop_pkt_dis(mac_drv);\n\tif (drv->mac_cb->mac_type == HNAE_PORT_DEBUG)\n\t\thns_gmac_set_uc_match(mac_drv, 0);\n\n\thns_gmac_config_pad_and_crc(mac_drv, 1);\n\n\tdsaf_set_dev_bit(drv, GMAC_MODE_CHANGE_EN_REG,\n\t\t\t GMAC_MODE_CHANGE_EB_B, 1);\n\n\t/* reduce gmac tx water line to avoid gmac hang-up\n\t * in speed 100M and duplex half.\n\t */\n\tdsaf_set_dev_field(drv, GMAC_TX_WATER_LINE_REG, GMAC_TX_WATER_LINE_MASK,\n\t\t\t   GMAC_TX_WATER_LINE_SHIFT, 8);\n}\n\nvoid hns_gmac_update_stats(void *mac_drv)\n{\n\tstruct mac_hw_stats *hw_stats = NULL;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\thw_stats = &drv->mac_cb->hw_stats;\n\n\t/* RX */\n\thw_stats->rx_good_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_RX_OCTETS_TOTAL_OK_REG);\n\thw_stats->rx_bad_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_RX_OCTETS_BAD_REG);\n\thw_stats->rx_uc_pkts += dsaf_read_dev(drv, GMAC_RX_UC_PKTS_REG);\n\thw_stats->rx_mc_pkts += dsaf_read_dev(drv, GMAC_RX_MC_PKTS_REG);\n\thw_stats->rx_bc_pkts += dsaf_read_dev(drv, GMAC_RX_BC_PKTS_REG);\n\thw_stats->rx_64bytes\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_64OCTETS_REG);\n\thw_stats->rx_65to127\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_65TO127OCTETS_REG);\n\thw_stats->rx_128to255\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_128TO255OCTETS_REG);\n\thw_stats->rx_256to511\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_255TO511OCTETS_REG);\n\thw_stats->rx_512to1023\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_512TO1023OCTETS_REG);\n\thw_stats->rx_1024to1518\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_1024TO1518OCTETS_REG);\n\thw_stats->rx_1519tomax\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PKTS_1519TOMAXOCTETS_REG);\n\thw_stats->rx_fcs_err += dsaf_read_dev(drv, GMAC_RX_FCS_ERRORS_REG);\n\thw_stats->rx_vlan_pkts += dsaf_read_dev(drv, GMAC_RX_TAGGED_REG);\n\thw_stats->rx_data_err += dsaf_read_dev(drv, GMAC_RX_DATA_ERR_REG);\n\thw_stats->rx_align_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_ALIGN_ERRORS_REG);\n\thw_stats->rx_oversize\n\t\t+= dsaf_read_dev(drv, GMAC_RX_LONG_ERRORS_REG);\n\thw_stats->rx_jabber_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_JABBER_ERRORS_REG);\n\thw_stats->rx_pfc_tc0\n\t\t+= dsaf_read_dev(drv, GMAC_RX_PAUSE_MACCTRL_FRAM_REG);\n\thw_stats->rx_unknown_ctrl\n\t\t+= dsaf_read_dev(drv, GMAC_RX_UNKNOWN_MACCTRL_FRAM_REG);\n\thw_stats->rx_long_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_VERY_LONG_ERR_CNT_REG);\n\thw_stats->rx_minto64\n\t\t+= dsaf_read_dev(drv, GMAC_RX_RUNT_ERR_CNT_REG);\n\thw_stats->rx_under_min\n\t\t+= dsaf_read_dev(drv, GMAC_RX_SHORT_ERR_CNT_REG);\n\thw_stats->rx_filter_pkts\n\t\t+= dsaf_read_dev(drv, GMAC_RX_FILT_PKT_CNT_REG);\n\thw_stats->rx_filter_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_RX_OCTETS_TOTAL_FILT_REG);\n\thw_stats->rx_fifo_overrun_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_OVERRUN_CNT_REG);\n\thw_stats->rx_len_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_LENGTHFIELD_ERR_CNT_REG);\n\thw_stats->rx_comma_err\n\t\t+= dsaf_read_dev(drv, GMAC_RX_FAIL_COMMA_CNT_REG);\n\n\t/* TX */\n\thw_stats->tx_good_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_OCTETS_TRANSMITTED_OK_REG);\n\thw_stats->tx_bad_bytes\n\t\t+= dsaf_read_dev(drv, GMAC_OCTETS_TRANSMITTED_BAD_REG);\n\thw_stats->tx_uc_pkts += dsaf_read_dev(drv, GMAC_TX_UC_PKTS_REG);\n\thw_stats->tx_mc_pkts += dsaf_read_dev(drv, GMAC_TX_MC_PKTS_REG);\n\thw_stats->tx_bc_pkts += dsaf_read_dev(drv, GMAC_TX_BC_PKTS_REG);\n\thw_stats->tx_64bytes\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_64OCTETS_REG);\n\thw_stats->tx_65to127\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_65TO127OCTETS_REG);\n\thw_stats->tx_128to255\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_128TO255OCTETS_REG);\n\thw_stats->tx_256to511\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_255TO511OCTETS_REG);\n\thw_stats->tx_512to1023\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_512TO1023OCTETS_REG);\n\thw_stats->tx_1024to1518\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_1024TO1518OCTETS_REG);\n\thw_stats->tx_1519tomax\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PKTS_1519TOMAXOCTETS_REG);\n\thw_stats->tx_jabber_err\n\t\t+= dsaf_read_dev(drv, GMAC_TX_EXCESSIVE_LENGTH_DROP_REG);\n\thw_stats->tx_underrun_err\n\t\t+= dsaf_read_dev(drv, GMAC_TX_UNDERRUN_REG);\n\thw_stats->tx_vlan += dsaf_read_dev(drv, GMAC_TX_TAGGED_REG);\n\thw_stats->tx_crc_err += dsaf_read_dev(drv, GMAC_TX_CRC_ERROR_REG);\n\thw_stats->tx_pfc_tc0\n\t\t+= dsaf_read_dev(drv, GMAC_TX_PAUSE_FRAMES_REG);\n}\n\nstatic void hns_gmac_set_mac_addr(void *mac_drv, char *mac_addr)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tu32 high_val = mac_addr[1] | (mac_addr[0] << 8);\n\n\tu32 low_val = mac_addr[5] | (mac_addr[4] << 8)\n\t\t| (mac_addr[3] << 16) | (mac_addr[2] << 24);\n\n\tu32 val = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG);\n\tu32 sta_addr_en = dsaf_get_bit(val, GMAC_ADDR_EN_B);\n\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_LOW_2_REG, low_val);\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG,\n\t\t       high_val | (sta_addr_en << GMAC_ADDR_EN_B));\n}\n\nstatic int hns_gmac_config_loopback(void *mac_drv, enum hnae_loop loop_mode,\n\t\t\t\t    u8 enable)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tswitch (loop_mode) {\n\tcase MAC_INTERNALLOOP_MAC:\n\t\tdsaf_set_dev_bit(drv, GMAC_LOOP_REG, GMAC_LP_REG_CF2MI_LP_EN_B,\n\t\t\t\t !!enable);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(drv->dev, \"loop_mode error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hns_gmac_get_info(void *mac_drv, struct mac_info *mac_info)\n{\n\tenum hns_gmac_duplex_mdoe duplex;\n\tenum hns_port_mode speed;\n\tu32 rx_pause;\n\tu32 tx_pause;\n\tu32 rx;\n\tu32 tx;\n\tu16 fc_tx_timer;\n\tstruct hns_gmac_port_mode_cfg port_mode = { GMAC_10M_MII, 0 };\n\n\thns_gmac_port_mode_get(mac_drv, &port_mode);\n\tmac_info->pad_and_crc_en = port_mode.crc_add && port_mode.pad_enable;\n\tmac_info->auto_neg = port_mode.an_enable;\n\n\thns_gmac_get_tx_auto_pause_frames(mac_drv, &fc_tx_timer);\n\tmac_info->tx_pause_time = fc_tx_timer;\n\n\thns_gmac_get_en(mac_drv, &rx, &tx);\n\tmac_info->port_en = rx && tx;\n\n\thns_gmac_get_duplex_type(mac_drv, &duplex);\n\tmac_info->duplex = duplex;\n\n\thns_gmac_get_port_mode(mac_drv, &speed);\n\tswitch (speed) {\n\tcase GMAC_10M_SGMII:\n\t\tmac_info->speed = MAC_SPEED_10;\n\t\tbreak;\n\tcase GMAC_100M_SGMII:\n\t\tmac_info->speed = MAC_SPEED_100;\n\t\tbreak;\n\tcase GMAC_1000M_SGMII:\n\t\tmac_info->speed = MAC_SPEED_1000;\n\t\tbreak;\n\tdefault:\n\t\tmac_info->speed = 0;\n\t\tbreak;\n\t}\n\n\thns_gmac_get_pausefrm_cfg(mac_drv, &rx_pause, &tx_pause);\n\tmac_info->rx_pause_en = rx_pause;\n\tmac_info->tx_pause_en = tx_pause;\n}\n\nstatic void hns_gmac_autoneg_stat(void *mac_drv, u32 *enable)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*enable = dsaf_get_dev_bit(drv, GMAC_TRANSMIT_CONTROL_REG,\n\t\t\t\t   GMAC_TX_AN_EN_B);\n}\n\nstatic void hns_gmac_get_link_status(void *mac_drv, u32 *link_stat)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*link_stat = dsaf_get_dev_bit(drv, GMAC_AN_NEG_STATE_REG,\n\t\t\t\t      GMAC_AN_NEG_STAT_RX_SYNC_OK_B);\n}\n\nstatic void hns_gmac_get_regs(void *mac_drv, void *data)\n{\n\tu32 *regs = data;\n\tint i;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t/* base config registers */\n\tregs[0] = dsaf_read_dev(drv, GMAC_DUPLEX_TYPE_REG);\n\tregs[1] = dsaf_read_dev(drv, GMAC_FD_FC_TYPE_REG);\n\tregs[2] = dsaf_read_dev(drv, GMAC_FC_TX_TIMER_REG);\n\tregs[3] = dsaf_read_dev(drv, GMAC_FD_FC_ADDR_LOW_REG);\n\tregs[4] = dsaf_read_dev(drv, GMAC_FD_FC_ADDR_HIGH_REG);\n\tregs[5] = dsaf_read_dev(drv, GMAC_IPG_TX_TIMER_REG);\n\tregs[6] = dsaf_read_dev(drv, GMAC_PAUSE_THR_REG);\n\tregs[7] = dsaf_read_dev(drv, GMAC_MAX_FRM_SIZE_REG);\n\tregs[8] = dsaf_read_dev(drv, GMAC_PORT_MODE_REG);\n\tregs[9] = dsaf_read_dev(drv, GMAC_PORT_EN_REG);\n\tregs[10] = dsaf_read_dev(drv, GMAC_PAUSE_EN_REG);\n\tregs[11] = dsaf_read_dev(drv, GMAC_SHORT_RUNTS_THR_REG);\n\tregs[12] = dsaf_read_dev(drv, GMAC_AN_NEG_STATE_REG);\n\tregs[13] = dsaf_read_dev(drv, GMAC_TX_LOCAL_PAGE_REG);\n\tregs[14] = dsaf_read_dev(drv, GMAC_TRANSMIT_CONTROL_REG);\n\tregs[15] = dsaf_read_dev(drv, GMAC_REC_FILT_CONTROL_REG);\n\tregs[16] = dsaf_read_dev(drv, GMAC_PTP_CONFIG_REG);\n\n\t/* rx static registers */\n\tregs[17] = dsaf_read_dev(drv, GMAC_RX_OCTETS_TOTAL_OK_REG);\n\tregs[18] = dsaf_read_dev(drv, GMAC_RX_OCTETS_BAD_REG);\n\tregs[19] = dsaf_read_dev(drv, GMAC_RX_UC_PKTS_REG);\n\tregs[20] = dsaf_read_dev(drv, GMAC_RX_MC_PKTS_REG);\n\tregs[21] = dsaf_read_dev(drv, GMAC_RX_BC_PKTS_REG);\n\tregs[22] = dsaf_read_dev(drv, GMAC_RX_PKTS_64OCTETS_REG);\n\tregs[23] = dsaf_read_dev(drv, GMAC_RX_PKTS_65TO127OCTETS_REG);\n\tregs[24] = dsaf_read_dev(drv, GMAC_RX_PKTS_128TO255OCTETS_REG);\n\tregs[25] = dsaf_read_dev(drv, GMAC_RX_PKTS_255TO511OCTETS_REG);\n\tregs[26] = dsaf_read_dev(drv, GMAC_RX_PKTS_512TO1023OCTETS_REG);\n\tregs[27] = dsaf_read_dev(drv, GMAC_RX_PKTS_1024TO1518OCTETS_REG);\n\tregs[28] = dsaf_read_dev(drv, GMAC_RX_PKTS_1519TOMAXOCTETS_REG);\n\tregs[29] = dsaf_read_dev(drv, GMAC_RX_FCS_ERRORS_REG);\n\tregs[30] = dsaf_read_dev(drv, GMAC_RX_TAGGED_REG);\n\tregs[31] = dsaf_read_dev(drv, GMAC_RX_DATA_ERR_REG);\n\tregs[32] = dsaf_read_dev(drv, GMAC_RX_ALIGN_ERRORS_REG);\n\tregs[33] = dsaf_read_dev(drv, GMAC_RX_LONG_ERRORS_REG);\n\tregs[34] = dsaf_read_dev(drv, GMAC_RX_JABBER_ERRORS_REG);\n\tregs[35] = dsaf_read_dev(drv, GMAC_RX_PAUSE_MACCTRL_FRAM_REG);\n\tregs[36] = dsaf_read_dev(drv, GMAC_RX_UNKNOWN_MACCTRL_FRAM_REG);\n\tregs[37] = dsaf_read_dev(drv, GMAC_RX_VERY_LONG_ERR_CNT_REG);\n\tregs[38] = dsaf_read_dev(drv, GMAC_RX_RUNT_ERR_CNT_REG);\n\tregs[39] = dsaf_read_dev(drv, GMAC_RX_SHORT_ERR_CNT_REG);\n\tregs[40] = dsaf_read_dev(drv, GMAC_RX_FILT_PKT_CNT_REG);\n\tregs[41] = dsaf_read_dev(drv, GMAC_RX_OCTETS_TOTAL_FILT_REG);\n\n\t/* tx static registers */\n\tregs[42] = dsaf_read_dev(drv, GMAC_OCTETS_TRANSMITTED_OK_REG);\n\tregs[43] = dsaf_read_dev(drv, GMAC_OCTETS_TRANSMITTED_BAD_REG);\n\tregs[44] = dsaf_read_dev(drv, GMAC_TX_UC_PKTS_REG);\n\tregs[45] = dsaf_read_dev(drv, GMAC_TX_MC_PKTS_REG);\n\tregs[46] = dsaf_read_dev(drv, GMAC_TX_BC_PKTS_REG);\n\tregs[47] = dsaf_read_dev(drv, GMAC_TX_PKTS_64OCTETS_REG);\n\tregs[48] = dsaf_read_dev(drv, GMAC_TX_PKTS_65TO127OCTETS_REG);\n\tregs[49] = dsaf_read_dev(drv, GMAC_TX_PKTS_128TO255OCTETS_REG);\n\tregs[50] = dsaf_read_dev(drv, GMAC_TX_PKTS_255TO511OCTETS_REG);\n\tregs[51] = dsaf_read_dev(drv, GMAC_TX_PKTS_512TO1023OCTETS_REG);\n\tregs[52] = dsaf_read_dev(drv, GMAC_TX_PKTS_1024TO1518OCTETS_REG);\n\tregs[53] = dsaf_read_dev(drv, GMAC_TX_PKTS_1519TOMAXOCTETS_REG);\n\tregs[54] = dsaf_read_dev(drv, GMAC_TX_EXCESSIVE_LENGTH_DROP_REG);\n\tregs[55] = dsaf_read_dev(drv, GMAC_TX_UNDERRUN_REG);\n\tregs[56] = dsaf_read_dev(drv, GMAC_TX_TAGGED_REG);\n\tregs[57] = dsaf_read_dev(drv, GMAC_TX_CRC_ERROR_REG);\n\tregs[58] = dsaf_read_dev(drv, GMAC_TX_PAUSE_FRAMES_REG);\n\n\tregs[59] = dsaf_read_dev(drv, GAMC_RX_MAX_FRAME);\n\tregs[60] = dsaf_read_dev(drv, GMAC_LINE_LOOP_BACK_REG);\n\tregs[61] = dsaf_read_dev(drv, GMAC_CF_CRC_STRIP_REG);\n\tregs[62] = dsaf_read_dev(drv, GMAC_MODE_CHANGE_EN_REG);\n\tregs[63] = dsaf_read_dev(drv, GMAC_SIXTEEN_BIT_CNTR_REG);\n\tregs[64] = dsaf_read_dev(drv, GMAC_LD_LINK_COUNTER_REG);\n\tregs[65] = dsaf_read_dev(drv, GMAC_LOOP_REG);\n\tregs[66] = dsaf_read_dev(drv, GMAC_RECV_CONTROL_REG);\n\tregs[67] = dsaf_read_dev(drv, GMAC_VLAN_CODE_REG);\n\tregs[68] = dsaf_read_dev(drv, GMAC_RX_OVERRUN_CNT_REG);\n\tregs[69] = dsaf_read_dev(drv, GMAC_RX_LENGTHFIELD_ERR_CNT_REG);\n\tregs[70] = dsaf_read_dev(drv, GMAC_RX_FAIL_COMMA_CNT_REG);\n\n\tregs[71] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_0_REG);\n\tregs[72] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_0_REG);\n\tregs[73] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_1_REG);\n\tregs[74] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_1_REG);\n\tregs[75] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_2_REG);\n\tregs[76] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG);\n\tregs[77] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_3_REG);\n\tregs[78] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_3_REG);\n\tregs[79] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_4_REG);\n\tregs[80] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_4_REG);\n\tregs[81] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_5_REG);\n\tregs[82] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_5_REG);\n\tregs[83] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_MSK_0_REG);\n\tregs[84] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_MSK_0_REG);\n\tregs[85] = dsaf_read_dev(drv, GMAC_STATION_ADDR_LOW_MSK_1_REG);\n\tregs[86] = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_MSK_1_REG);\n\tregs[87] = dsaf_read_dev(drv, GMAC_MAC_SKIP_LEN_REG);\n\tregs[88] = dsaf_read_dev(drv, GMAC_TX_LOOP_PKT_PRI_REG);\n\n\t/* mark end of mac regs */\n\tfor (i = 89; i < 96; i++)\n\t\tregs[i] = 0xaaaaaaaa;\n}\n\nstatic void hns_gmac_get_stats(void *mac_drv, u64 *data)\n{\n\tu32 i;\n\tu64 *buf = data;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct mac_hw_stats *hw_stats = NULL;\n\n\thw_stats = &drv->mac_cb->hw_stats;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_gmac_stats_string); i++) {\n\t\tbuf[i] = DSAF_STATS_READ(hw_stats,\n\t\t\tg_gmac_stats_string[i].offset);\n\t}\n}\n\nstatic void hns_gmac_get_strings(u32 stringset, u8 *data)\n{\n\tchar *buff = (char *)data;\n\tu32 i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_gmac_stats_string); i++) {\n\t\tsnprintf(buff, ETH_GSTRING_LEN, \"%s\",\n\t\t\t g_gmac_stats_string[i].desc);\n\t\tbuff = buff + ETH_GSTRING_LEN;\n\t}\n}\n\nstatic int hns_gmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ARRAY_SIZE(g_gmac_stats_string);\n\n\treturn 0;\n}\n\nstatic int hns_gmac_get_regs_count(void)\n{\n\treturn ETH_GMAC_DUMP_NUM;\n}\n\nvoid *hns_gmac_config(struct hns_mac_cb *mac_cb, struct mac_params *mac_param)\n{\n\tstruct mac_driver *mac_drv;\n\n\tmac_drv = devm_kzalloc(mac_cb->dev, sizeof(*mac_drv), GFP_KERNEL);\n\tif (!mac_drv)\n\t\treturn NULL;\n\n\tmac_drv->mac_init = hns_gmac_init;\n\tmac_drv->mac_enable = hns_gmac_enable;\n\tmac_drv->mac_disable = hns_gmac_disable;\n\tmac_drv->mac_free = hns_gmac_free;\n\tmac_drv->adjust_link = hns_gmac_adjust_link;\n\tmac_drv->set_tx_auto_pause_frames = hns_gmac_set_tx_auto_pause_frames;\n\tmac_drv->config_max_frame_length = hns_gmac_config_max_frame_length;\n\tmac_drv->mac_pausefrm_cfg = hns_gmac_pause_frm_cfg;\n\n\tmac_drv->mac_id = mac_param->mac_id;\n\tmac_drv->mac_mode = mac_param->mac_mode;\n\tmac_drv->io_base = mac_param->vaddr;\n\tmac_drv->dev = mac_param->dev;\n\tmac_drv->mac_cb = mac_cb;\n\n\tmac_drv->set_mac_addr = hns_gmac_set_mac_addr;\n\tmac_drv->set_an_mode = hns_gmac_config_an_mode;\n\tmac_drv->config_loopback = hns_gmac_config_loopback;\n\tmac_drv->config_pad_and_crc = hns_gmac_config_pad_and_crc;\n\tmac_drv->config_half_duplex = hns_gmac_set_duplex_type;\n\tmac_drv->set_rx_ignore_pause_frames = hns_gmac_set_rx_auto_pause_frames;\n\tmac_drv->get_info = hns_gmac_get_info;\n\tmac_drv->autoneg_stat = hns_gmac_autoneg_stat;\n\tmac_drv->get_pause_enable = hns_gmac_get_pausefrm_cfg;\n\tmac_drv->get_link_status = hns_gmac_get_link_status;\n\tmac_drv->get_regs = hns_gmac_get_regs;\n\tmac_drv->get_regs_count = hns_gmac_get_regs_count;\n\tmac_drv->get_ethtool_stats = hns_gmac_get_stats;\n\tmac_drv->get_sset_count = hns_gmac_get_sset_count;\n\tmac_drv->get_strings = hns_gmac_get_strings;\n\tmac_drv->update_stats = hns_gmac_update_stats;\n\tmac_drv->set_promiscuous = hns_gmac_set_promisc;\n\n\treturn (void *)mac_drv;\n}\n", "/*\n * Copyright (c) 2014-2015 Hisilicon Limited.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n\n#include \"hns_dsaf_ppe.h\"\n\nvoid hns_ppe_set_tso_enable(struct hns_ppe_cb *ppe_cb, u32 value)\n{\n\tdsaf_set_dev_bit(ppe_cb, PPEV2_CFG_TSO_EN_REG, 0, !!value);\n}\n\nvoid hns_ppe_set_rss_key(struct hns_ppe_cb *ppe_cb,\n\t\t\t const u32 rss_key[HNS_PPEV2_RSS_KEY_NUM])\n{\n\tu32 key_item;\n\n\tfor (key_item = 0; key_item < HNS_PPEV2_RSS_KEY_NUM; key_item++)\n\t\tdsaf_write_dev(ppe_cb, PPEV2_RSS_KEY_REG + key_item * 0x4,\n\t\t\t       rss_key[key_item]);\n}\n\nvoid hns_ppe_set_indir_table(struct hns_ppe_cb *ppe_cb,\n\t\t\t     const u32 rss_tab[HNS_PPEV2_RSS_IND_TBL_SIZE])\n{\n\tint i;\n\tint reg_value;\n\n\tfor (i = 0; i < (HNS_PPEV2_RSS_IND_TBL_SIZE / 4); i++) {\n\t\treg_value = dsaf_read_dev(ppe_cb,\n\t\t\t\t\t  PPEV2_INDRECTION_TBL_REG + i * 0x4);\n\n\t\tdsaf_set_field(reg_value, PPEV2_CFG_RSS_TBL_4N0_M,\n\t\t\t       PPEV2_CFG_RSS_TBL_4N0_S,\n\t\t\t       rss_tab[i * 4 + 0] & 0x1F);\n\t\tdsaf_set_field(reg_value, PPEV2_CFG_RSS_TBL_4N1_M,\n\t\t\t       PPEV2_CFG_RSS_TBL_4N1_S,\n\t\t\t\trss_tab[i * 4 + 1] & 0x1F);\n\t\tdsaf_set_field(reg_value, PPEV2_CFG_RSS_TBL_4N2_M,\n\t\t\t       PPEV2_CFG_RSS_TBL_4N2_S,\n\t\t\t\trss_tab[i * 4 + 2] & 0x1F);\n\t\tdsaf_set_field(reg_value, PPEV2_CFG_RSS_TBL_4N3_M,\n\t\t\t       PPEV2_CFG_RSS_TBL_4N3_S,\n\t\t\t\trss_tab[i * 4 + 3] & 0x1F);\n\t\tdsaf_write_dev(\n\t\t\tppe_cb, PPEV2_INDRECTION_TBL_REG + i * 0x4, reg_value);\n\t}\n}\n\nstatic void __iomem *\nhns_ppe_common_get_ioaddr(struct ppe_common_cb *ppe_common)\n{\n\treturn ppe_common->dsaf_dev->ppe_base + PPE_COMMON_REG_OFFSET;\n}\n\n/**\n * hns_ppe_common_get_cfg - get ppe common config\n * @dsaf_dev: dasf device\n * comm_index: common index\n * retuen 0 - success , negative --fail\n */\nint hns_ppe_common_get_cfg(struct dsaf_device *dsaf_dev, int comm_index)\n{\n\tstruct ppe_common_cb *ppe_common;\n\tint ppe_num;\n\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev))\n\t\tppe_num = HNS_PPE_SERVICE_NW_ENGINE_NUM;\n\telse\n\t\tppe_num = HNS_PPE_DEBUG_NW_ENGINE_NUM;\n\n\tppe_common = devm_kzalloc(dsaf_dev->dev, sizeof(*ppe_common) +\n\t\tppe_num * sizeof(struct hns_ppe_cb), GFP_KERNEL);\n\tif (!ppe_common)\n\t\treturn -ENOMEM;\n\n\tppe_common->ppe_num = ppe_num;\n\tppe_common->dsaf_dev = dsaf_dev;\n\tppe_common->comm_index = comm_index;\n\tif (!HNS_DSAF_IS_DEBUG(dsaf_dev))\n\t\tppe_common->ppe_mode = PPE_COMMON_MODE_SERVICE;\n\telse\n\t\tppe_common->ppe_mode = PPE_COMMON_MODE_DEBUG;\n\tppe_common->dev = dsaf_dev->dev;\n\n\tppe_common->io_base = hns_ppe_common_get_ioaddr(ppe_common);\n\n\tdsaf_dev->ppe_common[comm_index] = ppe_common;\n\n\treturn 0;\n}\n\nvoid hns_ppe_common_free_cfg(struct dsaf_device *dsaf_dev, u32 comm_index)\n{\n\tdsaf_dev->ppe_common[comm_index] = NULL;\n}\n\nstatic void __iomem *hns_ppe_get_iobase(struct ppe_common_cb *ppe_common,\n\t\t\t\t\tint ppe_idx)\n{\n\treturn ppe_common->dsaf_dev->ppe_base + ppe_idx * PPE_REG_OFFSET;\n}\n\nstatic void hns_ppe_get_cfg(struct ppe_common_cb *ppe_common)\n{\n\tu32 i;\n\tstruct hns_ppe_cb *ppe_cb;\n\tu32 ppe_num = ppe_common->ppe_num;\n\n\tfor (i = 0; i < ppe_num; i++) {\n\t\tppe_cb = &ppe_common->ppe_cb[i];\n\t\tppe_cb->dev = ppe_common->dev;\n\t\tppe_cb->next = NULL;\n\t\tppe_cb->ppe_common_cb = ppe_common;\n\t\tppe_cb->index = i;\n\t\tppe_cb->io_base = hns_ppe_get_iobase(ppe_common, i);\n\t\tppe_cb->virq = 0;\n\t}\n}\n\nstatic void hns_ppe_cnt_clr_ce(struct hns_ppe_cb *ppe_cb)\n{\n\tdsaf_set_dev_bit(ppe_cb, PPE_TNL_0_5_CNT_CLR_CE_REG,\n\t\t\t PPE_CNT_CLR_CE_B, 1);\n}\n\nstatic void hns_ppe_set_vlan_strip(struct hns_ppe_cb *ppe_cb, int en)\n{\n\tdsaf_write_dev(ppe_cb, PPEV2_VLAN_STRIP_EN_REG, en);\n}\n\n/**\n * hns_ppe_checksum_hw - set ppe checksum caculate\n * @ppe_device: ppe device\n * @value: value\n */\nstatic void hns_ppe_checksum_hw(struct hns_ppe_cb *ppe_cb, u32 value)\n{\n\tdsaf_set_dev_field(ppe_cb, PPE_CFG_PRO_CHECK_EN_REG,\n\t\t\t   0xfffffff, 0, value);\n}\n\nstatic void hns_ppe_set_qid_mode(struct ppe_common_cb *ppe_common,\n\t\t\t\t enum ppe_qid_mode qid_mdoe)\n{\n\tdsaf_set_dev_field(ppe_common, PPE_COM_CFG_QID_MODE_REG,\n\t\t\t   PPE_CFG_QID_MODE_CF_QID_MODE_M,\n\t\t\t   PPE_CFG_QID_MODE_CF_QID_MODE_S, qid_mdoe);\n}\n\n/**\n * hns_ppe_set_qid - set ppe qid\n * @ppe_common: ppe common device\n * @qid: queue id\n */\nstatic void hns_ppe_set_qid(struct ppe_common_cb *ppe_common, u32 qid)\n{\n\tu32 qid_mod = dsaf_read_dev(ppe_common, PPE_COM_CFG_QID_MODE_REG);\n\n\tif (!dsaf_get_field(qid_mod, PPE_CFG_QID_MODE_DEF_QID_M,\n\t\t\t    PPE_CFG_QID_MODE_DEF_QID_S)) {\n\t\tdsaf_set_field(qid_mod, PPE_CFG_QID_MODE_DEF_QID_M,\n\t\t\t       PPE_CFG_QID_MODE_DEF_QID_S, qid);\n\t\tdsaf_write_dev(ppe_common, PPE_COM_CFG_QID_MODE_REG, qid_mod);\n\t}\n}\n\n/**\n * hns_ppe_set_port_mode - set port mode\n * @ppe_device: ppe device\n * @mode: port mode\n */\nstatic void hns_ppe_set_port_mode(struct hns_ppe_cb *ppe_cb,\n\t\t\t\t  enum ppe_port_mode mode)\n{\n\tdsaf_write_dev(ppe_cb, PPE_CFG_XGE_MODE_REG, mode);\n}\n\n/**\n * hns_ppe_common_init_hw - init ppe common device\n * @ppe_common: ppe common device\n *\n * Return 0 on success, negative on failure\n */\nstatic int hns_ppe_common_init_hw(struct ppe_common_cb *ppe_common)\n{\n\tenum ppe_qid_mode qid_mode;\n\tstruct dsaf_device *dsaf_dev = ppe_common->dsaf_dev;\n\tenum dsaf_mode dsaf_mode = dsaf_dev->dsaf_mode;\n\n\tdsaf_dev->misc_op->ppe_comm_srst(dsaf_dev, 0);\n\tmdelay(100);\n\tdsaf_dev->misc_op->ppe_comm_srst(dsaf_dev, 1);\n\tmdelay(100);\n\n\tif (ppe_common->ppe_mode == PPE_COMMON_MODE_SERVICE) {\n\t\tswitch (dsaf_mode) {\n\t\tcase DSAF_MODE_ENABLE_FIX:\n\t\tcase DSAF_MODE_DISABLE_FIX:\n\t\t\tqid_mode = PPE_QID_MODE0;\n\t\t\thns_ppe_set_qid(ppe_common, 0);\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_0VM:\n\t\tcase DSAF_MODE_DISABLE_2PORT_64VM:\n\t\t\tqid_mode = PPE_QID_MODE3;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_8VM:\n\t\tcase DSAF_MODE_DISABLE_2PORT_16VM:\n\t\t\tqid_mode = PPE_QID_MODE4;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_16VM:\n\t\tcase DSAF_MODE_DISABLE_6PORT_0VM:\n\t\t\tqid_mode = PPE_QID_MODE5;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_32VM:\n\t\tcase DSAF_MODE_DISABLE_6PORT_16VM:\n\t\t\tqid_mode = PPE_QID_MODE2;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_ENABLE_128VM:\n\t\tcase DSAF_MODE_DISABLE_6PORT_4VM:\n\t\t\tqid_mode = PPE_QID_MODE1;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_DISABLE_2PORT_8VM:\n\t\t\tqid_mode = PPE_QID_MODE7;\n\t\t\tbreak;\n\t\tcase DSAF_MODE_DISABLE_6PORT_2VM:\n\t\t\tqid_mode = PPE_QID_MODE6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(ppe_common->dev,\n\t\t\t\t\"get ppe queue mode failed! dsaf_mode=%d\\n\",\n\t\t\t\tdsaf_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\thns_ppe_set_qid_mode(ppe_common, qid_mode);\n\t}\n\n\tdsaf_set_dev_bit(ppe_common, PPE_COM_COMMON_CNT_CLR_CE_REG,\n\t\t\t PPE_COMMON_CNT_CLR_CE_B, 1);\n\n\treturn 0;\n}\n\n/*clr ppe exception irq*/\nstatic void hns_ppe_exc_irq_en(struct hns_ppe_cb *ppe_cb, int en)\n{\n\tu32 clr_vlue = 0xfffffffful;\n\tu32 msk_vlue = en ? 0xfffffffful : 0; /*1 is en, 0 is dis*/\n\tu32 vld_msk = 0;\n\n\t/*only care bit 0,1,7*/\n\tdsaf_set_bit(vld_msk, 0, 1);\n\tdsaf_set_bit(vld_msk, 1, 1);\n\tdsaf_set_bit(vld_msk, 7, 1);\n\n\t/*clr sts**/\n\tdsaf_write_dev(ppe_cb, PPE_RINT_REG, clr_vlue);\n\n\t/*for some reserved bits, so set 0**/\n\tdsaf_write_dev(ppe_cb, PPE_INTEN_REG, msk_vlue & vld_msk);\n}\n\n/**\n * ppe_init_hw - init ppe\n * @ppe_cb: ppe device\n */\nstatic void hns_ppe_init_hw(struct hns_ppe_cb *ppe_cb)\n{\n\tstruct ppe_common_cb *ppe_common_cb = ppe_cb->ppe_common_cb;\n\tu32 port = ppe_cb->index;\n\tstruct dsaf_device *dsaf_dev = ppe_common_cb->dsaf_dev;\n\tint i;\n\n\t/* get default RSS key */\n\tnetdev_rss_key_fill(ppe_cb->rss_key, HNS_PPEV2_RSS_KEY_SIZE);\n\n\tdsaf_dev->misc_op->ppe_srst(dsaf_dev, port, 0);\n\tmdelay(10);\n\tdsaf_dev->misc_op->ppe_srst(dsaf_dev, port, 1);\n\n\t/* clr and msk except irq*/\n\thns_ppe_exc_irq_en(ppe_cb, 0);\n\n\tif (ppe_common_cb->ppe_mode == PPE_COMMON_MODE_DEBUG) {\n\t\thns_ppe_set_port_mode(ppe_cb, PPE_MODE_GE);\n\t\tdsaf_write_dev(ppe_cb, PPE_CFG_PAUSE_IDLE_CNT_REG, 0);\n\t} else {\n\t\thns_ppe_set_port_mode(ppe_cb, PPE_MODE_XGE);\n\t}\n\n\thns_ppe_checksum_hw(ppe_cb, 0xffffffff);\n\thns_ppe_cnt_clr_ce(ppe_cb);\n\n\tif (!AE_IS_VER1(dsaf_dev->dsaf_ver)) {\n\t\thns_ppe_set_vlan_strip(ppe_cb, 0);\n\n\t\tdsaf_write_dev(ppe_cb, PPE_CFG_MAX_FRAME_LEN_REG,\n\t\t\t       HNS_PPEV2_MAX_FRAME_LEN);\n\n\t\t/* set default RSS key in h/w */\n\t\thns_ppe_set_rss_key(ppe_cb, ppe_cb->rss_key);\n\n\t\t/* Set default indrection table in h/w */\n\t\tfor (i = 0; i < HNS_PPEV2_RSS_IND_TBL_SIZE; i++)\n\t\t\tppe_cb->rss_indir_table[i] = i;\n\t\thns_ppe_set_indir_table(ppe_cb, ppe_cb->rss_indir_table);\n\t}\n}\n\n/**\n * ppe_uninit_hw - uninit ppe\n * @ppe_device: ppe device\n */\nstatic void hns_ppe_uninit_hw(struct hns_ppe_cb *ppe_cb)\n{\n\tu32 port;\n\n\tif (ppe_cb->ppe_common_cb) {\n\t\tstruct dsaf_device *dsaf_dev = ppe_cb->ppe_common_cb->dsaf_dev;\n\n\t\tport = ppe_cb->index;\n\t\tdsaf_dev->misc_op->ppe_srst(dsaf_dev, port, 0);\n\t}\n}\n\nvoid hns_ppe_uninit_ex(struct ppe_common_cb *ppe_common)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ppe_common->ppe_num; i++) {\n\t\tif (ppe_common->dsaf_dev->mac_cb[i])\n\t\t\thns_ppe_uninit_hw(&ppe_common->ppe_cb[i]);\n\t\tmemset(&ppe_common->ppe_cb[i], 0, sizeof(struct hns_ppe_cb));\n\t}\n}\n\nvoid hns_ppe_uninit(struct dsaf_device *dsaf_dev)\n{\n\tu32 i;\n\n\tfor (i = 0; i < HNS_PPE_COM_NUM; i++) {\n\t\tif (dsaf_dev->ppe_common[i])\n\t\t\thns_ppe_uninit_ex(dsaf_dev->ppe_common[i]);\n\t\thns_rcb_common_free_cfg(dsaf_dev, i);\n\t\thns_ppe_common_free_cfg(dsaf_dev, i);\n\t}\n}\n\n/**\n * hns_ppe_reset - reinit ppe/rcb hw\n * @dsaf_dev: dasf device\n * retuen void\n */\nvoid hns_ppe_reset_common(struct dsaf_device *dsaf_dev, u8 ppe_common_index)\n{\n\tu32 i;\n\tint ret;\n\tstruct ppe_common_cb *ppe_common;\n\n\tppe_common = dsaf_dev->ppe_common[ppe_common_index];\n\tret = hns_ppe_common_init_hw(ppe_common);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < ppe_common->ppe_num; i++) {\n\t\t/* We only need to initiate ppe when the port exists */\n\t\tif (dsaf_dev->mac_cb[i])\n\t\t\thns_ppe_init_hw(&ppe_common->ppe_cb[i]);\n\t}\n\n\tret = hns_rcb_common_init_hw(dsaf_dev->rcb_common[ppe_common_index]);\n\tif (ret)\n\t\treturn;\n\n\thns_rcb_common_init_commit_hw(dsaf_dev->rcb_common[ppe_common_index]);\n}\n\nvoid hns_ppe_update_stats(struct hns_ppe_cb *ppe_cb)\n{\n\tstruct hns_ppe_hw_stats *hw_stats = &ppe_cb->hw_stats;\n\n\thw_stats->rx_pkts_from_sw\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_SW_PKT_CNT_REG);\n\thw_stats->rx_pkts\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_WR_BD_OK_PKT_CNT_REG);\n\thw_stats->rx_drop_no_bd\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_NO_BUF_CNT_REG);\n\thw_stats->rx_alloc_buf_fail\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_APP_BUF_FAIL_CNT_REG);\n\thw_stats->rx_alloc_buf_wait\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_APP_BUF_WAIT_CNT_REG);\n\thw_stats->rx_drop_no_buf\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_DROP_FUL_CNT_REG);\n\thw_stats->rx_err_fifo_full\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_DROP_PRT_CNT_REG);\n\n\thw_stats->tx_bd_form_rcb\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_BD_CNT_REG);\n\thw_stats->tx_pkts_from_rcb\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_CNT_REG);\n\thw_stats->tx_pkts\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_OK_CNT_REG);\n\thw_stats->tx_err_fifo_empty\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_EPT_CNT_REG);\n\thw_stats->tx_err_checksum\n\t\t+= dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_CS_FAIL_CNT_REG);\n}\n\nint hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}\n\nint hns_ppe_get_regs_count(void)\n{\n\treturn ETH_PPE_DUMP_NUM;\n}\n\n/**\n * ppe_get_strings - get ppe srting\n * @ppe_device: ppe device\n * @stringset: string set type\n * @data: output string\n */\nvoid hns_ppe_get_strings(struct hns_ppe_cb *ppe_cb, int stringset, u8 *data)\n{\n\tchar *buff = (char *)data;\n\tint index = ppe_cb->index;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_sw_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_pkt_ok\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_drop_pkt_no_bd\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_alloc_buf_fail\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_alloc_buf_wait\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_pkt_drop_no_buf\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_rx_pkt_err_fifo_full\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_bd\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_pkt_ok\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_pkt_err_fifo_empty\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"ppe%d_tx_pkt_err_csum_fail\", index);\n}\n\nvoid hns_ppe_get_stats(struct hns_ppe_cb *ppe_cb, u64 *data)\n{\n\tu64 *regs_buff = data;\n\tstruct hns_ppe_hw_stats *hw_stats = &ppe_cb->hw_stats;\n\n\tregs_buff[0] = hw_stats->rx_pkts_from_sw;\n\tregs_buff[1] = hw_stats->rx_pkts;\n\tregs_buff[2] = hw_stats->rx_drop_no_bd;\n\tregs_buff[3] = hw_stats->rx_alloc_buf_fail;\n\tregs_buff[4] = hw_stats->rx_alloc_buf_wait;\n\tregs_buff[5] = hw_stats->rx_drop_no_buf;\n\tregs_buff[6] = hw_stats->rx_err_fifo_full;\n\n\tregs_buff[7] = hw_stats->tx_bd_form_rcb;\n\tregs_buff[8] = hw_stats->tx_pkts_from_rcb;\n\tregs_buff[9] = hw_stats->tx_pkts;\n\tregs_buff[10] = hw_stats->tx_err_fifo_empty;\n\tregs_buff[11] = hw_stats->tx_err_checksum;\n}\n\n/**\n * hns_ppe_init - init ppe device\n * @dsaf_dev: dasf device\n * retuen 0 - success , negative --fail\n */\nint hns_ppe_init(struct dsaf_device *dsaf_dev)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < HNS_PPE_COM_NUM; i++) {\n\t\tret = hns_ppe_common_get_cfg(dsaf_dev, i);\n\t\tif (ret)\n\t\t\tgoto get_cfg_fail;\n\n\t\tret = hns_rcb_common_get_cfg(dsaf_dev, i);\n\t\tif (ret)\n\t\t\tgoto get_cfg_fail;\n\n\t\thns_ppe_get_cfg(dsaf_dev->ppe_common[i]);\n\n\t\tret = hns_rcb_get_cfg(dsaf_dev->rcb_common[i]);\n\t\tif (ret)\n\t\t\tgoto get_cfg_fail;\n\t}\n\n\tfor (i = 0; i < HNS_PPE_COM_NUM; i++)\n\t\thns_ppe_reset_common(dsaf_dev, i);\n\n\treturn 0;\n\nget_cfg_fail:\n\tfor (i = 0; i < HNS_PPE_COM_NUM; i++) {\n\t\thns_rcb_common_free_cfg(dsaf_dev, i);\n\t\thns_ppe_common_free_cfg(dsaf_dev, i);\n\t}\n\n\treturn ret;\n}\n\nvoid hns_ppe_get_regs(struct hns_ppe_cb *ppe_cb, void *data)\n{\n\tstruct ppe_common_cb *ppe_common = ppe_cb->ppe_common_cb;\n\tu32 *regs = data;\n\tu32 i;\n\tu32 offset;\n\n\t/* ppe common registers */\n\tregs[0] = dsaf_read_dev(ppe_common, PPE_COM_CFG_QID_MODE_REG);\n\tregs[1] = dsaf_read_dev(ppe_common, PPE_COM_INTEN_REG);\n\tregs[2] = dsaf_read_dev(ppe_common, PPE_COM_RINT_REG);\n\tregs[3] = dsaf_read_dev(ppe_common, PPE_COM_INTSTS_REG);\n\tregs[4] = dsaf_read_dev(ppe_common, PPE_COM_COMMON_CNT_CLR_CE_REG);\n\n\tfor (i = 0; i < DSAF_TOTAL_QUEUE_NUM; i++) {\n\t\toffset = PPE_COM_HIS_RX_PKT_QID_DROP_CNT_REG + 0x4 * i;\n\t\tregs[5 + i] = dsaf_read_dev(ppe_common, offset);\n\t\toffset = PPE_COM_HIS_RX_PKT_QID_OK_CNT_REG + 0x4 * i;\n\t\tregs[5 + i + DSAF_TOTAL_QUEUE_NUM]\n\t\t\t\t= dsaf_read_dev(ppe_common, offset);\n\t\toffset = PPE_COM_HIS_TX_PKT_QID_ERR_CNT_REG + 0x4 * i;\n\t\tregs[5 + i + DSAF_TOTAL_QUEUE_NUM * 2]\n\t\t\t\t= dsaf_read_dev(ppe_common, offset);\n\t\toffset = PPE_COM_HIS_TX_PKT_QID_OK_CNT_REG + 0x4 * i;\n\t\tregs[5 + i + DSAF_TOTAL_QUEUE_NUM * 3]\n\t\t\t\t= dsaf_read_dev(ppe_common, offset);\n\t}\n\n\t/* mark end of ppe regs */\n\tfor (i = 521; i < 524; i++)\n\t\tregs[i] = 0xeeeeeeee;\n\n\t/* ppe channel registers */\n\tregs[525] = dsaf_read_dev(ppe_cb, PPE_CFG_TX_FIFO_THRSLD_REG);\n\tregs[526] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_FIFO_THRSLD_REG);\n\tregs[527] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_FIFO_PAUSE_THRSLD_REG);\n\tregs[528] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_FIFO_SW_BP_THRSLD_REG);\n\tregs[529] = dsaf_read_dev(ppe_cb, PPE_CFG_PAUSE_IDLE_CNT_REG);\n\tregs[530] = dsaf_read_dev(ppe_cb, PPE_CFG_BUS_CTRL_REG);\n\tregs[531] = dsaf_read_dev(ppe_cb, PPE_CFG_TNL_TO_BE_RST_REG);\n\tregs[532] = dsaf_read_dev(ppe_cb, PPE_CURR_TNL_CAN_RST_REG);\n\n\tregs[533] = dsaf_read_dev(ppe_cb, PPE_CFG_XGE_MODE_REG);\n\tregs[534] = dsaf_read_dev(ppe_cb, PPE_CFG_MAX_FRAME_LEN_REG);\n\tregs[535] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_PKT_MODE_REG);\n\tregs[536] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_VLAN_TAG_REG);\n\tregs[537] = dsaf_read_dev(ppe_cb, PPE_CFG_TAG_GEN_REG);\n\tregs[538] = dsaf_read_dev(ppe_cb, PPE_CFG_PARSE_TAG_REG);\n\tregs[539] = dsaf_read_dev(ppe_cb, PPE_CFG_PRO_CHECK_EN_REG);\n\n\tregs[540] = dsaf_read_dev(ppe_cb, PPE_INTEN_REG);\n\tregs[541] = dsaf_read_dev(ppe_cb, PPE_RINT_REG);\n\tregs[542] = dsaf_read_dev(ppe_cb, PPE_INTSTS_REG);\n\tregs[543] = dsaf_read_dev(ppe_cb, PPE_CFG_RX_PKT_INT_REG);\n\n\tregs[544] = dsaf_read_dev(ppe_cb, PPE_CFG_HEAT_DECT_TIME0_REG);\n\tregs[545] = dsaf_read_dev(ppe_cb, PPE_CFG_HEAT_DECT_TIME1_REG);\n\n\t/* ppe static */\n\tregs[546] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_SW_PKT_CNT_REG);\n\tregs[547] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_WR_BD_OK_PKT_CNT_REG);\n\tregs[548] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_NO_BUF_CNT_REG);\n\tregs[549] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_BD_CNT_REG);\n\tregs[550] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_CNT_REG);\n\tregs[551] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_OK_CNT_REG);\n\tregs[552] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_EPT_CNT_REG);\n\tregs[553] = dsaf_read_dev(ppe_cb, PPE_HIS_TX_PKT_CS_FAIL_CNT_REG);\n\tregs[554] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_APP_BUF_FAIL_CNT_REG);\n\tregs[555] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_APP_BUF_WAIT_CNT_REG);\n\tregs[556] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_DROP_FUL_CNT_REG);\n\tregs[557] = dsaf_read_dev(ppe_cb, PPE_HIS_RX_PKT_DROP_PRT_CNT_REG);\n\n\tregs[558] = dsaf_read_dev(ppe_cb, PPE_TNL_0_5_CNT_CLR_CE_REG);\n\tregs[559] = dsaf_read_dev(ppe_cb, PPE_CFG_AXI_DBG_REG);\n\tregs[560] = dsaf_read_dev(ppe_cb, PPE_HIS_PRO_ERR_REG);\n\tregs[561] = dsaf_read_dev(ppe_cb, PPE_HIS_TNL_FIFO_ERR_REG);\n\tregs[562] = dsaf_read_dev(ppe_cb, PPE_CURR_CFF_DATA_NUM_REG);\n\tregs[563] = dsaf_read_dev(ppe_cb, PPE_CURR_RX_ST_REG);\n\tregs[564] = dsaf_read_dev(ppe_cb, PPE_CURR_TX_ST_REG);\n\tregs[565] = dsaf_read_dev(ppe_cb, PPE_CURR_RX_FIFO0_REG);\n\tregs[566] = dsaf_read_dev(ppe_cb, PPE_CURR_RX_FIFO1_REG);\n\tregs[567] = dsaf_read_dev(ppe_cb, PPE_CURR_TX_FIFO0_REG);\n\tregs[568] = dsaf_read_dev(ppe_cb, PPE_CURR_TX_FIFO1_REG);\n\tregs[569] = dsaf_read_dev(ppe_cb, PPE_ECO0_REG);\n\tregs[570] = dsaf_read_dev(ppe_cb, PPE_ECO1_REG);\n\tregs[571] = dsaf_read_dev(ppe_cb, PPE_ECO2_REG);\n\n\t/* mark end of ppe regs */\n\tfor (i = 572; i < 576; i++)\n\t\tregs[i] = 0xeeeeeeee;\n}\n", "/*\n * Copyright (c) 2014-2015 Hisilicon Limited.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/cdev.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <asm/cacheflush.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n#include <linux/spinlock.h>\n\n#include \"hns_dsaf_main.h\"\n#include \"hns_dsaf_ppe.h\"\n#include \"hns_dsaf_rcb.h\"\n\n#define RCB_COMMON_REG_OFFSET 0x80000\n#define TX_RING 0\n#define RX_RING 1\n\n#define RCB_RESET_WAIT_TIMES 30\n#define RCB_RESET_TRY_TIMES 10\n\n/* Because default mtu is 1500, rcb buffer size is set to 2048 enough */\n#define RCB_DEFAULT_BUFFER_SIZE 2048\n\n/**\n *hns_rcb_wait_fbd_clean - clean fbd\n *@qs: ring struct pointer array\n *@qnum: num of array\n *@flag: tx or rx flag\n */\nvoid hns_rcb_wait_fbd_clean(struct hnae_queue **qs, int q_num, u32 flag)\n{\n\tint i, wait_cnt;\n\tu32 fbd_num;\n\n\tfor (wait_cnt = i = 0; i < q_num; wait_cnt++) {\n\t\tusleep_range(200, 300);\n\t\tfbd_num = 0;\n\t\tif (flag & RCB_INT_FLAG_TX)\n\t\t\tfbd_num += dsaf_read_dev(qs[i],\n\t\t\t\t\t\t RCB_RING_TX_RING_FBDNUM_REG);\n\t\tif (flag & RCB_INT_FLAG_RX)\n\t\t\tfbd_num += dsaf_read_dev(qs[i],\n\t\t\t\t\t\t RCB_RING_RX_RING_FBDNUM_REG);\n\t\tif (!fbd_num)\n\t\t\ti++;\n\t\tif (wait_cnt >= 10000)\n\t\t\tbreak;\n\t}\n\n\tif (i < q_num)\n\t\tdev_err(qs[i]->handle->owner_dev,\n\t\t\t\"queue(%d) wait fbd(%d) clean fail!!\\n\", i, fbd_num);\n}\n\n/**\n *hns_rcb_reset_ring_hw - ring reset\n *@q: ring struct pointer\n */\nvoid hns_rcb_reset_ring_hw(struct hnae_queue *q)\n{\n\tu32 wait_cnt;\n\tu32 try_cnt = 0;\n\tu32 could_ret;\n\n\tu32 tx_fbd_num;\n\n\twhile (try_cnt++ < RCB_RESET_TRY_TIMES) {\n\t\tusleep_range(100, 200);\n\t\ttx_fbd_num = dsaf_read_dev(q, RCB_RING_TX_RING_FBDNUM_REG);\n\t\tif (tx_fbd_num)\n\t\t\tcontinue;\n\n\t\tdsaf_write_dev(q, RCB_RING_PREFETCH_EN_REG, 0);\n\n\t\tdsaf_write_dev(q, RCB_RING_T0_BE_RST, 1);\n\n\t\tmsleep(20);\n\t\tcould_ret = dsaf_read_dev(q, RCB_RING_COULD_BE_RST);\n\n\t\twait_cnt = 0;\n\t\twhile (!could_ret && (wait_cnt < RCB_RESET_WAIT_TIMES)) {\n\t\t\tdsaf_write_dev(q, RCB_RING_T0_BE_RST, 0);\n\n\t\t\tdsaf_write_dev(q, RCB_RING_T0_BE_RST, 1);\n\n\t\t\tmsleep(20);\n\t\t\tcould_ret = dsaf_read_dev(q, RCB_RING_COULD_BE_RST);\n\n\t\t\twait_cnt++;\n\t\t}\n\n\t\tdsaf_write_dev(q, RCB_RING_T0_BE_RST, 0);\n\n\t\tif (could_ret)\n\t\t\tbreak;\n\t}\n\n\tif (try_cnt >= RCB_RESET_TRY_TIMES)\n\t\tdev_err(q->dev->dev, \"port%d reset ring fail\\n\",\n\t\t\thns_ae_get_vf_cb(q->handle)->port_index);\n}\n\n/**\n *hns_rcb_int_ctrl_hw - rcb irq enable control\n *@q: hnae queue struct pointer\n *@flag:ring flag tx or rx\n *@mask:mask\n */\nvoid hns_rcb_int_ctrl_hw(struct hnae_queue *q, u32 flag, u32 mask)\n{\n\tu32 int_mask_en = !!mask;\n\n\tif (flag & RCB_INT_FLAG_TX) {\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_TXWL_REG, int_mask_en);\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_TX_OVERTIME_REG,\n\t\t\t       int_mask_en);\n\t}\n\n\tif (flag & RCB_INT_FLAG_RX) {\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_RXWL_REG, int_mask_en);\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_RX_OVERTIME_REG,\n\t\t\t       int_mask_en);\n\t}\n}\n\nvoid hns_rcb_int_clr_hw(struct hnae_queue *q, u32 flag)\n{\n\tif (flag & RCB_INT_FLAG_TX) {\n\t\tdsaf_write_dev(q, RCB_RING_INTSTS_TX_RING_REG, 1);\n\t\tdsaf_write_dev(q, RCB_RING_INTSTS_TX_OVERTIME_REG, 1);\n\t}\n\n\tif (flag & RCB_INT_FLAG_RX) {\n\t\tdsaf_write_dev(q, RCB_RING_INTSTS_RX_RING_REG, 1);\n\t\tdsaf_write_dev(q, RCB_RING_INTSTS_RX_OVERTIME_REG, 1);\n\t}\n}\n\nvoid hns_rcbv2_int_ctrl_hw(struct hnae_queue *q, u32 flag, u32 mask)\n{\n\tu32 int_mask_en = !!mask;\n\n\tif (flag & RCB_INT_FLAG_TX)\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_TXWL_REG, int_mask_en);\n\n\tif (flag & RCB_INT_FLAG_RX)\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_RXWL_REG, int_mask_en);\n}\n\nvoid hns_rcbv2_int_clr_hw(struct hnae_queue *q, u32 flag)\n{\n\tif (flag & RCB_INT_FLAG_TX)\n\t\tdsaf_write_dev(q, RCBV2_TX_RING_INT_STS_REG, 1);\n\n\tif (flag & RCB_INT_FLAG_RX)\n\t\tdsaf_write_dev(q, RCBV2_RX_RING_INT_STS_REG, 1);\n}\n\n/**\n *hns_rcb_ring_enable_hw - enable ring\n *@ring: rcb ring\n */\nvoid hns_rcb_ring_enable_hw(struct hnae_queue *q, u32 val)\n{\n\tdsaf_write_dev(q, RCB_RING_PREFETCH_EN_REG, !!val);\n}\n\nvoid hns_rcb_start(struct hnae_queue *q, u32 val)\n{\n\thns_rcb_ring_enable_hw(q, val);\n}\n\n/**\n *hns_rcb_common_init_commit_hw - make rcb common init completed\n *@rcb_common: rcb common device\n */\nvoid hns_rcb_common_init_commit_hw(struct rcb_common_cb *rcb_common)\n{\n\twmb();\t/* Sync point before breakpoint */\n\tdsaf_write_dev(rcb_common, RCB_COM_CFG_SYS_FSH_REG, 1);\n\twmb();\t/* Sync point after breakpoint */\n}\n\n/* hns_rcb_set_tx_ring_bs - init rcb ring buf size regester\n *@q: hnae_queue\n *@buf_size: buffer size set to hw\n */\nvoid hns_rcb_set_tx_ring_bs(struct hnae_queue *q, u32 buf_size)\n{\n\tu32 bd_size_type = hns_rcb_buf_size2type(buf_size);\n\n\tdsaf_write_dev(q, RCB_RING_TX_RING_BD_LEN_REG,\n\t\t       bd_size_type);\n}\n\n/* hns_rcb_set_rx_ring_bs - init rcb ring buf size regester\n *@q: hnae_queue\n *@buf_size: buffer size set to hw\n */\nvoid hns_rcb_set_rx_ring_bs(struct hnae_queue *q, u32 buf_size)\n{\n\tu32 bd_size_type = hns_rcb_buf_size2type(buf_size);\n\n\tdsaf_write_dev(q, RCB_RING_RX_RING_BD_LEN_REG,\n\t\t       bd_size_type);\n}\n\n/**\n *hns_rcb_ring_init - init rcb ring\n *@ring_pair: ring pair control block\n *@ring_type: ring type, RX_RING or TX_RING\n */\nstatic void hns_rcb_ring_init(struct ring_pair_cb *ring_pair, int ring_type)\n{\n\tstruct hnae_queue *q = &ring_pair->q;\n\tstruct hnae_ring *ring =\n\t\t(ring_type == RX_RING) ? &q->rx_ring : &q->tx_ring;\n\tdma_addr_t dma = ring->desc_dma_addr;\n\n\tif (ring_type == RX_RING) {\n\t\tdsaf_write_dev(q, RCB_RING_RX_RING_BASEADDR_L_REG,\n\t\t\t       (u32)dma);\n\t\tdsaf_write_dev(q, RCB_RING_RX_RING_BASEADDR_H_REG,\n\t\t\t       (u32)((dma >> 31) >> 1));\n\n\t\thns_rcb_set_rx_ring_bs(q, ring->buf_size);\n\n\t\tdsaf_write_dev(q, RCB_RING_RX_RING_BD_NUM_REG,\n\t\t\t       ring_pair->port_id_in_comm);\n\t\tdsaf_write_dev(q, RCB_RING_RX_RING_PKTLINE_REG,\n\t\t\t       ring_pair->port_id_in_comm);\n\t} else {\n\t\tdsaf_write_dev(q, RCB_RING_TX_RING_BASEADDR_L_REG,\n\t\t\t       (u32)dma);\n\t\tdsaf_write_dev(q, RCB_RING_TX_RING_BASEADDR_H_REG,\n\t\t\t       (u32)((dma >> 31) >> 1));\n\n\t\thns_rcb_set_tx_ring_bs(q, ring->buf_size);\n\n\t\tdsaf_write_dev(q, RCB_RING_TX_RING_BD_NUM_REG,\n\t\t\t       ring_pair->port_id_in_comm);\n\t\tdsaf_write_dev(q, RCB_RING_TX_RING_PKTLINE_REG,\n\t\t\tring_pair->port_id_in_comm + HNS_RCB_TX_PKTLINE_OFFSET);\n\t}\n}\n\n/**\n *hns_rcb_init_hw - init rcb hardware\n *@ring: rcb ring\n */\nvoid hns_rcb_init_hw(struct ring_pair_cb *ring)\n{\n\thns_rcb_ring_init(ring, RX_RING);\n\thns_rcb_ring_init(ring, TX_RING);\n}\n\n/**\n *hns_rcb_set_port_desc_cnt - set rcb port description num\n *@rcb_common: rcb_common device\n *@port_idx:port index\n *@desc_cnt:BD num\n */\nstatic void hns_rcb_set_port_desc_cnt(struct rcb_common_cb *rcb_common,\n\t\t\t\t      u32 port_idx, u32 desc_cnt)\n{\n\tdsaf_write_dev(rcb_common, RCB_CFG_BD_NUM_REG + port_idx * 4,\n\t\t       desc_cnt);\n}\n\nstatic void hns_rcb_set_port_timeout(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx, u32 timeout)\n{\n\tif (AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver)) {\n\t\tdsaf_write_dev(rcb_common, RCB_CFG_OVERTIME_REG,\n\t\t\t       timeout * HNS_RCB_CLK_FREQ_MHZ);\n\t} else if (!HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev)) {\n\t\tif (timeout > HNS_RCB_DEF_GAP_TIME_USECS)\n\t\t\tdsaf_write_dev(rcb_common,\n\t\t\t\t       RCB_PORT_INT_GAPTIME_REG + port_idx * 4,\n\t\t\t\t       HNS_RCB_DEF_GAP_TIME_USECS);\n\t\telse\n\t\t\tdsaf_write_dev(rcb_common,\n\t\t\t\t       RCB_PORT_INT_GAPTIME_REG + port_idx * 4,\n\t\t\t\t       timeout);\n\n\t\tdsaf_write_dev(rcb_common,\n\t\t\t       RCB_PORT_CFG_OVERTIME_REG + port_idx * 4,\n\t\t\t       timeout);\n\t} else {\n\t\tdsaf_write_dev(rcb_common,\n\t\t\t       RCB_PORT_CFG_OVERTIME_REG + port_idx * 4,\n\t\t\t       timeout);\n\t}\n}\n\nstatic int hns_rcb_common_get_port_num(struct rcb_common_cb *rcb_common)\n{\n\tif (!HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev))\n\t\treturn HNS_RCB_SERVICE_NW_ENGINE_NUM;\n\telse\n\t\treturn HNS_RCB_DEBUG_NW_ENGINE_NUM;\n}\n\n/*clr rcb comm exception irq**/\nstatic void hns_rcb_comm_exc_irq_en(\n\t\t\tstruct rcb_common_cb *rcb_common, int en)\n{\n\tu32 clr_vlue = 0xfffffffful;\n\tu32 msk_vlue = en ? 0 : 0xfffffffful;\n\n\t/* clr int*/\n\tdsaf_write_dev(rcb_common, RCB_COM_INTSTS_ECC_ERR_REG, clr_vlue);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_SF_CFG_RING_STS, clr_vlue);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_SF_CFG_BD_RINT_STS, clr_vlue);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_RINT_TX_PKT_REG, clr_vlue);\n\tdsaf_write_dev(rcb_common, RCB_COM_AXI_ERR_STS, clr_vlue);\n\n\t/*en msk*/\n\tdsaf_write_dev(rcb_common, RCB_COM_INTMASK_ECC_ERR_REG, msk_vlue);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_SF_CFG_INTMASK_RING, msk_vlue);\n\n\t/*for tx bd neednot cacheline, so msk sf_txring_fbd_intmask (bit 1)**/\n\tdsaf_write_dev(rcb_common, RCB_COM_SF_CFG_INTMASK_BD, msk_vlue | 2);\n\n\tdsaf_write_dev(rcb_common, RCB_COM_INTMSK_TX_PKT_REG, msk_vlue);\n\tdsaf_write_dev(rcb_common, RCB_COM_AXI_WR_ERR_INTMASK, msk_vlue);\n}\n\n/**\n *hns_rcb_common_init_hw - init rcb common hardware\n *@rcb_common: rcb_common device\n *retuen 0 - success , negative --fail\n */\nint hns_rcb_common_init_hw(struct rcb_common_cb *rcb_common)\n{\n\tu32 reg_val;\n\tint i;\n\tint port_num = hns_rcb_common_get_port_num(rcb_common);\n\n\thns_rcb_comm_exc_irq_en(rcb_common, 0);\n\n\treg_val = dsaf_read_dev(rcb_common, RCB_COM_CFG_INIT_FLAG_REG);\n\tif (0x1 != (reg_val & 0x1)) {\n\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\"RCB_COM_CFG_INIT_FLAG_REG reg = 0x%x\\n\", reg_val);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < port_num; i++) {\n\t\thns_rcb_set_port_desc_cnt(rcb_common, i, rcb_common->desc_num);\n\t\thns_rcb_set_rx_coalesced_frames(\n\t\t\trcb_common, i, HNS_RCB_DEF_RX_COALESCED_FRAMES);\n\t\tif (!AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver) &&\n\t\t    !HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev))\n\t\t\thns_rcb_set_tx_coalesced_frames(\n\t\t\t\trcb_common, i, HNS_RCB_DEF_TX_COALESCED_FRAMES);\n\t\thns_rcb_set_port_timeout(\n\t\t\trcb_common, i, HNS_RCB_DEF_COALESCED_USECS);\n\t}\n\n\tdsaf_write_dev(rcb_common, RCB_COM_CFG_ENDIAN_REG,\n\t\t       HNS_RCB_COMMON_ENDIAN);\n\n\tif (AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver)) {\n\t\tdsaf_write_dev(rcb_common, RCB_COM_CFG_FNA_REG, 0x0);\n\t\tdsaf_write_dev(rcb_common, RCB_COM_CFG_FA_REG, 0x1);\n\t} else {\n\t\tdsaf_set_dev_bit(rcb_common, RCBV2_COM_CFG_USER_REG,\n\t\t\t\t RCB_COM_CFG_FNA_B, false);\n\t\tdsaf_set_dev_bit(rcb_common, RCBV2_COM_CFG_USER_REG,\n\t\t\t\t RCB_COM_CFG_FA_B, true);\n\t\tdsaf_set_dev_bit(rcb_common, RCBV2_COM_CFG_TSO_MODE_REG,\n\t\t\t\t RCB_COM_TSO_MODE_B, HNS_TSO_MODE_8BD_32K);\n\t}\n\n\treturn 0;\n}\n\nint hns_rcb_buf_size2type(u32 buf_size)\n{\n\tint bd_size_type;\n\n\tswitch (buf_size) {\n\tcase 512:\n\t\tbd_size_type = HNS_BD_SIZE_512_TYPE;\n\t\tbreak;\n\tcase 1024:\n\t\tbd_size_type = HNS_BD_SIZE_1024_TYPE;\n\t\tbreak;\n\tcase 2048:\n\t\tbd_size_type = HNS_BD_SIZE_2048_TYPE;\n\t\tbreak;\n\tcase 4096:\n\t\tbd_size_type = HNS_BD_SIZE_4096_TYPE;\n\t\tbreak;\n\tdefault:\n\t\tbd_size_type = -EINVAL;\n\t}\n\n\treturn bd_size_type;\n}\n\nstatic void hns_rcb_ring_get_cfg(struct hnae_queue *q, int ring_type)\n{\n\tstruct hnae_ring *ring;\n\tstruct rcb_common_cb *rcb_common;\n\tstruct ring_pair_cb *ring_pair_cb;\n\tu16 desc_num, mdnum_ppkt;\n\tbool irq_idx, is_ver1;\n\n\tring_pair_cb = container_of(q, struct ring_pair_cb, q);\n\tis_ver1 = AE_IS_VER1(ring_pair_cb->rcb_common->dsaf_dev->dsaf_ver);\n\tif (ring_type == RX_RING) {\n\t\tring = &q->rx_ring;\n\t\tring->io_base = ring_pair_cb->q.io_base;\n\t\tirq_idx = HNS_RCB_IRQ_IDX_RX;\n\t\tmdnum_ppkt = HNS_RCB_RING_MAX_BD_PER_PKT;\n\t} else {\n\t\tring = &q->tx_ring;\n\t\tring->io_base = (u8 __iomem *)ring_pair_cb->q.io_base +\n\t\t\tHNS_RCB_TX_REG_OFFSET;\n\t\tirq_idx = HNS_RCB_IRQ_IDX_TX;\n\t\tmdnum_ppkt = is_ver1 ? HNS_RCB_RING_MAX_TXBD_PER_PKT :\n\t\t\t\t HNS_RCBV2_RING_MAX_TXBD_PER_PKT;\n\t}\n\n\trcb_common = ring_pair_cb->rcb_common;\n\tdesc_num = rcb_common->dsaf_dev->desc_num;\n\n\tring->desc = NULL;\n\tring->desc_cb = NULL;\n\n\tring->irq = ring_pair_cb->virq[irq_idx];\n\tring->desc_dma_addr = 0;\n\n\tring->buf_size = RCB_DEFAULT_BUFFER_SIZE;\n\tring->desc_num = desc_num;\n\tring->max_desc_num_per_pkt = mdnum_ppkt;\n\tring->max_raw_data_sz_per_desc = HNS_RCB_MAX_PKT_SIZE;\n\tring->max_pkt_size = HNS_RCB_MAX_PKT_SIZE;\n\tring->next_to_use = 0;\n\tring->next_to_clean = 0;\n}\n\nstatic void hns_rcb_ring_pair_get_cfg(struct ring_pair_cb *ring_pair_cb)\n{\n\tring_pair_cb->q.handle = NULL;\n\n\thns_rcb_ring_get_cfg(&ring_pair_cb->q, RX_RING);\n\thns_rcb_ring_get_cfg(&ring_pair_cb->q, TX_RING);\n}\n\nstatic int hns_rcb_get_port_in_comm(\n\tstruct rcb_common_cb *rcb_common, int ring_idx)\n{\n\treturn ring_idx / (rcb_common->max_q_per_vf * rcb_common->max_vfn);\n}\n\n#define SERVICE_RING_IRQ_IDX(v1) \\\n\t((v1) ? HNS_SERVICE_RING_IRQ_IDX : HNSV2_SERVICE_RING_IRQ_IDX)\nstatic int hns_rcb_get_base_irq_idx(struct rcb_common_cb *rcb_common)\n{\n\tbool is_ver1 = AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver);\n\n\tif (!HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev))\n\t\treturn SERVICE_RING_IRQ_IDX(is_ver1);\n\telse\n\t\treturn  HNS_DEBUG_RING_IRQ_IDX;\n}\n\n#define RCB_COMM_BASE_TO_RING_BASE(base, ringid)\\\n\t((base) + 0x10000 + HNS_RCB_REG_OFFSET * (ringid))\n/**\n *hns_rcb_get_cfg - get rcb config\n *@rcb_common: rcb common device\n */\nint hns_rcb_get_cfg(struct rcb_common_cb *rcb_common)\n{\n\tstruct ring_pair_cb *ring_pair_cb;\n\tu32 i;\n\tu32 ring_num = rcb_common->ring_num;\n\tint base_irq_idx = hns_rcb_get_base_irq_idx(rcb_common);\n\tstruct platform_device *pdev =\n\t\tto_platform_device(rcb_common->dsaf_dev->dev);\n\tbool is_ver1 = AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver);\n\n\tfor (i = 0; i < ring_num; i++) {\n\t\tring_pair_cb = &rcb_common->ring_pair_cb[i];\n\t\tring_pair_cb->rcb_common = rcb_common;\n\t\tring_pair_cb->dev = rcb_common->dsaf_dev->dev;\n\t\tring_pair_cb->index = i;\n\t\tring_pair_cb->q.io_base =\n\t\t\tRCB_COMM_BASE_TO_RING_BASE(rcb_common->io_base, i);\n\t\tring_pair_cb->port_id_in_comm =\n\t\t\thns_rcb_get_port_in_comm(rcb_common, i);\n\t\tring_pair_cb->virq[HNS_RCB_IRQ_IDX_TX] =\n\t\tis_ver1 ? platform_get_irq(pdev, base_irq_idx + i * 2) :\n\t\t\t  platform_get_irq(pdev, base_irq_idx + i * 3 + 1);\n\t\tring_pair_cb->virq[HNS_RCB_IRQ_IDX_RX] =\n\t\tis_ver1 ? platform_get_irq(pdev, base_irq_idx + i * 2 + 1) :\n\t\t\t  platform_get_irq(pdev, base_irq_idx + i * 3);\n\t\tif ((ring_pair_cb->virq[HNS_RCB_IRQ_IDX_TX] == -EPROBE_DEFER) ||\n\t\t    (ring_pair_cb->virq[HNS_RCB_IRQ_IDX_RX] == -EPROBE_DEFER))\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tring_pair_cb->q.phy_base =\n\t\t\tRCB_COMM_BASE_TO_RING_BASE(rcb_common->phy_base, i);\n\t\thns_rcb_ring_pair_get_cfg(ring_pair_cb);\n\t}\n\n\treturn 0;\n}\n\n/**\n *hns_rcb_get_rx_coalesced_frames - get rcb port rx coalesced frames\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *\n *Returns: coalesced_frames\n */\nu32 hns_rcb_get_rx_coalesced_frames(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx)\n{\n\treturn dsaf_read_dev(rcb_common, RCB_CFG_PKTLINE_REG + port_idx * 4);\n}\n\n/**\n *hns_rcb_get_tx_coalesced_frames - get rcb port tx coalesced frames\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *\n *Returns: coalesced_frames\n */\nu32 hns_rcb_get_tx_coalesced_frames(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx)\n{\n\tu64 reg;\n\n\treg = RCB_CFG_PKTLINE_REG + (port_idx + HNS_RCB_TX_PKTLINE_OFFSET) * 4;\n\treturn dsaf_read_dev(rcb_common, reg);\n}\n\n/**\n *hns_rcb_get_coalesce_usecs - get rcb port coalesced time_out\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *\n *Returns: time_out\n */\nu32 hns_rcb_get_coalesce_usecs(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx)\n{\n\tif (AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver))\n\t\treturn dsaf_read_dev(rcb_common, RCB_CFG_OVERTIME_REG) /\n\t\t       HNS_RCB_CLK_FREQ_MHZ;\n\telse\n\t\treturn dsaf_read_dev(rcb_common,\n\t\t\t\t     RCB_PORT_CFG_OVERTIME_REG + port_idx * 4);\n}\n\n/**\n *hns_rcb_set_coalesce_usecs - set rcb port coalesced time_out\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *@timeout:tx/rx time for coalesced time_out\n *\n * Returns:\n * Zero for success, or an error code in case of failure\n */\nint hns_rcb_set_coalesce_usecs(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx, u32 timeout)\n{\n\tu32 old_timeout = hns_rcb_get_coalesce_usecs(rcb_common, port_idx);\n\n\tif (timeout == old_timeout)\n\t\treturn 0;\n\n\tif (AE_IS_VER1(rcb_common->dsaf_dev->dsaf_ver)) {\n\t\tif (!HNS_DSAF_IS_DEBUG(rcb_common->dsaf_dev)) {\n\t\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\t\"error: not support coalesce_usecs setting!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (timeout > HNS_RCB_MAX_COALESCED_USECS || timeout == 0) {\n\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\"error: coalesce_usecs setting supports 1~1023us\\n\");\n\t\treturn -EINVAL;\n\t}\n\thns_rcb_set_port_timeout(rcb_common, port_idx, timeout);\n\treturn 0;\n}\n\n/**\n *hns_rcb_set_tx_coalesced_frames - set rcb coalesced frames\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *@coalesced_frames:tx/rx BD num for coalesced frames\n *\n * Returns:\n * Zero for success, or an error code in case of failure\n */\nint hns_rcb_set_tx_coalesced_frames(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx, u32 coalesced_frames)\n{\n\tu32 old_waterline =\n\t\thns_rcb_get_tx_coalesced_frames(rcb_common, port_idx);\n\tu64 reg;\n\n\tif (coalesced_frames == old_waterline)\n\t\treturn 0;\n\n\tif (coalesced_frames != 1) {\n\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\"error: not support tx coalesce_frames setting!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = RCB_CFG_PKTLINE_REG + (port_idx + HNS_RCB_TX_PKTLINE_OFFSET) * 4;\n\tdsaf_write_dev(rcb_common, reg,\tcoalesced_frames);\n\treturn 0;\n}\n\n/**\n *hns_rcb_set_rx_coalesced_frames - set rcb rx coalesced frames\n *@rcb_common: rcb_common device\n *@port_idx:port id in comm\n *@coalesced_frames:tx/rx BD num for coalesced frames\n *\n * Returns:\n * Zero for success, or an error code in case of failure\n */\nint hns_rcb_set_rx_coalesced_frames(\n\tstruct rcb_common_cb *rcb_common, u32 port_idx, u32 coalesced_frames)\n{\n\tu32 old_waterline =\n\t\thns_rcb_get_rx_coalesced_frames(rcb_common, port_idx);\n\n\tif (coalesced_frames == old_waterline)\n\t\treturn 0;\n\n\tif (coalesced_frames >= rcb_common->desc_num ||\n\t    coalesced_frames > HNS_RCB_MAX_COALESCED_FRAMES ||\n\t    coalesced_frames < HNS_RCB_MIN_COALESCED_FRAMES) {\n\t\tdev_err(rcb_common->dsaf_dev->dev,\n\t\t\t\"error: not support coalesce_frames setting!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdsaf_write_dev(rcb_common, RCB_CFG_PKTLINE_REG + port_idx * 4,\n\t\t       coalesced_frames);\n\treturn 0;\n}\n\n/**\n *hns_rcb_get_queue_mode - get max VM number and max ring number per VM\n *\t\t\t\t\t\taccordding to dsaf mode\n *@dsaf_mode: dsaf mode\n *@max_vfn : max vfn number\n *@max_q_per_vf:max ring number per vm\n */\nvoid hns_rcb_get_queue_mode(enum dsaf_mode dsaf_mode, u16 *max_vfn,\n\t\t\t    u16 *max_q_per_vf)\n{\n\tswitch (dsaf_mode) {\n\tcase DSAF_MODE_DISABLE_6PORT_0VM:\n\t\t*max_vfn = 1;\n\t\t*max_q_per_vf = 16;\n\t\tbreak;\n\tcase DSAF_MODE_DISABLE_FIX:\n\tcase DSAF_MODE_DISABLE_SP:\n\t\t*max_vfn = 1;\n\t\t*max_q_per_vf = 1;\n\t\tbreak;\n\tcase DSAF_MODE_DISABLE_2PORT_64VM:\n\t\t*max_vfn = 64;\n\t\t*max_q_per_vf = 1;\n\t\tbreak;\n\tcase DSAF_MODE_DISABLE_6PORT_16VM:\n\t\t*max_vfn = 16;\n\t\t*max_q_per_vf = 1;\n\t\tbreak;\n\tdefault:\n\t\t*max_vfn = 1;\n\t\t*max_q_per_vf = 16;\n\t\tbreak;\n\t}\n}\n\nint hns_rcb_get_ring_num(struct dsaf_device *dsaf_dev)\n{\n\tswitch (dsaf_dev->dsaf_mode) {\n\tcase DSAF_MODE_ENABLE_FIX:\n\tcase DSAF_MODE_DISABLE_SP:\n\t\treturn 1;\n\n\tcase DSAF_MODE_DISABLE_FIX:\n\t\treturn 6;\n\n\tcase DSAF_MODE_ENABLE_0VM:\n\t\treturn 32;\n\n\tcase DSAF_MODE_DISABLE_6PORT_0VM:\n\tcase DSAF_MODE_ENABLE_16VM:\n\tcase DSAF_MODE_DISABLE_6PORT_2VM:\n\tcase DSAF_MODE_DISABLE_6PORT_16VM:\n\tcase DSAF_MODE_DISABLE_6PORT_4VM:\n\tcase DSAF_MODE_ENABLE_8VM:\n\t\treturn 96;\n\n\tcase DSAF_MODE_DISABLE_2PORT_16VM:\n\tcase DSAF_MODE_DISABLE_2PORT_8VM:\n\tcase DSAF_MODE_ENABLE_32VM:\n\tcase DSAF_MODE_DISABLE_2PORT_64VM:\n\tcase DSAF_MODE_ENABLE_128VM:\n\t\treturn 128;\n\n\tdefault:\n\t\tdev_warn(dsaf_dev->dev,\n\t\t\t \"get ring num fail,use default!dsaf_mode=%d\\n\",\n\t\t\t dsaf_dev->dsaf_mode);\n\t\treturn 128;\n\t}\n}\n\nvoid __iomem *hns_rcb_common_get_vaddr(struct rcb_common_cb *rcb_common)\n{\n\tstruct dsaf_device *dsaf_dev = rcb_common->dsaf_dev;\n\n\treturn dsaf_dev->ppe_base + RCB_COMMON_REG_OFFSET;\n}\n\nstatic phys_addr_t hns_rcb_common_get_paddr(struct rcb_common_cb *rcb_common)\n{\n\tstruct dsaf_device *dsaf_dev = rcb_common->dsaf_dev;\n\n\treturn dsaf_dev->ppe_paddr + RCB_COMMON_REG_OFFSET;\n}\n\nint hns_rcb_common_get_cfg(struct dsaf_device *dsaf_dev,\n\t\t\t   int comm_index)\n{\n\tstruct rcb_common_cb *rcb_common;\n\tenum dsaf_mode dsaf_mode = dsaf_dev->dsaf_mode;\n\tu16 max_vfn;\n\tu16 max_q_per_vf;\n\tint ring_num = hns_rcb_get_ring_num(dsaf_dev);\n\n\trcb_common =\n\t\tdevm_kzalloc(dsaf_dev->dev, sizeof(*rcb_common) +\n\t\t\tring_num * sizeof(struct ring_pair_cb), GFP_KERNEL);\n\tif (!rcb_common) {\n\t\tdev_err(dsaf_dev->dev, \"rcb common devm_kzalloc fail!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trcb_common->comm_index = comm_index;\n\trcb_common->ring_num = ring_num;\n\trcb_common->dsaf_dev = dsaf_dev;\n\n\trcb_common->desc_num = dsaf_dev->desc_num;\n\n\thns_rcb_get_queue_mode(dsaf_mode, &max_vfn, &max_q_per_vf);\n\trcb_common->max_vfn = max_vfn;\n\trcb_common->max_q_per_vf = max_q_per_vf;\n\n\trcb_common->io_base = hns_rcb_common_get_vaddr(rcb_common);\n\trcb_common->phy_base = hns_rcb_common_get_paddr(rcb_common);\n\n\tdsaf_dev->rcb_common[comm_index] = rcb_common;\n\treturn 0;\n}\n\nvoid hns_rcb_common_free_cfg(struct dsaf_device *dsaf_dev,\n\t\t\t     u32 comm_index)\n{\n\tdsaf_dev->rcb_common[comm_index] = NULL;\n}\n\nvoid hns_rcb_update_stats(struct hnae_queue *queue)\n{\n\tstruct ring_pair_cb *ring =\n\t\tcontainer_of(queue, struct ring_pair_cb, q);\n\tstruct dsaf_device *dsaf_dev = ring->rcb_common->dsaf_dev;\n\tstruct ppe_common_cb *ppe_common\n\t\t= dsaf_dev->ppe_common[ring->rcb_common->comm_index];\n\tstruct hns_ring_hw_stats *hw_stats = &ring->hw_stats;\n\n\thw_stats->rx_pkts += dsaf_read_dev(queue,\n\t\t\t RCB_RING_RX_RING_PKTNUM_RECORD_REG);\n\tdsaf_write_dev(queue, RCB_RING_RX_RING_PKTNUM_RECORD_REG, 0x1);\n\n\thw_stats->ppe_rx_ok_pkts += dsaf_read_dev(ppe_common,\n\t\t\t PPE_COM_HIS_RX_PKT_QID_OK_CNT_REG + 4 * ring->index);\n\thw_stats->ppe_rx_drop_pkts += dsaf_read_dev(ppe_common,\n\t\t\t PPE_COM_HIS_RX_PKT_QID_DROP_CNT_REG + 4 * ring->index);\n\n\thw_stats->tx_pkts += dsaf_read_dev(queue,\n\t\t\t RCB_RING_TX_RING_PKTNUM_RECORD_REG);\n\tdsaf_write_dev(queue, RCB_RING_TX_RING_PKTNUM_RECORD_REG, 0x1);\n\n\thw_stats->ppe_tx_ok_pkts += dsaf_read_dev(ppe_common,\n\t\t\t PPE_COM_HIS_TX_PKT_QID_OK_CNT_REG + 4 * ring->index);\n\thw_stats->ppe_tx_drop_pkts += dsaf_read_dev(ppe_common,\n\t\t\t PPE_COM_HIS_TX_PKT_QID_ERR_CNT_REG + 4 * ring->index);\n}\n\n/**\n *hns_rcb_get_stats - get rcb statistic\n *@ring: rcb ring\n *@data:statistic value\n */\nvoid hns_rcb_get_stats(struct hnae_queue *queue, u64 *data)\n{\n\tu64 *regs_buff = data;\n\tstruct ring_pair_cb *ring =\n\t\tcontainer_of(queue, struct ring_pair_cb, q);\n\tstruct hns_ring_hw_stats *hw_stats = &ring->hw_stats;\n\n\tregs_buff[0] = hw_stats->tx_pkts;\n\tregs_buff[1] = hw_stats->ppe_tx_ok_pkts;\n\tregs_buff[2] = hw_stats->ppe_tx_drop_pkts;\n\tregs_buff[3] =\n\t\tdsaf_read_dev(queue, RCB_RING_TX_RING_FBDNUM_REG);\n\n\tregs_buff[4] = queue->tx_ring.stats.tx_pkts;\n\tregs_buff[5] = queue->tx_ring.stats.tx_bytes;\n\tregs_buff[6] = queue->tx_ring.stats.tx_err_cnt;\n\tregs_buff[7] = queue->tx_ring.stats.io_err_cnt;\n\tregs_buff[8] = queue->tx_ring.stats.sw_err_cnt;\n\tregs_buff[9] = queue->tx_ring.stats.seg_pkt_cnt;\n\tregs_buff[10] = queue->tx_ring.stats.restart_queue;\n\tregs_buff[11] = queue->tx_ring.stats.tx_busy;\n\n\tregs_buff[12] = hw_stats->rx_pkts;\n\tregs_buff[13] = hw_stats->ppe_rx_ok_pkts;\n\tregs_buff[14] = hw_stats->ppe_rx_drop_pkts;\n\tregs_buff[15] =\n\t\tdsaf_read_dev(queue, RCB_RING_RX_RING_FBDNUM_REG);\n\n\tregs_buff[16] = queue->rx_ring.stats.rx_pkts;\n\tregs_buff[17] = queue->rx_ring.stats.rx_bytes;\n\tregs_buff[18] = queue->rx_ring.stats.rx_err_cnt;\n\tregs_buff[19] = queue->rx_ring.stats.io_err_cnt;\n\tregs_buff[20] = queue->rx_ring.stats.sw_err_cnt;\n\tregs_buff[21] = queue->rx_ring.stats.seg_pkt_cnt;\n\tregs_buff[22] = queue->rx_ring.stats.reuse_pg_cnt;\n\tregs_buff[23] = queue->rx_ring.stats.err_pkt_len;\n\tregs_buff[24] = queue->rx_ring.stats.non_vld_descs;\n\tregs_buff[25] = queue->rx_ring.stats.err_bd_num;\n\tregs_buff[26] = queue->rx_ring.stats.l2_err;\n\tregs_buff[27] = queue->rx_ring.stats.l3l4_csum_err;\n}\n\n/**\n *hns_rcb_get_ring_sset_count - rcb string set count\n *@stringset:ethtool cmd\n *return rcb ring string set count\n */\nint hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}\n\n/**\n *hns_rcb_get_common_regs_count - rcb common regs count\n *return regs count\n */\nint hns_rcb_get_common_regs_count(void)\n{\n\treturn HNS_RCB_COMMON_DUMP_REG_NUM;\n}\n\n/**\n *rcb_get_sset_count - rcb ring regs count\n *return regs count\n */\nint hns_rcb_get_ring_regs_count(void)\n{\n\treturn HNS_RCB_RING_DUMP_REG_NUM;\n}\n\n/**\n *hns_rcb_get_strings - get rcb string set\n *@stringset:string set index\n *@data:strings name value\n *@index:queue index\n */\nvoid hns_rcb_get_strings(int stringset, u8 *data, int index)\n{\n\tchar *buff = (char *)data;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_rcb_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_ppe_tx_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_ppe_drop_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_fbd_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_bytes\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_err_cnt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_io_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_sw_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_seg_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_restart_queue\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_tx_busy\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_rcb_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_ppe_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_ppe_drop_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_fbd_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_bytes\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_err_cnt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_io_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_sw_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_seg_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_reuse_pg\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_len_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_non_vld_desc_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_bd_num_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_l2_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_l3l4csum_err\", index);\n}\n\nvoid hns_rcb_get_common_regs(struct rcb_common_cb *rcb_com, void *data)\n{\n\tu32 *regs = data;\n\tbool is_ver1 = AE_IS_VER1(rcb_com->dsaf_dev->dsaf_ver);\n\tbool is_dbg = HNS_DSAF_IS_DEBUG(rcb_com->dsaf_dev);\n\tu32 reg_tmp;\n\tu32 reg_num_tmp;\n\tu32 i = 0;\n\n\t/*rcb common registers */\n\tregs[0] = dsaf_read_dev(rcb_com, RCB_COM_CFG_ENDIAN_REG);\n\tregs[1] = dsaf_read_dev(rcb_com, RCB_COM_CFG_SYS_FSH_REG);\n\tregs[2] = dsaf_read_dev(rcb_com, RCB_COM_CFG_INIT_FLAG_REG);\n\n\tregs[3] = dsaf_read_dev(rcb_com, RCB_COM_CFG_PKT_REG);\n\tregs[4] = dsaf_read_dev(rcb_com, RCB_COM_CFG_RINVLD_REG);\n\tregs[5] = dsaf_read_dev(rcb_com, RCB_COM_CFG_FNA_REG);\n\tregs[6] = dsaf_read_dev(rcb_com, RCB_COM_CFG_FA_REG);\n\tregs[7] = dsaf_read_dev(rcb_com, RCB_COM_CFG_PKT_TC_BP_REG);\n\tregs[8] = dsaf_read_dev(rcb_com, RCB_COM_CFG_PPE_TNL_CLKEN_REG);\n\n\tregs[9] = dsaf_read_dev(rcb_com, RCB_COM_INTMSK_TX_PKT_REG);\n\tregs[10] = dsaf_read_dev(rcb_com, RCB_COM_RINT_TX_PKT_REG);\n\tregs[11] = dsaf_read_dev(rcb_com, RCB_COM_INTMASK_ECC_ERR_REG);\n\tregs[12] = dsaf_read_dev(rcb_com, RCB_COM_INTSTS_ECC_ERR_REG);\n\tregs[13] = dsaf_read_dev(rcb_com, RCB_COM_EBD_SRAM_ERR_REG);\n\tregs[14] = dsaf_read_dev(rcb_com, RCB_COM_RXRING_ERR_REG);\n\tregs[15] = dsaf_read_dev(rcb_com, RCB_COM_TXRING_ERR_REG);\n\tregs[16] = dsaf_read_dev(rcb_com, RCB_COM_TX_FBD_ERR_REG);\n\tregs[17] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK_EN_REG);\n\tregs[18] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK0_REG);\n\tregs[19] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK1_REG);\n\tregs[20] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK2_REG);\n\tregs[21] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK3_REG);\n\tregs[22] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK4_REG);\n\tregs[23] = dsaf_read_dev(rcb_com, RCB_SRAM_ECC_CHK5_REG);\n\tregs[24] = dsaf_read_dev(rcb_com, RCB_ECC_ERR_ADDR0_REG);\n\tregs[25] = dsaf_read_dev(rcb_com, RCB_ECC_ERR_ADDR3_REG);\n\tregs[26] = dsaf_read_dev(rcb_com, RCB_ECC_ERR_ADDR4_REG);\n\tregs[27] = dsaf_read_dev(rcb_com, RCB_ECC_ERR_ADDR5_REG);\n\n\tregs[28] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_INTMASK_RING);\n\tregs[29] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_RING_STS);\n\tregs[30] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_RING);\n\tregs[31] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_INTMASK_BD);\n\tregs[32] = dsaf_read_dev(rcb_com, RCB_COM_SF_CFG_BD_RINT_STS);\n\tregs[33] = dsaf_read_dev(rcb_com, RCB_COM_RCB_RD_BD_BUSY);\n\tregs[34] = dsaf_read_dev(rcb_com, RCB_COM_RCB_FBD_CRT_EN);\n\tregs[35] = dsaf_read_dev(rcb_com, RCB_COM_AXI_WR_ERR_INTMASK);\n\tregs[36] = dsaf_read_dev(rcb_com, RCB_COM_AXI_ERR_STS);\n\tregs[37] = dsaf_read_dev(rcb_com, RCB_COM_CHK_TX_FBD_NUM_REG);\n\n\t/* rcb common entry registers */\n\tfor (i = 0; i < 16; i++) { /* total 16 model registers */\n\t\tregs[38 + i]\n\t\t\t= dsaf_read_dev(rcb_com, RCB_CFG_BD_NUM_REG + 4 * i);\n\t\tregs[54 + i]\n\t\t\t= dsaf_read_dev(rcb_com, RCB_CFG_PKTLINE_REG + 4 * i);\n\t}\n\n\treg_tmp = is_ver1 ? RCB_CFG_OVERTIME_REG : RCB_PORT_CFG_OVERTIME_REG;\n\treg_num_tmp = (is_ver1 || is_dbg) ? 1 : 6;\n\tfor (i = 0; i < reg_num_tmp; i++)\n\t\tregs[70 + i] = dsaf_read_dev(rcb_com, reg_tmp);\n\n\tregs[76] = dsaf_read_dev(rcb_com, RCB_CFG_PKTLINE_INT_NUM_REG);\n\tregs[77] = dsaf_read_dev(rcb_com, RCB_CFG_OVERTIME_INT_NUM_REG);\n\n\t/* mark end of rcb common regs */\n\tfor (i = 78; i < 80; i++)\n\t\tregs[i] = 0xcccccccc;\n}\n\nvoid hns_rcb_get_ring_regs(struct hnae_queue *queue, void *data)\n{\n\tu32 *regs = data;\n\tstruct ring_pair_cb *ring_pair\n\t\t= container_of(queue, struct ring_pair_cb, q);\n\tu32 i = 0;\n\n\t/*rcb ring registers */\n\tregs[0] = dsaf_read_dev(queue, RCB_RING_RX_RING_BASEADDR_L_REG);\n\tregs[1] = dsaf_read_dev(queue, RCB_RING_RX_RING_BASEADDR_H_REG);\n\tregs[2] = dsaf_read_dev(queue, RCB_RING_RX_RING_BD_NUM_REG);\n\tregs[3] = dsaf_read_dev(queue, RCB_RING_RX_RING_BD_LEN_REG);\n\tregs[4] = dsaf_read_dev(queue, RCB_RING_RX_RING_PKTLINE_REG);\n\tregs[5] = dsaf_read_dev(queue, RCB_RING_RX_RING_TAIL_REG);\n\tregs[6] = dsaf_read_dev(queue, RCB_RING_RX_RING_HEAD_REG);\n\tregs[7] = dsaf_read_dev(queue, RCB_RING_RX_RING_FBDNUM_REG);\n\tregs[8] = dsaf_read_dev(queue, RCB_RING_RX_RING_PKTNUM_RECORD_REG);\n\n\tregs[9] = dsaf_read_dev(queue, RCB_RING_TX_RING_BASEADDR_L_REG);\n\tregs[10] = dsaf_read_dev(queue, RCB_RING_TX_RING_BASEADDR_H_REG);\n\tregs[11] = dsaf_read_dev(queue, RCB_RING_TX_RING_BD_NUM_REG);\n\tregs[12] = dsaf_read_dev(queue, RCB_RING_TX_RING_BD_LEN_REG);\n\tregs[13] = dsaf_read_dev(queue, RCB_RING_TX_RING_PKTLINE_REG);\n\tregs[15] = dsaf_read_dev(queue, RCB_RING_TX_RING_TAIL_REG);\n\tregs[16] = dsaf_read_dev(queue, RCB_RING_TX_RING_HEAD_REG);\n\tregs[17] = dsaf_read_dev(queue, RCB_RING_TX_RING_FBDNUM_REG);\n\tregs[18] = dsaf_read_dev(queue, RCB_RING_TX_RING_OFFSET_REG);\n\tregs[19] = dsaf_read_dev(queue, RCB_RING_TX_RING_PKTNUM_RECORD_REG);\n\n\tregs[20] = dsaf_read_dev(queue, RCB_RING_PREFETCH_EN_REG);\n\tregs[21] = dsaf_read_dev(queue, RCB_RING_CFG_VF_NUM_REG);\n\tregs[22] = dsaf_read_dev(queue, RCB_RING_ASID_REG);\n\tregs[23] = dsaf_read_dev(queue, RCB_RING_RX_VM_REG);\n\tregs[24] = dsaf_read_dev(queue, RCB_RING_T0_BE_RST);\n\tregs[25] = dsaf_read_dev(queue, RCB_RING_COULD_BE_RST);\n\tregs[26] = dsaf_read_dev(queue, RCB_RING_WRR_WEIGHT_REG);\n\n\tregs[27] = dsaf_read_dev(queue, RCB_RING_INTMSK_RXWL_REG);\n\tregs[28] = dsaf_read_dev(queue, RCB_RING_INTSTS_RX_RING_REG);\n\tregs[29] = dsaf_read_dev(queue, RCB_RING_INTMSK_TXWL_REG);\n\tregs[30] = dsaf_read_dev(queue, RCB_RING_INTSTS_TX_RING_REG);\n\tregs[31] = dsaf_read_dev(queue, RCB_RING_INTMSK_RX_OVERTIME_REG);\n\tregs[32] = dsaf_read_dev(queue, RCB_RING_INTSTS_RX_OVERTIME_REG);\n\tregs[33] = dsaf_read_dev(queue, RCB_RING_INTMSK_TX_OVERTIME_REG);\n\tregs[34] = dsaf_read_dev(queue, RCB_RING_INTSTS_TX_OVERTIME_REG);\n\n\t/* mark end of ring regs */\n\tfor (i = 35; i < 40; i++)\n\t\tregs[i] = 0xcccccc00 + ring_pair->index;\n}\n", "/*\n * Copyright (c) 2014-2015 Hisilicon Limited.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/io-64-nonatomic-hi-lo.h>\n#include <linux/of_mdio.h>\n#include \"hns_dsaf_main.h\"\n#include \"hns_dsaf_mac.h\"\n#include \"hns_dsaf_xgmac.h\"\n#include \"hns_dsaf_reg.h\"\n\nstatic const struct mac_stats_string g_xgmac_stats_string[] = {\n\t{\"xgmac_tx_bad_pkts_minto64\", MAC_STATS_FIELD_OFF(tx_fragment_err)},\n\t{\"xgmac_tx_good_pkts_minto64\", MAC_STATS_FIELD_OFF(tx_undersize)},\n\t{\"xgmac_tx_total_pkts_minto64\",\tMAC_STATS_FIELD_OFF(tx_under_min_pkts)},\n\t{\"xgmac_tx_pkts_64\", MAC_STATS_FIELD_OFF(tx_64bytes)},\n\t{\"xgmac_tx_pkts_65to127\", MAC_STATS_FIELD_OFF(tx_65to127)},\n\t{\"xgmac_tx_pkts_128to255\", MAC_STATS_FIELD_OFF(tx_128to255)},\n\t{\"xgmac_tx_pkts_256to511\", MAC_STATS_FIELD_OFF(tx_256to511)},\n\t{\"xgmac_tx_pkts_512to1023\", MAC_STATS_FIELD_OFF(tx_512to1023)},\n\t{\"xgmac_tx_pkts_1024to1518\", MAC_STATS_FIELD_OFF(tx_1024to1518)},\n\t{\"xgmac_tx_pkts_1519tomax\", MAC_STATS_FIELD_OFF(tx_1519tomax)},\n\t{\"xgmac_tx_good_pkts_1519tomax\",\n\t\tMAC_STATS_FIELD_OFF(tx_1519tomax_good)},\n\t{\"xgmac_tx_good_pkts_untralmax\", MAC_STATS_FIELD_OFF(tx_oversize)},\n\t{\"xgmac_tx_bad_pkts_untralmax\", MAC_STATS_FIELD_OFF(tx_jabber_err)},\n\t{\"xgmac_tx_good_pkts_all\", MAC_STATS_FIELD_OFF(tx_good_pkts)},\n\t{\"xgmac_tx_good_byte_all\", MAC_STATS_FIELD_OFF(tx_good_bytes)},\n\t{\"xgmac_tx_total_pkt\", MAC_STATS_FIELD_OFF(tx_total_pkts)},\n\t{\"xgmac_tx_total_byt\", MAC_STATS_FIELD_OFF(tx_total_bytes)},\n\t{\"xgmac_tx_uc_pkt\", MAC_STATS_FIELD_OFF(tx_uc_pkts)},\n\t{\"xgmac_tx_mc_pkt\", MAC_STATS_FIELD_OFF(tx_mc_pkts)},\n\t{\"xgmac_tx_bc_pkt\", MAC_STATS_FIELD_OFF(tx_bc_pkts)},\n\t{\"xgmac_tx_pause_frame_num\", MAC_STATS_FIELD_OFF(tx_pfc_tc0)},\n\t{\"xgmac_tx_pfc_per_1pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc1)},\n\t{\"xgmac_tx_pfc_per_2pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc2)},\n\t{\"xgmac_tx_pfc_per_3pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc3)},\n\t{\"xgmac_tx_pfc_per_4pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc4)},\n\t{\"xgmac_tx_pfc_per_5pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc5)},\n\t{\"xgmac_tx_pfc_per_6pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc6)},\n\t{\"xgmac_tx_pfc_per_7pause_framer\", MAC_STATS_FIELD_OFF(tx_pfc_tc7)},\n\t{\"xgmac_tx_mac_ctrol_frame\", MAC_STATS_FIELD_OFF(tx_ctrl)},\n\t{\"xgmac_tx_1731_pkts\", MAC_STATS_FIELD_OFF(tx_1731_pkts)},\n\t{\"xgmac_tx_1588_pkts\", MAC_STATS_FIELD_OFF(tx_1588_pkts)},\n\t{\"xgmac_rx_good_pkt_from_dsaf\", MAC_STATS_FIELD_OFF(rx_good_from_sw)},\n\t{\"xgmac_rx_bad_pkt_from_dsaf\", MAC_STATS_FIELD_OFF(rx_bad_from_sw)},\n\t{\"xgmac_tx_bad_pkt_64tomax\", MAC_STATS_FIELD_OFF(tx_bad_pkts)},\n\n\t{\"xgmac_rx_bad_pkts_minto64\", MAC_STATS_FIELD_OFF(rx_fragment_err)},\n\t{\"xgmac_rx_good_pkts_minto64\", MAC_STATS_FIELD_OFF(rx_undersize)},\n\t{\"xgmac_rx_total_pkts_minto64\", MAC_STATS_FIELD_OFF(rx_under_min)},\n\t{\"xgmac_rx_pkt_64\", MAC_STATS_FIELD_OFF(rx_64bytes)},\n\t{\"xgmac_rx_pkt_65to127\", MAC_STATS_FIELD_OFF(rx_65to127)},\n\t{\"xgmac_rx_pkt_128to255\", MAC_STATS_FIELD_OFF(rx_128to255)},\n\t{\"xgmac_rx_pkt_256to511\", MAC_STATS_FIELD_OFF(rx_256to511)},\n\t{\"xgmac_rx_pkt_512to1023\", MAC_STATS_FIELD_OFF(rx_512to1023)},\n\t{\"xgmac_rx_pkt_1024to1518\", MAC_STATS_FIELD_OFF(rx_1024to1518)},\n\t{\"xgmac_rx_pkt_1519tomax\", MAC_STATS_FIELD_OFF(rx_1519tomax)},\n\t{\"xgmac_rx_good_pkt_1519tomax\",\tMAC_STATS_FIELD_OFF(rx_1519tomax_good)},\n\t{\"xgmac_rx_good_pkt_untramax\", MAC_STATS_FIELD_OFF(rx_oversize)},\n\t{\"xgmac_rx_bad_pkt_untramax\", MAC_STATS_FIELD_OFF(rx_jabber_err)},\n\t{\"xgmac_rx_good_pkt\", MAC_STATS_FIELD_OFF(rx_good_pkts)},\n\t{\"xgmac_rx_good_byt\", MAC_STATS_FIELD_OFF(rx_good_bytes)},\n\t{\"xgmac_rx_pkt\", MAC_STATS_FIELD_OFF(rx_total_pkts)},\n\t{\"xgmac_rx_byt\", MAC_STATS_FIELD_OFF(rx_total_bytes)},\n\t{\"xgmac_rx_uc_pkt\", MAC_STATS_FIELD_OFF(rx_uc_pkts)},\n\t{\"xgmac_rx_mc_pkt\", MAC_STATS_FIELD_OFF(rx_mc_pkts)},\n\t{\"xgmac_rx_bc_pkt\", MAC_STATS_FIELD_OFF(rx_bc_pkts)},\n\t{\"xgmac_rx_pause_frame_num\", MAC_STATS_FIELD_OFF(rx_pfc_tc0)},\n\t{\"xgmac_rx_pfc_per_1pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc1)},\n\t{\"xgmac_rx_pfc_per_2pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc2)},\n\t{\"xgmac_rx_pfc_per_3pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc3)},\n\t{\"xgmac_rx_pfc_per_4pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc4)},\n\t{\"xgmac_rx_pfc_per_5pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc5)},\n\t{\"xgmac_rx_pfc_per_6pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc6)},\n\t{\"xgmac_rx_pfc_per_7pause_frame\", MAC_STATS_FIELD_OFF(rx_pfc_tc7)},\n\t{\"xgmac_rx_mac_control\", MAC_STATS_FIELD_OFF(rx_unknown_ctrl)},\n\t{\"xgmac_tx_good_pkt_todsaf\", MAC_STATS_FIELD_OFF(tx_good_to_sw)},\n\t{\"xgmac_tx_bad_pkt_todsaf\", MAC_STATS_FIELD_OFF(tx_bad_to_sw)},\n\t{\"xgmac_rx_1731_pkt\", MAC_STATS_FIELD_OFF(rx_1731_pkts)},\n\t{\"xgmac_rx_symbol_err_pkt\", MAC_STATS_FIELD_OFF(rx_symbol_err)},\n\t{\"xgmac_rx_fcs_pkt\", MAC_STATS_FIELD_OFF(rx_fcs_err)}\n};\n\n/**\n *hns_xgmac_tx_enable - xgmac port tx enable\n *@drv: mac driver\n *@value: value of enable\n */\nstatic void hns_xgmac_tx_enable(struct mac_driver *drv, u32 value)\n{\n\tdsaf_set_dev_bit(drv, XGMAC_MAC_ENABLE_REG, XGMAC_ENABLE_TX_B, !!value);\n}\n\n/**\n *hns_xgmac_rx_enable - xgmac port rx enable\n *@drv: mac driver\n *@value: value of enable\n */\nstatic void hns_xgmac_rx_enable(struct mac_driver *drv, u32 value)\n{\n\tdsaf_set_dev_bit(drv, XGMAC_MAC_ENABLE_REG, XGMAC_ENABLE_RX_B, !!value);\n}\n\n/**\n * hns_xgmac_tx_lf_rf_insert - insert lf rf control about xgmac\n * @mac_drv: mac driver\n * @mode: inserf rf or lf\n */\nstatic void hns_xgmac_lf_rf_insert(struct mac_driver *mac_drv, u32 mode)\n{\n\tdsaf_set_dev_field(mac_drv, XGMAC_MAC_TX_LF_RF_CONTROL_REG,\n\t\t\t   XGMAC_LF_RF_INSERT_M, XGMAC_LF_RF_INSERT_S, mode);\n}\n\n/**\n * hns_xgmac__lf_rf_control_init - initial the lf rf control register\n * @mac_drv: mac driver\n */\nstatic void hns_xgmac_lf_rf_control_init(struct mac_driver *mac_drv)\n{\n\tu32 val = 0;\n\n\tdsaf_set_bit(val, XGMAC_UNIDIR_EN_B, 0);\n\tdsaf_set_bit(val, XGMAC_RF_TX_EN_B, 1);\n\tdsaf_set_field(val, XGMAC_LF_RF_INSERT_M, XGMAC_LF_RF_INSERT_S, 0);\n\tdsaf_write_reg(mac_drv, XGMAC_MAC_TX_LF_RF_CONTROL_REG, val);\n}\n\n/**\n *hns_xgmac_enable - enable xgmac port\n *@drv: mac driver\n *@mode: mode of mac port\n */\nstatic void hns_xgmac_enable(void *mac_drv, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\thns_xgmac_lf_rf_insert(drv, HNS_XGMAC_NO_LF_RF_INSERT);\n\n\t/*enable XGE rX/tX */\n\tif (mode == MAC_COMM_MODE_TX) {\n\t\thns_xgmac_tx_enable(drv, 1);\n\t} else if (mode == MAC_COMM_MODE_RX) {\n\t\thns_xgmac_rx_enable(drv, 1);\n\t} else if (mode == MAC_COMM_MODE_RX_AND_TX) {\n\t\thns_xgmac_tx_enable(drv, 1);\n\t\thns_xgmac_rx_enable(drv, 1);\n\t} else {\n\t\tdev_err(drv->dev, \"error mac mode:%d\\n\", mode);\n\t}\n}\n\n/**\n *hns_xgmac_disable - disable xgmac port\n *@mac_drv: mac driver\n *@mode: mode of mac port\n */\nstatic void hns_xgmac_disable(void *mac_drv, enum mac_commom_mode mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tif (mode == MAC_COMM_MODE_TX) {\n\t\thns_xgmac_tx_enable(drv, 0);\n\t} else if (mode == MAC_COMM_MODE_RX) {\n\t\thns_xgmac_rx_enable(drv, 0);\n\t} else if (mode == MAC_COMM_MODE_RX_AND_TX) {\n\t\thns_xgmac_tx_enable(drv, 0);\n\t\thns_xgmac_rx_enable(drv, 0);\n\t}\n\thns_xgmac_lf_rf_insert(drv, HNS_XGMAC_LF_INSERT);\n}\n\n/**\n *hns_xgmac_pma_fec_enable - xgmac PMA FEC enable\n *@drv: mac driver\n *@tx_value: tx value\n *@rx_value: rx value\n *return status\n */\nstatic void hns_xgmac_pma_fec_enable(struct mac_driver *drv, u32 tx_value,\n\t\t\t\t     u32 rx_value)\n{\n\tu32 origin = dsaf_read_dev(drv, XGMAC_PMA_FEC_CONTROL_REG);\n\n\tdsaf_set_bit(origin, XGMAC_PMA_FEC_CTL_TX_B, !!tx_value);\n\tdsaf_set_bit(origin, XGMAC_PMA_FEC_CTL_RX_B, !!rx_value);\n\tdsaf_write_dev(drv, XGMAC_PMA_FEC_CONTROL_REG, origin);\n}\n\n/* clr exc irq for xge*/\nstatic void hns_xgmac_exc_irq_en(struct mac_driver *drv, u32 en)\n{\n\tu32 clr_vlue = 0xfffffffful;\n\tu32 msk_vlue = en ? 0xfffffffful : 0; /*1 is en, 0 is dis*/\n\n\tdsaf_write_dev(drv, XGMAC_INT_STATUS_REG, clr_vlue);\n\tdsaf_write_dev(drv, XGMAC_INT_ENABLE_REG, msk_vlue);\n}\n\n/**\n *hns_xgmac_init - initialize XGE\n *@mac_drv: mac driver\n */\nstatic void hns_xgmac_init(void *mac_drv)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct dsaf_device *dsaf_dev\n\t\t= (struct dsaf_device *)dev_get_drvdata(drv->dev);\n\tu32 port = drv->mac_id;\n\n\tdsaf_dev->misc_op->xge_srst(dsaf_dev, port, 0);\n\tmdelay(100);\n\tdsaf_dev->misc_op->xge_srst(dsaf_dev, port, 1);\n\n\tmdelay(100);\n\thns_xgmac_lf_rf_control_init(drv);\n\thns_xgmac_exc_irq_en(drv, 0);\n\n\thns_xgmac_pma_fec_enable(drv, 0x0, 0x0);\n\n\thns_xgmac_disable(mac_drv, MAC_COMM_MODE_RX_AND_TX);\n}\n\n/**\n *hns_xgmac_config_pad_and_crc - set xgmac pad and crc enable the same time\n *@mac_drv: mac driver\n *@newval:enable of pad and crc\n */\nstatic void hns_xgmac_config_pad_and_crc(void *mac_drv, u8 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 origin = dsaf_read_dev(drv, XGMAC_MAC_CONTROL_REG);\n\n\tdsaf_set_bit(origin, XGMAC_CTL_TX_PAD_B, !!newval);\n\tdsaf_set_bit(origin, XGMAC_CTL_TX_FCS_B, !!newval);\n\tdsaf_set_bit(origin, XGMAC_CTL_RX_FCS_B, !!newval);\n\tdsaf_write_dev(drv, XGMAC_MAC_CONTROL_REG, origin);\n}\n\n/**\n *hns_xgmac_pausefrm_cfg - set pause param about xgmac\n *@mac_drv: mac driver\n *@newval:enable of pad and crc\n */\nstatic void hns_xgmac_pausefrm_cfg(void *mac_drv, u32 rx_en, u32 tx_en)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 origin = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG);\n\n\tdsaf_set_bit(origin, XGMAC_PAUSE_CTL_TX_B, !!tx_en);\n\tdsaf_set_bit(origin, XGMAC_PAUSE_CTL_RX_B, !!rx_en);\n\tdsaf_write_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG, origin);\n}\n\nstatic void hns_xgmac_set_pausefrm_mac_addr(void *mac_drv, char *mac_addr)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tu32 high_val = mac_addr[1] | (mac_addr[0] << 8);\n\tu32 low_val = mac_addr[5] | (mac_addr[4] << 8)\n\t\t| (mac_addr[3] << 16) | (mac_addr[2] << 24);\n\tdsaf_write_dev(drv, XGMAC_MAC_PAUSE_LOCAL_MAC_L_REG, low_val);\n\tdsaf_write_dev(drv, XGMAC_MAC_PAUSE_LOCAL_MAC_H_REG, high_val);\n}\n\n/**\n *hns_xgmac_set_rx_ignore_pause_frames - set rx pause param about xgmac\n *@mac_drv: mac driver\n *@enable:enable rx pause param\n */\nstatic void hns_xgmac_set_rx_ignore_pause_frames(void *mac_drv, u32 enable)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, XGMAC_MAC_PAUSE_CTRL_REG,\n\t\t\t XGMAC_PAUSE_CTL_RX_B, !!enable);\n}\n\n/**\n *hns_xgmac_set_tx_auto_pause_frames - set tx pause param about xgmac\n *@mac_drv: mac driver\n *@enable:enable tx pause param\n */\nstatic void hns_xgmac_set_tx_auto_pause_frames(void *mac_drv, u16 enable)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, XGMAC_MAC_PAUSE_CTRL_REG,\n\t\t\t XGMAC_PAUSE_CTL_TX_B, !!enable);\n\n\t/*if enable is not zero ,set tx pause time */\n\tif (enable)\n\t\tdsaf_write_dev(drv, XGMAC_MAC_PAUSE_TIME_REG, enable);\n}\n\n/**\n *hns_xgmac_config_max_frame_length - set xgmac max frame length\n *@mac_drv: mac driver\n *@newval:xgmac max frame length\n */\nstatic void hns_xgmac_config_max_frame_length(void *mac_drv, u16 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_write_dev(drv, XGMAC_MAC_MAX_PKT_SIZE_REG, newval);\n}\n\nvoid hns_xgmac_update_stats(void *mac_drv)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct mac_hw_stats *hw_stats = &drv->mac_cb->hw_stats;\n\n\t/* TX */\n\thw_stats->tx_fragment_err\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_FRAGMENT);\n\thw_stats->tx_undersize\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_UNDERSIZE);\n\thw_stats->tx_under_min_pkts\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_UNDERMIN);\n\thw_stats->tx_64bytes = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_64OCTETS);\n\thw_stats->tx_65to127\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_65TO127OCTETS);\n\thw_stats->tx_128to255\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_128TO255OCTETS);\n\thw_stats->tx_256to511\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_256TO511OCTETS);\n\thw_stats->tx_512to1023\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_512TO1023OCTETS);\n\thw_stats->tx_1024to1518\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1024TO1518OCTETS);\n\thw_stats->tx_1519tomax\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1519TOMAXOCTETS);\n\thw_stats->tx_1519tomax_good\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1519TOMAXOCTETSOK);\n\thw_stats->tx_oversize = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_OVERSIZE);\n\thw_stats->tx_jabber_err = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_JABBER);\n\thw_stats->tx_good_pkts = hns_mac_reg_read64(drv, XGMAC_TX_GOODPKTS);\n\thw_stats->tx_good_bytes = hns_mac_reg_read64(drv, XGMAC_TX_GOODOCTETS);\n\thw_stats->tx_total_pkts = hns_mac_reg_read64(drv, XGMAC_TX_TOTAL_PKTS);\n\thw_stats->tx_total_bytes\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_TOTALOCTETS);\n\thw_stats->tx_uc_pkts = hns_mac_reg_read64(drv, XGMAC_TX_UNICASTPKTS);\n\thw_stats->tx_mc_pkts = hns_mac_reg_read64(drv, XGMAC_TX_MULTICASTPKTS);\n\thw_stats->tx_bc_pkts = hns_mac_reg_read64(drv, XGMAC_TX_BROADCASTPKTS);\n\thw_stats->tx_pfc_tc0 = hns_mac_reg_read64(drv, XGMAC_TX_PRI0PAUSEPKTS);\n\thw_stats->tx_pfc_tc1 = hns_mac_reg_read64(drv, XGMAC_TX_PRI1PAUSEPKTS);\n\thw_stats->tx_pfc_tc2 = hns_mac_reg_read64(drv, XGMAC_TX_PRI2PAUSEPKTS);\n\thw_stats->tx_pfc_tc3 = hns_mac_reg_read64(drv, XGMAC_TX_PRI3PAUSEPKTS);\n\thw_stats->tx_pfc_tc4 = hns_mac_reg_read64(drv, XGMAC_TX_PRI4PAUSEPKTS);\n\thw_stats->tx_pfc_tc5 = hns_mac_reg_read64(drv, XGMAC_TX_PRI5PAUSEPKTS);\n\thw_stats->tx_pfc_tc6 = hns_mac_reg_read64(drv, XGMAC_TX_PRI6PAUSEPKTS);\n\thw_stats->tx_pfc_tc7 = hns_mac_reg_read64(drv, XGMAC_TX_PRI7PAUSEPKTS);\n\thw_stats->tx_ctrl = hns_mac_reg_read64(drv, XGMAC_TX_MACCTRLPKTS);\n\thw_stats->tx_1731_pkts = hns_mac_reg_read64(drv, XGMAC_TX_1731PKTS);\n\thw_stats->tx_1588_pkts = hns_mac_reg_read64(drv, XGMAC_TX_1588PKTS);\n\thw_stats->rx_good_from_sw\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_FROMAPPGOODPKTS);\n\thw_stats->rx_bad_from_sw\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_FROMAPPBADPKTS);\n\thw_stats->tx_bad_pkts = hns_mac_reg_read64(drv, XGMAC_TX_ERRALLPKTS);\n\n\t/* RX */\n\thw_stats->rx_fragment_err\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_FRAGMENT);\n\thw_stats->rx_undersize\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTSUNDERSIZE);\n\thw_stats->rx_under_min\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_UNDERMIN);\n\thw_stats->rx_64bytes = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_64OCTETS);\n\thw_stats->rx_65to127\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_65TO127OCTETS);\n\thw_stats->rx_128to255\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_128TO255OCTETS);\n\thw_stats->rx_256to511\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_256TO511OCTETS);\n\thw_stats->rx_512to1023\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_512TO1023OCTETS);\n\thw_stats->rx_1024to1518\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1024TO1518OCTETS);\n\thw_stats->rx_1519tomax\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1519TOMAXOCTETS);\n\thw_stats->rx_1519tomax_good\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1519TOMAXOCTETSOK);\n\thw_stats->rx_oversize = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_OVERSIZE);\n\thw_stats->rx_jabber_err = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_JABBER);\n\thw_stats->rx_good_pkts = hns_mac_reg_read64(drv, XGMAC_RX_GOODPKTS);\n\thw_stats->rx_good_bytes = hns_mac_reg_read64(drv, XGMAC_RX_GOODOCTETS);\n\thw_stats->rx_total_pkts = hns_mac_reg_read64(drv, XGMAC_RX_TOTAL_PKTS);\n\thw_stats->rx_total_bytes\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_TOTALOCTETS);\n\thw_stats->rx_uc_pkts = hns_mac_reg_read64(drv, XGMAC_RX_UNICASTPKTS);\n\thw_stats->rx_mc_pkts = hns_mac_reg_read64(drv, XGMAC_RX_MULTICASTPKTS);\n\thw_stats->rx_bc_pkts = hns_mac_reg_read64(drv, XGMAC_RX_BROADCASTPKTS);\n\thw_stats->rx_pfc_tc0 = hns_mac_reg_read64(drv, XGMAC_RX_PRI0PAUSEPKTS);\n\thw_stats->rx_pfc_tc1 = hns_mac_reg_read64(drv, XGMAC_RX_PRI1PAUSEPKTS);\n\thw_stats->rx_pfc_tc2 = hns_mac_reg_read64(drv, XGMAC_RX_PRI2PAUSEPKTS);\n\thw_stats->rx_pfc_tc3 = hns_mac_reg_read64(drv, XGMAC_RX_PRI3PAUSEPKTS);\n\thw_stats->rx_pfc_tc4 = hns_mac_reg_read64(drv, XGMAC_RX_PRI4PAUSEPKTS);\n\thw_stats->rx_pfc_tc5 = hns_mac_reg_read64(drv, XGMAC_RX_PRI5PAUSEPKTS);\n\thw_stats->rx_pfc_tc6 = hns_mac_reg_read64(drv, XGMAC_RX_PRI6PAUSEPKTS);\n\thw_stats->rx_pfc_tc7 = hns_mac_reg_read64(drv, XGMAC_RX_PRI7PAUSEPKTS);\n\n\thw_stats->rx_unknown_ctrl\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_MACCTRLPKTS);\n\thw_stats->tx_good_to_sw\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_SENDAPPGOODPKTS);\n\thw_stats->tx_bad_to_sw\n\t\t= hns_mac_reg_read64(drv, XGMAC_TX_SENDAPPBADPKTS);\n\thw_stats->rx_1731_pkts = hns_mac_reg_read64(drv, XGMAC_RX_1731PKTS);\n\thw_stats->rx_symbol_err\n\t\t= hns_mac_reg_read64(drv, XGMAC_RX_SYMBOLERRPKTS);\n\thw_stats->rx_fcs_err = hns_mac_reg_read64(drv, XGMAC_RX_FCSERRPKTS);\n}\n\n/**\n *hns_xgmac_free - free xgmac driver\n *@mac_drv: mac driver\n */\nstatic void hns_xgmac_free(void *mac_drv)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct dsaf_device *dsaf_dev\n\t\t= (struct dsaf_device *)dev_get_drvdata(drv->dev);\n\n\tu32 mac_id = drv->mac_id;\n\n\tdsaf_dev->misc_op->xge_srst(dsaf_dev, mac_id, 0);\n}\n\n/**\n *hns_xgmac_get_info - get xgmac information\n *@mac_drv: mac driver\n *@mac_info:mac information\n */\nstatic void hns_xgmac_get_info(void *mac_drv, struct mac_info *mac_info)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 pause_time, pause_ctrl, port_mode, ctrl_val;\n\n\tctrl_val = dsaf_read_dev(drv, XGMAC_MAC_CONTROL_REG);\n\tmac_info->pad_and_crc_en = dsaf_get_bit(ctrl_val, XGMAC_CTL_TX_PAD_B);\n\tmac_info->auto_neg = 0;\n\n\tpause_time = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_TIME_REG);\n\tmac_info->tx_pause_time = pause_time;\n\n\tport_mode = dsaf_read_dev(drv, XGMAC_PORT_MODE_REG);\n\tmac_info->port_en = dsaf_get_field(port_mode, XGMAC_PORT_MODE_TX_M,\n\t\t\t\t\t   XGMAC_PORT_MODE_TX_S) &&\n\t\t\t\tdsaf_get_field(port_mode, XGMAC_PORT_MODE_RX_M,\n\t\t\t\t\t       XGMAC_PORT_MODE_RX_S);\n\tmac_info->duplex = 1;\n\tmac_info->speed = MAC_SPEED_10000;\n\n\tpause_ctrl = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG);\n\tmac_info->rx_pause_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_RX_B);\n\tmac_info->tx_pause_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_TX_B);\n}\n\n/**\n *hns_xgmac_get_pausefrm_cfg - get xgmac pause param\n *@mac_drv: mac driver\n *@rx_en:xgmac rx pause enable\n *@tx_en:xgmac tx pause enable\n */\nstatic void hns_xgmac_get_pausefrm_cfg(void *mac_drv, u32 *rx_en, u32 *tx_en)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 pause_ctrl;\n\n\tpause_ctrl = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG);\n\t*rx_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_RX_B);\n\t*tx_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_TX_B);\n}\n\n/**\n *hns_xgmac_get_link_status - get xgmac link status\n *@mac_drv: mac driver\n *@link_stat: xgmac link stat\n */\nstatic void hns_xgmac_get_link_status(void *mac_drv, u32 *link_stat)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*link_stat = dsaf_read_dev(drv, XGMAC_LINK_STATUS_REG);\n}\n\n/**\n *hns_xgmac_get_regs - dump xgmac regs\n *@mac_drv: mac driver\n *@cmd:ethtool cmd\n *@data:data for value of regs\n */\nstatic void hns_xgmac_get_regs(void *mac_drv, void *data)\n{\n\tu32 i = 0;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 *regs = data;\n\tu64 qtmp;\n\n\t/* base config registers */\n\tregs[0] = dsaf_read_dev(drv, XGMAC_INT_STATUS_REG);\n\tregs[1] = dsaf_read_dev(drv, XGMAC_INT_ENABLE_REG);\n\tregs[2] = dsaf_read_dev(drv, XGMAC_INT_SET_REG);\n\tregs[3] = dsaf_read_dev(drv, XGMAC_IERR_U_INFO_REG);\n\tregs[4] = dsaf_read_dev(drv, XGMAC_OVF_INFO_REG);\n\tregs[5] = dsaf_read_dev(drv, XGMAC_OVF_CNT_REG);\n\tregs[6] = dsaf_read_dev(drv, XGMAC_PORT_MODE_REG);\n\tregs[7] = dsaf_read_dev(drv, XGMAC_CLK_ENABLE_REG);\n\tregs[8] = dsaf_read_dev(drv, XGMAC_RESET_REG);\n\tregs[9] = dsaf_read_dev(drv, XGMAC_LINK_CONTROL_REG);\n\tregs[10] = dsaf_read_dev(drv, XGMAC_LINK_STATUS_REG);\n\n\tregs[11] = dsaf_read_dev(drv, XGMAC_SPARE_REG);\n\tregs[12] = dsaf_read_dev(drv, XGMAC_SPARE_CNT_REG);\n\tregs[13] = dsaf_read_dev(drv, XGMAC_MAC_ENABLE_REG);\n\tregs[14] = dsaf_read_dev(drv, XGMAC_MAC_CONTROL_REG);\n\tregs[15] = dsaf_read_dev(drv, XGMAC_MAC_IPG_REG);\n\tregs[16] = dsaf_read_dev(drv, XGMAC_MAC_MSG_CRC_EN_REG);\n\tregs[17] = dsaf_read_dev(drv, XGMAC_MAC_MSG_IMG_REG);\n\tregs[18] = dsaf_read_dev(drv, XGMAC_MAC_MSG_FC_CFG_REG);\n\tregs[19] = dsaf_read_dev(drv, XGMAC_MAC_MSG_TC_CFG_REG);\n\tregs[20] = dsaf_read_dev(drv, XGMAC_MAC_PAD_SIZE_REG);\n\tregs[21] = dsaf_read_dev(drv, XGMAC_MAC_MIN_PKT_SIZE_REG);\n\tregs[22] = dsaf_read_dev(drv, XGMAC_MAC_MAX_PKT_SIZE_REG);\n\tregs[23] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG);\n\tregs[24] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_TIME_REG);\n\tregs[25] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_GAP_REG);\n\tregs[26] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_LOCAL_MAC_H_REG);\n\tregs[27] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_LOCAL_MAC_L_REG);\n\tregs[28] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_PEER_MAC_H_REG);\n\tregs[29] = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_PEER_MAC_L_REG);\n\tregs[30] = dsaf_read_dev(drv, XGMAC_MAC_PFC_PRI_EN_REG);\n\tregs[31] = dsaf_read_dev(drv, XGMAC_MAC_1588_CTRL_REG);\n\tregs[32] = dsaf_read_dev(drv, XGMAC_MAC_1588_TX_PORT_DLY_REG);\n\tregs[33] = dsaf_read_dev(drv, XGMAC_MAC_1588_RX_PORT_DLY_REG);\n\tregs[34] = dsaf_read_dev(drv, XGMAC_MAC_1588_ASYM_DLY_REG);\n\tregs[35] = dsaf_read_dev(drv, XGMAC_MAC_1588_ADJUST_CFG_REG);\n\n\tregs[36] = dsaf_read_dev(drv, XGMAC_MAC_Y1731_ETH_TYPE_REG);\n\tregs[37] = dsaf_read_dev(drv, XGMAC_MAC_MIB_CONTROL_REG);\n\tregs[38] = dsaf_read_dev(drv, XGMAC_MAC_WAN_RATE_ADJUST_REG);\n\tregs[39] = dsaf_read_dev(drv, XGMAC_MAC_TX_ERR_MARK_REG);\n\tregs[40] = dsaf_read_dev(drv, XGMAC_MAC_TX_LF_RF_CONTROL_REG);\n\tregs[41] = dsaf_read_dev(drv, XGMAC_MAC_RX_LF_RF_STATUS_REG);\n\tregs[42] = dsaf_read_dev(drv, XGMAC_MAC_TX_RUNT_PKT_CNT_REG);\n\tregs[43] = dsaf_read_dev(drv, XGMAC_MAC_RX_RUNT_PKT_CNT_REG);\n\tregs[44] = dsaf_read_dev(drv, XGMAC_MAC_RX_PREAM_ERR_PKT_CNT_REG);\n\tregs[45] = dsaf_read_dev(drv, XGMAC_MAC_TX_LF_RF_TERM_PKT_CNT_REG);\n\tregs[46] = dsaf_read_dev(drv, XGMAC_MAC_TX_SN_MISMATCH_PKT_CNT_REG);\n\tregs[47] = dsaf_read_dev(drv, XGMAC_MAC_RX_ERR_MSG_CNT_REG);\n\tregs[48] = dsaf_read_dev(drv, XGMAC_MAC_RX_ERR_EFD_CNT_REG);\n\tregs[49] = dsaf_read_dev(drv, XGMAC_MAC_ERR_INFO_REG);\n\tregs[50] = dsaf_read_dev(drv, XGMAC_MAC_DBG_INFO_REG);\n\n\tregs[51] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SYNC_THD_REG);\n\tregs[52] = dsaf_read_dev(drv, XGMAC_PCS_STATUS1_REG);\n\tregs[53] = dsaf_read_dev(drv, XGMAC_PCS_BASER_STATUS1_REG);\n\tregs[54] = dsaf_read_dev(drv, XGMAC_PCS_BASER_STATUS2_REG);\n\tregs[55] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SEEDA_0_REG);\n\tregs[56] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SEEDA_1_REG);\n\tregs[57] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SEEDB_0_REG);\n\tregs[58] = dsaf_read_dev(drv, XGMAC_PCS_BASER_SEEDB_1_REG);\n\tregs[59] = dsaf_read_dev(drv, XGMAC_PCS_BASER_TEST_CONTROL_REG);\n\tregs[60] = dsaf_read_dev(drv, XGMAC_PCS_BASER_TEST_ERR_CNT_REG);\n\tregs[61] = dsaf_read_dev(drv, XGMAC_PCS_DBG_INFO_REG);\n\tregs[62] = dsaf_read_dev(drv, XGMAC_PCS_DBG_INFO1_REG);\n\tregs[63] = dsaf_read_dev(drv, XGMAC_PCS_DBG_INFO2_REG);\n\tregs[64] = dsaf_read_dev(drv, XGMAC_PCS_DBG_INFO3_REG);\n\n\tregs[65] = dsaf_read_dev(drv, XGMAC_PMA_ENABLE_REG);\n\tregs[66] = dsaf_read_dev(drv, XGMAC_PMA_CONTROL_REG);\n\tregs[67] = dsaf_read_dev(drv, XGMAC_PMA_SIGNAL_STATUS_REG);\n\tregs[68] = dsaf_read_dev(drv, XGMAC_PMA_DBG_INFO_REG);\n\tregs[69] = dsaf_read_dev(drv, XGMAC_PMA_FEC_ABILITY_REG);\n\tregs[70] = dsaf_read_dev(drv, XGMAC_PMA_FEC_CONTROL_REG);\n\tregs[71] = dsaf_read_dev(drv, XGMAC_PMA_FEC_CORR_BLOCK_CNT__REG);\n\tregs[72] = dsaf_read_dev(drv, XGMAC_PMA_FEC_UNCORR_BLOCK_CNT__REG);\n\n\t/* status registers */\n#define hns_xgmac_cpy_q(p, q) \\\n\tdo {\\\n\t\t*(p) = (u32)(q);\\\n\t\t*((p) + 1) = (u32)((q) >> 32);\\\n\t} while (0)\n\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_FRAGMENT);\n\thns_xgmac_cpy_q(&regs[73], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_UNDERSIZE);\n\thns_xgmac_cpy_q(&regs[75], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_UNDERMIN);\n\thns_xgmac_cpy_q(&regs[77], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_64OCTETS);\n\thns_xgmac_cpy_q(&regs[79], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_65TO127OCTETS);\n\thns_xgmac_cpy_q(&regs[81], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_128TO255OCTETS);\n\thns_xgmac_cpy_q(&regs[83], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_256TO511OCTETS);\n\thns_xgmac_cpy_q(&regs[85], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_512TO1023OCTETS);\n\thns_xgmac_cpy_q(&regs[87], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1024TO1518OCTETS);\n\thns_xgmac_cpy_q(&regs[89], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1519TOMAXOCTETS);\n\thns_xgmac_cpy_q(&regs[91], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_1519TOMAXOCTETSOK);\n\thns_xgmac_cpy_q(&regs[93], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_OVERSIZE);\n\thns_xgmac_cpy_q(&regs[95], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PKTS_JABBER);\n\thns_xgmac_cpy_q(&regs[97], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_GOODPKTS);\n\thns_xgmac_cpy_q(&regs[99], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_GOODOCTETS);\n\thns_xgmac_cpy_q(&regs[101], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_TOTAL_PKTS);\n\thns_xgmac_cpy_q(&regs[103], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_TOTALOCTETS);\n\thns_xgmac_cpy_q(&regs[105], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_UNICASTPKTS);\n\thns_xgmac_cpy_q(&regs[107], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_MULTICASTPKTS);\n\thns_xgmac_cpy_q(&regs[109], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_BROADCASTPKTS);\n\thns_xgmac_cpy_q(&regs[111], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI0PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[113], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI1PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[115], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI2PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[117], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI3PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[119], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI4PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[121], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI5PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[123], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI6PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[125], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_PRI7PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[127], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_MACCTRLPKTS);\n\thns_xgmac_cpy_q(&regs[129], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_1731PKTS);\n\thns_xgmac_cpy_q(&regs[131], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_1588PKTS);\n\thns_xgmac_cpy_q(&regs[133], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_FROMAPPGOODPKTS);\n\thns_xgmac_cpy_q(&regs[135], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_FROMAPPBADPKTS);\n\thns_xgmac_cpy_q(&regs[137], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_ERRALLPKTS);\n\thns_xgmac_cpy_q(&regs[139], qtmp);\n\n\t/* RX */\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_FRAGMENT);\n\thns_xgmac_cpy_q(&regs[141], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTSUNDERSIZE);\n\thns_xgmac_cpy_q(&regs[143], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_UNDERMIN);\n\thns_xgmac_cpy_q(&regs[145], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_64OCTETS);\n\thns_xgmac_cpy_q(&regs[147], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_65TO127OCTETS);\n\thns_xgmac_cpy_q(&regs[149], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_128TO255OCTETS);\n\thns_xgmac_cpy_q(&regs[151], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_256TO511OCTETS);\n\thns_xgmac_cpy_q(&regs[153], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_512TO1023OCTETS);\n\thns_xgmac_cpy_q(&regs[155], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1024TO1518OCTETS);\n\thns_xgmac_cpy_q(&regs[157], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1519TOMAXOCTETS);\n\thns_xgmac_cpy_q(&regs[159], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_1519TOMAXOCTETSOK);\n\thns_xgmac_cpy_q(&regs[161], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_OVERSIZE);\n\thns_xgmac_cpy_q(&regs[163], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PKTS_JABBER);\n\thns_xgmac_cpy_q(&regs[165], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_GOODPKTS);\n\thns_xgmac_cpy_q(&regs[167], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_GOODOCTETS);\n\thns_xgmac_cpy_q(&regs[169], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_TOTAL_PKTS);\n\thns_xgmac_cpy_q(&regs[171], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_TOTALOCTETS);\n\thns_xgmac_cpy_q(&regs[173], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_UNICASTPKTS);\n\thns_xgmac_cpy_q(&regs[175], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_MULTICASTPKTS);\n\thns_xgmac_cpy_q(&regs[177], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_BROADCASTPKTS);\n\thns_xgmac_cpy_q(&regs[179], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI0PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[181], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI1PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[183], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI2PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[185], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI3PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[187], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI4PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[189], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI5PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[191], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI6PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[193], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_PRI7PAUSEPKTS);\n\thns_xgmac_cpy_q(&regs[195], qtmp);\n\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_MACCTRLPKTS);\n\thns_xgmac_cpy_q(&regs[197], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_SENDAPPGOODPKTS);\n\thns_xgmac_cpy_q(&regs[199], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_TX_SENDAPPBADPKTS);\n\thns_xgmac_cpy_q(&regs[201], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_1731PKTS);\n\thns_xgmac_cpy_q(&regs[203], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_SYMBOLERRPKTS);\n\thns_xgmac_cpy_q(&regs[205], qtmp);\n\tqtmp = hns_mac_reg_read64(drv, XGMAC_RX_FCSERRPKTS);\n\thns_xgmac_cpy_q(&regs[207], qtmp);\n\n\t/* mark end of mac regs */\n\tfor (i = 208; i < 214; i++)\n\t\tregs[i] = 0xaaaaaaaa;\n}\n\n/**\n *hns_xgmac_get_stats - get xgmac statistic\n *@mac_drv: mac driver\n *@data:data for value of stats regs\n */\nstatic void hns_xgmac_get_stats(void *mac_drv, u64 *data)\n{\n\tu32 i;\n\tu64 *buf = data;\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tstruct mac_hw_stats *hw_stats = NULL;\n\n\thw_stats = &drv->mac_cb->hw_stats;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_xgmac_stats_string); i++) {\n\t\tbuf[i] = DSAF_STATS_READ(hw_stats,\n\t\t\tg_xgmac_stats_string[i].offset);\n\t}\n}\n\n/**\n *hns_xgmac_get_strings - get xgmac strings name\n *@stringset: type of values in data\n *@data:data for value of string name\n */\nstatic void hns_xgmac_get_strings(u32 stringset, u8 *data)\n{\n\tchar *buff = (char *)data;\n\tu32 i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_xgmac_stats_string); i++) {\n\t\tsnprintf(buff, ETH_GSTRING_LEN, g_xgmac_stats_string[i].desc);\n\t\tbuff = buff + ETH_GSTRING_LEN;\n\t}\n}\n\n/**\n *hns_xgmac_get_sset_count - get xgmac string set count\n *@stringset: type of values in data\n *return xgmac string set count\n */\nstatic int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}\n\n/**\n *hns_xgmac_get_regs_count - get xgmac regs count\n *return xgmac regs count\n */\nstatic int hns_xgmac_get_regs_count(void)\n{\n\treturn HNS_XGMAC_DUMP_NUM;\n}\n\nvoid *hns_xgmac_config(struct hns_mac_cb *mac_cb, struct mac_params *mac_param)\n{\n\tstruct mac_driver *mac_drv;\n\n\tmac_drv = devm_kzalloc(mac_cb->dev, sizeof(*mac_drv), GFP_KERNEL);\n\tif (!mac_drv)\n\t\treturn NULL;\n\n\tmac_drv->mac_init = hns_xgmac_init;\n\tmac_drv->mac_enable = hns_xgmac_enable;\n\tmac_drv->mac_disable = hns_xgmac_disable;\n\n\tmac_drv->mac_id = mac_param->mac_id;\n\tmac_drv->mac_mode = mac_param->mac_mode;\n\tmac_drv->io_base = mac_param->vaddr;\n\tmac_drv->dev = mac_param->dev;\n\tmac_drv->mac_cb = mac_cb;\n\n\tmac_drv->set_mac_addr = hns_xgmac_set_pausefrm_mac_addr;\n\tmac_drv->set_an_mode = NULL;\n\tmac_drv->config_loopback = NULL;\n\tmac_drv->config_pad_and_crc = hns_xgmac_config_pad_and_crc;\n\tmac_drv->config_half_duplex = NULL;\n\tmac_drv->set_rx_ignore_pause_frames =\n\t\thns_xgmac_set_rx_ignore_pause_frames;\n\tmac_drv->mac_free = hns_xgmac_free;\n\tmac_drv->adjust_link = NULL;\n\tmac_drv->set_tx_auto_pause_frames = hns_xgmac_set_tx_auto_pause_frames;\n\tmac_drv->config_max_frame_length = hns_xgmac_config_max_frame_length;\n\tmac_drv->mac_pausefrm_cfg = hns_xgmac_pausefrm_cfg;\n\tmac_drv->autoneg_stat = NULL;\n\tmac_drv->get_info = hns_xgmac_get_info;\n\tmac_drv->get_pause_enable = hns_xgmac_get_pausefrm_cfg;\n\tmac_drv->get_link_status = hns_xgmac_get_link_status;\n\tmac_drv->get_regs = hns_xgmac_get_regs;\n\tmac_drv->get_ethtool_stats = hns_xgmac_get_stats;\n\tmac_drv->get_sset_count = hns_xgmac_get_sset_count;\n\tmac_drv->get_regs_count = hns_xgmac_get_regs_count;\n\tmac_drv->get_strings = hns_xgmac_get_strings;\n\tmac_drv->update_stats = hns_xgmac_update_stats;\n\n\treturn (void *)mac_drv;\n}\n"], "filenames": ["drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c", "drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c", "drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c", "drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c"], "buggy_code_start_loc": [669, 425, 879, 784], "buggy_code_end_loc": [670, 426, 880, 785], "fixing_code_start_loc": [669, 425, 879, 784], "fixing_code_end_loc": [670, 426, 880, 785], "type": "CWE-119", "message": "In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings.", "other": {"cve": {"id": "CVE-2017-18222", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-08T14:29:00.223", "lastModified": "2018-05-24T01:29:01.003", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings."}, {"lang": "es", "value": "En el kernel de Linux en versiones anteriores a la 4.12, Hisilicon Network Subsystem (HNS) no considera el caso ETH_SS_PRIV_FLAGS a la hora de recuperar los datos de sset_count, lo que permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer y corrupci\u00f3n de memoria) o, posiblemente, otro impacto no especificado, tal y como ha quedado demostrado por la incompatibilidad entre hns_get_sset_count y ethtool_get_strings."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.12", "matchCriteriaId": "D9BBDA7A-EA95-41C5-8F4C-CA458BCB7E1F"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=412b65d15a7f8a93794653968308fc100f2aa87c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/103349", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3654-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3654-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3656-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4188", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c"}}