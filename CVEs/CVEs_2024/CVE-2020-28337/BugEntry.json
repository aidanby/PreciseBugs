{"buggy_code": ["<?php\n\nnamespace MicroweberPackages\\Utils\\Zip;\n\n/**\n * UnZip Class.\n *\n * This class is based on a library I found at PHPClasses:\n * http://phpclasses.org/package/2495-PHP-Pack-and-unpack-files-packed-in-ZIP-archives.html\n *\n * The original library is a little rough around the edges so I\n * refactored it and added several additional methods -- Phil Sturgeon\n *\n * This class requires extension ZLib Enabled.\n *\n * @author        Alexandre Tedeschi\n * @author        Phil Sturgeon\n *\n * @link        http://bitbucket.org/philsturgeon/codeigniter-unzip\n *\n * @license        http://www.gnu.org/licenses/lgpl.html\n *\n * @version     1.0.0\n */\nclass Unzip\n{\n    private $compressed_list = array();\n    // List of files in the ZIP\n    private $central_dir_list = array();\n    // Central dir list... It's a kind of 'extra attributes' for a set of files\n    private $end_of_central = array();\n    // End of central dir, contains ZIP Comments\n    private $info = array();\n    private $error = array();\n    private $_zip_file = '';\n    private $_target_dir = false;\n    private $apply_chmod = 0755;\n    private $fh;\n    private $zip_signature = \"\\x50\\x4b\\x03\\x04\";\n    // local file header signature\n    private $dir_signature = \"\\x50\\x4b\\x01\\x02\";\n    // central dir header signature\n    private $central_signature_end = \"\\x50\\x4b\\x05\\x06\";\n    // ignore these directories (useless meta data)\n    private $_skip_dirs = array('__MACOSX');\n    // Rename target files with underscore case\n    private $underscore_case = true;\n    private $_allow_extensions = null;\n\n    // What is allowed out of the zip\n    // --------------------------------------------------------------------\n\n    /**\n     * Constructor.\n     *\n     * @param     string\n     *\n     * @return none\n     */\n    public function __construct()\n    {\n    }\n\n    /**\n     * Unzip all files in archive.\n     *\n     * @param     none\n     *\n     * @return    none\n     */\n    public function extract($zip_file, $target_dir = null, $preserve_filepath = true)\n    {\n        $this->_zip_file = $zip_file;\n        $this->_target_dir = $target_dir ? $target_dir : dirname($this->_zip_file);\n\n        if (function_exists('zip_open')) {\n\n            $is_any = $this->native_unzip($zip_file, $target_dir, $preserve_filepath);\n\n            if (!empty($is_any)) {\n                return $is_any;\n            }\n\n        } else if (function_exists('gzinflate')) {\n            if (!$files = $this->_list_files()) {\n                $this->set_error('ZIP folder was empty.');\n\n                return false;\n            }\n\n            $file_locations = array();\n            foreach ($files as $file => $trash) {\n                $dirname = pathinfo($file, PATHINFO_DIRNAME);\n                $extension = (pathinfo($file, PATHINFO_EXTENSION));\n\n                $folders = explode('/', $dirname);\n                $out_dn = $this->_target_dir . '/' . $dirname;\n                $out_dn = str_replace('\\/', DS, $out_dn);\n                // Skip stuff in stupid folders\n                if (in_array(current($folders), $this->_skip_dirs)) {\n                    continue;\n                }\n\n                // Skip any files that are not allowed\n                if (is_array($this->_allow_extensions) && $extension && !in_array($extension, $this->_allow_extensions)) {\n                    continue;\n                }\n\n                if (!is_dir($out_dn) && $preserve_filepath) {\n                    $str = '';\n                    foreach ($folders as $folder) {\n                        $str = $str ? $str . '/' . $folder : $folder;\n                        if (!is_dir($this->_target_dir . '/' . $str)) {\n                            $this->set_debug('Creating folder: ' . $this->_target_dir . '/' . $str);\n\n                            if (!@mkdir_recursive($this->_target_dir . '/' . $str)) {\n                                $this->set_error('Desitnation path is not writable.');\n\n                                return false;\n                            }\n\n                            // Apply chmod if configured to do so\n                            $this->apply_chmod && chmod($this->_target_dir . '/' . $str, $this->apply_chmod);\n                        }\n                    }\n                }\n\n                if (substr($file, -1, 1) == '/') {\n                    continue;\n                }\n\n                $file_locations[] = $file_location = $this->_target_dir . '/' . ($preserve_filepath ? $file : basename($file));\n\n                $this->_extract_file($file, $file_location, $this->underscore_case);\n                // Skip stuff in stupid folders\n                if (in_array(current($folders), $this->_skip_dirs)) {\n                    continue;\n                }\n\n                // Skip any files that are not allowed\n                if (is_array($this->_allow_extensions) && $extension && !in_array($extension, $this->_allow_extensions)) {\n                    continue;\n                }\n\n                if (!is_dir($out_dn) && $preserve_filepath) {\n                    $str = '';\n                    foreach ($folders as $folder) {\n                        $str = $str ? $str . '/' . $folder : $folder;\n                        if (!is_dir($this->_target_dir . '/' . $str)) {\n                            $this->set_debug('Creating folder: ' . $this->_target_dir . '/' . $str);\n\n                            if (!@mkdir_recursive($this->_target_dir . '/' . $str)) {\n                                $this->set_error('Desitnation path is not writable.');\n                                $resp = array('error' => 'Error with the unzip! Desitnation path is not writable.');\n\n                                return $resp;\n\n                                return false;\n                            }\n\n                            // Apply chmod if configured to do so\n                            $this->apply_chmod && chmod($this->_target_dir . '/' . $str, $this->apply_chmod);\n                        }\n                    }\n                }\n\n                if (substr($file, -1, 1) == '/') {\n                    continue;\n                }\n\n                $file_locations[] = $file_location = $this->_target_dir . '/' . ($preserve_filepath ? $file : basename($file));\n\n                $this->_extract_file($file, $file_location, $this->underscore_case);\n            }\n\n            return $file_locations;\n        }\n\n        $resp = array('error' => 'There was an error with the unzip');\n\n        return $resp;\n    }\n\n\n    public function native_unzip($zip_file, $target_dir = null, $preserve_filepath = true)\n    {\n        $file_locations = array();\n        if (function_exists('zip_open')) {\n            $filename = $zip_file;\n\n            try {\n                if (!is_dir($target_dir)) {\n                    @mkdir_recursive($target_dir);\n                }\n            } catch (\\ErrorException $e) {\n\n            }\n\n\n            // get all dirs and make them because of error: is_dir(): open_basedir restriction in effect.\n            $dirs_tree = array();\n            $archive = zip_open($filename);\n            while ($entry = zip_read($archive)) {\n                $name = zip_entry_name($entry);\n                $name = dirname($name);\n                $is_dir_there = $target_dir . $name;\n\n                if ($name != '.') {\n                    $dirs_tree[] = $is_dir_there;\n\n                }\n\n            }\n            $dirs_tree = array_unique($dirs_tree);\n\n            foreach ($dirs_tree as $item) {\n                try {\n                    if (!is_dir($item)) {\n                        @mkdir_recursive($item);\n                    }\n                } catch (\\ErrorException $e) {\n                // error: is_dir(): open_basedir restriction in effect.\n                }\n            }\n\n            zip_close($archive);\n\n\n            // open for extract\n            $archive = zip_open($filename);\n\n            if (is_resource($archive)) {\n                if (function_exists('set_time_limit')) {\n                    @set_time_limit(600);\n                }\n\n                while ($entry = zip_read($archive)) {\n                    $size = zip_entry_filesize($entry);\n                    $name = zip_entry_name($entry);\n                    $target_file_to_save = normalize_path($target_dir . $name, false);\n                    $target_file_to_save_dir = dirname($target_file_to_save);\n                    if(!is_dir($target_file_to_save_dir)){\n                        mkdir_recursive($target_file_to_save_dir);\n                    }\n//\n                   //  var_dump($entry);\n//                    var_dump($name);\n//                    var_dump($target_file_to_save);\n//                    echo '________________' . PHP_EOL;\n//                    continue;\n\n                    $unzipped = @fopen($target_file_to_save, 'wb');\n                    while ($size > 0) {\n                        $chunkSize = ($size > 10240) ? 10240 : $size;\n                        $size -= $chunkSize;\n                        $chunk = zip_entry_read($entry, $chunkSize);\n                        if ($chunk !== false) {\n                            @fwrite($unzipped, $chunk);\n                            $file_locations[] = $target_file_to_save;\n                        }\n                    }\n                    @fclose($unzipped);\n                }\n                zip_close($archive);\n            }\n\n            return $file_locations;\n        }\n\n        return $file_locations;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * List all files in archive.\n     *\n     * @param     bool\n     *\n     * @return mixed\n     */\n    private function _list_files($stop_on_file = false)\n    {\n        if (sizeof($this->compressed_list)) {\n            $this->set_debug('Returning already loaded file list.');\n\n            return $this->compressed_list;\n        }\n\n        // Open file, and set file handler\n        $fh = fopen($this->_zip_file, 'r');\n        $this->fh = &$fh;\n\n        if (!$fh) {\n            $this->set_error('Failed to load file: ' . $this->_zip_file);\n\n            return false;\n        }\n\n        $this->set_debug('Loading list from \"End of Central Dir\" index list...');\n\n        if (!$this->_load_file_list_by_eof($fh, $stop_on_file)) {\n            $this->set_debug('Failed! Trying to load list looking for signatures...');\n\n            if (!$this->_load_files_by_signatures($fh, $stop_on_file)) {\n                $this->set_debug('Failed! Could not find any valid header.');\n                $this->set_error('ZIP File is corrupted or empty');\n\n                return false;\n            }\n        }\n\n        return $this->compressed_list;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Save debug data.\n     *\n     * @param    string\n     *\n     * @return none\n     */\n    public function set_debug($string)\n    {\n        $this->info[] = $string;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Save errors.\n     *\n     * @param    string\n     *\n     * @return none\n     */\n    public function set_error($string)\n    {\n        $this->error[] = $string;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _load_file_list_by_eof(&$fh, $stop_on_file = false)\n    {\n        // Check if there's a valid Central Dir signature.\n        // Let's consider a file comment smaller than 1024 characters...\n        // Actually, it length can be 65536.. But we're not going to support it.\n\n        for ($x = 0; $x < 1024; ++$x) {\n            fseek($fh, -22 - $x, SEEK_END);\n\n            $signature = fread($fh, 4);\n\n            if ($signature == $this->central_signature_end) {\n                // If found EOF Central Dir\n                $eodir['disk_number_this'] = unpack('v', fread($fh, 2));\n                // number of this disk\n                $eodir['disk_number'] = unpack('v', fread($fh, 2));\n                // number of the disk with the start of the central directory\n                $eodir['total_entries_this'] = unpack('v', fread($fh, 2));\n                // total number of entries in the central dir on this disk\n                $eodir['total_entries'] = unpack('v', fread($fh, 2));\n                // total number of entries in\n                $eodir['size_of_cd'] = unpack('V', fread($fh, 4));\n                // size of the central directory\n                $eodir['offset_start_cd'] = unpack('V', fread($fh, 4));\n                // offset of start of central directory with respect to the starting disk number\n                $zip_comment_lenght = unpack('v', fread($fh, 2));\n                // zipfile comment length\n                $eodir['zipfile_comment'] = $zip_comment_lenght[1] ? fread($fh, $zip_comment_lenght[1]) : '';\n                // zipfile comment\n\n                $this->end_of_central = array('disk_number_this' => $eodir['disk_number_this'][1], 'disk_number' => $eodir['disk_number'][1], 'total_entries_this' => $eodir['total_entries_this'][1], 'total_entries' => $eodir['total_entries'][1], 'size_of_cd' => $eodir['size_of_cd'][1], 'offset_start_cd' => $eodir['offset_start_cd'][1], 'zipfile_comment' => $eodir['zipfile_comment']);\n\n                // Then, load file list\n                fseek($fh, $this->end_of_central['offset_start_cd']);\n                $signature = fread($fh, 4);\n\n                while ($signature == $this->dir_signature) {\n                    $dir['version_madeby'] = unpack('v', fread($fh, 2));\n                    // version made by\n                    $dir['version_needed'] = unpack('v', fread($fh, 2));\n                    // version needed to extract\n                    $dir['general_bit_flag'] = unpack('v', fread($fh, 2));\n                    // general purpose bit flag\n                    $dir['compression_method'] = unpack('v', fread($fh, 2));\n                    // compression method\n                    $dir['lastmod_time'] = unpack('v', fread($fh, 2));\n                    // last mod file time\n                    $dir['lastmod_date'] = unpack('v', fread($fh, 2));\n                    // last mod file date\n                    $dir['crc-32'] = fread($fh, 4);\n                    // crc-32\n                    $dir['compressed_size'] = unpack('V', fread($fh, 4));\n                    // compressed size\n                    $dir['uncompressed_size'] = unpack('V', fread($fh, 4));\n                    // uncompressed size\n                    $zip_file_length = unpack('v', fread($fh, 2));\n                    // filename length\n                    $extra_field_length = unpack('v', fread($fh, 2));\n                    // extra field length\n                    $fileCommentLength = unpack('v', fread($fh, 2));\n                    // file comment length\n                    $dir['disk_number_start'] = unpack('v', fread($fh, 2));\n                    // disk number start\n                    $dir['internal_attributes'] = unpack('v', fread($fh, 2));\n                    // internal file attributes-byte1\n                    $dir['external_attributes1'] = unpack('v', fread($fh, 2));\n                    // external file attributes-byte2\n                    $dir['external_attributes2'] = unpack('v', fread($fh, 2));\n                    // external file attributes\n                    $dir['relative_offset'] = unpack('V', fread($fh, 4));\n                    // relative offset of local header\n                    $dir['file_name'] = fread($fh, $zip_file_length[1]);\n                    // filename\n                    $dir['extra_field'] = $extra_field_length[1] ? fread($fh, $extra_field_length[1]) : '';\n                    // extra field\n                    $dir['file_comment'] = $fileCommentLength[1] ? fread($fh, $fileCommentLength[1]) : '';\n                    // file comment\n                    // Convert the date and time, from MS-DOS format to UNIX Timestamp\n                    $binary_mod_date = str_pad(decbin($dir['lastmod_date'][1]), 16, '0', STR_PAD_LEFT);\n                    $binary_mod_time = str_pad(decbin($dir['lastmod_time'][1]), 16, '0', STR_PAD_LEFT);\n                    $last_mod_year = bindec(substr($binary_mod_date, 0, 7)) + 1980;\n                    $last_mod_month = bindec(substr($binary_mod_date, 7, 4));\n                    $last_mod_day = bindec(substr($binary_mod_date, 11, 5));\n                    $last_mod_hour = bindec(substr($binary_mod_time, 0, 5));\n                    $last_mod_minute = bindec(substr($binary_mod_time, 5, 6));\n                    $last_mod_second = bindec(substr($binary_mod_time, 11, 5));\n\n                    $this->central_dir_list[$dir['file_name']] = array('version_madeby' => $dir['version_madeby'][1], 'version_needed' => $dir['version_needed'][1], 'general_bit_flag' => str_pad(decbin($dir['general_bit_flag'][1]), 8, '0', STR_PAD_LEFT), 'compression_method' => $dir['compression_method'][1], 'lastmod_datetime' => mktime($last_mod_hour, $last_mod_minute, $last_mod_second, $last_mod_month, $last_mod_day, $last_mod_year), 'crc-32' => str_pad(dechex(ord($dir['crc-32'][3])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][2])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][1])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][0])), 2, '0', STR_PAD_LEFT), 'compressed_size' => $dir['compressed_size'][1], 'uncompressed_size' => $dir['uncompressed_size'][1], 'disk_number_start' => $dir['disk_number_start'][1], 'internal_attributes' => $dir['internal_attributes'][1], 'external_attributes1' => $dir['external_attributes1'][1], 'external_attributes2' => $dir['external_attributes2'][1], 'relative_offset' => $dir['relative_offset'][1], 'file_name' => $dir['file_name'], 'extra_field' => $dir['extra_field'], 'file_comment' => $dir['file_comment']);\n\n                    $signature = fread($fh, 4);\n                }\n\n                // If loaded centralDirs, then try to identify the offsetPosition of the compressed data.\n                if ($this->central_dir_list) {\n                    foreach ($this->central_dir_list as $filename => $details) {\n                        $i = $this->_get_file_header($fh, $details['relative_offset']);\n                        $this->compressed_list[$filename]['file_name'] = $filename;\n                        $this->compressed_list[$filename]['compression_method'] = $details['compression_method'];\n                        $this->compressed_list[$filename]['version_needed'] = $details['version_needed'];\n                        $this->compressed_list[$filename]['lastmod_datetime'] = $details['lastmod_datetime'];\n                        $this->compressed_list[$filename]['crc-32'] = $details['crc-32'];\n                        $this->compressed_list[$filename]['compressed_size'] = $details['compressed_size'];\n                        $this->compressed_list[$filename]['uncompressed_size'] = $details['uncompressed_size'];\n                        $this->compressed_list[$filename]['lastmod_datetime'] = $details['lastmod_datetime'];\n                        $this->compressed_list[$filename]['extra_field'] = $i['extra_field'];\n                        $this->compressed_list[$filename]['contents_start_offset'] = $i['contents_start_offset'];\n\n                        if (strtolower($stop_on_file) == strtolower($filename)) {\n                            break;\n                        }\n                    }\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _get_file_header(&$fh, $start_offset = false)\n    {\n        if ($start_offset !== false) {\n            fseek($fh, $start_offset);\n        }\n\n        $signature = fread($fh, 4);\n\n        if ($signature == $this->zip_signature) {\n            // Get information about the zipped file\n            $file['version_needed'] = unpack('v', fread($fh, 2));\n            // version needed to extract\n            $file['general_bit_flag'] = unpack('v', fread($fh, 2));\n            // general purpose bit flag\n            $file['compression_method'] = unpack('v', fread($fh, 2));\n            // compression method\n            $file['lastmod_time'] = unpack('v', fread($fh, 2));\n            // last mod file time\n            $file['lastmod_date'] = unpack('v', fread($fh, 2));\n            // last mod file date\n            $file['crc-32'] = fread($fh, 4);\n            // crc-32\n            $file['compressed_size'] = unpack('V', fread($fh, 4));\n            // compressed size\n            $file['uncompressed_size'] = unpack('V', fread($fh, 4));\n            // uncompressed size\n            $zip_file_length = unpack('v', fread($fh, 2));\n            // filename length\n            $extra_field_length = unpack('v', fread($fh, 2));\n            // extra field length\n            $file['file_name'] = fread($fh, $zip_file_length[1]);\n            // filename\n            $file['extra_field'] = $extra_field_length[1] ? fread($fh, $extra_field_length[1]) : '';\n            // extra field\n            $file['contents_start_offset'] = ftell($fh);\n\n            // Bypass the whole compressed contents, and look for the next file\n            fseek($fh, $file['compressed_size'][1], SEEK_CUR);\n\n            // Convert the date and time, from MS-DOS format to UNIX Timestamp\n            $binary_mod_date = str_pad(decbin($file['lastmod_date'][1]), 16, '0', STR_PAD_LEFT);\n            $binary_mod_time = str_pad(decbin($file['lastmod_time'][1]), 16, '0', STR_PAD_LEFT);\n\n            $last_mod_year = bindec(substr($binary_mod_date, 0, 7)) + 1980;\n            $last_mod_month = bindec(substr($binary_mod_date, 7, 4));\n            $last_mod_day = bindec(substr($binary_mod_date, 11, 5));\n            $last_mod_hour = bindec(substr($binary_mod_time, 0, 5));\n            $last_mod_minute = bindec(substr($binary_mod_time, 5, 6));\n            $last_mod_second = bindec(substr($binary_mod_time, 11, 5));\n\n            // Mount file table\n            $i = array('file_name' => $file['file_name'], 'compression_method' => $file['compression_method'][1], 'version_needed' => $file['version_needed'][1], 'lastmod_datetime' => mktime($last_mod_hour, $last_mod_minute, $last_mod_second, $last_mod_month, $last_mod_day, $last_mod_year), 'crc-32' => str_pad(dechex(ord($file['crc-32'][3])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][2])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][1])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][0])), 2, '0', STR_PAD_LEFT), 'compressed_size' => $file['compressed_size'][1], 'uncompressed_size' => $file['uncompressed_size'][1], 'extra_field' => $file['extra_field'], 'general_bit_flag' => str_pad(decbin($file['general_bit_flag'][1]), 8, '0', STR_PAD_LEFT), 'contents_start_offset' => $file['contents_start_offset']);\n\n            return $i;\n        }\n\n        return false;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _load_files_by_signatures(&$fh, $stop_on_file = false)\n    {\n        fseek($fh, 0);\n\n        $return = false;\n        for (; ;) {\n            $details = $this->_get_file_header($fh);\n\n            if (!$details) {\n                $this->set_debug('Invalid signature. Trying to verify if is old style Data Descriptor...');\n                fseek($fh, 12 - 4, SEEK_CUR);\n                // 12: Data descriptor - 4: Signature (that will be read again)\n                $details = $this->_get_file_header($fh);\n            }\n\n            if (!$details) {\n                $this->set_debug('Still invalid signature. Probably reached the end of the file.');\n                break;\n            }\n\n            $filename = $details['file_name'];\n            $this->compressed_list[$filename] = $details;\n            $return = true;\n\n            if (strtolower($stop_on_file) == strtolower($filename)) {\n                break;\n            }\n        }\n\n        return $return;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Unzip file in archive.\n     *\n     * @param     string , boolean, boolean\n     *\n     * @return Unziped file.\n     */\n    private function _extract_file($compressed_file_name, $target_file_name = false, $underscore_case = false)\n    {\n        if (!sizeof($this->compressed_list)) {\n            $this->set_debug('Trying to unzip before loading file list... Loading it!');\n            $this->_list_files(false, $compressed_file_name);\n        }\n\n        $fdetails = &$this->compressed_list[$compressed_file_name];\n\n        if (!isset($this->compressed_list[$compressed_file_name])) {\n            $this->set_error('File \"<strong>$compressed_file_name</strong>\" is not compressed in the zip.');\n\n            return false;\n        }\n\n        if (substr($compressed_file_name, -1) == '/') {\n            $this->set_error('Trying to unzip a folder name \"<strong>$compressed_file_name</strong>\".');\n\n            return false;\n        }\n\n        if (!$fdetails['uncompressed_size']) {\n            $this->set_debug('File \"<strong>$compressed_file_name</strong>\" is empty.');\n\n            return $target_file_name ? file_put_contents($target_file_name, '') : '';\n        }\n\n        if ($underscore_case) {\n            $pathinfo = pathinfo($target_file_name);\n            //  $pathinfo['filename_new'] = preg_replace('/([^.a-z0-9]+)/i', '_', strtolower($pathinfo['filename']));\n            $pathinfo['filename_new'] = ($pathinfo['filename']);\n            $target_file_name = $pathinfo['dirname'] . '/' . $pathinfo['filename_new'] . '.' . ($pathinfo['extension']);\n        }\n\n        fseek($this->fh, $fdetails['contents_start_offset']);\n        $ret = $this->_uncompress(fread($this->fh, $fdetails['compressed_size']), $fdetails['compression_method'], $fdetails['uncompressed_size'], $target_file_name);\n\n        if ($this->apply_chmod && $target_file_name) {\n            chmod($target_file_name, 0755);\n        }\n\n        return $ret;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Uncompress file. And save it to the targetFile.\n     *\n     * @param     Filecontent , int, int, boolean\n     *\n     * @return none\n     */\n    private function _uncompress($content, $mode, $uncompressed_size, $target_file_name = false)\n    {\n        switch ($mode) {\n            case 0 :\n                return $target_file_name ? file_put_contents($target_file_name, $content) : $content;\n            case 1 :\n                $this->set_error('Shrunk mode is not supported... yet?');\n\n                return false;\n            case 2 :\n            case 3 :\n            case 4 :\n            case 5 :\n                $this->set_error('Compression factor ' . ($mode - 1) . ' is not supported... yet?');\n\n                return false;\n            case 6 :\n                $this->set_error('Implode is not supported... yet?');\n\n                return false;\n            case 7 :\n                $this->set_error('Tokenizing compression algorithm is not supported... yet?');\n\n                return false;\n            case 8 :\n                // Deflate\n                return $target_file_name ? file_put_contents($target_file_name, gzinflate($content, $uncompressed_size)) : gzinflate($content, $uncompressed_size);\n            case 9 :\n                $this->set_error('Enhanced Deflating is not supported... yet?');\n\n                return false;\n            case 10 :\n                $this->set_error('PKWARE Date Compression Library Impoloding is not supported... yet?');\n\n                return false;\n            case 12 :\n                // Bzip2\n                return $target_file_name ? file_put_contents($target_file_name, bzdecompress($content)) : bzdecompress($content);\n            case 18 :\n                $this->set_error('IBM TERSE is not supported... yet?');\n\n                return false;\n            default :\n                $this->set_error('Unknown uncompress method: $mode');\n\n                return false;\n        }\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * What extensions do we want out of this ZIP.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function allow($ext = null)\n    {\n        $this->_allow_extensions = $ext;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Show error messages.\n     *\n     * @param    string\n     *\n     * @return string\n     */\n    public function error_string($open = '<p>', $close = '</p>')\n    {\n        return $open . implode($close . $open, $this->error) . $close;\n    }\n\n    /**\n     * Show debug messages.\n     *\n     * @param    string\n     *\n     * @return string\n     */\n    public function debug_string($open = '<p>', $close = '</p>')\n    {\n        return $open . implode($close . $open, $this->info) . $close;\n    }\n\n    /**\n     * Free the file resource Automatic destroy.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function __destroy()\n    {\n        $this->close();\n    }\n\n    /**\n     * Free the file resource.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function close()\n    {\n        // Free the file resource\n        if ($this->fh) {\n            fclose($this->fh);\n        }\n    }\n}\n", ".mw-backup-v2-import {\n    padding-right: 40px;\n    padding-left: 40px;\n    text-align: center;\n    display: flex;\n    flex-flow: column;\n    height: 100%;\n    align-items: center;\n    justify-content: center;\n}\n\n.mw-backup-v2-import > .import-image {\n    display: none;\n}\n\n.mw-backup-v2-import-option {\n    padding-left: 15px;\n    padding-bottom: 15px;\n    background: #FFF;\n    border: 1px solid #ebebeb;\n    margin-bottom: 15px;\n    width: 100%;\n    text-align: left;\n}\n\n.mw-backup-v2-import-option.active {\n    box-shadow: 0px 4px 11px #e6e6e6;\n}\n\n.mw-backup-v2-import-option:hover {\n    box-shadow: 0px 4px 11px #e6e6e6;\n}\n\n.mw-backup-v2-import-option h3 {\n    font-weight: bold;\n    font-size: 18px;\n    margin-top: 20px;\n}\n\n.mw-backup-v2-import-option p {\n    font-size: 13px;\n}\n\n.mw-backup-v2-import-option > .option-radio {\n    width: 50px;\n    height: 55px;\n    float: left;\n    padding-top: 25px;\n    padding-left: 10px;\n}\n\n.mw-backup-v2-import-buttons {\n    text-align: right;\n}\n\n.mw-backup-v2-import-buttons > .button-cancel {\n    margin-right: 25px;\n    font-weight: bold;\n    cursor: pointer;\n    padding: 15px;\n}\n\n.backup-import-modal-log {\n    text-align: left;\n    color: #fff;\n    background: #575757;\n    padding-top: 15px;\n    padding-left: 15px;\n    padding-bottom: 15px;\n    font-family: monospace;\n    border-radius: 4px;\n    margin-top: 15px;\n    margin-bottom: 15px;\n    height: 200px;\n    overflow-y: auto;\n}\n\n#backup-import-progressbar h3 {\n    color: #469a36;\n}\n\n.backup-import-modal-log-progress {\n    width: 80%;\n}\n\n#quick-parent-selector-tree {\n    max-height: 40vh;\n    overflow: auto;\n}\n\n.export-stepper-1-select {\n    margin: 0px 0 25px;\n}\n\n.export-stepper .mw-stepper-item {\n    padding: 10px;\n}\n\n.export-stepper-1-select .mw-construct-itd {\n    width: 100%;\n}\n\n.step-actions .mw-ui-btn {\n    min-width: 180px;\n}\n\n.step-actions-2, .step-actions-3 {\n    justify-content: flex-end;\n}\n\n.step-header-actions {\n    padding-bottom: 15px;\n}\n\n.export-step-2-items-head .mw-construct-itd,\n.export-step-3-items-head .mw-construct-itd {\n    display: flex;\n    padding-bottom: 10px;\n}\n\n.export-step-2-items-head,\n.export-step-3-items-head {\n    padding-bottom: 15px;\n\n}\n\n.export-step-2-items-head .mw-ui-check + .mw-ui-check,\n.export-step-3-items-head .mw-ui-check + .mw-ui-check {\n    margin-left: 10px;\n}\n\n.js-export-log-content {\n    text-align: left;\n    color: #fff;\n    background: #575757;\n    padding-top: 15px;\n    padding-left: 15px;\n    padding-bottom: 15px;\n    font-family: monospace;\n    border-radius: 4px;\n    margin-top: 15px;\n    margin-bottom: 15px;\n}\n\n.js-export-log:empty {\n    display: none;\n}\n\n.export-stepper-1 .export-stepper-content,\n.export-stepper-4 .export-stepper-content {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n}\n\n@media screen and (min-height: 700px) {\n    .export-stepper-1 .export-stepper-content,\n    .export-stepper-4 .export-stepper-content {\n        padding: 40px 0;\n    }\n}\n\n.export-stepper-content{\n    padding-top: 20px;\n}\n\n.mw-selectable-list label {\n    padding: 15px 10px;\n    display: flex;\n    align-items: center;\n}\n\n.mw-selectable-list > label > * {\n    padding-top: 0;\n    padding-bottom: 0;\n    border: 0 !important;\n}\n\n.mw-selectable-list .mw-selectable-list-input .mw-ui-check {\n    top: 0;\n}\n\n.mw-selectable-list-input {\n    order: 1;\n}\n\n.mw-selectable-list-icon {\n    order: 2;\n}\n\n.mw-selectable-list-content {\n    order: 3;\n}\n\n.mw-selectable-list .mw-selectable-list-content {\n    font-size: 13px;\n    font-weight: 400;\n}\n\n.mw-selectable-list-content-description {\n    font-size: 0.75rem;\n    font-weight: 400;\n    color: #919191;\n}"], "fixing_code": ["<?php\n\nnamespace MicroweberPackages\\Utils\\Zip;\n\n/**\n * UnZip Class.\n *\n * This class is based on a library I found at PHPClasses:\n * http://phpclasses.org/package/2495-PHP-Pack-and-unpack-files-packed-in-ZIP-archives.html\n *\n * The original library is a little rough around the edges so I\n * refactored it and added several additional methods -- Phil Sturgeon\n *\n * This class requires extension ZLib Enabled.\n *\n * @author        Alexandre Tedeschi\n * @author        Phil Sturgeon\n *\n * @link        http://bitbucket.org/philsturgeon/codeigniter-unzip\n *\n * @license        http://www.gnu.org/licenses/lgpl.html\n *\n * @version     1.0.0\n */\nclass Unzip\n{\n    private $compressed_list = array();\n    // List of files in the ZIP\n    private $central_dir_list = array();\n    // Central dir list... It's a kind of 'extra attributes' for a set of files\n    private $end_of_central = array();\n    // End of central dir, contains ZIP Comments\n    private $info = array();\n    private $error = array();\n    private $_zip_file = '';\n    private $_target_dir = false;\n    private $apply_chmod = 0755;\n    private $fh;\n    private $zip_signature = \"\\x50\\x4b\\x03\\x04\";\n    // local file header signature\n    private $dir_signature = \"\\x50\\x4b\\x01\\x02\";\n    // central dir header signature\n    private $central_signature_end = \"\\x50\\x4b\\x05\\x06\";\n    // ignore these directories (useless meta data)\n    private $_skip_dirs = array('__MACOSX');\n    // Rename target files with underscore case\n    private $underscore_case = true;\n    private $_allow_extensions = null;\n\n    // What is allowed out of the zip\n    // --------------------------------------------------------------------\n\n    /**\n     * Constructor.\n     *\n     * @param     string\n     *\n     * @return none\n     */\n    public function __construct()\n    {\n    }\n\n    /**\n     * Unzip all files in archive.\n     *\n     * @param     none\n     *\n     * @return    none\n     */\n    public function extract($zip_file, $target_dir = null, $preserve_filepath = true)\n    {\n        $this->_zip_file = $zip_file;\n        $this->_target_dir = $target_dir ? $target_dir : dirname($this->_zip_file);\n\n        if (function_exists('zip_open')) {\n\n            $is_any = $this->native_unzip($zip_file, $target_dir, $preserve_filepath);\n\n            if (!empty($is_any)) {\n                return $is_any;\n            }\n\n        } else if (function_exists('gzinflate')) {\n\n            if (!$files = $this->_list_files()) {\n                $this->set_error('ZIP folder was empty.');\n                return false;\n            }\n\n            $file_locations = array();\n            foreach ($files as $file => $trash) {\n\n                if (strpos($file,'..') !== false) {\n                    continue;\n                }\n\n                $dirname = pathinfo($file, PATHINFO_DIRNAME);\n                $extension = (pathinfo($file, PATHINFO_EXTENSION));\n\n                $folders = explode('/', $dirname);\n                $out_dn = $this->_target_dir . '/' . $dirname;\n                $out_dn = str_replace('\\/', DS, $out_dn);\n                // Skip stuff in stupid folders\n                if (in_array(current($folders), $this->_skip_dirs)) {\n                    continue;\n                }\n\n                // Skip any files that are not allowed\n                if (is_array($this->_allow_extensions) && $extension && !in_array($extension, $this->_allow_extensions)) {\n                    continue;\n                }\n\n                if (!is_dir($out_dn) && $preserve_filepath) {\n                    $str = '';\n                    foreach ($folders as $folder) {\n                        $str = $str ? $str . '/' . $folder : $folder;\n                        if (!is_dir($this->_target_dir . '/' . $str)) {\n                            $this->set_debug('Creating folder: ' . $this->_target_dir . '/' . $str);\n\n                            if (!@mkdir_recursive($this->_target_dir . '/' . $str)) {\n                                $this->set_error('Desitnation path is not writable.');\n\n                                return false;\n                            }\n\n                            // Apply chmod if configured to do so\n                            $this->apply_chmod && chmod($this->_target_dir . '/' . $str, $this->apply_chmod);\n                        }\n                    }\n                }\n\n                if (substr($file, -1, 1) == '/') {\n                    continue;\n                }\n\n                $file_locations[] = $file_location = $this->_target_dir . '/' . ($preserve_filepath ? $file : basename($file));\n\n                $this->_extract_file($file, $file_location, $this->underscore_case);\n                // Skip stuff in stupid folders\n                if (in_array(current($folders), $this->_skip_dirs)) {\n                    continue;\n                }\n\n                // Skip any files that are not allowed\n                if (is_array($this->_allow_extensions) && $extension && !in_array($extension, $this->_allow_extensions)) {\n                    continue;\n                }\n\n                if (!is_dir($out_dn) && $preserve_filepath) {\n                    $str = '';\n                    foreach ($folders as $folder) {\n                        $str = $str ? $str . '/' . $folder : $folder;\n                        if (!is_dir($this->_target_dir . '/' . $str)) {\n                            $this->set_debug('Creating folder: ' . $this->_target_dir . '/' . $str);\n\n                            if (!@mkdir_recursive($this->_target_dir . '/' . $str)) {\n                                $this->set_error('Desitnation path is not writable.');\n                                $resp = array('error' => 'Error with the unzip! Desitnation path is not writable.');\n\n                                return $resp;\n\n                                return false;\n                            }\n\n                            // Apply chmod if configured to do so\n                            $this->apply_chmod && chmod($this->_target_dir . '/' . $str, $this->apply_chmod);\n                        }\n                    }\n                }\n\n                if (substr($file, -1, 1) == '/') {\n                    continue;\n                }\n\n                $file_locations[] = $file_location = $this->_target_dir . '/' . ($preserve_filepath ? $file : basename($file));\n\n                $this->_extract_file($file, $file_location, $this->underscore_case);\n            }\n\n            return $file_locations;\n        }\n\n        $resp = array('error' => 'There was an error with the unzip');\n\n        return $resp;\n    }\n\n\n    public function native_unzip($zip_file, $target_dir = null, $preserve_filepath = true)\n    {\n        $file_locations = array();\n        if (function_exists('zip_open')) {\n            $filename = $zip_file;\n\n            try {\n                if (!is_dir($target_dir)) {\n                    @mkdir_recursive($target_dir);\n                }\n            } catch (\\ErrorException $e) {\n\n            }\n\n\n            // get all dirs and make them because of error: is_dir(): open_basedir restriction in effect.\n            $dirs_tree = array();\n            $archive = zip_open($filename);\n            while ($entry = zip_read($archive)) {\n                $name = zip_entry_name($entry);\n                $name = dirname($name);\n                $is_dir_there = $target_dir . $name;\n\n                if (strpos($is_dir_there,'..') !== false) {\n                   continue;\n                }\n\n                if ($name != '.') {\n                    $dirs_tree[] = $is_dir_there;\n\n                }\n\n            }\n\n            $dirs_tree = array_unique($dirs_tree);\n\n            foreach ($dirs_tree as $item) {\n                try {\n                    if (!is_dir($item)) {\n                        @mkdir_recursive($item);\n                    }\n                } catch (\\ErrorException $e) {\n                // error: is_dir(): open_basedir restriction in effect.\n                }\n            }\n\n            zip_close($archive);\n\n\n            // open for extract\n            $archive = zip_open($filename);\n\n            if (is_resource($archive)) {\n                if (function_exists('set_time_limit')) {\n                    @set_time_limit(600);\n                }\n\n                while ($entry = zip_read($archive)) {\n                    $size = zip_entry_filesize($entry);\n                    $name = zip_entry_name($entry);\n                    $target_file_to_save = normalize_path($target_dir . $name, false);\n\n                    if (strpos($target_file_to_save,'..') !== false) {\n                        continue;\n                    }\n\n                    $target_file_to_save_dir = dirname($target_file_to_save);\n                    if(!is_dir($target_file_to_save_dir)){\n                        mkdir_recursive($target_file_to_save_dir);\n                    }\n//\n                   //  var_dump($entry);\n//                    var_dump($name);\n//                    var_dump($target_file_to_save);\n//                    echo '________________' . PHP_EOL;\n//                    continue;\n\n                    $unzipped = @fopen($target_file_to_save, 'wb');\n                    while ($size > 0) {\n                        $chunkSize = ($size > 10240) ? 10240 : $size;\n                        $size -= $chunkSize;\n                        $chunk = zip_entry_read($entry, $chunkSize);\n                        if ($chunk !== false) {\n                            @fwrite($unzipped, $chunk);\n                            $file_locations[] = $target_file_to_save;\n                        }\n                    }\n                    @fclose($unzipped);\n                }\n                zip_close($archive);\n            }\n            if (!empty($file_locations)) {\n                $file_locations = array_unique($file_locations);\n            }\n        }\n\n        return $file_locations;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * List all files in archive.\n     *\n     * @param     bool\n     *\n     * @return mixed\n     */\n    private function _list_files($stop_on_file = false)\n    {\n        if (sizeof($this->compressed_list)) {\n            $this->set_debug('Returning already loaded file list.');\n\n            return $this->compressed_list;\n        }\n\n        // Open file, and set file handler\n        $fh = fopen($this->_zip_file, 'r');\n        $this->fh = &$fh;\n\n        if (!$fh) {\n            $this->set_error('Failed to load file: ' . $this->_zip_file);\n\n            return false;\n        }\n\n        $this->set_debug('Loading list from \"End of Central Dir\" index list...');\n\n        if (!$this->_load_file_list_by_eof($fh, $stop_on_file)) {\n            $this->set_debug('Failed! Trying to load list looking for signatures...');\n\n            if (!$this->_load_files_by_signatures($fh, $stop_on_file)) {\n                $this->set_debug('Failed! Could not find any valid header.');\n                $this->set_error('ZIP File is corrupted or empty');\n\n                return false;\n            }\n        }\n\n        return $this->compressed_list;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Save debug data.\n     *\n     * @param    string\n     *\n     * @return none\n     */\n    public function set_debug($string)\n    {\n        $this->info[] = $string;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Save errors.\n     *\n     * @param    string\n     *\n     * @return none\n     */\n    public function set_error($string)\n    {\n        $this->error[] = $string;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _load_file_list_by_eof(&$fh, $stop_on_file = false)\n    {\n        // Check if there's a valid Central Dir signature.\n        // Let's consider a file comment smaller than 1024 characters...\n        // Actually, it length can be 65536.. But we're not going to support it.\n\n        for ($x = 0; $x < 1024; ++$x) {\n            fseek($fh, -22 - $x, SEEK_END);\n\n            $signature = fread($fh, 4);\n\n            if ($signature == $this->central_signature_end) {\n                // If found EOF Central Dir\n                $eodir['disk_number_this'] = unpack('v', fread($fh, 2));\n                // number of this disk\n                $eodir['disk_number'] = unpack('v', fread($fh, 2));\n                // number of the disk with the start of the central directory\n                $eodir['total_entries_this'] = unpack('v', fread($fh, 2));\n                // total number of entries in the central dir on this disk\n                $eodir['total_entries'] = unpack('v', fread($fh, 2));\n                // total number of entries in\n                $eodir['size_of_cd'] = unpack('V', fread($fh, 4));\n                // size of the central directory\n                $eodir['offset_start_cd'] = unpack('V', fread($fh, 4));\n                // offset of start of central directory with respect to the starting disk number\n                $zip_comment_lenght = unpack('v', fread($fh, 2));\n                // zipfile comment length\n                $eodir['zipfile_comment'] = $zip_comment_lenght[1] ? fread($fh, $zip_comment_lenght[1]) : '';\n                // zipfile comment\n\n                $this->end_of_central = array('disk_number_this' => $eodir['disk_number_this'][1], 'disk_number' => $eodir['disk_number'][1], 'total_entries_this' => $eodir['total_entries_this'][1], 'total_entries' => $eodir['total_entries'][1], 'size_of_cd' => $eodir['size_of_cd'][1], 'offset_start_cd' => $eodir['offset_start_cd'][1], 'zipfile_comment' => $eodir['zipfile_comment']);\n\n                // Then, load file list\n                fseek($fh, $this->end_of_central['offset_start_cd']);\n                $signature = fread($fh, 4);\n\n                while ($signature == $this->dir_signature) {\n                    $dir['version_madeby'] = unpack('v', fread($fh, 2));\n                    // version made by\n                    $dir['version_needed'] = unpack('v', fread($fh, 2));\n                    // version needed to extract\n                    $dir['general_bit_flag'] = unpack('v', fread($fh, 2));\n                    // general purpose bit flag\n                    $dir['compression_method'] = unpack('v', fread($fh, 2));\n                    // compression method\n                    $dir['lastmod_time'] = unpack('v', fread($fh, 2));\n                    // last mod file time\n                    $dir['lastmod_date'] = unpack('v', fread($fh, 2));\n                    // last mod file date\n                    $dir['crc-32'] = fread($fh, 4);\n                    // crc-32\n                    $dir['compressed_size'] = unpack('V', fread($fh, 4));\n                    // compressed size\n                    $dir['uncompressed_size'] = unpack('V', fread($fh, 4));\n                    // uncompressed size\n                    $zip_file_length = unpack('v', fread($fh, 2));\n                    // filename length\n                    $extra_field_length = unpack('v', fread($fh, 2));\n                    // extra field length\n                    $fileCommentLength = unpack('v', fread($fh, 2));\n                    // file comment length\n                    $dir['disk_number_start'] = unpack('v', fread($fh, 2));\n                    // disk number start\n                    $dir['internal_attributes'] = unpack('v', fread($fh, 2));\n                    // internal file attributes-byte1\n                    $dir['external_attributes1'] = unpack('v', fread($fh, 2));\n                    // external file attributes-byte2\n                    $dir['external_attributes2'] = unpack('v', fread($fh, 2));\n                    // external file attributes\n                    $dir['relative_offset'] = unpack('V', fread($fh, 4));\n                    // relative offset of local header\n                    $dir['file_name'] = fread($fh, $zip_file_length[1]);\n                    // filename\n                    $dir['extra_field'] = $extra_field_length[1] ? fread($fh, $extra_field_length[1]) : '';\n                    // extra field\n                    $dir['file_comment'] = $fileCommentLength[1] ? fread($fh, $fileCommentLength[1]) : '';\n                    // file comment\n                    // Convert the date and time, from MS-DOS format to UNIX Timestamp\n                    $binary_mod_date = str_pad(decbin($dir['lastmod_date'][1]), 16, '0', STR_PAD_LEFT);\n                    $binary_mod_time = str_pad(decbin($dir['lastmod_time'][1]), 16, '0', STR_PAD_LEFT);\n                    $last_mod_year = bindec(substr($binary_mod_date, 0, 7)) + 1980;\n                    $last_mod_month = bindec(substr($binary_mod_date, 7, 4));\n                    $last_mod_day = bindec(substr($binary_mod_date, 11, 5));\n                    $last_mod_hour = bindec(substr($binary_mod_time, 0, 5));\n                    $last_mod_minute = bindec(substr($binary_mod_time, 5, 6));\n                    $last_mod_second = bindec(substr($binary_mod_time, 11, 5));\n\n                    $this->central_dir_list[$dir['file_name']] = array('version_madeby' => $dir['version_madeby'][1], 'version_needed' => $dir['version_needed'][1], 'general_bit_flag' => str_pad(decbin($dir['general_bit_flag'][1]), 8, '0', STR_PAD_LEFT), 'compression_method' => $dir['compression_method'][1], 'lastmod_datetime' => mktime($last_mod_hour, $last_mod_minute, $last_mod_second, $last_mod_month, $last_mod_day, $last_mod_year), 'crc-32' => str_pad(dechex(ord($dir['crc-32'][3])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][2])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][1])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][0])), 2, '0', STR_PAD_LEFT), 'compressed_size' => $dir['compressed_size'][1], 'uncompressed_size' => $dir['uncompressed_size'][1], 'disk_number_start' => $dir['disk_number_start'][1], 'internal_attributes' => $dir['internal_attributes'][1], 'external_attributes1' => $dir['external_attributes1'][1], 'external_attributes2' => $dir['external_attributes2'][1], 'relative_offset' => $dir['relative_offset'][1], 'file_name' => $dir['file_name'], 'extra_field' => $dir['extra_field'], 'file_comment' => $dir['file_comment']);\n\n                    $signature = fread($fh, 4);\n                }\n\n                // If loaded centralDirs, then try to identify the offsetPosition of the compressed data.\n                if ($this->central_dir_list) {\n                    foreach ($this->central_dir_list as $filename => $details) {\n                        $i = $this->_get_file_header($fh, $details['relative_offset']);\n                        $this->compressed_list[$filename]['file_name'] = $filename;\n                        $this->compressed_list[$filename]['compression_method'] = $details['compression_method'];\n                        $this->compressed_list[$filename]['version_needed'] = $details['version_needed'];\n                        $this->compressed_list[$filename]['lastmod_datetime'] = $details['lastmod_datetime'];\n                        $this->compressed_list[$filename]['crc-32'] = $details['crc-32'];\n                        $this->compressed_list[$filename]['compressed_size'] = $details['compressed_size'];\n                        $this->compressed_list[$filename]['uncompressed_size'] = $details['uncompressed_size'];\n                        $this->compressed_list[$filename]['lastmod_datetime'] = $details['lastmod_datetime'];\n                        $this->compressed_list[$filename]['extra_field'] = $i['extra_field'];\n                        $this->compressed_list[$filename]['contents_start_offset'] = $i['contents_start_offset'];\n\n                        if (strtolower($stop_on_file) == strtolower($filename)) {\n                            break;\n                        }\n                    }\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _get_file_header(&$fh, $start_offset = false)\n    {\n        if ($start_offset !== false) {\n            fseek($fh, $start_offset);\n        }\n\n        $signature = fread($fh, 4);\n\n        if ($signature == $this->zip_signature) {\n            // Get information about the zipped file\n            $file['version_needed'] = unpack('v', fread($fh, 2));\n            // version needed to extract\n            $file['general_bit_flag'] = unpack('v', fread($fh, 2));\n            // general purpose bit flag\n            $file['compression_method'] = unpack('v', fread($fh, 2));\n            // compression method\n            $file['lastmod_time'] = unpack('v', fread($fh, 2));\n            // last mod file time\n            $file['lastmod_date'] = unpack('v', fread($fh, 2));\n            // last mod file date\n            $file['crc-32'] = fread($fh, 4);\n            // crc-32\n            $file['compressed_size'] = unpack('V', fread($fh, 4));\n            // compressed size\n            $file['uncompressed_size'] = unpack('V', fread($fh, 4));\n            // uncompressed size\n            $zip_file_length = unpack('v', fread($fh, 2));\n            // filename length\n            $extra_field_length = unpack('v', fread($fh, 2));\n            // extra field length\n            $file['file_name'] = fread($fh, $zip_file_length[1]);\n            // filename\n            $file['extra_field'] = $extra_field_length[1] ? fread($fh, $extra_field_length[1]) : '';\n            // extra field\n            $file['contents_start_offset'] = ftell($fh);\n\n            // Bypass the whole compressed contents, and look for the next file\n            fseek($fh, $file['compressed_size'][1], SEEK_CUR);\n\n            // Convert the date and time, from MS-DOS format to UNIX Timestamp\n            $binary_mod_date = str_pad(decbin($file['lastmod_date'][1]), 16, '0', STR_PAD_LEFT);\n            $binary_mod_time = str_pad(decbin($file['lastmod_time'][1]), 16, '0', STR_PAD_LEFT);\n\n            $last_mod_year = bindec(substr($binary_mod_date, 0, 7)) + 1980;\n            $last_mod_month = bindec(substr($binary_mod_date, 7, 4));\n            $last_mod_day = bindec(substr($binary_mod_date, 11, 5));\n            $last_mod_hour = bindec(substr($binary_mod_time, 0, 5));\n            $last_mod_minute = bindec(substr($binary_mod_time, 5, 6));\n            $last_mod_second = bindec(substr($binary_mod_time, 11, 5));\n\n            // Mount file table\n            $i = array('file_name' => $file['file_name'], 'compression_method' => $file['compression_method'][1], 'version_needed' => $file['version_needed'][1], 'lastmod_datetime' => mktime($last_mod_hour, $last_mod_minute, $last_mod_second, $last_mod_month, $last_mod_day, $last_mod_year), 'crc-32' => str_pad(dechex(ord($file['crc-32'][3])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][2])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][1])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][0])), 2, '0', STR_PAD_LEFT), 'compressed_size' => $file['compressed_size'][1], 'uncompressed_size' => $file['uncompressed_size'][1], 'extra_field' => $file['extra_field'], 'general_bit_flag' => str_pad(decbin($file['general_bit_flag'][1]), 8, '0', STR_PAD_LEFT), 'contents_start_offset' => $file['contents_start_offset']);\n\n            return $i;\n        }\n\n        return false;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _load_files_by_signatures(&$fh, $stop_on_file = false)\n    {\n        fseek($fh, 0);\n\n        $return = false;\n        for (; ;) {\n            $details = $this->_get_file_header($fh);\n\n            if (!$details) {\n                $this->set_debug('Invalid signature. Trying to verify if is old style Data Descriptor...');\n                fseek($fh, 12 - 4, SEEK_CUR);\n                // 12: Data descriptor - 4: Signature (that will be read again)\n                $details = $this->_get_file_header($fh);\n            }\n\n            if (!$details) {\n                $this->set_debug('Still invalid signature. Probably reached the end of the file.');\n                break;\n            }\n\n            $filename = $details['file_name'];\n            $this->compressed_list[$filename] = $details;\n            $return = true;\n\n            if (strtolower($stop_on_file) == strtolower($filename)) {\n                break;\n            }\n        }\n\n        return $return;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Unzip file in archive.\n     *\n     * @param     string , boolean, boolean\n     *\n     * @return Unziped file.\n     */\n    private function _extract_file($compressed_file_name, $target_file_name = false, $underscore_case = false)\n    {\n        if (strpos($target_file_name,'..') !== false) {\n            return false;\n        }\n\n        if (strpos($compressed_file_name,'..') !== false) {\n            return false;\n        }\n\n        if (!sizeof($this->compressed_list)) {\n            $this->set_debug('Trying to unzip before loading file list... Loading it!');\n            $this->_list_files(false, $compressed_file_name);\n        }\n\n        $fdetails = &$this->compressed_list[$compressed_file_name];\n\n        if (!isset($this->compressed_list[$compressed_file_name])) {\n            $this->set_error('File \"<strong>$compressed_file_name</strong>\" is not compressed in the zip.');\n\n            return false;\n        }\n\n        if (substr($compressed_file_name, -1) == '/') {\n            $this->set_error('Trying to unzip a folder name \"<strong>$compressed_file_name</strong>\".');\n\n            return false;\n        }\n\n        if (!$fdetails['uncompressed_size']) {\n            $this->set_debug('File \"<strong>$compressed_file_name</strong>\" is empty.');\n\n            return $target_file_name ? file_put_contents($target_file_name, '') : '';\n        }\n\n        if ($underscore_case) {\n            $pathinfo = pathinfo($target_file_name);\n            //  $pathinfo['filename_new'] = preg_replace('/([^.a-z0-9]+)/i', '_', strtolower($pathinfo['filename']));\n            $pathinfo['filename_new'] = ($pathinfo['filename']);\n            $target_file_name = $pathinfo['dirname'] . '/' . $pathinfo['filename_new'] . '.' . ($pathinfo['extension']);\n        }\n\n        fseek($this->fh, $fdetails['contents_start_offset']);\n        $ret = $this->_uncompress(fread($this->fh, $fdetails['compressed_size']), $fdetails['compression_method'], $fdetails['uncompressed_size'], $target_file_name);\n\n        if ($this->apply_chmod && $target_file_name) {\n            chmod($target_file_name, 0755);\n        }\n\n        return $ret;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Uncompress file. And save it to the targetFile.\n     *\n     * @param     Filecontent , int, int, boolean\n     *\n     * @return none\n     */\n    private function _uncompress($content, $mode, $uncompressed_size, $target_file_name = false)\n    {\n        switch ($mode) {\n            case 0 :\n                return $target_file_name ? file_put_contents($target_file_name, $content) : $content;\n            case 1 :\n                $this->set_error('Shrunk mode is not supported... yet?');\n\n                return false;\n            case 2 :\n            case 3 :\n            case 4 :\n            case 5 :\n                $this->set_error('Compression factor ' . ($mode - 1) . ' is not supported... yet?');\n\n                return false;\n            case 6 :\n                $this->set_error('Implode is not supported... yet?');\n\n                return false;\n            case 7 :\n                $this->set_error('Tokenizing compression algorithm is not supported... yet?');\n\n                return false;\n            case 8 :\n                // Deflate\n                return $target_file_name ? file_put_contents($target_file_name, gzinflate($content, $uncompressed_size)) : gzinflate($content, $uncompressed_size);\n            case 9 :\n                $this->set_error('Enhanced Deflating is not supported... yet?');\n\n                return false;\n            case 10 :\n                $this->set_error('PKWARE Date Compression Library Impoloding is not supported... yet?');\n\n                return false;\n            case 12 :\n                // Bzip2\n                return $target_file_name ? file_put_contents($target_file_name, bzdecompress($content)) : bzdecompress($content);\n            case 18 :\n                $this->set_error('IBM TERSE is not supported... yet?');\n\n                return false;\n            default :\n                $this->set_error('Unknown uncompress method: $mode');\n\n                return false;\n        }\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * What extensions do we want out of this ZIP.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function allow($ext = null)\n    {\n        $this->_allow_extensions = $ext;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Show error messages.\n     *\n     * @param    string\n     *\n     * @return string\n     */\n    public function error_string($open = '<p>', $close = '</p>')\n    {\n        return $open . implode($close . $open, $this->error) . $close;\n    }\n\n    /**\n     * Show debug messages.\n     *\n     * @param    string\n     *\n     * @return string\n     */\n    public function debug_string($open = '<p>', $close = '</p>')\n    {\n        return $open . implode($close . $open, $this->info) . $close;\n    }\n\n    /**\n     * Free the file resource Automatic destroy.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function __destroy()\n    {\n        $this->close();\n    }\n\n    /**\n     * Free the file resource.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function close()\n    {\n        // Free the file resource\n        if ($this->fh) {\n            fclose($this->fh);\n        }\n    }\n}\n", ".mw-backup-v2-import {\n    padding-right: 40px;\n    padding-left: 40px;\n    text-align: center;\n    display: flex;\n    flex-flow: column;\n    height: 100%;\n    align-items: center;\n    justify-content: center;\n}\n\n.mw-backup-v2-import > .import-image {\n    display: none;\n}\n\n.mw-backup-v2-import-option {\n    padding-left: 15px;\n    padding-bottom: 15px;\n    background: #FFF;\n    border: 1px solid #ebebeb;\n    margin-bottom: 15px;\n    width: 100%;\n    text-align: left;\n}\n\n.mw-backup-v2-import-option.active {\n    box-shadow: 0px 4px 11px #e6e6e6;\n}\n\n.mw-backup-v2-import-option:hover {\n    box-shadow: 0px 4px 11px #e6e6e6;\n}\n\n.mw-backup-v2-import-option h3 {\n    font-weight: bold;\n    font-size: 18px;\n    margin-top: 20px;\n}\n\n.mw-backup-v2-import-option p {\n    font-size: 13px;\n}\n\n.mw-backup-v2-import-option > .option-radio {\n    width: 50px;\n    height: 55px;\n    float: left;\n    padding-top: 25px;\n    padding-left: 10px;\n}\n\n.mw-backup-v2-import-buttons {\n    text-align: right;\n}\n\n.mw-backup-v2-import-buttons > .button-cancel {\n    margin-right: 25px;\n    font-weight: bold;\n    cursor: pointer;\n    padding: 15px;\n}\n\n.backup-import-modal-log {\n    text-align: left;\n    color: #fff;\n    background: #575757;\n    padding-top: 15px;\n    padding-left: 15px;\n    padding-bottom: 15px;\n    font-family: monospace;\n    border-radius: 4px;\n    margin-top: 15px;\n    margin-bottom: 15px;\n    height: 200px;\n    overflow-y: auto;\n}\n\n#backup-import-progressbar h3 {\n    color: #469a36;\n}\n\n.backup-import-modal-log-progress {\n    width: 80%;\n}\n\n#quick-parent-selector-tree {\n    max-height: 40vh;\n    overflow: auto;\n}\n\n.export-stepper-1-select {\n    margin: 0px 0 25px;\n}\n\n.export-stepper .mw-stepper-item {\n    padding: 10px;\n}\n\n.export-stepper-1-select .mw-construct-itd {\n    width: 100%;\n}\n\n.step-actions .mw-ui-btn {\n    min-width: 180px;\n}\n\n.step-actions-2, .step-actions-3 {\n    justify-content: flex-end;\n}\n\n.step-header-actions {\n    padding-bottom: 15px;\n}\n\n.export-step-2-items-head .mw-construct-itd,\n.export-step-3-items-head .mw-construct-itd {\n    display: flex;\n    padding-bottom: 10px;\n}\n\n.export-step-2-items-head,\n.export-step-3-items-head {\n    padding-bottom: 15px;\n\n}\n\n.export-step-2-items-head .mw-ui-check + .mw-ui-check,\n.export-step-3-items-head .mw-ui-check + .mw-ui-check {\n    margin-left: 10px;\n}\n\n.js-export-log-content {\n    text-align: left;\n    color: #fff;\n    background: #575757;\n    padding-top: 15px;\n    padding-left: 15px;\n    padding-bottom: 15px;\n    font-family: monospace;\n    border-radius: 4px;\n    margin-top: 15px;\n    margin-bottom: 15px;\n    overflow-y: scroll;\n}\n\n.js-export-log:empty {\n    display: none;\n}\n\n.export-stepper-1 .export-stepper-content,\n.export-stepper-4 .export-stepper-content {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n}\n\n@media screen and (min-height: 700px) {\n    .export-stepper-1 .export-stepper-content,\n    .export-stepper-4 .export-stepper-content {\n        padding: 40px 0;\n    }\n}\n\n.export-stepper-content{\n    padding-top: 20px;\n}\n\n.mw-selectable-list label {\n    padding: 15px 10px;\n    display: flex;\n    align-items: center;\n}\n\n.mw-selectable-list > label > * {\n    padding-top: 0;\n    padding-bottom: 0;\n    border: 0 !important;\n}\n\n.mw-selectable-list .mw-selectable-list-input .mw-ui-check {\n    top: 0;\n}\n\n.mw-selectable-list-input {\n    order: 1;\n}\n\n.mw-selectable-list-icon {\n    order: 2;\n}\n\n.mw-selectable-list-content {\n    order: 3;\n}\n\n.mw-selectable-list .mw-selectable-list-content {\n    font-size: 13px;\n    font-weight: 400;\n}\n\n.mw-selectable-list-content-description {\n    font-size: 0.75rem;\n    font-weight: 400;\n    color: #919191;\n}"], "filenames": ["src/MicroweberPackages/Utils/Zip/Unzip.php", "userfiles/modules/admin/backup_v2/css/style.css"], "buggy_code_start_loc": [84, 142], "buggy_code_end_loc": [571, 142], "fixing_code_start_loc": [85, 143], "fixing_code_end_loc": [596, 144], "type": "CWE-22", "message": "A directory traversal issue in the Utils/Unzip module in Microweber through 1.1.20 allows an authenticated attacker to gain remote code execution via the backup restore feature. To exploit the vulnerability, an attacker must have the credentials of an administrative user, upload a maliciously constructed ZIP file with file paths including relative paths (i.e., ../../), move this file into the backup directory, and execute a restore on this file.", "other": {"cve": {"id": "CVE-2020-28337", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-15T20:15:12.223", "lastModified": "2022-01-01T18:13:26.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A directory traversal issue in the Utils/Unzip module in Microweber through 1.1.20 allows an authenticated attacker to gain remote code execution via the backup restore feature. To exploit the vulnerability, an attacker must have the credentials of an administrative user, upload a maliciously constructed ZIP file with file paths including relative paths (i.e., ../../), move this file into the backup directory, and execute a restore on this file."}, {"lang": "es", "value": "Un problema de salto de directorio en el m\u00f3dulo Utils/Unzip en Microweber versiones hasta 1.1.20, permite a un atacante autenticado conseguir una ejecuci\u00f3n de c\u00f3digo remota por medio de la funcionalidad backup restore.&#xa0;Para explotar la vulnerabilidad, un atacante debe tener las credenciales de un usuario administrativo, cargar un archivo ZIP construido maliciosamente con rutas de archivo que incluyan rutas relativas (es decir, ../../), mover este archivo al directorio de copia de seguridad y ejecutar una restaurar en este archivo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microweber:microweber:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1.20", "matchCriteriaId": "418F2228-2E62-4636-854B-E8C08047BA25"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/162514/Microweber-CMS-1.1.20-Remote-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/microweber/microweber/commit/777ee9c3e7519eb3672c79ac41066175b2001b50", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://sl1nki.page/advisories/CVE-2020-28337", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://sl1nki.page/blog/2021/02/01/microweber-zip-slip", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/microweber/microweber/commit/777ee9c3e7519eb3672c79ac41066175b2001b50"}}