{"buggy_code": ["# -*- coding: utf-8 -*-\n\n### NOTE #################################################################################\n# This file has to stay format compatible to Python 2, or pip under Python 2 will\n# not be able to detect that OctoPrint requires Python 3 but instead fail with a\n# syntax error.\n#\n# So, no f-strings, no walrus operators, no pyupgrade or codemods.\n##########################################################################################\n\nimport os\nimport sys\nfrom distutils.command.build_py import build_py as _build_py\n\nimport versioneer  # noqa: F401\n\nsys.path.insert(0, os.path.join(os.path.dirname(os.path.realpath(__file__)), \"src\"))\nimport setuptools  # noqa: F401,E402\n\nimport octoprint_setuptools  # noqa: F401,E402\n\n# ----------------------------------------------------------------------------------------\n\n# Supported python versions\nPYTHON_REQUIRES = \">=3.7, <4\"\n\n# Requirements for setup.py\nSETUP_REQUIRES = []\n\n# Requirements for our application\nbundled_plugins = [\n    \"OctoPrint-FileCheck>=2021.2.23\",\n    \"OctoPrint-FirmwareCheck>=2021.10.11\",\n    \"OctoPrint-PiSupport>=2022.3.28\",\n]\ncore_deps = [\n    \"cachelib>=0.2,<0.3\",\n    \"Click>=8.0.3,<9\",\n    \"colorlog>=6,<7\",\n    \"emoji>=1.4.2,<2\",\n    \"feedparser>=6.0.8,<7\",\n    \"filetype>=1.0.7,<2\",\n    \"Flask-Assets>=2.0,<3\",\n    \"Flask-Babel>=2.0,<3\",\n    \"Flask-Login>=0.6,<0.7\",  # breaking changes can happen on minor version increases\n    \"flask>=2.2,<2.3\",  # breaking changes can happen on minor version increases (with deprecation warnings)\n    \"frozendict>=2.0,<3\",\n    \"future>=0.18.2,<1\",  # not really needed anymore, but leaving in for py2/3 compat plugins\n    \"markdown>=3.2.2,<4\",\n    \"netaddr>=0.8,<0.9\",  # changelog hints at breaking changes on minor version increases\n    \"netifaces>=0.11,<1\",\n    \"pathvalidate>=2.4.1,<3\",\n    \"pkginfo>=1.7.1,<2\",\n    \"psutil>=5.8,<6\",\n    \"pylru>=1.2,<2\",\n    \"pyserial>=3.4,<4\",\n    \"PyYAML>=5.4.1,<6\",\n    \"requests>=2.26.0,<3\",\n    \"sarge==0.1.6\",\n    \"semantic_version>=2.8.5,<3\",\n    \"sentry-sdk>=1.5.7,<2\",\n    \"tornado>=6.0.4,<7\",\n    \"watchdog>=1,<2\",\n    \"websocket-client>=1.2.1,<2\",\n    \"werkzeug>=2.2,<2.3\",  # breaking changes can happen on minor version increases\n    \"wrapt>=1.14,<1.15\",\n    \"zeroconf>=0.33,<0.34\",  # breaking changes can happen on minor version increases\n    \"zipstream-ng>=1.3.4,<2.0.0\",\n    \"pydantic>=1.9.1,<2\",\n    \"pydantic-settings>=0.2.5,<1\",  # TODO: replace with vendored with_attrs_docs\n]\nvendored_deps = [\n    \"blinker>=1.4,<2\",  # dependency of flask_principal\n    \"regex\",  # dependency of awesome-slugify\n    \"unidecode\",  # dependency of awesome-slugify\n]\n\nINSTALL_REQUIRES = bundled_plugins + core_deps + vendored_deps\n\n# Additional requirements for optional install options and/or OS-specific dependencies\nEXTRA_REQUIRES = {\n    # Dependencies for OSX\n    \":sys_platform == 'darwin'\": [\n        \"appdirs>=1.4.4,<2\",\n    ],\n    # Dependencies for core development\n    \"develop\": [\n        # Testing dependencies\n        \"ddt\",\n        \"mock>=4,<5\",\n        \"pytest-doctest-custom>=1.0.0,<2\",\n        \"pytest>=6.2.5,<7\",\n        # pre-commit\n        \"pre-commit\",\n        # profiler\n        \"pyinstrument\",\n    ],\n    # Dependencies for developing OctoPrint plugins\n    \"plugins\": [\"cookiecutter>=1.7.2,<1.8\"],\n    # Dependencies for building the documentation\n    \"docs\": [\n        \"readthedocs-sphinx-ext>=2.1.5,<3\",\n        \"sphinx_rtd_theme>=1,<2\",\n        \"sphinx>=4,<5\",\n        \"sphinxcontrib-httpdomain>=1.8.0,<2\",\n        \"sphinxcontrib-mermaid>=0.7.1,<0.8\",\n    ],\n}\n\n# ----------------------------------------------------------------------------------------\n# Anything below here is just command setup and general setup configuration\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n\ndef read_file_contents(path):\n    import io\n\n    with io.open(path, encoding=\"utf-8\") as f:\n        return f.read()\n\n\ndef copy_files_build_py_factory(files, baseclass):\n    class copy_files_build_py(baseclass):\n        files = {}\n\n        def run(self):\n            print(\"RUNNING copy_files_build_py\")\n            if not self.dry_run:\n                import shutil\n\n                for directory, files in self.files.items():\n                    target_dir = os.path.join(self.build_lib, directory)\n                    self.mkpath(target_dir)\n\n                    for entry in files:\n                        if isinstance(entry, tuple):\n                            if len(entry) != 2:\n                                continue\n                            source, dest = entry[0], os.path.join(target_dir, entry[1])\n                        else:\n                            source = entry\n                            dest = os.path.join(target_dir, source)\n\n                        print(\"Copying {} to {}\".format(source, dest))\n                        shutil.copy2(source, dest)\n\n            baseclass.run(self)\n\n    return type(copy_files_build_py)(\n        copy_files_build_py.__name__, (copy_files_build_py,), {\"files\": files}\n    )\n\n\ndef get_cmdclass():\n    # make sure these are always available, even when run by dependabot\n    global versioneer, octoprint_setuptools, md_to_html_build_py_factory\n\n    cmdclass = versioneer.get_cmdclass()\n\n    # add clean command\n    cmdclass.update(\n        {\n            \"clean\": octoprint_setuptools.CleanCommand.for_options(\n                source_folder=\"src\", eggs=[\"OctoPrint*.egg-info\"]\n            )\n        }\n    )\n\n    # add translation commands\n    translation_dir = \"translations\"\n    pot_file = os.path.join(translation_dir, \"messages.pot\")\n    bundled_dir = os.path.join(\"src\", \"octoprint\", \"translations\")\n    cmdclass.update(\n        octoprint_setuptools.get_babel_commandclasses(\n            pot_file=pot_file,\n            output_dir=translation_dir,\n            pack_name_prefix=\"OctoPrint-i18n-\",\n            pack_path_prefix=\"\",\n            bundled_dir=bundled_dir,\n        )\n    )\n\n    cmdclass[\"build_py\"] = copy_files_build_py_factory(\n        {\n            \"octoprint/templates/_data\": [\n                \"AUTHORS.md\",\n                \"SUPPORTERS.md\",\n                \"THIRDPARTYLICENSES.md\",\n            ]\n        },\n        cmdclass[\"build_py\"] if \"build_py\" in cmdclass else _build_py,\n    )\n\n    return cmdclass\n\n\ndef params():\n    # make sure these are always available, even when run by dependabot\n    global versioneer, get_cmdclass, read_file_contents, here, PYTHON_REQUIRES, SETUP_REQUIRES, INSTALL_REQUIRES, EXTRA_REQUIRES\n\n    name = \"OctoPrint\"\n    version = versioneer.get_version()\n    cmdclass = get_cmdclass()\n\n    description = \"The snappy web interface for your 3D printer\"\n    long_description = read_file_contents(os.path.join(here, \"README.md\"))\n    long_description_content_type = \"text/markdown\"\n\n    python_requires = PYTHON_REQUIRES\n    setup_requires = SETUP_REQUIRES\n    install_requires = INSTALL_REQUIRES\n    extras_require = EXTRA_REQUIRES\n\n    classifiers = [\n        \"Development Status :: 5 - Production/Stable\",\n        \"Environment :: Web Environment\",\n        \"Framework :: Flask\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: End Users/Desktop\",\n        \"Intended Audience :: Manufacturing\",\n        \"Intended Audience :: Other Audience\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: GNU Affero General Public License v3\",\n        \"Natural Language :: English\",\n        \"Natural Language :: German\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: JavaScript\",\n        \"Topic :: Printing\",\n        \"Topic :: System :: Monitoring\",\n    ]\n    author = \"Gina H\u00e4u\u00dfge\"\n    author_email = \"gina@octoprint.org\"\n    url = \"https://octoprint.org\"\n    license = \"GNU Affero General Public License v3\"\n    keywords = \"3dprinting 3dprinter 3d-printing 3d-printer octoprint\"\n\n    project_urls = {\n        \"Community Forum\": \"https://community.octoprint.org\",\n        \"Bug Reports\": \"https://github.com/OctoPrint/OctoPrint/issues\",\n        \"Source\": \"https://github.com/OctoPrint/OctoPrint\",\n        \"Funding\": \"https://support.octoprint.org\",\n    }\n\n    packages = setuptools.find_packages(where=\"src\")\n    package_dir = {\n        \"\": \"src\",\n    }\n    package_data = {\n        \"octoprint\": octoprint_setuptools.package_data_dirs(\n            \"src/octoprint\", [\"static\", \"templates\", \"plugins\", \"translations\"]\n        )\n        + [\"util/piptestballoon/setup.py\"]\n    }\n\n    include_package_data = True\n    zip_safe = False\n\n    if os.environ.get(\"READTHEDOCS\", None) == \"True\":\n        # we can't tell read the docs to please perform a pip install -e .[docs], so we help\n        # it a bit here by explicitly adding the docs dependencies\n        install_requires = install_requires + extras_require[\"docs\"]\n\n    entry_points = {\"console_scripts\": [\"octoprint = octoprint:main\"]}\n\n    return locals()\n\n\nsetuptools.setup(**params())\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport atexit\nimport base64\nimport functools\nimport logging\nimport logging.config\nimport mimetypes\nimport os\nimport re\nimport signal\nimport sys\nimport time\nimport uuid  # noqa: F401\nfrom collections import OrderedDict, defaultdict\n\nfrom babel import Locale\nfrom flask import (  # noqa: F401\n    Blueprint,\n    Flask,\n    Request,\n    Response,\n    current_app,\n    g,\n    make_response,\n    request,\n    session,\n)\nfrom flask_assets import Bundle, Environment\nfrom flask_babel import Babel, gettext, ngettext  # noqa: F401\nfrom flask_login import (  # noqa: F401\n    LoginManager,\n    current_user,\n    session_protected,\n    user_logged_out,\n)\nfrom watchdog.observers import Observer\nfrom watchdog.observers.polling import PollingObserver\nfrom werkzeug.exceptions import HTTPException\n\nimport octoprint.util\nimport octoprint.util.net\nfrom octoprint.server import util\nfrom octoprint.systemcommands import system_command_manager\nfrom octoprint.util.json import JsonEncoding\nfrom octoprint.vendor.flask_principal import (  # noqa: F401\n    AnonymousIdentity,\n    Identity,\n    Permission,\n    Principal,\n    RoleNeed,\n    UserNeed,\n    identity_changed,\n    identity_loaded,\n)\nfrom octoprint.vendor.sockjs.tornado import SockJSRouter\n\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\nSUCCESS = {}\nNO_CONTENT = (\"\", 204, {\"Content-Type\": \"text/plain\"})\nNOT_MODIFIED = (\"Not Modified\", 304, {\"Content-Type\": \"text/plain\"})\n\napp = Flask(\"octoprint\")\n\nassets = None\nbabel = None\ndebug = False\nsafe_mode = False\n\nprinter = None\nprinterProfileManager = None\nfileManager = None\nslicingManager = None\nanalysisQueue = None\nuserManager = None\npermissionManager = None\ngroupManager = None\neventManager = None\nloginManager = None\npluginManager = None\npluginLifecycleManager = None\npreemptiveCache = None\njsonEncoder = None\njsonDecoder = None\nconnectivityChecker = None\nenvironmentDetector = None\n\nprincipals = Principal(app)\n\nimport octoprint.access.groups as groups  # noqa: E402\nimport octoprint.access.permissions as permissions  # noqa: E402\n\n# we set admin_permission to a GroupPermission with the default admin group\nadmin_permission = octoprint.util.variable_deprecated(\n    \"admin_permission has been deprecated, \" \"please use individual Permissions instead\",\n    since=\"1.4.0\",\n)(groups.GroupPermission(groups.ADMIN_GROUP))\n\n# we set user_permission to a GroupPermission with the default user group\nuser_permission = octoprint.util.variable_deprecated(\n    \"user_permission has been deprecated, \" \"please use individual Permissions instead\",\n    since=\"1.4.0\",\n)(groups.GroupPermission(groups.USER_GROUP))\n\nimport octoprint._version  # noqa: E402\nimport octoprint.access.groups as groups  # noqa: E402\nimport octoprint.access.users as users  # noqa: E402\nimport octoprint.events as events  # noqa: E402\nimport octoprint.filemanager.analysis  # noqa: E402\nimport octoprint.filemanager.storage  # noqa: E402\nimport octoprint.plugin  # noqa: E402\nimport octoprint.slicing  # noqa: E402\nimport octoprint.timelapse  # noqa: E402\n\n# only import further octoprint stuff down here, as it might depend on things defined above to be initialized already\nfrom octoprint import __branch__, __display_version__, __revision__, __version__\nfrom octoprint.printer.profile import PrinterProfileManager\nfrom octoprint.printer.standard import Printer\nfrom octoprint.server.util import (\n    corsRequestHandler,\n    corsResponseHandler,\n    loginFromApiKeyRequestHandler,\n    requireLoginRequestHandler,\n)\nfrom octoprint.server.util.flask import PreemptiveCache\nfrom octoprint.settings import settings\n\nVERSION = __version__\nBRANCH = __branch__\nDISPLAY_VERSION = __display_version__\nREVISION = __revision__\n\nLOCALES = []\nLANGUAGES = set()\n\n\n@identity_loaded.connect_via(app)\ndef on_identity_loaded(sender, identity):\n    user = load_user(identity.id)\n    if user is None:\n        user = userManager.anonymous_user_factory()\n\n    identity.provides.add(UserNeed(user.get_id()))\n    for need in user.needs:\n        identity.provides.add(need)\n\n\ndef _clear_identity(sender):\n    # Remove session keys set by Flask-Principal\n    for key in (\"identity.id\", \"identity.name\", \"identity.auth_type\"):\n        session.pop(key, None)\n\n    # switch to anonymous identity\n    identity_changed.send(sender, identity=AnonymousIdentity())\n\n\n@session_protected.connect_via(app)\ndef on_session_protected(sender):\n    # session was deleted by session protection, that means the user is no more and we need to clear our identity\n    if session.get(\"remember\", None) == \"clear\":\n        _clear_identity(sender)\n\n\n@user_logged_out.connect_via(app)\ndef on_user_logged_out(sender, user=None):\n    # user was logged out, clear identity\n    _clear_identity(sender)\n\n\ndef load_user(id):\n    if id is None:\n        return None\n\n    if id == \"_api\":\n        return userManager.api_user_factory()\n\n    if session and \"usersession.id\" in session:\n        sessionid = session[\"usersession.id\"]\n    else:\n        sessionid = None\n\n    if sessionid:\n        user = userManager.find_user(userid=id, session=sessionid)\n    else:\n        user = userManager.find_user(userid=id)\n\n    if user and user.is_active:\n        return user\n\n    return None\n\n\ndef load_user_from_request(request):\n    user = None\n\n    if settings().getBoolean([\"accessControl\", \"trustBasicAuthentication\"]):\n        # Basic Authentication?\n        user = util.get_user_for_authorization_header(\n            request.headers.get(\"Authorization\")\n        )\n\n    if settings().getBoolean([\"accessControl\", \"trustRemoteUser\"]):\n        # Remote user header?\n        user = util.get_user_for_remote_user_header(request)\n\n    return user\n\n\ndef unauthorized_user():\n    from flask import abort\n\n    abort(403)\n\n\n# ~~ startup code\n\n\nclass Server:\n    def __init__(\n        self,\n        settings=None,\n        plugin_manager=None,\n        connectivity_checker=None,\n        environment_detector=None,\n        event_manager=None,\n        host=None,\n        port=None,\n        v6_only=False,\n        debug=False,\n        safe_mode=False,\n        allow_root=False,\n        octoprint_daemon=None,\n    ):\n        self._settings = settings\n        self._plugin_manager = plugin_manager\n        self._connectivity_checker = connectivity_checker\n        self._environment_detector = environment_detector\n        self._event_manager = event_manager\n        self._host = host\n        self._port = port\n        self._v6_only = v6_only\n        self._debug = debug\n        self._safe_mode = safe_mode\n        self._allow_root = allow_root\n        self._octoprint_daemon = octoprint_daemon\n        self._server = None\n\n        self._logger = None\n\n        self._lifecycle_callbacks = defaultdict(list)\n\n        self._intermediary_server = None\n\n    def run(self):\n        if not self._allow_root:\n            self._check_for_root()\n\n        if self._settings is None:\n            self._settings = settings()\n\n        if not self._settings.getBoolean([\"server\", \"ignoreIncompleteStartup\"]):\n            self._settings.setBoolean([\"server\", \"incompleteStartup\"], True)\n            self._settings.save()\n\n        if self._plugin_manager is None:\n            self._plugin_manager = octoprint.plugin.plugin_manager()\n\n        global app\n        global babel\n\n        global printer\n        global printerProfileManager\n        global fileManager\n        global slicingManager\n        global analysisQueue\n        global userManager\n        global permissionManager\n        global groupManager\n        global eventManager\n        global loginManager\n        global pluginManager\n        global pluginLifecycleManager\n        global preemptiveCache\n        global jsonEncoder\n        global jsonDecoder\n        global connectivityChecker\n        global environmentDetector\n        global debug\n        global safe_mode\n\n        from tornado.ioloop import IOLoop\n        from tornado.web import Application\n\n        debug = self._debug\n        safe_mode = self._safe_mode\n\n        if safe_mode:\n            self._log_safe_mode_start(safe_mode)\n\n        if self._v6_only and not octoprint.util.net.HAS_V6:\n            raise RuntimeError(\n                \"IPv6 only mode configured but system doesn't support IPv6\"\n            )\n\n        if self._host is None:\n            host = self._settings.get([\"server\", \"host\"])\n            if host is None:\n                if octoprint.util.net.HAS_V6:\n                    host = \"::\"\n                else:\n                    host = \"0.0.0.0\"\n\n            self._host = host\n\n        if \":\" in self._host and not octoprint.util.net.HAS_V6:\n            raise RuntimeError(\n                \"IPv6 host address {!r} configured but system doesn't support IPv6\".format(\n                    self._host\n                )\n            )\n\n        if self._port is None:\n            self._port = self._settings.getInt([\"server\", \"port\"])\n            if self._port is None:\n                self._port = 5000\n\n        self._logger = logging.getLogger(__name__)\n        self._setup_heartbeat_logging()\n        pluginManager = self._plugin_manager\n\n        # monkey patch/fix some stuff\n        util.tornado.fix_json_encode()\n        util.tornado.fix_websocket_check_origin()\n        util.tornado.enable_per_message_deflate_extension()\n        util.flask.fix_flask_jsonify()\n\n        self._setup_mimetypes()\n\n        additional_translation_folders = []\n        if not safe_mode:\n            additional_translation_folders += [\n                self._settings.getBaseFolder(\"translations\")\n            ]\n        util.flask.enable_additional_translations(\n            additional_folders=additional_translation_folders\n        )\n\n        # setup app\n        self._setup_app(app)\n\n        # setup i18n\n        self._setup_i18n(app)\n\n        if self._settings.getBoolean([\"serial\", \"log\"]):\n            # enable debug logging to serial.log\n            logging.getLogger(\"SERIAL\").setLevel(logging.DEBUG)\n\n        if self._settings.getBoolean([\"devel\", \"pluginTimings\"]):\n            # enable plugin timings log\n            logging.getLogger(\"PLUGIN_TIMINGS\").setLevel(logging.DEBUG)\n\n        # start the intermediary server\n        self._start_intermediary_server()\n\n        ### IMPORTANT!\n        ###\n        ### Best do not start any subprocesses until the intermediary server shuts down again or they MIGHT inherit the\n        ### open port and prevent us from firing up Tornado later.\n        ###\n        ### The intermediary server's socket should have the CLOSE_EXEC flag (or its equivalent) set where possible, but\n        ### we can only do that if fcntl is available or we are on Windows, so better safe than sorry.\n        ###\n        ### See also issues #2035 and #2090\n\n        systemCommandManager = system_command_manager()\n        printerProfileManager = PrinterProfileManager()\n        eventManager = self._event_manager\n\n        analysis_queue_factories = {\n            \"gcode\": octoprint.filemanager.analysis.GcodeAnalysisQueue\n        }\n        analysis_queue_hooks = pluginManager.get_hooks(\n            \"octoprint.filemanager.analysis.factory\"\n        )\n        for name, hook in analysis_queue_hooks.items():\n            try:\n                additional_factories = hook()\n                analysis_queue_factories.update(**additional_factories)\n            except Exception:\n                self._logger.exception(\n                    f\"Error while processing analysis queues from {name}\",\n                    extra={\"plugin\": name},\n                )\n        analysisQueue = octoprint.filemanager.analysis.AnalysisQueue(\n            analysis_queue_factories\n        )\n\n        slicingManager = octoprint.slicing.SlicingManager(\n            self._settings.getBaseFolder(\"slicingProfiles\"), printerProfileManager\n        )\n\n        storage_managers = {}\n        storage_managers[\n            octoprint.filemanager.FileDestinations.LOCAL\n        ] = octoprint.filemanager.storage.LocalFileStorage(\n            self._settings.getBaseFolder(\"uploads\"),\n            really_universal=self._settings.getBoolean(\n                [\"feature\", \"enforceReallyUniversalFilenames\"]\n            ),\n        )\n\n        fileManager = octoprint.filemanager.FileManager(\n            analysisQueue,\n            slicingManager,\n            printerProfileManager,\n            initial_storage_managers=storage_managers,\n        )\n        pluginLifecycleManager = LifecycleManager(pluginManager)\n        preemptiveCache = PreemptiveCache(\n            os.path.join(\n                self._settings.getBaseFolder(\"data\"), \"preemptive_cache_config.yaml\"\n            )\n        )\n\n        JsonEncoding.add_encoder(users.User, lambda obj: obj.as_dict())\n        JsonEncoding.add_encoder(groups.Group, lambda obj: obj.as_dict())\n        JsonEncoding.add_encoder(\n            permissions.OctoPrintPermission, lambda obj: obj.as_dict()\n        )\n\n        # start regular check if we are connected to the internet\n        def on_connectivity_change(old_value, new_value):\n            eventManager.fire(\n                events.Events.CONNECTIVITY_CHANGED,\n                payload={\"old\": old_value, \"new\": new_value},\n            )\n\n        connectivityChecker = self._connectivity_checker\n        environmentDetector = self._environment_detector\n\n        def on_settings_update(*args, **kwargs):\n            # make sure our connectivity checker runs with the latest settings\n            connectivityEnabled = self._settings.getBoolean(\n                [\"server\", \"onlineCheck\", \"enabled\"]\n            )\n            connectivityInterval = self._settings.getInt(\n                [\"server\", \"onlineCheck\", \"interval\"]\n            )\n            connectivityHost = self._settings.get([\"server\", \"onlineCheck\", \"host\"])\n            connectivityPort = self._settings.getInt([\"server\", \"onlineCheck\", \"port\"])\n            connectivityName = self._settings.get([\"server\", \"onlineCheck\", \"name\"])\n\n            if (\n                connectivityChecker.enabled != connectivityEnabled\n                or connectivityChecker.interval != connectivityInterval\n                or connectivityChecker.host != connectivityHost\n                or connectivityChecker.port != connectivityPort\n                or connectivityChecker.name != connectivityName\n            ):\n                connectivityChecker.enabled = connectivityEnabled\n                connectivityChecker.interval = connectivityInterval\n                connectivityChecker.host = connectivityHost\n                connectivityChecker.port = connectivityPort\n                connectivityChecker.name = connectivityName\n                connectivityChecker.check_immediately()\n\n        eventManager.subscribe(events.Events.SETTINGS_UPDATED, on_settings_update)\n\n        components = {\n            \"plugin_manager\": pluginManager,\n            \"printer_profile_manager\": printerProfileManager,\n            \"event_bus\": eventManager,\n            \"analysis_queue\": analysisQueue,\n            \"slicing_manager\": slicingManager,\n            \"file_manager\": fileManager,\n            \"plugin_lifecycle_manager\": pluginLifecycleManager,\n            \"preemptive_cache\": preemptiveCache,\n            \"json_encoder\": jsonEncoder,\n            \"json_decoder\": jsonDecoder,\n            \"connectivity_checker\": connectivityChecker,\n            \"environment_detector\": self._environment_detector,\n            \"system_commands\": systemCommandManager,\n        }\n\n        # ~~ setup access control\n\n        # get additional permissions from plugins\n        self._setup_plugin_permissions()\n\n        # create group manager instance\n        group_manager_factories = pluginManager.get_hooks(\n            \"octoprint.access.groups.factory\"\n        )\n        for name, factory in group_manager_factories.items():\n            try:\n                groupManager = factory(components, self._settings)\n                if groupManager is not None:\n                    self._logger.debug(\n                        f\"Created group manager instance from factory {name}\"\n                    )\n                    break\n            except Exception:\n                self._logger.exception(\n                    \"Error while creating group manager instance from factory {}\".format(\n                        name\n                    )\n                )\n        else:\n            group_manager_name = self._settings.get([\"accessControl\", \"groupManager\"])\n            try:\n                clazz = octoprint.util.get_class(group_manager_name)\n                groupManager = clazz()\n            except AttributeError:\n                self._logger.exception(\n                    \"Could not instantiate group manager {}, \"\n                    \"falling back to FilebasedGroupManager!\".format(group_manager_name)\n                )\n                groupManager = octoprint.access.groups.FilebasedGroupManager()\n        components.update({\"group_manager\": groupManager})\n\n        # create user manager instance\n        user_manager_factories = pluginManager.get_hooks(\n            \"octoprint.users.factory\"\n        )  # legacy, set first so that new wins\n        user_manager_factories.update(\n            pluginManager.get_hooks(\"octoprint.access.users.factory\")\n        )\n        for name, factory in user_manager_factories.items():\n            try:\n                userManager = factory(components, self._settings)\n                if userManager is not None:\n                    self._logger.debug(\n                        f\"Created user manager instance from factory {name}\"\n                    )\n                    break\n            except Exception:\n                self._logger.exception(\n                    \"Error while creating user manager instance from factory {}\".format(\n                        name\n                    ),\n                    extra={\"plugin\": name},\n                )\n        else:\n            user_manager_name = self._settings.get([\"accessControl\", \"userManager\"])\n            try:\n                clazz = octoprint.util.get_class(user_manager_name)\n                userManager = clazz(groupManager)\n            except octoprint.access.users.CorruptUserStorage:\n                raise\n            except Exception:\n                self._logger.exception(\n                    \"Could not instantiate user manager {}, \"\n                    \"falling back to FilebasedUserManager!\".format(user_manager_name)\n                )\n                userManager = octoprint.access.users.FilebasedUserManager(groupManager)\n        components.update({\"user_manager\": userManager})\n\n        # create printer instance\n        printer_factories = pluginManager.get_hooks(\"octoprint.printer.factory\")\n        for name, factory in printer_factories.items():\n            try:\n                printer = factory(components)\n                if printer is not None:\n                    self._logger.debug(f\"Created printer instance from factory {name}\")\n                    break\n            except Exception:\n                self._logger.exception(\n                    f\"Error while creating printer instance from factory {name}\",\n                    extra={\"plugin\": name},\n                )\n        else:\n            printer = Printer(fileManager, analysisQueue, printerProfileManager)\n        components.update({\"printer\": printer})\n\n        from octoprint import (\n            init_custom_events,\n            init_settings_plugin_config_migration_and_cleanup,\n        )\n        from octoprint import octoprint_plugin_inject_factory as opif\n        from octoprint import settings_plugin_inject_factory as spif\n\n        init_custom_events(pluginManager)\n\n        octoprint_plugin_inject_factory = opif(self._settings, components)\n        settings_plugin_inject_factory = spif(self._settings)\n\n        pluginManager.implementation_inject_factories = [\n            octoprint_plugin_inject_factory,\n            settings_plugin_inject_factory,\n        ]\n        pluginManager.initialize_implementations()\n\n        init_settings_plugin_config_migration_and_cleanup(pluginManager)\n\n        pluginManager.log_all_plugins()\n\n        # log environment data now\n        self._environment_detector.log_detected_environment()\n\n        # initialize file manager and register it for changes in the registered plugins\n        fileManager.initialize()\n        pluginLifecycleManager.add_callback(\n            [\"enabled\", \"disabled\"], lambda name, plugin: fileManager.reload_plugins()\n        )\n\n        # initialize slicing manager and register it for changes in the registered plugins\n        slicingManager.initialize()\n        pluginLifecycleManager.add_callback(\n            [\"enabled\", \"disabled\"], lambda name, plugin: slicingManager.reload_slicers()\n        )\n\n        # setup jinja2\n        self._setup_jinja2()\n\n        # setup assets\n        self._setup_assets()\n\n        # configure timelapse\n        octoprint.timelapse.valid_timelapse(\"test\")\n        octoprint.timelapse.configure_timelapse()\n\n        # setup command triggers\n        events.CommandTrigger(printer)\n        if self._debug:\n            events.DebugEventListener()\n\n        # setup login manager\n        self._setup_login_manager()\n\n        # register API blueprint\n        self._setup_blueprints()\n\n        ## Tornado initialization starts here\n\n        ioloop = IOLoop()\n        ioloop.install()\n\n        enable_cors = settings().getBoolean([\"api\", \"allowCrossOrigin\"])\n\n        self._router = SockJSRouter(\n            self._create_socket_connection,\n            \"/sockjs\",\n            session_kls=util.sockjs.ThreadSafeSession,\n            user_settings={\n                \"websocket_allow_origin\": \"*\" if enable_cors else \"\",\n                \"jsessionid\": False,\n                \"sockjs_url\": \"../../static/js/lib/sockjs.min.js\",\n            },\n        )\n\n        upload_suffixes = {\n            \"name\": self._settings.get([\"server\", \"uploads\", \"nameSuffix\"]),\n            \"path\": self._settings.get([\"server\", \"uploads\", \"pathSuffix\"]),\n        }\n\n        def mime_type_guesser(path):\n            from octoprint.filemanager import get_mime_type\n\n            return get_mime_type(path)\n\n        def download_name_generator(path):\n            metadata = fileManager.get_metadata(\"local\", path)\n            if metadata and \"display\" in metadata:\n                return metadata[\"display\"]\n\n        download_handler_kwargs = {\"as_attachment\": True, \"allow_client_caching\": False}\n\n        additional_mime_types = {\"mime_type_guesser\": mime_type_guesser}\n\n        ##~~ Permission validators\n\n        access_validators_from_plugins = []\n        for plugin, hook in pluginManager.get_hooks(\n            \"octoprint.server.http.access_validator\"\n        ).items():\n            try:\n                access_validators_from_plugins.append(\n                    util.tornado.access_validation_factory(app, hook)\n                )\n            except Exception:\n                self._logger.exception(\n                    \"Error while adding tornado access validator from plugin {}\".format(\n                        plugin\n                    ),\n                    extra={\"plugin\": plugin},\n                )\n\n        timelapse_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.TIMELAPSE_LIST,\n            ),\n        ] + access_validators_from_plugins\n        download_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.FILES_DOWNLOAD,\n            ),\n        ] + access_validators_from_plugins\n        log_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.PLUGIN_LOGGING_MANAGE,\n            ),\n        ] + access_validators_from_plugins\n        camera_validators = [\n            util.tornado.access_validation_factory(\n                app, util.flask.permission_validator, permissions.Permissions.WEBCAM\n            ),\n        ] + access_validators_from_plugins\n        systeminfo_validators = [\n            util.tornado.access_validation_factory(\n                app, util.flask.permission_validator, permissions.Permissions.SYSTEM\n            )\n        ] + access_validators_from_plugins\n\n        timelapse_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*timelapse_validators)\n        }\n        download_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*download_validators)\n        }\n        log_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*log_validators)\n        }\n        camera_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*camera_validators)\n        }\n        systeminfo_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*systeminfo_validators)\n        }\n\n        no_hidden_files_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: not octoprint.util.is_hidden_path(path), status_code=404\n            )\n        }\n\n        valid_timelapse = lambda path: not octoprint.util.is_hidden_path(path) and (\n            octoprint.timelapse.valid_timelapse(path)\n            or octoprint.timelapse.valid_timelapse_thumbnail(path)\n        )\n        timelapse_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                valid_timelapse,\n                status_code=404,\n            )\n        }\n        timelapses_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: valid_timelapse(path)\n                and os.path.realpath(os.path.abspath(path)).startswith(\n                    settings().getBaseFolder(\"timelapse\")\n                ),\n                status_code=400,\n            )\n        }\n\n        valid_log = lambda path: not octoprint.util.is_hidden_path(\n            path\n        ) and path.endswith(\".log\")\n        log_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                valid_log,\n                status_code=404,\n            )\n        }\n        logs_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: valid_log(path)\n                and os.path.realpath(os.path.abspath(path)).startswith(\n                    settings().getBaseFolder(\"logs\")\n                ),\n                status_code=400,\n            )\n        }\n\n        def joined_dict(*dicts):\n            if not len(dicts):\n                return {}\n\n            joined = {}\n            for d in dicts:\n                joined.update(d)\n            return joined\n\n        util.tornado.RequestlessExceptionLoggingMixin.LOG_REQUEST = debug\n        util.tornado.CorsSupportMixin.ENABLE_CORS = enable_cors\n\n        server_routes = self._router.urls + [\n            # various downloads\n            # .mpg and .mp4 timelapses:\n            (\n                r\"/downloads/timelapse/(.*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\"path\": self._settings.getBaseFolder(\"timelapse\")},\n                    timelapse_permission_validator,\n                    download_handler_kwargs,\n                    timelapse_path_validator,\n                ),\n            ),\n            # zipped timelapse bundles\n            (\n                r\"/downloads/timelapses\",\n                util.tornado.DynamicZipBundleHandler,\n                joined_dict(\n                    {\n                        \"as_attachment\": True,\n                        \"attachment_name\": \"octoprint-timelapses.zip\",\n                        \"path_processor\": lambda x: (\n                            x,\n                            os.path.join(self._settings.getBaseFolder(\"timelapse\"), x),\n                        ),\n                    },\n                    timelapse_permission_validator,\n                    timelapses_path_validator,\n                ),\n            ),\n            # uploaded printables\n            (\n                r\"/downloads/files/local/(.*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\n                        \"path\": self._settings.getBaseFolder(\"uploads\"),\n                        \"as_attachment\": True,\n                        \"name_generator\": download_name_generator,\n                    },\n                    download_permission_validator,\n                    download_handler_kwargs,\n                    no_hidden_files_validator,\n                    additional_mime_types,\n                ),\n            ),\n            # log files\n            (\n                r\"/downloads/logs/([^/]*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\n                        \"path\": self._settings.getBaseFolder(\"logs\"),\n                        \"mime_type_guesser\": lambda *args, **kwargs: \"text/plain\",\n                        \"stream_body\": True,\n                    },\n                    download_handler_kwargs,\n                    log_permission_validator,\n                    log_path_validator,\n                ),\n            ),\n            # zipped log file bundles\n            (\n                r\"/downloads/logs\",\n                util.tornado.DynamicZipBundleHandler,\n                joined_dict(\n                    {\n                        \"as_attachment\": True,\n                        \"attachment_name\": \"octoprint-logs.zip\",\n                        \"path_processor\": lambda x: (\n                            x,\n                            os.path.join(self._settings.getBaseFolder(\"logs\"), x),\n                        ),\n                    },\n                    log_permission_validator,\n                    logs_path_validator,\n                ),\n            ),\n            # system info bundle\n            (\n                r\"/downloads/systeminfo.zip\",\n                util.tornado.SystemInfoBundleHandler,\n                systeminfo_permission_validator,\n            ),\n            # camera snapshot\n            (\n                r\"/downloads/camera/current\",\n                util.tornado.UrlProxyHandler,\n                joined_dict(\n                    {\n                        \"url\": self._settings.get([\"webcam\", \"snapshot\"]),\n                        \"as_attachment\": True,\n                    },\n                    camera_permission_validator,\n                ),\n            ),\n            # generated webassets\n            (\n                r\"/static/webassets/(.*)\",\n                util.tornado.LargeResponseHandler,\n                {\n                    \"path\": os.path.join(\n                        self._settings.getBaseFolder(\"generated\"), \"webassets\"\n                    ),\n                    \"is_pre_compressed\": True,\n                },\n            ),\n            # online indicators - text file with \"online\" as content and a transparent gif\n            (r\"/online.txt\", util.tornado.StaticDataHandler, {\"data\": \"online\\n\"}),\n            (\n                r\"/online.gif\",\n                util.tornado.StaticDataHandler,\n                {\n                    \"data\": bytes(\n                        base64.b64decode(\n                            \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n                        )\n                    ),\n                    \"content_type\": \"image/gif\",\n                },\n            ),\n            # deprecated endpoints\n            (\n                r\"/api/logs\",\n                util.tornado.DeprecatedEndpointHandler,\n                {\"url\": \"/plugin/logging/logs\"},\n            ),\n            (\n                r\"/api/logs/(.*)\",\n                util.tornado.DeprecatedEndpointHandler,\n                {\"url\": \"/plugin/logging/logs/{0}\"},\n            ),\n        ]\n\n        # fetch additional routes from plugins\n        for name, hook in pluginManager.get_hooks(\"octoprint.server.http.routes\").items():\n            try:\n                result = hook(list(server_routes))\n            except Exception:\n                self._logger.exception(\n                    f\"There was an error while retrieving additional \"\n                    f\"server routes from plugin hook {name}\",\n                    extra={\"plugin\": name},\n                )\n            else:\n                if isinstance(result, (list, tuple)):\n                    for entry in result:\n                        if not isinstance(entry, tuple) or not len(entry) == 3:\n                            continue\n                        if not isinstance(entry[0], str):\n                            continue\n                        if not isinstance(entry[2], dict):\n                            continue\n\n                        route, handler, kwargs = entry\n                        route = r\"/plugin/{name}/{route}\".format(\n                            name=name,\n                            route=route if not route.startswith(\"/\") else route[1:],\n                        )\n\n                        self._logger.debug(\n                            f\"Adding additional route {route} handled by handler {handler} and with additional arguments {kwargs!r}\"\n                        )\n                        server_routes.append((route, handler, kwargs))\n\n        headers = {\n            \"X-Robots-Tag\": \"noindex, nofollow, noimageindex\",\n            \"X-Content-Type-Options\": \"nosniff\",\n        }\n        if not settings().getBoolean([\"server\", \"allowFraming\"]):\n            headers[\"X-Frame-Options\"] = \"sameorigin\"\n\n        removed_headers = [\"Server\"]\n\n        server_routes.append(\n            (\n                r\".*\",\n                util.tornado.UploadStorageFallbackHandler,\n                {\n                    \"fallback\": util.tornado.WsgiInputContainer(\n                        app.wsgi_app, headers=headers, removed_headers=removed_headers\n                    ),\n                    \"file_prefix\": \"octoprint-file-upload-\",\n                    \"file_suffix\": \".tmp\",\n                    \"suffixes\": upload_suffixes,\n                },\n            )\n        )\n\n        transforms = [\n            util.tornado.GlobalHeaderTransform.for_headers(\n                \"OctoPrintGlobalHeaderTransform\",\n                headers=headers,\n                removed_headers=removed_headers,\n            )\n        ]\n\n        self._tornado_app = Application(handlers=server_routes, transforms=transforms)\n        max_body_sizes = [\n            (\n                \"POST\",\n                r\"/api/files/([^/]*)\",\n                self._settings.getInt([\"server\", \"uploads\", \"maxSize\"]),\n            ),\n            (\"POST\", r\"/api/languages\", 5 * 1024 * 1024),\n        ]\n\n        # allow plugins to extend allowed maximum body sizes\n        for name, hook in pluginManager.get_hooks(\n            \"octoprint.server.http.bodysize\"\n        ).items():\n            try:\n                result = hook(list(max_body_sizes))\n            except Exception:\n                self._logger.exception(\n                    f\"There was an error while retrieving additional \"\n                    f\"upload sizes from plugin hook {name}\",\n                    extra={\"plugin\": name},\n                )\n            else:\n                if isinstance(result, (list, tuple)):\n                    for entry in result:\n                        if not isinstance(entry, tuple) or not len(entry) == 3:\n                            continue\n                        if (\n                            entry[0]\n                            not in util.tornado.UploadStorageFallbackHandler.BODY_METHODS\n                        ):\n                            continue\n                        if not isinstance(entry[2], int):\n                            continue\n\n                        method, route, size = entry\n                        route = r\"/plugin/{name}/{route}\".format(\n                            name=name,\n                            route=route if not route.startswith(\"/\") else route[1:],\n                        )\n\n                        self._logger.debug(\n                            f\"Adding maximum body size of {size}B for {method} requests to {route})\"\n                        )\n                        max_body_sizes.append((method, route, size))\n\n        self._stop_intermediary_server()\n\n        # initialize and bind the server\n        trusted_downstream = self._settings.get(\n            [\"server\", \"reverseProxy\", \"trustedDownstream\"]\n        )\n        if not isinstance(trusted_downstream, list):\n            self._logger.warning(\n                \"server.reverseProxy.trustedDownstream is not a list, skipping\"\n            )\n            trusted_downstream = []\n\n        server_kwargs = {\n            \"max_body_sizes\": max_body_sizes,\n            \"default_max_body_size\": self._settings.getInt([\"server\", \"maxSize\"]),\n            \"xheaders\": True,\n            \"trusted_downstream\": trusted_downstream,\n        }\n        if sys.platform == \"win32\":\n            # set 10min idle timeout under windows to hopefully make #2916 less likely\n            server_kwargs.update({\"idle_connection_timeout\": 600})\n\n        self._server = util.tornado.CustomHTTPServer(self._tornado_app, **server_kwargs)\n\n        listening_address = self._host\n        if self._host == \"::\" and not self._v6_only:\n            # special case - tornado only listens on v4 _and_ v6 if we use None as address\n            listening_address = None\n\n        self._server.listen(self._port, address=listening_address)\n\n        ### From now on it's ok to launch subprocesses again\n\n        eventManager.fire(events.Events.STARTUP)\n\n        # analysis backlog\n        fileManager.process_backlog()\n\n        # auto connect\n        if self._settings.getBoolean([\"serial\", \"autoconnect\"]):\n            self._logger.info(\n                \"Autoconnect on startup is configured, trying to connect to the printer...\"\n            )\n            try:\n                (port, baudrate) = (\n                    self._settings.get([\"serial\", \"port\"]),\n                    self._settings.getInt([\"serial\", \"baudrate\"]),\n                )\n                printer_profile = printerProfileManager.get_default()\n                connectionOptions = printer.__class__.get_connection_options()\n                if port in connectionOptions[\"ports\"] or port == \"AUTO\" or port is None:\n                    self._logger.info(\n                        f\"Trying to connect to configured serial port {port}\"\n                    )\n                    printer.connect(\n                        port=port,\n                        baudrate=baudrate,\n                        profile=printer_profile[\"id\"]\n                        if \"id\" in printer_profile\n                        else \"_default\",\n                    )\n                else:\n                    self._logger.info(\n                        \"Could not find configured serial port {} in the system, cannot automatically connect to a non existing printer. Is it plugged in and booted up yet?\"\n                    )\n            except Exception:\n                self._logger.exception(\n                    \"Something went wrong while attempting to automatically connect to the printer\"\n                )\n\n        # start up watchdogs\n        try:\n            watched = self._settings.getBaseFolder(\"watched\")\n            watchdog_handler = util.watchdog.GcodeWatchdogHandler(fileManager, printer)\n            watchdog_handler.initial_scan(watched)\n\n            if self._settings.getBoolean([\"feature\", \"pollWatched\"]):\n                # use less performant polling observer if explicitly configured\n                observer = PollingObserver()\n            else:\n                # use os default\n                observer = Observer()\n\n            observer.schedule(watchdog_handler, watched, recursive=True)\n            observer.start()\n        except Exception:\n            self._logger.exception(\"Error starting watched folder observer\")\n\n        # run our startup plugins\n        octoprint.plugin.call_plugin(\n            octoprint.plugin.StartupPlugin,\n            \"on_startup\",\n            args=(self._host, self._port),\n            sorting_context=\"StartupPlugin.on_startup\",\n        )\n\n        def call_on_startup(name, plugin):\n            implementation = plugin.get_implementation(octoprint.plugin.StartupPlugin)\n            if implementation is None:\n                return\n            implementation.on_startup(self._host, self._port)\n\n        pluginLifecycleManager.add_callback(\"enabled\", call_on_startup)\n\n        # prepare our after startup function\n        def on_after_startup():\n            if self._host == \"::\":\n                if self._v6_only:\n                    # only v6\n                    self._logger.info(f\"Listening on http://[::]:{self._port}\")\n                else:\n                    # all v4 and v6\n                    self._logger.info(\n                        \"Listening on http://0.0.0.0:{port} and http://[::]:{port}\".format(\n                            port=self._port\n                        )\n                    )\n            else:\n                self._logger.info(\n                    \"Listening on http://{}:{}\".format(\n                        self._host if \":\" not in self._host else \"[\" + self._host + \"]\",\n                        self._port,\n                    )\n                )\n\n            if safe_mode and self._settings.getBoolean([\"server\", \"startOnceInSafeMode\"]):\n                self._logger.info(\n                    \"Server started successfully in safe mode as requested from config, removing flag\"\n                )\n                self._settings.setBoolean([\"server\", \"startOnceInSafeMode\"], False)\n                self._settings.save()\n\n            # now this is somewhat ugly, but the issue is the following: startup plugins might want to do things for\n            # which they need the server to be already alive (e.g. for being able to resolve urls, such as favicons\n            # or service xmls or the like). While they are working though the ioloop would block. Therefore we'll\n            # create a single use thread in which to perform our after-startup-tasks, start that and hand back\n            # control to the ioloop\n            def work():\n                octoprint.plugin.call_plugin(\n                    octoprint.plugin.StartupPlugin,\n                    \"on_after_startup\",\n                    sorting_context=\"StartupPlugin.on_after_startup\",\n                )\n\n                def call_on_after_startup(name, plugin):\n                    implementation = plugin.get_implementation(\n                        octoprint.plugin.StartupPlugin\n                    )\n                    if implementation is None:\n                        return\n                    implementation.on_after_startup()\n\n                pluginLifecycleManager.add_callback(\"enabled\", call_on_after_startup)\n\n                # if there was a rogue plugin we wouldn't even have made it here, so remove startup triggered safe mode\n                # flag again...\n                self._settings.setBoolean([\"server\", \"incompleteStartup\"], False)\n                self._settings.save()\n\n                # make a backup of the current config\n                self._settings.backup(ext=\"backup\")\n\n                # when we are through with that we also run our preemptive cache\n                if settings().getBoolean([\"devel\", \"cache\", \"preemptive\"]):\n                    self._execute_preemptive_flask_caching(preemptiveCache)\n\n            import threading\n\n            threading.Thread(target=work).start()\n\n        ioloop.add_callback(on_after_startup)\n\n        # prepare our shutdown function\n        def on_shutdown():\n            # will be called on clean system exit and shutdown the watchdog observer and call the on_shutdown methods\n            # on all registered ShutdownPlugins\n            self._logger.info(\"Shutting down...\")\n            observer.stop()\n            observer.join()\n            eventManager.fire(events.Events.SHUTDOWN)\n\n            self._logger.info(\"Calling on_shutdown on plugins\")\n            octoprint.plugin.call_plugin(\n                octoprint.plugin.ShutdownPlugin,\n                \"on_shutdown\",\n                sorting_context=\"ShutdownPlugin.on_shutdown\",\n            )\n\n            # wait for shutdown event to be processed, but maximally for 15s\n            event_timeout = 15.0\n            if eventManager.join(timeout=event_timeout):\n                self._logger.warning(\n                    \"Event loop was still busy processing after {}s, shutting down anyhow\".format(\n                        event_timeout\n                    )\n                )\n\n            if self._octoprint_daemon is not None:\n                self._logger.info(\"Cleaning up daemon pidfile\")\n                self._octoprint_daemon.terminated()\n\n            self._logger.info(\"Goodbye!\")\n\n        atexit.register(on_shutdown)\n\n        def sigterm_handler(*args, **kwargs):\n            # will stop tornado on SIGTERM, making the program exit cleanly\n            def shutdown_tornado():\n                self._logger.debug(\"Shutting down tornado's IOLoop...\")\n                ioloop.stop()\n\n            self._logger.debug(\"SIGTERM received...\")\n            ioloop.add_callback_from_signal(shutdown_tornado)\n\n        signal.signal(signal.SIGTERM, sigterm_handler)\n\n        try:\n            # this is the main loop - as long as tornado is running, OctoPrint is running\n            ioloop.start()\n            self._logger.debug(\"Tornado's IOLoop stopped\")\n        except (KeyboardInterrupt, SystemExit):\n            pass\n        except Exception:\n            self._logger.fatal(\n                \"Now that is embarrassing... Something really really went wrong here. Please report this including the stacktrace below in OctoPrint's bugtracker. Thanks!\"\n            )\n            self._logger.exception(\"Stacktrace follows:\")\n\n    def _log_safe_mode_start(self, self_mode):\n        self_mode_file = os.path.join(\n            self._settings.getBaseFolder(\"data\"), \"last_safe_mode\"\n        )\n        try:\n            with open(self_mode_file, \"w+\", encoding=\"utf-8\") as f:\n                f.write(self_mode)\n        except Exception as ex:\n            self._logger.warn(f\"Could not write safe mode file {self_mode_file}: {ex}\")\n\n    def _create_socket_connection(self, session):\n        global printer, fileManager, analysisQueue, userManager, eventManager, connectivityChecker\n        return util.sockjs.PrinterStateConnection(\n            printer,\n            fileManager,\n            analysisQueue,\n            userManager,\n            groupManager,\n            eventManager,\n            pluginManager,\n            connectivityChecker,\n            session,\n        )\n\n    def _check_for_root(self):\n        if \"geteuid\" in dir(os) and os.geteuid() == 0:\n            exit(\"You should not run OctoPrint as root!\")\n\n    def _get_locale(self):\n        global LANGUAGES\n\n        if \"l10n\" in request.values:\n            return Locale.negotiate([request.values[\"l10n\"]], LANGUAGES)\n\n        if \"X-Locale\" in request.headers:\n            return Locale.negotiate([request.headers[\"X-Locale\"]], LANGUAGES)\n\n        if hasattr(g, \"identity\") and g.identity:\n            userid = g.identity.id\n            try:\n                user_language = userManager.get_user_setting(\n                    userid, (\"interface\", \"language\")\n                )\n                if user_language is not None and not user_language == \"_default\":\n                    return Locale.negotiate([user_language], LANGUAGES)\n            except octoprint.access.users.UnknownUser:\n                pass\n\n        default_language = self._settings.get([\"appearance\", \"defaultLanguage\"])\n        if (\n            default_language is not None\n            and not default_language == \"_default\"\n            and default_language in LANGUAGES\n        ):\n            return Locale.negotiate([default_language], LANGUAGES)\n\n        return Locale.parse(request.accept_languages.best_match(LANGUAGES))\n\n    def _setup_heartbeat_logging(self):\n        logger = logging.getLogger(__name__ + \".heartbeat\")\n\n        def log_heartbeat():\n            logger.info(\"Server heartbeat <3\")\n\n        interval = settings().getFloat([\"server\", \"heartbeat\"])\n        logger.info(f\"Starting server heartbeat, {interval}s interval\")\n\n        timer = octoprint.util.RepeatedTimer(interval, log_heartbeat)\n        timer.start()\n\n    def _setup_app(self, app):\n        from octoprint.server.util.flask import (\n            OctoPrintFlaskRequest,\n            OctoPrintFlaskResponse,\n            OctoPrintJsonEncoder,\n            OctoPrintSessionInterface,\n            PrefixAwareJinjaEnvironment,\n            ReverseProxiedEnvironment,\n        )\n\n        # we must set this here because setting app.debug will access app.jinja_env\n        app.jinja_environment = PrefixAwareJinjaEnvironment\n\n        app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n        app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] = False\n        app.config[\"REMEMBER_COOKIE_HTTPONLY\"] = True\n\n        # we must not set this before TEMPLATES_AUTO_RELOAD is set to True or that won't take\n        app.debug = self._debug\n\n        # setup octoprint's flask json serialization/deserialization\n        app.json_encoder = OctoPrintJsonEncoder\n\n        s = settings()\n\n        secret_key = s.get([\"server\", \"secretKey\"])\n        if not secret_key:\n            import string\n            from random import choice\n\n            chars = string.ascii_lowercase + string.ascii_uppercase + string.digits\n            secret_key = \"\".join(choice(chars) for _ in range(32))\n            s.set([\"server\", \"secretKey\"], secret_key)\n            s.save()\n\n        app.secret_key = secret_key\n\n        reverse_proxied = ReverseProxiedEnvironment(\n            header_prefix=s.get([\"server\", \"reverseProxy\", \"prefixHeader\"]),\n            header_scheme=s.get([\"server\", \"reverseProxy\", \"schemeHeader\"]),\n            header_host=s.get([\"server\", \"reverseProxy\", \"hostHeader\"]),\n            header_server=s.get([\"server\", \"reverseProxy\", \"serverHeader\"]),\n            header_port=s.get([\"server\", \"reverseProxy\", \"portHeader\"]),\n            prefix=s.get([\"server\", \"reverseProxy\", \"prefixFallback\"]),\n            scheme=s.get([\"server\", \"reverseProxy\", \"schemeFallback\"]),\n            host=s.get([\"server\", \"reverseProxy\", \"hostFallback\"]),\n            server=s.get([\"server\", \"reverseProxy\", \"serverFallback\"]),\n            port=s.get([\"server\", \"reverseProxy\", \"portFallback\"]),\n        )\n\n        OctoPrintFlaskRequest.environment_wrapper = reverse_proxied\n        app.request_class = OctoPrintFlaskRequest\n        app.response_class = OctoPrintFlaskResponse\n        app.session_interface = OctoPrintSessionInterface()\n\n        @app.before_request\n        def before_request():\n            g.locale = self._get_locale()\n\n            # used for performance measurement\n            g.start_time = time.monotonic()\n\n            if self._debug and \"perfprofile\" in request.args:\n                try:\n                    from pyinstrument import Profiler\n\n                    g.perfprofiler = Profiler()\n                    g.perfprofiler.start()\n                except ImportError:\n                    # profiler dependency not installed, ignore\n                    pass\n\n        @app.after_request\n        def after_request(response):\n            # send no-cache headers with all POST responses\n            if request.method == \"POST\":\n                response.cache_control.no_cache = True\n\n            response.headers.add(\"X-Clacks-Overhead\", \"GNU Terry Pratchett\")\n\n            if hasattr(g, \"perfprofiler\"):\n                g.perfprofiler.stop()\n                output_html = g.perfprofiler.output_html()\n                return make_response(output_html)\n\n            if hasattr(g, \"start_time\"):\n                end_time = time.monotonic()\n                duration_ms = int((end_time - g.start_time) * 1000)\n                response.headers.add(\"Server-Timing\", f\"app;dur={duration_ms}\")\n\n            return response\n\n        from octoprint.util.jinja import MarkdownFilter\n\n        MarkdownFilter(app)\n\n    def _setup_i18n(self, app):\n        global babel\n        global LOCALES\n        global LANGUAGES\n\n        babel = Babel(app)\n\n        def get_available_locale_identifiers(locales):\n            result = set()\n\n            # add available translations\n            for locale in locales:\n                result.add(locale.language)\n                if locale.territory:\n                    # if a territory is specified, add that too\n                    result.add(f\"{locale.language}_{locale.territory}\")\n\n            return result\n\n        LOCALES = babel.list_translations()\n        LANGUAGES = get_available_locale_identifiers(LOCALES)\n\n        @babel.localeselector\n        def get_locale():\n            return self._get_locale()\n\n    def _setup_jinja2(self):\n        import re\n\n        app.jinja_env.add_extension(\"jinja2.ext.do\")\n        app.jinja_env.add_extension(\"octoprint.util.jinja.trycatch\")\n\n        def regex_replace(s, find, replace):\n            return re.sub(find, replace, s)\n\n        html_header_regex = re.compile(\n            r\"<h(?P<number>[1-6])>(?P<content>.*?)</h(?P=number)>\"\n        )\n\n        def offset_html_headers(s, offset):\n            def repl(match):\n                number = int(match.group(\"number\"))\n                number += offset\n                if number > 6:\n                    number = 6\n                elif number < 1:\n                    number = 1\n                return \"<h{number}>{content}</h{number}>\".format(\n                    number=number, content=match.group(\"content\")\n                )\n\n            return html_header_regex.sub(repl, s)\n\n        markdown_header_regex = re.compile(\n            r\"^(?P<hashes>#+)\\s+(?P<content>.*)$\", flags=re.MULTILINE\n        )\n\n        def offset_markdown_headers(s, offset):\n            def repl(match):\n                number = len(match.group(\"hashes\"))\n                number += offset\n                if number > 6:\n                    number = 6\n                elif number < 1:\n                    number = 1\n                return \"{hashes} {content}\".format(\n                    hashes=\"#\" * number, content=match.group(\"content\")\n                )\n\n            return markdown_header_regex.sub(repl, s)\n\n        html_link_regex = re.compile(r\"<(?P<tag>a.*?)>(?P<content>.*?)</a>\")\n\n        def externalize_links(text):\n            def repl(match):\n                tag = match.group(\"tag\")\n                if \"href\" not in tag:\n                    return match.group(0)\n\n                if \"target=\" not in tag and \"rel=\" not in tag:\n                    tag += ' target=\"_blank\" rel=\"noreferrer noopener\"'\n\n                content = match.group(\"content\")\n                return f\"<{tag}>{content}</a>\"\n\n            return html_link_regex.sub(repl, text)\n\n        single_quote_regex = re.compile(\"(?<!\\\\\\\\)'\")\n\n        def escape_single_quote(text):\n            return single_quote_regex.sub(\"\\\\'\", text)\n\n        double_quote_regex = re.compile('(?<!\\\\\\\\)\"')\n\n        def escape_double_quote(text):\n            return double_quote_regex.sub('\\\\\"', text)\n\n        app.jinja_env.filters[\"regex_replace\"] = regex_replace\n        app.jinja_env.filters[\"offset_html_headers\"] = offset_html_headers\n        app.jinja_env.filters[\"offset_markdown_headers\"] = offset_markdown_headers\n        app.jinja_env.filters[\"externalize_links\"] = externalize_links\n        app.jinja_env.filters[\"escape_single_quote\"] = app.jinja_env.filters[\n            \"esq\"\n        ] = escape_single_quote\n        app.jinja_env.filters[\"escape_double_quote\"] = app.jinja_env.filters[\n            \"edq\"\n        ] = escape_double_quote\n\n        # configure additional template folders for jinja2\n        import jinja2\n\n        import octoprint.util.jinja\n\n        app.jinja_env.prefix_loader = jinja2.PrefixLoader({})\n\n        loaders = [app.jinja_loader, app.jinja_env.prefix_loader]\n        if octoprint.util.is_running_from_source():\n            root = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../..\"))\n            allowed = [\"AUTHORS.md\", \"SUPPORTERS.md\", \"THIRDPARTYLICENSES.md\"]\n            files = {\"_data/\" + name: os.path.join(root, name) for name in allowed}\n            loaders.append(octoprint.util.jinja.SelectedFilesWithConversionLoader(files))\n\n        # TODO: Remove this in 2.0.0\n        warning_message = \"Loading plugin template '{template}' from '{filename}' without plugin prefix, this is deprecated and will soon no longer be supported.\"\n        loaders.append(\n            octoprint.util.jinja.WarningLoader(\n                octoprint.util.jinja.PrefixChoiceLoader(app.jinja_env.prefix_loader),\n                warning_message,\n            )\n        )\n\n        app.jinja_loader = jinja2.ChoiceLoader(loaders)\n\n        self._register_template_plugins()\n\n        # make sure plugin lifecycle events relevant for jinja2 are taken care of\n        def template_enabled(name, plugin):\n            if plugin.implementation is None or not isinstance(\n                plugin.implementation, octoprint.plugin.TemplatePlugin\n            ):\n                return\n            self._register_additional_template_plugin(plugin.implementation)\n\n        def template_disabled(name, plugin):\n            if plugin.implementation is None or not isinstance(\n                plugin.implementation, octoprint.plugin.TemplatePlugin\n            ):\n                return\n            self._unregister_additional_template_plugin(plugin.implementation)\n\n        pluginLifecycleManager.add_callback(\"enabled\", template_enabled)\n        pluginLifecycleManager.add_callback(\"disabled\", template_disabled)\n\n    def _execute_preemptive_flask_caching(self, preemptive_cache):\n        import time\n\n        from werkzeug.test import EnvironBuilder\n\n        # we clean up entries from our preemptive cache settings that haven't been\n        # accessed longer than server.preemptiveCache.until days\n        preemptive_cache_timeout = settings().getInt(\n            [\"server\", \"preemptiveCache\", \"until\"]\n        )\n        cutoff_timestamp = time.time() - preemptive_cache_timeout * 24 * 60 * 60\n\n        def filter_current_entries(entry):\n            \"\"\"Returns True for entries younger than the cutoff date\"\"\"\n            return \"_timestamp\" in entry and entry[\"_timestamp\"] > cutoff_timestamp\n\n        def filter_http_entries(entry):\n            \"\"\"Returns True for entries targeting http or https.\"\"\"\n            return (\n                \"base_url\" in entry\n                and entry[\"base_url\"]\n                and (\n                    entry[\"base_url\"].startswith(\"http://\")\n                    or entry[\"base_url\"].startswith(\"https://\")\n                )\n            )\n\n        def filter_entries(entry):\n            \"\"\"Combined filter.\"\"\"\n            filters = (filter_current_entries, filter_http_entries)\n            return all([f(entry) for f in filters])\n\n        # filter out all old and non-http entries\n        cache_data = preemptive_cache.clean_all_data(\n            lambda root, entries: list(filter(filter_entries, entries))\n        )\n        if not cache_data:\n            return\n\n        def execute_caching():\n            logger = logging.getLogger(__name__ + \".preemptive_cache\")\n\n            for route in sorted(cache_data.keys(), key=lambda x: (x.count(\"/\"), x)):\n                entries = reversed(\n                    sorted(cache_data[route], key=lambda x: x.get(\"_count\", 0))\n                )\n                for kwargs in entries:\n                    plugin = kwargs.get(\"plugin\", None)\n                    if plugin:\n                        try:\n                            plugin_info = pluginManager.get_plugin_info(\n                                plugin, require_enabled=True\n                            )\n                            if plugin_info is None:\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it is not installed or enabled, preemptive caching makes no sense\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n\n                            implementation = plugin_info.implementation\n                            if implementation is None or not isinstance(\n                                implementation, octoprint.plugin.UiPlugin\n                            ):\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it is not a UiPlugin, preemptive caching makes no sense\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n                            if not implementation.get_ui_preemptive_caching_enabled():\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it has disabled preemptive caching\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n                        except Exception:\n                            logger.exception(\n                                \"Error while trying to check if plugin {} has preemptive caching enabled, skipping entry\"\n                            )\n                            continue\n\n                    additional_request_data = kwargs.get(\"_additional_request_data\", {})\n                    kwargs = {\n                        k: v\n                        for k, v in kwargs.items()\n                        if not k.startswith(\"_\") and not k == \"plugin\"\n                    }\n                    kwargs.update(additional_request_data)\n\n                    try:\n                        start = time.monotonic()\n                        if plugin:\n                            logger.info(\n                                \"Preemptively caching {} (ui {}) for {!r}\".format(\n                                    route, plugin, kwargs\n                                )\n                            )\n                        else:\n                            logger.info(\n                                \"Preemptively caching {} (ui _default) for {!r}\".format(\n                                    route, kwargs\n                                )\n                            )\n\n                        headers = kwargs.get(\"headers\", {})\n                        headers[\"X-Force-View\"] = plugin if plugin else \"_default\"\n                        headers[\"X-Preemptive-Recording\"] = \"yes\"\n                        kwargs[\"headers\"] = headers\n\n                        builder = EnvironBuilder(**kwargs)\n                        app(builder.get_environ(), lambda *a, **kw: None)\n\n                        logger.info(f\"... done in {time.monotonic() - start:.2f}s\")\n                    except Exception:\n                        logger.exception(\n                            \"Error while trying to preemptively cache {} for {!r}\".format(\n                                route, kwargs\n                            )\n                        )\n\n        # asynchronous caching\n        import threading\n\n        cache_thread = threading.Thread(\n            target=execute_caching, name=\"Preemptive Cache Worker\"\n        )\n        cache_thread.daemon = True\n        cache_thread.start()\n\n    def _register_template_plugins(self):\n        template_plugins = pluginManager.get_implementations(\n            octoprint.plugin.TemplatePlugin\n        )\n        for plugin in template_plugins:\n            try:\n                self._register_additional_template_plugin(plugin)\n            except Exception:\n                self._logger.exception(\n                    \"Error while trying to register templates of plugin {}, ignoring it\".format(\n                        plugin._identifier\n                    )\n                )\n\n    def _register_additional_template_plugin(self, plugin):\n        import octoprint.util.jinja\n\n        folder = plugin.get_template_folder()\n        if (\n            folder is not None\n            and plugin.template_folder_key not in app.jinja_env.prefix_loader.mapping\n        ):\n            loader = octoprint.util.jinja.FilteredFileSystemLoader(\n                [plugin.get_template_folder()],\n                path_filter=lambda x: not octoprint.util.is_hidden_path(x),\n            )\n\n            app.jinja_env.prefix_loader.mapping[plugin.template_folder_key] = loader\n\n    def _unregister_additional_template_plugin(self, plugin):\n        folder = plugin.get_template_folder()\n        if (\n            folder is not None\n            and plugin.template_folder_key in app.jinja_env.prefix_loader.mapping\n        ):\n            del app.jinja_env.prefix_loader.mapping[plugin.template_folder_key]\n\n    def _setup_blueprints(self):\n        # do not remove or the index view won't be found\n        import octoprint.server.views  # noqa: F401\n        from octoprint.server.api import api\n        from octoprint.server.util.flask import make_api_error\n\n        blueprints = [api]\n        api_endpoints = [\"/api\"]\n        registrators = [functools.partial(app.register_blueprint, api, url_prefix=\"/api\")]\n\n        # also register any blueprints defined in BlueprintPlugins\n        (\n            blueprints_from_plugins,\n            api_endpoints_from_plugins,\n            registrators_from_plugins,\n        ) = self._prepare_blueprint_plugins()\n        blueprints += blueprints_from_plugins\n        api_endpoints += api_endpoints_from_plugins\n        registrators += registrators_from_plugins\n\n        # and register a blueprint for serving the static files of asset plugins which are not blueprint plugins themselves\n        (blueprints_from_assets, registrators_from_assets) = self._prepare_asset_plugins()\n        blueprints += blueprints_from_assets\n        registrators += registrators_from_assets\n\n        # make sure all before/after_request hook results are attached as well\n        self._add_plugin_request_handlers_to_blueprints(*blueprints)\n\n        # register everything with the system\n        for registrator in registrators:\n            registrator()\n\n        @app.errorhandler(HTTPException)\n        def _handle_api_error(ex):\n            if any(map(lambda x: request.path.startswith(x), api_endpoints)):\n                return make_api_error(ex.description, ex.code)\n            else:\n                return ex\n\n    def _prepare_blueprint_plugins(self):\n        def register_plugin_blueprint(plugin, blueprint, url_prefix):\n            try:\n                app.register_blueprint(\n                    blueprint, url_prefix=url_prefix, name_prefix=\"plugin\"\n                )\n                self._logger.debug(\n                    f\"Registered API of plugin {plugin} under URL prefix {url_prefix}\"\n                )\n            except Exception:\n                self._logger.exception(\n                    f\"Error while registering blueprint of plugin {plugin}, ignoring it\",\n                    extra={\"plugin\": plugin},\n                )\n\n        blueprints = []\n        api_endpoints = []\n        registrators = []\n\n        blueprint_plugins = octoprint.plugin.plugin_manager().get_implementations(\n            octoprint.plugin.BlueprintPlugin\n        )\n        for plugin in blueprint_plugins:\n            blueprint, prefix = self._prepare_blueprint_plugin(plugin)\n\n            blueprints.append(blueprint)\n            api_endpoints += map(\n                lambda x: prefix + x, plugin.get_blueprint_api_prefixes()\n            )\n            registrators.append(\n                functools.partial(\n                    register_plugin_blueprint, plugin._identifier, blueprint, prefix\n                )\n            )\n\n        return blueprints, api_endpoints, registrators\n\n    def _prepare_asset_plugins(self):\n        def register_asset_blueprint(plugin, blueprint, url_prefix):\n            try:\n                app.register_blueprint(\n                    blueprint, url_prefix=url_prefix, name_prefix=\"plugin\"\n                )\n                self._logger.debug(\n                    f\"Registered assets of plugin {plugin} under URL prefix {url_prefix}\"\n                )\n            except Exception:\n                self._logger.exception(\n                    f\"Error while registering blueprint of plugin {plugin}, ignoring it\",\n                    extra={\"plugin\": plugin},\n                )\n\n        blueprints = []\n        registrators = []\n\n        asset_plugins = octoprint.plugin.plugin_manager().get_implementations(\n            octoprint.plugin.AssetPlugin\n        )\n        for plugin in asset_plugins:\n            if isinstance(plugin, octoprint.plugin.BlueprintPlugin):\n                continue\n            blueprint, prefix = self._prepare_asset_plugin(plugin)\n\n            blueprints.append(blueprint)\n            registrators.append(\n                functools.partial(\n                    register_asset_blueprint, plugin._identifier, blueprint, prefix\n                )\n            )\n\n        return blueprints, registrators\n\n    def _prepare_blueprint_plugin(self, plugin):\n        name = plugin._identifier\n        blueprint = plugin.get_blueprint()\n        if blueprint is None:\n            return\n\n        blueprint.before_request(corsRequestHandler)\n        blueprint.before_request(loginFromApiKeyRequestHandler)\n        blueprint.after_request(corsResponseHandler)\n\n        if plugin.is_blueprint_protected():\n            blueprint.before_request(requireLoginRequestHandler)\n\n        url_prefix = f\"/plugin/{name}\"\n        return blueprint, url_prefix\n\n    def _prepare_asset_plugin(self, plugin):\n        name = plugin._identifier\n\n        url_prefix = f\"/plugin/{name}\"\n        blueprint = Blueprint(name, name, static_folder=plugin.get_asset_folder())\n        return blueprint, url_prefix\n\n    def _add_plugin_request_handlers_to_blueprints(self, *blueprints):\n        before_hooks = octoprint.plugin.plugin_manager().get_hooks(\n            \"octoprint.server.api.before_request\"\n        )\n        after_hooks = octoprint.plugin.plugin_manager().get_hooks(\n            \"octoprint.server.api.after_request\"\n        )\n\n        for name, hook in before_hooks.items():\n            plugin = octoprint.plugin.plugin_manager().get_plugin(name)\n            for blueprint in blueprints:\n                try:\n                    result = hook(plugin=plugin)\n                    if isinstance(result, (list, tuple)):\n                        for h in result:\n                            blueprint.before_request(h)\n                except Exception:\n                    self._logger.exception(\n                        \"Error processing before_request hooks from plugin {}\".format(\n                            plugin\n                        ),\n                        extra={\"plugin\": name},\n                    )\n\n        for name, hook in after_hooks.items():\n            plugin = octoprint.plugin.plugin_manager().get_plugin(name)\n            for blueprint in blueprints:\n                try:\n                    result = hook(plugin=plugin)\n                    if isinstance(result, (list, tuple)):\n                        for h in result:\n                            blueprint.after_request(h)\n                except Exception:\n                    self._logger.exception(\n                        \"Error processing after_request hooks from plugin {}\".format(\n                            plugin\n                        ),\n                        extra={\"plugin\": name},\n                    )\n\n    def _setup_mimetypes(self):\n        # Safety measures for Windows... apparently the mimetypes module takes its translation from the windows\n        # registry, and if for some weird reason that gets borked the reported MIME types can be all over the place.\n        # Since at least in Chrome that can cause hilarious issues with JS files (refusal to run them and thus a\n        # borked UI) we make sure that .js always maps to the correct application/javascript, and also throw in a\n        # .css -> text/css for good measure.\n        #\n        # See #3367\n        mimetypes.add_type(\"application/javascript\", \".js\")\n        mimetypes.add_type(\"text/css\", \".css\")\n\n    def _setup_assets(self):\n        global app\n        global assets\n        global pluginManager\n\n        from octoprint.server.util.webassets import MemoryManifest  # noqa: F401\n\n        util.flask.fix_webassets_filtertool()\n\n        base_folder = self._settings.getBaseFolder(\"generated\")\n\n        # clean the folder\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"clean_on_startup\"]):\n            import errno\n            import shutil\n\n            for entry, recreate in (\n                (\"webassets\", True),\n                # no longer used, but clean up just in case\n                (\".webassets-cache\", False),\n                (\".webassets-manifest.json\", False),\n            ):\n                path = os.path.join(base_folder, entry)\n\n                # delete path if it exists\n                if os.path.exists(path):\n                    try:\n                        self._logger.debug(f\"Deleting {path}...\")\n                        if os.path.isdir(path):\n                            shutil.rmtree(path)\n                        else:\n                            os.remove(path)\n                    except Exception:\n                        self._logger.exception(\n                            f\"Error while trying to delete {path}, \" f\"leaving it alone\"\n                        )\n                        continue\n\n                # re-create path if necessary\n                if recreate:\n                    self._logger.debug(f\"Creating {path}...\")\n                    error_text = (\n                        f\"Error while trying to re-create {path}, that might cause \"\n                        f\"errors with the webassets cache\"\n                    )\n                    try:\n                        os.makedirs(path)\n                    except OSError as e:\n                        if e.errno == errno.EACCES:\n                            # that might be caused by the user still having the folder open somewhere, let's try again after\n                            # waiting a bit\n                            import time\n\n                            for n in range(3):\n                                time.sleep(0.5)\n                                self._logger.debug(\n                                    \"Creating {path}: Retry #{retry} after {time}s\".format(\n                                        path=path, retry=n + 1, time=(n + 1) * 0.5\n                                    )\n                                )\n                                try:\n                                    os.makedirs(path)\n                                    break\n                                except Exception:\n                                    if self._logger.isEnabledFor(logging.DEBUG):\n                                        self._logger.exception(\n                                            f\"Ignored error while creating \"\n                                            f\"directory {path}\"\n                                        )\n                                    pass\n                            else:\n                                # this will only get executed if we never did\n                                # successfully execute makedirs above\n                                self._logger.exception(error_text)\n                                continue\n                        else:\n                            # not an access error, so something we don't understand\n                            # went wrong -> log an error and stop\n                            self._logger.exception(error_text)\n                            continue\n                    except Exception:\n                        # not an OSError, so something we don't understand\n                        # went wrong -> log an error and stop\n                        self._logger.exception(error_text)\n                        continue\n\n                self._logger.info(f\"Reset webasset folder {path}...\")\n\n        AdjustedEnvironment = type(Environment)(\n            Environment.__name__,\n            (Environment,),\n            {\"resolver_class\": util.flask.PluginAssetResolver},\n        )\n\n        class CustomDirectoryEnvironment(AdjustedEnvironment):\n            @property\n            def directory(self):\n                return base_folder\n\n        assets = CustomDirectoryEnvironment(app)\n        assets.debug = not self._settings.getBoolean([\"devel\", \"webassets\", \"bundle\"])\n\n        # we should rarely if ever regenerate the webassets in production and can wait a\n        # few seconds for regeneration in development, if it means we can get rid of\n        # a whole monkey patch and in internal use of pickle with non-tamperproof files\n        assets.cache = False\n        assets.manifest = \"memory\"\n\n        UpdaterType = type(util.flask.SettingsCheckUpdater)(\n            util.flask.SettingsCheckUpdater.__name__,\n            (util.flask.SettingsCheckUpdater,),\n            {\"updater\": assets.updater},\n        )\n        assets.updater = UpdaterType\n\n        preferred_stylesheet = self._settings.get([\"devel\", \"stylesheet\"])\n\n        dynamic_core_assets = util.flask.collect_core_assets()\n        dynamic_plugin_assets = util.flask.collect_plugin_assets(\n            preferred_stylesheet=preferred_stylesheet\n        )\n\n        js_libs = [\n            \"js/lib/babel-polyfill.min.js\",\n            \"js/lib/jquery/jquery.min.js\",\n            \"js/lib/modernizr.custom.js\",\n            \"js/lib/lodash.min.js\",\n            \"js/lib/sprintf.min.js\",\n            \"js/lib/knockout.js\",\n            \"js/lib/knockout.mapping-latest.js\",\n            \"js/lib/babel.js\",\n            \"js/lib/bootstrap/bootstrap.js\",\n            \"js/lib/bootstrap/bootstrap-modalmanager.js\",\n            \"js/lib/bootstrap/bootstrap-modal.js\",\n            \"js/lib/bootstrap/bootstrap-slider.js\",\n            \"js/lib/bootstrap/bootstrap-tabdrop.js\",\n            \"js/lib/jquery/jquery-ui.js\",\n            \"js/lib/jquery/jquery.flot.js\",\n            \"js/lib/jquery/jquery.flot.time.js\",\n            \"js/lib/jquery/jquery.flot.crosshair.js\",\n            \"js/lib/jquery/jquery.flot.resize.js\",\n            \"js/lib/jquery/jquery.iframe-transport.js\",\n            \"js/lib/jquery/jquery.fileupload.js\",\n            \"js/lib/jquery/jquery.slimscroll.min.js\",\n            \"js/lib/jquery/jquery.qrcode.min.js\",\n            \"js/lib/jquery/jquery.bootstrap.wizard.js\",\n            \"js/lib/pnotify/pnotify.core.min.js\",\n            \"js/lib/pnotify/pnotify.buttons.min.js\",\n            \"js/lib/pnotify/pnotify.callbacks.min.js\",\n            \"js/lib/pnotify/pnotify.confirm.min.js\",\n            \"js/lib/pnotify/pnotify.desktop.min.js\",\n            \"js/lib/pnotify/pnotify.history.min.js\",\n            \"js/lib/pnotify/pnotify.mobile.min.js\",\n            \"js/lib/pnotify/pnotify.nonblock.min.js\",\n            \"js/lib/pnotify/pnotify.reference.min.js\",\n            \"js/lib/pnotify/pnotify.tooltip.min.js\",\n            \"js/lib/pnotify/pnotify.maxheight.js\",\n            \"js/lib/moment-with-locales.min.js\",\n            \"js/lib/pusher.color.min.js\",\n            \"js/lib/detectmobilebrowser.js\",\n            \"js/lib/ua-parser.min.js\",\n            \"js/lib/md5.min.js\",\n            \"js/lib/bootstrap-slider-knockout-binding.js\",\n            \"js/lib/loglevel.min.js\",\n            \"js/lib/sockjs.min.js\",\n            \"js/lib/hls.js\",\n            \"js/lib/less.js\",\n        ]\n\n        css_libs = [\n            \"css/bootstrap.min.css\",\n            \"css/bootstrap-modal.css\",\n            \"css/bootstrap-slider.css\",\n            \"css/bootstrap-tabdrop.css\",\n            \"vendor/font-awesome-3.2.1/css/font-awesome.min.css\",\n            \"vendor/fontawesome-6.1.1/css/all.min.css\",\n            \"vendor/fontawesome-6.1.1/css/v4-shims.min.css\",\n            \"css/jquery.fileupload-ui.css\",\n            \"css/pnotify.core.min.css\",\n            \"css/pnotify.buttons.min.css\",\n            \"css/pnotify.history.min.css\",\n        ]\n\n        # a couple of custom filters\n        from webassets.filter import register_filter\n\n        from octoprint.server.util.webassets import (\n            GzipFile,\n            JsDelimiterBundler,\n            JsPluginBundle,\n            LessImportRewrite,\n            RJSMinExtended,\n            SourceMapRemove,\n            SourceMapRewrite,\n        )\n\n        register_filter(LessImportRewrite)\n        register_filter(SourceMapRewrite)\n        register_filter(SourceMapRemove)\n        register_filter(JsDelimiterBundler)\n        register_filter(GzipFile)\n        register_filter(RJSMinExtended)\n\n        def all_assets_for_plugins(collection):\n            \"\"\"Gets all plugin assets for a dict of plugin->assets\"\"\"\n            result = []\n            for assets in collection.values():\n                result += assets\n            return result\n\n        # -- JS --------------------------------------------------------------------------------------------------------\n\n        filters = [\"sourcemap_remove\"]\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"minify\"]):\n            filters += [\"rjsmin_extended\"]\n        filters += [\"js_delimiter_bundler\", \"gzip\"]\n\n        js_filters = filters\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"minify_plugins\"]):\n            js_plugin_filters = js_filters\n        else:\n            js_plugin_filters = [x for x in js_filters if x not in (\"rjsmin_extended\",)]\n\n        def js_bundles_for_plugins(collection, filters=None):\n            \"\"\"Produces JsPluginBundle instances that output IIFE wrapped assets\"\"\"\n            result = OrderedDict()\n            for plugin, assets in collection.items():\n                if len(assets):\n                    result[plugin] = JsPluginBundle(plugin, *assets, filters=filters)\n            return result\n\n        js_core = (\n            dynamic_core_assets[\"js\"]\n            + all_assets_for_plugins(dynamic_plugin_assets[\"bundled\"][\"js\"])\n            + [\"js/app/dataupdater.js\", \"js/app/helpers.js\", \"js/app/main.js\"]\n        )\n        js_plugins = js_bundles_for_plugins(\n            dynamic_plugin_assets[\"external\"][\"js\"], filters=\"js_delimiter_bundler\"\n        )\n\n        clientjs_core = dynamic_core_assets[\"clientjs\"] + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"clientjs\"]\n        )\n        clientjs_plugins = js_bundles_for_plugins(\n            dynamic_plugin_assets[\"external\"][\"clientjs\"], filters=\"js_delimiter_bundler\"\n        )\n\n        js_libs_bundle = Bundle(\n            *js_libs, output=\"webassets/packed_libs.js\", filters=\",\".join(js_filters)\n        )\n\n        js_core_bundle = Bundle(\n            *js_core, output=\"webassets/packed_core.js\", filters=\",\".join(js_filters)\n        )\n\n        if len(js_plugins) == 0:\n            js_plugins_bundle = Bundle(*[])\n        else:\n            js_plugins_bundle = Bundle(\n                *js_plugins.values(),\n                output=\"webassets/packed_plugins.js\",\n                filters=\",\".join(js_plugin_filters),\n            )\n\n        js_app_bundle = Bundle(\n            js_plugins_bundle,\n            js_core_bundle,\n            output=\"webassets/packed_app.js\",\n            filters=\",\".join(js_plugin_filters),\n        )\n\n        js_client_core_bundle = Bundle(\n            *clientjs_core,\n            output=\"webassets/packed_client_core.js\",\n            filters=\",\".join(js_filters),\n        )\n\n        if len(clientjs_plugins) == 0:\n            js_client_plugins_bundle = Bundle(*[])\n        else:\n            js_client_plugins_bundle = Bundle(\n                *clientjs_plugins.values(),\n                output=\"webassets/packed_client_plugins.js\",\n                filters=\",\".join(js_plugin_filters),\n            )\n\n        js_client_bundle = Bundle(\n            js_client_core_bundle,\n            js_client_plugins_bundle,\n            output=\"webassets/packed_client.js\",\n            filters=\",\".join(js_plugin_filters),\n        )\n\n        # -- CSS -------------------------------------------------------------------------------------------------------\n\n        css_filters = [\"cssrewrite\", \"gzip\"]\n\n        css_core = list(dynamic_core_assets[\"css\"]) + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"css\"]\n        )\n        css_plugins = list(\n            all_assets_for_plugins(dynamic_plugin_assets[\"external\"][\"css\"])\n        )\n\n        css_libs_bundle = Bundle(\n            *css_libs, output=\"webassets/packed_libs.css\", filters=\",\".join(css_filters)\n        )\n\n        if len(css_core) == 0:\n            css_core_bundle = Bundle(*[])\n        else:\n            css_core_bundle = Bundle(\n                *css_core,\n                output=\"webassets/packed_core.css\",\n                filters=\",\".join(css_filters),\n            )\n\n        if len(css_plugins) == 0:\n            css_plugins_bundle = Bundle(*[])\n        else:\n            css_plugins_bundle = Bundle(\n                *css_plugins,\n                output=\"webassets/packed_plugins.css\",\n                filters=\",\".join(css_filters),\n            )\n\n        css_app_bundle = Bundle(\n            css_core,\n            css_plugins,\n            output=\"webassets/packed_app.css\",\n            filters=\",\".join(css_filters),\n        )\n\n        # -- LESS ------------------------------------------------------------------------------------------------------\n\n        less_filters = [\"cssrewrite\", \"less_importrewrite\", \"gzip\"]\n\n        less_core = list(dynamic_core_assets[\"less\"]) + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"less\"]\n        )\n        less_plugins = all_assets_for_plugins(dynamic_plugin_assets[\"external\"][\"less\"])\n\n        if len(less_core) == 0:\n            less_core_bundle = Bundle(*[])\n        else:\n            less_core_bundle = Bundle(\n                *less_core,\n                output=\"webassets/packed_core.less\",\n                filters=\",\".join(less_filters),\n            )\n\n        if len(less_plugins) == 0:\n            less_plugins_bundle = Bundle(*[])\n        else:\n            less_plugins_bundle = Bundle(\n                *less_plugins,\n                output=\"webassets/packed_plugins.less\",\n                filters=\",\".join(less_filters),\n            )\n\n        less_app_bundle = Bundle(\n            less_core,\n            less_plugins,\n            output=\"webassets/packed_app.less\",\n            filters=\",\".join(less_filters),\n        )\n\n        # -- asset registration ----------------------------------------------------------------------------------------\n\n        assets.register(\"js_libs\", js_libs_bundle)\n        assets.register(\"js_client_core\", js_client_core_bundle)\n        for plugin, bundle in clientjs_plugins.items():\n            # register our collected clientjs plugin bundles so that they are bound to the environment\n            assets.register(f\"js_client_plugin_{plugin}\", bundle)\n        assets.register(\"js_client_plugins\", js_client_plugins_bundle)\n        assets.register(\"js_client\", js_client_bundle)\n        assets.register(\"js_core\", js_core_bundle)\n        for plugin, bundle in js_plugins.items():\n            # register our collected plugin bundles so that they are bound to the environment\n            assets.register(f\"js_plugin_{plugin}\", bundle)\n        assets.register(\"js_plugins\", js_plugins_bundle)\n        assets.register(\"js_app\", js_app_bundle)\n        assets.register(\"css_libs\", css_libs_bundle)\n        assets.register(\"css_core\", css_core_bundle)\n        assets.register(\"css_plugins\", css_plugins_bundle)\n        assets.register(\"css_app\", css_app_bundle)\n        assets.register(\"less_core\", less_core_bundle)\n        assets.register(\"less_plugins\", less_plugins_bundle)\n        assets.register(\"less_app\", less_app_bundle)\n\n    def _setup_login_manager(self):\n        global loginManager\n\n        loginManager = LoginManager()\n\n        # \"strong\" is incompatible to remember me, see maxcountryman/flask-login#156. It also causes issues with\n        # clients toggling between IPv4 and IPv6 client addresses due to names being resolved one way or the other as\n        # at least observed on a Win10 client targeting \"localhost\", resolved as both \"127.0.0.1\" and \"::1\"\n        loginManager.session_protection = \"basic\"\n\n        loginManager.user_loader(load_user)\n        loginManager.unauthorized_handler(unauthorized_user)\n        loginManager.anonymous_user = userManager.anonymous_user_factory\n        loginManager.request_loader(load_user_from_request)\n\n        loginManager.init_app(app, add_context_processor=False)\n\n    def _start_intermediary_server(self):\n        import socket\n        import threading\n        from http.server import BaseHTTPRequestHandler, HTTPServer\n\n        host = self._host\n        port = self._port\n\n        class IntermediaryServerHandler(BaseHTTPRequestHandler):\n            def __init__(self, rules=None, *args, **kwargs):\n                if rules is None:\n                    rules = []\n                self.rules = rules\n                BaseHTTPRequestHandler.__init__(self, *args, **kwargs)\n\n            def do_GET(self):\n                request_path = self.path\n                if \"?\" in request_path:\n                    request_path = request_path[0 : request_path.find(\"?\")]\n\n                for rule in self.rules:\n                    path, data, content_type = rule\n                    if request_path == path:\n                        self.send_response(200)\n                        if content_type:\n                            self.send_header(\"Content-Type\", content_type)\n                        self.end_headers()\n                        if isinstance(data, str):\n                            data = data.encode(\"utf-8\")\n                        self.wfile.write(data)\n                        break\n                else:\n                    self.send_response(404)\n                    self.wfile.write(b\"Not found\")\n\n        base_path = os.path.realpath(\n            os.path.join(os.path.dirname(__file__), \"..\", \"static\")\n        )\n        rules = [\n            (\n                \"/\",\n                [\n                    \"intermediary.html\",\n                ],\n                \"text/html\",\n            ),\n            (\"/favicon.ico\", [\"img\", \"tentacle-20x20.png\"], \"image/png\"),\n            (\n                \"/intermediary.gif\",\n                bytes(\n                    base64.b64decode(\n                        \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n                    )\n                ),\n                \"image/gif\",\n            ),\n        ]\n\n        def contents(args):\n            path = os.path.join(base_path, *args)\n            if not os.path.isfile(path):\n                return \"\"\n\n            with open(path, \"rb\") as f:\n                data = f.read()\n            return data\n\n        def process(rule):\n            if len(rule) == 2:\n                path, data = rule\n                content_type = None\n            else:\n                path, data, content_type = rule\n\n            if isinstance(data, (list, tuple)):\n                data = contents(data)\n\n            return path, data, content_type\n\n        rules = list(\n            map(process, filter(lambda rule: len(rule) == 2 or len(rule) == 3, rules))\n        )\n\n        HTTPServerV4 = HTTPServer\n\n        class HTTPServerV6(HTTPServer):\n            address_family = socket.AF_INET6\n\n        class HTTPServerV6SingleStack(HTTPServerV6):\n            def __init__(self, *args, **kwargs):\n                HTTPServerV6.__init__(self, *args, **kwargs)\n\n                # explicitly set V6ONLY flag - seems to be the default, but just to make sure...\n                self.socket.setsockopt(\n                    octoprint.util.net.IPPROTO_IPV6, octoprint.util.net.IPV6_V6ONLY, 1\n                )\n\n        class HTTPServerV6DualStack(HTTPServerV6):\n            def __init__(self, *args, **kwargs):\n                HTTPServerV6.__init__(self, *args, **kwargs)\n\n                # explicitly unset V6ONLY flag\n                self.socket.setsockopt(\n                    octoprint.util.net.IPPROTO_IPV6, octoprint.util.net.IPV6_V6ONLY, 0\n                )\n\n        if \":\" in host:\n            # v6\n            if host == \"::\" and not self._v6_only:\n                ServerClass = HTTPServerV6DualStack\n            else:\n                ServerClass = HTTPServerV6SingleStack\n        else:\n            # v4\n            ServerClass = HTTPServerV4\n\n        if host == \"::\":\n            if self._v6_only:\n                self._logger.debug(f\"Starting intermediary server on http://[::]:{port}\")\n            else:\n                self._logger.debug(\n                    \"Starting intermediary server on http://0.0.0.0:{port} and http://[::]:{port}\".format(\n                        port=port\n                    )\n                )\n        else:\n            self._logger.debug(\n                \"Starting intermediary server on http://{}:{}\".format(\n                    host if \":\" not in host else \"[\" + host + \"]\", port\n                )\n            )\n\n        self._intermediary_server = ServerClass(\n            (host, port),\n            lambda *args, **kwargs: IntermediaryServerHandler(rules, *args, **kwargs),\n            bind_and_activate=False,\n        )\n\n        # if possible, make sure our socket's port descriptor isn't handed over to subprocesses\n        from octoprint.util.platform import set_close_exec\n\n        try:\n            set_close_exec(self._intermediary_server.fileno())\n        except Exception:\n            self._logger.exception(\n                \"Error while attempting to set_close_exec on intermediary server socket\"\n            )\n\n        # then bind the server and have it serve our handler until stopped\n        try:\n            self._intermediary_server.server_bind()\n            self._intermediary_server.server_activate()\n        except Exception as exc:\n            self._intermediary_server.server_close()\n\n            if isinstance(exc, UnicodeDecodeError) and sys.platform == \"win32\":\n                # we end up here if the hostname contains non-ASCII characters due to\n                # https://bugs.python.org/issue26227 - tell the user they need\n                # to either change their hostname or read up other options in\n                # https://github.com/OctoPrint/OctoPrint/issues/3963\n                raise CannotStartServerException(\n                    \"OctoPrint cannot start due to a Python bug \"\n                    \"(https://bugs.python.org/issue26227). Your \"\n                    \"computer's host name contains non-ASCII characters. \"\n                    \"Please either change your computer's host name to \"\n                    \"contain only ASCII characters, or take a look at \"\n                    \"https://github.com/OctoPrint/OctoPrint/issues/3963 for \"\n                    \"other options.\"\n                )\n            else:\n                raise\n\n        def serve():\n            try:\n                self._intermediary_server.serve_forever()\n            except Exception:\n                self._logger.exception(\"Error in intermediary server\")\n\n        thread = threading.Thread(target=serve)\n        thread.daemon = True\n        thread.start()\n\n        self._logger.info(\"Intermediary server started\")\n\n    def _stop_intermediary_server(self):\n        if self._intermediary_server is None:\n            return\n        self._logger.info(\"Shutting down intermediary server...\")\n        self._intermediary_server.shutdown()\n        self._intermediary_server.server_close()\n        self._logger.info(\"Intermediary server shut down\")\n\n    def _setup_plugin_permissions(self):\n        global pluginManager\n\n        from octoprint.access.permissions import PluginOctoPrintPermission\n\n        key_whitelist = re.compile(r\"[A-Za-z0-9_]*\")\n\n        def permission_key(plugin, definition):\n            return \"PLUGIN_{}_{}\".format(plugin.upper(), definition[\"key\"].upper())\n\n        def permission_name(plugin, definition):\n            return \"{}: {}\".format(plugin, definition[\"name\"])\n\n        def permission_role(plugin, role):\n            return f\"plugin_{plugin}_{role}\"\n\n        def process_regular_permission(plugin_info, definition):\n            permissions = []\n            for key in definition.get(\"permissions\", []):\n                permission = octoprint.access.permissions.Permissions.find(key)\n\n                if permission is None:\n                    # if there is still no permission found, postpone this - maybe it is a permission from\n                    # another plugin that hasn't been loaded yet\n                    return False\n\n                permissions.append(permission)\n\n            roles = definition.get(\"roles\", [])\n            description = definition.get(\"description\", \"\")\n            dangerous = definition.get(\"dangerous\", False)\n            default_groups = definition.get(\"default_groups\", [])\n\n            roles_and_permissions = [\n                permission_role(plugin_info.key, role) for role in roles\n            ] + permissions\n\n            key = permission_key(plugin_info.key, definition)\n            permission = PluginOctoPrintPermission(\n                permission_name(plugin_info.name, definition),\n                description,\n                plugin=plugin_info.key,\n                dangerous=dangerous,\n                default_groups=default_groups,\n                *roles_and_permissions,\n            )\n            setattr(\n                octoprint.access.permissions.Permissions,\n                key,\n                PluginOctoPrintPermission(\n                    permission_name(plugin_info.name, definition),\n                    description,\n                    plugin=plugin_info.key,\n                    dangerous=dangerous,\n                    default_groups=default_groups,\n                    *roles_and_permissions,\n                ),\n            )\n\n            self._logger.info(\n                \"Added new permission from plugin {}: {} (needs: {!r})\".format(\n                    plugin_info.key, key, \", \".join(map(repr, permission.needs))\n                )\n            )\n            return True\n\n        postponed = []\n\n        hooks = pluginManager.get_hooks(\"octoprint.access.permissions\")\n        for name, factory in hooks.items():\n            try:\n                if isinstance(factory, (tuple, list)):\n                    additional_permissions = list(factory)\n                elif callable(factory):\n                    additional_permissions = factory()\n                else:\n                    raise ValueError(\"factory must be either a callable, tuple or list\")\n\n                if not isinstance(additional_permissions, (tuple, list)):\n                    raise ValueError(\n                        \"factory result must be either a tuple or a list of permission definition dicts\"\n                    )\n\n                plugin_info = pluginManager.get_plugin_info(name)\n                for p in additional_permissions:\n                    if not isinstance(p, dict):\n                        continue\n\n                    if \"key\" not in p or \"name\" not in p:\n                        continue\n\n                    if not key_whitelist.match(p[\"key\"]):\n                        self._logger.warning(\n                            \"Got permission with invalid key from plugin {}: {}\".format(\n                                name, p[\"key\"]\n                            )\n                        )\n                        continue\n\n                    if not process_regular_permission(plugin_info, p):\n                        postponed.append((plugin_info, p))\n            except Exception:\n                self._logger.exception(\n                    f\"Error while creating permission instance/s from {name}\"\n                )\n\n        # final resolution passes\n        pass_number = 1\n        still_postponed = []\n        while len(postponed):\n            start_length = len(postponed)\n            self._logger.debug(\n                \"Plugin permission resolution pass #{}, \"\n                \"{} unresolved permissions...\".format(pass_number, start_length)\n            )\n\n            for plugin_info, definition in postponed:\n                if not process_regular_permission(plugin_info, definition):\n                    still_postponed.append((plugin_info, definition))\n\n            self._logger.debug(\n                \"... pass #{} done, {} permissions left to resolve\".format(\n                    pass_number, len(still_postponed)\n                )\n            )\n\n            if len(still_postponed) == start_length:\n                # no change, looks like some stuff is unresolvable - let's bail\n                for plugin_info, definition in still_postponed:\n                    self._logger.warning(\n                        \"Unable to resolve permission from {}: {!r}\".format(\n                            plugin_info.key, definition\n                        )\n                    )\n                break\n\n            postponed = still_postponed\n            still_postponed = []\n            pass_number += 1\n\n\nclass LifecycleManager:\n    def __init__(self, plugin_manager):\n        self._plugin_manager = plugin_manager\n\n        self._plugin_lifecycle_callbacks = defaultdict(list)\n        self._logger = logging.getLogger(__name__)\n\n        def wrap_plugin_event(lifecycle_event, new_handler):\n            orig_handler = getattr(self._plugin_manager, \"on_plugin_\" + lifecycle_event)\n\n            def handler(*args, **kwargs):\n                if callable(orig_handler):\n                    orig_handler(*args, **kwargs)\n                if callable(new_handler):\n                    new_handler(*args, **kwargs)\n\n            return handler\n\n        def on_plugin_event_factory(lifecycle_event):\n            def on_plugin_event(name, plugin):\n                self.on_plugin_event(lifecycle_event, name, plugin)\n\n            return on_plugin_event\n\n        for event in (\"loaded\", \"unloaded\", \"enabled\", \"disabled\"):\n            wrap_plugin_event(event, on_plugin_event_factory(event))\n\n    def on_plugin_event(self, event, name, plugin):\n        for lifecycle_callback in self._plugin_lifecycle_callbacks[event]:\n            lifecycle_callback(name, plugin)\n\n    def add_callback(self, events, callback):\n        if isinstance(events, str):\n            events = [events]\n\n        for event in events:\n            self._plugin_lifecycle_callbacks[event].append(callback)\n\n    def remove_callback(self, callback, events=None):\n        if events is None:\n            for event in self._plugin_lifecycle_callbacks:\n                if callback in self._plugin_lifecycle_callbacks[event]:\n                    self._plugin_lifecycle_callbacks[event].remove(callback)\n        else:\n            if isinstance(events, str):\n                events = [events]\n\n            for event in events:\n                if callback in self._plugin_lifecycle_callbacks[event]:\n                    self._plugin_lifecycle_callbacks[event].remove(callback)\n\n\nclass CannotStartServerException(Exception):\n    pass\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport logging\n\nfrom flask import (\n    Blueprint,\n    Response,\n    abort,\n    current_app,\n    g,\n    jsonify,\n    make_response,\n    request,\n    session,\n)\nfrom flask_login import current_user, login_user, logout_user\nfrom werkzeug.exceptions import HTTPException\n\nimport octoprint.access.users\nimport octoprint.plugin\nimport octoprint.server\nimport octoprint.util.net as util_net\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.events import Events, eventManager\nfrom octoprint.server import NO_CONTENT\nfrom octoprint.server.util import (\n    corsRequestHandler,\n    corsResponseHandler,\n    loginFromApiKeyRequestHandler,\n    loginFromAuthorizationHeaderRequestHandler,\n    noCachingExceptGetResponseHandler,\n)\nfrom octoprint.server.util.flask import (\n    get_json_command_from_request,\n    get_remote_address,\n    no_firstrun_access,\n    passive_login,\n)\nfrom octoprint.settings import settings as s\nfrom octoprint.settings import valid_boolean_trues\nfrom octoprint.vendor.flask_principal import Identity, identity_changed\n\n# ~~ init api blueprint, including sub modules\n\napi = Blueprint(\"api\", __name__)\n\nfrom . import access as api_access  # noqa: F401,E402\nfrom . import connection as api_connection  # noqa: F401,E402\nfrom . import files as api_files  # noqa: F401,E402\nfrom . import job as api_job  # noqa: F401,E402\nfrom . import languages as api_languages  # noqa: F401,E402\nfrom . import printer as api_printer  # noqa: F401,E402\nfrom . import printer_profiles as api_printer_profiles  # noqa: F401,E402\nfrom . import settings as api_settings  # noqa: F401,E402\nfrom . import slicing as api_slicing  # noqa: F401,E402\nfrom . import system as api_system  # noqa: F401,E402\nfrom . import timelapse as api_timelapse  # noqa: F401,E402\nfrom . import users as api_users  # noqa: F401,E402\n\nVERSION = \"0.1\"\n\napi.after_request(noCachingExceptGetResponseHandler)\n\napi.before_request(corsRequestHandler)\napi.before_request(loginFromAuthorizationHeaderRequestHandler)\napi.before_request(loginFromApiKeyRequestHandler)\napi.after_request(corsResponseHandler)\n\n# ~~ data from plugins\n\n\n@api.route(\"/plugin/<string:name>\", methods=[\"GET\"])\ndef pluginData(name):\n    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(\n        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin\n    )\n    if not api_plugins:\n        abort(404)\n\n    if len(api_plugins) > 1:\n        abort(500, description=\"More than one api provider registered, can't proceed\")\n\n    try:\n        api_plugin = api_plugins[0]\n        if api_plugin.is_api_adminonly() and not current_user.is_admin:\n            abort(403)\n\n        response = api_plugin.on_api_get(request)\n\n        if response is not None:\n            message = (\n                \"Rewriting response from {} to use abort(msg, code) - please \"\n                \"consider upgrading the implementation accordingly\".format(name)\n            )\n            if (\n                isinstance(response, Response)\n                and response.mimetype == \"text/html\"\n                and response.status_code >= 300\n            ):\n                # this actually looks like an error response\n                logging.getLogger(__name__).info(message)\n                abort(response.status_code, description=response.data)\n            elif (\n                isinstance(response, tuple)\n                and len(response) == 2\n                and isinstance(response[0], (str, bytes))\n                and response[1] >= 300\n            ):\n                # this actually looks like an error response\n                logging.getLogger(__name__).info(message)\n                abort(response[1], response[0])\n            return response\n        return NO_CONTENT\n    except HTTPException:\n        raise\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error calling SimpleApiPlugin {name}\", extra={\"plugin\": name}\n        )\n        return abort(500)\n\n\n# ~~ commands for plugins\n\n\n@api.route(\"/plugin/<string:name>\", methods=[\"POST\"])\n@no_firstrun_access\ndef pluginCommand(name):\n    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(\n        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin\n    )\n\n    if not api_plugins:\n        abort(400)\n\n    if len(api_plugins) > 1:\n        abort(500, description=\"More than one api provider registered, can't proceed\")\n\n    api_plugin = api_plugins[0]\n    try:\n        valid_commands = api_plugin.get_api_commands()\n        if valid_commands is None:\n            abort(405)\n\n        if api_plugin.is_api_adminonly() and not Permissions.ADMIN.can():\n            abort(403)\n\n        command, data, response = get_json_command_from_request(request, valid_commands)\n        if response is not None:\n            return response\n\n        response = api_plugin.on_api_command(command, data)\n        if response is not None:\n            return response\n        return NO_CONTENT\n    except HTTPException:\n        raise\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error while executing SimpleApiPlugin {name}\",\n            extra={\"plugin\": name},\n        )\n        return abort(500)\n\n\n# ~~ first run setup\n\n\n@api.route(\"/setup/wizard\", methods=[\"GET\"])\ndef wizardState():\n    if (\n        not s().getBoolean([\"server\", \"firstRun\"])\n        and octoprint.server.userManager.has_been_customized()\n        and not Permissions.ADMIN.can()\n    ):\n        abort(403)\n\n    seen_wizards = s().get([\"server\", \"seenWizards\"])\n\n    result = {}\n    wizard_plugins = octoprint.server.pluginManager.get_implementations(\n        octoprint.plugin.WizardPlugin\n    )\n    for implementation in wizard_plugins:\n        name = implementation._identifier\n        try:\n            required = implementation.is_wizard_required()\n            details = implementation.get_wizard_details()\n            version = implementation.get_wizard_version()\n            ignored = octoprint.plugin.WizardPlugin.is_wizard_ignored(\n                seen_wizards, implementation\n            )\n        except Exception:\n            logging.getLogger(__name__).exception(\n                \"There was an error fetching wizard \"\n                \"details for {}, ignoring\".format(name),\n                extra={\"plugin\": name},\n            )\n        else:\n            result[name] = {\n                \"required\": required,\n                \"details\": details,\n                \"version\": version,\n                \"ignored\": ignored,\n            }\n\n    return jsonify(result)\n\n\n@api.route(\"/setup/wizard\", methods=[\"POST\"])\ndef wizardFinish():\n    if (\n        not s().getBoolean([\"server\", \"firstRun\"])\n        and octoprint.server.userManager.has_been_customized()\n        and not Permissions.ADMIN.can()\n    ):\n        abort(403)\n\n    data = {}\n    try:\n        data = request.get_json()\n    except Exception:\n        abort(400)\n\n    if data is None:\n        abort(400)\n\n    if \"handled\" not in data:\n        abort(400)\n    handled = data[\"handled\"]\n\n    if s().getBoolean([\"server\", \"firstRun\"]):\n        s().setBoolean([\"server\", \"firstRun\"], False)\n\n    seen_wizards = dict(s().get([\"server\", \"seenWizards\"]))\n\n    wizard_plugins = octoprint.server.pluginManager.get_implementations(\n        octoprint.plugin.WizardPlugin\n    )\n    for implementation in wizard_plugins:\n        name = implementation._identifier\n        try:\n            implementation.on_wizard_finish(name in handled)\n            if name in handled:\n                seen_wizards[name] = implementation.get_wizard_version()\n        except Exception:\n            logging.getLogger(__name__).exception(\n                \"There was an error finishing the \"\n                \"wizard for {}, ignoring\".format(name),\n                extra={\"plugin\": name},\n            )\n\n    s().set([\"server\", \"seenWizards\"], seen_wizards)\n    s().save()\n\n    return NO_CONTENT\n\n\n# ~~ system state\n\n\n@api.route(\"/version\", methods=[\"GET\"])\n@Permissions.STATUS.require(403)\ndef apiVersion():\n    return jsonify(\n        server=octoprint.server.VERSION,\n        api=VERSION,\n        text=f\"OctoPrint {octoprint.server.DISPLAY_VERSION}\",\n    )\n\n\n@api.route(\"/server\", methods=[\"GET\"])\n@Permissions.STATUS.require(403)\ndef serverStatus():\n    return jsonify(version=octoprint.server.VERSION, safemode=octoprint.server.safe_mode)\n\n\n# ~~ Login/user handling\n\n\n@api.route(\"/login\", methods=[\"POST\"])\ndef login():\n    data = request.get_json()\n    if not data:\n        data = request.values\n\n    if \"user\" in data and \"pass\" in data:\n        username = data[\"user\"]\n        password = data[\"pass\"]\n\n        if \"remember\" in data and data[\"remember\"] in valid_boolean_trues:\n            remember = True\n        else:\n            remember = False\n\n        if \"usersession.id\" in session:\n            _logout(current_user)\n\n        user = octoprint.server.userManager.find_user(username)\n        if user is not None:\n            if octoprint.server.userManager.check_password(username, password):\n                if not user.is_active:\n                    abort(403)\n\n                user = octoprint.server.userManager.login_user(user)\n                session[\"usersession.id\"] = user.session\n                g.user = user\n\n                login_user(user, remember=remember)\n                identity_changed.send(\n                    current_app._get_current_object(), identity=Identity(user.get_id())\n                )\n                session[\"login_mechanism\"] = \"http\"\n\n                remote_addr = get_remote_address(request)\n                logging.getLogger(__name__).info(\n                    \"Actively logging in user {} from {}\".format(\n                        user.get_id(), remote_addr\n                    )\n                )\n\n                response = user.as_dict()\n                response[\"_is_external_client\"] = s().getBoolean(\n                    [\"server\", \"ipCheck\", \"enabled\"]\n                ) and not util_net.is_lan_address(\n                    remote_addr,\n                    additional_private=s().get([\"server\", \"ipCheck\", \"trustedSubnets\"]),\n                )\n                response[\"_login_mechanism\"] = session[\"login_mechanism\"]\n\n                r = make_response(jsonify(response))\n                r.delete_cookie(\"active_logout\")\n\n                eventManager().fire(\n                    Events.USER_LOGGED_IN, payload={\"username\": user.get_id()}\n                )\n\n                return r\n\n        abort(403)\n\n    elif \"passive\" in data:\n        return passive_login()\n\n    abort(400, description=\"Neither user and pass attributes nor passive flag present\")\n\n\n@api.route(\"/logout\", methods=[\"POST\"])\ndef logout():\n    username = None\n    if current_user:\n        username = current_user.get_id()\n\n    # logout from user manager...\n    _logout(current_user)\n\n    # ... and from flask login (and principal)\n    logout_user()\n\n    # ... and send an active logout session cookie\n    r = make_response(jsonify(octoprint.server.userManager.anonymous_user_factory()))\n    r.set_cookie(\"active_logout\", \"true\")\n\n    if username:\n        eventManager().fire(Events.USER_LOGGED_OUT, payload={\"username\": username})\n\n    return r\n\n\ndef _logout(user):\n    if \"usersession.id\" in session:\n        del session[\"usersession.id\"]\n    if \"login_mechanism\" in session:\n        del session[\"login_mechanism\"]\n    octoprint.server.userManager.logout_user(user)\n\n\n@api.route(\"/currentuser\", methods=[\"GET\"])\ndef get_current_user():\n    return jsonify(\n        name=current_user.get_name(),\n        permissions=[permission.key for permission in current_user.effective_permissions],\n        groups=[group.key for group in current_user.groups],\n    )\n\n\n# ~~ Test utils\n\n\n@api.route(\"/util/test\", methods=[\"POST\"])\n@no_firstrun_access\n@Permissions.ADMIN.require(403)\ndef utilTest():\n    valid_commands = {\n        \"path\": [\"path\"],\n        \"url\": [\"url\"],\n        \"server\": [\"host\", \"port\"],\n        \"resolution\": [\"name\"],\n        \"address\": [],\n    }\n\n    command, data, response = get_json_command_from_request(request, valid_commands)\n    if response is not None:\n        return response\n\n    if command == \"path\":\n        return _test_path(data)\n    elif command == \"url\":\n        return _test_url(data)\n    elif command == \"server\":\n        return _test_server(data)\n    elif command == \"resolution\":\n        return _test_resolution(data)\n    elif command == \"address\":\n        return _test_address(data)\n\n\ndef _test_path(data):\n    import os\n\n    from octoprint.util.paths import normalize\n\n    path = normalize(data[\"path\"], real=False)\n    if not path:\n        return jsonify(\n            path=path,\n            exists=False,\n            typeok=False,\n            broken_symlink=False,\n            access=False,\n            result=False,\n        )\n\n    unreal_path = path\n    path = os.path.realpath(path)\n\n    check_type = None\n    check_access = []\n\n    if \"check_type\" in data and data[\"check_type\"] in (\"file\", \"dir\"):\n        check_type = data[\"check_type\"]\n\n    if \"check_access\" in data:\n        request_check_access = data[\"check_access\"]\n        if not isinstance(request_check_access, list):\n            request_check_access = list(request_check_access)\n\n        check_access = [\n            check for check in request_check_access if check in (\"r\", \"w\", \"x\")\n        ]\n\n    allow_create_dir = data.get(\"allow_create_dir\", False) and check_type == \"dir\"\n    check_writable_dir = data.get(\"check_writable_dir\", False) and check_type == \"dir\"\n    if check_writable_dir and \"w\" not in check_access:\n        check_access.append(\"w\")\n\n    # check if path exists\n    exists = os.path.exists(path)\n    if not exists:\n        if os.path.islink(unreal_path):\n            # broken symlink, see #2644\n            logging.getLogger(__name__).error(\n                \"{} is a broken symlink pointing at non existing {}\".format(\n                    unreal_path, path\n                )\n            )\n            return jsonify(\n                path=unreal_path,\n                exists=False,\n                typeok=False,\n                broken_symlink=True,\n                access=False,\n                result=False,\n            )\n\n        elif check_type == \"dir\" and allow_create_dir:\n            try:\n                os.makedirs(path)\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    f\"Error while trying to create {path}\"\n                )\n                return jsonify(\n                    path=path,\n                    exists=False,\n                    typeok=False,\n                    broken_symlink=False,\n                    access=False,\n                    result=False,\n                )\n            else:\n                exists = True\n\n    # check path type\n    type_mapping = {\"file\": os.path.isfile, \"dir\": os.path.isdir}\n    if check_type:\n        typeok = type_mapping[check_type](path)\n    else:\n        typeok = exists\n\n    # check if path allows requested access\n    access_mapping = {\"r\": os.R_OK, \"w\": os.W_OK, \"x\": os.X_OK}\n    if check_access:\n        mode = 0\n        for a in map(lambda x: access_mapping[x], check_access):\n            mode |= a\n        access = os.access(path, mode)\n    else:\n        access = exists\n\n    if check_writable_dir and check_type == \"dir\":\n        try:\n            test_path = os.path.join(path, \".testballoon.txt\")\n            with open(test_path, \"wb\") as f:\n                f.write(b\"Test\")\n            os.remove(test_path)\n        except Exception:\n            logging.getLogger(__name__).exception(\n                f\"Error while testing if {path} is really writable\"\n            )\n            return jsonify(\n                path=path,\n                exists=exists,\n                typeok=typeok,\n                broken_symlink=False,\n                access=False,\n                result=False,\n            )\n\n    return jsonify(\n        path=path,\n        exists=exists,\n        typeok=typeok,\n        broken_symlink=False,\n        access=access,\n        result=exists and typeok and access,\n    )\n\n\ndef _test_url(data):\n    import requests\n\n    from octoprint import util as util\n\n    class StatusCodeRange:\n        def __init__(self, start=None, end=None):\n            self.start = start\n            self.end = end\n\n        def __contains__(self, item):\n            if not isinstance(item, int):\n                return False\n            if self.start and self.end:\n                return self.start <= item < self.end\n            elif self.start:\n                return self.start <= item\n            elif self.end:\n                return item < self.end\n            else:\n                return False\n\n        def as_dict(self):\n            return {\"start\": self.start, \"end\": self.end}\n\n    status_ranges = {\n        \"informational\": StatusCodeRange(start=100, end=200),\n        \"success\": StatusCodeRange(start=200, end=300),\n        \"redirection\": StatusCodeRange(start=300, end=400),\n        \"client_error\": StatusCodeRange(start=400, end=500),\n        \"server_error\": StatusCodeRange(start=500, end=600),\n        \"normal\": StatusCodeRange(end=400),\n        \"error\": StatusCodeRange(start=400, end=600),\n        \"any\": StatusCodeRange(start=100),\n        \"timeout\": StatusCodeRange(start=0, end=1),\n    }\n\n    url = data[\"url\"]\n    method = data.get(\"method\", \"HEAD\")\n    timeout = 3.0\n    valid_ssl = True\n    check_status = [status_ranges[\"normal\"]]\n    content_type_whitelist = None\n    content_type_blacklist = None\n\n    if \"timeout\" in data:\n        try:\n            timeout = float(data[\"timeout\"])\n        except Exception:\n            abort(400, description=\"timeout is invalid\")\n\n    if \"validSsl\" in data:\n        valid_ssl = data[\"validSsl\"] in valid_boolean_trues\n\n    if \"status\" in data:\n        request_status = data[\"status\"]\n        if not isinstance(request_status, list):\n            request_status = [request_status]\n\n        check_status = []\n        for rs in request_status:\n            if isinstance(rs, int):\n                check_status.append([rs])\n            else:\n                if rs in status_ranges:\n                    check_status.append(status_ranges[rs])\n                else:\n                    code = requests.codes[rs]\n                    if code is not None:\n                        check_status.append([code])\n\n    if \"content_type_whitelist\" in data:\n        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):\n            abort(400, description=\"content_type_whitelist must be a list of mime types\")\n        content_type_whitelist = list(\n            map(util.parse_mime_type, data[\"content_type_whitelist\"])\n        )\n    if \"content_type_blacklist\" in data:\n        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):\n            abort(400, description=\"content_type_blacklist must be a list of mime types\")\n        content_type_blacklist = list(\n            map(util.parse_mime_type, data[\"content_type_blacklist\"])\n        )\n\n    response_result = None\n    outcome = True\n    status = 0\n    try:\n        with requests.request(\n            method=method, url=url, timeout=timeout, verify=valid_ssl, stream=True\n        ) as response:\n            status = response.status_code\n            outcome = outcome and any(map(lambda x: status in x, check_status))\n            content_type = response.headers.get(\"content-type\")\n\n            response_result = {\n                \"headers\": dict(response.headers),\n                \"content_type\": content_type,\n            }\n\n            if not content_type and data.get(\"content_type_guess\") in valid_boolean_trues:\n                content = response.content\n                content_type = util.guess_mime_type(bytearray(content))\n\n            if not content_type:\n                content_type = \"application/octet-stream\"\n\n            response_result = {\"assumed_content_type\": content_type}\n\n            parsed_content_type = util.parse_mime_type(content_type)\n\n            in_whitelist = content_type_whitelist is None or any(\n                map(\n                    lambda x: util.mime_type_matches(parsed_content_type, x),\n                    content_type_whitelist,\n                )\n            )\n            in_blacklist = content_type_blacklist is not None and any(\n                map(\n                    lambda x: util.mime_type_matches(parsed_content_type, x),\n                    content_type_blacklist,\n                )\n            )\n\n            if not in_whitelist or in_blacklist:\n                # we don't support this content type\n                response.close()\n                outcome = False\n\n            elif \"response\" in data and (\n                data[\"response\"] in valid_boolean_trues\n                or data[\"response\"] in (\"json\", \"bytes\")\n            ):\n                if data[\"response\"] == \"json\":\n                    content = response.json()\n\n                else:\n                    import base64\n\n                    content = base64.standard_b64encode(response.content)\n\n                response_result[\"content\"] = content\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error while running a test {method} request on {url}\"\n        )\n        outcome = False\n\n    result = {\"url\": url, \"status\": status, \"result\": outcome}\n    if response_result:\n        result[\"response\"] = response_result\n\n    return jsonify(**result)\n\n\ndef _test_server(data):\n    host = data[\"host\"]\n    try:\n        port = int(data[\"port\"])\n    except Exception:\n        abort(400, description=\"Invalid value for port\")\n\n    timeout = 3.05\n    if \"timeout\" in data:\n        try:\n            timeout = float(data[\"timeout\"])\n        except Exception:\n            abort(400, description=\"Invalid value for timeout\")\n\n    protocol = data.get(\"protocol\", \"tcp\")\n    if protocol not in (\"tcp\", \"udp\"):\n        abort(400, description=\"Invalid value for protocol\")\n\n    from octoprint.util import server_reachable\n\n    reachable = server_reachable(host, port, timeout=timeout, proto=protocol)\n\n    result = {\"host\": host, \"port\": port, \"protocol\": protocol, \"result\": reachable}\n\n    return jsonify(**result)\n\n\ndef _test_resolution(data):\n    name = data[\"name\"]\n\n    from octoprint.util.net import resolve_host\n\n    resolvable = len(resolve_host(name)) > 0\n\n    result = {\"name\": name, \"result\": resolvable}\n\n    return jsonify(**result)\n\n\ndef _test_address(data):\n    import netaddr\n\n    from octoprint.util.net import get_lan_ranges, sanitize_address\n\n    remote_addr = data.get(\"address\")\n    if not remote_addr:\n        remote_addr = get_remote_address(request)\n\n    remote_addr = sanitize_address(remote_addr)\n    ip = netaddr.IPAddress(remote_addr)\n\n    lan_subnets = get_lan_ranges()\n\n    detected_subnet = None\n    for subnet in lan_subnets:\n        if ip in subnet:\n            detected_subnet = subnet\n            break\n\n    result = {\n        \"is_lan_address\": detected_subnet is not None,\n        \"address\": remote_addr,\n    }\n\n    if detected_subnet is not None:\n        result[\"subnet\"] = str(detected_subnet)\n\n    return jsonify(**result)\n", "body{padding-top:40px;padding-bottom:40px;background-color:#f5f5f5}.form-signin{max-width:300px;padding:19px 29px 29px;margin:0 auto 20px;background-color:#fff;border:1px solid #e5e5e5;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;-webkit-box-shadow:0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:0 1px 2px rgba(0,0,0,0.05);box-shadow:0 1px 2px rgba(0,0,0,0.05)}.form-signin .form-signin-heading,.form-signin .checkbox{margin-bottom:10px}.form-signin input[type=\"text\"],.form-signin input[type=\"password\"]{font-size:16px;height:auto;margin-bottom:15px;padding:7px 9px}#login-error,#login-offline{display:none}#login-error.in,#login-offline.in{display:block}#login-overlay{position:fixed;top:0;left:0;width:100%;height:100%;z-index:10000;display:none}#login-overlay.in{display:block}#login-overlay .background{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#000000;filter:alpha(opacity=50);-moz-opacity:.5;-khtml-opacity:.5;opacity:.5}#login-overlay .wrapper{position:absolute;top:0;bottom:0;left:0;right:0}#login-overlay .wrapper .outer{display:table;width:100%;height:100%}#login-overlay .wrapper .outer .inner{display:table-cell;vertical-align:middle}#login-overlay .wrapper .outer .inner .content{text-align:center;color:white}#noscript{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#ffffff;z-index:12310}#noscript .wrapper{position:absolute;top:0;bottom:0;left:0;right:0}#noscript .wrapper .outer{display:table;width:100%;height:100%}#noscript .wrapper .outer .inner{display:table-cell;vertical-align:middle}#noscript .wrapper .outer .inner .content{text-align:center}", "/*\n * Will get included into the login dialog, NOT into the regular OctoPrint\n * web application.\n */\n\n$(function () {\n    var OctoPrint = window.OctoPrint;\n\n    OctoPrint.loginui = {\n        startedUp: false\n    };\n\n    var overlayElement = $(\"#login-overlay\");\n    var errorElement = $(\"#login-error\");\n    var offlineElement = $(\"#login-offline\");\n    var buttonElement = $(\"#login-button\");\n    var reconnectElement = $(\"#login-reconnect\");\n\n    var ignoreDisconnect = false;\n\n    buttonElement.click(function () {\n        var usernameElement = $(\"#login-user\");\n        var passwordElement = $(\"#login-password\");\n        var rememberElement = $(\"#login-remember\");\n\n        var username = usernameElement.val();\n        var password = passwordElement.val();\n        var remember = rememberElement.prop(\"checked\");\n\n        overlayElement.addClass(\"in\");\n        errorElement.removeClass(\"in\");\n\n        OctoPrint.browser\n            .login(username, password, remember)\n            .done(() => {\n                ignoreDisconnect = true;\n                window.location.href = REDIRECT_URL;\n            })\n            .fail(() => {\n                usernameElement.val(USER_ID);\n                passwordElement.val(\"\");\n\n                if (USER_ID) {\n                    passwordElement.focus();\n                } else {\n                    usernameElement.focus();\n                }\n\n                overlayElement.removeClass(\"in\");\n                errorElement.addClass(\"in\");\n            });\n\n        return false;\n    });\n\n    OctoPrint.options.baseurl = BASE_URL;\n\n    OctoPrint.socket.onConnected = () => {\n        buttonElement.prop(\"disabled\", false);\n        offlineElement.removeClass(\"in\");\n    };\n\n    OctoPrint.socket.onDisconnected = () => {\n        if (ignoreDisconnect) return;\n        buttonElement.prop(\"disabled\", true);\n        offlineElement.addClass(\"in\");\n    };\n\n    reconnectElement.click(() => {\n        OctoPrint.socket.reconnect();\n    });\n\n    OctoPrint.socket.connect();\n    OctoPrint.loginui.startedUp = true;\n});\n", "body {\n  padding-top: 40px;\n  padding-bottom: 40px;\n  background-color: #f5f5f5;\n}\n\n.form-signin {\n  max-width: 300px;\n  padding: 19px 29px 29px;\n  margin: 0 auto 20px;\n  background-color: #fff;\n  border: 1px solid #e5e5e5;\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  border-radius: 5px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\n  -moz-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\n\n  .form-signin-heading,\n  .checkbox {\n    margin-bottom: 10px;\n  }\n\n  input[type=\"text\"],\n  input[type=\"password\"] {\n    font-size: 16px;\n    height: auto;\n    margin-bottom: 15px;\n    padding: 7px 9px;\n  }\n}\n\n#login-error,\n#login-offline {\n  display: none;\n\n  &.in {\n    display: block;\n  }\n}\n\n#login-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 10000;\n  display: none;\n\n  &.in {\n    display: block;\n  }\n\n  .background {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-color: #000000;\n    filter: alpha(opacity=50);\n    -moz-opacity: 0.5;\n    -khtml-opacity: 0.5;\n    opacity: 0.5;\n  }\n\n  .wrapper {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n\n    .outer {\n      display: table;\n      width: 100%;\n      height: 100%;\n\n      .inner {\n        display: table-cell;\n        vertical-align: middle;\n\n        .content {\n          text-align: center;\n          color: white;\n        }\n      }\n    }\n  }\n}\n\n#noscript {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: #ffffff;\n  z-index: 12310;\n\n  .wrapper {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n\n    .outer {\n      display: table;\n      width: 100%;\n      height: 100%;\n\n      .inner {\n        display: table-cell;\n        vertical-align: middle;\n\n        .content {\n          text-align: center;\n        }\n      }\n    }\n  }\n}\n", "<html>\n<head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <title>OctoPrint Login</title>\n\n    <link rel=\"shortcut icon\" href=\"{{ url_for('static', filename='img/tentacle-32x32.png') }}\">\n    <link rel=\"mask-icon\" href=\"{{ url_for('static', filename='img/mask.svg') }}\" color=\"#56BE37\">\n    <link rel=\"mask-icon-theme\" href=\"{{ url_for('static', filename='img/mask-theme.svg') }}\" color=\"#56BE37\">\n    <link rel=\"apple-touch-icon\" sizes=\"114x114\" href=\"{{ url_for('static', filename='img/apple-touch-icon-114x114.png') }}\">\n    <link rel=\"apple-touch-icon\" sizes=\"144x144\" href=\"{{ url_for('static', filename='img/apple-touch-icon-144x144.png') }}\">\n\n    <!-- le CSS -->\n\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"css/bootstrap.min.css\") }}\">\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"css/bootstrap-responsive.min.css\") }}\">\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"vendor/font-awesome-5.15.1/css/all.min.css\") }}\">\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"vendor/font-awesome-5.15.1/css/v4-shims.css\") }}\">\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"css/login.css\") }}\">\n\n    {% for url in theming %}\n        <link rel=\"stylesheet\" href=\"{{ url }}\">\n    {% endfor %}\n\n    <!-- le javascript -->\n\n    <script>\n        var BASE_URL = \"{{ url_for('index') }}\";\n        var REDIRECT_URL = \"{{ redirect_url|e }}\";\n        var USER_ID = \"{{ user_id|e }}\";\n    </script>\n    <script src=\"{{ url_for(\"static\", filename=\"js/lib/jquery/jquery.min.js\") }}\"></script>\n    <script src=\"{{ url_for(\"static\", filename=\"js/lib/sockjs.min.js\") }}\"></script>\n    <script src=\"{{ url_for(\"static\", filename=\"js/lib/bootstrap/bootstrap.js\") }}\"></script>\n    <script src=\"{{ url_for(\"static\", filename=\"js/lib/lodash.min.js\") }}\"></script>\n\n    {% assets \"js_client\" %}\n        <script type=\"text/javascript\" src=\"{{ ASSET_URL }}\"></script>\n    {% endassets %}\n\n    <script src=\"{{ url_for(\"static\", filename=\"js/login/login.js\") }}\"></script>\n</head>\n<body>\n    <noscript>\n        <style type=\"text/css\">\n            #login,\n            #login-overlay {\n                display:none;\n            }\n        </style>\n        <div id=\"noscript\">\n            <div class=\"wrapper\">\n                <div class=\"outer\">\n                    <div class=\"inner\">\n                        <div class=\"content\">\n                            <h1 class=\"text-error\">{{ _('You don\\'t seem to have JavaScript enabled') }}</h1>\n                            {{ _('OctoPrint\\'s UI requires JavaScript to work. Please enable JavaScript and reload.') }}\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </noscript>\n\n    <div id=\"login\" class=\"container\">\n        <form class=\"form-signin\">\n            <h2 class=\"form-signin-heading\" data-test-id=\"login-title\">{{ _('Please log in') }}</h2>\n\n            <div id=\"login-error\" class=\"alert alert-error\" data-test-id=\"login-error\">{{ _('Incorrect username or password. Hint: Both are case sensitive!') }}</div>\n            <div id=\"login-offline\" class=\"alert alert-error\">{{ _('Server is currently offline.') }} <a id=\"login-reconnect\" href=\"javascript:void(0)\">{{ _('Reconnect...') }}</a></div>\n\n            {% if user_id %}<p>\n                {{ _('The following account is required:') }} {{ user_id|e }}\n            </p>{% elif logged_in %}<p>\n                {{ _('An account with the following permissions is required:') }} {{ permission_names|join(\", \") }}\n            </p>{% endif %}\n\n            <input type=\"text\" id=\"login-user\" data-test-id=\"login-username\" class=\"input-block-level\" placeholder=\"{{ _('Username')|edq }}\" {% if user_id %}value=\"{{ user_id|edq }}\" disabled{% endif %} autofocus autocapitalize=\"none\">\n            <input type=\"password\" id=\"login-password\" data-test-id=\"login-password\" class=\"input-block-level\" placeholder=\"{{ _('Password')|edq }}\">\n            <span class=\"pull-right\"><small><a href=\"https://faq.octoprint.org/forgotten-password\" id=\"login-forgotpassword\" target=\"_blank\" tabindex=\"-1\">{{ _('Forgot password?') }}</a></small></span>\n            <label class=\"checkbox\">\n                <input type=\"checkbox\" id=\"login-remember\" data-test-id=\"login-remember-me\"> {{ _('Remember me') }}\n            </label>\n            <button class=\"btn btn-block btn-large btn-primary\" id=\"login-button\" data-test-id=\"login-submit\" type=\"submit\">{{ _('Log in') }}</button>\n        </form>\n    </div>\n\n    <div id=\"login-overlay\">\n        <div class=\"background\"></div>\n        <div class=\"wrapper\">\n            <div class=\"outer\">\n                <div class=\"inner\">\n                    <div class=\"content\">\n                        <i class=\"fas fa-spinner fa-spin fa-4x\"></i>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</body>\n</html>\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n### NOTE #################################################################################\n# This file has to stay format compatible to Python 2, or pip under Python 2 will\n# not be able to detect that OctoPrint requires Python 3 but instead fail with a\n# syntax error.\n#\n# So, no f-strings, no walrus operators, no pyupgrade or codemods.\n##########################################################################################\n\nimport os\nimport sys\nfrom distutils.command.build_py import build_py as _build_py\n\nimport versioneer  # noqa: F401\n\nsys.path.insert(0, os.path.join(os.path.dirname(os.path.realpath(__file__)), \"src\"))\nimport setuptools  # noqa: F401,E402\n\nimport octoprint_setuptools  # noqa: F401,E402\n\n# ----------------------------------------------------------------------------------------\n\n# Supported python versions\nPYTHON_REQUIRES = \">=3.7, <4\"\n\n# Requirements for setup.py\nSETUP_REQUIRES = []\n\n# Requirements for our application\nbundled_plugins = [\n    \"OctoPrint-FileCheck>=2021.2.23\",\n    \"OctoPrint-FirmwareCheck>=2021.10.11\",\n    \"OctoPrint-PiSupport>=2022.3.28\",\n]\ncore_deps = [\n    \"cachelib>=0.2,<0.3\",\n    \"Click>=8.0.3,<9\",\n    \"colorlog>=6,<7\",\n    \"emoji>=1.4.2,<2\",\n    \"feedparser>=6.0.8,<7\",\n    \"filetype>=1.0.7,<2\",\n    \"Flask-Assets>=2.0,<3\",\n    \"Flask-Babel>=2.0,<3\",\n    \"Flask-Login>=0.6,<0.7\",  # breaking changes can happen on minor version increases\n    \"Flask-Limiter>=2.6,<3\",\n    \"flask>=2.2,<2.3\",  # breaking changes can happen on minor version increases (with deprecation warnings)\n    \"frozendict>=2.0,<3\",\n    \"future>=0.18.2,<1\",  # not really needed anymore, but leaving in for py2/3 compat plugins\n    \"markdown>=3.2.2,<4\",\n    \"netaddr>=0.8,<0.9\",  # changelog hints at breaking changes on minor version increases\n    \"netifaces>=0.11,<1\",\n    \"pathvalidate>=2.4.1,<3\",\n    \"pkginfo>=1.7.1,<2\",\n    \"psutil>=5.8,<6\",\n    \"pylru>=1.2,<2\",\n    \"pyserial>=3.4,<4\",\n    \"PyYAML>=5.4.1,<6\",\n    \"requests>=2.26.0,<3\",\n    \"sarge==0.1.6\",\n    \"semantic_version>=2.8.5,<3\",\n    \"sentry-sdk>=1.5.7,<2\",\n    \"tornado>=6.0.4,<7\",\n    \"watchdog>=1,<2\",\n    \"websocket-client>=1.2.1,<2\",\n    \"werkzeug>=2.2,<2.3\",  # breaking changes can happen on minor version increases\n    \"wrapt>=1.14,<1.15\",\n    \"zeroconf>=0.33,<0.34\",  # breaking changes can happen on minor version increases\n    \"zipstream-ng>=1.3.4,<2.0.0\",\n    \"pydantic>=1.9.1,<2\",\n    \"pydantic-settings>=0.2.5,<1\",  # TODO: replace with vendored with_attrs_docs\n]\nvendored_deps = [\n    \"blinker>=1.4,<2\",  # dependency of flask_principal\n    \"regex\",  # dependency of awesome-slugify\n    \"unidecode\",  # dependency of awesome-slugify\n]\n\nINSTALL_REQUIRES = bundled_plugins + core_deps + vendored_deps\n\n# Additional requirements for optional install options and/or OS-specific dependencies\nEXTRA_REQUIRES = {\n    # Dependencies for OSX\n    \":sys_platform == 'darwin'\": [\n        \"appdirs>=1.4.4,<2\",\n    ],\n    # Dependencies for core development\n    \"develop\": [\n        # Testing dependencies\n        \"ddt\",\n        \"mock>=4,<5\",\n        \"pytest-doctest-custom>=1.0.0,<2\",\n        \"pytest>=6.2.5,<7\",\n        # pre-commit\n        \"pre-commit\",\n        # profiler\n        \"pyinstrument\",\n    ],\n    # Dependencies for developing OctoPrint plugins\n    \"plugins\": [\"cookiecutter>=1.7.2,<1.8\"],\n    # Dependencies for building the documentation\n    \"docs\": [\n        \"readthedocs-sphinx-ext>=2.1.5,<3\",\n        \"sphinx_rtd_theme>=1,<2\",\n        \"sphinx>=4,<5\",\n        \"sphinxcontrib-httpdomain>=1.8.0,<2\",\n        \"sphinxcontrib-mermaid>=0.7.1,<0.8\",\n    ],\n}\n\n# ----------------------------------------------------------------------------------------\n# Anything below here is just command setup and general setup configuration\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n\ndef read_file_contents(path):\n    import io\n\n    with io.open(path, encoding=\"utf-8\") as f:\n        return f.read()\n\n\ndef copy_files_build_py_factory(files, baseclass):\n    class copy_files_build_py(baseclass):\n        files = {}\n\n        def run(self):\n            print(\"RUNNING copy_files_build_py\")\n            if not self.dry_run:\n                import shutil\n\n                for directory, files in self.files.items():\n                    target_dir = os.path.join(self.build_lib, directory)\n                    self.mkpath(target_dir)\n\n                    for entry in files:\n                        if isinstance(entry, tuple):\n                            if len(entry) != 2:\n                                continue\n                            source, dest = entry[0], os.path.join(target_dir, entry[1])\n                        else:\n                            source = entry\n                            dest = os.path.join(target_dir, source)\n\n                        print(\"Copying {} to {}\".format(source, dest))\n                        shutil.copy2(source, dest)\n\n            baseclass.run(self)\n\n    return type(copy_files_build_py)(\n        copy_files_build_py.__name__, (copy_files_build_py,), {\"files\": files}\n    )\n\n\ndef get_cmdclass():\n    # make sure these are always available, even when run by dependabot\n    global versioneer, octoprint_setuptools, md_to_html_build_py_factory\n\n    cmdclass = versioneer.get_cmdclass()\n\n    # add clean command\n    cmdclass.update(\n        {\n            \"clean\": octoprint_setuptools.CleanCommand.for_options(\n                source_folder=\"src\", eggs=[\"OctoPrint*.egg-info\"]\n            )\n        }\n    )\n\n    # add translation commands\n    translation_dir = \"translations\"\n    pot_file = os.path.join(translation_dir, \"messages.pot\")\n    bundled_dir = os.path.join(\"src\", \"octoprint\", \"translations\")\n    cmdclass.update(\n        octoprint_setuptools.get_babel_commandclasses(\n            pot_file=pot_file,\n            output_dir=translation_dir,\n            pack_name_prefix=\"OctoPrint-i18n-\",\n            pack_path_prefix=\"\",\n            bundled_dir=bundled_dir,\n        )\n    )\n\n    cmdclass[\"build_py\"] = copy_files_build_py_factory(\n        {\n            \"octoprint/templates/_data\": [\n                \"AUTHORS.md\",\n                \"SUPPORTERS.md\",\n                \"THIRDPARTYLICENSES.md\",\n            ]\n        },\n        cmdclass[\"build_py\"] if \"build_py\" in cmdclass else _build_py,\n    )\n\n    return cmdclass\n\n\ndef params():\n    # make sure these are always available, even when run by dependabot\n    global versioneer, get_cmdclass, read_file_contents, here, PYTHON_REQUIRES, SETUP_REQUIRES, INSTALL_REQUIRES, EXTRA_REQUIRES\n\n    name = \"OctoPrint\"\n    version = versioneer.get_version()\n    cmdclass = get_cmdclass()\n\n    description = \"The snappy web interface for your 3D printer\"\n    long_description = read_file_contents(os.path.join(here, \"README.md\"))\n    long_description_content_type = \"text/markdown\"\n\n    python_requires = PYTHON_REQUIRES\n    setup_requires = SETUP_REQUIRES\n    install_requires = INSTALL_REQUIRES\n    extras_require = EXTRA_REQUIRES\n\n    classifiers = [\n        \"Development Status :: 5 - Production/Stable\",\n        \"Environment :: Web Environment\",\n        \"Framework :: Flask\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: End Users/Desktop\",\n        \"Intended Audience :: Manufacturing\",\n        \"Intended Audience :: Other Audience\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: GNU Affero General Public License v3\",\n        \"Natural Language :: English\",\n        \"Natural Language :: German\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: JavaScript\",\n        \"Topic :: Printing\",\n        \"Topic :: System :: Monitoring\",\n    ]\n    author = \"Gina H\u00e4u\u00dfge\"\n    author_email = \"gina@octoprint.org\"\n    url = \"https://octoprint.org\"\n    license = \"GNU Affero General Public License v3\"\n    keywords = \"3dprinting 3dprinter 3d-printing 3d-printer octoprint\"\n\n    project_urls = {\n        \"Community Forum\": \"https://community.octoprint.org\",\n        \"Bug Reports\": \"https://github.com/OctoPrint/OctoPrint/issues\",\n        \"Source\": \"https://github.com/OctoPrint/OctoPrint\",\n        \"Funding\": \"https://support.octoprint.org\",\n    }\n\n    packages = setuptools.find_packages(where=\"src\")\n    package_dir = {\n        \"\": \"src\",\n    }\n    package_data = {\n        \"octoprint\": octoprint_setuptools.package_data_dirs(\n            \"src/octoprint\", [\"static\", \"templates\", \"plugins\", \"translations\"]\n        )\n        + [\"util/piptestballoon/setup.py\"]\n    }\n\n    include_package_data = True\n    zip_safe = False\n\n    if os.environ.get(\"READTHEDOCS\", None) == \"True\":\n        # we can't tell read the docs to please perform a pip install -e .[docs], so we help\n        # it a bit here by explicitly adding the docs dependencies\n        install_requires = install_requires + extras_require[\"docs\"]\n\n    entry_points = {\"console_scripts\": [\"octoprint = octoprint:main\"]}\n\n    return locals()\n\n\nsetuptools.setup(**params())\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport atexit\nimport base64\nimport functools\nimport logging\nimport logging.config\nimport mimetypes\nimport os\nimport re\nimport signal\nimport sys\nimport time\nimport uuid  # noqa: F401\nfrom collections import OrderedDict, defaultdict\n\nfrom babel import Locale\nfrom flask import (  # noqa: F401\n    Blueprint,\n    Flask,\n    Request,\n    Response,\n    current_app,\n    g,\n    make_response,\n    request,\n    session,\n)\nfrom flask_assets import Bundle, Environment\nfrom flask_babel import Babel, gettext, ngettext  # noqa: F401\nfrom flask_login import (  # noqa: F401\n    LoginManager,\n    current_user,\n    session_protected,\n    user_logged_out,\n)\nfrom watchdog.observers import Observer\nfrom watchdog.observers.polling import PollingObserver\nfrom werkzeug.exceptions import HTTPException\n\nimport octoprint.util\nimport octoprint.util.net\nfrom octoprint.server import util\nfrom octoprint.systemcommands import system_command_manager\nfrom octoprint.util.json import JsonEncoding\nfrom octoprint.vendor.flask_principal import (  # noqa: F401\n    AnonymousIdentity,\n    Identity,\n    Permission,\n    Principal,\n    RoleNeed,\n    UserNeed,\n    identity_changed,\n    identity_loaded,\n)\nfrom octoprint.vendor.sockjs.tornado import SockJSRouter\n\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\nSUCCESS = {}\nNO_CONTENT = (\"\", 204, {\"Content-Type\": \"text/plain\"})\nNOT_MODIFIED = (\"Not Modified\", 304, {\"Content-Type\": \"text/plain\"})\n\napp = Flask(\"octoprint\")\n\nassets = None\nbabel = None\nlimiter = None\ndebug = False\nsafe_mode = False\n\nprinter = None\nprinterProfileManager = None\nfileManager = None\nslicingManager = None\nanalysisQueue = None\nuserManager = None\npermissionManager = None\ngroupManager = None\neventManager = None\nloginManager = None\npluginManager = None\npluginLifecycleManager = None\npreemptiveCache = None\njsonEncoder = None\njsonDecoder = None\nconnectivityChecker = None\nenvironmentDetector = None\n\nprincipals = Principal(app)\n\nimport octoprint.access.groups as groups  # noqa: E402\nimport octoprint.access.permissions as permissions  # noqa: E402\n\n# we set admin_permission to a GroupPermission with the default admin group\nadmin_permission = octoprint.util.variable_deprecated(\n    \"admin_permission has been deprecated, \" \"please use individual Permissions instead\",\n    since=\"1.4.0\",\n)(groups.GroupPermission(groups.ADMIN_GROUP))\n\n# we set user_permission to a GroupPermission with the default user group\nuser_permission = octoprint.util.variable_deprecated(\n    \"user_permission has been deprecated, \" \"please use individual Permissions instead\",\n    since=\"1.4.0\",\n)(groups.GroupPermission(groups.USER_GROUP))\n\nimport octoprint._version  # noqa: E402\nimport octoprint.access.groups as groups  # noqa: E402\nimport octoprint.access.users as users  # noqa: E402\nimport octoprint.events as events  # noqa: E402\nimport octoprint.filemanager.analysis  # noqa: E402\nimport octoprint.filemanager.storage  # noqa: E402\nimport octoprint.plugin  # noqa: E402\nimport octoprint.slicing  # noqa: E402\nimport octoprint.timelapse  # noqa: E402\n\n# only import further octoprint stuff down here, as it might depend on things defined above to be initialized already\nfrom octoprint import __branch__, __display_version__, __revision__, __version__\nfrom octoprint.printer.profile import PrinterProfileManager\nfrom octoprint.printer.standard import Printer\nfrom octoprint.server.util import (\n    corsRequestHandler,\n    corsResponseHandler,\n    loginFromApiKeyRequestHandler,\n    requireLoginRequestHandler,\n)\nfrom octoprint.server.util.flask import PreemptiveCache\nfrom octoprint.settings import settings\n\nVERSION = __version__\nBRANCH = __branch__\nDISPLAY_VERSION = __display_version__\nREVISION = __revision__\n\nLOCALES = []\nLANGUAGES = set()\n\n\n@identity_loaded.connect_via(app)\ndef on_identity_loaded(sender, identity):\n    user = load_user(identity.id)\n    if user is None:\n        user = userManager.anonymous_user_factory()\n\n    identity.provides.add(UserNeed(user.get_id()))\n    for need in user.needs:\n        identity.provides.add(need)\n\n\ndef _clear_identity(sender):\n    # Remove session keys set by Flask-Principal\n    for key in (\"identity.id\", \"identity.name\", \"identity.auth_type\"):\n        session.pop(key, None)\n\n    # switch to anonymous identity\n    identity_changed.send(sender, identity=AnonymousIdentity())\n\n\n@session_protected.connect_via(app)\ndef on_session_protected(sender):\n    # session was deleted by session protection, that means the user is no more and we need to clear our identity\n    if session.get(\"remember\", None) == \"clear\":\n        _clear_identity(sender)\n\n\n@user_logged_out.connect_via(app)\ndef on_user_logged_out(sender, user=None):\n    # user was logged out, clear identity\n    _clear_identity(sender)\n\n\ndef load_user(id):\n    if id is None:\n        return None\n\n    if id == \"_api\":\n        return userManager.api_user_factory()\n\n    if session and \"usersession.id\" in session:\n        sessionid = session[\"usersession.id\"]\n    else:\n        sessionid = None\n\n    if sessionid:\n        user = userManager.find_user(userid=id, session=sessionid)\n    else:\n        user = userManager.find_user(userid=id)\n\n    if user and user.is_active:\n        return user\n\n    return None\n\n\ndef load_user_from_request(request):\n    user = None\n\n    if settings().getBoolean([\"accessControl\", \"trustBasicAuthentication\"]):\n        # Basic Authentication?\n        user = util.get_user_for_authorization_header(\n            request.headers.get(\"Authorization\")\n        )\n\n    if settings().getBoolean([\"accessControl\", \"trustRemoteUser\"]):\n        # Remote user header?\n        user = util.get_user_for_remote_user_header(request)\n\n    return user\n\n\ndef unauthorized_user():\n    from flask import abort\n\n    abort(403)\n\n\n# ~~ startup code\n\n\nclass Server:\n    def __init__(\n        self,\n        settings=None,\n        plugin_manager=None,\n        connectivity_checker=None,\n        environment_detector=None,\n        event_manager=None,\n        host=None,\n        port=None,\n        v6_only=False,\n        debug=False,\n        safe_mode=False,\n        allow_root=False,\n        octoprint_daemon=None,\n    ):\n        self._settings = settings\n        self._plugin_manager = plugin_manager\n        self._connectivity_checker = connectivity_checker\n        self._environment_detector = environment_detector\n        self._event_manager = event_manager\n        self._host = host\n        self._port = port\n        self._v6_only = v6_only\n        self._debug = debug\n        self._safe_mode = safe_mode\n        self._allow_root = allow_root\n        self._octoprint_daemon = octoprint_daemon\n        self._server = None\n\n        self._logger = None\n\n        self._lifecycle_callbacks = defaultdict(list)\n\n        self._intermediary_server = None\n\n    def run(self):\n        if not self._allow_root:\n            self._check_for_root()\n\n        if self._settings is None:\n            self._settings = settings()\n\n        if not self._settings.getBoolean([\"server\", \"ignoreIncompleteStartup\"]):\n            self._settings.setBoolean([\"server\", \"incompleteStartup\"], True)\n            self._settings.save()\n\n        if self._plugin_manager is None:\n            self._plugin_manager = octoprint.plugin.plugin_manager()\n\n        global app\n        global babel\n\n        global printer\n        global printerProfileManager\n        global fileManager\n        global slicingManager\n        global analysisQueue\n        global userManager\n        global permissionManager\n        global groupManager\n        global eventManager\n        global loginManager\n        global pluginManager\n        global pluginLifecycleManager\n        global preemptiveCache\n        global jsonEncoder\n        global jsonDecoder\n        global connectivityChecker\n        global environmentDetector\n        global debug\n        global safe_mode\n\n        from tornado.ioloop import IOLoop\n        from tornado.web import Application\n\n        debug = self._debug\n        safe_mode = self._safe_mode\n\n        if safe_mode:\n            self._log_safe_mode_start(safe_mode)\n\n        if self._v6_only and not octoprint.util.net.HAS_V6:\n            raise RuntimeError(\n                \"IPv6 only mode configured but system doesn't support IPv6\"\n            )\n\n        if self._host is None:\n            host = self._settings.get([\"server\", \"host\"])\n            if host is None:\n                if octoprint.util.net.HAS_V6:\n                    host = \"::\"\n                else:\n                    host = \"0.0.0.0\"\n\n            self._host = host\n\n        if \":\" in self._host and not octoprint.util.net.HAS_V6:\n            raise RuntimeError(\n                \"IPv6 host address {!r} configured but system doesn't support IPv6\".format(\n                    self._host\n                )\n            )\n\n        if self._port is None:\n            self._port = self._settings.getInt([\"server\", \"port\"])\n            if self._port is None:\n                self._port = 5000\n\n        self._logger = logging.getLogger(__name__)\n        self._setup_heartbeat_logging()\n        pluginManager = self._plugin_manager\n\n        # monkey patch/fix some stuff\n        util.tornado.fix_json_encode()\n        util.tornado.fix_websocket_check_origin()\n        util.tornado.enable_per_message_deflate_extension()\n        util.flask.fix_flask_jsonify()\n\n        self._setup_mimetypes()\n\n        additional_translation_folders = []\n        if not safe_mode:\n            additional_translation_folders += [\n                self._settings.getBaseFolder(\"translations\")\n            ]\n        util.flask.enable_additional_translations(\n            additional_folders=additional_translation_folders\n        )\n\n        # setup app\n        self._setup_app(app)\n\n        # setup i18n\n        self._setup_i18n(app)\n\n        if self._settings.getBoolean([\"serial\", \"log\"]):\n            # enable debug logging to serial.log\n            logging.getLogger(\"SERIAL\").setLevel(logging.DEBUG)\n\n        if self._settings.getBoolean([\"devel\", \"pluginTimings\"]):\n            # enable plugin timings log\n            logging.getLogger(\"PLUGIN_TIMINGS\").setLevel(logging.DEBUG)\n\n        # start the intermediary server\n        self._start_intermediary_server()\n\n        ### IMPORTANT!\n        ###\n        ### Best do not start any subprocesses until the intermediary server shuts down again or they MIGHT inherit the\n        ### open port and prevent us from firing up Tornado later.\n        ###\n        ### The intermediary server's socket should have the CLOSE_EXEC flag (or its equivalent) set where possible, but\n        ### we can only do that if fcntl is available or we are on Windows, so better safe than sorry.\n        ###\n        ### See also issues #2035 and #2090\n\n        systemCommandManager = system_command_manager()\n        printerProfileManager = PrinterProfileManager()\n        eventManager = self._event_manager\n\n        analysis_queue_factories = {\n            \"gcode\": octoprint.filemanager.analysis.GcodeAnalysisQueue\n        }\n        analysis_queue_hooks = pluginManager.get_hooks(\n            \"octoprint.filemanager.analysis.factory\"\n        )\n        for name, hook in analysis_queue_hooks.items():\n            try:\n                additional_factories = hook()\n                analysis_queue_factories.update(**additional_factories)\n            except Exception:\n                self._logger.exception(\n                    f\"Error while processing analysis queues from {name}\",\n                    extra={\"plugin\": name},\n                )\n        analysisQueue = octoprint.filemanager.analysis.AnalysisQueue(\n            analysis_queue_factories\n        )\n\n        slicingManager = octoprint.slicing.SlicingManager(\n            self._settings.getBaseFolder(\"slicingProfiles\"), printerProfileManager\n        )\n\n        storage_managers = {}\n        storage_managers[\n            octoprint.filemanager.FileDestinations.LOCAL\n        ] = octoprint.filemanager.storage.LocalFileStorage(\n            self._settings.getBaseFolder(\"uploads\"),\n            really_universal=self._settings.getBoolean(\n                [\"feature\", \"enforceReallyUniversalFilenames\"]\n            ),\n        )\n\n        fileManager = octoprint.filemanager.FileManager(\n            analysisQueue,\n            slicingManager,\n            printerProfileManager,\n            initial_storage_managers=storage_managers,\n        )\n        pluginLifecycleManager = LifecycleManager(pluginManager)\n        preemptiveCache = PreemptiveCache(\n            os.path.join(\n                self._settings.getBaseFolder(\"data\"), \"preemptive_cache_config.yaml\"\n            )\n        )\n\n        JsonEncoding.add_encoder(users.User, lambda obj: obj.as_dict())\n        JsonEncoding.add_encoder(groups.Group, lambda obj: obj.as_dict())\n        JsonEncoding.add_encoder(\n            permissions.OctoPrintPermission, lambda obj: obj.as_dict()\n        )\n\n        # start regular check if we are connected to the internet\n        def on_connectivity_change(old_value, new_value):\n            eventManager.fire(\n                events.Events.CONNECTIVITY_CHANGED,\n                payload={\"old\": old_value, \"new\": new_value},\n            )\n\n        connectivityChecker = self._connectivity_checker\n        environmentDetector = self._environment_detector\n\n        def on_settings_update(*args, **kwargs):\n            # make sure our connectivity checker runs with the latest settings\n            connectivityEnabled = self._settings.getBoolean(\n                [\"server\", \"onlineCheck\", \"enabled\"]\n            )\n            connectivityInterval = self._settings.getInt(\n                [\"server\", \"onlineCheck\", \"interval\"]\n            )\n            connectivityHost = self._settings.get([\"server\", \"onlineCheck\", \"host\"])\n            connectivityPort = self._settings.getInt([\"server\", \"onlineCheck\", \"port\"])\n            connectivityName = self._settings.get([\"server\", \"onlineCheck\", \"name\"])\n\n            if (\n                connectivityChecker.enabled != connectivityEnabled\n                or connectivityChecker.interval != connectivityInterval\n                or connectivityChecker.host != connectivityHost\n                or connectivityChecker.port != connectivityPort\n                or connectivityChecker.name != connectivityName\n            ):\n                connectivityChecker.enabled = connectivityEnabled\n                connectivityChecker.interval = connectivityInterval\n                connectivityChecker.host = connectivityHost\n                connectivityChecker.port = connectivityPort\n                connectivityChecker.name = connectivityName\n                connectivityChecker.check_immediately()\n\n        eventManager.subscribe(events.Events.SETTINGS_UPDATED, on_settings_update)\n\n        components = {\n            \"plugin_manager\": pluginManager,\n            \"printer_profile_manager\": printerProfileManager,\n            \"event_bus\": eventManager,\n            \"analysis_queue\": analysisQueue,\n            \"slicing_manager\": slicingManager,\n            \"file_manager\": fileManager,\n            \"plugin_lifecycle_manager\": pluginLifecycleManager,\n            \"preemptive_cache\": preemptiveCache,\n            \"json_encoder\": jsonEncoder,\n            \"json_decoder\": jsonDecoder,\n            \"connectivity_checker\": connectivityChecker,\n            \"environment_detector\": self._environment_detector,\n            \"system_commands\": systemCommandManager,\n        }\n\n        # ~~ setup access control\n\n        # get additional permissions from plugins\n        self._setup_plugin_permissions()\n\n        # create group manager instance\n        group_manager_factories = pluginManager.get_hooks(\n            \"octoprint.access.groups.factory\"\n        )\n        for name, factory in group_manager_factories.items():\n            try:\n                groupManager = factory(components, self._settings)\n                if groupManager is not None:\n                    self._logger.debug(\n                        f\"Created group manager instance from factory {name}\"\n                    )\n                    break\n            except Exception:\n                self._logger.exception(\n                    \"Error while creating group manager instance from factory {}\".format(\n                        name\n                    )\n                )\n        else:\n            group_manager_name = self._settings.get([\"accessControl\", \"groupManager\"])\n            try:\n                clazz = octoprint.util.get_class(group_manager_name)\n                groupManager = clazz()\n            except AttributeError:\n                self._logger.exception(\n                    \"Could not instantiate group manager {}, \"\n                    \"falling back to FilebasedGroupManager!\".format(group_manager_name)\n                )\n                groupManager = octoprint.access.groups.FilebasedGroupManager()\n        components.update({\"group_manager\": groupManager})\n\n        # create user manager instance\n        user_manager_factories = pluginManager.get_hooks(\n            \"octoprint.users.factory\"\n        )  # legacy, set first so that new wins\n        user_manager_factories.update(\n            pluginManager.get_hooks(\"octoprint.access.users.factory\")\n        )\n        for name, factory in user_manager_factories.items():\n            try:\n                userManager = factory(components, self._settings)\n                if userManager is not None:\n                    self._logger.debug(\n                        f\"Created user manager instance from factory {name}\"\n                    )\n                    break\n            except Exception:\n                self._logger.exception(\n                    \"Error while creating user manager instance from factory {}\".format(\n                        name\n                    ),\n                    extra={\"plugin\": name},\n                )\n        else:\n            user_manager_name = self._settings.get([\"accessControl\", \"userManager\"])\n            try:\n                clazz = octoprint.util.get_class(user_manager_name)\n                userManager = clazz(groupManager)\n            except octoprint.access.users.CorruptUserStorage:\n                raise\n            except Exception:\n                self._logger.exception(\n                    \"Could not instantiate user manager {}, \"\n                    \"falling back to FilebasedUserManager!\".format(user_manager_name)\n                )\n                userManager = octoprint.access.users.FilebasedUserManager(groupManager)\n        components.update({\"user_manager\": userManager})\n\n        # create printer instance\n        printer_factories = pluginManager.get_hooks(\"octoprint.printer.factory\")\n        for name, factory in printer_factories.items():\n            try:\n                printer = factory(components)\n                if printer is not None:\n                    self._logger.debug(f\"Created printer instance from factory {name}\")\n                    break\n            except Exception:\n                self._logger.exception(\n                    f\"Error while creating printer instance from factory {name}\",\n                    extra={\"plugin\": name},\n                )\n        else:\n            printer = Printer(fileManager, analysisQueue, printerProfileManager)\n        components.update({\"printer\": printer})\n\n        from octoprint import (\n            init_custom_events,\n            init_settings_plugin_config_migration_and_cleanup,\n        )\n        from octoprint import octoprint_plugin_inject_factory as opif\n        from octoprint import settings_plugin_inject_factory as spif\n\n        init_custom_events(pluginManager)\n\n        octoprint_plugin_inject_factory = opif(self._settings, components)\n        settings_plugin_inject_factory = spif(self._settings)\n\n        pluginManager.implementation_inject_factories = [\n            octoprint_plugin_inject_factory,\n            settings_plugin_inject_factory,\n        ]\n        pluginManager.initialize_implementations()\n\n        init_settings_plugin_config_migration_and_cleanup(pluginManager)\n\n        pluginManager.log_all_plugins()\n\n        # log environment data now\n        self._environment_detector.log_detected_environment()\n\n        # initialize file manager and register it for changes in the registered plugins\n        fileManager.initialize()\n        pluginLifecycleManager.add_callback(\n            [\"enabled\", \"disabled\"], lambda name, plugin: fileManager.reload_plugins()\n        )\n\n        # initialize slicing manager and register it for changes in the registered plugins\n        slicingManager.initialize()\n        pluginLifecycleManager.add_callback(\n            [\"enabled\", \"disabled\"], lambda name, plugin: slicingManager.reload_slicers()\n        )\n\n        # setup jinja2\n        self._setup_jinja2()\n\n        # setup assets\n        self._setup_assets()\n\n        # configure timelapse\n        octoprint.timelapse.valid_timelapse(\"test\")\n        octoprint.timelapse.configure_timelapse()\n\n        # setup command triggers\n        events.CommandTrigger(printer)\n        if self._debug:\n            events.DebugEventListener()\n\n        # setup login manager\n        self._setup_login_manager()\n\n        # register API blueprint\n        self._setup_blueprints()\n\n        ## Tornado initialization starts here\n\n        ioloop = IOLoop()\n        ioloop.install()\n\n        enable_cors = settings().getBoolean([\"api\", \"allowCrossOrigin\"])\n\n        self._router = SockJSRouter(\n            self._create_socket_connection,\n            \"/sockjs\",\n            session_kls=util.sockjs.ThreadSafeSession,\n            user_settings={\n                \"websocket_allow_origin\": \"*\" if enable_cors else \"\",\n                \"jsessionid\": False,\n                \"sockjs_url\": \"../../static/js/lib/sockjs.min.js\",\n            },\n        )\n\n        upload_suffixes = {\n            \"name\": self._settings.get([\"server\", \"uploads\", \"nameSuffix\"]),\n            \"path\": self._settings.get([\"server\", \"uploads\", \"pathSuffix\"]),\n        }\n\n        def mime_type_guesser(path):\n            from octoprint.filemanager import get_mime_type\n\n            return get_mime_type(path)\n\n        def download_name_generator(path):\n            metadata = fileManager.get_metadata(\"local\", path)\n            if metadata and \"display\" in metadata:\n                return metadata[\"display\"]\n\n        download_handler_kwargs = {\"as_attachment\": True, \"allow_client_caching\": False}\n\n        additional_mime_types = {\"mime_type_guesser\": mime_type_guesser}\n\n        ##~~ Permission validators\n\n        access_validators_from_plugins = []\n        for plugin, hook in pluginManager.get_hooks(\n            \"octoprint.server.http.access_validator\"\n        ).items():\n            try:\n                access_validators_from_plugins.append(\n                    util.tornado.access_validation_factory(app, hook)\n                )\n            except Exception:\n                self._logger.exception(\n                    \"Error while adding tornado access validator from plugin {}\".format(\n                        plugin\n                    ),\n                    extra={\"plugin\": plugin},\n                )\n\n        timelapse_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.TIMELAPSE_LIST,\n            ),\n        ] + access_validators_from_plugins\n        download_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.FILES_DOWNLOAD,\n            ),\n        ] + access_validators_from_plugins\n        log_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.PLUGIN_LOGGING_MANAGE,\n            ),\n        ] + access_validators_from_plugins\n        camera_validators = [\n            util.tornado.access_validation_factory(\n                app, util.flask.permission_validator, permissions.Permissions.WEBCAM\n            ),\n        ] + access_validators_from_plugins\n        systeminfo_validators = [\n            util.tornado.access_validation_factory(\n                app, util.flask.permission_validator, permissions.Permissions.SYSTEM\n            )\n        ] + access_validators_from_plugins\n\n        timelapse_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*timelapse_validators)\n        }\n        download_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*download_validators)\n        }\n        log_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*log_validators)\n        }\n        camera_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*camera_validators)\n        }\n        systeminfo_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*systeminfo_validators)\n        }\n\n        no_hidden_files_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: not octoprint.util.is_hidden_path(path), status_code=404\n            )\n        }\n\n        valid_timelapse = lambda path: not octoprint.util.is_hidden_path(path) and (\n            octoprint.timelapse.valid_timelapse(path)\n            or octoprint.timelapse.valid_timelapse_thumbnail(path)\n        )\n        timelapse_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                valid_timelapse,\n                status_code=404,\n            )\n        }\n        timelapses_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: valid_timelapse(path)\n                and os.path.realpath(os.path.abspath(path)).startswith(\n                    settings().getBaseFolder(\"timelapse\")\n                ),\n                status_code=400,\n            )\n        }\n\n        valid_log = lambda path: not octoprint.util.is_hidden_path(\n            path\n        ) and path.endswith(\".log\")\n        log_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                valid_log,\n                status_code=404,\n            )\n        }\n        logs_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: valid_log(path)\n                and os.path.realpath(os.path.abspath(path)).startswith(\n                    settings().getBaseFolder(\"logs\")\n                ),\n                status_code=400,\n            )\n        }\n\n        def joined_dict(*dicts):\n            if not len(dicts):\n                return {}\n\n            joined = {}\n            for d in dicts:\n                joined.update(d)\n            return joined\n\n        util.tornado.RequestlessExceptionLoggingMixin.LOG_REQUEST = debug\n        util.tornado.CorsSupportMixin.ENABLE_CORS = enable_cors\n\n        server_routes = self._router.urls + [\n            # various downloads\n            # .mpg and .mp4 timelapses:\n            (\n                r\"/downloads/timelapse/(.*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\"path\": self._settings.getBaseFolder(\"timelapse\")},\n                    timelapse_permission_validator,\n                    download_handler_kwargs,\n                    timelapse_path_validator,\n                ),\n            ),\n            # zipped timelapse bundles\n            (\n                r\"/downloads/timelapses\",\n                util.tornado.DynamicZipBundleHandler,\n                joined_dict(\n                    {\n                        \"as_attachment\": True,\n                        \"attachment_name\": \"octoprint-timelapses.zip\",\n                        \"path_processor\": lambda x: (\n                            x,\n                            os.path.join(self._settings.getBaseFolder(\"timelapse\"), x),\n                        ),\n                    },\n                    timelapse_permission_validator,\n                    timelapses_path_validator,\n                ),\n            ),\n            # uploaded printables\n            (\n                r\"/downloads/files/local/(.*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\n                        \"path\": self._settings.getBaseFolder(\"uploads\"),\n                        \"as_attachment\": True,\n                        \"name_generator\": download_name_generator,\n                    },\n                    download_permission_validator,\n                    download_handler_kwargs,\n                    no_hidden_files_validator,\n                    additional_mime_types,\n                ),\n            ),\n            # log files\n            (\n                r\"/downloads/logs/([^/]*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\n                        \"path\": self._settings.getBaseFolder(\"logs\"),\n                        \"mime_type_guesser\": lambda *args, **kwargs: \"text/plain\",\n                        \"stream_body\": True,\n                    },\n                    download_handler_kwargs,\n                    log_permission_validator,\n                    log_path_validator,\n                ),\n            ),\n            # zipped log file bundles\n            (\n                r\"/downloads/logs\",\n                util.tornado.DynamicZipBundleHandler,\n                joined_dict(\n                    {\n                        \"as_attachment\": True,\n                        \"attachment_name\": \"octoprint-logs.zip\",\n                        \"path_processor\": lambda x: (\n                            x,\n                            os.path.join(self._settings.getBaseFolder(\"logs\"), x),\n                        ),\n                    },\n                    log_permission_validator,\n                    logs_path_validator,\n                ),\n            ),\n            # system info bundle\n            (\n                r\"/downloads/systeminfo.zip\",\n                util.tornado.SystemInfoBundleHandler,\n                systeminfo_permission_validator,\n            ),\n            # camera snapshot\n            (\n                r\"/downloads/camera/current\",\n                util.tornado.UrlProxyHandler,\n                joined_dict(\n                    {\n                        \"url\": self._settings.get([\"webcam\", \"snapshot\"]),\n                        \"as_attachment\": True,\n                    },\n                    camera_permission_validator,\n                ),\n            ),\n            # generated webassets\n            (\n                r\"/static/webassets/(.*)\",\n                util.tornado.LargeResponseHandler,\n                {\n                    \"path\": os.path.join(\n                        self._settings.getBaseFolder(\"generated\"), \"webassets\"\n                    ),\n                    \"is_pre_compressed\": True,\n                },\n            ),\n            # online indicators - text file with \"online\" as content and a transparent gif\n            (r\"/online.txt\", util.tornado.StaticDataHandler, {\"data\": \"online\\n\"}),\n            (\n                r\"/online.gif\",\n                util.tornado.StaticDataHandler,\n                {\n                    \"data\": bytes(\n                        base64.b64decode(\n                            \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n                        )\n                    ),\n                    \"content_type\": \"image/gif\",\n                },\n            ),\n            # deprecated endpoints\n            (\n                r\"/api/logs\",\n                util.tornado.DeprecatedEndpointHandler,\n                {\"url\": \"/plugin/logging/logs\"},\n            ),\n            (\n                r\"/api/logs/(.*)\",\n                util.tornado.DeprecatedEndpointHandler,\n                {\"url\": \"/plugin/logging/logs/{0}\"},\n            ),\n        ]\n\n        # fetch additional routes from plugins\n        for name, hook in pluginManager.get_hooks(\"octoprint.server.http.routes\").items():\n            try:\n                result = hook(list(server_routes))\n            except Exception:\n                self._logger.exception(\n                    f\"There was an error while retrieving additional \"\n                    f\"server routes from plugin hook {name}\",\n                    extra={\"plugin\": name},\n                )\n            else:\n                if isinstance(result, (list, tuple)):\n                    for entry in result:\n                        if not isinstance(entry, tuple) or not len(entry) == 3:\n                            continue\n                        if not isinstance(entry[0], str):\n                            continue\n                        if not isinstance(entry[2], dict):\n                            continue\n\n                        route, handler, kwargs = entry\n                        route = r\"/plugin/{name}/{route}\".format(\n                            name=name,\n                            route=route if not route.startswith(\"/\") else route[1:],\n                        )\n\n                        self._logger.debug(\n                            f\"Adding additional route {route} handled by handler {handler} and with additional arguments {kwargs!r}\"\n                        )\n                        server_routes.append((route, handler, kwargs))\n\n        headers = {\n            \"X-Robots-Tag\": \"noindex, nofollow, noimageindex\",\n            \"X-Content-Type-Options\": \"nosniff\",\n        }\n        if not settings().getBoolean([\"server\", \"allowFraming\"]):\n            headers[\"X-Frame-Options\"] = \"sameorigin\"\n\n        removed_headers = [\"Server\"]\n\n        server_routes.append(\n            (\n                r\".*\",\n                util.tornado.UploadStorageFallbackHandler,\n                {\n                    \"fallback\": util.tornado.WsgiInputContainer(\n                        app.wsgi_app, headers=headers, removed_headers=removed_headers\n                    ),\n                    \"file_prefix\": \"octoprint-file-upload-\",\n                    \"file_suffix\": \".tmp\",\n                    \"suffixes\": upload_suffixes,\n                },\n            )\n        )\n\n        transforms = [\n            util.tornado.GlobalHeaderTransform.for_headers(\n                \"OctoPrintGlobalHeaderTransform\",\n                headers=headers,\n                removed_headers=removed_headers,\n            )\n        ]\n\n        self._tornado_app = Application(handlers=server_routes, transforms=transforms)\n        max_body_sizes = [\n            (\n                \"POST\",\n                r\"/api/files/([^/]*)\",\n                self._settings.getInt([\"server\", \"uploads\", \"maxSize\"]),\n            ),\n            (\"POST\", r\"/api/languages\", 5 * 1024 * 1024),\n        ]\n\n        # allow plugins to extend allowed maximum body sizes\n        for name, hook in pluginManager.get_hooks(\n            \"octoprint.server.http.bodysize\"\n        ).items():\n            try:\n                result = hook(list(max_body_sizes))\n            except Exception:\n                self._logger.exception(\n                    f\"There was an error while retrieving additional \"\n                    f\"upload sizes from plugin hook {name}\",\n                    extra={\"plugin\": name},\n                )\n            else:\n                if isinstance(result, (list, tuple)):\n                    for entry in result:\n                        if not isinstance(entry, tuple) or not len(entry) == 3:\n                            continue\n                        if (\n                            entry[0]\n                            not in util.tornado.UploadStorageFallbackHandler.BODY_METHODS\n                        ):\n                            continue\n                        if not isinstance(entry[2], int):\n                            continue\n\n                        method, route, size = entry\n                        route = r\"/plugin/{name}/{route}\".format(\n                            name=name,\n                            route=route if not route.startswith(\"/\") else route[1:],\n                        )\n\n                        self._logger.debug(\n                            f\"Adding maximum body size of {size}B for {method} requests to {route})\"\n                        )\n                        max_body_sizes.append((method, route, size))\n\n        self._stop_intermediary_server()\n\n        # initialize and bind the server\n        trusted_downstream = self._settings.get(\n            [\"server\", \"reverseProxy\", \"trustedDownstream\"]\n        )\n        if not isinstance(trusted_downstream, list):\n            self._logger.warning(\n                \"server.reverseProxy.trustedDownstream is not a list, skipping\"\n            )\n            trusted_downstream = []\n\n        server_kwargs = {\n            \"max_body_sizes\": max_body_sizes,\n            \"default_max_body_size\": self._settings.getInt([\"server\", \"maxSize\"]),\n            \"xheaders\": True,\n            \"trusted_downstream\": trusted_downstream,\n        }\n        if sys.platform == \"win32\":\n            # set 10min idle timeout under windows to hopefully make #2916 less likely\n            server_kwargs.update({\"idle_connection_timeout\": 600})\n\n        self._server = util.tornado.CustomHTTPServer(self._tornado_app, **server_kwargs)\n\n        listening_address = self._host\n        if self._host == \"::\" and not self._v6_only:\n            # special case - tornado only listens on v4 _and_ v6 if we use None as address\n            listening_address = None\n\n        self._server.listen(self._port, address=listening_address)\n\n        ### From now on it's ok to launch subprocesses again\n\n        eventManager.fire(events.Events.STARTUP)\n\n        # analysis backlog\n        fileManager.process_backlog()\n\n        # auto connect\n        if self._settings.getBoolean([\"serial\", \"autoconnect\"]):\n            self._logger.info(\n                \"Autoconnect on startup is configured, trying to connect to the printer...\"\n            )\n            try:\n                (port, baudrate) = (\n                    self._settings.get([\"serial\", \"port\"]),\n                    self._settings.getInt([\"serial\", \"baudrate\"]),\n                )\n                printer_profile = printerProfileManager.get_default()\n                connectionOptions = printer.__class__.get_connection_options()\n                if port in connectionOptions[\"ports\"] or port == \"AUTO\" or port is None:\n                    self._logger.info(\n                        f\"Trying to connect to configured serial port {port}\"\n                    )\n                    printer.connect(\n                        port=port,\n                        baudrate=baudrate,\n                        profile=printer_profile[\"id\"]\n                        if \"id\" in printer_profile\n                        else \"_default\",\n                    )\n                else:\n                    self._logger.info(\n                        \"Could not find configured serial port {} in the system, cannot automatically connect to a non existing printer. Is it plugged in and booted up yet?\"\n                    )\n            except Exception:\n                self._logger.exception(\n                    \"Something went wrong while attempting to automatically connect to the printer\"\n                )\n\n        # start up watchdogs\n        try:\n            watched = self._settings.getBaseFolder(\"watched\")\n            watchdog_handler = util.watchdog.GcodeWatchdogHandler(fileManager, printer)\n            watchdog_handler.initial_scan(watched)\n\n            if self._settings.getBoolean([\"feature\", \"pollWatched\"]):\n                # use less performant polling observer if explicitly configured\n                observer = PollingObserver()\n            else:\n                # use os default\n                observer = Observer()\n\n            observer.schedule(watchdog_handler, watched, recursive=True)\n            observer.start()\n        except Exception:\n            self._logger.exception(\"Error starting watched folder observer\")\n\n        # run our startup plugins\n        octoprint.plugin.call_plugin(\n            octoprint.plugin.StartupPlugin,\n            \"on_startup\",\n            args=(self._host, self._port),\n            sorting_context=\"StartupPlugin.on_startup\",\n        )\n\n        def call_on_startup(name, plugin):\n            implementation = plugin.get_implementation(octoprint.plugin.StartupPlugin)\n            if implementation is None:\n                return\n            implementation.on_startup(self._host, self._port)\n\n        pluginLifecycleManager.add_callback(\"enabled\", call_on_startup)\n\n        # prepare our after startup function\n        def on_after_startup():\n            if self._host == \"::\":\n                if self._v6_only:\n                    # only v6\n                    self._logger.info(f\"Listening on http://[::]:{self._port}\")\n                else:\n                    # all v4 and v6\n                    self._logger.info(\n                        \"Listening on http://0.0.0.0:{port} and http://[::]:{port}\".format(\n                            port=self._port\n                        )\n                    )\n            else:\n                self._logger.info(\n                    \"Listening on http://{}:{}\".format(\n                        self._host if \":\" not in self._host else \"[\" + self._host + \"]\",\n                        self._port,\n                    )\n                )\n\n            if safe_mode and self._settings.getBoolean([\"server\", \"startOnceInSafeMode\"]):\n                self._logger.info(\n                    \"Server started successfully in safe mode as requested from config, removing flag\"\n                )\n                self._settings.setBoolean([\"server\", \"startOnceInSafeMode\"], False)\n                self._settings.save()\n\n            # now this is somewhat ugly, but the issue is the following: startup plugins might want to do things for\n            # which they need the server to be already alive (e.g. for being able to resolve urls, such as favicons\n            # or service xmls or the like). While they are working though the ioloop would block. Therefore we'll\n            # create a single use thread in which to perform our after-startup-tasks, start that and hand back\n            # control to the ioloop\n            def work():\n                octoprint.plugin.call_plugin(\n                    octoprint.plugin.StartupPlugin,\n                    \"on_after_startup\",\n                    sorting_context=\"StartupPlugin.on_after_startup\",\n                )\n\n                def call_on_after_startup(name, plugin):\n                    implementation = plugin.get_implementation(\n                        octoprint.plugin.StartupPlugin\n                    )\n                    if implementation is None:\n                        return\n                    implementation.on_after_startup()\n\n                pluginLifecycleManager.add_callback(\"enabled\", call_on_after_startup)\n\n                # if there was a rogue plugin we wouldn't even have made it here, so remove startup triggered safe mode\n                # flag again...\n                self._settings.setBoolean([\"server\", \"incompleteStartup\"], False)\n                self._settings.save()\n\n                # make a backup of the current config\n                self._settings.backup(ext=\"backup\")\n\n                # when we are through with that we also run our preemptive cache\n                if settings().getBoolean([\"devel\", \"cache\", \"preemptive\"]):\n                    self._execute_preemptive_flask_caching(preemptiveCache)\n\n            import threading\n\n            threading.Thread(target=work).start()\n\n        ioloop.add_callback(on_after_startup)\n\n        # prepare our shutdown function\n        def on_shutdown():\n            # will be called on clean system exit and shutdown the watchdog observer and call the on_shutdown methods\n            # on all registered ShutdownPlugins\n            self._logger.info(\"Shutting down...\")\n            observer.stop()\n            observer.join()\n            eventManager.fire(events.Events.SHUTDOWN)\n\n            self._logger.info(\"Calling on_shutdown on plugins\")\n            octoprint.plugin.call_plugin(\n                octoprint.plugin.ShutdownPlugin,\n                \"on_shutdown\",\n                sorting_context=\"ShutdownPlugin.on_shutdown\",\n            )\n\n            # wait for shutdown event to be processed, but maximally for 15s\n            event_timeout = 15.0\n            if eventManager.join(timeout=event_timeout):\n                self._logger.warning(\n                    \"Event loop was still busy processing after {}s, shutting down anyhow\".format(\n                        event_timeout\n                    )\n                )\n\n            if self._octoprint_daemon is not None:\n                self._logger.info(\"Cleaning up daemon pidfile\")\n                self._octoprint_daemon.terminated()\n\n            self._logger.info(\"Goodbye!\")\n\n        atexit.register(on_shutdown)\n\n        def sigterm_handler(*args, **kwargs):\n            # will stop tornado on SIGTERM, making the program exit cleanly\n            def shutdown_tornado():\n                self._logger.debug(\"Shutting down tornado's IOLoop...\")\n                ioloop.stop()\n\n            self._logger.debug(\"SIGTERM received...\")\n            ioloop.add_callback_from_signal(shutdown_tornado)\n\n        signal.signal(signal.SIGTERM, sigterm_handler)\n\n        try:\n            # this is the main loop - as long as tornado is running, OctoPrint is running\n            ioloop.start()\n            self._logger.debug(\"Tornado's IOLoop stopped\")\n        except (KeyboardInterrupt, SystemExit):\n            pass\n        except Exception:\n            self._logger.fatal(\n                \"Now that is embarrassing... Something really really went wrong here. Please report this including the stacktrace below in OctoPrint's bugtracker. Thanks!\"\n            )\n            self._logger.exception(\"Stacktrace follows:\")\n\n    def _log_safe_mode_start(self, self_mode):\n        self_mode_file = os.path.join(\n            self._settings.getBaseFolder(\"data\"), \"last_safe_mode\"\n        )\n        try:\n            with open(self_mode_file, \"w+\", encoding=\"utf-8\") as f:\n                f.write(self_mode)\n        except Exception as ex:\n            self._logger.warn(f\"Could not write safe mode file {self_mode_file}: {ex}\")\n\n    def _create_socket_connection(self, session):\n        global printer, fileManager, analysisQueue, userManager, eventManager, connectivityChecker\n        return util.sockjs.PrinterStateConnection(\n            printer,\n            fileManager,\n            analysisQueue,\n            userManager,\n            groupManager,\n            eventManager,\n            pluginManager,\n            connectivityChecker,\n            session,\n        )\n\n    def _check_for_root(self):\n        if \"geteuid\" in dir(os) and os.geteuid() == 0:\n            exit(\"You should not run OctoPrint as root!\")\n\n    def _get_locale(self):\n        global LANGUAGES\n\n        if \"l10n\" in request.values:\n            return Locale.negotiate([request.values[\"l10n\"]], LANGUAGES)\n\n        if \"X-Locale\" in request.headers:\n            return Locale.negotiate([request.headers[\"X-Locale\"]], LANGUAGES)\n\n        if hasattr(g, \"identity\") and g.identity:\n            userid = g.identity.id\n            try:\n                user_language = userManager.get_user_setting(\n                    userid, (\"interface\", \"language\")\n                )\n                if user_language is not None and not user_language == \"_default\":\n                    return Locale.negotiate([user_language], LANGUAGES)\n            except octoprint.access.users.UnknownUser:\n                pass\n\n        default_language = self._settings.get([\"appearance\", \"defaultLanguage\"])\n        if (\n            default_language is not None\n            and not default_language == \"_default\"\n            and default_language in LANGUAGES\n        ):\n            return Locale.negotiate([default_language], LANGUAGES)\n\n        return Locale.parse(request.accept_languages.best_match(LANGUAGES))\n\n    def _setup_heartbeat_logging(self):\n        logger = logging.getLogger(__name__ + \".heartbeat\")\n\n        def log_heartbeat():\n            logger.info(\"Server heartbeat <3\")\n\n        interval = settings().getFloat([\"server\", \"heartbeat\"])\n        logger.info(f\"Starting server heartbeat, {interval}s interval\")\n\n        timer = octoprint.util.RepeatedTimer(interval, log_heartbeat)\n        timer.start()\n\n    def _setup_app(self, app):\n        global limiter\n\n        from octoprint.server.util.flask import (\n            OctoPrintFlaskRequest,\n            OctoPrintFlaskResponse,\n            OctoPrintJsonEncoder,\n            OctoPrintSessionInterface,\n            PrefixAwareJinjaEnvironment,\n            ReverseProxiedEnvironment,\n        )\n\n        # we must set this here because setting app.debug will access app.jinja_env\n        app.jinja_environment = PrefixAwareJinjaEnvironment\n\n        app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n        app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] = False\n        app.config[\"REMEMBER_COOKIE_HTTPONLY\"] = True\n\n        # we must not set this before TEMPLATES_AUTO_RELOAD is set to True or that won't take\n        app.debug = self._debug\n\n        # setup octoprint's flask json serialization/deserialization\n        app.json_encoder = OctoPrintJsonEncoder\n\n        s = settings()\n\n        secret_key = s.get([\"server\", \"secretKey\"])\n        if not secret_key:\n            import string\n            from random import choice\n\n            chars = string.ascii_lowercase + string.ascii_uppercase + string.digits\n            secret_key = \"\".join(choice(chars) for _ in range(32))\n            s.set([\"server\", \"secretKey\"], secret_key)\n            s.save()\n\n        app.secret_key = secret_key\n\n        reverse_proxied = ReverseProxiedEnvironment(\n            header_prefix=s.get([\"server\", \"reverseProxy\", \"prefixHeader\"]),\n            header_scheme=s.get([\"server\", \"reverseProxy\", \"schemeHeader\"]),\n            header_host=s.get([\"server\", \"reverseProxy\", \"hostHeader\"]),\n            header_server=s.get([\"server\", \"reverseProxy\", \"serverHeader\"]),\n            header_port=s.get([\"server\", \"reverseProxy\", \"portHeader\"]),\n            prefix=s.get([\"server\", \"reverseProxy\", \"prefixFallback\"]),\n            scheme=s.get([\"server\", \"reverseProxy\", \"schemeFallback\"]),\n            host=s.get([\"server\", \"reverseProxy\", \"hostFallback\"]),\n            server=s.get([\"server\", \"reverseProxy\", \"serverFallback\"]),\n            port=s.get([\"server\", \"reverseProxy\", \"portFallback\"]),\n        )\n\n        OctoPrintFlaskRequest.environment_wrapper = reverse_proxied\n        app.request_class = OctoPrintFlaskRequest\n        app.response_class = OctoPrintFlaskResponse\n        app.session_interface = OctoPrintSessionInterface()\n\n        @app.before_request\n        def before_request():\n            g.locale = self._get_locale()\n\n            # used for performance measurement\n            g.start_time = time.monotonic()\n\n            if self._debug and \"perfprofile\" in request.args:\n                try:\n                    from pyinstrument import Profiler\n\n                    g.perfprofiler = Profiler()\n                    g.perfprofiler.start()\n                except ImportError:\n                    # profiler dependency not installed, ignore\n                    pass\n\n        @app.after_request\n        def after_request(response):\n            # send no-cache headers with all POST responses\n            if request.method == \"POST\":\n                response.cache_control.no_cache = True\n\n            response.headers.add(\"X-Clacks-Overhead\", \"GNU Terry Pratchett\")\n\n            if hasattr(g, \"perfprofiler\"):\n                g.perfprofiler.stop()\n                output_html = g.perfprofiler.output_html()\n                return make_response(output_html)\n\n            if hasattr(g, \"start_time\"):\n                end_time = time.monotonic()\n                duration_ms = int((end_time - g.start_time) * 1000)\n                response.headers.add(\"Server-Timing\", f\"app;dur={duration_ms}\")\n\n            return response\n\n        from octoprint.util.jinja import MarkdownFilter\n\n        MarkdownFilter(app)\n\n        from flask_limiter import Limiter\n        from flask_limiter.util import get_remote_address\n\n        app.config[\"RATELIMIT_STRATEGY\"] = \"fixed-window-elastic-expiry\"\n\n        limiter = Limiter(app, key_func=get_remote_address)\n\n    def _setup_i18n(self, app):\n        global babel\n        global LOCALES\n        global LANGUAGES\n\n        babel = Babel(app)\n\n        def get_available_locale_identifiers(locales):\n            result = set()\n\n            # add available translations\n            for locale in locales:\n                result.add(locale.language)\n                if locale.territory:\n                    # if a territory is specified, add that too\n                    result.add(f\"{locale.language}_{locale.territory}\")\n\n            return result\n\n        LOCALES = babel.list_translations()\n        LANGUAGES = get_available_locale_identifiers(LOCALES)\n\n        @babel.localeselector\n        def get_locale():\n            return self._get_locale()\n\n    def _setup_jinja2(self):\n        import re\n\n        app.jinja_env.add_extension(\"jinja2.ext.do\")\n        app.jinja_env.add_extension(\"octoprint.util.jinja.trycatch\")\n\n        def regex_replace(s, find, replace):\n            return re.sub(find, replace, s)\n\n        html_header_regex = re.compile(\n            r\"<h(?P<number>[1-6])>(?P<content>.*?)</h(?P=number)>\"\n        )\n\n        def offset_html_headers(s, offset):\n            def repl(match):\n                number = int(match.group(\"number\"))\n                number += offset\n                if number > 6:\n                    number = 6\n                elif number < 1:\n                    number = 1\n                return \"<h{number}>{content}</h{number}>\".format(\n                    number=number, content=match.group(\"content\")\n                )\n\n            return html_header_regex.sub(repl, s)\n\n        markdown_header_regex = re.compile(\n            r\"^(?P<hashes>#+)\\s+(?P<content>.*)$\", flags=re.MULTILINE\n        )\n\n        def offset_markdown_headers(s, offset):\n            def repl(match):\n                number = len(match.group(\"hashes\"))\n                number += offset\n                if number > 6:\n                    number = 6\n                elif number < 1:\n                    number = 1\n                return \"{hashes} {content}\".format(\n                    hashes=\"#\" * number, content=match.group(\"content\")\n                )\n\n            return markdown_header_regex.sub(repl, s)\n\n        html_link_regex = re.compile(r\"<(?P<tag>a.*?)>(?P<content>.*?)</a>\")\n\n        def externalize_links(text):\n            def repl(match):\n                tag = match.group(\"tag\")\n                if \"href\" not in tag:\n                    return match.group(0)\n\n                if \"target=\" not in tag and \"rel=\" not in tag:\n                    tag += ' target=\"_blank\" rel=\"noreferrer noopener\"'\n\n                content = match.group(\"content\")\n                return f\"<{tag}>{content}</a>\"\n\n            return html_link_regex.sub(repl, text)\n\n        single_quote_regex = re.compile(\"(?<!\\\\\\\\)'\")\n\n        def escape_single_quote(text):\n            return single_quote_regex.sub(\"\\\\'\", text)\n\n        double_quote_regex = re.compile('(?<!\\\\\\\\)\"')\n\n        def escape_double_quote(text):\n            return double_quote_regex.sub('\\\\\"', text)\n\n        app.jinja_env.filters[\"regex_replace\"] = regex_replace\n        app.jinja_env.filters[\"offset_html_headers\"] = offset_html_headers\n        app.jinja_env.filters[\"offset_markdown_headers\"] = offset_markdown_headers\n        app.jinja_env.filters[\"externalize_links\"] = externalize_links\n        app.jinja_env.filters[\"escape_single_quote\"] = app.jinja_env.filters[\n            \"esq\"\n        ] = escape_single_quote\n        app.jinja_env.filters[\"escape_double_quote\"] = app.jinja_env.filters[\n            \"edq\"\n        ] = escape_double_quote\n\n        # configure additional template folders for jinja2\n        import jinja2\n\n        import octoprint.util.jinja\n\n        app.jinja_env.prefix_loader = jinja2.PrefixLoader({})\n\n        loaders = [app.jinja_loader, app.jinja_env.prefix_loader]\n        if octoprint.util.is_running_from_source():\n            root = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../..\"))\n            allowed = [\"AUTHORS.md\", \"SUPPORTERS.md\", \"THIRDPARTYLICENSES.md\"]\n            files = {\"_data/\" + name: os.path.join(root, name) for name in allowed}\n            loaders.append(octoprint.util.jinja.SelectedFilesWithConversionLoader(files))\n\n        # TODO: Remove this in 2.0.0\n        warning_message = \"Loading plugin template '{template}' from '{filename}' without plugin prefix, this is deprecated and will soon no longer be supported.\"\n        loaders.append(\n            octoprint.util.jinja.WarningLoader(\n                octoprint.util.jinja.PrefixChoiceLoader(app.jinja_env.prefix_loader),\n                warning_message,\n            )\n        )\n\n        app.jinja_loader = jinja2.ChoiceLoader(loaders)\n\n        self._register_template_plugins()\n\n        # make sure plugin lifecycle events relevant for jinja2 are taken care of\n        def template_enabled(name, plugin):\n            if plugin.implementation is None or not isinstance(\n                plugin.implementation, octoprint.plugin.TemplatePlugin\n            ):\n                return\n            self._register_additional_template_plugin(plugin.implementation)\n\n        def template_disabled(name, plugin):\n            if plugin.implementation is None or not isinstance(\n                plugin.implementation, octoprint.plugin.TemplatePlugin\n            ):\n                return\n            self._unregister_additional_template_plugin(plugin.implementation)\n\n        pluginLifecycleManager.add_callback(\"enabled\", template_enabled)\n        pluginLifecycleManager.add_callback(\"disabled\", template_disabled)\n\n    def _execute_preemptive_flask_caching(self, preemptive_cache):\n        import time\n\n        from werkzeug.test import EnvironBuilder\n\n        # we clean up entries from our preemptive cache settings that haven't been\n        # accessed longer than server.preemptiveCache.until days\n        preemptive_cache_timeout = settings().getInt(\n            [\"server\", \"preemptiveCache\", \"until\"]\n        )\n        cutoff_timestamp = time.time() - preemptive_cache_timeout * 24 * 60 * 60\n\n        def filter_current_entries(entry):\n            \"\"\"Returns True for entries younger than the cutoff date\"\"\"\n            return \"_timestamp\" in entry and entry[\"_timestamp\"] > cutoff_timestamp\n\n        def filter_http_entries(entry):\n            \"\"\"Returns True for entries targeting http or https.\"\"\"\n            return (\n                \"base_url\" in entry\n                and entry[\"base_url\"]\n                and (\n                    entry[\"base_url\"].startswith(\"http://\")\n                    or entry[\"base_url\"].startswith(\"https://\")\n                )\n            )\n\n        def filter_entries(entry):\n            \"\"\"Combined filter.\"\"\"\n            filters = (filter_current_entries, filter_http_entries)\n            return all([f(entry) for f in filters])\n\n        # filter out all old and non-http entries\n        cache_data = preemptive_cache.clean_all_data(\n            lambda root, entries: list(filter(filter_entries, entries))\n        )\n        if not cache_data:\n            return\n\n        def execute_caching():\n            logger = logging.getLogger(__name__ + \".preemptive_cache\")\n\n            for route in sorted(cache_data.keys(), key=lambda x: (x.count(\"/\"), x)):\n                entries = reversed(\n                    sorted(cache_data[route], key=lambda x: x.get(\"_count\", 0))\n                )\n                for kwargs in entries:\n                    plugin = kwargs.get(\"plugin\", None)\n                    if plugin:\n                        try:\n                            plugin_info = pluginManager.get_plugin_info(\n                                plugin, require_enabled=True\n                            )\n                            if plugin_info is None:\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it is not installed or enabled, preemptive caching makes no sense\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n\n                            implementation = plugin_info.implementation\n                            if implementation is None or not isinstance(\n                                implementation, octoprint.plugin.UiPlugin\n                            ):\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it is not a UiPlugin, preemptive caching makes no sense\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n                            if not implementation.get_ui_preemptive_caching_enabled():\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it has disabled preemptive caching\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n                        except Exception:\n                            logger.exception(\n                                \"Error while trying to check if plugin {} has preemptive caching enabled, skipping entry\"\n                            )\n                            continue\n\n                    additional_request_data = kwargs.get(\"_additional_request_data\", {})\n                    kwargs = {\n                        k: v\n                        for k, v in kwargs.items()\n                        if not k.startswith(\"_\") and not k == \"plugin\"\n                    }\n                    kwargs.update(additional_request_data)\n\n                    try:\n                        start = time.monotonic()\n                        if plugin:\n                            logger.info(\n                                \"Preemptively caching {} (ui {}) for {!r}\".format(\n                                    route, plugin, kwargs\n                                )\n                            )\n                        else:\n                            logger.info(\n                                \"Preemptively caching {} (ui _default) for {!r}\".format(\n                                    route, kwargs\n                                )\n                            )\n\n                        headers = kwargs.get(\"headers\", {})\n                        headers[\"X-Force-View\"] = plugin if plugin else \"_default\"\n                        headers[\"X-Preemptive-Recording\"] = \"yes\"\n                        kwargs[\"headers\"] = headers\n\n                        builder = EnvironBuilder(**kwargs)\n                        app(builder.get_environ(), lambda *a, **kw: None)\n\n                        logger.info(f\"... done in {time.monotonic() - start:.2f}s\")\n                    except Exception:\n                        logger.exception(\n                            \"Error while trying to preemptively cache {} for {!r}\".format(\n                                route, kwargs\n                            )\n                        )\n\n        # asynchronous caching\n        import threading\n\n        cache_thread = threading.Thread(\n            target=execute_caching, name=\"Preemptive Cache Worker\"\n        )\n        cache_thread.daemon = True\n        cache_thread.start()\n\n    def _register_template_plugins(self):\n        template_plugins = pluginManager.get_implementations(\n            octoprint.plugin.TemplatePlugin\n        )\n        for plugin in template_plugins:\n            try:\n                self._register_additional_template_plugin(plugin)\n            except Exception:\n                self._logger.exception(\n                    \"Error while trying to register templates of plugin {}, ignoring it\".format(\n                        plugin._identifier\n                    )\n                )\n\n    def _register_additional_template_plugin(self, plugin):\n        import octoprint.util.jinja\n\n        folder = plugin.get_template_folder()\n        if (\n            folder is not None\n            and plugin.template_folder_key not in app.jinja_env.prefix_loader.mapping\n        ):\n            loader = octoprint.util.jinja.FilteredFileSystemLoader(\n                [plugin.get_template_folder()],\n                path_filter=lambda x: not octoprint.util.is_hidden_path(x),\n            )\n\n            app.jinja_env.prefix_loader.mapping[plugin.template_folder_key] = loader\n\n    def _unregister_additional_template_plugin(self, plugin):\n        folder = plugin.get_template_folder()\n        if (\n            folder is not None\n            and plugin.template_folder_key in app.jinja_env.prefix_loader.mapping\n        ):\n            del app.jinja_env.prefix_loader.mapping[plugin.template_folder_key]\n\n    def _setup_blueprints(self):\n        # do not remove or the index view won't be found\n        import octoprint.server.views  # noqa: F401\n        from octoprint.server.api import api\n        from octoprint.server.util.flask import make_api_error\n\n        blueprints = [api]\n        api_endpoints = [\"/api\"]\n        registrators = [functools.partial(app.register_blueprint, api, url_prefix=\"/api\")]\n\n        # also register any blueprints defined in BlueprintPlugins\n        (\n            blueprints_from_plugins,\n            api_endpoints_from_plugins,\n            registrators_from_plugins,\n        ) = self._prepare_blueprint_plugins()\n        blueprints += blueprints_from_plugins\n        api_endpoints += api_endpoints_from_plugins\n        registrators += registrators_from_plugins\n\n        # and register a blueprint for serving the static files of asset plugins which are not blueprint plugins themselves\n        (blueprints_from_assets, registrators_from_assets) = self._prepare_asset_plugins()\n        blueprints += blueprints_from_assets\n        registrators += registrators_from_assets\n\n        # make sure all before/after_request hook results are attached as well\n        self._add_plugin_request_handlers_to_blueprints(*blueprints)\n\n        # register everything with the system\n        for registrator in registrators:\n            registrator()\n\n        @app.errorhandler(HTTPException)\n        def _handle_api_error(ex):\n            if any(map(lambda x: request.path.startswith(x), api_endpoints)):\n                return make_api_error(ex.description, ex.code)\n            else:\n                return ex\n\n    def _prepare_blueprint_plugins(self):\n        def register_plugin_blueprint(plugin, blueprint, url_prefix):\n            try:\n                app.register_blueprint(\n                    blueprint, url_prefix=url_prefix, name_prefix=\"plugin\"\n                )\n                self._logger.debug(\n                    f\"Registered API of plugin {plugin} under URL prefix {url_prefix}\"\n                )\n            except Exception:\n                self._logger.exception(\n                    f\"Error while registering blueprint of plugin {plugin}, ignoring it\",\n                    extra={\"plugin\": plugin},\n                )\n\n        blueprints = []\n        api_endpoints = []\n        registrators = []\n\n        blueprint_plugins = octoprint.plugin.plugin_manager().get_implementations(\n            octoprint.plugin.BlueprintPlugin\n        )\n        for plugin in blueprint_plugins:\n            blueprint, prefix = self._prepare_blueprint_plugin(plugin)\n\n            blueprints.append(blueprint)\n            api_endpoints += map(\n                lambda x: prefix + x, plugin.get_blueprint_api_prefixes()\n            )\n            registrators.append(\n                functools.partial(\n                    register_plugin_blueprint, plugin._identifier, blueprint, prefix\n                )\n            )\n\n        return blueprints, api_endpoints, registrators\n\n    def _prepare_asset_plugins(self):\n        def register_asset_blueprint(plugin, blueprint, url_prefix):\n            try:\n                app.register_blueprint(\n                    blueprint, url_prefix=url_prefix, name_prefix=\"plugin\"\n                )\n                self._logger.debug(\n                    f\"Registered assets of plugin {plugin} under URL prefix {url_prefix}\"\n                )\n            except Exception:\n                self._logger.exception(\n                    f\"Error while registering blueprint of plugin {plugin}, ignoring it\",\n                    extra={\"plugin\": plugin},\n                )\n\n        blueprints = []\n        registrators = []\n\n        asset_plugins = octoprint.plugin.plugin_manager().get_implementations(\n            octoprint.plugin.AssetPlugin\n        )\n        for plugin in asset_plugins:\n            if isinstance(plugin, octoprint.plugin.BlueprintPlugin):\n                continue\n            blueprint, prefix = self._prepare_asset_plugin(plugin)\n\n            blueprints.append(blueprint)\n            registrators.append(\n                functools.partial(\n                    register_asset_blueprint, plugin._identifier, blueprint, prefix\n                )\n            )\n\n        return blueprints, registrators\n\n    def _prepare_blueprint_plugin(self, plugin):\n        name = plugin._identifier\n        blueprint = plugin.get_blueprint()\n        if blueprint is None:\n            return\n\n        blueprint.before_request(corsRequestHandler)\n        blueprint.before_request(loginFromApiKeyRequestHandler)\n        blueprint.after_request(corsResponseHandler)\n\n        if plugin.is_blueprint_protected():\n            blueprint.before_request(requireLoginRequestHandler)\n\n        url_prefix = f\"/plugin/{name}\"\n        return blueprint, url_prefix\n\n    def _prepare_asset_plugin(self, plugin):\n        name = plugin._identifier\n\n        url_prefix = f\"/plugin/{name}\"\n        blueprint = Blueprint(name, name, static_folder=plugin.get_asset_folder())\n        return blueprint, url_prefix\n\n    def _add_plugin_request_handlers_to_blueprints(self, *blueprints):\n        before_hooks = octoprint.plugin.plugin_manager().get_hooks(\n            \"octoprint.server.api.before_request\"\n        )\n        after_hooks = octoprint.plugin.plugin_manager().get_hooks(\n            \"octoprint.server.api.after_request\"\n        )\n\n        for name, hook in before_hooks.items():\n            plugin = octoprint.plugin.plugin_manager().get_plugin(name)\n            for blueprint in blueprints:\n                try:\n                    result = hook(plugin=plugin)\n                    if isinstance(result, (list, tuple)):\n                        for h in result:\n                            blueprint.before_request(h)\n                except Exception:\n                    self._logger.exception(\n                        \"Error processing before_request hooks from plugin {}\".format(\n                            plugin\n                        ),\n                        extra={\"plugin\": name},\n                    )\n\n        for name, hook in after_hooks.items():\n            plugin = octoprint.plugin.plugin_manager().get_plugin(name)\n            for blueprint in blueprints:\n                try:\n                    result = hook(plugin=plugin)\n                    if isinstance(result, (list, tuple)):\n                        for h in result:\n                            blueprint.after_request(h)\n                except Exception:\n                    self._logger.exception(\n                        \"Error processing after_request hooks from plugin {}\".format(\n                            plugin\n                        ),\n                        extra={\"plugin\": name},\n                    )\n\n    def _setup_mimetypes(self):\n        # Safety measures for Windows... apparently the mimetypes module takes its translation from the windows\n        # registry, and if for some weird reason that gets borked the reported MIME types can be all over the place.\n        # Since at least in Chrome that can cause hilarious issues with JS files (refusal to run them and thus a\n        # borked UI) we make sure that .js always maps to the correct application/javascript, and also throw in a\n        # .css -> text/css for good measure.\n        #\n        # See #3367\n        mimetypes.add_type(\"application/javascript\", \".js\")\n        mimetypes.add_type(\"text/css\", \".css\")\n\n    def _setup_assets(self):\n        global app\n        global assets\n        global pluginManager\n\n        from octoprint.server.util.webassets import MemoryManifest  # noqa: F401\n\n        util.flask.fix_webassets_filtertool()\n\n        base_folder = self._settings.getBaseFolder(\"generated\")\n\n        # clean the folder\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"clean_on_startup\"]):\n            import errno\n            import shutil\n\n            for entry, recreate in (\n                (\"webassets\", True),\n                # no longer used, but clean up just in case\n                (\".webassets-cache\", False),\n                (\".webassets-manifest.json\", False),\n            ):\n                path = os.path.join(base_folder, entry)\n\n                # delete path if it exists\n                if os.path.exists(path):\n                    try:\n                        self._logger.debug(f\"Deleting {path}...\")\n                        if os.path.isdir(path):\n                            shutil.rmtree(path)\n                        else:\n                            os.remove(path)\n                    except Exception:\n                        self._logger.exception(\n                            f\"Error while trying to delete {path}, \" f\"leaving it alone\"\n                        )\n                        continue\n\n                # re-create path if necessary\n                if recreate:\n                    self._logger.debug(f\"Creating {path}...\")\n                    error_text = (\n                        f\"Error while trying to re-create {path}, that might cause \"\n                        f\"errors with the webassets cache\"\n                    )\n                    try:\n                        os.makedirs(path)\n                    except OSError as e:\n                        if e.errno == errno.EACCES:\n                            # that might be caused by the user still having the folder open somewhere, let's try again after\n                            # waiting a bit\n                            import time\n\n                            for n in range(3):\n                                time.sleep(0.5)\n                                self._logger.debug(\n                                    \"Creating {path}: Retry #{retry} after {time}s\".format(\n                                        path=path, retry=n + 1, time=(n + 1) * 0.5\n                                    )\n                                )\n                                try:\n                                    os.makedirs(path)\n                                    break\n                                except Exception:\n                                    if self._logger.isEnabledFor(logging.DEBUG):\n                                        self._logger.exception(\n                                            f\"Ignored error while creating \"\n                                            f\"directory {path}\"\n                                        )\n                                    pass\n                            else:\n                                # this will only get executed if we never did\n                                # successfully execute makedirs above\n                                self._logger.exception(error_text)\n                                continue\n                        else:\n                            # not an access error, so something we don't understand\n                            # went wrong -> log an error and stop\n                            self._logger.exception(error_text)\n                            continue\n                    except Exception:\n                        # not an OSError, so something we don't understand\n                        # went wrong -> log an error and stop\n                        self._logger.exception(error_text)\n                        continue\n\n                self._logger.info(f\"Reset webasset folder {path}...\")\n\n        AdjustedEnvironment = type(Environment)(\n            Environment.__name__,\n            (Environment,),\n            {\"resolver_class\": util.flask.PluginAssetResolver},\n        )\n\n        class CustomDirectoryEnvironment(AdjustedEnvironment):\n            @property\n            def directory(self):\n                return base_folder\n\n        assets = CustomDirectoryEnvironment(app)\n        assets.debug = not self._settings.getBoolean([\"devel\", \"webassets\", \"bundle\"])\n\n        # we should rarely if ever regenerate the webassets in production and can wait a\n        # few seconds for regeneration in development, if it means we can get rid of\n        # a whole monkey patch and in internal use of pickle with non-tamperproof files\n        assets.cache = False\n        assets.manifest = \"memory\"\n\n        UpdaterType = type(util.flask.SettingsCheckUpdater)(\n            util.flask.SettingsCheckUpdater.__name__,\n            (util.flask.SettingsCheckUpdater,),\n            {\"updater\": assets.updater},\n        )\n        assets.updater = UpdaterType\n\n        preferred_stylesheet = self._settings.get([\"devel\", \"stylesheet\"])\n\n        dynamic_core_assets = util.flask.collect_core_assets()\n        dynamic_plugin_assets = util.flask.collect_plugin_assets(\n            preferred_stylesheet=preferred_stylesheet\n        )\n\n        js_libs = [\n            \"js/lib/babel-polyfill.min.js\",\n            \"js/lib/jquery/jquery.min.js\",\n            \"js/lib/modernizr.custom.js\",\n            \"js/lib/lodash.min.js\",\n            \"js/lib/sprintf.min.js\",\n            \"js/lib/knockout.js\",\n            \"js/lib/knockout.mapping-latest.js\",\n            \"js/lib/babel.js\",\n            \"js/lib/bootstrap/bootstrap.js\",\n            \"js/lib/bootstrap/bootstrap-modalmanager.js\",\n            \"js/lib/bootstrap/bootstrap-modal.js\",\n            \"js/lib/bootstrap/bootstrap-slider.js\",\n            \"js/lib/bootstrap/bootstrap-tabdrop.js\",\n            \"js/lib/jquery/jquery-ui.js\",\n            \"js/lib/jquery/jquery.flot.js\",\n            \"js/lib/jquery/jquery.flot.time.js\",\n            \"js/lib/jquery/jquery.flot.crosshair.js\",\n            \"js/lib/jquery/jquery.flot.resize.js\",\n            \"js/lib/jquery/jquery.iframe-transport.js\",\n            \"js/lib/jquery/jquery.fileupload.js\",\n            \"js/lib/jquery/jquery.slimscroll.min.js\",\n            \"js/lib/jquery/jquery.qrcode.min.js\",\n            \"js/lib/jquery/jquery.bootstrap.wizard.js\",\n            \"js/lib/pnotify/pnotify.core.min.js\",\n            \"js/lib/pnotify/pnotify.buttons.min.js\",\n            \"js/lib/pnotify/pnotify.callbacks.min.js\",\n            \"js/lib/pnotify/pnotify.confirm.min.js\",\n            \"js/lib/pnotify/pnotify.desktop.min.js\",\n            \"js/lib/pnotify/pnotify.history.min.js\",\n            \"js/lib/pnotify/pnotify.mobile.min.js\",\n            \"js/lib/pnotify/pnotify.nonblock.min.js\",\n            \"js/lib/pnotify/pnotify.reference.min.js\",\n            \"js/lib/pnotify/pnotify.tooltip.min.js\",\n            \"js/lib/pnotify/pnotify.maxheight.js\",\n            \"js/lib/moment-with-locales.min.js\",\n            \"js/lib/pusher.color.min.js\",\n            \"js/lib/detectmobilebrowser.js\",\n            \"js/lib/ua-parser.min.js\",\n            \"js/lib/md5.min.js\",\n            \"js/lib/bootstrap-slider-knockout-binding.js\",\n            \"js/lib/loglevel.min.js\",\n            \"js/lib/sockjs.min.js\",\n            \"js/lib/hls.js\",\n            \"js/lib/less.js\",\n        ]\n\n        css_libs = [\n            \"css/bootstrap.min.css\",\n            \"css/bootstrap-modal.css\",\n            \"css/bootstrap-slider.css\",\n            \"css/bootstrap-tabdrop.css\",\n            \"vendor/font-awesome-3.2.1/css/font-awesome.min.css\",\n            \"vendor/fontawesome-6.1.1/css/all.min.css\",\n            \"vendor/fontawesome-6.1.1/css/v4-shims.min.css\",\n            \"css/jquery.fileupload-ui.css\",\n            \"css/pnotify.core.min.css\",\n            \"css/pnotify.buttons.min.css\",\n            \"css/pnotify.history.min.css\",\n        ]\n\n        # a couple of custom filters\n        from webassets.filter import register_filter\n\n        from octoprint.server.util.webassets import (\n            GzipFile,\n            JsDelimiterBundler,\n            JsPluginBundle,\n            LessImportRewrite,\n            RJSMinExtended,\n            SourceMapRemove,\n            SourceMapRewrite,\n        )\n\n        register_filter(LessImportRewrite)\n        register_filter(SourceMapRewrite)\n        register_filter(SourceMapRemove)\n        register_filter(JsDelimiterBundler)\n        register_filter(GzipFile)\n        register_filter(RJSMinExtended)\n\n        def all_assets_for_plugins(collection):\n            \"\"\"Gets all plugin assets for a dict of plugin->assets\"\"\"\n            result = []\n            for assets in collection.values():\n                result += assets\n            return result\n\n        # -- JS --------------------------------------------------------------------------------------------------------\n\n        filters = [\"sourcemap_remove\"]\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"minify\"]):\n            filters += [\"rjsmin_extended\"]\n        filters += [\"js_delimiter_bundler\", \"gzip\"]\n\n        js_filters = filters\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"minify_plugins\"]):\n            js_plugin_filters = js_filters\n        else:\n            js_plugin_filters = [x for x in js_filters if x not in (\"rjsmin_extended\",)]\n\n        def js_bundles_for_plugins(collection, filters=None):\n            \"\"\"Produces JsPluginBundle instances that output IIFE wrapped assets\"\"\"\n            result = OrderedDict()\n            for plugin, assets in collection.items():\n                if len(assets):\n                    result[plugin] = JsPluginBundle(plugin, *assets, filters=filters)\n            return result\n\n        js_core = (\n            dynamic_core_assets[\"js\"]\n            + all_assets_for_plugins(dynamic_plugin_assets[\"bundled\"][\"js\"])\n            + [\"js/app/dataupdater.js\", \"js/app/helpers.js\", \"js/app/main.js\"]\n        )\n        js_plugins = js_bundles_for_plugins(\n            dynamic_plugin_assets[\"external\"][\"js\"], filters=\"js_delimiter_bundler\"\n        )\n\n        clientjs_core = dynamic_core_assets[\"clientjs\"] + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"clientjs\"]\n        )\n        clientjs_plugins = js_bundles_for_plugins(\n            dynamic_plugin_assets[\"external\"][\"clientjs\"], filters=\"js_delimiter_bundler\"\n        )\n\n        js_libs_bundle = Bundle(\n            *js_libs, output=\"webassets/packed_libs.js\", filters=\",\".join(js_filters)\n        )\n\n        js_core_bundle = Bundle(\n            *js_core, output=\"webassets/packed_core.js\", filters=\",\".join(js_filters)\n        )\n\n        if len(js_plugins) == 0:\n            js_plugins_bundle = Bundle(*[])\n        else:\n            js_plugins_bundle = Bundle(\n                *js_plugins.values(),\n                output=\"webassets/packed_plugins.js\",\n                filters=\",\".join(js_plugin_filters),\n            )\n\n        js_app_bundle = Bundle(\n            js_plugins_bundle,\n            js_core_bundle,\n            output=\"webassets/packed_app.js\",\n            filters=\",\".join(js_plugin_filters),\n        )\n\n        js_client_core_bundle = Bundle(\n            *clientjs_core,\n            output=\"webassets/packed_client_core.js\",\n            filters=\",\".join(js_filters),\n        )\n\n        if len(clientjs_plugins) == 0:\n            js_client_plugins_bundle = Bundle(*[])\n        else:\n            js_client_plugins_bundle = Bundle(\n                *clientjs_plugins.values(),\n                output=\"webassets/packed_client_plugins.js\",\n                filters=\",\".join(js_plugin_filters),\n            )\n\n        js_client_bundle = Bundle(\n            js_client_core_bundle,\n            js_client_plugins_bundle,\n            output=\"webassets/packed_client.js\",\n            filters=\",\".join(js_plugin_filters),\n        )\n\n        # -- CSS -------------------------------------------------------------------------------------------------------\n\n        css_filters = [\"cssrewrite\", \"gzip\"]\n\n        css_core = list(dynamic_core_assets[\"css\"]) + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"css\"]\n        )\n        css_plugins = list(\n            all_assets_for_plugins(dynamic_plugin_assets[\"external\"][\"css\"])\n        )\n\n        css_libs_bundle = Bundle(\n            *css_libs, output=\"webassets/packed_libs.css\", filters=\",\".join(css_filters)\n        )\n\n        if len(css_core) == 0:\n            css_core_bundle = Bundle(*[])\n        else:\n            css_core_bundle = Bundle(\n                *css_core,\n                output=\"webassets/packed_core.css\",\n                filters=\",\".join(css_filters),\n            )\n\n        if len(css_plugins) == 0:\n            css_plugins_bundle = Bundle(*[])\n        else:\n            css_plugins_bundle = Bundle(\n                *css_plugins,\n                output=\"webassets/packed_plugins.css\",\n                filters=\",\".join(css_filters),\n            )\n\n        css_app_bundle = Bundle(\n            css_core,\n            css_plugins,\n            output=\"webassets/packed_app.css\",\n            filters=\",\".join(css_filters),\n        )\n\n        # -- LESS ------------------------------------------------------------------------------------------------------\n\n        less_filters = [\"cssrewrite\", \"less_importrewrite\", \"gzip\"]\n\n        less_core = list(dynamic_core_assets[\"less\"]) + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"less\"]\n        )\n        less_plugins = all_assets_for_plugins(dynamic_plugin_assets[\"external\"][\"less\"])\n\n        if len(less_core) == 0:\n            less_core_bundle = Bundle(*[])\n        else:\n            less_core_bundle = Bundle(\n                *less_core,\n                output=\"webassets/packed_core.less\",\n                filters=\",\".join(less_filters),\n            )\n\n        if len(less_plugins) == 0:\n            less_plugins_bundle = Bundle(*[])\n        else:\n            less_plugins_bundle = Bundle(\n                *less_plugins,\n                output=\"webassets/packed_plugins.less\",\n                filters=\",\".join(less_filters),\n            )\n\n        less_app_bundle = Bundle(\n            less_core,\n            less_plugins,\n            output=\"webassets/packed_app.less\",\n            filters=\",\".join(less_filters),\n        )\n\n        # -- asset registration ----------------------------------------------------------------------------------------\n\n        assets.register(\"js_libs\", js_libs_bundle)\n        assets.register(\"js_client_core\", js_client_core_bundle)\n        for plugin, bundle in clientjs_plugins.items():\n            # register our collected clientjs plugin bundles so that they are bound to the environment\n            assets.register(f\"js_client_plugin_{plugin}\", bundle)\n        assets.register(\"js_client_plugins\", js_client_plugins_bundle)\n        assets.register(\"js_client\", js_client_bundle)\n        assets.register(\"js_core\", js_core_bundle)\n        for plugin, bundle in js_plugins.items():\n            # register our collected plugin bundles so that they are bound to the environment\n            assets.register(f\"js_plugin_{plugin}\", bundle)\n        assets.register(\"js_plugins\", js_plugins_bundle)\n        assets.register(\"js_app\", js_app_bundle)\n        assets.register(\"css_libs\", css_libs_bundle)\n        assets.register(\"css_core\", css_core_bundle)\n        assets.register(\"css_plugins\", css_plugins_bundle)\n        assets.register(\"css_app\", css_app_bundle)\n        assets.register(\"less_core\", less_core_bundle)\n        assets.register(\"less_plugins\", less_plugins_bundle)\n        assets.register(\"less_app\", less_app_bundle)\n\n    def _setup_login_manager(self):\n        global loginManager\n\n        loginManager = LoginManager()\n\n        # \"strong\" is incompatible to remember me, see maxcountryman/flask-login#156. It also causes issues with\n        # clients toggling between IPv4 and IPv6 client addresses due to names being resolved one way or the other as\n        # at least observed on a Win10 client targeting \"localhost\", resolved as both \"127.0.0.1\" and \"::1\"\n        loginManager.session_protection = \"basic\"\n\n        loginManager.user_loader(load_user)\n        loginManager.unauthorized_handler(unauthorized_user)\n        loginManager.anonymous_user = userManager.anonymous_user_factory\n        loginManager.request_loader(load_user_from_request)\n\n        loginManager.init_app(app, add_context_processor=False)\n\n    def _start_intermediary_server(self):\n        import socket\n        import threading\n        from http.server import BaseHTTPRequestHandler, HTTPServer\n\n        host = self._host\n        port = self._port\n\n        class IntermediaryServerHandler(BaseHTTPRequestHandler):\n            def __init__(self, rules=None, *args, **kwargs):\n                if rules is None:\n                    rules = []\n                self.rules = rules\n                BaseHTTPRequestHandler.__init__(self, *args, **kwargs)\n\n            def do_GET(self):\n                request_path = self.path\n                if \"?\" in request_path:\n                    request_path = request_path[0 : request_path.find(\"?\")]\n\n                for rule in self.rules:\n                    path, data, content_type = rule\n                    if request_path == path:\n                        self.send_response(200)\n                        if content_type:\n                            self.send_header(\"Content-Type\", content_type)\n                        self.end_headers()\n                        if isinstance(data, str):\n                            data = data.encode(\"utf-8\")\n                        self.wfile.write(data)\n                        break\n                else:\n                    self.send_response(404)\n                    self.wfile.write(b\"Not found\")\n\n        base_path = os.path.realpath(\n            os.path.join(os.path.dirname(__file__), \"..\", \"static\")\n        )\n        rules = [\n            (\n                \"/\",\n                [\n                    \"intermediary.html\",\n                ],\n                \"text/html\",\n            ),\n            (\"/favicon.ico\", [\"img\", \"tentacle-20x20.png\"], \"image/png\"),\n            (\n                \"/intermediary.gif\",\n                bytes(\n                    base64.b64decode(\n                        \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n                    )\n                ),\n                \"image/gif\",\n            ),\n        ]\n\n        def contents(args):\n            path = os.path.join(base_path, *args)\n            if not os.path.isfile(path):\n                return \"\"\n\n            with open(path, \"rb\") as f:\n                data = f.read()\n            return data\n\n        def process(rule):\n            if len(rule) == 2:\n                path, data = rule\n                content_type = None\n            else:\n                path, data, content_type = rule\n\n            if isinstance(data, (list, tuple)):\n                data = contents(data)\n\n            return path, data, content_type\n\n        rules = list(\n            map(process, filter(lambda rule: len(rule) == 2 or len(rule) == 3, rules))\n        )\n\n        HTTPServerV4 = HTTPServer\n\n        class HTTPServerV6(HTTPServer):\n            address_family = socket.AF_INET6\n\n        class HTTPServerV6SingleStack(HTTPServerV6):\n            def __init__(self, *args, **kwargs):\n                HTTPServerV6.__init__(self, *args, **kwargs)\n\n                # explicitly set V6ONLY flag - seems to be the default, but just to make sure...\n                self.socket.setsockopt(\n                    octoprint.util.net.IPPROTO_IPV6, octoprint.util.net.IPV6_V6ONLY, 1\n                )\n\n        class HTTPServerV6DualStack(HTTPServerV6):\n            def __init__(self, *args, **kwargs):\n                HTTPServerV6.__init__(self, *args, **kwargs)\n\n                # explicitly unset V6ONLY flag\n                self.socket.setsockopt(\n                    octoprint.util.net.IPPROTO_IPV6, octoprint.util.net.IPV6_V6ONLY, 0\n                )\n\n        if \":\" in host:\n            # v6\n            if host == \"::\" and not self._v6_only:\n                ServerClass = HTTPServerV6DualStack\n            else:\n                ServerClass = HTTPServerV6SingleStack\n        else:\n            # v4\n            ServerClass = HTTPServerV4\n\n        if host == \"::\":\n            if self._v6_only:\n                self._logger.debug(f\"Starting intermediary server on http://[::]:{port}\")\n            else:\n                self._logger.debug(\n                    \"Starting intermediary server on http://0.0.0.0:{port} and http://[::]:{port}\".format(\n                        port=port\n                    )\n                )\n        else:\n            self._logger.debug(\n                \"Starting intermediary server on http://{}:{}\".format(\n                    host if \":\" not in host else \"[\" + host + \"]\", port\n                )\n            )\n\n        self._intermediary_server = ServerClass(\n            (host, port),\n            lambda *args, **kwargs: IntermediaryServerHandler(rules, *args, **kwargs),\n            bind_and_activate=False,\n        )\n\n        # if possible, make sure our socket's port descriptor isn't handed over to subprocesses\n        from octoprint.util.platform import set_close_exec\n\n        try:\n            set_close_exec(self._intermediary_server.fileno())\n        except Exception:\n            self._logger.exception(\n                \"Error while attempting to set_close_exec on intermediary server socket\"\n            )\n\n        # then bind the server and have it serve our handler until stopped\n        try:\n            self._intermediary_server.server_bind()\n            self._intermediary_server.server_activate()\n        except Exception as exc:\n            self._intermediary_server.server_close()\n\n            if isinstance(exc, UnicodeDecodeError) and sys.platform == \"win32\":\n                # we end up here if the hostname contains non-ASCII characters due to\n                # https://bugs.python.org/issue26227 - tell the user they need\n                # to either change their hostname or read up other options in\n                # https://github.com/OctoPrint/OctoPrint/issues/3963\n                raise CannotStartServerException(\n                    \"OctoPrint cannot start due to a Python bug \"\n                    \"(https://bugs.python.org/issue26227). Your \"\n                    \"computer's host name contains non-ASCII characters. \"\n                    \"Please either change your computer's host name to \"\n                    \"contain only ASCII characters, or take a look at \"\n                    \"https://github.com/OctoPrint/OctoPrint/issues/3963 for \"\n                    \"other options.\"\n                )\n            else:\n                raise\n\n        def serve():\n            try:\n                self._intermediary_server.serve_forever()\n            except Exception:\n                self._logger.exception(\"Error in intermediary server\")\n\n        thread = threading.Thread(target=serve)\n        thread.daemon = True\n        thread.start()\n\n        self._logger.info(\"Intermediary server started\")\n\n    def _stop_intermediary_server(self):\n        if self._intermediary_server is None:\n            return\n        self._logger.info(\"Shutting down intermediary server...\")\n        self._intermediary_server.shutdown()\n        self._intermediary_server.server_close()\n        self._logger.info(\"Intermediary server shut down\")\n\n    def _setup_plugin_permissions(self):\n        global pluginManager\n\n        from octoprint.access.permissions import PluginOctoPrintPermission\n\n        key_whitelist = re.compile(r\"[A-Za-z0-9_]*\")\n\n        def permission_key(plugin, definition):\n            return \"PLUGIN_{}_{}\".format(plugin.upper(), definition[\"key\"].upper())\n\n        def permission_name(plugin, definition):\n            return \"{}: {}\".format(plugin, definition[\"name\"])\n\n        def permission_role(plugin, role):\n            return f\"plugin_{plugin}_{role}\"\n\n        def process_regular_permission(plugin_info, definition):\n            permissions = []\n            for key in definition.get(\"permissions\", []):\n                permission = octoprint.access.permissions.Permissions.find(key)\n\n                if permission is None:\n                    # if there is still no permission found, postpone this - maybe it is a permission from\n                    # another plugin that hasn't been loaded yet\n                    return False\n\n                permissions.append(permission)\n\n            roles = definition.get(\"roles\", [])\n            description = definition.get(\"description\", \"\")\n            dangerous = definition.get(\"dangerous\", False)\n            default_groups = definition.get(\"default_groups\", [])\n\n            roles_and_permissions = [\n                permission_role(plugin_info.key, role) for role in roles\n            ] + permissions\n\n            key = permission_key(plugin_info.key, definition)\n            permission = PluginOctoPrintPermission(\n                permission_name(plugin_info.name, definition),\n                description,\n                plugin=plugin_info.key,\n                dangerous=dangerous,\n                default_groups=default_groups,\n                *roles_and_permissions,\n            )\n            setattr(\n                octoprint.access.permissions.Permissions,\n                key,\n                PluginOctoPrintPermission(\n                    permission_name(plugin_info.name, definition),\n                    description,\n                    plugin=plugin_info.key,\n                    dangerous=dangerous,\n                    default_groups=default_groups,\n                    *roles_and_permissions,\n                ),\n            )\n\n            self._logger.info(\n                \"Added new permission from plugin {}: {} (needs: {!r})\".format(\n                    plugin_info.key, key, \", \".join(map(repr, permission.needs))\n                )\n            )\n            return True\n\n        postponed = []\n\n        hooks = pluginManager.get_hooks(\"octoprint.access.permissions\")\n        for name, factory in hooks.items():\n            try:\n                if isinstance(factory, (tuple, list)):\n                    additional_permissions = list(factory)\n                elif callable(factory):\n                    additional_permissions = factory()\n                else:\n                    raise ValueError(\"factory must be either a callable, tuple or list\")\n\n                if not isinstance(additional_permissions, (tuple, list)):\n                    raise ValueError(\n                        \"factory result must be either a tuple or a list of permission definition dicts\"\n                    )\n\n                plugin_info = pluginManager.get_plugin_info(name)\n                for p in additional_permissions:\n                    if not isinstance(p, dict):\n                        continue\n\n                    if \"key\" not in p or \"name\" not in p:\n                        continue\n\n                    if not key_whitelist.match(p[\"key\"]):\n                        self._logger.warning(\n                            \"Got permission with invalid key from plugin {}: {}\".format(\n                                name, p[\"key\"]\n                            )\n                        )\n                        continue\n\n                    if not process_regular_permission(plugin_info, p):\n                        postponed.append((plugin_info, p))\n            except Exception:\n                self._logger.exception(\n                    f\"Error while creating permission instance/s from {name}\"\n                )\n\n        # final resolution passes\n        pass_number = 1\n        still_postponed = []\n        while len(postponed):\n            start_length = len(postponed)\n            self._logger.debug(\n                \"Plugin permission resolution pass #{}, \"\n                \"{} unresolved permissions...\".format(pass_number, start_length)\n            )\n\n            for plugin_info, definition in postponed:\n                if not process_regular_permission(plugin_info, definition):\n                    still_postponed.append((plugin_info, definition))\n\n            self._logger.debug(\n                \"... pass #{} done, {} permissions left to resolve\".format(\n                    pass_number, len(still_postponed)\n                )\n            )\n\n            if len(still_postponed) == start_length:\n                # no change, looks like some stuff is unresolvable - let's bail\n                for plugin_info, definition in still_postponed:\n                    self._logger.warning(\n                        \"Unable to resolve permission from {}: {!r}\".format(\n                            plugin_info.key, definition\n                        )\n                    )\n                break\n\n            postponed = still_postponed\n            still_postponed = []\n            pass_number += 1\n\n\nclass LifecycleManager:\n    def __init__(self, plugin_manager):\n        self._plugin_manager = plugin_manager\n\n        self._plugin_lifecycle_callbacks = defaultdict(list)\n        self._logger = logging.getLogger(__name__)\n\n        def wrap_plugin_event(lifecycle_event, new_handler):\n            orig_handler = getattr(self._plugin_manager, \"on_plugin_\" + lifecycle_event)\n\n            def handler(*args, **kwargs):\n                if callable(orig_handler):\n                    orig_handler(*args, **kwargs)\n                if callable(new_handler):\n                    new_handler(*args, **kwargs)\n\n            return handler\n\n        def on_plugin_event_factory(lifecycle_event):\n            def on_plugin_event(name, plugin):\n                self.on_plugin_event(lifecycle_event, name, plugin)\n\n            return on_plugin_event\n\n        for event in (\"loaded\", \"unloaded\", \"enabled\", \"disabled\"):\n            wrap_plugin_event(event, on_plugin_event_factory(event))\n\n    def on_plugin_event(self, event, name, plugin):\n        for lifecycle_callback in self._plugin_lifecycle_callbacks[event]:\n            lifecycle_callback(name, plugin)\n\n    def add_callback(self, events, callback):\n        if isinstance(events, str):\n            events = [events]\n\n        for event in events:\n            self._plugin_lifecycle_callbacks[event].append(callback)\n\n    def remove_callback(self, callback, events=None):\n        if events is None:\n            for event in self._plugin_lifecycle_callbacks:\n                if callback in self._plugin_lifecycle_callbacks[event]:\n                    self._plugin_lifecycle_callbacks[event].remove(callback)\n        else:\n            if isinstance(events, str):\n                events = [events]\n\n            for event in events:\n                if callback in self._plugin_lifecycle_callbacks[event]:\n                    self._plugin_lifecycle_callbacks[event].remove(callback)\n\n\nclass CannotStartServerException(Exception):\n    pass\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport logging\n\nfrom flask import (\n    Blueprint,\n    Response,\n    abort,\n    current_app,\n    g,\n    jsonify,\n    make_response,\n    request,\n    session,\n)\nfrom flask_login import current_user, login_user, logout_user\nfrom werkzeug.exceptions import HTTPException\n\nimport octoprint.access.users\nimport octoprint.plugin\nimport octoprint.server\nimport octoprint.util.net as util_net\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.events import Events, eventManager\nfrom octoprint.server import NO_CONTENT\nfrom octoprint.server.util import (\n    corsRequestHandler,\n    corsResponseHandler,\n    loginFromApiKeyRequestHandler,\n    loginFromAuthorizationHeaderRequestHandler,\n    noCachingExceptGetResponseHandler,\n)\nfrom octoprint.server.util.flask import (\n    get_json_command_from_request,\n    get_remote_address,\n    no_firstrun_access,\n    passive_login,\n)\nfrom octoprint.settings import settings as s\nfrom octoprint.settings import valid_boolean_trues\nfrom octoprint.vendor.flask_principal import Identity, identity_changed\n\n# ~~ init api blueprint, including sub modules\n\napi = Blueprint(\"api\", __name__)\n\nfrom . import access as api_access  # noqa: F401,E402\nfrom . import connection as api_connection  # noqa: F401,E402\nfrom . import files as api_files  # noqa: F401,E402\nfrom . import job as api_job  # noqa: F401,E402\nfrom . import languages as api_languages  # noqa: F401,E402\nfrom . import printer as api_printer  # noqa: F401,E402\nfrom . import printer_profiles as api_printer_profiles  # noqa: F401,E402\nfrom . import settings as api_settings  # noqa: F401,E402\nfrom . import slicing as api_slicing  # noqa: F401,E402\nfrom . import system as api_system  # noqa: F401,E402\nfrom . import timelapse as api_timelapse  # noqa: F401,E402\nfrom . import users as api_users  # noqa: F401,E402\n\nVERSION = \"0.1\"\n\napi.after_request(noCachingExceptGetResponseHandler)\n\napi.before_request(corsRequestHandler)\napi.before_request(loginFromAuthorizationHeaderRequestHandler)\napi.before_request(loginFromApiKeyRequestHandler)\napi.after_request(corsResponseHandler)\n\n# ~~ data from plugins\n\n\n@api.route(\"/plugin/<string:name>\", methods=[\"GET\"])\ndef pluginData(name):\n    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(\n        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin\n    )\n    if not api_plugins:\n        abort(404)\n\n    if len(api_plugins) > 1:\n        abort(500, description=\"More than one api provider registered, can't proceed\")\n\n    try:\n        api_plugin = api_plugins[0]\n        if api_plugin.is_api_adminonly() and not current_user.is_admin:\n            abort(403)\n\n        response = api_plugin.on_api_get(request)\n\n        if response is not None:\n            message = (\n                \"Rewriting response from {} to use abort(msg, code) - please \"\n                \"consider upgrading the implementation accordingly\".format(name)\n            )\n            if (\n                isinstance(response, Response)\n                and response.mimetype == \"text/html\"\n                and response.status_code >= 300\n            ):\n                # this actually looks like an error response\n                logging.getLogger(__name__).info(message)\n                abort(response.status_code, description=response.data)\n            elif (\n                isinstance(response, tuple)\n                and len(response) == 2\n                and isinstance(response[0], (str, bytes))\n                and response[1] >= 300\n            ):\n                # this actually looks like an error response\n                logging.getLogger(__name__).info(message)\n                abort(response[1], response[0])\n            return response\n        return NO_CONTENT\n    except HTTPException:\n        raise\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error calling SimpleApiPlugin {name}\", extra={\"plugin\": name}\n        )\n        return abort(500)\n\n\n# ~~ commands for plugins\n\n\n@api.route(\"/plugin/<string:name>\", methods=[\"POST\"])\n@no_firstrun_access\ndef pluginCommand(name):\n    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(\n        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin\n    )\n\n    if not api_plugins:\n        abort(400)\n\n    if len(api_plugins) > 1:\n        abort(500, description=\"More than one api provider registered, can't proceed\")\n\n    api_plugin = api_plugins[0]\n    try:\n        valid_commands = api_plugin.get_api_commands()\n        if valid_commands is None:\n            abort(405)\n\n        if api_plugin.is_api_adminonly() and not Permissions.ADMIN.can():\n            abort(403)\n\n        command, data, response = get_json_command_from_request(request, valid_commands)\n        if response is not None:\n            return response\n\n        response = api_plugin.on_api_command(command, data)\n        if response is not None:\n            return response\n        return NO_CONTENT\n    except HTTPException:\n        raise\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error while executing SimpleApiPlugin {name}\",\n            extra={\"plugin\": name},\n        )\n        return abort(500)\n\n\n# ~~ first run setup\n\n\n@api.route(\"/setup/wizard\", methods=[\"GET\"])\ndef wizardState():\n    if (\n        not s().getBoolean([\"server\", \"firstRun\"])\n        and octoprint.server.userManager.has_been_customized()\n        and not Permissions.ADMIN.can()\n    ):\n        abort(403)\n\n    seen_wizards = s().get([\"server\", \"seenWizards\"])\n\n    result = {}\n    wizard_plugins = octoprint.server.pluginManager.get_implementations(\n        octoprint.plugin.WizardPlugin\n    )\n    for implementation in wizard_plugins:\n        name = implementation._identifier\n        try:\n            required = implementation.is_wizard_required()\n            details = implementation.get_wizard_details()\n            version = implementation.get_wizard_version()\n            ignored = octoprint.plugin.WizardPlugin.is_wizard_ignored(\n                seen_wizards, implementation\n            )\n        except Exception:\n            logging.getLogger(__name__).exception(\n                \"There was an error fetching wizard \"\n                \"details for {}, ignoring\".format(name),\n                extra={\"plugin\": name},\n            )\n        else:\n            result[name] = {\n                \"required\": required,\n                \"details\": details,\n                \"version\": version,\n                \"ignored\": ignored,\n            }\n\n    return jsonify(result)\n\n\n@api.route(\"/setup/wizard\", methods=[\"POST\"])\ndef wizardFinish():\n    if (\n        not s().getBoolean([\"server\", \"firstRun\"])\n        and octoprint.server.userManager.has_been_customized()\n        and not Permissions.ADMIN.can()\n    ):\n        abort(403)\n\n    data = {}\n    try:\n        data = request.get_json()\n    except Exception:\n        abort(400)\n\n    if data is None:\n        abort(400)\n\n    if \"handled\" not in data:\n        abort(400)\n    handled = data[\"handled\"]\n\n    if s().getBoolean([\"server\", \"firstRun\"]):\n        s().setBoolean([\"server\", \"firstRun\"], False)\n\n    seen_wizards = dict(s().get([\"server\", \"seenWizards\"]))\n\n    wizard_plugins = octoprint.server.pluginManager.get_implementations(\n        octoprint.plugin.WizardPlugin\n    )\n    for implementation in wizard_plugins:\n        name = implementation._identifier\n        try:\n            implementation.on_wizard_finish(name in handled)\n            if name in handled:\n                seen_wizards[name] = implementation.get_wizard_version()\n        except Exception:\n            logging.getLogger(__name__).exception(\n                \"There was an error finishing the \"\n                \"wizard for {}, ignoring\".format(name),\n                extra={\"plugin\": name},\n            )\n\n    s().set([\"server\", \"seenWizards\"], seen_wizards)\n    s().save()\n\n    return NO_CONTENT\n\n\n# ~~ system state\n\n\n@api.route(\"/version\", methods=[\"GET\"])\n@Permissions.STATUS.require(403)\ndef apiVersion():\n    return jsonify(\n        server=octoprint.server.VERSION,\n        api=VERSION,\n        text=f\"OctoPrint {octoprint.server.DISPLAY_VERSION}\",\n    )\n\n\n@api.route(\"/server\", methods=[\"GET\"])\n@Permissions.STATUS.require(403)\ndef serverStatus():\n    return jsonify(version=octoprint.server.VERSION, safemode=octoprint.server.safe_mode)\n\n\n# ~~ Login/user handling\n\n\n@api.route(\"/login\", methods=[\"POST\"])\n@octoprint.server.limiter.limit(\n    \"3/minute;5/10 minutes;10/hour\",\n    deduct_when=lambda response: response.status_code == 403,\n    error_message=\"You have made too many failed login attempts. Please try again later.\",\n)\ndef login():\n    data = request.get_json()\n    if not data:\n        data = request.values\n\n    if \"user\" in data and \"pass\" in data:\n        username = data[\"user\"]\n        password = data[\"pass\"]\n\n        if \"remember\" in data and data[\"remember\"] in valid_boolean_trues:\n            remember = True\n        else:\n            remember = False\n\n        if \"usersession.id\" in session:\n            _logout(current_user)\n\n        user = octoprint.server.userManager.find_user(username)\n        if user is not None:\n            if octoprint.server.userManager.check_password(username, password):\n                if not user.is_active:\n                    abort(403)\n\n                user = octoprint.server.userManager.login_user(user)\n                session[\"usersession.id\"] = user.session\n                g.user = user\n\n                login_user(user, remember=remember)\n                identity_changed.send(\n                    current_app._get_current_object(), identity=Identity(user.get_id())\n                )\n                session[\"login_mechanism\"] = \"http\"\n\n                remote_addr = get_remote_address(request)\n                logging.getLogger(__name__).info(\n                    \"Actively logging in user {} from {}\".format(\n                        user.get_id(), remote_addr\n                    )\n                )\n\n                response = user.as_dict()\n                response[\"_is_external_client\"] = s().getBoolean(\n                    [\"server\", \"ipCheck\", \"enabled\"]\n                ) and not util_net.is_lan_address(\n                    remote_addr,\n                    additional_private=s().get([\"server\", \"ipCheck\", \"trustedSubnets\"]),\n                )\n                response[\"_login_mechanism\"] = session[\"login_mechanism\"]\n\n                r = make_response(jsonify(response))\n                r.delete_cookie(\"active_logout\")\n\n                eventManager().fire(\n                    Events.USER_LOGGED_IN, payload={\"username\": user.get_id()}\n                )\n\n                return r\n\n        abort(403)\n\n    elif \"passive\" in data:\n        return passive_login()\n\n    abort(400, description=\"Neither user and pass attributes nor passive flag present\")\n\n\n@api.route(\"/logout\", methods=[\"POST\"])\ndef logout():\n    username = None\n    if current_user:\n        username = current_user.get_id()\n\n    # logout from user manager...\n    _logout(current_user)\n\n    # ... and from flask login (and principal)\n    logout_user()\n\n    # ... and send an active logout session cookie\n    r = make_response(jsonify(octoprint.server.userManager.anonymous_user_factory()))\n    r.set_cookie(\"active_logout\", \"true\")\n\n    if username:\n        eventManager().fire(Events.USER_LOGGED_OUT, payload={\"username\": username})\n\n    return r\n\n\ndef _logout(user):\n    if \"usersession.id\" in session:\n        del session[\"usersession.id\"]\n    if \"login_mechanism\" in session:\n        del session[\"login_mechanism\"]\n    octoprint.server.userManager.logout_user(user)\n\n\n@api.route(\"/currentuser\", methods=[\"GET\"])\ndef get_current_user():\n    return jsonify(\n        name=current_user.get_name(),\n        permissions=[permission.key for permission in current_user.effective_permissions],\n        groups=[group.key for group in current_user.groups],\n    )\n\n\n# ~~ Test utils\n\n\n@api.route(\"/util/test\", methods=[\"POST\"])\n@no_firstrun_access\n@Permissions.ADMIN.require(403)\ndef utilTest():\n    valid_commands = {\n        \"path\": [\"path\"],\n        \"url\": [\"url\"],\n        \"server\": [\"host\", \"port\"],\n        \"resolution\": [\"name\"],\n        \"address\": [],\n    }\n\n    command, data, response = get_json_command_from_request(request, valid_commands)\n    if response is not None:\n        return response\n\n    if command == \"path\":\n        return _test_path(data)\n    elif command == \"url\":\n        return _test_url(data)\n    elif command == \"server\":\n        return _test_server(data)\n    elif command == \"resolution\":\n        return _test_resolution(data)\n    elif command == \"address\":\n        return _test_address(data)\n\n\ndef _test_path(data):\n    import os\n\n    from octoprint.util.paths import normalize\n\n    path = normalize(data[\"path\"], real=False)\n    if not path:\n        return jsonify(\n            path=path,\n            exists=False,\n            typeok=False,\n            broken_symlink=False,\n            access=False,\n            result=False,\n        )\n\n    unreal_path = path\n    path = os.path.realpath(path)\n\n    check_type = None\n    check_access = []\n\n    if \"check_type\" in data and data[\"check_type\"] in (\"file\", \"dir\"):\n        check_type = data[\"check_type\"]\n\n    if \"check_access\" in data:\n        request_check_access = data[\"check_access\"]\n        if not isinstance(request_check_access, list):\n            request_check_access = list(request_check_access)\n\n        check_access = [\n            check for check in request_check_access if check in (\"r\", \"w\", \"x\")\n        ]\n\n    allow_create_dir = data.get(\"allow_create_dir\", False) and check_type == \"dir\"\n    check_writable_dir = data.get(\"check_writable_dir\", False) and check_type == \"dir\"\n    if check_writable_dir and \"w\" not in check_access:\n        check_access.append(\"w\")\n\n    # check if path exists\n    exists = os.path.exists(path)\n    if not exists:\n        if os.path.islink(unreal_path):\n            # broken symlink, see #2644\n            logging.getLogger(__name__).error(\n                \"{} is a broken symlink pointing at non existing {}\".format(\n                    unreal_path, path\n                )\n            )\n            return jsonify(\n                path=unreal_path,\n                exists=False,\n                typeok=False,\n                broken_symlink=True,\n                access=False,\n                result=False,\n            )\n\n        elif check_type == \"dir\" and allow_create_dir:\n            try:\n                os.makedirs(path)\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    f\"Error while trying to create {path}\"\n                )\n                return jsonify(\n                    path=path,\n                    exists=False,\n                    typeok=False,\n                    broken_symlink=False,\n                    access=False,\n                    result=False,\n                )\n            else:\n                exists = True\n\n    # check path type\n    type_mapping = {\"file\": os.path.isfile, \"dir\": os.path.isdir}\n    if check_type:\n        typeok = type_mapping[check_type](path)\n    else:\n        typeok = exists\n\n    # check if path allows requested access\n    access_mapping = {\"r\": os.R_OK, \"w\": os.W_OK, \"x\": os.X_OK}\n    if check_access:\n        mode = 0\n        for a in map(lambda x: access_mapping[x], check_access):\n            mode |= a\n        access = os.access(path, mode)\n    else:\n        access = exists\n\n    if check_writable_dir and check_type == \"dir\":\n        try:\n            test_path = os.path.join(path, \".testballoon.txt\")\n            with open(test_path, \"wb\") as f:\n                f.write(b\"Test\")\n            os.remove(test_path)\n        except Exception:\n            logging.getLogger(__name__).exception(\n                f\"Error while testing if {path} is really writable\"\n            )\n            return jsonify(\n                path=path,\n                exists=exists,\n                typeok=typeok,\n                broken_symlink=False,\n                access=False,\n                result=False,\n            )\n\n    return jsonify(\n        path=path,\n        exists=exists,\n        typeok=typeok,\n        broken_symlink=False,\n        access=access,\n        result=exists and typeok and access,\n    )\n\n\ndef _test_url(data):\n    import requests\n\n    from octoprint import util as util\n\n    class StatusCodeRange:\n        def __init__(self, start=None, end=None):\n            self.start = start\n            self.end = end\n\n        def __contains__(self, item):\n            if not isinstance(item, int):\n                return False\n            if self.start and self.end:\n                return self.start <= item < self.end\n            elif self.start:\n                return self.start <= item\n            elif self.end:\n                return item < self.end\n            else:\n                return False\n\n        def as_dict(self):\n            return {\"start\": self.start, \"end\": self.end}\n\n    status_ranges = {\n        \"informational\": StatusCodeRange(start=100, end=200),\n        \"success\": StatusCodeRange(start=200, end=300),\n        \"redirection\": StatusCodeRange(start=300, end=400),\n        \"client_error\": StatusCodeRange(start=400, end=500),\n        \"server_error\": StatusCodeRange(start=500, end=600),\n        \"normal\": StatusCodeRange(end=400),\n        \"error\": StatusCodeRange(start=400, end=600),\n        \"any\": StatusCodeRange(start=100),\n        \"timeout\": StatusCodeRange(start=0, end=1),\n    }\n\n    url = data[\"url\"]\n    method = data.get(\"method\", \"HEAD\")\n    timeout = 3.0\n    valid_ssl = True\n    check_status = [status_ranges[\"normal\"]]\n    content_type_whitelist = None\n    content_type_blacklist = None\n\n    if \"timeout\" in data:\n        try:\n            timeout = float(data[\"timeout\"])\n        except Exception:\n            abort(400, description=\"timeout is invalid\")\n\n    if \"validSsl\" in data:\n        valid_ssl = data[\"validSsl\"] in valid_boolean_trues\n\n    if \"status\" in data:\n        request_status = data[\"status\"]\n        if not isinstance(request_status, list):\n            request_status = [request_status]\n\n        check_status = []\n        for rs in request_status:\n            if isinstance(rs, int):\n                check_status.append([rs])\n            else:\n                if rs in status_ranges:\n                    check_status.append(status_ranges[rs])\n                else:\n                    code = requests.codes[rs]\n                    if code is not None:\n                        check_status.append([code])\n\n    if \"content_type_whitelist\" in data:\n        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):\n            abort(400, description=\"content_type_whitelist must be a list of mime types\")\n        content_type_whitelist = list(\n            map(util.parse_mime_type, data[\"content_type_whitelist\"])\n        )\n    if \"content_type_blacklist\" in data:\n        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):\n            abort(400, description=\"content_type_blacklist must be a list of mime types\")\n        content_type_blacklist = list(\n            map(util.parse_mime_type, data[\"content_type_blacklist\"])\n        )\n\n    response_result = None\n    outcome = True\n    status = 0\n    try:\n        with requests.request(\n            method=method, url=url, timeout=timeout, verify=valid_ssl, stream=True\n        ) as response:\n            status = response.status_code\n            outcome = outcome and any(map(lambda x: status in x, check_status))\n            content_type = response.headers.get(\"content-type\")\n\n            response_result = {\n                \"headers\": dict(response.headers),\n                \"content_type\": content_type,\n            }\n\n            if not content_type and data.get(\"content_type_guess\") in valid_boolean_trues:\n                content = response.content\n                content_type = util.guess_mime_type(bytearray(content))\n\n            if not content_type:\n                content_type = \"application/octet-stream\"\n\n            response_result = {\"assumed_content_type\": content_type}\n\n            parsed_content_type = util.parse_mime_type(content_type)\n\n            in_whitelist = content_type_whitelist is None or any(\n                map(\n                    lambda x: util.mime_type_matches(parsed_content_type, x),\n                    content_type_whitelist,\n                )\n            )\n            in_blacklist = content_type_blacklist is not None and any(\n                map(\n                    lambda x: util.mime_type_matches(parsed_content_type, x),\n                    content_type_blacklist,\n                )\n            )\n\n            if not in_whitelist or in_blacklist:\n                # we don't support this content type\n                response.close()\n                outcome = False\n\n            elif \"response\" in data and (\n                data[\"response\"] in valid_boolean_trues\n                or data[\"response\"] in (\"json\", \"bytes\")\n            ):\n                if data[\"response\"] == \"json\":\n                    content = response.json()\n\n                else:\n                    import base64\n\n                    content = base64.standard_b64encode(response.content)\n\n                response_result[\"content\"] = content\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error while running a test {method} request on {url}\"\n        )\n        outcome = False\n\n    result = {\"url\": url, \"status\": status, \"result\": outcome}\n    if response_result:\n        result[\"response\"] = response_result\n\n    return jsonify(**result)\n\n\ndef _test_server(data):\n    host = data[\"host\"]\n    try:\n        port = int(data[\"port\"])\n    except Exception:\n        abort(400, description=\"Invalid value for port\")\n\n    timeout = 3.05\n    if \"timeout\" in data:\n        try:\n            timeout = float(data[\"timeout\"])\n        except Exception:\n            abort(400, description=\"Invalid value for timeout\")\n\n    protocol = data.get(\"protocol\", \"tcp\")\n    if protocol not in (\"tcp\", \"udp\"):\n        abort(400, description=\"Invalid value for protocol\")\n\n    from octoprint.util import server_reachable\n\n    reachable = server_reachable(host, port, timeout=timeout, proto=protocol)\n\n    result = {\"host\": host, \"port\": port, \"protocol\": protocol, \"result\": reachable}\n\n    return jsonify(**result)\n\n\ndef _test_resolution(data):\n    name = data[\"name\"]\n\n    from octoprint.util.net import resolve_host\n\n    resolvable = len(resolve_host(name)) > 0\n\n    result = {\"name\": name, \"result\": resolvable}\n\n    return jsonify(**result)\n\n\ndef _test_address(data):\n    import netaddr\n\n    from octoprint.util.net import get_lan_ranges, sanitize_address\n\n    remote_addr = data.get(\"address\")\n    if not remote_addr:\n        remote_addr = get_remote_address(request)\n\n    remote_addr = sanitize_address(remote_addr)\n    ip = netaddr.IPAddress(remote_addr)\n\n    lan_subnets = get_lan_ranges()\n\n    detected_subnet = None\n    for subnet in lan_subnets:\n        if ip in subnet:\n            detected_subnet = subnet\n            break\n\n    result = {\n        \"is_lan_address\": detected_subnet is not None,\n        \"address\": remote_addr,\n    }\n\n    if detected_subnet is not None:\n        result[\"subnet\"] = str(detected_subnet)\n\n    return jsonify(**result)\n", "body{padding-top:40px;padding-bottom:40px;background-color:#f5f5f5}.form-signin{max-width:300px;padding:19px 29px 29px;margin:0 auto 20px;background-color:#fff;border:1px solid #e5e5e5;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;-webkit-box-shadow:0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:0 1px 2px rgba(0,0,0,0.05);box-shadow:0 1px 2px rgba(0,0,0,0.05)}.form-signin .form-signin-heading,.form-signin .checkbox{margin-bottom:10px}.form-signin input[type=\"text\"],.form-signin input[type=\"password\"]{font-size:16px;height:auto;margin-bottom:15px;padding:7px 9px}#login-error-credentials,#login-error-rate,#login-offline{display:none}#login-error-credentials.in,#login-error-rate.in,#login-offline.in{display:block}#login-overlay{position:fixed;top:0;left:0;width:100%;height:100%;z-index:10000;display:none}#login-overlay.in{display:block}#login-overlay .background{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#000000;filter:alpha(opacity=50);-moz-opacity:.5;-khtml-opacity:.5;opacity:.5}#login-overlay .wrapper{position:absolute;top:0;bottom:0;left:0;right:0}#login-overlay .wrapper .outer{display:table;width:100%;height:100%}#login-overlay .wrapper .outer .inner{display:table-cell;vertical-align:middle}#login-overlay .wrapper .outer .inner .content{text-align:center;color:white}#noscript{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#ffffff;z-index:12310}#noscript .wrapper{position:absolute;top:0;bottom:0;left:0;right:0}#noscript .wrapper .outer{display:table;width:100%;height:100%}#noscript .wrapper .outer .inner{display:table-cell;vertical-align:middle}#noscript .wrapper .outer .inner .content{text-align:center}", "/*\n * Will get included into the login dialog, NOT into the regular OctoPrint\n * web application.\n */\n\n$(function () {\n    var OctoPrint = window.OctoPrint;\n\n    OctoPrint.loginui = {\n        startedUp: false\n    };\n\n    var overlayElement = $(\"#login-overlay\");\n    var errorCredentialsElement = $(\"#login-error-credentials\");\n    var errorRateElement = $(\"#login-error-rate\");\n    var offlineElement = $(\"#login-offline\");\n    var buttonElement = $(\"#login-button\");\n    var reconnectElement = $(\"#login-reconnect\");\n\n    var ignoreDisconnect = false;\n\n    buttonElement.click(function () {\n        var usernameElement = $(\"#login-user\");\n        var passwordElement = $(\"#login-password\");\n        var rememberElement = $(\"#login-remember\");\n\n        var username = usernameElement.val();\n        var password = passwordElement.val();\n        var remember = rememberElement.prop(\"checked\");\n\n        overlayElement.addClass(\"in\");\n        errorCredentialsElement.removeClass(\"in\");\n        errorRateElement.removeClass(\"in\");\n\n        OctoPrint.browser\n            .login(username, password, remember)\n            .done(() => {\n                ignoreDisconnect = true;\n                window.location.href = REDIRECT_URL;\n            })\n            .fail((xhr) => {\n                usernameElement.val(USER_ID);\n                passwordElement.val(\"\");\n\n                if (USER_ID) {\n                    passwordElement.focus();\n                } else {\n                    usernameElement.focus();\n                }\n\n                overlayElement.removeClass(\"in\");\n                if (xhr.status === 429) {\n                    errorRateElement.addClass(\"in\");\n                } else {\n                    errorCredentialsElement.addClass(\"in\");\n                }\n            });\n\n        return false;\n    });\n\n    OctoPrint.options.baseurl = BASE_URL;\n\n    OctoPrint.socket.onConnected = () => {\n        buttonElement.prop(\"disabled\", false);\n        offlineElement.removeClass(\"in\");\n    };\n\n    OctoPrint.socket.onDisconnected = () => {\n        if (ignoreDisconnect) return;\n        buttonElement.prop(\"disabled\", true);\n        offlineElement.addClass(\"in\");\n    };\n\n    reconnectElement.click(() => {\n        OctoPrint.socket.reconnect();\n    });\n\n    OctoPrint.socket.connect();\n    OctoPrint.loginui.startedUp = true;\n});\n", "body {\n  padding-top: 40px;\n  padding-bottom: 40px;\n  background-color: #f5f5f5;\n}\n\n.form-signin {\n  max-width: 300px;\n  padding: 19px 29px 29px;\n  margin: 0 auto 20px;\n  background-color: #fff;\n  border: 1px solid #e5e5e5;\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  border-radius: 5px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\n  -moz-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\n\n  .form-signin-heading,\n  .checkbox {\n    margin-bottom: 10px;\n  }\n\n  input[type=\"text\"],\n  input[type=\"password\"] {\n    font-size: 16px;\n    height: auto;\n    margin-bottom: 15px;\n    padding: 7px 9px;\n  }\n}\n\n#login-error-credentials,\n#login-error-rate,\n#login-offline {\n  display: none;\n\n  &.in {\n    display: block;\n  }\n}\n\n#login-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 10000;\n  display: none;\n\n  &.in {\n    display: block;\n  }\n\n  .background {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-color: #000000;\n    filter: alpha(opacity=50);\n    -moz-opacity: 0.5;\n    -khtml-opacity: 0.5;\n    opacity: 0.5;\n  }\n\n  .wrapper {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n\n    .outer {\n      display: table;\n      width: 100%;\n      height: 100%;\n\n      .inner {\n        display: table-cell;\n        vertical-align: middle;\n\n        .content {\n          text-align: center;\n          color: white;\n        }\n      }\n    }\n  }\n}\n\n#noscript {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: #ffffff;\n  z-index: 12310;\n\n  .wrapper {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n\n    .outer {\n      display: table;\n      width: 100%;\n      height: 100%;\n\n      .inner {\n        display: table-cell;\n        vertical-align: middle;\n\n        .content {\n          text-align: center;\n        }\n      }\n    }\n  }\n}\n", "<html>\n<head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <title>OctoPrint Login</title>\n\n    <link rel=\"shortcut icon\" href=\"{{ url_for('static', filename='img/tentacle-32x32.png') }}\">\n    <link rel=\"mask-icon\" href=\"{{ url_for('static', filename='img/mask.svg') }}\" color=\"#56BE37\">\n    <link rel=\"mask-icon-theme\" href=\"{{ url_for('static', filename='img/mask-theme.svg') }}\" color=\"#56BE37\">\n    <link rel=\"apple-touch-icon\" sizes=\"114x114\" href=\"{{ url_for('static', filename='img/apple-touch-icon-114x114.png') }}\">\n    <link rel=\"apple-touch-icon\" sizes=\"144x144\" href=\"{{ url_for('static', filename='img/apple-touch-icon-144x144.png') }}\">\n\n    <!-- le CSS -->\n\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"css/bootstrap.min.css\") }}\">\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"css/bootstrap-responsive.min.css\") }}\">\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"vendor/font-awesome-5.15.1/css/all.min.css\") }}\">\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"vendor/font-awesome-5.15.1/css/v4-shims.css\") }}\">\n    <link rel=\"stylesheet\" href=\"{{ url_for(\"static\", filename=\"css/login.css\") }}\">\n\n    {% for url in theming %}\n        <link rel=\"stylesheet\" href=\"{{ url }}\">\n    {% endfor %}\n\n    <!-- le javascript -->\n\n    <script>\n        var BASE_URL = \"{{ url_for('index') }}\";\n        var REDIRECT_URL = \"{{ redirect_url|e }}\";\n        var USER_ID = \"{{ user_id|e }}\";\n    </script>\n    <script src=\"{{ url_for(\"static\", filename=\"js/lib/jquery/jquery.min.js\") }}\"></script>\n    <script src=\"{{ url_for(\"static\", filename=\"js/lib/sockjs.min.js\") }}\"></script>\n    <script src=\"{{ url_for(\"static\", filename=\"js/lib/bootstrap/bootstrap.js\") }}\"></script>\n    <script src=\"{{ url_for(\"static\", filename=\"js/lib/lodash.min.js\") }}\"></script>\n\n    {% assets \"js_client\" %}\n        <script type=\"text/javascript\" src=\"{{ ASSET_URL }}\"></script>\n    {% endassets %}\n\n    <script src=\"{{ url_for(\"static\", filename=\"js/login/login.js\") }}\"></script>\n</head>\n<body>\n    <noscript>\n        <style type=\"text/css\">\n            #login,\n            #login-overlay {\n                display:none;\n            }\n        </style>\n        <div id=\"noscript\">\n            <div class=\"wrapper\">\n                <div class=\"outer\">\n                    <div class=\"inner\">\n                        <div class=\"content\">\n                            <h1 class=\"text-error\">{{ _('You don\\'t seem to have JavaScript enabled') }}</h1>\n                            {{ _('OctoPrint\\'s UI requires JavaScript to work. Please enable JavaScript and reload.') }}\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </noscript>\n\n    <div id=\"login\" class=\"container\">\n        <form class=\"form-signin\">\n            <h2 class=\"form-signin-heading\" data-test-id=\"login-title\">{{ _('Please log in') }}</h2>\n\n            <div id=\"login-error-credentials\" class=\"alert alert-error\" data-test-id=\"login-error\">{{ _('Incorrect username or password. Hint: Both are case sensitive!') }}</div>\n            <div id=\"login-error-rate\" class=\"alert alert-error\" data-test-id=\"login-error-rate\">{{ _('You have made too many failed login attempts. Please try again later.') }}</div>\n            <div id=\"login-offline\" class=\"alert alert-error\">{{ _('Server is currently offline.') }} <a id=\"login-reconnect\" href=\"javascript:void(0)\">{{ _('Reconnect...') }}</a></div>\n\n            {% if user_id %}<p>\n                {{ _('The following account is required:') }} {{ user_id|e }}\n            </p>{% elif logged_in %}<p>\n                {{ _('An account with the following permissions is required:') }} {{ permission_names|join(\", \") }}\n            </p>{% endif %}\n\n            <input type=\"text\" id=\"login-user\" data-test-id=\"login-username\" class=\"input-block-level\" placeholder=\"{{ _('Username')|edq }}\" {% if user_id %}value=\"{{ user_id|edq }}\" disabled{% endif %} autofocus autocapitalize=\"none\">\n            <input type=\"password\" id=\"login-password\" data-test-id=\"login-password\" class=\"input-block-level\" placeholder=\"{{ _('Password')|edq }}\">\n            <span class=\"pull-right\"><small><a href=\"https://faq.octoprint.org/forgotten-password\" id=\"login-forgotpassword\" target=\"_blank\" tabindex=\"-1\">{{ _('Forgot password?') }}</a></small></span>\n            <label class=\"checkbox\">\n                <input type=\"checkbox\" id=\"login-remember\" data-test-id=\"login-remember-me\"> {{ _('Remember me') }}\n            </label>\n            <button class=\"btn btn-block btn-large btn-primary\" id=\"login-button\" data-test-id=\"login-submit\" type=\"submit\">{{ _('Log in') }}</button>\n        </form>\n    </div>\n\n    <div id=\"login-overlay\">\n        <div class=\"background\"></div>\n        <div class=\"wrapper\">\n            <div class=\"outer\">\n                <div class=\"inner\">\n                    <div class=\"content\">\n                        <i class=\"fas fa-spinner fa-spin fa-4x\"></i>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</body>\n</html>\n"], "filenames": ["setup.py", "src/octoprint/server/__init__.py", "src/octoprint/server/api/__init__.py", "src/octoprint/static/css/login.css", "src/octoprint/static/js/login/login.js", "src/octoprint/static/less/login.less", "src/octoprint/templates/login.jinja2"], "buggy_code_start_loc": [45, 72, 283, 1, 14, 34, 68], "buggy_code_end_loc": [45, 1434, 283, 2, 51, 35, 69], "fixing_code_start_loc": [46, 73, 284, 1, 14, 34, 68], "fixing_code_end_loc": [47, 1445, 289, 2, 57, 36, 70], "type": "CWE-307", "message": "An attacker can freely brute force username and password and can takeover any account. An attacker could easily guess user passwords and gain access to user and administrative accounts.", "other": {"cve": {"id": "CVE-2022-2822", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-15T11:21:32.300", "lastModified": "2022-08-16T16:30:16.077", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An attacker can freely brute force username and password and can takeover any account. An attacker could easily guess user passwords and gain access to user and administrative accounts."}, {"lang": "es", "value": "Un atacante puede forzar libremente el nombre de usuario y la contrase\u00f1a y tomar el control de cualquier cuenta. Un atacante podr\u00eda adivinar f\u00e1cilmente las contrase\u00f1as de los usuarios y conseguir acceso a las cuentas de usuario y administrativas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-307"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octoprint:octoprint:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.0", "matchCriteriaId": "41F628B9-62B3-4DE5-B12C-BAF02356A97A"}]}]}], "references": [{"url": "https://github.com/octoprint/octoprint/commit/82c892ba40b3741d1b7711d949e56af64f5bc2de", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/6369f355-e6ef-4469-af75-0f6ff00cde3d", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octoprint/octoprint/commit/82c892ba40b3741d1b7711d949e56af64f5bc2de"}}