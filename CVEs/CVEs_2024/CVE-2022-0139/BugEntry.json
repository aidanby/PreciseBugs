{"buggy_code": ["/* radare2 - LGPL - Copyright 2021 - condret */\n\n#include <r_io.h>\n#include <r_util.h>\n\nR_API RIOBank *r_io_bank_new(const char *name) {\n\tr_return_val_if_fail (name, NULL);\n\tRIOBank *bank = R_NEW0 (RIOBank);\n\tif (!bank) {\n\t\treturn NULL;\n\t}\n\tbank->name = strdup (name);\n\tbank->submaps = r_crbtree_new (free);\n\tif (!bank->submaps) {\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->maprefs = r_list_newf (free);\n\tif (!bank->maprefs) {\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->todo = r_queue_new (8);\n\tif (!bank->todo) {\n\t\tr_list_free (bank->maprefs);\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\treturn bank;\n}\n\nR_API void r_io_bank_clear(RIOBank *bank) {\n\tr_return_if_fail (bank);\n\twhile (!r_queue_is_empty (bank->todo)) {\n\t\tfree (r_queue_dequeue (bank->todo));\n\t}\n\tbank->last_used = NULL;\n\tr_crbtree_clear (bank->submaps);\n\tr_list_purge (bank->maprefs);\n}\n\nR_API void r_io_bank_free(RIOBank *bank) {\n\tif (bank) {\n\t\tr_queue_free (bank->todo);\n\t\tr_list_free (bank->maprefs);\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank->name);\n\t\tfree (bank);\n\t}\n}\n\nR_API void r_io_bank_init(RIO *io) {\n\tr_return_if_fail (io);\n\tr_io_bank_fini (io);\n\tio->banks = r_id_storage_new (0, UT32_MAX);\n}\n\n\nstatic bool _bank_free_cb(void *user, void *data, ut32 id) {\n\tr_io_bank_free ((RIOBank *)data);\n\treturn true;\n}\n\nR_API void r_io_bank_fini(RIO *io) {\n\tr_return_if_fail (io);\n\tif (io->banks) {\n\t\tr_id_storage_foreach (io->banks, _bank_free_cb, NULL);\n\t\tr_id_storage_free (io->banks);\n\t\tio->banks = NULL;\n\t}\n}\n\nR_API RIOBank *r_io_bank_get(RIO *io, const ut32 bankid) {\n\tr_return_val_if_fail (io && io->banks, NULL);\n\treturn (RIOBank *)r_id_storage_get (io->banks, bankid);\n}\n\nR_API ut32 r_io_bank_first(RIO *io) {\n\tut32 bankid = -1;\n\tr_id_storage_get_lowest (io->banks, &bankid);\n\treturn bankid;\n}\n\nR_API bool r_io_bank_use(RIO *io, ut32 bankid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (bank) {\n\t\tio->bank = bankid;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API bool r_io_bank_add(RIO *io, RIOBank *bank) {\n\tr_return_val_if_fail (io && io->banks && bank, false);\n\treturn r_id_storage_add (io->banks, bank, &bank->id);\n}\n\nstatic RIOMapRef *_mapref_from_map(RIOMap *map) {\n\tRIOMapRef *mapref = R_NEW (RIOMapRef);\n\tif (mapref) {\n\t\tmapref->id = map->id;\n\t\tmapref->ts = map->ts;\n\t}\n\treturn mapref;\n}\n\n// incoming - in\n// cb for finding sm by lower boundary vaddr\nstatic int _find_sm_by_from_vaddr_cb(void *incoming, void *in, void *user) {\n\tRIOSubMap *bd = (RIOSubMap *)incoming, *sm = (RIOSubMap *)in;\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int _find_sm_by_vaddr_cb(void *incoming, void *in, void *user) {\n\tconst ut64 addr = ((ut64 *)incoming)[0];\n\tRIOSubMap *sm = (RIOSubMap *)in;\n\tif (r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tif (addr < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\nstatic int _find_lowest_intersection_sm_cb(void *incoming, void *in, void *user) {\n\tRIOSubMap *bd = (RIOSubMap *)incoming, *sm = (RIOSubMap *)in;\n\tif (r_io_submap_overlap (bd, sm)) {\n\t\treturn 0;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\n// returns the node containing the submap with lowest itv.addr, that intersects with sm\nstatic RRBNode *_find_entry_submap_node(RIOBank *bank, RIOSubMap *sm) {\n\tRRBNode *node = r_crbtree_find_node (bank->submaps, sm, _find_lowest_intersection_sm_cb, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRRBNode *prev = r_rbnode_prev (node);\n\twhile (prev && r_io_submap_overlap (((RIOSubMap *)prev->data), sm)) {\n\t\tnode = prev;\n\t\tprev = r_rbnode_prev (node);\n\t}\n\treturn node;\n}\n\nR_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}\n\nR_API bool r_io_bank_map_add_bottom(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_prepend (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\twhile (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\tr_list_prepend (bank->maprefs, mapref);\n\t\t\tfree (sm);\n\t\t\treturn true;\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\tr_list_prepend (bank->maprefs, mapref);\n\treturn true;\n}\n\nR_API bool r_io_bank_map_priorize(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\treturn false;\nfound:\n\tif (iter == bank->maprefs->tail) {\t//tail is top\n\t\treturn r_io_map_get_by_ref (io, mapref) ? true : false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// if this happens, something is really fucked up\n\t\tfree (sm);\n\t\treturn false;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_itv_eq (bd->itv, sm->itv)) {\n\t\t// no need to insert new sm, if boundaries match perfectly\n\t\t// instead override mapref of existing node/submap\n\t\tbd->mapref = *mapref;\n\t\tfree (sm);\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// bd completly overlaps sm on both ends,\n\t\t// therefor split bd into 2 maps => bd and bdsm\n\t\t// |---bd---||--sm--|-bdsm-|\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL) &\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t//delete all submaps that are completly included in sm\n\t\t// this can be optimized, there is no need to do search here\n\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tr_list_iter_to_top (bank->maprefs, iter);\n\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n}\n\n// deletes submaps that belong to a mapref with a specified priority from the submap tree of a bank.\n// the mapref is accessed by it's iter from the priority list in the bank,\n// so that the function can insert new submaps that fill the gaps. The iter represents the priority of the mapref.\n// this function DOES NOT delete the iter from the list. (that way it can be used for delete and relocate)\nstatic void _delete_submaps_from_bank_tree(RIO *io, RIOBank *bank, RListIter *prio, RIOMap *map) {\n\tRIOSubMap fake_sm;\n\tfake_sm.itv = map->itv;\n\tfake_sm.mapref.id = map->id;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\treturn;\n\t}\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\twhile (bd && r_io_submap_overlap (bd, (&fake_sm))) {\n\t\t// this loop deletes all affected submaps from the rbtree\n\t\t// and also enqueues them in bank->todo\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\tif (bd->mapref.id == fake_sm.mapref.id) {\n\t\t\tr_queue_enqueue (bank->todo, R_NEWCOPY (RIOSubMap, bd));\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tentry = next;\n\t\tbd = entry ? (RIOSubMap *)entry->data : NULL;\n\t}\n\tRListIter *iter = prio;\n\twhile (!r_queue_is_empty (bank->todo)) {\n\t\t// now check for each deleted submap if a lower map intersects with it\n\t\t// and create new submaps accordingly, and fill the gaps\n\t\tRIOSubMap *sm = r_queue_dequeue (bank->todo);\n\t\tRListIter *ator = r_list_iter_get_prev (iter);\n\t\twhile (ator) {\n\t\t\tmap = r_io_map_get_by_ref (io, (RIOMapRef *)ator->data);\n\t\t\tator = r_list_iter_get_prev (ator);\n\t\t\tif (!map) {\n\t\t\t\t// if this happens, something is fucked up, and no submap should be inserted\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if the map and sm intersect, the intersecting submap needs to be inserted in the tree\n\t\t\t// there are 5 cases to consider here\n\t\t\t// 1. no intersection: just continue to the next iteration\n\t\t\t// 2. map overlaps sm on both ends: insert submap for map with boundaries of sm\n\t\t\t// 3. map overlaps sm on the upper end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 4. map overlaps sm on the lower end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 5. sm overlaps sm on both ends: split sm into 2 submaps and enqueue new one in banks->todo; insert submap for map; adjust sm boundaries\n\t\t\tif (r_io_submap_to (sm) < r_io_map_from (map) || r_io_submap_from (sm) > r_io_map_to (map)) {\n\t\t\t\t// case 1\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRIOMapRef *mapref = _mapref_from_map (map);\n\t\t\tbd = r_io_submap_new (io, mapref);\n\t\t\tfree (mapref);\n\t\t\tif (!bd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_from (sm) >= r_io_map_from (map)) {\n\t\t\t\t// case 4 and 2\n\t\t\t\tr_io_submap_set_from (bd, r_io_submap_from (sm));\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t\t// case 2\n\t\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// case 4\n\t\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t// case 3\n\t\t\t\t// adjust bd upper boundary to avoid overlap with existing submaps\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t// adjust sm upper boundary to avoid hitting again on sm in further iterations\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// case 5 because all other cases are already handled\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (bd) + 1);\n\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_queue_enqueue (bank->todo, bdsm);\n\t\t}\n\t\tfree (sm);\n\t}\n}\n\nR_API bool r_io_bank_map_depriorize(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (bank && map, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref = NULL;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\t// map is not referenced by this bank\n\treturn false;\nfound:\n\tif (iter == bank->maprefs->head) {\n\t\t// map is already lowest priority\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\t_delete_submaps_from_bank_tree (io, bank, iter, map);\n\tr_list_delete (bank->maprefs, iter);\n\treturn r_io_bank_map_add_bottom (io, bankid, mapid);\n}\n\n// compared 2 maprefs of the same bank by their priority (position in  the mapref list)\n// returns 0, if both have the same priority\n// returns 1, if mr0 has higher priority than mr1\n// returns -1, if mr1 has higher priority tham mr0\n// returns 0, if neither mr0 nor mr1 are an element of the bank\nstatic int _mapref_priority_cmp(RIOBank *bank, RIOMapRef *mr0, RIOMapRef *mr1) {\n\tif (mr0->id == mr1->id) {\n\t\t// mapref have the same priority, if their mapid matches\n\t\treturn 0;\n\t}\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mr0->id) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (mapref->id == mr1->id) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\t// should never happen\n}\n\nR_API bool r_io_bank_update_map_boundaries(RIO *io, const ut32 bankid, const ut32 mapid, ut64 ofrom, ut64 oto) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\t// map is not referenced by this map\n\treturn false;\nfound:\n\t;RIOMap *map = r_io_map_get_by_ref (io, mapref);\n\tif (!map) {\n\t\t// inconsistent mapref\n\t\t// mapref should be deleted from bank here\n\t\treturn false;\n\t}\n\tif (r_io_map_from (map) == ofrom && r_io_map_to (map) == oto) {\n\t\t// nothing todo here\n\t\treturn true;\n\t}\n\t// allocate sm here to avoid deleting things without ensuring\n\t// that this code could at least insert 1 submap\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\n\tbank->last_used = NULL;\n\t// this problem can be divided in 2 steps:\n\t// 1. delete corresponding submaps and insert intersecting submaps with lower priority\n\t// 2. adjust addr and insert submaps at new addr respecting priority\n\tRIOMap fake_map;\n\tmemcpy (&fake_map, map, sizeof (RIOMap));\n\tfake_map.itv.addr = ofrom;\n\tfake_map.itv.size = oto - ofrom + 1;\n\t_delete_submaps_from_bank_tree (io, bank, iter, &fake_map);\n\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection here, so just insert sm into the tree and we're done\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t// assumption here is that there is no need to check for return value of r_crbtree_insert,\n\t\t// since it only fails, if allocation fails and a delete was performed before, so it should just be fine\n\t\treturn true;\n\t}\n\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t// check if sm has higher priority than bd by comparing their maprefs\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t// sm has higher priority that bd => adjust bd\n\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\tif (r_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t\t\t// bc of _find_entry_submap_node, we can be sure, that there is no\n\t\t\t\t// lower submap that intersects with sm\n\t\t\t\t//\n\t\t\t\t// instead of deleting and inserting, just replace the mapref,\n\t\t\t\t// similar to r_io_bank_map_priorize\n\t\t\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\t\t\tfree (sm);\n\t\t\t} else {\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\t\t// allocating bdsm here is fine, bc bd is already in the tree\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t// What do if this fails?\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t} else {\n\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t// bd has higher priority than sm => adjust sm\n\t\tif (r_io_submap_from (bd) <= r_io_submap_from (sm)) {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\t// bd completly overlaps sm => nothing to do\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t} // else\n\t\t\t// adjust sm\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t} else {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\t\tfree (sm);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tif (!bdsm) {\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\tfree (bdsm);\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t}\n\t// entry = r_rbnode_next (entry);\n\t// it is given that entry->data->from >= sm->from on every iteration\n\t// so only check for upper boundary of sm for intersection with entry->data\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t// iterate forwards starting at entry, while entry->data and sm overlap\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tentry = r_rbnode_next (entry);\n\t\t// check if sm has higher priority than bd by comparing their maprefs\n\t\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t\t// delete bd\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t\t// bd has higher priority than sm => adjust sm\n\t\t\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\t\t// in this case the size of sm would be 0,\n\t\t\t\t// but since empty maps are not allowed free sm and return\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t}\n\t}\n\tif (!entry) {\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\tbd = (RIOSubMap *)entry->data;\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t\t}\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t} else {\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t}\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// can this happen?\n\t\t\tfree (sm);\n\t\t}\n\t}\n\treturn true;\n}\n\n// locates next available address for a map with given size and alignment starting at *addr\nR_API bool r_io_bank_locate(RIO *io, const ut32 bankid, ut64 *addr, const ut64 size, ut64 load_align) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank && bank->submaps && addr && size, false);\n\tif (load_align == 0LL) {\n\t\tload_align = 1;\n\t}\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = *addr + (load_align - *addr % load_align) % load_align;\n\tfake_sm.itv.size = size;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\t// no submaps in this bank\n\t\t*addr = fake_sm.itv.addr;\n\t\treturn true;\n\t}\n\t// this is a bit meh: first iteration can never be successful,\n\t// bc entry->sm will always intersect with fake_sm, if\n\t// _find_entry_submap_node suceeded previously\n\tut64 next_location = fake_sm.itv.addr;\n\twhile (entry) {\n\t\tRIOSubMap *sm = (RIOSubMap *)entry->data;\n\t\tif (size <= r_io_submap_from (sm) - next_location) {\n\t\t\t*addr = next_location;\n\t\t\treturn true;\n\t\t}\n\t\tnext_location = (r_io_submap_to (sm) + 1) +\n\t\t\t(load_align - ((r_io_submap_to (sm) + 1) % load_align)) % load_align;\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tif (next_location == 0LL) {\n\t\t// overflow from last submap in the tree => no location\n\t\treturn false;\n\t}\n\tif (UT64_MAX - size + 1 < next_location) {\n\t\treturn false;\n\t}\n\t*addr = next_location;\n\treturn true;\n}\n\nR_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\n\nR_API bool r_io_bank_write_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof (RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_W)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tret = false;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int write_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_write_at (io, map->fd, paddr, &buf[buf_off], write_len) == write_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\n\n// reads only from single submap at addr and returns amount of bytes read.\n// if no submap is mapped at addr, fcn returns 0. returns -1 on error\nR_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_R)) {\n\t\treturn -1;\n\t}\n\tconst int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_read_at (io, map->fd, paddr, buf, read_len);\n}\n\n// writes only to single submap at addr and returns amount of bytes written.\n// if no submap is mapped at addr, fcn returns 0. returns -1 on error\nR_API int r_io_bank_write_to_submap_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_W)) {\n\t\treturn -1;\n\t}\n\tconst int write_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_write_at (io, map->fd, paddr, buf, write_len);\n}\n\nR_API RIOMap *r_io_bank_get_map_at(RIO *io, const ut32 bankid, ut64 addr) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, NULL);\n\tRRBNode *node = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn NULL;\n\t}\n\treturn r_io_map_get_by_ref (io, &sm->mapref);\n}\n\n// deletes map with mapid from bank with bankid\nR_API void r_io_bank_del_map(RIO *io, const ut32 bankid, const ut32 mapid) {\n\t// no need to check for mapref here, since this is \"just\" deleting\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\t//is this needed?\n\tr_return_if_fail (bank && map);\n\tRListIter *iter;\n\tRIOMapRef *mapref = NULL;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == map->id) {\n\t\t\t_delete_submaps_from_bank_tree (io, bank, iter, map);\n\t\t\tr_list_delete (bank->maprefs, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbank->last_used = NULL;\n\t// map is not referenced by this bank; nothing to do\n}\n\nR_API void r_io_bank_del(RIO *io, const ut32 bankid) {\n\tr_id_storage_delete (io->banks, bankid);\n\tif (io->bank == bankid) {\n\t\tio->bank = r_io_bank_first (io);\n\t}\n}\n\n// merges nearby submaps, that have a map ref to the same map, and free unneeded tree nodes\nR_API void r_io_bank_drain(RIO *io, const ut32 bankid) {\n\tr_return_if_fail (io);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn;\n\t}\n\tbank->last_used = NULL;\n\tRRBNode *node = r_crbtree_first_node (bank->submaps);\n\tRRBNode *next = NULL;\n\twhile (node) {\n\t\tnext = r_rbnode_next (node);\n\t\tif (next) {\n\t\t\tRIOSubMap *bd = (RIOSubMap *)node->data;\n\t\t\tRIOSubMap *sm = (RIOSubMap *)next->data;\n\t\t\tif (!memcmp (&bd->mapref, &sm->mapref, sizeof (RIOMapRef))) {\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tnode = next;\n\t}\n}\n\nR_IPI bool io_bank_has_map(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2021 - condret */\n\n#include <r_io.h>\n#include <r_util.h>\n\nR_API RIOBank *r_io_bank_new(const char *name) {\n\tr_return_val_if_fail (name, NULL);\n\tRIOBank *bank = R_NEW0 (RIOBank);\n\tif (!bank) {\n\t\treturn NULL;\n\t}\n\tbank->name = strdup (name);\n\tbank->submaps = r_crbtree_new (free);\n\tif (!bank->submaps) {\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->maprefs = r_list_newf (free);\n\tif (!bank->maprefs) {\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->todo = r_queue_new (8);\n\tif (!bank->todo) {\n\t\tr_list_free (bank->maprefs);\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\treturn bank;\n}\n\nR_API void r_io_bank_clear(RIOBank *bank) {\n\tr_return_if_fail (bank);\n\twhile (!r_queue_is_empty (bank->todo)) {\n\t\tfree (r_queue_dequeue (bank->todo));\n\t}\n\tbank->last_used = NULL;\n\tr_crbtree_clear (bank->submaps);\n\tr_list_purge (bank->maprefs);\n}\n\nR_API void r_io_bank_free(RIOBank *bank) {\n\tif (bank) {\n\t\tr_queue_free (bank->todo);\n\t\tr_list_free (bank->maprefs);\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank->name);\n\t\tfree (bank);\n\t}\n}\n\nR_API void r_io_bank_init(RIO *io) {\n\tr_return_if_fail (io);\n\tr_io_bank_fini (io);\n\tio->banks = r_id_storage_new (0, UT32_MAX);\n}\n\n\nstatic bool _bank_free_cb(void *user, void *data, ut32 id) {\n\tr_io_bank_free ((RIOBank *)data);\n\treturn true;\n}\n\nR_API void r_io_bank_fini(RIO *io) {\n\tr_return_if_fail (io);\n\tif (io->banks) {\n\t\tr_id_storage_foreach (io->banks, _bank_free_cb, NULL);\n\t\tr_id_storage_free (io->banks);\n\t\tio->banks = NULL;\n\t}\n}\n\nR_API RIOBank *r_io_bank_get(RIO *io, const ut32 bankid) {\n\tr_return_val_if_fail (io && io->banks, NULL);\n\treturn (RIOBank *)r_id_storage_get (io->banks, bankid);\n}\n\nR_API ut32 r_io_bank_first(RIO *io) {\n\tut32 bankid = -1;\n\tr_id_storage_get_lowest (io->banks, &bankid);\n\treturn bankid;\n}\n\nR_API bool r_io_bank_use(RIO *io, ut32 bankid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (bank) {\n\t\tio->bank = bankid;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API bool r_io_bank_add(RIO *io, RIOBank *bank) {\n\tr_return_val_if_fail (io && io->banks && bank, false);\n\treturn r_id_storage_add (io->banks, bank, &bank->id);\n}\n\nstatic RIOMapRef *_mapref_from_map(RIOMap *map) {\n\tRIOMapRef *mapref = R_NEW (RIOMapRef);\n\tif (mapref) {\n\t\tmapref->id = map->id;\n\t\tmapref->ts = map->ts;\n\t}\n\treturn mapref;\n}\n\n// incoming - in\n// cb for finding sm by lower boundary vaddr\nstatic int _find_sm_by_from_vaddr_cb(void *incoming, void *in, void *user) {\n\tRIOSubMap *bd = (RIOSubMap *)incoming, *sm = (RIOSubMap *)in;\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int _find_sm_by_vaddr_cb(void *incoming, void *in, void *user) {\n\tconst ut64 addr = ((ut64 *)incoming)[0];\n\tRIOSubMap *sm = (RIOSubMap *)in;\n\tif (r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tif (addr < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\nstatic int _find_lowest_intersection_sm_cb(void *incoming, void *in, void *user) {\n\tRIOSubMap *bd = (RIOSubMap *)incoming, *sm = (RIOSubMap *)in;\n\tif (r_io_submap_overlap (bd, sm)) {\n\t\treturn 0;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\n// returns the node containing the submap with lowest itv.addr, that intersects with sm\nstatic RRBNode *_find_entry_submap_node(RIOBank *bank, RIOSubMap *sm) {\n\tRRBNode *node = r_crbtree_find_node (bank->submaps, sm, _find_lowest_intersection_sm_cb, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRRBNode *prev = r_rbnode_prev (node);\n\twhile (prev && r_io_submap_overlap (((RIOSubMap *)prev->data), sm)) {\n\t\tnode = prev;\n\t\tprev = r_rbnode_prev (node);\n\t}\n\treturn node;\n}\n\nR_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tif (!a) {\n\t\t\tbreak;\n\t\t}\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}\n\nR_API bool r_io_bank_map_add_bottom(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_prepend (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\twhile (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\tr_list_prepend (bank->maprefs, mapref);\n\t\t\tfree (sm);\n\t\t\treturn true;\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\tr_list_prepend (bank->maprefs, mapref);\n\treturn true;\n}\n\nR_API bool r_io_bank_map_priorize(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\treturn false;\nfound:\n\tif (iter == bank->maprefs->tail) {\t//tail is top\n\t\treturn r_io_map_get_by_ref (io, mapref) ? true : false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// if this happens, something is really fucked up\n\t\tfree (sm);\n\t\treturn false;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_itv_eq (bd->itv, sm->itv)) {\n\t\t// no need to insert new sm, if boundaries match perfectly\n\t\t// instead override mapref of existing node/submap\n\t\tbd->mapref = *mapref;\n\t\tfree (sm);\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// bd completly overlaps sm on both ends,\n\t\t// therefor split bd into 2 maps => bd and bdsm\n\t\t// |---bd---||--sm--|-bdsm-|\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL) &\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t//delete all submaps that are completly included in sm\n\t\t// this can be optimized, there is no need to do search here\n\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tr_list_iter_to_top (bank->maprefs, iter);\n\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n}\n\n// deletes submaps that belong to a mapref with a specified priority from the submap tree of a bank.\n// the mapref is accessed by it's iter from the priority list in the bank,\n// so that the function can insert new submaps that fill the gaps. The iter represents the priority of the mapref.\n// this function DOES NOT delete the iter from the list. (that way it can be used for delete and relocate)\nstatic void _delete_submaps_from_bank_tree(RIO *io, RIOBank *bank, RListIter *prio, RIOMap *map) {\n\tRIOSubMap fake_sm;\n\tfake_sm.itv = map->itv;\n\tfake_sm.mapref.id = map->id;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\treturn;\n\t}\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\twhile (bd && r_io_submap_overlap (bd, (&fake_sm))) {\n\t\t// this loop deletes all affected submaps from the rbtree\n\t\t// and also enqueues them in bank->todo\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\tif (bd->mapref.id == fake_sm.mapref.id) {\n\t\t\tr_queue_enqueue (bank->todo, R_NEWCOPY (RIOSubMap, bd));\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tentry = next;\n\t\tbd = entry ? (RIOSubMap *)entry->data : NULL;\n\t}\n\tRListIter *iter = prio;\n\twhile (!r_queue_is_empty (bank->todo)) {\n\t\t// now check for each deleted submap if a lower map intersects with it\n\t\t// and create new submaps accordingly, and fill the gaps\n\t\tRIOSubMap *sm = r_queue_dequeue (bank->todo);\n\t\tRListIter *ator = r_list_iter_get_prev (iter);\n\t\twhile (ator) {\n\t\t\tmap = r_io_map_get_by_ref (io, (RIOMapRef *)ator->data);\n\t\t\tator = r_list_iter_get_prev (ator);\n\t\t\tif (!map) {\n\t\t\t\t// if this happens, something is fucked up, and no submap should be inserted\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if the map and sm intersect, the intersecting submap needs to be inserted in the tree\n\t\t\t// there are 5 cases to consider here\n\t\t\t// 1. no intersection: just continue to the next iteration\n\t\t\t// 2. map overlaps sm on both ends: insert submap for map with boundaries of sm\n\t\t\t// 3. map overlaps sm on the upper end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 4. map overlaps sm on the lower end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 5. sm overlaps sm on both ends: split sm into 2 submaps and enqueue new one in banks->todo; insert submap for map; adjust sm boundaries\n\t\t\tif (r_io_submap_to (sm) < r_io_map_from (map) || r_io_submap_from (sm) > r_io_map_to (map)) {\n\t\t\t\t// case 1\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRIOMapRef *mapref = _mapref_from_map (map);\n\t\t\tbd = r_io_submap_new (io, mapref);\n\t\t\tfree (mapref);\n\t\t\tif (!bd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_from (sm) >= r_io_map_from (map)) {\n\t\t\t\t// case 4 and 2\n\t\t\t\tr_io_submap_set_from (bd, r_io_submap_from (sm));\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t\t// case 2\n\t\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// case 4\n\t\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t// case 3\n\t\t\t\t// adjust bd upper boundary to avoid overlap with existing submaps\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t// adjust sm upper boundary to avoid hitting again on sm in further iterations\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// case 5 because all other cases are already handled\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (bd) + 1);\n\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_queue_enqueue (bank->todo, bdsm);\n\t\t}\n\t\tfree (sm);\n\t}\n}\n\nR_API bool r_io_bank_map_depriorize(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (bank && map, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref = NULL;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\t// map is not referenced by this bank\n\treturn false;\nfound:\n\tif (iter == bank->maprefs->head) {\n\t\t// map is already lowest priority\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\t_delete_submaps_from_bank_tree (io, bank, iter, map);\n\tr_list_delete (bank->maprefs, iter);\n\treturn r_io_bank_map_add_bottom (io, bankid, mapid);\n}\n\n// compared 2 maprefs of the same bank by their priority (position in  the mapref list)\n// returns 0, if both have the same priority\n// returns 1, if mr0 has higher priority than mr1\n// returns -1, if mr1 has higher priority tham mr0\n// returns 0, if neither mr0 nor mr1 are an element of the bank\nstatic int _mapref_priority_cmp(RIOBank *bank, RIOMapRef *mr0, RIOMapRef *mr1) {\n\tif (mr0->id == mr1->id) {\n\t\t// mapref have the same priority, if their mapid matches\n\t\treturn 0;\n\t}\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mr0->id) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (mapref->id == mr1->id) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\t// should never happen\n}\n\nR_API bool r_io_bank_update_map_boundaries(RIO *io, const ut32 bankid, const ut32 mapid, ut64 ofrom, ut64 oto) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\t// map is not referenced by this map\n\treturn false;\nfound:\n\t;RIOMap *map = r_io_map_get_by_ref (io, mapref);\n\tif (!map) {\n\t\t// inconsistent mapref\n\t\t// mapref should be deleted from bank here\n\t\treturn false;\n\t}\n\tif (r_io_map_from (map) == ofrom && r_io_map_to (map) == oto) {\n\t\t// nothing todo here\n\t\treturn true;\n\t}\n\t// allocate sm here to avoid deleting things without ensuring\n\t// that this code could at least insert 1 submap\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\n\tbank->last_used = NULL;\n\t// this problem can be divided in 2 steps:\n\t// 1. delete corresponding submaps and insert intersecting submaps with lower priority\n\t// 2. adjust addr and insert submaps at new addr respecting priority\n\tRIOMap fake_map;\n\tmemcpy (&fake_map, map, sizeof (RIOMap));\n\tfake_map.itv.addr = ofrom;\n\tfake_map.itv.size = oto - ofrom + 1;\n\t_delete_submaps_from_bank_tree (io, bank, iter, &fake_map);\n\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection here, so just insert sm into the tree and we're done\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t// assumption here is that there is no need to check for return value of r_crbtree_insert,\n\t\t// since it only fails, if allocation fails and a delete was performed before, so it should just be fine\n\t\treturn true;\n\t}\n\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t// check if sm has higher priority than bd by comparing their maprefs\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t// sm has higher priority that bd => adjust bd\n\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\tif (r_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t\t\t// bc of _find_entry_submap_node, we can be sure, that there is no\n\t\t\t\t// lower submap that intersects with sm\n\t\t\t\t//\n\t\t\t\t// instead of deleting and inserting, just replace the mapref,\n\t\t\t\t// similar to r_io_bank_map_priorize\n\t\t\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\t\t\tfree (sm);\n\t\t\t} else {\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\t\t// allocating bdsm here is fine, bc bd is already in the tree\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t// What do if this fails?\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t} else {\n\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t// bd has higher priority than sm => adjust sm\n\t\tif (r_io_submap_from (bd) <= r_io_submap_from (sm)) {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\t// bd completly overlaps sm => nothing to do\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t} // else\n\t\t\t// adjust sm\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t} else {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\t\tfree (sm);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tif (!bdsm) {\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\tfree (bdsm);\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t}\n\t// entry = r_rbnode_next (entry);\n\t// it is given that entry->data->from >= sm->from on every iteration\n\t// so only check for upper boundary of sm for intersection with entry->data\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t// iterate forwards starting at entry, while entry->data and sm overlap\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tentry = r_rbnode_next (entry);\n\t\t// check if sm has higher priority than bd by comparing their maprefs\n\t\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t\t// delete bd\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t\t// bd has higher priority than sm => adjust sm\n\t\t\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\t\t// in this case the size of sm would be 0,\n\t\t\t\t// but since empty maps are not allowed free sm and return\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t}\n\t}\n\tif (!entry) {\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\tbd = (RIOSubMap *)entry->data;\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t\t}\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t} else {\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t}\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// can this happen?\n\t\t\tfree (sm);\n\t\t}\n\t}\n\treturn true;\n}\n\n// locates next available address for a map with given size and alignment starting at *addr\nR_API bool r_io_bank_locate(RIO *io, const ut32 bankid, ut64 *addr, const ut64 size, ut64 load_align) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank && bank->submaps && addr && size, false);\n\tif (load_align == 0LL) {\n\t\tload_align = 1;\n\t}\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = *addr + (load_align - *addr % load_align) % load_align;\n\tfake_sm.itv.size = size;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\t// no submaps in this bank\n\t\t*addr = fake_sm.itv.addr;\n\t\treturn true;\n\t}\n\t// this is a bit meh: first iteration can never be successful,\n\t// bc entry->sm will always intersect with fake_sm, if\n\t// _find_entry_submap_node suceeded previously\n\tut64 next_location = fake_sm.itv.addr;\n\twhile (entry) {\n\t\tRIOSubMap *sm = (RIOSubMap *)entry->data;\n\t\tif (size <= r_io_submap_from (sm) - next_location) {\n\t\t\t*addr = next_location;\n\t\t\treturn true;\n\t\t}\n\t\tnext_location = (r_io_submap_to (sm) + 1) +\n\t\t\t(load_align - ((r_io_submap_to (sm) + 1) % load_align)) % load_align;\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tif (next_location == 0LL) {\n\t\t// overflow from last submap in the tree => no location\n\t\treturn false;\n\t}\n\tif (UT64_MAX - size + 1 < next_location) {\n\t\treturn false;\n\t}\n\t*addr = next_location;\n\treturn true;\n}\n\nR_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\n\nR_API bool r_io_bank_write_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof (RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_W)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tret = false;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int write_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_write_at (io, map->fd, paddr, &buf[buf_off], write_len) == write_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\n\n// reads only from single submap at addr and returns amount of bytes read.\n// if no submap is mapped at addr, fcn returns 0. returns -1 on error\nR_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_R)) {\n\t\treturn -1;\n\t}\n\tconst int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_read_at (io, map->fd, paddr, buf, read_len);\n}\n\n// writes only to single submap at addr and returns amount of bytes written.\n// if no submap is mapped at addr, fcn returns 0. returns -1 on error\nR_API int r_io_bank_write_to_submap_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_W)) {\n\t\treturn -1;\n\t}\n\tconst int write_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_write_at (io, map->fd, paddr, buf, write_len);\n}\n\nR_API RIOMap *r_io_bank_get_map_at(RIO *io, const ut32 bankid, ut64 addr) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, NULL);\n\tRRBNode *node = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn NULL;\n\t}\n\treturn r_io_map_get_by_ref (io, &sm->mapref);\n}\n\n// deletes map with mapid from bank with bankid\nR_API void r_io_bank_del_map(RIO *io, const ut32 bankid, const ut32 mapid) {\n\t// no need to check for mapref here, since this is \"just\" deleting\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\t//is this needed?\n\tr_return_if_fail (bank && map);\n\tRListIter *iter;\n\tRIOMapRef *mapref = NULL;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == map->id) {\n\t\t\t_delete_submaps_from_bank_tree (io, bank, iter, map);\n\t\t\tr_list_delete (bank->maprefs, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbank->last_used = NULL;\n\t// map is not referenced by this bank; nothing to do\n}\n\nR_API void r_io_bank_del(RIO *io, const ut32 bankid) {\n\tr_id_storage_delete (io->banks, bankid);\n\tif (io->bank == bankid) {\n\t\tio->bank = r_io_bank_first (io);\n\t}\n}\n\n// merges nearby submaps, that have a map ref to the same map, and free unneeded tree nodes\nR_API void r_io_bank_drain(RIO *io, const ut32 bankid) {\n\tr_return_if_fail (io);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn;\n\t}\n\tbank->last_used = NULL;\n\tRRBNode *node = r_crbtree_first_node (bank->submaps);\n\tRRBNode *next = NULL;\n\twhile (node) {\n\t\tnext = r_rbnode_next (node);\n\t\tif (next) {\n\t\t\tRIOSubMap *bd = (RIOSubMap *)node->data;\n\t\t\tRIOSubMap *sm = (RIOSubMap *)next->data;\n\t\t\tif (!memcmp (&bd->mapref, &sm->mapref, sizeof (RIOMapRef))) {\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tnode = next;\n\t}\n}\n\nR_IPI bool io_bank_has_map(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n"], "filenames": ["libr/io/io_bank.c"], "buggy_code_start_loc": [233], "buggy_code_end_loc": [234], "fixing_code_start_loc": [233], "fixing_code_end_loc": [237], "type": "CWE-416", "message": "Use After Free in GitHub repository radareorg/radare2 prior to 5.6.0.", "other": {"cve": {"id": "CVE-2022-0139", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-08T19:15:08.737", "lastModified": "2022-02-11T16:55:12.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository radareorg/radare2 prior to 5.6.0."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.6.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.0", "matchCriteriaId": "024FE30E-EDC3-45A1-9509-69BE3140C274"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/37897226a1a31f982bfefdc4aeefc2e50355c73c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/3dcb6f40-45cd-403b-929f-db123fde32c0", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/37897226a1a31f982bfefdc4aeefc2e50355c73c"}}