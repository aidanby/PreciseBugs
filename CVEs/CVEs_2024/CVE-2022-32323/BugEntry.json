{"buggy_code": ["/* input-bmp.c:\treads any bitmap I could get for testing\n\n   Copyright (C) 1999, 2000, 2001 Martin Weber.\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public License\n   as published by the Free Software Foundation; either version 2.1 of\n   the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n   USA. */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* Def: HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"types.h\"\n#include \"bitmap.h\"\n#include \"logreport.h\"\n#include \"xstd.h\"\n#include \"input-bmp.h\"\n\n\n#define BI_RGB            0\n#define BI_RLE8           1\n#define BI_RLE4           2\n#define BI_BITFIELDS      3\n#define BI_ALPHABITFIELDS 4\n\n#define BitSet(byte, bit)  (((byte) & (bit)) == (bit))\n\n#define ReadOK(file,buffer,len)  (fread(buffer, len, 1, file) != 0)\n\nstruct Bitmap_File_Head_Struct {\n  char zzMagic[2];              /* 00 \"BM\" */\n  unsigned long bfSize;         /* 02 */\n  unsigned short zzHotX;        /* 06 */\n  unsigned short zzHotY;        /* 08 */\n  unsigned long bfOffs;         /* 0A */\n  unsigned long biSize;         /* 0E */\n} Bitmap_File_Head;\n\nstruct Bitmap_Head_Struct {\n  unsigned long biWidth;        /* 12 */\n  unsigned long biHeight;       /* 16 */\n  unsigned short biPlanes;      /* 1A */\n  unsigned short biBitCnt;      /* 1C */\n  unsigned long biCompr;        /* 1E */\n  unsigned long biSizeIm;       /* 22 */\n  unsigned long biXPels;        /* 26 */\n  unsigned long biYPels;        /* 2A */\n  unsigned long biClrUsed;      /* 2E */\n  unsigned long biClrImp;       /* 32 */\n  unsigned long masks[4];       /* 36 */\n  /* 3A */\n} Bitmap_Head;\n \ntypedef struct\n{\n\tunsigned long mask;\n\tunsigned long shiftin;\n\tfloat  max_value;\n} Bitmap_Channel;\n\nstatic void\nsetMasksDefault (unsigned short        biBitCnt,\n                 Bitmap_Channel *masks)\n{\n  switch (biBitCnt)\n    {\n    case 32:\n      masks[0].mask      = 0x00ff0000;\n      masks[0].shiftin   = 16;\n      masks[0].max_value = (float)255.0;\n      masks[1].mask      = 0x0000ff00;\n      masks[1].shiftin   = 8;\n      masks[1].max_value = (float)255.0;\n      masks[2].mask      = 0x000000ff;\n      masks[2].shiftin   = 0;\n      masks[2].max_value = (float)255.0;\n      masks[3].mask      = 0x00000000;\n      masks[3].shiftin   = 0;\n      masks[3].max_value = (float)0.0;\n      break;\n\n    case 24:\n      masks[0].mask      = 0xff0000;\n      masks[0].shiftin   = 16;\n      masks[0].max_value = (float)255.0;\n      masks[1].mask      = 0x00ff00;\n      masks[1].shiftin   = 8;\n      masks[1].max_value = (float)255.0;\n      masks[2].mask      = 0x0000ff;\n      masks[2].shiftin   = 0;\n      masks[2].max_value = (float)255.0;\n      masks[3].mask      = 0x0;\n      masks[3].shiftin   = 0;\n      masks[3].max_value = (float)0.0;\n      break;\n\n    case 16:\n      masks[0].mask      = 0x7c00;\n      masks[0].shiftin   = 10;\n      masks[0].max_value = (float)31.0;\n      masks[1].mask      = 0x03e0;\n      masks[1].shiftin   = 5;\n      masks[1].max_value = (float)31.0;\n      masks[2].mask      = 0x001f;\n      masks[2].shiftin   = 0;\n      masks[2].max_value = (float)31.0;\n      masks[3].mask      = 0x0;\n      masks[3].shiftin   = 0;\n      masks[3].max_value = (float)0.0;\n      break;\n\n    default:\n      break;\n    }\n}\n\nstatic long ToL(unsigned char *);\nstatic short ToS(unsigned char *);\nstatic int ReadColorMap(FILE *, unsigned char[256][3], int, int, gboolean *, at_exception_type *);\nstatic gboolean ReadChannelMasks(unsigned int *, Bitmap_Channel *, unsigned int);\nstatic unsigned char *ReadImage(FILE *, int, int, unsigned char[256][3], int, int, int, int, gboolean, const Bitmap_Channel *, at_exception_type *);\n\nat_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[128];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n\n  fd = fopen(filename, \"rb\");\n\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n\n  if (!ReadOK(fd, buffer, 12))////\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n          \n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\t/* BI_ALPHABITFIELDS, etc. */\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    /* enhanced Windows format with bit masks */\n\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       /* 36 */\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       /* 3A */\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       /* 3E */\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       /* 42 */\n\n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    /* BMP Version 4 or 5 */\n\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n\n    Maps = 4;\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* biHeight may be negative, but -2147483648 is dangerous because:\n\t -2147483648 == -(-2147483648) */\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* protect against integer overflows caused by malicious BMPs */\n  /* use divisions in comparisons to avoid type overflows */\n\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  /* Get the Colormap */\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}\n\nstatic gboolean ReadColorMap(FILE * fd, unsigned char buffer[256][3], int number, int size, \n\tgboolean *Grey,\n\tat_exception_type *exp)\n{\n  int i;\n  unsigned char rgb[4];\n\n  *Grey = (number > 2);\n  for (i = 0; i < number; i++) {\n    if (!ReadOK(fd, rgb, size)) {\n      LOG (\"Bad colormap\\n\");\n      at_exception_fatal (exp, \"Bad colormap\");\n      return FALSE;\n    }\n\n    /* Bitmap save the colors in another order! But change only once! */\n\n    buffer[i][0] = rgb[2];\n    buffer[i][1] = rgb[1];\n    buffer[i][2] = rgb[0];\n    *Grey = ((*Grey) && (rgb[0] == rgb[1]) && (rgb[1] == rgb[2]));\n  }\ncleanup:\n  return TRUE;\n}\n\nstatic gboolean\nReadChannelMasks(unsigned int       *tmp,\n\tBitmap_Channel *masks,\n\tunsigned int          channels)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < channels; i++)\n\t{\n\t\tunsigned int mask;\n\t\tint    nbits, offset, bit;\n\n\t\tmask = tmp[i];\n\t\tmasks[i].mask = mask;\n\t\tnbits = 0;\n\t\toffset = -1;\n\n\t\tfor (bit = 0; bit < 32; bit++)\n\t\t{\n\t\t\tif (mask & 1)\n\t\t\t{\n\t\t\t\tnbits++;\n\t\t\t\tif (offset == -1)\n\t\t\t\t\toffset = bit;\n\t\t\t}\n\n\t\t\tmask = mask >> 1;\n\t\t}\n\n\t\tmasks[i].shiftin = offset;\n\t\tmasks[i].max_value = (float)((1 << nbits) - 1);\n\n#ifdef _DEBUG\n\t\tLOG4(\"Channel %d mask %08x in %d max_val %d\\n\",\n\t\t\ti, masks[i].mask, masks[i].shiftin, (int)masks[i].max_value);\n#endif\n\t}\n\n\treturn TRUE;\n}\n\n/*static gint32\nReadImage(FILE                 *fd,\n\tconst gchar          *filename,\n\tgint                  width,\n\tgint                  height,\n\tguchar                cmap[256][3],\n\tgint                  ncols,\n\tgint                  bpp,\n\tgint                  compression,\n\tgint                  rowbytes,\n\tgboolean              gray,\n\tconst BitmapChannel  *masks,\n\tGError              **error)*/\n\n\nstatic unsigned char *ReadImage(FILE * fd, int width, int height,\n\tunsigned char cmap[256][3],\n\tint ncols,\n\tint bpp, int compression, int rowbytes,\n\tgboolean    Grey,\n\tconst Bitmap_Channel * masks,\n\tat_exception_type * exp)\n{\n  unsigned char v, n;\n  int xpos = 0;\n  int ypos = 0;\n  unsigned char * image;\n  unsigned char *dest, *temp, *row_buf;\n  long rowstride, channels;\n  unsigned short rgb;\n  int i, i_max, j;\n  int total_bytes_read;\n  unsigned int px32;\n\n  if (!(compression == BI_RGB ||\n\t  (bpp == 8 && compression == BI_RLE8) ||\n\t  (bpp == 4 && compression == BI_RLE4) ||\n\t  (bpp == 16 && compression == BI_BITFIELDS) ||\n\t  (bpp == 32 && compression == BI_BITFIELDS)))\n  {\n\t  LOG(\"Unrecognized or invalid BMP compression format.\\n\");\n\t  at_exception_fatal(exp, \"Unrecognized or invalid BMP compression format.\");\n\t  return NULL;\n  }\n\n  if (bpp >= 16) {              /* color image */\n    XMALLOC(image, width * height * 3 * sizeof(unsigned char));\n    if (masks[3].mask != 0)\n    {\n      channels = 4;\n    }\n    else\n    {\n      channels = 3;\n    }\n  }\n  else if (Grey) /* Grey image */\n  {\n    XMALLOC(image, width * height * 1 * sizeof(unsigned char));\n    channels = 1;\n  } else {                      /* indexed image */\n\n    XMALLOC(image, width * height * 1 * sizeof(unsigned char));\n    channels = 1;\n  }\n\n  /* use XCALLOC to initialize the dest row_buf so that unspecified\n\t pixels in RLE bitmaps show up as the zeroth element in the palette.\n  */\n  XCALLOC(dest, width * height * channels);\n  XMALLOC (row_buf, rowbytes); \n  rowstride = width * channels;\n\n  ypos = height - 1;            /* Bitmaps begin in the lower left corner */\n\n  switch (bpp) {\n\n  case 32:\n    {\n      while (ReadOK (fd, row_buf, rowbytes))\n      {\n        temp = image + (ypos * rowstride);\n        for (xpos = 0; xpos < width; ++xpos) {\n\t\t\t  px32 = ToL(&row_buf[xpos * 4]);\n\t\t\t  unsigned char red = *(temp++) = ((px32 & masks[0].mask) >> masks[0].shiftin) * 255.0 / masks[0].max_value + 0.5;\n\t\t\t  unsigned char green = *(temp++) = ((px32 & masks[1].mask) >> masks[1].shiftin) * 255.0 / masks[1].max_value + 0.5;\n\t\t\t  unsigned char blue = *(temp++) = ((px32 & masks[2].mask) >> masks[2].shiftin) * 255.0 / masks[2].max_value + 0.5;\n\t\t\t  /* currently alpha channels are not supported by AutoTrace, thus simply ignored */\n\t\t\t  /*if (channels > 3)\n\t\t\t\t  *(temp++) = ((px32 & masks[3].mask) >> masks[3].shiftin) * 255.0 / masks[3].max_value + 0.5;*/\n\t\t  }\n\n\t\t  if (ypos == 0)\n\t\t\t  break;\n\n\t\t  --ypos; /* next line */\n      }\n    }\n    break;\n\n  case 24:\n    {\n      while (ReadOK (fd, row_buf, rowbytes))\n      {\n        temp = image + (ypos * rowstride);\n        for (xpos = 0; xpos < width; ++xpos) {\n          *(temp++) = row_buf[xpos * 3 + 2];\n          *(temp++) = row_buf[xpos * 3 + 1];\n          *(temp++) = row_buf[xpos * 3];\n        }\n        --ypos;                 /* next line */\n      }\n    }\n    break;\n\n  case 16:\n    {\n      while (ReadOK (fd, row_buf, rowbytes))\n      {\n        temp = image + (ypos * rowstride);\n        for (xpos = 0; xpos < width; ++xpos)\n        {\n\t\t\t  rgb = ToS(&row_buf[xpos * 2]);\n\t\t\t  *(temp++) = ((rgb & masks[0].mask) >> masks[0].shiftin) * 255.0 / masks[0].max_value + 0.5;\n\t\t\t  *(temp++) = ((rgb & masks[1].mask) >> masks[1].shiftin) * 255.0 / masks[1].max_value + 0.5;\n\t\t\t  *(temp++) = ((rgb & masks[2].mask) >> masks[2].shiftin) * 255.0 / masks[2].max_value + 0.5;\n\t\t\t  /* currently alpha channels are not supported by AutoTrace, thus simply ignored */\n\t\t\t  /*if (channels > 3)\n\t\t\t\t  *(temp++) = ((rgb & masks[3].mask) >> masks[3].shiftin) * 255.0 / masks[3].max_value + 0.5;*/\n\t\t  }\n\n\t\t  if (ypos == 0)\n\t\t\t  break;\n\n\t\t  --ypos; /* next line */\n      }\n    }\n    break;\n\n  case 8:\n  case 4:\n  case 1:\n    {\n      if (compression == 0) {\n        while (ReadOK(fd, &v, 1)) {\n          for (i = 1; (i <= (8 / bpp)) && (xpos < width); i++, xpos++) {\n\t\t\ttemp = image + (ypos * rowstride) + (xpos * channels);\n\t\t\t*temp = (v & (((1 << bpp) - 1) << (8 - (i*bpp)))) >> (8 - (i*bpp));\n\t\t\tif (Grey)\n\t\t\t\t*temp = cmap[*temp][0];\n\t  }\n\n          if (xpos == width) {\n\t    ReadOK (fd, row_buf, rowbytes - 1 - (width * bpp - 1) / 8);\n            ypos--;\n            xpos = 0;\n\n          }\n          if (ypos < 0)\n            break;\n        }\n        break;\n      } else {\n\t/* compressed image (either RLE8 or RLE4) */\n        while (ypos >= 0 && xpos <= width) {\n\t\t\tif (!ReadOK(fd, row_buf, 2))\n\t\t\t{\n\t\t\t\tLOG(\"The bitmap ends unexpectedly.\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((unsigned char) row_buf[0] != 0)\n\t\t      /* Count + Color - record */\n\t\t      {\n\t\t\t\t/* encoded mode run -\n\t\t\t\t *   row_buf[0] == run_length\n\t\t\t\t *   row_buf[1] == pixel data\n\t\t\t\t */\n\t\t        for (j = 0; ((unsigned char) j < (unsigned char) row_buf[0]) && (xpos < width);)\n\t\t          {\n#ifdef DEBUG2\n              printf(\"%u %u | \", xpos, width);\n#endif\n\t\t\t        for (i = 1;\n\t\t\t             ((i <= (8 / bpp)) &&\n\t\t\t             (xpos < width) &&\n\t\t\t             ((unsigned char) j < (unsigned char) row_buf[0]));\n\t\t\t             i++, xpos++, j++)\n\t\t\t          {\n\t\t\t            temp = dest + (ypos * rowstride) + (xpos * channels);\n\t\t\t            *temp = (unsigned char) ((row_buf[1] & (((1<<bpp)-1) << (8 - (i * bpp)))) >> (8 - (i * bpp)));\n\t\t\t\t        if (Grey)\n\t\t\t\t\t      *temp = cmap[*temp][0];\n\t\t\t          }\n            }\n          }\n          if ((row_buf[0] == 0) && (row_buf[1] > 2))\n            /* uncompressed record */\n\t\t{\n\t\t\tn = row_buf[1];\n\t\t\ttotal_bytes_read = 0;\n\n\t\t\tfor (j = 0; j < n; j += (8 / bpp))\n\t\t\t{\n\t\t\t\t/* read the next byte in the record */\n\t\t\t\tif (!ReadOK(fd, &v, 1))\n\t\t\t\t{\n\t\t\t\t\tLOG(\"The bitmap ends unexpectedly.\");\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\n\t\t\t\ttotal_bytes_read++;\n\n\t\t\t\t/* read all pixels from that byte */\n\t\t\t\ti_max = 8 / bpp;\n\t\t\t\tif (n - j < i_max)\n\t\t\t\t{\n\t\t\t\t\ti_max = n - j;\n\t\t\t\t}\n\n\t\t\t\ti = 1;\n\t\t\t\twhile ((i <= i_max) && (xpos < width))\n\t\t\t\t{\n\t\t\t\t\ttemp =\n\t\t\t\t\t\tdest + (ypos * rowstride) + (xpos * channels);\n\t\t\t\t\t*temp = (v >> (8 - (i*bpp))) & ((1 << bpp) - 1);\n\t\t\t\t\tif (Grey)\n\t\t\t\t\t\t*temp = cmap[*temp][0];\n\t\t\t\t\ti++;\n\t\t\t\t\txpos++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* absolute mode runs are padded to 16-bit alignment */\n\t\t\tif (total_bytes_read % 2)\n\t\t\t\tfread(&v, 1, 1, fd); //ReadOk\n\t\t}\n\t  if (((unsigned char) row_buf[0] == 0) && ((unsigned char) row_buf[1]==0))\n            /* Line end */\n          {\n            ypos--;\n            xpos = 0;\n          }\n          if (((unsigned char)row_buf[0] == 0) && ((unsigned char)row_buf[1] == 1))\n            /* Bitmap end */\n          {\n            break;\n          }\n          if (((unsigned char)row_buf[0] == 0) && ((unsigned char)row_buf[1] == 2))\n            /* Deltarecord */\n          {\n\t\t\tif (!ReadOK(fd, row_buf, 2))\n\t\t\t  {\n\t\t\t\tLOG(\"The bitmap ends unexpectedly.\");\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\txpos += (unsigned char) row_buf[0];\n\t\t    ypos -= (unsigned char) row_buf[1];\n          }\n        }\n        break;\n      }\n    }\n    break;\n  default:\n    /* This is very bad, we should not be here */\n    break;\n  }\n\n  if (bpp <= 8) {\n    unsigned char *temp2, *temp3;\n    unsigned char index;\n    temp2 = temp = image;\n    XMALLOC (image, width * height * 3 * sizeof (unsigned char)); //???\n    temp3 = image;\n    for (ypos = 0; ypos < height; ypos++) {\n      for (xpos = 0; xpos < width; xpos++) {\n        index = *temp2++;\n        *temp3++ = cmap[index][0];\n        if (!Grey) {\n          *temp3++ = cmap[index][1];\n          *temp3++ = cmap[index][2];\n        }\n      }\n    }\n    free(temp);\n  }\n\n  free (row_buf);\n  free(dest);\n  return image;\n}\n\nstatic long ToL(unsigned char *puffer)\n{\n  return (puffer[0] | puffer[1] << 8 | puffer[2] << 16 | puffer[3] << 24);\n}\n\nstatic short ToS(unsigned char *puffer)\n{\n  return ((short)(puffer[0] | puffer[1] << 8));\n}\n"], "fixing_code": ["/* input-bmp.c:\treads any bitmap I could get for testing\n\n   Copyright (C) 1999, 2000, 2001 Martin Weber.\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public License\n   as published by the Free Software Foundation; either version 2.1 of\n   the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n   USA. */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* Def: HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"types.h\"\n#include \"bitmap.h\"\n#include \"logreport.h\"\n#include \"xstd.h\"\n#include \"input-bmp.h\"\n\n\n#define BI_RGB            0\n#define BI_RLE8           1\n#define BI_RLE4           2\n#define BI_BITFIELDS      3\n#define BI_ALPHABITFIELDS 4\n\n#define BitSet(byte, bit)  (((byte) & (bit)) == (bit))\n\n#define ReadOK(file,buffer,len)  (fread(buffer, len, 1, file) != 0)\n\nstruct Bitmap_File_Head_Struct {\n  char zzMagic[2];              /* 00 \"BM\" */\n  unsigned long bfSize;         /* 02 */\n  unsigned short zzHotX;        /* 06 */\n  unsigned short zzHotY;        /* 08 */\n  unsigned long bfOffs;         /* 0A */\n  unsigned long biSize;         /* 0E */\n} Bitmap_File_Head;\n\nstruct Bitmap_Head_Struct {\n  unsigned long biWidth;        /* 12 */\n  unsigned long biHeight;       /* 16 */\n  unsigned short biPlanes;      /* 1A */\n  unsigned short biBitCnt;      /* 1C */\n  unsigned long biCompr;        /* 1E */\n  unsigned long biSizeIm;       /* 22 */\n  unsigned long biXPels;        /* 26 */\n  unsigned long biYPels;        /* 2A */\n  unsigned long biClrUsed;      /* 2E */\n  unsigned long biClrImp;       /* 32 */\n  unsigned long masks[4];       /* 36 */\n  /* 3A */\n} Bitmap_Head;\n \ntypedef struct\n{\n\tunsigned long mask;\n\tunsigned long shiftin;\n\tfloat  max_value;\n} Bitmap_Channel;\n\nstatic void\nsetMasksDefault (unsigned short        biBitCnt,\n                 Bitmap_Channel *masks)\n{\n  switch (biBitCnt)\n    {\n    case 32:\n      masks[0].mask      = 0x00ff0000;\n      masks[0].shiftin   = 16;\n      masks[0].max_value = (float)255.0;\n      masks[1].mask      = 0x0000ff00;\n      masks[1].shiftin   = 8;\n      masks[1].max_value = (float)255.0;\n      masks[2].mask      = 0x000000ff;\n      masks[2].shiftin   = 0;\n      masks[2].max_value = (float)255.0;\n      masks[3].mask      = 0x00000000;\n      masks[3].shiftin   = 0;\n      masks[3].max_value = (float)0.0;\n      break;\n\n    case 24:\n      masks[0].mask      = 0xff0000;\n      masks[0].shiftin   = 16;\n      masks[0].max_value = (float)255.0;\n      masks[1].mask      = 0x00ff00;\n      masks[1].shiftin   = 8;\n      masks[1].max_value = (float)255.0;\n      masks[2].mask      = 0x0000ff;\n      masks[2].shiftin   = 0;\n      masks[2].max_value = (float)255.0;\n      masks[3].mask      = 0x0;\n      masks[3].shiftin   = 0;\n      masks[3].max_value = (float)0.0;\n      break;\n\n    case 16:\n      masks[0].mask      = 0x7c00;\n      masks[0].shiftin   = 10;\n      masks[0].max_value = (float)31.0;\n      masks[1].mask      = 0x03e0;\n      masks[1].shiftin   = 5;\n      masks[1].max_value = (float)31.0;\n      masks[2].mask      = 0x001f;\n      masks[2].shiftin   = 0;\n      masks[2].max_value = (float)31.0;\n      masks[3].mask      = 0x0;\n      masks[3].shiftin   = 0;\n      masks[3].max_value = (float)0.0;\n      break;\n\n    default:\n      break;\n    }\n}\n\nstatic long ToL(unsigned char *);\nstatic short ToS(unsigned char *);\nstatic int ReadColorMap(FILE *, unsigned char[256][3], int, int, gboolean *, at_exception_type *);\nstatic gboolean ReadChannelMasks(unsigned int *, Bitmap_Channel *, unsigned int);\nstatic unsigned char *ReadImage(FILE *, int, int, unsigned char[256][3], int, int, int, int, gboolean, const Bitmap_Channel *, at_exception_type *);\n\nat_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[128];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n\n  fd = fopen(filename, \"rb\");\n\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n\n  if (!ReadOK(fd, buffer, 12))////\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n          \n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\t/* BI_ALPHABITFIELDS, etc. */\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    /* enhanced Windows format with bit masks */\n\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       /* 36 */\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       /* 3A */\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       /* 3E */\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       /* 42 */\n\n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    /* BMP Version 4 or 5 */\n\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n\n    Maps = 4;\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* biHeight may be negative, but -2147483648 is dangerous because:\n\t -2147483648 == -(-2147483648) */\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* protect against integer overflows caused by malicious BMPs */\n  /* use divisions in comparisons to avoid type overflows */\n\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  /* Get the Colormap */\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}\n\nstatic gboolean ReadColorMap(FILE * fd, unsigned char buffer[256][3], int number, int size, \n\tgboolean *Grey,\n\tat_exception_type *exp)\n{\n  int i;\n  unsigned char rgb[4];\n\n  *Grey = (number > 2);\n  for (i = 0; i < number; i++) {\n    if (!ReadOK(fd, rgb, size)) {\n      LOG (\"Bad colormap\\n\");\n      at_exception_fatal (exp, \"Bad colormap\");\n      return FALSE;\n    }\n\n    /* Bitmap save the colors in another order! But change only once! */\n\n    buffer[i][0] = rgb[2];\n    buffer[i][1] = rgb[1];\n    buffer[i][2] = rgb[0];\n    *Grey = ((*Grey) && (rgb[0] == rgb[1]) && (rgb[1] == rgb[2]));\n  }\ncleanup:\n  return TRUE;\n}\n\nstatic gboolean\nReadChannelMasks(unsigned int       *tmp,\n\tBitmap_Channel *masks,\n\tunsigned int          channels)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < channels; i++)\n\t{\n\t\tunsigned int mask;\n\t\tint    nbits, offset, bit;\n\n\t\tmask = tmp[i];\n\t\tmasks[i].mask = mask;\n\t\tnbits = 0;\n\t\toffset = -1;\n\n\t\tfor (bit = 0; bit < 32; bit++)\n\t\t{\n\t\t\tif (mask & 1)\n\t\t\t{\n\t\t\t\tnbits++;\n\t\t\t\tif (offset == -1)\n\t\t\t\t\toffset = bit;\n\t\t\t}\n\n\t\t\tmask = mask >> 1;\n\t\t}\n\n\t\tmasks[i].shiftin = offset;\n\t\tmasks[i].max_value = (float)((1 << nbits) - 1);\n\n#ifdef _DEBUG\n\t\tLOG4(\"Channel %d mask %08x in %d max_val %d\\n\",\n\t\t\ti, masks[i].mask, masks[i].shiftin, (int)masks[i].max_value);\n#endif\n\t}\n\n\treturn TRUE;\n}\n\n/*static gint32\nReadImage(FILE                 *fd,\n\tconst gchar          *filename,\n\tgint                  width,\n\tgint                  height,\n\tguchar                cmap[256][3],\n\tgint                  ncols,\n\tgint                  bpp,\n\tgint                  compression,\n\tgint                  rowbytes,\n\tgboolean              gray,\n\tconst BitmapChannel  *masks,\n\tGError              **error)*/\n\n\nstatic unsigned char *ReadImage(FILE * fd, int width, int height,\n\tunsigned char cmap[256][3],\n\tint ncols,\n\tint bpp, int compression, int rowbytes,\n\tgboolean    Grey,\n\tconst Bitmap_Channel * masks,\n\tat_exception_type * exp)\n{\n  unsigned char v, n;\n  int xpos = 0;\n  int ypos = 0;\n  unsigned char * image;\n  unsigned char *dest, *temp, *row_buf;\n  long rowstride, channels;\n  unsigned short rgb;\n  int i, i_max, j;\n  int total_bytes_read;\n  unsigned int px32;\n\n  if (!(compression == BI_RGB ||\n\t  (bpp == 8 && compression == BI_RLE8) ||\n\t  (bpp == 4 && compression == BI_RLE4) ||\n\t  (bpp == 16 && compression == BI_BITFIELDS) ||\n\t  (bpp == 32 && compression == BI_BITFIELDS)))\n  {\n\t  LOG(\"Unrecognized or invalid BMP compression format.\\n\");\n\t  at_exception_fatal(exp, \"Unrecognized or invalid BMP compression format.\");\n\t  return NULL;\n  }\n\n  if (bpp >= 16) {              /* color image */\n    XMALLOC(image, width * height * 3 * sizeof(unsigned char));\n    if (masks[3].mask != 0)\n    {\n      channels = 4;\n    }\n    else\n    {\n      channels = 3;\n    }\n  }\n  else if (Grey) /* Grey image */\n  {\n    XMALLOC(image, width * height * 1 * sizeof(unsigned char));\n    channels = 1;\n  } else {                      /* indexed image */\n\n    XMALLOC(image, width * height * 1 * sizeof(unsigned char));\n    channels = 1;\n  }\n\n  /* use XCALLOC to initialize the dest row_buf so that unspecified\n\t pixels in RLE bitmaps show up as the zeroth element in the palette.\n  */\n  XCALLOC(dest, width * height * channels);\n  XMALLOC (row_buf, rowbytes); \n  rowstride = width * channels;\n\n  ypos = height - 1;            /* Bitmaps begin in the lower left corner */\n\n  switch (bpp) {\n\n  case 32:\n    {\n      while (ReadOK (fd, row_buf, rowbytes))\n      {\n        temp = image + (ypos * rowstride);\n        for (xpos = 0; xpos < width; ++xpos) {\n\t  px32 = ToL(&row_buf[xpos * 4]);\n\t  unsigned char red = *(temp++) = ((px32 & masks[0].mask) >> masks[0].shiftin) * 255.0 / masks[0].max_value + 0.5;\n\t  unsigned char green = *(temp++) = ((px32 & masks[1].mask) >> masks[1].shiftin) * 255.0 / masks[1].max_value + 0.5;\n\t  unsigned char blue = *(temp++) = ((px32 & masks[2].mask) >> masks[2].shiftin) * 255.0 / masks[2].max_value + 0.5;\n\t  /* currently alpha channels are not supported by AutoTrace, thus simply ignored */\n\t  /*if (channels > 3)\n\t\t  *(temp++) = ((px32 & masks[3].mask) >> masks[3].shiftin) * 255.0 / masks[3].max_value + 0.5;*/\n\t}\n\n\tif (ypos == 0)\n\t  break;\n\n\t--ypos; /* next line */\n      }\n    }\n    break;\n\n  case 24:\n    {\n      while (ReadOK (fd, row_buf, rowbytes))\n      {\n        temp = image + (ypos * rowstride);\n        for (xpos = 0; xpos < width; ++xpos) {\n          *(temp++) = row_buf[xpos * 3 + 2];\n          *(temp++) = row_buf[xpos * 3 + 1];\n          *(temp++) = row_buf[xpos * 3];\n        }\n\n\tif (ypos == 0)\n\t  break;\n\n        --ypos; /* next line */\n      }\n    }\n    break;\n\n  case 16:\n    {\n      while (ReadOK (fd, row_buf, rowbytes))\n      {\n        temp = image + (ypos * rowstride);\n        for (xpos = 0; xpos < width; ++xpos)\n        {\n\t  rgb = ToS(&row_buf[xpos * 2]);\n\t  *(temp++) = ((rgb & masks[0].mask) >> masks[0].shiftin) * 255.0 / masks[0].max_value + 0.5;\n\t  *(temp++) = ((rgb & masks[1].mask) >> masks[1].shiftin) * 255.0 / masks[1].max_value + 0.5;\n\t  *(temp++) = ((rgb & masks[2].mask) >> masks[2].shiftin) * 255.0 / masks[2].max_value + 0.5;\n\t  /* currently alpha channels are not supported by AutoTrace, thus simply ignored */\n\t  /*if (channels > 3)\n\t\t  *(temp++) = ((rgb & masks[3].mask) >> masks[3].shiftin) * 255.0 / masks[3].max_value + 0.5;*/\n\t}\n\n\tif (ypos == 0)\n\t  break;\n\n\t--ypos; /* next line */\n      }\n    }\n    break;\n\n  case 8:\n  case 4:\n  case 1:\n    {\n      if (compression == 0) {\n        while (ReadOK(fd, &v, 1)) {\n          for (i = 1; (i <= (8 / bpp)) && (xpos < width); i++, xpos++) {\n\t\t\ttemp = image + (ypos * rowstride) + (xpos * channels);\n\t\t\t*temp = (v & (((1 << bpp) - 1) << (8 - (i*bpp)))) >> (8 - (i*bpp));\n\t\t\tif (Grey)\n\t\t\t\t*temp = cmap[*temp][0];\n\t  }\n\n          if (xpos == width) {\n\t    ReadOK (fd, row_buf, rowbytes - 1 - (width * bpp - 1) / 8);\n            ypos--;\n            xpos = 0;\n\n          }\n          if (ypos < 0)\n            break;\n        }\n        break;\n      } else {\n\t/* compressed image (either RLE8 or RLE4) */\n        while (ypos >= 0 && xpos <= width) {\n\t\t\tif (!ReadOK(fd, row_buf, 2))\n\t\t\t{\n\t\t\t\tLOG(\"The bitmap ends unexpectedly.\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((unsigned char) row_buf[0] != 0)\n\t\t      /* Count + Color - record */\n\t\t      {\n\t\t\t\t/* encoded mode run -\n\t\t\t\t *   row_buf[0] == run_length\n\t\t\t\t *   row_buf[1] == pixel data\n\t\t\t\t */\n\t\t        for (j = 0; ((unsigned char) j < (unsigned char) row_buf[0]) && (xpos < width);)\n\t\t          {\n#ifdef DEBUG2\n              printf(\"%u %u | \", xpos, width);\n#endif\n\t\t\t        for (i = 1;\n\t\t\t             ((i <= (8 / bpp)) &&\n\t\t\t             (xpos < width) &&\n\t\t\t             ((unsigned char) j < (unsigned char) row_buf[0]));\n\t\t\t             i++, xpos++, j++)\n\t\t\t          {\n\t\t\t            temp = dest + (ypos * rowstride) + (xpos * channels);\n\t\t\t            *temp = (unsigned char) ((row_buf[1] & (((1<<bpp)-1) << (8 - (i * bpp)))) >> (8 - (i * bpp)));\n\t\t\t\t        if (Grey)\n\t\t\t\t\t      *temp = cmap[*temp][0];\n\t\t\t          }\n            }\n          }\n          if ((row_buf[0] == 0) && (row_buf[1] > 2))\n            /* uncompressed record */\n\t\t{\n\t\t\tn = row_buf[1];\n\t\t\ttotal_bytes_read = 0;\n\n\t\t\tfor (j = 0; j < n; j += (8 / bpp))\n\t\t\t{\n\t\t\t\t/* read the next byte in the record */\n\t\t\t\tif (!ReadOK(fd, &v, 1))\n\t\t\t\t{\n\t\t\t\t\tLOG(\"The bitmap ends unexpectedly.\");\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\n\t\t\t\ttotal_bytes_read++;\n\n\t\t\t\t/* read all pixels from that byte */\n\t\t\t\ti_max = 8 / bpp;\n\t\t\t\tif (n - j < i_max)\n\t\t\t\t{\n\t\t\t\t\ti_max = n - j;\n\t\t\t\t}\n\n\t\t\t\ti = 1;\n\t\t\t\twhile ((i <= i_max) && (xpos < width))\n\t\t\t\t{\n\t\t\t\t\ttemp =\n\t\t\t\t\t\tdest + (ypos * rowstride) + (xpos * channels);\n\t\t\t\t\t*temp = (v >> (8 - (i*bpp))) & ((1 << bpp) - 1);\n\t\t\t\t\tif (Grey)\n\t\t\t\t\t\t*temp = cmap[*temp][0];\n\t\t\t\t\ti++;\n\t\t\t\t\txpos++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* absolute mode runs are padded to 16-bit alignment */\n\t\t\tif (total_bytes_read % 2)\n\t\t\t\tfread(&v, 1, 1, fd); //ReadOk\n\t\t}\n\t  if (((unsigned char) row_buf[0] == 0) && ((unsigned char) row_buf[1]==0))\n            /* Line end */\n          {\n            ypos--;\n            xpos = 0;\n          }\n          if (((unsigned char)row_buf[0] == 0) && ((unsigned char)row_buf[1] == 1))\n            /* Bitmap end */\n          {\n            break;\n          }\n          if (((unsigned char)row_buf[0] == 0) && ((unsigned char)row_buf[1] == 2))\n            /* Deltarecord */\n          {\n\t\t\tif (!ReadOK(fd, row_buf, 2))\n\t\t\t  {\n\t\t\t\tLOG(\"The bitmap ends unexpectedly.\");\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\txpos += (unsigned char) row_buf[0];\n\t\t    ypos -= (unsigned char) row_buf[1];\n          }\n        }\n        break;\n      }\n    }\n    break;\n  default:\n    /* This is very bad, we should not be here */\n    break;\n  }\n\n  if (bpp <= 8) {\n    unsigned char *temp2, *temp3;\n    unsigned char index;\n    temp2 = temp = image;\n    XMALLOC (image, width * height * 3 * sizeof (unsigned char)); //???\n    temp3 = image;\n    for (ypos = 0; ypos < height; ypos++) {\n      for (xpos = 0; xpos < width; xpos++) {\n        index = *temp2++;\n        *temp3++ = cmap[index][0];\n        if (!Grey) {\n          *temp3++ = cmap[index][1];\n          *temp3++ = cmap[index][2];\n        }\n      }\n    }\n    free(temp);\n  }\n\n  free (row_buf);\n  free(dest);\n  return image;\n}\n\nstatic long ToL(unsigned char *puffer)\n{\n  return (puffer[0] | puffer[1] << 8 | puffer[2] << 16 | puffer[3] << 24);\n}\n\nstatic short ToS(unsigned char *puffer)\n{\n  return ((short)(puffer[0] | puffer[1] << 8));\n}\n"], "filenames": ["src/input-bmp.c"], "buggy_code_start_loc": [643], "buggy_code_end_loc": [695], "fixing_code_start_loc": [643], "fixing_code_end_loc": [699], "type": "CWE-787", "message": "AutoTrace v0.40.0 was discovered to contain a heap overflow via the ReadImage function at input-bmp.c:660.", "other": {"cve": {"id": "CVE-2022-32323", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-14T21:15:08.513", "lastModified": "2022-10-27T13:28:27.863", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "AutoTrace v0.40.0 was discovered to contain a heap overflow via the ReadImage function at input-bmp.c:660."}, {"lang": "es", "value": "Se ha detectado que AutoTrace versi\u00f3n v0.40.0, contiene un desbordamiento de pila por medio de la funci\u00f3n ReadImage en el archivo input-bmp.c:660"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:autotrace_project:autotrace:0.40.0:*:*:*:*:*:*:*", "matchCriteriaId": "0E537C68-EC92-42A9-A459-0982D12FAC65"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/autotrace/autotrace/commit/2b44c173027736c64b3f379bd154c41bab745423", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4CZVCQH4L7KC5GXLU6SCESXR5TGSKQ2H/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UKZPC4WCDOJ7BPJOMZ46AV27RCABZRYA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/autotrace/autotrace/commit/2b44c173027736c64b3f379bd154c41bab745423"}}