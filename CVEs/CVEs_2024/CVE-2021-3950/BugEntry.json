{"buggy_code": ["\"\"\"\ndjango-helpdesk - A Django powered ticket tracker for small enterprise.\n\n(c) Copyright 2008 Jutda. All Rights Reserved. See LICENSE for details.\n\nlib.py - Common functions (eg multipart e-mail)\n\"\"\"\n\nimport logging\nimport mimetypes\n\nfrom django.conf import settings\nfrom django.utils.encoding import smart_text\n\nfrom helpdesk.models import FollowUpAttachment\n\n\nlogger = logging.getLogger('helpdesk')\n\n\ndef ticket_template_context(ticket):\n    context = {}\n\n    for field in ('title', 'created', 'modified', 'submitter_email',\n                  'status', 'get_status_display', 'on_hold', 'description',\n                  'resolution', 'priority', 'get_priority_display',\n                  'last_escalation', 'ticket', 'ticket_for_url', 'merged_to',\n                  'get_status', 'ticket_url', 'staff_url', '_get_assigned_to'\n                  ):\n        attr = getattr(ticket, field, None)\n        if callable(attr):\n            context[field] = '%s' % attr()\n        else:\n            context[field] = attr\n    context['assigned_to'] = context['_get_assigned_to']\n\n    return context\n\n\ndef queue_template_context(queue):\n    context = {}\n\n    for field in ('title', 'slug', 'email_address', 'from_address', 'locale'):\n        attr = getattr(queue, field, None)\n        if callable(attr):\n            context[field] = attr()\n        else:\n            context[field] = attr\n\n    return context\n\n\ndef safe_template_context(ticket):\n    \"\"\"\n    Return a dictionary that can be used as a template context to render\n    comments and other details with ticket or queue parameters. Note that\n    we don't just provide the Ticket & Queue objects to the template as\n    they could reveal confidential information. Just imagine these two options:\n        * {{ ticket.queue.email_box_password }}\n        * {{ ticket.assigned_to.password }}\n\n    Ouch!\n\n    The downside to this is that if we make changes to the model, we will also\n    have to update this code. Perhaps we can find a better way in the future.\n    \"\"\"\n\n    context = {\n        'queue': queue_template_context(ticket.queue),\n        'ticket': ticket_template_context(ticket),\n    }\n    context['ticket']['queue'] = context['queue']\n\n    return context\n\n\ndef text_is_spam(text, request):\n    # Based on a blog post by 'sciyoshi':\n    # http://sciyoshi.com/blog/2008/aug/27/using-akismet-djangos-new-comments-framework/\n    # This will return 'True' is the given text is deemed to be spam, or\n    # False if it is not spam. If it cannot be checked for some reason, we\n    # assume it isn't spam.\n    from django.contrib.sites.models import Site\n    from django.core.exceptions import ImproperlyConfigured\n    try:\n        from akismet import Akismet\n    except ImportError:\n        return False\n    try:\n        site = Site.objects.get_current()\n    except ImproperlyConfigured:\n        site = Site(domain='configure-django-sites.com')\n\n    # see https://akismet.readthedocs.io/en/latest/overview.html#using-akismet\n\n    apikey = None\n\n    if hasattr(settings, 'TYPEPAD_ANTISPAM_API_KEY'):\n        apikey = settings.TYPEPAD_ANTISPAM_API_KEY\n    elif hasattr(settings, 'PYTHON_AKISMET_API_KEY'):\n        # new env var expected by python-akismet package\n        apikey = settings.PYTHON_AKISMET_API_KEY\n    elif hasattr(settings, 'AKISMET_API_KEY'):\n        # deprecated, but kept for backward compatibility\n        apikey = settings.AKISMET_API_KEY\n    else:\n        return False\n\n    ak = Akismet(\n        blog_url='http://%s/' % site.domain,\n        key=apikey,\n    )\n\n    if hasattr(settings, 'TYPEPAD_ANTISPAM_API_KEY'):\n        ak.baseurl = 'api.antispam.typepad.com/1.1/'\n\n    if ak.verify_key():\n        ak_data = {\n            'user_ip': request.META.get('REMOTE_ADDR', '127.0.0.1'),\n            'user_agent': request.META.get('HTTP_USER_AGENT', ''),\n            'referrer': request.META.get('HTTP_REFERER', ''),\n            'comment_type': 'comment',\n            'comment_author': '',\n        }\n\n        return ak.comment_check(smart_text(text), data=ak_data)\n\n    return False\n\n\ndef process_attachments(followup, attached_files):\n    max_email_attachment_size = getattr(settings, 'HELPDESK_MAX_EMAIL_ATTACHMENT_SIZE', 512000)\n    attachments = []\n\n    for attached in attached_files:\n\n        if attached.size:\n            filename = smart_text(attached.name)\n            att = FollowUpAttachment(\n                followup=followup,\n                file=attached,\n                filename=filename,\n                mime_type=attached.content_type or\n                mimetypes.guess_type(filename, strict=False)[0] or\n                'application/octet-stream',\n                size=attached.size,\n            )\n            att.save()\n\n            if attached.size < max_email_attachment_size:\n                # Only files smaller than 512kb (or as defined in\n                # settings.HELPDESK_MAX_EMAIL_ATTACHMENT_SIZE) are sent via email.\n                attachments.append([filename, att.file])\n\n    return attachments\n\n\ndef format_time_spent(time_spent):\n    \"\"\"Format time_spent attribute to \"[H]HHh:MMm\" text string to be allign in\n    all graphical outputs\n    \"\"\"\n\n    if time_spent:\n        time_spent = \"{0:02d}h:{1:02d}m\".format(\n            time_spent.seconds // 3600,\n            time_spent.seconds // 60\n        )\n    else:\n        time_spent = \"\"\n    return time_spent\n"], "fixing_code": ["\"\"\"\ndjango-helpdesk - A Django powered ticket tracker for small enterprise.\n\n(c) Copyright 2008 Jutda. All Rights Reserved. See LICENSE for details.\n\nlib.py - Common functions (eg multipart e-mail)\n\"\"\"\n\nimport logging\nimport mimetypes\n\nfrom django.conf import settings\nfrom django.utils.encoding import smart_text\n\nfrom helpdesk.models import FollowUpAttachment\n\n\nlogger = logging.getLogger('helpdesk')\n\n\ndef ticket_template_context(ticket):\n    context = {}\n\n    for field in ('title', 'created', 'modified', 'submitter_email',\n                  'status', 'get_status_display', 'on_hold', 'description',\n                  'resolution', 'priority', 'get_priority_display',\n                  'last_escalation', 'ticket', 'ticket_for_url', 'merged_to',\n                  'get_status', 'ticket_url', 'staff_url', '_get_assigned_to'\n                  ):\n        attr = getattr(ticket, field, None)\n        if callable(attr):\n            context[field] = '%s' % attr()\n        else:\n            context[field] = attr\n    context['assigned_to'] = context['_get_assigned_to']\n\n    return context\n\n\ndef queue_template_context(queue):\n    context = {}\n\n    for field in ('title', 'slug', 'email_address', 'from_address', 'locale'):\n        attr = getattr(queue, field, None)\n        if callable(attr):\n            context[field] = attr()\n        else:\n            context[field] = attr\n\n    return context\n\n\ndef safe_template_context(ticket):\n    \"\"\"\n    Return a dictionary that can be used as a template context to render\n    comments and other details with ticket or queue parameters. Note that\n    we don't just provide the Ticket & Queue objects to the template as\n    they could reveal confidential information. Just imagine these two options:\n        * {{ ticket.queue.email_box_password }}\n        * {{ ticket.assigned_to.password }}\n\n    Ouch!\n\n    The downside to this is that if we make changes to the model, we will also\n    have to update this code. Perhaps we can find a better way in the future.\n    \"\"\"\n\n    context = {\n        'queue': queue_template_context(ticket.queue),\n        'ticket': ticket_template_context(ticket),\n    }\n    context['ticket']['queue'] = context['queue']\n\n    return context\n\n\ndef text_is_spam(text, request):\n    # Based on a blog post by 'sciyoshi':\n    # http://sciyoshi.com/blog/2008/aug/27/using-akismet-djangos-new-comments-framework/\n    # This will return 'True' is the given text is deemed to be spam, or\n    # False if it is not spam. If it cannot be checked for some reason, we\n    # assume it isn't spam.\n    from django.contrib.sites.models import Site\n    from django.core.exceptions import ImproperlyConfigured\n    try:\n        from akismet import Akismet\n    except ImportError:\n        return False\n    try:\n        site = Site.objects.get_current()\n    except ImproperlyConfigured:\n        site = Site(domain='configure-django-sites.com')\n\n    # see https://akismet.readthedocs.io/en/latest/overview.html#using-akismet\n\n    apikey = None\n\n    if hasattr(settings, 'TYPEPAD_ANTISPAM_API_KEY'):\n        apikey = settings.TYPEPAD_ANTISPAM_API_KEY\n    elif hasattr(settings, 'PYTHON_AKISMET_API_KEY'):\n        # new env var expected by python-akismet package\n        apikey = settings.PYTHON_AKISMET_API_KEY\n    elif hasattr(settings, 'AKISMET_API_KEY'):\n        # deprecated, but kept for backward compatibility\n        apikey = settings.AKISMET_API_KEY\n    else:\n        return False\n\n    ak = Akismet(\n        blog_url='http://%s/' % site.domain,\n        key=apikey,\n    )\n\n    if hasattr(settings, 'TYPEPAD_ANTISPAM_API_KEY'):\n        ak.baseurl = 'api.antispam.typepad.com/1.1/'\n\n    if ak.verify_key():\n        ak_data = {\n            'user_ip': request.META.get('REMOTE_ADDR', '127.0.0.1'),\n            'user_agent': request.META.get('HTTP_USER_AGENT', ''),\n            'referrer': request.META.get('HTTP_REFERER', ''),\n            'comment_type': 'comment',\n            'comment_author': '',\n        }\n\n        return ak.comment_check(smart_text(text), data=ak_data)\n\n    return False\n\n\ndef process_attachments(followup, attached_files):\n    max_email_attachment_size = getattr(settings, 'HELPDESK_MAX_EMAIL_ATTACHMENT_SIZE', 512000)\n    attachments = []\n\n    for attached in attached_files:\n\n        if attached.size:\n            filename = smart_text(attached.name)\n            att = FollowUpAttachment(\n                followup=followup,\n                file=attached,\n                filename=filename,\n                mime_type=attached.content_type or\n                mimetypes.guess_type(filename, strict=False)[0] or\n                'application/octet-stream',\n                size=attached.size,\n            )\n            att.full_clean()\n            att.save()\n\n            if attached.size < max_email_attachment_size:\n                # Only files smaller than 512kb (or as defined in\n                # settings.HELPDESK_MAX_EMAIL_ATTACHMENT_SIZE) are sent via email.\n                attachments.append([filename, att.file])\n\n    return attachments\n\n\ndef format_time_spent(time_spent):\n    \"\"\"Format time_spent attribute to \"[H]HHh:MMm\" text string to be allign in\n    all graphical outputs\n    \"\"\"\n\n    if time_spent:\n        time_spent = \"{0:02d}h:{1:02d}m\".format(\n            time_spent.seconds // 3600,\n            time_spent.seconds // 60\n        )\n    else:\n        time_spent = \"\"\n    return time_spent\n"], "filenames": ["helpdesk/lib.py"], "buggy_code_start_loc": [147], "buggy_code_end_loc": [147], "fixing_code_start_loc": [148], "fixing_code_end_loc": [149], "type": "CWE-79", "message": "django-helpdesk is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "other": {"cve": {"id": "CVE-2021-3950", "sourceIdentifier": "security@huntr.dev", "published": "2021-11-19T12:15:08.813", "lastModified": "2021-11-23T18:02:26.857", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "django-helpdesk is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}, {"lang": "es", "value": "django-helpdesk es vulnerable a una Neutralizaci\u00f3n Inapropiada de Entradas durante la Generaci\u00f3n de P\u00e1ginas Web (\"Cross-site Scripting\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:django-helpdesk_project:django-helpdesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.1", "matchCriteriaId": "401CC2F0-2497-44CA-987B-74CC7E83DA5C"}]}]}], "references": [{"url": "https://github.com/django-helpdesk/django-helpdesk/commit/04483bdac3b5196737516398b5ce0383875a5c60", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/4d7a5fdd-b2de-467a-ade0-3f2fb386638e", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/django-helpdesk/django-helpdesk/commit/04483bdac3b5196737516398b5ce0383875a5c60"}}