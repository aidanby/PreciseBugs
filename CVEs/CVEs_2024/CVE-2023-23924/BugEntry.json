{"buggy_code": ["<?php\n/**\n * @package dompdf\n * @link    https://github.com/dompdf/dompdf\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\Image;\n\nuse Dompdf\\Options;\nuse Dompdf\\Helpers;\nuse Dompdf\\Exception\\ImageException;\n\n/**\n * Static class that resolves image urls and downloads and caches\n * remote images if required.\n *\n * @package dompdf\n */\nclass Cache\n{\n    /**\n     * Array of downloaded images.  Cached so that identical images are\n     * not needlessly downloaded.\n     *\n     * @var array\n     */\n    protected static $_cache = [];\n\n    /**\n     * @var array\n     */\n    protected static $tempImages = [];\n\n    /**\n     * The url to the \"broken image\" used when images can't be loaded\n     *\n     * @var string\n     */\n    public static $broken_image = \"data:image/svg+xml;charset=utf8,%3C?xml version='1.0'?%3E%3Csvg width='64' height='64' xmlns='http://www.w3.org/2000/svg'%3E%3Cg%3E%3Crect stroke='%23666666' id='svg_1' height='60.499994' width='60.166667' y='1.666669' x='1.999998' stroke-width='1.5' fill='none'/%3E%3Cline stroke-linecap='null' stroke-linejoin='null' id='svg_3' y2='59.333253' x2='59.749916' y1='4.333415' x1='4.250079' stroke-width='1.5' stroke='%23999999' fill='none'/%3E%3Cline stroke-linecap='null' stroke-linejoin='null' id='svg_4' y2='59.999665' x2='4.062838' y1='3.750342' x1='60.062164' stroke-width='1.5' stroke='%23999999' fill='none'/%3E%3C/g%3E%3C/svg%3E\";\n\n    public static $error_message = \"Image not found or type unknown\";\n    \n    /**\n     * Resolve and fetch an image for use.\n     *\n     * @param string $url       The url of the image\n     * @param string $protocol  Default protocol if none specified in $url\n     * @param string $host      Default host if none specified in $url\n     * @param string $base_path Default path if none specified in $url\n     * @param Options $options  An instance of Dompdf\\Options\n     *\n     * @return array            An array with three elements: The local path to the image, the image\n     *                          extension, and an error message if the image could not be cached\n     */\n    static function resolve_url($url, $protocol, $host, $base_path, Options $options)\n    {\n        $tempfile = null;\n        $resolved_url = null;\n        $type = null;\n        $message = null;\n        \n        try {\n            $full_url = Helpers::build_url($protocol, $host, $base_path, $url);\n\n            if ($full_url === null) {\n                throw new ImageException(\"Unable to parse image URL $url.\", E_WARNING);\n            }\n\n            $parsed_url = Helpers::explode_url($full_url);\n            $protocol = strtolower($parsed_url[\"protocol\"]);\n            $is_data_uri = strpos($protocol, \"data:\") === 0;\n            \n            if (!$is_data_uri) {\n                $allowed_protocols = $options->getAllowedProtocols();\n                if (!array_key_exists($protocol, $allowed_protocols)) {\n                    throw new ImageException(\"Permission denied on $url. The communication protocol is not supported.\", E_WARNING);\n                }\n                foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n                    [$result, $message] = $rule($full_url);\n                    if (!$result) {\n                        throw new ImageException(\"Error loading $url: $message\", E_WARNING);\n                    }\n                }\n            }\n\n            if ($protocol === \"file://\") {\n                $resolved_url = $full_url;\n            } elseif (isset(self::$_cache[$full_url])) {\n                $resolved_url = self::$_cache[$full_url];\n            } else {\n                $tmp_dir = $options->getTempDir();\n                if (($resolved_url = @tempnam($tmp_dir, \"ca_dompdf_img_\")) === false) {\n                    throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n                }\n                $tempfile = $resolved_url;\n\n                $image = null;\n                if ($is_data_uri) {\n                    if (($parsed_data_uri = Helpers::parse_data_uri($url)) !== false) {\n                        $image = $parsed_data_uri[\"data\"];\n                    }\n                } else {\n                    list($image, $http_response_header) = Helpers::getFileContent($full_url, $options->getHttpContext());\n                }\n\n                // Image not found or invalid\n                if ($image === null) {\n                    $msg = ($is_data_uri ? \"Data-URI could not be parsed\" : \"Image not found\");\n                    throw new ImageException($msg, E_WARNING);\n                }\n\n                if (@file_put_contents($resolved_url, $image) === false) {\n                    throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n                }\n\n                self::$_cache[$full_url] = $resolved_url;\n            }\n\n            // Check if the local file is readable\n            if (!is_readable($resolved_url) || !filesize($resolved_url)) {\n                throw new ImageException(\"Image not readable or empty\", E_WARNING);\n            }\n\n            list($width, $height, $type) = Helpers::dompdf_getimagesize($resolved_url, $options->getHttpContext());\n\n            if (($width && $height && in_array($type, [\"gif\", \"png\", \"jpeg\", \"bmp\", \"svg\",\"webp\"], true)) === false) {\n                throw new ImageException(\"Image type unknown\", E_WARNING);\n            }\n\n            if ($type === \"svg\") {\n                $parser = xml_parser_create(\"utf-8\");\n                xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, false);\n                xml_set_element_handler(\n                    $parser,\n                    function ($parser, $name, $attributes) use ($options, $parsed_url, $full_url) {\n                        if ($name === \"image\") {\n                            $attributes = array_change_key_case($attributes, CASE_LOWER);\n                            $url = $attributes[\"xlink:href\"] ?? $attributes[\"href\"];\n                            if (!empty($url)) {\n                                $inner_full_url = Helpers::build_url($parsed_url[\"protocol\"], $parsed_url[\"host\"], $parsed_url[\"path\"], $url);\n                                if ($inner_full_url === $full_url) {\n                                    throw new ImageException(\"SVG self-reference is not allowed\", E_WARNING);\n                                }\n                                [$resolved_url, $type, $message] = self::resolve_url($url, $parsed_url[\"protocol\"], $parsed_url[\"host\"], $parsed_url[\"path\"], $options);\n                                if (!empty($message)) {\n                                    throw new ImageException(\"This SVG document references a restricted resource. $message\", E_WARNING);\n                                }\n                            }\n                        }\n                    },\n                    false\n                );\n        \n                if (($fp = fopen($resolved_url, \"r\")) !== false) {\n                    while ($line = fread($fp, 8192)) {\n                        xml_parse($parser, $line, false);\n                    }\n                    fclose($fp);\n                }\n                xml_parser_free($parser);\n            }\n        } catch (ImageException $e) {\n            if ($tempfile) {\n                unlink($tempfile);\n            }\n            $resolved_url = self::$broken_image;\n            list($width, $height, $type) = Helpers::dompdf_getimagesize($resolved_url, $options->getHttpContext());\n            $message = self::$error_message;\n            Helpers::record_warnings($e->getCode(), $e->getMessage() . \" \\n $url\", $e->getFile(), $e->getLine());\n            self::$_cache[$full_url] = $resolved_url;\n        }\n\n        return [$resolved_url, $type, $message];\n    }\n\n    /**\n     * Register a temp file for the given original image file.\n     *\n     * @param string $filePath The path of the original image.\n     * @param string $tempPath The path of the temp file to register.\n     * @param string $key      An optional key to register the temp file at.\n     */\n    static function addTempImage(string $filePath, string $tempPath, string $key = \"default\"): void\n    {\n        if (!isset(self::$tempImages[$filePath])) {\n            self::$tempImages[$filePath] = [];\n        }\n\n        self::$tempImages[$filePath][$key] = $tempPath;\n    }\n\n    /**\n     * Get the path of a temp file registered for the given original image file.\n     *\n     * @param string $filePath The path of the original image.\n     * @param string $key      The key the temp file is registered at.\n     */\n    static function getTempImage(string $filePath, string $key = \"default\"): ?string\n    {\n        return self::$tempImages[$filePath][$key] ?? null;\n    }\n\n    /**\n     * Unlink all cached images (i.e. temporary images either downloaded\n     * or converted) except for the bundled \"broken image\"\n     */\n    static function clear(bool $debugPng = false)\n    {\n        foreach (self::$_cache as $file) {\n            if ($file === self::$broken_image) {\n                continue;\n            }\n            if ($debugPng) {\n                print \"[clear unlink $file]\";\n            }\n            if (file_exists($file)) {\n                unlink($file);\n            }\n        }\n\n        foreach (self::$tempImages as $versions) {\n            foreach ($versions as $file) {\n                if ($file === self::$broken_image) {\n                    continue;\n                }\n                if ($debugPng) {\n                    print \"[unlink temp image $file]\";\n                }\n                if (file_exists($file)) {\n                    unlink($file);\n                }\n            }\n        }\n\n        self::$_cache = [];\n        self::$tempImages = [];\n    }\n\n    static function detect_type($file, $context = null)\n    {\n        list(, , $type) = Helpers::dompdf_getimagesize($file, $context);\n\n        return $type;\n    }\n\n    static function is_broken($url)\n    {\n        return $url === self::$broken_image;\n    }\n}\n\nif (file_exists(realpath(__DIR__ . \"/../../lib/res/broken_image.svg\"))) {\n    Cache::$broken_image = realpath(__DIR__ . \"/../../lib/res/broken_image.svg\");\n}\n"], "fixing_code": ["<?php\n/**\n * @package dompdf\n * @link    https://github.com/dompdf/dompdf\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\Image;\n\nuse Dompdf\\Options;\nuse Dompdf\\Helpers;\nuse Dompdf\\Exception\\ImageException;\n\n/**\n * Static class that resolves image urls and downloads and caches\n * remote images if required.\n *\n * @package dompdf\n */\nclass Cache\n{\n    /**\n     * Array of downloaded images.  Cached so that identical images are\n     * not needlessly downloaded.\n     *\n     * @var array\n     */\n    protected static $_cache = [];\n\n    /**\n     * @var array\n     */\n    protected static $tempImages = [];\n\n    /**\n     * The url to the \"broken image\" used when images can't be loaded\n     *\n     * @var string\n     */\n    public static $broken_image = \"data:image/svg+xml;charset=utf8,%3C?xml version='1.0'?%3E%3Csvg width='64' height='64' xmlns='http://www.w3.org/2000/svg'%3E%3Cg%3E%3Crect stroke='%23666666' id='svg_1' height='60.499994' width='60.166667' y='1.666669' x='1.999998' stroke-width='1.5' fill='none'/%3E%3Cline stroke-linecap='null' stroke-linejoin='null' id='svg_3' y2='59.333253' x2='59.749916' y1='4.333415' x1='4.250079' stroke-width='1.5' stroke='%23999999' fill='none'/%3E%3Cline stroke-linecap='null' stroke-linejoin='null' id='svg_4' y2='59.999665' x2='4.062838' y1='3.750342' x1='60.062164' stroke-width='1.5' stroke='%23999999' fill='none'/%3E%3C/g%3E%3C/svg%3E\";\n\n    public static $error_message = \"Image not found or type unknown\";\n    \n    /**\n     * Resolve and fetch an image for use.\n     *\n     * @param string $url       The url of the image\n     * @param string $protocol  Default protocol if none specified in $url\n     * @param string $host      Default host if none specified in $url\n     * @param string $base_path Default path if none specified in $url\n     * @param Options $options  An instance of Dompdf\\Options\n     *\n     * @return array            An array with three elements: The local path to the image, the image\n     *                          extension, and an error message if the image could not be cached\n     */\n    static function resolve_url($url, $protocol, $host, $base_path, Options $options)\n    {\n        $tempfile = null;\n        $resolved_url = null;\n        $type = null;\n        $message = null;\n        \n        try {\n            $full_url = Helpers::build_url($protocol, $host, $base_path, $url);\n\n            if ($full_url === null) {\n                throw new ImageException(\"Unable to parse image URL $url.\", E_WARNING);\n            }\n\n            $parsed_url = Helpers::explode_url($full_url);\n            $protocol = strtolower($parsed_url[\"protocol\"]);\n            $is_data_uri = strpos($protocol, \"data:\") === 0;\n            \n            if (!$is_data_uri) {\n                $allowed_protocols = $options->getAllowedProtocols();\n                if (!array_key_exists($protocol, $allowed_protocols)) {\n                    throw new ImageException(\"Permission denied on $url. The communication protocol is not supported.\", E_WARNING);\n                }\n                foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n                    [$result, $message] = $rule($full_url);\n                    if (!$result) {\n                        throw new ImageException(\"Error loading $url: $message\", E_WARNING);\n                    }\n                }\n            }\n\n            if ($protocol === \"file://\") {\n                $resolved_url = $full_url;\n            } elseif (isset(self::$_cache[$full_url])) {\n                $resolved_url = self::$_cache[$full_url];\n            } else {\n                $tmp_dir = $options->getTempDir();\n                if (($resolved_url = @tempnam($tmp_dir, \"ca_dompdf_img_\")) === false) {\n                    throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n                }\n                $tempfile = $resolved_url;\n\n                $image = null;\n                if ($is_data_uri) {\n                    if (($parsed_data_uri = Helpers::parse_data_uri($url)) !== false) {\n                        $image = $parsed_data_uri[\"data\"];\n                    }\n                } else {\n                    list($image, $http_response_header) = Helpers::getFileContent($full_url, $options->getHttpContext());\n                }\n\n                // Image not found or invalid\n                if ($image === null) {\n                    $msg = ($is_data_uri ? \"Data-URI could not be parsed\" : \"Image not found\");\n                    throw new ImageException($msg, E_WARNING);\n                }\n\n                if (@file_put_contents($resolved_url, $image) === false) {\n                    throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n                }\n\n                self::$_cache[$full_url] = $resolved_url;\n            }\n\n            // Check if the local file is readable\n            if (!is_readable($resolved_url) || !filesize($resolved_url)) {\n                throw new ImageException(\"Image not readable or empty\", E_WARNING);\n            }\n\n            list($width, $height, $type) = Helpers::dompdf_getimagesize($resolved_url, $options->getHttpContext());\n\n            if (($width && $height && in_array($type, [\"gif\", \"png\", \"jpeg\", \"bmp\", \"svg\",\"webp\"], true)) === false) {\n                throw new ImageException(\"Image type unknown\", E_WARNING);\n            }\n\n            if ($type === \"svg\") {\n                $parser = xml_parser_create(\"utf-8\");\n                xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, false);\n                xml_set_element_handler(\n                    $parser,\n                    function ($parser, $name, $attributes) use ($options, $parsed_url, $full_url) {\n                        if (strtolower($name) === \"image\") {\n                            $attributes = array_change_key_case($attributes, CASE_LOWER);\n                            $url = $attributes[\"xlink:href\"] ?? $attributes[\"href\"];\n                            if (!empty($url)) {\n                                $inner_full_url = Helpers::build_url($parsed_url[\"protocol\"], $parsed_url[\"host\"], $parsed_url[\"path\"], $url);\n                                if ($inner_full_url === $full_url) {\n                                    throw new ImageException(\"SVG self-reference is not allowed\", E_WARNING);\n                                }\n                                [$resolved_url, $type, $message] = self::resolve_url($url, $parsed_url[\"protocol\"], $parsed_url[\"host\"], $parsed_url[\"path\"], $options);\n                                if (!empty($message)) {\n                                    throw new ImageException(\"This SVG document references a restricted resource. $message\", E_WARNING);\n                                }\n                            }\n                        }\n                    },\n                    false\n                );\n        \n                if (($fp = fopen($resolved_url, \"r\")) !== false) {\n                    while ($line = fread($fp, 8192)) {\n                        xml_parse($parser, $line, false);\n                    }\n                    fclose($fp);\n                }\n                xml_parser_free($parser);\n            }\n        } catch (ImageException $e) {\n            if ($tempfile) {\n                unlink($tempfile);\n            }\n            $resolved_url = self::$broken_image;\n            list($width, $height, $type) = Helpers::dompdf_getimagesize($resolved_url, $options->getHttpContext());\n            $message = self::$error_message;\n            Helpers::record_warnings($e->getCode(), $e->getMessage() . \" \\n $url\", $e->getFile(), $e->getLine());\n            self::$_cache[$full_url] = $resolved_url;\n        }\n\n        return [$resolved_url, $type, $message];\n    }\n\n    /**\n     * Register a temp file for the given original image file.\n     *\n     * @param string $filePath The path of the original image.\n     * @param string $tempPath The path of the temp file to register.\n     * @param string $key      An optional key to register the temp file at.\n     */\n    static function addTempImage(string $filePath, string $tempPath, string $key = \"default\"): void\n    {\n        if (!isset(self::$tempImages[$filePath])) {\n            self::$tempImages[$filePath] = [];\n        }\n\n        self::$tempImages[$filePath][$key] = $tempPath;\n    }\n\n    /**\n     * Get the path of a temp file registered for the given original image file.\n     *\n     * @param string $filePath The path of the original image.\n     * @param string $key      The key the temp file is registered at.\n     */\n    static function getTempImage(string $filePath, string $key = \"default\"): ?string\n    {\n        return self::$tempImages[$filePath][$key] ?? null;\n    }\n\n    /**\n     * Unlink all cached images (i.e. temporary images either downloaded\n     * or converted) except for the bundled \"broken image\"\n     */\n    static function clear(bool $debugPng = false)\n    {\n        foreach (self::$_cache as $file) {\n            if ($file === self::$broken_image) {\n                continue;\n            }\n            if ($debugPng) {\n                print \"[clear unlink $file]\";\n            }\n            if (file_exists($file)) {\n                unlink($file);\n            }\n        }\n\n        foreach (self::$tempImages as $versions) {\n            foreach ($versions as $file) {\n                if ($file === self::$broken_image) {\n                    continue;\n                }\n                if ($debugPng) {\n                    print \"[unlink temp image $file]\";\n                }\n                if (file_exists($file)) {\n                    unlink($file);\n                }\n            }\n        }\n\n        self::$_cache = [];\n        self::$tempImages = [];\n    }\n\n    static function detect_type($file, $context = null)\n    {\n        list(, , $type) = Helpers::dompdf_getimagesize($file, $context);\n\n        return $type;\n    }\n\n    static function is_broken($url)\n    {\n        return $url === self::$broken_image;\n    }\n}\n\nif (file_exists(realpath(__DIR__ . \"/../../lib/res/broken_image.svg\"))) {\n    Cache::$broken_image = realpath(__DIR__ . \"/../../lib/res/broken_image.svg\");\n}\n"], "filenames": ["src/Image/Cache.php"], "buggy_code_start_loc": [136], "buggy_code_end_loc": [137], "fixing_code_start_loc": [136], "fixing_code_end_loc": [137], "type": "CWE-863", "message": "Dompdf is an HTML to PDF converter. The URI validation on dompdf 2.0.1 can be bypassed on SVG parsing by passing `<image>` tags with uppercase letters. This may lead to arbitrary object unserialize on PHP < 8, through the `phar` URL wrapper. An attacker can exploit the vulnerability to call arbitrary URL with arbitrary protocols, if they can provide a SVG file to dompdf. In PHP versions before 8.0.0, it leads to arbitrary unserialize, that will lead to the very least to an arbitrary file deletion and even remote code execution, depending on classes that are available.", "other": {"cve": {"id": "CVE-2023-23924", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-01T00:15:10.693", "lastModified": "2023-02-08T22:21:25.730", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dompdf is an HTML to PDF converter. The URI validation on dompdf 2.0.1 can be bypassed on SVG parsing by passing `<image>` tags with uppercase letters. This may lead to arbitrary object unserialize on PHP < 8, through the `phar` URL wrapper. An attacker can exploit the vulnerability to call arbitrary URL with arbitrary protocols, if they can provide a SVG file to dompdf. In PHP versions before 8.0.0, it leads to arbitrary unserialize, that will lead to the very least to an arbitrary file deletion and even remote code execution, depending on classes that are available."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-551"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dompdf_project:dompdf:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "A20BA838-5E5B-4CCD-B1DE-4AA444704DE3"}]}]}], "references": [{"url": "https://github.com/dompdf/dompdf/commit/7558f07f693b2ac3266089f21051e6b78c6a0c85", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dompdf/dompdf/releases/tag/v2.0.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/dompdf/dompdf/security/advisories/GHSA-3cw5-7cxw-v5qg", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dompdf/dompdf/commit/7558f07f693b2ac3266089f21051e6b78c6a0c85"}}