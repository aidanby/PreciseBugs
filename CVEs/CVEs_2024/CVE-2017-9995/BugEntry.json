{"buggy_code": ["/*\n * ScreenPressor decoder\n *\n * Copyright (c) 2017 Paul B Mahol\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n\n#define TOP  0x01000000\n#define BOT    0x010000\n\ntypedef struct RangeCoder {\n    unsigned   code;\n    unsigned   range;\n    unsigned   code1;\n} RangeCoder;\n\ntypedef struct PixelModel {\n    unsigned    freq[256];\n    unsigned    lookup[16];\n    unsigned    total_freq;\n} PixelModel;\n\ntypedef struct SCPRContext {\n    AVFrame        *last_frame;\n    AVFrame        *current_frame;\n    GetByteContext  gb;\n    RangeCoder      rc;\n    PixelModel      pixel_model[3][4096];\n    unsigned        op_model[6][7];\n    unsigned        run_model[6][257];\n    unsigned        range_model[257];\n    unsigned        count_model[257];\n    unsigned        fill_model[6];\n    unsigned        sxy_model[4][17];\n    unsigned        mv_model[2][513];\n    unsigned        nbx, nby;\n    unsigned        nbcount;\n    unsigned       *blocks;\n    unsigned        cbits;\n    int             cxshift;\n\n    int           (*get_freq)(RangeCoder *rc, unsigned total_freq, unsigned *freq);\n    int           (*decode)(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq);\n} SCPRContext;\n\nstatic void init_rangecoder(RangeCoder *rc, GetByteContext *gb)\n{\n    rc->code1 = 0;\n    rc->range = 0xFFFFFFFFU;\n    rc->code  = bytestream2_get_be32(gb);\n}\n\nstatic void reinit_tables(SCPRContext *s)\n{\n    int comp, i, j;\n\n    for (comp = 0; comp < 3; comp++) {\n        for (j = 0; j < 4096; j++) {\n            if (s->pixel_model[comp][j].total_freq != 256) {\n                for (i = 0; i < 256; i++)\n                    s->pixel_model[comp][j].freq[i] = 1;\n                for (i = 0; i < 16; i++)\n                    s->pixel_model[comp][j].lookup[i] = 16;\n                s->pixel_model[comp][j].total_freq = 256;\n            }\n        }\n    }\n\n    for (j = 0; j < 6; j++) {\n        unsigned *p = s->run_model[j];\n        for (i = 0; i < 256; i++)\n            p[i] = 1;\n        p[256] = 256;\n    }\n\n    for (j = 0; j < 6; j++) {\n        unsigned *op = s->op_model[j];\n        for (i = 0; i < 6; i++)\n            op[i] = 1;\n        op[6] = 6;\n    }\n\n    for (i = 0; i < 256; i++) {\n        s->range_model[i] = 1;\n        s->count_model[i] = 1;\n    }\n    s->range_model[256] = 256;\n    s->count_model[256] = 256;\n\n    for (i = 0; i < 5; i++) {\n        s->fill_model[i] = 1;\n    }\n    s->fill_model[5] = 5;\n\n    for (j = 0; j < 4; j++) {\n        for (i = 0; i < 16; i++) {\n            s->sxy_model[j][i] = 1;\n        }\n        s->sxy_model[j][16] = 16;\n    }\n\n    for (i = 0; i < 512; i++) {\n        s->mv_model[0][i] = 1;\n        s->mv_model[1][i] = 1;\n    }\n    s->mv_model[0][512] = 512;\n    s->mv_model[1][512] = 512;\n}\n\nstatic int decode(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n{\n    rc->code -= cumFreq * rc->range;\n    rc->range *= freq;\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n        unsigned byte = bytestream2_get_byte(gb);\n        rc->code = (rc->code << 8) | byte;\n        rc->range <<= 8;\n    }\n\n    return 0;\n}\n\nstatic int get_freq(RangeCoder *rc, unsigned total_freq, unsigned *freq)\n{\n    if (total_freq == 0)\n        return AVERROR_INVALIDDATA;\n\n    rc->range = rc->range / total_freq;\n\n    if (rc->range == 0)\n        return AVERROR_INVALIDDATA;\n\n    *freq = rc->code / rc->range;\n\n    return 0;\n}\n\nstatic int decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n{\n    unsigned t;\n\n    if (total_freq == 0)\n        return AVERROR_INVALIDDATA;\n\n    t = rc->range * (uint64_t)cumFreq / total_freq;\n\n    rc->code1 += t + 1;\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n        unsigned byte = bytestream2_get_byte(gb);\n        rc->code = (rc->code << 8) | byte;\n        rc->code1 <<= 8;\n        rc->range <<= 8;\n    }\n\n    return 0;\n}\n\nstatic int get_freq0(RangeCoder *rc, unsigned total_freq, unsigned *freq)\n{\n    if (rc->range == 0)\n        return AVERROR_INVALIDDATA;\n\n    *freq = total_freq * (uint64_t)(rc->code - rc->code1) / rc->range;\n\n    return 0;\n}\n\nstatic int decode_value(SCPRContext *s, unsigned *cnt, unsigned maxc, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = cnt[maxc];\n    unsigned value;\n    unsigned c = 0, cumfr = 0, cnt_c = 0;\n    int i, ret;\n\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n\n    while (c < maxc) {\n        cnt_c = cnt[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n\n    cnt[c] = cnt_c + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < maxc; i++) {\n            unsigned nc = (cnt[i] >> 1) + 1;\n            cnt[i] = nc;\n            totfr += nc;\n        }\n    }\n\n    cnt[maxc] = totfr;\n    *rval = c;\n\n    return 0;\n}\n\nstatic int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n\n    *rval = c & s->cbits;\n\n    return 0;\n}\n\nstatic int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)\n{\n    SCPRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    int cx = 0, cx1 = 0, k = 0, clr = 0;\n    int run, r, g, b, off, y = 0, x = 0, z, ret;\n    unsigned backstep = linesize - avctx->width;\n    const int cxshift = s->cxshift;\n    unsigned lx, ly, ptype;\n\n    reinit_tables(s);\n    bytestream2_skip(gb, 2);\n    init_rangecoder(&s->rc, gb);\n\n    while (k < avctx->width + 1) {\n        ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = r >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = g >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = b >> cxshift;\n\n        ret = decode_value(s, s->run_model[0], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        clr = (b << 16) + (g << 8) + r;\n        k += run;\n        while (run-- > 0) {\n            if (y >= avctx->height)\n                return AVERROR_INVALIDDATA;\n\n            dst[y * linesize + x] = clr;\n            lx = x;\n            ly = y;\n            x++;\n            if (x >= avctx->width) {\n                x = 0;\n                y++;\n            }\n        }\n    }\n    off = -linesize - 1;\n    ptype = 0;\n\n    while (x < avctx->width && y < avctx->height) {\n        ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);\n        if (ret < 0)\n            return ret;\n        if (ptype == 0) {\n            ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = r >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = g >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n            if (ret < 0)\n                return ret;\n\n            clr = (b << 16) + (g << 8) + r;\n        }\n        if (ptype > 5)\n            return AVERROR_INVALIDDATA;\n        ret = decode_value(s, s->run_model[ptype], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        switch (ptype) {\n        case 0:\n            while (run-- > 0) {\n                if (y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 1:\n            while (run-- > 0) {\n                if (y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                dst[y * linesize + x] = dst[ly * linesize + lx];\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            clr = dst[ly * linesize + lx];\n            break;\n        case 2:\n            while (run-- > 0) {\n                if (y < 1 || y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                clr = dst[y * linesize + x + off + 1];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 4:\n            while (run-- > 0) {\n                uint8_t *odst = (uint8_t *)dst;\n\n                if (y < 1 || y >= avctx->height ||\n                    (y == 1 && x == 0))\n                    return AVERROR_INVALIDDATA;\n\n                if (x == 0) {\n                    z = backstep;\n                } else {\n                    z = 0;\n                }\n\n                r = odst[(ly * linesize + lx) * 4] +\n                    odst[((y * linesize + x) + off - z) * 4 + 4] -\n                    odst[((y * linesize + x) + off - z) * 4];\n                g = odst[(ly * linesize + lx) * 4 + 1] +\n                    odst[((y * linesize + x) + off - z) * 4 + 5] -\n                    odst[((y * linesize + x) + off - z) * 4 + 1];\n                b = odst[(ly * linesize + lx) * 4 + 2] +\n                    odst[((y * linesize + x) + off - z) * 4 + 6] -\n                    odst[((y * linesize + x) + off - z) * 4 + 2];\n                clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 5:\n            while (run-- > 0) {\n                if (y < 1 || y >= avctx->height ||\n                    (y == 1 && x == 0))\n                    return AVERROR_INVALIDDATA;\n\n                if (x == 0) {\n                    z = backstep;\n                } else {\n                    z = 0;\n                }\n\n                clr = dst[y * linesize + x + off - z];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        }\n\n        if (avctx->bits_per_coded_sample == 16) {\n            cx1 = (clr & 0x3F00) >> 2;\n            cx = (clr & 0xFFFFFF) >> 16;\n        } else {\n            cx1 = (clr & 0xFC00) >> 4;\n            cx = (clr & 0xFFFFFF) >> 18;\n        }\n    }\n\n    return 0;\n}\n\nstatic int decompress_p(AVCodecContext *avctx,\n                        uint32_t *dst, int linesize,\n                        uint32_t *prev, int plinesize)\n{\n    SCPRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    int ret, temp, min, max, x, y, cx = 0, cx1 = 0;\n    int backstep = linesize - avctx->width;\n    const int cxshift = s->cxshift;\n\n    if (bytestream2_get_byte(gb) == 0)\n        return 0;\n    bytestream2_skip(gb, 1);\n    init_rangecoder(&s->rc, gb);\n\n    ret  = decode_value(s, s->range_model, 256, 1, &min);\n    ret |= decode_value(s, s->range_model, 256, 1, &temp);\n    min += temp << 8;\n    ret |= decode_value(s, s->range_model, 256, 1, &max);\n    ret |= decode_value(s, s->range_model, 256, 1, &temp);\n    if (ret < 0)\n        return ret;\n\n    max += temp << 8;\n    memset(s->blocks, 0, sizeof(*s->blocks) * s->nbcount);\n\n    while (min <= max) {\n        int fill, count;\n\n        ret  = decode_value(s, s->fill_model,  5,   10, &fill);\n        ret |= decode_value(s, s->count_model, 256, 20, &count);\n        if (ret < 0)\n            return ret;\n\n        while (min < s->nbcount && count-- > 0) {\n            s->blocks[min++] = fill;\n        }\n    }\n\n    for (y = 0; y < s->nby; y++) {\n        for (x = 0; x < s->nbx; x++) {\n            int sy1 = 0, sy2 = 16, sx1 = 0, sx2 = 16;\n\n            if (s->blocks[y * s->nbx + x] == 0)\n                continue;\n\n            if (((s->blocks[y * s->nbx + x] - 1) & 1) > 0) {\n                ret  = decode_value(s, s->sxy_model[0], 16, 100, &sx1);\n                ret |= decode_value(s, s->sxy_model[1], 16, 100, &sy1);\n                ret |= decode_value(s, s->sxy_model[2], 16, 100, &sx2);\n                ret |= decode_value(s, s->sxy_model[3], 16, 100, &sy2);\n                if (ret < 0)\n                    return ret;\n\n                sx2++;\n                sy2++;\n            }\n            if (((s->blocks[y * s->nbx + x] - 1) & 2) > 0) {\n                int i, j, by = y * 16, bx = x * 16;\n                int mvx, mvy;\n\n                ret  = decode_value(s, s->mv_model[0], 512, 100, &mvx);\n                ret |= decode_value(s, s->mv_model[1], 512, 100, &mvy);\n                if (ret < 0)\n                    return ret;\n\n                mvx -= 256;\n                mvy -= 256;\n\n                if (by + mvy + sy1 < 0 || bx + mvx + sx1 < 0 ||\n                    by + mvy + sy1 >= avctx->height || bx + mvx + sx1 >= avctx->width)\n                    return AVERROR_INVALIDDATA;\n\n                for (i = 0; i < sy2 - sy1 && (by + sy1 + i) < avctx->height && (by + mvy + sy1 + i) < avctx->height; i++) {\n                    for (j = 0; j < sx2 - sx1 && (bx + sx1 + j) < avctx->width && (bx + mvx + sx1 + j) < avctx->width; j++) {\n                        dst[(by + i + sy1) * linesize + bx + sx1 + j] = prev[(by + mvy + sy1 + i) * plinesize + bx + sx1 + mvx + j];\n                    }\n                }\n            } else {\n                int run, r, g, b, z, bx = x * 16 + sx1, by = y * 16 + sy1;\n                unsigned clr, ptype = 0;\n\n                for (; by < y * 16 + sy2 && by < avctx->height;) {\n                    ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);\n                    if (ptype == 0) {\n                        ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n                        if (ret < 0)\n                            return ret;\n\n                        cx1 = (cx << 6) & 0xFC0;\n                        cx = r >> cxshift;\n                        ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n                        if (ret < 0)\n                            return ret;\n\n                        cx1 = (cx << 6) & 0xFC0;\n                        cx = g >> cxshift;\n                        ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n                        if (ret < 0)\n                            return ret;\n\n                        clr = (b << 16) + (g << 8) + r;\n                    }\n                    if (ptype > 5)\n                        return AVERROR_INVALIDDATA;\n                    ret = decode_value(s, s->run_model[ptype], 256, 400, &run);\n                    if (ret < 0)\n                        return ret;\n\n                    switch (ptype) {\n                    case 0:\n                        while (run-- > 0) {\n                            if (by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 1:\n                        while (run-- > 0) {\n                            if (bx == 0) {\n                                if (by < 1)\n                                    return AVERROR_INVALIDDATA;\n                                z = backstep;\n                            } else {\n                                z = 0;\n                            }\n\n                            if (by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            clr = dst[by * linesize + bx - 1 - z];\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 2:\n                        while (run-- > 0) {\n                            if (by < 1 || by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            clr = dst[(by - 1) * linesize + bx];\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 3:\n                        while (run-- > 0) {\n                            if (by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            clr = prev[by * plinesize + bx];\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 4:\n                        while (run-- > 0) {\n                            uint8_t *odst = (uint8_t *)dst;\n\n                            if (by < 1 || by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            if (bx == 0) {\n                                z = backstep;\n                            } else {\n                                z = 0;\n                            }\n\n                            r = odst[((by - 1) * linesize + bx) * 4] +\n                                odst[(by * linesize + bx - 1 - z) * 4] -\n                                odst[((by - 1) * linesize + bx - 1 - z) * 4];\n                            g = odst[((by - 1) * linesize + bx) * 4 + 1] +\n                                odst[(by * linesize + bx - 1 - z) * 4 + 1] -\n                                odst[((by - 1) * linesize + bx - 1 - z) * 4 + 1];\n                            b = odst[((by - 1) * linesize + bx) * 4 + 2] +\n                                odst[(by * linesize + bx - 1 - z) * 4 + 2] -\n                                odst[((by - 1) * linesize + bx - 1 - z) * 4 + 2];\n                            clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 5:\n                        while (run-- > 0) {\n                            if (by < 1 || by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            if (bx == 0) {\n                                z = backstep;\n                            } else {\n                                z = 0;\n                            }\n\n                            clr = dst[(by - 1) * linesize + bx - 1 - z];\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    }\n\n                    if (avctx->bits_per_coded_sample == 16) {\n                        cx1 = (clr & 0x3F00) >> 2;\n                        cx = (clr & 0xFFFFFF) >> 16;\n                    } else {\n                        cx1 = (clr & 0xFC00) >> 4;\n                        cx = (clr & 0xFFFFFF) >> 18;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    SCPRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    AVFrame *frame = data;\n    int ret, type;\n\n    if (avctx->bits_per_coded_sample == 16) {\n        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n            return ret;\n    }\n\n    if ((ret = ff_reget_buffer(avctx, s->current_frame)) < 0)\n        return ret;\n\n    bytestream2_init(gb, avpkt->data, avpkt->size);\n\n    type = bytestream2_peek_byte(gb);\n\n    if (type == 2) {\n        s->get_freq = get_freq0;\n        s->decode = decode0;\n        frame->key_frame = 1;\n        ret = decompress_i(avctx, (uint32_t *)s->current_frame->data[0],\n                           s->current_frame->linesize[0] / 4);\n    } else if (type == 18) {\n        s->get_freq = get_freq;\n        s->decode = decode;\n        frame->key_frame = 1;\n        ret = decompress_i(avctx, (uint32_t *)s->current_frame->data[0],\n                           s->current_frame->linesize[0] / 4);\n    } else if (type == 17) {\n        uint32_t clr, *dst = (uint32_t *)s->current_frame->data[0];\n        int x, y;\n\n        frame->key_frame = 1;\n        bytestream2_skip(gb, 1);\n        if (avctx->bits_per_coded_sample == 16) {\n            uint16_t value = bytestream2_get_le16(gb);\n            int r, g, b;\n\n            r = (value      ) & 31;\n            g = (value >>  5) & 31;\n            b = (value >> 10) & 31;\n            clr = (r << 16) + (g << 8) + b;\n        } else {\n            clr = bytestream2_get_le24(gb);\n        }\n        for (y = 0; y < avctx->height; y++) {\n            for (x = 0; x < avctx->width; x++) {\n                dst[x] = clr;\n            }\n            dst += s->current_frame->linesize[0] / 4;\n        }\n    } else if (type == 0 || type == 1) {\n        frame->key_frame = 0;\n\n        ret = av_frame_copy(s->current_frame, s->last_frame);\n        if (ret < 0)\n            return ret;\n\n        ret = decompress_p(avctx, (uint32_t *)s->current_frame->data[0],\n                           s->current_frame->linesize[0] / 4,\n                           (uint32_t *)s->last_frame->data[0],\n                           s->last_frame->linesize[0] / 4);\n    } else {\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (ret < 0)\n        return ret;\n\n    if (avctx->bits_per_coded_sample != 16) {\n        ret = av_frame_ref(data, s->current_frame);\n        if (ret < 0)\n            return ret;\n    } else {\n        uint8_t *dst = frame->data[0];\n        int x, y;\n\n        ret = av_frame_copy(frame, s->current_frame);\n        if (ret < 0)\n            return ret;\n\n        for (y = 0; y < avctx->height; y++) {\n            for (x = 0; x < avctx->width * 4; x++) {\n                dst[x] = dst[x] << 3;\n            }\n            dst += frame->linesize[0];\n        }\n    }\n\n    frame->pict_type = frame->key_frame ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n    FFSWAP(AVFrame *, s->current_frame, s->last_frame);\n\n    frame->data[0]     += frame->linesize[0] * (avctx->height - 1);\n    frame->linesize[0] *= -1;\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    SCPRContext *s = avctx->priv_data;\n\n    switch (avctx->bits_per_coded_sample) {\n    case 16: avctx->pix_fmt = AV_PIX_FMT_RGB0; break;\n    case 24:\n    case 32: avctx->pix_fmt = AV_PIX_FMT_BGR0; break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported bitdepth %i\\n\", avctx->bits_per_coded_sample);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->get_freq = get_freq0;\n    s->decode = decode0;\n\n    s->cxshift = avctx->bits_per_coded_sample == 16 ? 0 : 2;\n    s->cbits = avctx->bits_per_coded_sample == 16 ? 0x1F : 0xFF;\n    s->nbx = (avctx->width + 15) / 16;\n    s->nby = (avctx->height + 15) / 16;\n    s->nbcount = s->nbx * s->nby;\n    s->blocks = av_malloc_array(s->nbcount, sizeof(*s->blocks));\n    if (!s->blocks)\n        return AVERROR(ENOMEM);\n\n    s->last_frame = av_frame_alloc();\n    s->current_frame = av_frame_alloc();\n    if (!s->last_frame || !s->current_frame)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic av_cold int decode_close(AVCodecContext *avctx)\n{\n    SCPRContext *s = avctx->priv_data;\n\n    av_freep(&s->blocks);\n    av_frame_free(&s->last_frame);\n    av_frame_free(&s->current_frame);\n\n    return 0;\n}\n\nAVCodec ff_scpr_decoder = {\n    .name             = \"scpr\",\n    .long_name        = NULL_IF_CONFIG_SMALL(\"ScreenPressor\"),\n    .type             = AVMEDIA_TYPE_VIDEO,\n    .id               = AV_CODEC_ID_SCPR,\n    .priv_data_size   = sizeof(SCPRContext),\n    .init             = decode_init,\n    .close            = decode_close,\n    .decode           = decode_frame,\n    .capabilities     = AV_CODEC_CAP_DR1,\n    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |\n                        FF_CODEC_CAP_INIT_CLEANUP,\n};\n"], "fixing_code": ["/*\n * ScreenPressor decoder\n *\n * Copyright (c) 2017 Paul B Mahol\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n\n#define TOP  0x01000000\n#define BOT    0x010000\n\ntypedef struct RangeCoder {\n    unsigned   code;\n    unsigned   range;\n    unsigned   code1;\n} RangeCoder;\n\ntypedef struct PixelModel {\n    unsigned    freq[256];\n    unsigned    lookup[16];\n    unsigned    total_freq;\n} PixelModel;\n\ntypedef struct SCPRContext {\n    AVFrame        *last_frame;\n    AVFrame        *current_frame;\n    GetByteContext  gb;\n    RangeCoder      rc;\n    PixelModel      pixel_model[3][4096];\n    unsigned        op_model[6][7];\n    unsigned        run_model[6][257];\n    unsigned        range_model[257];\n    unsigned        count_model[257];\n    unsigned        fill_model[6];\n    unsigned        sxy_model[4][17];\n    unsigned        mv_model[2][513];\n    unsigned        nbx, nby;\n    unsigned        nbcount;\n    unsigned       *blocks;\n    unsigned        cbits;\n    int             cxshift;\n\n    int           (*get_freq)(RangeCoder *rc, unsigned total_freq, unsigned *freq);\n    int           (*decode)(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq);\n} SCPRContext;\n\nstatic void init_rangecoder(RangeCoder *rc, GetByteContext *gb)\n{\n    rc->code1 = 0;\n    rc->range = 0xFFFFFFFFU;\n    rc->code  = bytestream2_get_be32(gb);\n}\n\nstatic void reinit_tables(SCPRContext *s)\n{\n    int comp, i, j;\n\n    for (comp = 0; comp < 3; comp++) {\n        for (j = 0; j < 4096; j++) {\n            if (s->pixel_model[comp][j].total_freq != 256) {\n                for (i = 0; i < 256; i++)\n                    s->pixel_model[comp][j].freq[i] = 1;\n                for (i = 0; i < 16; i++)\n                    s->pixel_model[comp][j].lookup[i] = 16;\n                s->pixel_model[comp][j].total_freq = 256;\n            }\n        }\n    }\n\n    for (j = 0; j < 6; j++) {\n        unsigned *p = s->run_model[j];\n        for (i = 0; i < 256; i++)\n            p[i] = 1;\n        p[256] = 256;\n    }\n\n    for (j = 0; j < 6; j++) {\n        unsigned *op = s->op_model[j];\n        for (i = 0; i < 6; i++)\n            op[i] = 1;\n        op[6] = 6;\n    }\n\n    for (i = 0; i < 256; i++) {\n        s->range_model[i] = 1;\n        s->count_model[i] = 1;\n    }\n    s->range_model[256] = 256;\n    s->count_model[256] = 256;\n\n    for (i = 0; i < 5; i++) {\n        s->fill_model[i] = 1;\n    }\n    s->fill_model[5] = 5;\n\n    for (j = 0; j < 4; j++) {\n        for (i = 0; i < 16; i++) {\n            s->sxy_model[j][i] = 1;\n        }\n        s->sxy_model[j][16] = 16;\n    }\n\n    for (i = 0; i < 512; i++) {\n        s->mv_model[0][i] = 1;\n        s->mv_model[1][i] = 1;\n    }\n    s->mv_model[0][512] = 512;\n    s->mv_model[1][512] = 512;\n}\n\nstatic int decode(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n{\n    rc->code -= cumFreq * rc->range;\n    rc->range *= freq;\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n        unsigned byte = bytestream2_get_byte(gb);\n        rc->code = (rc->code << 8) | byte;\n        rc->range <<= 8;\n    }\n\n    return 0;\n}\n\nstatic int get_freq(RangeCoder *rc, unsigned total_freq, unsigned *freq)\n{\n    if (total_freq == 0)\n        return AVERROR_INVALIDDATA;\n\n    rc->range = rc->range / total_freq;\n\n    if (rc->range == 0)\n        return AVERROR_INVALIDDATA;\n\n    *freq = rc->code / rc->range;\n\n    return 0;\n}\n\nstatic int decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n{\n    unsigned t;\n\n    if (total_freq == 0)\n        return AVERROR_INVALIDDATA;\n\n    t = rc->range * (uint64_t)cumFreq / total_freq;\n\n    rc->code1 += t + 1;\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n        unsigned byte = bytestream2_get_byte(gb);\n        rc->code = (rc->code << 8) | byte;\n        rc->code1 <<= 8;\n        rc->range <<= 8;\n    }\n\n    return 0;\n}\n\nstatic int get_freq0(RangeCoder *rc, unsigned total_freq, unsigned *freq)\n{\n    if (rc->range == 0)\n        return AVERROR_INVALIDDATA;\n\n    *freq = total_freq * (uint64_t)(rc->code - rc->code1) / rc->range;\n\n    return 0;\n}\n\nstatic int decode_value(SCPRContext *s, unsigned *cnt, unsigned maxc, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = cnt[maxc];\n    unsigned value;\n    unsigned c = 0, cumfr = 0, cnt_c = 0;\n    int i, ret;\n\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n\n    while (c < maxc) {\n        cnt_c = cnt[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n\n    cnt[c] = cnt_c + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < maxc; i++) {\n            unsigned nc = (cnt[i] >> 1) + 1;\n            cnt[i] = nc;\n            totfr += nc;\n        }\n    }\n\n    cnt[maxc] = totfr;\n    *rval = c;\n\n    return 0;\n}\n\nstatic int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if (x >= 16 || c >= 256) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n\n    *rval = c & s->cbits;\n\n    return 0;\n}\n\nstatic int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)\n{\n    SCPRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    int cx = 0, cx1 = 0, k = 0, clr = 0;\n    int run, r, g, b, off, y = 0, x = 0, z, ret;\n    unsigned backstep = linesize - avctx->width;\n    const int cxshift = s->cxshift;\n    unsigned lx, ly, ptype;\n\n    reinit_tables(s);\n    bytestream2_skip(gb, 2);\n    init_rangecoder(&s->rc, gb);\n\n    while (k < avctx->width + 1) {\n        ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = r >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = g >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = b >> cxshift;\n\n        ret = decode_value(s, s->run_model[0], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        clr = (b << 16) + (g << 8) + r;\n        k += run;\n        while (run-- > 0) {\n            if (y >= avctx->height)\n                return AVERROR_INVALIDDATA;\n\n            dst[y * linesize + x] = clr;\n            lx = x;\n            ly = y;\n            x++;\n            if (x >= avctx->width) {\n                x = 0;\n                y++;\n            }\n        }\n    }\n    off = -linesize - 1;\n    ptype = 0;\n\n    while (x < avctx->width && y < avctx->height) {\n        ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);\n        if (ret < 0)\n            return ret;\n        if (ptype == 0) {\n            ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = r >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = g >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n            if (ret < 0)\n                return ret;\n\n            clr = (b << 16) + (g << 8) + r;\n        }\n        if (ptype > 5)\n            return AVERROR_INVALIDDATA;\n        ret = decode_value(s, s->run_model[ptype], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        switch (ptype) {\n        case 0:\n            while (run-- > 0) {\n                if (y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 1:\n            while (run-- > 0) {\n                if (y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                dst[y * linesize + x] = dst[ly * linesize + lx];\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            clr = dst[ly * linesize + lx];\n            break;\n        case 2:\n            while (run-- > 0) {\n                if (y < 1 || y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                clr = dst[y * linesize + x + off + 1];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 4:\n            while (run-- > 0) {\n                uint8_t *odst = (uint8_t *)dst;\n\n                if (y < 1 || y >= avctx->height ||\n                    (y == 1 && x == 0))\n                    return AVERROR_INVALIDDATA;\n\n                if (x == 0) {\n                    z = backstep;\n                } else {\n                    z = 0;\n                }\n\n                r = odst[(ly * linesize + lx) * 4] +\n                    odst[((y * linesize + x) + off - z) * 4 + 4] -\n                    odst[((y * linesize + x) + off - z) * 4];\n                g = odst[(ly * linesize + lx) * 4 + 1] +\n                    odst[((y * linesize + x) + off - z) * 4 + 5] -\n                    odst[((y * linesize + x) + off - z) * 4 + 1];\n                b = odst[(ly * linesize + lx) * 4 + 2] +\n                    odst[((y * linesize + x) + off - z) * 4 + 6] -\n                    odst[((y * linesize + x) + off - z) * 4 + 2];\n                clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 5:\n            while (run-- > 0) {\n                if (y < 1 || y >= avctx->height ||\n                    (y == 1 && x == 0))\n                    return AVERROR_INVALIDDATA;\n\n                if (x == 0) {\n                    z = backstep;\n                } else {\n                    z = 0;\n                }\n\n                clr = dst[y * linesize + x + off - z];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        }\n\n        if (avctx->bits_per_coded_sample == 16) {\n            cx1 = (clr & 0x3F00) >> 2;\n            cx = (clr & 0xFFFFFF) >> 16;\n        } else {\n            cx1 = (clr & 0xFC00) >> 4;\n            cx = (clr & 0xFFFFFF) >> 18;\n        }\n    }\n\n    return 0;\n}\n\nstatic int decompress_p(AVCodecContext *avctx,\n                        uint32_t *dst, int linesize,\n                        uint32_t *prev, int plinesize)\n{\n    SCPRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    int ret, temp, min, max, x, y, cx = 0, cx1 = 0;\n    int backstep = linesize - avctx->width;\n    const int cxshift = s->cxshift;\n\n    if (bytestream2_get_byte(gb) == 0)\n        return 0;\n    bytestream2_skip(gb, 1);\n    init_rangecoder(&s->rc, gb);\n\n    ret  = decode_value(s, s->range_model, 256, 1, &min);\n    ret |= decode_value(s, s->range_model, 256, 1, &temp);\n    min += temp << 8;\n    ret |= decode_value(s, s->range_model, 256, 1, &max);\n    ret |= decode_value(s, s->range_model, 256, 1, &temp);\n    if (ret < 0)\n        return ret;\n\n    max += temp << 8;\n    memset(s->blocks, 0, sizeof(*s->blocks) * s->nbcount);\n\n    while (min <= max) {\n        int fill, count;\n\n        ret  = decode_value(s, s->fill_model,  5,   10, &fill);\n        ret |= decode_value(s, s->count_model, 256, 20, &count);\n        if (ret < 0)\n            return ret;\n\n        while (min < s->nbcount && count-- > 0) {\n            s->blocks[min++] = fill;\n        }\n    }\n\n    for (y = 0; y < s->nby; y++) {\n        for (x = 0; x < s->nbx; x++) {\n            int sy1 = 0, sy2 = 16, sx1 = 0, sx2 = 16;\n\n            if (s->blocks[y * s->nbx + x] == 0)\n                continue;\n\n            if (((s->blocks[y * s->nbx + x] - 1) & 1) > 0) {\n                ret  = decode_value(s, s->sxy_model[0], 16, 100, &sx1);\n                ret |= decode_value(s, s->sxy_model[1], 16, 100, &sy1);\n                ret |= decode_value(s, s->sxy_model[2], 16, 100, &sx2);\n                ret |= decode_value(s, s->sxy_model[3], 16, 100, &sy2);\n                if (ret < 0)\n                    return ret;\n\n                sx2++;\n                sy2++;\n            }\n            if (((s->blocks[y * s->nbx + x] - 1) & 2) > 0) {\n                int i, j, by = y * 16, bx = x * 16;\n                int mvx, mvy;\n\n                ret  = decode_value(s, s->mv_model[0], 512, 100, &mvx);\n                ret |= decode_value(s, s->mv_model[1], 512, 100, &mvy);\n                if (ret < 0)\n                    return ret;\n\n                mvx -= 256;\n                mvy -= 256;\n\n                if (by + mvy + sy1 < 0 || bx + mvx + sx1 < 0 ||\n                    by + mvy + sy1 >= avctx->height || bx + mvx + sx1 >= avctx->width)\n                    return AVERROR_INVALIDDATA;\n\n                for (i = 0; i < sy2 - sy1 && (by + sy1 + i) < avctx->height && (by + mvy + sy1 + i) < avctx->height; i++) {\n                    for (j = 0; j < sx2 - sx1 && (bx + sx1 + j) < avctx->width && (bx + mvx + sx1 + j) < avctx->width; j++) {\n                        dst[(by + i + sy1) * linesize + bx + sx1 + j] = prev[(by + mvy + sy1 + i) * plinesize + bx + sx1 + mvx + j];\n                    }\n                }\n            } else {\n                int run, r, g, b, z, bx = x * 16 + sx1, by = y * 16 + sy1;\n                unsigned clr, ptype = 0;\n\n                for (; by < y * 16 + sy2 && by < avctx->height;) {\n                    ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);\n                    if (ptype == 0) {\n                        ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n                        if (ret < 0)\n                            return ret;\n\n                        cx1 = (cx << 6) & 0xFC0;\n                        cx = r >> cxshift;\n                        ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n                        if (ret < 0)\n                            return ret;\n\n                        cx1 = (cx << 6) & 0xFC0;\n                        cx = g >> cxshift;\n                        ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n                        if (ret < 0)\n                            return ret;\n\n                        clr = (b << 16) + (g << 8) + r;\n                    }\n                    if (ptype > 5)\n                        return AVERROR_INVALIDDATA;\n                    ret = decode_value(s, s->run_model[ptype], 256, 400, &run);\n                    if (ret < 0)\n                        return ret;\n\n                    switch (ptype) {\n                    case 0:\n                        while (run-- > 0) {\n                            if (by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 1:\n                        while (run-- > 0) {\n                            if (bx == 0) {\n                                if (by < 1)\n                                    return AVERROR_INVALIDDATA;\n                                z = backstep;\n                            } else {\n                                z = 0;\n                            }\n\n                            if (by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            clr = dst[by * linesize + bx - 1 - z];\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 2:\n                        while (run-- > 0) {\n                            if (by < 1 || by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            clr = dst[(by - 1) * linesize + bx];\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 3:\n                        while (run-- > 0) {\n                            if (by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            clr = prev[by * plinesize + bx];\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 4:\n                        while (run-- > 0) {\n                            uint8_t *odst = (uint8_t *)dst;\n\n                            if (by < 1 || by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            if (bx == 0) {\n                                z = backstep;\n                            } else {\n                                z = 0;\n                            }\n\n                            r = odst[((by - 1) * linesize + bx) * 4] +\n                                odst[(by * linesize + bx - 1 - z) * 4] -\n                                odst[((by - 1) * linesize + bx - 1 - z) * 4];\n                            g = odst[((by - 1) * linesize + bx) * 4 + 1] +\n                                odst[(by * linesize + bx - 1 - z) * 4 + 1] -\n                                odst[((by - 1) * linesize + bx - 1 - z) * 4 + 1];\n                            b = odst[((by - 1) * linesize + bx) * 4 + 2] +\n                                odst[(by * linesize + bx - 1 - z) * 4 + 2] -\n                                odst[((by - 1) * linesize + bx - 1 - z) * 4 + 2];\n                            clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    case 5:\n                        while (run-- > 0) {\n                            if (by < 1 || by >= avctx->height)\n                                return AVERROR_INVALIDDATA;\n\n                            if (bx == 0) {\n                                z = backstep;\n                            } else {\n                                z = 0;\n                            }\n\n                            clr = dst[(by - 1) * linesize + bx - 1 - z];\n                            dst[by * linesize + bx] = clr;\n                            bx++;\n                            if (bx >= x * 16 + sx2 || bx >= avctx->width) {\n                                bx = x * 16 + sx1;\n                                by++;\n                            }\n                        }\n                        break;\n                    }\n\n                    if (avctx->bits_per_coded_sample == 16) {\n                        cx1 = (clr & 0x3F00) >> 2;\n                        cx = (clr & 0xFFFFFF) >> 16;\n                    } else {\n                        cx1 = (clr & 0xFC00) >> 4;\n                        cx = (clr & 0xFFFFFF) >> 18;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    SCPRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    AVFrame *frame = data;\n    int ret, type;\n\n    if (avctx->bits_per_coded_sample == 16) {\n        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n            return ret;\n    }\n\n    if ((ret = ff_reget_buffer(avctx, s->current_frame)) < 0)\n        return ret;\n\n    bytestream2_init(gb, avpkt->data, avpkt->size);\n\n    type = bytestream2_peek_byte(gb);\n\n    if (type == 2) {\n        s->get_freq = get_freq0;\n        s->decode = decode0;\n        frame->key_frame = 1;\n        ret = decompress_i(avctx, (uint32_t *)s->current_frame->data[0],\n                           s->current_frame->linesize[0] / 4);\n    } else if (type == 18) {\n        s->get_freq = get_freq;\n        s->decode = decode;\n        frame->key_frame = 1;\n        ret = decompress_i(avctx, (uint32_t *)s->current_frame->data[0],\n                           s->current_frame->linesize[0] / 4);\n    } else if (type == 17) {\n        uint32_t clr, *dst = (uint32_t *)s->current_frame->data[0];\n        int x, y;\n\n        frame->key_frame = 1;\n        bytestream2_skip(gb, 1);\n        if (avctx->bits_per_coded_sample == 16) {\n            uint16_t value = bytestream2_get_le16(gb);\n            int r, g, b;\n\n            r = (value      ) & 31;\n            g = (value >>  5) & 31;\n            b = (value >> 10) & 31;\n            clr = (r << 16) + (g << 8) + b;\n        } else {\n            clr = bytestream2_get_le24(gb);\n        }\n        for (y = 0; y < avctx->height; y++) {\n            for (x = 0; x < avctx->width; x++) {\n                dst[x] = clr;\n            }\n            dst += s->current_frame->linesize[0] / 4;\n        }\n    } else if (type == 0 || type == 1) {\n        frame->key_frame = 0;\n\n        ret = av_frame_copy(s->current_frame, s->last_frame);\n        if (ret < 0)\n            return ret;\n\n        ret = decompress_p(avctx, (uint32_t *)s->current_frame->data[0],\n                           s->current_frame->linesize[0] / 4,\n                           (uint32_t *)s->last_frame->data[0],\n                           s->last_frame->linesize[0] / 4);\n    } else {\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (ret < 0)\n        return ret;\n\n    if (avctx->bits_per_coded_sample != 16) {\n        ret = av_frame_ref(data, s->current_frame);\n        if (ret < 0)\n            return ret;\n    } else {\n        uint8_t *dst = frame->data[0];\n        int x, y;\n\n        ret = av_frame_copy(frame, s->current_frame);\n        if (ret < 0)\n            return ret;\n\n        for (y = 0; y < avctx->height; y++) {\n            for (x = 0; x < avctx->width * 4; x++) {\n                dst[x] = dst[x] << 3;\n            }\n            dst += frame->linesize[0];\n        }\n    }\n\n    frame->pict_type = frame->key_frame ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n    FFSWAP(AVFrame *, s->current_frame, s->last_frame);\n\n    frame->data[0]     += frame->linesize[0] * (avctx->height - 1);\n    frame->linesize[0] *= -1;\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    SCPRContext *s = avctx->priv_data;\n\n    switch (avctx->bits_per_coded_sample) {\n    case 16: avctx->pix_fmt = AV_PIX_FMT_RGB0; break;\n    case 24:\n    case 32: avctx->pix_fmt = AV_PIX_FMT_BGR0; break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported bitdepth %i\\n\", avctx->bits_per_coded_sample);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->get_freq = get_freq0;\n    s->decode = decode0;\n\n    s->cxshift = avctx->bits_per_coded_sample == 16 ? 0 : 2;\n    s->cbits = avctx->bits_per_coded_sample == 16 ? 0x1F : 0xFF;\n    s->nbx = (avctx->width + 15) / 16;\n    s->nby = (avctx->height + 15) / 16;\n    s->nbcount = s->nbx * s->nby;\n    s->blocks = av_malloc_array(s->nbcount, sizeof(*s->blocks));\n    if (!s->blocks)\n        return AVERROR(ENOMEM);\n\n    s->last_frame = av_frame_alloc();\n    s->current_frame = av_frame_alloc();\n    if (!s->last_frame || !s->current_frame)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic av_cold int decode_close(AVCodecContext *avctx)\n{\n    SCPRContext *s = avctx->priv_data;\n\n    av_freep(&s->blocks);\n    av_frame_free(&s->last_frame);\n    av_frame_free(&s->current_frame);\n\n    return 0;\n}\n\nAVCodec ff_scpr_decoder = {\n    .name             = \"scpr\",\n    .long_name        = NULL_IF_CONFIG_SMALL(\"ScreenPressor\"),\n    .type             = AVMEDIA_TYPE_VIDEO,\n    .id               = AV_CODEC_ID_SCPR,\n    .priv_data_size   = sizeof(SCPRContext),\n    .init             = decode_init,\n    .close            = decode_close,\n    .decode           = decode_frame,\n    .capabilities     = AV_CODEC_CAP_DR1,\n    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |\n                        FF_CODEC_CAP_INIT_CLEANUP,\n};\n"], "filenames": ["libavcodec/scpr.c"], "buggy_code_start_loc": [262], "buggy_code_end_loc": [262], "fixing_code_start_loc": [263], "fixing_code_end_loc": [266], "type": "CWE-119", "message": "libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.", "other": {"cve": {"id": "CVE-2017-9995", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-28T06:29:00.583", "lastModified": "2017-07-03T18:59:26.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."}, {"lang": "es", "value": "El archivo libavcodec/scpr.c en Ffmpeg 3.3 anterior a la 3.3.1 no valida adecuadamente la altura y anchura de los datos, lo que permite a un atacante remoto provocar una denegaci\u00f3n de servicio (buffer overflow basado en la pila din\u00e1mica -heap- y ca\u00edda de la aplicaci\u00f3n) u otro posible impacto no especificado mediante la manipulaci\u00f3n del archivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "ABC38E2D-3FA2-446B-B5BA-24E98BAA0EEE"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/99320", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1478", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1519", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/2171dfae8c065878a2e130390eb78cf2947a5b69", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/7ac5067146613997bb38442cb022d7f41321a706", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2171dfae8c065878a2e130390eb78cf2947a5b69"}}