{"buggy_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include <errno.h>\n\n#include \"asylo/platform/host_call/exit_handler_constants.h\"\n#include \"asylo/platform/host_call/trusted/host_call_dispatcher.h\"\n#include \"asylo/platform/host_call/trusted/host_calls.h\"\n#include \"asylo/platform/primitives/trusted_primitives.h\"\n#include \"asylo/platform/system_call/type_conversions/types_functions.h\"\n\nusing ::asylo::host_call::NonSystemCallDispatcher;\nusing ::asylo::primitives::MessageReader;\nusing ::asylo::primitives::MessageWriter;\nusing ::asylo::primitives::TrustedPrimitives;\n\nstatic constexpr int32_t kWaitQueueEnabled = 0;\nstatic constexpr int32_t kWaitQueueDisabled = 1;\n\nextern \"C\" {\n\nint enc_untrusted_sys_futex_wait(int32_t *futex, int32_t expected,\n                                 int64_t timeout_microsec) {\n  if (!TrustedPrimitives::IsOutsideEnclave(futex, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_sys_futex_wait: futex word should be in untrusted \"\n        \"local memory.\");\n  }\n\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(reinterpret_cast<uint64_t>(futex));\n  input.Push<int32_t>(expected);\n  input.Push<int64_t>(timeout_microsec);\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kSysFutexWaitHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sys_futex_wait\", 2);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // If FUTEX_WAIT successfully causes the thread to be suspended in the kernel,\n  // it returns a zero when the caller is woken up. Otherwise, it returns the\n  // appropriate errno.\n  if (result != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nint enc_untrusted_sys_futex_wake(int32_t *futex, int32_t num) {\n  if (!TrustedPrimitives::IsOutsideEnclave(futex, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_sys_futex_wake: futex word should be in untrusted \"\n        \"local memory.\");\n  }\n\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(reinterpret_cast<uint64_t>(futex));\n  input.Push<int32_t>(num);\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kSysFutexWakeHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sys_futex_wake\", 2);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nint32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}\n\nvoid enc_untrusted_destroy_wait_queue(int32_t *const queue) {\n  // This is a no op on purpose. Wait queue pointers are now\n  // registered to be freed on enclave exit.\n}\n\nvoid enc_untrusted_thread_wait(int32_t *const queue,\n                               uint64_t timeout_microsec) {\n  enc_untrusted_thread_wait_value(queue, kWaitQueueEnabled, timeout_microsec);\n}\n\nvoid enc_untrusted_notify(int32_t *const queue, int32_t num_threads) {\n  enc_untrusted_sys_futex_wake(queue, num_threads);\n}\n\nvoid enc_untrusted_disable_waiting(int32_t *const queue) {\n  enc_untrusted_wait_queue_set_value(queue, kWaitQueueDisabled);\n}\n\nvoid enc_untrusted_enable_waiting(int32_t *const queue) {\n  enc_untrusted_wait_queue_set_value(queue, kWaitQueueEnabled);\n}\n\nvoid enc_untrusted_wait_queue_set_value(int32_t *const queue, int32_t value) {\n  TrustedPrimitives::UntrustedLocalMemcpy(queue, &value, sizeof(int32_t));\n}\n\nvoid enc_untrusted_thread_wait_value(int32_t *const queue, int32_t value,\n                                     uint64_t timeout_microsec) {\n  enc_untrusted_sys_futex_wait(queue, value, timeout_microsec);\n}\n\n}  // extern \"C\"\n"], "fixing_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include <errno.h>\n\n#include \"asylo/platform/host_call/exit_handler_constants.h\"\n#include \"asylo/platform/host_call/trusted/host_call_dispatcher.h\"\n#include \"asylo/platform/host_call/trusted/host_calls.h\"\n#include \"asylo/platform/primitives/trusted_primitives.h\"\n#include \"asylo/platform/system_call/type_conversions/types_functions.h\"\n\nusing ::asylo::host_call::NonSystemCallDispatcher;\nusing ::asylo::primitives::MessageReader;\nusing ::asylo::primitives::MessageWriter;\nusing ::asylo::primitives::TrustedPrimitives;\n\nstatic constexpr int32_t kWaitQueueEnabled = 0;\nstatic constexpr int32_t kWaitQueueDisabled = 1;\n\nextern \"C\" {\n\nint enc_untrusted_sys_futex_wait(int32_t *futex, int32_t expected,\n                                 int64_t timeout_microsec) {\n  if (!TrustedPrimitives::IsOutsideEnclave(futex, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_sys_futex_wait: futex word should be in untrusted \"\n        \"local memory.\");\n  }\n\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(reinterpret_cast<uint64_t>(futex));\n  input.Push<int32_t>(expected);\n  input.Push<int64_t>(timeout_microsec);\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kSysFutexWaitHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sys_futex_wait\", 2);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // If FUTEX_WAIT successfully causes the thread to be suspended in the kernel,\n  // it returns a zero when the caller is woken up. Otherwise, it returns the\n  // appropriate errno.\n  if (result != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nint enc_untrusted_sys_futex_wake(int32_t *futex, int32_t num) {\n  if (!TrustedPrimitives::IsOutsideEnclave(futex, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_sys_futex_wake: futex word should be in untrusted \"\n        \"local memory.\");\n  }\n\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(reinterpret_cast<uint64_t>(futex));\n  input.Push<int32_t>(num);\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kSysFutexWakeHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sys_futex_wake\", 2);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nint32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}\n\nvoid enc_untrusted_destroy_wait_queue(int32_t *const queue) {\n  // This is a no op on purpose. Wait queue pointers are now\n  // registered to be freed on enclave exit.\n}\n\nvoid enc_untrusted_thread_wait(int32_t *const queue,\n                               uint64_t timeout_microsec) {\n  enc_untrusted_thread_wait_value(queue, kWaitQueueEnabled, timeout_microsec);\n}\n\nvoid enc_untrusted_notify(int32_t *const queue, int32_t num_threads) {\n  enc_untrusted_sys_futex_wake(queue, num_threads);\n}\n\nvoid enc_untrusted_disable_waiting(int32_t *const queue) {\n  enc_untrusted_wait_queue_set_value(queue, kWaitQueueDisabled);\n}\n\nvoid enc_untrusted_enable_waiting(int32_t *const queue) {\n  enc_untrusted_wait_queue_set_value(queue, kWaitQueueEnabled);\n}\n\nvoid enc_untrusted_wait_queue_set_value(int32_t *const queue, int32_t value) {\n  TrustedPrimitives::UntrustedLocalMemcpy(queue, &value, sizeof(int32_t));\n}\n\nvoid enc_untrusted_thread_wait_value(int32_t *const queue, int32_t value,\n                                     uint64_t timeout_microsec) {\n  enc_untrusted_sys_futex_wait(queue, value, timeout_microsec);\n}\n\n}  // extern \"C\"\n"], "filenames": ["asylo/platform/host_call/trusted/concurrency.cc"], "buggy_code_start_loc": [95], "buggy_code_end_loc": [95], "fixing_code_start_loc": [96], "fixing_code_end_loc": [100], "type": "CWE-787", "message": "An arbitrary memory overwrite vulnerability in Asylo versions up to 0.6.0 allows an attacker to make a host call to enc_untrusted_create_wait_queue that uses a pointer queue that relies on UntrustedLocalMemcpy, which fails to validate where the pointer is located. This allows an attacker to write memory values from within the enclave. We recommend upgrading past commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02", "other": {"cve": {"id": "CVE-2020-8937", "sourceIdentifier": "cve-coordination@google.com", "published": "2020-12-15T15:15:13.223", "lastModified": "2020-12-17T14:45:46.497", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An arbitrary memory overwrite vulnerability in Asylo versions up to 0.6.0 allows an attacker to make a host call to enc_untrusted_create_wait_queue that uses a pointer queue that relies on UntrustedLocalMemcpy, which fails to validate where the pointer is located. This allows an attacker to write memory values from within the enclave. We recommend upgrading past commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02"}, {"lang": "es", "value": "Una vulnerabilidad de sobrescritura de la memoria arbitraria en Asylo versiones hasta 0.6.0, permite a un atacante realizar una llamada de host a la funci\u00f3n enc_untrusted_create_wait_queue que usa una cola de puntero que se basa en la funci\u00f3n UntrustedLocalMemcpy, que comet\u00eda un fallo al comprobar d\u00f3nde se encuentra el puntero.&#xa0;Esto permite a un atacante escribir valores de memoria desde dentro del enclave.&#xa0;Recomendamos actualizar m\u00e1s all\u00e1 del commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:asylo:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.6.0", "matchCriteriaId": "D4356338-A28E-442E-BD14-1A927E3824E9"}]}]}], "references": [{"url": "https://github.com/google/asylo/commit/a37fb6a0e7daf30134dbbf357c9a518a1026aa02", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/asylo/commit/a37fb6a0e7daf30134dbbf357c9a518a1026aa02"}}