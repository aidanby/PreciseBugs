{"buggy_code": ["/*\n * llc_conn.c - Driver routines for connection component.\n *\n * Copyright (c) 1997 by Procom Technology, Inc.\n *\t\t 2001-2003 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n * This program can be redistributed or modified under the terms of the\n * GNU General Public License as published by the Free Software Foundation.\n * This program is distributed without any warranty or implied warranty\n * of merchantability or fitness for a particular purpose.\n *\n * See the GNU General Public License for more details.\n */\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/llc_sap.h>\n#include <net/llc_conn.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <net/llc_c_ev.h>\n#include <net/llc_c_ac.h>\n#include <net/llc_c_st.h>\n#include <net/llc_pdu.h>\n\n#if 0\n#define dprintk(args...) printk(KERN_DEBUG args)\n#else\n#define dprintk(args...)\n#endif\n\nstatic int llc_find_offset(int state, int ev_type);\nstatic void llc_conn_send_pdus(struct sock *sk);\nstatic int llc_conn_service(struct sock *sk, struct sk_buff *skb);\nstatic int llc_exec_conn_trans_actions(struct sock *sk,\n\t\t\t\t       struct llc_conn_state_trans *trans,\n\t\t\t\t       struct sk_buff *ev);\nstatic struct llc_conn_state_trans *llc_qualify_conn_ev(struct sock *sk,\n\t\t\t\t\t\t\tstruct sk_buff *skb);\n\n/* Offset table on connection states transition diagram */\nstatic int llc_offset_table[NBR_CONN_STATES][NBR_CONN_EV];\n\nint sysctl_llc2_ack_timeout = LLC2_ACK_TIME * HZ;\nint sysctl_llc2_p_timeout = LLC2_P_TIME * HZ;\nint sysctl_llc2_rej_timeout = LLC2_REJ_TIME * HZ;\nint sysctl_llc2_busy_timeout = LLC2_BUSY_TIME * HZ;\n\n/**\n *\tllc_conn_state_process - sends event to connection state machine\n *\t@sk: connection\n *\t@skb: occurred event\n *\n *\tSends an event to connection state machine. After processing event\n *\t(executing it's actions and changing state), upper layer will be\n *\tindicated or confirmed, if needed. Returns 0 for success, 1 for\n *\tfailure. The socket lock has to be held before calling this function.\n */\nint llc_conn_state_process(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\t/*\n\t * We have to hold the skb, because llc_conn_service will kfree it in\n\t * the sending path and we need to look at the skb->cb, where we encode\n\t * llc_conn_state_ev.\n\t */\n\tskb_get(skb);\n\tev->ind_prim = ev->cfm_prim = 0;\n\t/*\n\t * Send event to state machine\n\t */\n\trc = llc_conn_service(skb->sk, skb);\n\tif (unlikely(rc != 0)) {\n\t\tprintk(KERN_ERR \"%s: llc_conn_service failed\\n\", __func__);\n\t\tgoto out_kfree_skb;\n\t}\n\n\tif (unlikely(!ev->ind_prim && !ev->cfm_prim)) {\n\t\t/* indicate or confirm not required */\n\t\tif (!skb->next)\n\t\t\tgoto out_kfree_skb;\n\t\tgoto out_skb_put;\n\t}\n\n\tif (unlikely(ev->ind_prim && ev->cfm_prim)) /* Paranoia */\n\t\tskb_get(skb);\n\n\tswitch (ev->ind_prim) {\n\tcase LLC_DATA_PRIM:\n\t\tllc_save_primitive(sk, skb, LLC_DATA_PRIM);\n\t\tif (unlikely(sock_queue_rcv_skb(sk, skb))) {\n\t\t\t/*\n\t\t\t * shouldn't happen\n\t\t\t */\n\t\t\tprintk(KERN_ERR \"%s: sock_queue_rcv_skb failed!\\n\",\n\t\t\t       __func__);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\tbreak;\n\tcase LLC_CONN_PRIM:\n\t\t/*\n\t\t * Can't be sock_queue_rcv_skb, because we have to leave the\n\t\t * skb->sk pointing to the newly created struct sock in\n\t\t * llc_conn_handler. -acme\n\t\t */\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\tcase LLC_DISC_PRIM:\n\t\tsock_hold(sk);\n\t\tif (sk->sk_type == SOCK_STREAM &&\n\t\t    sk->sk_state == TCP_ESTABLISHED) {\n\t\t\tsk->sk_shutdown       = SHUTDOWN_MASK;\n\t\t\tsk->sk_socket->state  = SS_UNCONNECTED;\n\t\t\tsk->sk_state          = TCP_CLOSE;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t}\n\t\t}\n\t\tkfree_skb(skb);\n\t\tsock_put(sk);\n\t\tbreak;\n\tcase LLC_RESET_PRIM:\n\t\t/*\n\t\t * FIXME:\n\t\t * RESET is not being notified to upper layers for now\n\t\t */\n\t\tprintk(KERN_INFO \"%s: received a reset ind!\\n\", __func__);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\tdefault:\n\t\tif (ev->ind_prim) {\n\t\t\tprintk(KERN_INFO \"%s: received unknown %d prim!\\n\",\n\t\t\t\t__func__, ev->ind_prim);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\t/* No indication */\n\t\tbreak;\n\t}\n\n\tswitch (ev->cfm_prim) {\n\tcase LLC_DATA_PRIM:\n\t\tif (!llc_data_accept_state(llc->state))\n\t\t\tsk->sk_write_space(sk);\n\t\telse\n\t\t\trc = llc->failed_data_req = 1;\n\t\tbreak;\n\tcase LLC_CONN_PRIM:\n\t\tif (sk->sk_type == SOCK_STREAM &&\n\t\t    sk->sk_state == TCP_SYN_SENT) {\n\t\t\tif (ev->status) {\n\t\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\t\tsk->sk_state         = TCP_CLOSE;\n\t\t\t} else {\n\t\t\t\tsk->sk_socket->state = SS_CONNECTED;\n\t\t\t\tsk->sk_state         = TCP_ESTABLISHED;\n\t\t\t}\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t\tbreak;\n\tcase LLC_DISC_PRIM:\n\t\tsock_hold(sk);\n\t\tif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSING) {\n\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\tsk->sk_state         = TCP_CLOSE;\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t\tsock_put(sk);\n\t\tbreak;\n\tcase LLC_RESET_PRIM:\n\t\t/*\n\t\t * FIXME:\n\t\t * RESET is not being notified to upper layers for now\n\t\t */\n\t\tprintk(KERN_INFO \"%s: received a reset conf!\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\tif (ev->cfm_prim) {\n\t\t\tprintk(KERN_INFO \"%s: received unknown %d prim!\\n\",\n\t\t\t\t\t__func__, ev->cfm_prim);\n\t\t\tbreak;\n\t\t}\n\t\tgoto out_skb_put; /* No confirmation */\n\t}\nout_kfree_skb:\n\tkfree_skb(skb);\nout_skb_put:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\nvoid llc_conn_send_pdu(struct sock *sk, struct sk_buff *skb)\n{\n\t/* queue PDU to send to MAC layer */\n\tskb_queue_tail(&sk->sk_write_queue, skb);\n\tllc_conn_send_pdus(sk);\n}\n\n/**\n *\tllc_conn_rtn_pdu - sends received data pdu to upper layer\n *\t@sk: Active connection\n *\t@skb: Received data frame\n *\n *\tSends received data pdu to upper layer (by using indicate function).\n *\tPrepares service parameters (prim and prim_data). calling indication\n *\tfunction will be done in llc_conn_state_process.\n */\nvoid llc_conn_rtn_pdu(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\tev->ind_prim = LLC_DATA_PRIM;\n}\n\n/**\n *\tllc_conn_resend_i_pdu_as_cmd - resend all all unacknowledged I PDUs\n *\t@sk: active connection\n *\t@nr: NR\n *\t@first_p_bit: p_bit value of first pdu\n *\n *\tResend all unacknowledged I PDUs, starting with the NR; send first as\n *\tcommand PDU with P bit equal first_p_bit; if more than one send\n *\tsubsequent as command PDUs with P bit equal zero (0).\n */\nvoid llc_conn_resend_i_pdu_as_cmd(struct sock *sk, u8 nr, u8 first_p_bit)\n{\n\tstruct sk_buff *skb;\n\tstruct llc_pdu_sn *pdu;\n\tu16 nbr_unack_pdus;\n\tstruct llc_sock *llc;\n\tu8 howmany_resend = 0;\n\n\tllc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);\n\tif (!nbr_unack_pdus)\n\t\tgoto out;\n\t/*\n\t * Process unack PDUs only if unack queue is not empty; remove\n\t * appropriate PDUs, fix them up, and put them on mac_pdu_q.\n\t */\n\tllc = llc_sk(sk);\n\n\twhile ((skb = skb_dequeue(&llc->pdu_unack_q)) != NULL) {\n\t\tpdu = llc_pdu_sn_hdr(skb);\n\t\tllc_pdu_set_cmd_rsp(skb, LLC_PDU_CMD);\n\t\tllc_pdu_set_pf_bit(skb, first_p_bit);\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\n\t\tfirst_p_bit = 0;\n\t\tllc->vS = LLC_I_GET_NS(pdu);\n\t\thowmany_resend++;\n\t}\n\tif (howmany_resend > 0)\n\t\tllc->vS = (llc->vS + 1) % LLC_2_SEQ_NBR_MODULO;\n\t/* any PDUs to re-send are queued up; start sending to MAC */\n\tllc_conn_send_pdus(sk);\nout:;\n}\n\n/**\n *\tllc_conn_resend_i_pdu_as_rsp - Resend all unacknowledged I PDUs\n *\t@sk: active connection.\n *\t@nr: NR\n *\t@first_f_bit: f_bit value of first pdu.\n *\n *\tResend all unacknowledged I PDUs, starting with the NR; send first as\n *\tresponse PDU with F bit equal first_f_bit; if more than one send\n *\tsubsequent as response PDUs with F bit equal zero (0).\n */\nvoid llc_conn_resend_i_pdu_as_rsp(struct sock *sk, u8 nr, u8 first_f_bit)\n{\n\tstruct sk_buff *skb;\n\tu16 nbr_unack_pdus;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tu8 howmany_resend = 0;\n\n\tllc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);\n\tif (!nbr_unack_pdus)\n\t\tgoto out;\n\t/*\n\t * Process unack PDUs only if unack queue is not empty; remove\n\t * appropriate PDUs, fix them up, and put them on mac_pdu_q\n\t */\n\twhile ((skb = skb_dequeue(&llc->pdu_unack_q)) != NULL) {\n\t\tstruct llc_pdu_sn *pdu = llc_pdu_sn_hdr(skb);\n\n\t\tllc_pdu_set_cmd_rsp(skb, LLC_PDU_RSP);\n\t\tllc_pdu_set_pf_bit(skb, first_f_bit);\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\n\t\tfirst_f_bit = 0;\n\t\tllc->vS = LLC_I_GET_NS(pdu);\n\t\thowmany_resend++;\n\t}\n\tif (howmany_resend > 0)\n\t\tllc->vS = (llc->vS + 1) % LLC_2_SEQ_NBR_MODULO;\n\t/* any PDUs to re-send are queued up; start sending to MAC */\n\tllc_conn_send_pdus(sk);\nout:;\n}\n\n/**\n *\tllc_conn_remove_acked_pdus - Removes acknowledged pdus from tx queue\n *\t@sk: active connection\n *\tnr: NR\n *\thow_many_unacked: size of pdu_unack_q after removing acked pdus\n *\n *\tRemoves acknowledged pdus from transmit queue (pdu_unack_q). Returns\n *\tthe number of pdus that removed from queue.\n */\nint llc_conn_remove_acked_pdus(struct sock *sk, u8 nr, u16 *how_many_unacked)\n{\n\tint pdu_pos, i;\n\tstruct sk_buff *skb;\n\tstruct llc_pdu_sn *pdu;\n\tint nbr_acked = 0;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint q_len = skb_queue_len(&llc->pdu_unack_q);\n\n\tif (!q_len)\n\t\tgoto out;\n\tskb = skb_peek(&llc->pdu_unack_q);\n\tpdu = llc_pdu_sn_hdr(skb);\n\n\t/* finding position of last acked pdu in queue */\n\tpdu_pos = ((int)LLC_2_SEQ_NBR_MODULO + (int)nr -\n\t\t\t(int)LLC_I_GET_NS(pdu)) % LLC_2_SEQ_NBR_MODULO;\n\n\tfor (i = 0; i < pdu_pos && i < q_len; i++) {\n\t\tskb = skb_dequeue(&llc->pdu_unack_q);\n\t\tkfree_skb(skb);\n\t\tnbr_acked++;\n\t}\nout:\n\t*how_many_unacked = skb_queue_len(&llc->pdu_unack_q);\n\treturn nbr_acked;\n}\n\n/**\n *\tllc_conn_send_pdus - Sends queued PDUs\n *\t@sk: active connection\n *\n *\tSends queued pdus to MAC layer for transmission.\n */\nstatic void llc_conn_send_pdus(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&sk->sk_write_queue)) != NULL) {\n\t\tstruct llc_pdu_sn *pdu = llc_pdu_sn_hdr(skb);\n\n\t\tif (LLC_PDU_TYPE_IS_I(pdu) &&\n\t\t    !(skb->dev->flags & IFF_LOOPBACK)) {\n\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\tskb_queue_tail(&llc_sk(sk)->pdu_unack_q, skb);\n\t\t\tif (!skb2)\n\t\t\t\tbreak;\n\t\t\tskb = skb2;\n\t\t}\n\t\tdev_queue_xmit(skb);\n\t}\n}\n\n/**\n *\tllc_conn_service - finds transition and changes state of connection\n *\t@sk: connection\n *\t@skb: happened event\n *\n *\tThis function finds transition that matches with happened event, then\n *\texecutes related actions and finally changes state of connection.\n *\tReturns 0 for success, 1 for failure.\n */\nstatic int llc_conn_service(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc = 1;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_conn_state_trans *trans;\n\n\tif (llc->state > NBR_CONN_STATES)\n\t\tgoto out;\n\trc = 0;\n\ttrans = llc_qualify_conn_ev(sk, skb);\n\tif (trans) {\n\t\trc = llc_exec_conn_trans_actions(sk, trans, skb);\n\t\tif (!rc && trans->next_state != NO_STATE_CHANGE) {\n\t\t\tllc->state = trans->next_state;\n\t\t\tif (!llc_data_accept_state(llc->state))\n\t\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\n/**\n *\tllc_qualify_conn_ev - finds transition for event\n *\t@sk: connection\n *\t@skb: happened event\n *\n *\tThis function finds transition that matches with happened event.\n *\tReturns pointer to found transition on success, %NULL otherwise.\n */\nstatic struct llc_conn_state_trans *llc_qualify_conn_ev(struct sock *sk,\n\t\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct llc_conn_state_trans **next_trans;\n\tconst llc_conn_ev_qfyr_t *next_qualifier;\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_conn_state *curr_state =\n\t\t\t\t\t&llc_conn_state_table[llc->state - 1];\n\n\t/* search thru events for this state until\n\t * list exhausted or until no more\n\t */\n\tfor (next_trans = curr_state->transitions +\n\t\tllc_find_offset(llc->state - 1, ev->type);\n\t     (*next_trans)->ev; next_trans++) {\n\t\tif (!((*next_trans)->ev)(sk, skb)) {\n\t\t\t/* got POSSIBLE event match; the event may require\n\t\t\t * qualification based on the values of a number of\n\t\t\t * state flags; if all qualifications are met (i.e.,\n\t\t\t * if all qualifying functions return success, or 0,\n\t\t\t * then this is THE event we're looking for\n\t\t\t */\n\t\t\tfor (next_qualifier = (*next_trans)->ev_qualifiers;\n\t\t\t     next_qualifier && *next_qualifier &&\n\t\t\t     !(*next_qualifier)(sk, skb); next_qualifier++)\n\t\t\t\t/* nothing */;\n\t\t\tif (!next_qualifier || !*next_qualifier)\n\t\t\t\t/* all qualifiers executed successfully; this is\n\t\t\t\t * our transition; return it so we can perform\n\t\t\t\t * the associated actions & change the state\n\t\t\t\t */\n\t\t\t\treturn *next_trans;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n *\tllc_exec_conn_trans_actions - executes related actions\n *\t@sk: connection\n *\t@trans: transition that it's actions must be performed\n *\t@skb: event\n *\n *\tExecutes actions that is related to happened event. Returns 0 for\n *\tsuccess, 1 to indicate failure of at least one action.\n */\nstatic int llc_exec_conn_trans_actions(struct sock *sk,\n\t\t\t\t       struct llc_conn_state_trans *trans,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tint rc = 0;\n\tconst llc_conn_action_t *next_action;\n\n\tfor (next_action = trans->ev_actions;\n\t     next_action && *next_action; next_action++) {\n\t\tint rc2 = (*next_action)(sk, skb);\n\n\t\tif (rc2 == 2) {\n\t\t\trc = rc2;\n\t\t\tbreak;\n\t\t} else if (rc2)\n\t\t\trc = 1;\n\t}\n\treturn rc;\n}\n\nstatic inline bool llc_estab_match(const struct llc_sap *sap,\n\t\t\t\t   const struct llc_addr *daddr,\n\t\t\t\t   const struct llc_addr *laddr,\n\t\t\t\t   const struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\treturn llc->laddr.lsap == laddr->lsap &&\n\t\tllc->daddr.lsap == daddr->lsap &&\n\t\tether_addr_equal(llc->laddr.mac, laddr->mac) &&\n\t\tether_addr_equal(llc->daddr.mac, daddr->mac);\n}\n\n/**\n *\t__llc_lookup_established - Finds connection for the remote/local sap/mac\n *\t@sap: SAP\n *\t@daddr: address of remote LLC (MAC + SAP)\n *\t@laddr: address of local LLC (MAC + SAP)\n *\n *\tSearch connection list of the SAP and finds connection using the remote\n *\tmac, remote sap, local mac, and local sap. Returns pointer for\n *\tconnection found, %NULL otherwise.\n *\tCaller has to make sure local_bh is disabled.\n */\nstatic struct sock *__llc_lookup_established(struct llc_sap *sap,\n\t\t\t\t\t     struct llc_addr *daddr,\n\t\t\t\t\t     struct llc_addr *laddr)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_estab_match(sap, daddr, laddr, rc)) {\n\t\t\t/* Extra checks required by SLAB_DESTROY_BY_RCU */\n\t\t\tif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_estab_match(sap, daddr, laddr, rc))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock();\n\treturn rc;\n}\n\nstruct sock *llc_lookup_established(struct llc_sap *sap,\n\t\t\t\t    struct llc_addr *daddr,\n\t\t\t\t    struct llc_addr *laddr)\n{\n\tstruct sock *sk;\n\n\tlocal_bh_disable();\n\tsk = __llc_lookup_established(sap, daddr, laddr);\n\tlocal_bh_enable();\n\treturn sk;\n}\n\nstatic inline bool llc_listener_match(const struct llc_sap *sap,\n\t\t\t\t      const struct llc_addr *laddr,\n\t\t\t\t      const struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\treturn sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN &&\n\t\tllc->laddr.lsap == laddr->lsap &&\n\t\tether_addr_equal(llc->laddr.mac, laddr->mac);\n}\n\nstatic struct sock *__llc_lookup_listener(struct llc_sap *sap,\n\t\t\t\t\t  struct llc_addr *laddr)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_listener_match(sap, laddr, rc)) {\n\t\t\t/* Extra checks required by SLAB_DESTROY_BY_RCU */\n\t\t\tif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_listener_match(sap, laddr, rc))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock();\n\treturn rc;\n}\n\n/**\n *\tllc_lookup_listener - Finds listener for local MAC + SAP\n *\t@sap: SAP\n *\t@laddr: address of local LLC (MAC + SAP)\n *\n *\tSearch connection list of the SAP and finds connection listening on\n *\tlocal mac, and local sap. Returns pointer for parent socket found,\n *\t%NULL otherwise.\n *\tCaller has to make sure local_bh is disabled.\n */\nstatic struct sock *llc_lookup_listener(struct llc_sap *sap,\n\t\t\t\t\tstruct llc_addr *laddr)\n{\n\tstatic struct llc_addr null_addr;\n\tstruct sock *rc = __llc_lookup_listener(sap, laddr);\n\n\tif (!rc)\n\t\trc = __llc_lookup_listener(sap, &null_addr);\n\n\treturn rc;\n}\n\nstatic struct sock *__llc_lookup(struct llc_sap *sap,\n\t\t\t\t struct llc_addr *daddr,\n\t\t\t\t struct llc_addr *laddr)\n{\n\tstruct sock *sk = __llc_lookup_established(sap, daddr, laddr);\n\n\treturn sk ? : llc_lookup_listener(sap, laddr);\n}\n\n/**\n *\tllc_data_accept_state - designates if in this state data can be sent.\n *\t@state: state of connection.\n *\n *\tReturns 0 if data can be sent, 1 otherwise.\n */\nu8 llc_data_accept_state(u8 state)\n{\n\treturn state != LLC_CONN_STATE_NORMAL && state != LLC_CONN_STATE_BUSY &&\n\t       state != LLC_CONN_STATE_REJ;\n}\n\n/**\n *\tllc_find_next_offset - finds offset for next category of transitions\n *\t@state: state table.\n *\t@offset: start offset.\n *\n *\tFinds offset of next category of transitions in transition table.\n *\tReturns the start index of next category.\n */\nstatic u16 __init llc_find_next_offset(struct llc_conn_state *state, u16 offset)\n{\n\tu16 cnt = 0;\n\tstruct llc_conn_state_trans **next_trans;\n\n\tfor (next_trans = state->transitions + offset;\n\t     (*next_trans)->ev; next_trans++)\n\t\t++cnt;\n\treturn cnt;\n}\n\n/**\n *\tllc_build_offset_table - builds offset table of connection\n *\n *\tFills offset table of connection state transition table\n *\t(llc_offset_table).\n */\nvoid __init llc_build_offset_table(void)\n{\n\tstruct llc_conn_state *curr_state;\n\tint state, ev_type, next_offset;\n\n\tfor (state = 0; state < NBR_CONN_STATES; state++) {\n\t\tcurr_state = &llc_conn_state_table[state];\n\t\tnext_offset = 0;\n\t\tfor (ev_type = 0; ev_type < NBR_CONN_EV; ev_type++) {\n\t\t\tllc_offset_table[state][ev_type] = next_offset;\n\t\t\tnext_offset += llc_find_next_offset(curr_state,\n\t\t\t\t\t\t\t    next_offset) + 1;\n\t\t}\n\t}\n}\n\n/**\n *\tllc_find_offset - finds start offset of category of transitions\n *\t@state: state of connection\n *\t@ev_type: type of happened event\n *\n *\tFinds start offset of desired category of transitions. Returns the\n *\tdesired start offset.\n */\nstatic int llc_find_offset(int state, int ev_type)\n{\n\tint rc = 0;\n\t/* at this stage, llc_offset_table[..][2] is not important. it is for\n\t * init_pf_cycle and I don't know what is it.\n\t */\n\tswitch (ev_type) {\n\tcase LLC_CONN_EV_TYPE_PRIM:\n\t\trc = llc_offset_table[state][0]; break;\n\tcase LLC_CONN_EV_TYPE_PDU:\n\t\trc = llc_offset_table[state][4]; break;\n\tcase LLC_CONN_EV_TYPE_SIMPLE:\n\t\trc = llc_offset_table[state][1]; break;\n\tcase LLC_CONN_EV_TYPE_P_TMR:\n\tcase LLC_CONN_EV_TYPE_ACK_TMR:\n\tcase LLC_CONN_EV_TYPE_REJ_TMR:\n\tcase LLC_CONN_EV_TYPE_BUSY_TMR:\n\t\trc = llc_offset_table[state][3]; break;\n\t}\n\treturn rc;\n}\n\n/**\n *\tllc_sap_add_socket - adds a socket to a SAP\n *\t@sap: SAP\n *\t@sk: socket\n *\n *\tThis function adds a socket to the hash tables of a SAP.\n */\nvoid llc_sap_add_socket(struct llc_sap *sap, struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct hlist_head *dev_hb = llc_sk_dev_hash(sap, llc->dev->ifindex);\n\tstruct hlist_nulls_head *laddr_hb = llc_sk_laddr_hash(sap, &llc->laddr);\n\n\tllc_sap_hold(sap);\n\tllc_sk(sk)->sap = sap;\n\n\tspin_lock_bh(&sap->sk_lock);\n\tsap->sk_count++;\n\tsk_nulls_add_node_rcu(sk, laddr_hb);\n\thlist_add_head(&llc->dev_hash_node, dev_hb);\n\tspin_unlock_bh(&sap->sk_lock);\n}\n\n/**\n *\tllc_sap_remove_socket - removes a socket from SAP\n *\t@sap: SAP\n *\t@sk: socket\n *\n *\tThis function removes a connection from the hash tables of a SAP if\n *\tthe connection was in this list.\n */\nvoid llc_sap_remove_socket(struct llc_sap *sap, struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tspin_lock_bh(&sap->sk_lock);\n\tsk_nulls_del_node_init_rcu(sk);\n\thlist_del(&llc->dev_hash_node);\n\tsap->sk_count--;\n\tspin_unlock_bh(&sap->sk_lock);\n\tllc_sap_put(sap);\n}\n\n/**\n *\tllc_conn_rcv - sends received pdus to the connection state machine\n *\t@sk: current connection structure.\n *\t@skb: received frame.\n *\n *\tSends received pdus to the connection state machine.\n */\nstatic int llc_conn_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\tev->type   = LLC_CONN_EV_TYPE_PDU;\n\tev->reason = 0;\n\treturn llc_conn_state_process(sk, skb);\n}\n\nstatic struct sock *llc_create_incoming_sock(struct sock *sk,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     struct llc_addr *saddr,\n\t\t\t\t\t     struct llc_addr *daddr)\n{\n\tstruct sock *newsk = llc_sk_alloc(sock_net(sk), sk->sk_family, GFP_ATOMIC,\n\t\t\t\t\t  sk->sk_prot, 0);\n\tstruct llc_sock *newllc, *llc = llc_sk(sk);\n\n\tif (!newsk)\n\t\tgoto out;\n\tnewllc = llc_sk(newsk);\n\tmemcpy(&newllc->laddr, daddr, sizeof(newllc->laddr));\n\tmemcpy(&newllc->daddr, saddr, sizeof(newllc->daddr));\n\tnewllc->dev = dev;\n\tdev_hold(dev);\n\tllc_sap_add_socket(llc->sap, newsk);\n\tllc_sap_hold(llc->sap);\nout:\n\treturn newsk;\n}\n\nvoid llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr saddr, daddr;\n\tstruct sock *sk;\n\n\tllc_pdu_decode_sa(skb, saddr.mac);\n\tllc_pdu_decode_ssap(skb, &saddr.lsap);\n\tllc_pdu_decode_da(skb, daddr.mac);\n\tllc_pdu_decode_dsap(skb, &daddr.lsap);\n\n\tsk = __llc_lookup(sap, &saddr, &daddr);\n\tif (!sk)\n\t\tgoto drop;\n\n\tbh_lock_sock(sk);\n\t/*\n\t * This has to be done here and not at the upper layer ->accept\n\t * method because of the way the PROCOM state machine works:\n\t * it needs to set several state variables (see, for instance,\n\t * llc_adm_actions_2 in net/llc/llc_c_st.c) and send a packet to\n\t * the originator of the new connection, and this state has to be\n\t * in the newly created struct sock private area. -acme\n\t */\n\tif (unlikely(sk->sk_state == TCP_LISTEN)) {\n\t\tstruct sock *newsk = llc_create_incoming_sock(sk, skb->dev,\n\t\t\t\t\t\t\t      &saddr, &daddr);\n\t\tif (!newsk)\n\t\t\tgoto drop_unlock;\n\t\tskb_set_owner_r(skb, newsk);\n\t} else {\n\t\t/*\n\t\t * Can't be skb_set_owner_r, this will be done at the\n\t\t * llc_conn_state_process function, later on, when we will use\n\t\t * skb_queue_rcv_skb to send it to upper layers, this is\n\t\t * another trick required to cope with how the PROCOM state\n\t\t * machine works. -acme\n\t\t */\n\t\tskb->sk = sk;\n\t}\n\tif (!sock_owned_by_user(sk))\n\t\tllc_conn_rcv(sk, skb);\n\telse {\n\t\tdprintk(\"%s: adding to backlog...\\n\", __func__);\n\t\tllc_set_backlog_type(skb, LLC_PACKET);\n\t\tif (sk_add_backlog(sk, skb, sk->sk_rcvbuf))\n\t\t\tgoto drop_unlock;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn;\ndrop:\n\tkfree_skb(skb);\n\treturn;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\n#undef LLC_REFCNT_DEBUG\n#ifdef LLC_REFCNT_DEBUG\nstatic atomic_t llc_sock_nr;\n#endif\n\n/**\n *\tllc_backlog_rcv - Processes rx frames and expired timers.\n *\t@sk: LLC sock (p8022 connection)\n *\t@skb: queued rx frame or event\n *\n *\tThis function processes frames that has received and timers that has\n *\texpired during sending an I pdu (refer to data_req_handler).  frames\n *\tqueue by llc_rcv function (llc_mac.c) and timers queue by timer\n *\tcallback functions(llc_c_ac.c).\n */\nstatic int llc_backlog_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc = 0;\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tif (likely(llc_backlog_type(skb) == LLC_PACKET)) {\n\t\tif (likely(llc->state > 1)) /* not closed */\n\t\t\trc = llc_conn_rcv(sk, skb);\n\t\telse\n\t\t\tgoto out_kfree_skb;\n\t} else if (llc_backlog_type(skb) == LLC_EVENT) {\n\t\t/* timer expiration event */\n\t\tif (likely(llc->state > 1))  /* not closed */\n\t\t\trc = llc_conn_state_process(sk, skb);\n\t\telse\n\t\t\tgoto out_kfree_skb;\n\t} else {\n\t\tprintk(KERN_ERR \"%s: invalid skb in backlog\\n\", __func__);\n\t\tgoto out_kfree_skb;\n\t}\nout:\n\treturn rc;\nout_kfree_skb:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\n/**\n *     llc_sk_init - Initializes a socket with default llc values.\n *     @sk: socket to initialize.\n *\n *     Initializes a socket with default llc values.\n */\nstatic void llc_sk_init(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc->state    = LLC_CONN_STATE_ADM;\n\tllc->inc_cntr = llc->dec_cntr = 2;\n\tllc->dec_step = llc->connect_step = 1;\n\n\tsetup_timer(&llc->ack_timer.timer, llc_conn_ack_tmr_cb,\n\t\t\t(unsigned long)sk);\n\tllc->ack_timer.expire\t      = sysctl_llc2_ack_timeout;\n\n\tsetup_timer(&llc->pf_cycle_timer.timer, llc_conn_pf_cycle_tmr_cb,\n\t\t\t(unsigned long)sk);\n\tllc->pf_cycle_timer.expire\t   = sysctl_llc2_p_timeout;\n\n\tsetup_timer(&llc->rej_sent_timer.timer, llc_conn_rej_tmr_cb,\n\t\t\t(unsigned long)sk);\n\tllc->rej_sent_timer.expire\t   = sysctl_llc2_rej_timeout;\n\n\tsetup_timer(&llc->busy_state_timer.timer, llc_conn_busy_tmr_cb,\n\t\t\t(unsigned long)sk);\n\tllc->busy_state_timer.expire\t     = sysctl_llc2_busy_timeout;\n\n\tllc->n2 = 2;   /* max retransmit */\n\tllc->k  = 2;   /* tx win size, will adjust dynam */\n\tllc->rw = 128; /* rx win size (opt and equal to\n\t\t\t* tx_win of remote LLC) */\n\tskb_queue_head_init(&llc->pdu_unack_q);\n\tsk->sk_backlog_rcv = llc_backlog_rcv;\n}\n\n/**\n *\tllc_sk_alloc - Allocates LLC sock\n *\t@family: upper layer protocol family\n *\t@priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)\n *\n *\tAllocates a LLC sock and initializes it. Returns the new LLC sock\n *\tor %NULL if there's no memory available for one\n */\nstruct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)\n{\n\tstruct sock *sk = sk_alloc(net, family, priority, prot, kern);\n\n\tif (!sk)\n\t\tgoto out;\n\tllc_sk_init(sk);\n\tsock_init_data(NULL, sk);\n#ifdef LLC_REFCNT_DEBUG\n\tatomic_inc(&llc_sock_nr);\n\tprintk(KERN_DEBUG \"LLC socket %p created in %s, now we have %d alive\\n\", sk,\n\t\t__func__, atomic_read(&llc_sock_nr));\n#endif\nout:\n\treturn sk;\n}\n\n/**\n *\tllc_sk_free - Frees a LLC socket\n *\t@sk - socket to free\n *\n *\tFrees a LLC socket\n */\nvoid llc_sk_free(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc->state = LLC_CONN_OUT_OF_SVC;\n\t/* Stop all (possibly) running timers */\n\tllc_conn_ac_stop_all_timers(sk, NULL);\n#ifdef DEBUG_LLC_CONN_ALLOC\n\tprintk(KERN_INFO \"%s: unackq=%d, txq=%d\\n\", __func__,\n\t\tskb_queue_len(&llc->pdu_unack_q),\n\t\tskb_queue_len(&sk->sk_write_queue));\n#endif\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&llc->pdu_unack_q);\n#ifdef LLC_REFCNT_DEBUG\n\tif (atomic_read(&sk->sk_refcnt) != 1) {\n\t\tprintk(KERN_DEBUG \"Destruction of LLC sock %p delayed in %s, cnt=%d\\n\",\n\t\t\tsk, __func__, atomic_read(&sk->sk_refcnt));\n\t\tprintk(KERN_DEBUG \"%d LLC sockets are still alive\\n\",\n\t\t\tatomic_read(&llc_sock_nr));\n\t} else {\n\t\tatomic_dec(&llc_sock_nr);\n\t\tprintk(KERN_DEBUG \"LLC socket %p released in %s, %d are still alive\\n\", sk,\n\t\t\t__func__, atomic_read(&llc_sock_nr));\n\t}\n#endif\n\tsock_put(sk);\n}\n\n/**\n *\tllc_sk_reset - resets a connection\n *\t@sk: LLC socket to reset\n *\n *\tResets a connection to the out of service state. Stops its timers\n *\tand frees any frames in the queues of the connection.\n */\nvoid llc_sk_reset(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc_conn_ac_stop_all_timers(sk, NULL);\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&llc->pdu_unack_q);\n\tllc->remote_busy_flag\t= 0;\n\tllc->cause_flag\t\t= 0;\n\tllc->retry_count\t= 0;\n\tllc_conn_set_p_flag(sk, 0);\n\tllc->f_flag\t\t= 0;\n\tllc->s_flag\t\t= 0;\n\tllc->ack_pf\t\t= 0;\n\tllc->first_pdu_Ns\t= 0;\n\tllc->ack_must_be_send\t= 0;\n\tllc->dec_step\t\t= 1;\n\tllc->inc_cntr\t\t= 2;\n\tllc->dec_cntr\t\t= 2;\n\tllc->X\t\t\t= 0;\n\tllc->failed_data_req\t= 0 ;\n\tllc->last_nr\t\t= 0;\n}\n", "/*\n * llc_sap.c - driver routines for SAP component.\n *\n * Copyright (c) 1997 by Procom Technology, Inc.\n * \t\t 2001-2003 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n * This program can be redistributed or modified under the terms of the\n * GNU General Public License as published by the Free Software Foundation.\n * This program is distributed without any warranty or implied warranty\n * of merchantability or fitness for a particular purpose.\n *\n * See the GNU General Public License for more details.\n */\n\n#include <net/llc.h>\n#include <net/llc_if.h>\n#include <net/llc_conn.h>\n#include <net/llc_pdu.h>\n#include <net/llc_sap.h>\n#include <net/llc_s_ac.h>\n#include <net/llc_s_ev.h>\n#include <net/llc_s_st.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/llc.h>\n#include <linux/slab.h>\n\nstatic int llc_mac_header_len(unsigned short devtype)\n{\n\tswitch (devtype) {\n\tcase ARPHRD_ETHER:\n\tcase ARPHRD_LOOPBACK:\n\t\treturn sizeof(struct ethhdr);\n\t}\n\treturn 0;\n}\n\n/**\n *\tllc_alloc_frame - allocates sk_buff for frame\n *\t@dev: network device this skb will be sent over\n *\t@type: pdu type to allocate\n *\t@data_size: data size to allocate\n *\n *\tAllocates an sk_buff for frame and initializes sk_buff fields.\n *\tReturns allocated skb or %NULL when out of memory.\n */\nstruct sk_buff *llc_alloc_frame(struct sock *sk, struct net_device *dev,\n\t\t\t\tu8 type, u32 data_size)\n{\n\tint hlen = type == LLC_PDU_TYPE_U ? 3 : 4;\n\tstruct sk_buff *skb;\n\n\thlen += llc_mac_header_len(dev->type);\n\tskb = alloc_skb(hlen + data_size, GFP_ATOMIC);\n\n\tif (skb) {\n\t\tskb_reset_mac_header(skb);\n\t\tskb_reserve(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb_reset_transport_header(skb);\n\t\tskb->protocol = htons(ETH_P_802_2);\n\t\tskb->dev      = dev;\n\t\tif (sk != NULL)\n\t\t\tskb_set_owner_w(skb, sk);\n\t}\n\treturn skb;\n}\n\nvoid llc_save_primitive(struct sock *sk, struct sk_buff *skb, u8 prim)\n{\n\tstruct sockaddr_llc *addr;\n\n       /* save primitive for use by the user. */\n\taddr\t\t  = llc_ui_skb_cb(skb);\n\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sllc_family = sk->sk_family;\n\taddr->sllc_arphrd = skb->dev->type;\n\taddr->sllc_test   = prim == LLC_TEST_PRIM;\n\taddr->sllc_xid    = prim == LLC_XID_PRIM;\n\taddr->sllc_ua     = prim == LLC_DATAUNIT_PRIM;\n\tllc_pdu_decode_sa(skb, addr->sllc_mac);\n\tllc_pdu_decode_ssap(skb, &addr->sllc_sap);\n}\n\n/**\n *\tllc_sap_rtn_pdu - Informs upper layer on rx of an UI, XID or TEST pdu.\n *\t@sap: pointer to SAP\n *\t@skb: received pdu\n */\nvoid llc_sap_rtn_pdu(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tstruct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);\n\n\tswitch (LLC_U_PDU_RSP(pdu)) {\n\tcase LLC_1_PDU_CMD_TEST:\n\t\tev->prim = LLC_TEST_PRIM;\tbreak;\n\tcase LLC_1_PDU_CMD_XID:\n\t\tev->prim = LLC_XID_PRIM;\tbreak;\n\tcase LLC_1_PDU_CMD_UI:\n\t\tev->prim = LLC_DATAUNIT_PRIM;\tbreak;\n\t}\n\tev->ind_cfm_flag = LLC_IND;\n}\n\n/**\n *\tllc_find_sap_trans - finds transition for event\n *\t@sap: pointer to SAP\n *\t@skb: happened event\n *\n *\tThis function finds transition that matches with happened event.\n *\tReturns the pointer to found transition on success or %NULL for\n *\tfailure.\n */\nstatic struct llc_sap_state_trans *llc_find_sap_trans(struct llc_sap *sap,\n\t\t\t\t\t\t      struct sk_buff *skb)\n{\n\tint i = 0;\n\tstruct llc_sap_state_trans *rc = NULL;\n\tstruct llc_sap_state_trans **next_trans;\n\tstruct llc_sap_state *curr_state = &llc_sap_state_table[sap->state - 1];\n\t/*\n\t * Search thru events for this state until list exhausted or until\n\t * its obvious the event is not valid for the current state\n\t */\n\tfor (next_trans = curr_state->transitions; next_trans[i]->ev; i++)\n\t\tif (!next_trans[i]->ev(sap, skb)) {\n\t\t\trc = next_trans[i]; /* got event match; return it */\n\t\t\tbreak;\n\t\t}\n\treturn rc;\n}\n\n/**\n *\tllc_exec_sap_trans_actions - execute actions related to event\n *\t@sap: pointer to SAP\n *\t@trans: pointer to transition that it's actions must be performed\n *\t@skb: happened event.\n *\n *\tThis function executes actions that is related to happened event.\n *\tReturns 0 for success and 1 for failure of at least one action.\n */\nstatic int llc_exec_sap_trans_actions(struct llc_sap *sap,\n\t\t\t\t      struct llc_sap_state_trans *trans,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tint rc = 0;\n\tconst llc_sap_action_t *next_action = trans->ev_actions;\n\n\tfor (; next_action && *next_action; next_action++)\n\t\tif ((*next_action)(sap, skb))\n\t\t\trc = 1;\n\treturn rc;\n}\n\n/**\n *\tllc_sap_next_state - finds transition, execs actions & change SAP state\n *\t@sap: pointer to SAP\n *\t@skb: happened event\n *\n *\tThis function finds transition that matches with happened event, then\n *\texecutes related actions and finally changes state of SAP. It returns\n *\t0 on success and 1 for failure.\n */\nstatic int llc_sap_next_state(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tint rc = 1;\n\tstruct llc_sap_state_trans *trans;\n\n\tif (sap->state > LLC_NR_SAP_STATES)\n\t\tgoto out;\n\ttrans = llc_find_sap_trans(sap, skb);\n\tif (!trans)\n\t\tgoto out;\n\t/*\n\t * Got the state to which we next transition; perform the actions\n\t * associated with this transition before actually transitioning to the\n\t * next state\n\t */\n\trc = llc_exec_sap_trans_actions(sap, trans, skb);\n\tif (rc)\n\t\tgoto out;\n\t/*\n\t * Transition SAP to next state if all actions execute successfully\n\t */\n\tsap->state = trans->next_state;\nout:\n\treturn rc;\n}\n\n/**\n *\tllc_sap_state_process - sends event to SAP state machine\n *\t@sap: sap to use\n *\t@skb: pointer to occurred event\n *\n *\tAfter executing actions of the event, upper layer will be indicated\n *\tif needed(on receiving an UI frame). sk can be null for the\n *\tdatalink_proto case.\n */\nstatic void llc_sap_state_process(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\t/*\n\t * We have to hold the skb, because llc_sap_next_state\n\t * will kfree it in the sending path and we need to\n\t * look at the skb->cb, where we encode llc_sap_state_ev.\n\t */\n\tskb_get(skb);\n\tev->ind_cfm_flag = 0;\n\tllc_sap_next_state(sap, skb);\n\tif (ev->ind_cfm_flag == LLC_IND) {\n\t\tif (skb->sk->sk_state == TCP_LISTEN)\n\t\t\tkfree_skb(skb);\n\t\telse {\n\t\t\tllc_save_primitive(skb->sk, skb, ev->prim);\n\n\t\t\t/* queue skb to the user. */\n\t\t\tif (sock_queue_rcv_skb(skb->sk, skb))\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\tkfree_skb(skb);\n}\n\n/**\n *\tllc_build_and_send_test_pkt - TEST interface for upper layers.\n *\t@sap: sap to use\n *\t@skb: packet to send\n *\t@dmac: destination mac address\n *\t@dsap: destination sap\n *\n *\tThis function is called when upper layer wants to send a TEST pdu.\n *\tReturns 0 for success, 1 otherwise.\n */\nvoid llc_build_and_send_test_pkt(struct llc_sap *sap,\n\t\t\t\t struct sk_buff *skb, u8 *dmac, u8 dsap)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->saddr.lsap = sap->laddr.lsap;\n\tev->daddr.lsap = dsap;\n\tmemcpy(ev->saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(ev->daddr.mac, dmac, IFHWADDRLEN);\n\n\tev->type      = LLC_SAP_EV_TYPE_PRIM;\n\tev->prim      = LLC_TEST_PRIM;\n\tev->prim_type = LLC_PRIM_TYPE_REQ;\n\tllc_sap_state_process(sap, skb);\n}\n\n/**\n *\tllc_build_and_send_xid_pkt - XID interface for upper layers\n *\t@sap: sap to use\n *\t@skb: packet to send\n *\t@dmac: destination mac address\n *\t@dsap: destination sap\n *\n *\tThis function is called when upper layer wants to send a XID pdu.\n *\tReturns 0 for success, 1 otherwise.\n */\nvoid llc_build_and_send_xid_pkt(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\t\tu8 *dmac, u8 dsap)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->saddr.lsap = sap->laddr.lsap;\n\tev->daddr.lsap = dsap;\n\tmemcpy(ev->saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(ev->daddr.mac, dmac, IFHWADDRLEN);\n\n\tev->type      = LLC_SAP_EV_TYPE_PRIM;\n\tev->prim      = LLC_XID_PRIM;\n\tev->prim_type = LLC_PRIM_TYPE_REQ;\n\tllc_sap_state_process(sap, skb);\n}\n\n/**\n *\tllc_sap_rcv - sends received pdus to the sap state machine\n *\t@sap: current sap component structure.\n *\t@skb: received frame.\n *\n *\tSends received pdus to the sap state machine.\n */\nstatic void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->type   = LLC_SAP_EV_TYPE_PDU;\n\tev->reason = 0;\n\tskb->sk = sk;\n\tllc_sap_state_process(sap, skb);\n}\n\nstatic inline bool llc_dgram_match(const struct llc_sap *sap,\n\t\t\t\t   const struct llc_addr *laddr,\n\t\t\t\t   const struct sock *sk)\n{\n     struct llc_sock *llc = llc_sk(sk);\n\n     return sk->sk_type == SOCK_DGRAM &&\n\t  llc->laddr.lsap == laddr->lsap &&\n\t  ether_addr_equal(llc->laddr.mac, laddr->mac);\n}\n\n/**\n *\tllc_lookup_dgram - Finds dgram socket for the local sap/mac\n *\t@sap: SAP\n *\t@laddr: address of local LLC (MAC + SAP)\n *\n *\tSearch socket list of the SAP and finds connection using the local\n *\tmac, and local sap. Returns pointer for socket found, %NULL otherwise.\n */\nstatic struct sock *llc_lookup_dgram(struct llc_sap *sap,\n\t\t\t\t     const struct llc_addr *laddr)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock_bh();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_dgram_match(sap, laddr, rc)) {\n\t\t\t/* Extra checks required by SLAB_DESTROY_BY_RCU */\n\t\t\tif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_dgram_match(sap, laddr, rc))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock_bh();\n\treturn rc;\n}\n\nstatic inline bool llc_mcast_match(const struct llc_sap *sap,\n\t\t\t\t   const struct llc_addr *laddr,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   const struct sock *sk)\n{\n     struct llc_sock *llc = llc_sk(sk);\n\n     return sk->sk_type == SOCK_DGRAM &&\n\t  llc->laddr.lsap == laddr->lsap &&\n\t  llc->dev == skb->dev;\n}\n\nstatic void llc_do_mcast(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\t struct sock **stack, int count)\n{\n\tstruct sk_buff *skb1;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tskb1 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb1) {\n\t\t\tsock_put(stack[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tllc_sap_rcv(sap, skb1, stack[i]);\n\t\tsock_put(stack[i]);\n\t}\n}\n\n/**\n * \tllc_sap_mcast - Deliver multicast PDU's to all matching datagram sockets.\n *\t@sap: SAP\n *\t@laddr: address of local LLC (MAC + SAP)\n *\n *\tSearch socket list of the SAP and finds connections with same sap.\n *\tDeliver clone to each.\n */\nstatic void llc_sap_mcast(struct llc_sap *sap,\n\t\t\t  const struct llc_addr *laddr,\n\t\t\t  struct sk_buff *skb)\n{\n\tint i = 0, count = 256 / sizeof(struct sock *);\n\tstruct sock *sk, *stack[count];\n\tstruct llc_sock *llc;\n\tstruct hlist_head *dev_hb = llc_sk_dev_hash(sap, skb->dev->ifindex);\n\n\tspin_lock_bh(&sap->sk_lock);\n\thlist_for_each_entry(llc, dev_hb, dev_hash_node) {\n\n\t\tsk = &llc->sk;\n\n\t\tif (!llc_mcast_match(sap, laddr, skb, sk))\n\t\t\tcontinue;\n\n\t\tsock_hold(sk);\n\t\tif (i < count)\n\t\t\tstack[i++] = sk;\n\t\telse {\n\t\t\tllc_do_mcast(sap, skb, stack, i);\n\t\t\ti = 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&sap->sk_lock);\n\n\tllc_do_mcast(sap, skb, stack, i);\n}\n\n\nvoid llc_sap_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr laddr;\n\n\tllc_pdu_decode_da(skb, laddr.mac);\n\tllc_pdu_decode_dsap(skb, &laddr.lsap);\n\n\tif (is_multicast_ether_addr(laddr.mac)) {\n\t\tllc_sap_mcast(sap, &laddr, skb);\n\t\tkfree_skb(skb);\n\t} else {\n\t\tstruct sock *sk = llc_lookup_dgram(sap, &laddr);\n\t\tif (sk) {\n\t\t\tllc_sap_rcv(sap, skb, sk);\n\t\t\tsock_put(sk);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n}\n"], "fixing_code": ["/*\n * llc_conn.c - Driver routines for connection component.\n *\n * Copyright (c) 1997 by Procom Technology, Inc.\n *\t\t 2001-2003 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n * This program can be redistributed or modified under the terms of the\n * GNU General Public License as published by the Free Software Foundation.\n * This program is distributed without any warranty or implied warranty\n * of merchantability or fitness for a particular purpose.\n *\n * See the GNU General Public License for more details.\n */\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/llc_sap.h>\n#include <net/llc_conn.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <net/llc_c_ev.h>\n#include <net/llc_c_ac.h>\n#include <net/llc_c_st.h>\n#include <net/llc_pdu.h>\n\n#if 0\n#define dprintk(args...) printk(KERN_DEBUG args)\n#else\n#define dprintk(args...)\n#endif\n\nstatic int llc_find_offset(int state, int ev_type);\nstatic void llc_conn_send_pdus(struct sock *sk);\nstatic int llc_conn_service(struct sock *sk, struct sk_buff *skb);\nstatic int llc_exec_conn_trans_actions(struct sock *sk,\n\t\t\t\t       struct llc_conn_state_trans *trans,\n\t\t\t\t       struct sk_buff *ev);\nstatic struct llc_conn_state_trans *llc_qualify_conn_ev(struct sock *sk,\n\t\t\t\t\t\t\tstruct sk_buff *skb);\n\n/* Offset table on connection states transition diagram */\nstatic int llc_offset_table[NBR_CONN_STATES][NBR_CONN_EV];\n\nint sysctl_llc2_ack_timeout = LLC2_ACK_TIME * HZ;\nint sysctl_llc2_p_timeout = LLC2_P_TIME * HZ;\nint sysctl_llc2_rej_timeout = LLC2_REJ_TIME * HZ;\nint sysctl_llc2_busy_timeout = LLC2_BUSY_TIME * HZ;\n\n/**\n *\tllc_conn_state_process - sends event to connection state machine\n *\t@sk: connection\n *\t@skb: occurred event\n *\n *\tSends an event to connection state machine. After processing event\n *\t(executing it's actions and changing state), upper layer will be\n *\tindicated or confirmed, if needed. Returns 0 for success, 1 for\n *\tfailure. The socket lock has to be held before calling this function.\n */\nint llc_conn_state_process(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\t/*\n\t * We have to hold the skb, because llc_conn_service will kfree it in\n\t * the sending path and we need to look at the skb->cb, where we encode\n\t * llc_conn_state_ev.\n\t */\n\tskb_get(skb);\n\tev->ind_prim = ev->cfm_prim = 0;\n\t/*\n\t * Send event to state machine\n\t */\n\trc = llc_conn_service(skb->sk, skb);\n\tif (unlikely(rc != 0)) {\n\t\tprintk(KERN_ERR \"%s: llc_conn_service failed\\n\", __func__);\n\t\tgoto out_kfree_skb;\n\t}\n\n\tif (unlikely(!ev->ind_prim && !ev->cfm_prim)) {\n\t\t/* indicate or confirm not required */\n\t\tif (!skb->next)\n\t\t\tgoto out_kfree_skb;\n\t\tgoto out_skb_put;\n\t}\n\n\tif (unlikely(ev->ind_prim && ev->cfm_prim)) /* Paranoia */\n\t\tskb_get(skb);\n\n\tswitch (ev->ind_prim) {\n\tcase LLC_DATA_PRIM:\n\t\tllc_save_primitive(sk, skb, LLC_DATA_PRIM);\n\t\tif (unlikely(sock_queue_rcv_skb(sk, skb))) {\n\t\t\t/*\n\t\t\t * shouldn't happen\n\t\t\t */\n\t\t\tprintk(KERN_ERR \"%s: sock_queue_rcv_skb failed!\\n\",\n\t\t\t       __func__);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\tbreak;\n\tcase LLC_CONN_PRIM:\n\t\t/*\n\t\t * Can't be sock_queue_rcv_skb, because we have to leave the\n\t\t * skb->sk pointing to the newly created struct sock in\n\t\t * llc_conn_handler. -acme\n\t\t */\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\tcase LLC_DISC_PRIM:\n\t\tsock_hold(sk);\n\t\tif (sk->sk_type == SOCK_STREAM &&\n\t\t    sk->sk_state == TCP_ESTABLISHED) {\n\t\t\tsk->sk_shutdown       = SHUTDOWN_MASK;\n\t\t\tsk->sk_socket->state  = SS_UNCONNECTED;\n\t\t\tsk->sk_state          = TCP_CLOSE;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t}\n\t\t}\n\t\tkfree_skb(skb);\n\t\tsock_put(sk);\n\t\tbreak;\n\tcase LLC_RESET_PRIM:\n\t\t/*\n\t\t * FIXME:\n\t\t * RESET is not being notified to upper layers for now\n\t\t */\n\t\tprintk(KERN_INFO \"%s: received a reset ind!\\n\", __func__);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\tdefault:\n\t\tif (ev->ind_prim) {\n\t\t\tprintk(KERN_INFO \"%s: received unknown %d prim!\\n\",\n\t\t\t\t__func__, ev->ind_prim);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\t/* No indication */\n\t\tbreak;\n\t}\n\n\tswitch (ev->cfm_prim) {\n\tcase LLC_DATA_PRIM:\n\t\tif (!llc_data_accept_state(llc->state))\n\t\t\tsk->sk_write_space(sk);\n\t\telse\n\t\t\trc = llc->failed_data_req = 1;\n\t\tbreak;\n\tcase LLC_CONN_PRIM:\n\t\tif (sk->sk_type == SOCK_STREAM &&\n\t\t    sk->sk_state == TCP_SYN_SENT) {\n\t\t\tif (ev->status) {\n\t\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\t\tsk->sk_state         = TCP_CLOSE;\n\t\t\t} else {\n\t\t\t\tsk->sk_socket->state = SS_CONNECTED;\n\t\t\t\tsk->sk_state         = TCP_ESTABLISHED;\n\t\t\t}\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t\tbreak;\n\tcase LLC_DISC_PRIM:\n\t\tsock_hold(sk);\n\t\tif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSING) {\n\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\tsk->sk_state         = TCP_CLOSE;\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t\tsock_put(sk);\n\t\tbreak;\n\tcase LLC_RESET_PRIM:\n\t\t/*\n\t\t * FIXME:\n\t\t * RESET is not being notified to upper layers for now\n\t\t */\n\t\tprintk(KERN_INFO \"%s: received a reset conf!\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\tif (ev->cfm_prim) {\n\t\t\tprintk(KERN_INFO \"%s: received unknown %d prim!\\n\",\n\t\t\t\t\t__func__, ev->cfm_prim);\n\t\t\tbreak;\n\t\t}\n\t\tgoto out_skb_put; /* No confirmation */\n\t}\nout_kfree_skb:\n\tkfree_skb(skb);\nout_skb_put:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\nvoid llc_conn_send_pdu(struct sock *sk, struct sk_buff *skb)\n{\n\t/* queue PDU to send to MAC layer */\n\tskb_queue_tail(&sk->sk_write_queue, skb);\n\tllc_conn_send_pdus(sk);\n}\n\n/**\n *\tllc_conn_rtn_pdu - sends received data pdu to upper layer\n *\t@sk: Active connection\n *\t@skb: Received data frame\n *\n *\tSends received data pdu to upper layer (by using indicate function).\n *\tPrepares service parameters (prim and prim_data). calling indication\n *\tfunction will be done in llc_conn_state_process.\n */\nvoid llc_conn_rtn_pdu(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\tev->ind_prim = LLC_DATA_PRIM;\n}\n\n/**\n *\tllc_conn_resend_i_pdu_as_cmd - resend all all unacknowledged I PDUs\n *\t@sk: active connection\n *\t@nr: NR\n *\t@first_p_bit: p_bit value of first pdu\n *\n *\tResend all unacknowledged I PDUs, starting with the NR; send first as\n *\tcommand PDU with P bit equal first_p_bit; if more than one send\n *\tsubsequent as command PDUs with P bit equal zero (0).\n */\nvoid llc_conn_resend_i_pdu_as_cmd(struct sock *sk, u8 nr, u8 first_p_bit)\n{\n\tstruct sk_buff *skb;\n\tstruct llc_pdu_sn *pdu;\n\tu16 nbr_unack_pdus;\n\tstruct llc_sock *llc;\n\tu8 howmany_resend = 0;\n\n\tllc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);\n\tif (!nbr_unack_pdus)\n\t\tgoto out;\n\t/*\n\t * Process unack PDUs only if unack queue is not empty; remove\n\t * appropriate PDUs, fix them up, and put them on mac_pdu_q.\n\t */\n\tllc = llc_sk(sk);\n\n\twhile ((skb = skb_dequeue(&llc->pdu_unack_q)) != NULL) {\n\t\tpdu = llc_pdu_sn_hdr(skb);\n\t\tllc_pdu_set_cmd_rsp(skb, LLC_PDU_CMD);\n\t\tllc_pdu_set_pf_bit(skb, first_p_bit);\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\n\t\tfirst_p_bit = 0;\n\t\tllc->vS = LLC_I_GET_NS(pdu);\n\t\thowmany_resend++;\n\t}\n\tif (howmany_resend > 0)\n\t\tllc->vS = (llc->vS + 1) % LLC_2_SEQ_NBR_MODULO;\n\t/* any PDUs to re-send are queued up; start sending to MAC */\n\tllc_conn_send_pdus(sk);\nout:;\n}\n\n/**\n *\tllc_conn_resend_i_pdu_as_rsp - Resend all unacknowledged I PDUs\n *\t@sk: active connection.\n *\t@nr: NR\n *\t@first_f_bit: f_bit value of first pdu.\n *\n *\tResend all unacknowledged I PDUs, starting with the NR; send first as\n *\tresponse PDU with F bit equal first_f_bit; if more than one send\n *\tsubsequent as response PDUs with F bit equal zero (0).\n */\nvoid llc_conn_resend_i_pdu_as_rsp(struct sock *sk, u8 nr, u8 first_f_bit)\n{\n\tstruct sk_buff *skb;\n\tu16 nbr_unack_pdus;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tu8 howmany_resend = 0;\n\n\tllc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);\n\tif (!nbr_unack_pdus)\n\t\tgoto out;\n\t/*\n\t * Process unack PDUs only if unack queue is not empty; remove\n\t * appropriate PDUs, fix them up, and put them on mac_pdu_q\n\t */\n\twhile ((skb = skb_dequeue(&llc->pdu_unack_q)) != NULL) {\n\t\tstruct llc_pdu_sn *pdu = llc_pdu_sn_hdr(skb);\n\n\t\tllc_pdu_set_cmd_rsp(skb, LLC_PDU_RSP);\n\t\tllc_pdu_set_pf_bit(skb, first_f_bit);\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\n\t\tfirst_f_bit = 0;\n\t\tllc->vS = LLC_I_GET_NS(pdu);\n\t\thowmany_resend++;\n\t}\n\tif (howmany_resend > 0)\n\t\tllc->vS = (llc->vS + 1) % LLC_2_SEQ_NBR_MODULO;\n\t/* any PDUs to re-send are queued up; start sending to MAC */\n\tllc_conn_send_pdus(sk);\nout:;\n}\n\n/**\n *\tllc_conn_remove_acked_pdus - Removes acknowledged pdus from tx queue\n *\t@sk: active connection\n *\tnr: NR\n *\thow_many_unacked: size of pdu_unack_q after removing acked pdus\n *\n *\tRemoves acknowledged pdus from transmit queue (pdu_unack_q). Returns\n *\tthe number of pdus that removed from queue.\n */\nint llc_conn_remove_acked_pdus(struct sock *sk, u8 nr, u16 *how_many_unacked)\n{\n\tint pdu_pos, i;\n\tstruct sk_buff *skb;\n\tstruct llc_pdu_sn *pdu;\n\tint nbr_acked = 0;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint q_len = skb_queue_len(&llc->pdu_unack_q);\n\n\tif (!q_len)\n\t\tgoto out;\n\tskb = skb_peek(&llc->pdu_unack_q);\n\tpdu = llc_pdu_sn_hdr(skb);\n\n\t/* finding position of last acked pdu in queue */\n\tpdu_pos = ((int)LLC_2_SEQ_NBR_MODULO + (int)nr -\n\t\t\t(int)LLC_I_GET_NS(pdu)) % LLC_2_SEQ_NBR_MODULO;\n\n\tfor (i = 0; i < pdu_pos && i < q_len; i++) {\n\t\tskb = skb_dequeue(&llc->pdu_unack_q);\n\t\tkfree_skb(skb);\n\t\tnbr_acked++;\n\t}\nout:\n\t*how_many_unacked = skb_queue_len(&llc->pdu_unack_q);\n\treturn nbr_acked;\n}\n\n/**\n *\tllc_conn_send_pdus - Sends queued PDUs\n *\t@sk: active connection\n *\n *\tSends queued pdus to MAC layer for transmission.\n */\nstatic void llc_conn_send_pdus(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&sk->sk_write_queue)) != NULL) {\n\t\tstruct llc_pdu_sn *pdu = llc_pdu_sn_hdr(skb);\n\n\t\tif (LLC_PDU_TYPE_IS_I(pdu) &&\n\t\t    !(skb->dev->flags & IFF_LOOPBACK)) {\n\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\tskb_queue_tail(&llc_sk(sk)->pdu_unack_q, skb);\n\t\t\tif (!skb2)\n\t\t\t\tbreak;\n\t\t\tskb = skb2;\n\t\t}\n\t\tdev_queue_xmit(skb);\n\t}\n}\n\n/**\n *\tllc_conn_service - finds transition and changes state of connection\n *\t@sk: connection\n *\t@skb: happened event\n *\n *\tThis function finds transition that matches with happened event, then\n *\texecutes related actions and finally changes state of connection.\n *\tReturns 0 for success, 1 for failure.\n */\nstatic int llc_conn_service(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc = 1;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_conn_state_trans *trans;\n\n\tif (llc->state > NBR_CONN_STATES)\n\t\tgoto out;\n\trc = 0;\n\ttrans = llc_qualify_conn_ev(sk, skb);\n\tif (trans) {\n\t\trc = llc_exec_conn_trans_actions(sk, trans, skb);\n\t\tif (!rc && trans->next_state != NO_STATE_CHANGE) {\n\t\t\tllc->state = trans->next_state;\n\t\t\tif (!llc_data_accept_state(llc->state))\n\t\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\n/**\n *\tllc_qualify_conn_ev - finds transition for event\n *\t@sk: connection\n *\t@skb: happened event\n *\n *\tThis function finds transition that matches with happened event.\n *\tReturns pointer to found transition on success, %NULL otherwise.\n */\nstatic struct llc_conn_state_trans *llc_qualify_conn_ev(struct sock *sk,\n\t\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct llc_conn_state_trans **next_trans;\n\tconst llc_conn_ev_qfyr_t *next_qualifier;\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_conn_state *curr_state =\n\t\t\t\t\t&llc_conn_state_table[llc->state - 1];\n\n\t/* search thru events for this state until\n\t * list exhausted or until no more\n\t */\n\tfor (next_trans = curr_state->transitions +\n\t\tllc_find_offset(llc->state - 1, ev->type);\n\t     (*next_trans)->ev; next_trans++) {\n\t\tif (!((*next_trans)->ev)(sk, skb)) {\n\t\t\t/* got POSSIBLE event match; the event may require\n\t\t\t * qualification based on the values of a number of\n\t\t\t * state flags; if all qualifications are met (i.e.,\n\t\t\t * if all qualifying functions return success, or 0,\n\t\t\t * then this is THE event we're looking for\n\t\t\t */\n\t\t\tfor (next_qualifier = (*next_trans)->ev_qualifiers;\n\t\t\t     next_qualifier && *next_qualifier &&\n\t\t\t     !(*next_qualifier)(sk, skb); next_qualifier++)\n\t\t\t\t/* nothing */;\n\t\t\tif (!next_qualifier || !*next_qualifier)\n\t\t\t\t/* all qualifiers executed successfully; this is\n\t\t\t\t * our transition; return it so we can perform\n\t\t\t\t * the associated actions & change the state\n\t\t\t\t */\n\t\t\t\treturn *next_trans;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n *\tllc_exec_conn_trans_actions - executes related actions\n *\t@sk: connection\n *\t@trans: transition that it's actions must be performed\n *\t@skb: event\n *\n *\tExecutes actions that is related to happened event. Returns 0 for\n *\tsuccess, 1 to indicate failure of at least one action.\n */\nstatic int llc_exec_conn_trans_actions(struct sock *sk,\n\t\t\t\t       struct llc_conn_state_trans *trans,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tint rc = 0;\n\tconst llc_conn_action_t *next_action;\n\n\tfor (next_action = trans->ev_actions;\n\t     next_action && *next_action; next_action++) {\n\t\tint rc2 = (*next_action)(sk, skb);\n\n\t\tif (rc2 == 2) {\n\t\t\trc = rc2;\n\t\t\tbreak;\n\t\t} else if (rc2)\n\t\t\trc = 1;\n\t}\n\treturn rc;\n}\n\nstatic inline bool llc_estab_match(const struct llc_sap *sap,\n\t\t\t\t   const struct llc_addr *daddr,\n\t\t\t\t   const struct llc_addr *laddr,\n\t\t\t\t   const struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\treturn llc->laddr.lsap == laddr->lsap &&\n\t\tllc->daddr.lsap == daddr->lsap &&\n\t\tether_addr_equal(llc->laddr.mac, laddr->mac) &&\n\t\tether_addr_equal(llc->daddr.mac, daddr->mac);\n}\n\n/**\n *\t__llc_lookup_established - Finds connection for the remote/local sap/mac\n *\t@sap: SAP\n *\t@daddr: address of remote LLC (MAC + SAP)\n *\t@laddr: address of local LLC (MAC + SAP)\n *\n *\tSearch connection list of the SAP and finds connection using the remote\n *\tmac, remote sap, local mac, and local sap. Returns pointer for\n *\tconnection found, %NULL otherwise.\n *\tCaller has to make sure local_bh is disabled.\n */\nstatic struct sock *__llc_lookup_established(struct llc_sap *sap,\n\t\t\t\t\t     struct llc_addr *daddr,\n\t\t\t\t\t     struct llc_addr *laddr)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_estab_match(sap, daddr, laddr, rc)) {\n\t\t\t/* Extra checks required by SLAB_DESTROY_BY_RCU */\n\t\t\tif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_estab_match(sap, daddr, laddr, rc))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock();\n\treturn rc;\n}\n\nstruct sock *llc_lookup_established(struct llc_sap *sap,\n\t\t\t\t    struct llc_addr *daddr,\n\t\t\t\t    struct llc_addr *laddr)\n{\n\tstruct sock *sk;\n\n\tlocal_bh_disable();\n\tsk = __llc_lookup_established(sap, daddr, laddr);\n\tlocal_bh_enable();\n\treturn sk;\n}\n\nstatic inline bool llc_listener_match(const struct llc_sap *sap,\n\t\t\t\t      const struct llc_addr *laddr,\n\t\t\t\t      const struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\treturn sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN &&\n\t\tllc->laddr.lsap == laddr->lsap &&\n\t\tether_addr_equal(llc->laddr.mac, laddr->mac);\n}\n\nstatic struct sock *__llc_lookup_listener(struct llc_sap *sap,\n\t\t\t\t\t  struct llc_addr *laddr)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_listener_match(sap, laddr, rc)) {\n\t\t\t/* Extra checks required by SLAB_DESTROY_BY_RCU */\n\t\t\tif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_listener_match(sap, laddr, rc))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock();\n\treturn rc;\n}\n\n/**\n *\tllc_lookup_listener - Finds listener for local MAC + SAP\n *\t@sap: SAP\n *\t@laddr: address of local LLC (MAC + SAP)\n *\n *\tSearch connection list of the SAP and finds connection listening on\n *\tlocal mac, and local sap. Returns pointer for parent socket found,\n *\t%NULL otherwise.\n *\tCaller has to make sure local_bh is disabled.\n */\nstatic struct sock *llc_lookup_listener(struct llc_sap *sap,\n\t\t\t\t\tstruct llc_addr *laddr)\n{\n\tstatic struct llc_addr null_addr;\n\tstruct sock *rc = __llc_lookup_listener(sap, laddr);\n\n\tif (!rc)\n\t\trc = __llc_lookup_listener(sap, &null_addr);\n\n\treturn rc;\n}\n\nstatic struct sock *__llc_lookup(struct llc_sap *sap,\n\t\t\t\t struct llc_addr *daddr,\n\t\t\t\t struct llc_addr *laddr)\n{\n\tstruct sock *sk = __llc_lookup_established(sap, daddr, laddr);\n\n\treturn sk ? : llc_lookup_listener(sap, laddr);\n}\n\n/**\n *\tllc_data_accept_state - designates if in this state data can be sent.\n *\t@state: state of connection.\n *\n *\tReturns 0 if data can be sent, 1 otherwise.\n */\nu8 llc_data_accept_state(u8 state)\n{\n\treturn state != LLC_CONN_STATE_NORMAL && state != LLC_CONN_STATE_BUSY &&\n\t       state != LLC_CONN_STATE_REJ;\n}\n\n/**\n *\tllc_find_next_offset - finds offset for next category of transitions\n *\t@state: state table.\n *\t@offset: start offset.\n *\n *\tFinds offset of next category of transitions in transition table.\n *\tReturns the start index of next category.\n */\nstatic u16 __init llc_find_next_offset(struct llc_conn_state *state, u16 offset)\n{\n\tu16 cnt = 0;\n\tstruct llc_conn_state_trans **next_trans;\n\n\tfor (next_trans = state->transitions + offset;\n\t     (*next_trans)->ev; next_trans++)\n\t\t++cnt;\n\treturn cnt;\n}\n\n/**\n *\tllc_build_offset_table - builds offset table of connection\n *\n *\tFills offset table of connection state transition table\n *\t(llc_offset_table).\n */\nvoid __init llc_build_offset_table(void)\n{\n\tstruct llc_conn_state *curr_state;\n\tint state, ev_type, next_offset;\n\n\tfor (state = 0; state < NBR_CONN_STATES; state++) {\n\t\tcurr_state = &llc_conn_state_table[state];\n\t\tnext_offset = 0;\n\t\tfor (ev_type = 0; ev_type < NBR_CONN_EV; ev_type++) {\n\t\t\tllc_offset_table[state][ev_type] = next_offset;\n\t\t\tnext_offset += llc_find_next_offset(curr_state,\n\t\t\t\t\t\t\t    next_offset) + 1;\n\t\t}\n\t}\n}\n\n/**\n *\tllc_find_offset - finds start offset of category of transitions\n *\t@state: state of connection\n *\t@ev_type: type of happened event\n *\n *\tFinds start offset of desired category of transitions. Returns the\n *\tdesired start offset.\n */\nstatic int llc_find_offset(int state, int ev_type)\n{\n\tint rc = 0;\n\t/* at this stage, llc_offset_table[..][2] is not important. it is for\n\t * init_pf_cycle and I don't know what is it.\n\t */\n\tswitch (ev_type) {\n\tcase LLC_CONN_EV_TYPE_PRIM:\n\t\trc = llc_offset_table[state][0]; break;\n\tcase LLC_CONN_EV_TYPE_PDU:\n\t\trc = llc_offset_table[state][4]; break;\n\tcase LLC_CONN_EV_TYPE_SIMPLE:\n\t\trc = llc_offset_table[state][1]; break;\n\tcase LLC_CONN_EV_TYPE_P_TMR:\n\tcase LLC_CONN_EV_TYPE_ACK_TMR:\n\tcase LLC_CONN_EV_TYPE_REJ_TMR:\n\tcase LLC_CONN_EV_TYPE_BUSY_TMR:\n\t\trc = llc_offset_table[state][3]; break;\n\t}\n\treturn rc;\n}\n\n/**\n *\tllc_sap_add_socket - adds a socket to a SAP\n *\t@sap: SAP\n *\t@sk: socket\n *\n *\tThis function adds a socket to the hash tables of a SAP.\n */\nvoid llc_sap_add_socket(struct llc_sap *sap, struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct hlist_head *dev_hb = llc_sk_dev_hash(sap, llc->dev->ifindex);\n\tstruct hlist_nulls_head *laddr_hb = llc_sk_laddr_hash(sap, &llc->laddr);\n\n\tllc_sap_hold(sap);\n\tllc_sk(sk)->sap = sap;\n\n\tspin_lock_bh(&sap->sk_lock);\n\tsap->sk_count++;\n\tsk_nulls_add_node_rcu(sk, laddr_hb);\n\thlist_add_head(&llc->dev_hash_node, dev_hb);\n\tspin_unlock_bh(&sap->sk_lock);\n}\n\n/**\n *\tllc_sap_remove_socket - removes a socket from SAP\n *\t@sap: SAP\n *\t@sk: socket\n *\n *\tThis function removes a connection from the hash tables of a SAP if\n *\tthe connection was in this list.\n */\nvoid llc_sap_remove_socket(struct llc_sap *sap, struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tspin_lock_bh(&sap->sk_lock);\n\tsk_nulls_del_node_init_rcu(sk);\n\thlist_del(&llc->dev_hash_node);\n\tsap->sk_count--;\n\tspin_unlock_bh(&sap->sk_lock);\n\tllc_sap_put(sap);\n}\n\n/**\n *\tllc_conn_rcv - sends received pdus to the connection state machine\n *\t@sk: current connection structure.\n *\t@skb: received frame.\n *\n *\tSends received pdus to the connection state machine.\n */\nstatic int llc_conn_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\tev->type   = LLC_CONN_EV_TYPE_PDU;\n\tev->reason = 0;\n\treturn llc_conn_state_process(sk, skb);\n}\n\nstatic struct sock *llc_create_incoming_sock(struct sock *sk,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     struct llc_addr *saddr,\n\t\t\t\t\t     struct llc_addr *daddr)\n{\n\tstruct sock *newsk = llc_sk_alloc(sock_net(sk), sk->sk_family, GFP_ATOMIC,\n\t\t\t\t\t  sk->sk_prot, 0);\n\tstruct llc_sock *newllc, *llc = llc_sk(sk);\n\n\tif (!newsk)\n\t\tgoto out;\n\tnewllc = llc_sk(newsk);\n\tmemcpy(&newllc->laddr, daddr, sizeof(newllc->laddr));\n\tmemcpy(&newllc->daddr, saddr, sizeof(newllc->daddr));\n\tnewllc->dev = dev;\n\tdev_hold(dev);\n\tllc_sap_add_socket(llc->sap, newsk);\n\tllc_sap_hold(llc->sap);\nout:\n\treturn newsk;\n}\n\nvoid llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr saddr, daddr;\n\tstruct sock *sk;\n\n\tllc_pdu_decode_sa(skb, saddr.mac);\n\tllc_pdu_decode_ssap(skb, &saddr.lsap);\n\tllc_pdu_decode_da(skb, daddr.mac);\n\tllc_pdu_decode_dsap(skb, &daddr.lsap);\n\n\tsk = __llc_lookup(sap, &saddr, &daddr);\n\tif (!sk)\n\t\tgoto drop;\n\n\tbh_lock_sock(sk);\n\t/*\n\t * This has to be done here and not at the upper layer ->accept\n\t * method because of the way the PROCOM state machine works:\n\t * it needs to set several state variables (see, for instance,\n\t * llc_adm_actions_2 in net/llc/llc_c_st.c) and send a packet to\n\t * the originator of the new connection, and this state has to be\n\t * in the newly created struct sock private area. -acme\n\t */\n\tif (unlikely(sk->sk_state == TCP_LISTEN)) {\n\t\tstruct sock *newsk = llc_create_incoming_sock(sk, skb->dev,\n\t\t\t\t\t\t\t      &saddr, &daddr);\n\t\tif (!newsk)\n\t\t\tgoto drop_unlock;\n\t\tskb_set_owner_r(skb, newsk);\n\t} else {\n\t\t/*\n\t\t * Can't be skb_set_owner_r, this will be done at the\n\t\t * llc_conn_state_process function, later on, when we will use\n\t\t * skb_queue_rcv_skb to send it to upper layers, this is\n\t\t * another trick required to cope with how the PROCOM state\n\t\t * machine works. -acme\n\t\t */\n\t\tskb_orphan(skb);\n\t\tsock_hold(sk);\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_efree;\n\t}\n\tif (!sock_owned_by_user(sk))\n\t\tllc_conn_rcv(sk, skb);\n\telse {\n\t\tdprintk(\"%s: adding to backlog...\\n\", __func__);\n\t\tllc_set_backlog_type(skb, LLC_PACKET);\n\t\tif (sk_add_backlog(sk, skb, sk->sk_rcvbuf))\n\t\t\tgoto drop_unlock;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn;\ndrop:\n\tkfree_skb(skb);\n\treturn;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\n#undef LLC_REFCNT_DEBUG\n#ifdef LLC_REFCNT_DEBUG\nstatic atomic_t llc_sock_nr;\n#endif\n\n/**\n *\tllc_backlog_rcv - Processes rx frames and expired timers.\n *\t@sk: LLC sock (p8022 connection)\n *\t@skb: queued rx frame or event\n *\n *\tThis function processes frames that has received and timers that has\n *\texpired during sending an I pdu (refer to data_req_handler).  frames\n *\tqueue by llc_rcv function (llc_mac.c) and timers queue by timer\n *\tcallback functions(llc_c_ac.c).\n */\nstatic int llc_backlog_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc = 0;\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tif (likely(llc_backlog_type(skb) == LLC_PACKET)) {\n\t\tif (likely(llc->state > 1)) /* not closed */\n\t\t\trc = llc_conn_rcv(sk, skb);\n\t\telse\n\t\t\tgoto out_kfree_skb;\n\t} else if (llc_backlog_type(skb) == LLC_EVENT) {\n\t\t/* timer expiration event */\n\t\tif (likely(llc->state > 1))  /* not closed */\n\t\t\trc = llc_conn_state_process(sk, skb);\n\t\telse\n\t\t\tgoto out_kfree_skb;\n\t} else {\n\t\tprintk(KERN_ERR \"%s: invalid skb in backlog\\n\", __func__);\n\t\tgoto out_kfree_skb;\n\t}\nout:\n\treturn rc;\nout_kfree_skb:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\n/**\n *     llc_sk_init - Initializes a socket with default llc values.\n *     @sk: socket to initialize.\n *\n *     Initializes a socket with default llc values.\n */\nstatic void llc_sk_init(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc->state    = LLC_CONN_STATE_ADM;\n\tllc->inc_cntr = llc->dec_cntr = 2;\n\tllc->dec_step = llc->connect_step = 1;\n\n\tsetup_timer(&llc->ack_timer.timer, llc_conn_ack_tmr_cb,\n\t\t\t(unsigned long)sk);\n\tllc->ack_timer.expire\t      = sysctl_llc2_ack_timeout;\n\n\tsetup_timer(&llc->pf_cycle_timer.timer, llc_conn_pf_cycle_tmr_cb,\n\t\t\t(unsigned long)sk);\n\tllc->pf_cycle_timer.expire\t   = sysctl_llc2_p_timeout;\n\n\tsetup_timer(&llc->rej_sent_timer.timer, llc_conn_rej_tmr_cb,\n\t\t\t(unsigned long)sk);\n\tllc->rej_sent_timer.expire\t   = sysctl_llc2_rej_timeout;\n\n\tsetup_timer(&llc->busy_state_timer.timer, llc_conn_busy_tmr_cb,\n\t\t\t(unsigned long)sk);\n\tllc->busy_state_timer.expire\t     = sysctl_llc2_busy_timeout;\n\n\tllc->n2 = 2;   /* max retransmit */\n\tllc->k  = 2;   /* tx win size, will adjust dynam */\n\tllc->rw = 128; /* rx win size (opt and equal to\n\t\t\t* tx_win of remote LLC) */\n\tskb_queue_head_init(&llc->pdu_unack_q);\n\tsk->sk_backlog_rcv = llc_backlog_rcv;\n}\n\n/**\n *\tllc_sk_alloc - Allocates LLC sock\n *\t@family: upper layer protocol family\n *\t@priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)\n *\n *\tAllocates a LLC sock and initializes it. Returns the new LLC sock\n *\tor %NULL if there's no memory available for one\n */\nstruct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)\n{\n\tstruct sock *sk = sk_alloc(net, family, priority, prot, kern);\n\n\tif (!sk)\n\t\tgoto out;\n\tllc_sk_init(sk);\n\tsock_init_data(NULL, sk);\n#ifdef LLC_REFCNT_DEBUG\n\tatomic_inc(&llc_sock_nr);\n\tprintk(KERN_DEBUG \"LLC socket %p created in %s, now we have %d alive\\n\", sk,\n\t\t__func__, atomic_read(&llc_sock_nr));\n#endif\nout:\n\treturn sk;\n}\n\n/**\n *\tllc_sk_free - Frees a LLC socket\n *\t@sk - socket to free\n *\n *\tFrees a LLC socket\n */\nvoid llc_sk_free(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc->state = LLC_CONN_OUT_OF_SVC;\n\t/* Stop all (possibly) running timers */\n\tllc_conn_ac_stop_all_timers(sk, NULL);\n#ifdef DEBUG_LLC_CONN_ALLOC\n\tprintk(KERN_INFO \"%s: unackq=%d, txq=%d\\n\", __func__,\n\t\tskb_queue_len(&llc->pdu_unack_q),\n\t\tskb_queue_len(&sk->sk_write_queue));\n#endif\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&llc->pdu_unack_q);\n#ifdef LLC_REFCNT_DEBUG\n\tif (atomic_read(&sk->sk_refcnt) != 1) {\n\t\tprintk(KERN_DEBUG \"Destruction of LLC sock %p delayed in %s, cnt=%d\\n\",\n\t\t\tsk, __func__, atomic_read(&sk->sk_refcnt));\n\t\tprintk(KERN_DEBUG \"%d LLC sockets are still alive\\n\",\n\t\t\tatomic_read(&llc_sock_nr));\n\t} else {\n\t\tatomic_dec(&llc_sock_nr);\n\t\tprintk(KERN_DEBUG \"LLC socket %p released in %s, %d are still alive\\n\", sk,\n\t\t\t__func__, atomic_read(&llc_sock_nr));\n\t}\n#endif\n\tsock_put(sk);\n}\n\n/**\n *\tllc_sk_reset - resets a connection\n *\t@sk: LLC socket to reset\n *\n *\tResets a connection to the out of service state. Stops its timers\n *\tand frees any frames in the queues of the connection.\n */\nvoid llc_sk_reset(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc_conn_ac_stop_all_timers(sk, NULL);\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&llc->pdu_unack_q);\n\tllc->remote_busy_flag\t= 0;\n\tllc->cause_flag\t\t= 0;\n\tllc->retry_count\t= 0;\n\tllc_conn_set_p_flag(sk, 0);\n\tllc->f_flag\t\t= 0;\n\tllc->s_flag\t\t= 0;\n\tllc->ack_pf\t\t= 0;\n\tllc->first_pdu_Ns\t= 0;\n\tllc->ack_must_be_send\t= 0;\n\tllc->dec_step\t\t= 1;\n\tllc->inc_cntr\t\t= 2;\n\tllc->dec_cntr\t\t= 2;\n\tllc->X\t\t\t= 0;\n\tllc->failed_data_req\t= 0 ;\n\tllc->last_nr\t\t= 0;\n}\n", "/*\n * llc_sap.c - driver routines for SAP component.\n *\n * Copyright (c) 1997 by Procom Technology, Inc.\n * \t\t 2001-2003 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n * This program can be redistributed or modified under the terms of the\n * GNU General Public License as published by the Free Software Foundation.\n * This program is distributed without any warranty or implied warranty\n * of merchantability or fitness for a particular purpose.\n *\n * See the GNU General Public License for more details.\n */\n\n#include <net/llc.h>\n#include <net/llc_if.h>\n#include <net/llc_conn.h>\n#include <net/llc_pdu.h>\n#include <net/llc_sap.h>\n#include <net/llc_s_ac.h>\n#include <net/llc_s_ev.h>\n#include <net/llc_s_st.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/llc.h>\n#include <linux/slab.h>\n\nstatic int llc_mac_header_len(unsigned short devtype)\n{\n\tswitch (devtype) {\n\tcase ARPHRD_ETHER:\n\tcase ARPHRD_LOOPBACK:\n\t\treturn sizeof(struct ethhdr);\n\t}\n\treturn 0;\n}\n\n/**\n *\tllc_alloc_frame - allocates sk_buff for frame\n *\t@dev: network device this skb will be sent over\n *\t@type: pdu type to allocate\n *\t@data_size: data size to allocate\n *\n *\tAllocates an sk_buff for frame and initializes sk_buff fields.\n *\tReturns allocated skb or %NULL when out of memory.\n */\nstruct sk_buff *llc_alloc_frame(struct sock *sk, struct net_device *dev,\n\t\t\t\tu8 type, u32 data_size)\n{\n\tint hlen = type == LLC_PDU_TYPE_U ? 3 : 4;\n\tstruct sk_buff *skb;\n\n\thlen += llc_mac_header_len(dev->type);\n\tskb = alloc_skb(hlen + data_size, GFP_ATOMIC);\n\n\tif (skb) {\n\t\tskb_reset_mac_header(skb);\n\t\tskb_reserve(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb_reset_transport_header(skb);\n\t\tskb->protocol = htons(ETH_P_802_2);\n\t\tskb->dev      = dev;\n\t\tif (sk != NULL)\n\t\t\tskb_set_owner_w(skb, sk);\n\t}\n\treturn skb;\n}\n\nvoid llc_save_primitive(struct sock *sk, struct sk_buff *skb, u8 prim)\n{\n\tstruct sockaddr_llc *addr;\n\n       /* save primitive for use by the user. */\n\taddr\t\t  = llc_ui_skb_cb(skb);\n\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sllc_family = sk->sk_family;\n\taddr->sllc_arphrd = skb->dev->type;\n\taddr->sllc_test   = prim == LLC_TEST_PRIM;\n\taddr->sllc_xid    = prim == LLC_XID_PRIM;\n\taddr->sllc_ua     = prim == LLC_DATAUNIT_PRIM;\n\tllc_pdu_decode_sa(skb, addr->sllc_mac);\n\tllc_pdu_decode_ssap(skb, &addr->sllc_sap);\n}\n\n/**\n *\tllc_sap_rtn_pdu - Informs upper layer on rx of an UI, XID or TEST pdu.\n *\t@sap: pointer to SAP\n *\t@skb: received pdu\n */\nvoid llc_sap_rtn_pdu(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tstruct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);\n\n\tswitch (LLC_U_PDU_RSP(pdu)) {\n\tcase LLC_1_PDU_CMD_TEST:\n\t\tev->prim = LLC_TEST_PRIM;\tbreak;\n\tcase LLC_1_PDU_CMD_XID:\n\t\tev->prim = LLC_XID_PRIM;\tbreak;\n\tcase LLC_1_PDU_CMD_UI:\n\t\tev->prim = LLC_DATAUNIT_PRIM;\tbreak;\n\t}\n\tev->ind_cfm_flag = LLC_IND;\n}\n\n/**\n *\tllc_find_sap_trans - finds transition for event\n *\t@sap: pointer to SAP\n *\t@skb: happened event\n *\n *\tThis function finds transition that matches with happened event.\n *\tReturns the pointer to found transition on success or %NULL for\n *\tfailure.\n */\nstatic struct llc_sap_state_trans *llc_find_sap_trans(struct llc_sap *sap,\n\t\t\t\t\t\t      struct sk_buff *skb)\n{\n\tint i = 0;\n\tstruct llc_sap_state_trans *rc = NULL;\n\tstruct llc_sap_state_trans **next_trans;\n\tstruct llc_sap_state *curr_state = &llc_sap_state_table[sap->state - 1];\n\t/*\n\t * Search thru events for this state until list exhausted or until\n\t * its obvious the event is not valid for the current state\n\t */\n\tfor (next_trans = curr_state->transitions; next_trans[i]->ev; i++)\n\t\tif (!next_trans[i]->ev(sap, skb)) {\n\t\t\trc = next_trans[i]; /* got event match; return it */\n\t\t\tbreak;\n\t\t}\n\treturn rc;\n}\n\n/**\n *\tllc_exec_sap_trans_actions - execute actions related to event\n *\t@sap: pointer to SAP\n *\t@trans: pointer to transition that it's actions must be performed\n *\t@skb: happened event.\n *\n *\tThis function executes actions that is related to happened event.\n *\tReturns 0 for success and 1 for failure of at least one action.\n */\nstatic int llc_exec_sap_trans_actions(struct llc_sap *sap,\n\t\t\t\t      struct llc_sap_state_trans *trans,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tint rc = 0;\n\tconst llc_sap_action_t *next_action = trans->ev_actions;\n\n\tfor (; next_action && *next_action; next_action++)\n\t\tif ((*next_action)(sap, skb))\n\t\t\trc = 1;\n\treturn rc;\n}\n\n/**\n *\tllc_sap_next_state - finds transition, execs actions & change SAP state\n *\t@sap: pointer to SAP\n *\t@skb: happened event\n *\n *\tThis function finds transition that matches with happened event, then\n *\texecutes related actions and finally changes state of SAP. It returns\n *\t0 on success and 1 for failure.\n */\nstatic int llc_sap_next_state(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tint rc = 1;\n\tstruct llc_sap_state_trans *trans;\n\n\tif (sap->state > LLC_NR_SAP_STATES)\n\t\tgoto out;\n\ttrans = llc_find_sap_trans(sap, skb);\n\tif (!trans)\n\t\tgoto out;\n\t/*\n\t * Got the state to which we next transition; perform the actions\n\t * associated with this transition before actually transitioning to the\n\t * next state\n\t */\n\trc = llc_exec_sap_trans_actions(sap, trans, skb);\n\tif (rc)\n\t\tgoto out;\n\t/*\n\t * Transition SAP to next state if all actions execute successfully\n\t */\n\tsap->state = trans->next_state;\nout:\n\treturn rc;\n}\n\n/**\n *\tllc_sap_state_process - sends event to SAP state machine\n *\t@sap: sap to use\n *\t@skb: pointer to occurred event\n *\n *\tAfter executing actions of the event, upper layer will be indicated\n *\tif needed(on receiving an UI frame). sk can be null for the\n *\tdatalink_proto case.\n */\nstatic void llc_sap_state_process(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\t/*\n\t * We have to hold the skb, because llc_sap_next_state\n\t * will kfree it in the sending path and we need to\n\t * look at the skb->cb, where we encode llc_sap_state_ev.\n\t */\n\tskb_get(skb);\n\tev->ind_cfm_flag = 0;\n\tllc_sap_next_state(sap, skb);\n\tif (ev->ind_cfm_flag == LLC_IND) {\n\t\tif (skb->sk->sk_state == TCP_LISTEN)\n\t\t\tkfree_skb(skb);\n\t\telse {\n\t\t\tllc_save_primitive(skb->sk, skb, ev->prim);\n\n\t\t\t/* queue skb to the user. */\n\t\t\tif (sock_queue_rcv_skb(skb->sk, skb))\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\tkfree_skb(skb);\n}\n\n/**\n *\tllc_build_and_send_test_pkt - TEST interface for upper layers.\n *\t@sap: sap to use\n *\t@skb: packet to send\n *\t@dmac: destination mac address\n *\t@dsap: destination sap\n *\n *\tThis function is called when upper layer wants to send a TEST pdu.\n *\tReturns 0 for success, 1 otherwise.\n */\nvoid llc_build_and_send_test_pkt(struct llc_sap *sap,\n\t\t\t\t struct sk_buff *skb, u8 *dmac, u8 dsap)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->saddr.lsap = sap->laddr.lsap;\n\tev->daddr.lsap = dsap;\n\tmemcpy(ev->saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(ev->daddr.mac, dmac, IFHWADDRLEN);\n\n\tev->type      = LLC_SAP_EV_TYPE_PRIM;\n\tev->prim      = LLC_TEST_PRIM;\n\tev->prim_type = LLC_PRIM_TYPE_REQ;\n\tllc_sap_state_process(sap, skb);\n}\n\n/**\n *\tllc_build_and_send_xid_pkt - XID interface for upper layers\n *\t@sap: sap to use\n *\t@skb: packet to send\n *\t@dmac: destination mac address\n *\t@dsap: destination sap\n *\n *\tThis function is called when upper layer wants to send a XID pdu.\n *\tReturns 0 for success, 1 otherwise.\n */\nvoid llc_build_and_send_xid_pkt(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\t\tu8 *dmac, u8 dsap)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->saddr.lsap = sap->laddr.lsap;\n\tev->daddr.lsap = dsap;\n\tmemcpy(ev->saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(ev->daddr.mac, dmac, IFHWADDRLEN);\n\n\tev->type      = LLC_SAP_EV_TYPE_PRIM;\n\tev->prim      = LLC_XID_PRIM;\n\tev->prim_type = LLC_PRIM_TYPE_REQ;\n\tllc_sap_state_process(sap, skb);\n}\n\n/**\n *\tllc_sap_rcv - sends received pdus to the sap state machine\n *\t@sap: current sap component structure.\n *\t@skb: received frame.\n *\n *\tSends received pdus to the sap state machine.\n */\nstatic void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->type   = LLC_SAP_EV_TYPE_PDU;\n\tev->reason = 0;\n\tskb_orphan(skb);\n\tsock_hold(sk);\n\tskb->sk = sk;\n\tskb->destructor = sock_efree;\n\tllc_sap_state_process(sap, skb);\n}\n\nstatic inline bool llc_dgram_match(const struct llc_sap *sap,\n\t\t\t\t   const struct llc_addr *laddr,\n\t\t\t\t   const struct sock *sk)\n{\n     struct llc_sock *llc = llc_sk(sk);\n\n     return sk->sk_type == SOCK_DGRAM &&\n\t  llc->laddr.lsap == laddr->lsap &&\n\t  ether_addr_equal(llc->laddr.mac, laddr->mac);\n}\n\n/**\n *\tllc_lookup_dgram - Finds dgram socket for the local sap/mac\n *\t@sap: SAP\n *\t@laddr: address of local LLC (MAC + SAP)\n *\n *\tSearch socket list of the SAP and finds connection using the local\n *\tmac, and local sap. Returns pointer for socket found, %NULL otherwise.\n */\nstatic struct sock *llc_lookup_dgram(struct llc_sap *sap,\n\t\t\t\t     const struct llc_addr *laddr)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock_bh();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_dgram_match(sap, laddr, rc)) {\n\t\t\t/* Extra checks required by SLAB_DESTROY_BY_RCU */\n\t\t\tif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_dgram_match(sap, laddr, rc))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock_bh();\n\treturn rc;\n}\n\nstatic inline bool llc_mcast_match(const struct llc_sap *sap,\n\t\t\t\t   const struct llc_addr *laddr,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   const struct sock *sk)\n{\n     struct llc_sock *llc = llc_sk(sk);\n\n     return sk->sk_type == SOCK_DGRAM &&\n\t  llc->laddr.lsap == laddr->lsap &&\n\t  llc->dev == skb->dev;\n}\n\nstatic void llc_do_mcast(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\t struct sock **stack, int count)\n{\n\tstruct sk_buff *skb1;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tskb1 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb1) {\n\t\t\tsock_put(stack[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tllc_sap_rcv(sap, skb1, stack[i]);\n\t\tsock_put(stack[i]);\n\t}\n}\n\n/**\n * \tllc_sap_mcast - Deliver multicast PDU's to all matching datagram sockets.\n *\t@sap: SAP\n *\t@laddr: address of local LLC (MAC + SAP)\n *\n *\tSearch socket list of the SAP and finds connections with same sap.\n *\tDeliver clone to each.\n */\nstatic void llc_sap_mcast(struct llc_sap *sap,\n\t\t\t  const struct llc_addr *laddr,\n\t\t\t  struct sk_buff *skb)\n{\n\tint i = 0, count = 256 / sizeof(struct sock *);\n\tstruct sock *sk, *stack[count];\n\tstruct llc_sock *llc;\n\tstruct hlist_head *dev_hb = llc_sk_dev_hash(sap, skb->dev->ifindex);\n\n\tspin_lock_bh(&sap->sk_lock);\n\thlist_for_each_entry(llc, dev_hb, dev_hash_node) {\n\n\t\tsk = &llc->sk;\n\n\t\tif (!llc_mcast_match(sap, laddr, skb, sk))\n\t\t\tcontinue;\n\n\t\tsock_hold(sk);\n\t\tif (i < count)\n\t\t\tstack[i++] = sk;\n\t\telse {\n\t\t\tllc_do_mcast(sap, skb, stack, i);\n\t\t\ti = 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&sap->sk_lock);\n\n\tllc_do_mcast(sap, skb, stack, i);\n}\n\n\nvoid llc_sap_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr laddr;\n\n\tllc_pdu_decode_da(skb, laddr.mac);\n\tllc_pdu_decode_dsap(skb, &laddr.lsap);\n\n\tif (is_multicast_ether_addr(laddr.mac)) {\n\t\tllc_sap_mcast(sap, &laddr, skb);\n\t\tkfree_skb(skb);\n\t} else {\n\t\tstruct sock *sk = llc_lookup_dgram(sap, &laddr);\n\t\tif (sk) {\n\t\t\tllc_sap_rcv(sap, skb, sk);\n\t\t\tsock_put(sk);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n}\n"], "filenames": ["net/llc/llc_conn.c", "net/llc/llc_sap.c"], "buggy_code_start_loc": [823, 292], "buggy_code_end_loc": [824, 293], "fixing_code_start_loc": [824, 293], "fixing_code_end_loc": [828, 297], "type": "CWE-20", "message": "The LLC subsystem in the Linux kernel before 4.9.13 does not ensure that a certain destructor exists in required circumstances, which allows local users to cause a denial of service (BUG_ON) or possibly have unspecified other impact via crafted system calls.", "other": {"cve": {"id": "CVE-2017-6345", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-01T20:59:00.330", "lastModified": "2018-08-24T10:29:02.630", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The LLC subsystem in the Linux kernel before 4.9.13 does not ensure that a certain destructor exists in required circumstances, which allows local users to cause a denial of service (BUG_ON) or possibly have unspecified other impact via crafted system calls."}, {"lang": "es", "value": "El subsistema LLC en el kernel de Linux en versiones anteriores a 4.9.13 no garantiza que exista cierto destructor en las circunstancias requeridas, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (BUG_ON) o posiblemente tener otro impacto no especificado a trav\u00e9s de llamadas al sistema manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.9.12", "matchCriteriaId": "BDE2E7F2-434A-4283-B0EA-25ACBCF7C4BF"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8b74d439e1697110c5e5c600643e823eb1dd0762", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.debian.org/security/2017/dsa-3804", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.13", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/28/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96510", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762"}}