{"buggy_code": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nBottle is a fast and simple micro-framework for small web applications. It\noffers request dispatching (Routes) with URL parameter support, templates,\na built-in HTTP Server and adapters for many third party WSGI/HTTP-server and\ntemplate engines - all in a single file and with no dependencies other than the\nPython Standard Library.\n\nHomepage and documentation: http://bottlepy.org/\n\nCopyright (c) 2015, Marcel Hellkamp.\nLicense: MIT (see LICENSE for details)\n\"\"\"\n\nimport sys\n\n__author__ = 'Marcel Hellkamp'\n__version__ = '0.13-dev'\n__license__ = 'MIT'\n\n###############################################################################\n# Command-line interface ######################################################\n###############################################################################\n# INFO: Some server adapters need to monkey-patch std-lib modules before they\n# are imported. This is why some of the command-line handling is done here, but\n# the actual call to _main() is at the end of the file.\n\n\ndef _cli_parse(args):  # pragma: no coverage\n    from argparse import ArgumentParser\n\n    parser = ArgumentParser(usage=\"usage: %sprog [options] package.module:app\")\n    opt = parser.add_argument\n    opt('app', help='WSGI app entry point.')\n    opt(\"--version\", action=\"store_true\", help=\"show version number.\")\n    opt(\"-b\", \"--bind\", metavar=\"ADDRESS\", help=\"bind socket to ADDRESS.\")\n    opt(\"-s\", \"--server\", default='wsgiref', help=\"use SERVER as backend.\")\n    opt(\"-p\", \"--plugin\", action=\"append\", help=\"install additional plugin/s.\")\n    opt(\"-c\", \"--conf\", action=\"append\", metavar=\"FILE\",\n        help=\"load config values from FILE.\")\n    opt(\"-C\", \"--param\", action=\"append\", metavar=\"NAME=VALUE\",\n        help=\"override config values.\")\n    opt(\"--debug\", action=\"store_true\", help=\"start server in debug mode.\")\n    opt(\"--reload\", action=\"store_true\", help=\"auto-reload on file changes.\")\n\n    cli_args = parser.parse_args(args)\n\n    return cli_args, parser\n\n\ndef _cli_patch(cli_args):  # pragma: no coverage\n    parsed_args, _ = _cli_parse(cli_args)\n    opts = parsed_args\n    if opts.server:\n        if opts.server.startswith('gevent'):\n            import gevent.monkey\n            gevent.monkey.patch_all()\n        elif opts.server.startswith('eventlet'):\n            import eventlet\n            eventlet.monkey_patch()\n\n\nif __name__ == '__main__':\n    _cli_patch(sys.argv)\n\n###############################################################################\n# Imports and Python 2/3 unification ##########################################\n###############################################################################\n\n\nimport base64, cgi, email.utils, functools, hmac, imp, itertools, mimetypes,\\\n        os, re, tempfile, threading, time, warnings, weakref, hashlib\n\nfrom types import FunctionType\nfrom datetime import date as datedate, datetime, timedelta\nfrom tempfile import TemporaryFile\nfrom traceback import format_exc, print_exc\nfrom unicodedata import normalize\nfrom json import dumps as json_dumps, loads as json_lds\n\n# inspect.getargspec was removed in Python 3.6, use\n# Signature-based version where we can (Python 3.3+)\ntry:\n    from inspect import signature\n    def getargspec(func):\n        params = signature(func).parameters\n        args, varargs, keywords, defaults = [], None, None, []\n        for name, param in params.items():\n            if param.kind == param.VAR_POSITIONAL:\n                varargs = name\n            elif param.kind == param.VAR_KEYWORD:\n                keywords = name\n            else:\n                args.append(name)\n                if param.default is not param.empty:\n                    defaults.append(param.default)\n        return (args, varargs, keywords, tuple(defaults) or None)\nexcept ImportError:\n    try:\n        from inspect import getfullargspec\n        def getargspec(func):\n            spec = getfullargspec(func)\n            kwargs = makelist(spec[0]) + makelist(spec.kwonlyargs)\n            return kwargs, spec[1], spec[2], spec[3]\n    except ImportError:\n        from inspect import getargspec\n\npy3k = sys.version_info.major > 2\n\n\n# Workaround for the \"print is a keyword/function\" Python 2/3 dilemma\n# and a fallback for mod_wsgi (resticts stdout/err attribute access)\ntry:\n    _stdout, _stderr = sys.stdout.write, sys.stderr.write\nexcept IOError:\n    _stdout = lambda x: sys.stdout.write(x)\n    _stderr = lambda x: sys.stderr.write(x)\n\n# Lots of stdlib and builtin differences.\nif py3k:\n    import http.client as httplib\n    import _thread as thread\n    from urllib.parse import urljoin, SplitResult as UrlSplitResult\n    from urllib.parse import urlencode, quote as urlquote, unquote as urlunquote\n    urlunquote = functools.partial(urlunquote, encoding='latin1')\n    from http.cookies import SimpleCookie\n    from collections import MutableMapping as DictMixin\n    import pickle\n    from io import BytesIO\n    import configparser\n\n    basestring = str\n    unicode = str\n    json_loads = lambda s: json_lds(touni(s))\n    callable = lambda x: hasattr(x, '__call__')\n    imap = map\n\n    def _raise(*a):\n        raise a[0](a[1]).with_traceback(a[2])\nelse:  # 2.x\n    import httplib\n    import thread\n    from urlparse import urljoin, SplitResult as UrlSplitResult\n    from urllib import urlencode, quote as urlquote, unquote as urlunquote\n    from Cookie import SimpleCookie\n    from itertools import imap\n    import cPickle as pickle\n    from StringIO import StringIO as BytesIO\n    import ConfigParser as configparser\n    from collections import MutableMapping as DictMixin\n    unicode = unicode\n    json_loads = json_lds\n    exec(compile('def _raise(*a): raise a[0], a[1], a[2]', '<py3fix>', 'exec'))\n\n# Some helpers for string/byte handling\ndef tob(s, enc='utf8'):\n    return s.encode(enc) if isinstance(s, unicode) else bytes(s)\n\n\ndef touni(s, enc='utf8', err='strict'):\n    if isinstance(s, bytes):\n        return s.decode(enc, err)\n    else:\n        return unicode(s or (\"\" if s is None else s))\n\n\ntonat = touni if py3k else tob\n\n# 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).\n\n\n# A bug in functools causes it to break if the wrapper is an instance method\ndef update_wrapper(wrapper, wrapped, *a, **ka):\n    try:\n        functools.update_wrapper(wrapper, wrapped, *a, **ka)\n    except AttributeError:\n        pass\n\n# These helpers are used at module level and need to be defined first.\n# And yes, I know PEP-8, but sometimes a lower-case classname makes more sense.\n\n\ndef depr(major, minor, cause, fix):\n    text = \"Warning: Use of deprecated feature or API. (Deprecated in Bottle-%d.%d)\\n\"\\\n           \"Cause: %s\\n\"\\\n           \"Fix: %s\\n\" % (major, minor, cause, fix)\n    if DEBUG == 'strict':\n        raise DeprecationWarning(text)\n    warnings.warn(text, DeprecationWarning, stacklevel=3)\n    return DeprecationWarning(text)\n\n\ndef makelist(data):  # This is just too handy\n    if isinstance(data, (tuple, list, set, dict)):\n        return list(data)\n    elif data:\n        return [data]\n    else:\n        return []\n\n\nclass DictProperty(object):\n    \"\"\" Property that maps to a key in a local dict-like attribute. \"\"\"\n\n    def __init__(self, attr, key=None, read_only=False):\n        self.attr, self.key, self.read_only = attr, key, read_only\n\n    def __call__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter, self.key = func, self.key or func.__name__\n        return self\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        key, storage = self.key, getattr(obj, self.attr)\n        if key not in storage: storage[key] = self.getter(obj)\n        return storage[key]\n\n    def __set__(self, obj, value):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        getattr(obj, self.attr)[self.key] = value\n\n    def __delete__(self, obj):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        del getattr(obj, self.attr)[self.key]\n\n\nclass cached_property(object):\n    \"\"\" A property that is only computed once per instance and then replaces\n        itself with an ordinary attribute. Deleting the attribute resets the\n        property. \"\"\"\n\n    def __init__(self, func):\n        update_wrapper(self, func)\n        self.func = func\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value\n\n\nclass lazy_attribute(object):\n    \"\"\" A property that caches itself to the class object. \"\"\"\n\n    def __init__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter = func\n\n    def __get__(self, obj, cls):\n        value = self.getter(cls)\n        setattr(cls, self.__name__, value)\n        return value\n\n###############################################################################\n# Exceptions and Events #######################################################\n###############################################################################\n\n\nclass BottleException(Exception):\n    \"\"\" A base class for exceptions used by bottle. \"\"\"\n    pass\n\n###############################################################################\n# Routing ######################################################################\n###############################################################################\n\n\nclass RouteError(BottleException):\n    \"\"\" This is a base class for all routing related exceptions \"\"\"\n\n\nclass RouteReset(BottleException):\n    \"\"\" If raised by a plugin or request handler, the route is reset and all\n        plugins are re-applied. \"\"\"\n\n\nclass RouterUnknownModeError(RouteError):\n\n    pass\n\n\nclass RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\n\n\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\n\n\ndef _re_flatten(p):\n    \"\"\" Turn all capturing groups in a regular expression pattern into\n        non-capturing groups. \"\"\"\n    if '(' not in p:\n        return p\n    return re.sub(r'(\\\\*)(\\(\\?P<[^>]+>|\\((?!\\?))', lambda m: m.group(0) if\n                  len(m.group(1)) % 2 else m.group(1) + '(?:', p)\n\n\nclass Router(object):\n    \"\"\" A Router is an ordered collection of route->target pairs. It is used to\n        efficiently match WSGI requests against a number of routes and return\n        the first target that satisfies the request. The target may be anything,\n        usually a string, ID or callable object. A route consists of a path-rule\n        and a HTTP method.\n\n        The path-rule is either a static path (e.g. `/contact`) or a dynamic\n        path that contains wildcards (e.g. `/wiki/<page>`). The wildcard syntax\n        and details on the matching order are described in docs:`routing`.\n    \"\"\"\n\n    default_pattern = '[^/]+'\n    default_filter = 're'\n\n    #: The current CPython regexp implementation does not allow more\n    #: than 99 matching groups per regular expression.\n    _MAX_GROUPS_PER_PATTERN = 99\n\n    def __init__(self, strict=False):\n        self.rules = []  # All rules in order\n        self._groups = {}  # index of regexes to find them in dyna_routes\n        self.builder = {}  # Data structure for the url builder\n        self.static = {}  # Search structure for static routes\n        self.dyna_routes = {}\n        self.dyna_regexes = {}  # Search structure for dynamic routes\n        #: If true, static routes are no longer checked first.\n        self.strict_order = strict\n        self.filters = {\n            're': lambda conf: (_re_flatten(conf or self.default_pattern),\n                                None, None),\n            'int': lambda conf: (r'-?\\d+', int, lambda x: str(int(x))),\n            'float': lambda conf: (r'-?[\\d.]+', float, lambda x: str(float(x))),\n            'path': lambda conf: (r'.+?', None, None)\n        }\n\n    def add_filter(self, name, func):\n        \"\"\" Add a filter. The provided function is called with the configuration\n        string as parameter and must return a (regexp, to_python, to_url) tuple.\n        The first element is a string, the last two are callables or None. \"\"\"\n        self.filters[name] = func\n\n    rule_syntax = re.compile('(\\\\\\\\*)'\n        '(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:#(.*?)#)?)'\n          '|(?:<([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)'\n            '(?::((?:\\\\\\\\.|[^\\\\\\\\>]+)+)?)?)?>))')\n\n    def _itertokens(self, rule):\n        offset, prefix = 0, ''\n        for match in self.rule_syntax.finditer(rule):\n            prefix += rule[offset:match.start()]\n            g = match.groups()\n            if g[2] is not None:\n                depr(0, 13, \"Use of old route syntax.\",\n                            \"Use <name> instead of :name in routes.\")\n            if len(g[0]) % 2:  # Escaped wildcard\n                prefix += match.group(0)[len(g[0]):]\n                offset = match.end()\n                continue\n            if prefix:\n                yield prefix, None, None\n            name, filtr, conf = g[4:7] if g[2] is None else g[1:4]\n            yield name, filtr or 'default', conf or None\n            offset, prefix = match.end(), ''\n        if offset <= len(rule) or prefix:\n            yield prefix + rule[offset:], None, None\n\n    def add(self, rule, method, target, name=None):\n        \"\"\" Add a new rule or replace the target for an existing rule. \"\"\"\n        anons = 0  # Number of anonymous wildcards found\n        keys = []  # Names of keys\n        pattern = ''  # Regular expression pattern with named groups\n        filters = []  # Lists of wildcard input filters\n        builder = []  # Data structure for the URL builder\n        is_static = True\n\n        for key, mode, conf in self._itertokens(rule):\n            if mode:\n                is_static = False\n                if mode == 'default': mode = self.default_filter\n                mask, in_filter, out_filter = self.filters[mode](conf)\n                if not key:\n                    pattern += '(?:%s)' % mask\n                    key = 'anon%d' % anons\n                    anons += 1\n                else:\n                    pattern += '(?P<%s>%s)' % (key, mask)\n                    keys.append(key)\n                if in_filter: filters.append((key, in_filter))\n                builder.append((key, out_filter or str))\n            elif key:\n                pattern += re.escape(key)\n                builder.append((None, key))\n\n        self.builder[rule] = builder\n        if name: self.builder[name] = builder\n\n        if is_static and not self.strict_order:\n            self.static.setdefault(method, {})\n            self.static[method][self.build(rule)] = (target, None)\n            return\n\n        try:\n            re_pattern = re.compile('^(%s)$' % pattern)\n            re_match = re_pattern.match\n        except re.error as e:\n            raise RouteSyntaxError(\"Could not add Route: %s (%s)\" % (rule, e))\n\n        if filters:\n\n            def getargs(path):\n                url_args = re_match(path).groupdict()\n                for name, wildcard_filter in filters:\n                    try:\n                        url_args[name] = wildcard_filter(url_args[name])\n                    except ValueError:\n                        raise HTTPError(400, 'Path has wrong format.')\n                return url_args\n        elif re_pattern.groupindex:\n\n            def getargs(path):\n                return re_match(path).groupdict()\n        else:\n            getargs = None\n\n        flatpat = _re_flatten(pattern)\n        whole_rule = (rule, flatpat, target, getargs)\n\n        if (flatpat, method) in self._groups:\n            if DEBUG:\n                msg = 'Route <%s %s> overwrites a previously defined route'\n                warnings.warn(msg % (method, rule), RuntimeWarning)\n            self.dyna_routes[method][\n                self._groups[flatpat, method]] = whole_rule\n        else:\n            self.dyna_routes.setdefault(method, []).append(whole_rule)\n            self._groups[flatpat, method] = len(self.dyna_routes[method]) - 1\n\n        self._compile(method)\n\n    def _compile(self, method):\n        all_rules = self.dyna_routes[method]\n        comborules = self.dyna_regexes[method] = []\n        maxgroups = self._MAX_GROUPS_PER_PATTERN\n        for x in range(0, len(all_rules), maxgroups):\n            some = all_rules[x:x + maxgroups]\n            combined = (flatpat for (_, flatpat, _, _) in some)\n            combined = '|'.join('(^%s$)' % flatpat for flatpat in combined)\n            combined = re.compile(combined).match\n            rules = [(target, getargs) for (_, _, target, getargs) in some]\n            comborules.append((combined, rules))\n\n    def build(self, _name, *anons, **query):\n        \"\"\" Build an URL by filling the wildcards in a rule. \"\"\"\n        builder = self.builder.get(_name)\n        if not builder:\n            raise RouteBuildError(\"No route with that name.\", _name)\n        try:\n            for i, value in enumerate(anons):\n                query['anon%d' % i] = value\n            url = ''.join([f(query.pop(n)) if n else f for (n, f) in builder])\n            return url if not query else url + '?' + urlencode(query)\n        except KeyError as E:\n            raise RouteBuildError('Missing URL argument: %r' % E.args[0])\n\n    def match(self, environ):\n        \"\"\" Return a (target, url_args) tuple or raise HTTPError(400/404/405). \"\"\"\n        verb = environ['REQUEST_METHOD'].upper()\n        path = environ['PATH_INFO'] or '/'\n\n        if verb == 'HEAD':\n            methods = ['PROXY', verb, 'GET', 'ANY']\n        else:\n            methods = ['PROXY', verb, 'ANY']\n\n        for method in methods:\n            if method in self.static and path in self.static[method]:\n                target, getargs = self.static[method][path]\n                return target, getargs(path) if getargs else {}\n            elif method in self.dyna_regexes:\n                for combined, rules in self.dyna_regexes[method]:\n                    match = combined(path)\n                    if match:\n                        target, getargs = rules[match.lastindex - 1]\n                        return target, getargs(path) if getargs else {}\n\n        # No matching route found. Collect alternative methods for 405 response\n        allowed = set([])\n        nocheck = set(methods)\n        for method in set(self.static) - nocheck:\n            if path in self.static[method]:\n                allowed.add(verb)\n        for method in set(self.dyna_regexes) - allowed - nocheck:\n            for combined, rules in self.dyna_regexes[method]:\n                match = combined(path)\n                if match:\n                    allowed.add(method)\n        if allowed:\n            allow_header = \",\".join(sorted(allowed))\n            raise HTTPError(405, \"Method not allowed.\", Allow=allow_header)\n\n        # No matching route and no alternative method found. We give up\n        raise HTTPError(404, \"Not found: \" + repr(path))\n\n\nclass Route(object):\n    \"\"\" This class wraps a route callback along with route specific metadata and\n        configuration and applies Plugins on demand. It is also responsible for\n        turing an URL path rule into a regular expression usable by the Router.\n    \"\"\"\n\n    def __init__(self, app, rule, method, callback,\n                 name=None,\n                 plugins=None,\n                 skiplist=None, **config):\n        #: The application this route is installed to.\n        self.app = app\n        #: The path-rule string (e.g. ``/wiki/<page>``).\n        self.rule = rule\n        #: The HTTP method as a string (e.g. ``GET``).\n        self.method = method\n        #: The original callback with no plugins applied. Useful for introspection.\n        self.callback = callback\n        #: The name of the route (if specified) or ``None``.\n        self.name = name or None\n        #: A list of route-specific plugins (see :meth:`Bottle.route`).\n        self.plugins = plugins or []\n        #: A list of plugins to not apply to this route (see :meth:`Bottle.route`).\n        self.skiplist = skiplist or []\n        #: Additional keyword arguments passed to the :meth:`Bottle.route`\n        #: decorator are stored in this dictionary. Used for route-specific\n        #: plugin configuration and meta-data.\n        self.config = app.config._make_overlay()\n        self.config.load_dict(config)\n\n    @cached_property\n    def call(self):\n        \"\"\" The route callback with all plugins applied. This property is\n            created on demand and then cached to speed up subsequent requests.\"\"\"\n        return self._make_callback()\n\n    def reset(self):\n        \"\"\" Forget any cached values. The next time :attr:`call` is accessed,\n            all plugins are re-applied. \"\"\"\n        self.__dict__.pop('call', None)\n\n    def prepare(self):\n        \"\"\" Do all on-demand work immediately (useful for debugging).\"\"\"\n        self.call\n\n    def all_plugins(self):\n        \"\"\" Yield all Plugins affecting this route. \"\"\"\n        unique = set()\n        for p in reversed(self.app.plugins + self.plugins):\n            if True in self.skiplist: break\n            name = getattr(p, 'name', False)\n            if name and (name in self.skiplist or name in unique): continue\n            if p in self.skiplist or type(p) in self.skiplist: continue\n            if name: unique.add(name)\n            yield p\n\n    def _make_callback(self):\n        callback = self.callback\n        for plugin in self.all_plugins():\n            try:\n                if hasattr(plugin, 'apply'):\n                    callback = plugin.apply(callback, self)\n                else:\n                    callback = plugin(callback)\n            except RouteReset:  # Try again with changed configuration.\n                return self._make_callback()\n            if not callback is self.callback:\n                update_wrapper(callback, self.callback)\n        return callback\n\n    def get_undecorated_callback(self):\n        \"\"\" Return the callback. If the callback is a decorated function, try to\n            recover the original function. \"\"\"\n        func = self.callback\n        func = getattr(func, '__func__' if py3k else 'im_func', func)\n        closure_attr = '__closure__' if py3k else 'func_closure'\n        while hasattr(func, closure_attr) and getattr(func, closure_attr):\n            attributes = getattr(func, closure_attr)\n            func = attributes[0].cell_contents\n\n            # in case of decorators with multiple arguments\n            if not isinstance(func, FunctionType):\n                # pick first FunctionType instance from multiple arguments\n                func = filter(lambda x: isinstance(x, FunctionType),\n                              map(lambda x: x.cell_contents, attributes))\n                func = list(func)[0]  # py3 support\n        return func\n\n    def get_callback_args(self):\n        \"\"\" Return a list of argument names the callback (most likely) accepts\n            as keyword arguments. If the callback is a decorated function, try\n            to recover the original function before inspection. \"\"\"\n        return getargspec(self.get_undecorated_callback())[0]\n\n    def get_config(self, key, default=None):\n        \"\"\" Lookup a config field and return its value, first checking the\n            route.config, then route.app.config.\"\"\"\n        depr(0, 13, \"Route.get_config() is deprectated.\",\n                    \"The Route.config property already includes values from the\"\n                    \" application config for missing keys. Access it directly.\")\n        return self.config.get(key, default)\n\n    def __repr__(self):\n        cb = self.get_undecorated_callback()\n        return '<%s %r %r>' % (self.method, self.rule, cb)\n\n###############################################################################\n# Application Object ###########################################################\n###############################################################################\n\n\nclass Bottle(object):\n    \"\"\" Each Bottle object represents a single, distinct web application and\n        consists of routes, callbacks, plugins, resources and configuration.\n        Instances are callable WSGI applications.\n\n        :param catchall: If true (default), handle all exceptions. Turn off to\n                         let debugging middleware handle exceptions.\n    \"\"\"\n\n    @lazy_attribute\n    def _global_config(cls):\n        cfg = ConfigDict()\n        cfg.meta_set('catchall', 'validate', bool)\n        return cfg\n\n    def __init__(self, **kwargs):\n        #: A :class:`ConfigDict` for app specific configuration.\n        self.config = self._global_config._make_overlay()\n        self.config._add_change_listener(\n            functools.partial(self.trigger_hook, 'config'))\n\n        self.config.update({\n            \"catchall\": True\n        })\n\n        if kwargs.get('catchall') is False:\n            depr(0,13, \"Bottle(catchall) keyword argument.\",\n                        \"The 'catchall' setting is now part of the app \"\n                        \"configuration. Fix: `app.config['catchall'] = False`\")\n            self.config['catchall'] = False\n        if kwargs.get('autojson') is False:\n            depr(0, 13, \"Bottle(autojson) keyword argument.\",\n                 \"The 'autojson' setting is now part of the app \"\n                 \"configuration. Fix: `app.config['json.enable'] = False`\")\n            self.config['json.disable'] = True\n\n        self._mounts = []\n\n        #: A :class:`ResourceManager` for application files\n        self.resources = ResourceManager()\n\n        self.routes = []  # List of installed :class:`Route` instances.\n        self.router = Router()  # Maps requests to :class:`Route` instances.\n        self.error_handler = {}\n\n        # Core plugins\n        self.plugins = []  # List of installed plugins.\n        self.install(JSONPlugin())\n        self.install(TemplatePlugin())\n\n    #: If true, most exceptions are caught and returned as :exc:`HTTPError`\n    catchall = DictProperty('config', 'catchall')\n\n    __hook_names = 'before_request', 'after_request', 'app_reset', 'config'\n    __hook_reversed = {'after_request'}\n\n    @cached_property\n    def _hooks(self):\n        return dict((name, []) for name in self.__hook_names)\n\n    def add_hook(self, name, func):\n        \"\"\" Attach a callback to a hook. Three hooks are currently implemented:\n\n            before_request\n                Executed once before each request. The request context is\n                available, but no routing has happened yet.\n            after_request\n                Executed once after each request regardless of its outcome.\n            app_reset\n                Called whenever :meth:`Bottle.reset` is called.\n        \"\"\"\n        if name in self.__hook_reversed:\n            self._hooks[name].insert(0, func)\n        else:\n            self._hooks[name].append(func)\n\n    def remove_hook(self, name, func):\n        \"\"\" Remove a callback from a hook. \"\"\"\n        if name in self._hooks and func in self._hooks[name]:\n            self._hooks[name].remove(func)\n            return True\n\n    def trigger_hook(self, __name, *args, **kwargs):\n        \"\"\" Trigger a hook and return a list of results. \"\"\"\n        return [hook(*args, **kwargs) for hook in self._hooks[__name][:]]\n\n    def hook(self, name):\n        \"\"\" Return a decorator that attaches a callback to a hook. See\n            :meth:`add_hook` for details.\"\"\"\n\n        def decorator(func):\n            self.add_hook(name, func)\n            return func\n\n        return decorator\n\n    def _mount_wsgi(self, prefix, app, **options):\n        segments = [p for p in prefix.split('/') if p]\n        if not segments:\n            raise ValueError('WSGI applications cannot be mounted to \"/\".')\n        path_depth = len(segments)\n\n        def mountpoint_wrapper():\n            try:\n                request.path_shift(path_depth)\n                rs = HTTPResponse([])\n\n                def start_response(status, headerlist, exc_info=None):\n                    if exc_info:\n                        _raise(*exc_info)\n                    rs.status = status\n                    for name, value in headerlist:\n                        rs.add_header(name, value)\n                    return rs.body.append\n\n                body = app(request.environ, start_response)\n                rs.body = itertools.chain(rs.body, body) if rs.body else body\n                return rs\n            finally:\n                request.path_shift(-path_depth)\n\n        options.setdefault('skip', True)\n        options.setdefault('method', 'PROXY')\n        options.setdefault('mountpoint', {'prefix': prefix, 'target': app})\n        options['callback'] = mountpoint_wrapper\n\n        self.route('/%s/<:re:.*>' % '/'.join(segments), **options)\n        if not prefix.endswith('/'):\n            self.route('/' + '/'.join(segments), **options)\n\n    def _mount_app(self, prefix, app, **options):\n        if app in self._mounts or '_mount.app' in app.config:\n            depr(0, 13, \"Application mounted multiple times. Falling back to WSGI mount.\",\n                 \"Clone application before mounting to a different location.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        if options:\n            depr(0, 13, \"Unsupported mount options. Falling back to WSGI mount.\",\n                 \"Do not specify any route options when mounting bottle application.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        if not prefix.endswith(\"/\"):\n            depr(0, 13, \"Prefix must end in '/'. Falling back to WSGI mount.\",\n                 \"Consider adding an explicit redirect from '/prefix' to '/prefix/' in the parent application.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        self._mounts.append(app)\n        app.config['_mount.prefix'] = prefix\n        app.config['_mount.app'] = self\n        for route in app.routes:\n            route.rule = prefix + route.rule.lstrip('/')\n            self.add_route(route)\n\n    def mount(self, prefix, app, **options):\n        \"\"\" Mount an application (:class:`Bottle` or plain WSGI) to a specific\n            URL prefix. Example::\n\n                parent_app.mount('/prefix/', child_app)\n\n            :param prefix: path prefix or `mount-point`.\n            :param app: an instance of :class:`Bottle` or a WSGI application.\n\n            Plugins from the parent application are not applied to the routes\n            of the mounted child application. If you need plugins in the child\n            application, install them separately.\n\n            While it is possible to use path wildcards within the prefix path\n            (:class:`Bottle` childs only), it is highly discouraged.\n\n            The prefix path must end with a slash. If you want to access the\n            root of the child application via `/prefix` in addition to\n            `/prefix/`, consider adding a route with a 307 redirect to the\n            parent application.\n        \"\"\"\n\n        if not prefix.startswith('/'):\n            raise ValueError(\"Prefix must start with '/'\")\n\n        if isinstance(app, Bottle):\n            return self._mount_app(prefix, app, **options)\n        else:\n            return self._mount_wsgi(prefix, app, **options)\n\n    def merge(self, routes):\n        \"\"\" Merge the routes of another :class:`Bottle` application or a list of\n            :class:`Route` objects into this application. The routes keep their\n            'owner', meaning that the :data:`Route.app` attribute is not\n            changed. \"\"\"\n        if isinstance(routes, Bottle):\n            routes = routes.routes\n        for route in routes:\n            self.add_route(route)\n\n    def install(self, plugin):\n        \"\"\" Add a plugin to the list of plugins and prepare it for being\n            applied to all routes of this application. A plugin may be a simple\n            decorator or an object that implements the :class:`Plugin` API.\n        \"\"\"\n        if hasattr(plugin, 'setup'): plugin.setup(self)\n        if not callable(plugin) and not hasattr(plugin, 'apply'):\n            raise TypeError(\"Plugins must be callable or implement .apply()\")\n        self.plugins.append(plugin)\n        self.reset()\n        return plugin\n\n    def uninstall(self, plugin):\n        \"\"\" Uninstall plugins. Pass an instance to remove a specific plugin, a type\n            object to remove all plugins that match that type, a string to remove\n            all plugins with a matching ``name`` attribute or ``True`` to remove all\n            plugins. Return the list of removed plugins. \"\"\"\n        removed, remove = [], plugin\n        for i, plugin in list(enumerate(self.plugins))[::-1]:\n            if remove is True or remove is plugin or remove is type(plugin) \\\n            or getattr(plugin, 'name', True) == remove:\n                removed.append(plugin)\n                del self.plugins[i]\n                if hasattr(plugin, 'close'): plugin.close()\n        if removed: self.reset()\n        return removed\n\n    def reset(self, route=None):\n        \"\"\" Reset all routes (force plugins to be re-applied) and clear all\n            caches. If an ID or route object is given, only that specific route\n            is affected. \"\"\"\n        if route is None: routes = self.routes\n        elif isinstance(route, Route): routes = [route]\n        else: routes = [self.routes[route]]\n        for route in routes:\n            route.reset()\n        if DEBUG:\n            for route in routes:\n                route.prepare()\n        self.trigger_hook('app_reset')\n\n    def close(self):\n        \"\"\" Close the application and all installed plugins. \"\"\"\n        for plugin in self.plugins:\n            if hasattr(plugin, 'close'): plugin.close()\n\n    def run(self, **kwargs):\n        \"\"\" Calls :func:`run` with the same parameters. \"\"\"\n        run(self, **kwargs)\n\n    def match(self, environ):\n        \"\"\" Search for a matching route and return a (:class:`Route` , urlargs)\n            tuple. The second value is a dictionary with parameters extracted\n            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match.\"\"\"\n        return self.router.match(environ)\n\n    def get_url(self, routename, **kargs):\n        \"\"\" Return a string that matches a named route \"\"\"\n        scriptname = request.environ.get('SCRIPT_NAME', '').strip('/') + '/'\n        location = self.router.build(routename, **kargs).lstrip('/')\n        return urljoin(urljoin('/', scriptname), location)\n\n    def add_route(self, route):\n        \"\"\" Add a route object, but do not change the :data:`Route.app`\n            attribute.\"\"\"\n        self.routes.append(route)\n        self.router.add(route.rule, route.method, route, name=route.name)\n        if DEBUG: route.prepare()\n\n    def route(self,\n              path=None,\n              method='GET',\n              callback=None,\n              name=None,\n              apply=None,\n              skip=None, **config):\n        \"\"\" A decorator to bind a function to a request URL. Example::\n\n                @app.route('/hello/<name>')\n                def hello(name):\n                    return 'Hello %s' % name\n\n            The ``<name>`` part is a wildcard. See :class:`Router` for syntax\n            details.\n\n            :param path: Request path or a list of paths to listen to. If no\n              path is specified, it is automatically generated from the\n              signature of the function.\n            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of\n              methods to listen to. (default: `GET`)\n            :param callback: An optional shortcut to avoid the decorator\n              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``\n            :param name: The name for this route. (default: None)\n            :param apply: A decorator or plugin or a list of plugins. These are\n              applied to the route callback in addition to installed plugins.\n            :param skip: A list of plugins, plugin classes or names. Matching\n              plugins are not installed to this route. ``True`` skips all.\n\n            Any additional keyword arguments are stored as route-specific\n            configuration and passed to plugins (see :meth:`Plugin.apply`).\n        \"\"\"\n        if callable(path): path, callback = None, path\n        plugins = makelist(apply)\n        skiplist = makelist(skip)\n\n        def decorator(callback):\n            if isinstance(callback, basestring): callback = load(callback)\n            for rule in makelist(path) or yieldroutes(callback):\n                for verb in makelist(method):\n                    verb = verb.upper()\n                    route = Route(self, rule, verb, callback,\n                                  name=name,\n                                  plugins=plugins,\n                                  skiplist=skiplist, **config)\n                    self.add_route(route)\n            return callback\n\n        return decorator(callback) if callback else decorator\n\n    def get(self, path=None, method='GET', **options):\n        \"\"\" Equals :meth:`route`. \"\"\"\n        return self.route(path, method, **options)\n\n    def post(self, path=None, method='POST', **options):\n        \"\"\" Equals :meth:`route` with a ``POST`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def put(self, path=None, method='PUT', **options):\n        \"\"\" Equals :meth:`route` with a ``PUT`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def delete(self, path=None, method='DELETE', **options):\n        \"\"\" Equals :meth:`route` with a ``DELETE`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def patch(self, path=None, method='PATCH', **options):\n        \"\"\" Equals :meth:`route` with a ``PATCH`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def error(self, code=500):\n        \"\"\" Decorator: Register an output handler for a HTTP error code\"\"\"\n\n        def wrapper(handler):\n            self.error_handler[int(code)] = handler\n            return handler\n\n        return wrapper\n\n    def default_error_handler(self, res):\n        return tob(template(ERROR_PAGE_TEMPLATE, e=res, template_settings=dict(name='__ERROR_PAGE_TEMPLATE')))\n\n    def _handle(self, environ):\n        path = environ['bottle.raw_path'] = environ['PATH_INFO']\n        if py3k:\n            environ['PATH_INFO'] = path.encode('latin1').decode('utf8', 'ignore')\n\n        environ['bottle.app'] = self\n        request.bind(environ)\n        response.bind()\n\n        try:\n            while True: # Remove in 0.14 together with RouteReset\n                out = None\n                try:\n                    self.trigger_hook('before_request')\n                    route, args = self.router.match(environ)\n                    environ['route.handle'] = route\n                    environ['bottle.route'] = route\n                    environ['route.url_args'] = args\n                    out = route.call(**args)\n                    break\n                except HTTPResponse as E:\n                    out = E\n                    break\n                except RouteReset:\n                    depr(0, 13, \"RouteReset exception deprecated\",\n                                \"Call route.call() after route.reset() and \"\n                                \"return the result.\")\n                    route.reset()\n                    continue\n                finally:\n                    if isinstance(out, HTTPResponse):\n                        out.apply(response)\n                    try:\n                        self.trigger_hook('after_request')\n                    except HTTPResponse as E:\n                        out = E\n                        out.apply(response)\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as E:\n            if not self.catchall: raise\n            stacktrace = format_exc()\n            environ['wsgi.errors'].write(stacktrace)\n            environ['wsgi.errors'].flush()\n            out = HTTPError(500, \"Internal Server Error\", E, stacktrace)\n            out.apply(response)\n\n        return out\n\n    def _cast(self, out, peek=None):\n        \"\"\" Try to convert the parameter into something WSGI compatible and set\n        correct HTTP headers when possible.\n        Support: False, str, unicode, dict, HTTPResponse, HTTPError, file-like,\n        iterable of strings and iterable of unicodes\n        \"\"\"\n\n        # Empty output is done here\n        if not out:\n            if 'Content-Length' not in response:\n                response['Content-Length'] = 0\n            return []\n        # Join lists of byte or unicode strings. Mixed lists are NOT supported\n        if isinstance(out, (tuple, list))\\\n        and isinstance(out[0], (bytes, unicode)):\n            out = out[0][0:0].join(out)  # b'abc'[0:0] -> b''\n        # Encode unicode strings\n        if isinstance(out, unicode):\n            out = out.encode(response.charset)\n        # Byte Strings are just returned\n        if isinstance(out, bytes):\n            if 'Content-Length' not in response:\n                response['Content-Length'] = len(out)\n            return [out]\n        # HTTPError or HTTPException (recursive, because they may wrap anything)\n        # TODO: Handle these explicitly in handle() or make them iterable.\n        if isinstance(out, HTTPError):\n            out.apply(response)\n            out = self.error_handler.get(out.status_code,\n                                         self.default_error_handler)(out)\n            return self._cast(out)\n        if isinstance(out, HTTPResponse):\n            out.apply(response)\n            return self._cast(out.body)\n\n        # File-like objects.\n        if hasattr(out, 'read'):\n            if 'wsgi.file_wrapper' in request.environ:\n                return request.environ['wsgi.file_wrapper'](out)\n            elif hasattr(out, 'close') or not hasattr(out, '__iter__'):\n                return WSGIFileWrapper(out)\n\n        # Handle Iterables. We peek into them to detect their inner type.\n        try:\n            iout = iter(out)\n            first = next(iout)\n            while not first:\n                first = next(iout)\n        except StopIteration:\n            return self._cast('')\n        except HTTPResponse as E:\n            first = E\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as error:\n            if not self.catchall: raise\n            first = HTTPError(500, 'Unhandled exception', error, format_exc())\n\n        # These are the inner types allowed in iterator or generator objects.\n        if isinstance(first, HTTPResponse):\n            return self._cast(first)\n        elif isinstance(first, bytes):\n            new_iter = itertools.chain([first], iout)\n        elif isinstance(first, unicode):\n            encoder = lambda x: x.encode(response.charset)\n            new_iter = imap(encoder, itertools.chain([first], iout))\n        else:\n            msg = 'Unsupported response type: %s' % type(first)\n            return self._cast(HTTPError(500, msg))\n        if hasattr(out, 'close'):\n            new_iter = _closeiter(new_iter, out.close)\n        return new_iter\n\n    def wsgi(self, environ, start_response):\n        \"\"\" The bottle WSGI-interface. \"\"\"\n        try:\n            out = self._cast(self._handle(environ))\n            # rfc2616 section 4.3\n            if response._status_code in (100, 101, 204, 304)\\\n            or environ['REQUEST_METHOD'] == 'HEAD':\n                if hasattr(out, 'close'): out.close()\n                out = []\n            start_response(response._status_line, response.headerlist)\n            return out\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as E:\n            if not self.catchall: raise\n            err = '<h1>Critical error while processing request: %s</h1>' \\\n                  % html_escape(environ.get('PATH_INFO', '/'))\n            if DEBUG:\n                err += '<h2>Error:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       '<h2>Traceback:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       % (html_escape(repr(E)), html_escape(format_exc()))\n            environ['wsgi.errors'].write(err)\n            environ['wsgi.errors'].flush()\n            headers = [('Content-Type', 'text/html; charset=UTF-8')]\n            start_response('500 INTERNAL SERVER ERROR', headers, sys.exc_info())\n            return [tob(err)]\n\n    def __call__(self, environ, start_response):\n        \"\"\" Each instance of :class:'Bottle' is a WSGI application. \"\"\"\n        return self.wsgi(environ, start_response)\n\n    def __enter__(self):\n        \"\"\" Use this application as default for all module-level shortcuts. \"\"\"\n        default_app.push(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        default_app.pop()\n\n    def __setattr__(self, name, value):\n        if name in self.__dict__:\n            raise AttributeError(\"Attribute %s already defined. Plugin conflict?\" % name)\n        self.__dict__[name] = value\n\n\n###############################################################################\n# HTTP and WSGI Tools ##########################################################\n###############################################################################\n\n\nclass BaseRequest(object):\n    \"\"\" A wrapper for WSGI environment dictionaries that adds a lot of\n        convenient access methods and properties. Most of them are read-only.\n\n        Adding new attributes to a request actually adds them to the environ\n        dictionary (as 'bottle.request.ext.<name>'). This is the recommended\n        way to store and access request-specific data.\n    \"\"\"\n\n    __slots__ = ('environ', )\n\n    #: Maximum size of memory buffer for :attr:`body` in bytes.\n    MEMFILE_MAX = 102400\n\n    def __init__(self, environ=None):\n        \"\"\" Wrap a WSGI environ dictionary. \"\"\"\n        #: The wrapped WSGI environ dictionary. This is the only real attribute.\n        #: All other attributes actually are read-only properties.\n        self.environ = {} if environ is None else environ\n        self.environ['bottle.request'] = self\n\n    @DictProperty('environ', 'bottle.app', read_only=True)\n    def app(self):\n        \"\"\" Bottle application handling this request. \"\"\"\n        raise RuntimeError('This request is not connected to an application.')\n\n    @DictProperty('environ', 'bottle.route', read_only=True)\n    def route(self):\n        \"\"\" The bottle :class:`Route` object that matches this request. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @DictProperty('environ', 'route.url_args', read_only=True)\n    def url_args(self):\n        \"\"\" The arguments extracted from the URL. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @property\n    def path(self):\n        \"\"\" The value of ``PATH_INFO`` with exactly one prefixed slash (to fix\n            broken clients and avoid the \"empty path\" edge case). \"\"\"\n        return '/' + self.environ.get('PATH_INFO', '').lstrip('/')\n\n    @property\n    def method(self):\n        \"\"\" The ``REQUEST_METHOD`` value as an uppercase string. \"\"\"\n        return self.environ.get('REQUEST_METHOD', 'GET').upper()\n\n    @DictProperty('environ', 'bottle.request.headers', read_only=True)\n    def headers(self):\n        \"\"\" A :class:`WSGIHeaderDict` that provides case-insensitive access to\n            HTTP request headers. \"\"\"\n        return WSGIHeaderDict(self.environ)\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a request header, or a given default value. \"\"\"\n        return self.headers.get(name, default)\n\n    @DictProperty('environ', 'bottle.request.cookies', read_only=True)\n    def cookies(self):\n        \"\"\" Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT\n            decoded. Use :meth:`get_cookie` if you expect signed cookies. \"\"\"\n        cookies = SimpleCookie(self.environ.get('HTTP_COOKIE', '')).values()\n        return FormsDict((c.key, c.value) for c in cookies)\n\n    def get_cookie(self, key, default=None, secret=None):\n        \"\"\" Return the content of a cookie. To read a `Signed Cookie`, the\n            `secret` must match the one used to create the cookie (see\n            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing\n            cookie or wrong signature), return a default value. \"\"\"\n        value = self.cookies.get(key)\n        if secret and value:\n            dec = cookie_decode(value, secret)  # (key, value) tuple or None\n            return dec[1] if dec and dec[0] == key else default\n        return value or default\n\n    @DictProperty('environ', 'bottle.request.query', read_only=True)\n    def query(self):\n        \"\"\" The :attr:`query_string` parsed into a :class:`FormsDict`. These\n            values are sometimes called \"URL arguments\" or \"GET parameters\", but\n            not to be confused with \"URL wildcards\" as they are provided by the\n            :class:`Router`. \"\"\"\n        get = self.environ['bottle.get'] = FormsDict()\n        pairs = _parse_qsl(self.environ.get('QUERY_STRING', ''))\n        for key, value in pairs:\n            get[key] = value\n        return get\n\n    @DictProperty('environ', 'bottle.request.forms', read_only=True)\n    def forms(self):\n        \"\"\" Form values parsed from an `url-encoded` or `multipart/form-data`\n            encoded POST or PUT request body. The result is returned as a\n            :class:`FormsDict`. All keys and values are strings. File uploads\n            are stored separately in :attr:`files`. \"\"\"\n        forms = FormsDict()\n        for name, item in self.POST.allitems():\n            if not isinstance(item, FileUpload):\n                forms[name] = item\n        return forms\n\n    @DictProperty('environ', 'bottle.request.params', read_only=True)\n    def params(self):\n        \"\"\" A :class:`FormsDict` with the combined values of :attr:`query` and\n            :attr:`forms`. File uploads are stored in :attr:`files`. \"\"\"\n        params = FormsDict()\n        for key, value in self.query.allitems():\n            params[key] = value\n        for key, value in self.forms.allitems():\n            params[key] = value\n        return params\n\n    @DictProperty('environ', 'bottle.request.files', read_only=True)\n    def files(self):\n        \"\"\" File uploads parsed from `multipart/form-data` encoded POST or PUT\n            request body. The values are instances of :class:`FileUpload`.\n\n        \"\"\"\n        files = FormsDict()\n        for name, item in self.POST.allitems():\n            if isinstance(item, FileUpload):\n                files[name] = item\n        return files\n\n    @DictProperty('environ', 'bottle.request.json', read_only=True)\n    def json(self):\n        \"\"\" If the ``Content-Type`` header is ``application/json`` or\n            ``application/json-rpc``, this property holds the parsed content\n            of the request body. Only requests smaller than :attr:`MEMFILE_MAX`\n            are processed to avoid memory exhaustion.\n            Invalid JSON raises a 400 error response.\n        \"\"\"\n        ctype = self.environ.get('CONTENT_TYPE', '').lower().split(';')[0]\n        if ctype in ('application/json', 'application/json-rpc'):\n            b = self._get_body_string()\n            if not b:\n                return None\n            try:\n                return json_loads(b)\n            except (ValueError, TypeError):\n                raise HTTPError(400, 'Invalid JSON')\n        return None\n\n    def _iter_body(self, read, bufsize):\n        maxread = max(0, self.content_length)\n        while maxread:\n            part = read(min(maxread, bufsize))\n            if not part: break\n            yield part\n            maxread -= len(part)\n\n    @staticmethod\n    def _iter_chunked(read, bufsize):\n        err = HTTPError(400, 'Error while parsing chunked transfer body.')\n        rn, sem, bs = tob('\\r\\n'), tob(';'), tob('')\n        while True:\n            header = read(1)\n            while header[-2:] != rn:\n                c = read(1)\n                header += c\n                if not c: raise err\n                if len(header) > bufsize: raise err\n            size, _, _ = header.partition(sem)\n            try:\n                maxread = int(tonat(size.strip()), 16)\n            except ValueError:\n                raise err\n            if maxread == 0: break\n            buff = bs\n            while maxread > 0:\n                if not buff:\n                    buff = read(min(maxread, bufsize))\n                part, buff = buff[:maxread], buff[maxread:]\n                if not part: raise err\n                yield part\n                maxread -= len(part)\n            if read(2) != rn:\n                raise err\n\n    @DictProperty('environ', 'bottle.request.body', read_only=True)\n    def _body(self):\n        try:\n            read_func = self.environ['wsgi.input'].read\n        except KeyError:\n            self.environ['wsgi.input'] = BytesIO()\n            return self.environ['wsgi.input']\n        body_iter = self._iter_chunked if self.chunked else self._iter_body\n        body, body_size, is_temp_file = BytesIO(), 0, False\n        for part in body_iter(read_func, self.MEMFILE_MAX):\n            body.write(part)\n            body_size += len(part)\n            if not is_temp_file and body_size > self.MEMFILE_MAX:\n                body, tmp = TemporaryFile(mode='w+b'), body\n                body.write(tmp.getvalue())\n                del tmp\n                is_temp_file = True\n        self.environ['wsgi.input'] = body\n        body.seek(0)\n        return body\n\n    def _get_body_string(self):\n        \"\"\" read body until content-length or MEMFILE_MAX into a string. Raise\n            HTTPError(413) on requests that are to large. \"\"\"\n        clen = self.content_length\n        if clen > self.MEMFILE_MAX:\n            raise HTTPError(413, 'Request entity too large')\n        if clen < 0: clen = self.MEMFILE_MAX + 1\n        data = self.body.read(clen)\n        if len(data) > self.MEMFILE_MAX:  # Fail fast\n            raise HTTPError(413, 'Request entity too large')\n        return data\n\n    @property\n    def body(self):\n        \"\"\" The HTTP request body as a seek-able file-like object. Depending on\n            :attr:`MEMFILE_MAX`, this is either a temporary file or a\n            :class:`io.BytesIO` instance. Accessing this property for the first\n            time reads and replaces the ``wsgi.input`` environ variable.\n            Subsequent accesses just do a `seek(0)` on the file object. \"\"\"\n        self._body.seek(0)\n        return self._body\n\n    @property\n    def chunked(self):\n        \"\"\" True if Chunked transfer encoding was. \"\"\"\n        return 'chunked' in self.environ.get(\n            'HTTP_TRANSFER_ENCODING', '').lower()\n\n    #: An alias for :attr:`query`.\n    GET = query\n\n    @DictProperty('environ', 'bottle.request.post', read_only=True)\n    def POST(self):\n        \"\"\" The values of :attr:`forms` and :attr:`files` combined into a single\n            :class:`FormsDict`. Values are either strings (form values) or\n            instances of :class:`cgi.FieldStorage` (file uploads).\n        \"\"\"\n        post = FormsDict()\n        # We default to application/x-www-form-urlencoded for everything that\n        # is not multipart and take the fast path (also: 3.1 workaround)\n        if not self.content_type.startswith('multipart/'):\n            pairs = _parse_qsl(tonat(self._get_body_string(), 'latin1'))\n            for key, value in pairs:\n                post[key] = value\n            return post\n\n        safe_env = {'QUERY_STRING': ''}  # Build a safe environment for cgi\n        for key in ('REQUEST_METHOD', 'CONTENT_TYPE', 'CONTENT_LENGTH'):\n            if key in self.environ: safe_env[key] = self.environ[key]\n        args = dict(fp=self.body, environ=safe_env, keep_blank_values=True)\n\n        if py3k:\n            args['encoding'] = 'utf8'\n        data = cgi.FieldStorage(**args)\n        self['_cgi.FieldStorage'] = data  #http://bugs.python.org/issue18394\n        data = data.list or []\n        for item in data:\n            if item.filename:\n                post[item.name] = FileUpload(item.file, item.name,\n                                             item.filename, item.headers)\n            else:\n                post[item.name] = item.value\n        return post\n\n    @property\n    def url(self):\n        \"\"\" The full request URI including hostname and scheme. If your app\n            lives behind a reverse proxy or load balancer and you get confusing\n            results, make sure that the ``X-Forwarded-Host`` header is set\n            correctly. \"\"\"\n        return self.urlparts.geturl()\n\n    @DictProperty('environ', 'bottle.request.urlparts', read_only=True)\n    def urlparts(self):\n        \"\"\" The :attr:`url` string as an :class:`urlparse.SplitResult` tuple.\n            The tuple contains (scheme, host, path, query_string and fragment),\n            but the fragment is always empty because it is not visible to the\n            server. \"\"\"\n        env = self.environ\n        http = env.get('HTTP_X_FORWARDED_PROTO') \\\n             or env.get('wsgi.url_scheme', 'http')\n        host = env.get('HTTP_X_FORWARDED_HOST') or env.get('HTTP_HOST')\n        if not host:\n            # HTTP 1.1 requires a Host-header. This is for HTTP/1.0 clients.\n            host = env.get('SERVER_NAME', '127.0.0.1')\n            port = env.get('SERVER_PORT')\n            if port and port != ('80' if http == 'http' else '443'):\n                host += ':' + port\n        path = urlquote(self.fullpath)\n        return UrlSplitResult(http, host, path, env.get('QUERY_STRING'), '')\n\n    @property\n    def fullpath(self):\n        \"\"\" Request path including :attr:`script_name` (if present). \"\"\"\n        return urljoin(self.script_name, self.path.lstrip('/'))\n\n    @property\n    def query_string(self):\n        \"\"\" The raw :attr:`query` part of the URL (everything in between ``?``\n            and ``#``) as a string. \"\"\"\n        return self.environ.get('QUERY_STRING', '')\n\n    @property\n    def script_name(self):\n        \"\"\" The initial portion of the URL's `path` that was removed by a higher\n            level (server or routing middleware) before the application was\n            called. This script path is returned with leading and tailing\n            slashes. \"\"\"\n        script_name = self.environ.get('SCRIPT_NAME', '').strip('/')\n        return '/' + script_name + '/' if script_name else '/'\n\n    def path_shift(self, shift=1):\n        \"\"\" Shift path segments from :attr:`path` to :attr:`script_name` and\n            vice versa.\n\n           :param shift: The number of path segments to shift. May be negative\n                         to change the shift direction. (default: 1)\n        \"\"\"\n        script, path = path_shift(self.environ.get('SCRIPT_NAME', '/'), self.path, shift)\n        self['SCRIPT_NAME'], self['PATH_INFO'] = script, path\n\n    @property\n    def content_length(self):\n        \"\"\" The request body length as an integer. The client is responsible to\n            set this header. Otherwise, the real length of the body is unknown\n            and -1 is returned. In this case, :attr:`body` will be empty. \"\"\"\n        return int(self.environ.get('CONTENT_LENGTH') or -1)\n\n    @property\n    def content_type(self):\n        \"\"\" The Content-Type header as a lowercase-string (default: empty). \"\"\"\n        return self.environ.get('CONTENT_TYPE', '').lower()\n\n    @property\n    def is_xhr(self):\n        \"\"\" True if the request was triggered by a XMLHttpRequest. This only\n            works with JavaScript libraries that support the `X-Requested-With`\n            header (most of the popular libraries do). \"\"\"\n        requested_with = self.environ.get('HTTP_X_REQUESTED_WITH', '')\n        return requested_with.lower() == 'xmlhttprequest'\n\n    @property\n    def is_ajax(self):\n        \"\"\" Alias for :attr:`is_xhr`. \"Ajax\" is not the right term. \"\"\"\n        return self.is_xhr\n\n    @property\n    def auth(self):\n        \"\"\" HTTP authentication data as a (user, password) tuple. This\n            implementation currently supports basic (not digest) authentication\n            only. If the authentication happened at a higher level (e.g. in the\n            front web-server or a middleware), the password field is None, but\n            the user field is looked up from the ``REMOTE_USER`` environ\n            variable. On any errors, None is returned. \"\"\"\n        basic = parse_auth(self.environ.get('HTTP_AUTHORIZATION', ''))\n        if basic: return basic\n        ruser = self.environ.get('REMOTE_USER')\n        if ruser: return (ruser, None)\n        return None\n\n    @property\n    def remote_route(self):\n        \"\"\" A list of all IPs that were involved in this request, starting with\n            the client IP and followed by zero or more proxies. This does only\n            work if all proxies support the ```X-Forwarded-For`` header. Note\n            that this information can be forged by malicious clients. \"\"\"\n        proxy = self.environ.get('HTTP_X_FORWARDED_FOR')\n        if proxy: return [ip.strip() for ip in proxy.split(',')]\n        remote = self.environ.get('REMOTE_ADDR')\n        return [remote] if remote else []\n\n    @property\n    def remote_addr(self):\n        \"\"\" The client IP as a string. Note that this information can be forged\n            by malicious clients. \"\"\"\n        route = self.remote_route\n        return route[0] if route else None\n\n    def copy(self):\n        \"\"\" Return a new :class:`Request` with a shallow :attr:`environ` copy. \"\"\"\n        return Request(self.environ.copy())\n\n    def get(self, value, default=None):\n        return self.environ.get(value, default)\n\n    def __getitem__(self, key):\n        return self.environ[key]\n\n    def __delitem__(self, key):\n        self[key] = \"\"\n        del (self.environ[key])\n\n    def __iter__(self):\n        return iter(self.environ)\n\n    def __len__(self):\n        return len(self.environ)\n\n    def keys(self):\n        return self.environ.keys()\n\n    def __setitem__(self, key, value):\n        \"\"\" Change an environ value and clear all caches that depend on it. \"\"\"\n\n        if self.environ.get('bottle.request.readonly'):\n            raise KeyError('The environ dictionary is read-only.')\n\n        self.environ[key] = value\n        todelete = ()\n\n        if key == 'wsgi.input':\n            todelete = ('body', 'forms', 'files', 'params', 'post', 'json')\n        elif key == 'QUERY_STRING':\n            todelete = ('query', 'params')\n        elif key.startswith('HTTP_'):\n            todelete = ('headers', 'cookies')\n\n        for key in todelete:\n            self.environ.pop('bottle.request.' + key, None)\n\n    def __repr__(self):\n        return '<%s: %s %s>' % (self.__class__.__name__, self.method, self.url)\n\n    def __getattr__(self, name):\n        \"\"\" Search in self.environ for additional user defined attributes. \"\"\"\n        try:\n            var = self.environ['bottle.request.ext.%s' % name]\n            return var.__get__(self) if hasattr(var, '__get__') else var\n        except KeyError:\n            raise AttributeError('Attribute %r not defined.' % name)\n\n    def __setattr__(self, name, value):\n        if name == 'environ': return object.__setattr__(self, name, value)\n        key = 'bottle.request.ext.%s' % name\n        if key in self.environ:\n            raise AttributeError(\"Attribute already defined: %s\" % name)\n        self.environ[key] = value\n\n    def __delattr__(self, name, value):\n        try:\n            del self.environ['bottle.request.ext.%s' % name]\n        except KeyError:\n            raise AttributeError(\"Attribute not defined: %s\" % name)\n\n\ndef _hkey(s):\n    return s.title().replace('_', '-')\n\n\nclass HeaderProperty(object):\n    def __init__(self, name, reader=None, writer=str, default=''):\n        self.name, self.default = name, default\n        self.reader, self.writer = reader, writer\n        self.__doc__ = 'Current value of the %r header.' % name.title()\n\n    def __get__(self, obj, _):\n        if obj is None: return self\n        value = obj.headers.get(self.name, self.default)\n        return self.reader(value) if self.reader else value\n\n    def __set__(self, obj, value):\n        obj.headers[self.name] = self.writer(value)\n\n    def __delete__(self, obj):\n        del obj.headers[self.name]\n\n\nclass BaseResponse(object):\n    \"\"\" Storage class for a response body as well as headers and cookies.\n\n        This class does support dict-like case-insensitive item-access to\n        headers, but is NOT a dict. Most notably, iterating over a response\n        yields parts of the body and not the headers.\n\n        :param body: The response body as one of the supported types.\n        :param status: Either an HTTP status code (e.g. 200) or a status line\n                       including the reason phrase (e.g. '200 OK').\n        :param headers: A dictionary or a list of name-value pairs.\n\n        Additional keyword arguments are added to the list of headers.\n        Underscores in the header name are replaced with dashes.\n    \"\"\"\n\n    default_status = 200\n    default_content_type = 'text/html; charset=UTF-8'\n\n    # Header blacklist for specific response codes\n    # (rfc2616 section 10.2.3 and 10.3.5)\n    bad_headers = {\n        204: frozenset(('Content-Type', 'Content-Length')),\n        304: frozenset(('Allow', 'Content-Encoding', 'Content-Language',\n                  'Content-Length', 'Content-Range', 'Content-Type',\n                  'Content-Md5', 'Last-Modified'))\n    }\n\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        self._cookies = None\n        self._headers = {}\n        self.body = body\n        self.status = status or self.default_status\n        if headers:\n            if isinstance(headers, dict):\n                headers = headers.items()\n            for name, value in headers:\n                self.add_header(name, value)\n        if more_headers:\n            for name, value in more_headers.items():\n                self.add_header(name, value)\n\n    def copy(self, cls=None):\n        \"\"\" Returns a copy of self. \"\"\"\n        cls = cls or BaseResponse\n        assert issubclass(cls, BaseResponse)\n        copy = cls()\n        copy.status = self.status\n        copy._headers = dict((k, v[:]) for (k, v) in self._headers.items())\n        if self._cookies:\n            copy._cookies = SimpleCookie()\n            copy._cookies.load(self._cookies.output(header=''))\n        return copy\n\n    def __iter__(self):\n        return iter(self.body)\n\n    def close(self):\n        if hasattr(self.body, 'close'):\n            self.body.close()\n\n    @property\n    def status_line(self):\n        \"\"\" The HTTP status line as a string (e.g. ``404 Not Found``).\"\"\"\n        return self._status_line\n\n    @property\n    def status_code(self):\n        \"\"\" The HTTP status code as an integer (e.g. 404).\"\"\"\n        return self._status_code\n\n    def _set_status(self, status):\n        if isinstance(status, int):\n            code, status = status, _HTTP_STATUS_LINES.get(status)\n        elif ' ' in status:\n            status = status.strip()\n            code = int(status.split()[0])\n        else:\n            raise ValueError('String status line without a reason phrase.')\n        if not 100 <= code <= 999:\n            raise ValueError('Status code out of range.')\n        self._status_code = code\n        self._status_line = str(status or ('%d Unknown' % code))\n\n    def _get_status(self):\n        return self._status_line\n\n    status = property(\n        _get_status, _set_status, None,\n        ''' A writeable property to change the HTTP response status. It accepts\n            either a numeric code (100-999) or a string with a custom reason\n            phrase (e.g. \"404 Brain not found\"). Both :data:`status_line` and\n            :data:`status_code` are updated accordingly. The return value is\n            always a status string. ''')\n    del _get_status, _set_status\n\n    @property\n    def headers(self):\n        \"\"\" An instance of :class:`HeaderDict`, a case-insensitive dict-like\n            view on the response headers. \"\"\"\n        hdict = HeaderDict()\n        hdict.dict = self._headers\n        return hdict\n\n    def __contains__(self, name):\n        return _hkey(name) in self._headers\n\n    def __delitem__(self, name):\n        del self._headers[_hkey(name)]\n\n    def __getitem__(self, name):\n        return self._headers[_hkey(name)][-1]\n\n    def __setitem__(self, name, value):\n        self._headers[_hkey(name)] = [value if isinstance(value, unicode) else\n                                      str(value)]\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a previously defined header. If there is no\n            header with that name, return a default value. \"\"\"\n        return self._headers.get(_hkey(name), [default])[-1]\n\n    def set_header(self, name, value):\n        \"\"\" Create a new response header, replacing any previously defined\n            headers with the same name. \"\"\"\n        self._headers[_hkey(name)] = [value if isinstance(value, unicode)\n                                            else str(value)]\n\n    def add_header(self, name, value):\n        \"\"\" Add an additional response header, not removing duplicates. \"\"\"\n        self._headers.setdefault(_hkey(name), []).append(\n            value if isinstance(value, unicode) else str(value))\n\n    def iter_headers(self):\n        \"\"\" Yield (header, value) tuples, skipping headers that are not\n            allowed with the current response status code. \"\"\"\n        return self.headerlist\n\n    @property\n    def headerlist(self):\n        \"\"\" WSGI conform list of (header, value) tuples. \"\"\"\n        out = []\n        headers = list(self._headers.items())\n        if 'Content-Type' not in self._headers:\n            headers.append(('Content-Type', [self.default_content_type]))\n        if self._status_code in self.bad_headers:\n            bad_headers = self.bad_headers[self._status_code]\n            headers = [h for h in headers if h[0] not in bad_headers]\n        out += [(name, val) for (name, vals) in headers for val in vals]\n        if self._cookies:\n            for c in self._cookies.values():\n                out.append(('Set-Cookie', c.OutputString()))\n        if py3k:\n            return [(k, v.encode('utf8').decode('latin1')) for (k, v) in out]\n        else:\n            return [(k, v.encode('utf8') if isinstance(v, unicode) else v)\n                    for (k, v) in out]\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int)\n    expires = HeaderProperty(\n        'Expires',\n        reader=lambda x: datetime.utcfromtimestamp(parse_date(x)),\n        writer=lambda x: http_date(x))\n\n    @property\n    def charset(self, default='UTF-8'):\n        \"\"\" Return the charset specified in the content-type header (default: utf8). \"\"\"\n        if 'charset=' in self.content_type:\n            return self.content_type.split('charset=')[-1].split(';')[0].strip()\n        return default\n\n    def set_cookie(self, name, value, secret=None, **options):\n        \"\"\" Create a new cookie or replace an old one. If the `secret` parameter is\n            set, create a `Signed Cookie` (described below).\n\n            :param name: the name of the cookie.\n            :param value: the value of the cookie.\n            :param secret: a signature key required for signed cookies.\n\n            Additionally, this method accepts all RFC 2109 attributes that are\n            supported by :class:`cookie.Morsel`, including:\n\n            :param max_age: maximum age in seconds. (default: None)\n            :param expires: a datetime object or UNIX timestamp. (default: None)\n            :param domain: the domain that is allowed to read the cookie.\n              (default: current domain)\n            :param path: limits the cookie to a given path (default: current path)\n            :param secure: limit the cookie to HTTPS connections (default: off).\n            :param httponly: prevents client-side javascript to read this cookie\n              (default: off, requires Python 2.6 or newer).\n\n            If neither `expires` nor `max_age` is set (default), the cookie will\n            expire at the end of the browser session (as soon as the browser\n            window is closed).\n\n            Signed cookies may store any pickle-able object and are\n            cryptographically signed to prevent manipulation. Keep in mind that\n            cookies are limited to 4kb in most browsers.\n\n            Warning: Signed cookies are not encrypted (the client can still see\n            the content) and not copy-protected (the client can restore an old\n            cookie). The main intention is to make pickling and unpickling\n            save, not to store secret information at client side.\n        \"\"\"\n        if not self._cookies:\n            self._cookies = SimpleCookie()\n\n        if secret:\n            value = touni(cookie_encode((name, value), secret))\n        elif not isinstance(value, basestring):\n            raise TypeError('Secret key missing for non-string Cookie.')\n\n        # Cookie size plus options must not exceed 4kb.\n        if len(name) + len(value) > 3800:\n            raise ValueError('Content does not fit into a cookie.')\n\n        self._cookies[name] = value\n\n        for key, value in options.items():\n            if key == 'max_age':\n                if isinstance(value, timedelta):\n                    value = value.seconds + value.days * 24 * 3600\n            if key == 'expires':\n                if isinstance(value, (datedate, datetime)):\n                    value = value.timetuple()\n                elif isinstance(value, (int, float)):\n                    value = time.gmtime(value)\n                value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n            if key in ('secure', 'httponly') and not value:\n                continue\n            self._cookies[name][key.replace('_', '-')] = value\n\n    def delete_cookie(self, key, **kwargs):\n        \"\"\" Delete a cookie. Be sure to use the same `domain` and `path`\n            settings as used to create the cookie. \"\"\"\n        kwargs['max_age'] = -1\n        kwargs['expires'] = 0\n        self.set_cookie(key, '', **kwargs)\n\n    def __repr__(self):\n        out = ''\n        for name, value in self.headerlist:\n            out += '%s: %s\\n' % (name.title(), value.strip())\n        return out\n\n\ndef _local_property():\n    ls = threading.local()\n\n    def fget(_):\n        try:\n            return ls.var\n        except AttributeError:\n            raise RuntimeError(\"Request context not initialized.\")\n\n    def fset(_, value):\n        ls.var = value\n\n    def fdel(_):\n        del ls.var\n\n    return property(fget, fset, fdel, 'Thread-local property')\n\n\nclass LocalRequest(BaseRequest):\n    \"\"\" A thread-local subclass of :class:`BaseRequest` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`request`). If accessed during a\n        request/response cycle, this instance always refers to the *current*\n        request (even on a multithreaded server). \"\"\"\n    bind = BaseRequest.__init__\n    environ = _local_property()\n\n\nclass LocalResponse(BaseResponse):\n    \"\"\" A thread-local subclass of :class:`BaseResponse` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`response`). Its attributes are used\n        to build the HTTP response at the end of the request/response cycle.\n    \"\"\"\n    bind = BaseResponse.__init__\n    _status_line = _local_property()\n    _status_code = _local_property()\n    _cookies = _local_property()\n    _headers = _local_property()\n    body = _local_property()\n\n\nRequest = BaseRequest\nResponse = BaseResponse\n\n\nclass HTTPResponse(Response, BottleException):\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)\n\n    def apply(self, other):\n        other._status_code = self._status_code\n        other._status_line = self._status_line\n        other._headers = self._headers\n        other._cookies = self._cookies\n        other.body = self.body\n\n\nclass HTTPError(HTTPResponse):\n    default_status = 500\n\n    def __init__(self,\n                 status=None,\n                 body=None,\n                 exception=None,\n                 traceback=None, **more_headers):\n        self.exception = exception\n        self.traceback = traceback\n        super(HTTPError, self).__init__(body, status, **more_headers)\n\n###############################################################################\n# Plugins ######################################################################\n###############################################################################\n\n\nclass PluginError(BottleException):\n    pass\n\n\nclass JSONPlugin(object):\n    name = 'json'\n    api = 2\n\n    def __init__(self, json_dumps=json_dumps):\n        self.json_dumps = json_dumps\n\n    def setup(self, app):\n        app.config._define('json.enable', default=True, validate=bool,\n                          help=\"Enable or disable automatic dict->json filter.\")\n        app.config._define('json.ascii', default=False, validate=bool,\n                          help=\"Use only 7-bit ASCII characters in output.\")\n        app.config._define('json.indent', default=True, validate=bool,\n                          help=\"Add whitespace to make json more readable.\")\n        app.config._define('json.dump_func', default=None,\n                          help=\"If defined, use this function to transform\"\n                               \" dict into json. The other options no longer\"\n                               \" apply.\")\n\n    def apply(self, callback, route):\n        dumps = self.json_dumps\n        if not self.json_dumps: return callback\n\n        def wrapper(*a, **ka):\n            try:\n                rv = callback(*a, **ka)\n            except HTTPResponse as resp:\n                rv = resp\n\n            if isinstance(rv, dict):\n                #Attempt to serialize, raises exception on failure\n                json_response = dumps(rv)\n                #Set content type only if serialization successful\n                response.content_type = 'application/json'\n                return json_response\n            elif isinstance(rv, HTTPResponse) and isinstance(rv.body, dict):\n                rv.body = dumps(rv.body)\n                rv.content_type = 'application/json'\n            return rv\n\n        return wrapper\n\n\nclass TemplatePlugin(object):\n    \"\"\" This plugin applies the :func:`view` decorator to all routes with a\n        `template` config parameter. If the parameter is a tuple, the second\n        element must be a dict with additional options (e.g. `template_engine`)\n        or default variables for the template. \"\"\"\n    name = 'template'\n    api = 2\n\n    def setup(self, app):\n        app.tpl = self\n\n    def apply(self, callback, route):\n        conf = route.config.get('template')\n        if isinstance(conf, (tuple, list)) and len(conf) == 2:\n            return view(conf[0], **conf[1])(callback)\n        elif isinstance(conf, str):\n            return view(conf)(callback)\n        else:\n            return callback\n\n\n#: Not a plugin, but part of the plugin API. TODO: Find a better place.\nclass _ImportRedirect(object):\n    def __init__(self, name, impmask):\n        \"\"\" Create a virtual package that redirects imports (see PEP 302). \"\"\"\n        self.name = name\n        self.impmask = impmask\n        self.module = sys.modules.setdefault(name, imp.new_module(name))\n        self.module.__dict__.update({\n            '__file__': __file__,\n            '__path__': [],\n            '__all__': [],\n            '__loader__': self\n        })\n        sys.meta_path.append(self)\n\n    def find_module(self, fullname, path=None):\n        if '.' not in fullname: return\n        packname = fullname.rsplit('.', 1)[0]\n        if packname != self.name: return\n        return self\n\n    def load_module(self, fullname):\n        if fullname in sys.modules: return sys.modules[fullname]\n        modname = fullname.rsplit('.', 1)[1]\n        realname = self.impmask % modname\n        __import__(realname)\n        module = sys.modules[fullname] = sys.modules[realname]\n        setattr(self.module, modname, module)\n        module.__loader__ = self\n        return module\n\n###############################################################################\n# Common Utilities #############################################################\n###############################################################################\n\n\nclass MultiDict(DictMixin):\n    \"\"\" This dict stores multiple values per key, but behaves exactly like a\n        normal dict in that it returns only the newest value for any given key.\n        There are special methods available to access the full list of values.\n    \"\"\"\n\n    def __init__(self, *a, **k):\n        self.dict = dict((k, [v]) for (k, v) in dict(*a, **k).items())\n\n    def __len__(self):\n        return len(self.dict)\n\n    def __iter__(self):\n        return iter(self.dict)\n\n    def __contains__(self, key):\n        return key in self.dict\n\n    def __delitem__(self, key):\n        del self.dict[key]\n\n    def __getitem__(self, key):\n        return self.dict[key][-1]\n\n    def __setitem__(self, key, value):\n        self.append(key, value)\n\n    def keys(self):\n        return self.dict.keys()\n\n    if py3k:\n\n        def values(self):\n            return (v[-1] for v in self.dict.values())\n\n        def items(self):\n            return ((k, v[-1]) for k, v in self.dict.items())\n\n        def allitems(self):\n            return ((k, v) for k, vl in self.dict.items() for v in vl)\n\n        iterkeys = keys\n        itervalues = values\n        iteritems = items\n        iterallitems = allitems\n\n    else:\n\n        def values(self):\n            return [v[-1] for v in self.dict.values()]\n\n        def items(self):\n            return [(k, v[-1]) for k, v in self.dict.items()]\n\n        def iterkeys(self):\n            return self.dict.iterkeys()\n\n        def itervalues(self):\n            return (v[-1] for v in self.dict.itervalues())\n\n        def iteritems(self):\n            return ((k, v[-1]) for k, v in self.dict.iteritems())\n\n        def iterallitems(self):\n            return ((k, v) for k, vl in self.dict.iteritems() for v in vl)\n\n        def allitems(self):\n            return [(k, v) for k, vl in self.dict.iteritems() for v in vl]\n\n    def get(self, key, default=None, index=-1, type=None):\n        \"\"\" Return the most recent value for a key.\n\n            :param default: The default value to be returned if the key is not\n                   present or the type conversion fails.\n            :param index: An index for the list of available values.\n            :param type: If defined, this callable is used to cast the value\n                    into a specific type. Exception are suppressed and result in\n                    the default value to be returned.\n        \"\"\"\n        try:\n            val = self.dict[key][index]\n            return type(val) if type else val\n        except Exception:\n            pass\n        return default\n\n    def append(self, key, value):\n        \"\"\" Add a new value to the list of values for this key. \"\"\"\n        self.dict.setdefault(key, []).append(value)\n\n    def replace(self, key, value):\n        \"\"\" Replace the list of values with a single value. \"\"\"\n        self.dict[key] = [value]\n\n    def getall(self, key):\n        \"\"\" Return a (possibly empty) list of values for a key. \"\"\"\n        return self.dict.get(key) or []\n\n    #: Aliases for WTForms to mimic other multi-dict APIs (Django)\n    getone = get\n    getlist = getall\n\n\nclass FormsDict(MultiDict):\n    \"\"\" This :class:`MultiDict` subclass is used to store request form data.\n        Additionally to the normal dict-like item access methods (which return\n        unmodified data as native strings), this container also supports\n        attribute-like access to its values. Attributes are automatically de-\n        or recoded to match :attr:`input_encoding` (default: 'utf8'). Missing\n        attributes default to an empty string. \"\"\"\n\n    #: Encoding used for attribute values.\n    input_encoding = 'utf8'\n    #: If true (default), unicode strings are first encoded with `latin1`\n    #: and then decoded to match :attr:`input_encoding`.\n    recode_unicode = True\n\n    def _fix(self, s, encoding=None):\n        if isinstance(s, unicode) and self.recode_unicode:  # Python 3 WSGI\n            return s.encode('latin1').decode(encoding or self.input_encoding)\n        elif isinstance(s, bytes):  # Python 2 WSGI\n            return s.decode(encoding or self.input_encoding)\n        else:\n            return s\n\n    def decode(self, encoding=None):\n        \"\"\" Returns a copy with all keys and values de- or recoded to match\n            :attr:`input_encoding`. Some libraries (e.g. WTForms) want a\n            unicode dictionary. \"\"\"\n        copy = FormsDict()\n        enc = copy.input_encoding = encoding or self.input_encoding\n        copy.recode_unicode = False\n        for key, value in self.allitems():\n            copy.append(self._fix(key, enc), self._fix(value, enc))\n        return copy\n\n    def getunicode(self, name, default=None, encoding=None):\n        \"\"\" Return the value as a unicode string, or the default. \"\"\"\n        try:\n            return self._fix(self[name], encoding)\n        except (UnicodeError, KeyError):\n            return default\n\n    def __getattr__(self, name, default=unicode()):\n        # Without this guard, pickle generates a cryptic TypeError:\n        if name.startswith('__') and name.endswith('__'):\n            return super(FormsDict, self).__getattr__(name)\n        return self.getunicode(name, default=default)\n\n\nclass HeaderDict(MultiDict):\n    \"\"\" A case-insensitive version of :class:`MultiDict` that defaults to\n        replace the old value instead of appending it. \"\"\"\n\n    def __init__(self, *a, **ka):\n        self.dict = {}\n        if a or ka: self.update(*a, **ka)\n\n    def __contains__(self, key):\n        return _hkey(key) in self.dict\n\n    def __delitem__(self, key):\n        del self.dict[_hkey(key)]\n\n    def __getitem__(self, key):\n        return self.dict[_hkey(key)][-1]\n\n    def __setitem__(self, key, value):\n        self.dict[_hkey(key)] = [value if isinstance(value, unicode) else\n                                 str(value)]\n\n    def append(self, key, value):\n        self.dict.setdefault(_hkey(key), []).append(\n            value if isinstance(value, unicode) else str(value))\n\n    def replace(self, key, value):\n        self.dict[_hkey(key)] = [value if isinstance(value, unicode) else\n                                 str(value)]\n\n    def getall(self, key):\n        return self.dict.get(_hkey(key)) or []\n\n    def get(self, key, default=None, index=-1):\n        return MultiDict.get(self, _hkey(key), default, index)\n\n    def filter(self, names):\n        for name in [_hkey(n) for n in names]:\n            if name in self.dict:\n                del self.dict[name]\n\n\nclass WSGIHeaderDict(DictMixin):\n    \"\"\" This dict-like class wraps a WSGI environ dict and provides convenient\n        access to HTTP_* fields. Keys and values are native strings\n        (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI\n        environment contains non-native string values, these are de- or encoded\n        using a lossless 'latin1' character set.\n\n        The API will remain stable even on changes to the relevant PEPs.\n        Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one\n        that uses non-native strings.)\n    \"\"\"\n    #: List of keys that do not have a ``HTTP_`` prefix.\n    cgikeys = ('CONTENT_TYPE', 'CONTENT_LENGTH')\n\n    def __init__(self, environ):\n        self.environ = environ\n\n    def _ekey(self, key):\n        \"\"\" Translate header field name to CGI/WSGI environ key. \"\"\"\n        key = key.replace('-', '_').upper()\n        if key in self.cgikeys:\n            return key\n        return 'HTTP_' + key\n\n    def raw(self, key, default=None):\n        \"\"\" Return the header value as is (may be bytes or unicode). \"\"\"\n        return self.environ.get(self._ekey(key), default)\n\n    def __getitem__(self, key):\n        val = self.environ[self._ekey(key)]\n        if py3k:\n            if isinstance(val, unicode):\n                val = val.encode('latin1').decode('utf8')\n            else:\n                val = val.decode('utf8')\n        return val\n\n    def __setitem__(self, key, value):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __delitem__(self, key):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __iter__(self):\n        for key in self.environ:\n            if key[:5] == 'HTTP_':\n                yield _hkey(key[5:])\n            elif key in self.cgikeys:\n                yield _hkey(key)\n\n    def keys(self):\n        return [x for x in self]\n\n    def __len__(self):\n        return len(self.keys())\n\n    def __contains__(self, key):\n        return self._ekey(key) in self.environ\n\n_UNSET = object()\n\nclass ConfigDict(dict):\n    \"\"\" A dict-like configuration storage with additional support for\n        namespaces, validators, meta-data, overlays and more.\n\n        This dict-like class is heavily optimized for read access. All read-only\n        methods as well as item access should be as fast as the built-in dict.\n    \"\"\"\n\n    __slots__ = ('_meta', '_change_listener', '_overlays', '_virtual_keys', '_source', '__weakref__')\n\n    def __init__(self):\n        self._meta = {}\n        self._change_listener = []\n        #: Weak references of overlays that need to be kept in sync.\n        self._overlays = []\n        #: Config that is the source for this overlay.\n        self._source = None\n        #: Keys of values copied from the source (values we do not own)\n        self._virtual_keys = set()\n\n    def load_module(self, path, squash=True):\n        \"\"\"Load values from a Python module.\n\n           Example modue ``config.py``::\n\n                DEBUG = True\n                SQLITE = {\n                    \"db\": \":memory:\"\n                }\n\n\n           >>> c = ConfigDict()\n           >>> c.load_module('config')\n           {DEBUG: True, 'SQLITE.DB': 'memory'}\n           >>> c.load_module(\"config\", False)\n           {'DEBUG': True, 'SQLITE': {'DB': 'memory'}}\n\n           :param squash: If true (default), dictionary values are assumed to\n                          represent namespaces (see :meth:`load_dict`).\n        \"\"\"\n        config_obj = load(path)\n        obj = {key: getattr(config_obj, key) for key in dir(config_obj)\n               if key.isupper()}\n\n        if squash:\n            self.load_dict(obj)\n        else:\n            self.update(obj)\n        return self\n\n    def load_config(self, filename, **options):\n        \"\"\" Load values from an ``*.ini`` style config file.\n\n            A configuration file consists of sections, each led by a\n            ``[section]`` header, followed by key/value entries separated by\n            either ``=`` or ``:``. Section names and keys are case-insensitive.\n            Leading and trailing whitespace is removed from keys and values.\n            Values can be omitted, in which case the key/value delimiter may\n            also be left out. Values can also span multiple lines, as long as\n            they are indented deeper than the first line of the value. Commends\n            are prefixed by ``#`` or ``;`` and may only appear on their own on\n            an otherwise empty line.\n\n            Both section and key names may contain dots (``.``) as namespace\n            separators. The actual configuration parameter name is constructed\n            by joining section name and key name together and converting to\n            lower case.\n\n            The special sections ``bottle`` and ``ROOT`` refer to the root\n            namespace and the ``DEFAULT`` section defines default values for all\n            other sections.\n\n            With Python 3, extended string interpolation is enabled.\n\n            :param filename: The path of a config file, or a list of paths.\n            :param options: All keyword parameters are passed to the underlying\n                :class:`python:configparser.ConfigParser` constructor call.\n\n        \"\"\"\n        options.setdefault('allow_no_value', True)\n        if py3k:\n            options.setdefault('interpolation',\n                               configparser.ExtendedInterpolation())\n        conf = configparser.ConfigParser(**options)\n        conf.read(filename)\n        for section in conf.sections():\n            for key in conf.options(section):\n                value = conf.get(section, key)\n                if section not in ['bottle', 'ROOT']:\n                    key = section + '.' + key\n                self[key.lower()] = value\n        return self\n\n    def load_dict(self, source, namespace=''):\n        \"\"\" Load values from a dictionary structure. Nesting can be used to\n            represent namespaces.\n\n            >>> c = ConfigDict()\n            >>> c.load_dict({'some': {'namespace': {'key': 'value'} } })\n            {'some.namespace.key': 'value'}\n        \"\"\"\n        for key, value in source.items():\n            if isinstance(key, basestring):\n                nskey = (namespace + '.' + key).strip('.')\n                if isinstance(value, dict):\n                    self.load_dict(value, namespace=nskey)\n                else:\n                    self[nskey] = value\n            else:\n                raise TypeError('Key has type %r (not a string)' % type(key))\n        return self\n\n    def update(self, *a, **ka):\n        \"\"\" If the first parameter is a string, all keys are prefixed with this\n            namespace. Apart from that it works just as the usual dict.update().\n\n            >>> c = ConfigDict()\n            >>> c.update('some.namespace', key='value')\n        \"\"\"\n        prefix = ''\n        if a and isinstance(a[0], basestring):\n            prefix = a[0].strip('.') + '.'\n            a = a[1:]\n        for key, value in dict(*a, **ka).items():\n            self[prefix + key] = value\n\n    def setdefault(self, key, value):\n        if key not in self:\n            self[key] = value\n        return self[key]\n\n    def __setitem__(self, key, value):\n        if not isinstance(key, basestring):\n            raise TypeError('Key has type %r (not a string)' % type(key))\n\n        self._virtual_keys.discard(key)\n\n        value = self.meta_get(key, 'filter', lambda x: x)(value)\n        if key in self and self[key] is value:\n            return\n\n        self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n\n        for overlay in self._iter_overlays():\n            overlay._set_virtual(key, value)\n\n    def __delitem__(self, key):\n        if key not in self:\n            raise KeyError(key)\n        if key in self._virtual_keys:\n            raise KeyError(\"Virtual keys cannot be deleted: %s\" % key)\n\n        if self._source and key in self._source:\n            # Not virtual, but present in source -> Restore virtual value\n            dict.__delitem__(self, key)\n            self._set_virtual(key, self._source[key])\n        else:  # not virtual, not present in source. This is OUR value\n            self._on_change(key, None)\n            dict.__delitem__(self, key)\n            for overlay in self._iter_overlays():\n                overlay._delete_virtual(key)\n\n    def _set_virtual(self, key, value):\n        \"\"\" Recursively set or update virtual keys. Do nothing if non-virtual\n            value is present. \"\"\"\n        if key in self and key not in self._virtual_keys:\n            return  # Do nothing for non-virtual keys.\n\n        self._virtual_keys.add(key)\n        if key in self and self[key] is not value:\n            self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n        for overlay in self._iter_overlays():\n            overlay._set_virtual(key, value)\n\n    def _delete_virtual(self, key):\n        \"\"\" Recursively delete virtual entry. Do nothing if key is not virtual.\n        \"\"\"\n        if key not in self._virtual_keys:\n            return  # Do nothing for non-virtual keys.\n\n        if key in self:\n            self._on_change(key, None)\n        dict.__delitem__(self, key)\n        self._virtual_keys.discard(key)\n        for overlay in self._iter_overlays():\n            overlay._delete_virtual(key)\n\n    def _on_change(self, key, value):\n        for cb in self._change_listener:\n            if cb(self, key, value):\n                return True\n\n    def _add_change_listener(self, func):\n        self._change_listener.append(func)\n        return func\n\n    def meta_get(self, key, metafield, default=None):\n        \"\"\" Return the value of a meta field for a key. \"\"\"\n        return self._meta.get(key, {}).get(metafield, default)\n\n    def meta_set(self, key, metafield, value):\n        \"\"\" Set the meta field for a key to a new value. \"\"\"\n        self._meta.setdefault(key, {})[metafield] = value\n\n    def meta_list(self, key):\n        \"\"\" Return an iterable of meta field names defined for a key. \"\"\"\n        return self._meta.get(key, {}).keys()\n\n    def _define(self, key, default=_UNSET, help=_UNSET, validate=_UNSET):\n        \"\"\" (Unstable) Shortcut for plugins to define own config parameters. \"\"\"\n        if default is not _UNSET:\n            self.setdefault(key, default)\n        if help is not _UNSET:\n            self.meta_set(key, 'help', help)\n        if validate is not _UNSET:\n            self.meta_set(key, 'validate', validate)\n\n    def _iter_overlays(self):\n        for ref in self._overlays:\n            overlay = ref()\n            if overlay is not None:\n                yield overlay\n\n    def _make_overlay(self):\n        \"\"\" (Unstable) Create a new overlay that acts like a chained map: Values\n            missing in the overlay are copied from the source map. Both maps\n            share the same meta entries.\n\n            Entries that were copied from the source are called 'virtual'. You\n            can not delete virtual keys, but overwrite them, which turns them\n            into non-virtual entries. Setting keys on an overlay never affects\n            its source, but may affect any number of child overlays.\n\n            Other than collections.ChainMap or most other implementations, this\n            approach does not resolve missing keys on demand, but instead\n            actively copies all values from the source to the overlay and keeps\n            track of virtual and non-virtual keys internally. This removes any\n            lookup-overhead. Read-access is as fast as a build-in dict for both\n            virtual and non-virtual keys.\n\n            Changes are propagated recursively and depth-first. A failing\n            on-change handler in an overlay stops the propagation of virtual\n            values and may result in an partly updated tree. Take extra care\n            here and make sure that on-change handlers never fail.\n\n            Used by Route.config\n        \"\"\"\n        # Cleanup dead references\n        self._overlays[:] = [ref for ref in self._overlays if ref() is not None]\n\n        overlay = ConfigDict()\n        overlay._meta = self._meta\n        overlay._source = self\n        self._overlays.append(weakref.ref(overlay))\n        for key in self:\n            overlay._set_virtual(key, self[key])\n        return overlay\n\n\n\n\nclass AppStack(list):\n    \"\"\" A stack-like list. Calling it returns the head of the stack. \"\"\"\n\n    def __call__(self):\n        \"\"\" Return the current default application. \"\"\"\n        return self.default\n\n    def push(self, value=None):\n        \"\"\" Add a new :class:`Bottle` instance to the stack \"\"\"\n        if not isinstance(value, Bottle):\n            value = Bottle()\n        self.append(value)\n        return value\n    new_app = push\n\n    @property\n    def default(self):\n        try:\n            return self[-1]\n        except IndexError:\n            return self.push()\n\n\nclass WSGIFileWrapper(object):\n    def __init__(self, fp, buffer_size=1024 * 64):\n        self.fp, self.buffer_size = fp, buffer_size\n        for attr in ('fileno', 'close', 'read', 'readlines', 'tell', 'seek'):\n            if hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))\n\n    def __iter__(self):\n        buff, read = self.buffer_size, self.read\n        while True:\n            part = read(buff)\n            if not part: return\n            yield part\n\n\nclass _closeiter(object):\n    \"\"\" This only exists to be able to attach a .close method to iterators that\n        do not support attribute assignment (most of itertools). \"\"\"\n\n    def __init__(self, iterator, close=None):\n        self.iterator = iterator\n        self.close_callbacks = makelist(close)\n\n    def __iter__(self):\n        return iter(self.iterator)\n\n    def close(self):\n        for func in self.close_callbacks:\n            func()\n\n\nclass ResourceManager(object):\n    \"\"\" This class manages a list of search paths and helps to find and open\n        application-bound resources (files).\n\n        :param base: default value for :meth:`add_path` calls.\n        :param opener: callable used to open resources.\n        :param cachemode: controls which lookups are cached. One of 'all',\n                         'found' or 'none'.\n    \"\"\"\n\n    def __init__(self, base='./', opener=open, cachemode='all'):\n        self.opener = opener\n        self.base = base\n        self.cachemode = cachemode\n\n        #: A list of search paths. See :meth:`add_path` for details.\n        self.path = []\n        #: A cache for resolved paths. ``res.cache.clear()`` clears the cache.\n        self.cache = {}\n\n    def add_path(self, path, base=None, index=None, create=False):\n        \"\"\" Add a new path to the list of search paths. Return False if the\n            path does not exist.\n\n            :param path: The new search path. Relative paths are turned into\n                an absolute and normalized form. If the path looks like a file\n                (not ending in `/`), the filename is stripped off.\n            :param base: Path used to absolutize relative search paths.\n                Defaults to :attr:`base` which defaults to ``os.getcwd()``.\n            :param index: Position within the list of search paths. Defaults\n                to last index (appends to the list).\n\n            The `base` parameter makes it easy to reference files installed\n            along with a python module or package::\n\n                res.add_path('./resources/', __file__)\n        \"\"\"\n        base = os.path.abspath(os.path.dirname(base or self.base))\n        path = os.path.abspath(os.path.join(base, os.path.dirname(path)))\n        path += os.sep\n        if path in self.path:\n            self.path.remove(path)\n        if create and not os.path.isdir(path):\n            os.makedirs(path)\n        if index is None:\n            self.path.append(path)\n        else:\n            self.path.insert(index, path)\n        self.cache.clear()\n        return os.path.exists(path)\n\n    def __iter__(self):\n        \"\"\" Iterate over all existing files in all registered paths. \"\"\"\n        search = self.path[:]\n        while search:\n            path = search.pop()\n            if not os.path.isdir(path): continue\n            for name in os.listdir(path):\n                full = os.path.join(path, name)\n                if os.path.isdir(full): search.append(full)\n                else: yield full\n\n    def lookup(self, name):\n        \"\"\" Search for a resource and return an absolute file path, or `None`.\n\n            The :attr:`path` list is searched in order. The first match is\n            returend. Symlinks are followed. The result is cached to speed up\n            future lookups. \"\"\"\n        if name not in self.cache or DEBUG:\n            for path in self.path:\n                fpath = os.path.join(path, name)\n                if os.path.isfile(fpath):\n                    if self.cachemode in ('all', 'found'):\n                        self.cache[name] = fpath\n                    return fpath\n            if self.cachemode == 'all':\n                self.cache[name] = None\n        return self.cache[name]\n\n    def open(self, name, mode='r', *args, **kwargs):\n        \"\"\" Find a resource and return a file object, or raise IOError. \"\"\"\n        fname = self.lookup(name)\n        if not fname: raise IOError(\"Resource %r not found.\" % name)\n        return self.opener(fname, mode=mode, *args, **kwargs)\n\n\nclass FileUpload(object):\n    def __init__(self, fileobj, name, filename, headers=None):\n        \"\"\" Wrapper for file uploads. \"\"\"\n        #: Open file(-like) object (BytesIO buffer or temporary file)\n        self.file = fileobj\n        #: Name of the upload form field\n        self.name = name\n        #: Raw filename as sent by the client (may contain unsafe characters)\n        self.raw_filename = filename\n        #: A :class:`HeaderDict` with additional headers (e.g. content-type)\n        self.headers = HeaderDict(headers) if headers else HeaderDict()\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int, default=-1)\n\n    @cached_property\n    def filename(self):\n        \"\"\" Name of the file on the client file system, but normalized to ensure\n            file system compatibility. An empty filename is returned as 'empty'.\n\n            Only ASCII letters, digits, dashes, underscores and dots are\n            allowed in the final filename. Accents are removed, if possible.\n            Whitespace is replaced by a single dash. Leading or tailing dots\n            or dashes are removed. The filename is limited to 255 characters.\n        \"\"\"\n        fname = self.raw_filename\n        if not isinstance(fname, unicode):\n            fname = fname.decode('utf8', 'ignore')\n        fname = normalize('NFKD', fname)\n        fname = fname.encode('ASCII', 'ignore').decode('ASCII')\n        fname = os.path.basename(fname.replace('\\\\', os.path.sep))\n        fname = re.sub(r'[^a-zA-Z0-9-_.\\s]', '', fname).strip()\n        fname = re.sub(r'[-\\s]+', '-', fname).strip('.-')\n        return fname[:255] or 'empty'\n\n    def _copy_file(self, fp, chunk_size=2 ** 16):\n        read, write, offset = self.file.read, fp.write, self.file.tell()\n        while 1:\n            buf = read(chunk_size)\n            if not buf: break\n            write(buf)\n        self.file.seek(offset)\n\n    def save(self, destination, overwrite=False, chunk_size=2 ** 16):\n        \"\"\" Save file to disk or copy its content to an open file(-like) object.\n            If *destination* is a directory, :attr:`filename` is added to the\n            path. Existing files are not overwritten by default (IOError).\n\n            :param destination: File path, directory or file(-like) object.\n            :param overwrite: If True, replace existing files. (default: False)\n            :param chunk_size: Bytes to read at a time. (default: 64kb)\n        \"\"\"\n        if isinstance(destination, basestring):  # Except file-likes here\n            if os.path.isdir(destination):\n                destination = os.path.join(destination, self.filename)\n            if not overwrite and os.path.exists(destination):\n                raise IOError('File exists.')\n            with open(destination, 'wb') as fp:\n                self._copy_file(fp, chunk_size)\n        else:\n            self._copy_file(destination, chunk_size)\n\n###############################################################################\n# Application Helper ###########################################################\n###############################################################################\n\n\ndef abort(code=500, text='Unknown Error.'):\n    \"\"\" Aborts execution and causes a HTTP error. \"\"\"\n    raise HTTPError(code, text)\n\n\ndef redirect(url, code=None):\n    \"\"\" Aborts execution and causes a 303 or 302 redirect, depending on\n        the HTTP protocol version. \"\"\"\n    if not code:\n        code = 303 if request.get('SERVER_PROTOCOL') == \"HTTP/1.1\" else 302\n    res = response.copy(cls=HTTPResponse)\n    res.status = code\n    res.body = \"\"\n    res.set_header('Location', urljoin(request.url, url))\n    raise res\n\n\ndef _file_iter_range(fp, offset, bytes, maxread=1024 * 1024):\n    \"\"\" Yield chunks from a range in a file. No chunk is bigger than maxread.\"\"\"\n    fp.seek(offset)\n    while bytes > 0:\n        part = fp.read(min(bytes, maxread))\n        if not part: break\n        bytes -= len(part)\n        yield part\n\n\ndef static_file(filename, root,\n                mimetype=True,\n                download=False,\n                charset='UTF-8',\n                etag=None):\n    \"\"\" Open a file in a safe way and return an instance of :exc:`HTTPResponse`\n        that can be sent back to the client.\n\n        :param filename: Name or path of the file to send, relative to ``root``.\n        :param root: Root path for file lookups. Should be an absolute directory\n            path.\n        :param mimetype: Provide the content-type header (default: guess from\n            file extension)\n        :param download: If True, ask the browser to open a `Save as...` dialog\n            instead of opening the file with the associated program. You can\n            specify a custom filename as a string. If not specified, the\n            original filename is used (default: False).\n        :param charset: The charset for files with a ``text/*`` mime-type.\n            (default: UTF-8)\n        :param etag: Provide a pre-computed ETag header. If set to ``False``,\n            ETag handling is disabled. (default: auto-generate ETag header)\n\n        While checking user input is always a good idea, this function provides\n        additional protection against malicious ``filename`` parameters from\n        breaking out of the ``root`` directory and leaking sensitive information\n        to an attacker.\n\n        Read-protected files or files outside of the ``root`` directory are\n        answered with ``403 Access Denied``. Missing files result in a\n        ``404 Not Found`` response. Conditional requests (``If-Modified-Since``,\n        ``If-None-Match``) are answered with ``304 Not Modified`` whenever\n        possible. ``HEAD`` and ``Range`` requests (used by download managers to\n        check or continue partial downloads) are also handled automatically.\n\n    \"\"\"\n\n    root = os.path.join(os.path.abspath(root), '')\n    filename = os.path.abspath(os.path.join(root, filename.strip('/\\\\')))\n    headers = dict()\n\n    if not filename.startswith(root):\n        return HTTPError(403, \"Access denied.\")\n    if not os.path.exists(filename) or not os.path.isfile(filename):\n        return HTTPError(404, \"File does not exist.\")\n    if not os.access(filename, os.R_OK):\n        return HTTPError(403, \"You do not have permission to access this file.\")\n\n    if mimetype is True:\n        if download and download is not True:\n            mimetype, encoding = mimetypes.guess_type(download)\n        else:\n            mimetype, encoding = mimetypes.guess_type(filename)\n        if encoding: headers['Content-Encoding'] = encoding\n\n    if mimetype:\n        if (mimetype[:5] == 'text/' or mimetype == 'application/javascript')\\\n        and charset and 'charset' not in mimetype:\n            mimetype += '; charset=%s' % charset\n        headers['Content-Type'] = mimetype\n\n    if download:\n        download = os.path.basename(filename if download is True else download)\n        headers['Content-Disposition'] = 'attachment; filename=\"%s\"' % download\n\n    stats = os.stat(filename)\n    headers['Content-Length'] = clen = stats.st_size\n    lm = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", time.gmtime(stats.st_mtime))\n    headers['Last-Modified'] = lm\n    headers['Date'] = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", time.gmtime())\n\n    getenv = request.environ.get\n\n    if etag is None:\n        etag = '%d:%d:%d:%d:%s' % (stats.st_dev, stats.st_ino, stats.st_mtime,\n                                   clen, filename)\n        etag = hashlib.sha1(tob(etag)).hexdigest()\n\n    if etag:\n        headers['ETag'] = etag\n        check = getenv('HTTP_IF_NONE_MATCH')\n        if check and check == etag:\n            return HTTPResponse(status=304, **headers)\n\n    ims = getenv('HTTP_IF_MODIFIED_SINCE')\n    if ims:\n        ims = parse_date(ims.split(\";\")[0].strip())\n    if ims is not None and ims >= int(stats.st_mtime):\n        return HTTPResponse(status=304, **headers)\n\n    body = '' if request.method == 'HEAD' else open(filename, 'rb')\n\n    headers[\"Accept-Ranges\"] = \"bytes\"\n    range_header = getenv('HTTP_RANGE')\n    if range_header:\n        ranges = list(parse_range_header(range_header, clen))\n        if not ranges:\n            return HTTPError(416, \"Requested Range Not Satisfiable\")\n        offset, end = ranges[0]\n        headers[\"Content-Range\"] = \"bytes %d-%d/%d\" % (offset, end - 1, clen)\n        headers[\"Content-Length\"] = str(end - offset)\n        if body: body = _file_iter_range(body, offset, end - offset)\n        return HTTPResponse(body, status=206, **headers)\n    return HTTPResponse(body, **headers)\n\n###############################################################################\n# HTTP Utilities and MISC (TODO) ###############################################\n###############################################################################\n\n\ndef debug(mode=True):\n    \"\"\" Change the debug level.\n    There is only one debug level supported at the moment.\"\"\"\n    global DEBUG\n    if mode: warnings.simplefilter('default')\n    DEBUG = bool(mode)\n\n\ndef http_date(value):\n    if isinstance(value, (datedate, datetime)):\n        value = value.utctimetuple()\n    elif isinstance(value, (int, float)):\n        value = time.gmtime(value)\n    if not isinstance(value, basestring):\n        value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n    return value\n\n\ndef parse_date(ims):\n    \"\"\" Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. \"\"\"\n    try:\n        ts = email.utils.parsedate_tz(ims)\n        return time.mktime(ts[:8] + (0, )) - (ts[9] or 0) - time.timezone\n    except (TypeError, ValueError, IndexError, OverflowError):\n        return None\n\n\ndef parse_auth(header):\n    \"\"\" Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None\"\"\"\n    try:\n        method, data = header.split(None, 1)\n        if method.lower() == 'basic':\n            user, pwd = touni(base64.b64decode(tob(data))).split(':', 1)\n            return user, pwd\n    except (KeyError, ValueError):\n        return None\n\n\ndef parse_range_header(header, maxlen=0):\n    \"\"\" Yield (start, end) ranges parsed from a HTTP Range header. Skip\n        unsatisfiable ranges. The end index is non-inclusive.\"\"\"\n    if not header or header[:6] != 'bytes=': return\n    ranges = [r.split('-', 1) for r in header[6:].split(',') if '-' in r]\n    for start, end in ranges:\n        try:\n            if not start:  # bytes=-100    -> last 100 bytes\n                start, end = max(0, maxlen - int(end)), maxlen\n            elif not end:  # bytes=100-    -> all but the first 99 bytes\n                start, end = int(start), maxlen\n            else:  # bytes=100-200 -> bytes 100-200 (inclusive)\n                start, end = int(start), min(int(end) + 1, maxlen)\n            if 0 <= start < end <= maxlen:\n                yield start, end\n        except ValueError:\n            pass\n\n\n#: Header tokenizer used by _parse_http_header()\n_hsplit = re.compile('(?:(?:\"((?:[^\"\\\\\\\\]+|\\\\\\\\.)*)\")|([^;,=]+))([;,=]?)').findall\n\ndef _parse_http_header(h):\n    \"\"\" Parses a typical multi-valued and parametrised HTTP header (e.g. Accept headers) and returns a list of values\n        and parameters. For non-standard or broken input, this implementation may return partial results.\n    :param h: A header string (e.g. ``text/html,text/plain;q=0.9,*/*;q=0.8``)\n    :return: List of (value, params) tuples. The second element is a (possibly empty) dict.\n    \"\"\"\n    values = []\n    if '\"' not in h:  # INFO: Fast path without regexp (~2x faster)\n        for value in h.split(','):\n            parts = value.split(';')\n            values.append((parts[0].strip(), {}))\n            for attr in parts[1:]:\n                name, value = attr.split('=', 1)\n                values[-1][1][name.strip()] = value.strip()\n    else:\n        lop, key, attrs = ',', None, {}\n        for quoted, plain, tok in _hsplit(h):\n            value = plain.strip() if plain else quoted.replace('\\\\\"', '\"')\n            if lop == ',':\n                attrs = {}\n                values.append((value, attrs))\n            elif lop == ';':\n                if tok == '=':\n                    key = value\n                else:\n                    attrs[value] = ''\n            elif lop == '=' and key:\n                attrs[key] = value\n                key = None\n            lop = tok\n    return values\n\n\ndef _parse_qsl(qs):\n    r = []\n    for pair in qs.replace(';', '&').split('&'):\n        if not pair: continue\n        nv = pair.split('=', 1)\n        if len(nv) != 2: nv.append('')\n        key = urlunquote(nv[0].replace('+', ' '))\n        value = urlunquote(nv[1].replace('+', ' '))\n        r.append((key, value))\n    return r\n\n\ndef _lscmp(a, b):\n    \"\"\" Compares two strings in a cryptographically safe way:\n        Runtime is not affected by length of common prefix. \"\"\"\n    return not sum(0 if x == y else 1\n                   for x, y in zip(a, b)) and len(a) == len(b)\n\n\ndef cookie_encode(data, key, digestmod=None):\n    \"\"\" Encode and sign a pickle-able object. Return a (byte) string \"\"\"\n    digestmod = digestmod or hashlib.sha256\n    msg = base64.b64encode(pickle.dumps(data, -1))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=digestmod).digest())\n    return tob('!') + sig + tob('?') + msg\n\n\ndef cookie_decode(data, key, digestmod=None):\n    \"\"\" Verify and decode an encoded string. Return an object or None.\"\"\"\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(tob('?'), 1)\n        digestmod = digestmod or hashlib.sha256\n        hashed = hmac.new(tob(key), msg, digestmod=digestmod).digest()\n        if _lscmp(sig[1:], base64.b64encode(hashed)):\n            return pickle.loads(base64.b64decode(msg))\n    return None\n\n\ndef cookie_is_encoded(data):\n    \"\"\" Return True if the argument looks like a encoded cookie.\"\"\"\n    return bool(data.startswith(tob('!')) and tob('?') in data)\n\n\ndef html_escape(string):\n    \"\"\" Escape HTML special characters ``&<>`` and quotes ``'\"``. \"\"\"\n    return string.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\\\n                 .replace('\"', '&quot;').replace(\"'\", '&#039;')\n\n\ndef html_quote(string):\n    \"\"\" Escape and quote a string to be used as an HTTP attribute.\"\"\"\n    return '\"%s\"' % html_escape(string).replace('\\n', '&#10;')\\\n                    .replace('\\r', '&#13;').replace('\\t', '&#9;')\n\n\ndef yieldroutes(func):\n    \"\"\" Return a generator for routes that match the signature (name, args)\n    of the func parameter. This may yield more than one route if the function\n    takes optional keyword arguments. The output is best described by example::\n\n        a()         -> '/a'\n        b(x, y)     -> '/b/<x>/<y>'\n        c(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'\n        d(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'\n    \"\"\"\n    path = '/' + func.__name__.replace('__', '/').lstrip('/')\n    spec = getargspec(func)\n    argc = len(spec[0]) - len(spec[3] or [])\n    path += ('/<%s>' * argc) % tuple(spec[0][:argc])\n    yield path\n    for arg in spec[0][argc:]:\n        path += '/<%s>' % arg\n        yield path\n\n\ndef path_shift(script_name, path_info, shift=1):\n    \"\"\" Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.\n\n        :return: The modified paths.\n        :param script_name: The SCRIPT_NAME path.\n        :param script_name: The PATH_INFO path.\n        :param shift: The number of path fragments to shift. May be negative to\n          change the shift direction. (default: 1)\n    \"\"\"\n    if shift == 0: return script_name, path_info\n    pathlist = path_info.strip('/').split('/')\n    scriptlist = script_name.strip('/').split('/')\n    if pathlist and pathlist[0] == '': pathlist = []\n    if scriptlist and scriptlist[0] == '': scriptlist = []\n    if 0 < shift <= len(pathlist):\n        moved = pathlist[:shift]\n        scriptlist = scriptlist + moved\n        pathlist = pathlist[shift:]\n    elif 0 > shift >= -len(scriptlist):\n        moved = scriptlist[shift:]\n        pathlist = moved + pathlist\n        scriptlist = scriptlist[:shift]\n    else:\n        empty = 'SCRIPT_NAME' if shift < 0 else 'PATH_INFO'\n        raise AssertionError(\"Cannot shift. Nothing left from %s\" % empty)\n    new_script_name = '/' + '/'.join(scriptlist)\n    new_path_info = '/' + '/'.join(pathlist)\n    if path_info.endswith('/') and pathlist: new_path_info += '/'\n    return new_script_name, new_path_info\n\n\ndef auth_basic(check, realm=\"private\", text=\"Access denied\"):\n    \"\"\" Callback decorator to require HTTP auth (basic).\n        TODO: Add route(check_auth=...) parameter. \"\"\"\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*a, **ka):\n            user, password = request.auth or (None, None)\n            if user is None or not check(user, password):\n                err = HTTPError(401, text)\n                err.add_header('WWW-Authenticate', 'Basic realm=\"%s\"' % realm)\n                return err\n            return func(*a, **ka)\n\n        return wrapper\n\n    return decorator\n\n# Shortcuts for common Bottle methods.\n# They all refer to the current default application.\n\n\ndef make_default_app_wrapper(name):\n    \"\"\" Return a callable that relays calls to the current default app. \"\"\"\n\n    @functools.wraps(getattr(Bottle, name))\n    def wrapper(*a, **ka):\n        return getattr(app(), name)(*a, **ka)\n\n    return wrapper\n\n\nroute     = make_default_app_wrapper('route')\nget       = make_default_app_wrapper('get')\npost      = make_default_app_wrapper('post')\nput       = make_default_app_wrapper('put')\ndelete    = make_default_app_wrapper('delete')\npatch     = make_default_app_wrapper('patch')\nerror     = make_default_app_wrapper('error')\nmount     = make_default_app_wrapper('mount')\nhook      = make_default_app_wrapper('hook')\ninstall   = make_default_app_wrapper('install')\nuninstall = make_default_app_wrapper('uninstall')\nurl       = make_default_app_wrapper('get_url')\n\n###############################################################################\n# Server Adapter ###############################################################\n###############################################################################\n\n# Before you edit or add a server adapter, please read:\n# - https://github.com/bottlepy/bottle/pull/647#issuecomment-60152870\n# - https://github.com/bottlepy/bottle/pull/865#issuecomment-242795341\n\nclass ServerAdapter(object):\n    quiet = False\n\n    def __init__(self, host='127.0.0.1', port=8080, **options):\n        self.options = options\n        self.host = host\n        self.port = int(port)\n\n    def run(self, handler):  # pragma: no cover\n        pass\n\n    def __repr__(self):\n        args = ', '.join(['%s=%s' % (k, repr(v))\n                          for k, v in self.options.items()])\n        return \"%s(%s)\" % (self.__class__.__name__, args)\n\n\nclass CGIServer(ServerAdapter):\n    quiet = True\n\n    def run(self, handler):  # pragma: no cover\n        from wsgiref.handlers import CGIHandler\n\n        def fixed_environ(environ, start_response):\n            environ.setdefault('PATH_INFO', '')\n            return handler(environ, start_response)\n\n        CGIHandler().run(fixed_environ)\n\n\nclass FlupFCGIServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        import flup.server.fcgi\n        self.options.setdefault('bindAddress', (self.host, self.port))\n        flup.server.fcgi.WSGIServer(handler, **self.options).run()\n\n\nclass WSGIRefServer(ServerAdapter):\n    def run(self, app):  # pragma: no cover\n        from wsgiref.simple_server import make_server\n        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer\n        import socket\n\n        class FixedHandler(WSGIRequestHandler):\n            def address_string(self):  # Prevent reverse DNS lookups please.\n                return self.client_address[0]\n\n            def log_request(*args, **kw):\n                if not self.quiet:\n                    return WSGIRequestHandler.log_request(*args, **kw)\n\n        handler_cls = self.options.get('handler_class', FixedHandler)\n        server_cls = self.options.get('server_class', WSGIServer)\n\n        if ':' in self.host:  # Fix wsgiref for IPv6 addresses.\n            if getattr(server_cls, 'address_family') == socket.AF_INET:\n\n                class server_cls(server_cls):\n                    address_family = socket.AF_INET6\n\n        self.srv = make_server(self.host, self.port, app, server_cls,\n                               handler_cls)\n        self.port = self.srv.server_port  # update port actual port (0 means random)\n        try:\n            self.srv.serve_forever()\n        except KeyboardInterrupt:\n            self.srv.server_close()  # Prevent ResourceWarning: unclosed socket\n            raise\n\n\nclass CherryPyServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        from cherrypy import wsgiserver\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n\n        certfile = self.options.get('certfile')\n        if certfile:\n            del self.options['certfile']\n        keyfile = self.options.get('keyfile')\n        if keyfile:\n            del self.options['keyfile']\n\n        server = wsgiserver.CherryPyWSGIServer(**self.options)\n        if certfile:\n            server.ssl_certificate = certfile\n        if keyfile:\n            server.ssl_private_key = keyfile\n\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass WaitressServer(ServerAdapter):\n    def run(self, handler):\n        from waitress import serve\n        serve(handler, host=self.host, port=self.port, _quiet=self.quiet, **self.options)\n\n\nclass PasteServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        from paste import httpserver\n        from paste.translogger import TransLogger\n        handler = TransLogger(handler, setup_console_handler=(not self.quiet))\n        httpserver.serve(handler,\n                         host=self.host,\n                         port=str(self.port), **self.options)\n\n\nclass MeinheldServer(ServerAdapter):\n    def run(self, handler):\n        from meinheld import server\n        server.listen((self.host, self.port))\n        server.run(handler)\n\n\nclass FapwsServer(ServerAdapter):\n    \"\"\" Extremely fast webserver using libev. See http://www.fapws.org/ \"\"\"\n\n    def run(self, handler):  # pragma: no cover\n        import fapws._evwsgi as evwsgi\n        from fapws import base, config\n        port = self.port\n        if float(config.SERVER_IDENT[-2:]) > 0.4:\n            # fapws3 silently changed its API in 0.5\n            port = str(port)\n        evwsgi.start(self.host, port)\n        # fapws3 never releases the GIL. Complain upstream. I tried. No luck.\n        if 'BOTTLE_CHILD' in os.environ and not self.quiet:\n            _stderr(\"WARNING: Auto-reloading does not work with Fapws3.\\n\")\n            _stderr(\"         (Fapws3 breaks python thread support)\\n\")\n        evwsgi.set_base_module(base)\n\n        def app(environ, start_response):\n            environ['wsgi.multiprocess'] = False\n            return handler(environ, start_response)\n\n        evwsgi.wsgi_cb(('', app))\n        evwsgi.run()\n\n\nclass TornadoServer(ServerAdapter):\n    \"\"\" The super hyped asynchronous server by facebook. Untested. \"\"\"\n\n    def run(self, handler):  # pragma: no cover\n        import tornado.wsgi, tornado.httpserver, tornado.ioloop\n        container = tornado.wsgi.WSGIContainer(handler)\n        server = tornado.httpserver.HTTPServer(container)\n        server.listen(port=self.port, address=self.host)\n        tornado.ioloop.IOLoop.instance().start()\n\n\nclass AppEngineServer(ServerAdapter):\n    \"\"\" Adapter for Google App Engine. \"\"\"\n    quiet = True\n\n    def run(self, handler):\n        depr(0, 13, \"AppEngineServer no longer required\",\n             \"Configure your application directly in your app.yaml\")\n        from google.appengine.ext.webapp import util\n        # A main() function in the handler script enables 'App Caching'.\n        # Lets makes sure it is there. This _really_ improves performance.\n        module = sys.modules.get('__main__')\n        if module and not hasattr(module, 'main'):\n            module.main = lambda: util.run_wsgi_app(handler)\n        util.run_wsgi_app(handler)\n\n\nclass TwistedServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        from twisted.web import server, wsgi\n        from twisted.python.threadpool import ThreadPool\n        from twisted.internet import reactor\n        thread_pool = ThreadPool()\n        thread_pool.start()\n        reactor.addSystemEventTrigger('after', 'shutdown', thread_pool.stop)\n        factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))\n        reactor.listenTCP(self.port, factory, interface=self.host)\n        if not reactor.running:\n            reactor.run()\n\n\nclass DieselServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        from diesel.protocols.wsgi import WSGIApplication\n        app = WSGIApplication(handler, port=self.port)\n        app.run()\n\n\nclass GeventServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * See gevent.wsgi.WSGIServer() documentation for more options.\n    \"\"\"\n\n    def run(self, handler):\n        from gevent import pywsgi, local\n        if not isinstance(threading.local(), local.local):\n            msg = \"Bottle requires gevent.monkey.patch_all() (before import)\"\n            raise RuntimeError(msg)\n        if self.quiet:\n            self.options['log'] = None\n        address = (self.host, self.port)\n        server = pywsgi.WSGIServer(address, handler, **self.options)\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: server.stop())\n        server.serve_forever()\n\n\nclass GunicornServer(ServerAdapter):\n    \"\"\" Untested. See http://gunicorn.org/configure.html for options. \"\"\"\n\n    def run(self, handler):\n        from gunicorn.app.base import Application\n\n        config = {'bind': \"%s:%d\" % (self.host, int(self.port))}\n        config.update(self.options)\n\n        class GunicornApplication(Application):\n            def init(self, parser, opts, args):\n                return config\n\n            def load(self):\n                return handler\n\n        GunicornApplication().run()\n\n\nclass EventletServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * `backlog` adjust the eventlet backlog parameter which is the maximum\n          number of queued connections. Should be at least 1; the maximum\n          value is system-dependent.\n        * `family`: (default is 2) socket family, optional. See socket\n          documentation for available families.\n    \"\"\"\n\n    def run(self, handler):\n        from eventlet import wsgi, listen, patcher\n        if not patcher.is_monkey_patched(os):\n            msg = \"Bottle requires eventlet.monkey_patch() (before import)\"\n            raise RuntimeError(msg)\n        socket_args = {}\n        for arg in ('backlog', 'family'):\n            try:\n                socket_args[arg] = self.options.pop(arg)\n            except KeyError:\n                pass\n        address = (self.host, self.port)\n        try:\n            wsgi.server(listen(address, **socket_args), handler,\n                        log_output=(not self.quiet))\n        except TypeError:\n            # Fallback, if we have old version of eventlet\n            wsgi.server(listen(address), handler)\n\n\nclass RocketServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        from rocket import Rocket\n        server = Rocket((self.host, self.port), 'wsgi', {'wsgi_app': handler})\n        server.start()\n\n\nclass BjoernServer(ServerAdapter):\n    \"\"\" Fast server written in C: https://github.com/jonashaag/bjoern \"\"\"\n\n    def run(self, handler):\n        from bjoern import run\n        run(handler, self.host, self.port)\n\nclass AsyncioServerAdapter(ServerAdapter):\n    \"\"\" Extend ServerAdapter for adding custom event loop \"\"\"\n    def get_event_loop(self):\n        pass\n\nclass AiohttpServer(AsyncioServerAdapter):\n    \"\"\" Untested.\n        aiohttp\n        https://pypi.python.org/pypi/aiohttp/\n    \"\"\"\n\n    def get_event_loop(self):\n        import asyncio\n        return asyncio.new_event_loop()\n\n    def run(self, handler):\n        import asyncio\n        from aiohttp.wsgi import WSGIServerHttpProtocol\n        self.loop = self.get_event_loop()\n        asyncio.set_event_loop(self.loop)\n\n        protocol_factory = lambda: WSGIServerHttpProtocol(\n            handler,\n            readpayload=True,\n            debug=(not self.quiet))\n        self.loop.run_until_complete(self.loop.create_server(protocol_factory,\n                                                             self.host,\n                                                             self.port))\n\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: self.loop.stop())\n\n        try:\n            self.loop.run_forever()\n        except KeyboardInterrupt:\n            self.loop.stop()\n\nclass AiohttpUVLoopServer(AiohttpServer):\n    \"\"\"uvloop\n       https://github.com/MagicStack/uvloop\n    \"\"\"\n    def get_event_loop(self):\n        import uvloop\n        return uvloop.new_event_loop()\n\nclass AutoServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    adapters = [WaitressServer, PasteServer, TwistedServer, CherryPyServer,\n                WSGIRefServer]\n\n    def run(self, handler):\n        for sa in self.adapters:\n            try:\n                return sa(self.host, self.port, **self.options).run(handler)\n            except ImportError:\n                pass\n\n\nserver_names = {\n    'cgi': CGIServer,\n    'flup': FlupFCGIServer,\n    'wsgiref': WSGIRefServer,\n    'waitress': WaitressServer,\n    'cherrypy': CherryPyServer,\n    'paste': PasteServer,\n    'fapws3': FapwsServer,\n    'tornado': TornadoServer,\n    'gae': AppEngineServer,\n    'twisted': TwistedServer,\n    'diesel': DieselServer,\n    'meinheld': MeinheldServer,\n    'gunicorn': GunicornServer,\n    'eventlet': EventletServer,\n    'gevent': GeventServer,\n    'rocket': RocketServer,\n    'bjoern': BjoernServer,\n    'aiohttp': AiohttpServer,\n    'uvloop': AiohttpUVLoopServer,\n    'auto': AutoServer,\n}\n\n###############################################################################\n# Application Control ##########################################################\n###############################################################################\n\n\ndef load(target, **namespace):\n    \"\"\" Import a module or fetch an object from a module.\n\n        * ``package.module`` returns `module` as a module object.\n        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`.\n        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result.\n\n        The last form accepts not only function calls, but any type of\n        expression. Keyword arguments passed to this function are available as\n        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')``\n    \"\"\"\n    module, target = target.split(\":\", 1) if ':' in target else (target, None)\n    if module not in sys.modules: __import__(module)\n    if not target: return sys.modules[module]\n    if target.isalnum(): return getattr(sys.modules[module], target)\n    package_name = module.split('.')[0]\n    namespace[package_name] = sys.modules[package_name]\n    return eval('%s.%s' % (module, target), namespace)\n\n\ndef load_app(target):\n    \"\"\" Load a bottle application from a module and make sure that the import\n        does not affect the current default application, but returns a separate\n        application object. See :func:`load` for the target parameter. \"\"\"\n    global NORUN\n    NORUN, nr_old = True, NORUN\n    tmp = default_app.push()  # Create a new \"default application\"\n    try:\n        rv = load(target)  # Import the target module\n        return rv if callable(rv) else tmp\n    finally:\n        default_app.remove(tmp)  # Remove the temporary added default application\n        NORUN = nr_old\n\n\n_debug = debug\n\n\ndef run(app=None,\n        server='wsgiref',\n        host='127.0.0.1',\n        port=8080,\n        interval=1,\n        reloader=False,\n        quiet=False,\n        plugins=None,\n        debug=None,\n        config=None, **kargs):\n    \"\"\" Start a server instance. This method blocks until the server terminates.\n\n        :param app: WSGI application or target string supported by\n               :func:`load_app`. (default: :func:`default_app`)\n        :param server: Server adapter to use. See :data:`server_names` keys\n               for valid names or pass a :class:`ServerAdapter` subclass.\n               (default: `wsgiref`)\n        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on\n               all interfaces including the external one. (default: 127.0.0.1)\n        :param port: Server port to bind to. Values below 1024 require root\n               privileges. (default: 8080)\n        :param reloader: Start auto-reloading server? (default: False)\n        :param interval: Auto-reloader interval in seconds (default: 1)\n        :param quiet: Suppress output to stdout and stderr? (default: False)\n        :param options: Options passed to the server adapter.\n     \"\"\"\n    if NORUN: return\n    if reloader and not os.environ.get('BOTTLE_CHILD'):\n        import subprocess\n        lockfile = None\n        try:\n            fd, lockfile = tempfile.mkstemp(prefix='bottle.', suffix='.lock')\n            os.close(fd)  # We only need this file to exist. We never write to it\n            while os.path.exists(lockfile):\n                args = [sys.executable] + sys.argv\n                environ = os.environ.copy()\n                environ['BOTTLE_CHILD'] = 'true'\n                environ['BOTTLE_LOCKFILE'] = lockfile\n                p = subprocess.Popen(args, env=environ)\n                while p.poll() is None:  # Busy wait...\n                    os.utime(lockfile, None)  # I am alive!\n                    time.sleep(interval)\n                if p.poll() != 3:\n                    if os.path.exists(lockfile): os.unlink(lockfile)\n                    sys.exit(p.poll())\n        except KeyboardInterrupt:\n            pass\n        finally:\n            if os.path.exists(lockfile):\n                os.unlink(lockfile)\n        return\n\n    try:\n        if debug is not None: _debug(debug)\n        app = app or default_app()\n        if isinstance(app, basestring):\n            app = load_app(app)\n        if not callable(app):\n            raise ValueError(\"Application is not callable: %r\" % app)\n\n        for plugin in plugins or []:\n            if isinstance(plugin, basestring):\n                plugin = load(plugin)\n            app.install(plugin)\n\n        if config:\n            app.config.update(config)\n\n        if server in server_names:\n            server = server_names.get(server)\n        if isinstance(server, basestring):\n            server = load(server)\n        if isinstance(server, type):\n            server = server(host=host, port=port, **kargs)\n        if not isinstance(server, ServerAdapter):\n            raise ValueError(\"Unknown or unsupported server: %r\" % server)\n\n        server.quiet = server.quiet or quiet\n        if not server.quiet:\n            _stderr(\"Bottle v%s server starting up (using %s)...\\n\" %\n                    (__version__, repr(server)))\n            _stderr(\"Listening on http://%s:%d/\\n\" %\n                    (server.host, server.port))\n            _stderr(\"Hit Ctrl-C to quit.\\n\\n\")\n\n        if reloader:\n            lockfile = os.environ.get('BOTTLE_LOCKFILE')\n            bgcheck = FileCheckerThread(lockfile, interval)\n            with bgcheck:\n                server.run(app)\n            if bgcheck.status == 'reload':\n                sys.exit(3)\n        else:\n            server.run(app)\n    except KeyboardInterrupt:\n        pass\n    except (SystemExit, MemoryError):\n        raise\n    except:\n        if not reloader: raise\n        if not getattr(server, 'quiet', quiet):\n            print_exc()\n        time.sleep(interval)\n        sys.exit(3)\n\n\nclass FileCheckerThread(threading.Thread):\n    \"\"\" Interrupt main-thread as soon as a changed module file is detected,\n        the lockfile gets deleted or gets too old. \"\"\"\n\n    def __init__(self, lockfile, interval):\n        threading.Thread.__init__(self)\n        self.daemon = True\n        self.lockfile, self.interval = lockfile, interval\n        #: Is one of 'reload', 'error' or 'exit'\n        self.status = None\n\n    def run(self):\n        exists = os.path.exists\n        mtime = lambda p: os.stat(p).st_mtime\n        files = dict()\n\n        for module in list(sys.modules.values()):\n            path = getattr(module, '__file__', '')\n            if path[-4:] in ('.pyo', '.pyc'): path = path[:-1]\n            if path and exists(path): files[path] = mtime(path)\n\n        while not self.status:\n            if not exists(self.lockfile)\\\n            or mtime(self.lockfile) < time.time() - self.interval - 5:\n                self.status = 'error'\n                thread.interrupt_main()\n            for path, lmtime in list(files.items()):\n                if not exists(path) or mtime(path) > lmtime:\n                    self.status = 'reload'\n                    thread.interrupt_main()\n                    break\n            time.sleep(self.interval)\n\n    def __enter__(self):\n        self.start()\n\n    def __exit__(self, exc_type, *_):\n        if not self.status: self.status = 'exit'  # silent exit\n        self.join()\n        return exc_type is not None and issubclass(exc_type, KeyboardInterrupt)\n\n###############################################################################\n# Template Adapters ############################################################\n###############################################################################\n\n\nclass TemplateError(BottleException):\n    pass\n\n\nclass BaseTemplate(object):\n    \"\"\" Base class and minimal API for template adapters \"\"\"\n    extensions = ['tpl', 'html', 'thtml', 'stpl']\n    settings = {}  #used in prepare()\n    defaults = {}  #used in render()\n\n    def __init__(self,\n                 source=None,\n                 name=None,\n                 lookup=None,\n                 encoding='utf8', **settings):\n        \"\"\" Create a new template.\n        If the source parameter (str or buffer) is missing, the name argument\n        is used to guess a template filename. Subclasses can assume that\n        self.source and/or self.filename are set. Both are strings.\n        The lookup, encoding and settings parameters are stored as instance\n        variables.\n        The lookup parameter stores a list containing directory paths.\n        The encoding parameter should be used to decode byte strings or files.\n        The settings parameter contains a dict for engine-specific settings.\n        \"\"\"\n        self.name = name\n        self.source = source.read() if hasattr(source, 'read') else source\n        self.filename = source.filename if hasattr(source, 'filename') else None\n        self.lookup = [os.path.abspath(x) for x in lookup] if lookup else []\n        self.encoding = encoding\n        self.settings = self.settings.copy()  # Copy from class variable\n        self.settings.update(settings)  # Apply\n        if not self.source and self.name:\n            self.filename = self.search(self.name, self.lookup)\n            if not self.filename:\n                raise TemplateError('Template %s not found.' % repr(name))\n        if not self.source and not self.filename:\n            raise TemplateError('No template specified.')\n        self.prepare(**self.settings)\n\n    @classmethod\n    def search(cls, name, lookup=None):\n        \"\"\" Search name in all directories specified in lookup.\n        First without, then with common extensions. Return first hit. \"\"\"\n        if not lookup:\n            raise depr(0, 12, \"Empty template lookup path.\", \"Configure a template lookup path.\")\n\n        if os.path.isabs(name):\n            raise depr(0, 12, \"Use of absolute path for template name.\",\n                       \"Refer to templates with names or paths relative to the lookup path.\")\n\n        for spath in lookup:\n            spath = os.path.abspath(spath) + os.sep\n            fname = os.path.abspath(os.path.join(spath, name))\n            if not fname.startswith(spath): continue\n            if os.path.isfile(fname): return fname\n            for ext in cls.extensions:\n                if os.path.isfile('%s.%s' % (fname, ext)):\n                    return '%s.%s' % (fname, ext)\n\n    @classmethod\n    def global_config(cls, key, *args):\n        \"\"\" This reads or sets the global settings stored in class.settings. \"\"\"\n        if args:\n            cls.settings = cls.settings.copy()  # Make settings local to class\n            cls.settings[key] = args[0]\n        else:\n            return cls.settings[key]\n\n    def prepare(self, **options):\n        \"\"\" Run preparations (parsing, caching, ...).\n        It should be possible to call this again to refresh a template or to\n        update settings.\n        \"\"\"\n        raise NotImplementedError\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template with the specified local variables and return\n        a single byte or unicode string. If it is a byte string, the encoding\n        must match self.encoding. This method must be thread-safe!\n        Local variables may be provided in dictionaries (args)\n        or directly, as keywords (kwargs).\n        \"\"\"\n        raise NotImplementedError\n\n\nclass MakoTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from mako.template import Template\n        from mako.lookup import TemplateLookup\n        options.update({'input_encoding': self.encoding})\n        options.setdefault('format_exceptions', bool(DEBUG))\n        lookup = TemplateLookup(directories=self.lookup, **options)\n        if self.source:\n            self.tpl = Template(self.source, lookup=lookup, **options)\n        else:\n            self.tpl = Template(uri=self.name,\n                                filename=self.filename,\n                                lookup=lookup, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n\nclass CheetahTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from Cheetah.Template import Template\n        self.context = threading.local()\n        self.context.vars = {}\n        options['searchList'] = [self.context.vars]\n        if self.source:\n            self.tpl = Template(source=self.source, **options)\n        else:\n            self.tpl = Template(file=self.filename, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        self.context.vars.update(self.defaults)\n        self.context.vars.update(kwargs)\n        out = str(self.tpl)\n        self.context.vars.clear()\n        return out\n\n\nclass Jinja2Template(BaseTemplate):\n    def prepare(self, filters=None, tests=None, globals={}, **kwargs):\n        from jinja2 import Environment, FunctionLoader\n        self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)\n        if filters: self.env.filters.update(filters)\n        if tests: self.env.tests.update(tests)\n        if globals: self.env.globals.update(globals)\n        if self.source:\n            self.tpl = self.env.from_string(self.source)\n        else:\n            self.tpl = self.env.get_template(self.name)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n    def loader(self, name):\n        if name == self.filename:\n            fname = name\n        else:\n            fname = self.search(name, self.lookup)\n        if not fname: return\n        with open(fname, \"rb\") as f:\n            return (f.read().decode(self.encoding), fname, lambda: False)\n\n\nclass SimpleTemplate(BaseTemplate):\n    def prepare(self,\n                escape_func=html_escape,\n                noescape=False,\n                syntax=None, **ka):\n        self.cache = {}\n        enc = self.encoding\n        self._str = lambda x: touni(x, enc)\n        self._escape = lambda x: escape_func(touni(x, enc))\n        self.syntax = syntax\n        if noescape:\n            self._str, self._escape = self._escape, self._str\n\n    @cached_property\n    def co(self):\n        return compile(self.code, self.filename or '<string>', 'exec')\n\n    @cached_property\n    def code(self):\n        source = self.source\n        if not source:\n            with open(self.filename, 'rb') as f:\n                source = f.read()\n        try:\n            source, encoding = touni(source), 'utf8'\n        except UnicodeError:\n            raise depr(0, 11, 'Unsupported template encodings.', 'Use utf-8 for templates.')\n        parser = StplParser(source, encoding=encoding, syntax=self.syntax)\n        code = parser.translate()\n        self.encoding = parser.encoding\n        return code\n\n    def _rebase(self, _env, _name=None, **kwargs):\n        _env['_rebase'] = (_name, kwargs)\n\n    def _include(self, _env, _name=None, **kwargs):\n        env = _env.copy()\n        env.update(kwargs)\n        if _name not in self.cache:\n            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup, syntax=self.syntax)\n        return self.cache[_name].execute(env['_stdout'], env)\n\n    def execute(self, _stdout, kwargs):\n        env = self.defaults.copy()\n        env.update(kwargs)\n        env.update({\n            '_stdout': _stdout,\n            '_printlist': _stdout.extend,\n            'include': functools.partial(self._include, env),\n            'rebase': functools.partial(self._rebase, env),\n            '_rebase': None,\n            '_str': self._str,\n            '_escape': self._escape,\n            'get': env.get,\n            'setdefault': env.setdefault,\n            'defined': env.__contains__\n        })\n        exec(self.co, env)\n        if env.get('_rebase'):\n            subtpl, rargs = env.pop('_rebase')\n            rargs['base'] = ''.join(_stdout)  #copy stdout\n            del _stdout[:]  # clear stdout\n            return self._include(env, subtpl, **rargs)\n        return env\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template using keyword arguments as local variables. \"\"\"\n        env = {}\n        stdout = []\n        for dictarg in args:\n            env.update(dictarg)\n        env.update(kwargs)\n        self.execute(stdout, env)\n        return ''.join(stdout)\n\n\nclass StplSyntaxError(TemplateError):\n\n    pass\n\n\nclass StplParser(object):\n    \"\"\" Parser for stpl templates. \"\"\"\n    _re_cache = {}  #: Cache for compiled re patterns\n\n    # This huge pile of voodoo magic splits python code into 8 different tokens.\n    # We use the verbose (?x) regex mode to make this more manageable\n\n    _re_tok = _re_inl = r'''((?mx)         # verbose and dot-matches-newline mode\n        [urbURB]*\n        (?:  ''(?!')\n            |\"\"(?!\")\n            |'{6}\n            |\"{6}\n            |'(?:[^\\\\']|\\\\.)+?'\n            |\"(?:[^\\\\\"]|\\\\.)+?\"\n            |'{3}(?:[^\\\\]|\\\\.|\\n)+?'{3}\n            |\"{3}(?:[^\\\\]|\\\\.|\\n)+?\"{3}\n        )\n    )'''\n\n    _re_inl = _re_tok.replace(r'|\\n', '')  # We re-use this string pattern later\n\n    _re_tok += r'''\n        # 2: Comments (until end of line, but not the newline itself)\n        |(\\#.*)\n\n        # 3: Open and close (4) grouping tokens\n        |([\\[\\{\\(])\n        |([\\]\\}\\)])\n\n        # 5,6: Keywords that start or continue a python block (only start of line)\n        |^([\\ \\t]*(?:if|for|while|with|try|def|class)\\b)\n        |^([\\ \\t]*(?:elif|else|except|finally)\\b)\n\n        # 7: Our special 'end' keyword (but only if it stands alone)\n        |((?:^|;)[\\ \\t]*end[\\ \\t]*(?=(?:%(block_close)s[\\ \\t]*)?\\r?$|;|\\#))\n\n        # 8: A customizable end-of-code-block template token (only end of line)\n        |(%(block_close)s[\\ \\t]*(?=\\r?$))\n\n        # 9: And finally, a single newline. The 10th token is 'everything else'\n        |(\\r?\\n)\n    '''\n\n    # Match the start tokens of code areas in a template\n    _re_split = r'''(?m)^[ \\t]*(\\\\?)((%(line_start)s)|(%(block_start)s))'''\n    # Match inline statements (may contain python strings)\n    _re_inl = r'''%%(inline_start)s((?:%s|[^'\"\\n]+?)*?)%%(inline_end)s''' % _re_inl\n\n    default_syntax = '<% %> % {{ }}'\n\n    def __init__(self, source, syntax=None, encoding='utf8'):\n        self.source, self.encoding = touni(source, encoding), encoding\n        self.set_syntax(syntax or self.default_syntax)\n        self.code_buffer, self.text_buffer = [], []\n        self.lineno, self.offset = 1, 0\n        self.indent, self.indent_mod = 0, 0\n        self.paren_depth = 0\n\n    def get_syntax(self):\n        \"\"\" Tokens as a space separated string (default: <% %> % {{ }}) \"\"\"\n        return self._syntax\n\n    def set_syntax(self, syntax):\n        self._syntax = syntax\n        self._tokens = syntax.split()\n        if syntax not in self._re_cache:\n            names = 'block_start block_close line_start inline_start inline_end'\n            etokens = map(re.escape, self._tokens)\n            pattern_vars = dict(zip(names.split(), etokens))\n            patterns = (self._re_split, self._re_tok, self._re_inl)\n            patterns = [re.compile(p % pattern_vars) for p in patterns]\n            self._re_cache[syntax] = patterns\n        self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax]\n\n    syntax = property(get_syntax, set_syntax)\n\n    def translate(self):\n        if self.offset: raise RuntimeError('Parser is a one time instance.')\n        while True:\n            m = self.re_split.search(self.source, pos=self.offset)\n            if m:\n                text = self.source[self.offset:m.start()]\n                self.text_buffer.append(text)\n                self.offset = m.end()\n                if m.group(1):  # Escape syntax\n                    line, sep, _ = self.source[self.offset:].partition('\\n')\n                    self.text_buffer.append(self.source[m.start():m.start(1)] +\n                                            m.group(2) + line + sep)\n                    self.offset += len(line + sep)\n                    continue\n                self.flush_text()\n                self.offset += self.read_code(self.source[self.offset:],\n                                              multiline=bool(m.group(4)))\n            else:\n                break\n        self.text_buffer.append(self.source[self.offset:])\n        self.flush_text()\n        return ''.join(self.code_buffer)\n\n    def read_code(self, pysource, multiline):\n        code_line, comment = '', ''\n        offset = 0\n        while True:\n            m = self.re_tok.search(pysource, pos=offset)\n            if not m:\n                code_line += pysource[offset:]\n                offset = len(pysource)\n                self.write_code(code_line.strip(), comment)\n                break\n            code_line += pysource[offset:m.start()]\n            offset = m.end()\n            _str, _com, _po, _pc, _blk1, _blk2, _end, _cend, _nl = m.groups()\n            if self.paren_depth > 0 and (_blk1 or _blk2):  # a if b else c\n                code_line += _blk1 or _blk2\n                continue\n            if _str:  # Python string\n                code_line += _str\n            elif _com:  # Python comment (up to EOL)\n                comment = _com\n                if multiline and _com.strip().endswith(self._tokens[1]):\n                    multiline = False  # Allow end-of-block in comments\n            elif _po:  # open parenthesis\n                self.paren_depth += 1\n                code_line += _po\n            elif _pc:  # close parenthesis\n                if self.paren_depth > 0:\n                    # we could check for matching parentheses here, but it's\n                    # easier to leave that to python - just check counts\n                    self.paren_depth -= 1\n                code_line += _pc\n            elif _blk1:  # Start-block keyword (if/for/while/def/try/...)\n                code_line, self.indent_mod = _blk1, -1\n                self.indent += 1\n            elif _blk2:  # Continue-block keyword (else/elif/except/...)\n                code_line, self.indent_mod = _blk2, -1\n            elif _end:  # The non-standard 'end'-keyword (ends a block)\n                self.indent -= 1\n            elif _cend:  # The end-code-block template token (usually '%>')\n                if multiline: multiline = False\n                else: code_line += _cend\n            else:  # \\n\n                self.write_code(code_line.strip(), comment)\n                self.lineno += 1\n                code_line, comment, self.indent_mod = '', '', 0\n                if not multiline:\n                    break\n\n        return offset\n\n    def flush_text(self):\n        text = ''.join(self.text_buffer)\n        del self.text_buffer[:]\n        if not text: return\n        parts, pos, nl = [], 0, '\\\\\\n' + '  ' * self.indent\n        for m in self.re_inl.finditer(text):\n            prefix, pos = text[pos:m.start()], m.end()\n            if prefix:\n                parts.append(nl.join(map(repr, prefix.splitlines(True))))\n            if prefix.endswith('\\n'): parts[-1] += nl\n            parts.append(self.process_inline(m.group(1).strip()))\n        if pos < len(text):\n            prefix = text[pos:]\n            lines = prefix.splitlines(True)\n            if lines[-1].endswith('\\\\\\\\\\n'): lines[-1] = lines[-1][:-3]\n            elif lines[-1].endswith('\\\\\\\\\\r\\n'): lines[-1] = lines[-1][:-4]\n            parts.append(nl.join(map(repr, lines)))\n        code = '_printlist((%s,))' % ', '.join(parts)\n        self.lineno += code.count('\\n') + 1\n        self.write_code(code)\n\n    @staticmethod\n    def process_inline(chunk):\n        if chunk[0] == '!': return '_str(%s)' % chunk[1:]\n        return '_escape(%s)' % chunk\n\n    def write_code(self, line, comment=''):\n        code = '  ' * (self.indent + self.indent_mod)\n        code += line.lstrip() + comment + '\\n'\n        self.code_buffer.append(code)\n\n\ndef template(*args, **kwargs):\n    \"\"\"\n    Get a rendered template as a string iterator.\n    You can use a name, a filename or a template string as first parameter.\n    Template rendering arguments can be passed as dictionaries\n    or directly (as keyword arguments).\n    \"\"\"\n    tpl = args[0] if args else None\n    for dictarg in args[1:]:\n        kwargs.update(dictarg)\n    adapter = kwargs.pop('template_adapter', SimpleTemplate)\n    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)\n    tplid = (id(lookup), tpl)\n    if tplid not in TEMPLATES or DEBUG:\n        settings = kwargs.pop('template_settings', {})\n        if isinstance(tpl, adapter):\n            TEMPLATES[tplid] = tpl\n            if settings: TEMPLATES[tplid].prepare(**settings)\n        elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n        else:\n            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)\n    if not TEMPLATES[tplid]:\n        abort(500, 'Template (%s) not found' % tpl)\n    return TEMPLATES[tplid].render(kwargs)\n\n\nmako_template = functools.partial(template, template_adapter=MakoTemplate)\ncheetah_template = functools.partial(template,\n                                     template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\n\n\ndef view(tpl_name, **defaults):\n    \"\"\" Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,\n            for instance, JSON with autojson or other castfilters.\n    \"\"\"\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if isinstance(result, (dict, DictMixin)):\n                tplvars = defaults.copy()\n                tplvars.update(result)\n                return template(tpl_name, **tplvars)\n            elif result is None:\n                return template(tpl_name, defaults)\n            return result\n\n        return wrapper\n\n    return decorator\n\n\nmako_view = functools.partial(view, template_adapter=MakoTemplate)\ncheetah_view = functools.partial(view, template_adapter=CheetahTemplate)\njinja2_view = functools.partial(view, template_adapter=Jinja2Template)\n\n###############################################################################\n# Constants and Globals ########################################################\n###############################################################################\n\nTEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False  # If set, run() does nothing. Used by load_app()\n\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses.copy()\nHTTP_CODES[418] = \"I'm a teapot\"  # RFC 2324\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s' % (k, v))\n                          for (k, v) in HTTP_CODES.items())\n\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, request\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>\n            <title>Error: {{e.status}}</title>\n            <style type=\"text/css\">\n              html {background-color: #eee; font-family: sans-serif;}\n              body {background-color: #fff; border: 1px solid #ddd;\n                    padding: 15px; margin: 15px;}\n              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;}\n            </style>\n        </head>\n        <body>\n            <h1>Error: {{e.status}}</h1>\n            <p>Sorry, the requested URL <tt>{{repr(request.url)}}</tt>\n               caused an error:</p>\n            <pre>{{e.body}}</pre>\n            %%if DEBUG and e.exception:\n              <h2>Exception:</h2>\n              %%try:\n                %%exc = repr(e.exception)\n              %%except:\n                %%exc = '<unprintable %%s object>' %% type(e.exception).__name__\n              %%end\n              <pre>{{exc}}</pre>\n            %%end\n            %%if DEBUG and e.traceback:\n              <h2>Traceback:</h2>\n              <pre>{{e.traceback}}</pre>\n            %%end\n        </body>\n    </html>\n%%except ImportError:\n    <b>ImportError:</b> Could not generate the error page. Please add bottle to\n    the import path.\n%%end\n\"\"\" % __name__\n\n#: A thread-safe instance of :class:`LocalRequest`. If accessed from within a\n#: request callback, this instance always refers to the *current* request\n#: (even on a multi-threaded server).\nrequest = LocalRequest()\n\n#: A thread-safe instance of :class:`LocalResponse`. It is used to change the\n#: HTTP response for the *current* request.\nresponse = LocalResponse()\n\n#: A thread-safe namespace. Not used by Bottle.\nlocal = threading.local()\n\n# Initialize app stack (create first empty Bottle app now deferred until needed)\n# BC: 0.6.4 and needed for run()\napps = app = default_app = AppStack()\n\n#: A virtual package that redirects import statements.\n#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.\next = _ImportRedirect('bottle.ext' if __name__ == '__main__' else\n                      __name__ + \".ext\", 'bottle_%s').module\n\n\ndef _main(argv):  # pragma: no coverage\n    args, parser = _cli_parse(argv)\n\n    def _cli_error(cli_msg):\n        parser.print_help()\n        _stderr('\\nError: %s\\n' % cli_msg)\n        sys.exit(1)\n\n    if args.version:\n        _stdout('Bottle %s\\n' % __version__)\n        sys.exit(0)\n    if not args.app:\n        _cli_error(\"No application entry point specified.\")\n\n    sys.path.insert(0, '.')\n    sys.modules.setdefault('bottle', sys.modules['__main__'])\n\n    host, port = (args.bind or 'localhost'), 8080\n    if ':' in host and host.rfind(']') < host.rfind(':'):\n        host, port = host.rsplit(':', 1)\n    host = host.strip('[]')\n\n    config = ConfigDict()\n\n    for cfile in args.conf or []:\n        try:\n            if cfile.endswith('.json'):\n                with open(cfile, 'rb') as fp:\n                    config.load_dict(json_loads(fp.read()))\n            else:\n                config.load_config(cfile)\n        except configparser.Error as parse_error:\n            _cli_error(parse_error)\n        except IOError:\n            _cli_error(\"Unable to read config file %r\" % cfile)\n        except (UnicodeError, TypeError, ValueError) as error:\n            _cli_error(\"Unable to parse config file %r: %s\" % (cfile, error))\n\n    for cval in args.param or []:\n        if '=' in cval:\n            config.update((cval.split('=', 1),))\n        else:\n            config[cval] = True\n\n    run(args.app,\n        host=host,\n        port=int(port),\n        server=args.server,\n        reloader=args.reload,\n        plugins=args.plugin,\n        debug=args.debug,\n        config=config)\n\n\nif __name__ == '__main__':  # pragma: no coverage\n    _main(sys.argv)\n", "# -*- coding: utf-8 -*-\n''' Tests for the BaseRequest and BaseResponse objects and their subclasses. '''\n\nimport unittest\nimport sys\nimport bottle\nfrom bottle import request, tob, touni, tonat, json_dumps, HTTPError, parse_date\nfrom test import tools\nimport wsgiref.util\nimport base64\n\nfrom bottle import BaseRequest, BaseResponse, LocalRequest\n\n\nclass TestRequest(unittest.TestCase):\n\n    def test_app_property(self):\n        e = {}\n        r = BaseRequest(e)\n        self.assertRaises(RuntimeError, lambda: r.app)\n        e.update({'bottle.app': 5})\n        self.assertEqual(r.app, 5)\n\n    def test_route_property(self):\n        e = {'bottle.route': 5}\n        r = BaseRequest(e)\n        self.assertEqual(r.route, 5)\n\n    def test_url_for_property(self):\n        e = {}\n        r = BaseRequest(e)\n        self.assertRaises(RuntimeError, lambda: r.url_args)\n        e.update({'route.url_args': {'a': 5}})\n        self.assertEqual(r.url_args, {'a': 5})\n\n    def test_path(self):\n        \"\"\" PATH_INFO normalization. \"\"\"\n        # Legal paths\n        tests = [('', '/'), ('x','/x'), ('x/', '/x/'), ('/x', '/x'), ('/x/', '/x/')]\n        for raw, norm in tests:\n            self.assertEqual(norm, BaseRequest({'PATH_INFO': raw}).path)\n        # Strange paths\n        tests = [('///', '/'), ('//x','/x')]\n        for raw, norm in tests:\n            self.assertEqual(norm, BaseRequest({'PATH_INFO': raw}).path)\n        # No path at all\n        self.assertEqual('/', BaseRequest({}).path)\n\n    def test_method(self):\n        self.assertEqual(BaseRequest({}).method, 'GET')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'GET'}).method, 'GET')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'GeT'}).method, 'GET')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'get'}).method, 'GET')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'POst'}).method, 'POST')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'FanTASY'}).method, 'FANTASY')\n\n    def test_script_name(self):\n        \"\"\" SCRIPT_NAME normalization. \"\"\"\n        # Legal paths\n        tests = [('', '/'), ('x','/x/'), ('x/', '/x/'), ('/x', '/x/'), ('/x/', '/x/')]\n        for raw, norm in tests:\n            self.assertEqual(norm, BaseRequest({'SCRIPT_NAME': raw}).script_name)\n        # Strange paths\n        tests = [('///', '/'), ('///x///','/x/')]\n        for raw, norm in tests:\n            self.assertEqual(norm, BaseRequest({'SCRIPT_NAME': raw}).script_name)\n        # No path at all\n        self.assertEqual('/', BaseRequest({}).script_name)\n\n    def test_pathshift(self):\n        \"\"\" Request.path_shift() \"\"\"\n        def test_shift(s, p, c):\n            request = BaseRequest({'SCRIPT_NAME': s, 'PATH_INFO': p})\n            request.path_shift(c)\n            return [request['SCRIPT_NAME'], request.path]\n        self.assertEqual(['/a/b', '/c/d'], test_shift('/a/b', '/c/d', 0))\n        self.assertEqual(['/a/b', '/c/d/'], test_shift('/a/b', '/c/d/', 0))\n        self.assertEqual(['/a/b/c', '/d'], test_shift('/a/b', '/c/d', 1))\n        self.assertEqual(['/a', '/b/c/d'], test_shift('/a/b', '/c/d', -1))\n        self.assertEqual(['/a/b/c', '/d/'], test_shift('/a/b', '/c/d/', 1))\n        self.assertEqual(['/a', '/b/c/d/'], test_shift('/a/b', '/c/d/', -1))\n        self.assertEqual(['/a/b/c', '/d/'], test_shift('/a/b/', '/c/d/', 1))\n        self.assertEqual(['/a', '/b/c/d/'], test_shift('/a/b/', '/c/d/', -1))\n        self.assertEqual(['/a/b/c/d', '/'], test_shift('/', '/a/b/c/d', 4))\n        self.assertEqual(['/', '/a/b/c/d/'], test_shift('/a/b/c/d', '/', -4))\n        self.assertRaises(AssertionError, test_shift, '/a/b', '/c/d', 3)\n        self.assertRaises(AssertionError, test_shift, '/a/b', '/c/d', -3)\n\n    def test_url(self):\n        \"\"\" Environ: URL building \"\"\"\n        request = BaseRequest({'HTTP_HOST':'example.com'})\n        self.assertEqual('http://example.com/', request.url)\n        request = BaseRequest({'SERVER_NAME':'example.com'})\n        self.assertEqual('http://example.com/', request.url)\n        request = BaseRequest({'SERVER_NAME':'example.com', 'SERVER_PORT':'81'})\n        self.assertEqual('http://example.com:81/', request.url)\n        request = BaseRequest({'wsgi.url_scheme':'https', 'SERVER_NAME':'example.com'})\n        self.assertEqual('https://example.com/', request.url)\n        request = BaseRequest({'HTTP_HOST':'example.com', 'PATH_INFO':'/path',\n                               'QUERY_STRING':'1=b&c=d', 'SCRIPT_NAME':'/sp'})\n        self.assertEqual('http://example.com/sp/path?1=b&c=d', request.url)\n        request = BaseRequest({'HTTP_HOST':'example.com', 'PATH_INFO':'/pa th',\n                               'SCRIPT_NAME':'/s p'})\n        self.assertEqual('http://example.com/s%20p/pa%20th', request.url)\n\n    def test_dict_access(self):\n        \"\"\" Environ: request objects are environment dicts \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        request = BaseRequest(e)\n        self.assertEqual(list(request), list(e.keys()))\n        self.assertEqual(len(request), len(e))\n        for k, v in e.items():\n            self.assertTrue(k in request)\n            self.assertEqual(request[k], v)\n            request[k] = 'test'\n            self.assertEqual(request[k], 'test')\n        del request['PATH_INFO']\n        self.assertTrue('PATH_INFO' not in request)\n\n    def test_readonly_environ(self):\n        request = BaseRequest({'bottle.request.readonly':True})\n        def test(): request['x']='y'\n        self.assertRaises(KeyError, test)\n\n    def test_header_access(self):\n        \"\"\" Environ: Request objects decode headers \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['HTTP_SOME_HEADER'] = 'some value'\n        request = BaseRequest(e)\n        request['HTTP_SOME_OTHER_HEADER'] = 'some other value'\n        self.assertTrue('Some-Header' in request.headers)\n        self.assertTrue(request.headers['Some-Header'] == 'some value')\n        self.assertTrue(request.headers['Some-Other-Header'] == 'some other value')\n\n    def test_header_access_special(self):\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        request = BaseRequest(e)\n        request['CONTENT_TYPE'] = 'test'\n        request['CONTENT_LENGTH'] = '123'\n        self.assertEqual(request.headers['Content-Type'], 'test')\n        self.assertEqual(request.headers['Content-Length'], '123')\n\n    def test_cookie_dict(self):\n        \"\"\" Environ: Cookie dict \"\"\"\n        t = dict()\n        t['a=a']      = {'a': 'a'}\n        t['a=a; b=b'] = {'a': 'a', 'b':'b'}\n        t['a=a; a=b'] = {'a': 'b'}\n        for k, v in t.items():\n            request = BaseRequest({'HTTP_COOKIE': k})\n            for n in v:\n                self.assertEqual(v[n], request.cookies[n])\n                self.assertEqual(v[n], request.get_cookie(n))\n\n    def test_get(self):\n        \"\"\" Environ: GET data \"\"\"\n        qs = tonat(tob('a=a&a=1&b=b&c=c&cn=%e7%93%b6'), 'latin1')\n        request = BaseRequest({'QUERY_STRING':qs})\n        self.assertTrue('a' in request.query)\n        self.assertTrue('b' in request.query)\n        self.assertEqual(['a','1'], request.query.getall('a'))\n        self.assertEqual(['b'], request.query.getall('b'))\n        self.assertEqual('1', request.query['a'])\n        self.assertEqual('b', request.query['b'])\n        self.assertEqual(tonat(tob('\u74f6'), 'latin1'), request.query['cn'])\n        self.assertEqual(touni('\u74f6'), request.query.cn)\n\n    def test_post(self):\n        \"\"\" Environ: POST data \"\"\"\n        sq = tob('a=a&a=1&b=b&c=&d&cn=%e7%93%b6')\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(sq)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(sq))\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertTrue('a' in request.POST)\n        self.assertTrue('b' in request.POST)\n        self.assertEqual(['a','1'], request.POST.getall('a'))\n        self.assertEqual(['b'], request.POST.getall('b'))\n        self.assertEqual('1', request.POST['a'])\n        self.assertEqual('b', request.POST['b'])\n        self.assertEqual('', request.POST['c'])\n        self.assertEqual('', request.POST['d'])\n        self.assertEqual(tonat(tob('\u74f6'), 'latin1'), request.POST['cn'])\n        self.assertEqual(touni('\u74f6'), request.POST.cn)\n\n    def test_bodypost(self):\n        sq = tob('foobar')\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(sq)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(sq))\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertEqual('', request.POST['foobar'])\n\n    def test_body_noclose(self):\n        \"\"\" Test that the body file handler is not closed after request.POST \"\"\"\n        sq = tob('a=a&a=1&b=b&c=&d')\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(sq)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(sq))\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertEqual(sq, request.body.read())\n        request.POST # This caused a body.close() with Python 3.x\n        self.assertEqual(sq, request.body.read())\n\n    def test_params(self):\n        \"\"\" Environ: GET and POST are combined in request.param \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('b=b&c=p'))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = '7'\n        e['QUERY_STRING'] = 'a=a&c=g'\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertEqual(['a','b','c'], sorted(request.params.keys()))\n        self.assertEqual('p', request.params['c'])\n\n    def test_getpostleak(self):\n        \"\"\" Environ: GET and POST should not leak into each other \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('b=b'))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = '3'\n        e['QUERY_STRING'] = 'a=a'\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertEqual(['a'], list(request.GET.keys()))\n        self.assertEqual(['b'], list(request.POST.keys()))\n\n    def test_body(self):\n        \"\"\" Environ: Request.body should behave like a file object factory \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('abc'))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(3)\n        request = BaseRequest(e)\n        self.assertEqual(tob('abc'), request.body.read())\n        self.assertEqual(tob('abc'), request.body.read(3))\n        self.assertEqual(tob('abc'), request.body.readline())\n        self.assertEqual(tob('abc'), request.body.readline(3))\n\n    def test_bigbody(self):\n        \"\"\" Environ: Request.body should handle big uploads using files \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('x')*1024*1000)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(1024*1000)\n        request = BaseRequest(e)\n        self.assertTrue(hasattr(request.body, 'fileno'))\n        self.assertEqual(1024*1000, len(request.body.read()))\n        self.assertEqual(1024, len(request.body.read(1024)))\n        self.assertEqual(1024*1000, len(request.body.readline()))\n        self.assertEqual(1024, len(request.body.readline(1024)))\n\n    def test_tobigbody(self):\n        \"\"\" Environ: Request.body should truncate to Content-Length bytes \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('x')*1024)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = '42'\n        request = BaseRequest(e)\n        self.assertEqual(42, len(request.body.read()))\n        self.assertEqual(42, len(request.body.read(1024)))\n        self.assertEqual(42, len(request.body.readline()))\n        self.assertEqual(42, len(request.body.readline(1024)))\n\n    def _test_chunked(self, body, expect):\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(body))\n        e['wsgi.input'].seek(0)\n        e['HTTP_TRANSFER_ENCODING'] = 'chunked'\n        if isinstance(expect, str):\n            self.assertEqual(tob(expect), BaseRequest(e).body.read())\n        else:\n            self.assertRaises(expect, lambda: BaseRequest(e).body)\n\n    def test_chunked(self):\n        self._test_chunked('1\\r\\nx\\r\\nff\\r\\n' + 'y'*255 + '\\r\\n0\\r\\n',\n                           'x' + 'y'*255)\n        self._test_chunked('8\\r\\nxxxxxxxx\\r\\n0\\r\\n','xxxxxxxx')\n        self._test_chunked('0\\r\\n', '')\n\n    def test_chunked_meta_fields(self):\n        self._test_chunked('8 ; foo\\r\\nxxxxxxxx\\r\\n0\\r\\n','xxxxxxxx')\n        self._test_chunked('8;foo\\r\\nxxxxxxxx\\r\\n0\\r\\n','xxxxxxxx')\n        self._test_chunked('8;foo=bar\\r\\nxxxxxxxx\\r\\n0\\r\\n','xxxxxxxx')\n\n    def test_chunked_not_terminated(self):\n        self._test_chunked('1\\r\\nx\\r\\n', HTTPError)\n\n    def test_chunked_wrong_size(self):\n        self._test_chunked('2\\r\\nx\\r\\n', HTTPError)\n\n    def test_chunked_illegal_size(self):\n        self._test_chunked('x\\r\\nx\\r\\n', HTTPError)\n\n    def test_chunked_not_chunked_at_all(self):\n        self._test_chunked('abcdef', HTTPError)\n\n    def test_multipart(self):\n        \"\"\" Environ: POST (multipart files and multible values per key) \"\"\"\n        fields = [('field1','value1'), ('field2','value2'), ('field2','value3')]\n        files = [('file1','filename1.txt','content1'), ('\u4e07\u96be','\u4e07\u96befoo.py', '\u00e4\\n\u00f6\\r\u00fc')]\n        e = tools.multipart_environ(fields=fields, files=files)\n        request = BaseRequest(e)\n        # File content\n        self.assertTrue('file1' in request.POST)\n        self.assertTrue('file1' in request.files)\n        self.assertTrue('file1' not in request.forms)\n        cmp = tob('content1') if sys.version_info >= (3,2,0) else 'content1'\n        self.assertEqual(cmp, request.POST['file1'].file.read())\n        # File name and meta data\n        self.assertTrue('\u4e07\u96be' in request.POST)\n        self.assertTrue('\u4e07\u96be' in request.files)\n        self.assertTrue('\u4e07\u96be' not in request.forms)\n        self.assertEqual('foo.py', request.POST['\u4e07\u96be'].filename)\n        self.assertTrue(request.files['\u4e07\u96be'])\n        self.assertFalse(request.files.file77)\n        # UTF-8 files\n        x = request.POST['\u4e07\u96be'].file.read()\n        if (3,2,0) > sys.version_info >= (3,0,0):\n            x = x.encode('utf8')\n        self.assertEqual(tob('\u00e4\\n\u00f6\\r\u00fc'), x)\n        # No file\n        self.assertTrue('file3' not in request.POST)\n        self.assertTrue('file3' not in request.files)\n        self.assertTrue('file3' not in request.forms)\n        # Field (single)\n        self.assertEqual('value1', request.POST['field1'])\n        self.assertTrue('field1' not in request.files)\n        self.assertEqual('value1', request.forms['field1'])\n        # Field (multi)\n        self.assertEqual(2, len(request.POST.getall('field2')))\n        self.assertEqual(['value2', 'value3'], request.POST.getall('field2'))\n        self.assertEqual(['value2', 'value3'], request.forms.getall('field2'))\n        self.assertTrue('field2' not in request.files)\n\n    def test_json_empty(self):\n        \"\"\" Environ: Request.json property with empty body. \"\"\"\n        self.assertEqual(BaseRequest({}).json, None)\n\n    def test_json_noheader(self):\n        \"\"\" Environ: Request.json property with missing content-type header. \"\"\"\n        test = dict(a=5, b='test', c=[1,2,3])\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(json_dumps(test)))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(json_dumps(test)))\n        self.assertEqual(BaseRequest(e).json, None)\n\n    def test_json_tobig(self):\n        \"\"\" Environ: Request.json property with huge body. \"\"\"\n        test = dict(a=5, tobig='x' * bottle.BaseRequest.MEMFILE_MAX)\n        e = {'CONTENT_TYPE': 'application/json'}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(json_dumps(test)))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(json_dumps(test)))\n        self.assertRaises(HTTPError, lambda: BaseRequest(e).json)\n\n    def test_json_valid(self):\n        \"\"\" Environ: Request.json property. \"\"\"\n        test = dict(a=5, b='test', c=[1,2,3])\n        e = {'CONTENT_TYPE': 'application/json; charset=UTF-8'}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(json_dumps(test)))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(json_dumps(test)))\n        self.assertEqual(BaseRequest(e).json, test)\n\n    def test_json_forged_header_issue616(self):\n        test = dict(a=5, b='test', c=[1,2,3])\n        e = {'CONTENT_TYPE': 'text/plain;application/json'}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(json_dumps(test)))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(json_dumps(test)))\n        self.assertEqual(BaseRequest(e).json, None)\n\n    def test_json_header_empty_body(self):\n        \"\"\"Request Content-Type is application/json but body is empty\"\"\"\n        e = {'CONTENT_TYPE': 'application/json'}\n        wsgiref.util.setup_testing_defaults(e)\n        wsgiref.util.setup_testing_defaults(e)\n        e['CONTENT_LENGTH'] = \"0\"\n        self.assertEqual(BaseRequest(e).json, None)\n\n    def test_isajax(self):\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        self.assertFalse(BaseRequest(e.copy()).is_ajax)\n        e['HTTP_X_REQUESTED_WITH'] = 'XMLHttpRequest'\n        self.assertTrue(BaseRequest(e.copy()).is_ajax)\n\n    def test_auth(self):\n        user, pwd = 'marc', 'secret'\n        basic = touni(base64.b64encode(tob('%s:%s' % (user, pwd))))\n        r = BaseRequest({})\n        self.assertEqual(r.auth, None)\n        r.environ['HTTP_AUTHORIZATION'] = 'basic %s' % basic\n        self.assertEqual(r.auth, (user, pwd))\n        r.environ['REMOTE_USER'] = user\n        self.assertEqual(r.auth, (user, pwd))\n        del r.environ['HTTP_AUTHORIZATION']\n        self.assertEqual(r.auth, (user, None))\n\n    def test_remote_route(self):\n        ips = ['1.2.3.4', '2.3.4.5', '3.4.5.6']\n        r = BaseRequest({})\n        self.assertEqual(r.remote_route, [])\n        r.environ['HTTP_X_FORWARDED_FOR'] = ', '.join(ips)\n        self.assertEqual(r.remote_route, ips)\n        r.environ['REMOTE_ADDR'] = ips[1]\n        self.assertEqual(r.remote_route, ips)\n        del r.environ['HTTP_X_FORWARDED_FOR']\n        self.assertEqual(r.remote_route, [ips[1]])\n\n    def test_remote_addr(self):\n        ips = ['1.2.3.4', '2.3.4.5', '3.4.5.6']\n        r = BaseRequest({})\n        self.assertEqual(r.remote_addr, None)\n        r.environ['HTTP_X_FORWARDED_FOR'] = ', '.join(ips)\n        self.assertEqual(r.remote_addr, ips[0])\n        r.environ['REMOTE_ADDR'] = ips[1]\n        self.assertEqual(r.remote_addr, ips[0])\n        del r.environ['HTTP_X_FORWARDED_FOR']\n        self.assertEqual(r.remote_addr, ips[1])\n\n    def test_user_defined_attributes(self):\n        for cls in (BaseRequest, LocalRequest):\n            r = cls()\n\n            # New attributes go to the environ dict.\n            r.foo = 'somevalue'\n            self.assertEqual(r.foo, 'somevalue')\n            self.assertTrue('somevalue' in r.environ.values())\n\n            # Attributes are read-only once set.\n            self.assertRaises(AttributeError, setattr, r, 'foo', 'x')\n\n            # Unknown attributes raise AttributeError.\n            self.assertRaises(AttributeError, getattr, r, 'somevalue')\n\n\nclass TestResponse(unittest.TestCase):\n\n    def test_constructor_body(self):\n        self.assertEqual('',\n            BaseResponse('').body)\n\n        self.assertEqual('YAY',\n            BaseResponse('YAY').body)\n\n    def test_constructor_status(self):\n        self.assertEqual(200,\n            BaseResponse('YAY', 200).status_code)\n\n        self.assertEqual('200 OK',\n            BaseResponse('YAY', 200).status_line)\n\n        self.assertEqual('200 YAY',\n            BaseResponse('YAY', '200 YAY').status_line)\n\n        self.assertEqual('200 YAY',\n            BaseResponse('YAY', '200 YAY').status_line)\n\n    def test_constructor_headerlist(self):\n        from functools import partial\n        make_res = partial(BaseResponse, '', 200)\n\n        self.assertEquals('yay', make_res(x_test='yay')['x-test'])\n\n    def test_wsgi_header_values(self):\n        def cmp(app, wire):\n            rs = BaseResponse()\n            rs.set_header('x-test', app)\n            result = [v for (h, v) in rs.headerlist if h.lower()=='x-test'][0]\n            self.assertEquals(wire, result)\n\n        if bottle.py3k:\n            cmp(1, tonat('1', 'latin1'))\n            cmp('\u00f6\u00e4\u00fc', '\u00f6\u00e4\u00fc'.encode('utf8').decode('latin1'))\n            # Dropped byte header support in Python 3:\n            #cmp(tob('\u00e4\u00f6\u00fc'), '\u00e4\u00f6\u00fc'.encode('utf8').decode('latin1'))\n        else:\n            cmp(1, '1')\n            cmp('\u00f6\u00e4\u00fc', '\u00f6\u00e4\u00fc')\n            cmp(touni('\u00e4\u00f6\u00fc'), '\u00e4\u00f6\u00fc')\n\n    def test_set_status(self):\n        rs = BaseResponse()\n\n        rs.status = 200\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 200)\n        self.assertEqual(rs.status_line, '200 OK')\n\n        rs.status = 999\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 999)\n        self.assertEqual(rs.status_line, '999 Unknown')\n\n        rs.status = 404\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 404)\n        self.assertEqual(rs.status_line, '404 Not Found')\n\n        def test(): rs.status = -200\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Not Found') # last value\n\n        def test(): rs.status = 5\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Not Found') # last value\n\n        rs.status = '999 Who knows?' # Illegal, but acceptable three digit code\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 999)\n        self.assertEqual(rs.status_line, '999 Who knows?')\n\n        rs.status = 555 # Strange code\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 555)\n        self.assertEqual(rs.status_line, '555 Unknown')\n\n        rs.status = '404 Brain not Found' # Custom reason\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 404)\n        self.assertEqual(rs.status_line, '404 Brain not Found')\n\n        def test(): rs.status = '5 Illegal Code'\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Brain not Found') # last value\n\n        def test(): rs.status = '-99 Illegal Code'\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Brain not Found') # last value\n\n        def test(): rs.status = '1000 Illegal Code'\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Brain not Found') # last value\n\n        def test(): rs.status = '555' # No reason\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Brain not Found') # last value\n\n    def test_content_type(self):\n        rs = BaseResponse()\n        rs.content_type = 'test/some'\n        self.assertEqual('test/some', rs.headers.get('Content-Type'))\n\n    def test_charset(self):\n        rs = BaseResponse()\n        self.assertEqual(rs.charset, 'UTF-8')\n        rs.content_type = 'text/html; charset=latin9'\n        self.assertEqual(rs.charset, 'latin9')\n        rs.content_type = 'text/html'\n        self.assertEqual(rs.charset, 'UTF-8')\n\n    def test_set_cookie(self):\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', max_age=5)\n        r.set_cookie('name2', 'value 2', path='/foo')\n        cookies = [value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie']\n        cookies.sort()\n        self.assertEqual(cookies[0], 'name1=value; Max-Age=5')\n        self.assertEqual(cookies[1], 'name2=\"value 2\"; Path=/foo')\n\n    def test_set_cookie_value_long_string(self):\n        r = BaseResponse()\n        self.assertRaises(ValueError, r.set_cookie, name='test', value='x' * 4097)\n\n    def test_set_cookie_name_long_string(self):\n        r = BaseResponse()\n        self.assertRaises(ValueError, r.set_cookie, name='x' * 4097, value='simple_value')\n\n    def test_set_cookie_maxage(self):\n        import datetime\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', max_age=5)\n        r.set_cookie('name2', 'value', max_age=datetime.timedelta(days=1))\n        cookies = sorted([value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie'])\n        self.assertEqual(cookies[0], 'name1=value; Max-Age=5')\n        self.assertEqual(cookies[1], 'name2=value; Max-Age=86400')\n\n    def test_set_cookie_expires(self):\n        import datetime\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', expires=42)\n        r.set_cookie('name2', 'value', expires=datetime.datetime(1970,1,1,0,0,43))\n        cookies = sorted([value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie'])\n        self.assertEqual(cookies[0], 'name1=value; expires=Thu, 01 Jan 1970 00:00:42 GMT')\n        self.assertEqual(cookies[1], 'name2=value; expires=Thu, 01 Jan 1970 00:00:43 GMT')\n\n    def test_set_cookie_secure(self):\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', secure=True)\n        r.set_cookie('name2', 'value', secure=False)\n        cookies = sorted([value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie'])\n        self.assertEqual(cookies[0].lower(), 'name1=value; secure')\n        self.assertEqual(cookies[1], 'name2=value')\n\n    def test_set_cookie_httponly(self):\n        if sys.version_info < (2,6,0):\n            return\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', httponly=True)\n        r.set_cookie('name2', 'value', httponly=False)\n        cookies = sorted([value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie'])\n        self.assertEqual(cookies[0].lower(), 'name1=value; httponly')\n        self.assertEqual(cookies[1], 'name2=value')\n\n    def test_delete_cookie(self):\n        response = BaseResponse()\n        response.set_cookie('name', 'value')\n        response.delete_cookie('name')\n        cookies = [value for name, value in response.headerlist\n                   if name.title() == 'Set-Cookie']\n        self.assertTrue('Max-Age=-1' in cookies[0])\n\n    def test_set_header(self):\n        response = BaseResponse()\n        response['x-test'] = 'foo'\n        headers = [value for name, value in response.headerlist\n                   if name.title() == 'X-Test']\n        self.assertEqual(['foo'], headers)\n        self.assertEqual('foo', response['x-test'])\n\n        response['X-Test'] = 'bar'\n        headers = [value for name, value in response.headerlist\n                   if name.title() == 'X-Test']\n        self.assertEqual(['bar'], headers)\n        self.assertEqual('bar', response['x-test'])\n\n    def test_append_header(self):\n        response = BaseResponse()\n        response.set_header('x-test', 'foo')\n        headers = [value for name, value in response.headerlist\n                   if name.title() == 'X-Test']\n        self.assertEqual(['foo'], headers)\n        self.assertEqual('foo', response['x-test'])\n\n        response.add_header('X-Test', 'bar')\n        headers = [value for name, value in response.headerlist\n                   if name.title() == 'X-Test']\n        self.assertEqual(['foo', 'bar'], headers)\n        self.assertEqual('bar', response['x-test'])\n\n    def test_delete_header(self):\n        response = BaseResponse()\n        response['x-test'] = 'foo'\n        self.assertEqual('foo', response['x-test'])\n        del response['X-tESt']\n        self.assertRaises(KeyError, lambda: response['x-test'])\n\n    def test_non_string_header(self):\n        response = BaseResponse()\n        response['x-test'] = 5\n        self.assertEqual('5', response['x-test'])\n        response['x-test'] = None\n        self.assertEqual('None', response['x-test'])\n\n    def test_expires_header(self):\n        import datetime\n        response = BaseResponse()\n        now = datetime.datetime.now()\n        response.expires = now\n\n        def seconds(a, b):\n            td = max(a,b) - min(a,b)\n            return td.days*360*24 + td.seconds\n\n        self.assertEqual(0, seconds(response.expires, now))\n        now2 = datetime.datetime.utcfromtimestamp(\n            parse_date(response.headers['Expires']))\n        self.assertEqual(0, seconds(now, now2))\n\n\nclass TestRedirect(unittest.TestCase):\n\n    def assertRedirect(self, target, result, query=None, status=303, **args):\n        env = {'SERVER_PROTOCOL': 'HTTP/1.1'}\n        for key in list(args):\n            if key.startswith('wsgi'):\n                args[key.replace('_', '.', 1)] = args[key]\n                del args[key]\n        env.update(args)\n        request.bind(env)\n        bottle.response.bind()\n        try:\n            bottle.redirect(target, **(query or {}))\n        except bottle.HTTPResponse as E:\n            self.assertEqual(status, E.status_code)\n            self.assertTrue(E.headers)\n            self.assertEqual(result, E.headers['Location'])\n\n    def test_absolute_path(self):\n        self.assertRedirect('/', 'http://127.0.0.1/')\n        self.assertRedirect('/test.html', 'http://127.0.0.1/test.html')\n        self.assertRedirect('/test.html', 'http://127.0.0.1/test.html',\n                            PATH_INFO='/some/sub/path/')\n        self.assertRedirect('/test.html', 'http://127.0.0.1/test.html',\n                            PATH_INFO='/some/sub/file.html')\n        self.assertRedirect('/test.html', 'http://127.0.0.1/test.html',\n                            SCRIPT_NAME='/some/sub/path/')\n        self.assertRedirect('/foo/test.html', 'http://127.0.0.1/foo/test.html')\n        self.assertRedirect('/foo/test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/some/sub/file.html')\n\n    def test_relative_path(self):\n        self.assertRedirect('./', 'http://127.0.0.1/')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/test.html')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/foo/')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/foo/bar.html')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/foo/test.html',\n                            SCRIPT_NAME='/foo/')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/foo/bar/test.html',\n                            SCRIPT_NAME='/foo/', PATH_INFO='/bar/baz.html')\n        self.assertRedirect('./foo/test.html', 'http://127.0.0.1/foo/test.html')\n        self.assertRedirect('./foo/test.html', 'http://127.0.0.1/bar/foo/test.html',\n                            PATH_INFO='/bar/file.html')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/test.html',\n                            PATH_INFO='/foo/')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/foo/bar/')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/test.html',\n                            PATH_INFO='/foo/bar.html')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/test.html',\n                            SCRIPT_NAME='/foo/')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/foo/test.html',\n                            SCRIPT_NAME='/foo/', PATH_INFO='/bar/baz.html')\n        self.assertRedirect('../baz/../test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/foo/bar/')\n\n    def test_sheme(self):\n        self.assertRedirect('./test.html', 'https://127.0.0.1/test.html',\n                            wsgi_url_scheme='https')\n        self.assertRedirect('./test.html', 'https://127.0.0.1:80/test.html',\n                            wsgi_url_scheme='https', SERVER_PORT='80')\n\n    def test_host_http_1_0(self):\n        # No HTTP_HOST, just SERVER_NAME and SERVER_PORT.\n        self.assertRedirect('./test.html', 'http://example.com/test.html',\n                            SERVER_NAME='example.com',\n                            SERVER_PROTOCOL='HTTP/1.0', status=302)\n        self.assertRedirect('./test.html', 'http://127.0.0.1:81/test.html',\n                            SERVER_PORT='81',\n                            SERVER_PROTOCOL='HTTP/1.0', status=302)\n\n    def test_host_http_1_1(self):\n        self.assertRedirect('./test.html', 'http://example.com/test.html',\n                            HTTP_HOST='example.com')\n        self.assertRedirect('./test.html', 'http://example.com:81/test.html',\n                            HTTP_HOST='example.com:81')\n        # Trust HTTP_HOST over SERVER_NAME and PORT.\n        self.assertRedirect('./test.html', 'http://example.com:81/test.html',\n                            HTTP_HOST='example.com:81', SERVER_NAME='foobar')\n        self.assertRedirect('./test.html', 'http://example.com:81/test.html',\n                            HTTP_HOST='example.com:81', SERVER_PORT='80')\n\n    def test_host_http_proxy(self):\n        # Trust proxy headers over original header.\n        self.assertRedirect('./test.html', 'http://example.com/test.html',\n                            HTTP_X_FORWARDED_HOST='example.com',\n                            HTTP_HOST='127.0.0.1')\n\n    def test_specialchars(self):\n        ''' The target URL is not quoted automatically. '''\n        self.assertRedirect('./te st.html',\n                            'http://example.com/a%20a/b%20b/te st.html',\n                            HTTP_HOST='example.com', SCRIPT_NAME='/a a/', PATH_INFO='/b b/')\n\n    def test_redirect_preserve_cookies(self):\n        env = {'SERVER_PROTOCOL':'HTTP/1.1'}\n        request.bind(env)\n        bottle.response.bind()\n        try:\n            bottle.response.set_cookie('xxx', 'yyy')\n            bottle.redirect('...')\n        except bottle.HTTPResponse as E:\n            h = [v for (k, v) in E.headerlist if k == 'Set-Cookie']\n            self.assertEqual(h, ['xxx=yyy'])\n\nclass TestWSGIHeaderDict(unittest.TestCase):\n    def setUp(self):\n        self.env = {}\n        self.headers = bottle.WSGIHeaderDict(self.env)\n\n    def test_empty(self):\n        self.assertEqual(0, len(bottle.WSGIHeaderDict({})))\n\n    def test_native(self):\n        self.env['HTTP_TEST_HEADER'] = 'foobar'\n        self.assertEqual(self.headers['Test-header'], 'foobar')\n\n    def test_bytes(self):\n        self.env['HTTP_TEST_HEADER'] = tob('foobar')\n        self.assertEqual(self.headers['Test-Header'], 'foobar')\n\n    def test_unicode(self):\n        self.env['HTTP_TEST_HEADER'] = touni('foobar')\n        self.assertEqual(self.headers['Test-Header'], 'foobar')\n\n    def test_dict(self):\n        for key in 'foo-bar Foo-Bar foo-Bar FOO-BAR'.split():\n            self.assertTrue(key not in self.headers)\n            self.assertEqual(self.headers.get(key), None)\n            self.assertEqual(self.headers.get(key, 5), 5)\n            self.assertRaises(KeyError, lambda x: self.headers[x], key)\n        self.env['HTTP_FOO_BAR'] = 'test'\n        for key in 'foo-bar Foo-Bar foo-Bar FOO-BAR'.split():\n            self.assertTrue(key in self.headers)\n            self.assertEqual(self.headers.get(key), 'test')\n            self.assertEqual(self.headers.get(key, 5), 'test')\n"], "fixing_code": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nBottle is a fast and simple micro-framework for small web applications. It\noffers request dispatching (Routes) with URL parameter support, templates,\na built-in HTTP Server and adapters for many third party WSGI/HTTP-server and\ntemplate engines - all in a single file and with no dependencies other than the\nPython Standard Library.\n\nHomepage and documentation: http://bottlepy.org/\n\nCopyright (c) 2015, Marcel Hellkamp.\nLicense: MIT (see LICENSE for details)\n\"\"\"\n\nimport sys\n\n__author__ = 'Marcel Hellkamp'\n__version__ = '0.13-dev'\n__license__ = 'MIT'\n\n###############################################################################\n# Command-line interface ######################################################\n###############################################################################\n# INFO: Some server adapters need to monkey-patch std-lib modules before they\n# are imported. This is why some of the command-line handling is done here, but\n# the actual call to _main() is at the end of the file.\n\n\ndef _cli_parse(args):  # pragma: no coverage\n    from argparse import ArgumentParser\n\n    parser = ArgumentParser(usage=\"usage: %sprog [options] package.module:app\")\n    opt = parser.add_argument\n    opt('app', help='WSGI app entry point.')\n    opt(\"--version\", action=\"store_true\", help=\"show version number.\")\n    opt(\"-b\", \"--bind\", metavar=\"ADDRESS\", help=\"bind socket to ADDRESS.\")\n    opt(\"-s\", \"--server\", default='wsgiref', help=\"use SERVER as backend.\")\n    opt(\"-p\", \"--plugin\", action=\"append\", help=\"install additional plugin/s.\")\n    opt(\"-c\", \"--conf\", action=\"append\", metavar=\"FILE\",\n        help=\"load config values from FILE.\")\n    opt(\"-C\", \"--param\", action=\"append\", metavar=\"NAME=VALUE\",\n        help=\"override config values.\")\n    opt(\"--debug\", action=\"store_true\", help=\"start server in debug mode.\")\n    opt(\"--reload\", action=\"store_true\", help=\"auto-reload on file changes.\")\n\n    cli_args = parser.parse_args(args)\n\n    return cli_args, parser\n\n\ndef _cli_patch(cli_args):  # pragma: no coverage\n    parsed_args, _ = _cli_parse(cli_args)\n    opts = parsed_args\n    if opts.server:\n        if opts.server.startswith('gevent'):\n            import gevent.monkey\n            gevent.monkey.patch_all()\n        elif opts.server.startswith('eventlet'):\n            import eventlet\n            eventlet.monkey_patch()\n\n\nif __name__ == '__main__':\n    _cli_patch(sys.argv)\n\n###############################################################################\n# Imports and Python 2/3 unification ##########################################\n###############################################################################\n\n\nimport base64, cgi, email.utils, functools, hmac, imp, itertools, mimetypes,\\\n        os, re, tempfile, threading, time, warnings, weakref, hashlib\n\nfrom types import FunctionType\nfrom datetime import date as datedate, datetime, timedelta\nfrom tempfile import TemporaryFile\nfrom traceback import format_exc, print_exc\nfrom unicodedata import normalize\nfrom json import dumps as json_dumps, loads as json_lds\n\n# inspect.getargspec was removed in Python 3.6, use\n# Signature-based version where we can (Python 3.3+)\ntry:\n    from inspect import signature\n    def getargspec(func):\n        params = signature(func).parameters\n        args, varargs, keywords, defaults = [], None, None, []\n        for name, param in params.items():\n            if param.kind == param.VAR_POSITIONAL:\n                varargs = name\n            elif param.kind == param.VAR_KEYWORD:\n                keywords = name\n            else:\n                args.append(name)\n                if param.default is not param.empty:\n                    defaults.append(param.default)\n        return (args, varargs, keywords, tuple(defaults) or None)\nexcept ImportError:\n    try:\n        from inspect import getfullargspec\n        def getargspec(func):\n            spec = getfullargspec(func)\n            kwargs = makelist(spec[0]) + makelist(spec.kwonlyargs)\n            return kwargs, spec[1], spec[2], spec[3]\n    except ImportError:\n        from inspect import getargspec\n\npy3k = sys.version_info.major > 2\n\n\n# Workaround for the \"print is a keyword/function\" Python 2/3 dilemma\n# and a fallback for mod_wsgi (resticts stdout/err attribute access)\ntry:\n    _stdout, _stderr = sys.stdout.write, sys.stderr.write\nexcept IOError:\n    _stdout = lambda x: sys.stdout.write(x)\n    _stderr = lambda x: sys.stderr.write(x)\n\n# Lots of stdlib and builtin differences.\nif py3k:\n    import http.client as httplib\n    import _thread as thread\n    from urllib.parse import urljoin, SplitResult as UrlSplitResult\n    from urllib.parse import urlencode, quote as urlquote, unquote as urlunquote\n    urlunquote = functools.partial(urlunquote, encoding='latin1')\n    from http.cookies import SimpleCookie\n    from collections import MutableMapping as DictMixin\n    import pickle\n    from io import BytesIO\n    import configparser\n\n    basestring = str\n    unicode = str\n    json_loads = lambda s: json_lds(touni(s))\n    callable = lambda x: hasattr(x, '__call__')\n    imap = map\n\n    def _raise(*a):\n        raise a[0](a[1]).with_traceback(a[2])\nelse:  # 2.x\n    import httplib\n    import thread\n    from urlparse import urljoin, SplitResult as UrlSplitResult\n    from urllib import urlencode, quote as urlquote, unquote as urlunquote\n    from Cookie import SimpleCookie\n    from itertools import imap\n    import cPickle as pickle\n    from StringIO import StringIO as BytesIO\n    import ConfigParser as configparser\n    from collections import MutableMapping as DictMixin\n    unicode = unicode\n    json_loads = json_lds\n    exec(compile('def _raise(*a): raise a[0], a[1], a[2]', '<py3fix>', 'exec'))\n\n# Some helpers for string/byte handling\ndef tob(s, enc='utf8'):\n    return s.encode(enc) if isinstance(s, unicode) else bytes(s)\n\n\ndef touni(s, enc='utf8', err='strict'):\n    if isinstance(s, bytes):\n        return s.decode(enc, err)\n    else:\n        return unicode(s or (\"\" if s is None else s))\n\n\ntonat = touni if py3k else tob\n\n# 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).\n\n\n# A bug in functools causes it to break if the wrapper is an instance method\ndef update_wrapper(wrapper, wrapped, *a, **ka):\n    try:\n        functools.update_wrapper(wrapper, wrapped, *a, **ka)\n    except AttributeError:\n        pass\n\n# These helpers are used at module level and need to be defined first.\n# And yes, I know PEP-8, but sometimes a lower-case classname makes more sense.\n\n\ndef depr(major, minor, cause, fix):\n    text = \"Warning: Use of deprecated feature or API. (Deprecated in Bottle-%d.%d)\\n\"\\\n           \"Cause: %s\\n\"\\\n           \"Fix: %s\\n\" % (major, minor, cause, fix)\n    if DEBUG == 'strict':\n        raise DeprecationWarning(text)\n    warnings.warn(text, DeprecationWarning, stacklevel=3)\n    return DeprecationWarning(text)\n\n\ndef makelist(data):  # This is just too handy\n    if isinstance(data, (tuple, list, set, dict)):\n        return list(data)\n    elif data:\n        return [data]\n    else:\n        return []\n\n\nclass DictProperty(object):\n    \"\"\" Property that maps to a key in a local dict-like attribute. \"\"\"\n\n    def __init__(self, attr, key=None, read_only=False):\n        self.attr, self.key, self.read_only = attr, key, read_only\n\n    def __call__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter, self.key = func, self.key or func.__name__\n        return self\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        key, storage = self.key, getattr(obj, self.attr)\n        if key not in storage: storage[key] = self.getter(obj)\n        return storage[key]\n\n    def __set__(self, obj, value):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        getattr(obj, self.attr)[self.key] = value\n\n    def __delete__(self, obj):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        del getattr(obj, self.attr)[self.key]\n\n\nclass cached_property(object):\n    \"\"\" A property that is only computed once per instance and then replaces\n        itself with an ordinary attribute. Deleting the attribute resets the\n        property. \"\"\"\n\n    def __init__(self, func):\n        update_wrapper(self, func)\n        self.func = func\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value\n\n\nclass lazy_attribute(object):\n    \"\"\" A property that caches itself to the class object. \"\"\"\n\n    def __init__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter = func\n\n    def __get__(self, obj, cls):\n        value = self.getter(cls)\n        setattr(cls, self.__name__, value)\n        return value\n\n###############################################################################\n# Exceptions and Events #######################################################\n###############################################################################\n\n\nclass BottleException(Exception):\n    \"\"\" A base class for exceptions used by bottle. \"\"\"\n    pass\n\n###############################################################################\n# Routing ######################################################################\n###############################################################################\n\n\nclass RouteError(BottleException):\n    \"\"\" This is a base class for all routing related exceptions \"\"\"\n\n\nclass RouteReset(BottleException):\n    \"\"\" If raised by a plugin or request handler, the route is reset and all\n        plugins are re-applied. \"\"\"\n\n\nclass RouterUnknownModeError(RouteError):\n\n    pass\n\n\nclass RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\n\n\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\n\n\ndef _re_flatten(p):\n    \"\"\" Turn all capturing groups in a regular expression pattern into\n        non-capturing groups. \"\"\"\n    if '(' not in p:\n        return p\n    return re.sub(r'(\\\\*)(\\(\\?P<[^>]+>|\\((?!\\?))', lambda m: m.group(0) if\n                  len(m.group(1)) % 2 else m.group(1) + '(?:', p)\n\n\nclass Router(object):\n    \"\"\" A Router is an ordered collection of route->target pairs. It is used to\n        efficiently match WSGI requests against a number of routes and return\n        the first target that satisfies the request. The target may be anything,\n        usually a string, ID or callable object. A route consists of a path-rule\n        and a HTTP method.\n\n        The path-rule is either a static path (e.g. `/contact`) or a dynamic\n        path that contains wildcards (e.g. `/wiki/<page>`). The wildcard syntax\n        and details on the matching order are described in docs:`routing`.\n    \"\"\"\n\n    default_pattern = '[^/]+'\n    default_filter = 're'\n\n    #: The current CPython regexp implementation does not allow more\n    #: than 99 matching groups per regular expression.\n    _MAX_GROUPS_PER_PATTERN = 99\n\n    def __init__(self, strict=False):\n        self.rules = []  # All rules in order\n        self._groups = {}  # index of regexes to find them in dyna_routes\n        self.builder = {}  # Data structure for the url builder\n        self.static = {}  # Search structure for static routes\n        self.dyna_routes = {}\n        self.dyna_regexes = {}  # Search structure for dynamic routes\n        #: If true, static routes are no longer checked first.\n        self.strict_order = strict\n        self.filters = {\n            're': lambda conf: (_re_flatten(conf or self.default_pattern),\n                                None, None),\n            'int': lambda conf: (r'-?\\d+', int, lambda x: str(int(x))),\n            'float': lambda conf: (r'-?[\\d.]+', float, lambda x: str(float(x))),\n            'path': lambda conf: (r'.+?', None, None)\n        }\n\n    def add_filter(self, name, func):\n        \"\"\" Add a filter. The provided function is called with the configuration\n        string as parameter and must return a (regexp, to_python, to_url) tuple.\n        The first element is a string, the last two are callables or None. \"\"\"\n        self.filters[name] = func\n\n    rule_syntax = re.compile('(\\\\\\\\*)'\n        '(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:#(.*?)#)?)'\n          '|(?:<([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)'\n            '(?::((?:\\\\\\\\.|[^\\\\\\\\>]+)+)?)?)?>))')\n\n    def _itertokens(self, rule):\n        offset, prefix = 0, ''\n        for match in self.rule_syntax.finditer(rule):\n            prefix += rule[offset:match.start()]\n            g = match.groups()\n            if g[2] is not None:\n                depr(0, 13, \"Use of old route syntax.\",\n                            \"Use <name> instead of :name in routes.\")\n            if len(g[0]) % 2:  # Escaped wildcard\n                prefix += match.group(0)[len(g[0]):]\n                offset = match.end()\n                continue\n            if prefix:\n                yield prefix, None, None\n            name, filtr, conf = g[4:7] if g[2] is None else g[1:4]\n            yield name, filtr or 'default', conf or None\n            offset, prefix = match.end(), ''\n        if offset <= len(rule) or prefix:\n            yield prefix + rule[offset:], None, None\n\n    def add(self, rule, method, target, name=None):\n        \"\"\" Add a new rule or replace the target for an existing rule. \"\"\"\n        anons = 0  # Number of anonymous wildcards found\n        keys = []  # Names of keys\n        pattern = ''  # Regular expression pattern with named groups\n        filters = []  # Lists of wildcard input filters\n        builder = []  # Data structure for the URL builder\n        is_static = True\n\n        for key, mode, conf in self._itertokens(rule):\n            if mode:\n                is_static = False\n                if mode == 'default': mode = self.default_filter\n                mask, in_filter, out_filter = self.filters[mode](conf)\n                if not key:\n                    pattern += '(?:%s)' % mask\n                    key = 'anon%d' % anons\n                    anons += 1\n                else:\n                    pattern += '(?P<%s>%s)' % (key, mask)\n                    keys.append(key)\n                if in_filter: filters.append((key, in_filter))\n                builder.append((key, out_filter or str))\n            elif key:\n                pattern += re.escape(key)\n                builder.append((None, key))\n\n        self.builder[rule] = builder\n        if name: self.builder[name] = builder\n\n        if is_static and not self.strict_order:\n            self.static.setdefault(method, {})\n            self.static[method][self.build(rule)] = (target, None)\n            return\n\n        try:\n            re_pattern = re.compile('^(%s)$' % pattern)\n            re_match = re_pattern.match\n        except re.error as e:\n            raise RouteSyntaxError(\"Could not add Route: %s (%s)\" % (rule, e))\n\n        if filters:\n\n            def getargs(path):\n                url_args = re_match(path).groupdict()\n                for name, wildcard_filter in filters:\n                    try:\n                        url_args[name] = wildcard_filter(url_args[name])\n                    except ValueError:\n                        raise HTTPError(400, 'Path has wrong format.')\n                return url_args\n        elif re_pattern.groupindex:\n\n            def getargs(path):\n                return re_match(path).groupdict()\n        else:\n            getargs = None\n\n        flatpat = _re_flatten(pattern)\n        whole_rule = (rule, flatpat, target, getargs)\n\n        if (flatpat, method) in self._groups:\n            if DEBUG:\n                msg = 'Route <%s %s> overwrites a previously defined route'\n                warnings.warn(msg % (method, rule), RuntimeWarning)\n            self.dyna_routes[method][\n                self._groups[flatpat, method]] = whole_rule\n        else:\n            self.dyna_routes.setdefault(method, []).append(whole_rule)\n            self._groups[flatpat, method] = len(self.dyna_routes[method]) - 1\n\n        self._compile(method)\n\n    def _compile(self, method):\n        all_rules = self.dyna_routes[method]\n        comborules = self.dyna_regexes[method] = []\n        maxgroups = self._MAX_GROUPS_PER_PATTERN\n        for x in range(0, len(all_rules), maxgroups):\n            some = all_rules[x:x + maxgroups]\n            combined = (flatpat for (_, flatpat, _, _) in some)\n            combined = '|'.join('(^%s$)' % flatpat for flatpat in combined)\n            combined = re.compile(combined).match\n            rules = [(target, getargs) for (_, _, target, getargs) in some]\n            comborules.append((combined, rules))\n\n    def build(self, _name, *anons, **query):\n        \"\"\" Build an URL by filling the wildcards in a rule. \"\"\"\n        builder = self.builder.get(_name)\n        if not builder:\n            raise RouteBuildError(\"No route with that name.\", _name)\n        try:\n            for i, value in enumerate(anons):\n                query['anon%d' % i] = value\n            url = ''.join([f(query.pop(n)) if n else f for (n, f) in builder])\n            return url if not query else url + '?' + urlencode(query)\n        except KeyError as E:\n            raise RouteBuildError('Missing URL argument: %r' % E.args[0])\n\n    def match(self, environ):\n        \"\"\" Return a (target, url_args) tuple or raise HTTPError(400/404/405). \"\"\"\n        verb = environ['REQUEST_METHOD'].upper()\n        path = environ['PATH_INFO'] or '/'\n\n        if verb == 'HEAD':\n            methods = ['PROXY', verb, 'GET', 'ANY']\n        else:\n            methods = ['PROXY', verb, 'ANY']\n\n        for method in methods:\n            if method in self.static and path in self.static[method]:\n                target, getargs = self.static[method][path]\n                return target, getargs(path) if getargs else {}\n            elif method in self.dyna_regexes:\n                for combined, rules in self.dyna_regexes[method]:\n                    match = combined(path)\n                    if match:\n                        target, getargs = rules[match.lastindex - 1]\n                        return target, getargs(path) if getargs else {}\n\n        # No matching route found. Collect alternative methods for 405 response\n        allowed = set([])\n        nocheck = set(methods)\n        for method in set(self.static) - nocheck:\n            if path in self.static[method]:\n                allowed.add(verb)\n        for method in set(self.dyna_regexes) - allowed - nocheck:\n            for combined, rules in self.dyna_regexes[method]:\n                match = combined(path)\n                if match:\n                    allowed.add(method)\n        if allowed:\n            allow_header = \",\".join(sorted(allowed))\n            raise HTTPError(405, \"Method not allowed.\", Allow=allow_header)\n\n        # No matching route and no alternative method found. We give up\n        raise HTTPError(404, \"Not found: \" + repr(path))\n\n\nclass Route(object):\n    \"\"\" This class wraps a route callback along with route specific metadata and\n        configuration and applies Plugins on demand. It is also responsible for\n        turing an URL path rule into a regular expression usable by the Router.\n    \"\"\"\n\n    def __init__(self, app, rule, method, callback,\n                 name=None,\n                 plugins=None,\n                 skiplist=None, **config):\n        #: The application this route is installed to.\n        self.app = app\n        #: The path-rule string (e.g. ``/wiki/<page>``).\n        self.rule = rule\n        #: The HTTP method as a string (e.g. ``GET``).\n        self.method = method\n        #: The original callback with no plugins applied. Useful for introspection.\n        self.callback = callback\n        #: The name of the route (if specified) or ``None``.\n        self.name = name or None\n        #: A list of route-specific plugins (see :meth:`Bottle.route`).\n        self.plugins = plugins or []\n        #: A list of plugins to not apply to this route (see :meth:`Bottle.route`).\n        self.skiplist = skiplist or []\n        #: Additional keyword arguments passed to the :meth:`Bottle.route`\n        #: decorator are stored in this dictionary. Used for route-specific\n        #: plugin configuration and meta-data.\n        self.config = app.config._make_overlay()\n        self.config.load_dict(config)\n\n    @cached_property\n    def call(self):\n        \"\"\" The route callback with all plugins applied. This property is\n            created on demand and then cached to speed up subsequent requests.\"\"\"\n        return self._make_callback()\n\n    def reset(self):\n        \"\"\" Forget any cached values. The next time :attr:`call` is accessed,\n            all plugins are re-applied. \"\"\"\n        self.__dict__.pop('call', None)\n\n    def prepare(self):\n        \"\"\" Do all on-demand work immediately (useful for debugging).\"\"\"\n        self.call\n\n    def all_plugins(self):\n        \"\"\" Yield all Plugins affecting this route. \"\"\"\n        unique = set()\n        for p in reversed(self.app.plugins + self.plugins):\n            if True in self.skiplist: break\n            name = getattr(p, 'name', False)\n            if name and (name in self.skiplist or name in unique): continue\n            if p in self.skiplist or type(p) in self.skiplist: continue\n            if name: unique.add(name)\n            yield p\n\n    def _make_callback(self):\n        callback = self.callback\n        for plugin in self.all_plugins():\n            try:\n                if hasattr(plugin, 'apply'):\n                    callback = plugin.apply(callback, self)\n                else:\n                    callback = plugin(callback)\n            except RouteReset:  # Try again with changed configuration.\n                return self._make_callback()\n            if not callback is self.callback:\n                update_wrapper(callback, self.callback)\n        return callback\n\n    def get_undecorated_callback(self):\n        \"\"\" Return the callback. If the callback is a decorated function, try to\n            recover the original function. \"\"\"\n        func = self.callback\n        func = getattr(func, '__func__' if py3k else 'im_func', func)\n        closure_attr = '__closure__' if py3k else 'func_closure'\n        while hasattr(func, closure_attr) and getattr(func, closure_attr):\n            attributes = getattr(func, closure_attr)\n            func = attributes[0].cell_contents\n\n            # in case of decorators with multiple arguments\n            if not isinstance(func, FunctionType):\n                # pick first FunctionType instance from multiple arguments\n                func = filter(lambda x: isinstance(x, FunctionType),\n                              map(lambda x: x.cell_contents, attributes))\n                func = list(func)[0]  # py3 support\n        return func\n\n    def get_callback_args(self):\n        \"\"\" Return a list of argument names the callback (most likely) accepts\n            as keyword arguments. If the callback is a decorated function, try\n            to recover the original function before inspection. \"\"\"\n        return getargspec(self.get_undecorated_callback())[0]\n\n    def get_config(self, key, default=None):\n        \"\"\" Lookup a config field and return its value, first checking the\n            route.config, then route.app.config.\"\"\"\n        depr(0, 13, \"Route.get_config() is deprectated.\",\n                    \"The Route.config property already includes values from the\"\n                    \" application config for missing keys. Access it directly.\")\n        return self.config.get(key, default)\n\n    def __repr__(self):\n        cb = self.get_undecorated_callback()\n        return '<%s %r %r>' % (self.method, self.rule, cb)\n\n###############################################################################\n# Application Object ###########################################################\n###############################################################################\n\n\nclass Bottle(object):\n    \"\"\" Each Bottle object represents a single, distinct web application and\n        consists of routes, callbacks, plugins, resources and configuration.\n        Instances are callable WSGI applications.\n\n        :param catchall: If true (default), handle all exceptions. Turn off to\n                         let debugging middleware handle exceptions.\n    \"\"\"\n\n    @lazy_attribute\n    def _global_config(cls):\n        cfg = ConfigDict()\n        cfg.meta_set('catchall', 'validate', bool)\n        return cfg\n\n    def __init__(self, **kwargs):\n        #: A :class:`ConfigDict` for app specific configuration.\n        self.config = self._global_config._make_overlay()\n        self.config._add_change_listener(\n            functools.partial(self.trigger_hook, 'config'))\n\n        self.config.update({\n            \"catchall\": True\n        })\n\n        if kwargs.get('catchall') is False:\n            depr(0,13, \"Bottle(catchall) keyword argument.\",\n                        \"The 'catchall' setting is now part of the app \"\n                        \"configuration. Fix: `app.config['catchall'] = False`\")\n            self.config['catchall'] = False\n        if kwargs.get('autojson') is False:\n            depr(0, 13, \"Bottle(autojson) keyword argument.\",\n                 \"The 'autojson' setting is now part of the app \"\n                 \"configuration. Fix: `app.config['json.enable'] = False`\")\n            self.config['json.disable'] = True\n\n        self._mounts = []\n\n        #: A :class:`ResourceManager` for application files\n        self.resources = ResourceManager()\n\n        self.routes = []  # List of installed :class:`Route` instances.\n        self.router = Router()  # Maps requests to :class:`Route` instances.\n        self.error_handler = {}\n\n        # Core plugins\n        self.plugins = []  # List of installed plugins.\n        self.install(JSONPlugin())\n        self.install(TemplatePlugin())\n\n    #: If true, most exceptions are caught and returned as :exc:`HTTPError`\n    catchall = DictProperty('config', 'catchall')\n\n    __hook_names = 'before_request', 'after_request', 'app_reset', 'config'\n    __hook_reversed = {'after_request'}\n\n    @cached_property\n    def _hooks(self):\n        return dict((name, []) for name in self.__hook_names)\n\n    def add_hook(self, name, func):\n        \"\"\" Attach a callback to a hook. Three hooks are currently implemented:\n\n            before_request\n                Executed once before each request. The request context is\n                available, but no routing has happened yet.\n            after_request\n                Executed once after each request regardless of its outcome.\n            app_reset\n                Called whenever :meth:`Bottle.reset` is called.\n        \"\"\"\n        if name in self.__hook_reversed:\n            self._hooks[name].insert(0, func)\n        else:\n            self._hooks[name].append(func)\n\n    def remove_hook(self, name, func):\n        \"\"\" Remove a callback from a hook. \"\"\"\n        if name in self._hooks and func in self._hooks[name]:\n            self._hooks[name].remove(func)\n            return True\n\n    def trigger_hook(self, __name, *args, **kwargs):\n        \"\"\" Trigger a hook and return a list of results. \"\"\"\n        return [hook(*args, **kwargs) for hook in self._hooks[__name][:]]\n\n    def hook(self, name):\n        \"\"\" Return a decorator that attaches a callback to a hook. See\n            :meth:`add_hook` for details.\"\"\"\n\n        def decorator(func):\n            self.add_hook(name, func)\n            return func\n\n        return decorator\n\n    def _mount_wsgi(self, prefix, app, **options):\n        segments = [p for p in prefix.split('/') if p]\n        if not segments:\n            raise ValueError('WSGI applications cannot be mounted to \"/\".')\n        path_depth = len(segments)\n\n        def mountpoint_wrapper():\n            try:\n                request.path_shift(path_depth)\n                rs = HTTPResponse([])\n\n                def start_response(status, headerlist, exc_info=None):\n                    if exc_info:\n                        _raise(*exc_info)\n                    rs.status = status\n                    for name, value in headerlist:\n                        rs.add_header(name, value)\n                    return rs.body.append\n\n                body = app(request.environ, start_response)\n                rs.body = itertools.chain(rs.body, body) if rs.body else body\n                return rs\n            finally:\n                request.path_shift(-path_depth)\n\n        options.setdefault('skip', True)\n        options.setdefault('method', 'PROXY')\n        options.setdefault('mountpoint', {'prefix': prefix, 'target': app})\n        options['callback'] = mountpoint_wrapper\n\n        self.route('/%s/<:re:.*>' % '/'.join(segments), **options)\n        if not prefix.endswith('/'):\n            self.route('/' + '/'.join(segments), **options)\n\n    def _mount_app(self, prefix, app, **options):\n        if app in self._mounts or '_mount.app' in app.config:\n            depr(0, 13, \"Application mounted multiple times. Falling back to WSGI mount.\",\n                 \"Clone application before mounting to a different location.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        if options:\n            depr(0, 13, \"Unsupported mount options. Falling back to WSGI mount.\",\n                 \"Do not specify any route options when mounting bottle application.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        if not prefix.endswith(\"/\"):\n            depr(0, 13, \"Prefix must end in '/'. Falling back to WSGI mount.\",\n                 \"Consider adding an explicit redirect from '/prefix' to '/prefix/' in the parent application.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        self._mounts.append(app)\n        app.config['_mount.prefix'] = prefix\n        app.config['_mount.app'] = self\n        for route in app.routes:\n            route.rule = prefix + route.rule.lstrip('/')\n            self.add_route(route)\n\n    def mount(self, prefix, app, **options):\n        \"\"\" Mount an application (:class:`Bottle` or plain WSGI) to a specific\n            URL prefix. Example::\n\n                parent_app.mount('/prefix/', child_app)\n\n            :param prefix: path prefix or `mount-point`.\n            :param app: an instance of :class:`Bottle` or a WSGI application.\n\n            Plugins from the parent application are not applied to the routes\n            of the mounted child application. If you need plugins in the child\n            application, install them separately.\n\n            While it is possible to use path wildcards within the prefix path\n            (:class:`Bottle` childs only), it is highly discouraged.\n\n            The prefix path must end with a slash. If you want to access the\n            root of the child application via `/prefix` in addition to\n            `/prefix/`, consider adding a route with a 307 redirect to the\n            parent application.\n        \"\"\"\n\n        if not prefix.startswith('/'):\n            raise ValueError(\"Prefix must start with '/'\")\n\n        if isinstance(app, Bottle):\n            return self._mount_app(prefix, app, **options)\n        else:\n            return self._mount_wsgi(prefix, app, **options)\n\n    def merge(self, routes):\n        \"\"\" Merge the routes of another :class:`Bottle` application or a list of\n            :class:`Route` objects into this application. The routes keep their\n            'owner', meaning that the :data:`Route.app` attribute is not\n            changed. \"\"\"\n        if isinstance(routes, Bottle):\n            routes = routes.routes\n        for route in routes:\n            self.add_route(route)\n\n    def install(self, plugin):\n        \"\"\" Add a plugin to the list of plugins and prepare it for being\n            applied to all routes of this application. A plugin may be a simple\n            decorator or an object that implements the :class:`Plugin` API.\n        \"\"\"\n        if hasattr(plugin, 'setup'): plugin.setup(self)\n        if not callable(plugin) and not hasattr(plugin, 'apply'):\n            raise TypeError(\"Plugins must be callable or implement .apply()\")\n        self.plugins.append(plugin)\n        self.reset()\n        return plugin\n\n    def uninstall(self, plugin):\n        \"\"\" Uninstall plugins. Pass an instance to remove a specific plugin, a type\n            object to remove all plugins that match that type, a string to remove\n            all plugins with a matching ``name`` attribute or ``True`` to remove all\n            plugins. Return the list of removed plugins. \"\"\"\n        removed, remove = [], plugin\n        for i, plugin in list(enumerate(self.plugins))[::-1]:\n            if remove is True or remove is plugin or remove is type(plugin) \\\n            or getattr(plugin, 'name', True) == remove:\n                removed.append(plugin)\n                del self.plugins[i]\n                if hasattr(plugin, 'close'): plugin.close()\n        if removed: self.reset()\n        return removed\n\n    def reset(self, route=None):\n        \"\"\" Reset all routes (force plugins to be re-applied) and clear all\n            caches. If an ID or route object is given, only that specific route\n            is affected. \"\"\"\n        if route is None: routes = self.routes\n        elif isinstance(route, Route): routes = [route]\n        else: routes = [self.routes[route]]\n        for route in routes:\n            route.reset()\n        if DEBUG:\n            for route in routes:\n                route.prepare()\n        self.trigger_hook('app_reset')\n\n    def close(self):\n        \"\"\" Close the application and all installed plugins. \"\"\"\n        for plugin in self.plugins:\n            if hasattr(plugin, 'close'): plugin.close()\n\n    def run(self, **kwargs):\n        \"\"\" Calls :func:`run` with the same parameters. \"\"\"\n        run(self, **kwargs)\n\n    def match(self, environ):\n        \"\"\" Search for a matching route and return a (:class:`Route` , urlargs)\n            tuple. The second value is a dictionary with parameters extracted\n            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match.\"\"\"\n        return self.router.match(environ)\n\n    def get_url(self, routename, **kargs):\n        \"\"\" Return a string that matches a named route \"\"\"\n        scriptname = request.environ.get('SCRIPT_NAME', '').strip('/') + '/'\n        location = self.router.build(routename, **kargs).lstrip('/')\n        return urljoin(urljoin('/', scriptname), location)\n\n    def add_route(self, route):\n        \"\"\" Add a route object, but do not change the :data:`Route.app`\n            attribute.\"\"\"\n        self.routes.append(route)\n        self.router.add(route.rule, route.method, route, name=route.name)\n        if DEBUG: route.prepare()\n\n    def route(self,\n              path=None,\n              method='GET',\n              callback=None,\n              name=None,\n              apply=None,\n              skip=None, **config):\n        \"\"\" A decorator to bind a function to a request URL. Example::\n\n                @app.route('/hello/<name>')\n                def hello(name):\n                    return 'Hello %s' % name\n\n            The ``<name>`` part is a wildcard. See :class:`Router` for syntax\n            details.\n\n            :param path: Request path or a list of paths to listen to. If no\n              path is specified, it is automatically generated from the\n              signature of the function.\n            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of\n              methods to listen to. (default: `GET`)\n            :param callback: An optional shortcut to avoid the decorator\n              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``\n            :param name: The name for this route. (default: None)\n            :param apply: A decorator or plugin or a list of plugins. These are\n              applied to the route callback in addition to installed plugins.\n            :param skip: A list of plugins, plugin classes or names. Matching\n              plugins are not installed to this route. ``True`` skips all.\n\n            Any additional keyword arguments are stored as route-specific\n            configuration and passed to plugins (see :meth:`Plugin.apply`).\n        \"\"\"\n        if callable(path): path, callback = None, path\n        plugins = makelist(apply)\n        skiplist = makelist(skip)\n\n        def decorator(callback):\n            if isinstance(callback, basestring): callback = load(callback)\n            for rule in makelist(path) or yieldroutes(callback):\n                for verb in makelist(method):\n                    verb = verb.upper()\n                    route = Route(self, rule, verb, callback,\n                                  name=name,\n                                  plugins=plugins,\n                                  skiplist=skiplist, **config)\n                    self.add_route(route)\n            return callback\n\n        return decorator(callback) if callback else decorator\n\n    def get(self, path=None, method='GET', **options):\n        \"\"\" Equals :meth:`route`. \"\"\"\n        return self.route(path, method, **options)\n\n    def post(self, path=None, method='POST', **options):\n        \"\"\" Equals :meth:`route` with a ``POST`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def put(self, path=None, method='PUT', **options):\n        \"\"\" Equals :meth:`route` with a ``PUT`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def delete(self, path=None, method='DELETE', **options):\n        \"\"\" Equals :meth:`route` with a ``DELETE`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def patch(self, path=None, method='PATCH', **options):\n        \"\"\" Equals :meth:`route` with a ``PATCH`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def error(self, code=500):\n        \"\"\" Decorator: Register an output handler for a HTTP error code\"\"\"\n\n        def wrapper(handler):\n            self.error_handler[int(code)] = handler\n            return handler\n\n        return wrapper\n\n    def default_error_handler(self, res):\n        return tob(template(ERROR_PAGE_TEMPLATE, e=res, template_settings=dict(name='__ERROR_PAGE_TEMPLATE')))\n\n    def _handle(self, environ):\n        path = environ['bottle.raw_path'] = environ['PATH_INFO']\n        if py3k:\n            environ['PATH_INFO'] = path.encode('latin1').decode('utf8', 'ignore')\n\n        environ['bottle.app'] = self\n        request.bind(environ)\n        response.bind()\n\n        try:\n            while True: # Remove in 0.14 together with RouteReset\n                out = None\n                try:\n                    self.trigger_hook('before_request')\n                    route, args = self.router.match(environ)\n                    environ['route.handle'] = route\n                    environ['bottle.route'] = route\n                    environ['route.url_args'] = args\n                    out = route.call(**args)\n                    break\n                except HTTPResponse as E:\n                    out = E\n                    break\n                except RouteReset:\n                    depr(0, 13, \"RouteReset exception deprecated\",\n                                \"Call route.call() after route.reset() and \"\n                                \"return the result.\")\n                    route.reset()\n                    continue\n                finally:\n                    if isinstance(out, HTTPResponse):\n                        out.apply(response)\n                    try:\n                        self.trigger_hook('after_request')\n                    except HTTPResponse as E:\n                        out = E\n                        out.apply(response)\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as E:\n            if not self.catchall: raise\n            stacktrace = format_exc()\n            environ['wsgi.errors'].write(stacktrace)\n            environ['wsgi.errors'].flush()\n            out = HTTPError(500, \"Internal Server Error\", E, stacktrace)\n            out.apply(response)\n\n        return out\n\n    def _cast(self, out, peek=None):\n        \"\"\" Try to convert the parameter into something WSGI compatible and set\n        correct HTTP headers when possible.\n        Support: False, str, unicode, dict, HTTPResponse, HTTPError, file-like,\n        iterable of strings and iterable of unicodes\n        \"\"\"\n\n        # Empty output is done here\n        if not out:\n            if 'Content-Length' not in response:\n                response['Content-Length'] = 0\n            return []\n        # Join lists of byte or unicode strings. Mixed lists are NOT supported\n        if isinstance(out, (tuple, list))\\\n        and isinstance(out[0], (bytes, unicode)):\n            out = out[0][0:0].join(out)  # b'abc'[0:0] -> b''\n        # Encode unicode strings\n        if isinstance(out, unicode):\n            out = out.encode(response.charset)\n        # Byte Strings are just returned\n        if isinstance(out, bytes):\n            if 'Content-Length' not in response:\n                response['Content-Length'] = len(out)\n            return [out]\n        # HTTPError or HTTPException (recursive, because they may wrap anything)\n        # TODO: Handle these explicitly in handle() or make them iterable.\n        if isinstance(out, HTTPError):\n            out.apply(response)\n            out = self.error_handler.get(out.status_code,\n                                         self.default_error_handler)(out)\n            return self._cast(out)\n        if isinstance(out, HTTPResponse):\n            out.apply(response)\n            return self._cast(out.body)\n\n        # File-like objects.\n        if hasattr(out, 'read'):\n            if 'wsgi.file_wrapper' in request.environ:\n                return request.environ['wsgi.file_wrapper'](out)\n            elif hasattr(out, 'close') or not hasattr(out, '__iter__'):\n                return WSGIFileWrapper(out)\n\n        # Handle Iterables. We peek into them to detect their inner type.\n        try:\n            iout = iter(out)\n            first = next(iout)\n            while not first:\n                first = next(iout)\n        except StopIteration:\n            return self._cast('')\n        except HTTPResponse as E:\n            first = E\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as error:\n            if not self.catchall: raise\n            first = HTTPError(500, 'Unhandled exception', error, format_exc())\n\n        # These are the inner types allowed in iterator or generator objects.\n        if isinstance(first, HTTPResponse):\n            return self._cast(first)\n        elif isinstance(first, bytes):\n            new_iter = itertools.chain([first], iout)\n        elif isinstance(first, unicode):\n            encoder = lambda x: x.encode(response.charset)\n            new_iter = imap(encoder, itertools.chain([first], iout))\n        else:\n            msg = 'Unsupported response type: %s' % type(first)\n            return self._cast(HTTPError(500, msg))\n        if hasattr(out, 'close'):\n            new_iter = _closeiter(new_iter, out.close)\n        return new_iter\n\n    def wsgi(self, environ, start_response):\n        \"\"\" The bottle WSGI-interface. \"\"\"\n        try:\n            out = self._cast(self._handle(environ))\n            # rfc2616 section 4.3\n            if response._status_code in (100, 101, 204, 304)\\\n            or environ['REQUEST_METHOD'] == 'HEAD':\n                if hasattr(out, 'close'): out.close()\n                out = []\n            start_response(response._status_line, response.headerlist)\n            return out\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as E:\n            if not self.catchall: raise\n            err = '<h1>Critical error while processing request: %s</h1>' \\\n                  % html_escape(environ.get('PATH_INFO', '/'))\n            if DEBUG:\n                err += '<h2>Error:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       '<h2>Traceback:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       % (html_escape(repr(E)), html_escape(format_exc()))\n            environ['wsgi.errors'].write(err)\n            environ['wsgi.errors'].flush()\n            headers = [('Content-Type', 'text/html; charset=UTF-8')]\n            start_response('500 INTERNAL SERVER ERROR', headers, sys.exc_info())\n            return [tob(err)]\n\n    def __call__(self, environ, start_response):\n        \"\"\" Each instance of :class:'Bottle' is a WSGI application. \"\"\"\n        return self.wsgi(environ, start_response)\n\n    def __enter__(self):\n        \"\"\" Use this application as default for all module-level shortcuts. \"\"\"\n        default_app.push(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        default_app.pop()\n\n    def __setattr__(self, name, value):\n        if name in self.__dict__:\n            raise AttributeError(\"Attribute %s already defined. Plugin conflict?\" % name)\n        self.__dict__[name] = value\n\n\n###############################################################################\n# HTTP and WSGI Tools ##########################################################\n###############################################################################\n\n\nclass BaseRequest(object):\n    \"\"\" A wrapper for WSGI environment dictionaries that adds a lot of\n        convenient access methods and properties. Most of them are read-only.\n\n        Adding new attributes to a request actually adds them to the environ\n        dictionary (as 'bottle.request.ext.<name>'). This is the recommended\n        way to store and access request-specific data.\n    \"\"\"\n\n    __slots__ = ('environ', )\n\n    #: Maximum size of memory buffer for :attr:`body` in bytes.\n    MEMFILE_MAX = 102400\n\n    def __init__(self, environ=None):\n        \"\"\" Wrap a WSGI environ dictionary. \"\"\"\n        #: The wrapped WSGI environ dictionary. This is the only real attribute.\n        #: All other attributes actually are read-only properties.\n        self.environ = {} if environ is None else environ\n        self.environ['bottle.request'] = self\n\n    @DictProperty('environ', 'bottle.app', read_only=True)\n    def app(self):\n        \"\"\" Bottle application handling this request. \"\"\"\n        raise RuntimeError('This request is not connected to an application.')\n\n    @DictProperty('environ', 'bottle.route', read_only=True)\n    def route(self):\n        \"\"\" The bottle :class:`Route` object that matches this request. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @DictProperty('environ', 'route.url_args', read_only=True)\n    def url_args(self):\n        \"\"\" The arguments extracted from the URL. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @property\n    def path(self):\n        \"\"\" The value of ``PATH_INFO`` with exactly one prefixed slash (to fix\n            broken clients and avoid the \"empty path\" edge case). \"\"\"\n        return '/' + self.environ.get('PATH_INFO', '').lstrip('/')\n\n    @property\n    def method(self):\n        \"\"\" The ``REQUEST_METHOD`` value as an uppercase string. \"\"\"\n        return self.environ.get('REQUEST_METHOD', 'GET').upper()\n\n    @DictProperty('environ', 'bottle.request.headers', read_only=True)\n    def headers(self):\n        \"\"\" A :class:`WSGIHeaderDict` that provides case-insensitive access to\n            HTTP request headers. \"\"\"\n        return WSGIHeaderDict(self.environ)\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a request header, or a given default value. \"\"\"\n        return self.headers.get(name, default)\n\n    @DictProperty('environ', 'bottle.request.cookies', read_only=True)\n    def cookies(self):\n        \"\"\" Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT\n            decoded. Use :meth:`get_cookie` if you expect signed cookies. \"\"\"\n        cookies = SimpleCookie(self.environ.get('HTTP_COOKIE', '')).values()\n        return FormsDict((c.key, c.value) for c in cookies)\n\n    def get_cookie(self, key, default=None, secret=None):\n        \"\"\" Return the content of a cookie. To read a `Signed Cookie`, the\n            `secret` must match the one used to create the cookie (see\n            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing\n            cookie or wrong signature), return a default value. \"\"\"\n        value = self.cookies.get(key)\n        if secret and value:\n            dec = cookie_decode(value, secret)  # (key, value) tuple or None\n            return dec[1] if dec and dec[0] == key else default\n        return value or default\n\n    @DictProperty('environ', 'bottle.request.query', read_only=True)\n    def query(self):\n        \"\"\" The :attr:`query_string` parsed into a :class:`FormsDict`. These\n            values are sometimes called \"URL arguments\" or \"GET parameters\", but\n            not to be confused with \"URL wildcards\" as they are provided by the\n            :class:`Router`. \"\"\"\n        get = self.environ['bottle.get'] = FormsDict()\n        pairs = _parse_qsl(self.environ.get('QUERY_STRING', ''))\n        for key, value in pairs:\n            get[key] = value\n        return get\n\n    @DictProperty('environ', 'bottle.request.forms', read_only=True)\n    def forms(self):\n        \"\"\" Form values parsed from an `url-encoded` or `multipart/form-data`\n            encoded POST or PUT request body. The result is returned as a\n            :class:`FormsDict`. All keys and values are strings. File uploads\n            are stored separately in :attr:`files`. \"\"\"\n        forms = FormsDict()\n        for name, item in self.POST.allitems():\n            if not isinstance(item, FileUpload):\n                forms[name] = item\n        return forms\n\n    @DictProperty('environ', 'bottle.request.params', read_only=True)\n    def params(self):\n        \"\"\" A :class:`FormsDict` with the combined values of :attr:`query` and\n            :attr:`forms`. File uploads are stored in :attr:`files`. \"\"\"\n        params = FormsDict()\n        for key, value in self.query.allitems():\n            params[key] = value\n        for key, value in self.forms.allitems():\n            params[key] = value\n        return params\n\n    @DictProperty('environ', 'bottle.request.files', read_only=True)\n    def files(self):\n        \"\"\" File uploads parsed from `multipart/form-data` encoded POST or PUT\n            request body. The values are instances of :class:`FileUpload`.\n\n        \"\"\"\n        files = FormsDict()\n        for name, item in self.POST.allitems():\n            if isinstance(item, FileUpload):\n                files[name] = item\n        return files\n\n    @DictProperty('environ', 'bottle.request.json', read_only=True)\n    def json(self):\n        \"\"\" If the ``Content-Type`` header is ``application/json`` or\n            ``application/json-rpc``, this property holds the parsed content\n            of the request body. Only requests smaller than :attr:`MEMFILE_MAX`\n            are processed to avoid memory exhaustion.\n            Invalid JSON raises a 400 error response.\n        \"\"\"\n        ctype = self.environ.get('CONTENT_TYPE', '').lower().split(';')[0]\n        if ctype in ('application/json', 'application/json-rpc'):\n            b = self._get_body_string()\n            if not b:\n                return None\n            try:\n                return json_loads(b)\n            except (ValueError, TypeError):\n                raise HTTPError(400, 'Invalid JSON')\n        return None\n\n    def _iter_body(self, read, bufsize):\n        maxread = max(0, self.content_length)\n        while maxread:\n            part = read(min(maxread, bufsize))\n            if not part: break\n            yield part\n            maxread -= len(part)\n\n    @staticmethod\n    def _iter_chunked(read, bufsize):\n        err = HTTPError(400, 'Error while parsing chunked transfer body.')\n        rn, sem, bs = tob('\\r\\n'), tob(';'), tob('')\n        while True:\n            header = read(1)\n            while header[-2:] != rn:\n                c = read(1)\n                header += c\n                if not c: raise err\n                if len(header) > bufsize: raise err\n            size, _, _ = header.partition(sem)\n            try:\n                maxread = int(tonat(size.strip()), 16)\n            except ValueError:\n                raise err\n            if maxread == 0: break\n            buff = bs\n            while maxread > 0:\n                if not buff:\n                    buff = read(min(maxread, bufsize))\n                part, buff = buff[:maxread], buff[maxread:]\n                if not part: raise err\n                yield part\n                maxread -= len(part)\n            if read(2) != rn:\n                raise err\n\n    @DictProperty('environ', 'bottle.request.body', read_only=True)\n    def _body(self):\n        try:\n            read_func = self.environ['wsgi.input'].read\n        except KeyError:\n            self.environ['wsgi.input'] = BytesIO()\n            return self.environ['wsgi.input']\n        body_iter = self._iter_chunked if self.chunked else self._iter_body\n        body, body_size, is_temp_file = BytesIO(), 0, False\n        for part in body_iter(read_func, self.MEMFILE_MAX):\n            body.write(part)\n            body_size += len(part)\n            if not is_temp_file and body_size > self.MEMFILE_MAX:\n                body, tmp = TemporaryFile(mode='w+b'), body\n                body.write(tmp.getvalue())\n                del tmp\n                is_temp_file = True\n        self.environ['wsgi.input'] = body\n        body.seek(0)\n        return body\n\n    def _get_body_string(self):\n        \"\"\" read body until content-length or MEMFILE_MAX into a string. Raise\n            HTTPError(413) on requests that are to large. \"\"\"\n        clen = self.content_length\n        if clen > self.MEMFILE_MAX:\n            raise HTTPError(413, 'Request entity too large')\n        if clen < 0: clen = self.MEMFILE_MAX + 1\n        data = self.body.read(clen)\n        if len(data) > self.MEMFILE_MAX:  # Fail fast\n            raise HTTPError(413, 'Request entity too large')\n        return data\n\n    @property\n    def body(self):\n        \"\"\" The HTTP request body as a seek-able file-like object. Depending on\n            :attr:`MEMFILE_MAX`, this is either a temporary file or a\n            :class:`io.BytesIO` instance. Accessing this property for the first\n            time reads and replaces the ``wsgi.input`` environ variable.\n            Subsequent accesses just do a `seek(0)` on the file object. \"\"\"\n        self._body.seek(0)\n        return self._body\n\n    @property\n    def chunked(self):\n        \"\"\" True if Chunked transfer encoding was. \"\"\"\n        return 'chunked' in self.environ.get(\n            'HTTP_TRANSFER_ENCODING', '').lower()\n\n    #: An alias for :attr:`query`.\n    GET = query\n\n    @DictProperty('environ', 'bottle.request.post', read_only=True)\n    def POST(self):\n        \"\"\" The values of :attr:`forms` and :attr:`files` combined into a single\n            :class:`FormsDict`. Values are either strings (form values) or\n            instances of :class:`cgi.FieldStorage` (file uploads).\n        \"\"\"\n        post = FormsDict()\n        # We default to application/x-www-form-urlencoded for everything that\n        # is not multipart and take the fast path (also: 3.1 workaround)\n        if not self.content_type.startswith('multipart/'):\n            pairs = _parse_qsl(tonat(self._get_body_string(), 'latin1'))\n            for key, value in pairs:\n                post[key] = value\n            return post\n\n        safe_env = {'QUERY_STRING': ''}  # Build a safe environment for cgi\n        for key in ('REQUEST_METHOD', 'CONTENT_TYPE', 'CONTENT_LENGTH'):\n            if key in self.environ: safe_env[key] = self.environ[key]\n        args = dict(fp=self.body, environ=safe_env, keep_blank_values=True)\n\n        if py3k:\n            args['encoding'] = 'utf8'\n        data = cgi.FieldStorage(**args)\n        self['_cgi.FieldStorage'] = data  #http://bugs.python.org/issue18394\n        data = data.list or []\n        for item in data:\n            if item.filename:\n                post[item.name] = FileUpload(item.file, item.name,\n                                             item.filename, item.headers)\n            else:\n                post[item.name] = item.value\n        return post\n\n    @property\n    def url(self):\n        \"\"\" The full request URI including hostname and scheme. If your app\n            lives behind a reverse proxy or load balancer and you get confusing\n            results, make sure that the ``X-Forwarded-Host`` header is set\n            correctly. \"\"\"\n        return self.urlparts.geturl()\n\n    @DictProperty('environ', 'bottle.request.urlparts', read_only=True)\n    def urlparts(self):\n        \"\"\" The :attr:`url` string as an :class:`urlparse.SplitResult` tuple.\n            The tuple contains (scheme, host, path, query_string and fragment),\n            but the fragment is always empty because it is not visible to the\n            server. \"\"\"\n        env = self.environ\n        http = env.get('HTTP_X_FORWARDED_PROTO') \\\n             or env.get('wsgi.url_scheme', 'http')\n        host = env.get('HTTP_X_FORWARDED_HOST') or env.get('HTTP_HOST')\n        if not host:\n            # HTTP 1.1 requires a Host-header. This is for HTTP/1.0 clients.\n            host = env.get('SERVER_NAME', '127.0.0.1')\n            port = env.get('SERVER_PORT')\n            if port and port != ('80' if http == 'http' else '443'):\n                host += ':' + port\n        path = urlquote(self.fullpath)\n        return UrlSplitResult(http, host, path, env.get('QUERY_STRING'), '')\n\n    @property\n    def fullpath(self):\n        \"\"\" Request path including :attr:`script_name` (if present). \"\"\"\n        return urljoin(self.script_name, self.path.lstrip('/'))\n\n    @property\n    def query_string(self):\n        \"\"\" The raw :attr:`query` part of the URL (everything in between ``?``\n            and ``#``) as a string. \"\"\"\n        return self.environ.get('QUERY_STRING', '')\n\n    @property\n    def script_name(self):\n        \"\"\" The initial portion of the URL's `path` that was removed by a higher\n            level (server or routing middleware) before the application was\n            called. This script path is returned with leading and tailing\n            slashes. \"\"\"\n        script_name = self.environ.get('SCRIPT_NAME', '').strip('/')\n        return '/' + script_name + '/' if script_name else '/'\n\n    def path_shift(self, shift=1):\n        \"\"\" Shift path segments from :attr:`path` to :attr:`script_name` and\n            vice versa.\n\n           :param shift: The number of path segments to shift. May be negative\n                         to change the shift direction. (default: 1)\n        \"\"\"\n        script, path = path_shift(self.environ.get('SCRIPT_NAME', '/'), self.path, shift)\n        self['SCRIPT_NAME'], self['PATH_INFO'] = script, path\n\n    @property\n    def content_length(self):\n        \"\"\" The request body length as an integer. The client is responsible to\n            set this header. Otherwise, the real length of the body is unknown\n            and -1 is returned. In this case, :attr:`body` will be empty. \"\"\"\n        return int(self.environ.get('CONTENT_LENGTH') or -1)\n\n    @property\n    def content_type(self):\n        \"\"\" The Content-Type header as a lowercase-string (default: empty). \"\"\"\n        return self.environ.get('CONTENT_TYPE', '').lower()\n\n    @property\n    def is_xhr(self):\n        \"\"\" True if the request was triggered by a XMLHttpRequest. This only\n            works with JavaScript libraries that support the `X-Requested-With`\n            header (most of the popular libraries do). \"\"\"\n        requested_with = self.environ.get('HTTP_X_REQUESTED_WITH', '')\n        return requested_with.lower() == 'xmlhttprequest'\n\n    @property\n    def is_ajax(self):\n        \"\"\" Alias for :attr:`is_xhr`. \"Ajax\" is not the right term. \"\"\"\n        return self.is_xhr\n\n    @property\n    def auth(self):\n        \"\"\" HTTP authentication data as a (user, password) tuple. This\n            implementation currently supports basic (not digest) authentication\n            only. If the authentication happened at a higher level (e.g. in the\n            front web-server or a middleware), the password field is None, but\n            the user field is looked up from the ``REMOTE_USER`` environ\n            variable. On any errors, None is returned. \"\"\"\n        basic = parse_auth(self.environ.get('HTTP_AUTHORIZATION', ''))\n        if basic: return basic\n        ruser = self.environ.get('REMOTE_USER')\n        if ruser: return (ruser, None)\n        return None\n\n    @property\n    def remote_route(self):\n        \"\"\" A list of all IPs that were involved in this request, starting with\n            the client IP and followed by zero or more proxies. This does only\n            work if all proxies support the ```X-Forwarded-For`` header. Note\n            that this information can be forged by malicious clients. \"\"\"\n        proxy = self.environ.get('HTTP_X_FORWARDED_FOR')\n        if proxy: return [ip.strip() for ip in proxy.split(',')]\n        remote = self.environ.get('REMOTE_ADDR')\n        return [remote] if remote else []\n\n    @property\n    def remote_addr(self):\n        \"\"\" The client IP as a string. Note that this information can be forged\n            by malicious clients. \"\"\"\n        route = self.remote_route\n        return route[0] if route else None\n\n    def copy(self):\n        \"\"\" Return a new :class:`Request` with a shallow :attr:`environ` copy. \"\"\"\n        return Request(self.environ.copy())\n\n    def get(self, value, default=None):\n        return self.environ.get(value, default)\n\n    def __getitem__(self, key):\n        return self.environ[key]\n\n    def __delitem__(self, key):\n        self[key] = \"\"\n        del (self.environ[key])\n\n    def __iter__(self):\n        return iter(self.environ)\n\n    def __len__(self):\n        return len(self.environ)\n\n    def keys(self):\n        return self.environ.keys()\n\n    def __setitem__(self, key, value):\n        \"\"\" Change an environ value and clear all caches that depend on it. \"\"\"\n\n        if self.environ.get('bottle.request.readonly'):\n            raise KeyError('The environ dictionary is read-only.')\n\n        self.environ[key] = value\n        todelete = ()\n\n        if key == 'wsgi.input':\n            todelete = ('body', 'forms', 'files', 'params', 'post', 'json')\n        elif key == 'QUERY_STRING':\n            todelete = ('query', 'params')\n        elif key.startswith('HTTP_'):\n            todelete = ('headers', 'cookies')\n\n        for key in todelete:\n            self.environ.pop('bottle.request.' + key, None)\n\n    def __repr__(self):\n        return '<%s: %s %s>' % (self.__class__.__name__, self.method, self.url)\n\n    def __getattr__(self, name):\n        \"\"\" Search in self.environ for additional user defined attributes. \"\"\"\n        try:\n            var = self.environ['bottle.request.ext.%s' % name]\n            return var.__get__(self) if hasattr(var, '__get__') else var\n        except KeyError:\n            raise AttributeError('Attribute %r not defined.' % name)\n\n    def __setattr__(self, name, value):\n        if name == 'environ': return object.__setattr__(self, name, value)\n        key = 'bottle.request.ext.%s' % name\n        if key in self.environ:\n            raise AttributeError(\"Attribute already defined: %s\" % name)\n        self.environ[key] = value\n\n    def __delattr__(self, name, value):\n        try:\n            del self.environ['bottle.request.ext.%s' % name]\n        except KeyError:\n            raise AttributeError(\"Attribute not defined: %s\" % name)\n\n\ndef _hkey(key):\n    if '\\n' in key or '\\r' in key or '\\0' in key:\n        raise ValueError(\"Header names must not contain control characters: %r\" % key)\n    return key.title().replace('_', '-')\n\ndef _hval(value):\n    value = value if isinstance(value, unicode) else str(value)\n    if '\\n' in value or '\\r' in value or '\\0' in value:\n        raise ValueError(\"Header value must not contain control characters: %r\" % value)\n    return value\n\nclass HeaderProperty(object):\n    def __init__(self, name, reader=None, writer=str, default=''):\n        self.name, self.default = name, default\n        self.reader, self.writer = reader, writer\n        self.__doc__ = 'Current value of the %r header.' % name.title()\n\n    def __get__(self, obj, _):\n        if obj is None: return self\n        value = obj.headers.get(self.name, self.default)\n        return self.reader(value) if self.reader else value\n\n    def __set__(self, obj, value):\n        obj.headers[self.name] = self.writer(value)\n\n    def __delete__(self, obj):\n        del obj.headers[self.name]\n\n\nclass BaseResponse(object):\n    \"\"\" Storage class for a response body as well as headers and cookies.\n\n        This class does support dict-like case-insensitive item-access to\n        headers, but is NOT a dict. Most notably, iterating over a response\n        yields parts of the body and not the headers.\n\n        :param body: The response body as one of the supported types.\n        :param status: Either an HTTP status code (e.g. 200) or a status line\n                       including the reason phrase (e.g. '200 OK').\n        :param headers: A dictionary or a list of name-value pairs.\n\n        Additional keyword arguments are added to the list of headers.\n        Underscores in the header name are replaced with dashes.\n    \"\"\"\n\n    default_status = 200\n    default_content_type = 'text/html; charset=UTF-8'\n\n    # Header blacklist for specific response codes\n    # (rfc2616 section 10.2.3 and 10.3.5)\n    bad_headers = {\n        204: frozenset(('Content-Type', 'Content-Length')),\n        304: frozenset(('Allow', 'Content-Encoding', 'Content-Language',\n                  'Content-Length', 'Content-Range', 'Content-Type',\n                  'Content-Md5', 'Last-Modified'))\n    }\n\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        self._cookies = None\n        self._headers = {}\n        self.body = body\n        self.status = status or self.default_status\n        if headers:\n            if isinstance(headers, dict):\n                headers = headers.items()\n            for name, value in headers:\n                self.add_header(name, value)\n        if more_headers:\n            for name, value in more_headers.items():\n                self.add_header(name, value)\n\n    def copy(self, cls=None):\n        \"\"\" Returns a copy of self. \"\"\"\n        cls = cls or BaseResponse\n        assert issubclass(cls, BaseResponse)\n        copy = cls()\n        copy.status = self.status\n        copy._headers = dict((k, v[:]) for (k, v) in self._headers.items())\n        if self._cookies:\n            copy._cookies = SimpleCookie()\n            copy._cookies.load(self._cookies.output(header=''))\n        return copy\n\n    def __iter__(self):\n        return iter(self.body)\n\n    def close(self):\n        if hasattr(self.body, 'close'):\n            self.body.close()\n\n    @property\n    def status_line(self):\n        \"\"\" The HTTP status line as a string (e.g. ``404 Not Found``).\"\"\"\n        return self._status_line\n\n    @property\n    def status_code(self):\n        \"\"\" The HTTP status code as an integer (e.g. 404).\"\"\"\n        return self._status_code\n\n    def _set_status(self, status):\n        if isinstance(status, int):\n            code, status = status, _HTTP_STATUS_LINES.get(status)\n        elif ' ' in status:\n            status = status.strip()\n            code = int(status.split()[0])\n        else:\n            raise ValueError('String status line without a reason phrase.')\n        if not 100 <= code <= 999:\n            raise ValueError('Status code out of range.')\n        self._status_code = code\n        self._status_line = str(status or ('%d Unknown' % code))\n\n    def _get_status(self):\n        return self._status_line\n\n    status = property(\n        _get_status, _set_status, None,\n        ''' A writeable property to change the HTTP response status. It accepts\n            either a numeric code (100-999) or a string with a custom reason\n            phrase (e.g. \"404 Brain not found\"). Both :data:`status_line` and\n            :data:`status_code` are updated accordingly. The return value is\n            always a status string. ''')\n    del _get_status, _set_status\n\n    @property\n    def headers(self):\n        \"\"\" An instance of :class:`HeaderDict`, a case-insensitive dict-like\n            view on the response headers. \"\"\"\n        hdict = HeaderDict()\n        hdict.dict = self._headers\n        return hdict\n\n    def __contains__(self, name):\n        return _hkey(name) in self._headers\n\n    def __delitem__(self, name):\n        del self._headers[_hkey(name)]\n\n    def __getitem__(self, name):\n        return self._headers[_hkey(name)][-1]\n\n    def __setitem__(self, name, value):\n        self._headers[_hkey(name)] = [value if isinstance(value, unicode) else\n                                      str(value)]\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a previously defined header. If there is no\n            header with that name, return a default value. \"\"\"\n        return self._headers.get(_hkey(name), [default])[-1]\n\n    def set_header(self, name, value):\n        \"\"\" Create a new response header, replacing any previously defined\n            headers with the same name. \"\"\"\n        self._headers[_hkey(name)] = [value if isinstance(value, unicode)\n                                            else str(value)]\n\n    def add_header(self, name, value):\n        \"\"\" Add an additional response header, not removing duplicates. \"\"\"\n        self._headers.setdefault(_hkey(name), []).append(\n            value if isinstance(value, unicode) else str(value))\n\n    def iter_headers(self):\n        \"\"\" Yield (header, value) tuples, skipping headers that are not\n            allowed with the current response status code. \"\"\"\n        return self.headerlist\n\n    @property\n    def headerlist(self):\n        \"\"\" WSGI conform list of (header, value) tuples. \"\"\"\n        out = []\n        headers = list(self._headers.items())\n        if 'Content-Type' not in self._headers:\n            headers.append(('Content-Type', [self.default_content_type]))\n        if self._status_code in self.bad_headers:\n            bad_headers = self.bad_headers[self._status_code]\n            headers = [h for h in headers if h[0] not in bad_headers]\n        out += [(name, val) for (name, vals) in headers for val in vals]\n        if self._cookies:\n            for c in self._cookies.values():\n                out.append(('Set-Cookie', c.OutputString()))\n        if py3k:\n            return [(k, v.encode('utf8').decode('latin1')) for (k, v) in out]\n        else:\n            return [(k, v.encode('utf8') if isinstance(v, unicode) else v)\n                    for (k, v) in out]\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int)\n    expires = HeaderProperty(\n        'Expires',\n        reader=lambda x: datetime.utcfromtimestamp(parse_date(x)),\n        writer=lambda x: http_date(x))\n\n    @property\n    def charset(self, default='UTF-8'):\n        \"\"\" Return the charset specified in the content-type header (default: utf8). \"\"\"\n        if 'charset=' in self.content_type:\n            return self.content_type.split('charset=')[-1].split(';')[0].strip()\n        return default\n\n    def set_cookie(self, name, value, secret=None, **options):\n        \"\"\" Create a new cookie or replace an old one. If the `secret` parameter is\n            set, create a `Signed Cookie` (described below).\n\n            :param name: the name of the cookie.\n            :param value: the value of the cookie.\n            :param secret: a signature key required for signed cookies.\n\n            Additionally, this method accepts all RFC 2109 attributes that are\n            supported by :class:`cookie.Morsel`, including:\n\n            :param max_age: maximum age in seconds. (default: None)\n            :param expires: a datetime object or UNIX timestamp. (default: None)\n            :param domain: the domain that is allowed to read the cookie.\n              (default: current domain)\n            :param path: limits the cookie to a given path (default: current path)\n            :param secure: limit the cookie to HTTPS connections (default: off).\n            :param httponly: prevents client-side javascript to read this cookie\n              (default: off, requires Python 2.6 or newer).\n\n            If neither `expires` nor `max_age` is set (default), the cookie will\n            expire at the end of the browser session (as soon as the browser\n            window is closed).\n\n            Signed cookies may store any pickle-able object and are\n            cryptographically signed to prevent manipulation. Keep in mind that\n            cookies are limited to 4kb in most browsers.\n\n            Warning: Signed cookies are not encrypted (the client can still see\n            the content) and not copy-protected (the client can restore an old\n            cookie). The main intention is to make pickling and unpickling\n            save, not to store secret information at client side.\n        \"\"\"\n        if not self._cookies:\n            self._cookies = SimpleCookie()\n\n        if secret:\n            value = touni(cookie_encode((name, value), secret))\n        elif not isinstance(value, basestring):\n            raise TypeError('Secret key missing for non-string Cookie.')\n\n        # Cookie size plus options must not exceed 4kb.\n        if len(name) + len(value) > 3800:\n            raise ValueError('Content does not fit into a cookie.')\n\n        self._cookies[name] = value\n\n        for key, value in options.items():\n            if key == 'max_age':\n                if isinstance(value, timedelta):\n                    value = value.seconds + value.days * 24 * 3600\n            if key == 'expires':\n                if isinstance(value, (datedate, datetime)):\n                    value = value.timetuple()\n                elif isinstance(value, (int, float)):\n                    value = time.gmtime(value)\n                value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n            if key in ('secure', 'httponly') and not value:\n                continue\n            self._cookies[name][key.replace('_', '-')] = value\n\n    def delete_cookie(self, key, **kwargs):\n        \"\"\" Delete a cookie. Be sure to use the same `domain` and `path`\n            settings as used to create the cookie. \"\"\"\n        kwargs['max_age'] = -1\n        kwargs['expires'] = 0\n        self.set_cookie(key, '', **kwargs)\n\n    def __repr__(self):\n        out = ''\n        for name, value in self.headerlist:\n            out += '%s: %s\\n' % (name.title(), value.strip())\n        return out\n\n\ndef _local_property():\n    ls = threading.local()\n\n    def fget(_):\n        try:\n            return ls.var\n        except AttributeError:\n            raise RuntimeError(\"Request context not initialized.\")\n\n    def fset(_, value):\n        ls.var = value\n\n    def fdel(_):\n        del ls.var\n\n    return property(fget, fset, fdel, 'Thread-local property')\n\n\nclass LocalRequest(BaseRequest):\n    \"\"\" A thread-local subclass of :class:`BaseRequest` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`request`). If accessed during a\n        request/response cycle, this instance always refers to the *current*\n        request (even on a multithreaded server). \"\"\"\n    bind = BaseRequest.__init__\n    environ = _local_property()\n\n\nclass LocalResponse(BaseResponse):\n    \"\"\" A thread-local subclass of :class:`BaseResponse` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`response`). Its attributes are used\n        to build the HTTP response at the end of the request/response cycle.\n    \"\"\"\n    bind = BaseResponse.__init__\n    _status_line = _local_property()\n    _status_code = _local_property()\n    _cookies = _local_property()\n    _headers = _local_property()\n    body = _local_property()\n\n\nRequest = BaseRequest\nResponse = BaseResponse\n\n\nclass HTTPResponse(Response, BottleException):\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)\n\n    def apply(self, other):\n        other._status_code = self._status_code\n        other._status_line = self._status_line\n        other._headers = self._headers\n        other._cookies = self._cookies\n        other.body = self.body\n\n\nclass HTTPError(HTTPResponse):\n    default_status = 500\n\n    def __init__(self,\n                 status=None,\n                 body=None,\n                 exception=None,\n                 traceback=None, **more_headers):\n        self.exception = exception\n        self.traceback = traceback\n        super(HTTPError, self).__init__(body, status, **more_headers)\n\n###############################################################################\n# Plugins ######################################################################\n###############################################################################\n\n\nclass PluginError(BottleException):\n    pass\n\n\nclass JSONPlugin(object):\n    name = 'json'\n    api = 2\n\n    def __init__(self, json_dumps=json_dumps):\n        self.json_dumps = json_dumps\n\n    def setup(self, app):\n        app.config._define('json.enable', default=True, validate=bool,\n                          help=\"Enable or disable automatic dict->json filter.\")\n        app.config._define('json.ascii', default=False, validate=bool,\n                          help=\"Use only 7-bit ASCII characters in output.\")\n        app.config._define('json.indent', default=True, validate=bool,\n                          help=\"Add whitespace to make json more readable.\")\n        app.config._define('json.dump_func', default=None,\n                          help=\"If defined, use this function to transform\"\n                               \" dict into json. The other options no longer\"\n                               \" apply.\")\n\n    def apply(self, callback, route):\n        dumps = self.json_dumps\n        if not self.json_dumps: return callback\n\n        def wrapper(*a, **ka):\n            try:\n                rv = callback(*a, **ka)\n            except HTTPResponse as resp:\n                rv = resp\n\n            if isinstance(rv, dict):\n                #Attempt to serialize, raises exception on failure\n                json_response = dumps(rv)\n                #Set content type only if serialization successful\n                response.content_type = 'application/json'\n                return json_response\n            elif isinstance(rv, HTTPResponse) and isinstance(rv.body, dict):\n                rv.body = dumps(rv.body)\n                rv.content_type = 'application/json'\n            return rv\n\n        return wrapper\n\n\nclass TemplatePlugin(object):\n    \"\"\" This plugin applies the :func:`view` decorator to all routes with a\n        `template` config parameter. If the parameter is a tuple, the second\n        element must be a dict with additional options (e.g. `template_engine`)\n        or default variables for the template. \"\"\"\n    name = 'template'\n    api = 2\n\n    def setup(self, app):\n        app.tpl = self\n\n    def apply(self, callback, route):\n        conf = route.config.get('template')\n        if isinstance(conf, (tuple, list)) and len(conf) == 2:\n            return view(conf[0], **conf[1])(callback)\n        elif isinstance(conf, str):\n            return view(conf)(callback)\n        else:\n            return callback\n\n\n#: Not a plugin, but part of the plugin API. TODO: Find a better place.\nclass _ImportRedirect(object):\n    def __init__(self, name, impmask):\n        \"\"\" Create a virtual package that redirects imports (see PEP 302). \"\"\"\n        self.name = name\n        self.impmask = impmask\n        self.module = sys.modules.setdefault(name, imp.new_module(name))\n        self.module.__dict__.update({\n            '__file__': __file__,\n            '__path__': [],\n            '__all__': [],\n            '__loader__': self\n        })\n        sys.meta_path.append(self)\n\n    def find_module(self, fullname, path=None):\n        if '.' not in fullname: return\n        packname = fullname.rsplit('.', 1)[0]\n        if packname != self.name: return\n        return self\n\n    def load_module(self, fullname):\n        if fullname in sys.modules: return sys.modules[fullname]\n        modname = fullname.rsplit('.', 1)[1]\n        realname = self.impmask % modname\n        __import__(realname)\n        module = sys.modules[fullname] = sys.modules[realname]\n        setattr(self.module, modname, module)\n        module.__loader__ = self\n        return module\n\n###############################################################################\n# Common Utilities #############################################################\n###############################################################################\n\n\nclass MultiDict(DictMixin):\n    \"\"\" This dict stores multiple values per key, but behaves exactly like a\n        normal dict in that it returns only the newest value for any given key.\n        There are special methods available to access the full list of values.\n    \"\"\"\n\n    def __init__(self, *a, **k):\n        self.dict = dict((k, [v]) for (k, v) in dict(*a, **k).items())\n\n    def __len__(self):\n        return len(self.dict)\n\n    def __iter__(self):\n        return iter(self.dict)\n\n    def __contains__(self, key):\n        return key in self.dict\n\n    def __delitem__(self, key):\n        del self.dict[key]\n\n    def __getitem__(self, key):\n        return self.dict[key][-1]\n\n    def __setitem__(self, key, value):\n        self.append(key, value)\n\n    def keys(self):\n        return self.dict.keys()\n\n    if py3k:\n\n        def values(self):\n            return (v[-1] for v in self.dict.values())\n\n        def items(self):\n            return ((k, v[-1]) for k, v in self.dict.items())\n\n        def allitems(self):\n            return ((k, v) for k, vl in self.dict.items() for v in vl)\n\n        iterkeys = keys\n        itervalues = values\n        iteritems = items\n        iterallitems = allitems\n\n    else:\n\n        def values(self):\n            return [v[-1] for v in self.dict.values()]\n\n        def items(self):\n            return [(k, v[-1]) for k, v in self.dict.items()]\n\n        def iterkeys(self):\n            return self.dict.iterkeys()\n\n        def itervalues(self):\n            return (v[-1] for v in self.dict.itervalues())\n\n        def iteritems(self):\n            return ((k, v[-1]) for k, v in self.dict.iteritems())\n\n        def iterallitems(self):\n            return ((k, v) for k, vl in self.dict.iteritems() for v in vl)\n\n        def allitems(self):\n            return [(k, v) for k, vl in self.dict.iteritems() for v in vl]\n\n    def get(self, key, default=None, index=-1, type=None):\n        \"\"\" Return the most recent value for a key.\n\n            :param default: The default value to be returned if the key is not\n                   present or the type conversion fails.\n            :param index: An index for the list of available values.\n            :param type: If defined, this callable is used to cast the value\n                    into a specific type. Exception are suppressed and result in\n                    the default value to be returned.\n        \"\"\"\n        try:\n            val = self.dict[key][index]\n            return type(val) if type else val\n        except Exception:\n            pass\n        return default\n\n    def append(self, key, value):\n        \"\"\" Add a new value to the list of values for this key. \"\"\"\n        self.dict.setdefault(key, []).append(value)\n\n    def replace(self, key, value):\n        \"\"\" Replace the list of values with a single value. \"\"\"\n        self.dict[key] = [value]\n\n    def getall(self, key):\n        \"\"\" Return a (possibly empty) list of values for a key. \"\"\"\n        return self.dict.get(key) or []\n\n    #: Aliases for WTForms to mimic other multi-dict APIs (Django)\n    getone = get\n    getlist = getall\n\n\nclass FormsDict(MultiDict):\n    \"\"\" This :class:`MultiDict` subclass is used to store request form data.\n        Additionally to the normal dict-like item access methods (which return\n        unmodified data as native strings), this container also supports\n        attribute-like access to its values. Attributes are automatically de-\n        or recoded to match :attr:`input_encoding` (default: 'utf8'). Missing\n        attributes default to an empty string. \"\"\"\n\n    #: Encoding used for attribute values.\n    input_encoding = 'utf8'\n    #: If true (default), unicode strings are first encoded with `latin1`\n    #: and then decoded to match :attr:`input_encoding`.\n    recode_unicode = True\n\n    def _fix(self, s, encoding=None):\n        if isinstance(s, unicode) and self.recode_unicode:  # Python 3 WSGI\n            return s.encode('latin1').decode(encoding or self.input_encoding)\n        elif isinstance(s, bytes):  # Python 2 WSGI\n            return s.decode(encoding or self.input_encoding)\n        else:\n            return s\n\n    def decode(self, encoding=None):\n        \"\"\" Returns a copy with all keys and values de- or recoded to match\n            :attr:`input_encoding`. Some libraries (e.g. WTForms) want a\n            unicode dictionary. \"\"\"\n        copy = FormsDict()\n        enc = copy.input_encoding = encoding or self.input_encoding\n        copy.recode_unicode = False\n        for key, value in self.allitems():\n            copy.append(self._fix(key, enc), self._fix(value, enc))\n        return copy\n\n    def getunicode(self, name, default=None, encoding=None):\n        \"\"\" Return the value as a unicode string, or the default. \"\"\"\n        try:\n            return self._fix(self[name], encoding)\n        except (UnicodeError, KeyError):\n            return default\n\n    def __getattr__(self, name, default=unicode()):\n        # Without this guard, pickle generates a cryptic TypeError:\n        if name.startswith('__') and name.endswith('__'):\n            return super(FormsDict, self).__getattr__(name)\n        return self.getunicode(name, default=default)\n\nclass HeaderDict(MultiDict):\n    \"\"\" A case-insensitive version of :class:`MultiDict` that defaults to\n        replace the old value instead of appending it. \"\"\"\n\n    def __init__(self, *a, **ka):\n        self.dict = {}\n        if a or ka: self.update(*a, **ka)\n\n    def __contains__(self, key):\n        return _hkey(key) in self.dict\n\n    def __delitem__(self, key):\n        del self.dict[_hkey(key)]\n\n    def __getitem__(self, key):\n        return self.dict[_hkey(key)][-1]\n\n    def __setitem__(self, key, value):\n        self.dict[_hkey(key)] = [_hval(value)]\n\n    def append(self, key, value):\n        self.dict.setdefault(_hkey(key), []).append(_hval(value))\n\n    def replace(self, key, value):\n        self.dict[_hkey(key)] = [_hval(value)]\n\n    def getall(self, key):\n        return self.dict.get(_hkey(key)) or []\n\n    def get(self, key, default=None, index=-1):\n        return MultiDict.get(self, _hkey(key), default, index)\n\n    def filter(self, names):\n        for name in (_hkey(n) for n in names):\n            if name in self.dict:\n                del self.dict[name]\n\n\nclass WSGIHeaderDict(DictMixin):\n    \"\"\" This dict-like class wraps a WSGI environ dict and provides convenient\n        access to HTTP_* fields. Keys and values are native strings\n        (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI\n        environment contains non-native string values, these are de- or encoded\n        using a lossless 'latin1' character set.\n\n        The API will remain stable even on changes to the relevant PEPs.\n        Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one\n        that uses non-native strings.)\n    \"\"\"\n    #: List of keys that do not have a ``HTTP_`` prefix.\n    cgikeys = ('CONTENT_TYPE', 'CONTENT_LENGTH')\n\n    def __init__(self, environ):\n        self.environ = environ\n\n    def _ekey(self, key):\n        \"\"\" Translate header field name to CGI/WSGI environ key. \"\"\"\n        key = key.replace('-', '_').upper()\n        if key in self.cgikeys:\n            return key\n        return 'HTTP_' + key\n\n    def raw(self, key, default=None):\n        \"\"\" Return the header value as is (may be bytes or unicode). \"\"\"\n        return self.environ.get(self._ekey(key), default)\n\n    def __getitem__(self, key):\n        val = self.environ[self._ekey(key)]\n        if py3k:\n            if isinstance(val, unicode):\n                val = val.encode('latin1').decode('utf8')\n            else:\n                val = val.decode('utf8')\n        return val\n\n    def __setitem__(self, key, value):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __delitem__(self, key):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __iter__(self):\n        for key in self.environ:\n            if key[:5] == 'HTTP_':\n                yield _hkey(key[5:])\n            elif key in self.cgikeys:\n                yield _hkey(key)\n\n    def keys(self):\n        return [x for x in self]\n\n    def __len__(self):\n        return len(self.keys())\n\n    def __contains__(self, key):\n        return self._ekey(key) in self.environ\n\n_UNSET = object()\n\nclass ConfigDict(dict):\n    \"\"\" A dict-like configuration storage with additional support for\n        namespaces, validators, meta-data, overlays and more.\n\n        This dict-like class is heavily optimized for read access. All read-only\n        methods as well as item access should be as fast as the built-in dict.\n    \"\"\"\n\n    __slots__ = ('_meta', '_change_listener', '_overlays', '_virtual_keys', '_source', '__weakref__')\n\n    def __init__(self):\n        self._meta = {}\n        self._change_listener = []\n        #: Weak references of overlays that need to be kept in sync.\n        self._overlays = []\n        #: Config that is the source for this overlay.\n        self._source = None\n        #: Keys of values copied from the source (values we do not own)\n        self._virtual_keys = set()\n\n    def load_module(self, path, squash=True):\n        \"\"\"Load values from a Python module.\n\n           Example modue ``config.py``::\n\n                DEBUG = True\n                SQLITE = {\n                    \"db\": \":memory:\"\n                }\n\n\n           >>> c = ConfigDict()\n           >>> c.load_module('config')\n           {DEBUG: True, 'SQLITE.DB': 'memory'}\n           >>> c.load_module(\"config\", False)\n           {'DEBUG': True, 'SQLITE': {'DB': 'memory'}}\n\n           :param squash: If true (default), dictionary values are assumed to\n                          represent namespaces (see :meth:`load_dict`).\n        \"\"\"\n        config_obj = load(path)\n        obj = {key: getattr(config_obj, key) for key in dir(config_obj)\n               if key.isupper()}\n\n        if squash:\n            self.load_dict(obj)\n        else:\n            self.update(obj)\n        return self\n\n    def load_config(self, filename, **options):\n        \"\"\" Load values from an ``*.ini`` style config file.\n\n            A configuration file consists of sections, each led by a\n            ``[section]`` header, followed by key/value entries separated by\n            either ``=`` or ``:``. Section names and keys are case-insensitive.\n            Leading and trailing whitespace is removed from keys and values.\n            Values can be omitted, in which case the key/value delimiter may\n            also be left out. Values can also span multiple lines, as long as\n            they are indented deeper than the first line of the value. Commends\n            are prefixed by ``#`` or ``;`` and may only appear on their own on\n            an otherwise empty line.\n\n            Both section and key names may contain dots (``.``) as namespace\n            separators. The actual configuration parameter name is constructed\n            by joining section name and key name together and converting to\n            lower case.\n\n            The special sections ``bottle`` and ``ROOT`` refer to the root\n            namespace and the ``DEFAULT`` section defines default values for all\n            other sections.\n\n            With Python 3, extended string interpolation is enabled.\n\n            :param filename: The path of a config file, or a list of paths.\n            :param options: All keyword parameters are passed to the underlying\n                :class:`python:configparser.ConfigParser` constructor call.\n\n        \"\"\"\n        options.setdefault('allow_no_value', True)\n        if py3k:\n            options.setdefault('interpolation',\n                               configparser.ExtendedInterpolation())\n        conf = configparser.ConfigParser(**options)\n        conf.read(filename)\n        for section in conf.sections():\n            for key in conf.options(section):\n                value = conf.get(section, key)\n                if section not in ['bottle', 'ROOT']:\n                    key = section + '.' + key\n                self[key.lower()] = value\n        return self\n\n    def load_dict(self, source, namespace=''):\n        \"\"\" Load values from a dictionary structure. Nesting can be used to\n            represent namespaces.\n\n            >>> c = ConfigDict()\n            >>> c.load_dict({'some': {'namespace': {'key': 'value'} } })\n            {'some.namespace.key': 'value'}\n        \"\"\"\n        for key, value in source.items():\n            if isinstance(key, basestring):\n                nskey = (namespace + '.' + key).strip('.')\n                if isinstance(value, dict):\n                    self.load_dict(value, namespace=nskey)\n                else:\n                    self[nskey] = value\n            else:\n                raise TypeError('Key has type %r (not a string)' % type(key))\n        return self\n\n    def update(self, *a, **ka):\n        \"\"\" If the first parameter is a string, all keys are prefixed with this\n            namespace. Apart from that it works just as the usual dict.update().\n\n            >>> c = ConfigDict()\n            >>> c.update('some.namespace', key='value')\n        \"\"\"\n        prefix = ''\n        if a and isinstance(a[0], basestring):\n            prefix = a[0].strip('.') + '.'\n            a = a[1:]\n        for key, value in dict(*a, **ka).items():\n            self[prefix + key] = value\n\n    def setdefault(self, key, value):\n        if key not in self:\n            self[key] = value\n        return self[key]\n\n    def __setitem__(self, key, value):\n        if not isinstance(key, basestring):\n            raise TypeError('Key has type %r (not a string)' % type(key))\n\n        self._virtual_keys.discard(key)\n\n        value = self.meta_get(key, 'filter', lambda x: x)(value)\n        if key in self and self[key] is value:\n            return\n\n        self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n\n        for overlay in self._iter_overlays():\n            overlay._set_virtual(key, value)\n\n    def __delitem__(self, key):\n        if key not in self:\n            raise KeyError(key)\n        if key in self._virtual_keys:\n            raise KeyError(\"Virtual keys cannot be deleted: %s\" % key)\n\n        if self._source and key in self._source:\n            # Not virtual, but present in source -> Restore virtual value\n            dict.__delitem__(self, key)\n            self._set_virtual(key, self._source[key])\n        else:  # not virtual, not present in source. This is OUR value\n            self._on_change(key, None)\n            dict.__delitem__(self, key)\n            for overlay in self._iter_overlays():\n                overlay._delete_virtual(key)\n\n    def _set_virtual(self, key, value):\n        \"\"\" Recursively set or update virtual keys. Do nothing if non-virtual\n            value is present. \"\"\"\n        if key in self and key not in self._virtual_keys:\n            return  # Do nothing for non-virtual keys.\n\n        self._virtual_keys.add(key)\n        if key in self and self[key] is not value:\n            self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n        for overlay in self._iter_overlays():\n            overlay._set_virtual(key, value)\n\n    def _delete_virtual(self, key):\n        \"\"\" Recursively delete virtual entry. Do nothing if key is not virtual.\n        \"\"\"\n        if key not in self._virtual_keys:\n            return  # Do nothing for non-virtual keys.\n\n        if key in self:\n            self._on_change(key, None)\n        dict.__delitem__(self, key)\n        self._virtual_keys.discard(key)\n        for overlay in self._iter_overlays():\n            overlay._delete_virtual(key)\n\n    def _on_change(self, key, value):\n        for cb in self._change_listener:\n            if cb(self, key, value):\n                return True\n\n    def _add_change_listener(self, func):\n        self._change_listener.append(func)\n        return func\n\n    def meta_get(self, key, metafield, default=None):\n        \"\"\" Return the value of a meta field for a key. \"\"\"\n        return self._meta.get(key, {}).get(metafield, default)\n\n    def meta_set(self, key, metafield, value):\n        \"\"\" Set the meta field for a key to a new value. \"\"\"\n        self._meta.setdefault(key, {})[metafield] = value\n\n    def meta_list(self, key):\n        \"\"\" Return an iterable of meta field names defined for a key. \"\"\"\n        return self._meta.get(key, {}).keys()\n\n    def _define(self, key, default=_UNSET, help=_UNSET, validate=_UNSET):\n        \"\"\" (Unstable) Shortcut for plugins to define own config parameters. \"\"\"\n        if default is not _UNSET:\n            self.setdefault(key, default)\n        if help is not _UNSET:\n            self.meta_set(key, 'help', help)\n        if validate is not _UNSET:\n            self.meta_set(key, 'validate', validate)\n\n    def _iter_overlays(self):\n        for ref in self._overlays:\n            overlay = ref()\n            if overlay is not None:\n                yield overlay\n\n    def _make_overlay(self):\n        \"\"\" (Unstable) Create a new overlay that acts like a chained map: Values\n            missing in the overlay are copied from the source map. Both maps\n            share the same meta entries.\n\n            Entries that were copied from the source are called 'virtual'. You\n            can not delete virtual keys, but overwrite them, which turns them\n            into non-virtual entries. Setting keys on an overlay never affects\n            its source, but may affect any number of child overlays.\n\n            Other than collections.ChainMap or most other implementations, this\n            approach does not resolve missing keys on demand, but instead\n            actively copies all values from the source to the overlay and keeps\n            track of virtual and non-virtual keys internally. This removes any\n            lookup-overhead. Read-access is as fast as a build-in dict for both\n            virtual and non-virtual keys.\n\n            Changes are propagated recursively and depth-first. A failing\n            on-change handler in an overlay stops the propagation of virtual\n            values and may result in an partly updated tree. Take extra care\n            here and make sure that on-change handlers never fail.\n\n            Used by Route.config\n        \"\"\"\n        # Cleanup dead references\n        self._overlays[:] = [ref for ref in self._overlays if ref() is not None]\n\n        overlay = ConfigDict()\n        overlay._meta = self._meta\n        overlay._source = self\n        self._overlays.append(weakref.ref(overlay))\n        for key in self:\n            overlay._set_virtual(key, self[key])\n        return overlay\n\n\n\n\nclass AppStack(list):\n    \"\"\" A stack-like list. Calling it returns the head of the stack. \"\"\"\n\n    def __call__(self):\n        \"\"\" Return the current default application. \"\"\"\n        return self.default\n\n    def push(self, value=None):\n        \"\"\" Add a new :class:`Bottle` instance to the stack \"\"\"\n        if not isinstance(value, Bottle):\n            value = Bottle()\n        self.append(value)\n        return value\n    new_app = push\n\n    @property\n    def default(self):\n        try:\n            return self[-1]\n        except IndexError:\n            return self.push()\n\n\nclass WSGIFileWrapper(object):\n    def __init__(self, fp, buffer_size=1024 * 64):\n        self.fp, self.buffer_size = fp, buffer_size\n        for attr in ('fileno', 'close', 'read', 'readlines', 'tell', 'seek'):\n            if hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))\n\n    def __iter__(self):\n        buff, read = self.buffer_size, self.read\n        while True:\n            part = read(buff)\n            if not part: return\n            yield part\n\n\nclass _closeiter(object):\n    \"\"\" This only exists to be able to attach a .close method to iterators that\n        do not support attribute assignment (most of itertools). \"\"\"\n\n    def __init__(self, iterator, close=None):\n        self.iterator = iterator\n        self.close_callbacks = makelist(close)\n\n    def __iter__(self):\n        return iter(self.iterator)\n\n    def close(self):\n        for func in self.close_callbacks:\n            func()\n\n\nclass ResourceManager(object):\n    \"\"\" This class manages a list of search paths and helps to find and open\n        application-bound resources (files).\n\n        :param base: default value for :meth:`add_path` calls.\n        :param opener: callable used to open resources.\n        :param cachemode: controls which lookups are cached. One of 'all',\n                         'found' or 'none'.\n    \"\"\"\n\n    def __init__(self, base='./', opener=open, cachemode='all'):\n        self.opener = opener\n        self.base = base\n        self.cachemode = cachemode\n\n        #: A list of search paths. See :meth:`add_path` for details.\n        self.path = []\n        #: A cache for resolved paths. ``res.cache.clear()`` clears the cache.\n        self.cache = {}\n\n    def add_path(self, path, base=None, index=None, create=False):\n        \"\"\" Add a new path to the list of search paths. Return False if the\n            path does not exist.\n\n            :param path: The new search path. Relative paths are turned into\n                an absolute and normalized form. If the path looks like a file\n                (not ending in `/`), the filename is stripped off.\n            :param base: Path used to absolutize relative search paths.\n                Defaults to :attr:`base` which defaults to ``os.getcwd()``.\n            :param index: Position within the list of search paths. Defaults\n                to last index (appends to the list).\n\n            The `base` parameter makes it easy to reference files installed\n            along with a python module or package::\n\n                res.add_path('./resources/', __file__)\n        \"\"\"\n        base = os.path.abspath(os.path.dirname(base or self.base))\n        path = os.path.abspath(os.path.join(base, os.path.dirname(path)))\n        path += os.sep\n        if path in self.path:\n            self.path.remove(path)\n        if create and not os.path.isdir(path):\n            os.makedirs(path)\n        if index is None:\n            self.path.append(path)\n        else:\n            self.path.insert(index, path)\n        self.cache.clear()\n        return os.path.exists(path)\n\n    def __iter__(self):\n        \"\"\" Iterate over all existing files in all registered paths. \"\"\"\n        search = self.path[:]\n        while search:\n            path = search.pop()\n            if not os.path.isdir(path): continue\n            for name in os.listdir(path):\n                full = os.path.join(path, name)\n                if os.path.isdir(full): search.append(full)\n                else: yield full\n\n    def lookup(self, name):\n        \"\"\" Search for a resource and return an absolute file path, or `None`.\n\n            The :attr:`path` list is searched in order. The first match is\n            returend. Symlinks are followed. The result is cached to speed up\n            future lookups. \"\"\"\n        if name not in self.cache or DEBUG:\n            for path in self.path:\n                fpath = os.path.join(path, name)\n                if os.path.isfile(fpath):\n                    if self.cachemode in ('all', 'found'):\n                        self.cache[name] = fpath\n                    return fpath\n            if self.cachemode == 'all':\n                self.cache[name] = None\n        return self.cache[name]\n\n    def open(self, name, mode='r', *args, **kwargs):\n        \"\"\" Find a resource and return a file object, or raise IOError. \"\"\"\n        fname = self.lookup(name)\n        if not fname: raise IOError(\"Resource %r not found.\" % name)\n        return self.opener(fname, mode=mode, *args, **kwargs)\n\n\nclass FileUpload(object):\n    def __init__(self, fileobj, name, filename, headers=None):\n        \"\"\" Wrapper for file uploads. \"\"\"\n        #: Open file(-like) object (BytesIO buffer or temporary file)\n        self.file = fileobj\n        #: Name of the upload form field\n        self.name = name\n        #: Raw filename as sent by the client (may contain unsafe characters)\n        self.raw_filename = filename\n        #: A :class:`HeaderDict` with additional headers (e.g. content-type)\n        self.headers = HeaderDict(headers) if headers else HeaderDict()\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int, default=-1)\n\n    @cached_property\n    def filename(self):\n        \"\"\" Name of the file on the client file system, but normalized to ensure\n            file system compatibility. An empty filename is returned as 'empty'.\n\n            Only ASCII letters, digits, dashes, underscores and dots are\n            allowed in the final filename. Accents are removed, if possible.\n            Whitespace is replaced by a single dash. Leading or tailing dots\n            or dashes are removed. The filename is limited to 255 characters.\n        \"\"\"\n        fname = self.raw_filename\n        if not isinstance(fname, unicode):\n            fname = fname.decode('utf8', 'ignore')\n        fname = normalize('NFKD', fname)\n        fname = fname.encode('ASCII', 'ignore').decode('ASCII')\n        fname = os.path.basename(fname.replace('\\\\', os.path.sep))\n        fname = re.sub(r'[^a-zA-Z0-9-_.\\s]', '', fname).strip()\n        fname = re.sub(r'[-\\s]+', '-', fname).strip('.-')\n        return fname[:255] or 'empty'\n\n    def _copy_file(self, fp, chunk_size=2 ** 16):\n        read, write, offset = self.file.read, fp.write, self.file.tell()\n        while 1:\n            buf = read(chunk_size)\n            if not buf: break\n            write(buf)\n        self.file.seek(offset)\n\n    def save(self, destination, overwrite=False, chunk_size=2 ** 16):\n        \"\"\" Save file to disk or copy its content to an open file(-like) object.\n            If *destination* is a directory, :attr:`filename` is added to the\n            path. Existing files are not overwritten by default (IOError).\n\n            :param destination: File path, directory or file(-like) object.\n            :param overwrite: If True, replace existing files. (default: False)\n            :param chunk_size: Bytes to read at a time. (default: 64kb)\n        \"\"\"\n        if isinstance(destination, basestring):  # Except file-likes here\n            if os.path.isdir(destination):\n                destination = os.path.join(destination, self.filename)\n            if not overwrite and os.path.exists(destination):\n                raise IOError('File exists.')\n            with open(destination, 'wb') as fp:\n                self._copy_file(fp, chunk_size)\n        else:\n            self._copy_file(destination, chunk_size)\n\n###############################################################################\n# Application Helper ###########################################################\n###############################################################################\n\n\ndef abort(code=500, text='Unknown Error.'):\n    \"\"\" Aborts execution and causes a HTTP error. \"\"\"\n    raise HTTPError(code, text)\n\n\ndef redirect(url, code=None):\n    \"\"\" Aborts execution and causes a 303 or 302 redirect, depending on\n        the HTTP protocol version. \"\"\"\n    if not code:\n        code = 303 if request.get('SERVER_PROTOCOL') == \"HTTP/1.1\" else 302\n    res = response.copy(cls=HTTPResponse)\n    res.status = code\n    res.body = \"\"\n    res.set_header('Location', urljoin(request.url, url))\n    raise res\n\n\ndef _file_iter_range(fp, offset, bytes, maxread=1024 * 1024):\n    \"\"\" Yield chunks from a range in a file. No chunk is bigger than maxread.\"\"\"\n    fp.seek(offset)\n    while bytes > 0:\n        part = fp.read(min(bytes, maxread))\n        if not part: break\n        bytes -= len(part)\n        yield part\n\n\ndef static_file(filename, root,\n                mimetype=True,\n                download=False,\n                charset='UTF-8',\n                etag=None):\n    \"\"\" Open a file in a safe way and return an instance of :exc:`HTTPResponse`\n        that can be sent back to the client.\n\n        :param filename: Name or path of the file to send, relative to ``root``.\n        :param root: Root path for file lookups. Should be an absolute directory\n            path.\n        :param mimetype: Provide the content-type header (default: guess from\n            file extension)\n        :param download: If True, ask the browser to open a `Save as...` dialog\n            instead of opening the file with the associated program. You can\n            specify a custom filename as a string. If not specified, the\n            original filename is used (default: False).\n        :param charset: The charset for files with a ``text/*`` mime-type.\n            (default: UTF-8)\n        :param etag: Provide a pre-computed ETag header. If set to ``False``,\n            ETag handling is disabled. (default: auto-generate ETag header)\n\n        While checking user input is always a good idea, this function provides\n        additional protection against malicious ``filename`` parameters from\n        breaking out of the ``root`` directory and leaking sensitive information\n        to an attacker.\n\n        Read-protected files or files outside of the ``root`` directory are\n        answered with ``403 Access Denied``. Missing files result in a\n        ``404 Not Found`` response. Conditional requests (``If-Modified-Since``,\n        ``If-None-Match``) are answered with ``304 Not Modified`` whenever\n        possible. ``HEAD`` and ``Range`` requests (used by download managers to\n        check or continue partial downloads) are also handled automatically.\n\n    \"\"\"\n\n    root = os.path.join(os.path.abspath(root), '')\n    filename = os.path.abspath(os.path.join(root, filename.strip('/\\\\')))\n    headers = dict()\n\n    if not filename.startswith(root):\n        return HTTPError(403, \"Access denied.\")\n    if not os.path.exists(filename) or not os.path.isfile(filename):\n        return HTTPError(404, \"File does not exist.\")\n    if not os.access(filename, os.R_OK):\n        return HTTPError(403, \"You do not have permission to access this file.\")\n\n    if mimetype is True:\n        if download and download is not True:\n            mimetype, encoding = mimetypes.guess_type(download)\n        else:\n            mimetype, encoding = mimetypes.guess_type(filename)\n        if encoding: headers['Content-Encoding'] = encoding\n\n    if mimetype:\n        if (mimetype[:5] == 'text/' or mimetype == 'application/javascript')\\\n        and charset and 'charset' not in mimetype:\n            mimetype += '; charset=%s' % charset\n        headers['Content-Type'] = mimetype\n\n    if download:\n        download = os.path.basename(filename if download is True else download)\n        headers['Content-Disposition'] = 'attachment; filename=\"%s\"' % download\n\n    stats = os.stat(filename)\n    headers['Content-Length'] = clen = stats.st_size\n    lm = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", time.gmtime(stats.st_mtime))\n    headers['Last-Modified'] = lm\n    headers['Date'] = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", time.gmtime())\n\n    getenv = request.environ.get\n\n    if etag is None:\n        etag = '%d:%d:%d:%d:%s' % (stats.st_dev, stats.st_ino, stats.st_mtime,\n                                   clen, filename)\n        etag = hashlib.sha1(tob(etag)).hexdigest()\n\n    if etag:\n        headers['ETag'] = etag\n        check = getenv('HTTP_IF_NONE_MATCH')\n        if check and check == etag:\n            return HTTPResponse(status=304, **headers)\n\n    ims = getenv('HTTP_IF_MODIFIED_SINCE')\n    if ims:\n        ims = parse_date(ims.split(\";\")[0].strip())\n    if ims is not None and ims >= int(stats.st_mtime):\n        return HTTPResponse(status=304, **headers)\n\n    body = '' if request.method == 'HEAD' else open(filename, 'rb')\n\n    headers[\"Accept-Ranges\"] = \"bytes\"\n    range_header = getenv('HTTP_RANGE')\n    if range_header:\n        ranges = list(parse_range_header(range_header, clen))\n        if not ranges:\n            return HTTPError(416, \"Requested Range Not Satisfiable\")\n        offset, end = ranges[0]\n        headers[\"Content-Range\"] = \"bytes %d-%d/%d\" % (offset, end - 1, clen)\n        headers[\"Content-Length\"] = str(end - offset)\n        if body: body = _file_iter_range(body, offset, end - offset)\n        return HTTPResponse(body, status=206, **headers)\n    return HTTPResponse(body, **headers)\n\n###############################################################################\n# HTTP Utilities and MISC (TODO) ###############################################\n###############################################################################\n\n\ndef debug(mode=True):\n    \"\"\" Change the debug level.\n    There is only one debug level supported at the moment.\"\"\"\n    global DEBUG\n    if mode: warnings.simplefilter('default')\n    DEBUG = bool(mode)\n\n\ndef http_date(value):\n    if isinstance(value, (datedate, datetime)):\n        value = value.utctimetuple()\n    elif isinstance(value, (int, float)):\n        value = time.gmtime(value)\n    if not isinstance(value, basestring):\n        value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n    return value\n\n\ndef parse_date(ims):\n    \"\"\" Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. \"\"\"\n    try:\n        ts = email.utils.parsedate_tz(ims)\n        return time.mktime(ts[:8] + (0, )) - (ts[9] or 0) - time.timezone\n    except (TypeError, ValueError, IndexError, OverflowError):\n        return None\n\n\ndef parse_auth(header):\n    \"\"\" Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None\"\"\"\n    try:\n        method, data = header.split(None, 1)\n        if method.lower() == 'basic':\n            user, pwd = touni(base64.b64decode(tob(data))).split(':', 1)\n            return user, pwd\n    except (KeyError, ValueError):\n        return None\n\n\ndef parse_range_header(header, maxlen=0):\n    \"\"\" Yield (start, end) ranges parsed from a HTTP Range header. Skip\n        unsatisfiable ranges. The end index is non-inclusive.\"\"\"\n    if not header or header[:6] != 'bytes=': return\n    ranges = [r.split('-', 1) for r in header[6:].split(',') if '-' in r]\n    for start, end in ranges:\n        try:\n            if not start:  # bytes=-100    -> last 100 bytes\n                start, end = max(0, maxlen - int(end)), maxlen\n            elif not end:  # bytes=100-    -> all but the first 99 bytes\n                start, end = int(start), maxlen\n            else:  # bytes=100-200 -> bytes 100-200 (inclusive)\n                start, end = int(start), min(int(end) + 1, maxlen)\n            if 0 <= start < end <= maxlen:\n                yield start, end\n        except ValueError:\n            pass\n\n\n#: Header tokenizer used by _parse_http_header()\n_hsplit = re.compile('(?:(?:\"((?:[^\"\\\\\\\\]+|\\\\\\\\.)*)\")|([^;,=]+))([;,=]?)').findall\n\ndef _parse_http_header(h):\n    \"\"\" Parses a typical multi-valued and parametrised HTTP header (e.g. Accept headers) and returns a list of values\n        and parameters. For non-standard or broken input, this implementation may return partial results.\n    :param h: A header string (e.g. ``text/html,text/plain;q=0.9,*/*;q=0.8``)\n    :return: List of (value, params) tuples. The second element is a (possibly empty) dict.\n    \"\"\"\n    values = []\n    if '\"' not in h:  # INFO: Fast path without regexp (~2x faster)\n        for value in h.split(','):\n            parts = value.split(';')\n            values.append((parts[0].strip(), {}))\n            for attr in parts[1:]:\n                name, value = attr.split('=', 1)\n                values[-1][1][name.strip()] = value.strip()\n    else:\n        lop, key, attrs = ',', None, {}\n        for quoted, plain, tok in _hsplit(h):\n            value = plain.strip() if plain else quoted.replace('\\\\\"', '\"')\n            if lop == ',':\n                attrs = {}\n                values.append((value, attrs))\n            elif lop == ';':\n                if tok == '=':\n                    key = value\n                else:\n                    attrs[value] = ''\n            elif lop == '=' and key:\n                attrs[key] = value\n                key = None\n            lop = tok\n    return values\n\n\ndef _parse_qsl(qs):\n    r = []\n    for pair in qs.replace(';', '&').split('&'):\n        if not pair: continue\n        nv = pair.split('=', 1)\n        if len(nv) != 2: nv.append('')\n        key = urlunquote(nv[0].replace('+', ' '))\n        value = urlunquote(nv[1].replace('+', ' '))\n        r.append((key, value))\n    return r\n\n\ndef _lscmp(a, b):\n    \"\"\" Compares two strings in a cryptographically safe way:\n        Runtime is not affected by length of common prefix. \"\"\"\n    return not sum(0 if x == y else 1\n                   for x, y in zip(a, b)) and len(a) == len(b)\n\n\ndef cookie_encode(data, key, digestmod=None):\n    \"\"\" Encode and sign a pickle-able object. Return a (byte) string \"\"\"\n    digestmod = digestmod or hashlib.sha256\n    msg = base64.b64encode(pickle.dumps(data, -1))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=digestmod).digest())\n    return tob('!') + sig + tob('?') + msg\n\n\ndef cookie_decode(data, key, digestmod=None):\n    \"\"\" Verify and decode an encoded string. Return an object or None.\"\"\"\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(tob('?'), 1)\n        digestmod = digestmod or hashlib.sha256\n        hashed = hmac.new(tob(key), msg, digestmod=digestmod).digest()\n        if _lscmp(sig[1:], base64.b64encode(hashed)):\n            return pickle.loads(base64.b64decode(msg))\n    return None\n\n\ndef cookie_is_encoded(data):\n    \"\"\" Return True if the argument looks like a encoded cookie.\"\"\"\n    return bool(data.startswith(tob('!')) and tob('?') in data)\n\n\ndef html_escape(string):\n    \"\"\" Escape HTML special characters ``&<>`` and quotes ``'\"``. \"\"\"\n    return string.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\\\n                 .replace('\"', '&quot;').replace(\"'\", '&#039;')\n\n\ndef html_quote(string):\n    \"\"\" Escape and quote a string to be used as an HTTP attribute.\"\"\"\n    return '\"%s\"' % html_escape(string).replace('\\n', '&#10;')\\\n                    .replace('\\r', '&#13;').replace('\\t', '&#9;')\n\n\ndef yieldroutes(func):\n    \"\"\" Return a generator for routes that match the signature (name, args)\n    of the func parameter. This may yield more than one route if the function\n    takes optional keyword arguments. The output is best described by example::\n\n        a()         -> '/a'\n        b(x, y)     -> '/b/<x>/<y>'\n        c(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'\n        d(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'\n    \"\"\"\n    path = '/' + func.__name__.replace('__', '/').lstrip('/')\n    spec = getargspec(func)\n    argc = len(spec[0]) - len(spec[3] or [])\n    path += ('/<%s>' * argc) % tuple(spec[0][:argc])\n    yield path\n    for arg in spec[0][argc:]:\n        path += '/<%s>' % arg\n        yield path\n\n\ndef path_shift(script_name, path_info, shift=1):\n    \"\"\" Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.\n\n        :return: The modified paths.\n        :param script_name: The SCRIPT_NAME path.\n        :param script_name: The PATH_INFO path.\n        :param shift: The number of path fragments to shift. May be negative to\n          change the shift direction. (default: 1)\n    \"\"\"\n    if shift == 0: return script_name, path_info\n    pathlist = path_info.strip('/').split('/')\n    scriptlist = script_name.strip('/').split('/')\n    if pathlist and pathlist[0] == '': pathlist = []\n    if scriptlist and scriptlist[0] == '': scriptlist = []\n    if 0 < shift <= len(pathlist):\n        moved = pathlist[:shift]\n        scriptlist = scriptlist + moved\n        pathlist = pathlist[shift:]\n    elif 0 > shift >= -len(scriptlist):\n        moved = scriptlist[shift:]\n        pathlist = moved + pathlist\n        scriptlist = scriptlist[:shift]\n    else:\n        empty = 'SCRIPT_NAME' if shift < 0 else 'PATH_INFO'\n        raise AssertionError(\"Cannot shift. Nothing left from %s\" % empty)\n    new_script_name = '/' + '/'.join(scriptlist)\n    new_path_info = '/' + '/'.join(pathlist)\n    if path_info.endswith('/') and pathlist: new_path_info += '/'\n    return new_script_name, new_path_info\n\n\ndef auth_basic(check, realm=\"private\", text=\"Access denied\"):\n    \"\"\" Callback decorator to require HTTP auth (basic).\n        TODO: Add route(check_auth=...) parameter. \"\"\"\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*a, **ka):\n            user, password = request.auth or (None, None)\n            if user is None or not check(user, password):\n                err = HTTPError(401, text)\n                err.add_header('WWW-Authenticate', 'Basic realm=\"%s\"' % realm)\n                return err\n            return func(*a, **ka)\n\n        return wrapper\n\n    return decorator\n\n# Shortcuts for common Bottle methods.\n# They all refer to the current default application.\n\n\ndef make_default_app_wrapper(name):\n    \"\"\" Return a callable that relays calls to the current default app. \"\"\"\n\n    @functools.wraps(getattr(Bottle, name))\n    def wrapper(*a, **ka):\n        return getattr(app(), name)(*a, **ka)\n\n    return wrapper\n\n\nroute     = make_default_app_wrapper('route')\nget       = make_default_app_wrapper('get')\npost      = make_default_app_wrapper('post')\nput       = make_default_app_wrapper('put')\ndelete    = make_default_app_wrapper('delete')\npatch     = make_default_app_wrapper('patch')\nerror     = make_default_app_wrapper('error')\nmount     = make_default_app_wrapper('mount')\nhook      = make_default_app_wrapper('hook')\ninstall   = make_default_app_wrapper('install')\nuninstall = make_default_app_wrapper('uninstall')\nurl       = make_default_app_wrapper('get_url')\n\n###############################################################################\n# Server Adapter ###############################################################\n###############################################################################\n\n# Before you edit or add a server adapter, please read:\n# - https://github.com/bottlepy/bottle/pull/647#issuecomment-60152870\n# - https://github.com/bottlepy/bottle/pull/865#issuecomment-242795341\n\nclass ServerAdapter(object):\n    quiet = False\n\n    def __init__(self, host='127.0.0.1', port=8080, **options):\n        self.options = options\n        self.host = host\n        self.port = int(port)\n\n    def run(self, handler):  # pragma: no cover\n        pass\n\n    def __repr__(self):\n        args = ', '.join(['%s=%s' % (k, repr(v))\n                          for k, v in self.options.items()])\n        return \"%s(%s)\" % (self.__class__.__name__, args)\n\n\nclass CGIServer(ServerAdapter):\n    quiet = True\n\n    def run(self, handler):  # pragma: no cover\n        from wsgiref.handlers import CGIHandler\n\n        def fixed_environ(environ, start_response):\n            environ.setdefault('PATH_INFO', '')\n            return handler(environ, start_response)\n\n        CGIHandler().run(fixed_environ)\n\n\nclass FlupFCGIServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        import flup.server.fcgi\n        self.options.setdefault('bindAddress', (self.host, self.port))\n        flup.server.fcgi.WSGIServer(handler, **self.options).run()\n\n\nclass WSGIRefServer(ServerAdapter):\n    def run(self, app):  # pragma: no cover\n        from wsgiref.simple_server import make_server\n        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer\n        import socket\n\n        class FixedHandler(WSGIRequestHandler):\n            def address_string(self):  # Prevent reverse DNS lookups please.\n                return self.client_address[0]\n\n            def log_request(*args, **kw):\n                if not self.quiet:\n                    return WSGIRequestHandler.log_request(*args, **kw)\n\n        handler_cls = self.options.get('handler_class', FixedHandler)\n        server_cls = self.options.get('server_class', WSGIServer)\n\n        if ':' in self.host:  # Fix wsgiref for IPv6 addresses.\n            if getattr(server_cls, 'address_family') == socket.AF_INET:\n\n                class server_cls(server_cls):\n                    address_family = socket.AF_INET6\n\n        self.srv = make_server(self.host, self.port, app, server_cls,\n                               handler_cls)\n        self.port = self.srv.server_port  # update port actual port (0 means random)\n        try:\n            self.srv.serve_forever()\n        except KeyboardInterrupt:\n            self.srv.server_close()  # Prevent ResourceWarning: unclosed socket\n            raise\n\n\nclass CherryPyServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        from cherrypy import wsgiserver\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n\n        certfile = self.options.get('certfile')\n        if certfile:\n            del self.options['certfile']\n        keyfile = self.options.get('keyfile')\n        if keyfile:\n            del self.options['keyfile']\n\n        server = wsgiserver.CherryPyWSGIServer(**self.options)\n        if certfile:\n            server.ssl_certificate = certfile\n        if keyfile:\n            server.ssl_private_key = keyfile\n\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass WaitressServer(ServerAdapter):\n    def run(self, handler):\n        from waitress import serve\n        serve(handler, host=self.host, port=self.port, _quiet=self.quiet, **self.options)\n\n\nclass PasteServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        from paste import httpserver\n        from paste.translogger import TransLogger\n        handler = TransLogger(handler, setup_console_handler=(not self.quiet))\n        httpserver.serve(handler,\n                         host=self.host,\n                         port=str(self.port), **self.options)\n\n\nclass MeinheldServer(ServerAdapter):\n    def run(self, handler):\n        from meinheld import server\n        server.listen((self.host, self.port))\n        server.run(handler)\n\n\nclass FapwsServer(ServerAdapter):\n    \"\"\" Extremely fast webserver using libev. See http://www.fapws.org/ \"\"\"\n\n    def run(self, handler):  # pragma: no cover\n        import fapws._evwsgi as evwsgi\n        from fapws import base, config\n        port = self.port\n        if float(config.SERVER_IDENT[-2:]) > 0.4:\n            # fapws3 silently changed its API in 0.5\n            port = str(port)\n        evwsgi.start(self.host, port)\n        # fapws3 never releases the GIL. Complain upstream. I tried. No luck.\n        if 'BOTTLE_CHILD' in os.environ and not self.quiet:\n            _stderr(\"WARNING: Auto-reloading does not work with Fapws3.\\n\")\n            _stderr(\"         (Fapws3 breaks python thread support)\\n\")\n        evwsgi.set_base_module(base)\n\n        def app(environ, start_response):\n            environ['wsgi.multiprocess'] = False\n            return handler(environ, start_response)\n\n        evwsgi.wsgi_cb(('', app))\n        evwsgi.run()\n\n\nclass TornadoServer(ServerAdapter):\n    \"\"\" The super hyped asynchronous server by facebook. Untested. \"\"\"\n\n    def run(self, handler):  # pragma: no cover\n        import tornado.wsgi, tornado.httpserver, tornado.ioloop\n        container = tornado.wsgi.WSGIContainer(handler)\n        server = tornado.httpserver.HTTPServer(container)\n        server.listen(port=self.port, address=self.host)\n        tornado.ioloop.IOLoop.instance().start()\n\n\nclass AppEngineServer(ServerAdapter):\n    \"\"\" Adapter for Google App Engine. \"\"\"\n    quiet = True\n\n    def run(self, handler):\n        depr(0, 13, \"AppEngineServer no longer required\",\n             \"Configure your application directly in your app.yaml\")\n        from google.appengine.ext.webapp import util\n        # A main() function in the handler script enables 'App Caching'.\n        # Lets makes sure it is there. This _really_ improves performance.\n        module = sys.modules.get('__main__')\n        if module and not hasattr(module, 'main'):\n            module.main = lambda: util.run_wsgi_app(handler)\n        util.run_wsgi_app(handler)\n\n\nclass TwistedServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        from twisted.web import server, wsgi\n        from twisted.python.threadpool import ThreadPool\n        from twisted.internet import reactor\n        thread_pool = ThreadPool()\n        thread_pool.start()\n        reactor.addSystemEventTrigger('after', 'shutdown', thread_pool.stop)\n        factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))\n        reactor.listenTCP(self.port, factory, interface=self.host)\n        if not reactor.running:\n            reactor.run()\n\n\nclass DieselServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        from diesel.protocols.wsgi import WSGIApplication\n        app = WSGIApplication(handler, port=self.port)\n        app.run()\n\n\nclass GeventServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * See gevent.wsgi.WSGIServer() documentation for more options.\n    \"\"\"\n\n    def run(self, handler):\n        from gevent import pywsgi, local\n        if not isinstance(threading.local(), local.local):\n            msg = \"Bottle requires gevent.monkey.patch_all() (before import)\"\n            raise RuntimeError(msg)\n        if self.quiet:\n            self.options['log'] = None\n        address = (self.host, self.port)\n        server = pywsgi.WSGIServer(address, handler, **self.options)\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: server.stop())\n        server.serve_forever()\n\n\nclass GunicornServer(ServerAdapter):\n    \"\"\" Untested. See http://gunicorn.org/configure.html for options. \"\"\"\n\n    def run(self, handler):\n        from gunicorn.app.base import Application\n\n        config = {'bind': \"%s:%d\" % (self.host, int(self.port))}\n        config.update(self.options)\n\n        class GunicornApplication(Application):\n            def init(self, parser, opts, args):\n                return config\n\n            def load(self):\n                return handler\n\n        GunicornApplication().run()\n\n\nclass EventletServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * `backlog` adjust the eventlet backlog parameter which is the maximum\n          number of queued connections. Should be at least 1; the maximum\n          value is system-dependent.\n        * `family`: (default is 2) socket family, optional. See socket\n          documentation for available families.\n    \"\"\"\n\n    def run(self, handler):\n        from eventlet import wsgi, listen, patcher\n        if not patcher.is_monkey_patched(os):\n            msg = \"Bottle requires eventlet.monkey_patch() (before import)\"\n            raise RuntimeError(msg)\n        socket_args = {}\n        for arg in ('backlog', 'family'):\n            try:\n                socket_args[arg] = self.options.pop(arg)\n            except KeyError:\n                pass\n        address = (self.host, self.port)\n        try:\n            wsgi.server(listen(address, **socket_args), handler,\n                        log_output=(not self.quiet))\n        except TypeError:\n            # Fallback, if we have old version of eventlet\n            wsgi.server(listen(address), handler)\n\n\nclass RocketServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        from rocket import Rocket\n        server = Rocket((self.host, self.port), 'wsgi', {'wsgi_app': handler})\n        server.start()\n\n\nclass BjoernServer(ServerAdapter):\n    \"\"\" Fast server written in C: https://github.com/jonashaag/bjoern \"\"\"\n\n    def run(self, handler):\n        from bjoern import run\n        run(handler, self.host, self.port)\n\nclass AsyncioServerAdapter(ServerAdapter):\n    \"\"\" Extend ServerAdapter for adding custom event loop \"\"\"\n    def get_event_loop(self):\n        pass\n\nclass AiohttpServer(AsyncioServerAdapter):\n    \"\"\" Untested.\n        aiohttp\n        https://pypi.python.org/pypi/aiohttp/\n    \"\"\"\n\n    def get_event_loop(self):\n        import asyncio\n        return asyncio.new_event_loop()\n\n    def run(self, handler):\n        import asyncio\n        from aiohttp.wsgi import WSGIServerHttpProtocol\n        self.loop = self.get_event_loop()\n        asyncio.set_event_loop(self.loop)\n\n        protocol_factory = lambda: WSGIServerHttpProtocol(\n            handler,\n            readpayload=True,\n            debug=(not self.quiet))\n        self.loop.run_until_complete(self.loop.create_server(protocol_factory,\n                                                             self.host,\n                                                             self.port))\n\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: self.loop.stop())\n\n        try:\n            self.loop.run_forever()\n        except KeyboardInterrupt:\n            self.loop.stop()\n\nclass AiohttpUVLoopServer(AiohttpServer):\n    \"\"\"uvloop\n       https://github.com/MagicStack/uvloop\n    \"\"\"\n    def get_event_loop(self):\n        import uvloop\n        return uvloop.new_event_loop()\n\nclass AutoServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    adapters = [WaitressServer, PasteServer, TwistedServer, CherryPyServer,\n                WSGIRefServer]\n\n    def run(self, handler):\n        for sa in self.adapters:\n            try:\n                return sa(self.host, self.port, **self.options).run(handler)\n            except ImportError:\n                pass\n\n\nserver_names = {\n    'cgi': CGIServer,\n    'flup': FlupFCGIServer,\n    'wsgiref': WSGIRefServer,\n    'waitress': WaitressServer,\n    'cherrypy': CherryPyServer,\n    'paste': PasteServer,\n    'fapws3': FapwsServer,\n    'tornado': TornadoServer,\n    'gae': AppEngineServer,\n    'twisted': TwistedServer,\n    'diesel': DieselServer,\n    'meinheld': MeinheldServer,\n    'gunicorn': GunicornServer,\n    'eventlet': EventletServer,\n    'gevent': GeventServer,\n    'rocket': RocketServer,\n    'bjoern': BjoernServer,\n    'aiohttp': AiohttpServer,\n    'uvloop': AiohttpUVLoopServer,\n    'auto': AutoServer,\n}\n\n###############################################################################\n# Application Control ##########################################################\n###############################################################################\n\n\ndef load(target, **namespace):\n    \"\"\" Import a module or fetch an object from a module.\n\n        * ``package.module`` returns `module` as a module object.\n        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`.\n        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result.\n\n        The last form accepts not only function calls, but any type of\n        expression. Keyword arguments passed to this function are available as\n        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')``\n    \"\"\"\n    module, target = target.split(\":\", 1) if ':' in target else (target, None)\n    if module not in sys.modules: __import__(module)\n    if not target: return sys.modules[module]\n    if target.isalnum(): return getattr(sys.modules[module], target)\n    package_name = module.split('.')[0]\n    namespace[package_name] = sys.modules[package_name]\n    return eval('%s.%s' % (module, target), namespace)\n\n\ndef load_app(target):\n    \"\"\" Load a bottle application from a module and make sure that the import\n        does not affect the current default application, but returns a separate\n        application object. See :func:`load` for the target parameter. \"\"\"\n    global NORUN\n    NORUN, nr_old = True, NORUN\n    tmp = default_app.push()  # Create a new \"default application\"\n    try:\n        rv = load(target)  # Import the target module\n        return rv if callable(rv) else tmp\n    finally:\n        default_app.remove(tmp)  # Remove the temporary added default application\n        NORUN = nr_old\n\n\n_debug = debug\n\n\ndef run(app=None,\n        server='wsgiref',\n        host='127.0.0.1',\n        port=8080,\n        interval=1,\n        reloader=False,\n        quiet=False,\n        plugins=None,\n        debug=None,\n        config=None, **kargs):\n    \"\"\" Start a server instance. This method blocks until the server terminates.\n\n        :param app: WSGI application or target string supported by\n               :func:`load_app`. (default: :func:`default_app`)\n        :param server: Server adapter to use. See :data:`server_names` keys\n               for valid names or pass a :class:`ServerAdapter` subclass.\n               (default: `wsgiref`)\n        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on\n               all interfaces including the external one. (default: 127.0.0.1)\n        :param port: Server port to bind to. Values below 1024 require root\n               privileges. (default: 8080)\n        :param reloader: Start auto-reloading server? (default: False)\n        :param interval: Auto-reloader interval in seconds (default: 1)\n        :param quiet: Suppress output to stdout and stderr? (default: False)\n        :param options: Options passed to the server adapter.\n     \"\"\"\n    if NORUN: return\n    if reloader and not os.environ.get('BOTTLE_CHILD'):\n        import subprocess\n        lockfile = None\n        try:\n            fd, lockfile = tempfile.mkstemp(prefix='bottle.', suffix='.lock')\n            os.close(fd)  # We only need this file to exist. We never write to it\n            while os.path.exists(lockfile):\n                args = [sys.executable] + sys.argv\n                environ = os.environ.copy()\n                environ['BOTTLE_CHILD'] = 'true'\n                environ['BOTTLE_LOCKFILE'] = lockfile\n                p = subprocess.Popen(args, env=environ)\n                while p.poll() is None:  # Busy wait...\n                    os.utime(lockfile, None)  # I am alive!\n                    time.sleep(interval)\n                if p.poll() != 3:\n                    if os.path.exists(lockfile): os.unlink(lockfile)\n                    sys.exit(p.poll())\n        except KeyboardInterrupt:\n            pass\n        finally:\n            if os.path.exists(lockfile):\n                os.unlink(lockfile)\n        return\n\n    try:\n        if debug is not None: _debug(debug)\n        app = app or default_app()\n        if isinstance(app, basestring):\n            app = load_app(app)\n        if not callable(app):\n            raise ValueError(\"Application is not callable: %r\" % app)\n\n        for plugin in plugins or []:\n            if isinstance(plugin, basestring):\n                plugin = load(plugin)\n            app.install(plugin)\n\n        if config:\n            app.config.update(config)\n\n        if server in server_names:\n            server = server_names.get(server)\n        if isinstance(server, basestring):\n            server = load(server)\n        if isinstance(server, type):\n            server = server(host=host, port=port, **kargs)\n        if not isinstance(server, ServerAdapter):\n            raise ValueError(\"Unknown or unsupported server: %r\" % server)\n\n        server.quiet = server.quiet or quiet\n        if not server.quiet:\n            _stderr(\"Bottle v%s server starting up (using %s)...\\n\" %\n                    (__version__, repr(server)))\n            _stderr(\"Listening on http://%s:%d/\\n\" %\n                    (server.host, server.port))\n            _stderr(\"Hit Ctrl-C to quit.\\n\\n\")\n\n        if reloader:\n            lockfile = os.environ.get('BOTTLE_LOCKFILE')\n            bgcheck = FileCheckerThread(lockfile, interval)\n            with bgcheck:\n                server.run(app)\n            if bgcheck.status == 'reload':\n                sys.exit(3)\n        else:\n            server.run(app)\n    except KeyboardInterrupt:\n        pass\n    except (SystemExit, MemoryError):\n        raise\n    except:\n        if not reloader: raise\n        if not getattr(server, 'quiet', quiet):\n            print_exc()\n        time.sleep(interval)\n        sys.exit(3)\n\n\nclass FileCheckerThread(threading.Thread):\n    \"\"\" Interrupt main-thread as soon as a changed module file is detected,\n        the lockfile gets deleted or gets too old. \"\"\"\n\n    def __init__(self, lockfile, interval):\n        threading.Thread.__init__(self)\n        self.daemon = True\n        self.lockfile, self.interval = lockfile, interval\n        #: Is one of 'reload', 'error' or 'exit'\n        self.status = None\n\n    def run(self):\n        exists = os.path.exists\n        mtime = lambda p: os.stat(p).st_mtime\n        files = dict()\n\n        for module in list(sys.modules.values()):\n            path = getattr(module, '__file__', '')\n            if path[-4:] in ('.pyo', '.pyc'): path = path[:-1]\n            if path and exists(path): files[path] = mtime(path)\n\n        while not self.status:\n            if not exists(self.lockfile)\\\n            or mtime(self.lockfile) < time.time() - self.interval - 5:\n                self.status = 'error'\n                thread.interrupt_main()\n            for path, lmtime in list(files.items()):\n                if not exists(path) or mtime(path) > lmtime:\n                    self.status = 'reload'\n                    thread.interrupt_main()\n                    break\n            time.sleep(self.interval)\n\n    def __enter__(self):\n        self.start()\n\n    def __exit__(self, exc_type, *_):\n        if not self.status: self.status = 'exit'  # silent exit\n        self.join()\n        return exc_type is not None and issubclass(exc_type, KeyboardInterrupt)\n\n###############################################################################\n# Template Adapters ############################################################\n###############################################################################\n\n\nclass TemplateError(BottleException):\n    pass\n\n\nclass BaseTemplate(object):\n    \"\"\" Base class and minimal API for template adapters \"\"\"\n    extensions = ['tpl', 'html', 'thtml', 'stpl']\n    settings = {}  #used in prepare()\n    defaults = {}  #used in render()\n\n    def __init__(self,\n                 source=None,\n                 name=None,\n                 lookup=None,\n                 encoding='utf8', **settings):\n        \"\"\" Create a new template.\n        If the source parameter (str or buffer) is missing, the name argument\n        is used to guess a template filename. Subclasses can assume that\n        self.source and/or self.filename are set. Both are strings.\n        The lookup, encoding and settings parameters are stored as instance\n        variables.\n        The lookup parameter stores a list containing directory paths.\n        The encoding parameter should be used to decode byte strings or files.\n        The settings parameter contains a dict for engine-specific settings.\n        \"\"\"\n        self.name = name\n        self.source = source.read() if hasattr(source, 'read') else source\n        self.filename = source.filename if hasattr(source, 'filename') else None\n        self.lookup = [os.path.abspath(x) for x in lookup] if lookup else []\n        self.encoding = encoding\n        self.settings = self.settings.copy()  # Copy from class variable\n        self.settings.update(settings)  # Apply\n        if not self.source and self.name:\n            self.filename = self.search(self.name, self.lookup)\n            if not self.filename:\n                raise TemplateError('Template %s not found.' % repr(name))\n        if not self.source and not self.filename:\n            raise TemplateError('No template specified.')\n        self.prepare(**self.settings)\n\n    @classmethod\n    def search(cls, name, lookup=None):\n        \"\"\" Search name in all directories specified in lookup.\n        First without, then with common extensions. Return first hit. \"\"\"\n        if not lookup:\n            raise depr(0, 12, \"Empty template lookup path.\", \"Configure a template lookup path.\")\n\n        if os.path.isabs(name):\n            raise depr(0, 12, \"Use of absolute path for template name.\",\n                       \"Refer to templates with names or paths relative to the lookup path.\")\n\n        for spath in lookup:\n            spath = os.path.abspath(spath) + os.sep\n            fname = os.path.abspath(os.path.join(spath, name))\n            if not fname.startswith(spath): continue\n            if os.path.isfile(fname): return fname\n            for ext in cls.extensions:\n                if os.path.isfile('%s.%s' % (fname, ext)):\n                    return '%s.%s' % (fname, ext)\n\n    @classmethod\n    def global_config(cls, key, *args):\n        \"\"\" This reads or sets the global settings stored in class.settings. \"\"\"\n        if args:\n            cls.settings = cls.settings.copy()  # Make settings local to class\n            cls.settings[key] = args[0]\n        else:\n            return cls.settings[key]\n\n    def prepare(self, **options):\n        \"\"\" Run preparations (parsing, caching, ...).\n        It should be possible to call this again to refresh a template or to\n        update settings.\n        \"\"\"\n        raise NotImplementedError\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template with the specified local variables and return\n        a single byte or unicode string. If it is a byte string, the encoding\n        must match self.encoding. This method must be thread-safe!\n        Local variables may be provided in dictionaries (args)\n        or directly, as keywords (kwargs).\n        \"\"\"\n        raise NotImplementedError\n\n\nclass MakoTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from mako.template import Template\n        from mako.lookup import TemplateLookup\n        options.update({'input_encoding': self.encoding})\n        options.setdefault('format_exceptions', bool(DEBUG))\n        lookup = TemplateLookup(directories=self.lookup, **options)\n        if self.source:\n            self.tpl = Template(self.source, lookup=lookup, **options)\n        else:\n            self.tpl = Template(uri=self.name,\n                                filename=self.filename,\n                                lookup=lookup, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n\nclass CheetahTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from Cheetah.Template import Template\n        self.context = threading.local()\n        self.context.vars = {}\n        options['searchList'] = [self.context.vars]\n        if self.source:\n            self.tpl = Template(source=self.source, **options)\n        else:\n            self.tpl = Template(file=self.filename, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        self.context.vars.update(self.defaults)\n        self.context.vars.update(kwargs)\n        out = str(self.tpl)\n        self.context.vars.clear()\n        return out\n\n\nclass Jinja2Template(BaseTemplate):\n    def prepare(self, filters=None, tests=None, globals={}, **kwargs):\n        from jinja2 import Environment, FunctionLoader\n        self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)\n        if filters: self.env.filters.update(filters)\n        if tests: self.env.tests.update(tests)\n        if globals: self.env.globals.update(globals)\n        if self.source:\n            self.tpl = self.env.from_string(self.source)\n        else:\n            self.tpl = self.env.get_template(self.name)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n    def loader(self, name):\n        if name == self.filename:\n            fname = name\n        else:\n            fname = self.search(name, self.lookup)\n        if not fname: return\n        with open(fname, \"rb\") as f:\n            return (f.read().decode(self.encoding), fname, lambda: False)\n\n\nclass SimpleTemplate(BaseTemplate):\n    def prepare(self,\n                escape_func=html_escape,\n                noescape=False,\n                syntax=None, **ka):\n        self.cache = {}\n        enc = self.encoding\n        self._str = lambda x: touni(x, enc)\n        self._escape = lambda x: escape_func(touni(x, enc))\n        self.syntax = syntax\n        if noescape:\n            self._str, self._escape = self._escape, self._str\n\n    @cached_property\n    def co(self):\n        return compile(self.code, self.filename or '<string>', 'exec')\n\n    @cached_property\n    def code(self):\n        source = self.source\n        if not source:\n            with open(self.filename, 'rb') as f:\n                source = f.read()\n        try:\n            source, encoding = touni(source), 'utf8'\n        except UnicodeError:\n            raise depr(0, 11, 'Unsupported template encodings.', 'Use utf-8 for templates.')\n        parser = StplParser(source, encoding=encoding, syntax=self.syntax)\n        code = parser.translate()\n        self.encoding = parser.encoding\n        return code\n\n    def _rebase(self, _env, _name=None, **kwargs):\n        _env['_rebase'] = (_name, kwargs)\n\n    def _include(self, _env, _name=None, **kwargs):\n        env = _env.copy()\n        env.update(kwargs)\n        if _name not in self.cache:\n            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup, syntax=self.syntax)\n        return self.cache[_name].execute(env['_stdout'], env)\n\n    def execute(self, _stdout, kwargs):\n        env = self.defaults.copy()\n        env.update(kwargs)\n        env.update({\n            '_stdout': _stdout,\n            '_printlist': _stdout.extend,\n            'include': functools.partial(self._include, env),\n            'rebase': functools.partial(self._rebase, env),\n            '_rebase': None,\n            '_str': self._str,\n            '_escape': self._escape,\n            'get': env.get,\n            'setdefault': env.setdefault,\n            'defined': env.__contains__\n        })\n        exec(self.co, env)\n        if env.get('_rebase'):\n            subtpl, rargs = env.pop('_rebase')\n            rargs['base'] = ''.join(_stdout)  #copy stdout\n            del _stdout[:]  # clear stdout\n            return self._include(env, subtpl, **rargs)\n        return env\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template using keyword arguments as local variables. \"\"\"\n        env = {}\n        stdout = []\n        for dictarg in args:\n            env.update(dictarg)\n        env.update(kwargs)\n        self.execute(stdout, env)\n        return ''.join(stdout)\n\n\nclass StplSyntaxError(TemplateError):\n\n    pass\n\n\nclass StplParser(object):\n    \"\"\" Parser for stpl templates. \"\"\"\n    _re_cache = {}  #: Cache for compiled re patterns\n\n    # This huge pile of voodoo magic splits python code into 8 different tokens.\n    # We use the verbose (?x) regex mode to make this more manageable\n\n    _re_tok = _re_inl = r'''((?mx)         # verbose and dot-matches-newline mode\n        [urbURB]*\n        (?:  ''(?!')\n            |\"\"(?!\")\n            |'{6}\n            |\"{6}\n            |'(?:[^\\\\']|\\\\.)+?'\n            |\"(?:[^\\\\\"]|\\\\.)+?\"\n            |'{3}(?:[^\\\\]|\\\\.|\\n)+?'{3}\n            |\"{3}(?:[^\\\\]|\\\\.|\\n)+?\"{3}\n        )\n    )'''\n\n    _re_inl = _re_tok.replace(r'|\\n', '')  # We re-use this string pattern later\n\n    _re_tok += r'''\n        # 2: Comments (until end of line, but not the newline itself)\n        |(\\#.*)\n\n        # 3: Open and close (4) grouping tokens\n        |([\\[\\{\\(])\n        |([\\]\\}\\)])\n\n        # 5,6: Keywords that start or continue a python block (only start of line)\n        |^([\\ \\t]*(?:if|for|while|with|try|def|class)\\b)\n        |^([\\ \\t]*(?:elif|else|except|finally)\\b)\n\n        # 7: Our special 'end' keyword (but only if it stands alone)\n        |((?:^|;)[\\ \\t]*end[\\ \\t]*(?=(?:%(block_close)s[\\ \\t]*)?\\r?$|;|\\#))\n\n        # 8: A customizable end-of-code-block template token (only end of line)\n        |(%(block_close)s[\\ \\t]*(?=\\r?$))\n\n        # 9: And finally, a single newline. The 10th token is 'everything else'\n        |(\\r?\\n)\n    '''\n\n    # Match the start tokens of code areas in a template\n    _re_split = r'''(?m)^[ \\t]*(\\\\?)((%(line_start)s)|(%(block_start)s))'''\n    # Match inline statements (may contain python strings)\n    _re_inl = r'''%%(inline_start)s((?:%s|[^'\"\\n]+?)*?)%%(inline_end)s''' % _re_inl\n\n    default_syntax = '<% %> % {{ }}'\n\n    def __init__(self, source, syntax=None, encoding='utf8'):\n        self.source, self.encoding = touni(source, encoding), encoding\n        self.set_syntax(syntax or self.default_syntax)\n        self.code_buffer, self.text_buffer = [], []\n        self.lineno, self.offset = 1, 0\n        self.indent, self.indent_mod = 0, 0\n        self.paren_depth = 0\n\n    def get_syntax(self):\n        \"\"\" Tokens as a space separated string (default: <% %> % {{ }}) \"\"\"\n        return self._syntax\n\n    def set_syntax(self, syntax):\n        self._syntax = syntax\n        self._tokens = syntax.split()\n        if syntax not in self._re_cache:\n            names = 'block_start block_close line_start inline_start inline_end'\n            etokens = map(re.escape, self._tokens)\n            pattern_vars = dict(zip(names.split(), etokens))\n            patterns = (self._re_split, self._re_tok, self._re_inl)\n            patterns = [re.compile(p % pattern_vars) for p in patterns]\n            self._re_cache[syntax] = patterns\n        self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax]\n\n    syntax = property(get_syntax, set_syntax)\n\n    def translate(self):\n        if self.offset: raise RuntimeError('Parser is a one time instance.')\n        while True:\n            m = self.re_split.search(self.source, pos=self.offset)\n            if m:\n                text = self.source[self.offset:m.start()]\n                self.text_buffer.append(text)\n                self.offset = m.end()\n                if m.group(1):  # Escape syntax\n                    line, sep, _ = self.source[self.offset:].partition('\\n')\n                    self.text_buffer.append(self.source[m.start():m.start(1)] +\n                                            m.group(2) + line + sep)\n                    self.offset += len(line + sep)\n                    continue\n                self.flush_text()\n                self.offset += self.read_code(self.source[self.offset:],\n                                              multiline=bool(m.group(4)))\n            else:\n                break\n        self.text_buffer.append(self.source[self.offset:])\n        self.flush_text()\n        return ''.join(self.code_buffer)\n\n    def read_code(self, pysource, multiline):\n        code_line, comment = '', ''\n        offset = 0\n        while True:\n            m = self.re_tok.search(pysource, pos=offset)\n            if not m:\n                code_line += pysource[offset:]\n                offset = len(pysource)\n                self.write_code(code_line.strip(), comment)\n                break\n            code_line += pysource[offset:m.start()]\n            offset = m.end()\n            _str, _com, _po, _pc, _blk1, _blk2, _end, _cend, _nl = m.groups()\n            if self.paren_depth > 0 and (_blk1 or _blk2):  # a if b else c\n                code_line += _blk1 or _blk2\n                continue\n            if _str:  # Python string\n                code_line += _str\n            elif _com:  # Python comment (up to EOL)\n                comment = _com\n                if multiline and _com.strip().endswith(self._tokens[1]):\n                    multiline = False  # Allow end-of-block in comments\n            elif _po:  # open parenthesis\n                self.paren_depth += 1\n                code_line += _po\n            elif _pc:  # close parenthesis\n                if self.paren_depth > 0:\n                    # we could check for matching parentheses here, but it's\n                    # easier to leave that to python - just check counts\n                    self.paren_depth -= 1\n                code_line += _pc\n            elif _blk1:  # Start-block keyword (if/for/while/def/try/...)\n                code_line, self.indent_mod = _blk1, -1\n                self.indent += 1\n            elif _blk2:  # Continue-block keyword (else/elif/except/...)\n                code_line, self.indent_mod = _blk2, -1\n            elif _end:  # The non-standard 'end'-keyword (ends a block)\n                self.indent -= 1\n            elif _cend:  # The end-code-block template token (usually '%>')\n                if multiline: multiline = False\n                else: code_line += _cend\n            else:  # \\n\n                self.write_code(code_line.strip(), comment)\n                self.lineno += 1\n                code_line, comment, self.indent_mod = '', '', 0\n                if not multiline:\n                    break\n\n        return offset\n\n    def flush_text(self):\n        text = ''.join(self.text_buffer)\n        del self.text_buffer[:]\n        if not text: return\n        parts, pos, nl = [], 0, '\\\\\\n' + '  ' * self.indent\n        for m in self.re_inl.finditer(text):\n            prefix, pos = text[pos:m.start()], m.end()\n            if prefix:\n                parts.append(nl.join(map(repr, prefix.splitlines(True))))\n            if prefix.endswith('\\n'): parts[-1] += nl\n            parts.append(self.process_inline(m.group(1).strip()))\n        if pos < len(text):\n            prefix = text[pos:]\n            lines = prefix.splitlines(True)\n            if lines[-1].endswith('\\\\\\\\\\n'): lines[-1] = lines[-1][:-3]\n            elif lines[-1].endswith('\\\\\\\\\\r\\n'): lines[-1] = lines[-1][:-4]\n            parts.append(nl.join(map(repr, lines)))\n        code = '_printlist((%s,))' % ', '.join(parts)\n        self.lineno += code.count('\\n') + 1\n        self.write_code(code)\n\n    @staticmethod\n    def process_inline(chunk):\n        if chunk[0] == '!': return '_str(%s)' % chunk[1:]\n        return '_escape(%s)' % chunk\n\n    def write_code(self, line, comment=''):\n        code = '  ' * (self.indent + self.indent_mod)\n        code += line.lstrip() + comment + '\\n'\n        self.code_buffer.append(code)\n\n\ndef template(*args, **kwargs):\n    \"\"\"\n    Get a rendered template as a string iterator.\n    You can use a name, a filename or a template string as first parameter.\n    Template rendering arguments can be passed as dictionaries\n    or directly (as keyword arguments).\n    \"\"\"\n    tpl = args[0] if args else None\n    for dictarg in args[1:]:\n        kwargs.update(dictarg)\n    adapter = kwargs.pop('template_adapter', SimpleTemplate)\n    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)\n    tplid = (id(lookup), tpl)\n    if tplid not in TEMPLATES or DEBUG:\n        settings = kwargs.pop('template_settings', {})\n        if isinstance(tpl, adapter):\n            TEMPLATES[tplid] = tpl\n            if settings: TEMPLATES[tplid].prepare(**settings)\n        elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n        else:\n            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)\n    if not TEMPLATES[tplid]:\n        abort(500, 'Template (%s) not found' % tpl)\n    return TEMPLATES[tplid].render(kwargs)\n\n\nmako_template = functools.partial(template, template_adapter=MakoTemplate)\ncheetah_template = functools.partial(template,\n                                     template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\n\n\ndef view(tpl_name, **defaults):\n    \"\"\" Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,\n            for instance, JSON with autojson or other castfilters.\n    \"\"\"\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if isinstance(result, (dict, DictMixin)):\n                tplvars = defaults.copy()\n                tplvars.update(result)\n                return template(tpl_name, **tplvars)\n            elif result is None:\n                return template(tpl_name, defaults)\n            return result\n\n        return wrapper\n\n    return decorator\n\n\nmako_view = functools.partial(view, template_adapter=MakoTemplate)\ncheetah_view = functools.partial(view, template_adapter=CheetahTemplate)\njinja2_view = functools.partial(view, template_adapter=Jinja2Template)\n\n###############################################################################\n# Constants and Globals ########################################################\n###############################################################################\n\nTEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False  # If set, run() does nothing. Used by load_app()\n\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses.copy()\nHTTP_CODES[418] = \"I'm a teapot\"  # RFC 2324\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s' % (k, v))\n                          for (k, v) in HTTP_CODES.items())\n\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, request\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>\n            <title>Error: {{e.status}}</title>\n            <style type=\"text/css\">\n              html {background-color: #eee; font-family: sans-serif;}\n              body {background-color: #fff; border: 1px solid #ddd;\n                    padding: 15px; margin: 15px;}\n              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;}\n            </style>\n        </head>\n        <body>\n            <h1>Error: {{e.status}}</h1>\n            <p>Sorry, the requested URL <tt>{{repr(request.url)}}</tt>\n               caused an error:</p>\n            <pre>{{e.body}}</pre>\n            %%if DEBUG and e.exception:\n              <h2>Exception:</h2>\n              %%try:\n                %%exc = repr(e.exception)\n              %%except:\n                %%exc = '<unprintable %%s object>' %% type(e.exception).__name__\n              %%end\n              <pre>{{exc}}</pre>\n            %%end\n            %%if DEBUG and e.traceback:\n              <h2>Traceback:</h2>\n              <pre>{{e.traceback}}</pre>\n            %%end\n        </body>\n    </html>\n%%except ImportError:\n    <b>ImportError:</b> Could not generate the error page. Please add bottle to\n    the import path.\n%%end\n\"\"\" % __name__\n\n#: A thread-safe instance of :class:`LocalRequest`. If accessed from within a\n#: request callback, this instance always refers to the *current* request\n#: (even on a multi-threaded server).\nrequest = LocalRequest()\n\n#: A thread-safe instance of :class:`LocalResponse`. It is used to change the\n#: HTTP response for the *current* request.\nresponse = LocalResponse()\n\n#: A thread-safe namespace. Not used by Bottle.\nlocal = threading.local()\n\n# Initialize app stack (create first empty Bottle app now deferred until needed)\n# BC: 0.6.4 and needed for run()\napps = app = default_app = AppStack()\n\n#: A virtual package that redirects import statements.\n#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.\next = _ImportRedirect('bottle.ext' if __name__ == '__main__' else\n                      __name__ + \".ext\", 'bottle_%s').module\n\n\ndef _main(argv):  # pragma: no coverage\n    args, parser = _cli_parse(argv)\n\n    def _cli_error(cli_msg):\n        parser.print_help()\n        _stderr('\\nError: %s\\n' % cli_msg)\n        sys.exit(1)\n\n    if args.version:\n        _stdout('Bottle %s\\n' % __version__)\n        sys.exit(0)\n    if not args.app:\n        _cli_error(\"No application entry point specified.\")\n\n    sys.path.insert(0, '.')\n    sys.modules.setdefault('bottle', sys.modules['__main__'])\n\n    host, port = (args.bind or 'localhost'), 8080\n    if ':' in host and host.rfind(']') < host.rfind(':'):\n        host, port = host.rsplit(':', 1)\n    host = host.strip('[]')\n\n    config = ConfigDict()\n\n    for cfile in args.conf or []:\n        try:\n            if cfile.endswith('.json'):\n                with open(cfile, 'rb') as fp:\n                    config.load_dict(json_loads(fp.read()))\n            else:\n                config.load_config(cfile)\n        except configparser.Error as parse_error:\n            _cli_error(parse_error)\n        except IOError:\n            _cli_error(\"Unable to read config file %r\" % cfile)\n        except (UnicodeError, TypeError, ValueError) as error:\n            _cli_error(\"Unable to parse config file %r: %s\" % (cfile, error))\n\n    for cval in args.param or []:\n        if '=' in cval:\n            config.update((cval.split('=', 1),))\n        else:\n            config[cval] = True\n\n    run(args.app,\n        host=host,\n        port=int(port),\n        server=args.server,\n        reloader=args.reload,\n        plugins=args.plugin,\n        debug=args.debug,\n        config=config)\n\n\nif __name__ == '__main__':  # pragma: no coverage\n    _main(sys.argv)\n", "# -*- coding: utf-8 -*-\n''' Tests for the BaseRequest and BaseResponse objects and their subclasses. '''\n\nimport unittest\nimport sys\n\nimport itertools\n\nimport bottle\nfrom bottle import request, tob, touni, tonat, json_dumps, HTTPError, parse_date\nfrom test import tools\nimport wsgiref.util\nimport base64\n\nfrom bottle import BaseRequest, BaseResponse, LocalRequest\n\n\nclass TestRequest(unittest.TestCase):\n\n    def test_app_property(self):\n        e = {}\n        r = BaseRequest(e)\n        self.assertRaises(RuntimeError, lambda: r.app)\n        e.update({'bottle.app': 5})\n        self.assertEqual(r.app, 5)\n\n    def test_route_property(self):\n        e = {'bottle.route': 5}\n        r = BaseRequest(e)\n        self.assertEqual(r.route, 5)\n\n    def test_url_for_property(self):\n        e = {}\n        r = BaseRequest(e)\n        self.assertRaises(RuntimeError, lambda: r.url_args)\n        e.update({'route.url_args': {'a': 5}})\n        self.assertEqual(r.url_args, {'a': 5})\n\n    def test_path(self):\n        \"\"\" PATH_INFO normalization. \"\"\"\n        # Legal paths\n        tests = [('', '/'), ('x','/x'), ('x/', '/x/'), ('/x', '/x'), ('/x/', '/x/')]\n        for raw, norm in tests:\n            self.assertEqual(norm, BaseRequest({'PATH_INFO': raw}).path)\n        # Strange paths\n        tests = [('///', '/'), ('//x','/x')]\n        for raw, norm in tests:\n            self.assertEqual(norm, BaseRequest({'PATH_INFO': raw}).path)\n        # No path at all\n        self.assertEqual('/', BaseRequest({}).path)\n\n    def test_method(self):\n        self.assertEqual(BaseRequest({}).method, 'GET')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'GET'}).method, 'GET')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'GeT'}).method, 'GET')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'get'}).method, 'GET')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'POst'}).method, 'POST')\n        self.assertEqual(BaseRequest({'REQUEST_METHOD':'FanTASY'}).method, 'FANTASY')\n\n    def test_script_name(self):\n        \"\"\" SCRIPT_NAME normalization. \"\"\"\n        # Legal paths\n        tests = [('', '/'), ('x','/x/'), ('x/', '/x/'), ('/x', '/x/'), ('/x/', '/x/')]\n        for raw, norm in tests:\n            self.assertEqual(norm, BaseRequest({'SCRIPT_NAME': raw}).script_name)\n        # Strange paths\n        tests = [('///', '/'), ('///x///','/x/')]\n        for raw, norm in tests:\n            self.assertEqual(norm, BaseRequest({'SCRIPT_NAME': raw}).script_name)\n        # No path at all\n        self.assertEqual('/', BaseRequest({}).script_name)\n\n    def test_pathshift(self):\n        \"\"\" Request.path_shift() \"\"\"\n        def test_shift(s, p, c):\n            request = BaseRequest({'SCRIPT_NAME': s, 'PATH_INFO': p})\n            request.path_shift(c)\n            return [request['SCRIPT_NAME'], request.path]\n        self.assertEqual(['/a/b', '/c/d'], test_shift('/a/b', '/c/d', 0))\n        self.assertEqual(['/a/b', '/c/d/'], test_shift('/a/b', '/c/d/', 0))\n        self.assertEqual(['/a/b/c', '/d'], test_shift('/a/b', '/c/d', 1))\n        self.assertEqual(['/a', '/b/c/d'], test_shift('/a/b', '/c/d', -1))\n        self.assertEqual(['/a/b/c', '/d/'], test_shift('/a/b', '/c/d/', 1))\n        self.assertEqual(['/a', '/b/c/d/'], test_shift('/a/b', '/c/d/', -1))\n        self.assertEqual(['/a/b/c', '/d/'], test_shift('/a/b/', '/c/d/', 1))\n        self.assertEqual(['/a', '/b/c/d/'], test_shift('/a/b/', '/c/d/', -1))\n        self.assertEqual(['/a/b/c/d', '/'], test_shift('/', '/a/b/c/d', 4))\n        self.assertEqual(['/', '/a/b/c/d/'], test_shift('/a/b/c/d', '/', -4))\n        self.assertRaises(AssertionError, test_shift, '/a/b', '/c/d', 3)\n        self.assertRaises(AssertionError, test_shift, '/a/b', '/c/d', -3)\n\n    def test_url(self):\n        \"\"\" Environ: URL building \"\"\"\n        request = BaseRequest({'HTTP_HOST':'example.com'})\n        self.assertEqual('http://example.com/', request.url)\n        request = BaseRequest({'SERVER_NAME':'example.com'})\n        self.assertEqual('http://example.com/', request.url)\n        request = BaseRequest({'SERVER_NAME':'example.com', 'SERVER_PORT':'81'})\n        self.assertEqual('http://example.com:81/', request.url)\n        request = BaseRequest({'wsgi.url_scheme':'https', 'SERVER_NAME':'example.com'})\n        self.assertEqual('https://example.com/', request.url)\n        request = BaseRequest({'HTTP_HOST':'example.com', 'PATH_INFO':'/path',\n                               'QUERY_STRING':'1=b&c=d', 'SCRIPT_NAME':'/sp'})\n        self.assertEqual('http://example.com/sp/path?1=b&c=d', request.url)\n        request = BaseRequest({'HTTP_HOST':'example.com', 'PATH_INFO':'/pa th',\n                               'SCRIPT_NAME':'/s p'})\n        self.assertEqual('http://example.com/s%20p/pa%20th', request.url)\n\n    def test_dict_access(self):\n        \"\"\" Environ: request objects are environment dicts \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        request = BaseRequest(e)\n        self.assertEqual(list(request), list(e.keys()))\n        self.assertEqual(len(request), len(e))\n        for k, v in e.items():\n            self.assertTrue(k in request)\n            self.assertEqual(request[k], v)\n            request[k] = 'test'\n            self.assertEqual(request[k], 'test')\n        del request['PATH_INFO']\n        self.assertTrue('PATH_INFO' not in request)\n\n    def test_readonly_environ(self):\n        request = BaseRequest({'bottle.request.readonly':True})\n        def test(): request['x']='y'\n        self.assertRaises(KeyError, test)\n\n    def test_header_access(self):\n        \"\"\" Environ: Request objects decode headers \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['HTTP_SOME_HEADER'] = 'some value'\n        request = BaseRequest(e)\n        request['HTTP_SOME_OTHER_HEADER'] = 'some other value'\n        self.assertTrue('Some-Header' in request.headers)\n        self.assertTrue(request.headers['Some-Header'] == 'some value')\n        self.assertTrue(request.headers['Some-Other-Header'] == 'some other value')\n\n    def test_header_access_special(self):\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        request = BaseRequest(e)\n        request['CONTENT_TYPE'] = 'test'\n        request['CONTENT_LENGTH'] = '123'\n        self.assertEqual(request.headers['Content-Type'], 'test')\n        self.assertEqual(request.headers['Content-Length'], '123')\n\n    def test_cookie_dict(self):\n        \"\"\" Environ: Cookie dict \"\"\"\n        t = dict()\n        t['a=a']      = {'a': 'a'}\n        t['a=a; b=b'] = {'a': 'a', 'b':'b'}\n        t['a=a; a=b'] = {'a': 'b'}\n        for k, v in t.items():\n            request = BaseRequest({'HTTP_COOKIE': k})\n            for n in v:\n                self.assertEqual(v[n], request.cookies[n])\n                self.assertEqual(v[n], request.get_cookie(n))\n\n    def test_get(self):\n        \"\"\" Environ: GET data \"\"\"\n        qs = tonat(tob('a=a&a=1&b=b&c=c&cn=%e7%93%b6'), 'latin1')\n        request = BaseRequest({'QUERY_STRING':qs})\n        self.assertTrue('a' in request.query)\n        self.assertTrue('b' in request.query)\n        self.assertEqual(['a','1'], request.query.getall('a'))\n        self.assertEqual(['b'], request.query.getall('b'))\n        self.assertEqual('1', request.query['a'])\n        self.assertEqual('b', request.query['b'])\n        self.assertEqual(tonat(tob('\u74f6'), 'latin1'), request.query['cn'])\n        self.assertEqual(touni('\u74f6'), request.query.cn)\n\n    def test_post(self):\n        \"\"\" Environ: POST data \"\"\"\n        sq = tob('a=a&a=1&b=b&c=&d&cn=%e7%93%b6')\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(sq)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(sq))\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertTrue('a' in request.POST)\n        self.assertTrue('b' in request.POST)\n        self.assertEqual(['a','1'], request.POST.getall('a'))\n        self.assertEqual(['b'], request.POST.getall('b'))\n        self.assertEqual('1', request.POST['a'])\n        self.assertEqual('b', request.POST['b'])\n        self.assertEqual('', request.POST['c'])\n        self.assertEqual('', request.POST['d'])\n        self.assertEqual(tonat(tob('\u74f6'), 'latin1'), request.POST['cn'])\n        self.assertEqual(touni('\u74f6'), request.POST.cn)\n\n    def test_bodypost(self):\n        sq = tob('foobar')\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(sq)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(sq))\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertEqual('', request.POST['foobar'])\n\n    def test_body_noclose(self):\n        \"\"\" Test that the body file handler is not closed after request.POST \"\"\"\n        sq = tob('a=a&a=1&b=b&c=&d')\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(sq)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(sq))\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertEqual(sq, request.body.read())\n        request.POST # This caused a body.close() with Python 3.x\n        self.assertEqual(sq, request.body.read())\n\n    def test_params(self):\n        \"\"\" Environ: GET and POST are combined in request.param \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('b=b&c=p'))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = '7'\n        e['QUERY_STRING'] = 'a=a&c=g'\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertEqual(['a','b','c'], sorted(request.params.keys()))\n        self.assertEqual('p', request.params['c'])\n\n    def test_getpostleak(self):\n        \"\"\" Environ: GET and POST should not leak into each other \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('b=b'))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = '3'\n        e['QUERY_STRING'] = 'a=a'\n        e['REQUEST_METHOD'] = \"POST\"\n        request = BaseRequest(e)\n        self.assertEqual(['a'], list(request.GET.keys()))\n        self.assertEqual(['b'], list(request.POST.keys()))\n\n    def test_body(self):\n        \"\"\" Environ: Request.body should behave like a file object factory \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('abc'))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(3)\n        request = BaseRequest(e)\n        self.assertEqual(tob('abc'), request.body.read())\n        self.assertEqual(tob('abc'), request.body.read(3))\n        self.assertEqual(tob('abc'), request.body.readline())\n        self.assertEqual(tob('abc'), request.body.readline(3))\n\n    def test_bigbody(self):\n        \"\"\" Environ: Request.body should handle big uploads using files \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('x')*1024*1000)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(1024*1000)\n        request = BaseRequest(e)\n        self.assertTrue(hasattr(request.body, 'fileno'))\n        self.assertEqual(1024*1000, len(request.body.read()))\n        self.assertEqual(1024, len(request.body.read(1024)))\n        self.assertEqual(1024*1000, len(request.body.readline()))\n        self.assertEqual(1024, len(request.body.readline(1024)))\n\n    def test_tobigbody(self):\n        \"\"\" Environ: Request.body should truncate to Content-Length bytes \"\"\"\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob('x')*1024)\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = '42'\n        request = BaseRequest(e)\n        self.assertEqual(42, len(request.body.read()))\n        self.assertEqual(42, len(request.body.read(1024)))\n        self.assertEqual(42, len(request.body.readline()))\n        self.assertEqual(42, len(request.body.readline(1024)))\n\n    def _test_chunked(self, body, expect):\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(body))\n        e['wsgi.input'].seek(0)\n        e['HTTP_TRANSFER_ENCODING'] = 'chunked'\n        if isinstance(expect, str):\n            self.assertEqual(tob(expect), BaseRequest(e).body.read())\n        else:\n            self.assertRaises(expect, lambda: BaseRequest(e).body)\n\n    def test_chunked(self):\n        self._test_chunked('1\\r\\nx\\r\\nff\\r\\n' + 'y'*255 + '\\r\\n0\\r\\n',\n                           'x' + 'y'*255)\n        self._test_chunked('8\\r\\nxxxxxxxx\\r\\n0\\r\\n','xxxxxxxx')\n        self._test_chunked('0\\r\\n', '')\n\n    def test_chunked_meta_fields(self):\n        self._test_chunked('8 ; foo\\r\\nxxxxxxxx\\r\\n0\\r\\n','xxxxxxxx')\n        self._test_chunked('8;foo\\r\\nxxxxxxxx\\r\\n0\\r\\n','xxxxxxxx')\n        self._test_chunked('8;foo=bar\\r\\nxxxxxxxx\\r\\n0\\r\\n','xxxxxxxx')\n\n    def test_chunked_not_terminated(self):\n        self._test_chunked('1\\r\\nx\\r\\n', HTTPError)\n\n    def test_chunked_wrong_size(self):\n        self._test_chunked('2\\r\\nx\\r\\n', HTTPError)\n\n    def test_chunked_illegal_size(self):\n        self._test_chunked('x\\r\\nx\\r\\n', HTTPError)\n\n    def test_chunked_not_chunked_at_all(self):\n        self._test_chunked('abcdef', HTTPError)\n\n    def test_multipart(self):\n        \"\"\" Environ: POST (multipart files and multible values per key) \"\"\"\n        fields = [('field1','value1'), ('field2','value2'), ('field2','value3')]\n        files = [('file1','filename1.txt','content1'), ('\u4e07\u96be','\u4e07\u96befoo.py', '\u00e4\\n\u00f6\\r\u00fc')]\n        e = tools.multipart_environ(fields=fields, files=files)\n        request = BaseRequest(e)\n        # File content\n        self.assertTrue('file1' in request.POST)\n        self.assertTrue('file1' in request.files)\n        self.assertTrue('file1' not in request.forms)\n        cmp = tob('content1') if sys.version_info >= (3,2,0) else 'content1'\n        self.assertEqual(cmp, request.POST['file1'].file.read())\n        # File name and meta data\n        self.assertTrue('\u4e07\u96be' in request.POST)\n        self.assertTrue('\u4e07\u96be' in request.files)\n        self.assertTrue('\u4e07\u96be' not in request.forms)\n        self.assertEqual('foo.py', request.POST['\u4e07\u96be'].filename)\n        self.assertTrue(request.files['\u4e07\u96be'])\n        self.assertFalse(request.files.file77)\n        # UTF-8 files\n        x = request.POST['\u4e07\u96be'].file.read()\n        if (3,2,0) > sys.version_info >= (3,0,0):\n            x = x.encode('utf8')\n        self.assertEqual(tob('\u00e4\\n\u00f6\\r\u00fc'), x)\n        # No file\n        self.assertTrue('file3' not in request.POST)\n        self.assertTrue('file3' not in request.files)\n        self.assertTrue('file3' not in request.forms)\n        # Field (single)\n        self.assertEqual('value1', request.POST['field1'])\n        self.assertTrue('field1' not in request.files)\n        self.assertEqual('value1', request.forms['field1'])\n        # Field (multi)\n        self.assertEqual(2, len(request.POST.getall('field2')))\n        self.assertEqual(['value2', 'value3'], request.POST.getall('field2'))\n        self.assertEqual(['value2', 'value3'], request.forms.getall('field2'))\n        self.assertTrue('field2' not in request.files)\n\n    def test_json_empty(self):\n        \"\"\" Environ: Request.json property with empty body. \"\"\"\n        self.assertEqual(BaseRequest({}).json, None)\n\n    def test_json_noheader(self):\n        \"\"\" Environ: Request.json property with missing content-type header. \"\"\"\n        test = dict(a=5, b='test', c=[1,2,3])\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(json_dumps(test)))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(json_dumps(test)))\n        self.assertEqual(BaseRequest(e).json, None)\n\n    def test_json_tobig(self):\n        \"\"\" Environ: Request.json property with huge body. \"\"\"\n        test = dict(a=5, tobig='x' * bottle.BaseRequest.MEMFILE_MAX)\n        e = {'CONTENT_TYPE': 'application/json'}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(json_dumps(test)))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(json_dumps(test)))\n        self.assertRaises(HTTPError, lambda: BaseRequest(e).json)\n\n    def test_json_valid(self):\n        \"\"\" Environ: Request.json property. \"\"\"\n        test = dict(a=5, b='test', c=[1,2,3])\n        e = {'CONTENT_TYPE': 'application/json; charset=UTF-8'}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(json_dumps(test)))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(json_dumps(test)))\n        self.assertEqual(BaseRequest(e).json, test)\n\n    def test_json_forged_header_issue616(self):\n        test = dict(a=5, b='test', c=[1,2,3])\n        e = {'CONTENT_TYPE': 'text/plain;application/json'}\n        wsgiref.util.setup_testing_defaults(e)\n        e['wsgi.input'].write(tob(json_dumps(test)))\n        e['wsgi.input'].seek(0)\n        e['CONTENT_LENGTH'] = str(len(json_dumps(test)))\n        self.assertEqual(BaseRequest(e).json, None)\n\n    def test_json_header_empty_body(self):\n        \"\"\"Request Content-Type is application/json but body is empty\"\"\"\n        e = {'CONTENT_TYPE': 'application/json'}\n        wsgiref.util.setup_testing_defaults(e)\n        wsgiref.util.setup_testing_defaults(e)\n        e['CONTENT_LENGTH'] = \"0\"\n        self.assertEqual(BaseRequest(e).json, None)\n\n    def test_isajax(self):\n        e = {}\n        wsgiref.util.setup_testing_defaults(e)\n        self.assertFalse(BaseRequest(e.copy()).is_ajax)\n        e['HTTP_X_REQUESTED_WITH'] = 'XMLHttpRequest'\n        self.assertTrue(BaseRequest(e.copy()).is_ajax)\n\n    def test_auth(self):\n        user, pwd = 'marc', 'secret'\n        basic = touni(base64.b64encode(tob('%s:%s' % (user, pwd))))\n        r = BaseRequest({})\n        self.assertEqual(r.auth, None)\n        r.environ['HTTP_AUTHORIZATION'] = 'basic %s' % basic\n        self.assertEqual(r.auth, (user, pwd))\n        r.environ['REMOTE_USER'] = user\n        self.assertEqual(r.auth, (user, pwd))\n        del r.environ['HTTP_AUTHORIZATION']\n        self.assertEqual(r.auth, (user, None))\n\n    def test_remote_route(self):\n        ips = ['1.2.3.4', '2.3.4.5', '3.4.5.6']\n        r = BaseRequest({})\n        self.assertEqual(r.remote_route, [])\n        r.environ['HTTP_X_FORWARDED_FOR'] = ', '.join(ips)\n        self.assertEqual(r.remote_route, ips)\n        r.environ['REMOTE_ADDR'] = ips[1]\n        self.assertEqual(r.remote_route, ips)\n        del r.environ['HTTP_X_FORWARDED_FOR']\n        self.assertEqual(r.remote_route, [ips[1]])\n\n    def test_remote_addr(self):\n        ips = ['1.2.3.4', '2.3.4.5', '3.4.5.6']\n        r = BaseRequest({})\n        self.assertEqual(r.remote_addr, None)\n        r.environ['HTTP_X_FORWARDED_FOR'] = ', '.join(ips)\n        self.assertEqual(r.remote_addr, ips[0])\n        r.environ['REMOTE_ADDR'] = ips[1]\n        self.assertEqual(r.remote_addr, ips[0])\n        del r.environ['HTTP_X_FORWARDED_FOR']\n        self.assertEqual(r.remote_addr, ips[1])\n\n    def test_user_defined_attributes(self):\n        for cls in (BaseRequest, LocalRequest):\n            r = cls()\n\n            # New attributes go to the environ dict.\n            r.foo = 'somevalue'\n            self.assertEqual(r.foo, 'somevalue')\n            self.assertTrue('somevalue' in r.environ.values())\n\n            # Attributes are read-only once set.\n            self.assertRaises(AttributeError, setattr, r, 'foo', 'x')\n\n            # Unknown attributes raise AttributeError.\n            self.assertRaises(AttributeError, getattr, r, 'somevalue')\n\n\nclass TestResponse(unittest.TestCase):\n\n    def test_constructor_body(self):\n        self.assertEqual('',\n            BaseResponse('').body)\n\n        self.assertEqual('YAY',\n            BaseResponse('YAY').body)\n\n    def test_constructor_status(self):\n        self.assertEqual(200,\n            BaseResponse('YAY', 200).status_code)\n\n        self.assertEqual('200 OK',\n            BaseResponse('YAY', 200).status_line)\n\n        self.assertEqual('200 YAY',\n            BaseResponse('YAY', '200 YAY').status_line)\n\n        self.assertEqual('200 YAY',\n            BaseResponse('YAY', '200 YAY').status_line)\n\n    def test_constructor_headerlist(self):\n        from functools import partial\n        make_res = partial(BaseResponse, '', 200)\n\n        self.assertEquals('yay', make_res(x_test='yay')['x-test'])\n\n    def test_wsgi_header_values(self):\n        def cmp(app, wire):\n            rs = BaseResponse()\n            rs.set_header('x-test', app)\n            result = [v for (h, v) in rs.headerlist if h.lower()=='x-test'][0]\n            self.assertEquals(wire, result)\n\n        if bottle.py3k:\n            cmp(1, tonat('1', 'latin1'))\n            cmp('\u00f6\u00e4\u00fc', '\u00f6\u00e4\u00fc'.encode('utf8').decode('latin1'))\n            # Dropped byte header support in Python 3:\n            #cmp(tob('\u00e4\u00f6\u00fc'), '\u00e4\u00f6\u00fc'.encode('utf8').decode('latin1'))\n        else:\n            cmp(1, '1')\n            cmp('\u00f6\u00e4\u00fc', '\u00f6\u00e4\u00fc')\n            cmp(touni('\u00e4\u00f6\u00fc'), '\u00e4\u00f6\u00fc')\n\n    def test_set_status(self):\n        rs = BaseResponse()\n\n        rs.status = 200\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 200)\n        self.assertEqual(rs.status_line, '200 OK')\n\n        rs.status = 999\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 999)\n        self.assertEqual(rs.status_line, '999 Unknown')\n\n        rs.status = 404\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 404)\n        self.assertEqual(rs.status_line, '404 Not Found')\n\n        def test(): rs.status = -200\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Not Found') # last value\n\n        def test(): rs.status = 5\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Not Found') # last value\n\n        rs.status = '999 Who knows?' # Illegal, but acceptable three digit code\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 999)\n        self.assertEqual(rs.status_line, '999 Who knows?')\n\n        rs.status = 555 # Strange code\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 555)\n        self.assertEqual(rs.status_line, '555 Unknown')\n\n        rs.status = '404 Brain not Found' # Custom reason\n        self.assertEqual(rs.status, rs.status_line)\n        self.assertEqual(rs.status_code, 404)\n        self.assertEqual(rs.status_line, '404 Brain not Found')\n\n        def test(): rs.status = '5 Illegal Code'\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Brain not Found') # last value\n\n        def test(): rs.status = '-99 Illegal Code'\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Brain not Found') # last value\n\n        def test(): rs.status = '1000 Illegal Code'\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Brain not Found') # last value\n\n        def test(): rs.status = '555' # No reason\n        self.assertRaises(ValueError, test)\n        self.assertEqual(rs.status, rs.status_line) # last value\n        self.assertEqual(rs.status_code, 404) # last value\n        self.assertEqual(rs.status_line, '404 Brain not Found') # last value\n\n    def test_content_type(self):\n        rs = BaseResponse()\n        rs.content_type = 'test/some'\n        self.assertEqual('test/some', rs.headers.get('Content-Type'))\n\n    def test_charset(self):\n        rs = BaseResponse()\n        self.assertEqual(rs.charset, 'UTF-8')\n        rs.content_type = 'text/html; charset=latin9'\n        self.assertEqual(rs.charset, 'latin9')\n        rs.content_type = 'text/html'\n        self.assertEqual(rs.charset, 'UTF-8')\n\n    def test_set_cookie(self):\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', max_age=5)\n        r.set_cookie('name2', 'value 2', path='/foo')\n        cookies = [value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie']\n        cookies.sort()\n        self.assertEqual(cookies[0], 'name1=value; Max-Age=5')\n        self.assertEqual(cookies[1], 'name2=\"value 2\"; Path=/foo')\n\n    def test_set_cookie_value_long_string(self):\n        r = BaseResponse()\n        self.assertRaises(ValueError, r.set_cookie, name='test', value='x' * 4097)\n\n    def test_set_cookie_name_long_string(self):\n        r = BaseResponse()\n        self.assertRaises(ValueError, r.set_cookie, name='x' * 4097, value='simple_value')\n\n    def test_set_cookie_maxage(self):\n        import datetime\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', max_age=5)\n        r.set_cookie('name2', 'value', max_age=datetime.timedelta(days=1))\n        cookies = sorted([value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie'])\n        self.assertEqual(cookies[0], 'name1=value; Max-Age=5')\n        self.assertEqual(cookies[1], 'name2=value; Max-Age=86400')\n\n    def test_set_cookie_expires(self):\n        import datetime\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', expires=42)\n        r.set_cookie('name2', 'value', expires=datetime.datetime(1970,1,1,0,0,43))\n        cookies = sorted([value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie'])\n        self.assertEqual(cookies[0], 'name1=value; expires=Thu, 01 Jan 1970 00:00:42 GMT')\n        self.assertEqual(cookies[1], 'name2=value; expires=Thu, 01 Jan 1970 00:00:43 GMT')\n\n    def test_set_cookie_secure(self):\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', secure=True)\n        r.set_cookie('name2', 'value', secure=False)\n        cookies = sorted([value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie'])\n        self.assertEqual(cookies[0].lower(), 'name1=value; secure')\n        self.assertEqual(cookies[1], 'name2=value')\n\n    def test_set_cookie_httponly(self):\n        if sys.version_info < (2,6,0):\n            return\n        r = BaseResponse()\n        r.set_cookie('name1', 'value', httponly=True)\n        r.set_cookie('name2', 'value', httponly=False)\n        cookies = sorted([value for name, value in r.headerlist\n                   if name.title() == 'Set-Cookie'])\n        self.assertEqual(cookies[0].lower(), 'name1=value; httponly')\n        self.assertEqual(cookies[1], 'name2=value')\n\n    def test_delete_cookie(self):\n        response = BaseResponse()\n        response.set_cookie('name', 'value')\n        response.delete_cookie('name')\n        cookies = [value for name, value in response.headerlist\n                   if name.title() == 'Set-Cookie']\n        self.assertTrue('Max-Age=-1' in cookies[0])\n\n    def test_set_header(self):\n        response = BaseResponse()\n        response['x-test'] = 'foo'\n        headers = [value for name, value in response.headerlist\n                   if name.title() == 'X-Test']\n        self.assertEqual(['foo'], headers)\n        self.assertEqual('foo', response['x-test'])\n\n        response['X-Test'] = 'bar'\n        headers = [value for name, value in response.headerlist\n                   if name.title() == 'X-Test']\n        self.assertEqual(['bar'], headers)\n        self.assertEqual('bar', response['x-test'])\n\n    def test_append_header(self):\n        response = BaseResponse()\n        response.set_header('x-test', 'foo')\n        headers = [value for name, value in response.headerlist\n                   if name.title() == 'X-Test']\n        self.assertEqual(['foo'], headers)\n        self.assertEqual('foo', response['x-test'])\n\n        response.add_header('X-Test', 'bar')\n        headers = [value for name, value in response.headerlist\n                   if name.title() == 'X-Test']\n        self.assertEqual(['foo', 'bar'], headers)\n        self.assertEqual('bar', response['x-test'])\n\n    def test_delete_header(self):\n        response = BaseResponse()\n        response['x-test'] = 'foo'\n        self.assertEqual('foo', response['x-test'])\n        del response['X-tESt']\n        self.assertRaises(KeyError, lambda: response['x-test'])\n\n    def test_non_string_header(self):\n        response = BaseResponse()\n        response['x-test'] = 5\n        self.assertEqual('5', response['x-test'])\n        response['x-test'] = None\n        self.assertEqual('None', response['x-test'])\n\n    def test_prevent_control_characters_in_headers(self):\n        apis = 'append', 'replace', '__setitem__', 'setdefault'\n        masks = '{}test', 'test{}', 'te{}st'\n        tests = '\\n', '\\r', '\\n\\r', '\\0'\n        for api, mask, test in itertools.product(apis, masks, tests):\n            hd = bottle.HeaderDict()\n            func = getattr(hd, api)\n            value = mask.replace(\"{}\", test)\n            self.assertRaises(ValueError, func, value, \"test-value\")\n            self.assertRaises(ValueError, func, \"test-name\", value)\n\n    def test_expires_header(self):\n        import datetime\n        response = BaseResponse()\n        now = datetime.datetime.now()\n        response.expires = now\n\n        def seconds(a, b):\n            td = max(a,b) - min(a,b)\n            return td.days*360*24 + td.seconds\n\n        self.assertEqual(0, seconds(response.expires, now))\n        now2 = datetime.datetime.utcfromtimestamp(\n            parse_date(response.headers['Expires']))\n        self.assertEqual(0, seconds(now, now2))\n\n\nclass TestRedirect(unittest.TestCase):\n\n    def assertRedirect(self, target, result, query=None, status=303, **args):\n        env = {'SERVER_PROTOCOL': 'HTTP/1.1'}\n        for key in list(args):\n            if key.startswith('wsgi'):\n                args[key.replace('_', '.', 1)] = args[key]\n                del args[key]\n        env.update(args)\n        request.bind(env)\n        bottle.response.bind()\n        try:\n            bottle.redirect(target, **(query or {}))\n        except bottle.HTTPResponse as E:\n            self.assertEqual(status, E.status_code)\n            self.assertTrue(E.headers)\n            self.assertEqual(result, E.headers['Location'])\n\n    def test_absolute_path(self):\n        self.assertRedirect('/', 'http://127.0.0.1/')\n        self.assertRedirect('/test.html', 'http://127.0.0.1/test.html')\n        self.assertRedirect('/test.html', 'http://127.0.0.1/test.html',\n                            PATH_INFO='/some/sub/path/')\n        self.assertRedirect('/test.html', 'http://127.0.0.1/test.html',\n                            PATH_INFO='/some/sub/file.html')\n        self.assertRedirect('/test.html', 'http://127.0.0.1/test.html',\n                            SCRIPT_NAME='/some/sub/path/')\n        self.assertRedirect('/foo/test.html', 'http://127.0.0.1/foo/test.html')\n        self.assertRedirect('/foo/test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/some/sub/file.html')\n\n    def test_relative_path(self):\n        self.assertRedirect('./', 'http://127.0.0.1/')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/test.html')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/foo/')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/foo/bar.html')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/foo/test.html',\n                            SCRIPT_NAME='/foo/')\n        self.assertRedirect('./test.html', 'http://127.0.0.1/foo/bar/test.html',\n                            SCRIPT_NAME='/foo/', PATH_INFO='/bar/baz.html')\n        self.assertRedirect('./foo/test.html', 'http://127.0.0.1/foo/test.html')\n        self.assertRedirect('./foo/test.html', 'http://127.0.0.1/bar/foo/test.html',\n                            PATH_INFO='/bar/file.html')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/test.html',\n                            PATH_INFO='/foo/')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/foo/bar/')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/test.html',\n                            PATH_INFO='/foo/bar.html')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/test.html',\n                            SCRIPT_NAME='/foo/')\n        self.assertRedirect('../test.html', 'http://127.0.0.1/foo/test.html',\n                            SCRIPT_NAME='/foo/', PATH_INFO='/bar/baz.html')\n        self.assertRedirect('../baz/../test.html', 'http://127.0.0.1/foo/test.html',\n                            PATH_INFO='/foo/bar/')\n\n    def test_sheme(self):\n        self.assertRedirect('./test.html', 'https://127.0.0.1/test.html',\n                            wsgi_url_scheme='https')\n        self.assertRedirect('./test.html', 'https://127.0.0.1:80/test.html',\n                            wsgi_url_scheme='https', SERVER_PORT='80')\n\n    def test_host_http_1_0(self):\n        # No HTTP_HOST, just SERVER_NAME and SERVER_PORT.\n        self.assertRedirect('./test.html', 'http://example.com/test.html',\n                            SERVER_NAME='example.com',\n                            SERVER_PROTOCOL='HTTP/1.0', status=302)\n        self.assertRedirect('./test.html', 'http://127.0.0.1:81/test.html',\n                            SERVER_PORT='81',\n                            SERVER_PROTOCOL='HTTP/1.0', status=302)\n\n    def test_host_http_1_1(self):\n        self.assertRedirect('./test.html', 'http://example.com/test.html',\n                            HTTP_HOST='example.com')\n        self.assertRedirect('./test.html', 'http://example.com:81/test.html',\n                            HTTP_HOST='example.com:81')\n        # Trust HTTP_HOST over SERVER_NAME and PORT.\n        self.assertRedirect('./test.html', 'http://example.com:81/test.html',\n                            HTTP_HOST='example.com:81', SERVER_NAME='foobar')\n        self.assertRedirect('./test.html', 'http://example.com:81/test.html',\n                            HTTP_HOST='example.com:81', SERVER_PORT='80')\n\n    def test_host_http_proxy(self):\n        # Trust proxy headers over original header.\n        self.assertRedirect('./test.html', 'http://example.com/test.html',\n                            HTTP_X_FORWARDED_HOST='example.com',\n                            HTTP_HOST='127.0.0.1')\n\n    def test_specialchars(self):\n        ''' The target URL is not quoted automatically. '''\n        self.assertRedirect('./te st.html',\n                            'http://example.com/a%20a/b%20b/te st.html',\n                            HTTP_HOST='example.com', SCRIPT_NAME='/a a/', PATH_INFO='/b b/')\n\n    def test_redirect_preserve_cookies(self):\n        env = {'SERVER_PROTOCOL':'HTTP/1.1'}\n        request.bind(env)\n        bottle.response.bind()\n        try:\n            bottle.response.set_cookie('xxx', 'yyy')\n            bottle.redirect('...')\n        except bottle.HTTPResponse as E:\n            h = [v for (k, v) in E.headerlist if k == 'Set-Cookie']\n            self.assertEqual(h, ['xxx=yyy'])\n\nclass TestWSGIHeaderDict(unittest.TestCase):\n    def setUp(self):\n        self.env = {}\n        self.headers = bottle.WSGIHeaderDict(self.env)\n\n    def test_empty(self):\n        self.assertEqual(0, len(bottle.WSGIHeaderDict({})))\n\n    def test_native(self):\n        self.env['HTTP_TEST_HEADER'] = 'foobar'\n        self.assertEqual(self.headers['Test-header'], 'foobar')\n\n    def test_bytes(self):\n        self.env['HTTP_TEST_HEADER'] = tob('foobar')\n        self.assertEqual(self.headers['Test-Header'], 'foobar')\n\n    def test_unicode(self):\n        self.env['HTTP_TEST_HEADER'] = touni('foobar')\n        self.assertEqual(self.headers['Test-Header'], 'foobar')\n\n    def test_dict(self):\n        for key in 'foo-bar Foo-Bar foo-Bar FOO-BAR'.split():\n            self.assertTrue(key not in self.headers)\n            self.assertEqual(self.headers.get(key), None)\n            self.assertEqual(self.headers.get(key, 5), 5)\n            self.assertRaises(KeyError, lambda x: self.headers[x], key)\n        self.env['HTTP_FOO_BAR'] = 'test'\n        for key in 'foo-bar Foo-Bar foo-Bar FOO-BAR'.split():\n            self.assertTrue(key in self.headers)\n            self.assertEqual(self.headers.get(key), 'test')\n            self.assertEqual(self.headers.get(key, 5), 'test')\n"], "filenames": ["bottle.py", "test/test_environ.py"], "buggy_code_start_loc": [1576, 5], "buggy_code_end_loc": [2211, 697], "fixing_code_start_loc": [1576, 6], "fixing_code_end_loc": [2214, 712], "type": "CWE-93", "message": "redirect() in bottle.py in bottle 0.12.10 doesn't filter a \"\\r\\n\" sequence, which leads to a CRLF attack, as demonstrated by a redirect(\"233\\r\\nSet-Cookie: name=salt\") call.", "other": {"cve": {"id": "CVE-2016-9964", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-16T09:59:00.373", "lastModified": "2017-01-11T03:00:14.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "redirect() in bottle.py in bottle 0.12.10 doesn't filter a \"\\r\\n\" sequence, which leads to a CRLF attack, as demonstrated by a redirect(\"233\\r\\nSet-Cookie: name=salt\") call."}, {"lang": "es", "value": "redirect() en bottle.py en bottle 0.12.10 no filtra una secuencia \"\\r\\n\", lo que lleva a un ataque CRLF, seg\u00fan lo demostrado por una llamada redireccionada (\"233\\r\\nSet-Cookie: name=salt\")."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-93"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bottlepy:bottle:0.12.10:*:*:*:*:*:*:*", "matchCriteriaId": "7C61B220-6383-4108-8B6D-D1394CDB4C5C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.debian.org/security/2016/dsa-3743", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94961", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/bottlepy/bottle/commit/6d7e13da0f998820800ecb3fe9ccee4189aefb54", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/bottlepy/bottle/issues/913", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bottlepy/bottle/commit/6d7e13da0f998820800ecb3fe9ccee4189aefb54"}}