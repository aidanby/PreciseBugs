{"buggy_code": ["# @fastify/csrf-protection\n\n![CI](https://github.com/fastify/csrf-protection/workflows/CI/badge.svg)\n[![NPM version](https://img.shields.io/npm/v/@fastify/csrf-protection.svg?style=flat)](https://www.npmjs.com/package/@fastify/csrf-protection)\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](https://standardjs.com/)\n\nThis plugin helps developers protect their Fastify server against [CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery) attacks.\nIn order to fully protect against CSRF, developers should study [Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\nin depth. See also [pillarjs/understanding-csrf](https://github.com/pillarjs/understanding-csrf) as a good guide.\n\n## Security Disclaimer\n\nSecuring applications against CSRF is a _developer responsibility_ and it should not be fully trusted to any third party modules.\nWe do not claim that this module is able to protect an application without a clear study of CSRF, its impact and the needed mitigations.\n@fastify/csrf-protection provides a series of utilities that developers can use to secure their application.\nWe recommend using [@fastify/helmet](https://github.com/fastify/fastify-helmet) to implement some of those mitigations.\n\nSecurity is always a tradeoff between risk mitigation, functionality, performance, and developer experience.\nAs a result we will not consider a report of a plugin default configuration option as security\nvulnerability that might be unsafe in certain scenarios as long as this module provides a\nway to provide full mitigation through configuration.\n\n# Install\n```js\nnpm i @fastify/csrf-protection\n```\n\n## Usage\n\n\n### Use with [`@fastify/cookie`](https://github.com/fastify/@fastify/cookie)\n\nIf you use `@fastify/csrf-protection` with `@fastify/cookie`, the CSRF secret will be added to the response cookies.\nBy default, the cookie used will be named `_csrf`, but you can rename it via the `cookieKey` option.\nWhen `cookieOpts` are provided, they **override** the default cookie options. Make sure you restore any of the default options which provide sensible and secure defaults.\n\n```js\nfastify.register(require('@fastify/cookie'))\nfastify.register(require('@fastify/csrf-protection'))\n\n// if you want to sign cookies:\nfastify.register(require('@fastify/cookie'), { secret }) // See following section to ensure security\nfastify.register(require('@fastify/csrf-protection'), { cookieOpts: { signed: true } })\n\n// generate a token\nfastify.route({\n  method: 'GET',\n  path: '/',\n  handler: async (req, reply) => {\n    const token = await reply.generateCsrf()\n    return { token }\n  }\n})\n\n// protect a route\nfastify.route({\n  method: 'POST',\n  path: '/',\n  onRequest: fastify.csrfProtection,\n  handler: async (req, reply) => {\n    return req.body\n  }\n})\n```\n\n### Use with [`@fastify/session`](https://github.com/fastify/session)\n\nIf you use `@fastify/csrf-protection` with `@fastify/session`, the CSRF secret will be added to the session.\nBy default, the key used will be named `_csrf`, but you can rename it via the `sessionKey` option.\n\n```js\nfastify.register(require('@fastify-session'))\nfastify.register(require('@fastify/csrf-protection'), { sessionPlugin: '@fastify/session' })\n\n// generate a token\nfastify.route({\n  method: 'GET',\n  path: '/',\n  handler: async (req, reply) => {\n    const token = await reply.generateCsrf()\n    return { token }\n  }\n})\n\n// protect a route\nfastify.route({\n  method: 'POST',\n  path: '/',\n  onRequest: fastify.csrfProtection,\n  handler: async (req, reply) => {\n    return req.body\n  }\n})\n```\n\n### Use with [`@fastify/secure-session`](https://github.com/fastify/fastify-secure-session)\n\nIf you use `@fastify/csrf-protection` with `@fastify/secure-session`, the CSRF secret will be added to the session.\nBy default, the key used will be named `_csrf`, but you can rename it via the `sessionKey` option.\n\n```js\nfastify.register(require('@fastify/secure-session'))\nfastify.register(require('@fastify/csrf-protection'), { sessionPlugin: '@fastify/secure-session' })\n\n// generate a token\nfastify.route({\n  method: 'GET',\n  path: '/',\n  handler: async (req, reply) => {\n    const token = await reply.generateCsrf()\n    return { token }\n  }\n})\n\n// protect a route\nfastify.route({\n  method: 'POST',\n  path: '/',\n  onRequest: fastify.csrfProtection,\n  handler: async (req, reply) => {\n    return req.body\n  }\n})\n```\n\n### Securing the secret\n\nThe `secret` shown in the code above is strictly just an example. In all cases, you would need to make sure that the `secret` is:\n- **Never** hard-coded in the code or `.env` files or anywhere in the repository\n- Stored in some external services like KMS, Vault or something similar\n- Read at run-time and supplied to this option\n- Of significant character length to provide adequate entropy\n- Truly random sequence of characters (You could use [crypto-random-string](http://npm.im/crypto-random-string))\n\nApart from these safeguards, it is extremely important to [use HTTPS for your website/app](https://letsencrypt.org/) to avoid a bunch of other potential security issues like [MITM attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) etc.\n\n## API\n\n### Module Options\n\n| Options      | Description |\n| ----------- | ----------- |\n| `cookieKey` |  The name of the cookie where the CSRF secret will be stored, default `_csrf`.     |\n| `cookieOpts` |  The cookie serialization options. See [@fastify/cookie](https://github.com/fastify/fastify-cookie).    |\n| `sessionKey` |  The key where to store the CSRF secret in the session.     |\n| `getToken` |  A sync function to get the CSRF secret from the request.     |\n| `getUserInfo` |  A sync function to get the a string of user-specific information to prevent cookie tossing.     |\n| `sessionPlugin` |  The session plugin that you are using (if applicable).     |\n| `csrfOpts` |  The csrf options. See  [@fastify/csrf](https://github.com/fastify/csrf).     |\n\n### `reply.generateCsrf([opts])`\n\nGenerates a secret (if it is not already present) and returns a promise that resolves to the associated secret.\n\n```js\nconst token = await reply.generateCsrf()\n```\n\nYou can also pass the [cookie serialization](https://github.com/fastify/fastify-cookie) options to the function.\n\nThe option `userInfo` is required if `getUserInfo` has been specified in the module option.\nThe provided `userInfo` is hashed  inside the csrf token and it is not directly exposed.\nThis option is needed to protect against cookie tossing.\n\n### `fastify.csrfProtection(request, reply, next)`\n\nA hook that you can use for protecting routes or entire plugins from CSRF attacks.\nGenerally, we recommend using an `onRequest` hook, but if you are sending the token\nvia the request body, then you must use a `preValidation` or `preHandler` hook.\n\n```js\n// protect the fastify instance\nfastify.addHook('onRequest', fastify.csrfProtection)\n\n// protect a single route\nfastify.route({\n  method: 'POST',\n  path: '/',\n  onRequest: fastify.csrfProtection,\n  handler: async (req, reply) => {\n    return req.body\n  }\n})\n```\n\nYou can configure the function to read the CSRF token via the `getToken` option, by default the following is used:\n\n```js\nfunction getToken (req) {\n  return (req.body && req.body._csrf) ||\n    req.headers['csrf-token'] ||\n    req.headers['xsrf-token'] ||\n    req.headers['x-csrf-token'] ||\n    req.headers['x-xsrf-token']\n}\n```\n\nIt is recommended to provide a custom `getToken` function for performance and [security](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#use-of-custom-request-headers) reasons.\n\n```js\nfastify.register(require('@fastify/csrf-protection'), \n  { getToken: function (req) { return req.headers['csrf-token'] } }\n)\n```\nor\n\n```js\nfastify.register(require('@fastify/csrf-protection'), \n  { getToken: (req) => req.headers['csrf-token'] }\n)\n```\n\n## License\n\n[MIT](./LICENSE)\n", "'use strict'\n\nconst assert = require('assert')\nconst fp = require('fastify-plugin')\nconst CSRF = require('@fastify/csrf')\nconst createError = require('@fastify/error')\n\nconst MissingCSRFSecretError = createError('FST_CSRF_MISSING_SECRET', 'Missing csrf secret', 403)\nconst InvalidCSRFTokenError = createError('FST_CSRF_INVALID_TOKEN', 'Invalid csrf token', 403)\n\nconst defaultOptions = {\n  cookieKey: '_csrf',\n  cookieOpts: { path: '/', sameSite: true, httpOnly: true },\n  sessionKey: '_csrf',\n  getToken: getTokenDefault,\n  getUserInfo: getUserInfoDefault,\n  sessionPlugin: '@fastify/cookie'\n}\n\nasync function fastifyCsrfProtection (fastify, opts) {\n  const {\n    cookieKey,\n    cookieOpts,\n    sessionKey,\n    getToken,\n    getUserInfo,\n    sessionPlugin\n  } = Object.assign({}, defaultOptions, opts)\n\n  const csrfOpts = opts && opts.csrfOpts ? opts.csrfOpts : {}\n\n  assert(typeof cookieKey === 'string', 'cookieKey should be a string')\n  assert(typeof sessionKey === 'string', 'sessionKey should be a string')\n  assert(typeof getToken === 'function', 'getToken should be a function')\n  assert(typeof getUserInfo === 'function', 'getUserInfo should be a function')\n  assert(typeof cookieOpts === 'object', 'cookieOpts should be a object')\n  assert(\n    ['@fastify/cookie', '@fastify/session', '@fastify/secure-session'].includes(sessionPlugin),\n    \"sessionPlugin should be one of the following: '@fastify/cookie', '@fastify/session', '@fastify/secure-session'\"\n  )\n\n  if (opts.getUserInfo) {\n    csrfOpts.userInfo = true\n  }\n  const tokens = new CSRF(csrfOpts)\n\n  const isCookieSigned = cookieOpts && cookieOpts.signed\n\n  if (sessionPlugin === '@fastify/secure-session') {\n    fastify.decorateReply('generateCsrf', generateCsrfSecureSession)\n  } else if (sessionPlugin === '@fastify/session') {\n    fastify.decorateReply('generateCsrf', generateCsrfSession)\n  } else {\n    fastify.decorateReply('generateCsrf', generateCsrfCookie)\n  }\n\n  fastify.decorate('csrfProtection', csrfProtection)\n\n  let getSecret\n\n  if (sessionPlugin === '@fastify/secure-session') {\n    getSecret = function getSecret (req, reply) { return req.session.get(sessionKey) }\n  } else if (sessionPlugin === '@fastify/session') {\n    getSecret = function getSecret (req, reply) { return req.session[sessionKey] }\n  } else {\n    getSecret = function getSecret (req, reply) {\n      return isCookieSigned\n        ? reply.unsignCookie(req.cookies[cookieKey] || '').value\n        : req.cookies[cookieKey]\n    }\n  }\n\n  function generateCsrfCookie (opts) {\n    let secret = isCookieSigned\n      ? this.unsignCookie(this.request.cookies[cookieKey] || '').value\n      : this.request.cookies[cookieKey]\n    const userInfo = opts ? opts.userInfo : undefined\n    if (!secret) {\n      secret = tokens.secretSync()\n      this.setCookie(cookieKey, secret, Object.assign({}, cookieOpts, opts))\n    }\n    return tokens.create(secret, userInfo)\n  }\n\n  function generateCsrfSecureSession (opts) {\n    let secret = this.request.session.get(sessionKey)\n    if (!secret) {\n      secret = tokens.secretSync()\n      this.request.session.set(sessionKey, secret)\n    }\n    const userInfo = opts ? opts.userInfo : undefined\n    if (opts) {\n      this.request.session.options(opts)\n    }\n    return tokens.create(secret, userInfo)\n  }\n\n  function generateCsrfSession (opts) {\n    let secret = this.request.session[sessionKey]\n    const userInfo = opts ? opts.userInfo : undefined\n    if (!secret) {\n      secret = tokens.secretSync()\n      this.request.session[sessionKey] = secret\n    }\n    return tokens.create(secret, userInfo)\n  }\n\n  function csrfProtection (req, reply, next) {\n    const secret = getSecret(req, reply)\n    if (!secret) {\n      req.log.warn('Missing csrf secret')\n      return reply.send(new MissingCSRFSecretError())\n    }\n    if (!tokens.verify(secret, getToken(req), getUserInfo(req))) {\n      req.log.warn('Invalid csrf token')\n      return reply.send(new InvalidCSRFTokenError())\n    }\n    next()\n  }\n}\n\nfunction getTokenDefault (req) {\n  return (req.body && req.body._csrf) ||\n    req.headers['csrf-token'] ||\n    req.headers['xsrf-token'] ||\n    req.headers['x-csrf-token'] ||\n    req.headers['x-xsrf-token']\n}\n\nfunction getUserInfoDefault (req) {\n  return undefined\n}\n\nmodule.exports = fp(fastifyCsrfProtection, {\n  fastify: '4.x',\n  name: '@fastify/csrf-protection'\n})\nmodule.exports.default = fastifyCsrfProtection\nmodule.exports.fastifyCsrfProtection = fastifyCsrfProtection\n", "'use strict'\n\nconst { test } = require('tap')\nconst Fastify = require('fastify')\nconst fastifyCookie = require('@fastify/cookie')\nconst fastifySession = require('@fastify/session')\nconst fastifySecureSession = require('@fastify/secure-session')\nconst fastifyCsrf = require('../')\n\nconst sodium = require('sodium-native')\nconst key = Buffer.alloc(sodium.crypto_secretbox_KEYBYTES)\nsodium.randombytes_buf(key)\n\ntest('Cookies with User-Info', async t => {\n  const fastify = Fastify()\n  await fastify.register(fastifyCookie)\n  await fastify.register(fastifyCsrf, {\n    getUserInfo (req) {\n      return userInfoDB[req.body.username]\n    }\n  })\n\n  const userInfoDB = {\n    foo: 'a42'\n  }\n\n  fastify.post('/login', async (req, reply) => {\n    const token = await reply.generateCsrf({ userInfo: userInfoDB[req.body.username] })\n    return { token }\n  })\n\n  // must be preHandler as we are parsing the body\n  fastify.post('/', { preHandler: fastify.csrfProtection }, async (req, reply) => {\n    return req.body\n  })\n\n  const response1 = await fastify.inject({\n    method: 'POST',\n    path: '/login',\n    body: {\n      username: 'foo'\n    }\n  })\n\n  t.equal(response1.statusCode, 200)\n\n  const cookie1 = response1.cookies[0]\n  const { token } = response1.json()\n\n  const response2 = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    cookies: {\n      _csrf: cookie1.value\n    },\n    body: {\n      _csrf: token,\n      username: 'foo'\n    }\n  })\n\n  t.equal(response2.statusCode, 200)\n})\n\ntest('Session with User-Info', async t => {\n  const fastify = Fastify()\n  await fastify.register(fastifyCookie)\n  await fastify.register(fastifySession, {\n    secret: 'a'.repeat(32),\n    cookie: { path: '/', secure: false }\n  })\n  await fastify.register(fastifyCsrf, {\n    sessionPlugin: '@fastify/session',\n    getUserInfo (req) {\n      return req.session.username\n    }\n  })\n\n  fastify.post('/login', async (req, reply) => {\n    req.session.username = req.body.username\n    const token = await reply.generateCsrf({ userInfo: req.body.username })\n    return { token }\n  })\n\n  // must be preHandler as we are parsing the body\n  fastify.post('/', { preHandler: fastify.csrfProtection }, async (req, reply) => {\n    return req.body\n  })\n\n  const response1 = await fastify.inject({\n    method: 'POST',\n    path: '/login',\n    body: {\n      username: 'foo'\n    }\n  })\n\n  t.equal(response1.statusCode, 200)\n\n  const cookie1 = response1.cookies[0]\n  const { token } = response1.json()\n\n  const response2 = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    cookies: {\n      sessionId: cookie1.value\n    },\n    body: {\n      _csrf: token,\n      username: 'foo'\n    }\n  })\n\n  t.equal(response2.statusCode, 200)\n})\n\ntest('SecureSession with User-Info', async t => {\n  const fastify = Fastify()\n  await fastify.register(fastifySecureSession, { key, cookie: { path: '/', secure: false } })\n  await fastify.register(fastifyCsrf, {\n    sessionPlugin: '@fastify/secure-session',\n    getUserInfo (req) {\n      return req.session.get('username')\n    }\n  })\n\n  fastify.post('/login', async (req, reply) => {\n    req.session.set('username', req.body.username)\n    const token = await reply.generateCsrf({ userInfo: req.body.username })\n    return { token }\n  })\n\n  // must be preHandler as we are parsing the body\n  fastify.post('/', { preHandler: fastify.csrfProtection }, async (req, reply) => {\n    return req.body\n  })\n\n  const response1 = await fastify.inject({\n    method: 'POST',\n    path: '/login',\n    body: {\n      username: 'foo'\n    }\n  })\n\n  t.equal(response1.statusCode, 200)\n\n  const cookie1 = response1.cookies[0]\n  const { token } = response1.json()\n\n  const response2 = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    cookies: {\n      session: cookie1.value\n    },\n    body: {\n      _csrf: token,\n      username: 'foo'\n    }\n  })\n\n  t.equal(response2.statusCode, 200)\n})\n", "/// <reference types=\"node\" />\n\nimport { FastifyPluginAsync, FastifyRequest } from 'fastify';\nimport { Options as CSRFOptions } from \"@fastify/csrf\";\nimport { CookieSerializeOptions as FastifyCookieSerializeOptions } from \"@fastify/cookie\";\n\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    csrfProtection(req: FastifyRequest, reply: FastifyReply, done: () => void): any;\n  }\n\n  interface FastifyReply {\n    /**\n     * Generate a token and configure the secret if needed\n     * @param options Serialize options\n     */\n    generateCsrf(\n      options?: fastifyCsrfProtection.CookieSerializeOptions\n    ): string;\n  }\n}\n\ntype FastifyCsrfProtection = FastifyPluginAsync<fastifyCsrfProtection.FastifyCsrfOptions>;\n\ndeclare namespace fastifyCsrfProtection {\n  export type CookieSerializeOptions = FastifyCookieSerializeOptions\n\n  export type GetTokenFn = (req: FastifyRequest) => string | void;\n  \n  export interface FastifyCsrfProtectionOptions {\n    csrfOpts?: CSRFOptions;\n    cookieKey?: string;\n    cookieOpts?: CookieSerializeOptions;\n    sessionKey?: string;\n    getUserInfo?: (req: FastifyRequest) => string;\n    getToken?: GetTokenFn;\n    sessionPlugin?: '@fastify/cookie' | '@fastify/session' | '@fastify/secure-session';\n  }\n\n  /**\n   * @deprecated Use FastifyCsrfProtectionOptions instead\n   */\n  export type FastifyCsrfOptions = FastifyCsrfProtectionOptions;\n\n  export const fastifyCsrfProtection: FastifyCsrfProtection\n  export { fastifyCsrfProtection as default }\n}\n\n\ndeclare function fastifyCsrfProtection(...params: Parameters<FastifyCsrfProtection>): ReturnType<FastifyCsrfProtection>\nexport = fastifyCsrfProtection\n", "import Fastify from 'fastify'\nimport FastifyCookie from '@fastify/cookie'\nimport FastifyCsrfProtection, { FastifyCsrfOptions } from '..'\nimport { expectError, expectDeprecated, expectType } from 'tsd'\nimport FastifySession from '@fastify/session'\n\nconst fastify = Fastify()\n\nasync function run() {\n  await fastify.register(FastifyCookie)\n  await fastify.register(FastifyCsrfProtection)\n\n  fastify.route({\n    method: 'GET',\n    url: '/',\n    handler: async (req, reply) => {\n      const token = reply.generateCsrf()\n      expectType<string>(token)\n      return token\n    }\n  })\n\n  fastify.route({\n    method: 'POST',\n    url: '/',\n    onRequest: fastify.csrfProtection,\n    handler: async (req, reply) => {\n      return req.body\n    }\n  })\n}\n\n\nfastify.register(FastifyCsrfProtection, { csrfOpts: { algorithm: 'sha1' } })\nexpectError(fastify.register(FastifyCsrfProtection, { csrfOpts: { algorithm: 1 } }))\n\nfastify.register(FastifySession)\nfastify.register(FastifyCsrfProtection, { getUserInfo(req) {\n  return req.session.get('username')\n}})\nexpectError(fastify.register(FastifyCsrfProtection, { getUserInfo: 'invalid' }))\n\nexpectDeprecated({} as FastifyCsrfOptions)\n"], "fixing_code": ["# @fastify/csrf-protection\n\n![CI](https://github.com/fastify/csrf-protection/workflows/CI/badge.svg)\n[![NPM version](https://img.shields.io/npm/v/@fastify/csrf-protection.svg?style=flat)](https://www.npmjs.com/package/@fastify/csrf-protection)\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](https://standardjs.com/)\n\nThis plugin helps developers protect their Fastify server against [CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery) attacks.\nIn order to fully protect against CSRF, developers should study [Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\nin depth. See also [pillarjs/understanding-csrf](https://github.com/pillarjs/understanding-csrf) as a good guide.\n\n## Security Disclaimer\n\nSecuring applications against CSRF is a _developer responsibility_ and it should not be fully trusted to any third party modules.\nWe do not claim that this module is able to protect an application without a clear study of CSRF, its impact and the needed mitigations.\n@fastify/csrf-protection provides a series of utilities that developers can use to secure their application.\nWe recommend using [@fastify/helmet](https://github.com/fastify/fastify-helmet) to implement some of those mitigations.\n\nSecurity is always a tradeoff between risk mitigation, functionality, performance, and developer experience.\nAs a result we will not consider a report of a plugin default configuration option as security\nvulnerability that might be unsafe in certain scenarios as long as this module provides a\nway to provide full mitigation through configuration.\n\n# Install\n```js\nnpm i @fastify/csrf-protection\n```\n\n## Usage\n\n\n### Use with [`@fastify/cookie`](https://github.com/fastify/@fastify/cookie)\n\nIf you use `@fastify/csrf-protection` with `@fastify/cookie`, the CSRF secret will be added to the response cookies.\nBy default, the cookie used will be named `_csrf`, but you can rename it via the `cookieKey` option.\nWhen `cookieOpts` are provided, they **override** the default cookie options. Make sure you restore any of the default options which provide sensible and secure defaults.\n\n```js\nfastify.register(require('@fastify/cookie'))\nfastify.register(require('@fastify/csrf-protection'))\n\n// if you want to sign cookies:\nfastify.register(require('@fastify/cookie'), { secret }) // See following section to ensure security\nfastify.register(require('@fastify/csrf-protection'), { cookieOpts: { signed: true } })\n\n// generate a token\nfastify.route({\n  method: 'GET',\n  path: '/',\n  handler: async (req, reply) => {\n    const token = await reply.generateCsrf()\n    return { token }\n  }\n})\n\n// protect a route\nfastify.route({\n  method: 'POST',\n  path: '/',\n  onRequest: fastify.csrfProtection,\n  handler: async (req, reply) => {\n    return req.body\n  }\n})\n```\n\n### Use with [`@fastify/session`](https://github.com/fastify/session)\n\nIf you use `@fastify/csrf-protection` with `@fastify/session`, the CSRF secret will be added to the session.\nBy default, the key used will be named `_csrf`, but you can rename it via the `sessionKey` option.\n\n```js\nfastify.register(require('@fastify-session'))\nfastify.register(require('@fastify/csrf-protection'), { sessionPlugin: '@fastify/session' })\n\n// generate a token\nfastify.route({\n  method: 'GET',\n  path: '/',\n  handler: async (req, reply) => {\n    const token = await reply.generateCsrf()\n    return { token }\n  }\n})\n\n// protect a route\nfastify.route({\n  method: 'POST',\n  path: '/',\n  onRequest: fastify.csrfProtection,\n  handler: async (req, reply) => {\n    return req.body\n  }\n})\n```\n\n### Use with [`@fastify/secure-session`](https://github.com/fastify/fastify-secure-session)\n\nIf you use `@fastify/csrf-protection` with `@fastify/secure-session`, the CSRF secret will be added to the session.\nBy default, the key used will be named `_csrf`, but you can rename it via the `sessionKey` option.\n\n```js\nfastify.register(require('@fastify/secure-session'))\nfastify.register(require('@fastify/csrf-protection'), { sessionPlugin: '@fastify/secure-session' })\n\n// generate a token\nfastify.route({\n  method: 'GET',\n  path: '/',\n  handler: async (req, reply) => {\n    const token = await reply.generateCsrf()\n    return { token }\n  }\n})\n\n// protect a route\nfastify.route({\n  method: 'POST',\n  path: '/',\n  onRequest: fastify.csrfProtection,\n  handler: async (req, reply) => {\n    return req.body\n  }\n})\n```\n\n### Securing the secret\n\nThe `secret` shown in the code above is strictly just an example. In all cases, you would need to make sure that the `secret` is:\n- **Never** hard-coded in the code or `.env` files or anywhere in the repository\n- Stored in some external services like KMS, Vault or something similar\n- Read at run-time and supplied to this option\n- Of significant character length to provide adequate entropy\n- Truly random sequence of characters (You could use [crypto-random-string](http://npm.im/crypto-random-string))\n\nApart from these safeguards, it is extremely important to [use HTTPS for your website/app](https://letsencrypt.org/) to avoid a bunch of other potential security issues like [MITM attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) etc.\n\n## API\n\n### Module Options\n\n| Options      | Description |\n| ----------- | ----------- |\n| `cookieKey` |  The name of the cookie where the CSRF secret will be stored, default `_csrf`.     |\n| `cookieOpts` |  The cookie serialization options. See [@fastify/cookie](https://github.com/fastify/fastify-cookie).    |\n| `sessionKey` |  The key where to store the CSRF secret in the session.     |\n| `getToken` |  A sync function to get the CSRF secret from the request.     |\n| `getUserInfo` |  A sync function to get the a string of user-specific information to prevent cookie tossing.     |\n| `sessionPlugin` |  The session plugin that you are using (if applicable).     |\n| `csrfOpts` |  The csrf options. See  [@fastify/csrf](https://github.com/fastify/csrf).     |\n\n### `reply.generateCsrf([opts])`\n\nGenerates a secret (if it is not already present) and returns a promise that resolves to the associated secret.\n\n```js\nconst token = await reply.generateCsrf()\n```\n\nYou can also pass the [cookie serialization](https://github.com/fastify/fastify-cookie) options to the function.\n\nThe option `userInfo` is required if `getUserInfo` has been specified in the module option.\nThe provided `userInfo` is hashed  inside the csrf token and it is not directly exposed.\nThis option is needed to protect against cookie tossing.\nThe option `csrfOpts.hmacKey` is required if `getUserInfo` has been specified in the module option in combination with using [@fastify/cookie](https://github.com/fastify/fastify-cookie) as sessionPlugin\n\n### `fastify.csrfProtection(request, reply, next)`\n\nA hook that you can use for protecting routes or entire plugins from CSRF attacks.\nGenerally, we recommend using an `onRequest` hook, but if you are sending the token\nvia the request body, then you must use a `preValidation` or `preHandler` hook.\n\n```js\n// protect the fastify instance\nfastify.addHook('onRequest', fastify.csrfProtection)\n\n// protect a single route\nfastify.route({\n  method: 'POST',\n  path: '/',\n  onRequest: fastify.csrfProtection,\n  handler: async (req, reply) => {\n    return req.body\n  }\n})\n```\n\nYou can configure the function to read the CSRF token via the `getToken` option, by default the following is used:\n\n```js\nfunction getToken (req) {\n  return (req.body && req.body._csrf) ||\n    req.headers['csrf-token'] ||\n    req.headers['xsrf-token'] ||\n    req.headers['x-csrf-token'] ||\n    req.headers['x-xsrf-token']\n}\n```\n\nIt is recommended to provide a custom `getToken` function for performance and [security](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#use-of-custom-request-headers) reasons.\n\n```js\nfastify.register(require('@fastify/csrf-protection'), \n  { getToken: function (req) { return req.headers['csrf-token'] } }\n)\n```\nor\n\n```js\nfastify.register(require('@fastify/csrf-protection'), \n  { getToken: (req) => req.headers['csrf-token'] }\n)\n```\n\n## License\n\n[MIT](./LICENSE)\n", "'use strict'\n\nconst assert = require('assert')\nconst fp = require('fastify-plugin')\nconst CSRF = require('@fastify/csrf')\nconst createError = require('@fastify/error')\n\nconst MissingCSRFSecretError = createError('FST_CSRF_MISSING_SECRET', 'Missing csrf secret', 403)\nconst InvalidCSRFTokenError = createError('FST_CSRF_INVALID_TOKEN', 'Invalid csrf token', 403)\n\nconst defaultOptions = {\n  cookieKey: '_csrf',\n  cookieOpts: { path: '/', sameSite: true, httpOnly: true },\n  sessionKey: '_csrf',\n  getToken: getTokenDefault,\n  getUserInfo: getUserInfoDefault,\n  sessionPlugin: '@fastify/cookie'\n}\n\nasync function fastifyCsrfProtection (fastify, opts) {\n  const {\n    cookieKey,\n    cookieOpts,\n    sessionKey,\n    getToken,\n    getUserInfo,\n    sessionPlugin\n  } = Object.assign({}, defaultOptions, opts)\n\n  const csrfOpts = opts && opts.csrfOpts ? opts.csrfOpts : {}\n\n  assert(typeof cookieKey === 'string', 'cookieKey should be a string')\n  assert(typeof sessionKey === 'string', 'sessionKey should be a string')\n  assert(typeof getToken === 'function', 'getToken should be a function')\n  assert(typeof getUserInfo === 'function', 'getUserInfo should be a function')\n  assert(typeof cookieOpts === 'object', 'cookieOpts should be a object')\n  assert(\n    ['@fastify/cookie', '@fastify/session', '@fastify/secure-session'].includes(sessionPlugin),\n    \"sessionPlugin should be one of the following: '@fastify/cookie', '@fastify/session', '@fastify/secure-session'\"\n  )\n\n  if (opts.getUserInfo) {\n    csrfOpts.userInfo = true\n  }\n\n  if (sessionPlugin === '@fastify/cookie' && csrfOpts.userInfo) {\n    assert(csrfOpts.hmacKey, 'csrfOpts.hmacKey is required')\n  }\n\n  const tokens = new CSRF(csrfOpts)\n\n  const isCookieSigned = cookieOpts && cookieOpts.signed\n\n  if (sessionPlugin === '@fastify/secure-session') {\n    fastify.decorateReply('generateCsrf', generateCsrfSecureSession)\n  } else if (sessionPlugin === '@fastify/session') {\n    fastify.decorateReply('generateCsrf', generateCsrfSession)\n  } else {\n    fastify.decorateReply('generateCsrf', generateCsrfCookie)\n  }\n\n  fastify.decorate('csrfProtection', csrfProtection)\n\n  let getSecret\n\n  if (sessionPlugin === '@fastify/secure-session') {\n    getSecret = function getSecret (req, reply) { return req.session.get(sessionKey) }\n  } else if (sessionPlugin === '@fastify/session') {\n    getSecret = function getSecret (req, reply) { return req.session[sessionKey] }\n  } else {\n    getSecret = function getSecret (req, reply) {\n      return isCookieSigned\n        ? reply.unsignCookie(req.cookies[cookieKey] || '').value\n        : req.cookies[cookieKey]\n    }\n  }\n\n  function generateCsrfCookie (opts) {\n    let secret = isCookieSigned\n      ? this.unsignCookie(this.request.cookies[cookieKey] || '').value\n      : this.request.cookies[cookieKey]\n    const userInfo = opts ? opts.userInfo : undefined\n    if (!secret) {\n      secret = tokens.secretSync()\n      this.setCookie(cookieKey, secret, Object.assign({}, cookieOpts, opts))\n    }\n    return tokens.create(secret, userInfo)\n  }\n\n  function generateCsrfSecureSession (opts) {\n    let secret = this.request.session.get(sessionKey)\n    if (!secret) {\n      secret = tokens.secretSync()\n      this.request.session.set(sessionKey, secret)\n    }\n    const userInfo = opts ? opts.userInfo : undefined\n    if (opts) {\n      this.request.session.options(opts)\n    }\n    return tokens.create(secret, userInfo)\n  }\n\n  function generateCsrfSession (opts) {\n    let secret = this.request.session[sessionKey]\n    const userInfo = opts ? opts.userInfo : undefined\n    if (!secret) {\n      secret = tokens.secretSync()\n      this.request.session[sessionKey] = secret\n    }\n    return tokens.create(secret, userInfo)\n  }\n\n  function csrfProtection (req, reply, next) {\n    const secret = getSecret(req, reply)\n    if (!secret) {\n      req.log.warn('Missing csrf secret')\n      return reply.send(new MissingCSRFSecretError())\n    }\n    if (!tokens.verify(secret, getToken(req), getUserInfo(req))) {\n      req.log.warn('Invalid csrf token')\n      return reply.send(new InvalidCSRFTokenError())\n    }\n    next()\n  }\n}\n\nfunction getTokenDefault (req) {\n  return (req.body && req.body._csrf) ||\n    req.headers['csrf-token'] ||\n    req.headers['xsrf-token'] ||\n    req.headers['x-csrf-token'] ||\n    req.headers['x-xsrf-token']\n}\n\nfunction getUserInfoDefault (req) {\n  return undefined\n}\n\nmodule.exports = fp(fastifyCsrfProtection, {\n  fastify: '4.x',\n  name: '@fastify/csrf-protection'\n})\nmodule.exports.default = fastifyCsrfProtection\nmodule.exports.fastifyCsrfProtection = fastifyCsrfProtection\n", "'use strict'\n\nconst { test } = require('tap')\nconst Fastify = require('fastify')\nconst fastifyCookie = require('@fastify/cookie')\nconst fastifySession = require('@fastify/session')\nconst fastifySecureSession = require('@fastify/secure-session')\nconst fastifyCsrf = require('../')\n\nconst sodium = require('sodium-native')\nconst key = Buffer.alloc(sodium.crypto_secretbox_KEYBYTES)\nsodium.randombytes_buf(key)\n\ntest('Cookies with User-Info', async t => {\n  const fastify = Fastify()\n  await fastify.register(fastifyCookie)\n  await fastify.register(fastifyCsrf, {\n    getUserInfo (req) {\n      return userInfoDB[req.body.username]\n    },\n    csrfOpts: {\n      hmacKey: 'foo'\n    }\n  })\n\n  const userInfoDB = {\n    foo: 'a42'\n  }\n\n  fastify.post('/login', async (req, reply) => {\n    const token = await reply.generateCsrf({ userInfo: userInfoDB[req.body.username] })\n    return { token }\n  })\n\n  // must be preHandler as we are parsing the body\n  fastify.post('/', { preHandler: fastify.csrfProtection }, async (req, reply) => {\n    return req.body\n  })\n\n  const response1 = await fastify.inject({\n    method: 'POST',\n    path: '/login',\n    body: {\n      username: 'foo'\n    }\n  })\n\n  t.equal(response1.statusCode, 200)\n\n  const cookie1 = response1.cookies[0]\n  const { token } = response1.json()\n\n  const response2 = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    cookies: {\n      _csrf: cookie1.value\n    },\n    body: {\n      _csrf: token,\n      username: 'foo'\n    }\n  })\n\n  t.equal(response2.statusCode, 200)\n})\n\ntest('Session with User-Info', async t => {\n  const fastify = Fastify()\n  await fastify.register(fastifyCookie)\n  await fastify.register(fastifySession, {\n    secret: 'a'.repeat(32),\n    cookie: { path: '/', secure: false }\n  })\n  await fastify.register(fastifyCsrf, {\n    sessionPlugin: '@fastify/session',\n    getUserInfo (req) {\n      return req.session.username\n    },\n    csrfOpts: {\n      hmacKey: 'foo'\n    }\n  })\n\n  fastify.post('/login', async (req, reply) => {\n    req.session.username = req.body.username\n    const token = await reply.generateCsrf({ userInfo: req.body.username })\n    return { token }\n  })\n\n  // must be preHandler as we are parsing the body\n  fastify.post('/', { preHandler: fastify.csrfProtection }, async (req, reply) => {\n    return req.body\n  })\n\n  const response1 = await fastify.inject({\n    method: 'POST',\n    path: '/login',\n    body: {\n      username: 'foo'\n    }\n  })\n\n  t.equal(response1.statusCode, 200)\n\n  const cookie1 = response1.cookies[0]\n  const { token } = response1.json()\n\n  const response2 = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    cookies: {\n      sessionId: cookie1.value\n    },\n    body: {\n      _csrf: token,\n      username: 'foo'\n    }\n  })\n\n  t.equal(response2.statusCode, 200)\n})\n\ntest('SecureSession with User-Info', async t => {\n  const fastify = Fastify()\n  await fastify.register(fastifySecureSession, { key, cookie: { path: '/', secure: false } })\n  await fastify.register(fastifyCsrf, {\n    sessionPlugin: '@fastify/secure-session',\n    getUserInfo (req) {\n      return req.session.get('username')\n    },\n    csrfOpts: {\n      hmacKey: 'foo'\n    }\n  })\n\n  fastify.post('/login', async (req, reply) => {\n    req.session.set('username', req.body.username)\n    const token = await reply.generateCsrf({ userInfo: req.body.username })\n    return { token }\n  })\n\n  // must be preHandler as we are parsing the body\n  fastify.post('/', { preHandler: fastify.csrfProtection }, async (req, reply) => {\n    return req.body\n  })\n\n  const response1 = await fastify.inject({\n    method: 'POST',\n    path: '/login',\n    body: {\n      username: 'foo'\n    }\n  })\n\n  t.equal(response1.statusCode, 200)\n\n  const cookie1 = response1.cookies[0]\n  const { token } = response1.json()\n\n  const response2 = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    cookies: {\n      session: cookie1.value\n    },\n    body: {\n      _csrf: token,\n      username: 'foo'\n    }\n  })\n\n  t.equal(response2.statusCode, 200)\n})\n\ntest('Validate presence of hmac key with User-Info /1', async (t) => {\n  const fastify = Fastify()\n  await fastify.register(fastifyCookie)\n\n  await t.rejects(fastify.register(fastifyCsrf, {\n    getUserInfo (req) {\n      return req.session.get('username')\n    }\n  }), Error('csrfOpts.hmacKey is required'))\n})\n\ntest('Validate presence of hmac key with User-Info /2', async (t) => {\n  const fastify = Fastify()\n  await fastify.register(fastifyCookie)\n\n  await t.rejects(fastify.register(fastifyCsrf, {\n    getUserInfo (req) {\n      return req.session.get('username')\n    },\n    sessionPlugin: '@fastify/cookie'\n  }), Error('csrfOpts.hmacKey is required'))\n})\n\ntest('Validate presence of hmac key with User-Info /3', async (t) => {\n  const fastify = Fastify()\n  await fastify.register(fastifyCookie)\n\n  await t.rejects(fastify.register(fastifyCsrf, {\n    getUserInfo (req) {\n      return req.session.get('username')\n    },\n    csrfOpts: {\n      hmacKey: undefined\n    }\n  }), Error('csrfOpts.hmacKey is required'))\n})\n\ntest('Validate presence of hmac key with User-Info /4', async (t) => {\n  const fastify = Fastify()\n  await fastify.register(fastifyCookie)\n\n  await t.rejects(fastify.register(fastifyCsrf, {\n    getUserInfo (req) {\n      return req.session.get('username')\n    },\n    sessionPlugin: '@fastify/cookie',\n    csrfOpts: {\n      hmacKey: undefined\n    }\n  }), Error('csrfOpts.hmacKey is required'))\n})\n\ntest('Validate presence of hmac key with User-Info /5', async (t) => {\n  const fastify = Fastify()\n  await fastify.register(fastifySecureSession, { key, cookie: { path: '/', secure: false } })\n\n  await t.resolves(fastify.register(fastifyCsrf, {\n    getUserInfo (req) {\n      return req.session.get('username')\n    },\n    sessionPlugin: '@fastify/secure-session'\n  }))\n})\n\ntest('Validate presence of hmac key with User-Info /6', async (t) => {\n  const fastify = Fastify()\n  await fastify.register(fastifySecureSession, { key, cookie: { path: '/', secure: false } })\n\n  await t.resolves(fastify.register(fastifyCsrf, {\n    getUserInfo (req) {\n      return req.session.get('username')\n    },\n    sessionPlugin: '@fastify/secure-session',\n    csrfOpts: {\n      hmacKey: 'foo'\n    }\n  }))\n})\n", "/// <reference types=\"node\" />\n\nimport { FastifyPluginAsync, FastifyRequest } from 'fastify';\nimport { Options as CSRFOptions } from \"@fastify/csrf\";\nimport { CookieSerializeOptions as FastifyCookieSerializeOptions } from \"@fastify/cookie\";\n\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    csrfProtection(req: FastifyRequest, reply: FastifyReply, done: () => void): any;\n  }\n\n  interface FastifyReply {\n    /**\n     * Generate a token and configure the secret if needed\n     * @param options Serialize options\n     */\n    generateCsrf(\n      options?: fastifyCsrfProtection.CookieSerializeOptions\n    ): string;\n  }\n}\n\ntype FastifyCsrfProtection = FastifyPluginAsync<fastifyCsrfProtection.FastifyCsrfOptions>;\n\ndeclare namespace fastifyCsrfProtection {\n  export type CookieSerializeOptions = FastifyCookieSerializeOptions\n\n  export type GetTokenFn = (req: FastifyRequest) => string | void;\n\n  interface FastifyCsrfProtectionOptionsBase {\n    cookieKey?: string;\n    cookieOpts?: CookieSerializeOptions;\n    sessionKey?: string;\n    getUserInfo?: (req: FastifyRequest) => string;\n    getToken?: GetTokenFn;\n  }\n\n  interface FastifyCsrfProtectionOptionsFastifyCookie {\n    sessionPlugin?: '@fastify/cookie';\n    csrfOpts: Omit<CSRFOptions, 'hmacKey'> & Required<Pick<CSRFOptions, 'hmacKey'>>;\n  }\n\n  interface FastifyCsrfProtectionOptionsFastifySession {\n    sessionPlugin: '@fastify/session';\n    csrfOpts?: CSRFOptions;\n  }\n\n  interface FastifyCsrfProtectionOptionsFastifySecureSession {\n    sessionPlugin: '@fastify/secure-session';\n    csrfOpts?: CSRFOptions;\n  }\n\n  export type FastifyCsrfProtectionOptions = FastifyCsrfProtectionOptionsBase & (\n    FastifyCsrfProtectionOptionsFastifyCookie |\n    FastifyCsrfProtectionOptionsFastifySession |\n    FastifyCsrfProtectionOptionsFastifySecureSession\n  )\n\n  /**\n   * @deprecated Use FastifyCsrfProtectionOptions instead\n   */\n  export type FastifyCsrfOptions = FastifyCsrfProtectionOptions;\n\n  export const fastifyCsrfProtection: FastifyCsrfProtection\n  export { fastifyCsrfProtection as default }\n}\n\n\ndeclare function fastifyCsrfProtection(...params: Parameters<FastifyCsrfProtection>): ReturnType<FastifyCsrfProtection>\nexport = fastifyCsrfProtection\n", "import Fastify from 'fastify'\nimport FastifyCookie from '@fastify/cookie'\nimport FastifyCsrfProtection, { FastifyCsrfOptions } from '..'\nimport { expectError, expectDeprecated, expectType } from 'tsd'\nimport FastifySession from '@fastify/session'\n\nconst fastify = Fastify()\n\nasync function run() {\n  await fastify.register(FastifyCookie)\n  await fastify.register(FastifyCsrfProtection)\n\n  fastify.route({\n    method: 'GET',\n    url: '/',\n    handler: async (req, reply) => {\n      const token = reply.generateCsrf()\n      expectType<string>(token)\n      return token\n    }\n  })\n\n  fastify.route({\n    method: 'POST',\n    url: '/',\n    onRequest: fastify.csrfProtection,\n    handler: async (req, reply) => {\n      return req.body\n    }\n  })\n}\n\n\nfastify.register(FastifyCsrfProtection, { csrfOpts: { algorithm: 'sha1', hmacKey: 'hmac' } })\nexpectError(fastify.register(FastifyCsrfProtection, { csrfOpts: { algorithm: 1 } }))\n\nfastify.register(FastifySession)\nfastify.register(FastifyCsrfProtection, {\n  csrfOpts: {\n    hmacKey: '123'\n  },\n  getUserInfo(req) {\n    return req.session.get('username')\n  }\n})\nexpectError(fastify.register(FastifyCsrfProtection, { getUserInfo: 'invalid' }))\n\nfastify.register(FastifyCsrfProtection, { csrfOpts: { hmacKey: 'hmac' }, sessionPlugin: '@fastify/cookie' })\nfastify.register(FastifyCsrfProtection, { csrfOpts: { hmacKey: 'hmac' } })\nexpectError(fastify.register(FastifyCsrfProtection, { }))\nexpectError(fastify.register(FastifyCsrfProtection, { csrfOpts: { }}))\nexpectError(fastify.register(FastifyCsrfProtection, { sessionPlugin: '@fastify/cookie', csrfOpts: { }}))\nfastify.register(FastifyCsrfProtection, { csrfOpts: { }, sessionPlugin: '@fastify/session' })\nfastify.register(FastifyCsrfProtection, { csrfOpts: { }, sessionPlugin: '@fastify/secure-session' })\nfastify.register(FastifyCsrfProtection, { sessionPlugin: '@fastify/session' })\nfastify.register(FastifyCsrfProtection, { sessionPlugin: '@fastify/secure-session' })\n\nexpectDeprecated({} as FastifyCsrfOptions)\n"], "filenames": ["README.md", "index.js", "test/user-info.test.js", "types/index.d.ts", "types/index.test-d.ts"], "buggy_code_start_loc": [163, 44, 19, 29, 34], "buggy_code_end_loc": [163, 44, 165, 38, 42], "fixing_code_start_loc": [164, 45, 20, 29, 34], "fixing_code_end_loc": [165, 50, 254, 58, 58], "type": "CWE-352", "message": "@fastify/csrf-protection is a plugin which helps protect Fastify servers against CSRF attacks. The CSRF protection enforced by the @fastify/csrf-protection library in combination with @fastify/cookie can be bypassed from network and same-site attackers under certain conditions. @fastify/csrf-protection supports an optional userInfo parameter that binds the CSRF token to the user. This parameter has been introduced to prevent cookie-tossing attacks as a fix for CVE-2021-29624. Whenever userInfo parameter is missing, or its value can be predicted for the target user account, network and same-site attackers can 1. fixate a _csrf cookie in the victim's browser, and 2. forge CSRF tokens that are valid for the victim's session. This allows attackers to bypass the CSRF protection mechanism. As a fix, @fastify/csrf-protection starting from version 6.3.0 (and v4.1.0) includes a server-defined secret hmacKey that cryptographically binds the CSRF token to the value of the _csrf cookie and the userInfo parameter, making tokens non-spoofable by attackers. This protection is effective as long as the userInfo parameter is unique for each user. This is patched in versions 6.3.0 and v4.1.0. Users are advised to upgrade. Users unable to upgrade may use a random, non-predictable userInfo parameter for each user as a mitigation.", "other": {"cve": {"id": "CVE-2023-27495", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-20T18:15:07.233", "lastModified": "2023-05-02T02:07:27.720", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "@fastify/csrf-protection is a plugin which helps protect Fastify servers against CSRF attacks. The CSRF protection enforced by the @fastify/csrf-protection library in combination with @fastify/cookie can be bypassed from network and same-site attackers under certain conditions. @fastify/csrf-protection supports an optional userInfo parameter that binds the CSRF token to the user. This parameter has been introduced to prevent cookie-tossing attacks as a fix for CVE-2021-29624. Whenever userInfo parameter is missing, or its value can be predicted for the target user account, network and same-site attackers can 1. fixate a _csrf cookie in the victim's browser, and 2. forge CSRF tokens that are valid for the victim's session. This allows attackers to bypass the CSRF protection mechanism. As a fix, @fastify/csrf-protection starting from version 6.3.0 (and v4.1.0) includes a server-defined secret hmacKey that cryptographically binds the CSRF token to the value of the _csrf cookie and the userInfo parameter, making tokens non-spoofable by attackers. This protection is effective as long as the userInfo parameter is unique for each user. This is patched in versions 6.3.0 and v4.1.0. Users are advised to upgrade. Users unable to upgrade may use a random, non-predictable userInfo parameter for each user as a mitigation."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fastify:csrf-protection:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.1.0", "matchCriteriaId": "FFFBC7FD-D310-411C-AD25-A1526EDC05BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fastify:csrf-protection:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "6.3.0", "matchCriteriaId": "38CB7906-F94A-4915-B657-11A79B46985A"}]}]}], "references": [{"url": "https://github.com/fastify/csrf-protection/commit/be3e5761f37aa05c7c1ac8ed44499c51ecec8058", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/fastify/csrf-protection/security/advisories/GHSA-qrgf-9gpc-vrxw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://www.cvedetails.com/cve/CVE-2021-29624", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fastify/csrf-protection/commit/be3e5761f37aa05c7c1ac8ed44499c51ecec8058"}}