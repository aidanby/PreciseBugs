{"buggy_code": ["/****************************************************************************\n**\n** Copyright (C) 2016 The Qt Company Ltd.\n** Contact: https://www.qt.io/licensing/\n**\n** This file is part of the QtGui module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see https://www.qt.io/terms-conditions. For further\n** information use the contact form at https://www.qt.io/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 3 as published by the Free Software\n** Foundation and appearing in the file LICENSE.LGPL3 included in the\n** packaging of this file. Please review the following information to\n** ensure the GNU Lesser General Public License version 3 requirements\n** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 2.0 or (at your option) the GNU General\n** Public license version 3 or any later version approved by the KDE Free\n** Qt Foundation. The licenses are as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3\n** included in the packaging of this file. Please review the following\n** information to ensure the GNU General Public License requirements will\n** be met: https://www.gnu.org/licenses/gpl-2.0.html and\n** https://www.gnu.org/licenses/gpl-3.0.html.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include \"qpaintengineex_p.h\"\n#include \"qpainter_p.h\"\n#include \"qstroker_p.h\"\n#include \"qbezier_p.h\"\n#include <private/qpainterpath_p.h>\n#include <private/qfontengine_p.h>\n#include <private/qstatictext_p.h>\n\n#include <qvarlengtharray.h>\n#include <qdebug.h>\n\n\nQT_BEGIN_NAMESPACE\n\n#if !defined(QT_MAX_CACHED_GLYPH_SIZE)\n#  define QT_MAX_CACHED_GLYPH_SIZE 64\n#endif\n\n/*******************************************************************************\n *\n * class QVectorPath\n *\n */\nQVectorPath::~QVectorPath()\n{\n    if (m_hints & ShouldUseCacheHint) {\n        CacheEntry *e = m_cache;\n        while (e) {\n            if (e->data)\n                e->cleanup(e->engine, e->data);\n            CacheEntry *n = e->next;\n            delete e;\n            e = n;\n        }\n    }\n}\n\n\nQRectF QVectorPath::controlPointRect() const\n{\n    if (m_hints & ControlPointRect)\n        return QRectF(QPointF(m_cp_rect.x1, m_cp_rect.y1), QPointF(m_cp_rect.x2, m_cp_rect.y2));\n\n    if (m_count == 0) {\n        m_cp_rect.x1 = m_cp_rect.x2 = m_cp_rect.y1 = m_cp_rect.y2 = 0;\n        m_hints |= ControlPointRect;\n        return QRectF(QPointF(m_cp_rect.x1, m_cp_rect.y1), QPointF(m_cp_rect.x2, m_cp_rect.y2));\n    }\n    Q_ASSERT(m_points && m_count > 0);\n\n    const qreal *pts = m_points;\n    m_cp_rect.x1 = m_cp_rect.x2 = *pts;\n    ++pts;\n    m_cp_rect.y1 = m_cp_rect.y2 = *pts;\n    ++pts;\n\n    const qreal *epts = m_points + (m_count << 1);\n    while (pts < epts) {\n        qreal x = *pts;\n        if (x < m_cp_rect.x1) m_cp_rect.x1 = x;\n        else if (x > m_cp_rect.x2) m_cp_rect.x2 = x;\n        ++pts;\n\n        qreal y = *pts;\n        if (y < m_cp_rect.y1) m_cp_rect.y1 = y;\n        else if (y > m_cp_rect.y2) m_cp_rect.y2 = y;\n        ++pts;\n    }\n\n    m_hints |= ControlPointRect;\n    return QRectF(QPointF(m_cp_rect.x1, m_cp_rect.y1), QPointF(m_cp_rect.x2, m_cp_rect.y2));\n}\n\n\nQVectorPath::CacheEntry *QVectorPath::addCacheData(QPaintEngineEx *engine, void *data,\n                                                   qvectorpath_cache_cleanup cleanup) const{\n    Q_ASSERT(!lookupCacheData(engine));\n    if ((m_hints & IsCachedHint) == 0) {\n        m_cache = nullptr;\n        m_hints |= IsCachedHint;\n    }\n    CacheEntry *e = new CacheEntry;\n    e->engine = engine;\n    e->data = data;\n    e->cleanup = cleanup;\n    e->next = m_cache;\n    m_cache = e;\n    return m_cache;\n}\n\n\nconst QVectorPath &qtVectorPathForPath(const QPainterPath &path)\n{\n    Q_ASSERT(path.d_func());\n    return path.d_func()->vectorPath();\n}\n\n#ifndef QT_NO_DEBUG_STREAM\nQDebug Q_GUI_EXPORT &operator<<(QDebug &s, const QVectorPath &path)\n{\n    QDebugStateSaver saver(s);\n    QRectF rf = path.controlPointRect();\n    s << \"QVectorPath(size:\" << path.elementCount()\n      << \" hints:\" << Qt::hex << path.hints()\n      << rf << ')';\n    return s;\n}\n#endif\n\n/*******************************************************************************\n *\n * class QPaintEngineExPrivate:\n *\n */\n\n\nstruct StrokeHandler {\n    StrokeHandler(int reserve) : pts(reserve), types(reserve) {}\n    QDataBuffer<qreal> pts;\n    QDataBuffer<QPainterPath::ElementType> types;\n};\n\n\nQPaintEngineExPrivate::QPaintEngineExPrivate()\n    : dasher(&stroker),\n      strokeHandler(nullptr),\n      activeStroker(nullptr),\n      strokerPen(Qt::NoPen)\n{\n}\n\n\nQPaintEngineExPrivate::~QPaintEngineExPrivate()\n{\n    delete strokeHandler;\n}\n\n\nvoid QPaintEngineExPrivate::replayClipOperations()\n{\n    Q_Q(QPaintEngineEx);\n\n    QPainter *p = q->painter();\n    if (!p || !p->d_ptr)\n        return;\n\n    const QList<QPainterClipInfo> &clipInfo = p->d_ptr->state->clipInfo;\n\n    QTransform transform = q->state()->matrix;\n\n    for (const QPainterClipInfo &info : clipInfo) {\n\n        if (info.matrix != q->state()->matrix) {\n            q->state()->matrix = info.matrix;\n            q->transformChanged();\n        }\n\n        switch (info.clipType) {\n        case QPainterClipInfo::RegionClip:\n            q->clip(info.region, info.operation);\n            break;\n        case QPainterClipInfo::PathClip:\n            q->clip(info.path, info.operation);\n            break;\n        case QPainterClipInfo::RectClip:\n            q->clip(info.rect, info.operation);\n            break;\n        case QPainterClipInfo::RectFClip: {\n            qreal right = info.rectf.x() + info.rectf.width();\n            qreal bottom = info.rectf.y() + info.rectf.height();\n            qreal pts[] = { info.rectf.x(), info.rectf.y(),\n                            right, info.rectf.y(),\n                            right, bottom,\n                            info.rectf.x(), bottom };\n            QVectorPath vp(pts, 4, nullptr, QVectorPath::RectangleHint);\n            q->clip(vp, info.operation);\n            break;\n            }\n        }\n    }\n\n    if (transform != q->state()->matrix) {\n        q->state()->matrix = transform;\n        q->transformChanged();\n    }\n}\n\n\nbool QPaintEngineExPrivate::hasClipOperations() const\n{\n    Q_Q(const QPaintEngineEx);\n\n    QPainter *p = q->painter();\n    if (!p || !p->d_ptr)\n        return false;\n\n    return !p->d_ptr->state->clipInfo.isEmpty();\n}\n\n/*******************************************************************************\n *\n * class QPaintEngineEx:\n *\n */\n\nstatic const QPainterPath::ElementType qpaintengineex_ellipse_types[] = {\n    QPainterPath::MoveToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement\n};\n\nstatic const QPainterPath::ElementType qpaintengineex_line_types_16[] = {\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement\n};\n\nstatic const QPainterPath::ElementType qpaintengineex_rect4_types_32[] = {\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 1\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 2\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 3\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 4\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 5\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 6\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 7\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 8\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 9\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 10\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 11\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 12\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 13\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 14\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 15\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 16\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 17\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 18\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 19\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 20\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 21\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 22\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 23\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 24\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 25\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 26\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 27\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 28\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 29\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 30\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 31\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 32\n};\n\n\nstatic const QPainterPath::ElementType qpaintengineex_roundedrect_types[] = {\n    QPainterPath::MoveToElement,\n    QPainterPath::LineToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::LineToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::LineToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::LineToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement\n};\n\n\n\nstatic void qpaintengineex_moveTo(qreal x, qreal y, void *data) {\n    ((StrokeHandler *) data)->pts.add(x);\n    ((StrokeHandler *) data)->pts.add(y);\n    ((StrokeHandler *) data)->types.add(QPainterPath::MoveToElement);\n}\n\nstatic void qpaintengineex_lineTo(qreal x, qreal y, void *data) {\n    ((StrokeHandler *) data)->pts.add(x);\n    ((StrokeHandler *) data)->pts.add(y);\n    ((StrokeHandler *) data)->types.add(QPainterPath::LineToElement);\n}\n\nstatic void qpaintengineex_cubicTo(qreal c1x, qreal c1y, qreal c2x, qreal c2y, qreal ex, qreal ey, void *data) {\n    ((StrokeHandler *) data)->pts.add(c1x);\n    ((StrokeHandler *) data)->pts.add(c1y);\n    ((StrokeHandler *) data)->types.add(QPainterPath::CurveToElement);\n\n    ((StrokeHandler *) data)->pts.add(c2x);\n    ((StrokeHandler *) data)->pts.add(c2y);\n    ((StrokeHandler *) data)->types.add(QPainterPath::CurveToDataElement);\n\n    ((StrokeHandler *) data)->pts.add(ex);\n    ((StrokeHandler *) data)->pts.add(ey);\n    ((StrokeHandler *) data)->types.add(QPainterPath::CurveToDataElement);\n}\n\nQPaintEngineEx::QPaintEngineEx()\n    : QPaintEngine(*new QPaintEngineExPrivate, AllFeatures)\n{\n    extended = true;\n}\n\nQPaintEngineEx::QPaintEngineEx(QPaintEngineExPrivate &data)\n    : QPaintEngine(data, AllFeatures)\n{\n    extended = true;\n}\n\nQPainterState *QPaintEngineEx::createState(QPainterState *orig) const\n{\n    if (!orig)\n        return new QPainterState;\n    return new QPainterState(orig);\n}\n\nQ_GUI_EXPORT extern bool qt_scaleForTransform(const QTransform &transform, qreal *scale); // qtransform.cpp\n\nvoid QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n\n    Q_D(QPaintEngineEx);\n\n    if (path.isEmpty())\n        return;\n\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        // Check to avoid generating unwieldy amount of dashes that will not be visible anyway\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (extent / patternLength > 10000) {\n            // approximate stream of tiny dashes with semi-transparent solid line\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n\n    if (!d->activeStroker) {\n        return;\n    }\n\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n\n    const qreal *lastPoint = points + (pointCount<<1);\n\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n\n    // Some engines might decide to optimize for the non-shape hint later on...\n    uint flags = QVectorPath::WindingFill;\n\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n\n    // ### Perspective Xforms are currently not supported...\n    if (!pen.isCosmetic()) {\n        // We include cosmetic pens in this case to avoid having to\n        // change the current transform. Normal transformed,\n        // non-cosmetic pens will be transformed as part of fill\n        // later, so they are also covered here..\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n\n        if (!d->strokeHandler->types.size()) // an empty path...\n            return;\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        // For cosmetic pens we need a bit of trickery... We to process xform the input points\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n\n        fill(strokePath, brush);\n\n        state()->matrix = xform;\n        transformChanged();\n    }\n}\n\nvoid QPaintEngineEx::draw(const QVectorPath &path)\n{\n    const QBrush &brush = state()->brush;\n    if (qbrush_style(brush) != Qt::NoBrush)\n        fill(path, brush);\n\n    const QPen &pen = state()->pen;\n    if (qpen_style(pen) != Qt::NoPen && qbrush_style(qpen_brush(pen)) != Qt::NoBrush)\n        stroke(path, pen);\n}\n\n\nvoid QPaintEngineEx::clip(const QRect &r, Qt::ClipOperation op)\n{\n    qreal right = r.x() + r.width();\n    qreal bottom = r.y() + r.height();\n    qreal pts[] = { qreal(r.x()), qreal(r.y()),\n                    right, qreal(r.y()),\n                    right, bottom,\n                    qreal(r.x()), bottom,\n                    qreal(r.x()), qreal(r.y()) };\n    QVectorPath vp(pts, 5, nullptr, QVectorPath::RectangleHint);\n    clip(vp, op);\n}\n\nvoid QPaintEngineEx::clip(const QRegion &region, Qt::ClipOperation op)\n{\n    const auto rectsInRegion = region.rectCount();\n    if (rectsInRegion == 1) {\n        clip(*region.begin(), op);\n    } else if (rectsInRegion <= 32) {\n        qreal pts[2*32*4];\n        int pos = 0;\n        for (QRect r : region) {\n            qreal x1 = r.x();\n            qreal y1 = r.y();\n            qreal x2 = r.x() + r.width();\n            qreal y2 = r.y() + r.height();\n\n            pts[pos++] = x1;\n            pts[pos++] = y1;\n\n            pts[pos++] = x2;\n            pts[pos++] = y1;\n\n            pts[pos++] = x2;\n            pts[pos++] = y2;\n\n            pts[pos++] = x1;\n            pts[pos++] = y2;\n        }\n        QVectorPath vp(pts, rectsInRegion * 4, qpaintengineex_rect4_types_32);\n        clip(vp, op);\n    } else {\n        QVarLengthArray<qreal> pts(rectsInRegion * 2 * 4);\n        QVarLengthArray<QPainterPath::ElementType> types(rectsInRegion * 4);\n        int ppos = 0;\n        int tpos = 0;\n\n        for (QRect r : region) {\n            qreal x1 = r.x();\n            qreal y1 = r.y();\n            qreal x2 = r.x() + r.width();\n            qreal y2 = r.y() + r.height();\n\n            pts[ppos++] = x1;\n            pts[ppos++] = y1;\n\n            pts[ppos++] = x2;\n            pts[ppos++] = y1;\n\n            pts[ppos++] = x2;\n            pts[ppos++] = y2;\n\n            pts[ppos++] = x1;\n            pts[ppos++] = y2;\n\n            types[tpos++] = QPainterPath::MoveToElement;\n            types[tpos++] = QPainterPath::LineToElement;\n            types[tpos++] = QPainterPath::LineToElement;\n            types[tpos++] = QPainterPath::LineToElement;\n        }\n\n        QVectorPath vp(pts.data(), rectsInRegion * 4, types.data());\n        clip(vp, op);\n    }\n\n}\n\nvoid QPaintEngineEx::clip(const QPainterPath &path, Qt::ClipOperation op)\n{\n    if (path.isEmpty()) {\n        QVectorPath vp(nullptr, 0);\n        clip(vp, op);\n    } else {\n        clip(qtVectorPathForPath(path), op);\n    }\n}\n\nvoid QPaintEngineEx::fillRect(const QRectF &r, const QBrush &brush)\n{\n    qreal pts[] = { r.x(), r.y(), r.x() + r.width(), r.y(),\n                    r.x() + r.width(), r.y() + r.height(), r.x(), r.y() + r.height() };\n    QVectorPath vp(pts, 4, nullptr, QVectorPath::RectangleHint);\n    fill(vp, brush);\n}\n\nvoid QPaintEngineEx::fillRect(const QRectF &r, const QColor &color)\n{\n    fillRect(r, QBrush(color));\n}\n\nvoid QPaintEngineEx::drawRects(const QRect *rects, int rectCount)\n{\n    for (int i=0; i<rectCount; ++i) {\n        const QRect &r = rects[i];\n        // ### Is there a one off here?\n        qreal right = r.x() + r.width();\n        qreal bottom = r.y() + r.height();\n        qreal pts[] = { qreal(r.x()), qreal(r.y()),\n                        right, qreal(r.y()),\n                        right, bottom,\n                        qreal(r.x()), bottom,\n                        qreal(r.x()), qreal(r.y()) };\n        QVectorPath vp(pts, 5, nullptr, QVectorPath::RectangleHint);\n        draw(vp);\n    }\n}\n\nvoid QPaintEngineEx::drawRects(const QRectF *rects, int rectCount)\n{\n    for (int i=0; i<rectCount; ++i) {\n        const QRectF &r = rects[i];\n        qreal right = r.x() + r.width();\n        qreal bottom = r.y() + r.height();\n        qreal pts[] = { r.x(), r.y(),\n                        right, r.y(),\n                        right, bottom,\n                        r.x(), bottom,\n                        r.x(), r.y() };\n        QVectorPath vp(pts, 5, nullptr, QVectorPath::RectangleHint);\n        draw(vp);\n    }\n}\n\n\nvoid QPaintEngineEx::drawRoundedRect(const QRectF &rect, qreal xRadius, qreal yRadius,\n                                     Qt::SizeMode mode)\n{\n    qreal x1 = rect.left();\n    qreal x2 = rect.right();\n    qreal y1 = rect.top();\n    qreal y2 = rect.bottom();\n\n    if (mode == Qt::RelativeSize) {\n        xRadius = xRadius * rect.width() / 200.;\n        yRadius = yRadius * rect.height() / 200.;\n    }\n\n    xRadius = qMin(xRadius, rect.width() / 2);\n    yRadius = qMin(yRadius, rect.height() / 2);\n\n    qreal pts[] = {\n        x1 + xRadius, y1,                   // MoveTo\n        x2 - xRadius, y1,                   // LineTo\n        x2 - (1 - KAPPA) * xRadius, y1,     // CurveTo\n        x2, y1 + (1 - KAPPA) * yRadius,\n        x2, y1 + yRadius,\n        x2, y2 - yRadius,                   // LineTo\n        x2, y2 - (1 - KAPPA) * yRadius,     // CurveTo\n        x2 - (1 - KAPPA) * xRadius, y2,\n        x2 - xRadius, y2,\n        x1 + xRadius, y2,                   // LineTo\n        x1 + (1 - KAPPA) * xRadius, y2,           // CurveTo\n        x1, y2 - (1 - KAPPA) * yRadius,\n        x1, y2 - yRadius,\n        x1, y1 + yRadius,                   // LineTo\n        x1, y1 + (1 - KAPPA) * yRadius,           // CurveTo\n        x1 + (1 - KAPPA) * xRadius, y1,\n        x1 + xRadius, y1\n    };\n\n    QVectorPath path(pts, 17, qpaintengineex_roundedrect_types, QVectorPath::RoundedRectHint);\n    draw(path);\n}\n\n\n\nvoid QPaintEngineEx::drawLines(const QLine *lines, int lineCount)\n{\n    int elementCount = lineCount << 1;\n    while (elementCount > 0) {\n        int count = qMin(elementCount, 32);\n\n        qreal pts[64];\n        int count2 = count<<1;\n        for (int i=0; i<count2; ++i)\n            pts[i] = ((const int *) lines)[i];\n\n        QVectorPath path(pts, count, qpaintengineex_line_types_16, QVectorPath::LinesHint);\n        stroke(path, state()->pen);\n\n        elementCount -= 32;\n        lines += 16;\n    }\n}\n\nvoid QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)\n{\n    int elementCount = lineCount << 1;\n    while (elementCount > 0) {\n        int count = qMin(elementCount, 32);\n\n        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,\n                         QVectorPath::LinesHint);\n        stroke(path, state()->pen);\n\n        elementCount -= 32;\n        lines += 16;\n    }\n}\n\nvoid QPaintEngineEx::drawEllipse(const QRectF &r)\n{\n    qreal pts[26]; // QPointF[13] without constructors...\n    union {\n        qreal *ptr;\n        QPointF *points;\n    } x;\n    x.ptr = pts;\n\n    int point_count = 0;\n    x.points[0] = qt_curves_for_arc(r, 0, -360, x.points + 1, &point_count);\n    if (point_count == 0)\n        return;\n    QVectorPath vp((qreal *) pts, point_count + 1, qpaintengineex_ellipse_types, QVectorPath::EllipseHint);\n    draw(vp);\n}\n\nvoid QPaintEngineEx::drawEllipse(const QRect &r)\n{\n    drawEllipse(QRectF(r));\n}\n\nvoid QPaintEngineEx::drawPath(const QPainterPath &path)\n{\n    if (!path.isEmpty())\n        draw(qtVectorPathForPath(path));\n}\n\n\nvoid QPaintEngineEx::drawPoints(const QPointF *points, int pointCount)\n{\n    QPen pen = state()->pen;\n    if (pen.capStyle() == Qt::FlatCap)\n        pen.setCapStyle(Qt::SquareCap);\n\n    if (pen.brush().isOpaque()) {\n        while (pointCount > 0) {\n            int count = qMin(pointCount, 16);\n            qreal pts[64];\n            int oset = -1;\n            for (int i=0; i<count; ++i) {\n                pts[++oset] = points[i].x();\n                pts[++oset] = points[i].y();\n                pts[++oset] = points[i].x() + 1/63.;\n                pts[++oset] = points[i].y();\n            }\n            QVectorPath path(pts, count * 2, qpaintengineex_line_types_16, QVectorPath::LinesHint);\n            stroke(path, pen);\n            pointCount -= 16;\n            points += 16;\n        }\n    } else {\n        for (int i=0; i<pointCount; ++i) {\n            qreal pts[] = { points[i].x(), points[i].y(), points[i].x() + qreal(1/63.), points[i].y() };\n            QVectorPath path(pts, 2, nullptr);\n            stroke(path, pen);\n        }\n    }\n}\n\nvoid QPaintEngineEx::drawPoints(const QPoint *points, int pointCount)\n{\n    QPen pen = state()->pen;\n    if (pen.capStyle() == Qt::FlatCap)\n        pen.setCapStyle(Qt::SquareCap);\n\n    if (pen.brush().isOpaque()) {\n        while (pointCount > 0) {\n            int count = qMin(pointCount, 16);\n            qreal pts[64];\n            int oset = -1;\n            for (int i=0; i<count; ++i) {\n                pts[++oset] = points[i].x();\n                pts[++oset] = points[i].y();\n                pts[++oset] = points[i].x() + 1/63.;\n                pts[++oset] = points[i].y();\n            }\n            QVectorPath path(pts, count * 2, qpaintengineex_line_types_16, QVectorPath::LinesHint);\n            stroke(path, pen);\n            pointCount -= 16;\n            points += 16;\n        }\n    } else {\n        for (int i=0; i<pointCount; ++i) {\n            qreal pts[] = { qreal(points[i].x()), qreal(points[i].y()),\n                            qreal(points[i].x() +1/63.), qreal(points[i].y()) };\n            QVectorPath path(pts, 2, nullptr);\n            stroke(path, pen);\n        }\n    }\n}\n\n\nvoid QPaintEngineEx::drawPolygon(const QPointF *points, int pointCount, PolygonDrawMode mode)\n{\n    QVectorPath path((const qreal *) points, pointCount, nullptr, QVectorPath::polygonFlags(mode));\n\n    if (mode == PolylineMode)\n        stroke(path, state()->pen);\n    else\n        draw(path);\n}\n\nvoid QPaintEngineEx::drawPolygon(const QPoint *points, int pointCount, PolygonDrawMode mode)\n{\n    int count = pointCount<<1;\n    QVarLengthArray<qreal> pts(count);\n\n    for (int i=0; i<count; ++i)\n        pts[i] = ((const int *) points)[i];\n\n    QVectorPath path(pts.data(), pointCount, nullptr, QVectorPath::polygonFlags(mode));\n\n    if (mode == PolylineMode)\n        stroke(path, state()->pen);\n    else\n        draw(path);\n\n}\n\nvoid QPaintEngineEx::drawPixmap(const QPointF &pos, const QPixmap &pm)\n{\n    drawPixmap(QRectF(pos, pm.size() / pm.devicePixelRatio()), pm, pm.rect());\n}\n\nvoid QPaintEngineEx::drawImage(const QPointF &pos, const QImage &image)\n{\n    drawImage(QRectF(pos, image.size() / image.devicePixelRatio()), image, image.rect());\n}\n\nvoid QPaintEngineEx::drawTiledPixmap(const QRectF &r, const QPixmap &pixmap, const QPointF &s)\n{\n    QBrush brush(state()->pen.color(), pixmap);\n    QTransform xform = QTransform::fromTranslate(r.x() - s.x(), r.y() - s.y());\n    if (!qFuzzyCompare(pixmap.devicePixelRatio(), qreal(1.0)))\n        xform.scale(1.0/pixmap.devicePixelRatio(), 1.0/pixmap.devicePixelRatio());\n    brush.setTransform(xform);\n\n    qreal pts[] = { r.x(), r.y(),\n                    r.x() + r.width(), r.y(),\n                    r.x() + r.width(), r.y() + r.height(),\n                    r.x(), r.y() + r.height() };\n\n    QVectorPath path(pts, 4, nullptr, QVectorPath::RectangleHint);\n    fill(path, brush);\n}\n\nvoid QPaintEngineEx::drawPixmapFragments(const QPainter::PixmapFragment *fragments, int fragmentCount,\n                                         const QPixmap &pixmap, QPainter::PixmapFragmentHints /*hints*/)\n{\n    if (pixmap.isNull())\n        return;\n\n    qreal oldOpacity = state()->opacity;\n    QTransform oldTransform = state()->matrix;\n\n    for (int i = 0; i < fragmentCount; ++i) {\n        QTransform transform = oldTransform;\n        transform.translate(fragments[i].x, fragments[i].y);\n        transform.rotate(fragments[i].rotation);\n        state()->opacity = oldOpacity * fragments[i].opacity;\n        state()->matrix = transform;\n        opacityChanged();\n        transformChanged();\n\n        qreal w = fragments[i].scaleX * fragments[i].width;\n        qreal h = fragments[i].scaleY * fragments[i].height;\n        QRectF sourceRect(fragments[i].sourceLeft, fragments[i].sourceTop,\n                          fragments[i].width, fragments[i].height);\n        drawPixmap(QRectF(-0.5 * w, -0.5 * h, w, h), pixmap, sourceRect);\n    }\n\n    state()->opacity = oldOpacity;\n    state()->matrix = oldTransform;\n    opacityChanged();\n    transformChanged();\n}\n\nvoid QPaintEngineEx::setState(QPainterState *s)\n{\n    QPaintEngine::state = s;\n}\n\n\nvoid QPaintEngineEx::updateState(const QPaintEngineState &)\n{\n    // do nothing...\n}\n\nQ_GUI_EXPORT QPainterPath qt_painterPathFromVectorPath(const QVectorPath &path)\n{\n    const qreal *points = path.points();\n    const QPainterPath::ElementType *types = path.elements();\n\n    QPainterPath p;\n    if (types) {\n        int id = 0;\n        for (int i=0; i<path.elementCount(); ++i) {\n            switch(types[i]) {\n            case QPainterPath::MoveToElement:\n                p.moveTo(QPointF(points[id], points[id+1]));\n                id+=2;\n                break;\n            case QPainterPath::LineToElement:\n                p.lineTo(QPointF(points[id], points[id+1]));\n                id+=2;\n                break;\n            case QPainterPath::CurveToElement: {\n                QPointF p1(points[id], points[id+1]);\n                QPointF p2(points[id+2], points[id+3]);\n                QPointF p3(points[id+4], points[id+5]);\n                p.cubicTo(p1, p2, p3);\n                id+=6;\n                break;\n            }\n            case QPainterPath::CurveToDataElement:\n                ;\n                break;\n            }\n        }\n    } else {\n        p.moveTo(QPointF(points[0], points[1]));\n        int id = 2;\n        for (int i=1; i<path.elementCount(); ++i) {\n            p.lineTo(QPointF(points[id], points[id+1]));\n            id+=2;\n        }\n    }\n    if (path.hints() & QVectorPath::WindingFill)\n        p.setFillRule(Qt::WindingFill);\n\n    return p;\n}\n\nvoid QPaintEngineEx::drawStaticTextItem(QStaticTextItem *staticTextItem)\n{\n    QPainterPath path;\n    path.setFillRule(Qt::WindingFill);\n\n    if (staticTextItem->numGlyphs == 0)\n        return;\n\n    QFontEngine *fontEngine = staticTextItem->fontEngine();\n    fontEngine->addGlyphsToPath(staticTextItem->glyphs, staticTextItem->glyphPositions,\n                                staticTextItem->numGlyphs, &path, { });\n    if (!path.isEmpty()) {\n        QPainterState *s = state();\n        QPainter::RenderHints oldHints = s->renderHints;\n        bool changedHints = false;\n        if (bool(oldHints & QPainter::TextAntialiasing)\n            && !bool(fontEngine->fontDef.styleStrategy & QFont::NoAntialias)\n            && !bool(oldHints & QPainter::Antialiasing)) {\n            s->renderHints |= QPainter::Antialiasing;\n            renderHintsChanged();\n            changedHints = true;\n        }\n\n        fill(qtVectorPathForPath(path), s->pen.brush());\n\n        if (changedHints) {\n            s->renderHints = oldHints;\n            renderHintsChanged();\n        }\n    }\n}\n\nbool QPaintEngineEx::requiresPretransformedGlyphPositions(QFontEngine *, const QTransform &) const\n{\n    return false;\n}\n\nbool QPaintEngineEx::shouldDrawCachedGlyphs(QFontEngine *fontEngine, const QTransform &m) const\n{\n    if (fontEngine->glyphFormat == QFontEngine::Format_ARGB)\n        return true;\n\n    static const int maxCachedGlyphSizeSquared = std::pow([]{\n        if (int env = qEnvironmentVariableIntValue(\"QT_MAX_CACHED_GLYPH_SIZE\"))\n            return env;\n        return QT_MAX_CACHED_GLYPH_SIZE;\n    }(), 2);\n\n    qreal pixelSize = fontEngine->fontDef.pixelSize;\n    return (pixelSize * pixelSize * qAbs(m.determinant())) <= maxCachedGlyphSizeSquared;\n}\n\nQT_END_NAMESPACE\n"], "fixing_code": ["/****************************************************************************\n**\n** Copyright (C) 2016 The Qt Company Ltd.\n** Contact: https://www.qt.io/licensing/\n**\n** This file is part of the QtGui module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see https://www.qt.io/terms-conditions. For further\n** information use the contact form at https://www.qt.io/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 3 as published by the Free Software\n** Foundation and appearing in the file LICENSE.LGPL3 included in the\n** packaging of this file. Please review the following information to\n** ensure the GNU Lesser General Public License version 3 requirements\n** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 2.0 or (at your option) the GNU General\n** Public license version 3 or any later version approved by the KDE Free\n** Qt Foundation. The licenses are as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3\n** included in the packaging of this file. Please review the following\n** information to ensure the GNU General Public License requirements will\n** be met: https://www.gnu.org/licenses/gpl-2.0.html and\n** https://www.gnu.org/licenses/gpl-3.0.html.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include \"qpaintengineex_p.h\"\n#include \"qpainter_p.h\"\n#include \"qstroker_p.h\"\n#include \"qbezier_p.h\"\n#include <private/qpainterpath_p.h>\n#include <private/qfontengine_p.h>\n#include <private/qstatictext_p.h>\n\n#include <qvarlengtharray.h>\n#include <qdebug.h>\n\n\nQT_BEGIN_NAMESPACE\n\n#if !defined(QT_MAX_CACHED_GLYPH_SIZE)\n#  define QT_MAX_CACHED_GLYPH_SIZE 64\n#endif\n\n/*******************************************************************************\n *\n * class QVectorPath\n *\n */\nQVectorPath::~QVectorPath()\n{\n    if (m_hints & ShouldUseCacheHint) {\n        CacheEntry *e = m_cache;\n        while (e) {\n            if (e->data)\n                e->cleanup(e->engine, e->data);\n            CacheEntry *n = e->next;\n            delete e;\n            e = n;\n        }\n    }\n}\n\n\nQRectF QVectorPath::controlPointRect() const\n{\n    if (m_hints & ControlPointRect)\n        return QRectF(QPointF(m_cp_rect.x1, m_cp_rect.y1), QPointF(m_cp_rect.x2, m_cp_rect.y2));\n\n    if (m_count == 0) {\n        m_cp_rect.x1 = m_cp_rect.x2 = m_cp_rect.y1 = m_cp_rect.y2 = 0;\n        m_hints |= ControlPointRect;\n        return QRectF(QPointF(m_cp_rect.x1, m_cp_rect.y1), QPointF(m_cp_rect.x2, m_cp_rect.y2));\n    }\n    Q_ASSERT(m_points && m_count > 0);\n\n    const qreal *pts = m_points;\n    m_cp_rect.x1 = m_cp_rect.x2 = *pts;\n    ++pts;\n    m_cp_rect.y1 = m_cp_rect.y2 = *pts;\n    ++pts;\n\n    const qreal *epts = m_points + (m_count << 1);\n    while (pts < epts) {\n        qreal x = *pts;\n        if (x < m_cp_rect.x1) m_cp_rect.x1 = x;\n        else if (x > m_cp_rect.x2) m_cp_rect.x2 = x;\n        ++pts;\n\n        qreal y = *pts;\n        if (y < m_cp_rect.y1) m_cp_rect.y1 = y;\n        else if (y > m_cp_rect.y2) m_cp_rect.y2 = y;\n        ++pts;\n    }\n\n    m_hints |= ControlPointRect;\n    return QRectF(QPointF(m_cp_rect.x1, m_cp_rect.y1), QPointF(m_cp_rect.x2, m_cp_rect.y2));\n}\n\n\nQVectorPath::CacheEntry *QVectorPath::addCacheData(QPaintEngineEx *engine, void *data,\n                                                   qvectorpath_cache_cleanup cleanup) const{\n    Q_ASSERT(!lookupCacheData(engine));\n    if ((m_hints & IsCachedHint) == 0) {\n        m_cache = nullptr;\n        m_hints |= IsCachedHint;\n    }\n    CacheEntry *e = new CacheEntry;\n    e->engine = engine;\n    e->data = data;\n    e->cleanup = cleanup;\n    e->next = m_cache;\n    m_cache = e;\n    return m_cache;\n}\n\n\nconst QVectorPath &qtVectorPathForPath(const QPainterPath &path)\n{\n    Q_ASSERT(path.d_func());\n    return path.d_func()->vectorPath();\n}\n\n#ifndef QT_NO_DEBUG_STREAM\nQDebug Q_GUI_EXPORT &operator<<(QDebug &s, const QVectorPath &path)\n{\n    QDebugStateSaver saver(s);\n    QRectF rf = path.controlPointRect();\n    s << \"QVectorPath(size:\" << path.elementCount()\n      << \" hints:\" << Qt::hex << path.hints()\n      << rf << ')';\n    return s;\n}\n#endif\n\n/*******************************************************************************\n *\n * class QPaintEngineExPrivate:\n *\n */\n\n\nstruct StrokeHandler {\n    StrokeHandler(int reserve) : pts(reserve), types(reserve) {}\n    QDataBuffer<qreal> pts;\n    QDataBuffer<QPainterPath::ElementType> types;\n};\n\n\nQPaintEngineExPrivate::QPaintEngineExPrivate()\n    : dasher(&stroker),\n      strokeHandler(nullptr),\n      activeStroker(nullptr),\n      strokerPen(Qt::NoPen)\n{\n}\n\n\nQPaintEngineExPrivate::~QPaintEngineExPrivate()\n{\n    delete strokeHandler;\n}\n\n\nvoid QPaintEngineExPrivate::replayClipOperations()\n{\n    Q_Q(QPaintEngineEx);\n\n    QPainter *p = q->painter();\n    if (!p || !p->d_ptr)\n        return;\n\n    const QList<QPainterClipInfo> &clipInfo = p->d_ptr->state->clipInfo;\n\n    QTransform transform = q->state()->matrix;\n\n    for (const QPainterClipInfo &info : clipInfo) {\n\n        if (info.matrix != q->state()->matrix) {\n            q->state()->matrix = info.matrix;\n            q->transformChanged();\n        }\n\n        switch (info.clipType) {\n        case QPainterClipInfo::RegionClip:\n            q->clip(info.region, info.operation);\n            break;\n        case QPainterClipInfo::PathClip:\n            q->clip(info.path, info.operation);\n            break;\n        case QPainterClipInfo::RectClip:\n            q->clip(info.rect, info.operation);\n            break;\n        case QPainterClipInfo::RectFClip: {\n            qreal right = info.rectf.x() + info.rectf.width();\n            qreal bottom = info.rectf.y() + info.rectf.height();\n            qreal pts[] = { info.rectf.x(), info.rectf.y(),\n                            right, info.rectf.y(),\n                            right, bottom,\n                            info.rectf.x(), bottom };\n            QVectorPath vp(pts, 4, nullptr, QVectorPath::RectangleHint);\n            q->clip(vp, info.operation);\n            break;\n            }\n        }\n    }\n\n    if (transform != q->state()->matrix) {\n        q->state()->matrix = transform;\n        q->transformChanged();\n    }\n}\n\n\nbool QPaintEngineExPrivate::hasClipOperations() const\n{\n    Q_Q(const QPaintEngineEx);\n\n    QPainter *p = q->painter();\n    if (!p || !p->d_ptr)\n        return false;\n\n    return !p->d_ptr->state->clipInfo.isEmpty();\n}\n\n/*******************************************************************************\n *\n * class QPaintEngineEx:\n *\n */\n\nstatic const QPainterPath::ElementType qpaintengineex_ellipse_types[] = {\n    QPainterPath::MoveToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement\n};\n\nstatic const QPainterPath::ElementType qpaintengineex_line_types_16[] = {\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement,\n    QPainterPath::MoveToElement, QPainterPath::LineToElement\n};\n\nstatic const QPainterPath::ElementType qpaintengineex_rect4_types_32[] = {\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 1\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 2\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 3\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 4\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 5\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 6\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 7\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 8\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 9\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 10\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 11\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 12\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 13\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 14\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 15\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 16\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 17\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 18\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 19\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 20\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 21\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 22\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 23\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 24\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 25\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 26\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 27\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 28\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 29\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 30\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 31\n    QPainterPath::MoveToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, QPainterPath::LineToElement, // 32\n};\n\n\nstatic const QPainterPath::ElementType qpaintengineex_roundedrect_types[] = {\n    QPainterPath::MoveToElement,\n    QPainterPath::LineToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::LineToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::LineToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::LineToElement,\n    QPainterPath::CurveToElement,\n    QPainterPath::CurveToDataElement,\n    QPainterPath::CurveToDataElement\n};\n\n\n\nstatic void qpaintengineex_moveTo(qreal x, qreal y, void *data) {\n    ((StrokeHandler *) data)->pts.add(x);\n    ((StrokeHandler *) data)->pts.add(y);\n    ((StrokeHandler *) data)->types.add(QPainterPath::MoveToElement);\n}\n\nstatic void qpaintengineex_lineTo(qreal x, qreal y, void *data) {\n    ((StrokeHandler *) data)->pts.add(x);\n    ((StrokeHandler *) data)->pts.add(y);\n    ((StrokeHandler *) data)->types.add(QPainterPath::LineToElement);\n}\n\nstatic void qpaintengineex_cubicTo(qreal c1x, qreal c1y, qreal c2x, qreal c2y, qreal ex, qreal ey, void *data) {\n    ((StrokeHandler *) data)->pts.add(c1x);\n    ((StrokeHandler *) data)->pts.add(c1y);\n    ((StrokeHandler *) data)->types.add(QPainterPath::CurveToElement);\n\n    ((StrokeHandler *) data)->pts.add(c2x);\n    ((StrokeHandler *) data)->pts.add(c2y);\n    ((StrokeHandler *) data)->types.add(QPainterPath::CurveToDataElement);\n\n    ((StrokeHandler *) data)->pts.add(ex);\n    ((StrokeHandler *) data)->pts.add(ey);\n    ((StrokeHandler *) data)->types.add(QPainterPath::CurveToDataElement);\n}\n\nQPaintEngineEx::QPaintEngineEx()\n    : QPaintEngine(*new QPaintEngineExPrivate, AllFeatures)\n{\n    extended = true;\n}\n\nQPaintEngineEx::QPaintEngineEx(QPaintEngineExPrivate &data)\n    : QPaintEngine(data, AllFeatures)\n{\n    extended = true;\n}\n\nQPainterState *QPaintEngineEx::createState(QPainterState *orig) const\n{\n    if (!orig)\n        return new QPainterState;\n    return new QPainterState(orig);\n}\n\nQ_GUI_EXPORT extern bool qt_scaleForTransform(const QTransform &transform, qreal *scale); // qtransform.cpp\n\nvoid QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n\n    Q_D(QPaintEngineEx);\n\n    if (path.isEmpty())\n        return;\n\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        // Check to avoid generating unwieldy amount of dashes that will not be visible anyway\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (qFuzzyIsNull(extent) || extent / patternLength > 10000) {\n            // approximate stream of tiny dashes with semi-transparent solid line\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n\n    if (!d->activeStroker) {\n        return;\n    }\n\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n\n    const qreal *lastPoint = points + (pointCount<<1);\n\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n\n    // Some engines might decide to optimize for the non-shape hint later on...\n    uint flags = QVectorPath::WindingFill;\n\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n\n    // ### Perspective Xforms are currently not supported...\n    if (!pen.isCosmetic()) {\n        // We include cosmetic pens in this case to avoid having to\n        // change the current transform. Normal transformed,\n        // non-cosmetic pens will be transformed as part of fill\n        // later, so they are also covered here..\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n\n        if (!d->strokeHandler->types.size()) // an empty path...\n            return;\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        // For cosmetic pens we need a bit of trickery... We to process xform the input points\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n\n        fill(strokePath, brush);\n\n        state()->matrix = xform;\n        transformChanged();\n    }\n}\n\nvoid QPaintEngineEx::draw(const QVectorPath &path)\n{\n    const QBrush &brush = state()->brush;\n    if (qbrush_style(brush) != Qt::NoBrush)\n        fill(path, brush);\n\n    const QPen &pen = state()->pen;\n    if (qpen_style(pen) != Qt::NoPen && qbrush_style(qpen_brush(pen)) != Qt::NoBrush)\n        stroke(path, pen);\n}\n\n\nvoid QPaintEngineEx::clip(const QRect &r, Qt::ClipOperation op)\n{\n    qreal right = r.x() + r.width();\n    qreal bottom = r.y() + r.height();\n    qreal pts[] = { qreal(r.x()), qreal(r.y()),\n                    right, qreal(r.y()),\n                    right, bottom,\n                    qreal(r.x()), bottom,\n                    qreal(r.x()), qreal(r.y()) };\n    QVectorPath vp(pts, 5, nullptr, QVectorPath::RectangleHint);\n    clip(vp, op);\n}\n\nvoid QPaintEngineEx::clip(const QRegion &region, Qt::ClipOperation op)\n{\n    const auto rectsInRegion = region.rectCount();\n    if (rectsInRegion == 1) {\n        clip(*region.begin(), op);\n    } else if (rectsInRegion <= 32) {\n        qreal pts[2*32*4];\n        int pos = 0;\n        for (QRect r : region) {\n            qreal x1 = r.x();\n            qreal y1 = r.y();\n            qreal x2 = r.x() + r.width();\n            qreal y2 = r.y() + r.height();\n\n            pts[pos++] = x1;\n            pts[pos++] = y1;\n\n            pts[pos++] = x2;\n            pts[pos++] = y1;\n\n            pts[pos++] = x2;\n            pts[pos++] = y2;\n\n            pts[pos++] = x1;\n            pts[pos++] = y2;\n        }\n        QVectorPath vp(pts, rectsInRegion * 4, qpaintengineex_rect4_types_32);\n        clip(vp, op);\n    } else {\n        QVarLengthArray<qreal> pts(rectsInRegion * 2 * 4);\n        QVarLengthArray<QPainterPath::ElementType> types(rectsInRegion * 4);\n        int ppos = 0;\n        int tpos = 0;\n\n        for (QRect r : region) {\n            qreal x1 = r.x();\n            qreal y1 = r.y();\n            qreal x2 = r.x() + r.width();\n            qreal y2 = r.y() + r.height();\n\n            pts[ppos++] = x1;\n            pts[ppos++] = y1;\n\n            pts[ppos++] = x2;\n            pts[ppos++] = y1;\n\n            pts[ppos++] = x2;\n            pts[ppos++] = y2;\n\n            pts[ppos++] = x1;\n            pts[ppos++] = y2;\n\n            types[tpos++] = QPainterPath::MoveToElement;\n            types[tpos++] = QPainterPath::LineToElement;\n            types[tpos++] = QPainterPath::LineToElement;\n            types[tpos++] = QPainterPath::LineToElement;\n        }\n\n        QVectorPath vp(pts.data(), rectsInRegion * 4, types.data());\n        clip(vp, op);\n    }\n\n}\n\nvoid QPaintEngineEx::clip(const QPainterPath &path, Qt::ClipOperation op)\n{\n    if (path.isEmpty()) {\n        QVectorPath vp(nullptr, 0);\n        clip(vp, op);\n    } else {\n        clip(qtVectorPathForPath(path), op);\n    }\n}\n\nvoid QPaintEngineEx::fillRect(const QRectF &r, const QBrush &brush)\n{\n    qreal pts[] = { r.x(), r.y(), r.x() + r.width(), r.y(),\n                    r.x() + r.width(), r.y() + r.height(), r.x(), r.y() + r.height() };\n    QVectorPath vp(pts, 4, nullptr, QVectorPath::RectangleHint);\n    fill(vp, brush);\n}\n\nvoid QPaintEngineEx::fillRect(const QRectF &r, const QColor &color)\n{\n    fillRect(r, QBrush(color));\n}\n\nvoid QPaintEngineEx::drawRects(const QRect *rects, int rectCount)\n{\n    for (int i=0; i<rectCount; ++i) {\n        const QRect &r = rects[i];\n        // ### Is there a one off here?\n        qreal right = r.x() + r.width();\n        qreal bottom = r.y() + r.height();\n        qreal pts[] = { qreal(r.x()), qreal(r.y()),\n                        right, qreal(r.y()),\n                        right, bottom,\n                        qreal(r.x()), bottom,\n                        qreal(r.x()), qreal(r.y()) };\n        QVectorPath vp(pts, 5, nullptr, QVectorPath::RectangleHint);\n        draw(vp);\n    }\n}\n\nvoid QPaintEngineEx::drawRects(const QRectF *rects, int rectCount)\n{\n    for (int i=0; i<rectCount; ++i) {\n        const QRectF &r = rects[i];\n        qreal right = r.x() + r.width();\n        qreal bottom = r.y() + r.height();\n        qreal pts[] = { r.x(), r.y(),\n                        right, r.y(),\n                        right, bottom,\n                        r.x(), bottom,\n                        r.x(), r.y() };\n        QVectorPath vp(pts, 5, nullptr, QVectorPath::RectangleHint);\n        draw(vp);\n    }\n}\n\n\nvoid QPaintEngineEx::drawRoundedRect(const QRectF &rect, qreal xRadius, qreal yRadius,\n                                     Qt::SizeMode mode)\n{\n    qreal x1 = rect.left();\n    qreal x2 = rect.right();\n    qreal y1 = rect.top();\n    qreal y2 = rect.bottom();\n\n    if (mode == Qt::RelativeSize) {\n        xRadius = xRadius * rect.width() / 200.;\n        yRadius = yRadius * rect.height() / 200.;\n    }\n\n    xRadius = qMin(xRadius, rect.width() / 2);\n    yRadius = qMin(yRadius, rect.height() / 2);\n\n    qreal pts[] = {\n        x1 + xRadius, y1,                   // MoveTo\n        x2 - xRadius, y1,                   // LineTo\n        x2 - (1 - KAPPA) * xRadius, y1,     // CurveTo\n        x2, y1 + (1 - KAPPA) * yRadius,\n        x2, y1 + yRadius,\n        x2, y2 - yRadius,                   // LineTo\n        x2, y2 - (1 - KAPPA) * yRadius,     // CurveTo\n        x2 - (1 - KAPPA) * xRadius, y2,\n        x2 - xRadius, y2,\n        x1 + xRadius, y2,                   // LineTo\n        x1 + (1 - KAPPA) * xRadius, y2,           // CurveTo\n        x1, y2 - (1 - KAPPA) * yRadius,\n        x1, y2 - yRadius,\n        x1, y1 + yRadius,                   // LineTo\n        x1, y1 + (1 - KAPPA) * yRadius,           // CurveTo\n        x1 + (1 - KAPPA) * xRadius, y1,\n        x1 + xRadius, y1\n    };\n\n    QVectorPath path(pts, 17, qpaintengineex_roundedrect_types, QVectorPath::RoundedRectHint);\n    draw(path);\n}\n\n\n\nvoid QPaintEngineEx::drawLines(const QLine *lines, int lineCount)\n{\n    int elementCount = lineCount << 1;\n    while (elementCount > 0) {\n        int count = qMin(elementCount, 32);\n\n        qreal pts[64];\n        int count2 = count<<1;\n        for (int i=0; i<count2; ++i)\n            pts[i] = ((const int *) lines)[i];\n\n        QVectorPath path(pts, count, qpaintengineex_line_types_16, QVectorPath::LinesHint);\n        stroke(path, state()->pen);\n\n        elementCount -= 32;\n        lines += 16;\n    }\n}\n\nvoid QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)\n{\n    int elementCount = lineCount << 1;\n    while (elementCount > 0) {\n        int count = qMin(elementCount, 32);\n\n        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,\n                         QVectorPath::LinesHint);\n        stroke(path, state()->pen);\n\n        elementCount -= 32;\n        lines += 16;\n    }\n}\n\nvoid QPaintEngineEx::drawEllipse(const QRectF &r)\n{\n    qreal pts[26]; // QPointF[13] without constructors...\n    union {\n        qreal *ptr;\n        QPointF *points;\n    } x;\n    x.ptr = pts;\n\n    int point_count = 0;\n    x.points[0] = qt_curves_for_arc(r, 0, -360, x.points + 1, &point_count);\n    if (point_count == 0)\n        return;\n    QVectorPath vp((qreal *) pts, point_count + 1, qpaintengineex_ellipse_types, QVectorPath::EllipseHint);\n    draw(vp);\n}\n\nvoid QPaintEngineEx::drawEllipse(const QRect &r)\n{\n    drawEllipse(QRectF(r));\n}\n\nvoid QPaintEngineEx::drawPath(const QPainterPath &path)\n{\n    if (!path.isEmpty())\n        draw(qtVectorPathForPath(path));\n}\n\n\nvoid QPaintEngineEx::drawPoints(const QPointF *points, int pointCount)\n{\n    QPen pen = state()->pen;\n    if (pen.capStyle() == Qt::FlatCap)\n        pen.setCapStyle(Qt::SquareCap);\n\n    if (pen.brush().isOpaque()) {\n        while (pointCount > 0) {\n            int count = qMin(pointCount, 16);\n            qreal pts[64];\n            int oset = -1;\n            for (int i=0; i<count; ++i) {\n                pts[++oset] = points[i].x();\n                pts[++oset] = points[i].y();\n                pts[++oset] = points[i].x() + 1/63.;\n                pts[++oset] = points[i].y();\n            }\n            QVectorPath path(pts, count * 2, qpaintengineex_line_types_16, QVectorPath::LinesHint);\n            stroke(path, pen);\n            pointCount -= 16;\n            points += 16;\n        }\n    } else {\n        for (int i=0; i<pointCount; ++i) {\n            qreal pts[] = { points[i].x(), points[i].y(), points[i].x() + qreal(1/63.), points[i].y() };\n            QVectorPath path(pts, 2, nullptr);\n            stroke(path, pen);\n        }\n    }\n}\n\nvoid QPaintEngineEx::drawPoints(const QPoint *points, int pointCount)\n{\n    QPen pen = state()->pen;\n    if (pen.capStyle() == Qt::FlatCap)\n        pen.setCapStyle(Qt::SquareCap);\n\n    if (pen.brush().isOpaque()) {\n        while (pointCount > 0) {\n            int count = qMin(pointCount, 16);\n            qreal pts[64];\n            int oset = -1;\n            for (int i=0; i<count; ++i) {\n                pts[++oset] = points[i].x();\n                pts[++oset] = points[i].y();\n                pts[++oset] = points[i].x() + 1/63.;\n                pts[++oset] = points[i].y();\n            }\n            QVectorPath path(pts, count * 2, qpaintengineex_line_types_16, QVectorPath::LinesHint);\n            stroke(path, pen);\n            pointCount -= 16;\n            points += 16;\n        }\n    } else {\n        for (int i=0; i<pointCount; ++i) {\n            qreal pts[] = { qreal(points[i].x()), qreal(points[i].y()),\n                            qreal(points[i].x() +1/63.), qreal(points[i].y()) };\n            QVectorPath path(pts, 2, nullptr);\n            stroke(path, pen);\n        }\n    }\n}\n\n\nvoid QPaintEngineEx::drawPolygon(const QPointF *points, int pointCount, PolygonDrawMode mode)\n{\n    QVectorPath path((const qreal *) points, pointCount, nullptr, QVectorPath::polygonFlags(mode));\n\n    if (mode == PolylineMode)\n        stroke(path, state()->pen);\n    else\n        draw(path);\n}\n\nvoid QPaintEngineEx::drawPolygon(const QPoint *points, int pointCount, PolygonDrawMode mode)\n{\n    int count = pointCount<<1;\n    QVarLengthArray<qreal> pts(count);\n\n    for (int i=0; i<count; ++i)\n        pts[i] = ((const int *) points)[i];\n\n    QVectorPath path(pts.data(), pointCount, nullptr, QVectorPath::polygonFlags(mode));\n\n    if (mode == PolylineMode)\n        stroke(path, state()->pen);\n    else\n        draw(path);\n\n}\n\nvoid QPaintEngineEx::drawPixmap(const QPointF &pos, const QPixmap &pm)\n{\n    drawPixmap(QRectF(pos, pm.size() / pm.devicePixelRatio()), pm, pm.rect());\n}\n\nvoid QPaintEngineEx::drawImage(const QPointF &pos, const QImage &image)\n{\n    drawImage(QRectF(pos, image.size() / image.devicePixelRatio()), image, image.rect());\n}\n\nvoid QPaintEngineEx::drawTiledPixmap(const QRectF &r, const QPixmap &pixmap, const QPointF &s)\n{\n    QBrush brush(state()->pen.color(), pixmap);\n    QTransform xform = QTransform::fromTranslate(r.x() - s.x(), r.y() - s.y());\n    if (!qFuzzyCompare(pixmap.devicePixelRatio(), qreal(1.0)))\n        xform.scale(1.0/pixmap.devicePixelRatio(), 1.0/pixmap.devicePixelRatio());\n    brush.setTransform(xform);\n\n    qreal pts[] = { r.x(), r.y(),\n                    r.x() + r.width(), r.y(),\n                    r.x() + r.width(), r.y() + r.height(),\n                    r.x(), r.y() + r.height() };\n\n    QVectorPath path(pts, 4, nullptr, QVectorPath::RectangleHint);\n    fill(path, brush);\n}\n\nvoid QPaintEngineEx::drawPixmapFragments(const QPainter::PixmapFragment *fragments, int fragmentCount,\n                                         const QPixmap &pixmap, QPainter::PixmapFragmentHints /*hints*/)\n{\n    if (pixmap.isNull())\n        return;\n\n    qreal oldOpacity = state()->opacity;\n    QTransform oldTransform = state()->matrix;\n\n    for (int i = 0; i < fragmentCount; ++i) {\n        QTransform transform = oldTransform;\n        transform.translate(fragments[i].x, fragments[i].y);\n        transform.rotate(fragments[i].rotation);\n        state()->opacity = oldOpacity * fragments[i].opacity;\n        state()->matrix = transform;\n        opacityChanged();\n        transformChanged();\n\n        qreal w = fragments[i].scaleX * fragments[i].width;\n        qreal h = fragments[i].scaleY * fragments[i].height;\n        QRectF sourceRect(fragments[i].sourceLeft, fragments[i].sourceTop,\n                          fragments[i].width, fragments[i].height);\n        drawPixmap(QRectF(-0.5 * w, -0.5 * h, w, h), pixmap, sourceRect);\n    }\n\n    state()->opacity = oldOpacity;\n    state()->matrix = oldTransform;\n    opacityChanged();\n    transformChanged();\n}\n\nvoid QPaintEngineEx::setState(QPainterState *s)\n{\n    QPaintEngine::state = s;\n}\n\n\nvoid QPaintEngineEx::updateState(const QPaintEngineState &)\n{\n    // do nothing...\n}\n\nQ_GUI_EXPORT QPainterPath qt_painterPathFromVectorPath(const QVectorPath &path)\n{\n    const qreal *points = path.points();\n    const QPainterPath::ElementType *types = path.elements();\n\n    QPainterPath p;\n    if (types) {\n        int id = 0;\n        for (int i=0; i<path.elementCount(); ++i) {\n            switch(types[i]) {\n            case QPainterPath::MoveToElement:\n                p.moveTo(QPointF(points[id], points[id+1]));\n                id+=2;\n                break;\n            case QPainterPath::LineToElement:\n                p.lineTo(QPointF(points[id], points[id+1]));\n                id+=2;\n                break;\n            case QPainterPath::CurveToElement: {\n                QPointF p1(points[id], points[id+1]);\n                QPointF p2(points[id+2], points[id+3]);\n                QPointF p3(points[id+4], points[id+5]);\n                p.cubicTo(p1, p2, p3);\n                id+=6;\n                break;\n            }\n            case QPainterPath::CurveToDataElement:\n                ;\n                break;\n            }\n        }\n    } else {\n        p.moveTo(QPointF(points[0], points[1]));\n        int id = 2;\n        for (int i=1; i<path.elementCount(); ++i) {\n            p.lineTo(QPointF(points[id], points[id+1]));\n            id+=2;\n        }\n    }\n    if (path.hints() & QVectorPath::WindingFill)\n        p.setFillRule(Qt::WindingFill);\n\n    return p;\n}\n\nvoid QPaintEngineEx::drawStaticTextItem(QStaticTextItem *staticTextItem)\n{\n    QPainterPath path;\n    path.setFillRule(Qt::WindingFill);\n\n    if (staticTextItem->numGlyphs == 0)\n        return;\n\n    QFontEngine *fontEngine = staticTextItem->fontEngine();\n    fontEngine->addGlyphsToPath(staticTextItem->glyphs, staticTextItem->glyphPositions,\n                                staticTextItem->numGlyphs, &path, { });\n    if (!path.isEmpty()) {\n        QPainterState *s = state();\n        QPainter::RenderHints oldHints = s->renderHints;\n        bool changedHints = false;\n        if (bool(oldHints & QPainter::TextAntialiasing)\n            && !bool(fontEngine->fontDef.styleStrategy & QFont::NoAntialias)\n            && !bool(oldHints & QPainter::Antialiasing)) {\n            s->renderHints |= QPainter::Antialiasing;\n            renderHintsChanged();\n            changedHints = true;\n        }\n\n        fill(qtVectorPathForPath(path), s->pen.brush());\n\n        if (changedHints) {\n            s->renderHints = oldHints;\n            renderHintsChanged();\n        }\n    }\n}\n\nbool QPaintEngineEx::requiresPretransformedGlyphPositions(QFontEngine *, const QTransform &) const\n{\n    return false;\n}\n\nbool QPaintEngineEx::shouldDrawCachedGlyphs(QFontEngine *fontEngine, const QTransform &m) const\n{\n    if (fontEngine->glyphFormat == QFontEngine::Format_ARGB)\n        return true;\n\n    static const int maxCachedGlyphSizeSquared = std::pow([]{\n        if (int env = qEnvironmentVariableIntValue(\"QT_MAX_CACHED_GLYPH_SIZE\"))\n            return env;\n        return QT_MAX_CACHED_GLYPH_SIZE;\n    }(), 2);\n\n    qreal pixelSize = fontEngine->fontDef.pixelSize;\n    return (pixelSize * pixelSize * qAbs(m.determinant())) <= maxCachedGlyphSizeSquared;\n}\n\nQT_END_NAMESPACE\n"], "filenames": ["src/gui/painting/qpaintengineex.cpp"], "buggy_code_start_loc": [429], "buggy_code_end_loc": [430], "fixing_code_start_loc": [429], "fixing_code_end_loc": [430], "type": "CWE-787", "message": "Qt 5.x before 5.15.6 and 6.x through 6.1.2 has an out-of-bounds write in QOutlineMapper::convertPath (called from QRasterPaintEngine::fill and QPaintEngineEx::stroke).", "other": {"cve": {"id": "CVE-2021-38593", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-12T02:15:06.580", "lastModified": "2023-01-19T20:16:57.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Qt 5.x before 5.15.6 and 6.x through 6.1.2 has an out-of-bounds write in QOutlineMapper::convertPath (called from QRasterPaintEngine::fill and QPaintEngineEx::stroke)."}, {"lang": "es", "value": "Qt 5.x antes de la versi\u00f3n 5.15.6 y 6.x hasta la versi\u00f3n 6.1.2 tiene una escritura fuera de l\u00edmites en QOutlineMapper::convertPath (llamada desde QRasterPaintEngine::fill y QPaintEngineEx::stroke)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qt:qt:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.15.6", "matchCriteriaId": "A3DF360C-4ADC-4C67-802D-4E6651BE9782"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qt:qt:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndIncluding": "6.1.2", "matchCriteriaId": "44ADCFEF-FA24-4424-94C4-A455F8E53CD2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=35566", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/qt/OSV-2021-903.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/qt/qtbase/commit/1ca02cf2879a5e1511a2f2109f0925cf4c892862", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qt/qtbase/commit/202143ba41f6ac574f1858214ed8bf4a38b73ccd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qt/qtbase/commit/6b400e3147dcfd8cc3a393ace1bd118c93762e0c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/36VN2WKMNQUSTF6ZW2X52NPAJVXJ4S5I/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HY5YCSDCTLHVMP3OXOM6HNTWHV6DBHDX/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://wiki.qt.io/Qt_5.15_Release#Known_Issues", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Release Notes", "Vendor Advisory"]}, {"url": "https://www.qt.io/blog/qt-5.15-extended-support-for-subscription-license-holders", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/qt/qtbase/commit/1ca02cf2879a5e1511a2f2109f0925cf4c892862"}}