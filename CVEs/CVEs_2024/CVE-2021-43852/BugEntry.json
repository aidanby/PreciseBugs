{"buggy_code": ["define(function(require) {\n    'use strict';\n\n    const $ = require('jquery');\n    const _ = require('underscore');\n    const loadModules = require('oroui/js/app/services/load-modules');\n    const tools = {};\n    const iOS = /(iPad|iPhone)/.test(navigator.userAgent);\n    const iPadOS = !!(navigator.userAgent.match(/Mac/) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2);\n\n    /**\n     * @export oroui/js/tools\n     * @name   oroui.tools\n     */\n    _.extend(tools, {\n        /** @type {boolean} */\n        debug: false,\n        /**\n         * Pack object to string\n         *\n         * Object {foo: 'x', 'bar': 'y'} will be converted to string \"foo=x&bar=y\".\n         *\n         * @param {Object} object\n         * @return {String}\n         */\n        packToQueryString: function(object) {\n            return $.param(object);\n        },\n\n        /**\n         * Pack object to string with query parameters sorted\n         *\n         * Object {foo: 'x', 'bar': 'y'} will be converted to string \"foo=x&bar=y\".\n         *\n         * @param {Object} object\n         * @return {String}\n         */\n        packToQuerySortedString: function(object) {\n            const self = this;\n            const result = [];\n            const add = function(key, value) {\n                result[result.length] = encodeURIComponent(key) + '=' +\n                    encodeURIComponent(value === null ? '' : value);\n            };\n\n            const buildParams = function(pref, obj) {\n                if (self.isArrayLikeObject(obj)) {\n                    obj = _.toArray(obj);\n                }\n\n                if (_.isArray(obj)) {\n                    obj.sort();\n                    _.each(obj, function(value, key) {\n                        buildParams(pref + '[' + (typeof value === 'object' ? key : '') + ']', value);\n                    });\n                } else if (typeof obj === 'object') {\n                    const keys = _.keys(obj);\n                    keys.sort();\n                    for (let i = 0; i < keys.length; i++) {\n                        const name = keys[i];\n                        buildParams(pref + '[' + name + ']', obj[name]);\n                    }\n                } else {\n                    add(pref, obj);\n                }\n            };\n\n            const keys = _.keys(object);\n            keys.sort();\n            for (let i = 0; i < keys.length; i++) {\n                const prefix = keys[i];\n                buildParams(prefix, object[prefix]);\n            }\n            return result.join('&');\n        },\n\n        /**\n         * Unpack string to object. Reverse from packToQueryString.\n         *\n         * @param {String} query\n         * @return {Object}\n         */\n        unpackFromQueryString: function(query) {\n            if (query.charAt(0) === '?') {\n                query = query.slice(1);\n            }\n            const setValue = function(root, path, value) {\n                if (path.length > 1) {\n                    const dir = path.shift();\n                    if (typeof root[dir] === 'undefined') {\n                        root[dir] = path[0] === '' ? [] : {};\n                    }\n                    setValue(root[dir], path, value);\n                } else {\n                    if (root instanceof Array) {\n                        root.push(value);\n                    } else {\n                        root[path] = value;\n                    }\n                }\n            };\n            const nvp = query.split('&');\n            const data = {};\n            for (let i = 0; i < nvp.length; i++) {\n                const pair = nvp[i].split('=');\n                if (pair.length < 2) {\n                    continue;\n                }\n                const name = this.decodeUriComponent(pair[0]);\n                const value = this.decodeUriComponent(pair[1]);\n\n                let path = name.match(/(^[^\\[]+)(\\[.*\\]$)?/);\n                const first = path[1];\n                if (path[2]) {\n                    // case of 'array[level1]' || 'array[level1][level2]'\n                    path = path[2].match(/(?=\\[(.*)\\]$)/)[1].split('][');\n                } else {\n                    // case of 'name'\n                    path = [];\n                }\n                path.unshift(first);\n\n                setValue(data, path, value);\n            }\n            return data;\n        },\n\n        /**\n         * Decode URL encoded component\n         *\n         * @param {String} string\n         * @return {String}\n         * @protected\n         */\n        decodeUriComponent: function(string) {\n            let result = string.replace(/\\+/g, '%20');\n            result = decodeURIComponent(result);\n            return result;\n        },\n\n        /**\n         * Invert object keys.\n         *\n         * Example of usage:\n         *\n         * oro.app.invertKeys({foo: 'x', bar: 'y'}, {foo: 'f', bar: 'b'})\n         * will return {f: 'x', b: 'y'}\n         *\n         * @param {Object} object\n         * @param {Object} keys\n         * @return {Object}\n         */\n        invertKeys: function(object, keys) {\n            const result = _.extend({}, object);\n            for (const key in keys) {\n                if (!keys.hasOwnProperty(key)) {\n                    continue;\n                }\n                const baseKey = key;\n                const mirrorKey = keys[key];\n\n                if (baseKey in result) {\n                    result[mirrorKey] = result[baseKey];\n                    delete result[baseKey];\n                }\n            }\n            return result;\n        },\n\n        /**\n         * Loosely compare two values\n         *\n         * @param {*} value1\n         * @param {*} value2\n         * @return {Boolean} TRUE if values are equal, otherwise - FALSE\n         */\n        isEqualsLoosely: function(value1, value2) {\n            if (!_.isObject(value1)) {\n                if (_.isNumber(value1) || _.isNumber(value2)) {\n                    const toNumber = function(v) {\n                        if (_.isString(v) && v === '') {\n                            return NaN;\n                        }\n                        return Number(v);\n                    };\n                    return (toNumber(value1) === toNumber(value2));\n                }\n                return ((value1 || '') === (value2 || ''));\n            } else if (_.isObject(value1)) {\n                let valueKeys = _.keys(value1);\n\n                if (_.isObject(value2)) {\n                    valueKeys = _.unique(valueKeys.concat(_.keys(value2)));\n                    for (const index in valueKeys) {\n                        if (!valueKeys.hasOwnProperty(index)) {\n                            continue;\n                        }\n                        const key = valueKeys[index];\n                        if (!_.has(value2, key) || !this.isEqualsLoosely(value1[key], value2[key])) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return false;\n            } else {\n                return value1 == value2; // eslint-disable-line eqeqeq\n            }\n        },\n\n        /**\n         * Deep clone a value\n         *\n         * @param {*} value\n         * @return {*}\n         */\n        deepClone: function(value) {\n            return $.extend(true, {}, value);\n        },\n\n        /**\n         * Are we currently on mobile\n         */\n        isMobile: function() {\n            return _.isMobile();\n        },\n\n        /**\n         * Are we currently on desktop\n         */\n        isDesktop: function() {\n            return _.isDesktop();\n        },\n\n        /**\n         * Are we have touch screen\n         */\n        isTouchDevice: function() {\n            return 'ontouchstart' in window ||\n                window.DocumentTouch && document instanceof window.DocumentTouch ||\n                navigator.maxTouchPoints > 0 ||\n                window.navigator.msMaxTouchPoints > 0;\n        },\n\n        /**\n         * Are we currently on iOS device\n         */\n        isIOS: function() {\n            return iOS || iPadOS;\n        },\n\n        /**\n         * Loads dynamic list of modules and execute callback function with passed modules\n         *\n         * @deprecated use 'oroui/js/app/services/load-modules'\n         * @param {Object.<string, string>|Array.<string>|string} modules\n         *  - Object: where keys are formal module names and values are actual\n         *  - Array: module names,\n         *  - string: single module name\n         * @param {function(Object)=} callback\n         * @param {Object=} context\n         * @return {Promise}\n         */\n        loadModules: loadModules,\n\n        /**\n         * Loads single module and returns promise\n         *\n         * @deprecated use 'oroui/js/app/services/load-modules'\n         * @param {string} module name\n         * @return {Promise}\n         */\n        loadModule: loadModules,\n\n        /**\n         * Loads single module and replaces the property\n         *\n         * @param {Object} container where to replace property\n         * @param {string} moduleProperty name to replace module ref to concrete realization\n         * @return {JQueryPromise}\n         */\n        loadModuleAndReplace: function(container, moduleProperty) {\n            if (typeof container[moduleProperty] !== 'string') {\n                const deferred = $.Deferred();\n                deferred.resolve(container[moduleProperty]);\n                return deferred.promise();\n            }\n            return loadModules(container[moduleProperty]).then(function(realization) {\n                container[moduleProperty] = realization;\n                return realization;\n            });\n        },\n\n        /**\n         * Check if current page is an error page (404, 503, 504, etc.)\n         * @returns {boolean}\n         */\n        isErrorPage: function() {\n            return Boolean($('meta[name=error]').length);\n        },\n\n        /**\n         * Creates safe regexp expression from string\n         *\n         * @param {string} str\n         * @param {string} flags\n         */\n        safeRegExp: function(str, flags) {\n            str = str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n            const expression = new RegExp('(' + str + ')', flags);\n            return expression;\n        },\n\n        /**\n         * Generates Version 4 random UUIDs (https://en.wikipedia.org/wiki/Universally_unique_identifier)\n         * @return {string}\n         */\n        createRandomUUID: function() {\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n                const r = Math.random() * 16 | 0;\n                const v = c === 'x' ? r : (r & 0x3 | 0x8);\n                return v.toString(16);\n            });\n        },\n\n        /**\n         * Checks input values and if it isn't an array wraps it\n         *\n         * @returns {Array}\n         */\n        ensureArray: function(value) {\n            return _.isArray(value) ? value : [value];\n        },\n\n        /**\n         * Check is this object can be represented as an array\n         *\n         * @param {Object} object\n         * @returns {boolean}\n         */\n        isArrayLikeObject: function(object) {\n            if (typeof object !== 'object') {\n                return false;\n            }\n            const keys = _.keys(object);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                if (String(key) !== String(i)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Checks if passed value represents a number (e.g. 3.5 and '3.5' are numeric)\n         *\n         * @param {*} value\n         * @return {boolean}\n         */\n        isNumeric: function(value) {\n            return !isNaN(parseFloat(value)) && isFinite(value);\n        },\n\n        /**\n         * Adds css rules to the first style sheet\n         *\n         * @param {string} selector\n         * @param {string} styles\n         */\n        addCSSRule: function(selector, styles) {\n            const css = `${selector} { ${styles} }`;\n            const ID = '__runtime-styles';\n            const style = document.getElementById(ID) || (() => {\n                const head = document.head || document.getElementsByTagName('head')[0];\n                const style = document.createElement('style');\n                style.type = 'text/css';\n                style.id = ID;\n                head.appendChild(style);\n                return style;\n            })();\n\n            style.appendChild(document.createTextNode(css));\n        },\n\n        /**\n         * @param {Object} event\n         */\n        isTargetBlankEvent: function(event) {\n            const mouseMiddleButton = 2;\n            return event.shiftKey || event.altKey || event.ctrlKey || event.metaKey ||\n                event.which === mouseMiddleButton;\n        },\n\n        /**\n         * Gets an XPath for an element which describes its hierarchical location.\n         *\n         * @param {HTMLElement} element\n         * @returns {string|null}\n         */\n        getElementXPath: function(element) {\n            const paths = [];\n            let tagName;\n            if (element && element.id) {\n                tagName = element.nodeName.toLowerCase();\n                return '//' + tagName + '[@id=\"' + element.id + '\"]';\n            } else {\n                // Use nodeName (instead of localName) so namespace prefix is included (if any).\n                for (; element && element.nodeType === 1; element = element.parentNode) {\n                    let index = 0;\n                    tagName = element.nodeName.toLowerCase();\n                    // EXTRA TEST FOR ELEMENT.ID\n                    if (element && element.id) {\n                        paths.splice(0, 0, '/' + tagName + '[@id=\"' + element.id + '\"]');\n                        break;\n                    }\n\n                    for (let sibling = element.previousSibling; sibling; sibling = sibling.previousSibling) {\n                        // Ignore document type declaration.\n                        if (sibling.nodeType === Node.DOCUMENT_TYPE_NODE) {\n                            continue;\n                        }\n                        if (sibling.nodeName === element.nodeName) {\n                            ++index;\n                        }\n                    }\n\n                    const pathIndex = '[' + (index + 1) + ']';\n                    const classAttr = element.className ? '[@class=\"' + element.className + '\"]' : '';\n                    paths.splice(0, 0, tagName + pathIndex + classAttr);\n                }\n\n                return paths.length ? '/' + paths.join('/') : null;\n            }\n        },\n\n        /**\n         * Gets unique CSS selector for DOM element.\n         *\n         * @param {HTMLElement} element\n         * @param {boolean} [clearPath=true]\n         * @returns {string}\n         */\n        getElementCSSPath: function(element, clearPath = true) {\n            const buildPath = (el, path = []) => {\n                if (el && el.nodeType === Node.ELEMENT_NODE) {\n                    let part = el.nodeName.toLowerCase();\n\n                    if (el.className) {\n                        part += `.${el.className.trim().split(' ')[0]}`;\n                    }\n\n                    if (el.nodeName !== 'HTML') {\n                        part += `:nth-child(${$(el).index() + 1})`;\n                    }\n\n                    return buildPath(el.parentNode, path.concat([part]));\n                } else {\n                    const preparedPath = path.reverse().join(' > ');\n\n                    if (clearPath) {\n                        const regExp = /(\\.js-focus-visible|\\.focus-visible|\\.hide|\\.show)/;\n\n                        return preparedPath.replace(new RegExp(regExp, 'g'), '');\n                    }\n\n                    return preparedPath;\n                }\n            };\n\n            return buildPath(element);\n        },\n\n        getPrototypeChain: function(object) {\n            const chain = [];\n            while (object = Object.getPrototypeOf(object)) {\n                chain.unshift(object);\n            }\n            return chain;\n        },\n\n        getAllPropertyVersions: function(object, name) {\n            const versions = [];\n            const prototypeChain = tools.getPrototypeChain(object);\n            prototypeChain.forEach(prototype => {\n                if (prototype.hasOwnProperty(name)) {\n                    versions.push(prototype[name]);\n                }\n            });\n            return versions;\n        }\n    });\n\n    return tools;\n});\n"], "fixing_code": ["define(function(require) {\n    'use strict';\n\n    const $ = require('jquery');\n    const _ = require('underscore');\n    const loadModules = require('oroui/js/app/services/load-modules');\n    const tools = {};\n    const iOS = /(iPad|iPhone)/.test(navigator.userAgent);\n    const iPadOS = !!(navigator.userAgent.match(/Mac/) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2);\n\n    /**\n     * @export oroui/js/tools\n     * @name   oroui.tools\n     */\n    _.extend(tools, {\n        /** @type {boolean} */\n        debug: false,\n        /**\n         * Pack object to string\n         *\n         * Object {foo: 'x', 'bar': 'y'} will be converted to string \"foo=x&bar=y\".\n         *\n         * @param {Object} object\n         * @return {String}\n         */\n        packToQueryString: function(object) {\n            return $.param(object);\n        },\n\n        /**\n         * Pack object to string with query parameters sorted\n         *\n         * Object {foo: 'x', 'bar': 'y'} will be converted to string \"foo=x&bar=y\".\n         *\n         * @param {Object} object\n         * @return {String}\n         */\n        packToQuerySortedString: function(object) {\n            const self = this;\n            const result = [];\n            const add = function(key, value) {\n                result[result.length] = encodeURIComponent(key) + '=' +\n                    encodeURIComponent(value === null ? '' : value);\n            };\n\n            const buildParams = function(pref, obj) {\n                if (self.isArrayLikeObject(obj)) {\n                    obj = _.toArray(obj);\n                }\n\n                if (_.isArray(obj)) {\n                    obj.sort();\n                    _.each(obj, function(value, key) {\n                        buildParams(pref + '[' + (typeof value === 'object' ? key : '') + ']', value);\n                    });\n                } else if (typeof obj === 'object') {\n                    const keys = _.keys(obj);\n                    keys.sort();\n                    for (let i = 0; i < keys.length; i++) {\n                        const name = keys[i];\n                        buildParams(pref + '[' + name + ']', obj[name]);\n                    }\n                } else {\n                    add(pref, obj);\n                }\n            };\n\n            const keys = _.keys(object);\n            keys.sort();\n            for (let i = 0; i < keys.length; i++) {\n                const prefix = keys[i];\n                buildParams(prefix, object[prefix]);\n            }\n            return result.join('&');\n        },\n\n        /**\n         * Unpack string to object. Reverse from packToQueryString.\n         *\n         * @param {String} query\n         * @return {Object}\n         */\n        unpackFromQueryString: function(query) {\n            if (query.charAt(0) === '?') {\n                query = query.slice(1);\n            }\n            const setValue = function(root, path, value) {\n                if (path[0] === '__proto__') {\n                    // Prevent Object.prototype pollution\n                    return;\n                }\n                if (path.length > 1) {\n                    const dir = path.shift();\n                    if (typeof root[dir] === 'undefined') {\n                        root[dir] = path[0] === '' ? [] : {};\n                    }\n                    setValue(root[dir], path, value);\n                } else {\n                    if (root instanceof Array) {\n                        root.push(value);\n                    } else {\n                        root[path] = value;\n                    }\n                }\n            };\n            const nvp = query.split('&');\n            const data = {};\n            for (let i = 0; i < nvp.length; i++) {\n                const pair = nvp[i].split('=');\n                if (pair.length < 2) {\n                    continue;\n                }\n                const name = this.decodeUriComponent(pair[0]);\n                const value = this.decodeUriComponent(pair[1]);\n\n                let path = name.match(/(^[^\\[]+)(\\[.*\\]$)?/);\n                const first = path[1];\n                if (path[2]) {\n                    // case of 'array[level1]' || 'array[level1][level2]'\n                    path = path[2].match(/(?=\\[(.*)\\]$)/)[1].split('][');\n                } else {\n                    // case of 'name'\n                    path = [];\n                }\n                path.unshift(first);\n\n                setValue(data, path, value);\n            }\n            return data;\n        },\n\n        /**\n         * Decode URL encoded component\n         *\n         * @param {String} string\n         * @return {String}\n         * @protected\n         */\n        decodeUriComponent: function(string) {\n            let result = string.replace(/\\+/g, '%20');\n            result = decodeURIComponent(result);\n            return result;\n        },\n\n        /**\n         * Invert object keys.\n         *\n         * Example of usage:\n         *\n         * oro.app.invertKeys({foo: 'x', bar: 'y'}, {foo: 'f', bar: 'b'})\n         * will return {f: 'x', b: 'y'}\n         *\n         * @param {Object} object\n         * @param {Object} keys\n         * @return {Object}\n         */\n        invertKeys: function(object, keys) {\n            const result = _.extend({}, object);\n            for (const key in keys) {\n                if (!keys.hasOwnProperty(key)) {\n                    continue;\n                }\n                const baseKey = key;\n                const mirrorKey = keys[key];\n\n                if (baseKey in result) {\n                    result[mirrorKey] = result[baseKey];\n                    delete result[baseKey];\n                }\n            }\n            return result;\n        },\n\n        /**\n         * Loosely compare two values\n         *\n         * @param {*} value1\n         * @param {*} value2\n         * @return {Boolean} TRUE if values are equal, otherwise - FALSE\n         */\n        isEqualsLoosely: function(value1, value2) {\n            if (!_.isObject(value1)) {\n                if (_.isNumber(value1) || _.isNumber(value2)) {\n                    const toNumber = function(v) {\n                        if (_.isString(v) && v === '') {\n                            return NaN;\n                        }\n                        return Number(v);\n                    };\n                    return (toNumber(value1) === toNumber(value2));\n                }\n                return ((value1 || '') === (value2 || ''));\n            } else if (_.isObject(value1)) {\n                let valueKeys = _.keys(value1);\n\n                if (_.isObject(value2)) {\n                    valueKeys = _.unique(valueKeys.concat(_.keys(value2)));\n                    for (const index in valueKeys) {\n                        if (!valueKeys.hasOwnProperty(index)) {\n                            continue;\n                        }\n                        const key = valueKeys[index];\n                        if (!_.has(value2, key) || !this.isEqualsLoosely(value1[key], value2[key])) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return false;\n            } else {\n                return value1 == value2; // eslint-disable-line eqeqeq\n            }\n        },\n\n        /**\n         * Deep clone a value\n         *\n         * @param {*} value\n         * @return {*}\n         */\n        deepClone: function(value) {\n            return $.extend(true, {}, value);\n        },\n\n        /**\n         * Are we currently on mobile\n         */\n        isMobile: function() {\n            return _.isMobile();\n        },\n\n        /**\n         * Are we currently on desktop\n         */\n        isDesktop: function() {\n            return _.isDesktop();\n        },\n\n        /**\n         * Are we have touch screen\n         */\n        isTouchDevice: function() {\n            return 'ontouchstart' in window ||\n                window.DocumentTouch && document instanceof window.DocumentTouch ||\n                navigator.maxTouchPoints > 0 ||\n                window.navigator.msMaxTouchPoints > 0;\n        },\n\n        /**\n         * Are we currently on iOS device\n         */\n        isIOS: function() {\n            return iOS || iPadOS;\n        },\n\n        /**\n         * Loads dynamic list of modules and execute callback function with passed modules\n         *\n         * @deprecated use 'oroui/js/app/services/load-modules'\n         * @param {Object.<string, string>|Array.<string>|string} modules\n         *  - Object: where keys are formal module names and values are actual\n         *  - Array: module names,\n         *  - string: single module name\n         * @param {function(Object)=} callback\n         * @param {Object=} context\n         * @return {Promise}\n         */\n        loadModules: loadModules,\n\n        /**\n         * Loads single module and returns promise\n         *\n         * @deprecated use 'oroui/js/app/services/load-modules'\n         * @param {string} module name\n         * @return {Promise}\n         */\n        loadModule: loadModules,\n\n        /**\n         * Loads single module and replaces the property\n         *\n         * @param {Object} container where to replace property\n         * @param {string} moduleProperty name to replace module ref to concrete realization\n         * @return {JQueryPromise}\n         */\n        loadModuleAndReplace: function(container, moduleProperty) {\n            if (typeof container[moduleProperty] !== 'string') {\n                const deferred = $.Deferred();\n                deferred.resolve(container[moduleProperty]);\n                return deferred.promise();\n            }\n            return loadModules(container[moduleProperty]).then(function(realization) {\n                container[moduleProperty] = realization;\n                return realization;\n            });\n        },\n\n        /**\n         * Check if current page is an error page (404, 503, 504, etc.)\n         * @returns {boolean}\n         */\n        isErrorPage: function() {\n            return Boolean($('meta[name=error]').length);\n        },\n\n        /**\n         * Creates safe regexp expression from string\n         *\n         * @param {string} str\n         * @param {string} flags\n         */\n        safeRegExp: function(str, flags) {\n            str = str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n            const expression = new RegExp('(' + str + ')', flags);\n            return expression;\n        },\n\n        /**\n         * Generates Version 4 random UUIDs (https://en.wikipedia.org/wiki/Universally_unique_identifier)\n         * @return {string}\n         */\n        createRandomUUID: function() {\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n                const r = Math.random() * 16 | 0;\n                const v = c === 'x' ? r : (r & 0x3 | 0x8);\n                return v.toString(16);\n            });\n        },\n\n        /**\n         * Checks input values and if it isn't an array wraps it\n         *\n         * @returns {Array}\n         */\n        ensureArray: function(value) {\n            return _.isArray(value) ? value : [value];\n        },\n\n        /**\n         * Check is this object can be represented as an array\n         *\n         * @param {Object} object\n         * @returns {boolean}\n         */\n        isArrayLikeObject: function(object) {\n            if (typeof object !== 'object') {\n                return false;\n            }\n            const keys = _.keys(object);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                if (String(key) !== String(i)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Checks if passed value represents a number (e.g. 3.5 and '3.5' are numeric)\n         *\n         * @param {*} value\n         * @return {boolean}\n         */\n        isNumeric: function(value) {\n            return !isNaN(parseFloat(value)) && isFinite(value);\n        },\n\n        /**\n         * Adds css rules to the first style sheet\n         *\n         * @param {string} selector\n         * @param {string} styles\n         */\n        addCSSRule: function(selector, styles) {\n            const css = `${selector} { ${styles} }`;\n            const ID = '__runtime-styles';\n            const style = document.getElementById(ID) || (() => {\n                const head = document.head || document.getElementsByTagName('head')[0];\n                const style = document.createElement('style');\n                style.type = 'text/css';\n                style.id = ID;\n                head.appendChild(style);\n                return style;\n            })();\n\n            style.appendChild(document.createTextNode(css));\n        },\n\n        /**\n         * @param {Object} event\n         */\n        isTargetBlankEvent: function(event) {\n            const mouseMiddleButton = 2;\n            return event.shiftKey || event.altKey || event.ctrlKey || event.metaKey ||\n                event.which === mouseMiddleButton;\n        },\n\n        /**\n         * Gets an XPath for an element which describes its hierarchical location.\n         *\n         * @param {HTMLElement} element\n         * @returns {string|null}\n         */\n        getElementXPath: function(element) {\n            const paths = [];\n            let tagName;\n            if (element && element.id) {\n                tagName = element.nodeName.toLowerCase();\n                return '//' + tagName + '[@id=\"' + element.id + '\"]';\n            } else {\n                // Use nodeName (instead of localName) so namespace prefix is included (if any).\n                for (; element && element.nodeType === 1; element = element.parentNode) {\n                    let index = 0;\n                    tagName = element.nodeName.toLowerCase();\n                    // EXTRA TEST FOR ELEMENT.ID\n                    if (element && element.id) {\n                        paths.splice(0, 0, '/' + tagName + '[@id=\"' + element.id + '\"]');\n                        break;\n                    }\n\n                    for (let sibling = element.previousSibling; sibling; sibling = sibling.previousSibling) {\n                        // Ignore document type declaration.\n                        if (sibling.nodeType === Node.DOCUMENT_TYPE_NODE) {\n                            continue;\n                        }\n                        if (sibling.nodeName === element.nodeName) {\n                            ++index;\n                        }\n                    }\n\n                    const pathIndex = '[' + (index + 1) + ']';\n                    const classAttr = element.className ? '[@class=\"' + element.className + '\"]' : '';\n                    paths.splice(0, 0, tagName + pathIndex + classAttr);\n                }\n\n                return paths.length ? '/' + paths.join('/') : null;\n            }\n        },\n\n        /**\n         * Gets unique CSS selector for DOM element.\n         *\n         * @param {HTMLElement} element\n         * @param {boolean} [clearPath=true]\n         * @returns {string}\n         */\n        getElementCSSPath: function(element, clearPath = true) {\n            const buildPath = (el, path = []) => {\n                if (el && el.nodeType === Node.ELEMENT_NODE) {\n                    let part = el.nodeName.toLowerCase();\n\n                    if (el.className) {\n                        part += `.${el.className.trim().split(' ')[0]}`;\n                    }\n\n                    if (el.nodeName !== 'HTML') {\n                        part += `:nth-child(${$(el).index() + 1})`;\n                    }\n\n                    return buildPath(el.parentNode, path.concat([part]));\n                } else {\n                    const preparedPath = path.reverse().join(' > ');\n\n                    if (clearPath) {\n                        const regExp = /(\\.js-focus-visible|\\.focus-visible|\\.hide|\\.show)/;\n\n                        return preparedPath.replace(new RegExp(regExp, 'g'), '');\n                    }\n\n                    return preparedPath;\n                }\n            };\n\n            return buildPath(element);\n        },\n\n        getPrototypeChain: function(object) {\n            const chain = [];\n            while (object = Object.getPrototypeOf(object)) {\n                chain.unshift(object);\n            }\n            return chain;\n        },\n\n        getAllPropertyVersions: function(object, name) {\n            const versions = [];\n            const prototypeChain = tools.getPrototypeChain(object);\n            prototypeChain.forEach(prototype => {\n                if (prototype.hasOwnProperty(name)) {\n                    versions.push(prototype[name]);\n                }\n            });\n            return versions;\n        }\n    });\n\n    return tools;\n});\n"], "filenames": ["src/Oro/Bundle/UIBundle/Resources/public/js/tools.js"], "buggy_code_start_loc": [87], "buggy_code_end_loc": [87], "fixing_code_start_loc": [88], "fixing_code_end_loc": [92], "type": "CWE-1321", "message": "OroPlatform is a PHP Business Application Platform. In affected versions by sending a specially crafted request, an attacker could inject properties into existing JavaScript language construct prototypes, such as objects. Later this injection may lead to JS code execution by libraries that are vulnerable to Prototype Pollution. This issue has been patched in version 4.2.8. Users unable to upgrade may configure a firewall to drop requests containing next strings: `__proto__` , `constructor[prototype]`, and `constructor.prototype` to mitigate this issue.", "other": {"cve": {"id": "CVE-2021-43852", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-04T20:15:07.730", "lastModified": "2022-01-12T21:11:39.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OroPlatform is a PHP Business Application Platform. In affected versions by sending a specially crafted request, an attacker could inject properties into existing JavaScript language construct prototypes, such as objects. Later this injection may lead to JS code execution by libraries that are vulnerable to Prototype Pollution. This issue has been patched in version 4.2.8. Users unable to upgrade may configure a firewall to drop requests containing next strings: `__proto__` , `constructor[prototype]`, and `constructor.prototype` to mitigate this issue."}, {"lang": "es", "value": "OroPlatform es una plataforma de aplicaciones empresariales PHP. En las versiones afectadas, mediante el env\u00edo de una petici\u00f3n especialmente dise\u00f1ada, un atacante podr\u00eda inyectar propiedades en los prototipos de construcci\u00f3n del lenguaje JavaScript existentes, como los objetos. Posteriormente esta inyecci\u00f3n podr\u00eda conllevar a una ejecuci\u00f3n de c\u00f3digo JS por parte de las librer\u00edas que son vulnerables a una Contaminaci\u00f3n de Prototipos. Este problema ha sido parcheado en la versi\u00f3n 4.2.8. Los usuarios que no puedan actualizar pueden configurar un firewall para que elimine las peticiones que contengan las siguientes cadenas \"__proto__\", \"constructor[prototype]\", y \"constructor.prototype\" para mitigar este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oroinc:oroplatform:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.14", "matchCriteriaId": "87F8B0EB-6235-4EA7-9D34-F2FDF469C1C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oroinc:oroplatform:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2.0", "versionEndExcluding": "4.2.8", "matchCriteriaId": "2BB63725-D5A6-4440-BC10-A003B18ADF5B"}]}]}], "references": [{"url": "https://github.com/oroinc/platform/commit/62c26936b3adee9c20255dcd9f8ee5c299b464a9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/oroinc/platform/security/advisories/GHSA-jx5q-g37m-h5hj", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/oroinc/platform/commit/62c26936b3adee9c20255dcd9f8ee5c299b464a9"}}