{"buggy_code": ["/*\n * ndpi_main.c\n *\n * Copyright (C) 2011-20 - ntop.org\n *\n * This file is part of nDPI, an open source deep packet inspection\n * library based on the OpenDPI and PACE technology by ipoque GmbH\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/types.h>\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_UNKNOWN\n\n#include \"ndpi_config.h\"\n#include \"ndpi_api.h\"\n#include \"ahocorasick.h\"\n#include \"libcache.h\"\n\n#include <time.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n\n#if defined __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__\n#include <sys/endian.h>\n#endif\n\n#include \"ndpi_content_match.c.inc\"\n#include \"third_party/include/ndpi_patricia.h\"\n#include \"third_party/include/ht_hash.h\"\n#include \"third_party/include/ndpi_md5.h\"\n\n/* stun.c */\nextern u_int32_t get_stun_lru_key(struct ndpi_flow_struct *flow, u_int8_t rev);\n\nstatic int _ndpi_debug_callbacks = 0;\n\n/* #define MATCH_DEBUG 1 */\n\n/* ****************************************** */\n\nstatic void *(*_ndpi_flow_malloc)(size_t size);\nstatic void (*_ndpi_flow_free)(void *ptr);\n\nstatic void *(*_ndpi_malloc)(size_t size);\nstatic void (*_ndpi_free)(void *ptr);\n\n/* ****************************************** */\n\n/* Forward */\nstatic void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str, ndpi_port_range *range,\n                           ndpi_proto_defaults_t *def, u_int8_t customUserProto, ndpi_default_ports_tree_node_t **root,\n                           const char *_func, int _line);\n\nstatic int removeDefaultPort(ndpi_port_range *range, ndpi_proto_defaults_t *def, ndpi_default_ports_tree_node_t **root);\n\n/* ****************************************** */\n\nstatic inline uint8_t flow_is_proto(struct ndpi_flow_struct *flow, u_int16_t p) {\n  return((flow->detected_protocol_stack[0] == p) || (flow->detected_protocol_stack[1] == p));\n}\n\n/* ****************************************** */\n\nvoid *ndpi_malloc(size_t size) {\n  return(_ndpi_malloc ? _ndpi_malloc(size) : malloc(size));\n}\nvoid *ndpi_flow_malloc(size_t size) {\n  return(_ndpi_flow_malloc ? _ndpi_flow_malloc(size) : ndpi_malloc(size));\n}\n\n/* ****************************************** */\n\nvoid *ndpi_calloc(unsigned long count, size_t size) {\n  size_t len = count * size;\n  void *p = ndpi_malloc(len);\n\n  if(p)\n    memset(p, 0, len);\n\n  return(p);\n}\n\n/* ****************************************** */\n\nvoid ndpi_free(void *ptr) {\n  if(_ndpi_free)\n    _ndpi_free(ptr);\n  else\n    free(ptr);\n}\n\n/* ****************************************** */\n\nvoid ndpi_flow_free(void *ptr) {\n  if(_ndpi_flow_free)\n    _ndpi_flow_free(ptr);\n  else\n    ndpi_free_flow((struct ndpi_flow_struct *) ptr);\n}\n\n/* ****************************************** */\n\nvoid *ndpi_realloc(void *ptr, size_t old_size, size_t new_size) {\n  void *ret = ndpi_malloc(new_size);\n\n  if(!ret)\n    return(ret);\n  else {\n    memcpy(ret, ptr, old_size);\n    ndpi_free(ptr);\n    return(ret);\n  }\n}\n/* ****************************************** */\n\nchar *ndpi_strdup(const char *s) {\n  int len = strlen(s);\n  char *m = ndpi_malloc(len + 1);\n\n  if(m) {\n    memcpy(m, s, len);\n    m[len] = '\\0';\n  }\n\n  return(m);\n}\n\n/* *********************************************************************************** */\n\n/* Opaque structure defined here */\nstruct ndpi_ptree\n{\n  patricia_tree_t *v4;\n  patricia_tree_t *v6;\n};\n\n/* *********************************************************************************** */\n\nu_int32_t ndpi_detection_get_sizeof_ndpi_flow_struct(void) {\n  return(sizeof(struct ndpi_flow_struct));\n}\n\n/* *********************************************************************************** */\n\nu_int32_t ndpi_detection_get_sizeof_ndpi_id_struct(void) {\n  return(sizeof(struct ndpi_id_struct));\n}\n\n/* *********************************************************************************** */\n\nu_int32_t ndpi_detection_get_sizeof_ndpi_flow_tcp_struct(void) {\n  return(sizeof(struct ndpi_flow_tcp_struct));\n}\n\n/* *********************************************************************************** */\n\nu_int32_t ndpi_detection_get_sizeof_ndpi_flow_udp_struct(void) {\n  return(sizeof(struct ndpi_flow_udp_struct));\n}\n\n/* *********************************************************************************** */\n\nchar *ndpi_get_proto_by_id(struct ndpi_detection_module_struct *ndpi_str, u_int id) {\n  return((id >= ndpi_str->ndpi_num_supported_protocols) ? NULL : ndpi_str->proto_defaults[id].protoName);\n}\n\n/* *********************************************************************************** */\n\nu_int16_t ndpi_get_proto_by_name(struct ndpi_detection_module_struct *ndpi_str, const char *name) {\n  u_int16_t i, num = ndpi_get_num_supported_protocols(ndpi_str);\n\n  for (i = 0; i < num; i++)\n    if(strcasecmp(ndpi_get_proto_by_id(ndpi_str, i), name) == 0)\n      return(i);\n\n  return(NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ************************************************************************************* */\n\n#ifdef CODE_UNUSED\nndpi_port_range *ndpi_build_default_ports_range(ndpi_port_range *ports, u_int16_t portA_low, u_int16_t portA_high,\n                                                u_int16_t portB_low, u_int16_t portB_high, u_int16_t portC_low,\n                                                u_int16_t portC_high, u_int16_t portD_low, u_int16_t portD_high,\n                                                u_int16_t portE_low, u_int16_t portE_high) {\n  int i = 0;\n\n  ports[i].port_low = portA_low, ports[i].port_high = portA_high;\n  i++;\n  ports[i].port_low = portB_low, ports[i].port_high = portB_high;\n  i++;\n  ports[i].port_low = portC_low, ports[i].port_high = portC_high;\n  i++;\n  ports[i].port_low = portD_low, ports[i].port_high = portD_high;\n  i++;\n  ports[i].port_low = portE_low, ports[i].port_high = portE_high;\n\n  return(ports);\n}\n#endif\n\n/* *********************************************************************************** */\n\nndpi_port_range *ndpi_build_default_ports(ndpi_port_range *ports, u_int16_t portA, u_int16_t portB, u_int16_t portC,\n                                          u_int16_t portD, u_int16_t portE) {\n  int i = 0;\n\n  ports[i].port_low = portA, ports[i].port_high = portA;\n  i++;\n  ports[i].port_low = portB, ports[i].port_high = portB;\n  i++;\n  ports[i].port_low = portC, ports[i].port_high = portC;\n  i++;\n  ports[i].port_low = portD, ports[i].port_high = portD;\n  i++;\n  ports[i].port_low = portE, ports[i].port_high = portE;\n\n  return(ports);\n}\n\n/* ********************************************************************************** */\n\nvoid ndpi_set_proto_breed(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId, ndpi_protocol_breed_t breed) {\n  if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)\n    return;\n  else\n    ndpi_str->proto_defaults[protoId].protoBreed = breed;\n}\n\n/* ********************************************************************************** */\n\nvoid ndpi_set_proto_category(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId,\n                             ndpi_protocol_category_t protoCategory) {\n  if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)\n    return;\n  else\n    ndpi_str->proto_defaults[protoId].protoCategory = protoCategory;\n}\n\n/* ********************************************************************************** */\n\n/*\n  There are some (master) protocols that are informative, meaning that it shows\n  what is the subprotocol about, but also that the subprotocol isn't a real protocol.\n\n  Example:\n  - DNS is informative as if we see a DNS request for www.facebook.com, the\n  returned protocol is DNS.Facebook, but Facebook isn't a real subprotocol but\n  rather it indicates a query for Facebook and not Facebook traffic.\n  - HTTP/SSL are NOT informative as SSL.Facebook (likely) means that this is\n  SSL (HTTPS) traffic containg Facebook traffic.\n*/\nu_int8_t ndpi_is_subprotocol_informative(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId) {\n  if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)\n    return(0);\n\n  switch (protoId) {\n    /* All dissectors that have calls to ndpi_match_host_subprotocol() */\n  case NDPI_PROTOCOL_DNS:\n    return(1);\n    break;\n\n  default:\n    return(0);\n  }\n}\n/* ********************************************************************************** */\n\nvoid ndpi_exclude_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                           u_int16_t protocol_id, const char *_file, const char *_func, int _line) {\n  if(protocol_id < NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n    if(ndpi_str && ndpi_str->ndpi_log_level >= NDPI_LOG_DEBUG && ndpi_str->ndpi_debug_printf != NULL) {\n      (*(ndpi_str->ndpi_debug_printf))(protocol_id, ndpi_str, NDPI_LOG_DEBUG, _file, _func, _line, \"exclude %s\\n\",\n\t\t\t\t       ndpi_get_proto_name(ndpi_str, protocol_id));\n    }\n#endif\n    NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, protocol_id);\n  }\n}\n\n/* ********************************************************************************** */\n\nvoid ndpi_set_proto_defaults(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_breed_t breed,\n                             u_int16_t protoId, u_int8_t can_have_a_subprotocol, u_int16_t tcp_master_protoId[2],\n                             u_int16_t udp_master_protoId[2], char *protoName, ndpi_protocol_category_t protoCategory,\n                             ndpi_port_range *tcpDefPorts, ndpi_port_range *udpDefPorts) {\n  char *name;\n  int j;\n\n  if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {\n#ifdef DEBUG\n    NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: INTERNAL ERROR\\n\", protoName, protoId);\n#endif\n    return;\n  }\n\n  if(ndpi_str->proto_defaults[protoId].protoName != NULL) {\n#ifdef DEBUG\n    NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: already initialized. Ignoring it\\n\", protoName, protoId);\n#endif\n    return;\n  }\n\n  name = ndpi_strdup(protoName);\n\n  if(ndpi_str->proto_defaults[protoId].protoName)\n    ndpi_free(ndpi_str->proto_defaults[protoId].protoName);\n\n  ndpi_str->proto_defaults[protoId].protoName = name, ndpi_str->proto_defaults[protoId].protoCategory = protoCategory,\n    ndpi_str->proto_defaults[protoId].protoId = protoId, ndpi_str->proto_defaults[protoId].protoBreed = breed;\n  ndpi_str->proto_defaults[protoId].can_have_a_subprotocol = can_have_a_subprotocol;\n\n  memcpy(&ndpi_str->proto_defaults[protoId].master_tcp_protoId, tcp_master_protoId, 2 * sizeof(u_int16_t));\n  memcpy(&ndpi_str->proto_defaults[protoId].master_udp_protoId, udp_master_protoId, 2 * sizeof(u_int16_t));\n\n  for (j = 0; j < MAX_DEFAULT_PORTS; j++) {\n    if(udpDefPorts[j].port_low != 0)\n      addDefaultPort(ndpi_str, &udpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->udpRoot,\n\t\t     __FUNCTION__, __LINE__);\n\n    if(tcpDefPorts[j].port_low != 0)\n      addDefaultPort(ndpi_str, &tcpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->tcpRoot,\n\t\t     __FUNCTION__, __LINE__);\n\n    /* No port range, just the lower port */\n    ndpi_str->proto_defaults[protoId].tcp_default_ports[j] = tcpDefPorts[j].port_low;\n    ndpi_str->proto_defaults[protoId].udp_default_ports[j] = udpDefPorts[j].port_low;\n  }\n}\n\n/* ******************************************************************** */\n\nstatic int ndpi_default_ports_tree_node_t_cmp(const void *a, const void *b) {\n  ndpi_default_ports_tree_node_t *fa = (ndpi_default_ports_tree_node_t *) a;\n  ndpi_default_ports_tree_node_t *fb = (ndpi_default_ports_tree_node_t *) b;\n\n  //printf(\"[NDPI] %s(%d, %d)\\n\", __FUNCTION__, fa->default_port, fb->default_port);\n\n  return((fa->default_port == fb->default_port) ? 0 : ((fa->default_port < fb->default_port) ? -1 : 1));\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_default_ports_tree_node_t_walker(const void *node, const ndpi_VISIT which, const int depth) {\n  ndpi_default_ports_tree_node_t *f = *(ndpi_default_ports_tree_node_t **) node;\n\n  printf(\"<%d>Walk on node %s (%u)\\n\", depth,\n\t which == ndpi_preorder ?\n\t \"ndpi_preorder\" :\n\t which == ndpi_postorder ?\n\t \"ndpi_postorder\" :\n\t which == ndpi_endorder ? \"ndpi_endorder\" : which == ndpi_leaf ? \"ndpi_leaf\" : \"unknown\",\n\t f->default_port);\n}\n\n/* ******************************************************************** */\n\nstatic void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str, ndpi_port_range *range,\n                           ndpi_proto_defaults_t *def, u_int8_t customUserProto, ndpi_default_ports_tree_node_t **root,\n                           const char *_func, int _line) {\n  u_int16_t port;\n\n  for (port = range->port_low; port <= range->port_high; port++) {\n    ndpi_default_ports_tree_node_t *node =\n      (ndpi_default_ports_tree_node_t *) ndpi_malloc(sizeof(ndpi_default_ports_tree_node_t));\n    ndpi_default_ports_tree_node_t *ret;\n\n    if(!node) {\n      NDPI_LOG_ERR(ndpi_str, \"%s:%d not enough memory\\n\", _func, _line);\n      break;\n    }\n\n    node->proto = def, node->default_port = port, node->customUserProto = customUserProto;\n    ret = (ndpi_default_ports_tree_node_t *) ndpi_tsearch(node, (void *) root, ndpi_default_ports_tree_node_t_cmp); /* Add it to the tree */\n\n    if(ret != node) {\n      NDPI_LOG_DBG(ndpi_str, \"[NDPI] %s:%d found duplicate for port %u: overwriting it with new value\\n\", _func,\n\t\t   _line, port);\n\n      ret->proto = def;\n      ndpi_free(node);\n    }\n  }\n}\n\n/* ****************************************************** */\n\n/*\n  NOTE\n\n  This function must be called with a semaphore set, this in order to avoid\n  changing the datastructures while using them\n*/\nstatic int removeDefaultPort(ndpi_port_range *range, ndpi_proto_defaults_t *def, ndpi_default_ports_tree_node_t **root) {\n  ndpi_default_ports_tree_node_t node;\n  u_int16_t port;\n\n  for (port = range->port_low; port <= range->port_high; port++) {\n    ndpi_default_ports_tree_node_t *ret;\n\n    node.proto = def, node.default_port = port;\n    ret = (ndpi_default_ports_tree_node_t *) ndpi_tdelete(\n\t\t\t\t\t\t\t  &node, (void *) root, ndpi_default_ports_tree_node_t_cmp); /* Add it to the tree */\n\n    if(ret != NULL) {\n      ndpi_free((ndpi_default_ports_tree_node_t *) ret);\n      return(0);\n    }\n  }\n\n  return(-1);\n}\n\n/* ****************************************************** */\n\nstatic int ndpi_string_to_automa(struct ndpi_detection_module_struct *ndpi_str, ndpi_automa *automa, char *value,\n                                 u_int16_t protocol_id, ndpi_protocol_category_t category, ndpi_protocol_breed_t breed,\n                                 u_int8_t free_str_on_duplicate) {\n  AC_PATTERN_t ac_pattern;\n  AC_ERROR_t rc;\n\n  if((value == NULL) || (protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))) {\n    NDPI_LOG_ERR(ndpi_str, \"[NDPI] protoId=%d: INTERNAL ERROR\\n\", protocol_id);\n    return(-1);\n  }\n\n  if(automa->ac_automa == NULL)\n    return(-2);\n\n  ac_pattern.astring = value, ac_pattern.rep.number = protocol_id,\n    ac_pattern.rep.category = (u_int16_t) category, ac_pattern.rep.breed = (u_int16_t) breed;\n\n#ifdef MATCH_DEBUG\n  printf(\"Adding to automa [%s][protocol_id: %u][category: %u][breed: %u]\\n\", value, protocol_id, category, breed);\n#endif\n\n  if(value == NULL)\n    ac_pattern.length = 0;\n  else\n    ac_pattern.length = strlen(ac_pattern.astring);\n\n  rc = ac_automata_add(((AC_AUTOMATA_t *) automa->ac_automa), &ac_pattern);\n  if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS)\n    return(-2);\n  if(rc == ACERR_DUPLICATE_PATTERN && free_str_on_duplicate)\n    ndpi_free(value);\n\n  return(0);\n}\n\n/* ****************************************************** */\n\nstatic int ndpi_add_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *_value, int protocol_id,\n                                         ndpi_protocol_category_t category, ndpi_protocol_breed_t breed) {\n  int rv;\n  char *value = ndpi_strdup(_value);\n\n  if(!value)\n    return(-1);\n\n#ifdef DEBUG\n  NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding [%s][%d]\\n\", value, protocol_id);\n#endif\n\n  rv = ndpi_string_to_automa(ndpi_str, &ndpi_str->host_automa, value, protocol_id, category, breed, 1);\n\n  if(rv != 0)\n    ndpi_free(value);\n\n  return(rv);\n}\n\n/* ****************************************************** */\n\n#ifdef CODE_UNUSED\nint ndpi_add_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id,\n                                 ndpi_protocol_category_t category, ndpi_protocol_breed_t breed) {\n  return(ndpi_string_to_automa(ndpi_str, &ndpi_str->content_automa, value, protocol_id, category, breed, 0));\n}\n#endif\n\n/* ****************************************************** */\n\n/*\n  NOTE\n\n  This function must be called with a semaphore set, this in order to avoid\n  changing the datastructures while using them\n*/\nstatic int ndpi_remove_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id) {\n  NDPI_LOG_ERR(ndpi_str, \"[NDPI] Missing implementation for proto %s/%d\\n\", value, protocol_id);\n  return(-1);\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_init_protocol_match(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_match *match) {\n  u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};\n  ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];\n\n  if(ndpi_str->proto_defaults[match->protocol_id].protoName == NULL) {\n    ndpi_str->proto_defaults[match->protocol_id].protoName = ndpi_strdup(match->proto_name);\n\n    ndpi_str->proto_defaults[match->protocol_id].protoId = match->protocol_id;\n    ndpi_str->proto_defaults[match->protocol_id].protoCategory = match->protocol_category;\n    ndpi_str->proto_defaults[match->protocol_id].protoBreed = match->protocol_breed;\n\n    ndpi_set_proto_defaults(ndpi_str, ndpi_str->proto_defaults[match->protocol_id].protoBreed,\n\t\t\t    ndpi_str->proto_defaults[match->protocol_id].protoId, 0 /* can_have_a_subprotocol */,\n\t\t\t    no_master, no_master, ndpi_str->proto_defaults[match->protocol_id].protoName,\n\t\t\t    ndpi_str->proto_defaults[match->protocol_id].protoCategory,\n\t\t\t    ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t    ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  }\n\n  ndpi_add_host_url_subprotocol(ndpi_str, match->string_to_match, match->protocol_id, match->protocol_category,\n\t\t\t\tmatch->protocol_breed);\n}\n\n/* ******************************************************************** */\n\n/* Self check function to be called onli for testing purposes */\nvoid ndpi_self_check_host_match() {\n  u_int32_t i, j;\n\n  for (i = 0; host_match[i].string_to_match != NULL; i++) {\n    for (j = 0; host_match[j].string_to_match != NULL; j++) {\n      if((i != j) && (strcmp(host_match[i].string_to_match, host_match[j].string_to_match) == 0)) {\n\tprintf(\"[INTERNAL ERROR]: Duplicate string detected '%s' [id: %u, id %u]\\n\",\n\t       host_match[i].string_to_match, i, j);\n\tprintf(\"\\nPlease fix host_match[] in ndpi_content_match.c.inc\\n\");\n\texit(0);\n      }\n    }\n  }\n}\n\n/* ******************************************************************** */\n\nstatic void init_string_based_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  int i;\n\n  for (i = 0; host_match[i].string_to_match != NULL; i++)\n    ndpi_init_protocol_match(ndpi_str, &host_match[i]);\n\n  ndpi_enable_loaded_categories(ndpi_str);\n\n#ifdef MATCH_DEBUG\n  // ac_automata_display(ndpi_str->host_automa.ac_automa, 'n');\n#endif\n\n  for (i = 0; ndpi_en_bigrams[i] != NULL; i++)\n    ndpi_string_to_automa(ndpi_str, &ndpi_str->bigrams_automa, (char *) ndpi_en_bigrams[i], 1, 1, 1, 0);\n\n  for (i = 0; ndpi_en_impossible_bigrams[i] != NULL; i++)\n    ndpi_string_to_automa(ndpi_str, &ndpi_str->impossible_bigrams_automa, (char *) ndpi_en_impossible_bigrams[i], 1,\n\t\t\t  1, 1, 0);\n}\n\n/* ******************************************************************** */\n\nint ndpi_set_detection_preferences(struct ndpi_detection_module_struct *ndpi_str, ndpi_detection_preference pref,\n                                   int value) {\n  switch (pref) {\n  case ndpi_pref_direction_detect_disable:\n    ndpi_str->direction_detect_disable = (u_int8_t) value;\n    break;\n\n  default:\n    return(-1);\n  }\n\n  return(0);\n}\n\n/* ******************************************************************** */\n\nstatic void ndpi_validate_protocol_initialization(struct ndpi_detection_module_struct *ndpi_str) {\n  int i;\n\n  for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {\n    if(ndpi_str->proto_defaults[i].protoName == NULL) {\n      NDPI_LOG_ERR(ndpi_str,\n\t\t   \"[NDPI] INTERNAL ERROR missing protoName initialization for [protoId=%d]: recovering\\n\", i);\n    } else {\n      if((i != NDPI_PROTOCOL_UNKNOWN) &&\n\t (ndpi_str->proto_defaults[i].protoCategory == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {\n\tNDPI_LOG_ERR(ndpi_str,\n\t\t     \"[NDPI] INTERNAL ERROR missing category [protoId=%d/%s] initialization: recovering\\n\", i,\n\t\t     ndpi_str->proto_defaults[i].protoName ? ndpi_str->proto_defaults[i].protoName : \"???\");\n      }\n    }\n  }\n}\n\n/* ******************************************************************** */\n\n/* This function is used to map protocol name and default ports and it MUST\n   be updated whenever a new protocol is added to NDPI.\n\n   Do NOT add web services (NDPI_SERVICE_xxx) here.\n*/\nstatic void ndpi_init_protocol_defaults(struct ndpi_detection_module_struct *ndpi_str) {\n  ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];\n  u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO}, custom_master[2];\n\n  /* Reset all settings */\n  memset(ndpi_str->proto_defaults, 0, sizeof(ndpi_str->proto_defaults));\n\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNRATED, NDPI_PROTOCOL_UNKNOWN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Unknown\", NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_FTP_CONTROL, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"FTP_CONTROL\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 21, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_FTP_DATA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"FTP_DATA\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 20, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_POP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"POP3\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 110, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_POPS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"POPS\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 995, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MAIL_SMTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMTP\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 25, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_SMTPS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMTPS\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 465, 587, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_IMAP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IMAP\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 143, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_IMAPS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IMAPS\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 993, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNS, 1 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 53, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 53, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IPP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IPP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IMO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IMO\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP, 1 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"HTTP\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 80, 0 /* ntop */, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MDNS, 1 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MDNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5353, 5354, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NTP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 123, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETBIOS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NetBIOS\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 139, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 137, 138, 139, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NFS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NFS\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 2049, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 2049, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSDP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SSDP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BGP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"BGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 179, 2605, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SNMP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SNMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 161, 162, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_XDMCP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"XDMCP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 177, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 177, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_DANGEROUS, NDPI_PROTOCOL_SMBV1, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMBv1\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 445, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SYSLOG, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Syslog\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 514, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 514, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DHCP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 67, 68, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_POSTGRES, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PostgreSQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 5432, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MYSQL, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MySQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 3306, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECT_DOWNLOAD_LINK,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Direct_Download_Link\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_APPLEJUICE,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"AppleJuice\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECTCONNECT,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"DirectConnect\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NATS,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Nats\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_NTOP, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"ntop\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VMWARE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"VMware\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 903, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 902, 903, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FBZERO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"FacebookZero\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_KONTIKI,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Kontiki\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_MEDIA, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_OPENFT,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"OpenFT\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_FASTTRACK,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"FastTrack\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_GNUTELLA,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Gnutella\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_EDONKEY, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"eDonkey\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_BITTORRENT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"BitTorrent\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 51413, 53646, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 6771, 51413, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Skype\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE_CALL,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"SkypeCall\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TIKTOK, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TikTok\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEREDO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Teredo\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3544, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(\n\t\t\t  ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WECHAT, 0 /* can_have_a_subprotocol */, no_master, /* wechat.com */\n\t\t\t  no_master, \"WeChat\", NDPI_PROTOCOL_CATEGORY_CHAT, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEMCACHED, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Memcached\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 11211, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 11211, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMBV23, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMBv23\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 445, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MINING, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Mining\", CUSTOM_CATEGORY_MINING,\n\t\t\t  ndpi_build_default_ports(ports_a, 8333, 30303, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NEST_LOG_SINK,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"NestLogSink\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_CLOUD,\n\t\t\t  ndpi_build_default_ports(ports_a, 11095, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MODBUS, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"Modbus\", NDPI_PROTOCOL_CATEGORY_NETWORK, /* Perhaps IoT in the future */\n\t\t\t  ndpi_build_default_ports(ports_a, 502, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_CALL,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppCall\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DATASAVER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DataSaver\", NDPI_PROTOCOL_CATEGORY_WEB /* dummy */,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SIGNAL, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, /* https://signal.org */\n\t\t\t  no_master, \"Signal\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOH_DOT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DoH_DoT\", NDPI_PROTOCOL_CATEGORY_NETWORK /* dummy */,\n\t\t\t  ndpi_build_default_ports(ports_a, 853, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FREE_205, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"FREE_205\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WIREGUARD, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"WireGuard\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 51820, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_XBOX, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Xbox\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 3074, 3076, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3074, 3076, 500, 3544, 4500) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PLAYSTATION, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Playstation\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 1935, 3478, 3479, 3480, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3478, 3479, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQ, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"QQ\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_RTSP, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"RTSP\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 554, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 554, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ICECAST, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IceCast\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPLIVE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PPLive\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ZATTOO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Zattoo\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SHOUTCAST, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"ShoutCast\", NDPI_PROTOCOL_CATEGORY_MUSIC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOPCAST, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Sopcast\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVANTS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Tvants\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVUPLAYER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TVUplayer\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_DOWNLOAD,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Download\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQLIVE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"QQLive\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_THUNDER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Thunder\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOULSEEK, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Soulseek\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PS_VUE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PS_VUE\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_IRC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IRC\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 194, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 194, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AYIYA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Ayiya\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5072, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UNENCRYPTED_JABBER,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Unencrypted_Jabber\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OSCAR, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Oscar\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_BATTLEFIELD, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"BattleField\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_VRRP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"VRRP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STEAM, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Steam\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HALFLIFE2, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"HalfLife2\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLDOFWARCRAFT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"WorldOfWarcraft\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_HOTSPOT_SHIELD,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"HotspotShield\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VPN, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_TELNET, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Telnet\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 23, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n\n  custom_master[0] = NDPI_PROTOCOL_SIP, custom_master[1] = NDPI_PROTOCOL_H323;\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_STUN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, custom_master, \"STUN\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3478, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_IP_IPSEC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IPsec\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 500, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 500, 4500, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_GRE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"GRE\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"ICMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IGMP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IGMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_EGP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"EGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_SCTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SCTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_OSPF, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"OSPF\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 2604, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IP_IN_IP,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"IP_in_IP\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RTP\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RDP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RDP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 3389, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3389, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VNC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"VNC\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 5900, 5901, 5800, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PCANYWHERE,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"PcAnywhere\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZOOM, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Zoom\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_FILES,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppFiles\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"WhatsApp\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_TLS, 1 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"TLS\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSH, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SSH\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 22, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_USENET, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Usenet\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MGCP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MGCP\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IAX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IAX\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 4569, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 4569, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AFP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"AFP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 548, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 548, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HULU, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Hulu\", NDPI_PROTOCOL_CATEGORY_STREAMING,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CHECKMK, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"CHECKMK\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 6556, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_STEALTHNET,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Stealthnet\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_AIMINI, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Aimini\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SIP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SIP\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 5060, 5061, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5060, 5061, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TRUPHONE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TruPhone\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMPV6, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"ICMPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCPV6, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DHCPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ARMAGETRON, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Armagetron\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CROSSFIRE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Crossfire\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOFUS, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Dofus\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FIESTA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Fiesta\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FLORENSIA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Florensia\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_GUILDWARS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Guildwars\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_ACTIVESYNC,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_ActiveSync\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KERBEROS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Kerberos\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 88, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 88, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LDAP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"LDAP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 389, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 389, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MAPLESTORY, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MapleStory\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MSSQL_TDS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MsSQL-TDS\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 1433, 1434, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PPTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PPTP\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WARCRAFT3, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Warcraft3\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLD_OF_KUNG_FU, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"WorldOfKungFu\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DCERPC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DCE_RPC\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 135, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETFLOW, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NetFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 2055, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SFLOW, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"sFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 6343, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_CONNECT,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Connect\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_PROXY,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Proxy\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 8080, 3128, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CITRIX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Citrix\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 1494, 2598, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBEX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Webex\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RADIUS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Radius\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 1812, 1813, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 1812, 1813, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMVIEWER,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"TeamViewer\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 5938, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5938, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LOTUS_NOTES,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"LotusNotes\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,\n\t\t\t  ndpi_build_default_ports(ports_a, 1352, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(\n\t\t\t  ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SAP, 0 /* can_have_a_subprotocol */, no_master, no_master,\n\t\t\t  \"SAP\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 3201, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */); /* Missing dissector: port based only */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_GTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"GTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 2152, 2123, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UPNP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"UPnP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 1780, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 1900, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TELEGRAM, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Telegram\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_QUIC, 1 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"QUIC\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 443, 80, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DIAMETER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Diameter\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 3868, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_APPLE_PUSH,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"ApplePush\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DROPBOX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Dropbox\", NDPI_PROTOCOL_CATEGORY_CLOUD,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 17500, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SPOTIFY, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Spotify\", NDPI_PROTOCOL_CATEGORY_MUSIC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MESSENGER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Messenger\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LISP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"LISP\", NDPI_PROTOCOL_CATEGORY_CLOUD,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 4342, 4341, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_EAQ, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"EAQ\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 6000, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KAKAOTALK_VOICE,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"KakaoTalk_Voice\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MPEGTS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MPEG_TS\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  /* http://en.wikipedia.org/wiki/Link-local_Multicast_Name_Resolution */\n  ndpi_set_proto_defaults(\n\t\t\t  ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LLMNR, 0 /* can_have_a_subprotocol */, no_master, no_master,\n\t\t\t  \"LLMNR\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 5355, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5355, 0, 0, 0, 0) /* UDP */); /* Missing dissector: port based only */\n  ndpi_set_proto_defaults(\n\t\t\t  ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_REMOTE_SCAN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RemoteScan\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 6077, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 6078, 0, 0, 0, 0) /* UDP */); /* Missing dissector: port based only */\n\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_H323, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"H323\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 1719, 1720, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 1719, 1720, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OPENVPN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"OpenVPN\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 1194, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 1194, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NOE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NOE\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CISCOVPN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"CiscoVPN\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 10000, 8008, 8009, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 10000, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMSPEAK, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TeamSpeak\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKINNY, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"CiscoSkinny\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 2000, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTCP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RTCP\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RSYNC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RSYNC\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 873, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ORACLE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Oracle\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 1521, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CORBA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Corba\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UBUNTUONE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"UbuntuONE\", NDPI_PROTOCOL_CATEGORY_CLOUD,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHOIS_DAS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Whois-DAS\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 43, 4343, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));    /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_COLLECTD, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Collectd\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),      /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 25826, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOCKS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SOCKS\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 1080, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 1080, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TFTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TFTP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),   /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 69, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTMP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RTMP\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 1935, 0, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));   /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PANDO, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Pando_Media_Booster\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEGACO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Megaco\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),     /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 2944, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_REDIS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Redis\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 6379, 0, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));   /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZMQ, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"ZeroMQ\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_VHUA, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"VHUA\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),      /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 58267, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STARCRAFT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Starcraft\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 1119, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 1119, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_UBNTAC2, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"UBNTAC2\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),      /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 10001, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VIBER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Viber\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 7985, 5242, 5243, 4244, 0),     /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 7985, 7987, 5242, 5243, 4244)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_COAP, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"COAP\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),        /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 5683, 5684, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MQTT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MQTT\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 1883, 8883, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));      /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOMEIP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SOMEIP\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 30491, 30501, 0, 0, 0),      /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 30491, 30501, 30490, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RX\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_GIT, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Git\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,\n\t\t\t  ndpi_build_default_ports(ports_a, 9418, 0, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));   /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DRDA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DRDA\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HANGOUT_DUO,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"GoogleHangoutDuo\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BJNP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"BJNP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 8612, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMPP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMPP\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_OOKLA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Ookla\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMQP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"AMQP\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_DNSCRYPT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DNScrypt\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TINC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TINC\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 655, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 655, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FIX, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"FIX\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_NINTENDO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Nintendo\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CSGO, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"CSGO\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AJP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"AJP\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 8009, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TARGUS_GETDATA,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Targus Dataspeed\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 5001, 5201, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5001, 5201, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMAZON_VIDEO,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"AmazonVideo\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNP3, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"DNP3\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 20000, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IEC60870, 1 /* no subprotocol */,\n\t\t\t  no_master, no_master, \"IEC60870\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_NETWORK, /* Perhaps IoT in the future */\n\t\t\t  ndpi_build_default_ports(ports_a, 2404, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BLOOMBERG, 1 /* no subprotocol */,\n\t\t\t  no_master, no_master, \"Bloomberg\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CAPWAP, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"CAPWAP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5246, 5247, 0, 0, 0) /* UDP */\n\t\t\t  );\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZABBIX, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"Zabbix\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 10050, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */\n\t\t\t  );\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_S7COMM, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"s7comm\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 102, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MSTEAMS, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"Teams\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */\n\t\t\t  );\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBSOCKET,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"WebSocket\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n\n#ifdef CUSTOM_NDPI_PROTOCOLS\n#include \"../../../nDPI-custom/custom_ndpi_main.c\"\n#endif\n\n  /* calling function for host and content matched protocols */\n  init_string_based_protocols(ndpi_str);\n\n  ndpi_validate_protocol_initialization(ndpi_str);\n}\n\n/* ****************************************************** */\n\n#ifdef CUSTOM_NDPI_PROTOCOLS\n#include \"../../../nDPI-custom/custom_ndpi_protocols.c\"\n#endif\n\n/* ****************************************************** */\n\nstatic int ac_match_handler(AC_MATCH_t *m, AC_TEXT_t *txt, AC_REP_t *match) {\n  int min_len = (txt->length < m->patterns->length) ? txt->length : m->patterns->length;\n  char buf[64] = {'\\0'}, *whatfound;\n  int min_buf_len = (txt->length > 63 /* sizeof(buf)-1 */) ? 63 : txt->length;\n  u_int buf_len = strlen(buf);\n\n  strncpy(buf, txt->astring, min_buf_len);\n  buf[min_buf_len] = '\\0';\n\n#ifdef MATCH_DEBUG\n  printf(\"Searching [to search: %s/%u][pattern: %s/%u] [len: %d][match_num: %u][%s]\\n\", buf,\n\t (unigned int) txt->length, m->patterns->astring, (unigned int) m->patterns->length, min_len, m->match_num,\n\t m->patterns->astring);\n#endif\n\n  whatfound = strstr(buf, m->patterns->astring);\n\n#ifdef MATCH_DEBUG\n  printf(\"[NDPI] %s() [searching=%s][pattern=%s][%s][%c]\\n\", __FUNCTION__, buf, m->patterns->astring,\n\t whatfound ? whatfound : \"<NULL>\", whatfound[-1]);\n#endif\n\n  if(whatfound) {\n    /*\n      The patch below allows in case of pattern ws.amazon.com\n      to avoid matching aws.amazon.com whereas a.ws.amazon.com\n      has to match\n    */\n    if((whatfound != buf) && (m->patterns->astring[0] != '.') /* The searched pattern does not start with . */\n       && strchr(m->patterns->astring, '.') /* The matched pattern has a . (e.g. numeric or sym IPs) */) {\n      int len = strlen(m->patterns->astring);\n\n      if((whatfound[-1] != '.') || ((m->patterns->astring[len - 1] != '.') &&\n\t\t\t\t    (whatfound[len] != '\\0') /* endsWith does not hold here */)) {\n\treturn(0);\n      } else {\n\tmemcpy(match, &m->patterns[0].rep, sizeof(AC_REP_t)); /* Partial match? */\n\treturn(0); /* Keep searching as probably there is a better match */\n      }\n    }\n  }\n\n  /*\n    Return 1 for stopping to the first match.\n    We might consider searching for the more\n    specific match, paying more cpu cycles.\n  */\n  memcpy(match, &m->patterns[0].rep, sizeof(AC_REP_t));\n\n  if(((buf_len >= min_len) && (strncmp(&buf[buf_len - min_len], m->patterns->astring, min_len) == 0)) ||\n     (strncmp(buf, m->patterns->astring, min_len) == 0) /* begins with */\n     ) {\n#ifdef MATCH_DEBUG\n    printf(\"Found match [%s][%s] [len: %d]\"\n\t   // \"[proto_id: %u]\"\n\t   \"\\n\",\n\t   buf, m->patterns->astring, min_len /* , *matching_protocol_id */);\n#endif\n    return(1); /* If the pattern found matches the string at the beginning we stop here */\n  } else {\n#ifdef MATCH_DEBUG\n    printf(\"NO match found: continue\\n\");\n#endif\n    return(0); /* 0 to continue searching, !0 to stop */\n  }\n}\n\n/* ******************************************************************** */\n\nstatic int fill_prefix_v4(prefix_t *p, const struct in_addr *a, int b, int mb) {\n  if(b < 0 || b > mb)\n    return(-1);\n\n  memset(p, 0, sizeof(prefix_t));\n  memcpy(&p->add.sin, a, (mb + 7) / 8);\n  p->family = AF_INET;\n  p->bitlen = b;\n  p->ref_count = 0;\n\n  return(0);\n}\n\n/* ******************************************* */\n\nstatic int fill_prefix_v6(prefix_t *prefix, const struct in6_addr *addr, int bits, int maxbits) {\n#ifdef PATRICIA_IPV6\n  if(bits < 0 || bits > maxbits)\n    return -1;\n\n  memcpy(&prefix->add.sin6, addr, (maxbits + 7) / 8);\n  prefix->family = AF_INET6, prefix->bitlen = bits, prefix->ref_count = 0;\n\n  return 0;\n#else\n  return(-1);\n#endif\n}\n\n/* ******************************************* */\n\nu_int16_t ndpi_network_ptree_match(struct ndpi_detection_module_struct *ndpi_str,\n                                   struct in_addr *pin /* network byte order */) {\n  prefix_t prefix;\n  patricia_node_t *node;\n\n  /* Make sure all in network byte order otherwise compares wont work */\n  fill_prefix_v4(&prefix, pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n  node = ndpi_patricia_search_best(ndpi_str->protocols_ptree, &prefix);\n\n  return(node ? node->value.uv.user_value : NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ******************************************* */\n\nu_int16_t ndpi_network_port_ptree_match(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\tstruct in_addr *pin /* network byte order */,\n\t\t\t\t\tu_int16_t port /* network byte order */) {\n  prefix_t prefix;\n  patricia_node_t *node;\n\n  /* Make sure all in network byte order otherwise compares wont work */\n  fill_prefix_v4(&prefix, pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n  node = ndpi_patricia_search_best(ndpi_str->protocols_ptree, &prefix);\n\n  if(node) {\n    if((node->value.uv.additional_user_value == 0)\n       || (node->value.uv.additional_user_value == port))\n      return(node->value.uv.user_value);\n  }\n\n  return(NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ******************************************* */\n\n#if 0\nstatic u_int8_t tor_ptree_match(struct ndpi_detection_module_struct *ndpi_str, struct in_addr *pin) {\n  return((ndpi_network_ptree_match(ndpi_str, pin) == NDPI_PROTOCOL_TOR) ? 1 : 0);\n}\n#endif\n\n/* ******************************************* */\n\nu_int8_t ndpi_is_tor_flow(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  if(packet->tcp != NULL) {\n    if(packet->iph) {\n      if(flow->guessed_host_protocol_id == NDPI_PROTOCOL_TOR)\n\treturn(1);\n    }\n  }\n\n  return(0);\n}\n\n/* ******************************************* */\n\nstatic patricia_node_t *add_to_ptree(patricia_tree_t *tree, int family, void *addr, int bits) {\n  prefix_t prefix;\n  patricia_node_t *node;\n\n  fill_prefix_v4(&prefix, (struct in_addr *) addr, bits, tree->maxbits);\n\n  node = ndpi_patricia_lookup(tree, &prefix);\n  if(node) memset(&node->value, 0, sizeof(node->value));\n\n  return(node);\n}\n\n/* ******************************************* */\n\n/*\n  Load a file containing IPv4 addresses in CIDR format as 'protocol_id'\n\n  Return: the number of entries loaded or -1 in case of error\n*/\nint ndpi_load_ipv4_ptree(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t const char *path, u_int16_t protocol_id) {\n  char buffer[128], *line, *addr, *cidr, *saveptr;\n  FILE *fd;\n  int len;\n  u_int num_loaded = 0;\n\n  fd = fopen(path, \"r\");\n\n  if(fd == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));\n    return(-1);\n  }\n\n  while (1) {\n    line = fgets(buffer, sizeof(buffer), fd);\n\n    if(line == NULL)\n      break;\n\n    len = strlen(line);\n\n    if((len <= 1) || (line[0] == '#'))\n      continue;\n\n    line[len - 1] = '\\0';\n    addr = strtok_r(line, \"/\", &saveptr);\n\n    if(addr) {\n      struct in_addr pin;\n      patricia_node_t *node;\n\n      cidr = strtok_r(NULL, \"\\n\", &saveptr);\n\n      pin.s_addr = inet_addr(addr);\n      if((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, cidr ? atoi(cidr) : 32 /* bits */)) != NULL) {\n\tnode->value.uv.user_value = protocol_id, node->value.uv.additional_user_value = 0 /* port */;\n\tnum_loaded++;\n      }\n    }\n  }\n\n  fclose(fd);\n  return(num_loaded);\n}\n\n/* ******************************************* */\n\nstatic void ndpi_init_ptree_ipv4(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t void *ptree, ndpi_network host_list[],\n                                 u_int8_t skip_tor_hosts) {\n  int i;\n\n  for (i = 0; host_list[i].network != 0x0; i++) {\n    struct in_addr pin;\n    patricia_node_t *node;\n\n    if(skip_tor_hosts && (host_list[i].value == NDPI_PROTOCOL_TOR))\n      continue;\n\n    pin.s_addr = htonl(host_list[i].network);\n    if((node = add_to_ptree(ptree, AF_INET, &pin, host_list[i].cidr /* bits */)) != NULL) {\n      node->value.uv.user_value = host_list[i].value, node->value.uv.additional_user_value = 0;\n    }\n  }\n}\n\n/* ******************************************* */\n\nstatic int ndpi_add_host_ip_subprotocol(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\tchar *value, u_int16_t protocol_id) {\n  patricia_node_t *node;\n  struct in_addr pin;\n  int bits = 32;\n  char *ptr = strrchr(value, '/');\n  u_int16_t port = 0; /* Format ip:8.248.73.247:443 */\n  char *double_column;\n\n  if(ptr) {\n    ptr[0] = '\\0';\n    ptr++;\n\n    if((double_column = strrchr(ptr, ':')) != NULL) {\n      double_column[0] = '\\0';\n      port = atoi(&double_column[1]);\n    }\n\n    if(atoi(ptr) >= 0 && atoi(ptr) <= 32)\n      bits = atoi(ptr);\n  } else {\n    /*\n      Let's check if there is the port defined\n      Example: ip:8.248.73.247:443@AmazonPrime\n    */\n    double_column = strrchr(value, ':');\n\n    if(double_column) {\n      double_column[0] = '\\0';\n      port = atoi(&double_column[1]);\n    }\n  }\n\n  inet_pton(AF_INET, value, &pin);\n\n  if((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, bits)) != NULL) {\n    node->value.uv.user_value = protocol_id, node->value.uv.additional_user_value = htons(port);\n  }\n\n  return(0);\n}\n\nvoid set_ndpi_malloc(void *(*__ndpi_malloc)(size_t size)) {\n  _ndpi_malloc = __ndpi_malloc;\n}\nvoid set_ndpi_flow_malloc(void *(*__ndpi_flow_malloc)(size_t size)) {\n  _ndpi_flow_malloc = __ndpi_flow_malloc;\n}\n\nvoid set_ndpi_free(void (*__ndpi_free)(void *ptr)) {\n  _ndpi_free = __ndpi_free;\n}\nvoid set_ndpi_flow_free(void (*__ndpi_flow_free)(void *ptr)) {\n  _ndpi_flow_free = __ndpi_flow_free;\n}\n\nvoid ndpi_debug_printf(unsigned int proto, struct ndpi_detection_module_struct *ndpi_str, ndpi_log_level_t log_level,\n                       const char *file_name, const char *func_name, int line_number, const char *format, ...) {\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n  va_list args;\n#define MAX_STR_LEN 250\n  char str[MAX_STR_LEN];\n  if(ndpi_str != NULL && log_level > NDPI_LOG_ERROR && proto > 0 && proto < NDPI_MAX_SUPPORTED_PROTOCOLS &&\n     !NDPI_ISSET(&ndpi_str->debug_bitmask, proto))\n    return;\n  va_start(args, format);\n  vsnprintf(str, sizeof(str) - 1, format, args);\n  va_end(args);\n\n  if(ndpi_str != NULL) {\n    printf(\"%s:%s:%-3d - [%s]: %s\", file_name, func_name, line_number, ndpi_get_proto_name(ndpi_str, proto), str);\n  } else {\n    printf(\"Proto: %u, %s\", proto, str);\n  }\n#endif\n}\n\nvoid set_ndpi_debug_function(struct ndpi_detection_module_struct *ndpi_str, ndpi_debug_function_ptr ndpi_debug_printf) {\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n  ndpi_str->ndpi_debug_printf = ndpi_debug_printf;\n#endif\n}\n\n/* ****************************************** */\n\n/* Keep it in order and in sync with ndpi_protocol_category_t in ndpi_typedefs.h */\nstatic const char *categories[] = {\n\t\t\t\t   \"Unspecified\",\n\t\t\t\t   \"Media\",\n\t\t\t\t   \"VPN\",\n\t\t\t\t   \"Email\",\n\t\t\t\t   \"DataTransfer\",\n\t\t\t\t   \"Web\",\n\t\t\t\t   \"SocialNetwork\",\n\t\t\t\t   \"Download-FileTransfer-FileSharing\",\n\t\t\t\t   \"Game\",\n\t\t\t\t   \"Chat\",\n\t\t\t\t   \"VoIP\",\n\t\t\t\t   \"Database\",\n\t\t\t\t   \"RemoteAccess\",\n\t\t\t\t   \"Cloud\",\n\t\t\t\t   \"Network\",\n\t\t\t\t   \"Collaborative\",\n\t\t\t\t   \"RPC\",\n\t\t\t\t   \"Streaming\",\n\t\t\t\t   \"System\",\n\t\t\t\t   \"SoftwareUpdate\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"Music\",\n\t\t\t\t   \"Video\",\n\t\t\t\t   \"Shopping\",\n\t\t\t\t   \"Productivity\",\n\t\t\t\t   \"FileSharing\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"Mining\", /* 99 */\n\t\t\t\t   \"Malware\",\n\t\t\t\t   \"Advertisement\",\n\t\t\t\t   \"Banned_Site\",\n\t\t\t\t   \"Site_Unavailable\",\n\t\t\t\t   \"Allowed_Site\",\n\t\t\t\t   \"Antimalware\",\n};\n\n/* ******************************************************************** */\n\nstruct ndpi_detection_module_struct *ndpi_init_detection_module(ndpi_init_prefs prefs) {\n  struct ndpi_detection_module_struct *ndpi_str = ndpi_malloc(sizeof(struct ndpi_detection_module_struct));\n  int i;\n\n  if(ndpi_str == NULL) {\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n    NDPI_LOG_ERR(ndpi_str, \"ndpi_init_detection_module initial malloc failed for ndpi_str\\n\");\n#endif /* NDPI_ENABLE_DEBUG_MESSAGES */\n    return(NULL);\n  }\n\n  memset(ndpi_str, 0, sizeof(struct ndpi_detection_module_struct));\n\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n  set_ndpi_debug_function(ndpi_str, (ndpi_debug_function_ptr) ndpi_debug_printf);\n#endif /* NDPI_ENABLE_DEBUG_MESSAGES */\n\n  if((ndpi_str->protocols_ptree = ndpi_New_Patricia(32 /* IPv4 */)) != NULL)\n    ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, host_protocol_list, prefs & ndpi_dont_load_tor_hosts);\n\n  NDPI_BITMASK_RESET(ndpi_str->detection_bitmask);\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n  ndpi_str->user_data = NULL;\n#endif\n\n  ndpi_str->ticks_per_second = 1000; /* ndpi_str->ticks_per_second */\n  ndpi_str->tcp_max_retransmission_window_size = NDPI_DEFAULT_MAX_TCP_RETRANSMISSION_WINDOW_SIZE;\n  ndpi_str->directconnect_connection_ip_tick_timeout =\n    NDPI_DIRECTCONNECT_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;\n\n  ndpi_str->rtsp_connection_timeout = NDPI_RTSP_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->tvants_connection_timeout = NDPI_TVANTS_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->irc_timeout = NDPI_IRC_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->gnutella_timeout = NDPI_GNUTELLA_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n\n  ndpi_str->battlefield_timeout = NDPI_BATTLEFIELD_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n\n  ndpi_str->thunder_timeout = NDPI_THUNDER_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->yahoo_detect_http_connections = NDPI_YAHOO_DETECT_HTTP_CONNECTIONS;\n\n  ndpi_str->yahoo_lan_video_timeout = NDPI_YAHOO_LAN_VIDEO_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->zattoo_connection_timeout = NDPI_ZATTOO_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->jabber_stun_timeout = NDPI_JABBER_STUN_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->jabber_file_transfer_timeout = NDPI_JABBER_FT_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->soulseek_connection_ip_tick_timeout =\n    NDPI_SOULSEEK_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;\n\n  ndpi_str->ndpi_num_supported_protocols = NDPI_MAX_SUPPORTED_PROTOCOLS;\n  ndpi_str->ndpi_num_custom_protocols = 0;\n\n  ndpi_str->host_automa.ac_automa = ac_automata_init(ac_match_handler);\n  ndpi_str->content_automa.ac_automa = ac_automata_init(ac_match_handler);\n  ndpi_str->bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);\n  ndpi_str->impossible_bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);\n\n  if((sizeof(categories) / sizeof(char *)) != NDPI_PROTOCOL_NUM_CATEGORIES) {\n    NDPI_LOG_ERR(ndpi_str, \"[NDPI] invalid categories length: expected %u, got %u\\n\", NDPI_PROTOCOL_NUM_CATEGORIES,\n\t\t (unsigned int) (sizeof(categories) / sizeof(char *)));\n    return(NULL);\n  }\n\n  ndpi_str->custom_categories.hostnames.ac_automa = ac_automata_init(ac_match_handler);\n  ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);\n\n  ndpi_str->custom_categories.ipAddresses = ndpi_New_Patricia(32 /* IPv4 */);\n  ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);\n\n  if((ndpi_str->custom_categories.ipAddresses == NULL) || (ndpi_str->custom_categories.ipAddresses_shadow == NULL))\n    return(NULL);\n\n  ndpi_init_protocol_defaults(ndpi_str);\n\n  for (i = 0; i < NUM_CUSTOM_CATEGORIES; i++)\n    snprintf(ndpi_str->custom_category_labels[i], CUSTOM_CATEGORY_LABEL_LEN, \"User custom category %u\",\n\t     (unsigned int) (i + 1));\n\n  return(ndpi_str);\n}\n\n/* *********************************************** */\n\nvoid ndpi_finalize_initalization(struct ndpi_detection_module_struct *ndpi_str) {\n  u_int i;\n\n  for (i = 0; i < 4; i++) {\n    ndpi_automa *automa;\n\n    switch (i) {\n    case 0:\n      automa = &ndpi_str->host_automa;\n      break;\n\n    case 1:\n      automa = &ndpi_str->content_automa;\n      break;\n\n    case 2:\n      automa = &ndpi_str->bigrams_automa;\n      break;\n\n    case 3:\n      automa = &ndpi_str->impossible_bigrams_automa;\n      break;\n\n    default:\n      automa = NULL;\n      break;\n    }\n\n    if(automa) {\n      ac_automata_finalize((AC_AUTOMATA_t *) automa->ac_automa);\n      automa->ac_automa_finalized = 1;\n    }\n  }\n}\n\n/* *********************************************** */\n\n/* Wrappers */\nvoid *ndpi_init_automa(void) {\n  return(ac_automata_init(ac_match_handler));\n}\n\n/* ****************************************************** */\n\nint ndpi_add_string_value_to_automa(void *_automa, char *str, u_int32_t num) {\n  AC_PATTERN_t ac_pattern;\n  AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;\n  AC_ERROR_t rc;\n\n  if(automa == NULL)\n    return(-1);\n\n  memset(&ac_pattern, 0, sizeof(ac_pattern));\n  ac_pattern.astring    = str;\n  ac_pattern.rep.number = num;\n  ac_pattern.length     = strlen(ac_pattern.astring);\n\n  rc = ac_automata_add(automa, &ac_pattern);\n  return(rc == ACERR_SUCCESS || rc == ACERR_DUPLICATE_PATTERN ? 0 : -1);\n}\n\n/* ****************************************************** */\n\nint ndpi_add_string_to_automa(void *_automa, char *str) {\n  return(ndpi_add_string_value_to_automa(_automa, str, 1));\n}\n\n/* ****************************************************** */\n\nvoid ndpi_free_automa(void *_automa) {\n  ac_automata_release((AC_AUTOMATA_t *) _automa, 0);\n}\n\n/* ****************************************************** */\n\nvoid ndpi_finalize_automa(void *_automa) {\n  ac_automata_finalize((AC_AUTOMATA_t *) _automa);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_string(void *_automa, char *string_to_match) {\n  AC_REP_t match = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };\n  AC_TEXT_t ac_input_text;\n  AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;\n  int rc;\n\n  if((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))\n    return(-2);\n\n  ac_input_text.astring = string_to_match, ac_input_text.length = strlen(string_to_match);\n  rc = ac_automata_search(automa, &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  return(rc ? match.number : 0);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_string_protocol_id(void *_automa, char *string_to_match,\n\t\t\t\t  u_int match_len, u_int16_t *protocol_id,\n\t\t\t\t  ndpi_protocol_category_t *category,\n\t\t\t\t  ndpi_protocol_breed_t *breed) {\n  AC_TEXT_t ac_input_text;\n  AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;\n  AC_REP_t match = { 0, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };\n  int rc;\n\n  *protocol_id = (u_int16_t)-1;\n  if((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))\n    return(-2);\n\n  ac_input_text.astring = string_to_match, ac_input_text.length = match_len;\n  rc = ac_automata_search(automa, &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  if(rc)\n    *protocol_id = (u_int16_t)match.number, *category = match.category,\n      *breed = match.breed;\n  else\n    *protocol_id = NDPI_PROTOCOL_UNKNOWN;\n\n  return((*protocol_id != NDPI_PROTOCOL_UNKNOWN) ? 0 : -1);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_string_value(void *_automa, char *string_to_match,\n\t\t\t    u_int match_len, u_int32_t *num) {\n  AC_TEXT_t ac_input_text;\n  AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;\n  AC_REP_t match = { 0, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };\n  int rc;\n\n  *num = (u_int32_t)-1;\n  if((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))\n    return(-2);\n\n  ac_input_text.astring = string_to_match, ac_input_text.length = match_len;\n  rc = ac_automata_search(automa, &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  if(rc)\n    *num = match.number;\n  else\n    *num = 0;\n\n  return(rc ? 0 : -1);\n}\n\n/* *********************************************** */\n\nint ndpi_match_custom_category(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t       char *name, u_int name_len,\n                               ndpi_protocol_category_t *category) {\n  ndpi_protocol_breed_t breed;\n  u_int16_t id;\n  int rc = ndpi_match_string_protocol_id(ndpi_str->custom_categories.hostnames.ac_automa,\n\t\t\t\t\t name, name_len, &id, category, &breed);\n\n  return(rc);\n}\n\n/* *********************************************** */\n\nint ndpi_get_custom_category_match(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t   char *name_or_ip, u_int name_len,\n\t\t\t\t   ndpi_protocol_category_t *id) {\n  char ipbuf[64], *ptr;\n  struct in_addr pin;\n  u_int cp_len = ndpi_min(sizeof(ipbuf) - 1, name_len);\n\n  if(!ndpi_str->custom_categories.categories_loaded)\n    return(-1);\n\n  if(cp_len > 0) {\n    memcpy(ipbuf, name_or_ip, cp_len);\n    ipbuf[cp_len] = '\\0';\n  } else\n    ipbuf[0] = '\\0';\n\n  ptr = strrchr(ipbuf, '/');\n\n  if(ptr)\n    ptr[0] = '\\0';\n\n  if(inet_pton(AF_INET, ipbuf, &pin) == 1) {\n    /* Search IP */\n    prefix_t prefix;\n    patricia_node_t *node;\n\n    /* Make sure all in network byte order otherwise compares wont work */\n    fill_prefix_v4(&prefix, &pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n    node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);\n\n    if(node) {\n      *id = node->value.uv.user_value;\n\n      return(0);\n    }\n\n    return(-1);\n  } else {\n    /* Search Host */\n    return(ndpi_match_custom_category(ndpi_str, name_or_ip, name_len, id));\n  }\n}\n\n/* *********************************************** */\n\nstatic void free_ptree_data(void *data) {\n  ;\n}\n\n/* ****************************************************** */\n\nvoid ndpi_exit_detection_module(struct ndpi_detection_module_struct *ndpi_str) {\n  if(ndpi_str != NULL) {\n    int i;\n\n    for (i = 0; i < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS); i++) {\n      if(ndpi_str->proto_defaults[i].protoName)\n\tndpi_free(ndpi_str->proto_defaults[i].protoName);\n    }\n\n    /* NDPI_PROTOCOL_TINC */\n    if(ndpi_str->tinc_cache)\n      cache_free((cache_t)(ndpi_str->tinc_cache));\n\n    if(ndpi_str->ookla_cache)\n      ndpi_lru_free_cache(ndpi_str->ookla_cache);\n\n    if(ndpi_str->stun_cache)\n      ndpi_lru_free_cache(ndpi_str->stun_cache);\n\n    if(ndpi_str->msteams_cache)\n      ndpi_lru_free_cache(ndpi_str->msteams_cache);\n\n    if(ndpi_str->protocols_ptree)\n      ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->protocols_ptree, free_ptree_data);\n\n    if(ndpi_str->udpRoot != NULL)\n      ndpi_tdestroy(ndpi_str->udpRoot, ndpi_free);\n    if(ndpi_str->tcpRoot != NULL)\n      ndpi_tdestroy(ndpi_str->tcpRoot, ndpi_free);\n\n    if(ndpi_str->host_automa.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->host_automa.ac_automa,\n\t\t\t  1 /* free patterns strings memory */);\n\n    if(ndpi_str->content_automa.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->content_automa.ac_automa, 0);\n\n    if(ndpi_str->bigrams_automa.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->bigrams_automa.ac_automa, 0);\n\n    if(ndpi_str->impossible_bigrams_automa.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->impossible_bigrams_automa.ac_automa, 0);\n\n    if(ndpi_str->custom_categories.hostnames.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,\n\t\t\t  1 /* free patterns strings memory */);\n\n    if(ndpi_str->custom_categories.hostnames_shadow.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa,\n\t\t\t  1 /* free patterns strings memory */);\n\n    if(ndpi_str->custom_categories.ipAddresses != NULL)\n      ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);\n\n    if(ndpi_str->custom_categories.ipAddresses_shadow != NULL)\n      ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses_shadow, free_ptree_data);\n\n#ifdef CUSTOM_NDPI_PROTOCOLS\n#include \"../../../nDPI-custom/ndpi_exit_detection_module.c\"\n#endif\n\n    ndpi_free(ndpi_str);\n  }\n}\n\n/* ****************************************************** */\n\nint ndpi_get_protocol_id_master_proto(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protocol_id,\n                                      u_int16_t **tcp_master_proto, u_int16_t **udp_master_proto) {\n  if(protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) {\n    *tcp_master_proto = ndpi_str->proto_defaults[NDPI_PROTOCOL_UNKNOWN].master_tcp_protoId,\n      *udp_master_proto = ndpi_str->proto_defaults[NDPI_PROTOCOL_UNKNOWN].master_udp_protoId;\n    return(-1);\n  }\n\n  *tcp_master_proto = ndpi_str->proto_defaults[protocol_id].master_tcp_protoId,\n    *udp_master_proto = ndpi_str->proto_defaults[protocol_id].master_udp_protoId;\n\n  return(0);\n}\n\n/* ****************************************************** */\n\nstatic ndpi_default_ports_tree_node_t *ndpi_get_guessed_protocol_id(struct ndpi_detection_module_struct *ndpi_str,\n                                                                    u_int8_t proto, u_int16_t sport, u_int16_t dport) {\n  ndpi_default_ports_tree_node_t node;\n\n  if(sport && dport) {\n    int low = ndpi_min(sport, dport);\n    int high = ndpi_max(sport, dport);\n    const void *ret;\n\n    node.default_port = low; /* Check server port first */\n    ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,\n\t\t     ndpi_default_ports_tree_node_t_cmp);\n\n    if(ret == NULL) {\n      node.default_port = high;\n      ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,\n\t\t       ndpi_default_ports_tree_node_t_cmp);\n    }\n\n    if(ret)\n      return(*(ndpi_default_ports_tree_node_t **) ret);\n  }\n\n  return(NULL);\n}\n\n/* ****************************************************** */\n\n/*\n  These are UDP protocols that must fit a single packet\n  and thus that if have NOT been detected they cannot be guessed\n  as they have been excluded\n*/\nu_int8_t is_udp_guessable_protocol(u_int16_t l7_guessed_proto) {\n  switch (l7_guessed_proto) {\n  case NDPI_PROTOCOL_QUIC:\n  case NDPI_PROTOCOL_SNMP:\n  case NDPI_PROTOCOL_NETFLOW:\n    /* TODO: add more protocols (if any missing) */\n    return(1);\n  }\n\n  return(0);\n}\n\n/* ****************************************************** */\n\nu_int16_t ndpi_guess_protocol_id(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                 u_int8_t proto, u_int16_t sport, u_int16_t dport, u_int8_t *user_defined_proto) {\n  *user_defined_proto = 0; /* Default */\n\n  if(sport && dport) {\n    ndpi_default_ports_tree_node_t *found = ndpi_get_guessed_protocol_id(ndpi_str, proto, sport, dport);\n\n    if(found != NULL) {\n      u_int16_t guessed_proto = found->proto->protoId;\n\n      /* We need to check if the guessed protocol isn't excluded by nDPI */\n      if(flow && (proto == IPPROTO_UDP) &&\n\t NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, guessed_proto) &&\n\t is_udp_guessable_protocol(guessed_proto))\n\treturn(NDPI_PROTOCOL_UNKNOWN);\n      else {\n\t*user_defined_proto = found->customUserProto;\n\treturn(guessed_proto);\n      }\n    }\n  } else {\n    /* No TCP/UDP */\n\n    switch (proto) {\n    case NDPI_IPSEC_PROTOCOL_ESP:\n    case NDPI_IPSEC_PROTOCOL_AH:\n      return(NDPI_PROTOCOL_IP_IPSEC);\n      break;\n    case NDPI_GRE_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_GRE);\n      break;\n    case NDPI_ICMP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_ICMP);\n      break;\n    case NDPI_IGMP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_IGMP);\n      break;\n    case NDPI_EGP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_EGP);\n      break;\n    case NDPI_SCTP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_SCTP);\n      break;\n    case NDPI_OSPF_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_OSPF);\n      break;\n    case NDPI_IPIP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_IP_IN_IP);\n      break;\n    case NDPI_ICMPV6_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_ICMPV6);\n      break;\n    case 112:\n      return(NDPI_PROTOCOL_IP_VRRP);\n      break;\n    }\n  }\n\n  return(NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ******************************************************************** */\n\nu_int ndpi_get_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  return(ndpi_str->ndpi_num_supported_protocols);\n}\n\n/* ******************************************************************** */\n\n#ifdef WIN32\nchar *strsep(char **sp, char *sep) {\n  char *p, *s;\n  if(sp == NULL || *sp == NULL || **sp == '\\0')\n    return(NULL);\n  s = *sp;\n  p = s + strcspn(s, sep);\n  if(*p != '\\0')\n    *p++ = '\\0';\n  *sp = p;\n  return(s);\n}\n#endif\n\n/* ******************************************************************** */\n\nint ndpi_handle_rule(struct ndpi_detection_module_struct *ndpi_str, char *rule, u_int8_t do_add) {\n  char *at, *proto, *elem;\n  ndpi_proto_defaults_t *def;\n  u_int16_t subprotocol_id, i;\n\n  at = strrchr(rule, '@');\n  if(at == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Invalid rule '%s'\\n\", rule);\n    return(-1);\n  } else\n    at[0] = 0, proto = &at[1];\n\n  for (i = 0; proto[i] != '\\0'; i++) {\n    switch (proto[i]) {\n    case '/':\n    case '&':\n    case '^':\n    case ':':\n    case ';':\n    case '\\'':\n    case '\"':\n    case ' ':\n      proto[i] = '_';\n      break;\n    }\n  }\n\n  for (i = 0, def = NULL; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {\n    if(ndpi_str->proto_defaults[i].protoName && strcasecmp(ndpi_str->proto_defaults[i].protoName, proto) == 0) {\n      def = &ndpi_str->proto_defaults[i];\n      subprotocol_id = i;\n      break;\n    }\n  }\n\n  if(def == NULL) {\n    if(!do_add) {\n      /* We need to remove a rule */\n      NDPI_LOG_ERR(ndpi_str, \"Unable to find protocol '%s': skipping rule '%s'\\n\", proto, rule);\n      return(-3);\n    } else {\n      ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];\n      u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};\n\n      if(ndpi_str->ndpi_num_custom_protocols >= (NDPI_MAX_NUM_CUSTOM_PROTOCOLS - 1)) {\n\tNDPI_LOG_ERR(ndpi_str, \"Too many protocols defined (%u): skipping protocol %s\\n\",\n\t\t     ndpi_str->ndpi_num_custom_protocols, proto);\n\treturn(-2);\n      }\n\n      ndpi_set_proto_defaults(\n\t\t\t      ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, ndpi_str->ndpi_num_supported_protocols,\n\t\t\t      0 /* can_have_a_subprotocol */, no_master, no_master, proto,\n\t\t\t      NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, /* TODO add protocol category support in rules */\n\t\t\t      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n      def = &ndpi_str->proto_defaults[ndpi_str->ndpi_num_supported_protocols];\n      subprotocol_id = ndpi_str->ndpi_num_supported_protocols;\n      ndpi_str->ndpi_num_supported_protocols++, ndpi_str->ndpi_num_custom_protocols++;\n    }\n  }\n\n  while ((elem = strsep(&rule, \",\")) != NULL) {\n    char *attr = elem, *value = NULL;\n    ndpi_port_range range;\n    int is_tcp = 0, is_udp = 0, is_ip = 0;\n\n    if(strncmp(attr, \"tcp:\", 4) == 0)\n      is_tcp = 1, value = &attr[4];\n    else if(strncmp(attr, \"udp:\", 4) == 0)\n      is_udp = 1, value = &attr[4];\n    else if(strncmp(attr, \"ip:\", 3) == 0)\n      is_ip = 1, value = &attr[3];\n    else if(strncmp(attr, \"host:\", 5) == 0) {\n      /* host:\"<value>\",host:\"<value>\",.....@<subproto> */\n      value = &attr[5];\n      if(value[0] == '\"')\n\tvalue++; /* remove leading \" */\n      if(value[strlen(value) - 1] == '\"')\n\tvalue[strlen(value) - 1] = '\\0'; /* remove trailing \" */\n    }\n\n    if(is_tcp || is_udp) {\n      u_int p_low, p_high;\n\n      if(sscanf(value, \"%u-%u\", &p_low, &p_high) == 2)\n\trange.port_low = p_low, range.port_high = p_high;\n      else\n\trange.port_low = range.port_high = atoi(&elem[4]);\n\n      if(do_add)\n\taddDefaultPort(ndpi_str, &range, def, 1 /* Custom user proto */,\n\t\t       is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot, __FUNCTION__, __LINE__);\n      else\n\tremoveDefaultPort(&range, def, is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot);\n    } else if(is_ip) {\n      /* NDPI_PROTOCOL_TOR */\n      ndpi_add_host_ip_subprotocol(ndpi_str, value, subprotocol_id);\n    } else {\n      if(do_add)\n\tndpi_add_host_url_subprotocol(ndpi_str, value, subprotocol_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,\n\t\t\t\t      NDPI_PROTOCOL_ACCEPTABLE);\n      else\n\tndpi_remove_host_url_subprotocol(ndpi_str, value, subprotocol_id);\n    }\n  }\n\n  return(0);\n}\n\n/* ******************************************************************** */\n\n/*\n * Format:\n *\n * <host|ip>\t<category_id>\n *\n * Notes:\n *  - host and category are separated by a single TAB\n *  - empty lines or lines starting with # are ignored\n */\nint ndpi_load_categories_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {\n  char buffer[512], *line, *name, *category, *saveptr;\n  FILE *fd;\n  int len, num = 0;\n\n  fd = fopen(path, \"r\");\n\n  if(fd == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));\n    return(-1);\n  }\n\n  while (1) {\n    line = fgets(buffer, sizeof(buffer), fd);\n\n    if(line == NULL)\n      break;\n\n    len = strlen(line);\n\n    if((len <= 1) || (line[0] == '#'))\n      continue;\n\n    line[len - 1] = '\\0';\n    name = strtok_r(line, \"\\t\", &saveptr);\n\n    if(name) {\n      category = strtok_r(NULL, \"\\t\", &saveptr);\n\n      if(category) {\n\tint rc = ndpi_load_category(ndpi_str, name, (ndpi_protocol_category_t) atoi(category));\n\n\tif(rc >= 0)\n\t  num++;\n      }\n    }\n  }\n\n  fclose(fd);\n  ndpi_enable_loaded_categories(ndpi_str);\n\n  return(num);\n}\n\n/* ******************************************************************** */\n\n/*\n  Format:\n  <tcp|udp>:<port>,<tcp|udp>:<port>,.....@<proto>\n\n  Subprotocols Format:\n  host:\"<value>\",host:\"<value>\",.....@<subproto>\n\n  IP based Subprotocols Format (<value> is IP or CIDR):\n  ip:<value>,ip:<value>,.....@<subproto>\n\n  Example:\n  tcp:80,tcp:3128@HTTP\n  udp:139@NETBIOS\n\n*/\nint ndpi_load_protocols_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {\n  FILE *fd;\n  char *buffer, *old_buffer;\n  int chunk_len = 512, buffer_len = chunk_len, old_buffer_len;\n  int i, rc = -1;\n\n  fd = fopen(path, \"r\");\n\n  if(fd == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));\n    goto error;\n  }\n\n  buffer = ndpi_malloc(buffer_len);\n\n  if(buffer == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");\n    goto close_fd;\n  }\n\n  while (1) {\n    char *line = buffer;\n    int line_len = buffer_len;\n\n    while ((line = fgets(line, line_len, fd)) != NULL && line[strlen(line) - 1] != '\\n') {\n      i = strlen(line);\n      old_buffer = buffer;\n      old_buffer_len = buffer_len;\n      buffer_len += chunk_len;\n\n      buffer = ndpi_realloc(old_buffer, old_buffer_len, buffer_len);\n\n      if(buffer == NULL) {\n\tNDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");\n\tndpi_free(old_buffer);\n\tgoto close_fd;\n      }\n\n      line = &buffer[i];\n      line_len = chunk_len;\n    }\n\n    if(!line) /* safety check */\n      break;\n\n    i = strlen(buffer);\n    if((i <= 1) || (buffer[0] == '#'))\n      continue;\n    else\n      buffer[i - 1] = '\\0';\n\n    ndpi_handle_rule(ndpi_str, buffer, 1);\n  }\n\n  rc = 0;\n\n  ndpi_free(buffer);\n\n close_fd:\n  fclose(fd);\n\n error:\n  return(rc);\n}\n\n/* ******************************************************************** */\n\n/* ntop */\nvoid ndpi_set_bitmask_protocol_detection(char *label, struct ndpi_detection_module_struct *ndpi_str,\n                                         const NDPI_PROTOCOL_BITMASK *detection_bitmask, const u_int32_t idx,\n                                         u_int16_t ndpi_protocol_id,\n                                         void (*func)(struct ndpi_detection_module_struct *,\n                                                      struct ndpi_flow_struct *flow),\n                                         const NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_bitmask,\n                                         u_int8_t b_save_bitmask_unknow, u_int8_t b_add_detection_bitmask) {\n  /*\n    Compare specify protocol bitmask with main detection bitmask\n  */\n  if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(*detection_bitmask, ndpi_protocol_id) != 0) {\n#ifdef DEBUG\n    NDPI_LOG_DBG2(ndpi_str,\n\t\t  \"[NDPI] ndpi_set_bitmask_protocol_detection: %s : [callback_buffer] idx= %u, [proto_defaults] \"\n\t\t  \"protocol_id=%u\\n\",\n\t\t  label, idx, ndpi_protocol_id);\n#endif\n\n    if(ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx != 0) {\n      NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Internal error: protocol %s/%u has been already registered\\n\", label,\n\t\t    ndpi_protocol_id);\n#ifdef DEBUG\n    } else {\n      NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding %s with protocol id %d\\n\", label, ndpi_protocol_id);\n#endif\n    }\n\n    /*\n      Set function and index protocol within proto_default structure for port protocol detection\n      and callback_buffer function for DPI protocol detection\n    */\n    ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx = idx;\n    ndpi_str->proto_defaults[ndpi_protocol_id].func = ndpi_str->callback_buffer[idx].func = func;\n\n    /*\n      Set ndpi_selection_bitmask for protocol\n    */\n    ndpi_str->callback_buffer[idx].ndpi_selection_bitmask = ndpi_selection_bitmask;\n\n    /*\n      Reset protocol detection bitmask via NDPI_PROTOCOL_UNKNOWN and than add specify protocol bitmast to callback\n      buffer.\n    */\n    if(b_save_bitmask_unknow)\n      NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, NDPI_PROTOCOL_UNKNOWN);\n    if(b_add_detection_bitmask)\n      NDPI_ADD_PROTOCOL_TO_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, ndpi_protocol_id);\n\n    NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].excluded_protocol_bitmask, ndpi_protocol_id);\n  }\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_set_protocol_detection_bitmask2(struct ndpi_detection_module_struct *ndpi_str,\n                                          const NDPI_PROTOCOL_BITMASK *dbm) {\n  NDPI_PROTOCOL_BITMASK detection_bitmask_local;\n  NDPI_PROTOCOL_BITMASK *detection_bitmask = &detection_bitmask_local;\n  u_int32_t a = 0;\n\n  NDPI_BITMASK_SET(detection_bitmask_local, *dbm);\n  NDPI_BITMASK_SET(ndpi_str->detection_bitmask, *dbm);\n\n  /* set this here to zero to be interrupt safe */\n  ndpi_str->callback_buffer_size = 0;\n\n  /* HTTP */\n  init_http_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* STARCRAFT */\n  init_starcraft_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TLS */\n  init_tls_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* STUN */\n  init_stun_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RTP */\n  init_rtp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RTSP */\n  init_rtsp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RDP */\n  init_rdp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SIP */\n  init_sip_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IMO */\n  init_imo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Teredo */\n  init_teredo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* EDONKEY */\n  init_edonkey_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FASTTRACK */\n  init_fasttrack_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* GNUTELLA */\n  init_gnutella_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DIRECTCONNECT */\n  init_directconnect_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NATS */\n  init_nats_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* YAHOO */\n  init_yahoo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* OSCAR */\n  init_oscar_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* APPLEJUICE */\n  init_applejuice_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SOULSEEK */\n  init_soulseek_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SOCKS */\n  init_socks_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IRC */\n  init_irc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* JABBER */\n  init_jabber_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MAIL_POP */\n  init_mail_pop_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MAIL_IMAP */\n  init_mail_imap_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MAIL_SMTP */\n  init_mail_smtp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* USENET */\n  init_usenet_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DNS */\n  init_dns_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FILETOPIA */\n  init_fbzero_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* VMWARE */\n  init_vmware_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NON_TCP_UDP */\n  init_non_tcp_udp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TVANTS */\n  init_tvants_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SOPCAST */\n  init_sopcast_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TVUPLAYER */\n  init_tvuplayer_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PPSTREAM */\n  init_ppstream_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PPLIVE */\n  init_pplive_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IAX */\n  init_iax_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MGPC */\n  init_mgpc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ZATTOO */\n  init_zattoo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* QQ */\n  init_qq_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SSH */\n  init_ssh_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AYIYA */\n  init_ayiya_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* THUNDER */\n  init_thunder_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* VNC */\n  init_vnc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TEAMVIEWER */\n  init_teamviewer_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DHCP */\n  init_dhcp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* STEAM */\n  init_steam_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* HALFLIFE2 */\n  init_halflife2_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* XBOX */\n  init_xbox_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* HTTP_APPLICATION_ACTIVESYNC */\n  init_http_activesync_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SMB */\n  init_smb_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MINING */\n  init_mining_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TELNET */\n  init_telnet_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NTP */\n  init_ntp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NFS */\n  init_nfs_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SSDP */\n  init_ssdp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WORLD_OF_WARCRAFT */\n  init_world_of_warcraft_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* POSTGRES */\n  init_postgres_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MYSQL */\n  init_mysql_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* BGP */\n  init_bgp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* BATTLEFIELD */\n  init_battlefield_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PCANYWHERE */\n  init_pcanywhere_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SNMP */\n  init_snmp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* KONTIKI */\n  init_kontiki_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ICECAST */\n  init_icecast_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SHOUTCAST */\n  init_shoutcast_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* KERBEROS */\n  init_kerberos_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* OPENFT */\n  init_openft_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SYSLOG */\n  init_syslog_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DIRECT_DOWNLOAD_LINK */\n  init_directdownloadlink_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NETBIOS */\n  init_netbios_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MDNS */\n  init_mdns_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IPP */\n  init_ipp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* LDAP */\n  init_ldap_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WARCRAFT3 */\n  init_warcraft3_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* XDMCP */\n  init_xdmcp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TFTP */\n  init_tftp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MSSQL_TDS */\n  init_mssql_tds_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PPTP */\n  init_pptp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* STEALTHNET */\n  init_stealthnet_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DHCPV6 */\n  init_dhcpv6_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AFP */\n  init_afp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* check_mk */\n  init_checkmk_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AIMINI */\n  init_aimini_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FLORENSIA */\n  init_florensia_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MAPLESTORY */\n  init_maplestory_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DOFUS */\n  init_dofus_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WORLD_OF_KUNG_FU */\n  init_world_of_kung_fu_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FIESTA */\n  init_fiesta_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CROSSIFIRE */\n  init_crossfire_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* GUILDWARS */\n  init_guildwars_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ARMAGETRON */\n  init_armagetron_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DROPBOX */\n  init_dropbox_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SPOTIFY */\n  init_spotify_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RADIUS */\n  init_radius_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CITRIX */\n  init_citrix_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* LOTUS_NOTES */\n  init_lotus_notes_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* GTP */\n  init_gtp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DCERPC */\n  init_dcerpc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NETFLOW */\n  init_netflow_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SFLOW */\n  init_sflow_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* H323 */\n  init_h323_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* OPENVPN */\n  init_openvpn_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NOE */\n  init_noe_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CISCOVPN */\n  init_ciscovpn_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TEAMSPEAK */\n  init_teamspeak_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TOR */\n  init_tor_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SKINNY */\n  init_skinny_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RTCP */\n  init_rtcp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RSYNC */\n  init_rsync_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WHOIS_DAS */\n  init_whois_das_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ORACLE */\n  init_oracle_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CORBA */\n  init_corba_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RTMP */\n  init_rtmp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FTP_CONTROL */\n  init_ftp_control_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FTP_DATA */\n  init_ftp_data_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PANDO */\n  init_pando_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MEGACO */\n  init_megaco_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* REDIS */\n  init_redis_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* UPnP */\n  init_upnp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* VHUA */\n  init_vhua_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ZMQ */\n  init_zmq_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TELEGRAM */\n  init_telegram_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* QUIC */\n  init_quic_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DIAMETER */\n  init_diameter_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* APPLE_PUSH */\n  init_apple_push_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* EAQ */\n  init_eaq_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* KAKAOTALK_VOICE */\n  init_kakaotalk_voice_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MPEGTS */\n  init_mpegts_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* UBNTAC2 */\n  init_ubntac2_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* COAP */\n  init_coap_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MQTT */\n  init_mqtt_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SOME/IP */\n  init_someip_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RX */\n  init_rx_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* GIT */\n  init_git_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* HANGOUT */\n  init_hangout_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DRDA */\n  init_drda_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* BJNP */\n  init_bjnp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SMPP */\n  init_smpp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TINC */\n  init_tinc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FIX */\n  init_fix_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NINTENDO */\n  init_nintendo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MODBUS */\n  init_modbus_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CAPWAP */\n  init_capwap_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ZABBIX */\n  init_zabbix_dissector(ndpi_str, &a, detection_bitmask);\n\n  /*** Put false-positive sensitive protocols at the end ***/\n\n  /* VIBER */\n  init_viber_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SKYPE */\n  init_skype_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* BITTORRENT */\n  init_bittorrent_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WHATSAPP */\n  init_whatsapp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* OOKLA */\n  init_ookla_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AMQP */\n  init_amqp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CSGO */\n  init_csgo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* LISP */\n  init_lisp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AJP */\n  init_ajp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Memcached */\n  init_memcached_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Nest Log Sink */\n  init_nest_log_sink_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WireGuard VPN */\n  init_wireguard_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Amazon_Video */\n  init_amazon_video_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Targus Getdata */\n  init_targus_getdata_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* S7 comm */\n  init_s7comm_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IEC 60870-5-104 */\n  init_104_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WEBSOCKET */\n  init_websocket_dissector(ndpi_str, &a, detection_bitmask);\n\n#ifdef CUSTOM_NDPI_PROTOCOLS\n#include \"../../../nDPI-custom/custom_ndpi_main_init.c\"\n#endif\n\n  /* ----------------------------------------------------------------- */\n\n  ndpi_str->callback_buffer_size = a;\n\n  NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size is %u\\n\", ndpi_str->callback_buffer_size);\n\n  /* now build the specific buffer for tcp, udp and non_tcp_udp */\n  ndpi_str->callback_buffer_size_tcp_payload = 0;\n  ndpi_str->callback_buffer_size_tcp_no_payload = 0;\n  for (a = 0; a < ndpi_str->callback_buffer_size; a++) {\n    if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &\n\t(NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |\n\t NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {\n      if(_ndpi_debug_callbacks)\n\tNDPI_LOG_DBG2(ndpi_str, \"callback_buffer_tcp_payload, adding buffer %u as entry %u\\n\", a,\n\t\t      ndpi_str->callback_buffer_size_tcp_payload);\n\n      memcpy(&ndpi_str->callback_buffer_tcp_payload[ndpi_str->callback_buffer_size_tcp_payload],\n\t     &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));\n      ndpi_str->callback_buffer_size_tcp_payload++;\n\n      if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) ==\n\t 0) {\n\tif(_ndpi_debug_callbacks)\n\t  NDPI_LOG_DBG2(\n                        ndpi_str,\n                        \"\\tcallback_buffer_tcp_no_payload, additional adding buffer %u to no_payload process\\n\", a);\n\n\tmemcpy(&ndpi_str->callback_buffer_tcp_no_payload[ndpi_str->callback_buffer_size_tcp_no_payload],\n\t       &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));\n\tndpi_str->callback_buffer_size_tcp_no_payload++;\n      }\n    }\n  }\n\n  ndpi_str->callback_buffer_size_udp = 0;\n  for (a = 0; a < ndpi_str->callback_buffer_size; a++) {\n    if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &\n\t(NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |\n\t NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {\n      if(_ndpi_debug_callbacks)\n\tNDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size_udp: adding buffer : %u as entry %u\\n\", a,\n\t\t      ndpi_str->callback_buffer_size_udp);\n\n      memcpy(&ndpi_str->callback_buffer_udp[ndpi_str->callback_buffer_size_udp], &ndpi_str->callback_buffer[a],\n\t     sizeof(struct ndpi_call_function_struct));\n      ndpi_str->callback_buffer_size_udp++;\n    }\n  }\n\n  ndpi_str->callback_buffer_size_non_tcp_udp = 0;\n  for (a = 0; a < ndpi_str->callback_buffer_size; a++) {\n    if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &\n\t(NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP |\n\t NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)) == 0 ||\n       (ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC) !=\n       0) {\n      if(_ndpi_debug_callbacks)\n\tNDPI_LOG_DBG2(ndpi_str, \"callback_buffer_non_tcp_udp: adding buffer : %u as entry %u\\n\", a,\n\t\t      ndpi_str->callback_buffer_size_non_tcp_udp);\n\n      memcpy(&ndpi_str->callback_buffer_non_tcp_udp[ndpi_str->callback_buffer_size_non_tcp_udp],\n\t     &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));\n      ndpi_str->callback_buffer_size_non_tcp_udp++;\n    }\n  }\n}\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n/* handle extension headers in IPv6 packets\n * arguments:\n * \tl4ptr: pointer to the byte following the initial IPv6 header\n * \tl4len: the length of the IPv6 packet excluding the IPv6 header\n * \tnxt_hdr: next header value from the IPv6 header\n * result:\n * \tl4ptr: pointer to the start of the actual packet payload\n * \tl4len: length of the actual payload\n * \tnxt_hdr: protocol of the actual payload\n * returns 0 upon success and 1 upon failure\n */\nint ndpi_handle_ipv6_extension_headers(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t **l4ptr,\n                                       u_int16_t *l4len, u_int8_t *nxt_hdr) {\n  while ((*nxt_hdr == 0 || *nxt_hdr == 43 || *nxt_hdr == 44 || *nxt_hdr == 60 || *nxt_hdr == 135 || *nxt_hdr == 59)) {\n    u_int16_t ehdr_len;\n\n    // no next header\n    if(*nxt_hdr == 59) {\n      return(1);\n    }\n    // fragment extension header has fixed size of 8 bytes and the first byte is the next header type\n    if(*nxt_hdr == 44) {\n      if(*l4len < 8) {\n\treturn(1);\n      }\n      *nxt_hdr = (*l4ptr)[0];\n      *l4len -= 8;\n      (*l4ptr) += 8;\n      continue;\n    }\n    // the other extension headers have one byte for the next header type\n    // and one byte for the extension header length in 8 byte steps minus the first 8 bytes\n    if(*l4len < 2) {\n      return(1);\n    }\n    ehdr_len = (*l4ptr)[1];\n    ehdr_len *= 8;\n    ehdr_len += 8;\n\n    if(*l4len < ehdr_len) {\n      return(1);\n    }\n    *nxt_hdr = (*l4ptr)[0];\n    *l4len -= ehdr_len;\n    (*l4ptr) += ehdr_len;\n  }\n  return(0);\n}\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\nstatic u_int8_t ndpi_iph_is_valid_and_not_fragmented(const struct ndpi_iphdr *iph, const u_int16_t ipsize) {\n  //#ifdef REQUIRE_FULL_PACKETS\n  if(ipsize < iph->ihl * 4 || ipsize < ntohs(iph->tot_len) || ntohs(iph->tot_len) < iph->ihl * 4 ||\n     (iph->frag_off & htons(0x1FFF)) != 0) {\n    return(0);\n  }\n  //#endif\n\n  return(1);\n}\n\nstatic u_int8_t ndpi_detection_get_l4_internal(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t *l3,\n                                               u_int16_t l3_len, const u_int8_t **l4_return, u_int16_t *l4_len_return,\n                                               u_int8_t *l4_protocol_return, u_int32_t flags) {\n  const struct ndpi_iphdr *iph = NULL;\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  const struct ndpi_ipv6hdr *iph_v6 = NULL;\n#endif\n  u_int16_t l4len = 0;\n  const u_int8_t *l4ptr = NULL;\n  u_int8_t l4protocol = 0;\n\n  if(l3 == NULL || l3_len < sizeof(struct ndpi_iphdr))\n    return(1);\n\n  if((iph = (const struct ndpi_iphdr *) l3) == NULL)\n    return(1);\n\n  if(iph->version == IPVERSION && iph->ihl >= 5) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");\n  }\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  else if(iph->version == 6 && l3_len >= sizeof(struct ndpi_ipv6hdr)) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");\n    iph_v6 = (const struct ndpi_ipv6hdr *) l3;\n    iph = NULL;\n  }\n#endif\n  else {\n    return(1);\n  }\n\n  if((flags & NDPI_DETECTION_ONLY_IPV6) && iph != NULL) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv4 header found but excluded by flag\\n\");\n    return(1);\n  }\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  else if((flags & NDPI_DETECTION_ONLY_IPV4) && iph_v6 != NULL) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv6 header found but excluded by flag\\n\");\n    return(1);\n  }\n#endif\n\n  if(iph != NULL && ndpi_iph_is_valid_and_not_fragmented(iph, l3_len)) {\n    u_int16_t len = ntohs(iph->tot_len);\n    u_int16_t hlen = (iph->ihl * 4);\n\n    l4ptr = (((const u_int8_t *) iph) + iph->ihl * 4);\n\n    if(len == 0)\n      len = l3_len;\n\n    l4len = (len > hlen) ? (len - hlen) : 0;\n    l4protocol = iph->protocol;\n  }\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  else if(iph_v6 != NULL && (l3_len - sizeof(struct ndpi_ipv6hdr)) >= ntohs(iph_v6->ip6_hdr.ip6_un1_plen)) {\n    l4ptr = (((const u_int8_t *) iph_v6) + sizeof(struct ndpi_ipv6hdr));\n    l4len = ntohs(iph_v6->ip6_hdr.ip6_un1_plen);\n    l4protocol = iph_v6->ip6_hdr.ip6_un1_nxt;\n\n    // we need to handle IPv6 extension headers if present\n    if(ndpi_handle_ipv6_extension_headers(ndpi_str, &l4ptr, &l4len, &l4protocol) != 0) {\n      return(1);\n    }\n\n  }\n#endif\n  else {\n    return(1);\n  }\n\n  if(l4_return != NULL) {\n    *l4_return = l4ptr;\n  }\n\n  if(l4_len_return != NULL) {\n    *l4_len_return = l4len;\n  }\n\n  if(l4_protocol_return != NULL) {\n    *l4_protocol_return = l4protocol;\n  }\n\n  return(0);\n}\n\n/* ************************************************ */\n\nvoid ndpi_apply_flow_protocol_to_packet(struct ndpi_flow_struct *flow, struct ndpi_packet_struct *packet) {\n  memcpy(&packet->detected_protocol_stack, &flow->detected_protocol_stack, sizeof(packet->detected_protocol_stack));\n  memcpy(&packet->protocol_stack_info, &flow->protocol_stack_info, sizeof(packet->protocol_stack_info));\n}\n\n/* ************************************************ */\n\nstatic int ndpi_init_packet_header(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t   struct ndpi_flow_struct *flow,\n                                   unsigned short packetlen) {\n  const struct ndpi_iphdr *decaps_iph = NULL;\n  u_int16_t l3len;\n  u_int16_t l4len;\n  const u_int8_t *l4ptr;\n  u_int8_t l4protocol;\n  u_int8_t l4_result;\n\n  if(!flow)\n    return(1);\n\n  /* reset payload_packet_len, will be set if ipv4 tcp or udp */\n  flow->packet.payload_packet_len = 0;\n  flow->packet.l4_packet_len = 0;\n  flow->packet.l3_packet_len = packetlen;\n\n  flow->packet.tcp = NULL, flow->packet.udp = NULL;\n  flow->packet.generic_l4_ptr = NULL;\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  flow->packet.iphv6 = NULL;\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\n  ndpi_apply_flow_protocol_to_packet(flow, &flow->packet);\n\n  l3len = flow->packet.l3_packet_len;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  if(flow->packet.iph != NULL) {\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\n    decaps_iph = flow->packet.iph;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  }\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\n  if(decaps_iph && decaps_iph->version == IPVERSION && decaps_iph->ihl >= 5) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");\n  }\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  else if(decaps_iph && decaps_iph->version == 6 && l3len >= sizeof(struct ndpi_ipv6hdr) &&\n\t  (ndpi_str->ip_version_limit & NDPI_DETECTION_ONLY_IPV4) == 0) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");\n    flow->packet.iphv6 = (struct ndpi_ipv6hdr *) flow->packet.iph;\n    flow->packet.iph = NULL;\n  }\n#endif\n  else {\n    flow->packet.iph = NULL;\n    return(1);\n  }\n\n  /* needed:\n   *  - unfragmented packets\n   *  - ip header <= packet len\n   *  - ip total length >= packet len\n   */\n\n  l4ptr = NULL;\n  l4len = 0;\n  l4protocol = 0;\n\n  l4_result =\n    ndpi_detection_get_l4_internal(ndpi_str, (const u_int8_t *) decaps_iph, l3len, &l4ptr, &l4len, &l4protocol, 0);\n\n  if(l4_result != 0) {\n    return(1);\n  }\n\n  flow->packet.l4_protocol = l4protocol;\n  flow->packet.l4_packet_len = l4len;\n  flow->l4_proto = l4protocol;\n\n  /* tcp / udp detection */\n  if(l4protocol == IPPROTO_TCP && flow->packet.l4_packet_len >= 20 /* min size of tcp */) {\n    /* tcp */\n    flow->packet.tcp = (struct ndpi_tcphdr *) l4ptr;\n    if(flow->packet.l4_packet_len >= flow->packet.tcp->doff * 4) {\n      flow->packet.payload_packet_len = flow->packet.l4_packet_len - flow->packet.tcp->doff * 4;\n      flow->packet.actual_payload_len = flow->packet.payload_packet_len;\n      flow->packet.payload = ((u_int8_t *) flow->packet.tcp) + (flow->packet.tcp->doff * 4);\n\n      /* check for new tcp syn packets, here\n       * idea: reset detection state if a connection is unknown\n       */\n      if(flow->packet.tcp->syn != 0 && flow->packet.tcp->ack == 0 && flow->init_finished != 0 &&\n\t flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {\n\tu_int8_t backup;\n\tu_int16_t backup1, backup2;\n\n\tif(flow->http.url) {\n\t  ndpi_free(flow->http.url);\n\t  flow->http.url = NULL;\n\t}\n\tif(flow->http.content_type) {\n\t  ndpi_free(flow->http.content_type);\n\t  flow->http.content_type = NULL;\n\t}\n\tif(flow->http.user_agent) {\n\t  ndpi_free(flow->http.user_agent);\n\t  flow->http.user_agent = NULL;\n\t}\n\tif(flow->kerberos_buf.pktbuf) {\n\t  ndpi_free(flow->kerberos_buf.pktbuf);\n\t  flow->kerberos_buf.pktbuf = NULL;\n\t}\n\tif(flow->l4.tcp.tls.message.buffer) {\n\t  ndpi_free(flow->l4.tcp.tls.message.buffer);\n\t  flow->l4.tcp.tls.message.buffer = NULL;\n\t  flow->l4.tcp.tls.message.buffer_len = flow->l4.tcp.tls.message.buffer_used = 0;\n\t}\n\n\tbackup = flow->num_processed_pkts;\n\tbackup1 = flow->guessed_protocol_id;\n\tbackup2 = flow->guessed_host_protocol_id;\n\tmemset(flow, 0, sizeof(*(flow)));\n\tflow->num_processed_pkts = backup;\n\tflow->guessed_protocol_id = backup1;\n\tflow->guessed_host_protocol_id = backup2;\n\n\tNDPI_LOG_DBG(ndpi_str, \"tcp syn packet for unknown protocol, reset detection state\\n\");\n      }\n    } else {\n      /* tcp header not complete */\n      flow->packet.tcp = NULL;\n    }\n  } else if(l4protocol == IPPROTO_UDP && flow->packet.l4_packet_len >= 8 /* size of udp */) {\n    flow->packet.udp = (struct ndpi_udphdr *) l4ptr;\n    flow->packet.payload_packet_len = flow->packet.l4_packet_len - 8;\n    flow->packet.payload = ((u_int8_t *) flow->packet.udp) + 8;\n  } else {\n    flow->packet.generic_l4_ptr = l4ptr;\n  }\n\n  return(0);\n}\n\n/* ************************************************ */\n\nvoid ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t      struct ndpi_flow_struct *flow) {\n  if(!flow) {\n    return;\n  } else {\n    /* const for gcc code optimization and cleaner code */\n    struct ndpi_packet_struct *packet = &flow->packet;\n    const struct ndpi_iphdr *iph = packet->iph;\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n    const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;\n#endif\n    const struct ndpi_tcphdr *tcph = packet->tcp;\n    const struct ndpi_udphdr *udph = flow->packet.udp;\n\n    packet->tcp_retransmission = 0, packet->packet_direction = 0;\n\n    if(ndpi_str->direction_detect_disable) {\n      packet->packet_direction = flow->packet_direction;\n    } else {\n      if(iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))\n\tpacket->packet_direction = 1;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n      if(iphv6 != NULL && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)\n\tpacket->packet_direction = 1;\n#endif\n    }\n\n    packet->packet_lines_parsed_complete = 0;\n\n    if(flow->init_finished == 0) {\n      flow->init_finished = 1;\n      flow->setup_packet_direction = packet->packet_direction;\n    }\n\n    if(tcph != NULL) {\n      /* reset retried bytes here before setting it */\n      packet->num_retried_bytes = 0;\n\n      if(!ndpi_str->direction_detect_disable)\n\tpacket->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;\n\n      if(tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&\n\t flow->l4.tcp.seen_ack == 0) {\n\tflow->l4.tcp.seen_syn = 1;\n      }\n      if(tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&\n\t flow->l4.tcp.seen_ack == 0) {\n\tflow->l4.tcp.seen_syn_ack = 1;\n      }\n      if(tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&\n\t flow->l4.tcp.seen_ack == 0) {\n\tflow->l4.tcp.seen_ack = 1;\n      }\n      if((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||\n\t (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {\n\t/* initialize tcp sequence counters */\n\t/* the ack flag needs to be set to get valid sequence numbers from the other\n\t * direction. Usually it will catch the second packet syn+ack but it works\n\t * also for asymmetric traffic where it will use the first data packet\n\t *\n\t * if the syn flag is set add one to the sequence number,\n\t * otherwise use the payload length.\n\t */\n\tif(tcph->ack != 0) {\n\t  flow->next_tcp_seq_nr[flow->packet.packet_direction] =\n\t    ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);\n\n\t  flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);\n\t}\n      } else if(packet->payload_packet_len > 0) {\n\t/* check tcp sequence counters */\n\tif(((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >\n\t   ndpi_str->tcp_max_retransmission_window_size) {\n\t  packet->tcp_retransmission = 1;\n\n\t  /* CHECK IF PARTIAL RETRY IS HAPPENING */\n\t  if((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <\n\t      packet->payload_packet_len)) {\n\t    /* num_retried_bytes actual_payload_len hold info about the partial retry\n\t       analyzer which require this info can make use of this info\n\t       Other analyzer can use packet->payload_packet_len */\n\t    packet->num_retried_bytes =\n\t      (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));\n\t    packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;\n\t    flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;\n\t  }\n\t}\n\n\t/* normal path\n\t   actual_payload_len is initialized to payload_packet_len during tcp header parsing itself.\n\t   It will be changed only in case of retransmission */\n\telse {\n\t  packet->num_retried_bytes = 0;\n\t  flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;\n\t}\n      }\n\n      if(tcph->rst) {\n\tflow->next_tcp_seq_nr[0] = 0;\n\tflow->next_tcp_seq_nr[1] = 0;\n      }\n    } else if(udph != NULL) {\n      if(!ndpi_str->direction_detect_disable)\n\tpacket->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;\n    }\n\n    if(flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {\n      flow->packet_counter++;\n    }\n\n    if(flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&\n       packet->payload_packet_len) {\n      flow->packet_direction_counter[packet->packet_direction]++;\n    }\n\n    if(flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >\n       flow->byte_counter[packet->packet_direction]) {\n      flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;\n    }\n  }\n}\n\n/* ************************************************ */\n\nvoid check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {\n  if(!flow)\n    return;\n\n  void *func = NULL;\n  u_int32_t a;\n  u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;\n  int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;\n  NDPI_PROTOCOL_BITMASK detection_bitmask;\n\n  NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);\n\n  if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&\n     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t  ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&\n     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&\n     (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n     ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {\n    if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n       (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))\n      ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),\n\tfunc = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;\n  }\n\n  for (a = 0; a < ndpi_str->callback_buffer_size_non_tcp_udp; a++) {\n    if((func != ndpi_str->callback_buffer_non_tcp_udp[a].func) &&\n       (ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n       ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask &&\n       NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t    ndpi_str->callback_buffer_non_tcp_udp[a].excluded_protocol_bitmask) == 0 &&\n       NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_non_tcp_udp[a].detection_bitmask, detection_bitmask) != 0) {\n      if(ndpi_str->callback_buffer_non_tcp_udp[a].func != NULL)\n\tndpi_str->callback_buffer_non_tcp_udp[a].func(ndpi_str, flow);\n\n      if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)\n\tbreak; /* Stop after detecting the first protocol */\n    }\n  }\n}\n\n/* ************************************************ */\n\nvoid check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                              NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {\n  void *func = NULL;\n  u_int32_t a;\n  u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;\n  int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;\n  NDPI_PROTOCOL_BITMASK detection_bitmask;\n\n  NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);\n\n  if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&\n     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t  ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&\n     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&\n     (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n     ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {\n    if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n       (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))\n      ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),\n\tfunc = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;\n  }\n\n  if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {\n    for (a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {\n      if((func != ndpi_str->callback_buffer_udp[a].func) &&\n\t (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n\t ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask &&\n\t NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t      ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0 &&\n\t NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask, detection_bitmask) != 0) {\n\tndpi_str->callback_buffer_udp[a].func(ndpi_str, flow);\n\n\t// NDPI_LOG_DBG(ndpi_str, \"[UDP,CALL] dissector of protocol as callback_buffer idx =  %d\\n\",a);\n\tif(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)\n\t  break; /* Stop after detecting the first protocol */\n      } else if(_ndpi_debug_callbacks)\n\tNDPI_LOG_DBG2(ndpi_str, \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\", a);\n    }\n  }\n}\n\n/* ************************************************ */\n\nvoid check_ndpi_tcp_flow_func(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t      struct ndpi_flow_struct *flow,\n                              NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {\n  void *func = NULL;\n  u_int32_t a;\n  u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;\n  int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;\n  NDPI_PROTOCOL_BITMASK detection_bitmask;\n\n  NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);\n\n  if(flow->packet.payload_packet_len != 0) {\n    if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&\n       NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t    ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&\n       NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&\n       (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n       ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {\n      if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n\t (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))\n\tndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),\n\t  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;\n    }\n\n    if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {\n      for (a = 0; a < ndpi_str->callback_buffer_size_tcp_payload; a++) {\n\tif((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&\n\t   (ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n\t   ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask &&\n\t   NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t\tndpi_str->callback_buffer_tcp_payload[a].excluded_protocol_bitmask) == 0 &&\n\t   NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_payload[a].detection_bitmask,\n\t\t\t\tdetection_bitmask) != 0) {\n\t  ndpi_str->callback_buffer_tcp_payload[a].func(ndpi_str, flow);\n\n\t  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)\n\t    break; /* Stop after detecting the first protocol */\n\t}\n      }\n    }\n  } else {\n    /* no payload */\n    if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&\n       NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t    ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&\n       NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&\n       (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n       ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {\n      if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n\t (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL) &&\n\t ((ndpi_str->callback_buffer[flow->guessed_protocol_id].ndpi_selection_bitmask &\n\t   NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0))\n\tndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),\n\t  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;\n    }\n\n    for (a = 0; a < ndpi_str->callback_buffer_size_tcp_no_payload; a++) {\n      if((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&\n\t (ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n\t ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask &&\n\t NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t      ndpi_str->callback_buffer_tcp_no_payload[a].excluded_protocol_bitmask) == 0 &&\n\t NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_no_payload[a].detection_bitmask,\n\t\t\t      detection_bitmask) != 0) {\n\tndpi_str->callback_buffer_tcp_no_payload[a].func(ndpi_str, flow);\n\n\tif(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)\n\t  break; /* Stop after detecting the first protocol */\n      }\n    }\n  }\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_check_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                          NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {\n  if(flow->packet.tcp != NULL)\n    check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet);\n  else if(flow->packet.udp != NULL)\n    check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet);\n  else\n    check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet);\n}\n\n/* ********************************************************************************* */\n\nu_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t      struct ndpi_flow_struct *flow) {\n  u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;\n\n  if(flow->packet.iph) {\n    struct in_addr addr;\n    u_int16_t sport, dport;\n\n    addr.s_addr = flow->packet.iph->saddr;\n\n    if((flow->l4_proto == IPPROTO_TCP) && flow->packet.tcp)\n      sport = flow->packet.tcp->source, dport = flow->packet.tcp->dest;\n    else if((flow->l4_proto == IPPROTO_UDP) && flow->packet.udp)\n      sport = flow->packet.udp->source, dport = flow->packet.udp->dest;\n    else\n      sport = dport = 0;\n\n    /* guess host protocol */\n    ret = ndpi_network_port_ptree_match(ndpi_str, &addr, sport);\n\n    if(ret == NDPI_PROTOCOL_UNKNOWN) {\n      addr.s_addr = flow->packet.iph->daddr;\n      ret = ndpi_network_port_ptree_match(ndpi_str, &addr, dport);\n    }\n  }\n\n  return(ret);\n}\n\n/* ********************************************************************************* */\n\nndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                    u_int8_t enable_guess, u_int8_t *protocol_was_guessed) {\n  ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};\n\n  *protocol_was_guessed = 0;\n\n  if(flow == NULL)\n    return(ret);\n\n  /* Init defaults */\n  ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];\n  ret.category = flow->category;\n\n  /* Ensure that we don't change our mind if detection is already complete */\n  if((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))\n    return(ret);\n\n  /* TODO: add the remaining stage_XXXX protocols */\n  if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {\n    u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN, guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;\n\n    if(flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)\n      goto check_stun_export;\n    else if((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO) ||\n\t    (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER) ||\n\t    (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL)) {\n      *protocol_was_guessed = 1;\n      ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);\n    }\n    else if((flow->l4.tcp.tls.hello_processed == 1) &&\n\t    (flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0')) {\n      *protocol_was_guessed = 1;\n      ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);\n    } else if(enable_guess) {\n      if((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN) && (flow->packet.l4_protocol == IPPROTO_TCP) &&\n\t flow->l4.tcp.tls.hello_processed)\n\tflow->guessed_protocol_id = NDPI_PROTOCOL_TLS;\n\n      guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;\n\n      if((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n\t ((flow->packet.l4_protocol == IPPROTO_UDP) &&\n\t  NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id) &&\n\t  is_udp_guessable_protocol(guessed_host_protocol_id)))\n\tflow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;\n\n      /* Ignore guessed protocol if they have been discarded */\n      if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)\n\t // && (guessed_host_protocol_id == NDPI_PROTOCOL_UNKNOWN)\n\t && (flow->packet.l4_protocol == IPPROTO_UDP) &&\n\t NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id) &&\n\t is_udp_guessable_protocol(guessed_protocol_id))\n\tflow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;\n\n      if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {\n\tif((guessed_protocol_id == 0) && (flow->protos.stun_ssl.stun.num_binding_requests > 0) &&\n\t   (flow->protos.stun_ssl.stun.num_processed_pkts > 0))\n\t  guessed_protocol_id = NDPI_PROTOCOL_STUN;\n\n\tif(flow->host_server_name[0] != '\\0') {\n\t  ndpi_protocol_match_result ret_match;\n\n\t  memset(&ret_match, 0, sizeof(ret_match));\n\n\t  ndpi_match_host_subprotocol(ndpi_str, flow, (char *) flow->host_server_name,\n\t\t\t\t      strlen((const char *) flow->host_server_name), &ret_match,\n\t\t\t\t      NDPI_PROTOCOL_DNS);\n\n\t  if(ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)\n\t    guessed_host_protocol_id = ret_match.protocol_id;\n\t}\n\n\t*protocol_was_guessed = 1;\n\tndpi_int_change_protocol(ndpi_str, flow, guessed_host_protocol_id, guessed_protocol_id);\n      }\n    }\n  } else if(enable_guess) {\n    if(flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n      *protocol_was_guessed = 1;\n      flow->detected_protocol_stack[1] = flow->guessed_protocol_id;\n    }\n\n    if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n      *protocol_was_guessed = 1;\n      flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;\n    }\n\n    if(flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0]) {\n      *protocol_was_guessed = 1;\n      flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;\n    }\n  }\n\n  if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) &&\n     (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {\n  check_stun_export:\n    if(flow->protos.stun_ssl.stun.num_processed_pkts || flow->protos.stun_ssl.stun.num_udp_pkts) {\n      // if(/* (flow->protos.stun_ssl.stun.num_processed_pkts >= NDPI_MIN_NUM_STUN_DETECTION) */\n      *protocol_was_guessed = 1;\n      ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_STUN);\n    }\n  }\n\n  ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];\n\n  if(ret.master_protocol == NDPI_PROTOCOL_STUN) {\n    if(ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)\n      ret.app_protocol = NDPI_PROTOCOL_MESSENGER;\n    else if(ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {\n      /*\n\tAs Google has recently introduced Duo,\n\twe need to distinguish between it and hangout\n\tthing that should be handled by the STUN dissector\n      */\n      ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;\n    }\n  }\n\n  if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) {\n    *protocol_was_guessed = 1;\n    ndpi_fill_protocol_category(ndpi_str, flow, &ret);\n  }\n\n  return(ret);\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                               const unsigned char *packet, const unsigned short packetlen,\n                               const u_int64_t current_tick_l, struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {\n  if(flow == NULL)\n    return;\n\n  if(flow->server_id == NULL)\n    flow->server_id = dst; /* Default */\n\n  /* need at least 20 bytes for ip header */\n  if(packetlen < 20) {\n    return;\n  }\n\n  flow->packet.tick_timestamp_l = current_tick_l;\n  flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);\n\n  /* parse packet */\n  flow->packet.iph = (struct ndpi_iphdr *) packet;\n  /* we are interested in ipv4 packet */\n\n  /* set up the packet headers for the extra packet function to use if it wants */\n  if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)\n    return;\n\n  /* detect traffic for tcp or udp only */\n  flow->src = src, flow->dst = dst;\n  ndpi_connection_tracking(ndpi_str, flow);\n\n  /* call the extra packet function (which may add more data/info to flow) */\n  if(flow->extra_packets_func) {\n    if((flow->extra_packets_func(ndpi_str, flow)) == 0)\n      flow->check_extra_packets = 0;\n\n    if(++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)\n      flow->extra_packets_func = NULL; /* Enough packets detected */\n  }\n}\n\n/* ********************************************************************************* */\n\nint ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str, const char *ip_address_and_mask,\n                          ndpi_protocol_category_t category) {\n  patricia_node_t *node;\n  struct in_addr pin;\n  int bits = 32;\n  char *ptr;\n  char ipbuf[64];\n\n  strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));\n  ipbuf[sizeof(ipbuf) - 1] = '\\0';\n\n  ptr = strrchr(ipbuf, '/');\n\n  if(ptr) {\n    *(ptr++) = '\\0';\n    if(atoi(ptr) >= 0 && atoi(ptr) <= 32)\n      bits = atoi(ptr);\n  }\n\n  if(inet_pton(AF_INET, ipbuf, &pin) != 1) {\n    NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);\n    return(-1);\n  }\n\n  if((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow, AF_INET, &pin, bits)) != NULL) {\n    node->value.uv.user_value = (u_int16_t)category, node->value.uv.additional_user_value = 0;\n  }\n\n  return(0);\n}\n\n\n/* ********************************************************************************* */\n\nint ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str, const char *name_to_add,\n                                ndpi_protocol_category_t category) {\n  char *name;\n\n  if(name_to_add == NULL)\n    return(-1);\n\n  name = ndpi_strdup(name_to_add);\n\n  if(name == NULL)\n    return(-1);\n\n#if 0\n  printf(\"===> %s() Loading %s as %u\\n\", __FUNCTION__, name, category);\n#endif\n\n  AC_PATTERN_t ac_pattern;\n  AC_ERROR_t rc;\n\n  memset(&ac_pattern, 0, sizeof(ac_pattern));\n\n  if(ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {\n    free(name);\n    return(-1);\n  }\n\n  ac_pattern.astring = name, ac_pattern.length = strlen(ac_pattern.astring);\n  ac_pattern.rep.number = (u_int32_t) category,  ac_pattern.rep.category = category;;\n\n  rc = ac_automata_add(ndpi_str->custom_categories.hostnames_shadow.ac_automa, &ac_pattern);\n  if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS) {\n    free(name);\n    return(-1);\n  }\n\n  if(rc == ACERR_DUPLICATE_PATTERN)\n    free(name);\n\n  return(0);\n}\n\n/* ********************************************************************************* */\n\n/* Loads an IP or name category */\nint ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct, const char *ip_or_name,\n                       ndpi_protocol_category_t category) {\n  int rv;\n\n  /* Try to load as IP address first */\n  rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);\n\n  if(rv < 0) {\n    /* IP load failed, load as hostname */\n    rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);\n  }\n\n  return(rv);\n}\n\n/* ********************************************************************************* */\n\nint ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str) {\n  int i;\n\n  /* First add the nDPI known categories matches */\n  for (i = 0; category_match[i].string_to_match != NULL; i++)\n    ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);\n\n  /* Free */\n  ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,\n\t\t      1 /* free patterns strings memory */);\n\n  /* Finalize */\n  ac_automata_finalize((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa);\n\n  /* Swap */\n  ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;\n\n  /* Realloc */\n  ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);\n\n  if(ndpi_str->custom_categories.ipAddresses != NULL)\n    ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);\n\n  ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;\n  ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);\n\n  ndpi_str->custom_categories.categories_loaded = 1;\n\n  return(0);\n}\n\n/* ********************************************************************************* */\n\nint ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_str, u_int32_t saddr, u_int32_t daddr,\n                                   ndpi_protocol *ret) {\n  if(ndpi_str->custom_categories.categories_loaded) {\n    prefix_t prefix;\n    patricia_node_t *node;\n\n    if(saddr == 0)\n      node = NULL;\n    else {\n      /* Make sure all in network byte order otherwise compares wont work */\n      fill_prefix_v4(&prefix, (struct in_addr *) &saddr, 32,\n\t\t     ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n      node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);\n    }\n\n    if(!node) {\n      if(daddr != 0) {\n\tfill_prefix_v4(&prefix, (struct in_addr *) &daddr, 32,\n\t\t       ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n\tnode = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);\n      }\n    }\n\n    if(node) {\n      ret->category = (ndpi_protocol_category_t) node->value.uv.user_value;\n\n      return(1);\n    }\n  }\n\n  ret->category = ndpi_get_proto_category(ndpi_str, *ret);\n\n  return(0);\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                 ndpi_protocol *ret) {\n  if(ndpi_str->custom_categories.categories_loaded) {\n    if(flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {\n      flow->category = ret->category = flow->guessed_header_category;\n      return;\n    }\n\n    if(flow->host_server_name[0] != '\\0') {\n      u_int32_t id;\n      int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->host_server_name,\n\t\t\t\t\t  strlen((char *) flow->host_server_name), &id);\n\n      if(rc == 0) {\n\tflow->category = ret->category = (ndpi_protocol_category_t) id;\n\treturn;\n      }\n    }\n\n    if(flow->l4.tcp.tls.hello_processed == 1 &&\n       flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0') {\n      u_int32_t id;\n      int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->protos.stun_ssl.ssl.client_requested_server_name,\n\t\t\t\t\t  strlen(flow->protos.stun_ssl.ssl.client_requested_server_name), &id);\n\n      if(rc == 0) {\n\tflow->category = ret->category = (ndpi_protocol_category_t) id;\n\treturn;\n      }\n    }\n  }\n\n  flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);\n}\n\n/* ********************************************************************************* */\n\nstatic void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}\n\n/* ********************************************************************************* */\n\nstatic void ndpi_reconcile_protocols(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t    struct ndpi_flow_struct *flow,\n\t\t\t\t    ndpi_protocol *ret) {\n  /*\n     Skype for a host doing MS Teams means MS Teams\n     (MS Teams uses Skype as transport protocol for voice/video)\n  */\n\n  switch(ret->app_protocol) {\n  case NDPI_PROTOCOL_MSTEAMS:\n    if(flow->packet.iph && flow->packet.tcp) {\n      // printf(\"====>> NDPI_PROTOCOL_MSTEAMS\\n\");\n\n      if(ndpi_str->msteams_cache == NULL)\n\tndpi_str->msteams_cache = ndpi_lru_cache_init(1024);\n\n      if(ndpi_str->msteams_cache)\n\tndpi_lru_add_to_cache(ndpi_str->msteams_cache,\n\t\t\t      flow->packet.iph->saddr,\n\t\t\t      flow->packet.tick_timestamp & 0xFFFF /* 16 bit */);\n    }\n    break;\n\n  case NDPI_PROTOCOL_SKYPE:\n  case NDPI_PROTOCOL_SKYPE_CALL:\n    if(flow->packet.iph\n       && flow->packet.udp\n       && ndpi_str->msteams_cache) {\n      u_int16_t when;\n\n      if(ndpi_lru_find_cache(ndpi_str->msteams_cache, flow->packet.iph->saddr,\n\t\t\t     &when, 0 /* Don't remove it as it can be used for other connections */)) {\n\tu_int16_t tdiff = (flow->packet.tick_timestamp & 0xFFFF) - when;\n\n\tif(tdiff < 60 /* sec */) {\n\t  // printf(\"====>> NDPI_PROTOCOL_SKYPE(_CALL) -> NDPI_PROTOCOL_MSTEAMS [%u]\\n\", tdiff);\n\t  ret->app_protocol = NDPI_PROTOCOL_MSTEAMS;\n\n\t  /* Refresh cache */\n\t  ndpi_lru_add_to_cache(ndpi_str->msteams_cache,\n\t\t\t\tflow->packet.iph->saddr,\n\t\t\t\tflow->packet.tick_timestamp & 0xFFFF /* 16 bit */);\n\t}\n      }\n    }\n    break;\n  } /* switch */\n}\n\n/* ********************************************************************************* */\n\nndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,\n                                            struct ndpi_flow_struct *flow, const unsigned char *packet,\n                                            const unsigned short packetlen, const u_int64_t current_tick_l,\n                                            struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {\n  NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;\n  u_int32_t a;\n  ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};\n\n  if(ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)\n    NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,\n\t     \"START packet processing\\n\");\n\n  if(flow == NULL)\n    return(ret);\n  else\n    ret.category = flow->category;\n\n  flow->num_processed_pkts++;\n\n  /* Init default */\n  ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];\n\n  if(flow->server_id == NULL)\n    flow->server_id = dst; /* Default */\n\n  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN) {\n    if(flow->check_extra_packets) {\n      ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_tick_l, src, dst);\n      /* Update in case of new match */\n      ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0],\n\tret.category = flow->category;\n      goto invalidate_ptr;\n    } else\n      goto ret_protocols;\n  }\n\n  /* need at least 20 bytes for ip header */\n  if(packetlen < 20) {\n    /* reset protocol which is normally done in init_packet_header */\n    ndpi_int_reset_packet_protocol(&flow->packet);\n    goto invalidate_ptr;\n  }\n\n  flow->packet.tick_timestamp_l = current_tick_l;\n  flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);\n\n  /* parse packet */\n  flow->packet.iph = (struct ndpi_iphdr *) packet;\n  /* we are interested in ipv4 packet */\n\n  if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)\n    goto invalidate_ptr;\n\n  /* detect traffic for tcp or udp only */\n  flow->src = src, flow->dst = dst;\n\n  ndpi_connection_tracking(ndpi_str, flow);\n\n  /* build ndpi_selection packet bitmask */\n  ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;\n  if(flow->packet.iph != NULL)\n    ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;\n\n  if(flow->packet.tcp != NULL)\n    ndpi_selection_packet |=\n      (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);\n\n  if(flow->packet.udp != NULL)\n    ndpi_selection_packet |=\n      (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);\n\n  if(flow->packet.payload_packet_len != 0)\n    ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;\n\n  if(flow->packet.tcp_retransmission == 0)\n    ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  if(flow->packet.iphv6 != NULL)\n    ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\n  if((!flow->protocol_id_already_guessed) && (\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\t\t\t\t\t      flow->packet.iphv6 ||\n#endif\n\t\t\t\t\t      flow->packet.iph)) {\n    u_int16_t sport, dport;\n    u_int8_t protocol;\n    u_int8_t user_defined_proto;\n\n    flow->protocol_id_already_guessed = 1;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n    if(flow->packet.iphv6 != NULL) {\n      protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;\n    } else\n#endif\n      {\n\tprotocol = flow->packet.iph->protocol;\n      }\n\n    if(flow->packet.udp)\n      sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);\n    else if(flow->packet.tcp)\n      sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);\n    else\n      sport = dport = 0;\n\n    /* guess protocol */\n    flow->guessed_protocol_id =\n      (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);\n    flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);\n\n    if(ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {\n      ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, &ret);\n      flow->guessed_header_category = ret.category;\n    } else\n      flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;\n\n    if(flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {\n      /* This is a custom protocol and it has priority over everything else */\n      ret.master_protocol = NDPI_PROTOCOL_UNKNOWN,\n\tret.app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;\n      ndpi_fill_protocol_category(ndpi_str, flow, &ret);\n      goto invalidate_ptr;\n    }\n\n    if(user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n      if(flow->packet.iph) {\n\tif(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n\t  u_int8_t protocol_was_guessed;\n\n\t  /* ret.master_protocol = flow->guessed_protocol_id , ret.app_protocol = flow->guessed_host_protocol_id; /\\* ****** *\\/ */\n\t  ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);\n\t}\n\n\tndpi_fill_protocol_category(ndpi_str, flow, &ret);\n\tgoto invalidate_ptr;\n      }\n    } else {\n      /* guess host protocol */\n      if(flow->packet.iph) {\n\n\tflow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);\n\n\t/*\n\t  We could implement a shortcut here skipping dissectors for\n\t  protocols we have identified by other means such as with the IP\n\n\t  However we do NOT stop here and skip invoking the dissectors\n\t  because we want to dissect the flow (e.g. dissect the TLS)\n\t  and extract metadata.\n\t*/\n#if SKIP_INVOKING_THE_DISSECTORS\n\tif(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n\t  /*\n\t    We have identified a protocol using the IP address so\n\t    it is not worth to dissect the traffic as we already have\n\t    the solution\n\t  */\n\t  ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;\n\t}\n#endif\n      }\n    }\n  }\n\n  if(flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {\n    /* This is a custom protocol and it has priority over everything else */\n    ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;\n\n    ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);\n    ndpi_fill_protocol_category(ndpi_str, flow, &ret);\n    goto invalidate_ptr;\n  }\n\n  ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);\n\n  a = flow->packet.detected_protocol_stack[0];\n  if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)\n    a = NDPI_PROTOCOL_UNKNOWN;\n\n  if(a != NDPI_PROTOCOL_UNKNOWN) {\n    int i;\n\n    for (i = 0; i < sizeof(flow->host_server_name); i++) {\n      if(flow->host_server_name[i] != '\\0')\n\tflow->host_server_name[i] = tolower(flow->host_server_name[i]);\n      else {\n\tflow->host_server_name[i] = '\\0';\n\tbreak;\n      }\n    }\n  }\n\n ret_protocols:\n  if(flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {\n    ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];\n\n    if(ret.app_protocol == ret.master_protocol)\n      ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;\n  } else\n    ret.app_protocol = flow->detected_protocol_stack[0];\n\n  /* Don't overwrite the category if already set */\n  if((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))\n    ndpi_fill_protocol_category(ndpi_str, flow, &ret);\n  else\n    ret.category = flow->category;\n\n  if((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&\n     (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&\n     (flow->guessed_protocol_id == 0)) {\n    u_int8_t protocol_was_guessed;\n\n    /*\n      This is a TCP flow\n      - whose first packet is NOT a SYN\n      - no protocol has been detected\n\n      We don't see how future packets can match anything\n      hence we giveup here\n    */\n    ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);\n  }\n\n  if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&\n     (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {\n    ret.master_protocol = ret.app_protocol;\n    ret.app_protocol = flow->guessed_host_protocol_id;\n  }\n\n  if((!flow->risk_checked) && (ret.master_protocol != NDPI_PROTOCOL_UNKNOWN)) {\n    ndpi_default_ports_tree_node_t *found;\n    u_int16_t *default_ports, sport, dport;\n\n    if(flow->packet.udp)\n      found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_UDP,\n\t\t\t\t\t   sport = ntohs(flow->packet.udp->source),\n\t\t\t\t\t   dport = ntohs(flow->packet.udp->dest)),\n\tdefault_ports = ndpi_str->proto_defaults[ret.master_protocol].udp_default_ports;\n    else if(flow->packet.tcp)\n      found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_TCP,\n\t\t\t\t\t   sport = ntohs(flow->packet.tcp->source),\n\t\t\t\t\t   dport = ntohs(flow->packet.tcp->dest)),\n\tdefault_ports = ndpi_str->proto_defaults[ret.master_protocol].tcp_default_ports;\n    else\n      found = NULL, default_ports = NULL;\n\n    if(found\n       && (found->proto->protoId != NDPI_PROTOCOL_UNKNOWN)\n       && (found->proto->protoId != ret.master_protocol)) {\n      // printf(\"******** %u / %u\\n\", found->proto->protoId, ret.master_protocol);\n      NDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);\n    } else if(default_ports && (default_ports[0] != 0)) {\n      u_int8_t found = 0, i;\n\n      for(i=0; (i<MAX_DEFAULT_PORTS) && (default_ports[i] != 0); i++) {\n\tif((default_ports[i] == sport) || (default_ports[i] == dport)) {\n\t  found = 1;\n\t  break;\n\t}\n      } /* for */\n\n      if(!found) {\n\t// printf(\"******** Invalid default port\\n\");\n\tNDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);\n      }\n    }\n\n    flow->risk_checked = 1;\n  }\n\n  ndpi_reconcile_protocols(ndpi_str, flow, &ret);\n\n invalidate_ptr:\n  /*\n    Invalidate packet memory to avoid accessing the pointers below\n    when the packet is no longer accessible\n  */\n  flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;\n  ndpi_reset_packet_line_info(&flow->packet);\n\n  return(ret);\n}\n\n/* ********************************************************************************* */\n\nu_int32_t ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  val = 0;\n\n  // cancel if eof, ' ' or line end chars are reached\n  while (*str >= '0' && *str <= '9' && max_chars_to_read > 0) {\n    val *= 10;\n    val += *str - '0';\n    str++;\n    max_chars_to_read = max_chars_to_read - 1;\n    *bytes_read = *bytes_read + 1;\n  }\n\n  return(val);\n}\n\n/* ********************************************************************************* */\n\n#ifdef CODE_UNUSED\nu_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  val = 0;\n  if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {\n    return(ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));\n  } else {\n    /*use base 16 system */\n    str += 2;\n    max_chars_to_read -= 2;\n    *bytes_read = *bytes_read + 2;\n\n    while (max_chars_to_read > 0) {\n      if(*str >= '0' && *str <= '9') {\n\tval *= 16;\n\tval += *str - '0';\n      } else if(*str >= 'a' && *str <= 'f') {\n\tval *= 16;\n\tval += *str + 10 - 'a';\n      } else if(*str >= 'A' && *str <= 'F') {\n\tval *= 16;\n\tval += *str + 10 - 'A';\n      } else {\n\tbreak;\n      }\n      str++;\n      max_chars_to_read = max_chars_to_read - 1;\n      *bytes_read = *bytes_read + 1;\n    }\n  }\n\n  return(val);\n}\n\n#endif\n\n/* ********************************************************************************* */\n\nu_int64_t ndpi_bytestream_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int64_t val;\n  val = 0;\n  // cancel if eof, ' ' or line end chars are reached\n  while (max_chars_to_read > 0 && *str >= '0' && *str <= '9') {\n    val *= 10;\n    val += *str - '0';\n    str++;\n    max_chars_to_read = max_chars_to_read - 1;\n    *bytes_read = *bytes_read + 1;\n  }\n  return(val);\n}\n\n/* ********************************************************************************* */\n\nu_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read,\n                                                 u_int16_t *bytes_read) {\n  u_int64_t val;\n  val = 0;\n  if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {\n    return(ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));\n  } else {\n    /*use base 16 system */\n    str += 2;\n    max_chars_to_read -= 2;\n    *bytes_read = *bytes_read + 2;\n    while (max_chars_to_read > 0) {\n      if(*str >= '0' && *str <= '9') {\n\tval *= 16;\n\tval += *str - '0';\n      } else if(*str >= 'a' && *str <= 'f') {\n\tval *= 16;\n\tval += *str + 10 - 'a';\n      } else if(*str >= 'A' && *str <= 'F') {\n\tval *= 16;\n\tval += *str + 10 - 'A';\n      } else {\n\tbreak;\n      }\n      str++;\n      max_chars_to_read = max_chars_to_read - 1;\n      *bytes_read = *bytes_read + 1;\n    }\n  }\n  return(val);\n}\n\n/* ********************************************************************************* */\n\nu_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  u_int16_t read = 0;\n  u_int16_t oldread;\n  u_int32_t c;\n  /* ip address must be X.X.X.X with each X between 0 and 255 */\n  oldread = read;\n  c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = c << 24;\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 16);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 8);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read)\n    return(0);\n  val = val + c;\n\n  *bytes_read = *bytes_read + read;\n\n  return(htonl(val));\n}\n\n/* ********************************************************************************* */\n\n/* internal function for every detection to parse one packet and to increase the info buffer */\nvoid ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {\n  u_int32_t a;\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  if((packet->payload_packet_len < 3) || (packet->payload == NULL))\n    return;\n\n  if(packet->packet_lines_parsed_complete != 0)\n    return;\n\n  packet->packet_lines_parsed_complete = 1;\n  ndpi_reset_packet_line_info(packet);\n\n  packet->line[packet->parsed_lines].ptr = packet->payload;\n  packet->line[packet->parsed_lines].len = 0;\n\n  for (a = 0; (a < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {\n    if((a + 1) >= packet->payload_packet_len)\n      return; /* Return if only one byte remains (prevent invalid reads past end-of-buffer) */\n\n    if(get_u_int16_t(packet->payload, a) == ntohs(0x0d0a)) {\n      /* If end of line char sequence CR+NL \"\\r\\n\", process line */\n\n      if(((a + 3) <= packet->payload_packet_len)\n\t && (get_u_int16_t(packet->payload, a+2) == ntohs(0x0d0a))) {\n\t/* \\r\\n\\r\\n */\n\tint diff; /* No unsigned ! */\n\tu_int32_t a1 = a + 4;\n\n\tdiff = ndpi_min(packet->payload_packet_len-a1, sizeof(flow->initial_binary_bytes));\n\n\tif(diff > 0) {\n\t  memcpy(&flow->initial_binary_bytes, &packet->payload[a1], diff);\n\t  flow->initial_binary_bytes_len = diff;\n\t}\n      }\n\n      packet->line[packet->parsed_lines].len =\n\t(u_int16_t)(((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));\n\n      /* First line of a HTTP response parsing. Expected a \"HTTP/1.? ???\" */\n      if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&\n\t strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&\n\t packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] > '0' && /* response code between 000 and 699 */\n\t packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {\n\tpacket->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];\n\tpacket->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");\n\tpacket->http_num_headers++;\n\n\t/* Set server HTTP response code */\n\tif(packet->payload_packet_len >= 12) {\n\t  char buf[4];\n\n\t  /* Set server HTTP response code */\n\t  strncpy(buf, (char *) &packet->payload[9], 3);\n\t  buf[3] = '\\0';\n\n\t  flow->http.response_status_code = atoi(buf);\n\t  /* https://en.wikipedia.org/wiki/List_of_HTTP_status_codes */\n\t  if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))\n\t    flow->http.response_status_code = 0; /* Out of range */\n\t}\n      }\n\n      /* \"Server:\" header line in HTTP response */\n      if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,\n\t\t     \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {\n\t// some stupid clients omit a space and place the servername directly after the colon\n\tif(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {\n\t  packet->server_line.ptr =\n\t    &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];\n\t  packet->server_line.len =\n\t    packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);\n\t} else {\n\t  packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];\n\t  packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");\n\t}\n\tpacket->http_num_headers++;\n      }\n      /* \"Host:\" header line in HTTP request */\n      if(packet->line[packet->parsed_lines].len > 6 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {\n\t// some stupid clients omit a space and place the hostname directly after the colon\n\tif(packet->line[packet->parsed_lines].ptr[5] == ' ') {\n\t  packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];\n\t  packet->host_line.len = packet->line[packet->parsed_lines].len - 6;\n\t} else {\n\t  packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];\n\t  packet->host_line.len = packet->line[packet->parsed_lines].len - 5;\n\t}\n\tpacket->http_num_headers++;\n      }\n      /* \"X-Forwarded-For:\" header line in HTTP request. Commonly used for HTTP proxies. */\n      if(packet->line[packet->parsed_lines].len > 17 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {\n\t// some stupid clients omit a space and place the hostname directly after the colon\n\tif(packet->line[packet->parsed_lines].ptr[16] == ' ') {\n\t  packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];\n\t  packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;\n\t} else {\n\t  packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];\n\t  packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;\n\t}\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Type:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 14 &&\n\t (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {\n\tpacket->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];\n\tpacket->content_line.len = packet->line[packet->parsed_lines].len - 14;\n\n\twhile ((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))\n\t  packet->content_line.len--, packet->content_line.ptr++;\n\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Type:\" header line in HTTP AGAIN. Probably a bogus response without space after \":\" */\n      if((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&\n\t (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {\n\tpacket->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];\n\tpacket->content_line.len = packet->line[packet->parsed_lines].len - 13;\n\tpacket->http_num_headers++;\n      }\n\n      if(packet->content_line.len > 0) {\n\t/* application/json; charset=utf-8 */\n\tchar separator[] = {';', '\\r', '\\0'};\n\tint i;\n\n\tfor (i = 0; separator[i] != '\\0'; i++) {\n\t  char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);\n\n\t  if(c != NULL)\n\t    packet->content_line.len = c - (char *) packet->content_line.ptr;\n\t}\n      }\n\n      /* \"Accept:\" header line in HTTP request. */\n      if(packet->line[packet->parsed_lines].len > 8 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {\n\tpacket->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];\n\tpacket->accept_line.len = packet->line[packet->parsed_lines].len - 8;\n\tpacket->http_num_headers++;\n      }\n      /* \"Referer:\" header line in HTTP request. */\n      if(packet->line[packet->parsed_lines].len > 9 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {\n\tpacket->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];\n\tpacket->referer_line.len = packet->line[packet->parsed_lines].len - 9;\n\tpacket->http_num_headers++;\n      }\n      /* \"User-Agent:\" header line in HTTP request. */\n      if(packet->line[packet->parsed_lines].len > 12 &&\n\t (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {\n\tpacket->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];\n\tpacket->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Encoding:\" header line in HTTP response (and request?). */\n      if(packet->line[packet->parsed_lines].len > 18 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {\n\tpacket->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];\n\tpacket->http_encoding.len = packet->line[packet->parsed_lines].len - 18;\n\tpacket->http_num_headers++;\n      }\n      /* \"Transfer-Encoding:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 19 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {\n\tpacket->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];\n\tpacket->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Length:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 16 &&\n\t ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {\n\tpacket->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];\n\tpacket->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Disposition\"*/\n      if(packet->line[packet->parsed_lines].len > 21 &&\n\t ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Disposition: \", 21) == 0))) {\n\tpacket->content_disposition_line.ptr = &packet->line[packet->parsed_lines].ptr[21];\n\tpacket->content_disposition_line.len = packet->line[packet->parsed_lines].len - 21;\n\tpacket->http_num_headers++;\n      }\n      /* \"Cookie:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 8 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {\n\tpacket->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];\n\tpacket->http_cookie.len = packet->line[packet->parsed_lines].len - 8;\n\tpacket->http_num_headers++;\n      }\n      /* \"Origin:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 8 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {\n\tpacket->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];\n\tpacket->http_origin.len = packet->line[packet->parsed_lines].len - 8;\n\tpacket->http_num_headers++;\n      }\n      /* \"X-Session-Type:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 16 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {\n\tpacket->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];\n\tpacket->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;\n\tpacket->http_num_headers++;\n      }\n      /* Identification and counting of other HTTP headers.\n       * We consider the most common headers, but there are many others,\n       * which can be seen at references below:\n       * - https://tools.ietf.org/html/rfc7230\n       * - https://en.wikipedia.org/wiki/List_of_HTTP_header_fields\n       */\n      if((packet->line[packet->parsed_lines].len > 6 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 8 &&\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||\n\t (packet->line[packet->parsed_lines].len > 9 &&\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||\n\t (packet->line[packet->parsed_lines].len > 12 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 15 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 17 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 27 &&\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,\n\t\t      \"Upgrade-Insecure-Requests: \", 27) == 0)) {\n\t/* Just count. In the future, if needed, this if can be splited to parse these headers */\n\tpacket->http_num_headers++;\n      }\n\n      if(packet->line[packet->parsed_lines].len == 0) {\n\tpacket->empty_line_position = a;\n\tpacket->empty_line_position_set = 1;\n      }\n\n      if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))\n\treturn;\n\n      packet->parsed_lines++;\n      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];\n      packet->line[packet->parsed_lines].len = 0;\n\n      a++; /* next char in the payload */\n    }\n  }\n\n  if(packet->parsed_lines >= 1) {\n    packet->line[packet->parsed_lines].len =\n      (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) -\n\t\t  ((unsigned long) packet->line[packet->parsed_lines].ptr));\n    packet->parsed_lines++;\n  }\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int32_t a;\n  u_int16_t end = packet->payload_packet_len;\n\n  if(packet->packet_lines_parsed_complete != 0)\n    return;\n\n  packet->packet_lines_parsed_complete = 1;\n  packet->parsed_lines = 0;\n\n  if(packet->payload_packet_len == 0)\n    return;\n\n  packet->line[packet->parsed_lines].ptr = packet->payload;\n  packet->line[packet->parsed_lines].len = 0;\n\n  for (a = 0; a < end; a++) {\n    if(packet->payload[a] == 0x0a) {\n      packet->line[packet->parsed_lines].len = (u_int16_t)(\n\t\t\t\t\t\t\t   ((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));\n\n      if(a > 0 && packet->payload[a - 1] == 0x0d)\n\tpacket->line[packet->parsed_lines].len--;\n\n      if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))\n\tbreak;\n\n      packet->parsed_lines++;\n      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];\n      packet->line[packet->parsed_lines].len = 0;\n\n      if((a + 1) >= packet->payload_packet_len)\n\tbreak;\n\n      //a++;\n    }\n  }\n}\n\n/* ********************************************************************************* */\n\nu_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                       u_int16_t counter) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");\n\n  if(packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||\n\t\t\t\t\t      (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||\n\t\t\t\t\t      (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||\n\t\t\t\t\t      packet->payload[counter] == '-' || packet->payload[counter] == '_')) {\n    NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");\n    counter++;\n    while (packet->payload_packet_len > counter &&\n\t   ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||\n\t    (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||\n\t    (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||\n\t    packet->payload[counter] == '-' || packet->payload[counter] == '_' ||\n\t    packet->payload[counter] == '.')) {\n      NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");\n      counter++;\n      if(packet->payload_packet_len > counter && packet->payload[counter] == '@') {\n\tNDPI_LOG_DBG2(ndpi_str, \"@\\n\");\n\tcounter++;\n\twhile (packet->payload_packet_len > counter &&\n\t       ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||\n\t\t(packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||\n\t\t(packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||\n\t\tpacket->payload[counter] == '-' || packet->payload[counter] == '_')) {\n\t  NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");\n\t  counter++;\n\t  if(packet->payload_packet_len > counter && packet->payload[counter] == '.') {\n\t    NDPI_LOG_DBG2(ndpi_str, \".\\n\");\n\t    counter++;\n\t    if(packet->payload_packet_len > counter + 1 &&\n\t       ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&\n\t\t(packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {\n\t      NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");\n\t      counter += 2;\n\t      if(packet->payload_packet_len > counter &&\n\t\t (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {\n\t\tNDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");\n\t\treturn(counter);\n\t      } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&\n\t\t\tpacket->payload[counter] <= 'z') {\n\t\tNDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");\n\t\tcounter++;\n\t\tif(packet->payload_packet_len > counter &&\n\t\t   (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {\n\t\t  NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");\n\t\t  return(counter);\n\t\t} else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&\n\t\t\t  packet->payload[counter] <= 'z') {\n\t\t  counter++;\n\t\t  if(packet->payload_packet_len > counter &&\n\t\t     (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {\n\t\t    NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");\n\t\t    return(counter);\n\t\t  } else {\n\t\t    return(0);\n\t\t  }\n\t\t} else {\n\t\t  return(0);\n\t\t}\n\t      } else {\n\t\treturn(0);\n\t      }\n\t    } else {\n\t      return(0);\n\t    }\n\t  }\n\t}\n\treturn(0);\n      }\n    }\n  }\n  return(0);\n}\n\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n/* ********************************************************************************* */\n\nvoid ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct *ndpi_str, const char **file,\n                                           const char **func, u_int32_t *line) {\n  *file = \"\";\n  *func = \"\";\n\n  if(ndpi_str->ndpi_debug_print_file != NULL)\n    *file = ndpi_str->ndpi_debug_print_file;\n\n  if(ndpi_str->ndpi_debug_print_function != NULL)\n    *func = ndpi_str->ndpi_debug_print_function;\n\n  *line = ndpi_str->ndpi_debug_print_line;\n}\n#endif\n\n/* ********************************************************************************* */\n\nu_int8_t ndpi_detection_get_l4(const u_int8_t *l3, u_int16_t l3_len, const u_int8_t **l4_return,\n                               u_int16_t *l4_len_return, u_int8_t *l4_protocol_return, u_int32_t flags) {\n  return(ndpi_detection_get_l4_internal(NULL, l3, l3_len, l4_return, l4_len_return, l4_protocol_return, flags));\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {\n  struct ndpi_id_struct *src = flow->src, *dst = flow->dst;\n\n  ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);\n\n  if(src != NULL) {\n    NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);\n\n    if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)\n      NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);\n  }\n\n  if(dst != NULL) {\n    NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);\n\n    if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)\n      NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);\n  }\n}\n\n/* ********************************************************************************* */\n\nu_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {\n  return(flow->detected_protocol_stack[1]);\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_int_change_flow_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                   u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {\n  if(!flow)\n    return;\n\n  flow->detected_protocol_stack[0] = upper_detected_protocol,\n    flow->detected_protocol_stack[1] = lower_detected_protocol;\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_int_change_packet_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                     u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  /* NOTE: everything below is identically to change_flow_protocol\n   *        except flow->packet If you want to change something here,\n   *        don't! Change it for the flow function and apply it here\n   *        as well */\n\n  if(!packet)\n    return;\n\n  packet->detected_protocol_stack[0] = upper_detected_protocol,\n    packet->detected_protocol_stack[1] = lower_detected_protocol;\n}\n\n/* ********************************************************************************* */\n\n/* generic function for changing the protocol\n *\n * what it does is:\n * 1.update the flow protocol stack with the new protocol\n * 2.update the packet protocol stack with the new protocol\n */\nvoid ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                              u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {\n  if((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))\n    upper_detected_protocol = lower_detected_protocol;\n\n  if(upper_detected_protocol == lower_detected_protocol)\n    lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;\n\n  if((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {\n    if((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n       (upper_detected_protocol != flow->guessed_host_protocol_id)) {\n      if(ndpi_str->proto_defaults[upper_detected_protocol].can_have_a_subprotocol) {\n\tlower_detected_protocol = upper_detected_protocol;\n\tupper_detected_protocol = flow->guessed_host_protocol_id;\n      }\n    }\n  }\n\n  ndpi_int_change_flow_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);\n  ndpi_int_change_packet_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                              ndpi_protocol_category_t protocol_category) {\n  flow->category = protocol_category;\n}\n\n/* ********************************************************************************* */\n\n/* turns a packet back to unknown */\nvoid ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet) {\n  int a;\n\n  for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)\n    packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_int_reset_protocol(struct ndpi_flow_struct *flow) {\n  if(flow) {\n    int a;\n\n    for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)\n      flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;\n  }\n}\n\n/* ********************************************************************************* */\n\nvoid NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t *ip) {\n  memset(ip, 0, sizeof(ndpi_ip_addr_t));\n}\n\n/* ********************************************************************************* */\n\n#ifdef CODE_UNUSED\n/* NTOP */\nint NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t *ip) {\n  return(memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);\n}\n#endif\n\n/* ********************************************************************************* */\n\n/* check if the source ip address in packet and ip are equal */\n/* NTOP */\nint ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\n  /* IPv6 */\n  if(packet->iphv6 != NULL) {\n    if(packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&\n       packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&\n       packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&\n       packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])\n      return(1);\n    //else\n    return(0);\n  }\n#endif\n\n  /* IPv4 */\n  if(packet->iph->saddr == ip->ipv4)\n    return(1);\n  return(0);\n}\n\n/* ********************************************************************************* */\n\n/* check if the destination ip address in packet and ip are equal */\nint ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\n  /* IPv6 */\n  if(packet->iphv6 != NULL) {\n    if(packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&\n       packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&\n       packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&\n       packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])\n      return(1);\n    //else\n    return(0);\n  }\n#endif\n\n  /* IPv4 */\n  if(packet->iph->saddr == ip->ipv4)\n    return(1);\n\n  return(0);\n}\n\n/* ********************************************************************************* */\n\n/* get the source ip address from packet and put it into ip */\n/* NTOP */\nvoid ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {\n  NDPI_PROTOCOL_IP_clear(ip);\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\n  /* IPv6 */\n  if(packet->iphv6 != NULL) {\n    ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];\n    ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];\n    ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];\n    ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];\n\n  } else\n#endif\n\n    /* IPv4 */\n    ip->ipv4 = packet->iph->saddr;\n}\n\n/* ********************************************************************************* */\n\n/* get the destination ip address from packet and put it into ip */\n/* NTOP */\nvoid ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {\n  NDPI_PROTOCOL_IP_clear(ip);\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\n  if(packet->iphv6 != NULL) {\n    ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];\n    ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];\n    ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];\n    ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];\n\n  } else\n\n#endif\n\n    ip->ipv4 = packet->iph->daddr;\n}\n\n/* ********************************************************************************* */\n\nu_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip) {\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  return(ip->ipv6.u6_addr.u6_addr32[1] != 0 || ip->ipv6.u6_addr.u6_addr32[2] != 0 ||\n\t  ip->ipv6.u6_addr.u6_addr32[3] != 0);\n#else\n  return(0);\n#endif\n}\n\n/* ********************************************************************************* */\n\nchar *ndpi_get_ip_string(const ndpi_ip_addr_t *ip, char *buf, u_int buf_len) {\n  const u_int8_t *a = (const u_int8_t *) &ip->ipv4;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  if(ndpi_is_ipv6(ip)) {\n    if(inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)\n      buf[0] = '\\0';\n\n    return(buf);\n  }\n#endif\n\n  snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);\n\n  return(buf);\n}\n\n/* ****************************************************** */\n\n/* Returns -1 on failutre, otherwise fills parsed_ip and returns the IP version */\nint ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip) {\n  int rv = -1;\n  memset(parsed_ip, 0, sizeof(*parsed_ip));\n\n  if(strchr(ip_str, '.')) {\n    if(inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)\n      rv = 4;\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  } else {\n    if(inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)\n      rv = 6;\n#endif\n  }\n\n  return(rv);\n}\n\n/* ****************************************************** */\n\nu_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t *str,\n\t\t\t\t\t  u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);\n  return(ntohs(val));\n}\n\n/* ****************************************************** */\n\nu_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p) {\n  return(((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);\n}\n\n/* ****************************************************** */\n\nu_int16_t ndpi_get_lower_proto(ndpi_protocol proto) {\n  return((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);\n}\n\n/* ****************************************************** */\n\nndpi_protocol ndpi_guess_undetected_protocol(struct ndpi_detection_module_struct *ndpi_str,\n                                             struct ndpi_flow_struct *flow, u_int8_t proto,\n                                             u_int32_t shost /* host byte order */, u_int16_t sport,\n                                             u_int32_t dhost /* host byte order */, u_int16_t dport) {\n  u_int32_t rc;\n  struct in_addr addr;\n  ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};\n  u_int8_t user_defined_proto;\n\n  if((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {\n    rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);\n\n    if(rc != NDPI_PROTOCOL_UNKNOWN) {\n      if(flow && (proto == IPPROTO_UDP) &&\n\t NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))\n\t;\n      else {\n\tret.app_protocol = rc,\n\t  ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);\n\n\tif(ret.app_protocol == ret.master_protocol)\n\t  ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;\n\n\tret.category = ndpi_get_proto_category(ndpi_str, ret);\n\treturn(ret);\n      }\n    }\n\n    rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);\n    if(rc != NDPI_PROTOCOL_UNKNOWN) {\n      if(flow && (proto == IPPROTO_UDP) &&\n\t NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))\n\t;\n      else {\n\tret.app_protocol = rc;\n\n\tif(rc == NDPI_PROTOCOL_TLS)\n\t  goto check_guessed_skype;\n\telse {\n\t  ret.category = ndpi_get_proto_category(ndpi_str, ret);\n\t  return(ret);\n\t}\n      }\n    }\n\n  check_guessed_skype:\n    addr.s_addr = htonl(shost);\n    if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {\n      ret.app_protocol = NDPI_PROTOCOL_SKYPE;\n    } else {\n      addr.s_addr = htonl(dhost);\n      if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)\n\tret.app_protocol = NDPI_PROTOCOL_SKYPE;\n    }\n  } else\n    ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);\n\n  ret.category = ndpi_get_proto_category(ndpi_str, ret);\n  return(ret);\n}\n\n/* ****************************************************** */\n\nchar *ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str,\n\t\t       ndpi_protocol proto, char *buf, u_int buf_len) {\n  if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {\n    if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)\n      snprintf(buf, buf_len, \"%u.%u\", proto.master_protocol, proto.app_protocol);\n    else\n      snprintf(buf, buf_len, \"%u\", proto.master_protocol);\n  } else\n    snprintf(buf, buf_len, \"%u\", proto.app_protocol);\n\n  return(buf);\n}\n\n/* ****************************************************** */\n\nchar *ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t ndpi_protocol proto, char *buf, u_int buf_len) {\n  if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {\n    if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)\n      snprintf(buf, buf_len, \"%s.%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol),\n\t       ndpi_get_proto_name(ndpi_str, proto.app_protocol));\n    else\n      snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol));\n  } else\n    snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.app_protocol));\n\n  return(buf);\n}\n\n/* ****************************************************** */\n\nint ndpi_is_custom_category(ndpi_protocol_category_t category) {\n  switch (category) {\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:\n    return(1);\n    break;\n\n  default:\n    return(0);\n    break;\n  }\n}\n\n/* ****************************************************** */\n\nvoid ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t    ndpi_protocol_category_t category,\n                            char *name) {\n  if(!name)\n    return;\n\n  switch (category) {\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:\n    snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:\n    snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:\n    snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:\n    snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:\n    snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  default:\n    break;\n  }\n}\n\n/* ****************************************************** */\n\nconst char *ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t   ndpi_protocol_category_t category) {\n  if((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {\n    static char b[24];\n\n    if(!ndpi_str)\n      snprintf(b, sizeof(b), \"NULL nDPI\");\n    else\n      snprintf(b, sizeof(b), \"Invalid category %d\", (int) category);\n    return(b);\n  }\n\n  if((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {\n    switch (category) {\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:\n      return(ndpi_str->custom_category_labels[0]);\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:\n      return(ndpi_str->custom_category_labels[1]);\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:\n      return(ndpi_str->custom_category_labels[2]);\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:\n      return(ndpi_str->custom_category_labels[3]);\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:\n      return(ndpi_str->custom_category_labels[4]);\n    case NDPI_PROTOCOL_NUM_CATEGORIES:\n      return(\"Code should not use this internal constant\");\n    default:\n      return(\"Unspecified\");\n    }\n  } else\n    return(categories[category]);\n}\n\n/* ****************************************************** */\n\nndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\t\t ndpi_protocol proto) {\n  if(proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)\n    return(proto.category);\n\n  /* simple rule: sub protocol first, master after */\n  else if((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN) ||\n\t  (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {\n    if(proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))\n      return(ndpi_str->proto_defaults[proto.app_protocol].protoCategory);\n  } else if(proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))\n    return(ndpi_str->proto_defaults[proto.master_protocol].protoCategory);\n\n  return(NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);\n}\n\n/* ****************************************************** */\n\nchar *ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t  u_int16_t proto_id) {\n  if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||\n     (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||\n     (ndpi_str->proto_defaults[proto_id].protoName == NULL))\n    proto_id = NDPI_PROTOCOL_UNKNOWN;\n\n  return(ndpi_str->proto_defaults[proto_id].protoName);\n}\n\n/* ****************************************************** */\n\nndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\t   u_int16_t proto_id) {\n  if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||\n     (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||\n     (ndpi_str->proto_defaults[proto_id].protoName == NULL))\n    proto_id = NDPI_PROTOCOL_UNKNOWN;\n\n  return(ndpi_str->proto_defaults[proto_id].protoBreed);\n}\n\n/* ****************************************************** */\n\nchar *ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\tndpi_protocol_breed_t breed_id) {\n  switch (breed_id) {\n  case NDPI_PROTOCOL_SAFE:\n    return(\"Safe\");\n    break;\n  case NDPI_PROTOCOL_ACCEPTABLE:\n    return(\"Acceptable\");\n    break;\n  case NDPI_PROTOCOL_FUN:\n    return(\"Fun\");\n    break;\n  case NDPI_PROTOCOL_UNSAFE:\n    return(\"Unsafe\");\n    break;\n  case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:\n    return(\"Potentially Dangerous\");\n    break;\n  case NDPI_PROTOCOL_DANGEROUS:\n    return(\"Dangerous\");\n    break;\n  case NDPI_PROTOCOL_UNRATED:\n  default:\n    return(\"Unrated\");\n    break;\n  }\n}\n\n/* ****************************************************** */\n\nint ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto) {\n  int i;\n\n  for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)\n    if(strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)\n      return(i);\n\n  return(-1);\n}\n\n/* ****************************************************** */\n\nint ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat) {\n  int i;\n\n  for (i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {\n    const char *name = ndpi_category_get_name(ndpi_str, i);\n\n    if(strcasecmp(cat, name) == 0)\n      return(i);\n  }\n\n  return(-1);\n}\n\n/* ****************************************************** */\n\nvoid ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  int i;\n\n  for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)\n    printf(\"%3d %-22s %-8s %-12s %s\\n\", i, ndpi_str->proto_defaults[i].protoName,\n\t   ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),\n\t   ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),\n\t   ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory));\n}\n\n/* ****************************************************** */\n\n/*\n * Find the first occurrence of find in s, where the search is limited to the\n * first slen characters of s.\n */\nchar *ndpi_strnstr(const char *s, const char *find, size_t slen) {\n  char c;\n  size_t len;\n\n  if((c = *find++) != '\\0') {\n    len = strnlen(find, slen);\n    do {\n      char sc;\n\n      do {\n\tif(slen-- < 1 || (sc = *s++) == '\\0')\n\t  return(NULL);\n      } while (sc != c);\n      if(len > slen)\n\treturn(NULL);\n    } while (strncmp(s, find, len) != 0);\n    s--;\n  }\n\n  return((char *) s);\n}\n\n/* ****************************************************** */\n\n/*\n * Same as ndpi_strnstr but case-insensitive\n */\nchar *ndpi_strncasestr(const char *s, const char *find, size_t slen) {\n  char c;\n  size_t len;\n\n  if((c = *find++) != '\\0') {\n    len = strlen(find);\n    do {\n      char sc;\n\n      do {\n\tif(slen-- < 1 || (sc = *s++) == '\\0')\n\t  return(NULL);\n      } while (sc != c);\n\n      if(len > slen)\n\treturn(NULL);\n    } while (strncasecmp(s, find, len) != 0);\n\n    s--;\n  }\n  return((char *) s);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_prefix(const u_int8_t *payload,\n\t\t      size_t payload_len, const char *str, size_t str_len) {\n  int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;\n\n  return(rc);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *string_to_match,\n                                  u_int string_to_match_len, ndpi_protocol_match_result *ret_match,\n                                  u_int8_t is_host_match) {\n  AC_TEXT_t ac_input_text;\n  ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;\n  AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};\n  int rc;\n\n  if((automa->ac_automa == NULL) || (string_to_match_len == 0))\n    return(NDPI_PROTOCOL_UNKNOWN);\n\n  if(!automa->ac_automa_finalized) {\n    printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);\n    return(0); /* No matches */\n  }\n\n  ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;\n  rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  /* We need to take into account also rc == 0 that is used for partial matches */\n  ret_match->protocol_id = match.number, ret_match->protocol_category = match.category,\n    ret_match->protocol_breed = match.breed;\n\n  return(rc ? match.number : 0);\n}\n\n/* **************************************** */\n\nstatic u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto) {\n  /* Sometimes certificates are more generic than previously identified protocols */\n\n  if((previous_proto == NDPI_PROTOCOL_UNKNOWN) || (previous_proto == new_proto))\n    return(0);\n\n  switch (previous_proto) {\n  case NDPI_PROTOCOL_WHATSAPP_CALL:\n  case NDPI_PROTOCOL_WHATSAPP_FILES:\n    if(new_proto == NDPI_PROTOCOL_WHATSAPP)\n      return(1);\n  }\n\n  return(0);\n}\n\n/* ****************************************************** */\n\nstatic u_int16_t ndpi_automa_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str,\n                                                      struct ndpi_flow_struct *flow, char *string_to_match,\n                                                      u_int string_to_match_len, u_int16_t master_protocol_id,\n                                                      ndpi_protocol_match_result *ret_match, u_int8_t is_host_match) {\n  int matching_protocol_id;\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  matching_protocol_id =\n    ndpi_match_string_subprotocol(ndpi_str, string_to_match, string_to_match_len, ret_match, is_host_match);\n\n#ifdef DEBUG\n  {\n    char m[256];\n    int len = ndpi_min(sizeof(m), string_to_match_len);\n\n    strncpy(m, string_to_match, len);\n    m[len] = '\\0';\n\n    NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\", m,\n\t\t  ndpi_str->proto_defaults[matching_protocol_id].protoName);\n  }\n#endif\n\n  if((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n     (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {\n    /* Move the protocol on slot 0 down one position */\n    packet->detected_protocol_stack[1] = master_protocol_id,\n      packet->detected_protocol_stack[0] = matching_protocol_id;\n\n    flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],\n      flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];\n\n    if(flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)\n      flow->category = ret_match->protocol_category;\n\n    return(packet->detected_protocol_stack[0]);\n  }\n\n#ifdef DEBUG\n  string_to_match[string_to_match_len] = '\\0';\n  NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);\n#endif\n\n  ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN, ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,\n    ret_match->protocol_breed = NDPI_PROTOCOL_UNRATED;\n\n  return(NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ****************************************************** */\n\nu_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                      char *string_to_match, u_int string_to_match_len,\n                                      ndpi_protocol_match_result *ret_match, u_int16_t master_protocol_id) {\n  u_int16_t rc = ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,\n\t\t\t\t\t\t      master_protocol_id, ret_match, 1);\n  ndpi_protocol_category_t id = ret_match->protocol_category;\n\n  if(ndpi_get_custom_category_match(ndpi_str, string_to_match, string_to_match_len, &id) != -1) {\n    /* if(id != -1) */ {\n      flow->category = ret_match->protocol_category = id;\n      rc = master_protocol_id;\n    }\n  }\n\n  return(rc);\n}\n\n/* **************************************** */\n\nint ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow,\n                                 u_int16_t master_protocol, char *name, u_int name_len) {\n  ndpi_protocol_match_result ret_match;\n  u_int16_t subproto, what_len;\n  char *what;\n\n  if((name_len > 2) && (name[0] == '*') && (name[1] == '.'))\n    what = &name[1], what_len = name_len - 1;\n  else\n    what = name, what_len = name_len;\n\n  subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len, &ret_match, master_protocol);\n\n  if(subproto != NDPI_PROTOCOL_UNKNOWN) {\n    ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);\n    ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);\n    return(1);\n  } else\n    return(0);\n}\n\n/* ****************************************************** */\n\nu_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\t struct ndpi_flow_struct *flow,\n                                         char *string_to_match, u_int string_to_match_len,\n                                         ndpi_protocol_match_result *ret_match,\n\t\t\t\t\t u_int16_t master_protocol_id) {\n  return(ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,\n\t\t\t\t\t       master_protocol_id, ret_match, 0));\n}\n\n/* ****************************************************** */\n\nint ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str,\n\t\t      ndpi_automa *automa, char *bigram_to_match) {\n  AC_TEXT_t ac_input_text;\n  AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};\n  int rc;\n\n  if((automa->ac_automa == NULL) || (bigram_to_match == NULL))\n    return(-1);\n\n  if(!automa->ac_automa_finalized) {\n    printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);\n    return(0); /* No matches */\n  }\n\n  ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;\n  rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  return(rc ? match.number : 0);\n}\n\n/* ****************************************************** */\n\nvoid ndpi_free_flow(struct ndpi_flow_struct *flow) {\n  if(flow) {\n    if(flow->http.url)\n      ndpi_free(flow->http.url);\n    if(flow->http.content_type)\n      ndpi_free(flow->http.content_type);\n    if(flow->http.user_agent)\n      ndpi_free(flow->http.user_agent);\n    if(flow->kerberos_buf.pktbuf)\n      ndpi_free(flow->kerberos_buf.pktbuf);\n\n    if(flow_is_proto(flow, NDPI_PROTOCOL_TLS)) {\n      if(flow->protos.stun_ssl.ssl.server_names)\n\tndpi_free(flow->protos.stun_ssl.ssl.server_names);\n\n      if(flow->protos.stun_ssl.ssl.alpn)\n\tndpi_free(flow->protos.stun_ssl.ssl.alpn);\n\n      if(flow->protos.stun_ssl.ssl.tls_supported_versions)\n\tndpi_free(flow->protos.stun_ssl.ssl.tls_supported_versions);\n\n      if(flow->protos.stun_ssl.ssl.issuerDN)\n\tndpi_free(flow->protos.stun_ssl.ssl.issuerDN);\n\n      if(flow->protos.stun_ssl.ssl.subjectDN)\n\tndpi_free(flow->protos.stun_ssl.ssl.subjectDN);\n\n      if(flow->l4.tcp.tls.srv_cert_fingerprint_ctx)\n\tndpi_free(flow->l4.tcp.tls.srv_cert_fingerprint_ctx);\n\n      if(flow->protos.stun_ssl.ssl.encrypted_sni.esni)\n\tndpi_free(flow->protos.stun_ssl.ssl.encrypted_sni.esni);\n    }\n\n    if(flow->l4_proto == IPPROTO_TCP) {\n      if(flow->l4.tcp.tls.message.buffer)\n\tndpi_free(flow->l4.tcp.tls.message.buffer);\n    }\n\n    ndpi_free(flow);\n  }\n}\n\n/* ****************************************************** */\n\nchar *ndpi_revision() {\n  return(NDPI_GIT_RELEASE);\n}\n\n/* ****************************************************** */\n\n#ifdef WIN32\n\n/* https://stackoverflow.com/questions/10905892/equivalent-of-gettimeday-for-windows */\nint gettimeofday(struct timeval *tp, struct timezone *tzp) {\n  // Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's\n  // This magic number is the number of 100 nanosecond intervals since January 1, 1601 (UTC)\n  // until 00:00:00 January 1, 1970\n  static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);\n\n  SYSTEMTIME system_time;\n  FILETIME file_time;\n  uint64_t time;\n\n  GetSystemTime(&system_time);\n  SystemTimeToFileTime(&system_time, &file_time);\n  time = ((uint64_t) file_time.dwLowDateTime);\n  time += ((uint64_t) file_time.dwHighDateTime) << 32;\n\n  tp->tv_sec = (long) ((time - EPOCH) / 10000000L);\n  tp->tv_usec = (long) (system_time.wMilliseconds * 1000);\n  return(0);\n}\n#endif\n\nint NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b) {\n  int i;\n\n  for (i = 0; i < NDPI_NUM_FDS_BITS; i++) {\n    if(a.fds_bits[i] & b.fds_bits[i])\n      return(1);\n  }\n\n  return(0);\n}\n\n#ifdef CODE_UNUSED\nint NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a) {\n  int i;\n\n  for (i = 0; i < NDPI_NUM_FDS_BITS; i++)\n    if(a.fds_bits[i] != 0)\n      return(0);\n\n  return(1);\n}\n\nvoid NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a) {\n  int i;\n\n  for (i = 0; i < NDPI_NUM_FDS_BITS; i++)\n    printf(\"[%d=%u]\", i, a.fds_bits[i]);\n\n  printf(\"\\n\");\n}\n#endif\n\nu_int16_t ndpi_get_api_version() {\n  return(NDPI_API_VERSION);\n}\n\nndpi_proto_defaults_t *ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str) {\n  return(ndpi_str->proto_defaults);\n}\n\nu_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  return(ndpi_str->ndpi_num_supported_protocols);\n}\n\nu_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  return(ndpi_str->ndpi_num_custom_protocols);\n}\n\nu_int ndpi_get_ndpi_detection_module_size() {\n  return(sizeof(struct ndpi_detection_module_struct));\n}\n\nvoid ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l){\n  ndpi_str->ndpi_log_level = l;\n}\n\n/* ******************************************************************** */\n\n/* LRU cache */\nstruct ndpi_lru_cache *ndpi_lru_cache_init(u_int32_t num_entries) {\n  struct ndpi_lru_cache *c = (struct ndpi_lru_cache *) ndpi_malloc(sizeof(struct ndpi_lru_cache));\n\n  if(!c)\n    return(NULL);\n\n  c->entries = (struct ndpi_lru_cache_entry *) ndpi_calloc(num_entries, sizeof(struct ndpi_lru_cache_entry));\n\n  if(!c->entries) {\n    ndpi_free(c);\n    return(NULL);\n  } else\n    c->num_entries = num_entries;\n\n  return(c);\n}\n\nvoid ndpi_lru_free_cache(struct ndpi_lru_cache *c) {\n  ndpi_free(c->entries);\n  ndpi_free(c);\n}\n\nu_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key,\n\t\t\t     u_int16_t *value, u_int8_t clean_key_when_found) {\n  u_int32_t slot = key % c->num_entries;\n\n  if(c->entries[slot].is_full) {\n    *value = c->entries[slot].value;\n    if(clean_key_when_found)\n      c->entries[slot].is_full = 0;\n    return(1);\n  } else\n    return(0);\n}\n\nvoid ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value) {\n  u_int32_t slot = key % c->num_entries;\n\n  c->entries[slot].is_full = 1, c->entries[slot].key = key, c->entries[slot].value = value;\n}\n\n/* ******************************************************************** */\n\n/*\n  This function tells if it's possible to further dissect a given flow\n  0 - All possible dissection has been completed\n  1 - Additional dissection is possible\n*/\nu_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\tstruct ndpi_flow_struct *flow) {\n  u_int16_t proto =\n    flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];\n\n#if 0\n  printf(\"[DEBUG] %s(%u.%u): %u\\n\", __FUNCTION__,\n\t flow->detected_protocol_stack[0],\n\t flow->detected_protocol_stack[1],\n\t proto);\n#endif\n\n  switch (proto) {\n  case NDPI_PROTOCOL_TLS:\n    if(!flow->l4.tcp.tls.certificate_processed)\n      return(1); /* TODO: add check for TLS 1.3 */\n    break;\n\n  case NDPI_PROTOCOL_HTTP:\n    if((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))\n      return(1);\n    break;\n\n  case NDPI_PROTOCOL_DNS:\n    if(flow->protos.dns.num_answers == 0)\n      return(1);\n    break;\n\n  case NDPI_PROTOCOL_FTP_CONTROL:\n  case NDPI_PROTOCOL_MAIL_POP:\n  case NDPI_PROTOCOL_MAIL_IMAP:\n  case NDPI_PROTOCOL_MAIL_SMTP:\n    if(flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')\n      return(1);\n    break;\n\n  case NDPI_PROTOCOL_SSH:\n    if((flow->protos.ssh.hassh_client[0] == '\\0') || (flow->protos.ssh.hassh_server[0] == '\\0'))\n      return(1);\n    break;\n\n  case NDPI_PROTOCOL_TELNET:\n    if(!flow->protos.telnet.password_detected)\n      return(1);\n    break;\n  }\n\n  return(0);\n}\n\n/* ******************************************************************** */\n\nconst char *ndpi_get_l4_proto_name(ndpi_l4_proto_info proto) {\n  switch (proto) {\n  case ndpi_l4_proto_unknown:\n    return(\"\");\n    break;\n\n  case ndpi_l4_proto_tcp_only:\n    return(\"TCP\");\n    break;\n\n  case ndpi_l4_proto_udp_only:\n    return(\"UDP\");\n    break;\n\n  case ndpi_l4_proto_tcp_and_udp:\n    return(\"TCP/UDP\");\n    break;\n  }\n\n  return(\"\");\n}\n\n/* ******************************************************************** */\n\nndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\t  u_int16_t ndpi_proto_id) {\n  if(ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {\n    u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;\n    NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;\n\n    if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)\n      return(ndpi_l4_proto_tcp_only);\n    else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)\n      return(ndpi_l4_proto_udp_only);\n    else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)\n      return(ndpi_l4_proto_tcp_and_udp);\n  }\n\n  return(ndpi_l4_proto_unknown); /* default */\n}\n\n/* ******************************************************************** */\n\nndpi_ptree_t *ndpi_ptree_create(void) {\n  ndpi_ptree_t *tree = (ndpi_ptree_t *) ndpi_malloc(sizeof(ndpi_ptree_t));\n\n  if(tree) {\n    tree->v4 = ndpi_New_Patricia(32);\n    tree->v6 = ndpi_New_Patricia(128);\n\n    if((!tree->v4) || (!tree->v6)) {\n      ndpi_ptree_destroy(tree);\n      return(NULL);\n    }\n  }\n\n  return(tree);\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_ptree_destroy(ndpi_ptree_t *tree) {\n  if(tree) {\n    if(tree->v4)\n      ndpi_Destroy_Patricia(tree->v4, free_ptree_data);\n    if(tree->v6)\n      ndpi_Destroy_Patricia(tree->v6, free_ptree_data);\n\n    ndpi_free(tree);\n  }\n}\n\n/* ******************************************************************** */\n\nint ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr,\n\t\t      u_int8_t bits, uint user_data) {\n  u_int8_t is_v6 = ndpi_is_ipv6(addr);\n  patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;\n  prefix_t prefix;\n  patricia_node_t *node;\n\n  if(bits > ptree->maxbits)\n    return(-1);\n\n  if(is_v6)\n    fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);\n  else\n    fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);\n\n  /* Verify that the node does not already exist */\n  node = ndpi_patricia_search_best(ptree, &prefix);\n\n  if(node && (node->prefix->bitlen == bits))\n    return(-2);\n\n  node = ndpi_patricia_lookup(ptree, &prefix);\n\n  if(node != NULL) {\n    node->value.uv.user_value = user_data, node->value.uv.additional_user_value = 0;\n\n    return(0);\n  }\n\n  return(-3);\n}\n\n/* ******************************************************************** */\n\nint ndpi_ptree_match_addr(ndpi_ptree_t *tree,\n\t\t\t  const ndpi_ip_addr_t *addr, uint *user_data) {\n  u_int8_t is_v6 = ndpi_is_ipv6(addr);\n  patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;\n  prefix_t prefix;\n  patricia_node_t *node;\n  int bits = ptree->maxbits;\n\n  if(is_v6)\n    fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);\n  else\n    fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);\n\n  node = ndpi_patricia_search_best(ptree, &prefix);\n\n  if(node) {\n    *user_data = node->value.uv.user_value;\n\n    return(0);\n  }\n\n  return(-1);\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]) {\n  ndpi_MD5_CTX ctx;\n\n  ndpi_MD5Init(&ctx);\n  ndpi_MD5Update(&ctx, data, data_len);\n  ndpi_MD5Final(hash, &ctx);\n}\n"], "fixing_code": ["/*\n * ndpi_main.c\n *\n * Copyright (C) 2011-20 - ntop.org\n *\n * This file is part of nDPI, an open source deep packet inspection\n * library based on the OpenDPI and PACE technology by ipoque GmbH\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/types.h>\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_UNKNOWN\n\n#include \"ndpi_config.h\"\n#include \"ndpi_api.h\"\n#include \"ahocorasick.h\"\n#include \"libcache.h\"\n\n#include <time.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n\n#if defined __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__\n#include <sys/endian.h>\n#endif\n\n#include \"ndpi_content_match.c.inc\"\n#include \"third_party/include/ndpi_patricia.h\"\n#include \"third_party/include/ht_hash.h\"\n#include \"third_party/include/ndpi_md5.h\"\n\n/* stun.c */\nextern u_int32_t get_stun_lru_key(struct ndpi_flow_struct *flow, u_int8_t rev);\n\nstatic int _ndpi_debug_callbacks = 0;\n\n/* #define MATCH_DEBUG 1 */\n\n/* ****************************************** */\n\nstatic void *(*_ndpi_flow_malloc)(size_t size);\nstatic void (*_ndpi_flow_free)(void *ptr);\n\nstatic void *(*_ndpi_malloc)(size_t size);\nstatic void (*_ndpi_free)(void *ptr);\n\n/* ****************************************** */\n\n/* Forward */\nstatic void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str, ndpi_port_range *range,\n                           ndpi_proto_defaults_t *def, u_int8_t customUserProto, ndpi_default_ports_tree_node_t **root,\n                           const char *_func, int _line);\n\nstatic int removeDefaultPort(ndpi_port_range *range, ndpi_proto_defaults_t *def, ndpi_default_ports_tree_node_t **root);\n\n/* ****************************************** */\n\nstatic inline uint8_t flow_is_proto(struct ndpi_flow_struct *flow, u_int16_t p) {\n  return((flow->detected_protocol_stack[0] == p) || (flow->detected_protocol_stack[1] == p));\n}\n\n/* ****************************************** */\n\nvoid *ndpi_malloc(size_t size) {\n  return(_ndpi_malloc ? _ndpi_malloc(size) : malloc(size));\n}\nvoid *ndpi_flow_malloc(size_t size) {\n  return(_ndpi_flow_malloc ? _ndpi_flow_malloc(size) : ndpi_malloc(size));\n}\n\n/* ****************************************** */\n\nvoid *ndpi_calloc(unsigned long count, size_t size) {\n  size_t len = count * size;\n  void *p = ndpi_malloc(len);\n\n  if(p)\n    memset(p, 0, len);\n\n  return(p);\n}\n\n/* ****************************************** */\n\nvoid ndpi_free(void *ptr) {\n  if(_ndpi_free)\n    _ndpi_free(ptr);\n  else\n    free(ptr);\n}\n\n/* ****************************************** */\n\nvoid ndpi_flow_free(void *ptr) {\n  if(_ndpi_flow_free)\n    _ndpi_flow_free(ptr);\n  else\n    ndpi_free_flow((struct ndpi_flow_struct *) ptr);\n}\n\n/* ****************************************** */\n\nvoid *ndpi_realloc(void *ptr, size_t old_size, size_t new_size) {\n  void *ret = ndpi_malloc(new_size);\n\n  if(!ret)\n    return(ret);\n  else {\n    memcpy(ret, ptr, old_size);\n    ndpi_free(ptr);\n    return(ret);\n  }\n}\n/* ****************************************** */\n\nchar *ndpi_strdup(const char *s) {\n  int len = strlen(s);\n  char *m = ndpi_malloc(len + 1);\n\n  if(m) {\n    memcpy(m, s, len);\n    m[len] = '\\0';\n  }\n\n  return(m);\n}\n\n/* *********************************************************************************** */\n\n/* Opaque structure defined here */\nstruct ndpi_ptree\n{\n  patricia_tree_t *v4;\n  patricia_tree_t *v6;\n};\n\n/* *********************************************************************************** */\n\nu_int32_t ndpi_detection_get_sizeof_ndpi_flow_struct(void) {\n  return(sizeof(struct ndpi_flow_struct));\n}\n\n/* *********************************************************************************** */\n\nu_int32_t ndpi_detection_get_sizeof_ndpi_id_struct(void) {\n  return(sizeof(struct ndpi_id_struct));\n}\n\n/* *********************************************************************************** */\n\nu_int32_t ndpi_detection_get_sizeof_ndpi_flow_tcp_struct(void) {\n  return(sizeof(struct ndpi_flow_tcp_struct));\n}\n\n/* *********************************************************************************** */\n\nu_int32_t ndpi_detection_get_sizeof_ndpi_flow_udp_struct(void) {\n  return(sizeof(struct ndpi_flow_udp_struct));\n}\n\n/* *********************************************************************************** */\n\nchar *ndpi_get_proto_by_id(struct ndpi_detection_module_struct *ndpi_str, u_int id) {\n  return((id >= ndpi_str->ndpi_num_supported_protocols) ? NULL : ndpi_str->proto_defaults[id].protoName);\n}\n\n/* *********************************************************************************** */\n\nu_int16_t ndpi_get_proto_by_name(struct ndpi_detection_module_struct *ndpi_str, const char *name) {\n  u_int16_t i, num = ndpi_get_num_supported_protocols(ndpi_str);\n\n  for (i = 0; i < num; i++)\n    if(strcasecmp(ndpi_get_proto_by_id(ndpi_str, i), name) == 0)\n      return(i);\n\n  return(NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ************************************************************************************* */\n\n#ifdef CODE_UNUSED\nndpi_port_range *ndpi_build_default_ports_range(ndpi_port_range *ports, u_int16_t portA_low, u_int16_t portA_high,\n                                                u_int16_t portB_low, u_int16_t portB_high, u_int16_t portC_low,\n                                                u_int16_t portC_high, u_int16_t portD_low, u_int16_t portD_high,\n                                                u_int16_t portE_low, u_int16_t portE_high) {\n  int i = 0;\n\n  ports[i].port_low = portA_low, ports[i].port_high = portA_high;\n  i++;\n  ports[i].port_low = portB_low, ports[i].port_high = portB_high;\n  i++;\n  ports[i].port_low = portC_low, ports[i].port_high = portC_high;\n  i++;\n  ports[i].port_low = portD_low, ports[i].port_high = portD_high;\n  i++;\n  ports[i].port_low = portE_low, ports[i].port_high = portE_high;\n\n  return(ports);\n}\n#endif\n\n/* *********************************************************************************** */\n\nndpi_port_range *ndpi_build_default_ports(ndpi_port_range *ports, u_int16_t portA, u_int16_t portB, u_int16_t portC,\n                                          u_int16_t portD, u_int16_t portE) {\n  int i = 0;\n\n  ports[i].port_low = portA, ports[i].port_high = portA;\n  i++;\n  ports[i].port_low = portB, ports[i].port_high = portB;\n  i++;\n  ports[i].port_low = portC, ports[i].port_high = portC;\n  i++;\n  ports[i].port_low = portD, ports[i].port_high = portD;\n  i++;\n  ports[i].port_low = portE, ports[i].port_high = portE;\n\n  return(ports);\n}\n\n/* ********************************************************************************** */\n\nvoid ndpi_set_proto_breed(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId, ndpi_protocol_breed_t breed) {\n  if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)\n    return;\n  else\n    ndpi_str->proto_defaults[protoId].protoBreed = breed;\n}\n\n/* ********************************************************************************** */\n\nvoid ndpi_set_proto_category(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId,\n                             ndpi_protocol_category_t protoCategory) {\n  if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)\n    return;\n  else\n    ndpi_str->proto_defaults[protoId].protoCategory = protoCategory;\n}\n\n/* ********************************************************************************** */\n\n/*\n  There are some (master) protocols that are informative, meaning that it shows\n  what is the subprotocol about, but also that the subprotocol isn't a real protocol.\n\n  Example:\n  - DNS is informative as if we see a DNS request for www.facebook.com, the\n  returned protocol is DNS.Facebook, but Facebook isn't a real subprotocol but\n  rather it indicates a query for Facebook and not Facebook traffic.\n  - HTTP/SSL are NOT informative as SSL.Facebook (likely) means that this is\n  SSL (HTTPS) traffic containg Facebook traffic.\n*/\nu_int8_t ndpi_is_subprotocol_informative(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId) {\n  if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)\n    return(0);\n\n  switch (protoId) {\n    /* All dissectors that have calls to ndpi_match_host_subprotocol() */\n  case NDPI_PROTOCOL_DNS:\n    return(1);\n    break;\n\n  default:\n    return(0);\n  }\n}\n/* ********************************************************************************** */\n\nvoid ndpi_exclude_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                           u_int16_t protocol_id, const char *_file, const char *_func, int _line) {\n  if(protocol_id < NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n    if(ndpi_str && ndpi_str->ndpi_log_level >= NDPI_LOG_DEBUG && ndpi_str->ndpi_debug_printf != NULL) {\n      (*(ndpi_str->ndpi_debug_printf))(protocol_id, ndpi_str, NDPI_LOG_DEBUG, _file, _func, _line, \"exclude %s\\n\",\n\t\t\t\t       ndpi_get_proto_name(ndpi_str, protocol_id));\n    }\n#endif\n    NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, protocol_id);\n  }\n}\n\n/* ********************************************************************************** */\n\nvoid ndpi_set_proto_defaults(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_breed_t breed,\n                             u_int16_t protoId, u_int8_t can_have_a_subprotocol, u_int16_t tcp_master_protoId[2],\n                             u_int16_t udp_master_protoId[2], char *protoName, ndpi_protocol_category_t protoCategory,\n                             ndpi_port_range *tcpDefPorts, ndpi_port_range *udpDefPorts) {\n  char *name;\n  int j;\n\n  if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {\n#ifdef DEBUG\n    NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: INTERNAL ERROR\\n\", protoName, protoId);\n#endif\n    return;\n  }\n\n  if(ndpi_str->proto_defaults[protoId].protoName != NULL) {\n#ifdef DEBUG\n    NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: already initialized. Ignoring it\\n\", protoName, protoId);\n#endif\n    return;\n  }\n\n  name = ndpi_strdup(protoName);\n\n  if(ndpi_str->proto_defaults[protoId].protoName)\n    ndpi_free(ndpi_str->proto_defaults[protoId].protoName);\n\n  ndpi_str->proto_defaults[protoId].protoName = name, ndpi_str->proto_defaults[protoId].protoCategory = protoCategory,\n    ndpi_str->proto_defaults[protoId].protoId = protoId, ndpi_str->proto_defaults[protoId].protoBreed = breed;\n  ndpi_str->proto_defaults[protoId].can_have_a_subprotocol = can_have_a_subprotocol;\n\n  memcpy(&ndpi_str->proto_defaults[protoId].master_tcp_protoId, tcp_master_protoId, 2 * sizeof(u_int16_t));\n  memcpy(&ndpi_str->proto_defaults[protoId].master_udp_protoId, udp_master_protoId, 2 * sizeof(u_int16_t));\n\n  for (j = 0; j < MAX_DEFAULT_PORTS; j++) {\n    if(udpDefPorts[j].port_low != 0)\n      addDefaultPort(ndpi_str, &udpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->udpRoot,\n\t\t     __FUNCTION__, __LINE__);\n\n    if(tcpDefPorts[j].port_low != 0)\n      addDefaultPort(ndpi_str, &tcpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->tcpRoot,\n\t\t     __FUNCTION__, __LINE__);\n\n    /* No port range, just the lower port */\n    ndpi_str->proto_defaults[protoId].tcp_default_ports[j] = tcpDefPorts[j].port_low;\n    ndpi_str->proto_defaults[protoId].udp_default_ports[j] = udpDefPorts[j].port_low;\n  }\n}\n\n/* ******************************************************************** */\n\nstatic int ndpi_default_ports_tree_node_t_cmp(const void *a, const void *b) {\n  ndpi_default_ports_tree_node_t *fa = (ndpi_default_ports_tree_node_t *) a;\n  ndpi_default_ports_tree_node_t *fb = (ndpi_default_ports_tree_node_t *) b;\n\n  //printf(\"[NDPI] %s(%d, %d)\\n\", __FUNCTION__, fa->default_port, fb->default_port);\n\n  return((fa->default_port == fb->default_port) ? 0 : ((fa->default_port < fb->default_port) ? -1 : 1));\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_default_ports_tree_node_t_walker(const void *node, const ndpi_VISIT which, const int depth) {\n  ndpi_default_ports_tree_node_t *f = *(ndpi_default_ports_tree_node_t **) node;\n\n  printf(\"<%d>Walk on node %s (%u)\\n\", depth,\n\t which == ndpi_preorder ?\n\t \"ndpi_preorder\" :\n\t which == ndpi_postorder ?\n\t \"ndpi_postorder\" :\n\t which == ndpi_endorder ? \"ndpi_endorder\" : which == ndpi_leaf ? \"ndpi_leaf\" : \"unknown\",\n\t f->default_port);\n}\n\n/* ******************************************************************** */\n\nstatic void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str, ndpi_port_range *range,\n                           ndpi_proto_defaults_t *def, u_int8_t customUserProto, ndpi_default_ports_tree_node_t **root,\n                           const char *_func, int _line) {\n  u_int16_t port;\n\n  for (port = range->port_low; port <= range->port_high; port++) {\n    ndpi_default_ports_tree_node_t *node =\n      (ndpi_default_ports_tree_node_t *) ndpi_malloc(sizeof(ndpi_default_ports_tree_node_t));\n    ndpi_default_ports_tree_node_t *ret;\n\n    if(!node) {\n      NDPI_LOG_ERR(ndpi_str, \"%s:%d not enough memory\\n\", _func, _line);\n      break;\n    }\n\n    node->proto = def, node->default_port = port, node->customUserProto = customUserProto;\n    ret = (ndpi_default_ports_tree_node_t *) ndpi_tsearch(node, (void *) root, ndpi_default_ports_tree_node_t_cmp); /* Add it to the tree */\n\n    if(ret != node) {\n      NDPI_LOG_DBG(ndpi_str, \"[NDPI] %s:%d found duplicate for port %u: overwriting it with new value\\n\", _func,\n\t\t   _line, port);\n\n      ret->proto = def;\n      ndpi_free(node);\n    }\n  }\n}\n\n/* ****************************************************** */\n\n/*\n  NOTE\n\n  This function must be called with a semaphore set, this in order to avoid\n  changing the datastructures while using them\n*/\nstatic int removeDefaultPort(ndpi_port_range *range, ndpi_proto_defaults_t *def, ndpi_default_ports_tree_node_t **root) {\n  ndpi_default_ports_tree_node_t node;\n  u_int16_t port;\n\n  for (port = range->port_low; port <= range->port_high; port++) {\n    ndpi_default_ports_tree_node_t *ret;\n\n    node.proto = def, node.default_port = port;\n    ret = (ndpi_default_ports_tree_node_t *) ndpi_tdelete(\n\t\t\t\t\t\t\t  &node, (void *) root, ndpi_default_ports_tree_node_t_cmp); /* Add it to the tree */\n\n    if(ret != NULL) {\n      ndpi_free((ndpi_default_ports_tree_node_t *) ret);\n      return(0);\n    }\n  }\n\n  return(-1);\n}\n\n/* ****************************************************** */\n\nstatic int ndpi_string_to_automa(struct ndpi_detection_module_struct *ndpi_str, ndpi_automa *automa, char *value,\n                                 u_int16_t protocol_id, ndpi_protocol_category_t category, ndpi_protocol_breed_t breed,\n                                 u_int8_t free_str_on_duplicate) {\n  AC_PATTERN_t ac_pattern;\n  AC_ERROR_t rc;\n\n  if((value == NULL) || (protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))) {\n    NDPI_LOG_ERR(ndpi_str, \"[NDPI] protoId=%d: INTERNAL ERROR\\n\", protocol_id);\n    return(-1);\n  }\n\n  if(automa->ac_automa == NULL)\n    return(-2);\n\n  ac_pattern.astring = value, ac_pattern.rep.number = protocol_id,\n    ac_pattern.rep.category = (u_int16_t) category, ac_pattern.rep.breed = (u_int16_t) breed;\n\n#ifdef MATCH_DEBUG\n  printf(\"Adding to automa [%s][protocol_id: %u][category: %u][breed: %u]\\n\", value, protocol_id, category, breed);\n#endif\n\n  if(value == NULL)\n    ac_pattern.length = 0;\n  else\n    ac_pattern.length = strlen(ac_pattern.astring);\n\n  rc = ac_automata_add(((AC_AUTOMATA_t *) automa->ac_automa), &ac_pattern);\n  if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS)\n    return(-2);\n  if(rc == ACERR_DUPLICATE_PATTERN && free_str_on_duplicate)\n    ndpi_free(value);\n\n  return(0);\n}\n\n/* ****************************************************** */\n\nstatic int ndpi_add_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *_value, int protocol_id,\n                                         ndpi_protocol_category_t category, ndpi_protocol_breed_t breed) {\n  int rv;\n  char *value = ndpi_strdup(_value);\n\n  if(!value)\n    return(-1);\n\n#ifdef DEBUG\n  NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding [%s][%d]\\n\", value, protocol_id);\n#endif\n\n  rv = ndpi_string_to_automa(ndpi_str, &ndpi_str->host_automa, value, protocol_id, category, breed, 1);\n\n  if(rv != 0)\n    ndpi_free(value);\n\n  return(rv);\n}\n\n/* ****************************************************** */\n\n#ifdef CODE_UNUSED\nint ndpi_add_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id,\n                                 ndpi_protocol_category_t category, ndpi_protocol_breed_t breed) {\n  return(ndpi_string_to_automa(ndpi_str, &ndpi_str->content_automa, value, protocol_id, category, breed, 0));\n}\n#endif\n\n/* ****************************************************** */\n\n/*\n  NOTE\n\n  This function must be called with a semaphore set, this in order to avoid\n  changing the datastructures while using them\n*/\nstatic int ndpi_remove_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id) {\n  NDPI_LOG_ERR(ndpi_str, \"[NDPI] Missing implementation for proto %s/%d\\n\", value, protocol_id);\n  return(-1);\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_init_protocol_match(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_match *match) {\n  u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};\n  ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];\n\n  if(ndpi_str->proto_defaults[match->protocol_id].protoName == NULL) {\n    ndpi_str->proto_defaults[match->protocol_id].protoName = ndpi_strdup(match->proto_name);\n\n    ndpi_str->proto_defaults[match->protocol_id].protoId = match->protocol_id;\n    ndpi_str->proto_defaults[match->protocol_id].protoCategory = match->protocol_category;\n    ndpi_str->proto_defaults[match->protocol_id].protoBreed = match->protocol_breed;\n\n    ndpi_set_proto_defaults(ndpi_str, ndpi_str->proto_defaults[match->protocol_id].protoBreed,\n\t\t\t    ndpi_str->proto_defaults[match->protocol_id].protoId, 0 /* can_have_a_subprotocol */,\n\t\t\t    no_master, no_master, ndpi_str->proto_defaults[match->protocol_id].protoName,\n\t\t\t    ndpi_str->proto_defaults[match->protocol_id].protoCategory,\n\t\t\t    ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t    ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  }\n\n  ndpi_add_host_url_subprotocol(ndpi_str, match->string_to_match, match->protocol_id, match->protocol_category,\n\t\t\t\tmatch->protocol_breed);\n}\n\n/* ******************************************************************** */\n\n/* Self check function to be called onli for testing purposes */\nvoid ndpi_self_check_host_match() {\n  u_int32_t i, j;\n\n  for (i = 0; host_match[i].string_to_match != NULL; i++) {\n    for (j = 0; host_match[j].string_to_match != NULL; j++) {\n      if((i != j) && (strcmp(host_match[i].string_to_match, host_match[j].string_to_match) == 0)) {\n\tprintf(\"[INTERNAL ERROR]: Duplicate string detected '%s' [id: %u, id %u]\\n\",\n\t       host_match[i].string_to_match, i, j);\n\tprintf(\"\\nPlease fix host_match[] in ndpi_content_match.c.inc\\n\");\n\texit(0);\n      }\n    }\n  }\n}\n\n/* ******************************************************************** */\n\nstatic void init_string_based_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  int i;\n\n  for (i = 0; host_match[i].string_to_match != NULL; i++)\n    ndpi_init_protocol_match(ndpi_str, &host_match[i]);\n\n  ndpi_enable_loaded_categories(ndpi_str);\n\n#ifdef MATCH_DEBUG\n  // ac_automata_display(ndpi_str->host_automa.ac_automa, 'n');\n#endif\n\n  for (i = 0; ndpi_en_bigrams[i] != NULL; i++)\n    ndpi_string_to_automa(ndpi_str, &ndpi_str->bigrams_automa, (char *) ndpi_en_bigrams[i], 1, 1, 1, 0);\n\n  for (i = 0; ndpi_en_impossible_bigrams[i] != NULL; i++)\n    ndpi_string_to_automa(ndpi_str, &ndpi_str->impossible_bigrams_automa, (char *) ndpi_en_impossible_bigrams[i], 1,\n\t\t\t  1, 1, 0);\n}\n\n/* ******************************************************************** */\n\nint ndpi_set_detection_preferences(struct ndpi_detection_module_struct *ndpi_str, ndpi_detection_preference pref,\n                                   int value) {\n  switch (pref) {\n  case ndpi_pref_direction_detect_disable:\n    ndpi_str->direction_detect_disable = (u_int8_t) value;\n    break;\n\n  default:\n    return(-1);\n  }\n\n  return(0);\n}\n\n/* ******************************************************************** */\n\nstatic void ndpi_validate_protocol_initialization(struct ndpi_detection_module_struct *ndpi_str) {\n  int i;\n\n  for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {\n    if(ndpi_str->proto_defaults[i].protoName == NULL) {\n      NDPI_LOG_ERR(ndpi_str,\n\t\t   \"[NDPI] INTERNAL ERROR missing protoName initialization for [protoId=%d]: recovering\\n\", i);\n    } else {\n      if((i != NDPI_PROTOCOL_UNKNOWN) &&\n\t (ndpi_str->proto_defaults[i].protoCategory == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {\n\tNDPI_LOG_ERR(ndpi_str,\n\t\t     \"[NDPI] INTERNAL ERROR missing category [protoId=%d/%s] initialization: recovering\\n\", i,\n\t\t     ndpi_str->proto_defaults[i].protoName ? ndpi_str->proto_defaults[i].protoName : \"???\");\n      }\n    }\n  }\n}\n\n/* ******************************************************************** */\n\n/* This function is used to map protocol name and default ports and it MUST\n   be updated whenever a new protocol is added to NDPI.\n\n   Do NOT add web services (NDPI_SERVICE_xxx) here.\n*/\nstatic void ndpi_init_protocol_defaults(struct ndpi_detection_module_struct *ndpi_str) {\n  ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];\n  u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO}, custom_master[2];\n\n  /* Reset all settings */\n  memset(ndpi_str->proto_defaults, 0, sizeof(ndpi_str->proto_defaults));\n\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNRATED, NDPI_PROTOCOL_UNKNOWN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Unknown\", NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_FTP_CONTROL, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"FTP_CONTROL\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 21, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_FTP_DATA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"FTP_DATA\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 20, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_POP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"POP3\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 110, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_POPS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"POPS\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 995, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MAIL_SMTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMTP\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 25, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_SMTPS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMTPS\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 465, 587, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_IMAP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IMAP\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 143, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_IMAPS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IMAPS\", NDPI_PROTOCOL_CATEGORY_MAIL,\n\t\t\t  ndpi_build_default_ports(ports_a, 993, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNS, 1 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 53, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 53, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IPP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IPP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IMO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IMO\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP, 1 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"HTTP\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 80, 0 /* ntop */, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MDNS, 1 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MDNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5353, 5354, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NTP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 123, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETBIOS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NetBIOS\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 139, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 137, 138, 139, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NFS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NFS\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 2049, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 2049, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSDP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SSDP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BGP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"BGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 179, 2605, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SNMP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SNMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 161, 162, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_XDMCP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"XDMCP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 177, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 177, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_DANGEROUS, NDPI_PROTOCOL_SMBV1, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMBv1\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 445, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SYSLOG, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Syslog\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 514, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 514, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DHCP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 67, 68, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_POSTGRES, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PostgreSQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 5432, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MYSQL, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MySQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 3306, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECT_DOWNLOAD_LINK,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Direct_Download_Link\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_APPLEJUICE,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"AppleJuice\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECTCONNECT,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"DirectConnect\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NATS,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Nats\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_NTOP, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"ntop\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VMWARE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"VMware\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 903, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 902, 903, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FBZERO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"FacebookZero\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_KONTIKI,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Kontiki\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_MEDIA, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_OPENFT,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"OpenFT\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_FASTTRACK,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"FastTrack\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_GNUTELLA,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Gnutella\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_EDONKEY, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"eDonkey\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_BITTORRENT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"BitTorrent\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 51413, 53646, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 6771, 51413, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Skype\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE_CALL,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"SkypeCall\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TIKTOK, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TikTok\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEREDO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Teredo\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3544, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(\n\t\t\t  ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WECHAT, 0 /* can_have_a_subprotocol */, no_master, /* wechat.com */\n\t\t\t  no_master, \"WeChat\", NDPI_PROTOCOL_CATEGORY_CHAT, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEMCACHED, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Memcached\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 11211, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 11211, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMBV23, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMBv23\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 445, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MINING, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Mining\", CUSTOM_CATEGORY_MINING,\n\t\t\t  ndpi_build_default_ports(ports_a, 8333, 30303, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NEST_LOG_SINK,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"NestLogSink\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_CLOUD,\n\t\t\t  ndpi_build_default_ports(ports_a, 11095, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MODBUS, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"Modbus\", NDPI_PROTOCOL_CATEGORY_NETWORK, /* Perhaps IoT in the future */\n\t\t\t  ndpi_build_default_ports(ports_a, 502, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_CALL,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppCall\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DATASAVER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DataSaver\", NDPI_PROTOCOL_CATEGORY_WEB /* dummy */,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SIGNAL, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, /* https://signal.org */\n\t\t\t  no_master, \"Signal\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOH_DOT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DoH_DoT\", NDPI_PROTOCOL_CATEGORY_NETWORK /* dummy */,\n\t\t\t  ndpi_build_default_ports(ports_a, 853, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FREE_205, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"FREE_205\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WIREGUARD, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"WireGuard\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 51820, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_XBOX, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Xbox\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 3074, 3076, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3074, 3076, 500, 3544, 4500) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PLAYSTATION, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Playstation\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 1935, 3478, 3479, 3480, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3478, 3479, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQ, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"QQ\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_RTSP, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"RTSP\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 554, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 554, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ICECAST, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IceCast\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPLIVE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PPLive\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ZATTOO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Zattoo\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SHOUTCAST, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"ShoutCast\", NDPI_PROTOCOL_CATEGORY_MUSIC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOPCAST, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Sopcast\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVANTS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Tvants\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVUPLAYER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TVUplayer\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_DOWNLOAD,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Download\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQLIVE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"QQLive\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_THUNDER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Thunder\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOULSEEK, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Soulseek\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PS_VUE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PS_VUE\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_IRC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IRC\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 194, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 194, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AYIYA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Ayiya\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5072, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UNENCRYPTED_JABBER,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Unencrypted_Jabber\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OSCAR, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Oscar\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_BATTLEFIELD, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"BattleField\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_VRRP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"VRRP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STEAM, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Steam\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HALFLIFE2, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"HalfLife2\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLDOFWARCRAFT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"WorldOfWarcraft\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_HOTSPOT_SHIELD,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"HotspotShield\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VPN, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_TELNET, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Telnet\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 23, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n\n  custom_master[0] = NDPI_PROTOCOL_SIP, custom_master[1] = NDPI_PROTOCOL_H323;\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_STUN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, custom_master, \"STUN\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3478, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_IP_IPSEC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IPsec\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 500, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 500, 4500, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_GRE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"GRE\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"ICMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IGMP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IGMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_EGP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"EGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_SCTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SCTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_OSPF, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"OSPF\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 2604, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IP_IN_IP,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"IP_in_IP\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RTP\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RDP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RDP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 3389, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 3389, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VNC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"VNC\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 5900, 5901, 5800, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PCANYWHERE,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"PcAnywhere\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZOOM, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Zoom\", NDPI_PROTOCOL_CATEGORY_VIDEO,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_FILES,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppFiles\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"WhatsApp\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_TLS, 1 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"TLS\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSH, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SSH\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 22, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_USENET, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Usenet\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MGCP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MGCP\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IAX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"IAX\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 4569, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 4569, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AFP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"AFP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 548, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 548, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HULU, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Hulu\", NDPI_PROTOCOL_CATEGORY_STREAMING,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CHECKMK, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"CHECKMK\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 6556, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_STEALTHNET,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Stealthnet\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_AIMINI, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Aimini\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SIP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SIP\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 5060, 5061, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5060, 5061, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TRUPHONE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TruPhone\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMPV6, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"ICMPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCPV6, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DHCPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ARMAGETRON, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Armagetron\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CROSSFIRE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Crossfire\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOFUS, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Dofus\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FIESTA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Fiesta\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FLORENSIA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Florensia\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_GUILDWARS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Guildwars\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_ACTIVESYNC,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_ActiveSync\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KERBEROS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Kerberos\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 88, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 88, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LDAP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"LDAP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 389, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 389, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MAPLESTORY, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MapleStory\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MSSQL_TDS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MsSQL-TDS\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 1433, 1434, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PPTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"PPTP\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WARCRAFT3, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Warcraft3\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLD_OF_KUNG_FU, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"WorldOfKungFu\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DCERPC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DCE_RPC\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 135, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETFLOW, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NetFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 2055, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SFLOW, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"sFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 6343, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_CONNECT,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Connect\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_PROXY,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Proxy\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 8080, 3128, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CITRIX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Citrix\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 1494, 2598, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBEX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Webex\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RADIUS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Radius\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 1812, 1813, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 1812, 1813, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMVIEWER,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"TeamViewer\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,\n\t\t\t  ndpi_build_default_ports(ports_a, 5938, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5938, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LOTUS_NOTES,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"LotusNotes\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,\n\t\t\t  ndpi_build_default_ports(ports_a, 1352, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(\n\t\t\t  ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SAP, 0 /* can_have_a_subprotocol */, no_master, no_master,\n\t\t\t  \"SAP\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 3201, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */); /* Missing dissector: port based only */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_GTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"GTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 2152, 2123, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UPNP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"UPnP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 1780, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 1900, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TELEGRAM, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Telegram\", NDPI_PROTOCOL_CATEGORY_CHAT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_QUIC, 1 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"QUIC\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 443, 80, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DIAMETER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Diameter\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 3868, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_APPLE_PUSH,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"ApplePush\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DROPBOX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Dropbox\", NDPI_PROTOCOL_CATEGORY_CLOUD,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 17500, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SPOTIFY, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Spotify\", NDPI_PROTOCOL_CATEGORY_MUSIC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MESSENGER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Messenger\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LISP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"LISP\", NDPI_PROTOCOL_CATEGORY_CLOUD,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 4342, 4341, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_EAQ, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"EAQ\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 6000, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KAKAOTALK_VOICE,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"KakaoTalk_Voice\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MPEGTS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MPEG_TS\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  /* http://en.wikipedia.org/wiki/Link-local_Multicast_Name_Resolution */\n  ndpi_set_proto_defaults(\n\t\t\t  ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LLMNR, 0 /* can_have_a_subprotocol */, no_master, no_master,\n\t\t\t  \"LLMNR\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 5355, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5355, 0, 0, 0, 0) /* UDP */); /* Missing dissector: port based only */\n  ndpi_set_proto_defaults(\n\t\t\t  ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_REMOTE_SCAN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RemoteScan\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 6077, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 6078, 0, 0, 0, 0) /* UDP */); /* Missing dissector: port based only */\n\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_H323, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"H323\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 1719, 1720, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 1719, 1720, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OPENVPN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"OpenVPN\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 1194, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 1194, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NOE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"NOE\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CISCOVPN, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"CiscoVPN\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 10000, 8008, 8009, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 10000, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMSPEAK, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TeamSpeak\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKINNY, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"CiscoSkinny\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 2000, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTCP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RTCP\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RSYNC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RSYNC\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 873, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ORACLE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Oracle\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 1521, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CORBA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Corba\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UBUNTUONE, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"UbuntuONE\", NDPI_PROTOCOL_CATEGORY_CLOUD,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHOIS_DAS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Whois-DAS\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 43, 4343, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));    /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_COLLECTD, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Collectd\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),      /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 25826, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOCKS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SOCKS\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 1080, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 1080, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TFTP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TFTP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),   /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 69, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTMP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RTMP\", NDPI_PROTOCOL_CATEGORY_MEDIA,\n\t\t\t  ndpi_build_default_ports(ports_a, 1935, 0, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));   /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PANDO, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Pando_Media_Booster\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEGACO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Megaco\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),     /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 2944, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_REDIS, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Redis\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 6379, 0, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));   /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZMQ, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"ZeroMQ\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_VHUA, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"VHUA\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),      /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 58267, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STARCRAFT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Starcraft\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 1119, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 1119, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_UBNTAC2, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"UBNTAC2\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),      /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 10001, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VIBER, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Viber\", NDPI_PROTOCOL_CATEGORY_VOIP,\n\t\t\t  ndpi_build_default_ports(ports_a, 7985, 5242, 5243, 4244, 0),     /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 7985, 7987, 5242, 5243, 4244)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_COAP, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"COAP\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),        /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 5683, 5684, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MQTT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"MQTT\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 1883, 8883, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));      /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOMEIP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SOMEIP\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 30491, 30501, 0, 0, 0),      /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 30491, 30501, 30490, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RX, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"RX\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_GIT, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"Git\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,\n\t\t\t  ndpi_build_default_ports(ports_a, 9418, 0, 0, 0, 0), /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0));   /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DRDA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DRDA\", NDPI_PROTOCOL_CATEGORY_DATABASE,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HANGOUT_DUO,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"GoogleHangoutDuo\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BJNP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"BJNP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 8612, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMPP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"SMPP\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_OOKLA, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Ookla\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMQP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"AMQP\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_DNSCRYPT, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"DNScrypt\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0),  /* TCP */\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0)); /* UDP */\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TINC, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"TINC\", NDPI_PROTOCOL_CATEGORY_VPN,\n\t\t\t  ndpi_build_default_ports(ports_a, 655, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 655, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FIX, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"FIX\", NDPI_PROTOCOL_CATEGORY_RPC,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_NINTENDO, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"Nintendo\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CSGO, 0 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"CSGO\", NDPI_PROTOCOL_CATEGORY_GAME,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AJP, 0 /* can_have_a_subprotocol */,\n\t\t\t  no_master, no_master, \"AJP\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 8009, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TARGUS_GETDATA,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"Targus Dataspeed\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 5001, 5201, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5001, 5201, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMAZON_VIDEO,\n\t\t\t  0 /* can_have_a_subprotocol */, no_master, no_master, \"AmazonVideo\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNP3, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"DNP3\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 20000, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IEC60870, 1 /* no subprotocol */,\n\t\t\t  no_master, no_master, \"IEC60870\",\n\t\t\t  NDPI_PROTOCOL_CATEGORY_NETWORK, /* Perhaps IoT in the future */\n\t\t\t  ndpi_build_default_ports(ports_a, 2404, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BLOOMBERG, 1 /* no subprotocol */,\n\t\t\t  no_master, no_master, \"Bloomberg\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CAPWAP, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"CAPWAP\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 5246, 5247, 0, 0, 0) /* UDP */\n\t\t\t  );\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZABBIX, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"Zabbix\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 10050, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */\n\t\t\t  );\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_S7COMM, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"s7comm\", NDPI_PROTOCOL_CATEGORY_NETWORK,\n\t\t\t  ndpi_build_default_ports(ports_a, 102, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MSTEAMS, 1 /* no subprotocol */, no_master,\n\t\t\t  no_master, \"Teams\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */\n\t\t\t  );\n  ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBSOCKET,\n\t\t\t  1 /* can_have_a_subprotocol */, no_master,\n\t\t\t  no_master, \"WebSocket\", NDPI_PROTOCOL_CATEGORY_WEB,\n\t\t\t  ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t  ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n\n#ifdef CUSTOM_NDPI_PROTOCOLS\n#include \"../../../nDPI-custom/custom_ndpi_main.c\"\n#endif\n\n  /* calling function for host and content matched protocols */\n  init_string_based_protocols(ndpi_str);\n\n  ndpi_validate_protocol_initialization(ndpi_str);\n}\n\n/* ****************************************************** */\n\n#ifdef CUSTOM_NDPI_PROTOCOLS\n#include \"../../../nDPI-custom/custom_ndpi_protocols.c\"\n#endif\n\n/* ****************************************************** */\n\nstatic int ac_match_handler(AC_MATCH_t *m, AC_TEXT_t *txt, AC_REP_t *match) {\n  int min_len = (txt->length < m->patterns->length) ? txt->length : m->patterns->length;\n  char buf[64] = {'\\0'}, *whatfound;\n  int min_buf_len = (txt->length > 63 /* sizeof(buf)-1 */) ? 63 : txt->length;\n  u_int buf_len = strlen(buf);\n\n  strncpy(buf, txt->astring, min_buf_len);\n  buf[min_buf_len] = '\\0';\n\n#ifdef MATCH_DEBUG\n  printf(\"Searching [to search: %s/%u][pattern: %s/%u] [len: %d][match_num: %u][%s]\\n\", buf,\n\t (unigned int) txt->length, m->patterns->astring, (unigned int) m->patterns->length, min_len, m->match_num,\n\t m->patterns->astring);\n#endif\n\n  whatfound = strstr(buf, m->patterns->astring);\n\n#ifdef MATCH_DEBUG\n  printf(\"[NDPI] %s() [searching=%s][pattern=%s][%s][%c]\\n\", __FUNCTION__, buf, m->patterns->astring,\n\t whatfound ? whatfound : \"<NULL>\", whatfound[-1]);\n#endif\n\n  if(whatfound) {\n    /*\n      The patch below allows in case of pattern ws.amazon.com\n      to avoid matching aws.amazon.com whereas a.ws.amazon.com\n      has to match\n    */\n    if((whatfound != buf) && (m->patterns->astring[0] != '.') /* The searched pattern does not start with . */\n       && strchr(m->patterns->astring, '.') /* The matched pattern has a . (e.g. numeric or sym IPs) */) {\n      int len = strlen(m->patterns->astring);\n\n      if((whatfound[-1] != '.') || ((m->patterns->astring[len - 1] != '.') &&\n\t\t\t\t    (whatfound[len] != '\\0') /* endsWith does not hold here */)) {\n\treturn(0);\n      } else {\n\tmemcpy(match, &m->patterns[0].rep, sizeof(AC_REP_t)); /* Partial match? */\n\treturn(0); /* Keep searching as probably there is a better match */\n      }\n    }\n  }\n\n  /*\n    Return 1 for stopping to the first match.\n    We might consider searching for the more\n    specific match, paying more cpu cycles.\n  */\n  memcpy(match, &m->patterns[0].rep, sizeof(AC_REP_t));\n\n  if(((buf_len >= min_len) && (strncmp(&buf[buf_len - min_len], m->patterns->astring, min_len) == 0)) ||\n     (strncmp(buf, m->patterns->astring, min_len) == 0) /* begins with */\n     ) {\n#ifdef MATCH_DEBUG\n    printf(\"Found match [%s][%s] [len: %d]\"\n\t   // \"[proto_id: %u]\"\n\t   \"\\n\",\n\t   buf, m->patterns->astring, min_len /* , *matching_protocol_id */);\n#endif\n    return(1); /* If the pattern found matches the string at the beginning we stop here */\n  } else {\n#ifdef MATCH_DEBUG\n    printf(\"NO match found: continue\\n\");\n#endif\n    return(0); /* 0 to continue searching, !0 to stop */\n  }\n}\n\n/* ******************************************************************** */\n\nstatic int fill_prefix_v4(prefix_t *p, const struct in_addr *a, int b, int mb) {\n  if(b < 0 || b > mb)\n    return(-1);\n\n  memset(p, 0, sizeof(prefix_t));\n  memcpy(&p->add.sin, a, (mb + 7) / 8);\n  p->family = AF_INET;\n  p->bitlen = b;\n  p->ref_count = 0;\n\n  return(0);\n}\n\n/* ******************************************* */\n\nstatic int fill_prefix_v6(prefix_t *prefix, const struct in6_addr *addr, int bits, int maxbits) {\n#ifdef PATRICIA_IPV6\n  if(bits < 0 || bits > maxbits)\n    return -1;\n\n  memcpy(&prefix->add.sin6, addr, (maxbits + 7) / 8);\n  prefix->family = AF_INET6, prefix->bitlen = bits, prefix->ref_count = 0;\n\n  return 0;\n#else\n  return(-1);\n#endif\n}\n\n/* ******************************************* */\n\nu_int16_t ndpi_network_ptree_match(struct ndpi_detection_module_struct *ndpi_str,\n                                   struct in_addr *pin /* network byte order */) {\n  prefix_t prefix;\n  patricia_node_t *node;\n\n  /* Make sure all in network byte order otherwise compares wont work */\n  fill_prefix_v4(&prefix, pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n  node = ndpi_patricia_search_best(ndpi_str->protocols_ptree, &prefix);\n\n  return(node ? node->value.uv.user_value : NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ******************************************* */\n\nu_int16_t ndpi_network_port_ptree_match(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\tstruct in_addr *pin /* network byte order */,\n\t\t\t\t\tu_int16_t port /* network byte order */) {\n  prefix_t prefix;\n  patricia_node_t *node;\n\n  /* Make sure all in network byte order otherwise compares wont work */\n  fill_prefix_v4(&prefix, pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n  node = ndpi_patricia_search_best(ndpi_str->protocols_ptree, &prefix);\n\n  if(node) {\n    if((node->value.uv.additional_user_value == 0)\n       || (node->value.uv.additional_user_value == port))\n      return(node->value.uv.user_value);\n  }\n\n  return(NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ******************************************* */\n\n#if 0\nstatic u_int8_t tor_ptree_match(struct ndpi_detection_module_struct *ndpi_str, struct in_addr *pin) {\n  return((ndpi_network_ptree_match(ndpi_str, pin) == NDPI_PROTOCOL_TOR) ? 1 : 0);\n}\n#endif\n\n/* ******************************************* */\n\nu_int8_t ndpi_is_tor_flow(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  if(packet->tcp != NULL) {\n    if(packet->iph) {\n      if(flow->guessed_host_protocol_id == NDPI_PROTOCOL_TOR)\n\treturn(1);\n    }\n  }\n\n  return(0);\n}\n\n/* ******************************************* */\n\nstatic patricia_node_t *add_to_ptree(patricia_tree_t *tree, int family, void *addr, int bits) {\n  prefix_t prefix;\n  patricia_node_t *node;\n\n  fill_prefix_v4(&prefix, (struct in_addr *) addr, bits, tree->maxbits);\n\n  node = ndpi_patricia_lookup(tree, &prefix);\n  if(node) memset(&node->value, 0, sizeof(node->value));\n\n  return(node);\n}\n\n/* ******************************************* */\n\n/*\n  Load a file containing IPv4 addresses in CIDR format as 'protocol_id'\n\n  Return: the number of entries loaded or -1 in case of error\n*/\nint ndpi_load_ipv4_ptree(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t const char *path, u_int16_t protocol_id) {\n  char buffer[128], *line, *addr, *cidr, *saveptr;\n  FILE *fd;\n  int len;\n  u_int num_loaded = 0;\n\n  fd = fopen(path, \"r\");\n\n  if(fd == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));\n    return(-1);\n  }\n\n  while (1) {\n    line = fgets(buffer, sizeof(buffer), fd);\n\n    if(line == NULL)\n      break;\n\n    len = strlen(line);\n\n    if((len <= 1) || (line[0] == '#'))\n      continue;\n\n    line[len - 1] = '\\0';\n    addr = strtok_r(line, \"/\", &saveptr);\n\n    if(addr) {\n      struct in_addr pin;\n      patricia_node_t *node;\n\n      cidr = strtok_r(NULL, \"\\n\", &saveptr);\n\n      pin.s_addr = inet_addr(addr);\n      if((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, cidr ? atoi(cidr) : 32 /* bits */)) != NULL) {\n\tnode->value.uv.user_value = protocol_id, node->value.uv.additional_user_value = 0 /* port */;\n\tnum_loaded++;\n      }\n    }\n  }\n\n  fclose(fd);\n  return(num_loaded);\n}\n\n/* ******************************************* */\n\nstatic void ndpi_init_ptree_ipv4(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t void *ptree, ndpi_network host_list[],\n                                 u_int8_t skip_tor_hosts) {\n  int i;\n\n  for (i = 0; host_list[i].network != 0x0; i++) {\n    struct in_addr pin;\n    patricia_node_t *node;\n\n    if(skip_tor_hosts && (host_list[i].value == NDPI_PROTOCOL_TOR))\n      continue;\n\n    pin.s_addr = htonl(host_list[i].network);\n    if((node = add_to_ptree(ptree, AF_INET, &pin, host_list[i].cidr /* bits */)) != NULL) {\n      node->value.uv.user_value = host_list[i].value, node->value.uv.additional_user_value = 0;\n    }\n  }\n}\n\n/* ******************************************* */\n\nstatic int ndpi_add_host_ip_subprotocol(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\tchar *value, u_int16_t protocol_id) {\n  patricia_node_t *node;\n  struct in_addr pin;\n  int bits = 32;\n  char *ptr = strrchr(value, '/');\n  u_int16_t port = 0; /* Format ip:8.248.73.247:443 */\n  char *double_column;\n\n  if(ptr) {\n    ptr[0] = '\\0';\n    ptr++;\n\n    if((double_column = strrchr(ptr, ':')) != NULL) {\n      double_column[0] = '\\0';\n      port = atoi(&double_column[1]);\n    }\n\n    if(atoi(ptr) >= 0 && atoi(ptr) <= 32)\n      bits = atoi(ptr);\n  } else {\n    /*\n      Let's check if there is the port defined\n      Example: ip:8.248.73.247:443@AmazonPrime\n    */\n    double_column = strrchr(value, ':');\n\n    if(double_column) {\n      double_column[0] = '\\0';\n      port = atoi(&double_column[1]);\n    }\n  }\n\n  inet_pton(AF_INET, value, &pin);\n\n  if((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, bits)) != NULL) {\n    node->value.uv.user_value = protocol_id, node->value.uv.additional_user_value = htons(port);\n  }\n\n  return(0);\n}\n\nvoid set_ndpi_malloc(void *(*__ndpi_malloc)(size_t size)) {\n  _ndpi_malloc = __ndpi_malloc;\n}\nvoid set_ndpi_flow_malloc(void *(*__ndpi_flow_malloc)(size_t size)) {\n  _ndpi_flow_malloc = __ndpi_flow_malloc;\n}\n\nvoid set_ndpi_free(void (*__ndpi_free)(void *ptr)) {\n  _ndpi_free = __ndpi_free;\n}\nvoid set_ndpi_flow_free(void (*__ndpi_flow_free)(void *ptr)) {\n  _ndpi_flow_free = __ndpi_flow_free;\n}\n\nvoid ndpi_debug_printf(unsigned int proto, struct ndpi_detection_module_struct *ndpi_str, ndpi_log_level_t log_level,\n                       const char *file_name, const char *func_name, int line_number, const char *format, ...) {\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n  va_list args;\n#define MAX_STR_LEN 250\n  char str[MAX_STR_LEN];\n  if(ndpi_str != NULL && log_level > NDPI_LOG_ERROR && proto > 0 && proto < NDPI_MAX_SUPPORTED_PROTOCOLS &&\n     !NDPI_ISSET(&ndpi_str->debug_bitmask, proto))\n    return;\n  va_start(args, format);\n  vsnprintf(str, sizeof(str) - 1, format, args);\n  va_end(args);\n\n  if(ndpi_str != NULL) {\n    printf(\"%s:%s:%-3d - [%s]: %s\", file_name, func_name, line_number, ndpi_get_proto_name(ndpi_str, proto), str);\n  } else {\n    printf(\"Proto: %u, %s\", proto, str);\n  }\n#endif\n}\n\nvoid set_ndpi_debug_function(struct ndpi_detection_module_struct *ndpi_str, ndpi_debug_function_ptr ndpi_debug_printf) {\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n  ndpi_str->ndpi_debug_printf = ndpi_debug_printf;\n#endif\n}\n\n/* ****************************************** */\n\n/* Keep it in order and in sync with ndpi_protocol_category_t in ndpi_typedefs.h */\nstatic const char *categories[] = {\n\t\t\t\t   \"Unspecified\",\n\t\t\t\t   \"Media\",\n\t\t\t\t   \"VPN\",\n\t\t\t\t   \"Email\",\n\t\t\t\t   \"DataTransfer\",\n\t\t\t\t   \"Web\",\n\t\t\t\t   \"SocialNetwork\",\n\t\t\t\t   \"Download-FileTransfer-FileSharing\",\n\t\t\t\t   \"Game\",\n\t\t\t\t   \"Chat\",\n\t\t\t\t   \"VoIP\",\n\t\t\t\t   \"Database\",\n\t\t\t\t   \"RemoteAccess\",\n\t\t\t\t   \"Cloud\",\n\t\t\t\t   \"Network\",\n\t\t\t\t   \"Collaborative\",\n\t\t\t\t   \"RPC\",\n\t\t\t\t   \"Streaming\",\n\t\t\t\t   \"System\",\n\t\t\t\t   \"SoftwareUpdate\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"Music\",\n\t\t\t\t   \"Video\",\n\t\t\t\t   \"Shopping\",\n\t\t\t\t   \"Productivity\",\n\t\t\t\t   \"FileSharing\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"\",\n\t\t\t\t   \"Mining\", /* 99 */\n\t\t\t\t   \"Malware\",\n\t\t\t\t   \"Advertisement\",\n\t\t\t\t   \"Banned_Site\",\n\t\t\t\t   \"Site_Unavailable\",\n\t\t\t\t   \"Allowed_Site\",\n\t\t\t\t   \"Antimalware\",\n};\n\n/* ******************************************************************** */\n\nstruct ndpi_detection_module_struct *ndpi_init_detection_module(ndpi_init_prefs prefs) {\n  struct ndpi_detection_module_struct *ndpi_str = ndpi_malloc(sizeof(struct ndpi_detection_module_struct));\n  int i;\n\n  if(ndpi_str == NULL) {\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n    NDPI_LOG_ERR(ndpi_str, \"ndpi_init_detection_module initial malloc failed for ndpi_str\\n\");\n#endif /* NDPI_ENABLE_DEBUG_MESSAGES */\n    return(NULL);\n  }\n\n  memset(ndpi_str, 0, sizeof(struct ndpi_detection_module_struct));\n\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n  set_ndpi_debug_function(ndpi_str, (ndpi_debug_function_ptr) ndpi_debug_printf);\n#endif /* NDPI_ENABLE_DEBUG_MESSAGES */\n\n  if((ndpi_str->protocols_ptree = ndpi_New_Patricia(32 /* IPv4 */)) != NULL)\n    ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, host_protocol_list, prefs & ndpi_dont_load_tor_hosts);\n\n  NDPI_BITMASK_RESET(ndpi_str->detection_bitmask);\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n  ndpi_str->user_data = NULL;\n#endif\n\n  ndpi_str->ticks_per_second = 1000; /* ndpi_str->ticks_per_second */\n  ndpi_str->tcp_max_retransmission_window_size = NDPI_DEFAULT_MAX_TCP_RETRANSMISSION_WINDOW_SIZE;\n  ndpi_str->directconnect_connection_ip_tick_timeout =\n    NDPI_DIRECTCONNECT_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;\n\n  ndpi_str->rtsp_connection_timeout = NDPI_RTSP_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->tvants_connection_timeout = NDPI_TVANTS_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->irc_timeout = NDPI_IRC_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->gnutella_timeout = NDPI_GNUTELLA_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n\n  ndpi_str->battlefield_timeout = NDPI_BATTLEFIELD_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n\n  ndpi_str->thunder_timeout = NDPI_THUNDER_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->yahoo_detect_http_connections = NDPI_YAHOO_DETECT_HTTP_CONNECTIONS;\n\n  ndpi_str->yahoo_lan_video_timeout = NDPI_YAHOO_LAN_VIDEO_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->zattoo_connection_timeout = NDPI_ZATTOO_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->jabber_stun_timeout = NDPI_JABBER_STUN_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->jabber_file_transfer_timeout = NDPI_JABBER_FT_TIMEOUT * ndpi_str->ticks_per_second;\n  ndpi_str->soulseek_connection_ip_tick_timeout =\n    NDPI_SOULSEEK_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;\n\n  ndpi_str->ndpi_num_supported_protocols = NDPI_MAX_SUPPORTED_PROTOCOLS;\n  ndpi_str->ndpi_num_custom_protocols = 0;\n\n  ndpi_str->host_automa.ac_automa = ac_automata_init(ac_match_handler);\n  ndpi_str->content_automa.ac_automa = ac_automata_init(ac_match_handler);\n  ndpi_str->bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);\n  ndpi_str->impossible_bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);\n\n  if((sizeof(categories) / sizeof(char *)) != NDPI_PROTOCOL_NUM_CATEGORIES) {\n    NDPI_LOG_ERR(ndpi_str, \"[NDPI] invalid categories length: expected %u, got %u\\n\", NDPI_PROTOCOL_NUM_CATEGORIES,\n\t\t (unsigned int) (sizeof(categories) / sizeof(char *)));\n    return(NULL);\n  }\n\n  ndpi_str->custom_categories.hostnames.ac_automa = ac_automata_init(ac_match_handler);\n  ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);\n\n  ndpi_str->custom_categories.ipAddresses = ndpi_New_Patricia(32 /* IPv4 */);\n  ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);\n\n  if((ndpi_str->custom_categories.ipAddresses == NULL) || (ndpi_str->custom_categories.ipAddresses_shadow == NULL))\n    return(NULL);\n\n  ndpi_init_protocol_defaults(ndpi_str);\n\n  for (i = 0; i < NUM_CUSTOM_CATEGORIES; i++)\n    snprintf(ndpi_str->custom_category_labels[i], CUSTOM_CATEGORY_LABEL_LEN, \"User custom category %u\",\n\t     (unsigned int) (i + 1));\n\n  return(ndpi_str);\n}\n\n/* *********************************************** */\n\nvoid ndpi_finalize_initalization(struct ndpi_detection_module_struct *ndpi_str) {\n  u_int i;\n\n  for (i = 0; i < 4; i++) {\n    ndpi_automa *automa;\n\n    switch (i) {\n    case 0:\n      automa = &ndpi_str->host_automa;\n      break;\n\n    case 1:\n      automa = &ndpi_str->content_automa;\n      break;\n\n    case 2:\n      automa = &ndpi_str->bigrams_automa;\n      break;\n\n    case 3:\n      automa = &ndpi_str->impossible_bigrams_automa;\n      break;\n\n    default:\n      automa = NULL;\n      break;\n    }\n\n    if(automa) {\n      ac_automata_finalize((AC_AUTOMATA_t *) automa->ac_automa);\n      automa->ac_automa_finalized = 1;\n    }\n  }\n}\n\n/* *********************************************** */\n\n/* Wrappers */\nvoid *ndpi_init_automa(void) {\n  return(ac_automata_init(ac_match_handler));\n}\n\n/* ****************************************************** */\n\nint ndpi_add_string_value_to_automa(void *_automa, char *str, u_int32_t num) {\n  AC_PATTERN_t ac_pattern;\n  AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;\n  AC_ERROR_t rc;\n\n  if(automa == NULL)\n    return(-1);\n\n  memset(&ac_pattern, 0, sizeof(ac_pattern));\n  ac_pattern.astring    = str;\n  ac_pattern.rep.number = num;\n  ac_pattern.length     = strlen(ac_pattern.astring);\n\n  rc = ac_automata_add(automa, &ac_pattern);\n  return(rc == ACERR_SUCCESS || rc == ACERR_DUPLICATE_PATTERN ? 0 : -1);\n}\n\n/* ****************************************************** */\n\nint ndpi_add_string_to_automa(void *_automa, char *str) {\n  return(ndpi_add_string_value_to_automa(_automa, str, 1));\n}\n\n/* ****************************************************** */\n\nvoid ndpi_free_automa(void *_automa) {\n  ac_automata_release((AC_AUTOMATA_t *) _automa, 0);\n}\n\n/* ****************************************************** */\n\nvoid ndpi_finalize_automa(void *_automa) {\n  ac_automata_finalize((AC_AUTOMATA_t *) _automa);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_string(void *_automa, char *string_to_match) {\n  AC_REP_t match = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };\n  AC_TEXT_t ac_input_text;\n  AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;\n  int rc;\n\n  if((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))\n    return(-2);\n\n  ac_input_text.astring = string_to_match, ac_input_text.length = strlen(string_to_match);\n  rc = ac_automata_search(automa, &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  return(rc ? match.number : 0);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_string_protocol_id(void *_automa, char *string_to_match,\n\t\t\t\t  u_int match_len, u_int16_t *protocol_id,\n\t\t\t\t  ndpi_protocol_category_t *category,\n\t\t\t\t  ndpi_protocol_breed_t *breed) {\n  AC_TEXT_t ac_input_text;\n  AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;\n  AC_REP_t match = { 0, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };\n  int rc;\n\n  *protocol_id = (u_int16_t)-1;\n  if((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))\n    return(-2);\n\n  ac_input_text.astring = string_to_match, ac_input_text.length = match_len;\n  rc = ac_automata_search(automa, &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  if(rc)\n    *protocol_id = (u_int16_t)match.number, *category = match.category,\n      *breed = match.breed;\n  else\n    *protocol_id = NDPI_PROTOCOL_UNKNOWN;\n\n  return((*protocol_id != NDPI_PROTOCOL_UNKNOWN) ? 0 : -1);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_string_value(void *_automa, char *string_to_match,\n\t\t\t    u_int match_len, u_int32_t *num) {\n  AC_TEXT_t ac_input_text;\n  AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;\n  AC_REP_t match = { 0, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };\n  int rc;\n\n  *num = (u_int32_t)-1;\n  if((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))\n    return(-2);\n\n  ac_input_text.astring = string_to_match, ac_input_text.length = match_len;\n  rc = ac_automata_search(automa, &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  if(rc)\n    *num = match.number;\n  else\n    *num = 0;\n\n  return(rc ? 0 : -1);\n}\n\n/* *********************************************** */\n\nint ndpi_match_custom_category(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t       char *name, u_int name_len,\n                               ndpi_protocol_category_t *category) {\n  ndpi_protocol_breed_t breed;\n  u_int16_t id;\n  int rc = ndpi_match_string_protocol_id(ndpi_str->custom_categories.hostnames.ac_automa,\n\t\t\t\t\t name, name_len, &id, category, &breed);\n\n  return(rc);\n}\n\n/* *********************************************** */\n\nint ndpi_get_custom_category_match(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t   char *name_or_ip, u_int name_len,\n\t\t\t\t   ndpi_protocol_category_t *id) {\n  char ipbuf[64], *ptr;\n  struct in_addr pin;\n  u_int cp_len = ndpi_min(sizeof(ipbuf) - 1, name_len);\n\n  if(!ndpi_str->custom_categories.categories_loaded)\n    return(-1);\n\n  if(cp_len > 0) {\n    memcpy(ipbuf, name_or_ip, cp_len);\n    ipbuf[cp_len] = '\\0';\n  } else\n    ipbuf[0] = '\\0';\n\n  ptr = strrchr(ipbuf, '/');\n\n  if(ptr)\n    ptr[0] = '\\0';\n\n  if(inet_pton(AF_INET, ipbuf, &pin) == 1) {\n    /* Search IP */\n    prefix_t prefix;\n    patricia_node_t *node;\n\n    /* Make sure all in network byte order otherwise compares wont work */\n    fill_prefix_v4(&prefix, &pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n    node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);\n\n    if(node) {\n      *id = node->value.uv.user_value;\n\n      return(0);\n    }\n\n    return(-1);\n  } else {\n    /* Search Host */\n    return(ndpi_match_custom_category(ndpi_str, name_or_ip, name_len, id));\n  }\n}\n\n/* *********************************************** */\n\nstatic void free_ptree_data(void *data) {\n  ;\n}\n\n/* ****************************************************** */\n\nvoid ndpi_exit_detection_module(struct ndpi_detection_module_struct *ndpi_str) {\n  if(ndpi_str != NULL) {\n    int i;\n\n    for (i = 0; i < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS); i++) {\n      if(ndpi_str->proto_defaults[i].protoName)\n\tndpi_free(ndpi_str->proto_defaults[i].protoName);\n    }\n\n    /* NDPI_PROTOCOL_TINC */\n    if(ndpi_str->tinc_cache)\n      cache_free((cache_t)(ndpi_str->tinc_cache));\n\n    if(ndpi_str->ookla_cache)\n      ndpi_lru_free_cache(ndpi_str->ookla_cache);\n\n    if(ndpi_str->stun_cache)\n      ndpi_lru_free_cache(ndpi_str->stun_cache);\n\n    if(ndpi_str->msteams_cache)\n      ndpi_lru_free_cache(ndpi_str->msteams_cache);\n\n    if(ndpi_str->protocols_ptree)\n      ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->protocols_ptree, free_ptree_data);\n\n    if(ndpi_str->udpRoot != NULL)\n      ndpi_tdestroy(ndpi_str->udpRoot, ndpi_free);\n    if(ndpi_str->tcpRoot != NULL)\n      ndpi_tdestroy(ndpi_str->tcpRoot, ndpi_free);\n\n    if(ndpi_str->host_automa.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->host_automa.ac_automa,\n\t\t\t  1 /* free patterns strings memory */);\n\n    if(ndpi_str->content_automa.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->content_automa.ac_automa, 0);\n\n    if(ndpi_str->bigrams_automa.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->bigrams_automa.ac_automa, 0);\n\n    if(ndpi_str->impossible_bigrams_automa.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->impossible_bigrams_automa.ac_automa, 0);\n\n    if(ndpi_str->custom_categories.hostnames.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,\n\t\t\t  1 /* free patterns strings memory */);\n\n    if(ndpi_str->custom_categories.hostnames_shadow.ac_automa != NULL)\n      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa,\n\t\t\t  1 /* free patterns strings memory */);\n\n    if(ndpi_str->custom_categories.ipAddresses != NULL)\n      ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);\n\n    if(ndpi_str->custom_categories.ipAddresses_shadow != NULL)\n      ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses_shadow, free_ptree_data);\n\n#ifdef CUSTOM_NDPI_PROTOCOLS\n#include \"../../../nDPI-custom/ndpi_exit_detection_module.c\"\n#endif\n\n    ndpi_free(ndpi_str);\n  }\n}\n\n/* ****************************************************** */\n\nint ndpi_get_protocol_id_master_proto(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protocol_id,\n                                      u_int16_t **tcp_master_proto, u_int16_t **udp_master_proto) {\n  if(protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) {\n    *tcp_master_proto = ndpi_str->proto_defaults[NDPI_PROTOCOL_UNKNOWN].master_tcp_protoId,\n      *udp_master_proto = ndpi_str->proto_defaults[NDPI_PROTOCOL_UNKNOWN].master_udp_protoId;\n    return(-1);\n  }\n\n  *tcp_master_proto = ndpi_str->proto_defaults[protocol_id].master_tcp_protoId,\n    *udp_master_proto = ndpi_str->proto_defaults[protocol_id].master_udp_protoId;\n\n  return(0);\n}\n\n/* ****************************************************** */\n\nstatic ndpi_default_ports_tree_node_t *ndpi_get_guessed_protocol_id(struct ndpi_detection_module_struct *ndpi_str,\n                                                                    u_int8_t proto, u_int16_t sport, u_int16_t dport) {\n  ndpi_default_ports_tree_node_t node;\n\n  if(sport && dport) {\n    int low = ndpi_min(sport, dport);\n    int high = ndpi_max(sport, dport);\n    const void *ret;\n\n    node.default_port = low; /* Check server port first */\n    ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,\n\t\t     ndpi_default_ports_tree_node_t_cmp);\n\n    if(ret == NULL) {\n      node.default_port = high;\n      ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,\n\t\t       ndpi_default_ports_tree_node_t_cmp);\n    }\n\n    if(ret)\n      return(*(ndpi_default_ports_tree_node_t **) ret);\n  }\n\n  return(NULL);\n}\n\n/* ****************************************************** */\n\n/*\n  These are UDP protocols that must fit a single packet\n  and thus that if have NOT been detected they cannot be guessed\n  as they have been excluded\n*/\nu_int8_t is_udp_guessable_protocol(u_int16_t l7_guessed_proto) {\n  switch (l7_guessed_proto) {\n  case NDPI_PROTOCOL_QUIC:\n  case NDPI_PROTOCOL_SNMP:\n  case NDPI_PROTOCOL_NETFLOW:\n    /* TODO: add more protocols (if any missing) */\n    return(1);\n  }\n\n  return(0);\n}\n\n/* ****************************************************** */\n\nu_int16_t ndpi_guess_protocol_id(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                 u_int8_t proto, u_int16_t sport, u_int16_t dport, u_int8_t *user_defined_proto) {\n  *user_defined_proto = 0; /* Default */\n\n  if(sport && dport) {\n    ndpi_default_ports_tree_node_t *found = ndpi_get_guessed_protocol_id(ndpi_str, proto, sport, dport);\n\n    if(found != NULL) {\n      u_int16_t guessed_proto = found->proto->protoId;\n\n      /* We need to check if the guessed protocol isn't excluded by nDPI */\n      if(flow && (proto == IPPROTO_UDP) &&\n\t NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, guessed_proto) &&\n\t is_udp_guessable_protocol(guessed_proto))\n\treturn(NDPI_PROTOCOL_UNKNOWN);\n      else {\n\t*user_defined_proto = found->customUserProto;\n\treturn(guessed_proto);\n      }\n    }\n  } else {\n    /* No TCP/UDP */\n\n    switch (proto) {\n    case NDPI_IPSEC_PROTOCOL_ESP:\n    case NDPI_IPSEC_PROTOCOL_AH:\n      return(NDPI_PROTOCOL_IP_IPSEC);\n      break;\n    case NDPI_GRE_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_GRE);\n      break;\n    case NDPI_ICMP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_ICMP);\n      break;\n    case NDPI_IGMP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_IGMP);\n      break;\n    case NDPI_EGP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_EGP);\n      break;\n    case NDPI_SCTP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_SCTP);\n      break;\n    case NDPI_OSPF_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_OSPF);\n      break;\n    case NDPI_IPIP_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_IP_IN_IP);\n      break;\n    case NDPI_ICMPV6_PROTOCOL_TYPE:\n      return(NDPI_PROTOCOL_IP_ICMPV6);\n      break;\n    case 112:\n      return(NDPI_PROTOCOL_IP_VRRP);\n      break;\n    }\n  }\n\n  return(NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ******************************************************************** */\n\nu_int ndpi_get_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  return(ndpi_str->ndpi_num_supported_protocols);\n}\n\n/* ******************************************************************** */\n\n#ifdef WIN32\nchar *strsep(char **sp, char *sep) {\n  char *p, *s;\n  if(sp == NULL || *sp == NULL || **sp == '\\0')\n    return(NULL);\n  s = *sp;\n  p = s + strcspn(s, sep);\n  if(*p != '\\0')\n    *p++ = '\\0';\n  *sp = p;\n  return(s);\n}\n#endif\n\n/* ******************************************************************** */\n\nint ndpi_handle_rule(struct ndpi_detection_module_struct *ndpi_str, char *rule, u_int8_t do_add) {\n  char *at, *proto, *elem;\n  ndpi_proto_defaults_t *def;\n  u_int16_t subprotocol_id, i;\n\n  at = strrchr(rule, '@');\n  if(at == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Invalid rule '%s'\\n\", rule);\n    return(-1);\n  } else\n    at[0] = 0, proto = &at[1];\n\n  for (i = 0; proto[i] != '\\0'; i++) {\n    switch (proto[i]) {\n    case '/':\n    case '&':\n    case '^':\n    case ':':\n    case ';':\n    case '\\'':\n    case '\"':\n    case ' ':\n      proto[i] = '_';\n      break;\n    }\n  }\n\n  for (i = 0, def = NULL; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {\n    if(ndpi_str->proto_defaults[i].protoName && strcasecmp(ndpi_str->proto_defaults[i].protoName, proto) == 0) {\n      def = &ndpi_str->proto_defaults[i];\n      subprotocol_id = i;\n      break;\n    }\n  }\n\n  if(def == NULL) {\n    if(!do_add) {\n      /* We need to remove a rule */\n      NDPI_LOG_ERR(ndpi_str, \"Unable to find protocol '%s': skipping rule '%s'\\n\", proto, rule);\n      return(-3);\n    } else {\n      ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];\n      u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};\n\n      if(ndpi_str->ndpi_num_custom_protocols >= (NDPI_MAX_NUM_CUSTOM_PROTOCOLS - 1)) {\n\tNDPI_LOG_ERR(ndpi_str, \"Too many protocols defined (%u): skipping protocol %s\\n\",\n\t\t     ndpi_str->ndpi_num_custom_protocols, proto);\n\treturn(-2);\n      }\n\n      ndpi_set_proto_defaults(\n\t\t\t      ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, ndpi_str->ndpi_num_supported_protocols,\n\t\t\t      0 /* can_have_a_subprotocol */, no_master, no_master, proto,\n\t\t\t      NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, /* TODO add protocol category support in rules */\n\t\t\t      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n      def = &ndpi_str->proto_defaults[ndpi_str->ndpi_num_supported_protocols];\n      subprotocol_id = ndpi_str->ndpi_num_supported_protocols;\n      ndpi_str->ndpi_num_supported_protocols++, ndpi_str->ndpi_num_custom_protocols++;\n    }\n  }\n\n  while ((elem = strsep(&rule, \",\")) != NULL) {\n    char *attr = elem, *value = NULL;\n    ndpi_port_range range;\n    int is_tcp = 0, is_udp = 0, is_ip = 0;\n\n    if(strncmp(attr, \"tcp:\", 4) == 0)\n      is_tcp = 1, value = &attr[4];\n    else if(strncmp(attr, \"udp:\", 4) == 0)\n      is_udp = 1, value = &attr[4];\n    else if(strncmp(attr, \"ip:\", 3) == 0)\n      is_ip = 1, value = &attr[3];\n    else if(strncmp(attr, \"host:\", 5) == 0) {\n      /* host:\"<value>\",host:\"<value>\",.....@<subproto> */\n      value = &attr[5];\n      if(value[0] == '\"')\n\tvalue++; /* remove leading \" */\n      if(value[strlen(value) - 1] == '\"')\n\tvalue[strlen(value) - 1] = '\\0'; /* remove trailing \" */\n    }\n\n    if(is_tcp || is_udp) {\n      u_int p_low, p_high;\n\n      if(sscanf(value, \"%u-%u\", &p_low, &p_high) == 2)\n\trange.port_low = p_low, range.port_high = p_high;\n      else\n\trange.port_low = range.port_high = atoi(&elem[4]);\n\n      if(do_add)\n\taddDefaultPort(ndpi_str, &range, def, 1 /* Custom user proto */,\n\t\t       is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot, __FUNCTION__, __LINE__);\n      else\n\tremoveDefaultPort(&range, def, is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot);\n    } else if(is_ip) {\n      /* NDPI_PROTOCOL_TOR */\n      ndpi_add_host_ip_subprotocol(ndpi_str, value, subprotocol_id);\n    } else {\n      if(do_add)\n\tndpi_add_host_url_subprotocol(ndpi_str, value, subprotocol_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,\n\t\t\t\t      NDPI_PROTOCOL_ACCEPTABLE);\n      else\n\tndpi_remove_host_url_subprotocol(ndpi_str, value, subprotocol_id);\n    }\n  }\n\n  return(0);\n}\n\n/* ******************************************************************** */\n\n/*\n * Format:\n *\n * <host|ip>\t<category_id>\n *\n * Notes:\n *  - host and category are separated by a single TAB\n *  - empty lines or lines starting with # are ignored\n */\nint ndpi_load_categories_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {\n  char buffer[512], *line, *name, *category, *saveptr;\n  FILE *fd;\n  int len, num = 0;\n\n  fd = fopen(path, \"r\");\n\n  if(fd == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));\n    return(-1);\n  }\n\n  while (1) {\n    line = fgets(buffer, sizeof(buffer), fd);\n\n    if(line == NULL)\n      break;\n\n    len = strlen(line);\n\n    if((len <= 1) || (line[0] == '#'))\n      continue;\n\n    line[len - 1] = '\\0';\n    name = strtok_r(line, \"\\t\", &saveptr);\n\n    if(name) {\n      category = strtok_r(NULL, \"\\t\", &saveptr);\n\n      if(category) {\n\tint rc = ndpi_load_category(ndpi_str, name, (ndpi_protocol_category_t) atoi(category));\n\n\tif(rc >= 0)\n\t  num++;\n      }\n    }\n  }\n\n  fclose(fd);\n  ndpi_enable_loaded_categories(ndpi_str);\n\n  return(num);\n}\n\n/* ******************************************************************** */\n\n/*\n  Format:\n  <tcp|udp>:<port>,<tcp|udp>:<port>,.....@<proto>\n\n  Subprotocols Format:\n  host:\"<value>\",host:\"<value>\",.....@<subproto>\n\n  IP based Subprotocols Format (<value> is IP or CIDR):\n  ip:<value>,ip:<value>,.....@<subproto>\n\n  Example:\n  tcp:80,tcp:3128@HTTP\n  udp:139@NETBIOS\n\n*/\nint ndpi_load_protocols_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {\n  FILE *fd;\n  char *buffer, *old_buffer;\n  int chunk_len = 512, buffer_len = chunk_len, old_buffer_len;\n  int i, rc = -1;\n\n  fd = fopen(path, \"r\");\n\n  if(fd == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));\n    goto error;\n  }\n\n  buffer = ndpi_malloc(buffer_len);\n\n  if(buffer == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");\n    goto close_fd;\n  }\n\n  while (1) {\n    char *line = buffer;\n    int line_len = buffer_len;\n\n    while ((line = fgets(line, line_len, fd)) != NULL && line[strlen(line) - 1] != '\\n') {\n      i = strlen(line);\n      old_buffer = buffer;\n      old_buffer_len = buffer_len;\n      buffer_len += chunk_len;\n\n      buffer = ndpi_realloc(old_buffer, old_buffer_len, buffer_len);\n\n      if(buffer == NULL) {\n\tNDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");\n\tndpi_free(old_buffer);\n\tgoto close_fd;\n      }\n\n      line = &buffer[i];\n      line_len = chunk_len;\n    }\n\n    if(!line) /* safety check */\n      break;\n\n    i = strlen(buffer);\n    if((i <= 1) || (buffer[0] == '#'))\n      continue;\n    else\n      buffer[i - 1] = '\\0';\n\n    ndpi_handle_rule(ndpi_str, buffer, 1);\n  }\n\n  rc = 0;\n\n  ndpi_free(buffer);\n\n close_fd:\n  fclose(fd);\n\n error:\n  return(rc);\n}\n\n/* ******************************************************************** */\n\n/* ntop */\nvoid ndpi_set_bitmask_protocol_detection(char *label, struct ndpi_detection_module_struct *ndpi_str,\n                                         const NDPI_PROTOCOL_BITMASK *detection_bitmask, const u_int32_t idx,\n                                         u_int16_t ndpi_protocol_id,\n                                         void (*func)(struct ndpi_detection_module_struct *,\n                                                      struct ndpi_flow_struct *flow),\n                                         const NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_bitmask,\n                                         u_int8_t b_save_bitmask_unknow, u_int8_t b_add_detection_bitmask) {\n  /*\n    Compare specify protocol bitmask with main detection bitmask\n  */\n  if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(*detection_bitmask, ndpi_protocol_id) != 0) {\n#ifdef DEBUG\n    NDPI_LOG_DBG2(ndpi_str,\n\t\t  \"[NDPI] ndpi_set_bitmask_protocol_detection: %s : [callback_buffer] idx= %u, [proto_defaults] \"\n\t\t  \"protocol_id=%u\\n\",\n\t\t  label, idx, ndpi_protocol_id);\n#endif\n\n    if(ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx != 0) {\n      NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Internal error: protocol %s/%u has been already registered\\n\", label,\n\t\t    ndpi_protocol_id);\n#ifdef DEBUG\n    } else {\n      NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding %s with protocol id %d\\n\", label, ndpi_protocol_id);\n#endif\n    }\n\n    /*\n      Set function and index protocol within proto_default structure for port protocol detection\n      and callback_buffer function for DPI protocol detection\n    */\n    ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx = idx;\n    ndpi_str->proto_defaults[ndpi_protocol_id].func = ndpi_str->callback_buffer[idx].func = func;\n\n    /*\n      Set ndpi_selection_bitmask for protocol\n    */\n    ndpi_str->callback_buffer[idx].ndpi_selection_bitmask = ndpi_selection_bitmask;\n\n    /*\n      Reset protocol detection bitmask via NDPI_PROTOCOL_UNKNOWN and than add specify protocol bitmast to callback\n      buffer.\n    */\n    if(b_save_bitmask_unknow)\n      NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, NDPI_PROTOCOL_UNKNOWN);\n    if(b_add_detection_bitmask)\n      NDPI_ADD_PROTOCOL_TO_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, ndpi_protocol_id);\n\n    NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].excluded_protocol_bitmask, ndpi_protocol_id);\n  }\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_set_protocol_detection_bitmask2(struct ndpi_detection_module_struct *ndpi_str,\n                                          const NDPI_PROTOCOL_BITMASK *dbm) {\n  NDPI_PROTOCOL_BITMASK detection_bitmask_local;\n  NDPI_PROTOCOL_BITMASK *detection_bitmask = &detection_bitmask_local;\n  u_int32_t a = 0;\n\n  NDPI_BITMASK_SET(detection_bitmask_local, *dbm);\n  NDPI_BITMASK_SET(ndpi_str->detection_bitmask, *dbm);\n\n  /* set this here to zero to be interrupt safe */\n  ndpi_str->callback_buffer_size = 0;\n\n  /* HTTP */\n  init_http_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* STARCRAFT */\n  init_starcraft_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TLS */\n  init_tls_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* STUN */\n  init_stun_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RTP */\n  init_rtp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RTSP */\n  init_rtsp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RDP */\n  init_rdp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SIP */\n  init_sip_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IMO */\n  init_imo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Teredo */\n  init_teredo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* EDONKEY */\n  init_edonkey_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FASTTRACK */\n  init_fasttrack_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* GNUTELLA */\n  init_gnutella_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DIRECTCONNECT */\n  init_directconnect_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NATS */\n  init_nats_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* YAHOO */\n  init_yahoo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* OSCAR */\n  init_oscar_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* APPLEJUICE */\n  init_applejuice_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SOULSEEK */\n  init_soulseek_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SOCKS */\n  init_socks_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IRC */\n  init_irc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* JABBER */\n  init_jabber_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MAIL_POP */\n  init_mail_pop_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MAIL_IMAP */\n  init_mail_imap_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MAIL_SMTP */\n  init_mail_smtp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* USENET */\n  init_usenet_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DNS */\n  init_dns_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FILETOPIA */\n  init_fbzero_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* VMWARE */\n  init_vmware_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NON_TCP_UDP */\n  init_non_tcp_udp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TVANTS */\n  init_tvants_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SOPCAST */\n  init_sopcast_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TVUPLAYER */\n  init_tvuplayer_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PPSTREAM */\n  init_ppstream_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PPLIVE */\n  init_pplive_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IAX */\n  init_iax_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MGPC */\n  init_mgpc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ZATTOO */\n  init_zattoo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* QQ */\n  init_qq_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SSH */\n  init_ssh_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AYIYA */\n  init_ayiya_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* THUNDER */\n  init_thunder_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* VNC */\n  init_vnc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TEAMVIEWER */\n  init_teamviewer_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DHCP */\n  init_dhcp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* STEAM */\n  init_steam_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* HALFLIFE2 */\n  init_halflife2_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* XBOX */\n  init_xbox_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* HTTP_APPLICATION_ACTIVESYNC */\n  init_http_activesync_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SMB */\n  init_smb_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MINING */\n  init_mining_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TELNET */\n  init_telnet_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NTP */\n  init_ntp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NFS */\n  init_nfs_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SSDP */\n  init_ssdp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WORLD_OF_WARCRAFT */\n  init_world_of_warcraft_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* POSTGRES */\n  init_postgres_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MYSQL */\n  init_mysql_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* BGP */\n  init_bgp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* BATTLEFIELD */\n  init_battlefield_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PCANYWHERE */\n  init_pcanywhere_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SNMP */\n  init_snmp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* KONTIKI */\n  init_kontiki_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ICECAST */\n  init_icecast_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SHOUTCAST */\n  init_shoutcast_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* KERBEROS */\n  init_kerberos_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* OPENFT */\n  init_openft_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SYSLOG */\n  init_syslog_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DIRECT_DOWNLOAD_LINK */\n  init_directdownloadlink_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NETBIOS */\n  init_netbios_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MDNS */\n  init_mdns_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IPP */\n  init_ipp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* LDAP */\n  init_ldap_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WARCRAFT3 */\n  init_warcraft3_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* XDMCP */\n  init_xdmcp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TFTP */\n  init_tftp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MSSQL_TDS */\n  init_mssql_tds_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PPTP */\n  init_pptp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* STEALTHNET */\n  init_stealthnet_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DHCPV6 */\n  init_dhcpv6_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AFP */\n  init_afp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* check_mk */\n  init_checkmk_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AIMINI */\n  init_aimini_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FLORENSIA */\n  init_florensia_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MAPLESTORY */\n  init_maplestory_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DOFUS */\n  init_dofus_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WORLD_OF_KUNG_FU */\n  init_world_of_kung_fu_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FIESTA */\n  init_fiesta_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CROSSIFIRE */\n  init_crossfire_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* GUILDWARS */\n  init_guildwars_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ARMAGETRON */\n  init_armagetron_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DROPBOX */\n  init_dropbox_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SPOTIFY */\n  init_spotify_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RADIUS */\n  init_radius_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CITRIX */\n  init_citrix_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* LOTUS_NOTES */\n  init_lotus_notes_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* GTP */\n  init_gtp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DCERPC */\n  init_dcerpc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NETFLOW */\n  init_netflow_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SFLOW */\n  init_sflow_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* H323 */\n  init_h323_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* OPENVPN */\n  init_openvpn_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NOE */\n  init_noe_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CISCOVPN */\n  init_ciscovpn_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TEAMSPEAK */\n  init_teamspeak_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TOR */\n  init_tor_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SKINNY */\n  init_skinny_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RTCP */\n  init_rtcp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RSYNC */\n  init_rsync_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WHOIS_DAS */\n  init_whois_das_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ORACLE */\n  init_oracle_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CORBA */\n  init_corba_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RTMP */\n  init_rtmp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FTP_CONTROL */\n  init_ftp_control_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FTP_DATA */\n  init_ftp_data_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* PANDO */\n  init_pando_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MEGACO */\n  init_megaco_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* REDIS */\n  init_redis_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* UPnP */\n  init_upnp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* VHUA */\n  init_vhua_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ZMQ */\n  init_zmq_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TELEGRAM */\n  init_telegram_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* QUIC */\n  init_quic_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DIAMETER */\n  init_diameter_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* APPLE_PUSH */\n  init_apple_push_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* EAQ */\n  init_eaq_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* KAKAOTALK_VOICE */\n  init_kakaotalk_voice_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MPEGTS */\n  init_mpegts_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* UBNTAC2 */\n  init_ubntac2_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* COAP */\n  init_coap_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MQTT */\n  init_mqtt_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SOME/IP */\n  init_someip_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* RX */\n  init_rx_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* GIT */\n  init_git_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* HANGOUT */\n  init_hangout_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* DRDA */\n  init_drda_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* BJNP */\n  init_bjnp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SMPP */\n  init_smpp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* TINC */\n  init_tinc_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* FIX */\n  init_fix_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* NINTENDO */\n  init_nintendo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* MODBUS */\n  init_modbus_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CAPWAP */\n  init_capwap_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* ZABBIX */\n  init_zabbix_dissector(ndpi_str, &a, detection_bitmask);\n\n  /*** Put false-positive sensitive protocols at the end ***/\n\n  /* VIBER */\n  init_viber_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* SKYPE */\n  init_skype_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* BITTORRENT */\n  init_bittorrent_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WHATSAPP */\n  init_whatsapp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* OOKLA */\n  init_ookla_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AMQP */\n  init_amqp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* CSGO */\n  init_csgo_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* LISP */\n  init_lisp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* AJP */\n  init_ajp_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Memcached */\n  init_memcached_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Nest Log Sink */\n  init_nest_log_sink_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WireGuard VPN */\n  init_wireguard_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Amazon_Video */\n  init_amazon_video_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* Targus Getdata */\n  init_targus_getdata_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* S7 comm */\n  init_s7comm_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* IEC 60870-5-104 */\n  init_104_dissector(ndpi_str, &a, detection_bitmask);\n\n  /* WEBSOCKET */\n  init_websocket_dissector(ndpi_str, &a, detection_bitmask);\n\n#ifdef CUSTOM_NDPI_PROTOCOLS\n#include \"../../../nDPI-custom/custom_ndpi_main_init.c\"\n#endif\n\n  /* ----------------------------------------------------------------- */\n\n  ndpi_str->callback_buffer_size = a;\n\n  NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size is %u\\n\", ndpi_str->callback_buffer_size);\n\n  /* now build the specific buffer for tcp, udp and non_tcp_udp */\n  ndpi_str->callback_buffer_size_tcp_payload = 0;\n  ndpi_str->callback_buffer_size_tcp_no_payload = 0;\n  for (a = 0; a < ndpi_str->callback_buffer_size; a++) {\n    if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &\n\t(NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |\n\t NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {\n      if(_ndpi_debug_callbacks)\n\tNDPI_LOG_DBG2(ndpi_str, \"callback_buffer_tcp_payload, adding buffer %u as entry %u\\n\", a,\n\t\t      ndpi_str->callback_buffer_size_tcp_payload);\n\n      memcpy(&ndpi_str->callback_buffer_tcp_payload[ndpi_str->callback_buffer_size_tcp_payload],\n\t     &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));\n      ndpi_str->callback_buffer_size_tcp_payload++;\n\n      if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) ==\n\t 0) {\n\tif(_ndpi_debug_callbacks)\n\t  NDPI_LOG_DBG2(\n                        ndpi_str,\n                        \"\\tcallback_buffer_tcp_no_payload, additional adding buffer %u to no_payload process\\n\", a);\n\n\tmemcpy(&ndpi_str->callback_buffer_tcp_no_payload[ndpi_str->callback_buffer_size_tcp_no_payload],\n\t       &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));\n\tndpi_str->callback_buffer_size_tcp_no_payload++;\n      }\n    }\n  }\n\n  ndpi_str->callback_buffer_size_udp = 0;\n  for (a = 0; a < ndpi_str->callback_buffer_size; a++) {\n    if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &\n\t(NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |\n\t NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {\n      if(_ndpi_debug_callbacks)\n\tNDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size_udp: adding buffer : %u as entry %u\\n\", a,\n\t\t      ndpi_str->callback_buffer_size_udp);\n\n      memcpy(&ndpi_str->callback_buffer_udp[ndpi_str->callback_buffer_size_udp], &ndpi_str->callback_buffer[a],\n\t     sizeof(struct ndpi_call_function_struct));\n      ndpi_str->callback_buffer_size_udp++;\n    }\n  }\n\n  ndpi_str->callback_buffer_size_non_tcp_udp = 0;\n  for (a = 0; a < ndpi_str->callback_buffer_size; a++) {\n    if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &\n\t(NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP |\n\t NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)) == 0 ||\n       (ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC) !=\n       0) {\n      if(_ndpi_debug_callbacks)\n\tNDPI_LOG_DBG2(ndpi_str, \"callback_buffer_non_tcp_udp: adding buffer : %u as entry %u\\n\", a,\n\t\t      ndpi_str->callback_buffer_size_non_tcp_udp);\n\n      memcpy(&ndpi_str->callback_buffer_non_tcp_udp[ndpi_str->callback_buffer_size_non_tcp_udp],\n\t     &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));\n      ndpi_str->callback_buffer_size_non_tcp_udp++;\n    }\n  }\n}\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n/* handle extension headers in IPv6 packets\n * arguments:\n * \tl4ptr: pointer to the byte following the initial IPv6 header\n * \tl4len: the length of the IPv6 packet excluding the IPv6 header\n * \tnxt_hdr: next header value from the IPv6 header\n * result:\n * \tl4ptr: pointer to the start of the actual packet payload\n * \tl4len: length of the actual payload\n * \tnxt_hdr: protocol of the actual payload\n * returns 0 upon success and 1 upon failure\n */\nint ndpi_handle_ipv6_extension_headers(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t **l4ptr,\n                                       u_int16_t *l4len, u_int8_t *nxt_hdr) {\n  while ((*nxt_hdr == 0 || *nxt_hdr == 43 || *nxt_hdr == 44 || *nxt_hdr == 60 || *nxt_hdr == 135 || *nxt_hdr == 59)) {\n    u_int16_t ehdr_len;\n\n    // no next header\n    if(*nxt_hdr == 59) {\n      return(1);\n    }\n    // fragment extension header has fixed size of 8 bytes and the first byte is the next header type\n    if(*nxt_hdr == 44) {\n      if(*l4len < 8) {\n\treturn(1);\n      }\n      *nxt_hdr = (*l4ptr)[0];\n      *l4len -= 8;\n      (*l4ptr) += 8;\n      continue;\n    }\n    // the other extension headers have one byte for the next header type\n    // and one byte for the extension header length in 8 byte steps minus the first 8 bytes\n    if(*l4len < 2) {\n      return(1);\n    }\n    ehdr_len = (*l4ptr)[1];\n    ehdr_len *= 8;\n    ehdr_len += 8;\n\n    if(*l4len < ehdr_len) {\n      return(1);\n    }\n    *nxt_hdr = (*l4ptr)[0];\n    *l4len -= ehdr_len;\n    (*l4ptr) += ehdr_len;\n  }\n  return(0);\n}\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\nstatic u_int8_t ndpi_iph_is_valid_and_not_fragmented(const struct ndpi_iphdr *iph, const u_int16_t ipsize) {\n  //#ifdef REQUIRE_FULL_PACKETS\n  if(ipsize < iph->ihl * 4 || ipsize < ntohs(iph->tot_len) || ntohs(iph->tot_len) < iph->ihl * 4 ||\n     (iph->frag_off & htons(0x1FFF)) != 0) {\n    return(0);\n  }\n  //#endif\n\n  return(1);\n}\n\nstatic u_int8_t ndpi_detection_get_l4_internal(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t *l3,\n                                               u_int16_t l3_len, const u_int8_t **l4_return, u_int16_t *l4_len_return,\n                                               u_int8_t *l4_protocol_return, u_int32_t flags) {\n  const struct ndpi_iphdr *iph = NULL;\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  const struct ndpi_ipv6hdr *iph_v6 = NULL;\n#endif\n  u_int16_t l4len = 0;\n  const u_int8_t *l4ptr = NULL;\n  u_int8_t l4protocol = 0;\n\n  if(l3 == NULL || l3_len < sizeof(struct ndpi_iphdr))\n    return(1);\n\n  if((iph = (const struct ndpi_iphdr *) l3) == NULL)\n    return(1);\n\n  if(iph->version == IPVERSION && iph->ihl >= 5) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");\n  }\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  else if(iph->version == 6 && l3_len >= sizeof(struct ndpi_ipv6hdr)) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");\n    iph_v6 = (const struct ndpi_ipv6hdr *) l3;\n    iph = NULL;\n  }\n#endif\n  else {\n    return(1);\n  }\n\n  if((flags & NDPI_DETECTION_ONLY_IPV6) && iph != NULL) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv4 header found but excluded by flag\\n\");\n    return(1);\n  }\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  else if((flags & NDPI_DETECTION_ONLY_IPV4) && iph_v6 != NULL) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv6 header found but excluded by flag\\n\");\n    return(1);\n  }\n#endif\n\n  if(iph != NULL && ndpi_iph_is_valid_and_not_fragmented(iph, l3_len)) {\n    u_int16_t len = ntohs(iph->tot_len);\n    u_int16_t hlen = (iph->ihl * 4);\n\n    l4ptr = (((const u_int8_t *) iph) + iph->ihl * 4);\n\n    if(len == 0)\n      len = l3_len;\n\n    l4len = (len > hlen) ? (len - hlen) : 0;\n    l4protocol = iph->protocol;\n  }\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  else if(iph_v6 != NULL && (l3_len - sizeof(struct ndpi_ipv6hdr)) >= ntohs(iph_v6->ip6_hdr.ip6_un1_plen)) {\n    l4ptr = (((const u_int8_t *) iph_v6) + sizeof(struct ndpi_ipv6hdr));\n    l4len = ntohs(iph_v6->ip6_hdr.ip6_un1_plen);\n    l4protocol = iph_v6->ip6_hdr.ip6_un1_nxt;\n\n    // we need to handle IPv6 extension headers if present\n    if(ndpi_handle_ipv6_extension_headers(ndpi_str, &l4ptr, &l4len, &l4protocol) != 0) {\n      return(1);\n    }\n\n  }\n#endif\n  else {\n    return(1);\n  }\n\n  if(l4_return != NULL) {\n    *l4_return = l4ptr;\n  }\n\n  if(l4_len_return != NULL) {\n    *l4_len_return = l4len;\n  }\n\n  if(l4_protocol_return != NULL) {\n    *l4_protocol_return = l4protocol;\n  }\n\n  return(0);\n}\n\n/* ************************************************ */\n\nvoid ndpi_apply_flow_protocol_to_packet(struct ndpi_flow_struct *flow, struct ndpi_packet_struct *packet) {\n  memcpy(&packet->detected_protocol_stack, &flow->detected_protocol_stack, sizeof(packet->detected_protocol_stack));\n  memcpy(&packet->protocol_stack_info, &flow->protocol_stack_info, sizeof(packet->protocol_stack_info));\n}\n\n/* ************************************************ */\n\nstatic int ndpi_init_packet_header(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t   struct ndpi_flow_struct *flow,\n                                   unsigned short packetlen) {\n  const struct ndpi_iphdr *decaps_iph = NULL;\n  u_int16_t l3len;\n  u_int16_t l4len;\n  const u_int8_t *l4ptr;\n  u_int8_t l4protocol;\n  u_int8_t l4_result;\n\n  if(!flow)\n    return(1);\n\n  /* reset payload_packet_len, will be set if ipv4 tcp or udp */\n  flow->packet.payload_packet_len = 0;\n  flow->packet.l4_packet_len = 0;\n  flow->packet.l3_packet_len = packetlen;\n\n  flow->packet.tcp = NULL, flow->packet.udp = NULL;\n  flow->packet.generic_l4_ptr = NULL;\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  flow->packet.iphv6 = NULL;\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\n  ndpi_apply_flow_protocol_to_packet(flow, &flow->packet);\n\n  l3len = flow->packet.l3_packet_len;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  if(flow->packet.iph != NULL) {\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\n    decaps_iph = flow->packet.iph;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  }\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\n  if(decaps_iph && decaps_iph->version == IPVERSION && decaps_iph->ihl >= 5) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");\n  }\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  else if(decaps_iph && decaps_iph->version == 6 && l3len >= sizeof(struct ndpi_ipv6hdr) &&\n\t  (ndpi_str->ip_version_limit & NDPI_DETECTION_ONLY_IPV4) == 0) {\n    NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");\n    flow->packet.iphv6 = (struct ndpi_ipv6hdr *) flow->packet.iph;\n    flow->packet.iph = NULL;\n  }\n#endif\n  else {\n    flow->packet.iph = NULL;\n    return(1);\n  }\n\n  /* needed:\n   *  - unfragmented packets\n   *  - ip header <= packet len\n   *  - ip total length >= packet len\n   */\n\n  l4ptr = NULL;\n  l4len = 0;\n  l4protocol = 0;\n\n  l4_result =\n    ndpi_detection_get_l4_internal(ndpi_str, (const u_int8_t *) decaps_iph, l3len, &l4ptr, &l4len, &l4protocol, 0);\n\n  if(l4_result != 0) {\n    return(1);\n  }\n\n  flow->packet.l4_protocol = l4protocol;\n  flow->packet.l4_packet_len = l4len;\n  flow->l4_proto = l4protocol;\n\n  /* tcp / udp detection */\n  if(l4protocol == IPPROTO_TCP && flow->packet.l4_packet_len >= 20 /* min size of tcp */) {\n    /* tcp */\n    flow->packet.tcp = (struct ndpi_tcphdr *) l4ptr;\n    if(flow->packet.l4_packet_len >= flow->packet.tcp->doff * 4) {\n      flow->packet.payload_packet_len = flow->packet.l4_packet_len - flow->packet.tcp->doff * 4;\n      flow->packet.actual_payload_len = flow->packet.payload_packet_len;\n      flow->packet.payload = ((u_int8_t *) flow->packet.tcp) + (flow->packet.tcp->doff * 4);\n\n      /* check for new tcp syn packets, here\n       * idea: reset detection state if a connection is unknown\n       */\n      if(flow->packet.tcp->syn != 0 && flow->packet.tcp->ack == 0 && flow->init_finished != 0 &&\n\t flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {\n\tu_int8_t backup;\n\tu_int16_t backup1, backup2;\n\n\tif(flow->http.url) {\n\t  ndpi_free(flow->http.url);\n\t  flow->http.url = NULL;\n\t}\n\tif(flow->http.content_type) {\n\t  ndpi_free(flow->http.content_type);\n\t  flow->http.content_type = NULL;\n\t}\n\tif(flow->http.user_agent) {\n\t  ndpi_free(flow->http.user_agent);\n\t  flow->http.user_agent = NULL;\n\t}\n\tif(flow->kerberos_buf.pktbuf) {\n\t  ndpi_free(flow->kerberos_buf.pktbuf);\n\t  flow->kerberos_buf.pktbuf = NULL;\n\t}\n\tif(flow->l4.tcp.tls.message.buffer) {\n\t  ndpi_free(flow->l4.tcp.tls.message.buffer);\n\t  flow->l4.tcp.tls.message.buffer = NULL;\n\t  flow->l4.tcp.tls.message.buffer_len = flow->l4.tcp.tls.message.buffer_used = 0;\n\t}\n\n\tbackup = flow->num_processed_pkts;\n\tbackup1 = flow->guessed_protocol_id;\n\tbackup2 = flow->guessed_host_protocol_id;\n\tmemset(flow, 0, sizeof(*(flow)));\n\tflow->num_processed_pkts = backup;\n\tflow->guessed_protocol_id = backup1;\n\tflow->guessed_host_protocol_id = backup2;\n\n\tNDPI_LOG_DBG(ndpi_str, \"tcp syn packet for unknown protocol, reset detection state\\n\");\n      }\n    } else {\n      /* tcp header not complete */\n      flow->packet.tcp = NULL;\n    }\n  } else if(l4protocol == IPPROTO_UDP && flow->packet.l4_packet_len >= 8 /* size of udp */) {\n    flow->packet.udp = (struct ndpi_udphdr *) l4ptr;\n    flow->packet.payload_packet_len = flow->packet.l4_packet_len - 8;\n    flow->packet.payload = ((u_int8_t *) flow->packet.udp) + 8;\n  } else {\n    flow->packet.generic_l4_ptr = l4ptr;\n  }\n\n  return(0);\n}\n\n/* ************************************************ */\n\nvoid ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t      struct ndpi_flow_struct *flow) {\n  if(!flow) {\n    return;\n  } else {\n    /* const for gcc code optimization and cleaner code */\n    struct ndpi_packet_struct *packet = &flow->packet;\n    const struct ndpi_iphdr *iph = packet->iph;\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n    const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;\n#endif\n    const struct ndpi_tcphdr *tcph = packet->tcp;\n    const struct ndpi_udphdr *udph = flow->packet.udp;\n\n    packet->tcp_retransmission = 0, packet->packet_direction = 0;\n\n    if(ndpi_str->direction_detect_disable) {\n      packet->packet_direction = flow->packet_direction;\n    } else {\n      if(iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))\n\tpacket->packet_direction = 1;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n      if(iphv6 != NULL && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)\n\tpacket->packet_direction = 1;\n#endif\n    }\n\n    packet->packet_lines_parsed_complete = 0;\n\n    if(flow->init_finished == 0) {\n      flow->init_finished = 1;\n      flow->setup_packet_direction = packet->packet_direction;\n    }\n\n    if(tcph != NULL) {\n      /* reset retried bytes here before setting it */\n      packet->num_retried_bytes = 0;\n\n      if(!ndpi_str->direction_detect_disable)\n\tpacket->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;\n\n      if(tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&\n\t flow->l4.tcp.seen_ack == 0) {\n\tflow->l4.tcp.seen_syn = 1;\n      }\n      if(tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&\n\t flow->l4.tcp.seen_ack == 0) {\n\tflow->l4.tcp.seen_syn_ack = 1;\n      }\n      if(tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&\n\t flow->l4.tcp.seen_ack == 0) {\n\tflow->l4.tcp.seen_ack = 1;\n      }\n      if((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||\n\t (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {\n\t/* initialize tcp sequence counters */\n\t/* the ack flag needs to be set to get valid sequence numbers from the other\n\t * direction. Usually it will catch the second packet syn+ack but it works\n\t * also for asymmetric traffic where it will use the first data packet\n\t *\n\t * if the syn flag is set add one to the sequence number,\n\t * otherwise use the payload length.\n\t */\n\tif(tcph->ack != 0) {\n\t  flow->next_tcp_seq_nr[flow->packet.packet_direction] =\n\t    ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);\n\n\t  flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);\n\t}\n      } else if(packet->payload_packet_len > 0) {\n\t/* check tcp sequence counters */\n\tif(((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >\n\t   ndpi_str->tcp_max_retransmission_window_size) {\n\t  packet->tcp_retransmission = 1;\n\n\t  /* CHECK IF PARTIAL RETRY IS HAPPENING */\n\t  if((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <\n\t      packet->payload_packet_len)) {\n\t    /* num_retried_bytes actual_payload_len hold info about the partial retry\n\t       analyzer which require this info can make use of this info\n\t       Other analyzer can use packet->payload_packet_len */\n\t    packet->num_retried_bytes =\n\t      (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));\n\t    packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;\n\t    flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;\n\t  }\n\t}\n\n\t/* normal path\n\t   actual_payload_len is initialized to payload_packet_len during tcp header parsing itself.\n\t   It will be changed only in case of retransmission */\n\telse {\n\t  packet->num_retried_bytes = 0;\n\t  flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;\n\t}\n      }\n\n      if(tcph->rst) {\n\tflow->next_tcp_seq_nr[0] = 0;\n\tflow->next_tcp_seq_nr[1] = 0;\n      }\n    } else if(udph != NULL) {\n      if(!ndpi_str->direction_detect_disable)\n\tpacket->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;\n    }\n\n    if(flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {\n      flow->packet_counter++;\n    }\n\n    if(flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&\n       packet->payload_packet_len) {\n      flow->packet_direction_counter[packet->packet_direction]++;\n    }\n\n    if(flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >\n       flow->byte_counter[packet->packet_direction]) {\n      flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;\n    }\n  }\n}\n\n/* ************************************************ */\n\nvoid check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {\n  if(!flow)\n    return;\n\n  void *func = NULL;\n  u_int32_t a;\n  u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;\n  int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;\n  NDPI_PROTOCOL_BITMASK detection_bitmask;\n\n  NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);\n\n  if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&\n     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t  ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&\n     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&\n     (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n     ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {\n    if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n       (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))\n      ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),\n\tfunc = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;\n  }\n\n  for (a = 0; a < ndpi_str->callback_buffer_size_non_tcp_udp; a++) {\n    if((func != ndpi_str->callback_buffer_non_tcp_udp[a].func) &&\n       (ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n       ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask &&\n       NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t    ndpi_str->callback_buffer_non_tcp_udp[a].excluded_protocol_bitmask) == 0 &&\n       NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_non_tcp_udp[a].detection_bitmask, detection_bitmask) != 0) {\n      if(ndpi_str->callback_buffer_non_tcp_udp[a].func != NULL)\n\tndpi_str->callback_buffer_non_tcp_udp[a].func(ndpi_str, flow);\n\n      if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)\n\tbreak; /* Stop after detecting the first protocol */\n    }\n  }\n}\n\n/* ************************************************ */\n\nvoid check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                              NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {\n  void *func = NULL;\n  u_int32_t a;\n  u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;\n  int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;\n  NDPI_PROTOCOL_BITMASK detection_bitmask;\n\n  NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);\n\n  if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&\n     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t  ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&\n     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&\n     (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n     ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {\n    if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n       (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))\n      ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),\n\tfunc = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;\n  }\n\n  if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {\n    for (a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {\n      if((func != ndpi_str->callback_buffer_udp[a].func) &&\n\t (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n\t ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask &&\n\t NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t      ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0 &&\n\t NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask, detection_bitmask) != 0) {\n\tndpi_str->callback_buffer_udp[a].func(ndpi_str, flow);\n\n\t// NDPI_LOG_DBG(ndpi_str, \"[UDP,CALL] dissector of protocol as callback_buffer idx =  %d\\n\",a);\n\tif(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)\n\t  break; /* Stop after detecting the first protocol */\n      } else if(_ndpi_debug_callbacks)\n\tNDPI_LOG_DBG2(ndpi_str, \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\", a);\n    }\n  }\n}\n\n/* ************************************************ */\n\nvoid check_ndpi_tcp_flow_func(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t      struct ndpi_flow_struct *flow,\n                              NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {\n  void *func = NULL;\n  u_int32_t a;\n  u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;\n  int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;\n  NDPI_PROTOCOL_BITMASK detection_bitmask;\n\n  NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);\n\n  if(flow->packet.payload_packet_len != 0) {\n    if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&\n       NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t    ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&\n       NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&\n       (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n       ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {\n      if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n\t (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))\n\tndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),\n\t  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;\n    }\n\n    if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {\n      for (a = 0; a < ndpi_str->callback_buffer_size_tcp_payload; a++) {\n\tif((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&\n\t   (ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n\t   ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask &&\n\t   NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t\tndpi_str->callback_buffer_tcp_payload[a].excluded_protocol_bitmask) == 0 &&\n\t   NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_payload[a].detection_bitmask,\n\t\t\t\tdetection_bitmask) != 0) {\n\t  ndpi_str->callback_buffer_tcp_payload[a].func(ndpi_str, flow);\n\n\t  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)\n\t    break; /* Stop after detecting the first protocol */\n\t}\n      }\n    }\n  } else {\n    /* no payload */\n    if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&\n       NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t    ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&\n       NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&\n       (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n       ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {\n      if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n\t (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL) &&\n\t ((ndpi_str->callback_buffer[flow->guessed_protocol_id].ndpi_selection_bitmask &\n\t   NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0))\n\tndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),\n\t  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;\n    }\n\n    for (a = 0; a < ndpi_str->callback_buffer_size_tcp_no_payload; a++) {\n      if((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&\n\t (ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==\n\t ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask &&\n\t NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t      ndpi_str->callback_buffer_tcp_no_payload[a].excluded_protocol_bitmask) == 0 &&\n\t NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_no_payload[a].detection_bitmask,\n\t\t\t      detection_bitmask) != 0) {\n\tndpi_str->callback_buffer_tcp_no_payload[a].func(ndpi_str, flow);\n\n\tif(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)\n\t  break; /* Stop after detecting the first protocol */\n      }\n    }\n  }\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_check_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                          NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {\n  if(flow->packet.tcp != NULL)\n    check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet);\n  else if(flow->packet.udp != NULL)\n    check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet);\n  else\n    check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet);\n}\n\n/* ********************************************************************************* */\n\nu_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t      struct ndpi_flow_struct *flow) {\n  u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;\n\n  if(flow->packet.iph) {\n    struct in_addr addr;\n    u_int16_t sport, dport;\n\n    addr.s_addr = flow->packet.iph->saddr;\n\n    if((flow->l4_proto == IPPROTO_TCP) && flow->packet.tcp)\n      sport = flow->packet.tcp->source, dport = flow->packet.tcp->dest;\n    else if((flow->l4_proto == IPPROTO_UDP) && flow->packet.udp)\n      sport = flow->packet.udp->source, dport = flow->packet.udp->dest;\n    else\n      sport = dport = 0;\n\n    /* guess host protocol */\n    ret = ndpi_network_port_ptree_match(ndpi_str, &addr, sport);\n\n    if(ret == NDPI_PROTOCOL_UNKNOWN) {\n      addr.s_addr = flow->packet.iph->daddr;\n      ret = ndpi_network_port_ptree_match(ndpi_str, &addr, dport);\n    }\n  }\n\n  return(ret);\n}\n\n/* ********************************************************************************* */\n\nndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                    u_int8_t enable_guess, u_int8_t *protocol_was_guessed) {\n  ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};\n\n  *protocol_was_guessed = 0;\n\n  if(flow == NULL)\n    return(ret);\n\n  /* Init defaults */\n  ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];\n  ret.category = flow->category;\n\n  /* Ensure that we don't change our mind if detection is already complete */\n  if((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))\n    return(ret);\n\n  /* TODO: add the remaining stage_XXXX protocols */\n  if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {\n    u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN, guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;\n\n    if(flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)\n      goto check_stun_export;\n    else if((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO) ||\n\t    (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER) ||\n\t    (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL)) {\n      *protocol_was_guessed = 1;\n      ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);\n    }\n    else if((flow->l4.tcp.tls.hello_processed == 1) &&\n\t    (flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0')) {\n      *protocol_was_guessed = 1;\n      ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);\n    } else if(enable_guess) {\n      if((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN) && (flow->packet.l4_protocol == IPPROTO_TCP) &&\n\t flow->l4.tcp.tls.hello_processed)\n\tflow->guessed_protocol_id = NDPI_PROTOCOL_TLS;\n\n      guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;\n\n      if((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n\t ((flow->packet.l4_protocol == IPPROTO_UDP) &&\n\t  NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id) &&\n\t  is_udp_guessable_protocol(guessed_host_protocol_id)))\n\tflow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;\n\n      /* Ignore guessed protocol if they have been discarded */\n      if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)\n\t // && (guessed_host_protocol_id == NDPI_PROTOCOL_UNKNOWN)\n\t && (flow->packet.l4_protocol == IPPROTO_UDP) &&\n\t NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id) &&\n\t is_udp_guessable_protocol(guessed_protocol_id))\n\tflow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;\n\n      if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {\n\tif((guessed_protocol_id == 0) && (flow->protos.stun_ssl.stun.num_binding_requests > 0) &&\n\t   (flow->protos.stun_ssl.stun.num_processed_pkts > 0))\n\t  guessed_protocol_id = NDPI_PROTOCOL_STUN;\n\n\tif(flow->host_server_name[0] != '\\0') {\n\t  ndpi_protocol_match_result ret_match;\n\n\t  memset(&ret_match, 0, sizeof(ret_match));\n\n\t  ndpi_match_host_subprotocol(ndpi_str, flow, (char *) flow->host_server_name,\n\t\t\t\t      strlen((const char *) flow->host_server_name), &ret_match,\n\t\t\t\t      NDPI_PROTOCOL_DNS);\n\n\t  if(ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)\n\t    guessed_host_protocol_id = ret_match.protocol_id;\n\t}\n\n\t*protocol_was_guessed = 1;\n\tndpi_int_change_protocol(ndpi_str, flow, guessed_host_protocol_id, guessed_protocol_id);\n      }\n    }\n  } else if(enable_guess) {\n    if(flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n      *protocol_was_guessed = 1;\n      flow->detected_protocol_stack[1] = flow->guessed_protocol_id;\n    }\n\n    if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n      *protocol_was_guessed = 1;\n      flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;\n    }\n\n    if(flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0]) {\n      *protocol_was_guessed = 1;\n      flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;\n    }\n  }\n\n  if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) &&\n     (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {\n  check_stun_export:\n    if(flow->protos.stun_ssl.stun.num_processed_pkts || flow->protos.stun_ssl.stun.num_udp_pkts) {\n      // if(/* (flow->protos.stun_ssl.stun.num_processed_pkts >= NDPI_MIN_NUM_STUN_DETECTION) */\n      *protocol_was_guessed = 1;\n      ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_STUN);\n    }\n  }\n\n  ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];\n\n  if(ret.master_protocol == NDPI_PROTOCOL_STUN) {\n    if(ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)\n      ret.app_protocol = NDPI_PROTOCOL_MESSENGER;\n    else if(ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {\n      /*\n\tAs Google has recently introduced Duo,\n\twe need to distinguish between it and hangout\n\tthing that should be handled by the STUN dissector\n      */\n      ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;\n    }\n  }\n\n  if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) {\n    *protocol_was_guessed = 1;\n    ndpi_fill_protocol_category(ndpi_str, flow, &ret);\n  }\n\n  return(ret);\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                               const unsigned char *packet, const unsigned short packetlen,\n                               const u_int64_t current_tick_l, struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {\n  if(flow == NULL)\n    return;\n\n  if(flow->server_id == NULL)\n    flow->server_id = dst; /* Default */\n\n  /* need at least 20 bytes for ip header */\n  if(packetlen < 20) {\n    return;\n  }\n\n  flow->packet.tick_timestamp_l = current_tick_l;\n  flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);\n\n  /* parse packet */\n  flow->packet.iph = (struct ndpi_iphdr *) packet;\n  /* we are interested in ipv4 packet */\n\n  /* set up the packet headers for the extra packet function to use if it wants */\n  if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)\n    return;\n\n  /* detect traffic for tcp or udp only */\n  flow->src = src, flow->dst = dst;\n  ndpi_connection_tracking(ndpi_str, flow);\n\n  /* call the extra packet function (which may add more data/info to flow) */\n  if(flow->extra_packets_func) {\n    if((flow->extra_packets_func(ndpi_str, flow)) == 0)\n      flow->check_extra_packets = 0;\n\n    if(++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)\n      flow->extra_packets_func = NULL; /* Enough packets detected */\n  }\n}\n\n/* ********************************************************************************* */\n\nint ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str, const char *ip_address_and_mask,\n                          ndpi_protocol_category_t category) {\n  patricia_node_t *node;\n  struct in_addr pin;\n  int bits = 32;\n  char *ptr;\n  char ipbuf[64];\n\n  strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));\n  ipbuf[sizeof(ipbuf) - 1] = '\\0';\n\n  ptr = strrchr(ipbuf, '/');\n\n  if(ptr) {\n    *(ptr++) = '\\0';\n    if(atoi(ptr) >= 0 && atoi(ptr) <= 32)\n      bits = atoi(ptr);\n  }\n\n  if(inet_pton(AF_INET, ipbuf, &pin) != 1) {\n    NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);\n    return(-1);\n  }\n\n  if((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow, AF_INET, &pin, bits)) != NULL) {\n    node->value.uv.user_value = (u_int16_t)category, node->value.uv.additional_user_value = 0;\n  }\n\n  return(0);\n}\n\n\n/* ********************************************************************************* */\n\nint ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str, const char *name_to_add,\n                                ndpi_protocol_category_t category) {\n  char *name;\n\n  if(name_to_add == NULL)\n    return(-1);\n\n  name = ndpi_strdup(name_to_add);\n\n  if(name == NULL)\n    return(-1);\n\n#if 0\n  printf(\"===> %s() Loading %s as %u\\n\", __FUNCTION__, name, category);\n#endif\n\n  AC_PATTERN_t ac_pattern;\n  AC_ERROR_t rc;\n\n  memset(&ac_pattern, 0, sizeof(ac_pattern));\n\n  if(ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {\n    free(name);\n    return(-1);\n  }\n\n  ac_pattern.astring = name, ac_pattern.length = strlen(ac_pattern.astring);\n  ac_pattern.rep.number = (u_int32_t) category,  ac_pattern.rep.category = category;;\n\n  rc = ac_automata_add(ndpi_str->custom_categories.hostnames_shadow.ac_automa, &ac_pattern);\n  if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS) {\n    free(name);\n    return(-1);\n  }\n\n  if(rc == ACERR_DUPLICATE_PATTERN)\n    free(name);\n\n  return(0);\n}\n\n/* ********************************************************************************* */\n\n/* Loads an IP or name category */\nint ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct, const char *ip_or_name,\n                       ndpi_protocol_category_t category) {\n  int rv;\n\n  /* Try to load as IP address first */\n  rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);\n\n  if(rv < 0) {\n    /* IP load failed, load as hostname */\n    rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);\n  }\n\n  return(rv);\n}\n\n/* ********************************************************************************* */\n\nint ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str) {\n  int i;\n\n  /* First add the nDPI known categories matches */\n  for (i = 0; category_match[i].string_to_match != NULL; i++)\n    ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);\n\n  /* Free */\n  ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,\n\t\t      1 /* free patterns strings memory */);\n\n  /* Finalize */\n  ac_automata_finalize((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa);\n\n  /* Swap */\n  ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;\n\n  /* Realloc */\n  ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);\n\n  if(ndpi_str->custom_categories.ipAddresses != NULL)\n    ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);\n\n  ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;\n  ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);\n\n  ndpi_str->custom_categories.categories_loaded = 1;\n\n  return(0);\n}\n\n/* ********************************************************************************* */\n\nint ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_str, u_int32_t saddr, u_int32_t daddr,\n                                   ndpi_protocol *ret) {\n  if(ndpi_str->custom_categories.categories_loaded) {\n    prefix_t prefix;\n    patricia_node_t *node;\n\n    if(saddr == 0)\n      node = NULL;\n    else {\n      /* Make sure all in network byte order otherwise compares wont work */\n      fill_prefix_v4(&prefix, (struct in_addr *) &saddr, 32,\n\t\t     ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n      node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);\n    }\n\n    if(!node) {\n      if(daddr != 0) {\n\tfill_prefix_v4(&prefix, (struct in_addr *) &daddr, 32,\n\t\t       ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);\n\tnode = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);\n      }\n    }\n\n    if(node) {\n      ret->category = (ndpi_protocol_category_t) node->value.uv.user_value;\n\n      return(1);\n    }\n  }\n\n  ret->category = ndpi_get_proto_category(ndpi_str, *ret);\n\n  return(0);\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                 ndpi_protocol *ret) {\n  if(ndpi_str->custom_categories.categories_loaded) {\n    if(flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {\n      flow->category = ret->category = flow->guessed_header_category;\n      return;\n    }\n\n    if(flow->host_server_name[0] != '\\0') {\n      u_int32_t id;\n      int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->host_server_name,\n\t\t\t\t\t  strlen((char *) flow->host_server_name), &id);\n\n      if(rc == 0) {\n\tflow->category = ret->category = (ndpi_protocol_category_t) id;\n\treturn;\n      }\n    }\n\n    if(flow->l4.tcp.tls.hello_processed == 1 &&\n       flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0') {\n      u_int32_t id;\n      int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->protos.stun_ssl.ssl.client_requested_server_name,\n\t\t\t\t\t  strlen(flow->protos.stun_ssl.ssl.client_requested_server_name), &id);\n\n      if(rc == 0) {\n\tflow->category = ret->category = (ndpi_protocol_category_t) id;\n\treturn;\n      }\n    }\n  }\n\n  flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);\n}\n\n/* ********************************************************************************* */\n\nstatic void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}\n\n/* ********************************************************************************* */\n\nstatic void ndpi_reconcile_protocols(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t    struct ndpi_flow_struct *flow,\n\t\t\t\t    ndpi_protocol *ret) {\n  /*\n     Skype for a host doing MS Teams means MS Teams\n     (MS Teams uses Skype as transport protocol for voice/video)\n  */\n\n  switch(ret->app_protocol) {\n  case NDPI_PROTOCOL_MSTEAMS:\n    if(flow->packet.iph && flow->packet.tcp) {\n      // printf(\"====>> NDPI_PROTOCOL_MSTEAMS\\n\");\n\n      if(ndpi_str->msteams_cache == NULL)\n\tndpi_str->msteams_cache = ndpi_lru_cache_init(1024);\n\n      if(ndpi_str->msteams_cache)\n\tndpi_lru_add_to_cache(ndpi_str->msteams_cache,\n\t\t\t      flow->packet.iph->saddr,\n\t\t\t      flow->packet.tick_timestamp & 0xFFFF /* 16 bit */);\n    }\n    break;\n\n  case NDPI_PROTOCOL_SKYPE:\n  case NDPI_PROTOCOL_SKYPE_CALL:\n    if(flow->packet.iph\n       && flow->packet.udp\n       && ndpi_str->msteams_cache) {\n      u_int16_t when;\n\n      if(ndpi_lru_find_cache(ndpi_str->msteams_cache, flow->packet.iph->saddr,\n\t\t\t     &when, 0 /* Don't remove it as it can be used for other connections */)) {\n\tu_int16_t tdiff = (flow->packet.tick_timestamp & 0xFFFF) - when;\n\n\tif(tdiff < 60 /* sec */) {\n\t  // printf(\"====>> NDPI_PROTOCOL_SKYPE(_CALL) -> NDPI_PROTOCOL_MSTEAMS [%u]\\n\", tdiff);\n\t  ret->app_protocol = NDPI_PROTOCOL_MSTEAMS;\n\n\t  /* Refresh cache */\n\t  ndpi_lru_add_to_cache(ndpi_str->msteams_cache,\n\t\t\t\tflow->packet.iph->saddr,\n\t\t\t\tflow->packet.tick_timestamp & 0xFFFF /* 16 bit */);\n\t}\n      }\n    }\n    break;\n  } /* switch */\n}\n\n/* ********************************************************************************* */\n\nndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,\n                                            struct ndpi_flow_struct *flow, const unsigned char *packet,\n                                            const unsigned short packetlen, const u_int64_t current_tick_l,\n                                            struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {\n  NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;\n  u_int32_t a;\n  ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};\n\n  if(ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)\n    NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,\n\t     \"START packet processing\\n\");\n\n  if(flow == NULL)\n    return(ret);\n  else\n    ret.category = flow->category;\n\n  flow->num_processed_pkts++;\n\n  /* Init default */\n  ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];\n\n  if(flow->server_id == NULL)\n    flow->server_id = dst; /* Default */\n\n  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN) {\n    if(flow->check_extra_packets) {\n      ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_tick_l, src, dst);\n      /* Update in case of new match */\n      ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0],\n\tret.category = flow->category;\n      goto invalidate_ptr;\n    } else\n      goto ret_protocols;\n  }\n\n  /* need at least 20 bytes for ip header */\n  if(packetlen < 20) {\n    /* reset protocol which is normally done in init_packet_header */\n    ndpi_int_reset_packet_protocol(&flow->packet);\n    goto invalidate_ptr;\n  }\n\n  flow->packet.tick_timestamp_l = current_tick_l;\n  flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);\n\n  /* parse packet */\n  flow->packet.iph = (struct ndpi_iphdr *) packet;\n  /* we are interested in ipv4 packet */\n\n  if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)\n    goto invalidate_ptr;\n\n  /* detect traffic for tcp or udp only */\n  flow->src = src, flow->dst = dst;\n\n  ndpi_connection_tracking(ndpi_str, flow);\n\n  /* build ndpi_selection packet bitmask */\n  ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;\n  if(flow->packet.iph != NULL)\n    ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;\n\n  if(flow->packet.tcp != NULL)\n    ndpi_selection_packet |=\n      (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);\n\n  if(flow->packet.udp != NULL)\n    ndpi_selection_packet |=\n      (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);\n\n  if(flow->packet.payload_packet_len != 0)\n    ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;\n\n  if(flow->packet.tcp_retransmission == 0)\n    ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  if(flow->packet.iphv6 != NULL)\n    ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;\n#endif /* NDPI_DETECTION_SUPPORT_IPV6 */\n\n  if((!flow->protocol_id_already_guessed) && (\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\t\t\t\t\t      flow->packet.iphv6 ||\n#endif\n\t\t\t\t\t      flow->packet.iph)) {\n    u_int16_t sport, dport;\n    u_int8_t protocol;\n    u_int8_t user_defined_proto;\n\n    flow->protocol_id_already_guessed = 1;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n    if(flow->packet.iphv6 != NULL) {\n      protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;\n    } else\n#endif\n      {\n\tprotocol = flow->packet.iph->protocol;\n      }\n\n    if(flow->packet.udp)\n      sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);\n    else if(flow->packet.tcp)\n      sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);\n    else\n      sport = dport = 0;\n\n    /* guess protocol */\n    flow->guessed_protocol_id =\n      (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);\n    flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);\n\n    if(ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {\n      ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, &ret);\n      flow->guessed_header_category = ret.category;\n    } else\n      flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;\n\n    if(flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {\n      /* This is a custom protocol and it has priority over everything else */\n      ret.master_protocol = NDPI_PROTOCOL_UNKNOWN,\n\tret.app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;\n      ndpi_fill_protocol_category(ndpi_str, flow, &ret);\n      goto invalidate_ptr;\n    }\n\n    if(user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n      if(flow->packet.iph) {\n\tif(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n\t  u_int8_t protocol_was_guessed;\n\n\t  /* ret.master_protocol = flow->guessed_protocol_id , ret.app_protocol = flow->guessed_host_protocol_id; /\\* ****** *\\/ */\n\t  ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);\n\t}\n\n\tndpi_fill_protocol_category(ndpi_str, flow, &ret);\n\tgoto invalidate_ptr;\n      }\n    } else {\n      /* guess host protocol */\n      if(flow->packet.iph) {\n\n\tflow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);\n\n\t/*\n\t  We could implement a shortcut here skipping dissectors for\n\t  protocols we have identified by other means such as with the IP\n\n\t  However we do NOT stop here and skip invoking the dissectors\n\t  because we want to dissect the flow (e.g. dissect the TLS)\n\t  and extract metadata.\n\t*/\n#if SKIP_INVOKING_THE_DISSECTORS\n\tif(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {\n\t  /*\n\t    We have identified a protocol using the IP address so\n\t    it is not worth to dissect the traffic as we already have\n\t    the solution\n\t  */\n\t  ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;\n\t}\n#endif\n      }\n    }\n  }\n\n  if(flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {\n    /* This is a custom protocol and it has priority over everything else */\n    ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;\n\n    ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);\n    ndpi_fill_protocol_category(ndpi_str, flow, &ret);\n    goto invalidate_ptr;\n  }\n\n  ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);\n\n  a = flow->packet.detected_protocol_stack[0];\n  if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)\n    a = NDPI_PROTOCOL_UNKNOWN;\n\n  if(a != NDPI_PROTOCOL_UNKNOWN) {\n    int i;\n\n    for (i = 0; i < sizeof(flow->host_server_name); i++) {\n      if(flow->host_server_name[i] != '\\0')\n\tflow->host_server_name[i] = tolower(flow->host_server_name[i]);\n      else {\n\tflow->host_server_name[i] = '\\0';\n\tbreak;\n      }\n    }\n  }\n\n ret_protocols:\n  if(flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {\n    ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];\n\n    if(ret.app_protocol == ret.master_protocol)\n      ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;\n  } else\n    ret.app_protocol = flow->detected_protocol_stack[0];\n\n  /* Don't overwrite the category if already set */\n  if((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))\n    ndpi_fill_protocol_category(ndpi_str, flow, &ret);\n  else\n    ret.category = flow->category;\n\n  if((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&\n     (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&\n     (flow->guessed_protocol_id == 0)) {\n    u_int8_t protocol_was_guessed;\n\n    /*\n      This is a TCP flow\n      - whose first packet is NOT a SYN\n      - no protocol has been detected\n\n      We don't see how future packets can match anything\n      hence we giveup here\n    */\n    ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);\n  }\n\n  if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&\n     (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {\n    ret.master_protocol = ret.app_protocol;\n    ret.app_protocol = flow->guessed_host_protocol_id;\n  }\n\n  if((!flow->risk_checked) && (ret.master_protocol != NDPI_PROTOCOL_UNKNOWN)) {\n    ndpi_default_ports_tree_node_t *found;\n    u_int16_t *default_ports, sport, dport;\n\n    if(flow->packet.udp)\n      found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_UDP,\n\t\t\t\t\t   sport = ntohs(flow->packet.udp->source),\n\t\t\t\t\t   dport = ntohs(flow->packet.udp->dest)),\n\tdefault_ports = ndpi_str->proto_defaults[ret.master_protocol].udp_default_ports;\n    else if(flow->packet.tcp)\n      found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_TCP,\n\t\t\t\t\t   sport = ntohs(flow->packet.tcp->source),\n\t\t\t\t\t   dport = ntohs(flow->packet.tcp->dest)),\n\tdefault_ports = ndpi_str->proto_defaults[ret.master_protocol].tcp_default_ports;\n    else\n      found = NULL, default_ports = NULL;\n\n    if(found\n       && (found->proto->protoId != NDPI_PROTOCOL_UNKNOWN)\n       && (found->proto->protoId != ret.master_protocol)) {\n      // printf(\"******** %u / %u\\n\", found->proto->protoId, ret.master_protocol);\n      NDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);\n    } else if(default_ports && (default_ports[0] != 0)) {\n      u_int8_t found = 0, i;\n\n      for(i=0; (i<MAX_DEFAULT_PORTS) && (default_ports[i] != 0); i++) {\n\tif((default_ports[i] == sport) || (default_ports[i] == dport)) {\n\t  found = 1;\n\t  break;\n\t}\n      } /* for */\n\n      if(!found) {\n\t// printf(\"******** Invalid default port\\n\");\n\tNDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);\n      }\n    }\n\n    flow->risk_checked = 1;\n  }\n\n  ndpi_reconcile_protocols(ndpi_str, flow, &ret);\n\n invalidate_ptr:\n  /*\n    Invalidate packet memory to avoid accessing the pointers below\n    when the packet is no longer accessible\n  */\n  flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;\n  ndpi_reset_packet_line_info(&flow->packet);\n\n  return(ret);\n}\n\n/* ********************************************************************************* */\n\nu_int32_t ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  val = 0;\n\n  // cancel if eof, ' ' or line end chars are reached\n  while (*str >= '0' && *str <= '9' && max_chars_to_read > 0) {\n    val *= 10;\n    val += *str - '0';\n    str++;\n    max_chars_to_read = max_chars_to_read - 1;\n    *bytes_read = *bytes_read + 1;\n  }\n\n  return(val);\n}\n\n/* ********************************************************************************* */\n\n#ifdef CODE_UNUSED\nu_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  val = 0;\n  if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {\n    return(ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));\n  } else {\n    /*use base 16 system */\n    str += 2;\n    max_chars_to_read -= 2;\n    *bytes_read = *bytes_read + 2;\n\n    while (max_chars_to_read > 0) {\n      if(*str >= '0' && *str <= '9') {\n\tval *= 16;\n\tval += *str - '0';\n      } else if(*str >= 'a' && *str <= 'f') {\n\tval *= 16;\n\tval += *str + 10 - 'a';\n      } else if(*str >= 'A' && *str <= 'F') {\n\tval *= 16;\n\tval += *str + 10 - 'A';\n      } else {\n\tbreak;\n      }\n      str++;\n      max_chars_to_read = max_chars_to_read - 1;\n      *bytes_read = *bytes_read + 1;\n    }\n  }\n\n  return(val);\n}\n\n#endif\n\n/* ********************************************************************************* */\n\nu_int64_t ndpi_bytestream_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int64_t val;\n  val = 0;\n  // cancel if eof, ' ' or line end chars are reached\n  while (max_chars_to_read > 0 && *str >= '0' && *str <= '9') {\n    val *= 10;\n    val += *str - '0';\n    str++;\n    max_chars_to_read = max_chars_to_read - 1;\n    *bytes_read = *bytes_read + 1;\n  }\n  return(val);\n}\n\n/* ********************************************************************************* */\n\nu_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read,\n                                                 u_int16_t *bytes_read) {\n  u_int64_t val;\n  val = 0;\n  if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {\n    return(ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));\n  } else {\n    /*use base 16 system */\n    str += 2;\n    max_chars_to_read -= 2;\n    *bytes_read = *bytes_read + 2;\n    while (max_chars_to_read > 0) {\n      if(*str >= '0' && *str <= '9') {\n\tval *= 16;\n\tval += *str - '0';\n      } else if(*str >= 'a' && *str <= 'f') {\n\tval *= 16;\n\tval += *str + 10 - 'a';\n      } else if(*str >= 'A' && *str <= 'F') {\n\tval *= 16;\n\tval += *str + 10 - 'A';\n      } else {\n\tbreak;\n      }\n      str++;\n      max_chars_to_read = max_chars_to_read - 1;\n      *bytes_read = *bytes_read + 1;\n    }\n  }\n  return(val);\n}\n\n/* ********************************************************************************* */\n\nu_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  u_int16_t read = 0;\n  u_int16_t oldread;\n  u_int32_t c;\n\n  /* ip address must be X.X.X.X with each X between 0 and 255 */\n  oldread = read;\n  c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  \n  read++;\n  val = c << 24;\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  \n  read++;\n  val = val + (c << 16);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  \n  read++;\n  val = val + (c << 8);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read)\n    return(0);\n  \n  val = val + c;\n\n  *bytes_read = *bytes_read + read;\n\n  return(htonl(val));\n}\n\n/* ********************************************************************************* */\n\n/* internal function for every detection to parse one packet and to increase the info buffer */\nvoid ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {\n  u_int32_t a;\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  if((packet->payload_packet_len < 3) || (packet->payload == NULL))\n    return;\n\n  if(packet->packet_lines_parsed_complete != 0)\n    return;\n\n  packet->packet_lines_parsed_complete = 1;\n  ndpi_reset_packet_line_info(packet);\n\n  packet->line[packet->parsed_lines].ptr = packet->payload;\n  packet->line[packet->parsed_lines].len = 0;\n\n  for (a = 0; (a < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {\n    if((a + 1) >= packet->payload_packet_len)\n      return; /* Return if only one byte remains (prevent invalid reads past end-of-buffer) */\n\n    if(get_u_int16_t(packet->payload, a) == ntohs(0x0d0a)) {\n      /* If end of line char sequence CR+NL \"\\r\\n\", process line */\n\n      if(((a + 3) <= packet->payload_packet_len)\n\t && (get_u_int16_t(packet->payload, a+2) == ntohs(0x0d0a))) {\n\t/* \\r\\n\\r\\n */\n\tint diff; /* No unsigned ! */\n\tu_int32_t a1 = a + 4;\n\n\tdiff = packet->payload_packet_len - a1;\n\n\tif(diff > 0) {\n\t  diff = ndpi_min(diff, sizeof(flow->initial_binary_bytes));\n\t  memcpy(&flow->initial_binary_bytes, &packet->payload[a1], diff);\n\t  flow->initial_binary_bytes_len = diff;\n\t}\n      }\n\n      packet->line[packet->parsed_lines].len =\n\t(u_int16_t)(((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));\n\n      /* First line of a HTTP response parsing. Expected a \"HTTP/1.? ???\" */\n      if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&\n\t strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&\n\t packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] > '0' && /* response code between 000 and 699 */\n\t packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {\n\tpacket->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];\n\tpacket->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");\n\tpacket->http_num_headers++;\n\n\t/* Set server HTTP response code */\n\tif(packet->payload_packet_len >= 12) {\n\t  char buf[4];\n\n\t  /* Set server HTTP response code */\n\t  strncpy(buf, (char *) &packet->payload[9], 3);\n\t  buf[3] = '\\0';\n\n\t  flow->http.response_status_code = atoi(buf);\n\t  /* https://en.wikipedia.org/wiki/List_of_HTTP_status_codes */\n\t  if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))\n\t    flow->http.response_status_code = 0; /* Out of range */\n\t}\n      }\n\n      /* \"Server:\" header line in HTTP response */\n      if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,\n\t\t     \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {\n\t// some stupid clients omit a space and place the servername directly after the colon\n\tif(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {\n\t  packet->server_line.ptr =\n\t    &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];\n\t  packet->server_line.len =\n\t    packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);\n\t} else {\n\t  packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];\n\t  packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");\n\t}\n\tpacket->http_num_headers++;\n      }\n      /* \"Host:\" header line in HTTP request */\n      if(packet->line[packet->parsed_lines].len > 6 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {\n\t// some stupid clients omit a space and place the hostname directly after the colon\n\tif(packet->line[packet->parsed_lines].ptr[5] == ' ') {\n\t  packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];\n\t  packet->host_line.len = packet->line[packet->parsed_lines].len - 6;\n\t} else {\n\t  packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];\n\t  packet->host_line.len = packet->line[packet->parsed_lines].len - 5;\n\t}\n\tpacket->http_num_headers++;\n      }\n      /* \"X-Forwarded-For:\" header line in HTTP request. Commonly used for HTTP proxies. */\n      if(packet->line[packet->parsed_lines].len > 17 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {\n\t// some stupid clients omit a space and place the hostname directly after the colon\n\tif(packet->line[packet->parsed_lines].ptr[16] == ' ') {\n\t  packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];\n\t  packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;\n\t} else {\n\t  packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];\n\t  packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;\n\t}\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Type:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 14 &&\n\t (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {\n\tpacket->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];\n\tpacket->content_line.len = packet->line[packet->parsed_lines].len - 14;\n\n\twhile ((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))\n\t  packet->content_line.len--, packet->content_line.ptr++;\n\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Type:\" header line in HTTP AGAIN. Probably a bogus response without space after \":\" */\n      if((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&\n\t (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {\n\tpacket->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];\n\tpacket->content_line.len = packet->line[packet->parsed_lines].len - 13;\n\tpacket->http_num_headers++;\n      }\n\n      if(packet->content_line.len > 0) {\n\t/* application/json; charset=utf-8 */\n\tchar separator[] = {';', '\\r', '\\0'};\n\tint i;\n\n\tfor (i = 0; separator[i] != '\\0'; i++) {\n\t  char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);\n\n\t  if(c != NULL)\n\t    packet->content_line.len = c - (char *) packet->content_line.ptr;\n\t}\n      }\n\n      /* \"Accept:\" header line in HTTP request. */\n      if(packet->line[packet->parsed_lines].len > 8 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {\n\tpacket->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];\n\tpacket->accept_line.len = packet->line[packet->parsed_lines].len - 8;\n\tpacket->http_num_headers++;\n      }\n      /* \"Referer:\" header line in HTTP request. */\n      if(packet->line[packet->parsed_lines].len > 9 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {\n\tpacket->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];\n\tpacket->referer_line.len = packet->line[packet->parsed_lines].len - 9;\n\tpacket->http_num_headers++;\n      }\n      /* \"User-Agent:\" header line in HTTP request. */\n      if(packet->line[packet->parsed_lines].len > 12 &&\n\t (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {\n\tpacket->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];\n\tpacket->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Encoding:\" header line in HTTP response (and request?). */\n      if(packet->line[packet->parsed_lines].len > 18 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {\n\tpacket->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];\n\tpacket->http_encoding.len = packet->line[packet->parsed_lines].len - 18;\n\tpacket->http_num_headers++;\n      }\n      /* \"Transfer-Encoding:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 19 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {\n\tpacket->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];\n\tpacket->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Length:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 16 &&\n\t ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {\n\tpacket->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];\n\tpacket->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Disposition\"*/\n      if(packet->line[packet->parsed_lines].len > 21 &&\n\t ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Disposition: \", 21) == 0))) {\n\tpacket->content_disposition_line.ptr = &packet->line[packet->parsed_lines].ptr[21];\n\tpacket->content_disposition_line.len = packet->line[packet->parsed_lines].len - 21;\n\tpacket->http_num_headers++;\n      }\n      /* \"Cookie:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 8 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {\n\tpacket->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];\n\tpacket->http_cookie.len = packet->line[packet->parsed_lines].len - 8;\n\tpacket->http_num_headers++;\n      }\n      /* \"Origin:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 8 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {\n\tpacket->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];\n\tpacket->http_origin.len = packet->line[packet->parsed_lines].len - 8;\n\tpacket->http_num_headers++;\n      }\n      /* \"X-Session-Type:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 16 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {\n\tpacket->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];\n\tpacket->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;\n\tpacket->http_num_headers++;\n      }\n      /* Identification and counting of other HTTP headers.\n       * We consider the most common headers, but there are many others,\n       * which can be seen at references below:\n       * - https://tools.ietf.org/html/rfc7230\n       * - https://en.wikipedia.org/wiki/List_of_HTTP_header_fields\n       */\n      if((packet->line[packet->parsed_lines].len > 6 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 8 &&\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||\n\t (packet->line[packet->parsed_lines].len > 9 &&\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||\n\t (packet->line[packet->parsed_lines].len > 12 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 15 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 17 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 27 &&\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,\n\t\t      \"Upgrade-Insecure-Requests: \", 27) == 0)) {\n\t/* Just count. In the future, if needed, this if can be splited to parse these headers */\n\tpacket->http_num_headers++;\n      }\n\n      if(packet->line[packet->parsed_lines].len == 0) {\n\tpacket->empty_line_position = a;\n\tpacket->empty_line_position_set = 1;\n      }\n\n      if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))\n\treturn;\n\n      packet->parsed_lines++;\n      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];\n      packet->line[packet->parsed_lines].len = 0;\n\n      a++; /* next char in the payload */\n    }\n  }\n\n  if(packet->parsed_lines >= 1) {\n    packet->line[packet->parsed_lines].len =\n      (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) -\n\t\t  ((unsigned long) packet->line[packet->parsed_lines].ptr));\n    packet->parsed_lines++;\n  }\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int32_t a;\n  u_int16_t end = packet->payload_packet_len;\n\n  if(packet->packet_lines_parsed_complete != 0)\n    return;\n\n  packet->packet_lines_parsed_complete = 1;\n  packet->parsed_lines = 0;\n\n  if(packet->payload_packet_len == 0)\n    return;\n\n  packet->line[packet->parsed_lines].ptr = packet->payload;\n  packet->line[packet->parsed_lines].len = 0;\n\n  for (a = 0; a < end; a++) {\n    if(packet->payload[a] == 0x0a) {\n      packet->line[packet->parsed_lines].len = (u_int16_t)(\n\t\t\t\t\t\t\t   ((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));\n\n      if(a > 0 && packet->payload[a - 1] == 0x0d)\n\tpacket->line[packet->parsed_lines].len--;\n\n      if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))\n\tbreak;\n\n      packet->parsed_lines++;\n      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];\n      packet->line[packet->parsed_lines].len = 0;\n\n      if((a + 1) >= packet->payload_packet_len)\n\tbreak;\n\n      //a++;\n    }\n  }\n}\n\n/* ********************************************************************************* */\n\nu_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                       u_int16_t counter) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");\n\n  if(packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||\n\t\t\t\t\t      (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||\n\t\t\t\t\t      (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||\n\t\t\t\t\t      packet->payload[counter] == '-' || packet->payload[counter] == '_')) {\n    NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");\n    counter++;\n    while (packet->payload_packet_len > counter &&\n\t   ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||\n\t    (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||\n\t    (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||\n\t    packet->payload[counter] == '-' || packet->payload[counter] == '_' ||\n\t    packet->payload[counter] == '.')) {\n      NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");\n      counter++;\n      if(packet->payload_packet_len > counter && packet->payload[counter] == '@') {\n\tNDPI_LOG_DBG2(ndpi_str, \"@\\n\");\n\tcounter++;\n\twhile (packet->payload_packet_len > counter &&\n\t       ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||\n\t\t(packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||\n\t\t(packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||\n\t\tpacket->payload[counter] == '-' || packet->payload[counter] == '_')) {\n\t  NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");\n\t  counter++;\n\t  if(packet->payload_packet_len > counter && packet->payload[counter] == '.') {\n\t    NDPI_LOG_DBG2(ndpi_str, \".\\n\");\n\t    counter++;\n\t    if(packet->payload_packet_len > counter + 1 &&\n\t       ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&\n\t\t(packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {\n\t      NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");\n\t      counter += 2;\n\t      if(packet->payload_packet_len > counter &&\n\t\t (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {\n\t\tNDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");\n\t\treturn(counter);\n\t      } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&\n\t\t\tpacket->payload[counter] <= 'z') {\n\t\tNDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");\n\t\tcounter++;\n\t\tif(packet->payload_packet_len > counter &&\n\t\t   (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {\n\t\t  NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");\n\t\t  return(counter);\n\t\t} else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&\n\t\t\t  packet->payload[counter] <= 'z') {\n\t\t  counter++;\n\t\t  if(packet->payload_packet_len > counter &&\n\t\t     (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {\n\t\t    NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");\n\t\t    return(counter);\n\t\t  } else {\n\t\t    return(0);\n\t\t  }\n\t\t} else {\n\t\t  return(0);\n\t\t}\n\t      } else {\n\t\treturn(0);\n\t      }\n\t    } else {\n\t      return(0);\n\t    }\n\t  }\n\t}\n\treturn(0);\n      }\n    }\n  }\n  return(0);\n}\n\n#ifdef NDPI_ENABLE_DEBUG_MESSAGES\n/* ********************************************************************************* */\n\nvoid ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct *ndpi_str, const char **file,\n                                           const char **func, u_int32_t *line) {\n  *file = \"\";\n  *func = \"\";\n\n  if(ndpi_str->ndpi_debug_print_file != NULL)\n    *file = ndpi_str->ndpi_debug_print_file;\n\n  if(ndpi_str->ndpi_debug_print_function != NULL)\n    *func = ndpi_str->ndpi_debug_print_function;\n\n  *line = ndpi_str->ndpi_debug_print_line;\n}\n#endif\n\n/* ********************************************************************************* */\n\nu_int8_t ndpi_detection_get_l4(const u_int8_t *l3, u_int16_t l3_len, const u_int8_t **l4_return,\n                               u_int16_t *l4_len_return, u_int8_t *l4_protocol_return, u_int32_t flags) {\n  return(ndpi_detection_get_l4_internal(NULL, l3, l3_len, l4_return, l4_len_return, l4_protocol_return, flags));\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {\n  struct ndpi_id_struct *src = flow->src, *dst = flow->dst;\n\n  ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);\n\n  if(src != NULL) {\n    NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);\n\n    if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)\n      NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);\n  }\n\n  if(dst != NULL) {\n    NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);\n\n    if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)\n      NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);\n  }\n}\n\n/* ********************************************************************************* */\n\nu_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {\n  return(flow->detected_protocol_stack[1]);\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_int_change_flow_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                   u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {\n  if(!flow)\n    return;\n\n  flow->detected_protocol_stack[0] = upper_detected_protocol,\n    flow->detected_protocol_stack[1] = lower_detected_protocol;\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_int_change_packet_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                     u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  /* NOTE: everything below is identically to change_flow_protocol\n   *        except flow->packet If you want to change something here,\n   *        don't! Change it for the flow function and apply it here\n   *        as well */\n\n  if(!packet)\n    return;\n\n  packet->detected_protocol_stack[0] = upper_detected_protocol,\n    packet->detected_protocol_stack[1] = lower_detected_protocol;\n}\n\n/* ********************************************************************************* */\n\n/* generic function for changing the protocol\n *\n * what it does is:\n * 1.update the flow protocol stack with the new protocol\n * 2.update the packet protocol stack with the new protocol\n */\nvoid ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                              u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {\n  if((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))\n    upper_detected_protocol = lower_detected_protocol;\n\n  if(upper_detected_protocol == lower_detected_protocol)\n    lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;\n\n  if((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {\n    if((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n       (upper_detected_protocol != flow->guessed_host_protocol_id)) {\n      if(ndpi_str->proto_defaults[upper_detected_protocol].can_have_a_subprotocol) {\n\tlower_detected_protocol = upper_detected_protocol;\n\tupper_detected_protocol = flow->guessed_host_protocol_id;\n      }\n    }\n  }\n\n  ndpi_int_change_flow_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);\n  ndpi_int_change_packet_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                              ndpi_protocol_category_t protocol_category) {\n  flow->category = protocol_category;\n}\n\n/* ********************************************************************************* */\n\n/* turns a packet back to unknown */\nvoid ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet) {\n  int a;\n\n  for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)\n    packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;\n}\n\n/* ********************************************************************************* */\n\nvoid ndpi_int_reset_protocol(struct ndpi_flow_struct *flow) {\n  if(flow) {\n    int a;\n\n    for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)\n      flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;\n  }\n}\n\n/* ********************************************************************************* */\n\nvoid NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t *ip) {\n  memset(ip, 0, sizeof(ndpi_ip_addr_t));\n}\n\n/* ********************************************************************************* */\n\n#ifdef CODE_UNUSED\n/* NTOP */\nint NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t *ip) {\n  return(memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);\n}\n#endif\n\n/* ********************************************************************************* */\n\n/* check if the source ip address in packet and ip are equal */\n/* NTOP */\nint ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\n  /* IPv6 */\n  if(packet->iphv6 != NULL) {\n    if(packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&\n       packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&\n       packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&\n       packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])\n      return(1);\n    //else\n    return(0);\n  }\n#endif\n\n  /* IPv4 */\n  if(packet->iph->saddr == ip->ipv4)\n    return(1);\n  return(0);\n}\n\n/* ********************************************************************************* */\n\n/* check if the destination ip address in packet and ip are equal */\nint ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\n  /* IPv6 */\n  if(packet->iphv6 != NULL) {\n    if(packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&\n       packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&\n       packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&\n       packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])\n      return(1);\n    //else\n    return(0);\n  }\n#endif\n\n  /* IPv4 */\n  if(packet->iph->saddr == ip->ipv4)\n    return(1);\n\n  return(0);\n}\n\n/* ********************************************************************************* */\n\n/* get the source ip address from packet and put it into ip */\n/* NTOP */\nvoid ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {\n  NDPI_PROTOCOL_IP_clear(ip);\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\n  /* IPv6 */\n  if(packet->iphv6 != NULL) {\n    ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];\n    ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];\n    ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];\n    ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];\n\n  } else\n#endif\n\n    /* IPv4 */\n    ip->ipv4 = packet->iph->saddr;\n}\n\n/* ********************************************************************************* */\n\n/* get the destination ip address from packet and put it into ip */\n/* NTOP */\nvoid ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {\n  NDPI_PROTOCOL_IP_clear(ip);\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n\n  if(packet->iphv6 != NULL) {\n    ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];\n    ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];\n    ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];\n    ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];\n\n  } else\n\n#endif\n\n    ip->ipv4 = packet->iph->daddr;\n}\n\n/* ********************************************************************************* */\n\nu_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip) {\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  return(ip->ipv6.u6_addr.u6_addr32[1] != 0 || ip->ipv6.u6_addr.u6_addr32[2] != 0 ||\n\t  ip->ipv6.u6_addr.u6_addr32[3] != 0);\n#else\n  return(0);\n#endif\n}\n\n/* ********************************************************************************* */\n\nchar *ndpi_get_ip_string(const ndpi_ip_addr_t *ip, char *buf, u_int buf_len) {\n  const u_int8_t *a = (const u_int8_t *) &ip->ipv4;\n\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  if(ndpi_is_ipv6(ip)) {\n    if(inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)\n      buf[0] = '\\0';\n\n    return(buf);\n  }\n#endif\n\n  snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);\n\n  return(buf);\n}\n\n/* ****************************************************** */\n\n/* Returns -1 on failutre, otherwise fills parsed_ip and returns the IP version */\nint ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip) {\n  int rv = -1;\n  memset(parsed_ip, 0, sizeof(*parsed_ip));\n\n  if(strchr(ip_str, '.')) {\n    if(inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)\n      rv = 4;\n#ifdef NDPI_DETECTION_SUPPORT_IPV6\n  } else {\n    if(inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)\n      rv = 6;\n#endif\n  }\n\n  return(rv);\n}\n\n/* ****************************************************** */\n\nu_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t *str,\n\t\t\t\t\t  u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);\n  return(ntohs(val));\n}\n\n/* ****************************************************** */\n\nu_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p) {\n  return(((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);\n}\n\n/* ****************************************************** */\n\nu_int16_t ndpi_get_lower_proto(ndpi_protocol proto) {\n  return((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);\n}\n\n/* ****************************************************** */\n\nndpi_protocol ndpi_guess_undetected_protocol(struct ndpi_detection_module_struct *ndpi_str,\n                                             struct ndpi_flow_struct *flow, u_int8_t proto,\n                                             u_int32_t shost /* host byte order */, u_int16_t sport,\n                                             u_int32_t dhost /* host byte order */, u_int16_t dport) {\n  u_int32_t rc;\n  struct in_addr addr;\n  ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};\n  u_int8_t user_defined_proto;\n\n  if((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {\n    rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);\n\n    if(rc != NDPI_PROTOCOL_UNKNOWN) {\n      if(flow && (proto == IPPROTO_UDP) &&\n\t NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))\n\t;\n      else {\n\tret.app_protocol = rc,\n\t  ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);\n\n\tif(ret.app_protocol == ret.master_protocol)\n\t  ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;\n\n\tret.category = ndpi_get_proto_category(ndpi_str, ret);\n\treturn(ret);\n      }\n    }\n\n    rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);\n    if(rc != NDPI_PROTOCOL_UNKNOWN) {\n      if(flow && (proto == IPPROTO_UDP) &&\n\t NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))\n\t;\n      else {\n\tret.app_protocol = rc;\n\n\tif(rc == NDPI_PROTOCOL_TLS)\n\t  goto check_guessed_skype;\n\telse {\n\t  ret.category = ndpi_get_proto_category(ndpi_str, ret);\n\t  return(ret);\n\t}\n      }\n    }\n\n  check_guessed_skype:\n    addr.s_addr = htonl(shost);\n    if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {\n      ret.app_protocol = NDPI_PROTOCOL_SKYPE;\n    } else {\n      addr.s_addr = htonl(dhost);\n      if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)\n\tret.app_protocol = NDPI_PROTOCOL_SKYPE;\n    }\n  } else\n    ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);\n\n  ret.category = ndpi_get_proto_category(ndpi_str, ret);\n  return(ret);\n}\n\n/* ****************************************************** */\n\nchar *ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str,\n\t\t       ndpi_protocol proto, char *buf, u_int buf_len) {\n  if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {\n    if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)\n      snprintf(buf, buf_len, \"%u.%u\", proto.master_protocol, proto.app_protocol);\n    else\n      snprintf(buf, buf_len, \"%u\", proto.master_protocol);\n  } else\n    snprintf(buf, buf_len, \"%u\", proto.app_protocol);\n\n  return(buf);\n}\n\n/* ****************************************************** */\n\nchar *ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t ndpi_protocol proto, char *buf, u_int buf_len) {\n  if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {\n    if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)\n      snprintf(buf, buf_len, \"%s.%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol),\n\t       ndpi_get_proto_name(ndpi_str, proto.app_protocol));\n    else\n      snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol));\n  } else\n    snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.app_protocol));\n\n  return(buf);\n}\n\n/* ****************************************************** */\n\nint ndpi_is_custom_category(ndpi_protocol_category_t category) {\n  switch (category) {\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:\n    return(1);\n    break;\n\n  default:\n    return(0);\n    break;\n  }\n}\n\n/* ****************************************************** */\n\nvoid ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t    ndpi_protocol_category_t category,\n                            char *name) {\n  if(!name)\n    return;\n\n  switch (category) {\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:\n    snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:\n    snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:\n    snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:\n    snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:\n    snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);\n    break;\n\n  default:\n    break;\n  }\n}\n\n/* ****************************************************** */\n\nconst char *ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t   ndpi_protocol_category_t category) {\n  if((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {\n    static char b[24];\n\n    if(!ndpi_str)\n      snprintf(b, sizeof(b), \"NULL nDPI\");\n    else\n      snprintf(b, sizeof(b), \"Invalid category %d\", (int) category);\n    return(b);\n  }\n\n  if((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {\n    switch (category) {\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:\n      return(ndpi_str->custom_category_labels[0]);\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:\n      return(ndpi_str->custom_category_labels[1]);\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:\n      return(ndpi_str->custom_category_labels[2]);\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:\n      return(ndpi_str->custom_category_labels[3]);\n    case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:\n      return(ndpi_str->custom_category_labels[4]);\n    case NDPI_PROTOCOL_NUM_CATEGORIES:\n      return(\"Code should not use this internal constant\");\n    default:\n      return(\"Unspecified\");\n    }\n  } else\n    return(categories[category]);\n}\n\n/* ****************************************************** */\n\nndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\t\t ndpi_protocol proto) {\n  if(proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)\n    return(proto.category);\n\n  /* simple rule: sub protocol first, master after */\n  else if((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN) ||\n\t  (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {\n    if(proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))\n      return(ndpi_str->proto_defaults[proto.app_protocol].protoCategory);\n  } else if(proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))\n    return(ndpi_str->proto_defaults[proto.master_protocol].protoCategory);\n\n  return(NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);\n}\n\n/* ****************************************************** */\n\nchar *ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t  u_int16_t proto_id) {\n  if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||\n     (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||\n     (ndpi_str->proto_defaults[proto_id].protoName == NULL))\n    proto_id = NDPI_PROTOCOL_UNKNOWN;\n\n  return(ndpi_str->proto_defaults[proto_id].protoName);\n}\n\n/* ****************************************************** */\n\nndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\t   u_int16_t proto_id) {\n  if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||\n     (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||\n     (ndpi_str->proto_defaults[proto_id].protoName == NULL))\n    proto_id = NDPI_PROTOCOL_UNKNOWN;\n\n  return(ndpi_str->proto_defaults[proto_id].protoBreed);\n}\n\n/* ****************************************************** */\n\nchar *ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\tndpi_protocol_breed_t breed_id) {\n  switch (breed_id) {\n  case NDPI_PROTOCOL_SAFE:\n    return(\"Safe\");\n    break;\n  case NDPI_PROTOCOL_ACCEPTABLE:\n    return(\"Acceptable\");\n    break;\n  case NDPI_PROTOCOL_FUN:\n    return(\"Fun\");\n    break;\n  case NDPI_PROTOCOL_UNSAFE:\n    return(\"Unsafe\");\n    break;\n  case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:\n    return(\"Potentially Dangerous\");\n    break;\n  case NDPI_PROTOCOL_DANGEROUS:\n    return(\"Dangerous\");\n    break;\n  case NDPI_PROTOCOL_UNRATED:\n  default:\n    return(\"Unrated\");\n    break;\n  }\n}\n\n/* ****************************************************** */\n\nint ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto) {\n  int i;\n\n  for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)\n    if(strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)\n      return(i);\n\n  return(-1);\n}\n\n/* ****************************************************** */\n\nint ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat) {\n  int i;\n\n  for (i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {\n    const char *name = ndpi_category_get_name(ndpi_str, i);\n\n    if(strcasecmp(cat, name) == 0)\n      return(i);\n  }\n\n  return(-1);\n}\n\n/* ****************************************************** */\n\nvoid ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  int i;\n\n  for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)\n    printf(\"%3d %-22s %-8s %-12s %s\\n\", i, ndpi_str->proto_defaults[i].protoName,\n\t   ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),\n\t   ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),\n\t   ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory));\n}\n\n/* ****************************************************** */\n\n/*\n * Find the first occurrence of find in s, where the search is limited to the\n * first slen characters of s.\n */\nchar *ndpi_strnstr(const char *s, const char *find, size_t slen) {\n  char c;\n  size_t len;\n\n  if((c = *find++) != '\\0') {\n    len = strnlen(find, slen);\n    do {\n      char sc;\n\n      do {\n\tif(slen-- < 1 || (sc = *s++) == '\\0')\n\t  return(NULL);\n      } while (sc != c);\n      if(len > slen)\n\treturn(NULL);\n    } while (strncmp(s, find, len) != 0);\n    s--;\n  }\n\n  return((char *) s);\n}\n\n/* ****************************************************** */\n\n/*\n * Same as ndpi_strnstr but case-insensitive\n */\nchar *ndpi_strncasestr(const char *s, const char *find, size_t slen) {\n  char c;\n  size_t len;\n\n  if((c = *find++) != '\\0') {\n    len = strlen(find);\n    do {\n      char sc;\n\n      do {\n\tif(slen-- < 1 || (sc = *s++) == '\\0')\n\t  return(NULL);\n      } while (sc != c);\n\n      if(len > slen)\n\treturn(NULL);\n    } while (strncasecmp(s, find, len) != 0);\n\n    s--;\n  }\n  return((char *) s);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_prefix(const u_int8_t *payload,\n\t\t      size_t payload_len, const char *str, size_t str_len) {\n  int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;\n\n  return(rc);\n}\n\n/* ****************************************************** */\n\nint ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *string_to_match,\n                                  u_int string_to_match_len, ndpi_protocol_match_result *ret_match,\n                                  u_int8_t is_host_match) {\n  AC_TEXT_t ac_input_text;\n  ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;\n  AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};\n  int rc;\n\n  if((automa->ac_automa == NULL) || (string_to_match_len == 0))\n    return(NDPI_PROTOCOL_UNKNOWN);\n\n  if(!automa->ac_automa_finalized) {\n    printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);\n    return(0); /* No matches */\n  }\n\n  ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;\n  rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  /* We need to take into account also rc == 0 that is used for partial matches */\n  ret_match->protocol_id = match.number, ret_match->protocol_category = match.category,\n    ret_match->protocol_breed = match.breed;\n\n  return(rc ? match.number : 0);\n}\n\n/* **************************************** */\n\nstatic u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto) {\n  /* Sometimes certificates are more generic than previously identified protocols */\n\n  if((previous_proto == NDPI_PROTOCOL_UNKNOWN) || (previous_proto == new_proto))\n    return(0);\n\n  switch (previous_proto) {\n  case NDPI_PROTOCOL_WHATSAPP_CALL:\n  case NDPI_PROTOCOL_WHATSAPP_FILES:\n    if(new_proto == NDPI_PROTOCOL_WHATSAPP)\n      return(1);\n  }\n\n  return(0);\n}\n\n/* ****************************************************** */\n\nstatic u_int16_t ndpi_automa_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str,\n                                                      struct ndpi_flow_struct *flow, char *string_to_match,\n                                                      u_int string_to_match_len, u_int16_t master_protocol_id,\n                                                      ndpi_protocol_match_result *ret_match, u_int8_t is_host_match) {\n  int matching_protocol_id;\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  matching_protocol_id =\n    ndpi_match_string_subprotocol(ndpi_str, string_to_match, string_to_match_len, ret_match, is_host_match);\n\n#ifdef DEBUG\n  {\n    char m[256];\n    int len = ndpi_min(sizeof(m), string_to_match_len);\n\n    strncpy(m, string_to_match, len);\n    m[len] = '\\0';\n\n    NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\", m,\n\t\t  ndpi_str->proto_defaults[matching_protocol_id].protoName);\n  }\n#endif\n\n  if((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n     (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {\n    /* Move the protocol on slot 0 down one position */\n    packet->detected_protocol_stack[1] = master_protocol_id,\n      packet->detected_protocol_stack[0] = matching_protocol_id;\n\n    flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],\n      flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];\n\n    if(flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)\n      flow->category = ret_match->protocol_category;\n\n    return(packet->detected_protocol_stack[0]);\n  }\n\n#ifdef DEBUG\n  string_to_match[string_to_match_len] = '\\0';\n  NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);\n#endif\n\n  ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN, ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,\n    ret_match->protocol_breed = NDPI_PROTOCOL_UNRATED;\n\n  return(NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ****************************************************** */\n\nu_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,\n                                      char *string_to_match, u_int string_to_match_len,\n                                      ndpi_protocol_match_result *ret_match, u_int16_t master_protocol_id) {\n  u_int16_t rc = ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,\n\t\t\t\t\t\t      master_protocol_id, ret_match, 1);\n  ndpi_protocol_category_t id = ret_match->protocol_category;\n\n  if(ndpi_get_custom_category_match(ndpi_str, string_to_match, string_to_match_len, &id) != -1) {\n    /* if(id != -1) */ {\n      flow->category = ret_match->protocol_category = id;\n      rc = master_protocol_id;\n    }\n  }\n\n  return(rc);\n}\n\n/* **************************************** */\n\nint ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow,\n                                 u_int16_t master_protocol, char *name, u_int name_len) {\n  ndpi_protocol_match_result ret_match;\n  u_int16_t subproto, what_len;\n  char *what;\n\n  if((name_len > 2) && (name[0] == '*') && (name[1] == '.'))\n    what = &name[1], what_len = name_len - 1;\n  else\n    what = name, what_len = name_len;\n\n  subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len, &ret_match, master_protocol);\n\n  if(subproto != NDPI_PROTOCOL_UNKNOWN) {\n    ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);\n    ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);\n    return(1);\n  } else\n    return(0);\n}\n\n/* ****************************************************** */\n\nu_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\t struct ndpi_flow_struct *flow,\n                                         char *string_to_match, u_int string_to_match_len,\n                                         ndpi_protocol_match_result *ret_match,\n\t\t\t\t\t u_int16_t master_protocol_id) {\n  return(ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,\n\t\t\t\t\t       master_protocol_id, ret_match, 0));\n}\n\n/* ****************************************************** */\n\nint ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str,\n\t\t      ndpi_automa *automa, char *bigram_to_match) {\n  AC_TEXT_t ac_input_text;\n  AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};\n  int rc;\n\n  if((automa->ac_automa == NULL) || (bigram_to_match == NULL))\n    return(-1);\n\n  if(!automa->ac_automa_finalized) {\n    printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);\n    return(0); /* No matches */\n  }\n\n  ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;\n  rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);\n\n  /*\n    As ac_automata_search can detect partial matches and continue the search process\n    in case rc == 0 (i.e. no match), we need to check if there is a partial match\n    and in this case return it\n  */\n  if((rc == 0) && (match.number != 0))\n    rc = 1;\n\n  return(rc ? match.number : 0);\n}\n\n/* ****************************************************** */\n\nvoid ndpi_free_flow(struct ndpi_flow_struct *flow) {\n  if(flow) {\n    if(flow->http.url)\n      ndpi_free(flow->http.url);\n    if(flow->http.content_type)\n      ndpi_free(flow->http.content_type);\n    if(flow->http.user_agent)\n      ndpi_free(flow->http.user_agent);\n    if(flow->kerberos_buf.pktbuf)\n      ndpi_free(flow->kerberos_buf.pktbuf);\n\n    if(flow_is_proto(flow, NDPI_PROTOCOL_TLS)) {\n      if(flow->protos.stun_ssl.ssl.server_names)\n\tndpi_free(flow->protos.stun_ssl.ssl.server_names);\n\n      if(flow->protos.stun_ssl.ssl.alpn)\n\tndpi_free(flow->protos.stun_ssl.ssl.alpn);\n\n      if(flow->protos.stun_ssl.ssl.tls_supported_versions)\n\tndpi_free(flow->protos.stun_ssl.ssl.tls_supported_versions);\n\n      if(flow->protos.stun_ssl.ssl.issuerDN)\n\tndpi_free(flow->protos.stun_ssl.ssl.issuerDN);\n\n      if(flow->protos.stun_ssl.ssl.subjectDN)\n\tndpi_free(flow->protos.stun_ssl.ssl.subjectDN);\n\n      if(flow->l4.tcp.tls.srv_cert_fingerprint_ctx)\n\tndpi_free(flow->l4.tcp.tls.srv_cert_fingerprint_ctx);\n\n      if(flow->protos.stun_ssl.ssl.encrypted_sni.esni)\n\tndpi_free(flow->protos.stun_ssl.ssl.encrypted_sni.esni);\n    }\n\n    if(flow->l4_proto == IPPROTO_TCP) {\n      if(flow->l4.tcp.tls.message.buffer)\n\tndpi_free(flow->l4.tcp.tls.message.buffer);\n    }\n\n    ndpi_free(flow);\n  }\n}\n\n/* ****************************************************** */\n\nchar *ndpi_revision() {\n  return(NDPI_GIT_RELEASE);\n}\n\n/* ****************************************************** */\n\n#ifdef WIN32\n\n/* https://stackoverflow.com/questions/10905892/equivalent-of-gettimeday-for-windows */\nint gettimeofday(struct timeval *tp, struct timezone *tzp) {\n  // Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's\n  // This magic number is the number of 100 nanosecond intervals since January 1, 1601 (UTC)\n  // until 00:00:00 January 1, 1970\n  static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);\n\n  SYSTEMTIME system_time;\n  FILETIME file_time;\n  uint64_t time;\n\n  GetSystemTime(&system_time);\n  SystemTimeToFileTime(&system_time, &file_time);\n  time = ((uint64_t) file_time.dwLowDateTime);\n  time += ((uint64_t) file_time.dwHighDateTime) << 32;\n\n  tp->tv_sec = (long) ((time - EPOCH) / 10000000L);\n  tp->tv_usec = (long) (system_time.wMilliseconds * 1000);\n  return(0);\n}\n#endif\n\nint NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b) {\n  int i;\n\n  for (i = 0; i < NDPI_NUM_FDS_BITS; i++) {\n    if(a.fds_bits[i] & b.fds_bits[i])\n      return(1);\n  }\n\n  return(0);\n}\n\n#ifdef CODE_UNUSED\nint NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a) {\n  int i;\n\n  for (i = 0; i < NDPI_NUM_FDS_BITS; i++)\n    if(a.fds_bits[i] != 0)\n      return(0);\n\n  return(1);\n}\n\nvoid NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a) {\n  int i;\n\n  for (i = 0; i < NDPI_NUM_FDS_BITS; i++)\n    printf(\"[%d=%u]\", i, a.fds_bits[i]);\n\n  printf(\"\\n\");\n}\n#endif\n\nu_int16_t ndpi_get_api_version() {\n  return(NDPI_API_VERSION);\n}\n\nndpi_proto_defaults_t *ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str) {\n  return(ndpi_str->proto_defaults);\n}\n\nu_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  return(ndpi_str->ndpi_num_supported_protocols);\n}\n\nu_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str) {\n  return(ndpi_str->ndpi_num_custom_protocols);\n}\n\nu_int ndpi_get_ndpi_detection_module_size() {\n  return(sizeof(struct ndpi_detection_module_struct));\n}\n\nvoid ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l){\n  ndpi_str->ndpi_log_level = l;\n}\n\n/* ******************************************************************** */\n\n/* LRU cache */\nstruct ndpi_lru_cache *ndpi_lru_cache_init(u_int32_t num_entries) {\n  struct ndpi_lru_cache *c = (struct ndpi_lru_cache *) ndpi_malloc(sizeof(struct ndpi_lru_cache));\n\n  if(!c)\n    return(NULL);\n\n  c->entries = (struct ndpi_lru_cache_entry *) ndpi_calloc(num_entries, sizeof(struct ndpi_lru_cache_entry));\n\n  if(!c->entries) {\n    ndpi_free(c);\n    return(NULL);\n  } else\n    c->num_entries = num_entries;\n\n  return(c);\n}\n\nvoid ndpi_lru_free_cache(struct ndpi_lru_cache *c) {\n  ndpi_free(c->entries);\n  ndpi_free(c);\n}\n\nu_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key,\n\t\t\t     u_int16_t *value, u_int8_t clean_key_when_found) {\n  u_int32_t slot = key % c->num_entries;\n\n  if(c->entries[slot].is_full) {\n    *value = c->entries[slot].value;\n    if(clean_key_when_found)\n      c->entries[slot].is_full = 0;\n    return(1);\n  } else\n    return(0);\n}\n\nvoid ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value) {\n  u_int32_t slot = key % c->num_entries;\n\n  c->entries[slot].is_full = 1, c->entries[slot].key = key, c->entries[slot].value = value;\n}\n\n/* ******************************************************************** */\n\n/*\n  This function tells if it's possible to further dissect a given flow\n  0 - All possible dissection has been completed\n  1 - Additional dissection is possible\n*/\nu_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\tstruct ndpi_flow_struct *flow) {\n  u_int16_t proto =\n    flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];\n\n#if 0\n  printf(\"[DEBUG] %s(%u.%u): %u\\n\", __FUNCTION__,\n\t flow->detected_protocol_stack[0],\n\t flow->detected_protocol_stack[1],\n\t proto);\n#endif\n\n  switch (proto) {\n  case NDPI_PROTOCOL_TLS:\n    if(!flow->l4.tcp.tls.certificate_processed)\n      return(1); /* TODO: add check for TLS 1.3 */\n    break;\n\n  case NDPI_PROTOCOL_HTTP:\n    if((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))\n      return(1);\n    break;\n\n  case NDPI_PROTOCOL_DNS:\n    if(flow->protos.dns.num_answers == 0)\n      return(1);\n    break;\n\n  case NDPI_PROTOCOL_FTP_CONTROL:\n  case NDPI_PROTOCOL_MAIL_POP:\n  case NDPI_PROTOCOL_MAIL_IMAP:\n  case NDPI_PROTOCOL_MAIL_SMTP:\n    if(flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')\n      return(1);\n    break;\n\n  case NDPI_PROTOCOL_SSH:\n    if((flow->protos.ssh.hassh_client[0] == '\\0') || (flow->protos.ssh.hassh_server[0] == '\\0'))\n      return(1);\n    break;\n\n  case NDPI_PROTOCOL_TELNET:\n    if(!flow->protos.telnet.password_detected)\n      return(1);\n    break;\n  }\n\n  return(0);\n}\n\n/* ******************************************************************** */\n\nconst char *ndpi_get_l4_proto_name(ndpi_l4_proto_info proto) {\n  switch (proto) {\n  case ndpi_l4_proto_unknown:\n    return(\"\");\n    break;\n\n  case ndpi_l4_proto_tcp_only:\n    return(\"TCP\");\n    break;\n\n  case ndpi_l4_proto_udp_only:\n    return(\"UDP\");\n    break;\n\n  case ndpi_l4_proto_tcp_and_udp:\n    return(\"TCP/UDP\");\n    break;\n  }\n\n  return(\"\");\n}\n\n/* ******************************************************************** */\n\nndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\t  u_int16_t ndpi_proto_id) {\n  if(ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {\n    u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;\n    NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;\n\n    if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)\n      return(ndpi_l4_proto_tcp_only);\n    else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)\n      return(ndpi_l4_proto_udp_only);\n    else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)\n      return(ndpi_l4_proto_tcp_and_udp);\n  }\n\n  return(ndpi_l4_proto_unknown); /* default */\n}\n\n/* ******************************************************************** */\n\nndpi_ptree_t *ndpi_ptree_create(void) {\n  ndpi_ptree_t *tree = (ndpi_ptree_t *) ndpi_malloc(sizeof(ndpi_ptree_t));\n\n  if(tree) {\n    tree->v4 = ndpi_New_Patricia(32);\n    tree->v6 = ndpi_New_Patricia(128);\n\n    if((!tree->v4) || (!tree->v6)) {\n      ndpi_ptree_destroy(tree);\n      return(NULL);\n    }\n  }\n\n  return(tree);\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_ptree_destroy(ndpi_ptree_t *tree) {\n  if(tree) {\n    if(tree->v4)\n      ndpi_Destroy_Patricia(tree->v4, free_ptree_data);\n    if(tree->v6)\n      ndpi_Destroy_Patricia(tree->v6, free_ptree_data);\n\n    ndpi_free(tree);\n  }\n}\n\n/* ******************************************************************** */\n\nint ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr,\n\t\t      u_int8_t bits, uint user_data) {\n  u_int8_t is_v6 = ndpi_is_ipv6(addr);\n  patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;\n  prefix_t prefix;\n  patricia_node_t *node;\n\n  if(bits > ptree->maxbits)\n    return(-1);\n\n  if(is_v6)\n    fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);\n  else\n    fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);\n\n  /* Verify that the node does not already exist */\n  node = ndpi_patricia_search_best(ptree, &prefix);\n\n  if(node && (node->prefix->bitlen == bits))\n    return(-2);\n\n  node = ndpi_patricia_lookup(ptree, &prefix);\n\n  if(node != NULL) {\n    node->value.uv.user_value = user_data, node->value.uv.additional_user_value = 0;\n\n    return(0);\n  }\n\n  return(-3);\n}\n\n/* ******************************************************************** */\n\nint ndpi_ptree_match_addr(ndpi_ptree_t *tree,\n\t\t\t  const ndpi_ip_addr_t *addr, uint *user_data) {\n  u_int8_t is_v6 = ndpi_is_ipv6(addr);\n  patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;\n  prefix_t prefix;\n  patricia_node_t *node;\n  int bits = ptree->maxbits;\n\n  if(is_v6)\n    fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);\n  else\n    fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);\n\n  node = ndpi_patricia_search_best(ptree, &prefix);\n\n  if(node) {\n    *user_data = node->value.uv.user_value;\n\n    return(0);\n  }\n\n  return(-1);\n}\n\n/* ******************************************************************** */\n\nvoid ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]) {\n  ndpi_MD5_CTX ctx;\n\n  ndpi_MD5Init(&ctx);\n  ndpi_MD5Update(&ctx, data, data_len);\n  ndpi_MD5Final(hash, &ctx);\n}\n"], "filenames": ["src/lib/ndpi_main.c"], "buggy_code_start_loc": [4809], "buggy_code_end_loc": [4874], "fixing_code_start_loc": [4810], "fixing_code_end_loc": [4881], "type": "CWE-125", "message": "In nDPI through 3.2, the packet parsing code is vulnerable to a heap-based buffer over-read in ndpi_parse_packet_line_info in lib/ndpi_main.c.", "other": {"cve": {"id": "CVE-2020-15471", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-01T11:15:11.037", "lastModified": "2020-07-06T18:51:58.650", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In nDPI through 3.2, the packet parsing code is vulnerable to a heap-based buffer over-read in ndpi_parse_packet_line_info in lib/ndpi_main.c."}, {"lang": "es", "value": "En nDPI versiones hasta 3.2, el c\u00f3digo de an\u00e1lisis de paquetes es vulnerable a una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n ndpi_parse_packet_line_info en la biblioteca lib/ndpi_main.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ntop:ndpi:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2", "matchCriteriaId": "97EDB1C6-9886-4C0B-8F09-5A4C52DC5A45"}]}]}], "references": [{"url": "https://github.com/ntop/nDPI/commit/61066fb106efa6d3d95b67e47b662de208b2b622", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ntop/nDPI/commit/61066fb106efa6d3d95b67e47b662de208b2b622"}}