{"buggy_code": ["/* Copyright 2013 Simo Sorce <simo@samba.org>, see COPYING for license */\n\n/* This File implements the NTLM protocol as specified by:\n *      [MS-NLMP]: NT LAN Manager (NTLM) Authentication Protocol\n *\n * Additional cross checking with:\n * http://davenport.sourceforge.net/ntlm.html\n */\n\n#include <alloca.h>\n#include <endian.h>\n#include <errno.h>\n#include <iconv.h>\n#include <stddef.h>\n#include <string.h>\n#include <sys/time.h>\n\n#include <unicase.h>\n\n#include \"ntlm.h\"\n\n#pragma pack(push, 1)\nstruct wire_av_pair {\n    uint16_t av_id;\n    uint16_t av_len;\n    uint8_t value[]; /* variable */\n};\n#pragma pack(pop)\n\nenum msv_av_ids {\n    MSV_AV_EOL = 0,\n    MSV_AV_NB_COMPUTER_NAME,\n    MSV_AV_NB_DOMAIN_NAME,\n    MSV_AV_DNS_COMPUTER_NAME,\n    MSV_AV_DNS_DOMAIN_NAME,\n    MSV_AV_DNS_TREE_NAME,\n    MSV_AV_FLAGS,\n    MSV_AV_TIMESTAMP,\n    MSV_AV_SINGLE_HOST,\n    MSV_AV_TARGET_NAME,\n    MSV_AV_CHANNEL_BINDINGS\n};\n\n/* Used only on the same host */\n#pragma pack(push, 1)\nstruct wire_single_host_data {\n    uint32_t size;\n    uint32_t Z4;\n    uint32_t data_present;\n    uint32_t custom_data;\n    uint8_t machine_id[32];\n};\n#pragma pack(pop)\n\n#pragma pack(push, 1)\nstruct wire_ntlm_cli_chal {\n    uint8_t resp_type;\n    uint8_t hi_resp_type;\n    uint16_t reserved1;\n    uint32_t reserved2;\n    uint64_t timestamp;\n    uint8_t cli_chal[8];\n    uint32_t reserved3;\n    uint8_t av_pairs[]; /* variable */\n};\n#pragma pack(pop)\n\nstruct ntlm_ctx {\n    iconv_t from_oem;\n    iconv_t to_oem;\n};\n\nint ntlm_init_ctx(struct ntlm_ctx **ctx)\n{\n    struct ntlm_ctx *_ctx;\n    int ret = 0;\n\n    _ctx = calloc(1, sizeof(struct ntlm_ctx));\n    if (!_ctx) return ENOMEM;\n\n    _ctx->from_oem = iconv_open(\"UTF16LE\", \"UTF-8\");\n    if (_ctx->from_oem == (iconv_t) -1) {\n        ret = errno;\n    }\n\n    _ctx->to_oem = iconv_open(\"UTF-8\", \"UTF16LE\");\n    if (_ctx->to_oem == (iconv_t) -1) {\n        iconv_close(_ctx->from_oem);\n        ret = errno;\n    }\n\n    if (ret) {\n        safefree(_ctx);\n    } else {\n        *ctx = _ctx;\n    }\n    return ret;\n}\n\nint ntlm_free_ctx(struct ntlm_ctx **ctx)\n{\n    int ret;\n\n    if (!ctx || !*ctx) return 0;\n\n    if ((*ctx)->from_oem) {\n        ret = iconv_close((*ctx)->from_oem);\n        if (ret) goto done;\n    }\n\n    if ((*ctx)->to_oem) {\n        ret = iconv_close((*ctx)->to_oem);\n    }\n\ndone:\n    if (ret) ret = errno;\n    safefree(*ctx);\n    return ret;\n}\n\nvoid ntlm_free_buffer_data(struct ntlm_buffer *buf)\n{\n    if (!buf) return;\n\n    safefree(buf->data);\n    buf->length = 0;\n}\n\n/* A FILETIME structure is effectively a little endian 64 bit integer\n * with the time from January 1, 1601 UTC with 10s of microsecond resolution.\n */\n#define FILETIME_EPOCH_VALUE 116444736000000000LL\nuint64_t ntlm_timestamp_now(void)\n{\n    struct timeval tv;\n    uint64_t filetime;\n\n    gettimeofday(&tv, NULL);\n\n    /* set filetime to the time representing the eopch */\n    filetime = FILETIME_EPOCH_VALUE;\n    /* add the number of seconds since the epoch */\n    filetime += (uint64_t)tv.tv_sec * 10000000;\n    /* add the number of microseconds since the epoch */\n    filetime += tv.tv_usec * 10;\n\n    return filetime;\n}\n\nbool ntlm_casecmp(const char *s1, const char *s2)\n{\n    size_t s1_len, s2_len;\n    int ret, res;\n\n    if (s1 == s2) return true;\n    if (!s1 || !s2) return false;\n\n    s1_len = strlen(s1);\n    s2_len = strlen(s2);\n\n    ret = ulc_casecmp(s1, s1_len, s2, s2_len,\n                      uc_locale_language(), NULL, &res);\n    if (ret || res != 0) return false;\n    return true;\n}\n\n\n/**\n * @brief  Converts a string using the provided iconv context.\n *         This function is ok only to convert utf8<->utf16le\n *\n * @param cd        The iconv context\n * @param in        Input buffer\n * @param out       Output buffer\n * @param baselen   Input length\n * @param outlen    Returned length of out buffer\n *\n * NOTE: out must be preallocated to a size of baselen * 2\n *\n * @return 0 on success or a standard error value on error.\n */\nstatic int ntlm_str_convert(iconv_t cd,\n                            const char *in, char *out,\n                            size_t baselen, size_t *outlen)\n{\n    char *_in;\n    size_t inleft, outleft;\n    size_t ret;\n\n    ret = iconv(cd, NULL, NULL, NULL, NULL);\n    if (ret == -1) return errno;\n\n    _in = discard_const(in);\n    inleft = baselen;\n    /* conservative max_size calculation in case lots of octects end up\n     * being multiple bytes in length (in both directions) */\n    outleft = baselen * 2;\n\n    ret = iconv(cd, &_in, &inleft, &out, &outleft);\n    if (ret == -1) return errno;\n\n    if (outlen) {\n        *outlen = baselen * 2 - outleft;\n    }\n    return 0;\n}\n\nuint8_t ntlmssp_sig[8] = {'N', 'T', 'L', 'M', 'S', 'S', 'P', 0};\n\nstatic void ntlm_encode_header(struct wire_msg_hdr *hdr, uint32_t msg_type)\n{\n    memcpy(hdr->signature, ntlmssp_sig, 8);\n    hdr->msg_type = htole32(msg_type);\n}\n\nstatic int ntlm_decode_header(struct wire_msg_hdr *hdr, uint32_t *msg_type)\n{\n    if (memcmp(hdr->signature, ntlmssp_sig, 8) != 0) {\n        return ERR_DECODE;\n    }\n\n    *msg_type = le32toh(hdr->msg_type);\n    return 0;\n}\n\nstatic int ntlm_encode_oem_str(struct wire_field_hdr *hdr,\n                               struct ntlm_buffer *buffer,\n                               size_t *data_offs,\n                               const char *str, int str_len)\n{\n    if (*data_offs + str_len > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    memcpy(&buffer->data[*data_offs], str, str_len);\n    hdr->len = htole16(str_len);\n    hdr->max_len = htole16(str_len);\n    hdr->offset = htole32(*data_offs);\n\n    *data_offs += str_len;\n    return 0;\n}\n\nstatic int ntlm_decode_oem_str(struct wire_field_hdr *str_hdr,\n                               struct ntlm_buffer *buffer,\n                               size_t payload_offs, char **_str)\n{\n    uint16_t str_len;\n    uint32_t str_offs;\n    char *str = NULL;\n\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n\n    str = strndup((const char *)&buffer->data[str_offs], str_len);\n    if (!str) return ENOMEM;\n\ndone:\n    *_str = str;\n    return 0;\n}\n\nstatic int ntlm_encode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t *data_offs,\n                                    const char *str, int str_len)\n{\n    char *out;\n    size_t outlen;\n    int ret;\n\n    out = (char *)&buffer->data[*data_offs];\n\n    ret = ntlm_str_convert(ctx->from_oem, str, out, str_len, &outlen);\n    if (ret) return ret;\n\n    hdr->len = htole16(outlen);\n    hdr->max_len = htole16(outlen);\n    hdr->offset = htole32(*data_offs);\n\n    *data_offs += outlen;\n    return 0;\n}\n\nstatic int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen = 0;\n    int ret = 0;\n\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n\n    in = (char *)&buffer->data[str_offs];\n\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n\ndone:\n    if (ret) {\n        safefree(out);\n    } else {\n        /* make sure to terminate output string */\n        out[outlen] = '\\0';\n    }\n\n    *str = out;\n    return ret;\n}\n\nstruct wire_version ntlmssp_version = {\n    NTLMSSP_VERSION_MAJOR,\n    NTLMSSP_VERSION_MINOR,\n    NTLMSSP_VERSION_BUILD, /* 0 is always 0 even in LE */\n    { 0, 0, 0 },\n    NTLMSSP_VERSION_REV\n};\n\nvoid ntlm_internal_set_version(uint8_t major, uint8_t minor,\n                               uint16_t build, uint8_t revision)\n{\n    ntlmssp_version.major = major;\n    ntlmssp_version.minor = minor;\n    ntlmssp_version.build = htole16(build);\n    ntlmssp_version.revision = revision;\n}\n\nstatic int ntlm_encode_version(struct ntlm_ctx *ctx,\n                               struct ntlm_buffer *buffer,\n                               size_t data_offs)\n{\n    if (data_offs + sizeof(struct wire_version) > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    memcpy(&buffer->data[data_offs], &ntlmssp_version,\n           sizeof(struct wire_version));\n    return 0;\n}\n\nstatic int ntlm_encode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t *data_offs,\n                             struct ntlm_buffer *field)\n{\n    if (*data_offs + field->length > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    memcpy(&buffer->data[*data_offs], field->data, field->length);\n    hdr->len = htole16(field->length);\n    hdr->max_len = hdr->len;\n    hdr->offset = htole32(*data_offs);\n\n    *data_offs += field->length;\n    return 0;\n}\n\nstatic int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\n\ndone:\n    *field = b;\n    return 0;\n}\n\nstatic int ntlm_encode_av_pair_u16l_str(struct ntlm_ctx *ctx,\n                                        struct ntlm_buffer *buffer,\n                                        size_t *data_offs,\n                                        enum msv_av_ids av_id,\n                                        const char *str, size_t str_len)\n{\n    struct wire_av_pair *av_pair;\n    char *out;\n    size_t outlen;\n    int ret;\n\n    if (*data_offs + 4 + str_len > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    av_pair = (struct wire_av_pair *)&buffer->data[*data_offs];\n    out = (char *)av_pair->value;\n\n    ret = ntlm_str_convert(ctx->from_oem, str, out, str_len, &outlen);\n    if (ret) return ret;\n\n    av_pair->av_len = htole16(outlen);\n    av_pair->av_id = htole16(av_id);\n\n    *data_offs += av_pair->av_len + 4;\n    return 0;\n}\n\nstatic int ntlm_decode_av_pair_u16l_str(struct ntlm_ctx *ctx,\n                                        struct wire_av_pair *av_pair,\n                                        char **str)\n{\n    char *in, *out;\n    size_t inlen, outlen;\n    int ret;\n\n    in = (char *)av_pair->value;\n    inlen = le16toh(av_pair->av_len);\n    out = malloc(inlen * 2 + 1);\n\n    ret = ntlm_str_convert(ctx->to_oem, in, out, inlen, &outlen);\n    if (ret) {\n        safefree(out);\n        return ret;\n    }\n    /* terminate out string for sure */\n    out[outlen] = '\\0';\n\n    *str = out;\n    return 0;\n}\n\nstatic int ntlm_encode_av_pair_value(struct ntlm_buffer *buffer,\n                                     size_t *data_offs,\n                                     enum msv_av_ids av_id,\n                                     struct ntlm_buffer *value)\n{\n    struct wire_av_pair *av_pair;\n\n    if (*data_offs + 4 + value->length > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    av_pair = (struct wire_av_pair *)&buffer->data[*data_offs];\n    av_pair->av_id = htole16(av_id);\n    av_pair->av_len = htole16(value->length);\n    if (value->length) {\n        memcpy(av_pair->value, value->data, value->length);\n    }\n\n    *data_offs += value->length + 4;\n    return 0;\n}\n\nint ntlm_encode_target_info(struct ntlm_ctx *ctx, char *nb_computer_name,\n                            char *nb_domain_name, char *dns_computer_name,\n                            char *dns_domain_name, char *dns_tree_name,\n                            uint32_t *av_flags, uint64_t *av_timestamp,\n                            struct ntlm_buffer *av_single_host,\n                            char *av_target_name, struct ntlm_buffer *av_cb,\n                            struct ntlm_buffer *target_info)\n{\n    struct ntlm_buffer buffer;\n    size_t data_offs;\n    size_t max_size;\n    size_t nb_computer_name_len = 0;\n    size_t nb_domain_name_len = 0;\n    size_t dns_computer_name_len = 0;\n    size_t dns_domain_name_len = 0;\n    size_t dns_tree_name_len = 0;\n    size_t av_target_name_len = 0;\n    struct ntlm_buffer value;\n    int ret = 0;\n\n    max_size = 4; /* MSV_AV_EOL */\n\n    if (nb_computer_name) {\n        nb_computer_name_len = strlen(nb_computer_name);\n        max_size += 4 + nb_computer_name_len * 2;\n    }\n    if (nb_domain_name) {\n        nb_domain_name_len = strlen(nb_domain_name);\n        max_size += 4 + nb_domain_name_len * 2;\n    }\n    if (dns_computer_name) {\n        dns_computer_name_len = strlen(dns_computer_name);\n        max_size += 4 + dns_computer_name_len * 2;\n    }\n    if (dns_domain_name) {\n        dns_domain_name_len = strlen(dns_domain_name);\n        max_size += 4 + dns_domain_name_len * 2;\n    }\n    if (dns_tree_name) {\n        dns_tree_name_len = strlen(dns_tree_name);\n        max_size += 4 + dns_tree_name_len * 2;\n    }\n    if (av_flags) {\n        max_size += 4 + 4;\n    }\n    if (av_timestamp) {\n        max_size += 4 + 8;\n    }\n    if (av_single_host) {\n        max_size += 4 + av_single_host->length;\n    }\n    if (av_target_name) {\n        av_target_name_len = strlen(av_target_name);\n        max_size += 4 + av_target_name_len * 2;\n    }\n    if (av_cb && av_cb->length > 0) {\n        max_size += 4 + av_cb->length;\n    }\n\n    data_offs = 0;\n    buffer.length = max_size;\n    buffer.data = calloc(1, buffer.length);\n    if (!buffer.data) return ENOMEM;\n\n    if (nb_computer_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_NB_COMPUTER_NAME,\n                                           nb_computer_name,\n                                           nb_computer_name_len);\n        if (ret) goto done;\n    }\n    if (nb_domain_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_NB_DOMAIN_NAME,\n                                           nb_domain_name,\n                                           nb_domain_name_len);\n        if (ret) goto done;\n    }\n    if (dns_computer_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_DNS_COMPUTER_NAME,\n                                           dns_computer_name,\n                                           dns_computer_name_len);\n        if (ret) goto done;\n    }\n    if (dns_domain_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_DNS_DOMAIN_NAME,\n                                           dns_domain_name,\n                                           dns_domain_name_len);\n        if (ret) goto done;\n    }\n    if (dns_tree_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_DNS_TREE_NAME,\n                                           dns_tree_name,\n                                           dns_tree_name_len);\n        if (ret) goto done;\n    }\n    if (av_flags) {\n        uint32_t flags = htole32(*av_flags);\n        value.data = (uint8_t *)&flags;\n        value.length = 4;\n        ret = ntlm_encode_av_pair_value(&buffer, &data_offs,\n                                        MSV_AV_FLAGS, &value);\n        if (ret) goto done;\n    }\n    if (av_timestamp) {\n        uint64_t timestamp = htole64(*av_timestamp);\n        value.data = (uint8_t *)&timestamp;\n        value.length = 8;\n        ret = ntlm_encode_av_pair_value(&buffer, &data_offs,\n                                        MSV_AV_TIMESTAMP, &value);\n        if (ret) goto done;\n    }\n    if (av_single_host) {\n        ret = ntlm_encode_av_pair_value(&buffer, &data_offs,\n                                        MSV_AV_SINGLE_HOST, av_single_host);\n        if (ret) goto done;\n    }\n    if (av_target_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_TARGET_NAME,\n                                           av_target_name,\n                                           av_target_name_len);\n        if (ret) goto done;\n    }\n    if (av_cb && av_cb->length > 0) {\n        ret = ntlm_encode_av_pair_value(&buffer, &data_offs,\n                                        MSV_AV_CHANNEL_BINDINGS, av_cb);\n        if (ret) goto done;\n    }\n\n    value.length = 0;\n    value.data = NULL;\n    ret = ntlm_encode_av_pair_value(&buffer, &data_offs, MSV_AV_EOL, &value);\n    buffer.length = data_offs;\n\ndone:\n    if (ret) {\n       safefree(buffer.data);\n    } else {\n        *target_info = buffer;\n    }\n    return ret;\n}\n\nint ntlm_decode_target_info(struct ntlm_ctx *ctx, struct ntlm_buffer *buffer,\n                            char **nb_computer_name, char **nb_domain_name,\n                            char **dns_computer_name, char **dns_domain_name,\n                            char **dns_tree_name, char **av_target_name,\n                            uint32_t *av_flags, uint64_t *av_timestamp,\n                            struct ntlm_buffer *av_single_host,\n                            struct ntlm_buffer *av_cb)\n{\n    struct wire_av_pair *av_pair;\n    uint16_t av_id = (uint16_t)-1;\n    uint16_t av_len = (uint16_t)-1;\n    struct ntlm_buffer sh = { NULL, 0 };\n    struct ntlm_buffer cb = { NULL, 0 };\n    char *nb_computer = NULL;\n    char *nb_domain = NULL;\n    char *dns_computer = NULL;\n    char *dns_domain = NULL;\n    char *dns_tree = NULL;\n    char *av_target = NULL;\n    size_t data_offs = 0;\n    uint64_t timestamp = 0;\n    uint32_t flags = 0;\n    int ret = 0;\n\n    while (data_offs + 4 <= buffer->length) {\n        av_pair = (struct wire_av_pair *)&buffer->data[data_offs];\n        data_offs += 4;\n        av_id = le16toh(av_pair->av_id);\n        av_len = le16toh(av_pair->av_len);\n        if (av_len > buffer->length - data_offs) {\n            ret = ERR_DECODE;\n            goto done;\n        }\n        data_offs += av_len;\n\n        switch (av_id) {\n        case MSV_AV_CHANNEL_BINDINGS:\n            if (!av_cb) continue;\n            cb.data = av_pair->value;\n            cb.length = av_len;\n            break;\n        case MSV_AV_TARGET_NAME:\n            if (!av_target_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &av_target);\n            if (ret) goto done;\n            break;\n        case MSV_AV_SINGLE_HOST:\n            if (!av_single_host) continue;\n            sh.data = av_pair->value;\n            sh.length = av_len;\n            break;\n        case MSV_AV_TIMESTAMP:\n            if (!av_timestamp) continue;\n            memcpy(&timestamp, av_pair->value, sizeof(timestamp));\n            timestamp = le64toh(timestamp);\n            break;\n        case MSV_AV_FLAGS:\n            if (!av_flags) continue;\n            memcpy(&flags, av_pair->value, sizeof(flags));\n            flags = le32toh(flags);\n            break;\n        case MSV_AV_DNS_TREE_NAME:\n            if (!dns_tree_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_tree);\n            if (ret) goto done;\n            break;\n        case MSV_AV_DNS_DOMAIN_NAME:\n            if (!dns_domain_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_domain);\n            if (ret) goto done;\n            break;\n        case MSV_AV_DNS_COMPUTER_NAME:\n            if (!dns_computer_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_computer);\n            if (ret) goto done;\n            break;\n        case MSV_AV_NB_DOMAIN_NAME:\n            if (!nb_domain_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &nb_domain);\n            if (ret) goto done;\n            break;\n        case MSV_AV_NB_COMPUTER_NAME:\n            if (!nb_computer_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &nb_computer);\n            if (ret) goto done;\n            break;\n        default:\n            /* unknown av_pair, or EOL */\n            break;\n        }\n        if (av_id == MSV_AV_EOL) break;\n    }\n\n    if (av_id != MSV_AV_EOL || av_len != 0) {\n        ret = ERR_DECODE;\n    }\n\ndone:\n    if (ret) {\n        ntlm_free_buffer_data(&sh);\n        ntlm_free_buffer_data(&cb);\n        safefree(nb_computer);\n        safefree(nb_domain);\n        safefree(dns_computer);\n        safefree(dns_domain);\n        safefree(dns_tree);\n        safefree(av_target);\n    } else {\n        if (nb_computer_name) *nb_computer_name = nb_computer;\n        if (nb_domain_name) *nb_domain_name = nb_domain;\n        if (dns_computer_name) *dns_computer_name = dns_computer;\n        if (dns_domain_name) *dns_domain_name = dns_domain;\n        if (dns_tree_name) *dns_tree_name = dns_tree;\n        if (av_target_name) *av_target_name = av_target;\n        if (av_timestamp) *av_timestamp = timestamp;\n        if (av_single_host) *av_single_host = sh;\n        if (av_flags) *av_flags = flags;\n        if (av_cb) *av_cb = cb;\n    }\n    return ret;\n}\n\nint ntlm_process_target_info(struct ntlm_ctx *ctx, bool protect,\n                             struct ntlm_buffer *in,\n                             const char *spn,\n                             struct ntlm_buffer *unhashed_cb,\n                             struct ntlm_buffer *out,\n                             uint64_t *out_srv_time,\n                             bool *add_mic)\n{\n    char *nb_computer_name = NULL;\n    char *nb_domain_name = NULL;\n    char *dns_computer_name = NULL;\n    char *dns_domain_name = NULL;\n    char *dns_tree_name = NULL;\n    char *av_target_name = NULL;\n    uint32_t av_flags = 0;\n    uint64_t srv_time = 0;\n    uint8_t cb[16] = { 0 };\n    struct ntlm_buffer av_cb = { NULL, 0 };\n    int ret = 0;\n\n    /* TODO: check that returned netbios/dns names match ? */\n    /* TODO: support SingleHost buffers */\n    ret = ntlm_decode_target_info(ctx, in,\n                                  &nb_computer_name, &nb_domain_name,\n                                  &dns_computer_name, &dns_domain_name,\n                                  &dns_tree_name, &av_target_name,\n                                  &av_flags, &srv_time, NULL, NULL);\n    if (ret) goto done;\n\n    if (protect && (!nb_computer_name || nb_computer_name[0] == '\\0')) {\n        ret = EINVAL;\n        goto done;\n    }\n\n    if (spn && av_target_name &&\n        ((av_flags & MSVAVFLAGS_UNVERIFIED_SPN) == 0)) {\n        if (strcasecmp(spn, av_target_name) != 0) {\n            ret = EINVAL;\n            goto done;\n        }\n    }\n\n    /* the server did not send the timestamp, use current time */\n    if (srv_time == 0) {\n        srv_time = ntlm_timestamp_now();\n    } else if (add_mic) {\n        av_flags |= MSVAVFLAGS_MIC_PRESENT;\n        *add_mic = true;\n    }\n\n    if (unhashed_cb->length > 0) {\n        av_cb.data = cb;\n        av_cb.length = 16;\n        ret = ntlm_hash_channel_bindings(unhashed_cb, &av_cb);\n        if (ret) goto done;\n    }\n\n    if (!av_target_name && spn) {\n        av_target_name = strdup(spn);\n        if (!av_target_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    ret = ntlm_encode_target_info(ctx,\n                                  nb_computer_name, nb_domain_name,\n                                  dns_computer_name, dns_domain_name,\n                                  dns_tree_name, &av_flags, &srv_time,\n                                  NULL, av_target_name, &av_cb, out);\n\ndone:\n    safefree(nb_computer_name);\n    safefree(nb_domain_name);\n    safefree(dns_computer_name);\n    safefree(dns_domain_name);\n    safefree(dns_tree_name);\n    safefree(av_target_name);\n    *out_srv_time = srv_time;\n    return ret;\n}\n\nint ntlm_decode_msg_type(struct ntlm_ctx *ctx,\n                         struct ntlm_buffer *buffer,\n                         uint32_t *type)\n{\n    struct wire_neg_msg *msg;\n    uint32_t msg_type;\n    int ret;\n\n    if (!ctx) return EINVAL;\n\n    if (buffer->length < sizeof(struct wire_msg_hdr)) {\n        return ERR_DECODE;\n    }\n\n    msg = (struct wire_neg_msg *)buffer->data;\n\n    ret = ntlm_decode_header(&msg->header, &msg_type);\n    if (ret) goto done;\n\n    switch (msg_type) {\n    case NEGOTIATE_MESSAGE:\n        if (buffer->length < sizeof(struct wire_neg_msg)) {\n            return ERR_DECODE;\n        }\n        break;\n    case CHALLENGE_MESSAGE:\n        if (buffer->length < sizeof(struct wire_chal_msg) &&\n            buffer->length != sizeof(struct wire_chal_msg_old)) {\n            return ERR_DECODE;\n        }\n        break;\n    case AUTHENTICATE_MESSAGE:\n        if (buffer->length < sizeof(struct wire_auth_msg)) {\n            return ERR_DECODE;\n        }\n        break;\n    default:\n        ret = ERR_DECODE;\n        break;\n    }\n\ndone:\n    if (ret == 0) {\n        *type = msg_type;\n    }\n    return ret;\n}\n\nint ntlm_encode_neg_msg(struct ntlm_ctx *ctx, uint32_t flags,\n                        const char *domain, const char *workstation,\n                        struct ntlm_buffer *message)\n{\n    struct wire_neg_msg *msg;\n    struct ntlm_buffer buffer;\n    size_t data_offs;\n    size_t dom_len = 0;\n    size_t wks_len = 0;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    buffer.length = sizeof(struct wire_neg_msg);\n\n    /* Strings MUST use OEM charset in negotiate message */\n    if (flags & NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED) {\n        if (!domain) return EINVAL;\n        dom_len = strlen(domain);\n        buffer.length += dom_len;\n    }\n    if (flags & NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED) {\n        if (!workstation) return EINVAL;\n        wks_len = strlen(workstation);\n        buffer.length += wks_len;\n    }\n\n    buffer.data = calloc(1, buffer.length);\n    if (!buffer.data) return ENOMEM;\n\n    msg = (struct wire_neg_msg *)buffer.data;\n    data_offs = (char *)msg->payload - (char *)msg;\n\n    ntlm_encode_header(&msg->header, NEGOTIATE_MESSAGE);\n\n    msg->neg_flags = htole32(flags);\n\n    if (dom_len) {\n        ret = ntlm_encode_oem_str(&msg->domain_name, &buffer,\n                                  &data_offs, domain, dom_len);\n        if (ret) goto done;\n    }\n\n    if (wks_len) {\n        ret = ntlm_encode_oem_str(&msg->workstation_name, &buffer,\n                                  &data_offs, workstation, wks_len);\n        if (ret) goto done;\n    }\n\n    if (flags & NTLMSSP_NEGOTIATE_VERSION) {\n        ret = ntlm_encode_version(ctx, &buffer,\n                                  (char *)&msg->version - (char *)msg);\n        if (ret) goto done;\n    }\n\ndone:\n    if (ret) {\n        safefree(buffer.data);\n    } else {\n        *message = buffer;\n    }\n    return ret;\n}\n\nint ntlm_decode_neg_msg(struct ntlm_ctx *ctx,\n                        struct ntlm_buffer *buffer, uint32_t *flags,\n                        char **domain, char **workstation)\n{\n    struct wire_neg_msg *msg;\n    size_t payload_offs;\n    uint32_t neg_flags;\n    char *dom = NULL;\n    char *wks = NULL;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    msg = (struct wire_neg_msg *)buffer->data;\n    payload_offs = (char *)msg->payload - (char *)msg;\n\n    neg_flags = le32toh(msg->neg_flags);\n\n    if ((neg_flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {\n        /* adjust the payload offset to point to the\n         * version field, for compatibility with older\n         * clients that completely omitted the structure\n         * on the wire */\n        payload_offs -= sizeof(struct wire_version);\n    }\n\n    if (domain &&\n        (neg_flags & NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED)) {\n        ret = ntlm_decode_oem_str(&msg->domain_name, buffer,\n                                  payload_offs, &dom);\n        if (ret) goto done;\n    }\n    if (workstation &&\n        (neg_flags & NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED)) {\n        ret = ntlm_decode_oem_str(&msg->workstation_name, buffer,\n                                  payload_offs, &wks);\n        if (ret) goto done;\n    }\n\ndone:\n    if (ret) {\n        safefree(dom);\n        safefree(wks);\n    } else {\n        *flags = neg_flags;\n        if (domain) *domain = dom;\n        if (workstation) *workstation = wks;\n    }\n    return ret;\n}\n\nint ntlm_encode_chal_msg(struct ntlm_ctx *ctx,\n                         uint32_t flags,\n                         const char *target_name,\n                         struct ntlm_buffer *challenge,\n                         struct ntlm_buffer *target_info,\n                         struct ntlm_buffer *message)\n{\n    struct wire_chal_msg *msg;\n    struct ntlm_buffer buffer;\n    size_t data_offs;\n    size_t target_len = 0;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    if (!challenge || challenge->length != 8) return EINVAL;\n\n    buffer.length = sizeof(struct wire_chal_msg);\n\n    if ((flags & NTLMSSP_TARGET_TYPE_SERVER)\n        || (flags & NTLMSSP_TARGET_TYPE_DOMAIN)) {\n        if (!target_name) return EINVAL;\n\n        target_len = strlen(target_name);\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            buffer.length += target_len * 2;\n        } else {\n            buffer.length += target_len;\n        }\n    }\n\n    if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {\n        if (!target_info) return EINVAL;\n\n        buffer.length += target_info->length;\n    }\n\n    buffer.data = calloc(1, buffer.length);\n    if (!buffer.data) return ENOMEM;\n\n    msg = (struct wire_chal_msg *)buffer.data;\n    data_offs = (char *)msg->payload - (char *)msg;\n\n    ntlm_encode_header(&msg->header, CHALLENGE_MESSAGE);\n\n    /* this must be first as it pushes the payload further down */\n    if (flags & NTLMSSP_NEGOTIATE_VERSION) {\n        ret = ntlm_encode_version(ctx, &buffer,\n                                  (char *)&msg->version - (char *)msg);\n        if (ret) goto done;\n    }\n\n    if ((flags & NTLMSSP_TARGET_TYPE_SERVER)\n        || (flags & NTLMSSP_TARGET_TYPE_DOMAIN)) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->target_name, &buffer,\n                                           &data_offs, target_name, target_len);\n        } else {\n            ret = ntlm_encode_oem_str(&msg->target_name, &buffer,\n                                      &data_offs, target_name, target_len);\n        }\n        if (ret) goto done;\n    }\n\n    msg->neg_flags = htole32(flags);\n    memcpy(msg->server_challenge, challenge->data, 8);\n\n    if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {\n        ret = ntlm_encode_field(&msg->target_info, &buffer,\n                                &data_offs, target_info);\n        if (ret) goto done;\n    }\n\ndone:\n    if (ret) {\n        safefree(buffer.data);\n    } else {\n        *message = buffer;\n    }\n    return ret;\n}\n\nint ntlm_decode_chal_msg(struct ntlm_ctx *ctx,\n                         struct ntlm_buffer *buffer,\n                         uint32_t *_flags, char **target_name,\n                         struct ntlm_buffer *challenge,\n                         struct ntlm_buffer *target_info)\n{\n    struct wire_chal_msg *msg;\n    size_t payload_offs;\n    size_t base_chal_size;\n    uint32_t flags;\n    char *trg = NULL;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    if (challenge->length < 8) return EINVAL;\n\n    msg = (struct wire_chal_msg *)buffer->data;\n    payload_offs = (char *)msg->payload - (char *)msg;\n\n    flags = le32toh(msg->neg_flags);\n    base_chal_size = sizeof(struct wire_chal_msg);\n\n    if ((flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {\n        /* adjust the payload offset to point to the\n         * version field, for compatibility with older\n         * clients that completely omitted the structure\n         * on the wire */\n        payload_offs -= sizeof(struct wire_version);\n        base_chal_size -= sizeof(struct wire_version);\n    }\n\n    if ((flags & NTLMSSP_TARGET_TYPE_SERVER)\n        || (flags & NTLMSSP_TARGET_TYPE_DOMAIN)) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->target_name, buffer,\n                                           payload_offs, &trg);\n        } else {\n            ret = ntlm_decode_oem_str(&msg->target_name, buffer,\n                                      payload_offs, &trg);\n        }\n        if (ret) goto done;\n    }\n\n    memcpy(challenge->data, msg->server_challenge, 8);\n    challenge->length = 8;\n\n    /* if we allowed a broken short challenge message from an old\n     * server we must stop here */\n    if (buffer->length < base_chal_size) {\n        if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {\n            ret = ERR_DECODE;\n        }\n        goto done;\n    }\n\n    if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {\n        ret = ntlm_decode_field(&msg->target_info, buffer,\n                                payload_offs, target_info);\n        if (ret) goto done;\n    }\n\ndone:\n    if (ret) {\n        safefree(trg);\n    } else {\n        *_flags = flags;\n        *target_name = trg;\n    }\n    return ret;\n}\n\nint ntlm_encode_auth_msg(struct ntlm_ctx *ctx,\n                         uint32_t flags,\n                         struct ntlm_buffer *lm_chalresp,\n                         struct ntlm_buffer *nt_chalresp,\n                         char *domain_name, char *user_name,\n                         char *workstation,\n                         struct ntlm_buffer *enc_sess_key,\n                         struct ntlm_buffer *mic,\n                         struct ntlm_buffer *message)\n{\n    struct wire_auth_msg *msg;\n    struct ntlm_buffer buffer;\n    struct ntlm_buffer empty_chalresp = { 0 };\n    size_t data_offs;\n    size_t domain_name_len = 0;\n    size_t user_name_len = 0;\n    size_t workstation_len = 0;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    buffer.length = sizeof(struct wire_auth_msg);\n\n    if (lm_chalresp) {\n        buffer.length += lm_chalresp->length;\n    } else {\n        lm_chalresp = &empty_chalresp;\n    }\n    if (nt_chalresp) {\n        buffer.length += nt_chalresp->length;\n    } else {\n        nt_chalresp = &empty_chalresp;\n    }\n    if (domain_name) {\n        domain_name_len = strlen(domain_name);\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            buffer.length += domain_name_len * 2;\n        } else {\n            buffer.length += domain_name_len;\n        }\n    }\n    if (user_name) {\n        user_name_len = strlen(user_name);\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            buffer.length += user_name_len * 2;\n        } else {\n            buffer.length += user_name_len;\n        }\n    }\n    if (workstation) {\n        workstation_len = strlen(workstation);\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            buffer.length += workstation_len * 2;\n        } else {\n            buffer.length += workstation_len;\n        }\n    }\n    if (enc_sess_key) {\n        buffer.length += enc_sess_key->length;\n    }\n    if (mic) {\n        buffer.length += 16;\n    }\n\n    buffer.data = calloc(1, buffer.length);\n    if (!buffer.data) return ENOMEM;\n\n    msg = (struct wire_auth_msg *)buffer.data;\n    data_offs = (char *)msg->payload - (char *)msg;\n\n    ntlm_encode_header(&msg->header, AUTHENTICATE_MESSAGE);\n\n    /* this must be first as it pushes the payload further down */\n    if (flags & NTLMSSP_NEGOTIATE_VERSION) {\n        ret = ntlm_encode_version(ctx, &buffer,\n                                  (char *)&msg->version - (char *)msg);\n        if (ret) goto done;\n    }\n\n    /* this pushes the payload further down */\n    if (mic) {\n        memset(&buffer.data[data_offs], 0, mic->length);\n        /* return the actual pointer back in the mic, as it will\n         * be backfilled later by the caller */\n        mic->data = &buffer.data[data_offs];\n        data_offs += mic->length;\n    }\n\n    ret = ntlm_encode_field(&msg->lm_chalresp, &buffer,\n                            &data_offs, lm_chalresp);\n    if (ret) goto done;\n\n    ret = ntlm_encode_field(&msg->nt_chalresp, &buffer,\n                            &data_offs, nt_chalresp);\n    if (ret) goto done;\n\n    if (domain_name_len) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->domain_name,\n                                           &buffer, &data_offs,\n                                           domain_name, domain_name_len);\n        } else {\n            ret = ntlm_encode_oem_str(&msg->domain_name,\n                                      &buffer, &data_offs,\n                                      domain_name, domain_name_len);\n        }\n        if (ret) goto done;\n    }\n    if (user_name_len) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->user_name,\n                                           &buffer, &data_offs,\n                                           user_name, user_name_len);\n        } else {\n            ret = ntlm_encode_oem_str(&msg->user_name,\n                                      &buffer, &data_offs,\n                                      user_name, user_name_len);\n        }\n        if (ret) goto done;\n    }\n    if (workstation_len) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->workstation,\n                                           &buffer, &data_offs,\n                                           workstation, workstation_len);\n        } else {\n            ret = ntlm_encode_oem_str(&msg->workstation,\n                                      &buffer, &data_offs,\n                                      workstation, workstation_len);\n        }\n        if (ret) goto done;\n    }\n    if (enc_sess_key) {\n        ret = ntlm_encode_field(&msg->enc_sess_key, &buffer,\n                                &data_offs, enc_sess_key);\n        if (ret) goto done;\n    }\n\n    msg->neg_flags = htole32(flags);\n\ndone:\n    if (ret) {\n        safefree(buffer.data);\n    } else {\n        *message = buffer;\n    }\n    return ret;\n}\n\nint ntlm_decode_auth_msg(struct ntlm_ctx *ctx,\n                         struct ntlm_buffer *buffer,\n                         uint32_t flags,\n                         struct ntlm_buffer *lm_chalresp,\n                         struct ntlm_buffer *nt_chalresp,\n                         char **domain_name, char **user_name,\n                         char **workstation,\n                         struct ntlm_buffer *enc_sess_key,\n                         struct ntlm_buffer *target_info,\n                         struct ntlm_buffer *mic)\n{\n    struct wire_auth_msg *msg;\n    uint32_t neg_flags;\n    size_t payload_offs;\n    char *dom = NULL;\n    char *usr = NULL;\n    char *wks = NULL;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    if (lm_chalresp) lm_chalresp->data = NULL;\n    if (nt_chalresp) nt_chalresp->data = NULL;\n    if (enc_sess_key) enc_sess_key->data = NULL;\n\n    msg = (struct wire_auth_msg *)buffer->data;\n    payload_offs = (char *)msg->payload - (char *)msg;\n\n    neg_flags = le32toh(msg->neg_flags);\n    if ((neg_flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {\n        /* adjust the payload offset to point to the\n         * version field, for compatibility with older\n         * clients that completely omitted the structure\n         * on the wire */\n        payload_offs -= sizeof(struct wire_version);\n    }\n\n    /* Unconditionally copy 16 bytes for the MIC, if it was really\n     * added by the client it will be flagged in the AV_PAIR contained\n     * in the NT Response, that will be fully decoded later by the caller\n     * and the MIC checked otherwise these 16 bytes will just be ignored */\n    if (mic) {\n        size_t mic_offs = payload_offs;\n\n        if (mic->length < 16) return ERR_DECODE;\n\n        if ((neg_flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {\n            struct wire_version zver = {0};\n            /* mic is at payload_offs right now, but this offset may be\n             * wrongly reduced for compatibility with older clients,\n             * if all bytes are zeroed, then it means there was an actual\n             * empty version struct */\n            if (memcmp(&msg->version, &zver,\n                       sizeof(struct wire_version)) == 0) {\n                mic_offs += sizeof(struct wire_version);\n            }\n        }\n\n        if (buffer->length - mic_offs < 16) return ERR_DECODE;\n        memcpy(mic->data, &buffer->data[mic_offs], 16);\n    }\n\n    if (msg->lm_chalresp.len != 0 && lm_chalresp) {\n        ret = ntlm_decode_field(&msg->lm_chalresp, buffer,\n                                payload_offs, lm_chalresp);\n        if (ret) goto done;\n    }\n    if (msg->nt_chalresp.len != 0 && nt_chalresp) {\n        ret = ntlm_decode_field(&msg->nt_chalresp, buffer,\n                                payload_offs, nt_chalresp);\n        if (ret) goto done;\n\n        if (target_info) {\n            union wire_ntlm_response *resp;\n            struct wire_ntlmv2_cli_chal *chal;\n            uint8_t *data;\n            int len;\n            resp = (union wire_ntlm_response *)nt_chalresp->data;\n            chal = (struct wire_ntlmv2_cli_chal *)resp->v2.cli_chal;\n            len = nt_chalresp->length - sizeof(resp->v2.resp)\n                    - offsetof(struct wire_ntlmv2_cli_chal, target_info);\n            if (len > 0) {\n                data = chal->target_info;\n                target_info->data = malloc(len);\n                if (!target_info->data) {\n                    ret = ENOMEM;\n                    goto done;\n                }\n                memcpy(target_info->data, data, len);\n                target_info->length = len;\n            }\n        }\n    }\n    if (msg->domain_name.len != 0 && domain_name) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->domain_name, buffer,\n                                           payload_offs, &dom);\n        } else {\n            ret = ntlm_decode_oem_str(&msg->domain_name, buffer,\n                                      payload_offs, &dom);\n        }\n        if (ret) goto done;\n    }\n    if (msg->user_name.len != 0 && user_name) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->user_name, buffer,\n                                           payload_offs, &usr);\n        } else {\n            ret = ntlm_decode_oem_str(&msg->user_name, buffer,\n                                      payload_offs, &usr);\n        }\n        if (ret) goto done;\n    }\n    if (msg->workstation.len != 0 && workstation) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->workstation, buffer,\n                                           payload_offs, &wks);\n        } else {\n            ret = ntlm_decode_oem_str(&msg->workstation, buffer,\n                                      payload_offs, &wks);\n        }\n        if (ret) goto done;\n    }\n    if (msg->enc_sess_key.len != 0 && enc_sess_key) {\n        ret = ntlm_decode_field(&msg->enc_sess_key, buffer,\n                                payload_offs, enc_sess_key);\n    }\n\n    /* ignore returned flags, our flags are authoritative\n    flags = le32toh(msg->neg_flags);\n    */\n\ndone:\n    if (ret) {\n        if (lm_chalresp) safefree(lm_chalresp->data);\n        if (nt_chalresp) safefree(nt_chalresp->data);\n        if (enc_sess_key) safefree(enc_sess_key->data);\n        safefree(dom);\n        safefree(usr);\n        safefree(wks);\n    } else {\n        if (domain_name) *domain_name = dom;\n        if (user_name) *user_name = usr;\n        if (workstation) *workstation = wks;\n    }\n    return ret;\n}\n"], "fixing_code": ["/* Copyright 2013 Simo Sorce <simo@samba.org>, see COPYING for license */\n\n/* This File implements the NTLM protocol as specified by:\n *      [MS-NLMP]: NT LAN Manager (NTLM) Authentication Protocol\n *\n * Additional cross checking with:\n * http://davenport.sourceforge.net/ntlm.html\n */\n\n#include <alloca.h>\n#include <endian.h>\n#include <errno.h>\n#include <iconv.h>\n#include <stddef.h>\n#include <string.h>\n#include <sys/time.h>\n\n#include <unicase.h>\n\n#include \"ntlm.h\"\n\n#pragma pack(push, 1)\nstruct wire_av_pair {\n    uint16_t av_id;\n    uint16_t av_len;\n    uint8_t value[]; /* variable */\n};\n#pragma pack(pop)\n\nenum msv_av_ids {\n    MSV_AV_EOL = 0,\n    MSV_AV_NB_COMPUTER_NAME,\n    MSV_AV_NB_DOMAIN_NAME,\n    MSV_AV_DNS_COMPUTER_NAME,\n    MSV_AV_DNS_DOMAIN_NAME,\n    MSV_AV_DNS_TREE_NAME,\n    MSV_AV_FLAGS,\n    MSV_AV_TIMESTAMP,\n    MSV_AV_SINGLE_HOST,\n    MSV_AV_TARGET_NAME,\n    MSV_AV_CHANNEL_BINDINGS\n};\n\n/* Used only on the same host */\n#pragma pack(push, 1)\nstruct wire_single_host_data {\n    uint32_t size;\n    uint32_t Z4;\n    uint32_t data_present;\n    uint32_t custom_data;\n    uint8_t machine_id[32];\n};\n#pragma pack(pop)\n\n#pragma pack(push, 1)\nstruct wire_ntlm_cli_chal {\n    uint8_t resp_type;\n    uint8_t hi_resp_type;\n    uint16_t reserved1;\n    uint32_t reserved2;\n    uint64_t timestamp;\n    uint8_t cli_chal[8];\n    uint32_t reserved3;\n    uint8_t av_pairs[]; /* variable */\n};\n#pragma pack(pop)\n\nstruct ntlm_ctx {\n    iconv_t from_oem;\n    iconv_t to_oem;\n};\n\nint ntlm_init_ctx(struct ntlm_ctx **ctx)\n{\n    struct ntlm_ctx *_ctx;\n    int ret = 0;\n\n    _ctx = calloc(1, sizeof(struct ntlm_ctx));\n    if (!_ctx) return ENOMEM;\n\n    _ctx->from_oem = iconv_open(\"UTF16LE\", \"UTF-8\");\n    if (_ctx->from_oem == (iconv_t) -1) {\n        ret = errno;\n    }\n\n    _ctx->to_oem = iconv_open(\"UTF-8\", \"UTF16LE\");\n    if (_ctx->to_oem == (iconv_t) -1) {\n        iconv_close(_ctx->from_oem);\n        ret = errno;\n    }\n\n    if (ret) {\n        safefree(_ctx);\n    } else {\n        *ctx = _ctx;\n    }\n    return ret;\n}\n\nint ntlm_free_ctx(struct ntlm_ctx **ctx)\n{\n    int ret;\n\n    if (!ctx || !*ctx) return 0;\n\n    if ((*ctx)->from_oem) {\n        ret = iconv_close((*ctx)->from_oem);\n        if (ret) goto done;\n    }\n\n    if ((*ctx)->to_oem) {\n        ret = iconv_close((*ctx)->to_oem);\n    }\n\ndone:\n    if (ret) ret = errno;\n    safefree(*ctx);\n    return ret;\n}\n\nvoid ntlm_free_buffer_data(struct ntlm_buffer *buf)\n{\n    if (!buf) return;\n\n    safefree(buf->data);\n    buf->length = 0;\n}\n\n/* A FILETIME structure is effectively a little endian 64 bit integer\n * with the time from January 1, 1601 UTC with 10s of microsecond resolution.\n */\n#define FILETIME_EPOCH_VALUE 116444736000000000LL\nuint64_t ntlm_timestamp_now(void)\n{\n    struct timeval tv;\n    uint64_t filetime;\n\n    gettimeofday(&tv, NULL);\n\n    /* set filetime to the time representing the eopch */\n    filetime = FILETIME_EPOCH_VALUE;\n    /* add the number of seconds since the epoch */\n    filetime += (uint64_t)tv.tv_sec * 10000000;\n    /* add the number of microseconds since the epoch */\n    filetime += tv.tv_usec * 10;\n\n    return filetime;\n}\n\nbool ntlm_casecmp(const char *s1, const char *s2)\n{\n    size_t s1_len, s2_len;\n    int ret, res;\n\n    if (s1 == s2) return true;\n    if (!s1 || !s2) return false;\n\n    s1_len = strlen(s1);\n    s2_len = strlen(s2);\n\n    ret = ulc_casecmp(s1, s1_len, s2, s2_len,\n                      uc_locale_language(), NULL, &res);\n    if (ret || res != 0) return false;\n    return true;\n}\n\n\n/**\n * @brief  Converts a string using the provided iconv context.\n *         This function is ok only to convert utf8<->utf16le\n *\n * @param cd        The iconv context\n * @param in        Input buffer\n * @param out       Output buffer\n * @param baselen   Input length\n * @param outlen    Returned length of out buffer\n *\n * NOTE: out must be preallocated to a size of baselen * 2\n *\n * @return 0 on success or a standard error value on error.\n */\nstatic int ntlm_str_convert(iconv_t cd,\n                            const char *in, char *out,\n                            size_t baselen, size_t *outlen)\n{\n    char *_in;\n    size_t inleft, outleft;\n    size_t ret;\n\n    ret = iconv(cd, NULL, NULL, NULL, NULL);\n    if (ret == -1) return errno;\n\n    _in = discard_const(in);\n    inleft = baselen;\n    /* conservative max_size calculation in case lots of octects end up\n     * being multiple bytes in length (in both directions) */\n    outleft = baselen * 2;\n\n    ret = iconv(cd, &_in, &inleft, &out, &outleft);\n    if (ret == -1) return errno;\n\n    if (outlen) {\n        *outlen = baselen * 2 - outleft;\n    }\n    return 0;\n}\n\nuint8_t ntlmssp_sig[8] = {'N', 'T', 'L', 'M', 'S', 'S', 'P', 0};\n\nstatic void ntlm_encode_header(struct wire_msg_hdr *hdr, uint32_t msg_type)\n{\n    memcpy(hdr->signature, ntlmssp_sig, 8);\n    hdr->msg_type = htole32(msg_type);\n}\n\nstatic int ntlm_decode_header(struct wire_msg_hdr *hdr, uint32_t *msg_type)\n{\n    if (memcmp(hdr->signature, ntlmssp_sig, 8) != 0) {\n        return ERR_DECODE;\n    }\n\n    *msg_type = le32toh(hdr->msg_type);\n    return 0;\n}\n\nstatic int ntlm_encode_oem_str(struct wire_field_hdr *hdr,\n                               struct ntlm_buffer *buffer,\n                               size_t *data_offs,\n                               const char *str, int str_len)\n{\n    if (*data_offs + str_len > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    memcpy(&buffer->data[*data_offs], str, str_len);\n    hdr->len = htole16(str_len);\n    hdr->max_len = htole16(str_len);\n    hdr->offset = htole32(*data_offs);\n\n    *data_offs += str_len;\n    return 0;\n}\n\nstatic int ntlm_decode_oem_str(struct wire_field_hdr *str_hdr,\n                               struct ntlm_buffer *buffer,\n                               size_t payload_offs, char **_str)\n{\n    uint16_t str_len;\n    uint32_t str_offs;\n    char *str = NULL;\n\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n\n    str = strndup((const char *)&buffer->data[str_offs], str_len);\n    if (!str) return ENOMEM;\n\ndone:\n    *_str = str;\n    return 0;\n}\n\nstatic int ntlm_encode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t *data_offs,\n                                    const char *str, int str_len)\n{\n    char *out;\n    size_t outlen;\n    int ret;\n\n    out = (char *)&buffer->data[*data_offs];\n\n    ret = ntlm_str_convert(ctx->from_oem, str, out, str_len, &outlen);\n    if (ret) return ret;\n\n    hdr->len = htole16(outlen);\n    hdr->max_len = htole16(outlen);\n    hdr->offset = htole32(*data_offs);\n\n    *data_offs += outlen;\n    return 0;\n}\n\nstatic int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen = 0;\n    int ret = 0;\n\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n\n    in = (char *)&buffer->data[str_offs];\n\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n\ndone:\n    if (ret) {\n        safefree(out);\n    } else {\n        /* make sure to terminate output string */\n        out[outlen] = '\\0';\n    }\n\n    *str = out;\n    return ret;\n}\n\nstruct wire_version ntlmssp_version = {\n    NTLMSSP_VERSION_MAJOR,\n    NTLMSSP_VERSION_MINOR,\n    NTLMSSP_VERSION_BUILD, /* 0 is always 0 even in LE */\n    { 0, 0, 0 },\n    NTLMSSP_VERSION_REV\n};\n\nvoid ntlm_internal_set_version(uint8_t major, uint8_t minor,\n                               uint16_t build, uint8_t revision)\n{\n    ntlmssp_version.major = major;\n    ntlmssp_version.minor = minor;\n    ntlmssp_version.build = htole16(build);\n    ntlmssp_version.revision = revision;\n}\n\nstatic int ntlm_encode_version(struct ntlm_ctx *ctx,\n                               struct ntlm_buffer *buffer,\n                               size_t data_offs)\n{\n    if (data_offs + sizeof(struct wire_version) > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    memcpy(&buffer->data[data_offs], &ntlmssp_version,\n           sizeof(struct wire_version));\n    return 0;\n}\n\nstatic int ntlm_encode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t *data_offs,\n                             struct ntlm_buffer *field)\n{\n    if (*data_offs + field->length > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    memcpy(&buffer->data[*data_offs], field->data, field->length);\n    hdr->len = htole16(field->length);\n    hdr->max_len = hdr->len;\n    hdr->offset = htole32(*data_offs);\n\n    *data_offs += field->length;\n    return 0;\n}\n\nstatic int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\n\ndone:\n    *field = b;\n    return 0;\n}\n\nstatic int ntlm_encode_av_pair_u16l_str(struct ntlm_ctx *ctx,\n                                        struct ntlm_buffer *buffer,\n                                        size_t *data_offs,\n                                        enum msv_av_ids av_id,\n                                        const char *str, size_t str_len)\n{\n    struct wire_av_pair *av_pair;\n    char *out;\n    size_t outlen;\n    int ret;\n\n    if (*data_offs + 4 + str_len > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    av_pair = (struct wire_av_pair *)&buffer->data[*data_offs];\n    out = (char *)av_pair->value;\n\n    ret = ntlm_str_convert(ctx->from_oem, str, out, str_len, &outlen);\n    if (ret) return ret;\n\n    av_pair->av_len = htole16(outlen);\n    av_pair->av_id = htole16(av_id);\n\n    *data_offs += av_pair->av_len + 4;\n    return 0;\n}\n\nstatic int ntlm_decode_av_pair_u16l_str(struct ntlm_ctx *ctx,\n                                        struct wire_av_pair *av_pair,\n                                        char **str)\n{\n    char *in, *out;\n    size_t inlen, outlen;\n    int ret;\n\n    in = (char *)av_pair->value;\n    inlen = le16toh(av_pair->av_len);\n    out = malloc(inlen * 2 + 1);\n\n    ret = ntlm_str_convert(ctx->to_oem, in, out, inlen, &outlen);\n    if (ret) {\n        safefree(out);\n        return ret;\n    }\n    /* terminate out string for sure */\n    out[outlen] = '\\0';\n\n    *str = out;\n    return 0;\n}\n\nstatic int ntlm_encode_av_pair_value(struct ntlm_buffer *buffer,\n                                     size_t *data_offs,\n                                     enum msv_av_ids av_id,\n                                     struct ntlm_buffer *value)\n{\n    struct wire_av_pair *av_pair;\n\n    if (*data_offs + 4 + value->length > buffer->length) {\n        return ERR_ENCODE;\n    }\n\n    av_pair = (struct wire_av_pair *)&buffer->data[*data_offs];\n    av_pair->av_id = htole16(av_id);\n    av_pair->av_len = htole16(value->length);\n    if (value->length) {\n        memcpy(av_pair->value, value->data, value->length);\n    }\n\n    *data_offs += value->length + 4;\n    return 0;\n}\n\nint ntlm_encode_target_info(struct ntlm_ctx *ctx, char *nb_computer_name,\n                            char *nb_domain_name, char *dns_computer_name,\n                            char *dns_domain_name, char *dns_tree_name,\n                            uint32_t *av_flags, uint64_t *av_timestamp,\n                            struct ntlm_buffer *av_single_host,\n                            char *av_target_name, struct ntlm_buffer *av_cb,\n                            struct ntlm_buffer *target_info)\n{\n    struct ntlm_buffer buffer;\n    size_t data_offs;\n    size_t max_size;\n    size_t nb_computer_name_len = 0;\n    size_t nb_domain_name_len = 0;\n    size_t dns_computer_name_len = 0;\n    size_t dns_domain_name_len = 0;\n    size_t dns_tree_name_len = 0;\n    size_t av_target_name_len = 0;\n    struct ntlm_buffer value;\n    int ret = 0;\n\n    max_size = 4; /* MSV_AV_EOL */\n\n    if (nb_computer_name) {\n        nb_computer_name_len = strlen(nb_computer_name);\n        max_size += 4 + nb_computer_name_len * 2;\n    }\n    if (nb_domain_name) {\n        nb_domain_name_len = strlen(nb_domain_name);\n        max_size += 4 + nb_domain_name_len * 2;\n    }\n    if (dns_computer_name) {\n        dns_computer_name_len = strlen(dns_computer_name);\n        max_size += 4 + dns_computer_name_len * 2;\n    }\n    if (dns_domain_name) {\n        dns_domain_name_len = strlen(dns_domain_name);\n        max_size += 4 + dns_domain_name_len * 2;\n    }\n    if (dns_tree_name) {\n        dns_tree_name_len = strlen(dns_tree_name);\n        max_size += 4 + dns_tree_name_len * 2;\n    }\n    if (av_flags) {\n        max_size += 4 + 4;\n    }\n    if (av_timestamp) {\n        max_size += 4 + 8;\n    }\n    if (av_single_host) {\n        max_size += 4 + av_single_host->length;\n    }\n    if (av_target_name) {\n        av_target_name_len = strlen(av_target_name);\n        max_size += 4 + av_target_name_len * 2;\n    }\n    if (av_cb && av_cb->length > 0) {\n        max_size += 4 + av_cb->length;\n    }\n\n    data_offs = 0;\n    buffer.length = max_size;\n    buffer.data = calloc(1, buffer.length);\n    if (!buffer.data) return ENOMEM;\n\n    if (nb_computer_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_NB_COMPUTER_NAME,\n                                           nb_computer_name,\n                                           nb_computer_name_len);\n        if (ret) goto done;\n    }\n    if (nb_domain_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_NB_DOMAIN_NAME,\n                                           nb_domain_name,\n                                           nb_domain_name_len);\n        if (ret) goto done;\n    }\n    if (dns_computer_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_DNS_COMPUTER_NAME,\n                                           dns_computer_name,\n                                           dns_computer_name_len);\n        if (ret) goto done;\n    }\n    if (dns_domain_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_DNS_DOMAIN_NAME,\n                                           dns_domain_name,\n                                           dns_domain_name_len);\n        if (ret) goto done;\n    }\n    if (dns_tree_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_DNS_TREE_NAME,\n                                           dns_tree_name,\n                                           dns_tree_name_len);\n        if (ret) goto done;\n    }\n    if (av_flags) {\n        uint32_t flags = htole32(*av_flags);\n        value.data = (uint8_t *)&flags;\n        value.length = 4;\n        ret = ntlm_encode_av_pair_value(&buffer, &data_offs,\n                                        MSV_AV_FLAGS, &value);\n        if (ret) goto done;\n    }\n    if (av_timestamp) {\n        uint64_t timestamp = htole64(*av_timestamp);\n        value.data = (uint8_t *)&timestamp;\n        value.length = 8;\n        ret = ntlm_encode_av_pair_value(&buffer, &data_offs,\n                                        MSV_AV_TIMESTAMP, &value);\n        if (ret) goto done;\n    }\n    if (av_single_host) {\n        ret = ntlm_encode_av_pair_value(&buffer, &data_offs,\n                                        MSV_AV_SINGLE_HOST, av_single_host);\n        if (ret) goto done;\n    }\n    if (av_target_name) {\n        ret = ntlm_encode_av_pair_u16l_str(ctx, &buffer, &data_offs,\n                                           MSV_AV_TARGET_NAME,\n                                           av_target_name,\n                                           av_target_name_len);\n        if (ret) goto done;\n    }\n    if (av_cb && av_cb->length > 0) {\n        ret = ntlm_encode_av_pair_value(&buffer, &data_offs,\n                                        MSV_AV_CHANNEL_BINDINGS, av_cb);\n        if (ret) goto done;\n    }\n\n    value.length = 0;\n    value.data = NULL;\n    ret = ntlm_encode_av_pair_value(&buffer, &data_offs, MSV_AV_EOL, &value);\n    buffer.length = data_offs;\n\ndone:\n    if (ret) {\n       safefree(buffer.data);\n    } else {\n        *target_info = buffer;\n    }\n    return ret;\n}\n\nint ntlm_decode_target_info(struct ntlm_ctx *ctx, struct ntlm_buffer *buffer,\n                            char **nb_computer_name, char **nb_domain_name,\n                            char **dns_computer_name, char **dns_domain_name,\n                            char **dns_tree_name, char **av_target_name,\n                            uint32_t *av_flags, uint64_t *av_timestamp,\n                            struct ntlm_buffer *av_single_host,\n                            struct ntlm_buffer *av_cb)\n{\n    struct wire_av_pair *av_pair;\n    uint16_t av_id = (uint16_t)-1;\n    uint16_t av_len = (uint16_t)-1;\n    struct ntlm_buffer sh = { NULL, 0 };\n    struct ntlm_buffer cb = { NULL, 0 };\n    char *nb_computer = NULL;\n    char *nb_domain = NULL;\n    char *dns_computer = NULL;\n    char *dns_domain = NULL;\n    char *dns_tree = NULL;\n    char *av_target = NULL;\n    size_t data_offs = 0;\n    uint64_t timestamp = 0;\n    uint32_t flags = 0;\n    int ret = 0;\n\n    while (data_offs + 4 <= buffer->length) {\n        av_pair = (struct wire_av_pair *)&buffer->data[data_offs];\n        data_offs += 4;\n        av_id = le16toh(av_pair->av_id);\n        av_len = le16toh(av_pair->av_len);\n        if (av_len > buffer->length - data_offs) {\n            ret = ERR_DECODE;\n            goto done;\n        }\n        data_offs += av_len;\n\n        switch (av_id) {\n        case MSV_AV_CHANNEL_BINDINGS:\n            if (!av_cb) continue;\n            cb.data = av_pair->value;\n            cb.length = av_len;\n            break;\n        case MSV_AV_TARGET_NAME:\n            if (!av_target_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &av_target);\n            if (ret) goto done;\n            break;\n        case MSV_AV_SINGLE_HOST:\n            if (!av_single_host) continue;\n            sh.data = av_pair->value;\n            sh.length = av_len;\n            break;\n        case MSV_AV_TIMESTAMP:\n            if (!av_timestamp) continue;\n            memcpy(&timestamp, av_pair->value, sizeof(timestamp));\n            timestamp = le64toh(timestamp);\n            break;\n        case MSV_AV_FLAGS:\n            if (!av_flags) continue;\n            memcpy(&flags, av_pair->value, sizeof(flags));\n            flags = le32toh(flags);\n            break;\n        case MSV_AV_DNS_TREE_NAME:\n            if (!dns_tree_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_tree);\n            if (ret) goto done;\n            break;\n        case MSV_AV_DNS_DOMAIN_NAME:\n            if (!dns_domain_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_domain);\n            if (ret) goto done;\n            break;\n        case MSV_AV_DNS_COMPUTER_NAME:\n            if (!dns_computer_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_computer);\n            if (ret) goto done;\n            break;\n        case MSV_AV_NB_DOMAIN_NAME:\n            if (!nb_domain_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &nb_domain);\n            if (ret) goto done;\n            break;\n        case MSV_AV_NB_COMPUTER_NAME:\n            if (!nb_computer_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &nb_computer);\n            if (ret) goto done;\n            break;\n        default:\n            /* unknown av_pair, or EOL */\n            break;\n        }\n        if (av_id == MSV_AV_EOL) break;\n    }\n\n    if (av_id != MSV_AV_EOL || av_len != 0) {\n        ret = ERR_DECODE;\n    }\n\ndone:\n    if (ret) {\n        safefree(nb_computer);\n        safefree(nb_domain);\n        safefree(dns_computer);\n        safefree(dns_domain);\n        safefree(dns_tree);\n        safefree(av_target);\n    } else {\n        if (nb_computer_name) *nb_computer_name = nb_computer;\n        if (nb_domain_name) *nb_domain_name = nb_domain;\n        if (dns_computer_name) *dns_computer_name = dns_computer;\n        if (dns_domain_name) *dns_domain_name = dns_domain;\n        if (dns_tree_name) *dns_tree_name = dns_tree;\n        if (av_target_name) *av_target_name = av_target;\n        if (av_timestamp) *av_timestamp = timestamp;\n        if (av_single_host) *av_single_host = sh;\n        if (av_flags) *av_flags = flags;\n        if (av_cb) *av_cb = cb;\n    }\n    return ret;\n}\n\nint ntlm_process_target_info(struct ntlm_ctx *ctx, bool protect,\n                             struct ntlm_buffer *in,\n                             const char *spn,\n                             struct ntlm_buffer *unhashed_cb,\n                             struct ntlm_buffer *out,\n                             uint64_t *out_srv_time,\n                             bool *add_mic)\n{\n    char *nb_computer_name = NULL;\n    char *nb_domain_name = NULL;\n    char *dns_computer_name = NULL;\n    char *dns_domain_name = NULL;\n    char *dns_tree_name = NULL;\n    char *av_target_name = NULL;\n    uint32_t av_flags = 0;\n    uint64_t srv_time = 0;\n    uint8_t cb[16] = { 0 };\n    struct ntlm_buffer av_cb = { NULL, 0 };\n    int ret = 0;\n\n    /* TODO: check that returned netbios/dns names match ? */\n    /* TODO: support SingleHost buffers */\n    ret = ntlm_decode_target_info(ctx, in,\n                                  &nb_computer_name, &nb_domain_name,\n                                  &dns_computer_name, &dns_domain_name,\n                                  &dns_tree_name, &av_target_name,\n                                  &av_flags, &srv_time, NULL, NULL);\n    if (ret) goto done;\n\n    if (protect && (!nb_computer_name || nb_computer_name[0] == '\\0')) {\n        ret = EINVAL;\n        goto done;\n    }\n\n    if (spn && av_target_name &&\n        ((av_flags & MSVAVFLAGS_UNVERIFIED_SPN) == 0)) {\n        if (strcasecmp(spn, av_target_name) != 0) {\n            ret = EINVAL;\n            goto done;\n        }\n    }\n\n    /* the server did not send the timestamp, use current time */\n    if (srv_time == 0) {\n        srv_time = ntlm_timestamp_now();\n    } else if (add_mic) {\n        av_flags |= MSVAVFLAGS_MIC_PRESENT;\n        *add_mic = true;\n    }\n\n    if (unhashed_cb->length > 0) {\n        av_cb.data = cb;\n        av_cb.length = 16;\n        ret = ntlm_hash_channel_bindings(unhashed_cb, &av_cb);\n        if (ret) goto done;\n    }\n\n    if (!av_target_name && spn) {\n        av_target_name = strdup(spn);\n        if (!av_target_name) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    ret = ntlm_encode_target_info(ctx,\n                                  nb_computer_name, nb_domain_name,\n                                  dns_computer_name, dns_domain_name,\n                                  dns_tree_name, &av_flags, &srv_time,\n                                  NULL, av_target_name, &av_cb, out);\n\ndone:\n    safefree(nb_computer_name);\n    safefree(nb_domain_name);\n    safefree(dns_computer_name);\n    safefree(dns_domain_name);\n    safefree(dns_tree_name);\n    safefree(av_target_name);\n    *out_srv_time = srv_time;\n    return ret;\n}\n\nint ntlm_decode_msg_type(struct ntlm_ctx *ctx,\n                         struct ntlm_buffer *buffer,\n                         uint32_t *type)\n{\n    struct wire_neg_msg *msg;\n    uint32_t msg_type;\n    int ret;\n\n    if (!ctx) return EINVAL;\n\n    if (buffer->length < sizeof(struct wire_msg_hdr)) {\n        return ERR_DECODE;\n    }\n\n    msg = (struct wire_neg_msg *)buffer->data;\n\n    ret = ntlm_decode_header(&msg->header, &msg_type);\n    if (ret) goto done;\n\n    switch (msg_type) {\n    case NEGOTIATE_MESSAGE:\n        if (buffer->length < sizeof(struct wire_neg_msg)) {\n            return ERR_DECODE;\n        }\n        break;\n    case CHALLENGE_MESSAGE:\n        if (buffer->length < sizeof(struct wire_chal_msg) &&\n            buffer->length != sizeof(struct wire_chal_msg_old)) {\n            return ERR_DECODE;\n        }\n        break;\n    case AUTHENTICATE_MESSAGE:\n        if (buffer->length < sizeof(struct wire_auth_msg)) {\n            return ERR_DECODE;\n        }\n        break;\n    default:\n        ret = ERR_DECODE;\n        break;\n    }\n\ndone:\n    if (ret == 0) {\n        *type = msg_type;\n    }\n    return ret;\n}\n\nint ntlm_encode_neg_msg(struct ntlm_ctx *ctx, uint32_t flags,\n                        const char *domain, const char *workstation,\n                        struct ntlm_buffer *message)\n{\n    struct wire_neg_msg *msg;\n    struct ntlm_buffer buffer;\n    size_t data_offs;\n    size_t dom_len = 0;\n    size_t wks_len = 0;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    buffer.length = sizeof(struct wire_neg_msg);\n\n    /* Strings MUST use OEM charset in negotiate message */\n    if (flags & NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED) {\n        if (!domain) return EINVAL;\n        dom_len = strlen(domain);\n        buffer.length += dom_len;\n    }\n    if (flags & NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED) {\n        if (!workstation) return EINVAL;\n        wks_len = strlen(workstation);\n        buffer.length += wks_len;\n    }\n\n    buffer.data = calloc(1, buffer.length);\n    if (!buffer.data) return ENOMEM;\n\n    msg = (struct wire_neg_msg *)buffer.data;\n    data_offs = (char *)msg->payload - (char *)msg;\n\n    ntlm_encode_header(&msg->header, NEGOTIATE_MESSAGE);\n\n    msg->neg_flags = htole32(flags);\n\n    if (dom_len) {\n        ret = ntlm_encode_oem_str(&msg->domain_name, &buffer,\n                                  &data_offs, domain, dom_len);\n        if (ret) goto done;\n    }\n\n    if (wks_len) {\n        ret = ntlm_encode_oem_str(&msg->workstation_name, &buffer,\n                                  &data_offs, workstation, wks_len);\n        if (ret) goto done;\n    }\n\n    if (flags & NTLMSSP_NEGOTIATE_VERSION) {\n        ret = ntlm_encode_version(ctx, &buffer,\n                                  (char *)&msg->version - (char *)msg);\n        if (ret) goto done;\n    }\n\ndone:\n    if (ret) {\n        safefree(buffer.data);\n    } else {\n        *message = buffer;\n    }\n    return ret;\n}\n\nint ntlm_decode_neg_msg(struct ntlm_ctx *ctx,\n                        struct ntlm_buffer *buffer, uint32_t *flags,\n                        char **domain, char **workstation)\n{\n    struct wire_neg_msg *msg;\n    size_t payload_offs;\n    uint32_t neg_flags;\n    char *dom = NULL;\n    char *wks = NULL;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    msg = (struct wire_neg_msg *)buffer->data;\n    payload_offs = (char *)msg->payload - (char *)msg;\n\n    neg_flags = le32toh(msg->neg_flags);\n\n    if ((neg_flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {\n        /* adjust the payload offset to point to the\n         * version field, for compatibility with older\n         * clients that completely omitted the structure\n         * on the wire */\n        payload_offs -= sizeof(struct wire_version);\n    }\n\n    if (domain &&\n        (neg_flags & NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED)) {\n        ret = ntlm_decode_oem_str(&msg->domain_name, buffer,\n                                  payload_offs, &dom);\n        if (ret) goto done;\n    }\n    if (workstation &&\n        (neg_flags & NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED)) {\n        ret = ntlm_decode_oem_str(&msg->workstation_name, buffer,\n                                  payload_offs, &wks);\n        if (ret) goto done;\n    }\n\ndone:\n    if (ret) {\n        safefree(dom);\n        safefree(wks);\n    } else {\n        *flags = neg_flags;\n        if (domain) *domain = dom;\n        if (workstation) *workstation = wks;\n    }\n    return ret;\n}\n\nint ntlm_encode_chal_msg(struct ntlm_ctx *ctx,\n                         uint32_t flags,\n                         const char *target_name,\n                         struct ntlm_buffer *challenge,\n                         struct ntlm_buffer *target_info,\n                         struct ntlm_buffer *message)\n{\n    struct wire_chal_msg *msg;\n    struct ntlm_buffer buffer;\n    size_t data_offs;\n    size_t target_len = 0;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    if (!challenge || challenge->length != 8) return EINVAL;\n\n    buffer.length = sizeof(struct wire_chal_msg);\n\n    if ((flags & NTLMSSP_TARGET_TYPE_SERVER)\n        || (flags & NTLMSSP_TARGET_TYPE_DOMAIN)) {\n        if (!target_name) return EINVAL;\n\n        target_len = strlen(target_name);\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            buffer.length += target_len * 2;\n        } else {\n            buffer.length += target_len;\n        }\n    }\n\n    if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {\n        if (!target_info) return EINVAL;\n\n        buffer.length += target_info->length;\n    }\n\n    buffer.data = calloc(1, buffer.length);\n    if (!buffer.data) return ENOMEM;\n\n    msg = (struct wire_chal_msg *)buffer.data;\n    data_offs = (char *)msg->payload - (char *)msg;\n\n    ntlm_encode_header(&msg->header, CHALLENGE_MESSAGE);\n\n    /* this must be first as it pushes the payload further down */\n    if (flags & NTLMSSP_NEGOTIATE_VERSION) {\n        ret = ntlm_encode_version(ctx, &buffer,\n                                  (char *)&msg->version - (char *)msg);\n        if (ret) goto done;\n    }\n\n    if ((flags & NTLMSSP_TARGET_TYPE_SERVER)\n        || (flags & NTLMSSP_TARGET_TYPE_DOMAIN)) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->target_name, &buffer,\n                                           &data_offs, target_name, target_len);\n        } else {\n            ret = ntlm_encode_oem_str(&msg->target_name, &buffer,\n                                      &data_offs, target_name, target_len);\n        }\n        if (ret) goto done;\n    }\n\n    msg->neg_flags = htole32(flags);\n    memcpy(msg->server_challenge, challenge->data, 8);\n\n    if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {\n        ret = ntlm_encode_field(&msg->target_info, &buffer,\n                                &data_offs, target_info);\n        if (ret) goto done;\n    }\n\ndone:\n    if (ret) {\n        safefree(buffer.data);\n    } else {\n        *message = buffer;\n    }\n    return ret;\n}\n\nint ntlm_decode_chal_msg(struct ntlm_ctx *ctx,\n                         struct ntlm_buffer *buffer,\n                         uint32_t *_flags, char **target_name,\n                         struct ntlm_buffer *challenge,\n                         struct ntlm_buffer *target_info)\n{\n    struct wire_chal_msg *msg;\n    size_t payload_offs;\n    size_t base_chal_size;\n    uint32_t flags;\n    char *trg = NULL;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    if (challenge->length < 8) return EINVAL;\n\n    msg = (struct wire_chal_msg *)buffer->data;\n    payload_offs = (char *)msg->payload - (char *)msg;\n\n    flags = le32toh(msg->neg_flags);\n    base_chal_size = sizeof(struct wire_chal_msg);\n\n    if ((flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {\n        /* adjust the payload offset to point to the\n         * version field, for compatibility with older\n         * clients that completely omitted the structure\n         * on the wire */\n        payload_offs -= sizeof(struct wire_version);\n        base_chal_size -= sizeof(struct wire_version);\n    }\n\n    if ((flags & NTLMSSP_TARGET_TYPE_SERVER)\n        || (flags & NTLMSSP_TARGET_TYPE_DOMAIN)) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->target_name, buffer,\n                                           payload_offs, &trg);\n        } else {\n            ret = ntlm_decode_oem_str(&msg->target_name, buffer,\n                                      payload_offs, &trg);\n        }\n        if (ret) goto done;\n    }\n\n    memcpy(challenge->data, msg->server_challenge, 8);\n    challenge->length = 8;\n\n    /* if we allowed a broken short challenge message from an old\n     * server we must stop here */\n    if (buffer->length < base_chal_size) {\n        if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {\n            ret = ERR_DECODE;\n        }\n        goto done;\n    }\n\n    if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {\n        ret = ntlm_decode_field(&msg->target_info, buffer,\n                                payload_offs, target_info);\n        if (ret) goto done;\n    }\n\ndone:\n    if (ret) {\n        safefree(trg);\n    } else {\n        *_flags = flags;\n        *target_name = trg;\n    }\n    return ret;\n}\n\nint ntlm_encode_auth_msg(struct ntlm_ctx *ctx,\n                         uint32_t flags,\n                         struct ntlm_buffer *lm_chalresp,\n                         struct ntlm_buffer *nt_chalresp,\n                         char *domain_name, char *user_name,\n                         char *workstation,\n                         struct ntlm_buffer *enc_sess_key,\n                         struct ntlm_buffer *mic,\n                         struct ntlm_buffer *message)\n{\n    struct wire_auth_msg *msg;\n    struct ntlm_buffer buffer;\n    struct ntlm_buffer empty_chalresp = { 0 };\n    size_t data_offs;\n    size_t domain_name_len = 0;\n    size_t user_name_len = 0;\n    size_t workstation_len = 0;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    buffer.length = sizeof(struct wire_auth_msg);\n\n    if (lm_chalresp) {\n        buffer.length += lm_chalresp->length;\n    } else {\n        lm_chalresp = &empty_chalresp;\n    }\n    if (nt_chalresp) {\n        buffer.length += nt_chalresp->length;\n    } else {\n        nt_chalresp = &empty_chalresp;\n    }\n    if (domain_name) {\n        domain_name_len = strlen(domain_name);\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            buffer.length += domain_name_len * 2;\n        } else {\n            buffer.length += domain_name_len;\n        }\n    }\n    if (user_name) {\n        user_name_len = strlen(user_name);\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            buffer.length += user_name_len * 2;\n        } else {\n            buffer.length += user_name_len;\n        }\n    }\n    if (workstation) {\n        workstation_len = strlen(workstation);\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            buffer.length += workstation_len * 2;\n        } else {\n            buffer.length += workstation_len;\n        }\n    }\n    if (enc_sess_key) {\n        buffer.length += enc_sess_key->length;\n    }\n    if (mic) {\n        buffer.length += 16;\n    }\n\n    buffer.data = calloc(1, buffer.length);\n    if (!buffer.data) return ENOMEM;\n\n    msg = (struct wire_auth_msg *)buffer.data;\n    data_offs = (char *)msg->payload - (char *)msg;\n\n    ntlm_encode_header(&msg->header, AUTHENTICATE_MESSAGE);\n\n    /* this must be first as it pushes the payload further down */\n    if (flags & NTLMSSP_NEGOTIATE_VERSION) {\n        ret = ntlm_encode_version(ctx, &buffer,\n                                  (char *)&msg->version - (char *)msg);\n        if (ret) goto done;\n    }\n\n    /* this pushes the payload further down */\n    if (mic) {\n        memset(&buffer.data[data_offs], 0, mic->length);\n        /* return the actual pointer back in the mic, as it will\n         * be backfilled later by the caller */\n        mic->data = &buffer.data[data_offs];\n        data_offs += mic->length;\n    }\n\n    ret = ntlm_encode_field(&msg->lm_chalresp, &buffer,\n                            &data_offs, lm_chalresp);\n    if (ret) goto done;\n\n    ret = ntlm_encode_field(&msg->nt_chalresp, &buffer,\n                            &data_offs, nt_chalresp);\n    if (ret) goto done;\n\n    if (domain_name_len) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->domain_name,\n                                           &buffer, &data_offs,\n                                           domain_name, domain_name_len);\n        } else {\n            ret = ntlm_encode_oem_str(&msg->domain_name,\n                                      &buffer, &data_offs,\n                                      domain_name, domain_name_len);\n        }\n        if (ret) goto done;\n    }\n    if (user_name_len) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->user_name,\n                                           &buffer, &data_offs,\n                                           user_name, user_name_len);\n        } else {\n            ret = ntlm_encode_oem_str(&msg->user_name,\n                                      &buffer, &data_offs,\n                                      user_name, user_name_len);\n        }\n        if (ret) goto done;\n    }\n    if (workstation_len) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->workstation,\n                                           &buffer, &data_offs,\n                                           workstation, workstation_len);\n        } else {\n            ret = ntlm_encode_oem_str(&msg->workstation,\n                                      &buffer, &data_offs,\n                                      workstation, workstation_len);\n        }\n        if (ret) goto done;\n    }\n    if (enc_sess_key) {\n        ret = ntlm_encode_field(&msg->enc_sess_key, &buffer,\n                                &data_offs, enc_sess_key);\n        if (ret) goto done;\n    }\n\n    msg->neg_flags = htole32(flags);\n\ndone:\n    if (ret) {\n        safefree(buffer.data);\n    } else {\n        *message = buffer;\n    }\n    return ret;\n}\n\nint ntlm_decode_auth_msg(struct ntlm_ctx *ctx,\n                         struct ntlm_buffer *buffer,\n                         uint32_t flags,\n                         struct ntlm_buffer *lm_chalresp,\n                         struct ntlm_buffer *nt_chalresp,\n                         char **domain_name, char **user_name,\n                         char **workstation,\n                         struct ntlm_buffer *enc_sess_key,\n                         struct ntlm_buffer *target_info,\n                         struct ntlm_buffer *mic)\n{\n    struct wire_auth_msg *msg;\n    uint32_t neg_flags;\n    size_t payload_offs;\n    char *dom = NULL;\n    char *usr = NULL;\n    char *wks = NULL;\n    int ret = 0;\n\n    if (!ctx) return EINVAL;\n\n    if (lm_chalresp) lm_chalresp->data = NULL;\n    if (nt_chalresp) nt_chalresp->data = NULL;\n    if (enc_sess_key) enc_sess_key->data = NULL;\n\n    msg = (struct wire_auth_msg *)buffer->data;\n    payload_offs = (char *)msg->payload - (char *)msg;\n\n    neg_flags = le32toh(msg->neg_flags);\n    if ((neg_flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {\n        /* adjust the payload offset to point to the\n         * version field, for compatibility with older\n         * clients that completely omitted the structure\n         * on the wire */\n        payload_offs -= sizeof(struct wire_version);\n    }\n\n    /* Unconditionally copy 16 bytes for the MIC, if it was really\n     * added by the client it will be flagged in the AV_PAIR contained\n     * in the NT Response, that will be fully decoded later by the caller\n     * and the MIC checked otherwise these 16 bytes will just be ignored */\n    if (mic) {\n        size_t mic_offs = payload_offs;\n\n        if (mic->length < 16) return ERR_DECODE;\n\n        if ((neg_flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {\n            struct wire_version zver = {0};\n            /* mic is at payload_offs right now, but this offset may be\n             * wrongly reduced for compatibility with older clients,\n             * if all bytes are zeroed, then it means there was an actual\n             * empty version struct */\n            if (memcmp(&msg->version, &zver,\n                       sizeof(struct wire_version)) == 0) {\n                mic_offs += sizeof(struct wire_version);\n            }\n        }\n\n        if (buffer->length - mic_offs < 16) return ERR_DECODE;\n        memcpy(mic->data, &buffer->data[mic_offs], 16);\n    }\n\n    if (msg->lm_chalresp.len != 0 && lm_chalresp) {\n        ret = ntlm_decode_field(&msg->lm_chalresp, buffer,\n                                payload_offs, lm_chalresp);\n        if (ret) goto done;\n    }\n    if (msg->nt_chalresp.len != 0 && nt_chalresp) {\n        ret = ntlm_decode_field(&msg->nt_chalresp, buffer,\n                                payload_offs, nt_chalresp);\n        if (ret) goto done;\n\n        if (target_info) {\n            union wire_ntlm_response *resp;\n            struct wire_ntlmv2_cli_chal *chal;\n            uint8_t *data;\n            int len;\n            resp = (union wire_ntlm_response *)nt_chalresp->data;\n            chal = (struct wire_ntlmv2_cli_chal *)resp->v2.cli_chal;\n            len = nt_chalresp->length - sizeof(resp->v2.resp)\n                    - offsetof(struct wire_ntlmv2_cli_chal, target_info);\n            if (len > 0) {\n                data = chal->target_info;\n                target_info->data = malloc(len);\n                if (!target_info->data) {\n                    ret = ENOMEM;\n                    goto done;\n                }\n                memcpy(target_info->data, data, len);\n                target_info->length = len;\n            }\n        }\n    }\n    if (msg->domain_name.len != 0 && domain_name) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->domain_name, buffer,\n                                           payload_offs, &dom);\n        } else {\n            ret = ntlm_decode_oem_str(&msg->domain_name, buffer,\n                                      payload_offs, &dom);\n        }\n        if (ret) goto done;\n    }\n    if (msg->user_name.len != 0 && user_name) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->user_name, buffer,\n                                           payload_offs, &usr);\n        } else {\n            ret = ntlm_decode_oem_str(&msg->user_name, buffer,\n                                      payload_offs, &usr);\n        }\n        if (ret) goto done;\n    }\n    if (msg->workstation.len != 0 && workstation) {\n        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {\n            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->workstation, buffer,\n                                           payload_offs, &wks);\n        } else {\n            ret = ntlm_decode_oem_str(&msg->workstation, buffer,\n                                      payload_offs, &wks);\n        }\n        if (ret) goto done;\n    }\n    if (msg->enc_sess_key.len != 0 && enc_sess_key) {\n        ret = ntlm_decode_field(&msg->enc_sess_key, buffer,\n                                payload_offs, enc_sess_key);\n    }\n\n    /* ignore returned flags, our flags are authoritative\n    flags = le32toh(msg->neg_flags);\n    */\n\ndone:\n    if (ret) {\n        if (lm_chalresp) safefree(lm_chalresp->data);\n        if (nt_chalresp) safefree(nt_chalresp->data);\n        if (enc_sess_key) safefree(enc_sess_key->data);\n        safefree(dom);\n        safefree(usr);\n        safefree(wks);\n    } else {\n        if (domain_name) *domain_name = dom;\n        if (user_name) *user_name = usr;\n        if (workstation) *workstation = wks;\n    }\n    return ret;\n}\n"], "filenames": ["src/ntlm.c"], "buggy_code_start_loc": [734], "buggy_code_end_loc": [736], "fixing_code_start_loc": [733], "fixing_code_end_loc": [733], "type": "CWE-763", "message": "GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM authentication. Prior to version 1.2.0, an incorrect free when decoding target information can trigger a denial of service. The error condition incorrectly assumes the `cb` and `sh` buffers contain a copy of the data that needs to be freed. However, that is not the case. This vulnerability can be triggered via the main `gss_accept_sec_context` entry point. This will likely trigger an assertion failure in `free`, causing a denial-of-service. This issue is fixed in version 1.2.0.", "other": {"cve": {"id": "CVE-2023-25565", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-14T18:15:13.263", "lastModified": "2023-02-22T18:42:01.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM authentication. Prior to version 1.2.0, an incorrect free when decoding target information can trigger a denial of service. The error condition incorrectly assumes the `cb` and `sh` buffers contain a copy of the data that needs to be freed. However, that is not the case. This vulnerability can be triggered via the main `gss_accept_sec_context` entry point. This will likely trigger an assertion failure in `free`, causing a denial-of-service. This issue is fixed in version 1.2.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-763"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-590"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gss-ntlmssp_project:gss-ntlmssp:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.0", "matchCriteriaId": "13258161-610E-490D-B389-681F4803A220"}]}]}], "references": [{"url": "https://github.com/gssapi/gss-ntlmssp/commit/c16100f60907a2de92bcb676f303b81facee0f64", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gssapi/gss-ntlmssp/releases/tag/v1.2.0", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/gssapi/gss-ntlmssp/security/advisories/GHSA-7q7f-wqcg-mvfg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gssapi/gss-ntlmssp/commit/c16100f60907a2de92bcb676f303b81facee0f64"}}