{"buggy_code": ["/*\n * security/tomoyo/mount.c\n *\n * Copyright (C) 2005-2010  NTT DATA CORPORATION\n */\n\n#include <linux/slab.h>\n#include \"common.h\"\n\n/* Keywords for mount restrictions. */\n\n/* Allow to call 'mount --bind /source_dir /dest_dir' */\n#define TOMOYO_MOUNT_BIND_KEYWORD                        \"--bind\"\n/* Allow to call 'mount --move /old_dir    /new_dir ' */\n#define TOMOYO_MOUNT_MOVE_KEYWORD                        \"--move\"\n/* Allow to call 'mount -o remount /dir             ' */\n#define TOMOYO_MOUNT_REMOUNT_KEYWORD                     \"--remount\"\n/* Allow to call 'mount --make-unbindable /dir'       */\n#define TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD             \"--make-unbindable\"\n/* Allow to call 'mount --make-private /dir'          */\n#define TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD                \"--make-private\"\n/* Allow to call 'mount --make-slave /dir'            */\n#define TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD                  \"--make-slave\"\n/* Allow to call 'mount --make-shared /dir'           */\n#define TOMOYO_MOUNT_MAKE_SHARED_KEYWORD                 \"--make-shared\"\n\n/**\n * tomoyo_audit_mount_log - Audit mount log.\n *\n * @r: Pointer to \"struct tomoyo_request_info\".\n *\n * Returns 0 on success, negative value otherwise.\n */\nstatic int tomoyo_audit_mount_log(struct tomoyo_request_info *r)\n{\n\tconst char *dev = r->param.mount.dev->name;\n\tconst char *dir = r->param.mount.dir->name;\n\tconst char *type = r->param.mount.type->name;\n\tconst unsigned long flags = r->param.mount.flags;\n\tif (r->granted)\n\t\treturn 0;\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD))\n\t\ttomoyo_warn_log(r, \"mount -o remount %s 0x%lX\", dir, flags);\n\telse if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD)\n\t\t || !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD))\n\t\ttomoyo_warn_log(r, \"mount %s %s %s 0x%lX\", type, dev, dir,\n\t\t\t\tflags);\n\telse if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD))\n\t\ttomoyo_warn_log(r, \"mount %s %s 0x%lX\", type, dir, flags);\n\telse\n\t\ttomoyo_warn_log(r, \"mount -t %s %s %s 0x%lX\", type, dev, dir,\n\t\t\t\tflags);\n\treturn tomoyo_supervisor(r,\n\t\t\t\t TOMOYO_KEYWORD_ALLOW_MOUNT \"%s %s %s 0x%lX\\n\",\n\t\t\t\t tomoyo_pattern(r->param.mount.dev),\n\t\t\t\t tomoyo_pattern(r->param.mount.dir), type,\n\t\t\t\t flags);\n}\n\nstatic bool tomoyo_check_mount_acl(struct tomoyo_request_info *r,\n\t\t\t\t   const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_mount_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\treturn tomoyo_compare_number_union(r->param.mount.flags, &acl->flags) &&\n\t\ttomoyo_compare_name_union(r->param.mount.type, &acl->fs_type) &&\n\t\ttomoyo_compare_name_union(r->param.mount.dir, &acl->dir_name) &&\n\t\t(!r->param.mount.need_dev ||\n\t\t tomoyo_compare_name_union(r->param.mount.dev, &acl->dev_name));\n}\n\n/**\n * tomoyo_mount_acl - Check permission for mount() operation.\n *\n * @r:        Pointer to \"struct tomoyo_request_info\".\n * @dev_name: Name of device file.\n * @dir:      Pointer to \"struct path\".\n * @type:     Name of filesystem type.\n * @flags:    Mount options.\n *\n * Returns 0 on success, negative value otherwise.\n *\n * Caller holds tomoyo_read_lock().\n */\nstatic int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,\n\t\t\t    struct path *dir, char *type, unsigned long flags)\n{\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD)) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n\t}\n\tif (need_dev) {\n\t\t/* Get mount point or device file. */\n\t\tif (kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\treturn error;\n}\n\n/**\n * tomoyo_mount_permission - Check permission for mount() operation.\n *\n * @dev_name:  Name of device file.\n * @path:      Pointer to \"struct path\".\n * @type:      Name of filesystem type. May be NULL.\n * @flags:     Mount options.\n * @data_page: Optional data. May be NULL.\n *\n * Returns 0 on success, negative value otherwise.\n */\nint tomoyo_mount_permission(char *dev_name, struct path *path, char *type,\n\t\t\t    unsigned long flags, void *data_page)\n{\n\tstruct tomoyo_request_info r;\n\tint error;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\tif (flags & MS_REMOUNT) {\n\t\ttype = TOMOYO_MOUNT_REMOUNT_KEYWORD;\n\t\tflags &= ~MS_REMOUNT;\n\t}\n\tif (flags & MS_MOVE) {\n\t\ttype = TOMOYO_MOUNT_MOVE_KEYWORD;\n\t\tflags &= ~MS_MOVE;\n\t}\n\tif (flags & MS_BIND) {\n\t\ttype = TOMOYO_MOUNT_BIND_KEYWORD;\n\t\tflags &= ~MS_BIND;\n\t}\n\tif (flags & MS_UNBINDABLE) {\n\t\ttype = TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD;\n\t\tflags &= ~MS_UNBINDABLE;\n\t}\n\tif (flags & MS_PRIVATE) {\n\t\ttype = TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD;\n\t\tflags &= ~MS_PRIVATE;\n\t}\n\tif (flags & MS_SLAVE) {\n\t\ttype = TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD;\n\t\tflags &= ~MS_SLAVE;\n\t}\n\tif (flags & MS_SHARED) {\n\t\ttype = TOMOYO_MOUNT_MAKE_SHARED_KEYWORD;\n\t\tflags &= ~MS_SHARED;\n\t}\n\tif (!type)\n\t\ttype = \"<NULL>\";\n\tidx = tomoyo_read_lock();\n\terror = tomoyo_mount_acl(&r, dev_name, path, type, flags);\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}\n\nstatic bool tomoyo_same_mount_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t  const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_mount_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_mount_acl *p2 = container_of(b, typeof(*p2), head);\n\treturn tomoyo_same_acl_head(&p1->head, &p2->head) &&\n\t\ttomoyo_same_name_union(&p1->dev_name, &p2->dev_name) &&\n\t\ttomoyo_same_name_union(&p1->dir_name, &p2->dir_name) &&\n\t\ttomoyo_same_name_union(&p1->fs_type, &p2->fs_type) &&\n\t\ttomoyo_same_number_union(&p1->flags, &p2->flags);\n}\n\n/**\n * tomoyo_write_mount - Write \"struct tomoyo_mount_acl\" list.\n *\n * @data:      String to parse.\n * @domain:    Pointer to \"struct tomoyo_domain_info\".\n * @is_delete: True if it is a delete request.\n *\n * Returns 0 on success, negative value otherwise.\n *\n * Caller holds tomoyo_read_lock().\n */\nint tomoyo_write_mount(char *data, struct tomoyo_domain_info *domain,\n\t\t       const bool is_delete)\n{\n\tstruct tomoyo_mount_acl e = { .head.type = TOMOYO_TYPE_MOUNT_ACL };\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tchar *w[4];\n\tif (!tomoyo_tokenize(data, w, sizeof(w)) || !w[3][0])\n\t\treturn -EINVAL;\n\tif (!tomoyo_parse_name_union(w[0], &e.dev_name) ||\n\t    !tomoyo_parse_name_union(w[1], &e.dir_name) ||\n\t    !tomoyo_parse_name_union(w[2], &e.fs_type) ||\n\t    !tomoyo_parse_number_union(w[3], &e.flags))\n\t\tgoto out;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), is_delete, domain,\n\t\t\t\t     tomoyo_same_mount_acl, NULL);\n out:\n\ttomoyo_put_name_union(&e.dev_name);\n\ttomoyo_put_name_union(&e.dir_name);\n\ttomoyo_put_name_union(&e.fs_type);\n\ttomoyo_put_number_union(&e.flags);\n\treturn error;\n}\n"], "fixing_code": ["/*\n * security/tomoyo/mount.c\n *\n * Copyright (C) 2005-2010  NTT DATA CORPORATION\n */\n\n#include <linux/slab.h>\n#include \"common.h\"\n\n/* Keywords for mount restrictions. */\n\n/* Allow to call 'mount --bind /source_dir /dest_dir' */\n#define TOMOYO_MOUNT_BIND_KEYWORD                        \"--bind\"\n/* Allow to call 'mount --move /old_dir    /new_dir ' */\n#define TOMOYO_MOUNT_MOVE_KEYWORD                        \"--move\"\n/* Allow to call 'mount -o remount /dir             ' */\n#define TOMOYO_MOUNT_REMOUNT_KEYWORD                     \"--remount\"\n/* Allow to call 'mount --make-unbindable /dir'       */\n#define TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD             \"--make-unbindable\"\n/* Allow to call 'mount --make-private /dir'          */\n#define TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD                \"--make-private\"\n/* Allow to call 'mount --make-slave /dir'            */\n#define TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD                  \"--make-slave\"\n/* Allow to call 'mount --make-shared /dir'           */\n#define TOMOYO_MOUNT_MAKE_SHARED_KEYWORD                 \"--make-shared\"\n\n/**\n * tomoyo_audit_mount_log - Audit mount log.\n *\n * @r: Pointer to \"struct tomoyo_request_info\".\n *\n * Returns 0 on success, negative value otherwise.\n */\nstatic int tomoyo_audit_mount_log(struct tomoyo_request_info *r)\n{\n\tconst char *dev = r->param.mount.dev->name;\n\tconst char *dir = r->param.mount.dir->name;\n\tconst char *type = r->param.mount.type->name;\n\tconst unsigned long flags = r->param.mount.flags;\n\tif (r->granted)\n\t\treturn 0;\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD))\n\t\ttomoyo_warn_log(r, \"mount -o remount %s 0x%lX\", dir, flags);\n\telse if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD)\n\t\t || !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD))\n\t\ttomoyo_warn_log(r, \"mount %s %s %s 0x%lX\", type, dev, dir,\n\t\t\t\tflags);\n\telse if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD))\n\t\ttomoyo_warn_log(r, \"mount %s %s 0x%lX\", type, dir, flags);\n\telse\n\t\ttomoyo_warn_log(r, \"mount -t %s %s %s 0x%lX\", type, dev, dir,\n\t\t\t\tflags);\n\treturn tomoyo_supervisor(r,\n\t\t\t\t TOMOYO_KEYWORD_ALLOW_MOUNT \"%s %s %s 0x%lX\\n\",\n\t\t\t\t tomoyo_pattern(r->param.mount.dev),\n\t\t\t\t tomoyo_pattern(r->param.mount.dir), type,\n\t\t\t\t flags);\n}\n\nstatic bool tomoyo_check_mount_acl(struct tomoyo_request_info *r,\n\t\t\t\t   const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_mount_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\treturn tomoyo_compare_number_union(r->param.mount.flags, &acl->flags) &&\n\t\ttomoyo_compare_name_union(r->param.mount.type, &acl->fs_type) &&\n\t\ttomoyo_compare_name_union(r->param.mount.dir, &acl->dir_name) &&\n\t\t(!r->param.mount.need_dev ||\n\t\t tomoyo_compare_name_union(r->param.mount.dev, &acl->dev_name));\n}\n\n/**\n * tomoyo_mount_acl - Check permission for mount() operation.\n *\n * @r:        Pointer to \"struct tomoyo_request_info\".\n * @dev_name: Name of device file.\n * @dir:      Pointer to \"struct path\".\n * @type:     Name of filesystem type.\n * @flags:    Mount options.\n *\n * Returns 0 on success, negative value otherwise.\n *\n * Caller holds tomoyo_read_lock().\n */\nstatic int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,\n\t\t\t    struct path *dir, char *type, unsigned long flags)\n{\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD)) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n\t}\n\tif (need_dev) {\n\t\t/* Get mount point or device file. */\n\t\tif (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\treturn error;\n}\n\n/**\n * tomoyo_mount_permission - Check permission for mount() operation.\n *\n * @dev_name:  Name of device file.\n * @path:      Pointer to \"struct path\".\n * @type:      Name of filesystem type. May be NULL.\n * @flags:     Mount options.\n * @data_page: Optional data. May be NULL.\n *\n * Returns 0 on success, negative value otherwise.\n */\nint tomoyo_mount_permission(char *dev_name, struct path *path, char *type,\n\t\t\t    unsigned long flags, void *data_page)\n{\n\tstruct tomoyo_request_info r;\n\tint error;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\tif (flags & MS_REMOUNT) {\n\t\ttype = TOMOYO_MOUNT_REMOUNT_KEYWORD;\n\t\tflags &= ~MS_REMOUNT;\n\t}\n\tif (flags & MS_MOVE) {\n\t\ttype = TOMOYO_MOUNT_MOVE_KEYWORD;\n\t\tflags &= ~MS_MOVE;\n\t}\n\tif (flags & MS_BIND) {\n\t\ttype = TOMOYO_MOUNT_BIND_KEYWORD;\n\t\tflags &= ~MS_BIND;\n\t}\n\tif (flags & MS_UNBINDABLE) {\n\t\ttype = TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD;\n\t\tflags &= ~MS_UNBINDABLE;\n\t}\n\tif (flags & MS_PRIVATE) {\n\t\ttype = TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD;\n\t\tflags &= ~MS_PRIVATE;\n\t}\n\tif (flags & MS_SLAVE) {\n\t\ttype = TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD;\n\t\tflags &= ~MS_SLAVE;\n\t}\n\tif (flags & MS_SHARED) {\n\t\ttype = TOMOYO_MOUNT_MAKE_SHARED_KEYWORD;\n\t\tflags &= ~MS_SHARED;\n\t}\n\tif (!type)\n\t\ttype = \"<NULL>\";\n\tidx = tomoyo_read_lock();\n\terror = tomoyo_mount_acl(&r, dev_name, path, type, flags);\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}\n\nstatic bool tomoyo_same_mount_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t  const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_mount_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_mount_acl *p2 = container_of(b, typeof(*p2), head);\n\treturn tomoyo_same_acl_head(&p1->head, &p2->head) &&\n\t\ttomoyo_same_name_union(&p1->dev_name, &p2->dev_name) &&\n\t\ttomoyo_same_name_union(&p1->dir_name, &p2->dir_name) &&\n\t\ttomoyo_same_name_union(&p1->fs_type, &p2->fs_type) &&\n\t\ttomoyo_same_number_union(&p1->flags, &p2->flags);\n}\n\n/**\n * tomoyo_write_mount - Write \"struct tomoyo_mount_acl\" list.\n *\n * @data:      String to parse.\n * @domain:    Pointer to \"struct tomoyo_domain_info\".\n * @is_delete: True if it is a delete request.\n *\n * Returns 0 on success, negative value otherwise.\n *\n * Caller holds tomoyo_read_lock().\n */\nint tomoyo_write_mount(char *data, struct tomoyo_domain_info *domain,\n\t\t       const bool is_delete)\n{\n\tstruct tomoyo_mount_acl e = { .head.type = TOMOYO_TYPE_MOUNT_ACL };\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tchar *w[4];\n\tif (!tomoyo_tokenize(data, w, sizeof(w)) || !w[3][0])\n\t\treturn -EINVAL;\n\tif (!tomoyo_parse_name_union(w[0], &e.dev_name) ||\n\t    !tomoyo_parse_name_union(w[1], &e.dir_name) ||\n\t    !tomoyo_parse_name_union(w[2], &e.fs_type) ||\n\t    !tomoyo_parse_number_union(w[3], &e.flags))\n\t\tgoto out;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), is_delete, domain,\n\t\t\t\t     tomoyo_same_mount_acl, NULL);\n out:\n\ttomoyo_put_name_union(&e.dev_name);\n\ttomoyo_put_name_union(&e.dir_name);\n\ttomoyo_put_name_union(&e.fs_type);\n\ttomoyo_put_number_union(&e.flags);\n\treturn error;\n}\n"], "filenames": ["security/tomoyo/mount.c"], "buggy_code_start_loc": [141], "buggy_code_end_loc": [142], "fixing_code_start_loc": [141], "fixing_code_end_loc": [142], "type": "CWE-20", "message": "The tomoyo_mount_acl function in security/tomoyo/mount.c in the Linux kernel before 2.6.39.2 calls the kern_path function with arguments taken directly from a mount system call, which allows local users to cause a denial of service (OOPS) or possibly have unspecified other impact via a NULL value for the device name.", "other": {"cve": {"id": "CVE-2011-2518", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-24T23:55:01.573", "lastModified": "2023-02-13T04:31:06.953", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The tomoyo_mount_acl function in security/tomoyo/mount.c in the Linux kernel before 2.6.39.2 calls the kern_path function with arguments taken directly from a mount system call, which allows local users to cause a denial of service (OOPS) or possibly have unspecified other impact via a NULL value for the device name."}, {"lang": "es", "value": "La funci\u00f3n tomoyo_mount_acl de security/tomoyo/mount.c en el kernel de Linux antes de v2.6.39.2 llama a la funci\u00f3n kern_path con argumentos tomados directamente de una llamada al sistema de montaje, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (OOPS) o posiblemente tener otro impacto no especificado a trav\u00e9s de un valor NULL para el nombre del dispositivo."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.39.2", "matchCriteriaId": "800B0EA0-5CBB-429B-9B0B-4926F84458DC"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39.2", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=4e78c724d47e2342aa8fde61f6b8536f662f795f", "source": "secalert@redhat.com"}, {"url": "http://marc.info/?l=bugtraq&m=139447903326211&w=2", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/07/01/5", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/4e78c724d47e2342aa8fde61f6b8536f662f795f", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4e78c724d47e2342aa8fde61f6b8536f662f795f"}}