{"buggy_code": ["/*\n irc-core.c : irssi\n\n    Copyright (C) 1999-2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include <irssi/src/core/chat-protocols.h>\n#include <irssi/src/core/settings.h>\n\n#include <irssi/src/irc/core/irc-servers.h>\n#include <irssi/src/irc/core/irc-chatnets.h>\n#include <irssi/src/irc/core/irc-channels.h>\n#include <irssi/src/irc/core/irc-queries.h>\n#include <irssi/src/irc/core/irc-cap.h>\n#include <irssi/src/irc/core/sasl.h>\n\n#include <irssi/src/irc/core/irc-servers-setup.h>\n#include <irssi/src/core/channels-setup.h>\n\n#include <irssi/src/irc/core/ctcp.h>\n#include <irssi/src/irc/core/irc-commands.h>\n#include <irssi/src/irc/core/netsplit.h>\n\nvoid irc_expandos_init(void);\nvoid irc_expandos_deinit(void);\n\nvoid irc_session_init(void);\nvoid irc_session_deinit(void);\n\nvoid lag_init(void);\nvoid lag_deinit(void);\n\nstatic CHATNET_REC *create_chatnet(void)\n{\n        return g_malloc0(sizeof(IRC_CHATNET_REC));\n}\n\nstatic SERVER_SETUP_REC *create_server_setup(void)\n{\n        return g_malloc0(sizeof(IRC_SERVER_SETUP_REC));\n}\n\nstatic CHANNEL_SETUP_REC *create_channel_setup(void)\n{\n        return g_malloc0(sizeof(CHANNEL_SETUP_REC));\n}\n\nstatic SERVER_CONNECT_REC *create_server_connect(void)\n{\n        return g_malloc0(sizeof(IRC_SERVER_CONNECT_REC));\n}\n\nstatic void destroy_server_connect(SERVER_CONNECT_REC *conn)\n{\n\tIRC_SERVER_CONNECT_REC *ircconn;\n\n        ircconn = IRC_SERVER_CONNECT(conn);\n\tif (ircconn == NULL)\n\t\treturn;\n\n\tg_free_not_null(ircconn->usermode);\n\tg_free_not_null(ircconn->alternate_nick);\n}\n\nvoid irc_core_init(void)\n{\n\tCHAT_PROTOCOL_REC *rec;\n\n\trec = g_new0(CHAT_PROTOCOL_REC, 1);\n\trec->name = \"IRC\";\n\trec->fullname = \"Internet Relay Chat\";\n\trec->chatnet = \"ircnet\";\n\n        rec->case_insensitive = TRUE;\n\n\trec->create_chatnet = create_chatnet;\n        rec->create_server_setup = create_server_setup;\n        rec->create_channel_setup = create_channel_setup;\n\trec->create_server_connect = create_server_connect;\n\trec->destroy_server_connect = destroy_server_connect;\n\n\trec->server_init_connect = irc_server_init_connect;\n\trec->server_connect = irc_server_connect;\n\trec->channel_create =\n\t\t(CHANNEL_REC *(*) (SERVER_REC *, const char *,\n\t\t\t\t   const char *, int))\n                irc_channel_create;\n\trec->query_create =\n\t\t(QUERY_REC *(*) (const char *, const char *, int))\n                irc_query_create;\n\n\tchat_protocol_register(rec);\n        g_free(rec);\n\n        irc_session_init();\n\tirc_chatnets_init();\n\tirc_servers_init();\n\tirc_channels_init();\n\tirc_queries_init();\n\n\tctcp_init();\n\tirc_commands_init();\n\tirc_irc_init();\n\tlag_init();\n\tnetsplit_init();\n\tirc_expandos_init();\n\tirc_cap_init();\n\tsasl_init();\n\n\tsettings_check();\n\tmodule_register(\"core\", \"irc\");\n}\n\nvoid irc_core_deinit(void)\n{\n\tsignal_emit(\"chat protocol deinit\", 1, chat_protocol_find(\"IRC\"));\n\n\tsasl_deinit();\n\tirc_cap_deinit();\n\tirc_expandos_deinit();\n\tnetsplit_deinit();\n\tlag_deinit();\n\tirc_commands_deinit();\n\tctcp_deinit();\n\n\tirc_queries_deinit();\n\tirc_channels_deinit();\n\tirc_irc_deinit();\n\tirc_servers_deinit();\n\tirc_chatnets_deinit();\n\tirc_session_deinit();\n\n\tchat_protocol_unregister(\"IRC\");\n}\n", "/*\n servers-reconnect.c : irssi\n\n    Copyright (C) 1999-2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include <irssi/src/core/commands.h>\n#include <irssi/src/core/network.h>\n#include <irssi/src/core/signals.h>\n\n#include <irssi/src/irc/core/modes.h>\n#include <irssi/src/irc/core/irc-servers.h>\n\n#include <irssi/src/core/settings.h>\n\nstatic void sig_server_connect_copy(SERVER_CONNECT_REC **dest,\n\t\t\t\t    IRC_SERVER_CONNECT_REC *src)\n{\n\tIRC_SERVER_CONNECT_REC *rec;\n\n\tg_return_if_fail(dest != NULL);\n\tif (!IS_IRC_SERVER_CONNECT(src))\n\t\treturn;\n\n\trec = g_new0(IRC_SERVER_CONNECT_REC, 1);\n\trec->chat_type = IRC_PROTOCOL;\n\trec->max_cmds_at_once = src->max_cmds_at_once;\n\trec->cmd_queue_speed = src->cmd_queue_speed;\n        rec->max_query_chans = src->max_query_chans;\n\trec->max_kicks = src->max_kicks;\n\trec->max_modes = src->max_modes;\n\trec->max_msgs = src->max_msgs;\n\trec->max_whois = src->max_whois;\n\trec->usermode = g_strdup(src->usermode);\n\trec->alternate_nick = g_strdup(src->alternate_nick);\n\trec->sasl_mechanism = src->sasl_mechanism;\n\trec->sasl_username = src->sasl_username;\n\trec->sasl_password = src->sasl_password;\n\t*dest = (SERVER_CONNECT_REC *) rec;\n}\n\nstatic void sig_server_reconnect_save_status(IRC_SERVER_CONNECT_REC *conn,\n\t\t\t\t\t     IRC_SERVER_REC *server)\n{\n\tif (!IS_IRC_SERVER_CONNECT(conn) || !IS_IRC_SERVER(server) ||\n\t    !server->connected)\n\t\treturn;\n\n\tg_free_not_null(conn->channels);\n\tconn->channels = irc_server_get_channels(server);\n\n\tg_free_not_null(conn->usermode);\n\tconn->usermode = g_strdup(server->wanted_usermode);\n}\n\nstatic void sig_connected(IRC_SERVER_REC *server)\n{\n\tif (!IS_IRC_SERVER(server) || !server->connrec->reconnection)\n\t\treturn;\n\n\tif (server->connrec->away_reason != NULL)\n\t\tirc_server_send_away(server, server->connrec->away_reason);\n}\n\nstatic void event_nick_collision(IRC_SERVER_REC *server, const char *data)\n{\n\ttime_t new_connect;\n\n\tif (!IS_IRC_SERVER(server))\n\t\treturn;\n\n\t/* after server kills us because of nick collision, we want to\n\t   connect back immediately. but no matter how hard they kill us,\n\t   don't connect to the server more than once in every 10 seconds. */\n\n\tnew_connect = server->connect_time+10 -\n\t\tsettings_get_time(\"server_reconnect_time\")/1000;\n\tif (server->connect_time > new_connect)\n\t\tserver->connect_time = new_connect;\n\n        server->nick_collision = TRUE;\n}\n\nstatic void event_kill(IRC_SERVER_REC *server, const char *data,\n\t\t       const char *nick, const char *addr)\n{\n\tif (addr != NULL && !server->nick_collision) {\n\t\t/* don't reconnect if we were killed by an oper (not server) */\n\t\tserver->no_reconnect = TRUE;\n\t}\n}\n\nvoid irc_servers_reconnect_init(void)\n{\n\tsignal_add(\"server connect copy\", (SIGNAL_FUNC) sig_server_connect_copy);\n\tsignal_add(\"server reconnect save status\", (SIGNAL_FUNC) sig_server_reconnect_save_status);\n\tsignal_add(\"event connected\", (SIGNAL_FUNC) sig_connected);\n\tsignal_add(\"event 436\", (SIGNAL_FUNC) event_nick_collision);\n\tsignal_add(\"event kill\", (SIGNAL_FUNC) event_kill);\n}\n\nvoid irc_servers_reconnect_deinit(void)\n{\n\tsignal_remove(\"server connect copy\", (SIGNAL_FUNC) sig_server_connect_copy);\n\tsignal_remove(\"server reconnect save status\", (SIGNAL_FUNC) sig_server_reconnect_save_status);\n\tsignal_remove(\"event connected\", (SIGNAL_FUNC) sig_connected);\n\tsignal_remove(\"event 436\", (SIGNAL_FUNC) event_nick_collision);\n\tsignal_remove(\"event kill\", (SIGNAL_FUNC) event_kill);\n}\n", "/*\n irc-servers-setup.c : irssi\n\n    Copyright (C) 1999-2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include <irssi/src/core/signals.h>\n#include <irssi/src/core/network.h>\n#include <irssi/src/core/servers-setup.h>\n#include <irssi/src/lib-config/iconfig.h>\n#include <irssi/src/core/settings.h>\n\n#include <irssi/src/irc/core/irc-chatnets.h>\n#include <irssi/src/irc/core/irc-servers-setup.h>\n#include <irssi/src/irc/core/irc-servers.h>\n#include <irssi/src/irc/core/sasl.h>\n\n/* Fill information to connection from server setup record */\nstatic void sig_server_setup_fill_reconn(IRC_SERVER_CONNECT_REC *conn,\n\t\t\t\t\t IRC_SERVER_SETUP_REC *sserver)\n{\n        if (!IS_IRC_SERVER_CONNECT(conn) ||\n\t    !IS_IRC_SERVER_SETUP(sserver))\n\t\treturn;\n\n\tif (sserver->cmd_queue_speed > 0)\n\t\tconn->cmd_queue_speed = sserver->cmd_queue_speed;\n\tif (sserver->max_cmds_at_once > 0)\n\t\tconn->max_cmds_at_once = sserver->max_cmds_at_once;\n\tif (sserver->max_query_chans > 0)\n\t\tconn->max_query_chans = sserver->max_query_chans;\n}\n\nstatic void sig_server_setup_fill_connect(IRC_SERVER_CONNECT_REC *conn)\n{\n\tconst char *value;\n\n\tif (!IS_IRC_SERVER_CONNECT(conn))\n\t\treturn;\n\n\tvalue = settings_get_str(\"alternate_nick\");\n\tconn->alternate_nick = (value != NULL && *value != '\\0') ?\n\t\tg_strdup(value) : NULL;\n\n\tvalue = settings_get_str(\"usermode\");\n\tconn->usermode = (value != NULL && *value != '\\0') ?\n\t\tg_strdup(value) : NULL;\n}\n\nstatic void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,\n\t\t\t\t\t  IRC_CHATNET_REC *ircnet)\n{\n\tif (!IS_IRC_SERVER_CONNECT(conn))\n\t\treturn;\n\tg_return_if_fail(IS_IRCNET(ircnet));\n\n\tif (ircnet->alternate_nick != NULL) {\n\t\tg_free_and_null(conn->alternate_nick);\n\t\tconn->alternate_nick = g_strdup(ircnet->alternate_nick);\n\t}\n\tif (ircnet->usermode != NULL) {\n\t\tg_free_and_null(conn->usermode);\n\t\tconn->usermode = g_strdup(ircnet->usermode);\n\t}\n\n\tif (ircnet->max_kicks > 0) conn->max_kicks = ircnet->max_kicks;\n\tif (ircnet->max_msgs > 0) conn->max_msgs = ircnet->max_msgs;\n\tif (ircnet->max_modes > 0) conn->max_modes = ircnet->max_modes;\n\tif (ircnet->max_whois > 0) conn->max_whois = ircnet->max_whois;\n\n\tif (ircnet->max_cmds_at_once > 0)\n\t\tconn->max_cmds_at_once = ircnet->max_cmds_at_once;\n\tif (ircnet->cmd_queue_speed > 0)\n\t\tconn->cmd_queue_speed = ircnet->cmd_queue_speed;\n\tif (ircnet->max_query_chans > 0)\n\t\tconn->max_query_chans = ircnet->max_query_chans;\n\n\t/* Validate the SASL parameters filled by sig_chatnet_read() or cmd_network_add */\n\tconn->sasl_mechanism = SASL_MECHANISM_NONE;\n\tconn->sasl_username = NULL;\n\tconn->sasl_password = NULL;\n\n\tif (ircnet->sasl_mechanism != NULL) {\n\t\tif (!g_ascii_strcasecmp(ircnet->sasl_mechanism, \"plain\")) {\n\t\t\t/* The PLAIN method needs both the username and the password */\n\t\t\tconn->sasl_mechanism = SASL_MECHANISM_PLAIN;\n\t\t\tif (ircnet->sasl_username != NULL && *ircnet->sasl_username &&\n\t\t\t    ircnet->sasl_password != NULL && *ircnet->sasl_password) {\n\t\t\t\tconn->sasl_username = ircnet->sasl_username;\n\t\t\t\tconn->sasl_password = ircnet->sasl_password;\n\t\t\t} else\n\t\t\t\tg_warning(\"The fields sasl_username and sasl_password are either missing or empty\");\n\t\t}\n\t\telse if (!g_ascii_strcasecmp(ircnet->sasl_mechanism, \"external\")) {\n\t\t\tconn->sasl_mechanism = SASL_MECHANISM_EXTERNAL;\n\t\t}\n\t\telse\n\t\t\tg_warning(\"Unsupported SASL mechanism \\\"%s\\\" selected\", ircnet->sasl_mechanism);\n\t}\n}\n\nstatic void init_userinfo(void)\n{\n\tunsigned int changed;\n\tconst char *set, *nick, *user_name, *str;\n\n\tchanged = 0;\n\t/* check if nick/username/realname wasn't read from setup.. */\n        set = settings_get_str(\"real_name\");\n\tif (set == NULL || *set == '\\0') {\n\t\tstr = g_getenv(\"IRCNAME\");\n\t\tsettings_set_str(\"real_name\",\n\t\t\t\t str != NULL ? str : g_get_real_name());\n\t\tchanged |= USER_SETTINGS_REAL_NAME;\n\t}\n\n\t/* username */\n        user_name = settings_get_str(\"user_name\");\n\tif (user_name == NULL || *user_name == '\\0') {\n\t\tstr = g_getenv(\"IRCUSER\");\n\t\tsettings_set_str(\"user_name\",\n\t\t\t\t str != NULL ? str : g_get_user_name());\n\n\t\tuser_name = settings_get_str(\"user_name\");\n\t\tchanged |= USER_SETTINGS_USER_NAME;\n\t}\n\n\t/* nick */\n        nick = settings_get_str(\"nick\");\n\tif (nick == NULL || *nick == '\\0') {\n\t\tstr = g_getenv(\"IRCNICK\");\n\t\tsettings_set_str(\"nick\", str != NULL ? str : user_name);\n\n\t\tnick = settings_get_str(\"nick\");\n\t\tchanged |= USER_SETTINGS_NICK;\n\t}\n\n\t/* host name */\n        set = settings_get_str(\"hostname\");\n\tif (set == NULL || *set == '\\0') {\n\t\tstr = g_getenv(\"IRCHOST\");\n\t\tif (str != NULL) {\n\t\t\tsettings_set_str(\"hostname\", str);\n\t\t\tchanged |= USER_SETTINGS_HOSTNAME;\n\t\t}\n\t}\n\n\tsignal_emit(\"irssi init userinfo changed\", 1, GUINT_TO_POINTER(changed));\n}\n\nstatic void sig_server_setup_read(IRC_SERVER_SETUP_REC *rec, CONFIG_NODE *node)\n{\n\tg_return_if_fail(rec != NULL);\n\tg_return_if_fail(node != NULL);\n\n\tif (!IS_IRC_SERVER_SETUP(rec))\n\t\treturn;\n\n\trec->max_cmds_at_once = config_node_get_int(node, \"cmds_max_at_once\", 0);\n\trec->cmd_queue_speed = config_node_get_int(node, \"cmd_queue_speed\", 0);\n\trec->max_query_chans = config_node_get_int(node, \"max_query_chans\", 0);\n}\n\nstatic void sig_server_setup_saved(IRC_SERVER_SETUP_REC *rec,\n\t\t\t\t   CONFIG_NODE *node)\n{\n\tif (!IS_IRC_SERVER_SETUP(rec))\n\t\treturn;\n\n\tif (rec->max_cmds_at_once > 0)\n\t\ticonfig_node_set_int(node, \"cmds_max_at_once\", rec->max_cmds_at_once);\n\tif (rec->cmd_queue_speed > 0)\n\t\ticonfig_node_set_int(node, \"cmd_queue_speed\", rec->cmd_queue_speed);\n\tif (rec->max_query_chans > 0)\n\t\ticonfig_node_set_int(node, \"max_query_chans\", rec->max_query_chans);\n}\n\nvoid irc_servers_setup_init(void)\n{\n\tsettings_add_bool(\"server\", \"skip_motd\", FALSE);\n\tsettings_add_str(\"server\", \"alternate_nick\", \"\");\n\n\tinit_userinfo();\n\tsignal_add(\"server setup fill reconn\", (SIGNAL_FUNC) sig_server_setup_fill_reconn);\n\tsignal_add(\"server setup fill connect\", (SIGNAL_FUNC) sig_server_setup_fill_connect);\n\tsignal_add(\"server setup fill chatnet\", (SIGNAL_FUNC) sig_server_setup_fill_chatnet);\n\tsignal_add(\"server setup read\", (SIGNAL_FUNC) sig_server_setup_read);\n\tsignal_add(\"server setup saved\", (SIGNAL_FUNC) sig_server_setup_saved);\n}\n\nvoid irc_servers_setup_deinit(void)\n{\n\tsignal_remove(\"server setup fill reconn\", (SIGNAL_FUNC) sig_server_setup_fill_reconn);\n\tsignal_remove(\"server setup fill connect\", (SIGNAL_FUNC) sig_server_setup_fill_connect);\n\tsignal_remove(\"server setup fill chatnet\", (SIGNAL_FUNC) sig_server_setup_fill_chatnet);\n\tsignal_remove(\"server setup read\", (SIGNAL_FUNC) sig_server_setup_read);\n\tsignal_remove(\"server setup saved\", (SIGNAL_FUNC) sig_server_setup_saved);\n}\n"], "fixing_code": ["/*\n irc-core.c : irssi\n\n    Copyright (C) 1999-2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include <irssi/src/core/chat-protocols.h>\n#include <irssi/src/core/settings.h>\n\n#include <irssi/src/irc/core/irc-servers.h>\n#include <irssi/src/irc/core/irc-chatnets.h>\n#include <irssi/src/irc/core/irc-channels.h>\n#include <irssi/src/irc/core/irc-queries.h>\n#include <irssi/src/irc/core/irc-cap.h>\n#include <irssi/src/irc/core/sasl.h>\n\n#include <irssi/src/irc/core/irc-servers-setup.h>\n#include <irssi/src/core/channels-setup.h>\n\n#include <irssi/src/irc/core/ctcp.h>\n#include <irssi/src/irc/core/irc-commands.h>\n#include <irssi/src/irc/core/netsplit.h>\n\nvoid irc_expandos_init(void);\nvoid irc_expandos_deinit(void);\n\nvoid irc_session_init(void);\nvoid irc_session_deinit(void);\n\nvoid lag_init(void);\nvoid lag_deinit(void);\n\nstatic CHATNET_REC *create_chatnet(void)\n{\n        return g_malloc0(sizeof(IRC_CHATNET_REC));\n}\n\nstatic SERVER_SETUP_REC *create_server_setup(void)\n{\n        return g_malloc0(sizeof(IRC_SERVER_SETUP_REC));\n}\n\nstatic CHANNEL_SETUP_REC *create_channel_setup(void)\n{\n        return g_malloc0(sizeof(CHANNEL_SETUP_REC));\n}\n\nstatic SERVER_CONNECT_REC *create_server_connect(void)\n{\n        return g_malloc0(sizeof(IRC_SERVER_CONNECT_REC));\n}\n\nstatic void destroy_server_connect(SERVER_CONNECT_REC *conn)\n{\n\tIRC_SERVER_CONNECT_REC *ircconn;\n\n        ircconn = IRC_SERVER_CONNECT(conn);\n\tif (ircconn == NULL)\n\t\treturn;\n\n\tg_free_not_null(ircconn->usermode);\n\tg_free_not_null(ircconn->alternate_nick);\n\tg_free_not_null(ircconn->sasl_username);\n\tg_free_not_null(ircconn->sasl_password);\n}\n\nvoid irc_core_init(void)\n{\n\tCHAT_PROTOCOL_REC *rec;\n\n\trec = g_new0(CHAT_PROTOCOL_REC, 1);\n\trec->name = \"IRC\";\n\trec->fullname = \"Internet Relay Chat\";\n\trec->chatnet = \"ircnet\";\n\n        rec->case_insensitive = TRUE;\n\n\trec->create_chatnet = create_chatnet;\n        rec->create_server_setup = create_server_setup;\n        rec->create_channel_setup = create_channel_setup;\n\trec->create_server_connect = create_server_connect;\n\trec->destroy_server_connect = destroy_server_connect;\n\n\trec->server_init_connect = irc_server_init_connect;\n\trec->server_connect = irc_server_connect;\n\trec->channel_create =\n\t\t(CHANNEL_REC *(*) (SERVER_REC *, const char *,\n\t\t\t\t   const char *, int))\n                irc_channel_create;\n\trec->query_create =\n\t\t(QUERY_REC *(*) (const char *, const char *, int))\n                irc_query_create;\n\n\tchat_protocol_register(rec);\n        g_free(rec);\n\n        irc_session_init();\n\tirc_chatnets_init();\n\tirc_servers_init();\n\tirc_channels_init();\n\tirc_queries_init();\n\n\tctcp_init();\n\tirc_commands_init();\n\tirc_irc_init();\n\tlag_init();\n\tnetsplit_init();\n\tirc_expandos_init();\n\tirc_cap_init();\n\tsasl_init();\n\n\tsettings_check();\n\tmodule_register(\"core\", \"irc\");\n}\n\nvoid irc_core_deinit(void)\n{\n\tsignal_emit(\"chat protocol deinit\", 1, chat_protocol_find(\"IRC\"));\n\n\tsasl_deinit();\n\tirc_cap_deinit();\n\tirc_expandos_deinit();\n\tnetsplit_deinit();\n\tlag_deinit();\n\tirc_commands_deinit();\n\tctcp_deinit();\n\n\tirc_queries_deinit();\n\tirc_channels_deinit();\n\tirc_irc_deinit();\n\tirc_servers_deinit();\n\tirc_chatnets_deinit();\n\tirc_session_deinit();\n\n\tchat_protocol_unregister(\"IRC\");\n}\n", "/*\n servers-reconnect.c : irssi\n\n    Copyright (C) 1999-2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include <irssi/src/core/commands.h>\n#include <irssi/src/core/network.h>\n#include <irssi/src/core/signals.h>\n\n#include <irssi/src/irc/core/modes.h>\n#include <irssi/src/irc/core/irc-servers.h>\n\n#include <irssi/src/core/settings.h>\n\nstatic void sig_server_connect_copy(SERVER_CONNECT_REC **dest,\n\t\t\t\t    IRC_SERVER_CONNECT_REC *src)\n{\n\tIRC_SERVER_CONNECT_REC *rec;\n\n\tg_return_if_fail(dest != NULL);\n\tif (!IS_IRC_SERVER_CONNECT(src))\n\t\treturn;\n\n\trec = g_new0(IRC_SERVER_CONNECT_REC, 1);\n\trec->chat_type = IRC_PROTOCOL;\n\trec->max_cmds_at_once = src->max_cmds_at_once;\n\trec->cmd_queue_speed = src->cmd_queue_speed;\n        rec->max_query_chans = src->max_query_chans;\n\trec->max_kicks = src->max_kicks;\n\trec->max_modes = src->max_modes;\n\trec->max_msgs = src->max_msgs;\n\trec->max_whois = src->max_whois;\n\trec->usermode = g_strdup(src->usermode);\n\trec->alternate_nick = g_strdup(src->alternate_nick);\n\trec->sasl_mechanism = src->sasl_mechanism;\n\trec->sasl_username = g_strdup(src->sasl_username);\n\trec->sasl_password = g_strdup(src->sasl_password);\n\t*dest = (SERVER_CONNECT_REC *) rec;\n}\n\nstatic void sig_server_reconnect_save_status(IRC_SERVER_CONNECT_REC *conn,\n\t\t\t\t\t     IRC_SERVER_REC *server)\n{\n\tif (!IS_IRC_SERVER_CONNECT(conn) || !IS_IRC_SERVER(server) ||\n\t    !server->connected)\n\t\treturn;\n\n\tg_free_not_null(conn->channels);\n\tconn->channels = irc_server_get_channels(server);\n\n\tg_free_not_null(conn->usermode);\n\tconn->usermode = g_strdup(server->wanted_usermode);\n}\n\nstatic void sig_connected(IRC_SERVER_REC *server)\n{\n\tif (!IS_IRC_SERVER(server) || !server->connrec->reconnection)\n\t\treturn;\n\n\tif (server->connrec->away_reason != NULL)\n\t\tirc_server_send_away(server, server->connrec->away_reason);\n}\n\nstatic void event_nick_collision(IRC_SERVER_REC *server, const char *data)\n{\n\ttime_t new_connect;\n\n\tif (!IS_IRC_SERVER(server))\n\t\treturn;\n\n\t/* after server kills us because of nick collision, we want to\n\t   connect back immediately. but no matter how hard they kill us,\n\t   don't connect to the server more than once in every 10 seconds. */\n\n\tnew_connect = server->connect_time+10 -\n\t\tsettings_get_time(\"server_reconnect_time\")/1000;\n\tif (server->connect_time > new_connect)\n\t\tserver->connect_time = new_connect;\n\n        server->nick_collision = TRUE;\n}\n\nstatic void event_kill(IRC_SERVER_REC *server, const char *data,\n\t\t       const char *nick, const char *addr)\n{\n\tif (addr != NULL && !server->nick_collision) {\n\t\t/* don't reconnect if we were killed by an oper (not server) */\n\t\tserver->no_reconnect = TRUE;\n\t}\n}\n\nvoid irc_servers_reconnect_init(void)\n{\n\tsignal_add(\"server connect copy\", (SIGNAL_FUNC) sig_server_connect_copy);\n\tsignal_add(\"server reconnect save status\", (SIGNAL_FUNC) sig_server_reconnect_save_status);\n\tsignal_add(\"event connected\", (SIGNAL_FUNC) sig_connected);\n\tsignal_add(\"event 436\", (SIGNAL_FUNC) event_nick_collision);\n\tsignal_add(\"event kill\", (SIGNAL_FUNC) event_kill);\n}\n\nvoid irc_servers_reconnect_deinit(void)\n{\n\tsignal_remove(\"server connect copy\", (SIGNAL_FUNC) sig_server_connect_copy);\n\tsignal_remove(\"server reconnect save status\", (SIGNAL_FUNC) sig_server_reconnect_save_status);\n\tsignal_remove(\"event connected\", (SIGNAL_FUNC) sig_connected);\n\tsignal_remove(\"event 436\", (SIGNAL_FUNC) event_nick_collision);\n\tsignal_remove(\"event kill\", (SIGNAL_FUNC) event_kill);\n}\n", "/*\n irc-servers-setup.c : irssi\n\n    Copyright (C) 1999-2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include <irssi/src/core/signals.h>\n#include <irssi/src/core/network.h>\n#include <irssi/src/core/servers-setup.h>\n#include <irssi/src/lib-config/iconfig.h>\n#include <irssi/src/core/settings.h>\n\n#include <irssi/src/irc/core/irc-chatnets.h>\n#include <irssi/src/irc/core/irc-servers-setup.h>\n#include <irssi/src/irc/core/irc-servers.h>\n#include <irssi/src/irc/core/sasl.h>\n\n/* Fill information to connection from server setup record */\nstatic void sig_server_setup_fill_reconn(IRC_SERVER_CONNECT_REC *conn,\n\t\t\t\t\t IRC_SERVER_SETUP_REC *sserver)\n{\n        if (!IS_IRC_SERVER_CONNECT(conn) ||\n\t    !IS_IRC_SERVER_SETUP(sserver))\n\t\treturn;\n\n\tif (sserver->cmd_queue_speed > 0)\n\t\tconn->cmd_queue_speed = sserver->cmd_queue_speed;\n\tif (sserver->max_cmds_at_once > 0)\n\t\tconn->max_cmds_at_once = sserver->max_cmds_at_once;\n\tif (sserver->max_query_chans > 0)\n\t\tconn->max_query_chans = sserver->max_query_chans;\n}\n\nstatic void sig_server_setup_fill_connect(IRC_SERVER_CONNECT_REC *conn)\n{\n\tconst char *value;\n\n\tif (!IS_IRC_SERVER_CONNECT(conn))\n\t\treturn;\n\n\tvalue = settings_get_str(\"alternate_nick\");\n\tconn->alternate_nick = (value != NULL && *value != '\\0') ?\n\t\tg_strdup(value) : NULL;\n\n\tvalue = settings_get_str(\"usermode\");\n\tconn->usermode = (value != NULL && *value != '\\0') ?\n\t\tg_strdup(value) : NULL;\n}\n\nstatic void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,\n\t\t\t\t\t  IRC_CHATNET_REC *ircnet)\n{\n\tif (!IS_IRC_SERVER_CONNECT(conn))\n\t\treturn;\n\tg_return_if_fail(IS_IRCNET(ircnet));\n\n\tif (ircnet->alternate_nick != NULL) {\n\t\tg_free_and_null(conn->alternate_nick);\n\t\tconn->alternate_nick = g_strdup(ircnet->alternate_nick);\n\t}\n\tif (ircnet->usermode != NULL) {\n\t\tg_free_and_null(conn->usermode);\n\t\tconn->usermode = g_strdup(ircnet->usermode);\n\t}\n\n\tif (ircnet->max_kicks > 0) conn->max_kicks = ircnet->max_kicks;\n\tif (ircnet->max_msgs > 0) conn->max_msgs = ircnet->max_msgs;\n\tif (ircnet->max_modes > 0) conn->max_modes = ircnet->max_modes;\n\tif (ircnet->max_whois > 0) conn->max_whois = ircnet->max_whois;\n\n\tif (ircnet->max_cmds_at_once > 0)\n\t\tconn->max_cmds_at_once = ircnet->max_cmds_at_once;\n\tif (ircnet->cmd_queue_speed > 0)\n\t\tconn->cmd_queue_speed = ircnet->cmd_queue_speed;\n\tif (ircnet->max_query_chans > 0)\n\t\tconn->max_query_chans = ircnet->max_query_chans;\n\n\t/* Validate the SASL parameters filled by sig_chatnet_read() or cmd_network_add */\n\tconn->sasl_mechanism = SASL_MECHANISM_NONE;\n\tconn->sasl_username = NULL;\n\tconn->sasl_password = NULL;\n\n\tif (ircnet->sasl_mechanism != NULL) {\n\t\tif (!g_ascii_strcasecmp(ircnet->sasl_mechanism, \"plain\")) {\n\t\t\t/* The PLAIN method needs both the username and the password */\n\t\t\tconn->sasl_mechanism = SASL_MECHANISM_PLAIN;\n\t\t\tif (ircnet->sasl_username != NULL && *ircnet->sasl_username &&\n\t\t\t    ircnet->sasl_password != NULL && *ircnet->sasl_password) {\n\t\t\t\tconn->sasl_username = g_strdup(ircnet->sasl_username);\n\t\t\t\tconn->sasl_password = g_strdup(ircnet->sasl_password);\n\t\t\t} else\n\t\t\t\tg_warning(\"The fields sasl_username and sasl_password are either missing or empty\");\n\t\t}\n\t\telse if (!g_ascii_strcasecmp(ircnet->sasl_mechanism, \"external\")) {\n\t\t\tconn->sasl_mechanism = SASL_MECHANISM_EXTERNAL;\n\t\t}\n\t\telse\n\t\t\tg_warning(\"Unsupported SASL mechanism \\\"%s\\\" selected\", ircnet->sasl_mechanism);\n\t}\n}\n\nstatic void init_userinfo(void)\n{\n\tunsigned int changed;\n\tconst char *set, *nick, *user_name, *str;\n\n\tchanged = 0;\n\t/* check if nick/username/realname wasn't read from setup.. */\n        set = settings_get_str(\"real_name\");\n\tif (set == NULL || *set == '\\0') {\n\t\tstr = g_getenv(\"IRCNAME\");\n\t\tsettings_set_str(\"real_name\",\n\t\t\t\t str != NULL ? str : g_get_real_name());\n\t\tchanged |= USER_SETTINGS_REAL_NAME;\n\t}\n\n\t/* username */\n        user_name = settings_get_str(\"user_name\");\n\tif (user_name == NULL || *user_name == '\\0') {\n\t\tstr = g_getenv(\"IRCUSER\");\n\t\tsettings_set_str(\"user_name\",\n\t\t\t\t str != NULL ? str : g_get_user_name());\n\n\t\tuser_name = settings_get_str(\"user_name\");\n\t\tchanged |= USER_SETTINGS_USER_NAME;\n\t}\n\n\t/* nick */\n        nick = settings_get_str(\"nick\");\n\tif (nick == NULL || *nick == '\\0') {\n\t\tstr = g_getenv(\"IRCNICK\");\n\t\tsettings_set_str(\"nick\", str != NULL ? str : user_name);\n\n\t\tnick = settings_get_str(\"nick\");\n\t\tchanged |= USER_SETTINGS_NICK;\n\t}\n\n\t/* host name */\n        set = settings_get_str(\"hostname\");\n\tif (set == NULL || *set == '\\0') {\n\t\tstr = g_getenv(\"IRCHOST\");\n\t\tif (str != NULL) {\n\t\t\tsettings_set_str(\"hostname\", str);\n\t\t\tchanged |= USER_SETTINGS_HOSTNAME;\n\t\t}\n\t}\n\n\tsignal_emit(\"irssi init userinfo changed\", 1, GUINT_TO_POINTER(changed));\n}\n\nstatic void sig_server_setup_read(IRC_SERVER_SETUP_REC *rec, CONFIG_NODE *node)\n{\n\tg_return_if_fail(rec != NULL);\n\tg_return_if_fail(node != NULL);\n\n\tif (!IS_IRC_SERVER_SETUP(rec))\n\t\treturn;\n\n\trec->max_cmds_at_once = config_node_get_int(node, \"cmds_max_at_once\", 0);\n\trec->cmd_queue_speed = config_node_get_int(node, \"cmd_queue_speed\", 0);\n\trec->max_query_chans = config_node_get_int(node, \"max_query_chans\", 0);\n}\n\nstatic void sig_server_setup_saved(IRC_SERVER_SETUP_REC *rec,\n\t\t\t\t   CONFIG_NODE *node)\n{\n\tif (!IS_IRC_SERVER_SETUP(rec))\n\t\treturn;\n\n\tif (rec->max_cmds_at_once > 0)\n\t\ticonfig_node_set_int(node, \"cmds_max_at_once\", rec->max_cmds_at_once);\n\tif (rec->cmd_queue_speed > 0)\n\t\ticonfig_node_set_int(node, \"cmd_queue_speed\", rec->cmd_queue_speed);\n\tif (rec->max_query_chans > 0)\n\t\ticonfig_node_set_int(node, \"max_query_chans\", rec->max_query_chans);\n}\n\nvoid irc_servers_setup_init(void)\n{\n\tsettings_add_bool(\"server\", \"skip_motd\", FALSE);\n\tsettings_add_str(\"server\", \"alternate_nick\", \"\");\n\n\tinit_userinfo();\n\tsignal_add(\"server setup fill reconn\", (SIGNAL_FUNC) sig_server_setup_fill_reconn);\n\tsignal_add(\"server setup fill connect\", (SIGNAL_FUNC) sig_server_setup_fill_connect);\n\tsignal_add(\"server setup fill chatnet\", (SIGNAL_FUNC) sig_server_setup_fill_chatnet);\n\tsignal_add(\"server setup read\", (SIGNAL_FUNC) sig_server_setup_read);\n\tsignal_add(\"server setup saved\", (SIGNAL_FUNC) sig_server_setup_saved);\n}\n\nvoid irc_servers_setup_deinit(void)\n{\n\tsignal_remove(\"server setup fill reconn\", (SIGNAL_FUNC) sig_server_setup_fill_reconn);\n\tsignal_remove(\"server setup fill connect\", (SIGNAL_FUNC) sig_server_setup_fill_connect);\n\tsignal_remove(\"server setup fill chatnet\", (SIGNAL_FUNC) sig_server_setup_fill_chatnet);\n\tsignal_remove(\"server setup read\", (SIGNAL_FUNC) sig_server_setup_read);\n\tsignal_remove(\"server setup saved\", (SIGNAL_FUNC) sig_server_setup_saved);\n}\n"], "filenames": ["src/irc/core/irc-core.c", "src/irc/core/irc-servers-reconnect.c", "src/irc/core/irc-servers-setup.c"], "buggy_code_start_loc": [77, 52, 104], "buggy_code_end_loc": [77, 54, 106], "fixing_code_start_loc": [78, 52, 104], "fixing_code_end_loc": [80, 54, 106], "type": "CWE-416", "message": "Irssi before 1.0.8, 1.1.x before 1.1.3, and 1.2.x before 1.2.1, when SASL is enabled, has a use after free when sending SASL login to the server.", "other": {"cve": {"id": "CVE-2019-13045", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-29T14:15:09.277", "lastModified": "2019-07-03T15:15:11.007", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Irssi before 1.0.8, 1.1.x before 1.1.3, and 1.2.x before 1.2.1, when SASL is enabled, has a use after free when sending SASL login to the server."}, {"lang": "es", "value": "Irssi anterior a versi\u00f3n 1.0.8, versi\u00f3n 1.1.x anterior a 1.1.3 y versi\u00f3n 1.2.x anterior a 1.2.1, cuando SASL est\u00e1 habilitado, presenta un uso de memoria previamente libera cuando se env\u00eda el inicio de sesi\u00f3n de SASL hacia el servidor."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:irssi:irssi:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.8.18", "versionEndExcluding": "1.0.8", "matchCriteriaId": "BBCEBC59-8F48-4724-9AC2-FA9411BDB41F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:irssi:irssi:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.0", "versionEndExcluding": "1.1.3", "matchCriteriaId": "4CBF8EF1-F156-4BAE-A007-3374CA199852"}, {"vulnerable": true, "criteria": "cpe:2.3:a:irssi:irssi:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.2.0", "versionEndExcluding": "1.2.1", "matchCriteriaId": "49CEB439-DD26-4B0F-A2FE-ABF75F0B1CD2"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00004.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00030.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/153480/Slackware-Security-Advisory-irssi-Updates.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2019/06/29/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/108998", "source": "cve@mitre.org"}, {"url": "https://github.com/irssi/irssi/commit/d23b0d22cc611e43c88d99192a59f413f951a955", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://irssi.org/security/irssi_sa_2019_06.txt", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Jun/41", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4046-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/irssi/irssi/commit/d23b0d22cc611e43c88d99192a59f413f951a955"}}