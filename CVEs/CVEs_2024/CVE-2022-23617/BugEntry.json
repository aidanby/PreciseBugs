{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.annotation.Component;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\n\n/**\n * Administration xwiki action.\n *\n * @version $Id$\n */\n@Component\n@Named(\"admin\")\n@Singleton\npublic class AdminAction extends XWikiAction\n{\n    /** The logger. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(AdminAction.class);\n\n    /**\n     * Default constructor.\n     */\n    public AdminAction()\n    {\n        this.waitForXWikiInitialization = false;\n    }\n\n    @Override\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return EditForm.class;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        String content = request.getParameter(\"content\");\n        XWikiDocument doc = context.getDoc();\n        XWikiForm form = context.getForm();\n\n        synchronized (doc) {\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            EditForm peform = (EditForm) form;\n            String parent = peform.getParent();\n            if (parent != null) {\n                doc.setParent(parent);\n            }\n            String creator = peform.getCreator();\n            if (creator != null) {\n                doc.setCreator(creator);\n            }\n            String defaultTemplate = peform.getDefaultTemplate();\n            if (defaultTemplate != null) {\n                doc.setDefaultTemplate(defaultTemplate);\n            }\n            String defaultLanguage = peform.getDefaultLanguage();\n            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {\n                doc.setDefaultLanguage(defaultLanguage);\n            }\n            if (doc.getDefaultLanguage().equals(\"\")) {\n                doc.setDefaultLanguage(context.getWiki().getLanguagePreference(context));\n            }\n\n            String language = context.getWiki().getLanguagePreference(context);\n            String languagefromrequest = context.getRequest().getParameter(\"language\");\n            String languagetoedit =\n                ((languagefromrequest == null) || (languagefromrequest.equals(\"\"))) ? language : languagefromrequest;\n\n            if ((languagetoedit == null) || (languagetoedit.equals(\"default\"))) {\n                languagetoedit = \"\";\n            }\n            if (doc.isNew() || (doc.getDefaultLanguage().equals(languagetoedit))) {\n                languagetoedit = \"\";\n            }\n\n            if (languagetoedit.equals(\"\")) {\n                // In this case the created document is going to be the default document\n                tdoc = doc;\n                context.put(\"tdoc\", doc);\n                if (doc.isNew()) {\n                    doc.setDefaultLanguage(language);\n                    doc.setLanguage(\"\");\n                }\n            } else {\n                // If the translated doc object is the same as the doc object\n                // this means the translated doc did not exists so we need to create it\n                if ((tdoc == doc)) {\n                    tdoc = new XWikiDocument(doc.getDocumentReference());\n                    tdoc.setLanguage(languagetoedit);\n                    tdoc.setContent(doc.getContent());\n                    tdoc.setSyntax(doc.getSyntax());\n                    tdoc.setAuthor(context.getUser());\n                    tdoc.setStore(doc.getStore());\n                    context.put(\"tdoc\", tdoc);\n                }\n            }\n\n            XWikiDocument tdoc2 = tdoc.clone();\n            if (content != null && !content.isEmpty()) {\n                tdoc2.setContent(content);\n            }\n            context.put(\"tdoc\", tdoc2);\n            try {\n                tdoc2.readFromTemplate(peform, context);\n            } catch (XWikiException e) {\n                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                    context.put(\"exception\", e);\n                    return \"docalreadyexists\";\n                }\n            }\n\n            /* Setup a lock */\n            try {\n                XWikiLock lock = tdoc.getLock(context);\n                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {\n                    tdoc.setLock(context.getUser(), context);\n                }\n            } catch (Exception e) {\n                // Lock should never make XWiki fail\n                // But we should log any related information\n                LOGGER.error(\"Exception while setting up lock\", e);\n            }\n        }\n\n        return \"admin\";\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\nimport javax.script.ScriptContext;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.util.Util;\n\n/**\n * Create document action.\n *\n * @version $Id$\n * @since 2.4M2\n */\n@Component\n@Named(\"create\")\n@Singleton\npublic class CreateAction extends XWikiAction\n{\n    /**\n     * The name of the create.vm template to render.\n     */\n    private static final String CREATE_TEMPLATE = \"create\";\n\n    /**\n     * The name of the parent parameter.\n     */\n    private static final String PARENT = \"parent\";\n\n    /**\n     * The name of the space reference parameter.\n     */\n    private static final String SPACE_REFERENCE = \"spaceReference\";\n\n    /**\n     * The name parameter.\n     */\n    private static final String NAME = \"name\";\n\n    /**\n     * The name of the template field inside the template provider, or the template parameter which can be sent\n     * directly, without passing through the template provider.\n     */\n    private static final String TEMPLATE = \"template\";\n\n    /**\n     * Internal name for a flag determining if we are creating a Nested Space or a terminal document.\n     */\n    private static final String IS_SPACE = \"isSpace\";\n\n    /**\n     * Space homepage document name.\n     */\n    private static final String WEBHOME = \"WebHome\";\n\n    /**\n     * Local entity reference serializer hint.\n     */\n    private static final String LOCAL_SERIALIZER_HINT = \"local\";\n\n    /**\n     * Current entity reference resolver hint.\n     */\n    private static final String CURRENT_MIXED_RESOLVER_HINT = \"currentmixed\";\n\n    /**\n     * The action to perform when creating a new page from a template.\n     *\n     * @version $Id$\n     */\n    private enum ActionOnCreate\n    {\n        /**\n         * Go to edit mode without saving.\n         */\n        EDIT(\"edit\"),\n\n        /**\n         * Save and then go to edit mode.\n         */\n        SAVE_AND_EDIT(\"saveandedit\"),\n\n        /**\n         * Save and then go to view mode.\n         */\n        SAVE_AND_VIEW(\"saveandview\");\n\n        private static final Map<String, ActionOnCreate> BY_ACTION = new HashMap<>();\n\n        static {\n            for (ActionOnCreate actionOnCreate : values()) {\n                BY_ACTION.put(actionOnCreate.action, actionOnCreate);\n            }\n        }\n\n        private final String action;\n\n        ActionOnCreate(String action)\n        {\n            this.action = action;\n        }\n\n        public static ActionOnCreate valueOfAction(String action)\n        {\n            return BY_ACTION.get(action);\n        }\n    }\n\n    /**\n     * Default constructor.\n     */\n    public CreateAction()\n    {\n        this.waitForXWikiInitialization = false;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        CreateActionRequestHandler handler = new CreateActionRequestHandler(context);\n\n        // Read the request and extract the passed information.\n        handler.processRequest();\n\n        // Save the determined values so we have them available in the action template.\n        ScriptContext scontext = getCurrentScriptContext();\n        scontext.setAttribute(SPACE_REFERENCE, handler.getSpaceReference(), ScriptContext.ENGINE_SCOPE);\n        scontext.setAttribute(NAME, handler.getName(), ScriptContext.ENGINE_SCOPE);\n        scontext.setAttribute(IS_SPACE, handler.isSpace(), ScriptContext.ENGINE_SCOPE);\n        // put the available templates on the context, for the .vm to not compute them again\n        scontext.setAttribute(\"availableTemplateProviders\", handler.getAvailableTemplateProviders(),\n            ScriptContext.ENGINE_SCOPE);\n        scontext.setAttribute(\"recommendedTemplateProviders\", handler.getRecommendedTemplateProviders(),\n            ScriptContext.ENGINE_SCOPE);\n\n        DocumentReference newDocumentReference = handler.getNewDocumentReference();\n        if (newDocumentReference == null) {\n            // There is information still missing, go back to the template and fill it.\n            return CREATE_TEMPLATE;\n        }\n\n        // Check if the creation in the spaceReference is allowed.\n        if (!handler.isTemplateProviderAllowedToCreateInCurrentSpace()) {\n            // The selected template provider is not usable in the selected location. Go back to the template and pick\n            // something else.\n            return CREATE_TEMPLATE;\n        }\n\n        // Checking the rights to create the new document.\n        // Note: Note checking the logical spaceReference, but the space of the final actual document reference, since\n        // that is where we are creating the new document.\n        checkRights(newDocumentReference.getLastSpaceReference(), context);\n\n        // Check if the document to create already exists and if it respects the name strategy\n        XWikiDocument newDocument = context.getWiki().getDocument(newDocumentReference, context);\n        if (handler.isDocumentAlreadyExisting(newDocument) || handler.isDocumentPathTooLong(newDocumentReference)\n            || !this.isEntityReferenceNameValid(newDocumentReference)) {\n            return CREATE_TEMPLATE;\n        }\n\n        // Verify if the \"type\" of document to create has been set, even if we currently do not use it in the action.\n        // The goal is let the user be able to chose it, which have some consequences in the UI (thanks to javascript).\n        // See: https://jira.xwiki.org/browse/XWIKI-12580\n        // Note: we do not need the \"type\" if we have a template provider: the type of the new document will be the type\n        // of the template.\n        // TODO: handle this type in doCreate() that we call above (see: https://jira.xwiki.org/browse/XWIKI-12585).\n        if (StringUtils.isBlank(handler.getType()) && !handler.hasTemplate()) {\n            return CREATE_TEMPLATE;\n        }\n\n        // create is finally valid, can be executed\n        doCreate(context, newDocument, handler.isSpace(), handler.getTemplateProvider());\n\n        return null;\n    }\n\n    /**\n     * @param context the XWiki context\n     * @param spaceReference the reference of the space where the new document will be created\n     * @throws XWikiException in case the permission to create a new document in the specified space is denied\n     */\n    private void checkRights(SpaceReference spaceReference, XWikiContext context) throws XWikiException\n    {\n        ContextualAuthorizationManager authManager = Utils.getComponent(ContextualAuthorizationManager.class);\n        if (!authManager.hasAccess(Right.EDIT, spaceReference)) {\n            Object[] args = { spaceReference.toString(), context.getUser() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"The creation of a document into the space {0} has been denied to user {1}\", null, args);\n        }\n    }\n\n    /**\n     * Actually executes the create, after all preconditions have been verified.\n     *\n     * @param context the context of this action\n     * @param newDocument the document to be created\n     * @param isSpace whether the document is a space webhome or a page\n     * @param templateProvider the template provider to create from\n     * @throws XWikiException in case anything goes wrong accessing xwiki documents\n     */\n    private void doCreate(XWikiContext context, XWikiDocument newDocument, boolean isSpace, BaseObject templateProvider)\n        throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        XWikiDocument doc = context.getDoc();\n\n        String parent = getParent(request, doc, isSpace, context);\n\n        // get the title of the page to create, as specified in the parameters\n        String title = getTitle(request, newDocument, isSpace);\n\n        // get the template from the template parameter, to allow creation directly from template, without\n        // forcing to create a template provider for each template creation\n        String template = getTemplate(templateProvider, request);\n\n        // Read from the template provide the action to perform when creating the page.\n        ActionOnCreate actionOnCreate = getActionOnCreate(templateProvider);\n\n        String action = null;\n        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {\n            initAndSaveDocument(context, newDocument, title, template, parent);\n            action = newDocument.getDefaultEditMode(context);\n        } else {\n            action = actionOnCreate == ActionOnCreate.SAVE_AND_VIEW ? \"save\" : getEditMode(template, context);\n        }\n\n        // Perform a redirection to the selected action of the document to create.\n        String redirectParams = getRedirectParameters(parent, title, template, actionOnCreate);\n        String redirectURL = newDocument.getURL(action, redirectParams, context);\n        redirectURL = context.getResponse().encodeRedirectURL(redirectURL);\n        if (context.getRequest().getParameterMap().containsKey(\"ajax\")) {\n            // If this template is displayed from a modal popup, send a header in the response notifying that a\n            // redirect must be performed in the calling page.\n            context.getResponse().setHeader(\"redirect\", redirectURL);\n        } else {\n            // Perform the redirect\n            sendRedirect(context.getResponse(), redirectURL);\n        }\n    }\n\n    /**\n     * @return the resolver uses to resolve references received in request parameters\n     */\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, CURRENT_MIXED_RESOLVER_HINT);\n    }\n\n    /**\n     * Initialize and save the new document before editing it. Follow the steps done by the Save action.\n     * \n     * @param context the XWiki context\n     * @param newDocument the document being created\n     * @param title the document title\n     * @param template the template to copy\n     * @param parent the parent document\n     * @throws XWikiException if copying the template or saving the document fails\n     */\n    private void initAndSaveDocument(XWikiContext context, XWikiDocument newDocument, String title, String template,\n        String parent) throws XWikiException\n    {\n        XWiki xwiki = context.getWiki();\n        DocumentReferenceResolver<String> resolver = getCurrentMixedDocumentReferenceResolver();\n\n        // Set the locale and default locale, considering that we're creating the original version of the document\n        // (not a translation).\n        newDocument.setLocale(Locale.ROOT);\n        if (newDocument.getDefaultLocale() == Locale.ROOT) {\n            newDocument.setDefaultLocale(xwiki.getLocalePreference(context));\n        }\n\n        // Copy the template.\n        DocumentReference templateReference = resolver.resolve(template);\n        newDocument.readFromTemplate(templateReference, context);\n\n        // Set the parent field.\n        if (!StringUtils.isEmpty(parent)) {\n            DocumentReference parentReference = resolver.resolve(parent);\n            newDocument.setParentReference(parentReference);\n        }\n\n        // Set the document title\n        if (title != null) {\n            newDocument.setTitle(title);\n        }\n\n        // Set the author and creator.\n        DocumentReference currentUserReference = context.getUserReference();\n        newDocument.setAuthorReference(currentUserReference);\n        newDocument.setCreatorReference(currentUserReference);\n\n        // Make sure the user is allowed to make this modification\n        xwiki.checkSavingDocument(currentUserReference, newDocument, context);\n\n        xwiki.saveDocument(newDocument, context);\n    }\n\n    private String getRedirectParameters(String parent, String title, String template, ActionOnCreate actionOnCreate)\n    {\n        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {\n            // We don't need to pass any parameters because the document is saved before the redirect using the\n            // parameter values.\n            return null;\n        }\n\n        String redirectParams = \"template=\" + Util.encodeURI(template, null);\n        if (parent != null) {\n            redirectParams += \"&parent=\" + Util.encodeURI(parent, null);\n        }\n        if (title != null) {\n            redirectParams += \"&title=\" + Util.encodeURI(title, null);\n        }\n        if (actionOnCreate == ActionOnCreate.SAVE_AND_VIEW) {\n            // Add the CSRF token because we redirect to save action.\n            CSRFToken csrf = Utils.getComponent(CSRFToken.class);\n            redirectParams += \"&form_token=\" + Util.encodeURI(csrf.getToken(), null);\n        }\n\n        return redirectParams;\n    }\n\n    /**\n     * @param templateProvider the set template provider, if any\n     * @param request the request on which to fallback\n     * @return the string reference of the document to use as template or {@code \"\"} if none set\n     */\n    private String getTemplate(BaseObject templateProvider, XWikiRequest request)\n    {\n        String result = \"\";\n\n        if (templateProvider != null) {\n            result = templateProvider.getStringValue(TEMPLATE);\n        } else if (request.getParameter(TEMPLATE) != null) {\n            result = request.getParameter(TEMPLATE);\n        }\n\n        return result;\n    }\n\n    /**\n     * @param request the current request for which this action is executed\n     * @param doc the current document\n     * @param isSpace {@code true} if the request is to create a space, {@code false} if a page should be created\n     * @param context the XWiki context\n     * @return the serialized reference of the parent to create the document for\n     */\n    private String getParent(XWikiRequest request, XWikiDocument doc, boolean isSpace, XWikiContext context)\n    {\n        // This template can be passed a parent document reference in parameter (using the \"parent\" parameter).\n        // If a parent parameter is passed, use it to set the parent when creating the new Page or Space.\n        // If no parent parameter was passed:\n        // * use the current document\n        // ** if we're creating a new page and if the current document exists or\n        // * use the Main space's WebHome\n        // ** if we're creating a new page and the current document does not exist.\n        String parent = request.getParameter(PARENT);\n        if (StringUtils.isEmpty(parent)) {\n            EntityReferenceSerializer<String> localSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, LOCAL_SERIALIZER_HINT);\n\n            if (doc.isNew()) {\n                // Use the Main space's WebHome.\n                Provider<DocumentReference> defaultDocumentReferenceProvider =\n                    Utils.getComponent(DocumentReference.TYPE_PROVIDER);\n\n                DocumentReference parentRef =\n                    defaultDocumentReferenceProvider.get().setWikiReference(context.getWikiReference());\n\n                parent = localSerializer.serialize(parentRef);\n            } else {\n                // Use the current document.\n                DocumentReference parentRef = doc.getDocumentReference();\n\n                parent = localSerializer.serialize(parentRef);\n            }\n        }\n\n        return parent;\n    }\n\n    /**\n     * @param request the current request for which this action is executed\n     * @param newDocument the document to be created\n     * @param isSpace {@code true} if the request is to create a space, {@code false} if a page should be created\n     * @return the title of the page to be created. If no request parameter is set, the page name is returned for a new\n     *         page and the space name is returned for a new space\n     */\n    private String getTitle(XWikiRequest request, XWikiDocument newDocument, boolean isSpace)\n    {\n        String title = request.getParameter(\"title\");\n        if (StringUtils.isEmpty(title)) {\n            if (isSpace) {\n                title = newDocument.getDocumentReference().getLastSpaceReference().getName();\n            } else {\n                title = newDocument.getDocumentReference().getName();\n                // Avoid WebHome titles for pages that are really space homepages.\n                if (WEBHOME.equals(title)) {\n                    title = newDocument.getDocumentReference().getLastSpaceReference().getName();\n                }\n            }\n        }\n\n        return title;\n    }\n\n    /**\n     * @param templateProvider the template provider for this creation\n     * @return {@code true} if the created document should be saved on create, before editing, {@code false} otherwise\n     */\n    private ActionOnCreate getActionOnCreate(BaseObject templateProvider)\n    {\n        if (templateProvider != null) {\n            String action = templateProvider.getStringValue(\"action\");\n            ActionOnCreate actionOnCreate = ActionOnCreate.valueOfAction(action);\n            if (actionOnCreate != null) {\n                return actionOnCreate;\n            }\n        }\n\n        // Default action when creating a page from a template.\n        return ActionOnCreate.EDIT;\n    }\n\n    /**\n     * @param template the template to create document from\n     * @param resolver the resolver to use to resolve the template document reference\n     * @param context the context of the current request\n     * @return the default edit mode for a document created from the passed template\n     * @throws XWikiException in case something goes wrong accessing template document\n     */\n    private String getEditMode(String template, XWikiContext context)\n        throws XWikiException\n    {\n        // Determine the edit action (edit/inline) for the newly created document, if a template is passed it is\n        // used to determine the action. Default is 'edit'.\n        String editAction = ActionOnCreate.EDIT.name().toLowerCase();\n        XWiki xwiki = context.getWiki();\n        if (!StringUtils.isEmpty(template)) {\n            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n            if (xwiki.exists(templateReference, context)) {\n                editAction = xwiki.getDocument(templateReference, context).getDefaultEditMode(context);\n            }\n        }\n\n        return editAction;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.script.ScriptContext;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.rendering.syntax.Syntax;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\n\n/**\n * Initializes a document before it is edited.\n *\n * @version $Id$\n */\n@Component\n@Named(\"edit\")\n@Singleton\npublic class EditAction extends XWikiAction\n{\n    /**\n     * The object used for logging.\n     */\n    private static final Logger LOGGER = LoggerFactory.getLogger(EditAction.class);\n\n    /**\n     * Default constructor.\n     */\n    public EditAction()\n    {\n        this.waitForXWikiInitialization = false;\n    }\n\n    @Override\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return EditForm.class;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiDocument editedDocument = prepareEditedDocument(context);\n            maybeLockDocument(editedDocument, context);\n        } catch (XWikiException e) {\n            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                context.put(\"exception\", e);\n                return \"docalreadyexists\";\n            } else {\n                throw e;\n            }\n        }\n\n        // Make sure object property fields are displayed in edit mode.\n        // See XWikiDocument#display(String, BaseObject, XWikiContext)\n        // TODO: Revisit the display mode after the inline action is removed. Is the display mode still needed when\n        // there is only one edit action?\n        context.put(\"display\", \"edit\");\n        return \"edit\";\n    }\n\n    /**\n     * Determines the edited document (translation) and updates it based on the template specified on the request and\n     * any additional request parameters that overwrite the default values from the template.\n     *\n     * @param context the XWiki context\n     * @return the edited document\n     * @throws XWikiException if something goes wrong\n     */\n    protected XWikiDocument prepareEditedDocument(XWikiContext context) throws XWikiException\n    {\n        // Determine the edited document (translation).\n        XWikiDocument editedDocument = getEditedDocument(context);\n        EditForm editForm = (EditForm) context.getForm();\n\n        // Update the edited document based on the template specified on the request.\n        editedDocument.readFromTemplate(editForm, context);\n\n        // The default values from the template can be overwritten by additional request parameters.\n        updateDocumentTitleAndContentFromRequest(editedDocument, context);\n        editedDocument.readObjectsFromForm(editForm, context);\n\n        // Set the current user as creator, author and contentAuthor when the edited document is newly created to avoid\n        // using XWikiGuest instead (because those fields were not previously initialized).\n        if (editedDocument.isNew()) {\n            editedDocument.setCreatorReference(context.getUserReference());\n            editedDocument.setAuthorReference(context.getUserReference());\n            editedDocument.setContentAuthorReference(context.getUserReference());\n        }\n\n        // Expose the edited document on the XWiki context and the Velocity context.\n        putDocumentOnContext(editedDocument, context);\n\n        return editedDocument;\n    }\n\n    /**\n     * There are three important use cases:\n     * <ul>\n     * <li>editing or creating the original translation (for the default language)</li>\n     * <li>editing an existing document translation</li>\n     * <li>creating a new translation.</i>\n     * </ul>\n     * Most of the code deals with the really bad way the default language can be specified (empty string, 'default' or\n     * a real language code).\n     *\n     * @param context the XWiki context\n     * @return the edited document translation based on the language specified on the request\n     * @throws XWikiException if something goes wrong\n     */\n    private XWikiDocument getEditedDocument(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = context.getDoc();\n        boolean hasTranslation = doc != context.get(\"tdoc\");\n\n        // We have to clone the context document because it is cached and the changes we are going to make are valid\n        // only for the duration of the current request.\n        doc = doc.clone();\n        context.put(\"doc\", doc);\n\n        EditForm editForm = (EditForm) context.getForm();\n        doc.readDocMetaFromForm(editForm, context);\n\n        String language = context.getWiki().getLanguagePreference(context);\n        if (doc.isNew() && doc.getDefaultLanguage().equals(\"\")) {\n            doc.setDefaultLanguage(language);\n        }\n\n        String languageToEdit = StringUtils.isEmpty(editForm.getLanguage()) ? language : editForm.getLanguage();\n\n        // If no specific language is set or if it is \"default\" then we edit the current doc.\n        if (languageToEdit == null || languageToEdit.equals(\"default\")) {\n            languageToEdit = \"\";\n        }\n        // If the document is new or if the language to edit is the default language then we edit the default\n        // translation.\n        if (doc.isNew() || doc.getDefaultLanguage().equals(languageToEdit)) {\n            languageToEdit = \"\";\n        }\n        // If the doc does not exist in the language to edit and the language was not explicitly set in the URL then\n        // we edit the default document translation. This prevents use from creating unneeded translations.\n        if (!hasTranslation && StringUtils.isEmpty(editForm.getLanguage())) {\n            languageToEdit = \"\";\n        }\n\n        // Initialize the translated document.\n        XWikiDocument tdoc;\n        if (languageToEdit.equals(\"\")) {\n            // Edit the default document translation (default language).\n            tdoc = doc;\n            if (doc.isNew()) {\n                doc.setDefaultLanguage(language);\n                doc.setLanguage(\"\");\n            }\n        } else if (!hasTranslation && context.getWiki().isMultiLingual(context)) {\n            // Edit a new translation.\n            tdoc = new XWikiDocument(doc.getDocumentReference());\n            tdoc.setLanguage(languageToEdit);\n            tdoc.setDefaultLocale(doc.getDefaultLocale());\n            // Mark the translation. It's important to know whether a document is a translation or not, especially\n            // for the sheet manager which needs to access the objects using the default document not one of its\n            // translations.\n            tdoc.setTitle(doc.getTitle());\n            tdoc.setContent(doc.getContent());\n            tdoc.setSyntax(doc.getSyntax());\n            tdoc.setAuthorReference(context.getUserReference());\n            tdoc.setStore(doc.getStore());\n        } else {\n            // Edit an existing translation. Clone the translated document object to be sure that the changes we are\n            // going to make will last only for the duration of the current request.\n            tdoc = ((XWikiDocument) context.get(\"tdoc\")).clone();\n        }\n\n        return tdoc;\n    }\n\n    /**\n     * Updates the title and content of the given document with values taken from the 'title' and 'content' request\n     * parameters or based on the document section specified on the request.\n     *\n     * @param document the document whose title and content should be updated\n     * @param context the XWiki context\n     * @throws XWikiException if something goes wrong\n     */\n    private void updateDocumentTitleAndContentFromRequest(XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        // Check if section editing is enabled and if a section is specified.\n        boolean sectionEditingEnabled = context.getWiki().hasSectionEdit(context);\n        int sectionNumber = sectionEditingEnabled ? NumberUtils.toInt(context.getRequest().getParameter(\"section\")) : 0;\n        getCurrentScriptContext().setAttribute(\"sectionNumber\", sectionNumber, ScriptContext.ENGINE_SCOPE);\n\n        // Update the edited content.\n        EditForm editForm = (EditForm) context.getForm();\n        if (editForm.getContent() != null) {\n            document.setContent(editForm.getContent());\n        } else if (sectionNumber > 0) {\n            document.setContent(document.getContentOfSection(sectionNumber));\n        }\n\n        // Update the edited title.\n        if (editForm.getTitle() != null) {\n            document.setTitle(editForm.getTitle());\n        } else if (sectionNumber > 0 && document.getSections().size() > 0) {\n            // The edited content is either the content of the specified section or the content provided on the\n            // request. We assume the content provided on the request is meant to overwrite the specified section.\n            // In both cases the document content is currently having one section, so we can take its title.\n            String sectionTitle = document.getDocumentSection(1).getSectionTitle();\n            if (StringUtils.isNotBlank(sectionTitle)) {\n                // We cannot edit the page title while editing a page section so this title is for display only.\n                String sectionPlainTitle = document.getRenderedContent(sectionTitle, document.getSyntax().toIdString(),\n                    Syntax.PLAIN_1_0.toIdString(), context);\n                document.setTitle(localizePlainOrKey(\"core.editors.content.titleField.sectionEditingFormat\",\n                    document.getRenderedTitle(Syntax.PLAIN_1_0, context), sectionNumber, sectionPlainTitle));\n            }\n        }\n    }\n\n    /**\n     * Exposes the given document in the XWiki context and the Velocity context under the 'tdoc' and 'cdoc' keys.\n     *\n     * @param document the document to expose\n     * @param context the XWiki context\n     */\n    private void putDocumentOnContext(XWikiDocument document, XWikiContext context)\n    {\n        context.put(\"tdoc\", document);\n        // Old XWiki applications that are still using the inline action might expect the cdoc (content document) to be\n        // properly set on the context. Let's expose the given document also as cdoc for backward compatibility.\n        context.put(\"cdoc\", context.get(\"tdoc\"));\n    }\n\n    /**\n     * Locks the given document unless it is already locked by a different user and the current user didn't request to\n     * force the lock.\n     *\n     * @param document the document to lock\n     * @param context the XWiki context\n     */\n    private void maybeLockDocument(XWikiDocument document, XWikiContext context)\n    {\n        try {\n            XWikiLock lock = document.getLock(context);\n            EditForm editForm = (EditForm) context.getForm();\n            if (lock == null || lock.getUserName().equals(context.getUser()) || editForm.isLockForce()) {\n                document.setLock(context.getUser(), context);\n            }\n        } catch (Exception e) {\n            // Lock should never make XWiki fail, but we should log any related information.\n            LOGGER.error(\"Exception while setting up lock\", e);\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.annotation.Component;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\n\n/**\n * @deprecated use {@link EditAction} with {@code editor=inline} in the query string instead since 3.2\n */\n@Component\n@Named(\"inline\")\n@Singleton\n@Deprecated\npublic class InlineAction extends XWikiAction\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(InlineAction.class);\n\n    @Override\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return EditForm.class;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = context.getDoc();\n\n        synchronized (doc) {\n            XWikiForm form = context.getForm();\n\n            XWikiDocument cdoc = (XWikiDocument) context.get(\"cdoc\");\n            if (cdoc == null) {\n                cdoc = doc;\n            }\n\n            EditForm peform = (EditForm) form;\n\n            XWikiDocument doc2 = doc.clone();\n            context.put(\"doc\", doc2);\n\n            String parent = peform.getParent();\n            if (parent != null) {\n                doc2.setParent(parent);\n            }\n            String creator = peform.getCreator();\n            if (creator != null) {\n                doc2.setCreator(creator);\n            }\n            String defaultLanguage = peform.getDefaultLanguage();\n            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {\n                doc2.setDefaultLanguage(defaultLanguage);\n            }\n            if (doc2.getDefaultLanguage().equals(\"\")) {\n                doc2.setDefaultLanguage(context.getWiki().getLanguagePreference(context));\n            }\n            try {\n                doc2.readFromTemplate(peform, context);\n            } catch (XWikiException e) {\n                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                    return \"docalreadyexists\";\n                }\n            }\n\n            if (doc == cdoc) {\n                context.put(\"cdoc\", doc2);\n            } else {\n                XWikiDocument cdoc2 = cdoc.clone();\n                cdoc2.readFromTemplate(peform, context);\n                context.put(\"cdoc\", cdoc2);\n            }\n\n            doc2.readFromForm((EditForm) form, context);\n\n            // Set the current user as creator, author and contentAuthor when the edited document is newly created\n            // to avoid using XWikiGuest instead (because those fields were not previously initialized).\n            // This is needed for the script right, as guest doesn't have it and this would block the execution of\n            // scripts in newly created documents even if the user creating the document has the right.\n            if (doc2.isNew()) {\n                doc2.setCreatorReference(context.getUserReference());\n                doc2.setAuthorReference(context.getUserReference());\n                doc2.setContentAuthorReference(context.getUserReference());\n            }\n\n            /* Setup a lock */\n            try {\n                XWikiLock lock = doc.getLock(context);\n                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {\n                    doc.setLock(context.getUser(), context);\n                }\n            } catch (Exception e) {\n                // Lock should never make XWiki fail\n                // But we should log any related information\n                LOGGER.error(\"Exception while setting up lock\", e);\n            }\n        }\n\n        // Make sure object property fields are displayed in edit mode.\n        // See XWikiDocument#display(String, BaseObject, XWikiContext)\n        context.put(\"display\", \"edit\");\n\n        return \"inline\";\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.script.ScriptContext;\n\nimport org.apache.commons.httpclient.HttpStatus;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.diff.DifferentiationFailedException;\nimport org.suigeneris.jrcs.diff.delta.Delta;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.diff.ConflictDecision;\nimport org.xwiki.job.Job;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.refactoring.job.CreateRequest;\nimport org.xwiki.refactoring.script.RefactoringScriptService;\nimport org.xwiki.script.service.ScriptService;\nimport org.xwiki.store.merge.MergeConflictDecisionsManager;\nimport org.xwiki.store.merge.MergeDocumentResult;\nimport org.xwiki.store.merge.MergeManager;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MetaDataDiff;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\nimport com.xpn.xwiki.doc.merge.MergeConfiguration;\nimport com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;\nimport com.xpn.xwiki.objects.ObjectDiff;\n\n/**\n * Action used for saving and proceeding to view the saved page.\n * <p>\n * Used as a generic action for saving documents.\n *\n * @version $Id$\n */\n@Component\n@Named(\"save\")\n@Singleton\npublic class SaveAction extends PreviewAction\n{\n    /** The identifier of the save action. */\n    public static final String ACTION_NAME = \"save\";\n\n    protected static final String ASYNC_PARAM = \"async\";\n\n    /** Logger. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(SaveAction.class);\n\n    /**\n     * The key to retrieve the saved object version from the context.\n     */\n    private static final String SAVED_OBJECT_VERSION_KEY = \"SaveAction.savedObjectVersion\";\n\n    /**\n     * The context key to know if a document has been merged for saving it.\n     */\n    private static final String MERGED_DOCUMENTS = \"SaveAction.mergedDocuments\";\n\n    /**\n     * Parameter value used with forceSave to specify that the merge should be performed even if there is conflicts.\n     */\n    private static final String FORCE_SAVE_MERGE = \"merge\";\n\n    /**\n     * Parameter value used with forceSave to specify that no merge should be done but the current document should\n     * override the previous one.\n     */\n    private static final String FORCE_SAVE_OVERRIDE = \"override\";\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private MergeManager mergeManager;\n\n    private MergeConflictDecisionsManager conflictDecisionsManager;\n\n    public SaveAction()\n    {\n        this.waitForXWikiInitialization = true;\n    }\n\n    /**\n     * Saves the current document, updated according to the parameters sent in the request.\n     *\n     * @param context The current request {@link XWikiContext context}.\n     * @return <code>true</code> if there was an error and the response needs to render an error page,\n     *         <code>false</code> if the document was correctly saved.\n     * @throws XWikiException If an error occured: cannot communicate with the storage module, or cannot update the\n     *             document because the request contains invalid parameters.\n     */\n    public boolean save(XWikiContext context) throws XWikiException\n    {\n        XWiki xwiki = context.getWiki();\n        XWikiRequest request = context.getRequest();\n        XWikiDocument doc = context.getDoc();\n        EditForm form = (EditForm) context.getForm();\n\n        // Check save session\n        int sectionNumber = 0;\n        if (request.getParameter(\"section\") != null && xwiki.hasSectionEdit(context)) {\n            sectionNumber = Integer.parseInt(request.getParameter(\"section\"));\n        }\n\n        if (doc.isNew() && !this.isEntityReferenceNameValid(doc.getDocumentReference())) {\n            context.put(\"message\", \"entitynamevalidation.create.invalidname\");\n            context.put(\"messageParameters\",\n                new Object[] { getLocalSerializer().serialize(doc.getDocumentReference())});\n            return true;\n        }\n\n        XWikiDocument originalDoc = doc;\n\n        // We need to clone this document first, since a cached storage would return the same object for the\n        // following requests, so concurrent request might get a partially modified object, or worse, if an error\n        // occurs during the save, the cached object will not reflect the actual document at all.\n        doc = doc.clone();\n\n        String language = form.getLanguage();\n        // FIXME Which one should be used: doc.getDefaultLanguage or\n        // form.getDefaultLanguage()?\n        // String defaultLanguage = ((EditForm) form).getDefaultLanguage();\n        XWikiDocument tdoc;\n\n        if (doc.isNew() || (language == null) || (language.equals(\"\")) || (language.equals(\"default\"))\n            || (language.equals(doc.getDefaultLanguage()))) {\n            // Saving the default document translation.\n            // Need to save parent and defaultLanguage if they have changed\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if ((tdoc == doc) && xwiki.isMultiLingual(context)) {\n                // Saving a new document translation.\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n                // In that specific case, we want the original doc to be the translation document so that we\n                // never raised a conflict.\n                originalDoc = tdoc;\n            } else if (tdoc != doc) {\n                // Saving an existing document translation (but not the default one).\n                // Same as above, clone the object retrieved from the store cache.\n                originalDoc = tdoc;\n                tdoc = tdoc.clone();\n            }\n        }\n\n        if (doc.isNew()) {\n            doc.setLocale(Locale.ROOT);\n            if (doc.getDefaultLocale() == Locale.ROOT) {\n                doc.setDefaultLocale(xwiki.getLocalePreference(context));\n            }\n        }\n\n        try {\n            tdoc.readFromTemplate(form.getTemplate(), context);\n        } catch (XWikiException e) {\n            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                context.put(\"exception\", e);\n                return true;\n            }\n        }\n\n        // Convert the content and the meta data of the edited document and its translations if the syntax has changed\n        // and the request is asking for a syntax conversion. We do this after applying the template because the\n        // template may have content in the previous syntax that needs to be converted. We do this before applying the\n        // changes from the submitted form because it may contain content that was already converted.\n        if (form.isConvertSyntax() && !tdoc.getSyntax().toIdString().equals(form.getSyntaxId())) {\n            convertSyntax(tdoc, form.getSyntaxId(), context);\n        }\n\n        if (sectionNumber != 0) {\n            XWikiDocument sectionDoc = tdoc.clone();\n            sectionDoc.readFromForm(form, context);\n            String sectionContent = sectionDoc.getContent() + \"\\n\";\n            String content = tdoc.updateDocumentSection(sectionNumber, sectionContent);\n            tdoc.setContent(content);\n            tdoc.setComment(sectionDoc.getComment());\n            tdoc.setMinorEdit(sectionDoc.isMinorEdit());\n        } else {\n            tdoc.readFromForm(form, context);\n        }\n\n        // TODO: handle Author\n        String username = context.getUser();\n        tdoc.setAuthor(username);\n        if (tdoc.isNew()) {\n            tdoc.setCreator(username);\n        }\n\n        // Make sure we have at least the meta data dirty status\n        tdoc.setMetaDataDirty(true);\n\n        // Validate the document if we have xvalidate=1 in the request\n        if (\"1\".equals(request.getParameter(\"xvalidate\"))) {\n            boolean validationResult = tdoc.validate(context);\n            // If the validation fails we should show the \"Inline form\" edit mode\n            if (validationResult == false) {\n                // Set display context to 'edit'\n                context.put(\"display\", \"edit\");\n                // Set the action used by the \"Inline form\" edit mode as the context action. See #render(XWikiContext).\n                context.setAction(tdoc.getDefaultEditMode(context));\n                // Set the document in the context\n                context.put(\"doc\", doc);\n                context.put(\"cdoc\", tdoc);\n                context.put(\"tdoc\", tdoc);\n                // Force the \"Inline form\" edit mode.\n                getCurrentScriptContext().setAttribute(\"editor\", \"inline\", ScriptContext.ENGINE_SCOPE);\n\n                return true;\n            }\n        }\n\n        // Remove the redirect object if the save request doesn't update it. This allows users to easily overwrite\n        // redirect place-holders that are created when we move pages around.\n        if (tdoc.getXObject(RedirectClassDocumentInitializer.REFERENCE) != null\n            && request.getParameter(\"XWiki.RedirectClass_0_location\") == null) {\n            tdoc.removeXObjects(RedirectClassDocumentInitializer.REFERENCE);\n        }\n\n        // We only proceed on the check between versions in case of AJAX request, so we currently stay in the edit form\n        // This can be improved later by displaying a nice UI with some merge options in a sync request.\n        // For now we don't want our user to loose their changes.\n        if (isConflictCheckEnabled() && Utils.isAjaxRequest(context)\n            && request.getParameter(\"previousVersion\") != null) {\n            if (isConflictingWithVersion(context, originalDoc, tdoc)) {\n                return true;\n            }\n        }\n\n        // Make sure the user is allowed to make this modification\n        xwiki.checkSavingDocument(context.getUserReference(), tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);\n\n        // We get the comment to be used from the document\n        // It was read using readFromForm\n        xwiki.saveDocument(tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);\n\n        context.put(SAVED_OBJECT_VERSION_KEY, tdoc.getRCSVersion());\n\n        Job createJob = startCreateJob(tdoc.getDocumentReference(), form);\n        if (createJob != null) {\n            if (isAsync(request)) {\n                if (Utils.isAjaxRequest(context)) {\n                    // Redirect to the job status URL of the job we have just launched.\n                    sendRedirect(context.getResponse(), String.format(\"%s/rest/jobstatus/%s?media=json\",\n                        context.getRequest().getContextPath(), serializeJobId(createJob.getRequest().getId())));\n                }\n\n                // else redirect normally and the operation will eventually finish in the background.\n                // Note: It is preferred that async mode is called in an AJAX request that can display the progress.\n            } else {\n                // Sync mode, default, wait for the work to finish.\n                try {\n                    createJob.join();\n                } catch (InterruptedException e) {\n                    throw new XWikiException(String.format(\n                        \"Interrupted while waiting for template [%s] to be processed when creating the document [%s]\",\n                        form.getTemplate(), tdoc.getDocumentReference()), e);\n                }\n            }\n        } else {\n            // Nothing more to do, just unlock the document.\n            XWikiLock lock = tdoc.getLock(context);\n            if (lock != null) {\n                tdoc.removeLock(context);\n            }\n        }\n\n        return false;\n    }\n\n    private boolean isConflictCheckEnabled()\n    {\n        ConfigurationSource configurationSource = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");\n        return configurationSource.getProperty(\"edit.conflictChecking.enabled\", true);\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private MergeManager getMergeManager()\n    {\n        if (this.mergeManager == null) {\n            this.mergeManager = Utils.getComponent(MergeManager.class);\n        }\n\n        return this.mergeManager;\n    }\n\n    private MergeConflictDecisionsManager getConflictDecisionsManager()\n    {\n        if (this.conflictDecisionsManager == null) {\n            this.conflictDecisionsManager = Utils.getComponent(MergeConflictDecisionsManager.class);\n        }\n\n        return this.conflictDecisionsManager;\n    }\n\n    /**\n     * Retrieve the conflict decisions made from the request and fill the conflict decision manager with them. We handle\n     * two list of parameters here: - mergeChoices: those parameters are on the form [conflict id]=[choice] where the\n     * choice is defined by the {@link ConflictDecision.DecisionType} values. - customChoices: those parameters are on\n     * the form [conflict id]=[encoded string] where the encoded string is actually the desired value to solve the\n     * conflict.\n     */\n    private void recordConflictDecisions(XWikiContext context, DocumentReference documentReference)\n    {\n        XWikiRequest request = context.getRequest();\n        String[] mergeChoices = request.getParameterValues(\"mergeChoices\");\n        String[] customChoices = request.getParameterValues(\"customChoices\");\n\n        // Build a map indexed by the conflict ids and whose values are the actual decoded custom values.\n        Map<String, String> customChoicesMap = new HashMap<>();\n        if (customChoices != null) {\n            for (String customChoice : customChoices) {\n                String[] splittedCustomChoiceInfo = customChoice.split(\"=\");\n                String conflictReference = splittedCustomChoiceInfo[0];\n                String customValue = customChoice.substring(conflictReference.length() + 1);\n                try {\n                    customValue = URLDecoder.decode(customValue, request.getCharacterEncoding());\n                } catch (UnsupportedEncodingException e) {\n                    LOGGER.error(\"Error while decoding a custom value decision.\", e);\n                }\n                customChoicesMap.put(conflictReference, customValue);\n            }\n        }\n        if (mergeChoices != null) {\n            for (String choice : mergeChoices) {\n                String[] splittedChoiceInfo = choice.split(\"=\");\n                String conflictReference = splittedChoiceInfo[0];\n                String selectedChoice = splittedChoiceInfo[1];\n                List<String> customValue = null;\n\n                ConflictDecision.DecisionType decisionType =\n                    ConflictDecision.DecisionType.valueOf(selectedChoice.toUpperCase());\n\n                if (decisionType == ConflictDecision.DecisionType.CUSTOM) {\n                    customValue = Collections.singletonList(customChoicesMap.get(conflictReference));\n                }\n                getConflictDecisionsManager().recordDecision(documentReference, context.getUserReference(),\n                    conflictReference, decisionType, customValue);\n            }\n        }\n    }\n\n    /**\n     * Check if the version of the document being saved is conflicting with another version. This check is done by\n     * getting the \"previousVersion\" parameter from the request and comparing it with latest version of the document. If\n     * the current version of the document is not the same as the previous one, a diff is computed on the document\n     * content: a conflict is detected only if the contents are different.\n     * \n     * @param context the current context of the request.\n     * @param originalDoc the original version of the document being modified that will be saved (i.e. before content\n     *            changes). We don't retrieve it through context since it can be a translation.\n     * @return true in case of conflict. If it's true, the answer is immediately sent to the client.\n     */\n    private boolean isConflictingWithVersion(XWikiContext context, XWikiDocument originalDoc, XWikiDocument modifiedDoc)\n        throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n\n        // in case of force save we skip the check.\n        if (FORCE_SAVE_OVERRIDE.equals(request.getParameter(\"forceSave\"))) {\n            return false;\n        }\n\n        // the document is new we don't have to check the version date or anything\n        if (\"true\".equals(request.getParameter(\"isNew\")) && originalDoc.isNew()) {\n            return false;\n        }\n\n        // TODO The check of the previousVersion should be done at a lower level or with a semaphore since\n        // another job might have saved a different version of the document\n        Version previousVersion = new Version(request.getParameter(\"previousVersion\"));\n        Version latestVersion = originalDoc.getRCSVersion();\n\n        Date editingVersionDate = new Date(Long.parseLong(request.getParameter(\"editingVersionDate\")));\n        Date latestVersionDate = originalDoc.getDate();\n\n        // we ensure that nobody edited the document between the moment the user started to edit and now\n        if (!latestVersion.equals(previousVersion) || latestVersionDate.after(editingVersionDate)) {\n            try {\n                XWikiDocument previousDoc =\n                    getDocumentRevisionProvider().getRevision(originalDoc, previousVersion.toString());\n\n                // We also check that the previousDoc revision exists to avoid an exception if it has been deleted\n                // Note that if we're here and the request says that the document is new, it's not necessarily a\n                // conflict: we might be in the case where the doc has been created during the edition because of\n                // an image added to it, without updating the client. So it's still accurate to check that the diff\n                // hasn't changed.\n                if (!originalDoc.isNew() && previousDoc != null) {\n                    // if changes between previousVersion and latestVersion didn't change the content, it means it's ok\n                    // to save the current changes.\n                    List<Delta> contentDiff =\n                        originalDoc.getContentDiff(previousVersion.toString(), latestVersion.toString(), context);\n\n                    // we also need to check the object diff, to be sure there's no conflict with the inline form.\n                    List<List<ObjectDiff>> objectDiff =\n                        originalDoc.getObjectDiff(previousVersion.toString(), latestVersion.toString(), context);\n\n                    // we finally check the metadata: we want to get a conflict if the title changed, or the syntax,\n                    // the default language etc.\n                    // However we have to filter out the author: we don't care if the author reference changed and it's\n                    // actually most certainly the case if we are here.\n                    List<MetaDataDiff> metaDataDiff =\n                        originalDoc.getMetaDataDiff(previousVersion.toString(), latestVersion.toString(), context);\n\n                    List<MetaDataDiff> filteredMetaDataDiff = new ArrayList<>();\n                    for (MetaDataDiff dataDiff : metaDataDiff) {\n                        if (!dataDiff.getField().equals(\"author\")) {\n                            filteredMetaDataDiff.add(dataDiff);\n                        }\n                    }\n\n                    if (contentDiff.isEmpty() && objectDiff.isEmpty() && filteredMetaDataDiff.isEmpty()) {\n                        return false;\n                    } else {\n                        MergeConfiguration mergeConfiguration = new MergeConfiguration();\n\n                        // We need the reference of the user and the document in the config to retrieve\n                        // the conflict decision in the MergeManager.\n                        mergeConfiguration.setUserReference(context.getUserReference());\n                        mergeConfiguration.setConcernedDocument(modifiedDoc.getDocumentReferenceWithLocale());\n\n                        // The modified doc is actually the one we should save, so it's ok to modify it directly\n                        // and better for performance.\n                        mergeConfiguration.setProvidedVersionsModifiables(true);\n\n                        // We need to retrieve the conflict decisions that might have occurred from the request.\n                        recordConflictDecisions(context, modifiedDoc.getDocumentReferenceWithLocale());\n\n                        MergeDocumentResult mergeDocumentResult =\n                            getMergeManager().mergeDocument(previousDoc, originalDoc, modifiedDoc, mergeConfiguration);\n\n                        // Be sure to not keep the conflict decisions we might have made if new conflicts occurred\n                        // we don't want to pollute the list of decisions.\n                        getConflictDecisionsManager().removeConflictDecisionList(\n                            modifiedDoc.getDocumentReferenceWithLocale(), context.getUserReference());\n\n                        // If we don't get any conflict, or if we want to force the merge even with conflicts,\n                        // then we pursue to save the document.\n                        if (FORCE_SAVE_MERGE.equals(request.getParameter(\"forceSave\"))\n                            || !mergeDocumentResult.hasConflicts()) {\n                            context.put(MERGED_DOCUMENTS, \"true\");\n                            return false;\n\n                            // If we got merge conflicts and we don't want to force it, then we record the conflict in\n                            // order to allow fixing them independently.\n                        } else {\n                            getConflictDecisionsManager().recordConflicts(modifiedDoc.getDocumentReferenceWithLocale(),\n                                context.getUserReference(),\n                                mergeDocumentResult.getConflicts(MergeDocumentResult.DocumentPart.CONTENT));\n                        }\n                    }\n                }\n\n                // if the revision has been deleted or if the content/object diff is not empty\n                // we have a conflict.\n                // TODO: Improve it to return the diff between the current version and the latest recorder\n                Map<String, String> jsonObject = new LinkedHashMap<>();\n                jsonObject.put(\"previousVersion\", previousVersion.toString());\n                jsonObject.put(\"previousVersionDate\", editingVersionDate.toString());\n                jsonObject.put(\"latestVersion\", latestVersion.toString());\n                jsonObject.put(\"latestVersionDate\", latestVersionDate.toString());\n                this.answerJSON(context, HttpStatus.SC_CONFLICT, jsonObject);\n                return true;\n            } catch (DifferentiationFailedException e) {\n                throw new XWikiException(\"Error while loading the diff\", e);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean action(XWikiContext context) throws XWikiException\n    {\n        // CSRF prevention\n        if (!csrfTokenCheck(context, true)) {\n            return false;\n        }\n\n        if (save(context)) {\n            return true;\n        }\n\n        // forward to view\n        if (Utils.isAjaxRequest(context)) {\n            Map<String, String> jsonAnswer = new LinkedHashMap<>();\n            Version newVersion = (Version) context.get(SAVED_OBJECT_VERSION_KEY);\n            jsonAnswer.put(\"newVersion\", newVersion.toString());\n            if (\"true\".equals(context.get(MERGED_DOCUMENTS))) {\n                jsonAnswer.put(\"mergedDocument\", \"true\");\n            }\n            answerJSON(context, HttpStatus.SC_OK, jsonAnswer);\n        } else {\n            sendRedirect(context.getResponse(), Utils.getRedirect(\"view\", context));\n        }\n        return false;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiException e = (XWikiException) context.get(\"exception\");\n        if ((e != null) && (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY)) {\n            return \"docalreadyexists\";\n        }\n\n        if (\"edit\".equals(context.get(\"display\"))) {\n            // When form validation (xvalidate) fails the save action forwards to the \"Inline form\" edit mode. In this\n            // case the context action is not \"save\" anymore because it was changed in #save(XWikiContext). The context\n            // action should be the action used by the \"Inline form\" edit mode (either \"edit\" or \"inline\").\n            return context.getAction();\n        }\n\n        return \"exception\";\n    }\n\n    private boolean isAsync(XWikiRequest request)\n    {\n        return \"true\".equals(request.get(ASYNC_PARAM));\n    }\n\n    private Job startCreateJob(EntityReference entityReference, EditForm editForm) throws XWikiException\n    {\n        if (StringUtils.isBlank(editForm.getTemplate())) {\n            // No template specified, nothing more to do.\n            return null;\n        }\n\n        // If a template is set in the request, then this is a create action which needs to be handled by a create job,\n        // but skipping the target document, which is now already saved by the save action.\n\n        RefactoringScriptService refactoring =\n            (RefactoringScriptService) Utils.getComponent(ScriptService.class, \"refactoring\");\n\n        CreateRequest request = refactoring.getRequestFactory().createCreateRequest(Arrays.asList(entityReference));\n        request.setCheckAuthorRights(false);\n        // Set the target document.\n        request.setEntityReferences(Arrays.asList(entityReference));\n        // Set the template to use.\n        DocumentReferenceResolver<String> resolver =\n            Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        EntityReference templateReference = resolver.resolve(editForm.getTemplate());\n        request.setTemplateReference(templateReference);\n        // We`ve already created and populated the fields of the target document, focus only on the remaining children\n        // specified in the template.\n        request.setSkippedEntities(Arrays.asList(entityReference));\n\n        Job createJob = refactoring.create(request);\n        if (createJob != null) {\n            return createJob;\n        } else {\n            throw new XWikiException(String.format(\"Failed to schedule the create job for [%s]\", entityReference),\n                refactoring.getLastError());\n        }\n    }\n\n    private String serializeJobId(List<String> jobId)\n    {\n        return StringUtils.join(jobId, \"/\");\n    }\n\n    private void convertSyntax(XWikiDocument doc, String targetSyntaxId, XWikiContext xcontext) throws XWikiException\n    {\n        // Convert the syntax without saving. The syntax conversion will be saved later along with the other changes.\n        doc.convertSyntax(targetSyntaxId, xcontext);\n\n        for (Locale locale : doc.getTranslationLocales(xcontext)) {\n            // Skip the edited translation because we handle it separately.\n            if (!Objects.equals(locale, doc.getLocale())) {\n                XWikiDocument tdoc = doc.getTranslatedDocument(locale, xcontext);\n                // Double check if the syntax has changed because each document translation can have a different syntax.\n                if (!tdoc.getSyntax().toIdString().equals(targetSyntaxId)) {\n                    // Convert the syntax and save the changes.\n                    tdoc.convertSyntax(targetSyntaxId, xcontext);\n                    xcontext.getWiki().saveDocument(tdoc,\n                        String.format(\"Document converted from syntax %s to syntax %s\", tdoc.getSyntax().toIdString(),\n                            targetSyntaxId),\n                        xcontext);\n                }\n            }\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Vector;\n\nimport javax.inject.Inject;\nimport javax.script.ScriptContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.ActionExecutedEvent;\nimport org.xwiki.bridge.event.ActionExecutingEvent;\nimport org.xwiki.component.descriptor.ComponentDescriptor;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.container.Container;\nimport org.xwiki.container.Request;\nimport org.xwiki.container.servlet.ServletContainerException;\nimport org.xwiki.container.servlet.ServletContainerInitializer;\nimport org.xwiki.container.servlet.ServletRequest;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.internal.DefaultJobProgress;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.EntityReferenceValueProvider;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.WrappedThreadEventListener;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.NotFoundResourceHandlerException;\nimport org.xwiki.resource.ResourceReference;\nimport org.xwiki.resource.ResourceReferenceHandler;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.velocity.VelocityManager;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;\nimport com.xpn.xwiki.internal.web.LegacyAction;\nimport com.xpn.xwiki.monitor.api.MonitorPlugin;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;\n\n/**\n * <p>\n * Root class for most XWiki actions. It provides a common framework that allows actions to execute just the specific\n * action code, handling the extra activities, such as preparing the context and retrieving the document corresponding\n * to the URL.\n * </p>\n * <p>\n * It defines two methods, {@link #action(XWikiContext)} and {@link #render(XWikiContext)}, that should be overridden by\n * specific actions. {@link #action(XWikiContext)} should contain the processing part of the action.\n * {@link #render(XWikiContext)} should return the name of a template that should be rendered, or manually write to the\n * {@link XWikiResponse response} stream.\n * </p>\n * <p>\n * Serving a request goes through the following phases:\n * </p>\n * <ul>\n * <li>Wrapping the request and response object in XWiki specific wrappers</li>\n * <li>Prepare the request {@link XWikiContext XWiki-specific context}</li>\n * <li>Initialize/retrieve the XWiki object corresponding to the requested wiki</li>\n * <li>Handle file uploads</li>\n * <li>Prepare the velocity context</li>\n * <li>Prepare the document objects corresponding to the requested URL</li>\n * <li>Send action pre-notifications to listeners</li>\n * <li>Run the overridden {@link #action(XWikiContext)}</li>\n * <li>If {@link #action(XWikiContext)} returns true, run the overridden {@link #render(XWikiContext)}</li>\n * <li>If {@link #render(XWikiContext)} returned a string (template name), render the template with that name</li>\n * <li>Send action post-notifications to listeners</li>\n * </ul>\n * <p>\n * During this process, also handle specific errors, like when a document does not exist, or the user does not have the\n * right to perform the current action.\n * </p>\n */\npublic abstract class XWikiAction implements LegacyAction\n{\n    public static final String ACTION_PROGRESS = \"actionprogress\";\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);\n\n    /**\n     * Actions that need to be resolved on the main wiki instead of the current non-existing wiki. This is used to be\n     * able to render the skin even on a wiki that doesn't exist.\n     */\n    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =\n        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");\n\n    @Inject\n    protected ComponentDescriptor<LegacyAction> componentDescriptor;\n\n    @Inject\n    protected Container container;\n\n    @Inject\n    protected Execution execution;\n\n    /**\n     * Indicate if the action allow asynchronous display (among which the XWiki initialization).\n     */\n    protected boolean waitForXWikiInitialization = true;\n\n    /**\n     * Indicate if the XWiki.RedirectClass is handled by the action (see handleRedirectObject()).\n     */\n    protected boolean handleRedirectObject = false;\n\n    private ContextualLocalizationManager localization;\n\n    private JobProgressManager progress;\n\n    private ScriptContextManager scriptContextManager;\n\n    private EntityNameValidationManager entityNameValidationManager;\n\n    private EntityNameValidationConfiguration entityNameValidationConfiguration;\n\n    private EntityReferenceSerializer<String> localSerializer;\n\n    /**\n     * @return the class of the XWikiForm in charge of parsing the request\n     * @since 13.0\n     */\n    @Unstable\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return null;\n    }\n\n    protected ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    protected String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    protected JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    protected EntityNameValidationManager getEntityNameValidationManager()\n    {\n        if (this.entityNameValidationManager == null) {\n            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);\n        }\n        return this.entityNameValidationManager;\n    }\n\n    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()\n    {\n        if (this.entityNameValidationConfiguration == null) {\n            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);\n        }\n\n        return this.entityNameValidationConfiguration;\n    }\n\n    protected EntityReferenceSerializer<String> getLocalSerializer()\n    {\n        if (this.localSerializer == null) {\n            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n        return this.localSerializer;\n    }\n\n    /**\n     * @return the current unmodified {@link ScriptContext} instance\n     * @since 8.3M1\n     */\n    protected ScriptContext getCurrentScriptContext()\n    {\n        if (this.scriptContextManager == null) {\n            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);\n        }\n\n        return this.scriptContextManager.getCurrentScriptContext();\n    }\n\n    @Override\n    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception\n    {\n        XWikiContext context = null;\n\n        try {\n            // Initialize the XWiki Context which is the main object used to pass information across\n            // classes/methods. It's also wrapping the request, response, and all container objects\n            // in general.\n            context = initializeXWikiContext(servletRequest, servletResponse);\n\n            // From this line forward all information can be found in the XWiki Context.\n            execute(context);\n        } finally {\n            if (context != null) {\n                cleanupComponents();\n            }\n        }\n    }\n\n    /**\n     * Ensure that the given entity reference is valid according to the configured name strategy. Always returns true if\n     * the name strategy is not found.\n     *\n     * @param entityReference the entity reference name to validate\n     * @return {@code true} if the entity reference name is valid according to the name strategy.\n     * @since 12.0RC1\n     */\n    @Unstable\n    protected boolean isEntityReferenceNameValid(EntityReference entityReference)\n    {\n        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null\n            && this.getEntityNameValidationConfiguration().useValidation()) {\n            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {\n                Object[] args = {getLocalSerializer().serialize(entityReference)};\n                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,\n                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,\n                    args);\n                ScriptContext scontext = getCurrentScriptContext();\n                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Write an error response to an ajax request.\n     *\n     * @param httpStatusCode The status code to set on the response.\n     * @param message The message that should be displayed.\n     * @param context the context.\n     */\n    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)\n    {\n        try {\n            context.getResponse().setContentType(\"text/plain\");\n            context.getResponse().setStatus(httpStatusCode);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(message);\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);\n        }\n    }\n\n    public void execute(XWikiContext context) throws Exception\n    {\n        MonitorPlugin monitor = null;\n        FileUploadPlugin fileupload = null;\n        DefaultJobProgress actionProgress = null;\n        ObservationManager om = Utils.getComponent(ObservationManager.class);\n        Execution execution = Utils.getComponent(Execution.class);\n        String docName = \"\";\n\n        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");\n\n        String sasync = context.getRequest().get(\"async\");\n\n        try {\n            String action = context.getAction();\n\n            // Start progress\n            if (debug && om != null && execution != null) {\n                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());\n                om.addListener(new WrappedThreadEventListener(actionProgress));\n\n                // Register the action progress in the context\n                ExecutionContext econtext = execution.getContext();\n                if (econtext != null) {\n                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);\n                }\n            }\n\n            getProgress().pushLevelProgress(2, this);\n\n            getProgress().startStep(this, \"Get XWiki instance\");\n\n            // Initialize context.getWiki() with the main wiki\n            XWiki xwiki;\n\n            // Verify that the requested wiki exists\n            try {\n                // Don't show init screen if async is forced to false\n                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);\n\n                // If XWiki is still initializing display initialization template\n                if (xwiki == null) {\n                    // Display initialization template\n                    renderInit(context);\n\n                    // Initialization template has been displayed, stop here.\n                    return;\n                }\n            } catch (XWikiException e) {\n                // If the wiki asked by the user doesn't exist, then we first attempt to use any existing global\n                // redirects. If there are none, then we display the specific error template.\n                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {\n                    xwiki = XWiki.getMainXWiki(context);\n\n                    // Initialize the url factory\n                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n                    context.setURLFactory(urlf);\n\n                    // Initialize the velocity context and its bindings so that it may be used in the velocity templates\n                    // that we\n                    // are parsing below.\n                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n                    VelocityContext vcontext = velocityManager.getVelocityContext();\n\n                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                        // Starting XWiki 5.0M2, 'xwiki.virtual.redirect' was removed. Warn users still using it.\n                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {\n                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",\n                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));\n                        }\n\n                        // Display the error template only for actions that are not ignored\n                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {\n\n                            // Add localization resources to the context\n                            xwiki.prepareResources(context);\n\n                            // Set the main home page in the main space of the main wiki as the current requested entity\n                            // since we cannot set the non existing one as it would generate errors obviously...\n                            EntityReferenceValueProvider valueProvider =\n                                Utils.getComponent(EntityReferenceValueProvider.class);\n                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),\n                                valueProvider.getDefaultValue(EntityType.SPACE),\n                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);\n\n                            // Parse the error template\n                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),\n                                context);\n\n                            // Error template was displayed, stop here.\n                            return;\n                        }\n\n                        // At this point, we allow regular execution of the ignored action because even if the wiki\n                        // does not exist, we still need to allow UI resources to be retrieved (from the filesystem\n                        // and the main wiki) or our error template will not be rendered properly.\n\n                        // Proceed with serving the main wiki\n\n                    } else {\n                        // Global redirect was executed, stop here.\n                        return;\n                    }\n                } else {\n                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);\n                    throw e;\n                }\n            }\n\n            // Send global redirection (if any)\n            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                return;\n            }\n\n            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            // Handle ability to enter space URLs and convert them to page URLs (Nested Documents)\n            if (redirectSpaceURLs(action, urlf, xwiki, context)) {\n                return;\n            }\n\n            String sajax = context.getRequest().get(\"ajax\");\n            boolean ajax = false;\n            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {\n                ajax = true;\n            }\n            context.put(\"ajax\", ajax);\n\n            boolean async = false;\n            if (StringUtils.isNotEmpty(sasync)) {\n                async = sasync.equals(\"true\");\n            } else {\n                // By default allow asynchronous rendering for \"human oriented\" actions which are not executing an ajax\n                // request\n                async = !ajax && !this.waitForXWikiInitialization;\n            }\n            Utils.getComponent(AsyncContext.class).setEnabled(async);\n\n            // Any error before this will be treated using a redirection to an error page\n\n            if (monitor != null) {\n                monitor.startTimer(\"request\");\n            }\n\n            getProgress().startStep(this, \"Execute request\");\n\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n\n            getProgress().pushLevelProgress(7, this);\n\n            boolean eventSent = false;\n            try {\n                getProgress().startStep(this, \"Prepare documents and put them in the context\");\n\n                // Prepare documents and put them in the context\n                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {\n                    return;\n                }\n\n                // Start monitoring timer\n                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);\n                if (monitor != null) {\n                    monitor.startRequest(\"\", context.getAction(), context.getURL());\n                    monitor.startTimer(\"multipart\");\n                }\n\n                getProgress().startStep(this, \"Parses multipart\");\n\n                // Parses multipart so that params in multipart are available for all actions\n                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);\n                if (monitor != null) {\n                    monitor.endTimer(\"multipart\");\n                }\n\n                if (monitor != null) {\n                    monitor.setWikiPage(context.getDoc().getFullName());\n                }\n\n                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");\n\n                // For the moment we're sending the XWiki context as the data, but this will be\n                // changed in the future, when the whole platform will be written using components\n                // and there won't be a need for the context.\n                try {\n                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());\n                    om.notify(event, context.getDoc(), context);\n                    eventSent = true;\n                    if (event.isCanceled()) {\n                        // Action has been canceled\n                        // TODO: do something special ?\n                        return;\n                    }\n                } catch (Throwable ex) {\n                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()\n                        + \" using action [\" + context.getAction() + \"]\", ex);\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"prenotify\");\n                }\n\n                // Call the Actions\n\n                getProgress().startStep(this, \"Search and execute entity resource handler\");\n\n                // Call the new Entity Resource Reference Handler.\n                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(\n                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");\n                EntityResourceReference entityResourceReference =\n                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();\n\n                // We save the current action set since:\n                // - by default the action is set to \"view\" for Extensions not installed as root and contributing some\n                // new Entity Action (see https://jira.xwiki.org/browse/XWIKI-15182).\n                // - we want to set back the action in case no ResourceReferenceHandler was found to handle the URL\n                // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                String originalAction = context.getAction();\n                try {\n                    // Force the action in the context because of https://jira.xwiki.org/browse/XWIKI-15182.\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(entityResourceReference.getAction().getActionName());\n                    entityResourceReferenceHandler.handle(entityResourceReference,\n                        DefaultResourceReferenceHandlerChain.EMPTY);\n                    // Don't let the old actions kick in!\n                    return;\n                } catch (NotFoundResourceHandlerException e) {\n                    // No Entity Resource Action has been found. Don't do anything and let it go through\n                    // so that the old Action system kicks in...\n                    // Put back the action, because of https://jira.xwiki.org/browse/XWIKI-15182\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(originalAction);\n                }\n\n                getProgress().startStep(this, \"Execute action render\");\n\n                // Handle the XWiki.RedirectClass object that can be attached to the current document\n                boolean hasRedirect = false;\n                if (handleRedirectObject) {\n                    hasRedirect = handleRedirectObject(context);\n                }\n\n                // Then call the old Actions for backward compatibility (and because a lot of them have not been\n                // migrated to new Actions yet).\n                String renderResult = null;\n                XWikiDocument doc = context.getDoc();\n                docName = doc.getFullName();\n                if (!hasRedirect && action(context)) {\n                    renderResult = render(context);\n                }\n\n                if (renderResult != null) {\n                    if (doc.isNew() && \"view\".equals(context.getAction())\n                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))\n                        && !\"children\".equals(context.getRequest().get(\"viewer\"))\n                        && !\"siblings\".equals(context.getRequest().get(\"viewer\"))) {\n                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, context);\n                    } else {\n                        String page = Utils.getPage(context.getRequest(), renderResult);\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);\n                    }\n                }\n                return;\n            } catch (Throwable e) {\n                if (e instanceof IOException) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);\n                }\n\n                if (!(e instanceof XWikiException)) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,\n                        \"Uncaught exception\", e);\n                }\n\n                try {\n                    XWikiException xex = (XWikiException) e;\n                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        // Connection aborted from the client side, there's not much we can do on the server side. We\n                        // simply ignore it.\n                        LOGGER.debug(\"Connection aborted\", e);\n                        // We don't write any other message to the response, as the connection is broken, anyway.\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE\n                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                            context.put(\"cause\", \"disabled\");\n                        }\n                        // In case of user disabled or inactive, the resources are actually forbidden.\n                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);\n\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {\n                        context.put(\"message\", \"attachmentdoesnotexist\");\n                        Utils.parseTemplate(\n                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {\n                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));\n                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),\n                            context, vcontext);\n                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);\n                        return;\n                    }\n                    // Note: We don't use the vcontext variable computed above since apparently the velocity context\n                    // can have changed in between. Thus we get it again to be sure we're setting the binding in the\n                    // right one.\n                    velocityManager.getVelocityContext().put(\"exp\", e);\n                    if (LOGGER.isWarnEnabled()) {\n                        // Don't log \"Broken Pipe\" exceptions since they're not real errors and we don't want to pollute\n                        // the logs with unnecessary stack traces. It just means the client side has cancelled the\n                        // connection.\n                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {\n                            return;\n                        }\n                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);\n                    }\n                    // If the request is an AJAX request, we don't return a whole HTML page, but just the exception\n                    // inline.\n                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";\n                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);\n                    return;\n                } catch (XWikiException ex) {\n                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        LOGGER.error(\"Connection aborted\");\n                    }\n                } catch (Exception e2) {\n                    // I hope this never happens\n                    LOGGER.error(\"Uncaught exceptions (inner): \", e);\n                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);\n                }\n                return;\n            } finally {\n                // Let's make sure we have flushed content and closed\n                try {\n                    context.getResponse().getWriter().flush();\n                } catch (Throwable e) {\n                    // This might happen if the connection was closed, for example.\n                    // If we can't flush, then there's nothing more we can send to the client.\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"request\");\n                    monitor.startTimer(\"notify\");\n                }\n\n                if (eventSent) {\n                    // For the moment we're sending the XWiki context as the data, but this will be\n                    // changed in the future, when the whole platform will be written using components\n                    // and there won't be a need for the context.\n                    try {\n                        om.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);\n                    } catch (Throwable ex) {\n                        LOGGER.error(\"Cannot send action notifications for document [\" + docName + \" using action [\"\n                            + context.getAction() + \"]\", ex);\n                    }\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"notify\");\n                }\n\n                getProgress().startStep(this, \"Cleanup database connections\");\n\n                // Make sure we cleanup database connections\n                // There could be cases where we have some\n                xwiki.getStore().cleanUp(context);\n\n                getProgress().popLevelProgress(this);\n            }\n        } finally {\n            // End request\n            if (monitor != null) {\n                monitor.endRequest();\n            }\n\n            // Stop progress\n            if (actionProgress != null) {\n                getProgress().popLevelProgress(this);\n\n                om.removeListener(actionProgress.getName());\n            }\n\n            if (fileupload != null) {\n                fileupload.cleanFileList(context);\n            }\n        }\n    }\n\n    private void renderInit(XWikiContext xcontext) throws Exception\n    {\n        RenderingContext renderingContext = Utils.getComponent(RenderingContext.class);\n        MutableRenderingContext mutableRenderingContext =\n            renderingContext instanceof MutableRenderingContext ? (MutableRenderingContext) renderingContext : null;\n\n        if (mutableRenderingContext != null) {\n            mutableRenderingContext.push(renderingContext.getTransformation(), renderingContext.getXDOM(),\n                renderingContext.getDefaultSyntax(), \"init.vm\", renderingContext.isRestricted(), Syntax.XHTML_1_0);\n        }\n\n        xcontext.getResponse().setStatus(202);\n        xcontext.getResponse().setContentType(\"text/html; charset=UTF-8\");\n\n        try {\n            Utils.getComponent(TemplateManager.class).render(\"init.vm\", xcontext.getResponse().getWriter());\n        } finally {\n            if (mutableRenderingContext != null) {\n                mutableRenderingContext.pop();\n            }\n        }\n\n        xcontext.getResponse().flushBuffer();\n\n        xcontext.setFinished(true);\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse)\n        throws XWikiException, ServletException, InstantiationException, IllegalAccessException\n    {\n        XWikiForm form;\n        if (getFormClass() != null) {\n            form = getFormClass().newInstance();\n        } else {\n            form = null;\n        }\n\n        return initializeXWikiContext(servletRequest, servletResponse, form);\n    }\n\n    /**\n     * @return the name to put in the {@link XWikiContext}, by default the component role hint is used\n     * @since 13.0\n     */\n    @Unstable\n    protected String getName()\n    {\n        return this.componentDescriptor.getRoleHint();\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse, XWikiForm form) throws XWikiException, ServletException\n    {\n        String action = getName();\n\n        XWikiRequest request = new XWikiServletRequest(servletRequest);\n        XWikiResponse response = new XWikiServletResponse(servletResponse);\n        XWikiContext context = Utils.prepareContext(action, request, response,\n            new XWikiServletContext(servletRequest.getServletContext()));\n\n        if (form != null) {\n            form.reset(request);\n        }\n\n        // Add the form to the context\n        context.setForm(form);\n\n        // Initialize the Container component which is the new way of transporting the Context in the new\n        // component architecture.\n        initializeContainerComponent(context);\n\n        return context;\n    }\n\n    protected void initializeContainerComponent(XWikiContext context) throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request,\n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        ServletContainerInitializer containerInitializer = Utils.getComponent(ServletContainerInitializer.class);\n\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest(), context);\n            containerInitializer.initializeResponse(context.getResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize Request/Response or Session\", e);\n        }\n    }\n\n    protected void cleanupComponents()\n    {\n        // We must ensure we clean the ThreadLocal variables located in the Container and Execution\n        // components as otherwise we will have a potential memory leak.\n        container.removeRequest();\n        container.removeResponse();\n        container.removeSession();\n        execution.removeContext();\n    }\n\n    public String getRealPath(String path)\n    {\n        Request request = this.container.getRequest();\n\n        if (request instanceof ServletRequest) {\n            return ((ServletRequest) request).getHttpServletRequest().getServletContext().getRealPath(path);\n        }\n\n        return null;\n    }\n\n    // hook\n    public boolean action(XWikiContext context) throws XWikiException\n    {\n        return true;\n    }\n\n    // hook\n    public String render(XWikiContext context) throws XWikiException\n    {\n        return null;\n    }\n\n    /**\n     * Redirect the user to an other location if the document holds an XWiki.RedirectClass instance (used when a\n     * document is moved).\n     *\n     * @param context the XWiki context\n     * @return either or not a redirection have been sent\n     * @throws XWikiException if error occurs\n     * @since 8.0RC1\n     * @since 7.4.2\n     */\n    protected boolean handleRedirectObject(XWikiContext context) throws XWikiException\n    {\n        WikiReference wikiReference = context.getWikiReference();\n\n        // Look if the document has a redirect object\n        XWikiDocument doc = context.getDoc();\n        BaseObject redirectObj = doc.getXObject(RedirectClassDocumentInitializer.REFERENCE);\n        if (redirectObj == null) {\n            return false;\n        }\n\n        // Get the location\n        String location = redirectObj.getStringValue(\"location\");\n        if (StringUtils.isBlank(location)) {\n            return false;\n        }\n\n        // Resolve the location to get a reference\n        DocumentReferenceResolver<String> resolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);\n        EntityReference locationReference = resolver.resolve(location, wikiReference);\n\n        // Get the type of the current target\n        ResourceReference resourceReference = Utils.getComponent(ResourceReferenceManager.class).getResourceReference();\n        EntityResourceReference entityResource = (EntityResourceReference) resourceReference;\n        EntityReference entityReference = entityResource.getEntityReference();\n\n        // If the entity is inside a document, compute the new entity with the new document part.\n        if (entityReference.getType().ordinal() > EntityType.DOCUMENT.ordinal()) {\n            EntityReference parentDocument = entityReference.extractReference(EntityType.DOCUMENT);\n            locationReference = entityReference.replaceParent(parentDocument, locationReference);\n        }\n\n        // Get the URL corresponding to the location\n        // Note: the anchor part is lost in the process, because it is not sent to the server\n        // (see: http://stackoverflow.com/a/4276491)\n        String url = context.getWiki().getURL(locationReference, context.getAction(),\n            context.getRequest().getQueryString(), null, context);\n\n        // Send the redirection\n        try {\n            context.getResponse().sendRedirect(url);\n        } catch (IOException e) {\n            throw new XWikiException(\"Failed to redirect.\", e);\n        }\n\n        return true;\n    }\n\n    protected void handleRevision(XWikiContext context) throws XWikiException\n    {\n        String rev = context.getRequest().getParameter(\"rev\");\n        if (rev != null) {\n            context.put(\"rev\", rev);\n            XWikiDocument doc = (XWikiDocument) context.get(\"doc\");\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            // if the doc is deleted and we request a specific language, we have to set the locale so we can retrieve\n            // properly the document revision.\n            if (rev.startsWith(\"deleted\") && !StringUtils.isEmpty(context.getRequest().getParameter(\"language\"))\n                && doc == tdoc) {\n                Locale locale = LocaleUtils.toLocale(context.getRequest().getParameter(\"language\"), Locale.ROOT);\n                tdoc = new XWikiDocument(tdoc.getDocumentReference(), locale);\n            }\n            XWikiDocument rdoc =\n                (!doc.getLocale().equals(tdoc.getLocale())) ? doc : context.getWiki().getDocument(doc, rev, context);\n\n            XWikiDocument rtdoc =\n                (doc.getLocale().equals(tdoc.getLocale())) ? rdoc : context.getWiki().getDocument(tdoc, rev, context);\n\n            context.put(\"tdoc\", rtdoc);\n            context.put(\"cdoc\", rdoc);\n            context.put(\"doc\", rdoc);\n        }\n    }\n\n    /**\n     * Send redirection based on a regexp pattern (if any) set at the main wiki level. To enable this feature you must\n     * add xwiki.preferences.redirect=1 to your xwiki.cfg.\n     *\n     * @param response the servlet response\n     * @param url url of the request\n     * @param context the XWiki context\n     * @return true if a redirection has been sent\n     */\n    protected boolean sendGlobalRedirect(XWikiResponse response, String url, XWikiContext context) throws Exception\n    {\n        if (\"1\".equals(context.getWiki().Param(\"xwiki.preferences.redirect\"))) {\n            // Note: This implementation is not performant at all and will slow down the wiki as the number\n            // of redirects increases. A better implementation would use a cache of redirects and would use\n            // the notification mechanism to update the cache when the XWiki.XWikiPreferences document is\n            // modified.\n            XWikiDocument globalPreferences = context.getWiki().getDocument(\"xwiki:XWiki.XWikiPreferences\", context);\n            Vector<BaseObject> redirects = globalPreferences.getObjects(\"XWiki.GlobalRedirect\");\n\n            if (redirects != null) {\n                for (BaseObject redir : redirects) {\n                    if (redir != null) {\n                        String p = redir.getStringValue(\"pattern\");\n                        if (p != null && url.matches(p)) {\n                            String dest = redir.getStringValue(\"destination\");\n                            response.sendRedirect(url.replaceAll(p, dest));\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void sendRedirect(XWikiResponse response, String url) throws XWikiException\n    {\n        try {\n            if (url != null) {\n                response.sendRedirect(response.encodeRedirectURL(url));\n            }\n        } catch (IOException e) {\n            Object[] args = {url};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_REDIRECT_EXCEPTION,\n                \"Exception while sending redirect to page {0}\", e, args);\n        }\n    }\n\n    /**\n     * Gets the translated version of a document, in the specified language. If the translation does not exist, a new\n     * document translation is created. If the requested language does not correspond to a translation (is not defined\n     * or is the same as the main document), then the main document is returned.\n     *\n     * @param doc the main (default, untranslated) document to translate\n     * @param language the requested document language\n     * @param context the current request context\n     * @return the translated document, or the original untranslated document if the requested language is not a\n     *         translation\n     * @throws XWikiException if the translation cannot be retrieved from the database\n     */\n    protected XWikiDocument getTranslatedDocument(XWikiDocument doc, String language, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument tdoc;\n        if (StringUtils.isBlank(language) || language.equals(\"default\") || language.equals(doc.getDefaultLanguage())) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if (tdoc == doc) {\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n            }\n            tdoc.setTranslation(1);\n        }\n        return tdoc;\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     */\n    protected boolean csrfTokenCheck(XWikiContext context) throws XWikiException\n    {\n        return csrfTokenCheck(context, false);\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @param jsonAnswer if true, returns a JSON answer in case of AJAX request: allow to process it properly on client.\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     * @since 11.3RC1\n     */\n    protected boolean csrfTokenCheck(XWikiContext context, boolean jsonAnswer) throws XWikiException\n    {\n        final boolean isAjaxRequest = Utils.isAjaxRequest(context);\n        CSRFToken csrf = Utils.getComponent(CSRFToken.class);\n        try {\n            String token = context.getRequest().getParameter(\"form_token\");\n            if (!csrf.isTokenValid(token)) {\n                if (isAjaxRequest) {\n                    if (jsonAnswer) {\n                        Map<String, String> jsonObject = new LinkedHashMap<>();\n                        jsonObject.put(\"errorType\", \"CSRF\");\n                        jsonObject.put(\"resubmissionURI\", csrf.getRequestURI());\n                        jsonObject.put(\"newToken\", csrf.getToken());\n                        this.answerJSON(context, HttpServletResponse.SC_FORBIDDEN, jsonObject);\n                    } else {\n                        final String csrfCheckFailedMessage = localizePlainOrKey(\"core.editors.csrfCheckFailed\");\n                        writeAjaxErrorResponse(HttpServletResponse.SC_FORBIDDEN, csrfCheckFailedMessage, context);\n                    }\n                } else {\n                    sendRedirect(context.getResponse(), csrf.getResubmissionURL());\n                }\n\n                return false;\n            }\n        } catch (XWikiException exception) {\n            // too bad\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied, secret token verification failed\", exception);\n        }\n        return true;\n    }\n\n    /**\n     * In order to let users enter URLs to Spaces we do the following when receiving {@code /A/B} (where A and B are\n     * spaces):\n     * <ul>\n     * <li>check that the action is \"view\" (we only support this for the view action since otherwise this would break\n     * apps written before this concept was introduced in XWiki 7.2M1)</li>\n     * <li>if A.B exists then continue</li>\n     * <li>if A.B doesn't exist then forward to A.B.WebHome</li>\n     * </ul>\n     * In order to disable this redirect you should provide the {@code spaceRedirect=false} Query String parameter and\n     * value.\n     *\n     * @since 7.2M1\n     */\n    private boolean redirectSpaceURLs(String action, XWikiURLFactory urlf, XWiki xwiki, XWikiContext context)\n        throws Exception\n    {\n        if (\"view\".equals(action) && !\"false\".equalsIgnoreCase(context.getRequest().getParameter(\"spaceRedirect\"))) {\n            DocumentReference reference = xwiki.getDocumentReference(context.getRequest(), context);\n            if (!xwiki.exists(reference, context)) {\n                String defaultDocumentName = Utils.getComponent(EntityReferenceProvider.class)\n                    .getDefaultReference(EntityType.DOCUMENT).getName();\n                // Avoid an infinite loop by ensuring we're not on a WebHome already\n                if (!reference.getName().equals(defaultDocumentName)) {\n                    // Consider the reference as a Space Reference and Construct a new reference to the home of that\n                    // Space. Then generate the URL for it and forward to it\n                    SpaceReference spaceReference = new SpaceReference(reference.getName(), reference.getParent());\n                    // Extract the anchor\n                    String anchor = new URL(context.getRequest().getRequestURL().toString()).getRef();\n                    URL forwardURL = urlf.createURL(getLocalSerializer().serialize(spaceReference), defaultDocumentName,\n                        action, context.getRequest().getQueryString(), anchor,\n                        spaceReference.getWikiReference().getName(), context);\n                    // Since createURL() contain the webapp context and since RequestDispatcher should not contain it,\n                    // we need to remove it!\n                    String webappContext = xwiki.getWebAppPath(context);\n                    String relativeURL = urlf.getURL(forwardURL, context);\n                    relativeURL = '/' + StringUtils.substringAfter(relativeURL, webappContext);\n                    context.getRequest().getRequestDispatcher(relativeURL).forward(context.getRequest(),\n                        context.getResponse());\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Answer to a request with a JSON content.\n     * \n     * @param context the current context of the request.\n     * @param status the status code to send back.\n     * @param answer the content of the JSON answer.\n     * @throws XWikiException in case of error during the serialization of the JSON.\n     */\n    protected void answerJSON(XWikiContext context, int status, Map<String, String> answer) throws XWikiException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n\n        try {\n            String jsonAnswerAsString = mapper.writeValueAsString(answer);\n            context.getResponse().setContentType(\"application/json\");\n            context.getResponse().setContentLength(jsonAnswerAsString.length());\n            context.getResponse().setStatus(status);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(jsonAnswerAsString);\n        } catch (IOException e) {\n            throw new XWikiException(\"Error while sending JSON answer.\", e);\n        }\n    }\n\n    /**\n     * Make sure to set the right length (or nothing) in the response.\n     * \n     * @param response the response\n     * @param length the length to set in the response\n     * @since 11.10\n     * @since 10.11.10\n     * @since 11.3.6\n     */\n    protected void setContentLength(XWikiResponse response, long length)\n    {\n        // Set the content length in the response\n        response.setContentLengthLong(length);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\n\nimport javax.inject.Provider;\n\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.annotation.ComponentList;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.test.MockitoOldcoreRule;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link com.xpn.xwiki.web.CreateAction}.\n *\n * @version $Id$\n * @since 7.2M1\n */\n@ComponentList\n@ReferenceComponentList\npublic class CreateActionTest\n{\n    @Rule\n    public MockitoOldcoreRule oldcore = new MockitoOldcoreRule();\n\n    XWikiURLFactory mockURLFactory;\n\n    CreateAction action;\n\n    XWikiContext context;\n\n    XWikiRequest mockRequest;\n\n    XWikiResponse mockResponse;\n\n    Query mockTemplateProvidersQuery;\n\n    @Before\n    public void setUp() throws Exception\n    {\n        context = oldcore.getXWikiContext();\n\n        Utils.setComponentManager(oldcore.getMocker());\n\n        QueryManager mockSecureQueryManager =\n            oldcore.getMocker().registerMockComponent((Type) QueryManager.class, \"secure\");\n\n        mockTemplateProvidersQuery = mock(Query.class);\n        when(mockSecureQueryManager.createQuery(any(), any())).thenReturn(mockTemplateProvidersQuery);\n        when(mockTemplateProvidersQuery.execute()).thenReturn(Collections.emptyList());\n\n        when(oldcore.getMockContextualAuthorizationManager().hasAccess(any(Right.class), any(EntityReference.class)))\n            .thenReturn(true);\n\n        Provider<DocumentReference> mockDocumentReferenceProvider =\n            oldcore.getMocker().registerMockComponent(DocumentReference.TYPE_PROVIDER);\n        when(mockDocumentReferenceProvider.get())\n            .thenReturn(new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\"));\n\n        mockURLFactory = mock(XWikiURLFactory.class);\n        context.setURLFactory(mockURLFactory);\n\n        action = new CreateAction();\n\n        mockRequest = mock(XWikiRequest.class);\n        context.setRequest(mockRequest);\n\n        mockResponse = mock(XWikiResponse.class);\n        context.setResponse(mockResponse);\n\n        when(mockRequest.get(\"type\")).thenReturn(\"plain\");\n\n        this.oldcore.getMocker().registerMockComponent(ObservationManager.class);\n    }\n\n    @Test\n    public void newDocumentFromURL() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    public void newDocumentButNonTerminalFromURL() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Pass the tocreate=nonterminal request parameter\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,\n            \"xwiki\", context);\n    }\n\n    @Test\n    public void newDocumentFromURLWhenNoType() throws Exception\n    {\n        // No type has been set by the user\n        when(mockRequest.get(\"type\")).thenReturn(null);\n\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertEquals(\"create\", result);\n    }\n\n    @Test\n    public void newDocumentWebHomeTopLevelFromURL() throws Exception\n    {\n        // new document = xwiki:X.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: The title is not \"WebHome\", but \"X\" (the space's name) to avoid exposing \"WebHome\" in the UI.\n        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    public void newDocumentWebHomeFromURL() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: The bebavior is the same for both a top level space and a child space WebHome.\n        // Note2: The title is not \"WebHome\", but \"Y\" (the space's name) to avoid exposing \"WebHome\" in the UI.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,\n            \"xwiki\", context);\n    }\n\n    @Test\n    public void newDocumentWebHomeButTerminalFromURL() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Pass the tocreate=terminal request parameter\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y instead of X.Y.WebHome because the tocreate parameter says \"terminal\".\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    public void newDocumentWebHomeTopLevelSpaceButTerminalFromURL() throws Exception\n    {\n        // new document = xwiki:X.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Pass the tocreate=terminal request parameter\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to enter the missing values.\n        assertEquals(\"create\", result);\n\n        // Note: We can not create the \"X\" terminal document, since it is already at the top level of the hierarchy and\n        // none was able to be deducted from the given information. The user needs to specify more info in order to\n        // continue.\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),\n            any(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void existingDocumentFromUINoName() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Just landed on the create page or submitted with no values (no name) specified.\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to enter the missing values.\n        assertEquals(\"create\", result);\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),\n            any(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void existingDocumentFromUI() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.WebHome since we default to non-terminal documents.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,\n            \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUICheckEscaping() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X.Y&name=Z\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X.Y\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Z\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.Z.WebHome since we default to non-terminal documents.\n        verify(mockURLFactory).createURL(\"X.Y.Z\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null,\n            \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentTerminalFromUI() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&tocreate=terminal\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y instead of X.Y.WebHome because the tocreate parameter says \"terminal\".\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    public void existingDocumentTerminalFromUICheckEscaping() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X.Y&name=Z&tocreate=termina\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X.Y\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Z\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.Z instead of X.Y.Z.WebHome because the tocreate parameter says \"terminal\".\n        verify(mockURLFactory).createURL(\"X.Y\", \"Z\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    public void existingDocumentTerminalFromUIButAlreadyExisting() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n        // Mock it as existing in the DB as well with non-empty content\n        oldcore.getDocuments().put(new DocumentReference(documentReference, Locale.ROOT), document);\n        when(document.getContent()).thenReturn(\"Some non-empty content\");\n\n        // Submit from the UI spaceReference=X&name=Y&tocreate=terminal\n        // No diference if it was a non-terminal document, just easier to mock since we already have Main.WebHome set\n        // up.\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"Main\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"WebHome\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),\n            any(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void notExistingDocumentFromUIButNameTooLong() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(10);\n        context.setDoc(document);\n\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"Main\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Foo123456789\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),\n            any(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void notExistingDocumentFromUIButSpaceTooLong() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(10);\n        context.setDoc(document);\n\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"1.3.5.7.9.11\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Foo\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),\n            any(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void existingDocumentFromUITopLevelDocument() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI name=Y\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.WebHome since we default to non-terminal documents.\n        verify(mockURLFactory).createURL(\"Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    /*\n     * Deprecated parameters\n     */\n\n    @Test\n    public void existingDocumentFromUIDeprecated() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X&page=Y\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"page\")).thenReturn(\"Y\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y since the deprecated parameters were creating terminal documents by default.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    public void existingDocumentFromUIDeprecatedCheckEscaping() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X.Y&page=Z\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X.Y\");\n        when(mockRequest.getParameter(\"page\")).thenReturn(\"Z\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: The space parameter was previously considered as space name, not space reference, so it is escaped.\n        // Note2: We are creating X\\.Y.Z since the deprecated parameters were creating terminal documents by default.\n        verify(mockURLFactory).createURL(\"X\\\\.Y\", \"Z\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    public void existingDocumentNonTerminalFromUIDeprecated() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X&tocreate=space\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.WebHome because the tocreate parameter says \"space\".\n        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    public void existingDocumentNonTerminalFromUIDeprecatedIgnoringPage() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X&page=Y&tocreate=space\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"page\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.WebHome instead of X.Y because the tocreate parameter says \"space\" and the page\n        // parameter is ignored.\n        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    public void existingDocumentNonTerminalFromUIDeprecatedCheckEscaping() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X.Y&tocreate=space\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X.Y\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: The space parameter was previously considered as space name, not space reference, so it is escaped.\n        // Note2: We are creating X\\.Y.WebHome because the tocreate parameter says \"space\".\n        verify(mockURLFactory).createURL(\"X\\\\.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X.Y\", null,\n            \"xwiki\", context);\n    }\n\n    /*\n     * Template providers\n     */\n\n    @Test\n    public void existingDocumentFromUITemplateProviderExistingButNoneSelected() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(\"XWiki.MyTemplateProvider\",\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to enter the missing values.\n        assertEquals(\"create\", result);\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),\n            any(), any(XWikiContext.class));\n    }\n\n    /**\n     * Mocks 1 existing template provider.\n     * <p>\n     * Note: Calling it multiple times does not add multiple providers.\n     */\n    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,\n        List<String> allowedSpaces) throws Exception\n    {\n        mockExistingTemplateProviders(fullName, resolvedDocumentReference, allowedSpaces, false);\n    }\n\n    /**\n     * Mocks 1 existing template provider.\n     * <p>\n     * Note: Calling it multiple times does not add multiple providers.\n     */\n    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,\n        List<String> allowedSpaces, Boolean terminal) throws Exception\n    {\n        mockExistingTemplateProviders(fullName, resolvedDocumentReference, allowedSpaces, terminal, null);\n    }\n\n    /**\n     * Mocks 1 existing template provider.\n     * <p>\n     * Note: Calling it multiple times does not add multiple providers.\n     */\n    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,\n        List<String> allowedSpaces, Boolean terminal, String type) throws Exception\n    {\n        mockExistingTemplateProviders(fullName, resolvedDocumentReference, allowedSpaces, terminal, type, null);\n    }\n\n    /**\n     * Mocks 1 existing template provider.\n     * <p>\n     * Note: Calling it multiple times does not add multiple providers.\n     */\n    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,\n        List<String> allowedSpaces, Boolean terminal, String type, String action) throws Exception\n    {\n        DocumentReference templateProviderClassReference =\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"TemplateProviderClass\");\n\n        // Mock to return at least 1 existing template provider\n        when(mockTemplateProvidersQuery.execute()).thenReturn(new ArrayList<Object>(Arrays.asList(fullName)));\n\n        // Mock the template document as existing.\n        XWikiDocument templateProviderDocument = mock(XWikiDocument.class);\n        when(templateProviderDocument.getDocumentReference()).thenReturn(resolvedDocumentReference);\n        oldcore.getDocuments().put(new DocumentReference(resolvedDocumentReference, Locale.ROOT),\n            templateProviderDocument);\n        // Mock the provider object (template + spaces properties)\n        BaseObject templateProviderObject = mock(BaseObject.class);\n        when(templateProviderObject.getListValue(\"creationRestrictions\")).thenReturn(allowedSpaces);\n        String templateDocumentFullName = fullName.substring(0, fullName.indexOf(\"Provider\"));\n        when(templateProviderObject.getStringValue(\"template\")).thenReturn(templateDocumentFullName);\n        if (terminal != null) {\n            when(templateProviderObject.getIntValue(\"terminal\", -1)).thenReturn(terminal ? 1 : 0);\n        } else {\n            when(templateProviderObject.getIntValue(\"terminal\", -1)).thenReturn(-1);\n        }\n        if (type != null) {\n            when(templateProviderObject.getStringValue(\"type\")).thenReturn(type);\n        }\n        if (action != null) {\n            when(templateProviderObject.getStringValue(\"action\")).thenReturn(action);\n        }\n        when(templateProviderDocument.getXObject(templateProviderClassReference)).thenReturn(templateProviderObject);\n\n        // Mock the template document as existing\n        String templateDocumentName =\n            resolvedDocumentReference.getName().substring(0, resolvedDocumentReference.getName().indexOf(\"Provider\"));\n        DocumentReference templateDocumentReference =\n            new DocumentReference(templateDocumentName, new SpaceReference(resolvedDocumentReference.getParent()));\n        mockTemplateDocumentExisting(templateDocumentFullName, templateDocumentReference);\n    }\n\n    /**\n     * @param templateDocumentFullName\n     * @param templateDocumentReference\n     * @throws XWikiException\n     */\n    private void mockTemplateDocumentExisting(String templateDocumentFullName,\n        DocumentReference templateDocumentReference) throws XWikiException\n    {\n        XWikiDocument templateDocument = mock(XWikiDocument.class);\n        when(templateDocument.getDocumentReference()).thenReturn(templateDocumentReference);\n        when(templateDocument.getDefaultEditMode(context)).thenReturn(\"edit\");\n        oldcore.getDocuments().put(new DocumentReference(templateDocumentReference, Locale.ROOT), templateDocument);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecified() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y and using the template extracted from the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecifiedRestrictionExists() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider that allows usage in target space.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Arrays.asList(\"X\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: We are allowed to create anything under space X, be it a terminal or a non-terminal document.\n        // Note2: We are creating X.Y and using the template extracted from the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecifiedRestrictionExistsOnParentSpace() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X.Y.Z&name=W&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X.Y.Z\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"W\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider that allows usage in one of the target space's parents (top level in this\n        // case).\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Arrays.asList(\"X\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: We are allowed to create anything under space X or its children, be it a terminal or a non-terminal\n        // document\n        // Note2: We are creating X.Y.Z.W and using the template extracted from the template provider.\n        verify(mockURLFactory).createURL(\"X.Y.Z.W\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=W\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecifiedButNotAllowed() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"),\n            Arrays.asList(\"AnythingButX\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_TEMPLATE_NOT_AVAILABLE, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),\n            any(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void newDocumentFromURLTemplateProviderSpecifiedButNotAllowed() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference =\n            new DocumentReference(\"Y\", new SpaceReference(\"X\", new WikiReference(\"xwiki\")));\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"),\n            Arrays.asList(\"AnythingButX\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_TEMPLATE_NOT_AVAILABLE, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),\n            any(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void newDocumentWebHomeFromURLTemplateProviderSpecifiedButNotAllowed() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"),\n            Arrays.asList(\"AnythingButX\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_TEMPLATE_NOT_AVAILABLE, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),\n            any(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void newDocumentWebHomeFromURLTemplateProviderSpecifiedTerminal() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST, true);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal and using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    public void newDocumentWebHomeFromURLTemplateProviderSpecifiedTerminalOverriddenFromUIToNonTerminal()\n        throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST, true);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y.WebHome as non-terminal even if the template provider says otherwise.\n        // Also using a template, as specified in the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void newDocumentFromURLTemplateProviderSpecifiedNonTerminal() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", \"X\", \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST,\n            false);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal and using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void newDocumentFromURLTemplateProviderSpecifiedNonTerminalButOverriddenFromUITerminal() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", \"X\", \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST,\n            false);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal and using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateSpecified() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&template=XWiki.MyTemplate\n        String templateDocumentFullName = \"XWiki.MyTemplate\";\n        DocumentReference templateDocumentReference =\n            new DocumentReference(\"MyTemplate\", Arrays.asList(\"XWiki\"), \"xwiki\");\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"template\")).thenReturn(\"XWiki.MyTemplate\");\n\n        // Mock the passed template document as existing.\n        mockTemplateDocumentExisting(templateDocumentFullName, templateDocumentReference);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.WebHome and using the template specified in the request.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecifiedTerminal() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider that creates terminal documents.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST, true);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal and using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecifiedTerminalOverridenFromUIToNonTerminal() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");\n\n        // Mock 1 existing template provider that creates terminal documents.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST, true);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y.WebHome as non-terminal, even if the template provider says otherwise.\n        // Also using a template, as specified in the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecifiedNonTerminal() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider that creates terminal documents.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST,\n            false);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y.WebHome as non-terminal and using a template, as specified in the\n        // template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecifiedNonTerminalOverridenFromUIToTerminal() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Mock 1 existing template provider that creates terminal documents.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST,\n            false);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal, even if the template provider says otherwise.\n        // Also using a template, as specified in the template provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    public void newDocumentWebHomeFromURLTemplateProviderSpecifiedButOldPageType() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST, null,\n            \"page\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal, since the template provider did not specify a \"terminal\"\n        // property and it used the old \"page\" type instead. Also using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    public void newDocumentWebHomeFromURLTemplateProviderSpecifiedButOldPageTypeButOverriddenFromUIToNonTerminal()\n        throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST, null,\n            \"page\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y.WebHome as non-terminal, since even if the template provider did not\n        // specify a \"terminal\" property and it used the old \"page\" type, the UI explicitly asked for a non-terminal\n        // document. Also using a template, as specified in the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecifiedButOldSpaceType() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST, null,\n            \"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.WebHome as non-terminal, since the template provider does not specify a \"terminal\"\n        // property and we fallback on the \"type\" property's value. Also using the template extracted from the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    public void existingDocumentFromUITemplateProviderSpecifiedButOldSpaceTypeButOverridenFromUIToTerminal()\n        throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST, null,\n            \"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y as terminal, since it is overriden from the UI, regardless of any backwards\n        // compatibility resolutions. Also using the template extracted from the template provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    public void newDocumentWebHomeFromURLTemplateProviderSpecifiedWithSaveAndEdit() throws Exception\n    {\n        // Mock the document to create.\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", \"X\", \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getDocumentReferenceWithLocale()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        when(document.getDefaultEditMode(this.context)).thenReturn(\"edit\");\n        when(document.getDefaultLocale()).thenReturn(Locale.ROOT);\n        when(document.clone()).thenReturn(document);\n\n        // Mock the XWiki context.\n        when(this.context.getWiki().getLocalePreference(this.context)).thenReturn(Locale.FRENCH);\n        when(this.context.getWiki().getDocument(documentReference, this.context)).thenReturn(document);\n        this.context.setDoc(document);\n        DocumentReference userReference = new DocumentReference(\"xwiki\", \"Users\", \"Alice\");\n        this.context.setUserReference(userReference);\n\n        // Mock the creation request.\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"title\")).thenReturn(\"Yippee\");\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock the template provider.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(), null,\n            \"page\", \"saveandedit\");\n\n        // Run the create action.\n        assertNull(this.action.render(this.context));\n\n        verify(document).setLocale(Locale.ROOT);\n        verify(document).setDefaultLocale(Locale.FRENCH);\n        verify(document).readFromTemplate(new DocumentReference(\"xwiki\", \"XWiki\", \"MyTemplate\"), this.context);\n        verify(document).setTitle(\"Yippee\");\n        verify(document).setCreatorReference(userReference);\n        verify(document).setAuthorReference(userReference);\n        verify(this.context.getWiki()).saveDocument(document, this.context);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.util.Collections;\nimport java.util.Date;\n\nimport javax.inject.Named;\n\nimport org.apache.commons.lang.time.DateUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.context.Execution;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.validation.EntityNameValidation;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link SaveAction}.\n *\n * @version $Id$\n */\n@ComponentList\n@ReferenceComponentList\n@OldcoreTest(mockXWiki = false)\npublic class SaveActionTest\n{\n    private static final DocumentReference USER_REFERENCE = new DocumentReference(\"xwiki\", \"XWiki\", \"FooBar\");\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    @MockComponent\n    private EntityNameValidationManager entityNameValidationManager;\n\n    @MockComponent\n    private EntityNameValidationConfiguration entityNameValidationConfiguration;\n\n    @MockComponent\n    private Execution execution;\n\n    @MockComponent\n    @Named(\"xwikiproperties\")\n    private ConfigurationSource propertiesConf;\n\n    @MockComponent\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private XWikiContext context;\n\n    private SaveAction saveAction;\n\n    private XWikiRequest mockRequest;\n\n    private XWikiResponse mockResponse;\n\n    private XWikiDocument mockDocument;\n\n    private XWikiDocument mockClonedDocument;\n\n    private EditForm mockForm;\n\n    private XWiki xWiki;\n\n    @BeforeEach\n    void setup()\n    {\n        this.saveAction = new SaveAction();\n\n        context = oldcore.getXWikiContext();\n\n        xWiki = mock(XWiki.class);\n        context.setWiki(this.xWiki);\n\n        mockRequest = mock(XWikiRequest.class);\n        context.setRequest(mockRequest);\n\n        mockResponse = mock(XWikiResponse.class);\n        context.setResponse(mockResponse);\n\n        mockDocument = mock(XWikiDocument.class);\n        context.setDoc(mockDocument);\n\n        mockClonedDocument = mock(XWikiDocument.class);\n        when(mockDocument.clone()).thenReturn(mockClonedDocument);\n\n        mockForm = mock(EditForm.class);\n        context.setForm(mockForm);\n        when(this.entityNameValidationConfiguration.useValidation()).thenReturn(false);\n\n        context.setUserReference(USER_REFERENCE);\n    }\n\n    @Test\n    void newDocumentInvalidName() throws Exception\n    {\n        when(mockDocument.isNew()).thenReturn(true);\n        DocumentReference documentReference = new DocumentReference(\"XWiki\", \"Foo\", \"Bar\");\n        when(mockDocument.getDocumentReference()).thenReturn(documentReference);\n        when(this.entityNameValidationConfiguration.useValidation()).thenReturn(true);\n        EntityNameValidation entityNameValidation = mock(EntityNameValidation.class);\n        when(this.entityNameValidationManager.getEntityReferenceNameStrategy()).thenReturn(entityNameValidation);\n        when(entityNameValidation.isValid(documentReference)).thenReturn(false);\n\n        assertTrue(saveAction.save(this.context));\n        assertEquals(\"entitynamevalidation.create.invalidname\", context.get(\"message\"));\n        assertArrayEquals(new Object[] { \"Foo.Bar\" }, (Object[]) context.get(\"messageParameters\"));\n    }\n\n    @Test\n    void validSave() throws Exception\n    {\n        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));\n        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");\n        when(mockClonedDocument.getLock(this.context)).thenReturn(mock(XWikiLock.class));\n        when(mockForm.getTemplate()).thenReturn(\"\");\n        assertFalse(saveAction.save(this.context));\n        assertEquals(new Version(\"1.2\"), this.context.get(\"SaveAction.savedObjectVersion\"));\n\n        verify(mockClonedDocument).readFromTemplate(\"\", this.context);\n        verify(mockClonedDocument).setAuthor(\"XWiki.FooBar\");\n        verify(mockClonedDocument).setMetaDataDirty(true);\n        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);\n        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);\n        verify(mockClonedDocument).removeLock(this.context);\n    }\n\n    @Test\n    void validSaveNewTranslation() throws Exception\n    {\n        when(mockForm.getLanguage()).thenReturn(\"fr\");\n        when(mockClonedDocument.getTranslatedDocument(\"fr\", this.context)).thenReturn(mockClonedDocument);\n        when(mockClonedDocument.getDocumentReference()).thenReturn(new DocumentReference(\"xwiki\", \"My\", \"Page\"));\n        when(mockClonedDocument.getStore()).thenReturn(this.oldcore.getMockStore());\n        when(xWiki.getStore()).thenReturn(this.oldcore.getMockStore());\n        context.put(\"ajax\", true);\n        when(xWiki.isMultiLingual(this.context)).thenReturn(true);\n        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.1\");\n        when(mockRequest.getParameter(\"isNew\")).thenReturn(\"true\");\n        assertFalse(saveAction.save(this.context));\n        assertEquals(new Version(\"1.1\"), this.context.get(\"SaveAction.savedObjectVersion\"));\n        verify(this.xWiki).checkSavingDocument(eq(USER_REFERENCE), any(XWikiDocument.class), eq(\"\"),\n            eq(false), eq(this.context));\n        verify(this.xWiki).saveDocument(any(XWikiDocument.class), eq(\"\"), eq(false), eq(this.context));\n    }\n\n    @Test\n    void validSaveOldTranslation() throws Exception\n    {\n        when(mockForm.getLanguage()).thenReturn(\"fr\");\n        XWikiDocument translation = mock(XWikiDocument.class);\n        when(mockForm.getTemplate()).thenReturn(\"\");\n        when(mockClonedDocument.getTranslatedDocument(\"fr\", this.context)).thenReturn(translation);\n        when(translation.clone()).thenReturn(mockClonedDocument);\n        when(xWiki.getStore()).thenReturn(this.oldcore.getMockStore());\n        context.put(\"ajax\", true);\n        when(xWiki.isMultiLingual(this.context)).thenReturn(true);\n        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.3\");\n        when(mockRequest.getParameter(\"editingVersionDate\")).thenReturn(\"1000\");\n        when(translation.getRCSVersion()).thenReturn(new Version(\"1.3\"));\n        when(translation.getDate()).thenReturn(new Date(0));\n        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.4\"));\n        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");\n        assertFalse(saveAction.save(this.context));\n        assertEquals(new Version(\"1.4\"), this.context.get(\"SaveAction.savedObjectVersion\"));\n        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);\n        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);\n    }\n\n    /**\n     * This tests aims at checking the usecase when uploading an image in the WYSIWYG editor before the first save\n     * and saving afterwards.\n     */\n    @Test\n    void validSaveRequestImageUploadAndConflictCheck() throws Exception\n    {\n        when(mockDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));\n        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));\n        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");\n        when(mockClonedDocument.getLock(this.context)).thenReturn(mock(XWikiLock.class));\n        when(mockForm.getTemplate()).thenReturn(\"\");\n        when(this.propertiesConf.getProperty(\"edit.conflictChecking.enabled\")).thenReturn(true);\n        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.1\");\n        context.put(\"ajax\", true);\n        when(mockRequest.getParameter(\"forceSave\")).thenReturn(\"\");\n        when(mockRequest.getParameter(\"isNew\")).thenReturn(\"true\");\n\n        when(mockDocument.getDate()).thenReturn(new Date(42));\n        when(mockRequest.getParameter(\"editingVersionDate\")).thenReturn(\"43\");\n        when(this.documentRevisionProvider.getRevision(mockDocument, \"1.1\")).thenReturn(mock(XWikiDocument.class));\n        when(mockDocument.getContentDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());\n        when(mockDocument.getMetaDataDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());\n        when(mockDocument.getObjectDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());\n\n        assertFalse(saveAction.save(this.context));\n        assertEquals(new Version(\"1.2\"), this.context.get(\"SaveAction.savedObjectVersion\"));\n\n        verify(mockClonedDocument).readFromTemplate(\"\", this.context);\n        verify(mockClonedDocument).setAuthor(\"XWiki.FooBar\");\n        verify(mockClonedDocument).setMetaDataDirty(true);\n        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);\n        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);\n        verify(mockClonedDocument).removeLock(this.context);\n\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.annotation.Component;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\n\n/**\n * Administration xwiki action.\n *\n * @version $Id$\n */\n@Component\n@Named(\"admin\")\n@Singleton\npublic class AdminAction extends XWikiAction\n{\n    /** The logger. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(AdminAction.class);\n\n    /**\n     * Default constructor.\n     */\n    public AdminAction()\n    {\n        this.waitForXWikiInitialization = false;\n    }\n\n    @Override\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return EditForm.class;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        String content = request.getParameter(\"content\");\n        XWikiDocument doc = context.getDoc();\n        XWikiForm form = context.getForm();\n\n        synchronized (doc) {\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            EditForm peform = (EditForm) form;\n            String parent = peform.getParent();\n            if (parent != null) {\n                doc.setParent(parent);\n            }\n            String creator = peform.getCreator();\n            if (creator != null) {\n                doc.setCreator(creator);\n            }\n            String defaultTemplate = peform.getDefaultTemplate();\n            if (defaultTemplate != null) {\n                doc.setDefaultTemplate(defaultTemplate);\n            }\n            String defaultLanguage = peform.getDefaultLanguage();\n            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {\n                doc.setDefaultLanguage(defaultLanguage);\n            }\n            if (doc.getDefaultLanguage().equals(\"\")) {\n                doc.setDefaultLanguage(context.getWiki().getLanguagePreference(context));\n            }\n\n            String language = context.getWiki().getLanguagePreference(context);\n            String languagefromrequest = context.getRequest().getParameter(\"language\");\n            String languagetoedit =\n                ((languagefromrequest == null) || (languagefromrequest.equals(\"\"))) ? language : languagefromrequest;\n\n            if ((languagetoedit == null) || (languagetoedit.equals(\"default\"))) {\n                languagetoedit = \"\";\n            }\n            if (doc.isNew() || (doc.getDefaultLanguage().equals(languagetoedit))) {\n                languagetoedit = \"\";\n            }\n\n            if (languagetoedit.equals(\"\")) {\n                // In this case the created document is going to be the default document\n                tdoc = doc;\n                context.put(\"tdoc\", doc);\n                if (doc.isNew()) {\n                    doc.setDefaultLanguage(language);\n                    doc.setLanguage(\"\");\n                }\n            } else {\n                // If the translated doc object is the same as the doc object\n                // this means the translated doc did not exists so we need to create it\n                if ((tdoc == doc)) {\n                    tdoc = new XWikiDocument(doc.getDocumentReference());\n                    tdoc.setLanguage(languagetoedit);\n                    tdoc.setContent(doc.getContent());\n                    tdoc.setSyntax(doc.getSyntax());\n                    tdoc.setAuthor(context.getUser());\n                    tdoc.setStore(doc.getStore());\n                    context.put(\"tdoc\", tdoc);\n                }\n            }\n\n            XWikiDocument tdoc2 = tdoc.clone();\n            if (content != null && !content.isEmpty()) {\n                tdoc2.setContent(content);\n            }\n            context.put(\"tdoc\", tdoc2);\n            try {\n                readFromTemplate(tdoc2, peform.getTemplate(), context);\n            } catch (XWikiException e) {\n                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                    context.put(\"exception\", e);\n                    return \"docalreadyexists\";\n                }\n            }\n\n            /* Setup a lock */\n            try {\n                XWikiLock lock = tdoc.getLock(context);\n                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {\n                    tdoc.setLock(context.getUser(), context);\n                }\n            } catch (Exception e) {\n                // Lock should never make XWiki fail\n                // But we should log any related information\n                LOGGER.error(\"Exception while setting up lock\", e);\n            }\n        }\n\n        return \"admin\";\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\nimport javax.script.ScriptContext;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.util.Util;\n\n/**\n * Create document action.\n *\n * @version $Id$\n * @since 2.4M2\n */\n@Component\n@Named(\"create\")\n@Singleton\npublic class CreateAction extends XWikiAction\n{\n    /**\n     * The name of the create.vm template to render.\n     */\n    private static final String CREATE_TEMPLATE = \"create\";\n\n    /**\n     * The name of the parent parameter.\n     */\n    private static final String PARENT = \"parent\";\n\n    /**\n     * The name of the space reference parameter.\n     */\n    private static final String SPACE_REFERENCE = \"spaceReference\";\n\n    /**\n     * The name parameter.\n     */\n    private static final String NAME = \"name\";\n\n    /**\n     * The name of the template field inside the template provider, or the template parameter which can be sent\n     * directly, without passing through the template provider.\n     */\n    private static final String TEMPLATE = \"template\";\n\n    /**\n     * Internal name for a flag determining if we are creating a Nested Space or a terminal document.\n     */\n    private static final String IS_SPACE = \"isSpace\";\n\n    /**\n     * Space homepage document name.\n     */\n    private static final String WEBHOME = \"WebHome\";\n\n    /**\n     * Local entity reference serializer hint.\n     */\n    private static final String LOCAL_SERIALIZER_HINT = \"local\";\n\n    /**\n     * Current entity reference resolver hint.\n     */\n    private static final String CURRENT_MIXED_RESOLVER_HINT = \"currentmixed\";\n\n    /**\n     * The action to perform when creating a new page from a template.\n     *\n     * @version $Id$\n     */\n    private enum ActionOnCreate\n    {\n        /**\n         * Go to edit mode without saving.\n         */\n        EDIT(\"edit\"),\n\n        /**\n         * Save and then go to edit mode.\n         */\n        SAVE_AND_EDIT(\"saveandedit\"),\n\n        /**\n         * Save and then go to view mode.\n         */\n        SAVE_AND_VIEW(\"saveandview\");\n\n        private static final Map<String, ActionOnCreate> BY_ACTION = new HashMap<>();\n\n        static {\n            for (ActionOnCreate actionOnCreate : values()) {\n                BY_ACTION.put(actionOnCreate.action, actionOnCreate);\n            }\n        }\n\n        private final String action;\n\n        ActionOnCreate(String action)\n        {\n            this.action = action;\n        }\n\n        public static ActionOnCreate valueOfAction(String action)\n        {\n            return BY_ACTION.get(action);\n        }\n    }\n\n    /**\n     * Default constructor.\n     */\n    public CreateAction()\n    {\n        this.waitForXWikiInitialization = false;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        CreateActionRequestHandler handler = new CreateActionRequestHandler(context);\n\n        // Read the request and extract the passed information.\n        handler.processRequest();\n\n        // Save the determined values so we have them available in the action template.\n        ScriptContext scontext = getCurrentScriptContext();\n        scontext.setAttribute(SPACE_REFERENCE, handler.getSpaceReference(), ScriptContext.ENGINE_SCOPE);\n        scontext.setAttribute(NAME, handler.getName(), ScriptContext.ENGINE_SCOPE);\n        scontext.setAttribute(IS_SPACE, handler.isSpace(), ScriptContext.ENGINE_SCOPE);\n        // put the available templates on the context, for the .vm to not compute them again\n        scontext.setAttribute(\"availableTemplateProviders\", handler.getAvailableTemplateProviders(),\n            ScriptContext.ENGINE_SCOPE);\n        scontext.setAttribute(\"recommendedTemplateProviders\", handler.getRecommendedTemplateProviders(),\n            ScriptContext.ENGINE_SCOPE);\n\n        DocumentReference newDocumentReference = handler.getNewDocumentReference();\n        if (newDocumentReference == null) {\n            // There is information still missing, go back to the template and fill it.\n            return CREATE_TEMPLATE;\n        }\n\n        // Check if the creation in the spaceReference is allowed.\n        if (!handler.isTemplateProviderAllowedToCreateInCurrentSpace()) {\n            // The selected template provider is not usable in the selected location. Go back to the template and pick\n            // something else.\n            return CREATE_TEMPLATE;\n        }\n\n        // Checking the rights to create the new document.\n        // Note: Note checking the logical spaceReference, but the space of the final actual document reference, since\n        // that is where we are creating the new document.\n        checkRights(newDocumentReference.getLastSpaceReference(), context);\n\n        // Check if the document to create already exists and if it respects the name strategy\n        XWikiDocument newDocument = context.getWiki().getDocument(newDocumentReference, context);\n        if (handler.isDocumentAlreadyExisting(newDocument) || handler.isDocumentPathTooLong(newDocumentReference)\n            || !this.isEntityReferenceNameValid(newDocumentReference)) {\n            return CREATE_TEMPLATE;\n        }\n\n        // Verify if the \"type\" of document to create has been set, even if we currently do not use it in the action.\n        // The goal is let the user be able to chose it, which have some consequences in the UI (thanks to javascript).\n        // See: https://jira.xwiki.org/browse/XWIKI-12580\n        // Note: we do not need the \"type\" if we have a template provider: the type of the new document will be the type\n        // of the template.\n        // TODO: handle this type in doCreate() that we call above (see: https://jira.xwiki.org/browse/XWIKI-12585).\n        if (StringUtils.isBlank(handler.getType()) && !handler.hasTemplate()) {\n            return CREATE_TEMPLATE;\n        }\n\n        // create is finally valid, can be executed\n        doCreate(context, newDocument, handler.isSpace(), handler.getTemplateProvider());\n\n        return null;\n    }\n\n    /**\n     * @param context the XWiki context\n     * @param spaceReference the reference of the space where the new document will be created\n     * @throws XWikiException in case the permission to create a new document in the specified space is denied\n     */\n    private void checkRights(SpaceReference spaceReference, XWikiContext context) throws XWikiException\n    {\n        ContextualAuthorizationManager authManager = Utils.getComponent(ContextualAuthorizationManager.class);\n        if (!authManager.hasAccess(Right.EDIT, spaceReference)) {\n            Object[] args = { spaceReference.toString(), context.getUser() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"The creation of a document into the space {0} has been denied to user {1}\", null, args);\n        }\n    }\n\n    /**\n     * Actually executes the create, after all preconditions have been verified.\n     *\n     * @param context the context of this action\n     * @param newDocument the document to be created\n     * @param isSpace whether the document is a space webhome or a page\n     * @param templateProvider the template provider to create from\n     * @throws XWikiException in case anything goes wrong accessing xwiki documents\n     */\n    private void doCreate(XWikiContext context, XWikiDocument newDocument, boolean isSpace, BaseObject templateProvider)\n        throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        XWikiDocument doc = context.getDoc();\n\n        String parent = getParent(request, doc, isSpace, context);\n\n        // get the title of the page to create, as specified in the parameters\n        String title = getTitle(request, newDocument, isSpace);\n\n        // get the template from the template parameter, to allow creation directly from template, without\n        // forcing to create a template provider for each template creation\n        String template = getTemplate(templateProvider, request);\n\n        // Read from the template provide the action to perform when creating the page.\n        ActionOnCreate actionOnCreate = getActionOnCreate(templateProvider);\n\n        String action = null;\n        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {\n            initAndSaveDocument(context, newDocument, title, template, parent);\n            action = newDocument.getDefaultEditMode(context);\n        } else {\n            action = actionOnCreate == ActionOnCreate.SAVE_AND_VIEW ? \"save\" : getEditMode(template, context);\n        }\n\n        // Perform a redirection to the selected action of the document to create.\n        String redirectParams = getRedirectParameters(parent, title, template, actionOnCreate);\n        String redirectURL = newDocument.getURL(action, redirectParams, context);\n        redirectURL = context.getResponse().encodeRedirectURL(redirectURL);\n        if (context.getRequest().getParameterMap().containsKey(\"ajax\")) {\n            // If this template is displayed from a modal popup, send a header in the response notifying that a\n            // redirect must be performed in the calling page.\n            context.getResponse().setHeader(\"redirect\", redirectURL);\n        } else {\n            // Perform the redirect\n            sendRedirect(context.getResponse(), redirectURL);\n        }\n    }\n\n    /**\n     * @return the resolver uses to resolve references received in request parameters\n     */\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, CURRENT_MIXED_RESOLVER_HINT);\n    }\n\n    /**\n     * Initialize and save the new document before editing it. Follow the steps done by the Save action.\n     * \n     * @param context the XWiki context\n     * @param newDocument the document being created\n     * @param title the document title\n     * @param template the template to copy\n     * @param parent the parent document\n     * @throws XWikiException if copying the template or saving the document fails\n     */\n    private void initAndSaveDocument(XWikiContext context, XWikiDocument newDocument, String title, String template,\n        String parent) throws XWikiException\n    {\n        XWiki xwiki = context.getWiki();\n\n        // Set the locale and default locale, considering that we're creating the original version of the document\n        // (not a translation).\n        newDocument.setLocale(Locale.ROOT);\n        if (newDocument.getDefaultLocale() == Locale.ROOT) {\n            newDocument.setDefaultLocale(xwiki.getLocalePreference(context));\n        }\n\n        // Copy the template.\n        readFromTemplate(newDocument, template, context);\n\n        // Set the parent field.\n        if (!StringUtils.isEmpty(parent)) {\n            DocumentReference parentReference = this.currentmixedReferenceResolver.resolve(parent);\n            newDocument.setParentReference(parentReference);\n        }\n\n        // Set the document title\n        if (title != null) {\n            newDocument.setTitle(title);\n        }\n\n        // Set the author and creator.\n        DocumentReference currentUserReference = context.getUserReference();\n        newDocument.setAuthorReference(currentUserReference);\n        newDocument.setCreatorReference(currentUserReference);\n\n        // Make sure the user is allowed to make this modification\n        xwiki.checkSavingDocument(currentUserReference, newDocument, context);\n\n        xwiki.saveDocument(newDocument, context);\n    }\n\n    private String getRedirectParameters(String parent, String title, String template, ActionOnCreate actionOnCreate)\n    {\n        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {\n            // We don't need to pass any parameters because the document is saved before the redirect using the\n            // parameter values.\n            return null;\n        }\n\n        String redirectParams = \"template=\" + Util.encodeURI(template, null);\n        if (parent != null) {\n            redirectParams += \"&parent=\" + Util.encodeURI(parent, null);\n        }\n        if (title != null) {\n            redirectParams += \"&title=\" + Util.encodeURI(title, null);\n        }\n        if (actionOnCreate == ActionOnCreate.SAVE_AND_VIEW) {\n            // Add the CSRF token because we redirect to save action.\n            CSRFToken csrf = Utils.getComponent(CSRFToken.class);\n            redirectParams += \"&form_token=\" + Util.encodeURI(csrf.getToken(), null);\n        }\n\n        return redirectParams;\n    }\n\n    /**\n     * @param templateProvider the set template provider, if any\n     * @param request the request on which to fallback\n     * @return the string reference of the document to use as template or {@code \"\"} if none set\n     */\n    private String getTemplate(BaseObject templateProvider, XWikiRequest request)\n    {\n        String result = \"\";\n\n        if (templateProvider != null) {\n            result = templateProvider.getStringValue(TEMPLATE);\n        } else if (request.getParameter(TEMPLATE) != null) {\n            result = request.getParameter(TEMPLATE);\n        }\n\n        return result;\n    }\n\n    /**\n     * @param request the current request for which this action is executed\n     * @param doc the current document\n     * @param isSpace {@code true} if the request is to create a space, {@code false} if a page should be created\n     * @param context the XWiki context\n     * @return the serialized reference of the parent to create the document for\n     */\n    private String getParent(XWikiRequest request, XWikiDocument doc, boolean isSpace, XWikiContext context)\n    {\n        // This template can be passed a parent document reference in parameter (using the \"parent\" parameter).\n        // If a parent parameter is passed, use it to set the parent when creating the new Page or Space.\n        // If no parent parameter was passed:\n        // * use the current document\n        // ** if we're creating a new page and if the current document exists or\n        // * use the Main space's WebHome\n        // ** if we're creating a new page and the current document does not exist.\n        String parent = request.getParameter(PARENT);\n        if (StringUtils.isEmpty(parent)) {\n            EntityReferenceSerializer<String> localSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, LOCAL_SERIALIZER_HINT);\n\n            if (doc.isNew()) {\n                // Use the Main space's WebHome.\n                Provider<DocumentReference> defaultDocumentReferenceProvider =\n                    Utils.getComponent(DocumentReference.TYPE_PROVIDER);\n\n                DocumentReference parentRef =\n                    defaultDocumentReferenceProvider.get().setWikiReference(context.getWikiReference());\n\n                parent = localSerializer.serialize(parentRef);\n            } else {\n                // Use the current document.\n                DocumentReference parentRef = doc.getDocumentReference();\n\n                parent = localSerializer.serialize(parentRef);\n            }\n        }\n\n        return parent;\n    }\n\n    /**\n     * @param request the current request for which this action is executed\n     * @param newDocument the document to be created\n     * @param isSpace {@code true} if the request is to create a space, {@code false} if a page should be created\n     * @return the title of the page to be created. If no request parameter is set, the page name is returned for a new\n     *         page and the space name is returned for a new space\n     */\n    private String getTitle(XWikiRequest request, XWikiDocument newDocument, boolean isSpace)\n    {\n        String title = request.getParameter(\"title\");\n        if (StringUtils.isEmpty(title)) {\n            if (isSpace) {\n                title = newDocument.getDocumentReference().getLastSpaceReference().getName();\n            } else {\n                title = newDocument.getDocumentReference().getName();\n                // Avoid WebHome titles for pages that are really space homepages.\n                if (WEBHOME.equals(title)) {\n                    title = newDocument.getDocumentReference().getLastSpaceReference().getName();\n                }\n            }\n        }\n\n        return title;\n    }\n\n    /**\n     * @param templateProvider the template provider for this creation\n     * @return {@code true} if the created document should be saved on create, before editing, {@code false} otherwise\n     */\n    private ActionOnCreate getActionOnCreate(BaseObject templateProvider)\n    {\n        if (templateProvider != null) {\n            String action = templateProvider.getStringValue(\"action\");\n            ActionOnCreate actionOnCreate = ActionOnCreate.valueOfAction(action);\n            if (actionOnCreate != null) {\n                return actionOnCreate;\n            }\n        }\n\n        // Default action when creating a page from a template.\n        return ActionOnCreate.EDIT;\n    }\n\n    /**\n     * @param template the template to create document from\n     * @param resolver the resolver to use to resolve the template document reference\n     * @param context the context of the current request\n     * @return the default edit mode for a document created from the passed template\n     * @throws XWikiException in case something goes wrong accessing template document\n     */\n    private String getEditMode(String template, XWikiContext context)\n        throws XWikiException\n    {\n        // Determine the edit action (edit/inline) for the newly created document, if a template is passed it is\n        // used to determine the action. Default is 'edit'.\n        String editAction = ActionOnCreate.EDIT.name().toLowerCase();\n        XWiki xwiki = context.getWiki();\n        if (!StringUtils.isEmpty(template)) {\n            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n            if (xwiki.exists(templateReference, context)) {\n                editAction = xwiki.getDocument(templateReference, context).getDefaultEditMode(context);\n            }\n        }\n\n        return editAction;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.script.ScriptContext;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.rendering.syntax.Syntax;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\n\n/**\n * Initializes a document before it is edited.\n *\n * @version $Id$\n */\n@Component\n@Named(\"edit\")\n@Singleton\npublic class EditAction extends XWikiAction\n{\n    /**\n     * The object used for logging.\n     */\n    private static final Logger LOGGER = LoggerFactory.getLogger(EditAction.class);\n\n    /**\n     * Default constructor.\n     */\n    public EditAction()\n    {\n        this.waitForXWikiInitialization = false;\n    }\n\n    @Override\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return EditForm.class;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiDocument editedDocument = prepareEditedDocument(context);\n            maybeLockDocument(editedDocument, context);\n        } catch (XWikiException e) {\n            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                context.put(\"exception\", e);\n                return \"docalreadyexists\";\n            } else {\n                throw e;\n            }\n        }\n\n        // Make sure object property fields are displayed in edit mode.\n        // See XWikiDocument#display(String, BaseObject, XWikiContext)\n        // TODO: Revisit the display mode after the inline action is removed. Is the display mode still needed when\n        // there is only one edit action?\n        context.put(\"display\", \"edit\");\n        return \"edit\";\n    }\n\n    /**\n     * Determines the edited document (translation) and updates it based on the template specified on the request and\n     * any additional request parameters that overwrite the default values from the template.\n     *\n     * @param context the XWiki context\n     * @return the edited document\n     * @throws XWikiException if something goes wrong\n     */\n    protected XWikiDocument prepareEditedDocument(XWikiContext context) throws XWikiException\n    {\n        // Determine the edited document (translation).\n        XWikiDocument editedDocument = getEditedDocument(context);\n        EditForm editForm = (EditForm) context.getForm();\n\n        // Update the edited document based on the template specified on the request.\n        readFromTemplate(editedDocument, editForm.getTemplate(), context);\n\n        // The default values from the template can be overwritten by additional request parameters.\n        updateDocumentTitleAndContentFromRequest(editedDocument, context);\n        editedDocument.readObjectsFromForm(editForm, context);\n\n        // Set the current user as creator, author and contentAuthor when the edited document is newly created to avoid\n        // using XWikiGuest instead (because those fields were not previously initialized).\n        if (editedDocument.isNew()) {\n            editedDocument.setCreatorReference(context.getUserReference());\n            editedDocument.setAuthorReference(context.getUserReference());\n            editedDocument.setContentAuthorReference(context.getUserReference());\n        }\n\n        // Expose the edited document on the XWiki context and the Velocity context.\n        putDocumentOnContext(editedDocument, context);\n\n        return editedDocument;\n    }\n\n    /**\n     * There are three important use cases:\n     * <ul>\n     * <li>editing or creating the original translation (for the default language)</li>\n     * <li>editing an existing document translation</li>\n     * <li>creating a new translation.</i>\n     * </ul>\n     * Most of the code deals with the really bad way the default language can be specified (empty string, 'default' or\n     * a real language code).\n     *\n     * @param context the XWiki context\n     * @return the edited document translation based on the language specified on the request\n     * @throws XWikiException if something goes wrong\n     */\n    private XWikiDocument getEditedDocument(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = context.getDoc();\n        boolean hasTranslation = doc != context.get(\"tdoc\");\n\n        // We have to clone the context document because it is cached and the changes we are going to make are valid\n        // only for the duration of the current request.\n        doc = doc.clone();\n        context.put(\"doc\", doc);\n\n        EditForm editForm = (EditForm) context.getForm();\n        doc.readDocMetaFromForm(editForm, context);\n\n        String language = context.getWiki().getLanguagePreference(context);\n        if (doc.isNew() && doc.getDefaultLanguage().equals(\"\")) {\n            doc.setDefaultLanguage(language);\n        }\n\n        String languageToEdit = StringUtils.isEmpty(editForm.getLanguage()) ? language : editForm.getLanguage();\n\n        // If no specific language is set or if it is \"default\" then we edit the current doc.\n        if (languageToEdit == null || languageToEdit.equals(\"default\")) {\n            languageToEdit = \"\";\n        }\n        // If the document is new or if the language to edit is the default language then we edit the default\n        // translation.\n        if (doc.isNew() || doc.getDefaultLanguage().equals(languageToEdit)) {\n            languageToEdit = \"\";\n        }\n        // If the doc does not exist in the language to edit and the language was not explicitly set in the URL then\n        // we edit the default document translation. This prevents use from creating unneeded translations.\n        if (!hasTranslation && StringUtils.isEmpty(editForm.getLanguage())) {\n            languageToEdit = \"\";\n        }\n\n        // Initialize the translated document.\n        XWikiDocument tdoc;\n        if (languageToEdit.equals(\"\")) {\n            // Edit the default document translation (default language).\n            tdoc = doc;\n            if (doc.isNew()) {\n                doc.setDefaultLanguage(language);\n                doc.setLanguage(\"\");\n            }\n        } else if (!hasTranslation && context.getWiki().isMultiLingual(context)) {\n            // Edit a new translation.\n            tdoc = new XWikiDocument(doc.getDocumentReference());\n            tdoc.setLanguage(languageToEdit);\n            tdoc.setDefaultLocale(doc.getDefaultLocale());\n            // Mark the translation. It's important to know whether a document is a translation or not, especially\n            // for the sheet manager which needs to access the objects using the default document not one of its\n            // translations.\n            tdoc.setTitle(doc.getTitle());\n            tdoc.setContent(doc.getContent());\n            tdoc.setSyntax(doc.getSyntax());\n            tdoc.setAuthorReference(context.getUserReference());\n            tdoc.setStore(doc.getStore());\n        } else {\n            // Edit an existing translation. Clone the translated document object to be sure that the changes we are\n            // going to make will last only for the duration of the current request.\n            tdoc = ((XWikiDocument) context.get(\"tdoc\")).clone();\n        }\n\n        return tdoc;\n    }\n\n    /**\n     * Updates the title and content of the given document with values taken from the 'title' and 'content' request\n     * parameters or based on the document section specified on the request.\n     *\n     * @param document the document whose title and content should be updated\n     * @param context the XWiki context\n     * @throws XWikiException if something goes wrong\n     */\n    private void updateDocumentTitleAndContentFromRequest(XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        // Check if section editing is enabled and if a section is specified.\n        boolean sectionEditingEnabled = context.getWiki().hasSectionEdit(context);\n        int sectionNumber = sectionEditingEnabled ? NumberUtils.toInt(context.getRequest().getParameter(\"section\")) : 0;\n        getCurrentScriptContext().setAttribute(\"sectionNumber\", sectionNumber, ScriptContext.ENGINE_SCOPE);\n\n        // Update the edited content.\n        EditForm editForm = (EditForm) context.getForm();\n        if (editForm.getContent() != null) {\n            document.setContent(editForm.getContent());\n        } else if (sectionNumber > 0) {\n            document.setContent(document.getContentOfSection(sectionNumber));\n        }\n\n        // Update the edited title.\n        if (editForm.getTitle() != null) {\n            document.setTitle(editForm.getTitle());\n        } else if (sectionNumber > 0 && document.getSections().size() > 0) {\n            // The edited content is either the content of the specified section or the content provided on the\n            // request. We assume the content provided on the request is meant to overwrite the specified section.\n            // In both cases the document content is currently having one section, so we can take its title.\n            String sectionTitle = document.getDocumentSection(1).getSectionTitle();\n            if (StringUtils.isNotBlank(sectionTitle)) {\n                // We cannot edit the page title while editing a page section so this title is for display only.\n                String sectionPlainTitle = document.getRenderedContent(sectionTitle, document.getSyntax().toIdString(),\n                    Syntax.PLAIN_1_0.toIdString(), context);\n                document.setTitle(localizePlainOrKey(\"core.editors.content.titleField.sectionEditingFormat\",\n                    document.getRenderedTitle(Syntax.PLAIN_1_0, context), sectionNumber, sectionPlainTitle));\n            }\n        }\n    }\n\n    /**\n     * Exposes the given document in the XWiki context and the Velocity context under the 'tdoc' and 'cdoc' keys.\n     *\n     * @param document the document to expose\n     * @param context the XWiki context\n     */\n    private void putDocumentOnContext(XWikiDocument document, XWikiContext context)\n    {\n        context.put(\"tdoc\", document);\n        // Old XWiki applications that are still using the inline action might expect the cdoc (content document) to be\n        // properly set on the context. Let's expose the given document also as cdoc for backward compatibility.\n        context.put(\"cdoc\", context.get(\"tdoc\"));\n    }\n\n    /**\n     * Locks the given document unless it is already locked by a different user and the current user didn't request to\n     * force the lock.\n     *\n     * @param document the document to lock\n     * @param context the XWiki context\n     */\n    private void maybeLockDocument(XWikiDocument document, XWikiContext context)\n    {\n        try {\n            XWikiLock lock = document.getLock(context);\n            EditForm editForm = (EditForm) context.getForm();\n            if (lock == null || lock.getUserName().equals(context.getUser()) || editForm.isLockForce()) {\n                document.setLock(context.getUser(), context);\n            }\n        } catch (Exception e) {\n            // Lock should never make XWiki fail, but we should log any related information.\n            LOGGER.error(\"Exception while setting up lock\", e);\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.annotation.Component;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\n\n/**\n * @deprecated use {@link EditAction} with {@code editor=inline} in the query string instead since 3.2\n */\n@Component\n@Named(\"inline\")\n@Singleton\n@Deprecated\npublic class InlineAction extends XWikiAction\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(InlineAction.class);\n\n    @Override\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return EditForm.class;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = context.getDoc();\n\n        synchronized (doc) {\n            XWikiForm form = context.getForm();\n\n            XWikiDocument cdoc = (XWikiDocument) context.get(\"cdoc\");\n            if (cdoc == null) {\n                cdoc = doc;\n            }\n\n            EditForm peform = (EditForm) form;\n\n            XWikiDocument doc2 = doc.clone();\n            context.put(\"doc\", doc2);\n\n            String parent = peform.getParent();\n            if (parent != null) {\n                doc2.setParent(parent);\n            }\n            String creator = peform.getCreator();\n            if (creator != null) {\n                doc2.setCreator(creator);\n            }\n            String defaultLanguage = peform.getDefaultLanguage();\n            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {\n                doc2.setDefaultLanguage(defaultLanguage);\n            }\n            if (doc2.getDefaultLanguage().equals(\"\")) {\n                doc2.setDefaultLanguage(context.getWiki().getLanguagePreference(context));\n            }\n            try {\n                readFromTemplate(doc2, peform.getTemplate(), context);\n            } catch (XWikiException e) {\n                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                    return \"docalreadyexists\";\n                }\n            }\n\n            if (doc == cdoc) {\n                context.put(\"cdoc\", doc2);\n            } else {\n                XWikiDocument cdoc2 = cdoc.clone();\n                readFromTemplate(cdoc2, peform.getTemplate(), context);\n                context.put(\"cdoc\", cdoc2);\n            }\n\n            doc2.readFromForm((EditForm) form, context);\n\n            // Set the current user as creator, author and contentAuthor when the edited document is newly created\n            // to avoid using XWikiGuest instead (because those fields were not previously initialized).\n            // This is needed for the script right, as guest doesn't have it and this would block the execution of\n            // scripts in newly created documents even if the user creating the document has the right.\n            if (doc2.isNew()) {\n                doc2.setCreatorReference(context.getUserReference());\n                doc2.setAuthorReference(context.getUserReference());\n                doc2.setContentAuthorReference(context.getUserReference());\n            }\n\n            /* Setup a lock */\n            try {\n                XWikiLock lock = doc.getLock(context);\n                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {\n                    doc.setLock(context.getUser(), context);\n                }\n            } catch (Exception e) {\n                // Lock should never make XWiki fail\n                // But we should log any related information\n                LOGGER.error(\"Exception while setting up lock\", e);\n            }\n        }\n\n        // Make sure object property fields are displayed in edit mode.\n        // See XWikiDocument#display(String, BaseObject, XWikiContext)\n        context.put(\"display\", \"edit\");\n\n        return \"inline\";\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.script.ScriptContext;\n\nimport org.apache.commons.httpclient.HttpStatus;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.diff.DifferentiationFailedException;\nimport org.suigeneris.jrcs.diff.delta.Delta;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.diff.ConflictDecision;\nimport org.xwiki.job.Job;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.refactoring.job.CreateRequest;\nimport org.xwiki.refactoring.script.RefactoringScriptService;\nimport org.xwiki.script.service.ScriptService;\nimport org.xwiki.store.merge.MergeConflictDecisionsManager;\nimport org.xwiki.store.merge.MergeDocumentResult;\nimport org.xwiki.store.merge.MergeManager;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MetaDataDiff;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\nimport com.xpn.xwiki.doc.merge.MergeConfiguration;\nimport com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;\nimport com.xpn.xwiki.objects.ObjectDiff;\n\n/**\n * Action used for saving and proceeding to view the saved page.\n * <p>\n * Used as a generic action for saving documents.\n *\n * @version $Id$\n */\n@Component\n@Named(\"save\")\n@Singleton\npublic class SaveAction extends PreviewAction\n{\n    /** The identifier of the save action. */\n    public static final String ACTION_NAME = \"save\";\n\n    protected static final String ASYNC_PARAM = \"async\";\n\n    /** Logger. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(SaveAction.class);\n\n    /**\n     * The key to retrieve the saved object version from the context.\n     */\n    private static final String SAVED_OBJECT_VERSION_KEY = \"SaveAction.savedObjectVersion\";\n\n    /**\n     * The context key to know if a document has been merged for saving it.\n     */\n    private static final String MERGED_DOCUMENTS = \"SaveAction.mergedDocuments\";\n\n    /**\n     * Parameter value used with forceSave to specify that the merge should be performed even if there is conflicts.\n     */\n    private static final String FORCE_SAVE_MERGE = \"merge\";\n\n    /**\n     * Parameter value used with forceSave to specify that no merge should be done but the current document should\n     * override the previous one.\n     */\n    private static final String FORCE_SAVE_OVERRIDE = \"override\";\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private MergeManager mergeManager;\n\n    private MergeConflictDecisionsManager conflictDecisionsManager;\n\n    public SaveAction()\n    {\n        this.waitForXWikiInitialization = true;\n    }\n\n    /**\n     * Saves the current document, updated according to the parameters sent in the request.\n     *\n     * @param context The current request {@link XWikiContext context}.\n     * @return <code>true</code> if there was an error and the response needs to render an error page,\n     *         <code>false</code> if the document was correctly saved.\n     * @throws XWikiException If an error occured: cannot communicate with the storage module, or cannot update the\n     *             document because the request contains invalid parameters.\n     */\n    public boolean save(XWikiContext context) throws XWikiException\n    {\n        XWiki xwiki = context.getWiki();\n        XWikiRequest request = context.getRequest();\n        XWikiDocument doc = context.getDoc();\n        EditForm form = (EditForm) context.getForm();\n\n        // Check save session\n        int sectionNumber = 0;\n        if (request.getParameter(\"section\") != null && xwiki.hasSectionEdit(context)) {\n            sectionNumber = Integer.parseInt(request.getParameter(\"section\"));\n        }\n\n        if (doc.isNew() && !this.isEntityReferenceNameValid(doc.getDocumentReference())) {\n            context.put(\"message\", \"entitynamevalidation.create.invalidname\");\n            context.put(\"messageParameters\",\n                new Object[] { getLocalSerializer().serialize(doc.getDocumentReference())});\n            return true;\n        }\n\n        XWikiDocument originalDoc = doc;\n\n        // We need to clone this document first, since a cached storage would return the same object for the\n        // following requests, so concurrent request might get a partially modified object, or worse, if an error\n        // occurs during the save, the cached object will not reflect the actual document at all.\n        doc = doc.clone();\n\n        String language = form.getLanguage();\n        // FIXME Which one should be used: doc.getDefaultLanguage or\n        // form.getDefaultLanguage()?\n        // String defaultLanguage = ((EditForm) form).getDefaultLanguage();\n        XWikiDocument tdoc;\n\n        if (doc.isNew() || (language == null) || (language.equals(\"\")) || (language.equals(\"default\"))\n            || (language.equals(doc.getDefaultLanguage()))) {\n            // Saving the default document translation.\n            // Need to save parent and defaultLanguage if they have changed\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if ((tdoc == doc) && xwiki.isMultiLingual(context)) {\n                // Saving a new document translation.\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n                // In that specific case, we want the original doc to be the translation document so that we\n                // never raised a conflict.\n                originalDoc = tdoc;\n            } else if (tdoc != doc) {\n                // Saving an existing document translation (but not the default one).\n                // Same as above, clone the object retrieved from the store cache.\n                originalDoc = tdoc;\n                tdoc = tdoc.clone();\n            }\n        }\n\n        if (doc.isNew()) {\n            doc.setLocale(Locale.ROOT);\n            if (doc.getDefaultLocale() == Locale.ROOT) {\n                doc.setDefaultLocale(xwiki.getLocalePreference(context));\n            }\n        }\n\n        try {\n            readFromTemplate(tdoc, form.getTemplate(), context);\n        } catch (XWikiException e) {\n            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                context.put(\"exception\", e);\n                return true;\n            }\n        }\n\n        // Convert the content and the meta data of the edited document and its translations if the syntax has changed\n        // and the request is asking for a syntax conversion. We do this after applying the template because the\n        // template may have content in the previous syntax that needs to be converted. We do this before applying the\n        // changes from the submitted form because it may contain content that was already converted.\n        if (form.isConvertSyntax() && !tdoc.getSyntax().toIdString().equals(form.getSyntaxId())) {\n            convertSyntax(tdoc, form.getSyntaxId(), context);\n        }\n\n        if (sectionNumber != 0) {\n            XWikiDocument sectionDoc = tdoc.clone();\n            sectionDoc.readFromForm(form, context);\n            String sectionContent = sectionDoc.getContent() + \"\\n\";\n            String content = tdoc.updateDocumentSection(sectionNumber, sectionContent);\n            tdoc.setContent(content);\n            tdoc.setComment(sectionDoc.getComment());\n            tdoc.setMinorEdit(sectionDoc.isMinorEdit());\n        } else {\n            tdoc.readFromForm(form, context);\n        }\n\n        // TODO: handle Author\n        String username = context.getUser();\n        tdoc.setAuthor(username);\n        if (tdoc.isNew()) {\n            tdoc.setCreator(username);\n        }\n\n        // Make sure we have at least the meta data dirty status\n        tdoc.setMetaDataDirty(true);\n\n        // Validate the document if we have xvalidate=1 in the request\n        if (\"1\".equals(request.getParameter(\"xvalidate\"))) {\n            boolean validationResult = tdoc.validate(context);\n            // If the validation fails we should show the \"Inline form\" edit mode\n            if (validationResult == false) {\n                // Set display context to 'edit'\n                context.put(\"display\", \"edit\");\n                // Set the action used by the \"Inline form\" edit mode as the context action. See #render(XWikiContext).\n                context.setAction(tdoc.getDefaultEditMode(context));\n                // Set the document in the context\n                context.put(\"doc\", doc);\n                context.put(\"cdoc\", tdoc);\n                context.put(\"tdoc\", tdoc);\n                // Force the \"Inline form\" edit mode.\n                getCurrentScriptContext().setAttribute(\"editor\", \"inline\", ScriptContext.ENGINE_SCOPE);\n\n                return true;\n            }\n        }\n\n        // Remove the redirect object if the save request doesn't update it. This allows users to easily overwrite\n        // redirect place-holders that are created when we move pages around.\n        if (tdoc.getXObject(RedirectClassDocumentInitializer.REFERENCE) != null\n            && request.getParameter(\"XWiki.RedirectClass_0_location\") == null) {\n            tdoc.removeXObjects(RedirectClassDocumentInitializer.REFERENCE);\n        }\n\n        // We only proceed on the check between versions in case of AJAX request, so we currently stay in the edit form\n        // This can be improved later by displaying a nice UI with some merge options in a sync request.\n        // For now we don't want our user to loose their changes.\n        if (isConflictCheckEnabled() && Utils.isAjaxRequest(context)\n            && request.getParameter(\"previousVersion\") != null) {\n            if (isConflictingWithVersion(context, originalDoc, tdoc)) {\n                return true;\n            }\n        }\n\n        // Make sure the user is allowed to make this modification\n        xwiki.checkSavingDocument(context.getUserReference(), tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);\n\n        // We get the comment to be used from the document\n        // It was read using readFromForm\n        xwiki.saveDocument(tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);\n\n        context.put(SAVED_OBJECT_VERSION_KEY, tdoc.getRCSVersion());\n\n        Job createJob = startCreateJob(tdoc.getDocumentReference(), form);\n        if (createJob != null) {\n            if (isAsync(request)) {\n                if (Utils.isAjaxRequest(context)) {\n                    // Redirect to the job status URL of the job we have just launched.\n                    sendRedirect(context.getResponse(), String.format(\"%s/rest/jobstatus/%s?media=json\",\n                        context.getRequest().getContextPath(), serializeJobId(createJob.getRequest().getId())));\n                }\n\n                // else redirect normally and the operation will eventually finish in the background.\n                // Note: It is preferred that async mode is called in an AJAX request that can display the progress.\n            } else {\n                // Sync mode, default, wait for the work to finish.\n                try {\n                    createJob.join();\n                } catch (InterruptedException e) {\n                    throw new XWikiException(String.format(\n                        \"Interrupted while waiting for template [%s] to be processed when creating the document [%s]\",\n                        form.getTemplate(), tdoc.getDocumentReference()), e);\n                }\n            }\n        } else {\n            // Nothing more to do, just unlock the document.\n            XWikiLock lock = tdoc.getLock(context);\n            if (lock != null) {\n                tdoc.removeLock(context);\n            }\n        }\n\n        return false;\n    }\n\n    private boolean isConflictCheckEnabled()\n    {\n        ConfigurationSource configurationSource = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");\n        return configurationSource.getProperty(\"edit.conflictChecking.enabled\", true);\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private MergeManager getMergeManager()\n    {\n        if (this.mergeManager == null) {\n            this.mergeManager = Utils.getComponent(MergeManager.class);\n        }\n\n        return this.mergeManager;\n    }\n\n    private MergeConflictDecisionsManager getConflictDecisionsManager()\n    {\n        if (this.conflictDecisionsManager == null) {\n            this.conflictDecisionsManager = Utils.getComponent(MergeConflictDecisionsManager.class);\n        }\n\n        return this.conflictDecisionsManager;\n    }\n\n    /**\n     * Retrieve the conflict decisions made from the request and fill the conflict decision manager with them. We handle\n     * two list of parameters here: - mergeChoices: those parameters are on the form [conflict id]=[choice] where the\n     * choice is defined by the {@link ConflictDecision.DecisionType} values. - customChoices: those parameters are on\n     * the form [conflict id]=[encoded string] where the encoded string is actually the desired value to solve the\n     * conflict.\n     */\n    private void recordConflictDecisions(XWikiContext context, DocumentReference documentReference)\n    {\n        XWikiRequest request = context.getRequest();\n        String[] mergeChoices = request.getParameterValues(\"mergeChoices\");\n        String[] customChoices = request.getParameterValues(\"customChoices\");\n\n        // Build a map indexed by the conflict ids and whose values are the actual decoded custom values.\n        Map<String, String> customChoicesMap = new HashMap<>();\n        if (customChoices != null) {\n            for (String customChoice : customChoices) {\n                String[] splittedCustomChoiceInfo = customChoice.split(\"=\");\n                String conflictReference = splittedCustomChoiceInfo[0];\n                String customValue = customChoice.substring(conflictReference.length() + 1);\n                try {\n                    customValue = URLDecoder.decode(customValue, request.getCharacterEncoding());\n                } catch (UnsupportedEncodingException e) {\n                    LOGGER.error(\"Error while decoding a custom value decision.\", e);\n                }\n                customChoicesMap.put(conflictReference, customValue);\n            }\n        }\n        if (mergeChoices != null) {\n            for (String choice : mergeChoices) {\n                String[] splittedChoiceInfo = choice.split(\"=\");\n                String conflictReference = splittedChoiceInfo[0];\n                String selectedChoice = splittedChoiceInfo[1];\n                List<String> customValue = null;\n\n                ConflictDecision.DecisionType decisionType =\n                    ConflictDecision.DecisionType.valueOf(selectedChoice.toUpperCase());\n\n                if (decisionType == ConflictDecision.DecisionType.CUSTOM) {\n                    customValue = Collections.singletonList(customChoicesMap.get(conflictReference));\n                }\n                getConflictDecisionsManager().recordDecision(documentReference, context.getUserReference(),\n                    conflictReference, decisionType, customValue);\n            }\n        }\n    }\n\n    /**\n     * Check if the version of the document being saved is conflicting with another version. This check is done by\n     * getting the \"previousVersion\" parameter from the request and comparing it with latest version of the document. If\n     * the current version of the document is not the same as the previous one, a diff is computed on the document\n     * content: a conflict is detected only if the contents are different.\n     * \n     * @param context the current context of the request.\n     * @param originalDoc the original version of the document being modified that will be saved (i.e. before content\n     *            changes). We don't retrieve it through context since it can be a translation.\n     * @return true in case of conflict. If it's true, the answer is immediately sent to the client.\n     */\n    private boolean isConflictingWithVersion(XWikiContext context, XWikiDocument originalDoc, XWikiDocument modifiedDoc)\n        throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n\n        // in case of force save we skip the check.\n        if (FORCE_SAVE_OVERRIDE.equals(request.getParameter(\"forceSave\"))) {\n            return false;\n        }\n\n        // the document is new we don't have to check the version date or anything\n        if (\"true\".equals(request.getParameter(\"isNew\")) && originalDoc.isNew()) {\n            return false;\n        }\n\n        // TODO The check of the previousVersion should be done at a lower level or with a semaphore since\n        // another job might have saved a different version of the document\n        Version previousVersion = new Version(request.getParameter(\"previousVersion\"));\n        Version latestVersion = originalDoc.getRCSVersion();\n\n        Date editingVersionDate = new Date(Long.parseLong(request.getParameter(\"editingVersionDate\")));\n        Date latestVersionDate = originalDoc.getDate();\n\n        // we ensure that nobody edited the document between the moment the user started to edit and now\n        if (!latestVersion.equals(previousVersion) || latestVersionDate.after(editingVersionDate)) {\n            try {\n                XWikiDocument previousDoc =\n                    getDocumentRevisionProvider().getRevision(originalDoc, previousVersion.toString());\n\n                // We also check that the previousDoc revision exists to avoid an exception if it has been deleted\n                // Note that if we're here and the request says that the document is new, it's not necessarily a\n                // conflict: we might be in the case where the doc has been created during the edition because of\n                // an image added to it, without updating the client. So it's still accurate to check that the diff\n                // hasn't changed.\n                if (!originalDoc.isNew() && previousDoc != null) {\n                    // if changes between previousVersion and latestVersion didn't change the content, it means it's ok\n                    // to save the current changes.\n                    List<Delta> contentDiff =\n                        originalDoc.getContentDiff(previousVersion.toString(), latestVersion.toString(), context);\n\n                    // we also need to check the object diff, to be sure there's no conflict with the inline form.\n                    List<List<ObjectDiff>> objectDiff =\n                        originalDoc.getObjectDiff(previousVersion.toString(), latestVersion.toString(), context);\n\n                    // we finally check the metadata: we want to get a conflict if the title changed, or the syntax,\n                    // the default language etc.\n                    // However we have to filter out the author: we don't care if the author reference changed and it's\n                    // actually most certainly the case if we are here.\n                    List<MetaDataDiff> metaDataDiff =\n                        originalDoc.getMetaDataDiff(previousVersion.toString(), latestVersion.toString(), context);\n\n                    List<MetaDataDiff> filteredMetaDataDiff = new ArrayList<>();\n                    for (MetaDataDiff dataDiff : metaDataDiff) {\n                        if (!dataDiff.getField().equals(\"author\")) {\n                            filteredMetaDataDiff.add(dataDiff);\n                        }\n                    }\n\n                    if (contentDiff.isEmpty() && objectDiff.isEmpty() && filteredMetaDataDiff.isEmpty()) {\n                        return false;\n                    } else {\n                        MergeConfiguration mergeConfiguration = new MergeConfiguration();\n\n                        // We need the reference of the user and the document in the config to retrieve\n                        // the conflict decision in the MergeManager.\n                        mergeConfiguration.setUserReference(context.getUserReference());\n                        mergeConfiguration.setConcernedDocument(modifiedDoc.getDocumentReferenceWithLocale());\n\n                        // The modified doc is actually the one we should save, so it's ok to modify it directly\n                        // and better for performance.\n                        mergeConfiguration.setProvidedVersionsModifiables(true);\n\n                        // We need to retrieve the conflict decisions that might have occurred from the request.\n                        recordConflictDecisions(context, modifiedDoc.getDocumentReferenceWithLocale());\n\n                        MergeDocumentResult mergeDocumentResult =\n                            getMergeManager().mergeDocument(previousDoc, originalDoc, modifiedDoc, mergeConfiguration);\n\n                        // Be sure to not keep the conflict decisions we might have made if new conflicts occurred\n                        // we don't want to pollute the list of decisions.\n                        getConflictDecisionsManager().removeConflictDecisionList(\n                            modifiedDoc.getDocumentReferenceWithLocale(), context.getUserReference());\n\n                        // If we don't get any conflict, or if we want to force the merge even with conflicts,\n                        // then we pursue to save the document.\n                        if (FORCE_SAVE_MERGE.equals(request.getParameter(\"forceSave\"))\n                            || !mergeDocumentResult.hasConflicts()) {\n                            context.put(MERGED_DOCUMENTS, \"true\");\n                            return false;\n\n                            // If we got merge conflicts and we don't want to force it, then we record the conflict in\n                            // order to allow fixing them independently.\n                        } else {\n                            getConflictDecisionsManager().recordConflicts(modifiedDoc.getDocumentReferenceWithLocale(),\n                                context.getUserReference(),\n                                mergeDocumentResult.getConflicts(MergeDocumentResult.DocumentPart.CONTENT));\n                        }\n                    }\n                }\n\n                // if the revision has been deleted or if the content/object diff is not empty\n                // we have a conflict.\n                // TODO: Improve it to return the diff between the current version and the latest recorder\n                Map<String, String> jsonObject = new LinkedHashMap<>();\n                jsonObject.put(\"previousVersion\", previousVersion.toString());\n                jsonObject.put(\"previousVersionDate\", editingVersionDate.toString());\n                jsonObject.put(\"latestVersion\", latestVersion.toString());\n                jsonObject.put(\"latestVersionDate\", latestVersionDate.toString());\n                this.answerJSON(context, HttpStatus.SC_CONFLICT, jsonObject);\n                return true;\n            } catch (DifferentiationFailedException e) {\n                throw new XWikiException(\"Error while loading the diff\", e);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean action(XWikiContext context) throws XWikiException\n    {\n        // CSRF prevention\n        if (!csrfTokenCheck(context, true)) {\n            return false;\n        }\n\n        if (save(context)) {\n            return true;\n        }\n\n        // forward to view\n        if (Utils.isAjaxRequest(context)) {\n            Map<String, String> jsonAnswer = new LinkedHashMap<>();\n            Version newVersion = (Version) context.get(SAVED_OBJECT_VERSION_KEY);\n            jsonAnswer.put(\"newVersion\", newVersion.toString());\n            if (\"true\".equals(context.get(MERGED_DOCUMENTS))) {\n                jsonAnswer.put(\"mergedDocument\", \"true\");\n            }\n            answerJSON(context, HttpStatus.SC_OK, jsonAnswer);\n        } else {\n            sendRedirect(context.getResponse(), Utils.getRedirect(\"view\", context));\n        }\n        return false;\n    }\n\n    @Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiException e = (XWikiException) context.get(\"exception\");\n        if ((e != null) && (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY)) {\n            return \"docalreadyexists\";\n        }\n\n        if (\"edit\".equals(context.get(\"display\"))) {\n            // When form validation (xvalidate) fails the save action forwards to the \"Inline form\" edit mode. In this\n            // case the context action is not \"save\" anymore because it was changed in #save(XWikiContext). The context\n            // action should be the action used by the \"Inline form\" edit mode (either \"edit\" or \"inline\").\n            return context.getAction();\n        }\n\n        return \"exception\";\n    }\n\n    private boolean isAsync(XWikiRequest request)\n    {\n        return \"true\".equals(request.get(ASYNC_PARAM));\n    }\n\n    private Job startCreateJob(EntityReference entityReference, EditForm editForm) throws XWikiException\n    {\n        DocumentReference templateReference = resolveTemplate(editForm.getTemplate());\n\n        if (templateReference == null) {\n            // No template specified, nothing more to do.\n            return null;\n        }\n\n        // If a template is set in the request, then this is a create action which needs to be handled by a create job,\n        // but skipping the target document, which is now already saved by the save action.\n\n        RefactoringScriptService refactoring =\n            (RefactoringScriptService) Utils.getComponent(ScriptService.class, \"refactoring\");\n\n        CreateRequest request = refactoring.getRequestFactory().createCreateRequest(Arrays.asList(entityReference));\n        request.setCheckAuthorRights(false);\n        // Set the target document.\n        request.setEntityReferences(Arrays.asList(entityReference));\n        // Set the template to use.\n        request.setTemplateReference(templateReference);\n        // We`ve already created and populated the fields of the target document, focus only on the remaining children\n        // specified in the template.\n        request.setSkippedEntities(Arrays.asList(entityReference));\n\n        Job createJob = refactoring.create(request);\n        if (createJob != null) {\n            return createJob;\n        } else {\n            throw new XWikiException(String.format(\"Failed to schedule the create job for [%s]\", entityReference),\n                refactoring.getLastError());\n        }\n    }\n\n    private String serializeJobId(List<String> jobId)\n    {\n        return StringUtils.join(jobId, \"/\");\n    }\n\n    private void convertSyntax(XWikiDocument doc, String targetSyntaxId, XWikiContext xcontext) throws XWikiException\n    {\n        // Convert the syntax without saving. The syntax conversion will be saved later along with the other changes.\n        doc.convertSyntax(targetSyntaxId, xcontext);\n\n        for (Locale locale : doc.getTranslationLocales(xcontext)) {\n            // Skip the edited translation because we handle it separately.\n            if (!Objects.equals(locale, doc.getLocale())) {\n                XWikiDocument tdoc = doc.getTranslatedDocument(locale, xcontext);\n                // Double check if the syntax has changed because each document translation can have a different syntax.\n                if (!tdoc.getSyntax().toIdString().equals(targetSyntaxId)) {\n                    // Convert the syntax and save the changes.\n                    tdoc.convertSyntax(targetSyntaxId, xcontext);\n                    xcontext.getWiki().saveDocument(tdoc,\n                        String.format(\"Document converted from syntax %s to syntax %s\", tdoc.getSyntax().toIdString(),\n                            targetSyntaxId),\n                        xcontext);\n                }\n            }\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Vector;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.script.ScriptContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.ActionExecutedEvent;\nimport org.xwiki.bridge.event.ActionExecutingEvent;\nimport org.xwiki.component.descriptor.ComponentDescriptor;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.container.Container;\nimport org.xwiki.container.Request;\nimport org.xwiki.container.servlet.ServletContainerException;\nimport org.xwiki.container.servlet.ServletContainerInitializer;\nimport org.xwiki.container.servlet.ServletRequest;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.internal.DefaultJobProgress;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.EntityReferenceValueProvider;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.WrappedThreadEventListener;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.NotFoundResourceHandlerException;\nimport org.xwiki.resource.ResourceReference;\nimport org.xwiki.resource.ResourceReferenceHandler;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.velocity.VelocityManager;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;\nimport com.xpn.xwiki.internal.web.LegacyAction;\nimport com.xpn.xwiki.monitor.api.MonitorPlugin;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;\n\n/**\n * <p>\n * Root class for most XWiki actions. It provides a common framework that allows actions to execute just the specific\n * action code, handling the extra activities, such as preparing the context and retrieving the document corresponding\n * to the URL.\n * </p>\n * <p>\n * It defines two methods, {@link #action(XWikiContext)} and {@link #render(XWikiContext)}, that should be overridden by\n * specific actions. {@link #action(XWikiContext)} should contain the processing part of the action.\n * {@link #render(XWikiContext)} should return the name of a template that should be rendered, or manually write to the\n * {@link XWikiResponse response} stream.\n * </p>\n * <p>\n * Serving a request goes through the following phases:\n * </p>\n * <ul>\n * <li>Wrapping the request and response object in XWiki specific wrappers</li>\n * <li>Prepare the request {@link XWikiContext XWiki-specific context}</li>\n * <li>Initialize/retrieve the XWiki object corresponding to the requested wiki</li>\n * <li>Handle file uploads</li>\n * <li>Prepare the velocity context</li>\n * <li>Prepare the document objects corresponding to the requested URL</li>\n * <li>Send action pre-notifications to listeners</li>\n * <li>Run the overridden {@link #action(XWikiContext)}</li>\n * <li>If {@link #action(XWikiContext)} returns true, run the overridden {@link #render(XWikiContext)}</li>\n * <li>If {@link #render(XWikiContext)} returned a string (template name), render the template with that name</li>\n * <li>Send action post-notifications to listeners</li>\n * </ul>\n * <p>\n * During this process, also handle specific errors, like when a document does not exist, or the user does not have the\n * right to perform the current action.\n * </p>\n */\npublic abstract class XWikiAction implements LegacyAction\n{\n    public static final String ACTION_PROGRESS = \"actionprogress\";\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);\n\n    /**\n     * Actions that need to be resolved on the main wiki instead of the current non-existing wiki. This is used to be\n     * able to render the skin even on a wiki that doesn't exist.\n     */\n    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =\n        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");\n\n    @Inject\n    protected ComponentDescriptor<LegacyAction> componentDescriptor;\n\n    @Inject\n    protected Container container;\n\n    @Inject\n    protected Execution execution;\n\n    @Inject\n    protected ContextualAuthorizationManager autorization;\n\n    @Inject\n    @Named(\"currentmixed\")\n    protected DocumentReferenceResolver<String> currentmixedReferenceResolver;\n\n    /**\n     * Indicate if the action allow asynchronous display (among which the XWiki initialization).\n     */\n    protected boolean waitForXWikiInitialization = true;\n\n    /**\n     * Indicate if the XWiki.RedirectClass is handled by the action (see handleRedirectObject()).\n     */\n    protected boolean handleRedirectObject = false;\n\n    private ContextualLocalizationManager localization;\n\n    private JobProgressManager progress;\n\n    private ScriptContextManager scriptContextManager;\n\n    private EntityNameValidationManager entityNameValidationManager;\n\n    private EntityNameValidationConfiguration entityNameValidationConfiguration;\n\n    private EntityReferenceSerializer<String> localSerializer;\n\n    /**\n     * @return the class of the XWikiForm in charge of parsing the request\n     * @since 13.0\n     */\n    @Unstable\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return null;\n    }\n\n    protected ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    protected String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    protected JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    protected EntityNameValidationManager getEntityNameValidationManager()\n    {\n        if (this.entityNameValidationManager == null) {\n            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);\n        }\n        return this.entityNameValidationManager;\n    }\n\n    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()\n    {\n        if (this.entityNameValidationConfiguration == null) {\n            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);\n        }\n\n        return this.entityNameValidationConfiguration;\n    }\n\n    protected EntityReferenceSerializer<String> getLocalSerializer()\n    {\n        if (this.localSerializer == null) {\n            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n        return this.localSerializer;\n    }\n\n    /**\n     * @return the current unmodified {@link ScriptContext} instance\n     * @since 8.3M1\n     */\n    protected ScriptContext getCurrentScriptContext()\n    {\n        if (this.scriptContextManager == null) {\n            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);\n        }\n\n        return this.scriptContextManager.getCurrentScriptContext();\n    }\n\n    @Override\n    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception\n    {\n        XWikiContext context = null;\n\n        try {\n            // Initialize the XWiki Context which is the main object used to pass information across\n            // classes/methods. It's also wrapping the request, response, and all container objects\n            // in general.\n            context = initializeXWikiContext(servletRequest, servletResponse);\n\n            // From this line forward all information can be found in the XWiki Context.\n            execute(context);\n        } finally {\n            if (context != null) {\n                cleanupComponents();\n            }\n        }\n    }\n\n    /**\n     * Ensure that the given entity reference is valid according to the configured name strategy. Always returns true if\n     * the name strategy is not found.\n     *\n     * @param entityReference the entity reference name to validate\n     * @return {@code true} if the entity reference name is valid according to the name strategy.\n     * @since 12.0RC1\n     */\n    @Unstable\n    protected boolean isEntityReferenceNameValid(EntityReference entityReference)\n    {\n        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null\n            && this.getEntityNameValidationConfiguration().useValidation()) {\n            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {\n                Object[] args = {getLocalSerializer().serialize(entityReference)};\n                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,\n                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,\n                    args);\n                ScriptContext scontext = getCurrentScriptContext();\n                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Write an error response to an ajax request.\n     *\n     * @param httpStatusCode The status code to set on the response.\n     * @param message The message that should be displayed.\n     * @param context the context.\n     */\n    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)\n    {\n        try {\n            context.getResponse().setContentType(\"text/plain\");\n            context.getResponse().setStatus(httpStatusCode);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(message);\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);\n        }\n    }\n\n    public void execute(XWikiContext context) throws Exception\n    {\n        MonitorPlugin monitor = null;\n        FileUploadPlugin fileupload = null;\n        DefaultJobProgress actionProgress = null;\n        ObservationManager om = Utils.getComponent(ObservationManager.class);\n        Execution execution = Utils.getComponent(Execution.class);\n        String docName = \"\";\n\n        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");\n\n        String sasync = context.getRequest().get(\"async\");\n\n        try {\n            String action = context.getAction();\n\n            // Start progress\n            if (debug && om != null && execution != null) {\n                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());\n                om.addListener(new WrappedThreadEventListener(actionProgress));\n\n                // Register the action progress in the context\n                ExecutionContext econtext = execution.getContext();\n                if (econtext != null) {\n                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);\n                }\n            }\n\n            getProgress().pushLevelProgress(2, this);\n\n            getProgress().startStep(this, \"Get XWiki instance\");\n\n            // Initialize context.getWiki() with the main wiki\n            XWiki xwiki;\n\n            // Verify that the requested wiki exists\n            try {\n                // Don't show init screen if async is forced to false\n                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);\n\n                // If XWiki is still initializing display initialization template\n                if (xwiki == null) {\n                    // Display initialization template\n                    renderInit(context);\n\n                    // Initialization template has been displayed, stop here.\n                    return;\n                }\n            } catch (XWikiException e) {\n                // If the wiki asked by the user doesn't exist, then we first attempt to use any existing global\n                // redirects. If there are none, then we display the specific error template.\n                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {\n                    xwiki = XWiki.getMainXWiki(context);\n\n                    // Initialize the url factory\n                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n                    context.setURLFactory(urlf);\n\n                    // Initialize the velocity context and its bindings so that it may be used in the velocity templates\n                    // that we\n                    // are parsing below.\n                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n                    VelocityContext vcontext = velocityManager.getVelocityContext();\n\n                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                        // Starting XWiki 5.0M2, 'xwiki.virtual.redirect' was removed. Warn users still using it.\n                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {\n                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",\n                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));\n                        }\n\n                        // Display the error template only for actions that are not ignored\n                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {\n\n                            // Add localization resources to the context\n                            xwiki.prepareResources(context);\n\n                            // Set the main home page in the main space of the main wiki as the current requested entity\n                            // since we cannot set the non existing one as it would generate errors obviously...\n                            EntityReferenceValueProvider valueProvider =\n                                Utils.getComponent(EntityReferenceValueProvider.class);\n                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),\n                                valueProvider.getDefaultValue(EntityType.SPACE),\n                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);\n\n                            // Parse the error template\n                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),\n                                context);\n\n                            // Error template was displayed, stop here.\n                            return;\n                        }\n\n                        // At this point, we allow regular execution of the ignored action because even if the wiki\n                        // does not exist, we still need to allow UI resources to be retrieved (from the filesystem\n                        // and the main wiki) or our error template will not be rendered properly.\n\n                        // Proceed with serving the main wiki\n\n                    } else {\n                        // Global redirect was executed, stop here.\n                        return;\n                    }\n                } else {\n                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);\n                    throw e;\n                }\n            }\n\n            // Send global redirection (if any)\n            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                return;\n            }\n\n            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            // Handle ability to enter space URLs and convert them to page URLs (Nested Documents)\n            if (redirectSpaceURLs(action, urlf, xwiki, context)) {\n                return;\n            }\n\n            String sajax = context.getRequest().get(\"ajax\");\n            boolean ajax = false;\n            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {\n                ajax = true;\n            }\n            context.put(\"ajax\", ajax);\n\n            boolean async = false;\n            if (StringUtils.isNotEmpty(sasync)) {\n                async = sasync.equals(\"true\");\n            } else {\n                // By default allow asynchronous rendering for \"human oriented\" actions which are not executing an ajax\n                // request\n                async = !ajax && !this.waitForXWikiInitialization;\n            }\n            Utils.getComponent(AsyncContext.class).setEnabled(async);\n\n            // Any error before this will be treated using a redirection to an error page\n\n            if (monitor != null) {\n                monitor.startTimer(\"request\");\n            }\n\n            getProgress().startStep(this, \"Execute request\");\n\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n\n            getProgress().pushLevelProgress(7, this);\n\n            boolean eventSent = false;\n            try {\n                getProgress().startStep(this, \"Prepare documents and put them in the context\");\n\n                // Prepare documents and put them in the context\n                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {\n                    return;\n                }\n\n                // Start monitoring timer\n                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);\n                if (monitor != null) {\n                    monitor.startRequest(\"\", context.getAction(), context.getURL());\n                    monitor.startTimer(\"multipart\");\n                }\n\n                getProgress().startStep(this, \"Parses multipart\");\n\n                // Parses multipart so that params in multipart are available for all actions\n                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);\n                if (monitor != null) {\n                    monitor.endTimer(\"multipart\");\n                }\n\n                if (monitor != null) {\n                    monitor.setWikiPage(context.getDoc().getFullName());\n                }\n\n                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");\n\n                // For the moment we're sending the XWiki context as the data, but this will be\n                // changed in the future, when the whole platform will be written using components\n                // and there won't be a need for the context.\n                try {\n                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());\n                    om.notify(event, context.getDoc(), context);\n                    eventSent = true;\n                    if (event.isCanceled()) {\n                        // Action has been canceled\n                        // TODO: do something special ?\n                        return;\n                    }\n                } catch (Throwable ex) {\n                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()\n                        + \" using action [\" + context.getAction() + \"]\", ex);\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"prenotify\");\n                }\n\n                // Call the Actions\n\n                getProgress().startStep(this, \"Search and execute entity resource handler\");\n\n                // Call the new Entity Resource Reference Handler.\n                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(\n                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");\n                EntityResourceReference entityResourceReference =\n                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();\n\n                // We save the current action set since:\n                // - by default the action is set to \"view\" for Extensions not installed as root and contributing some\n                // new Entity Action (see https://jira.xwiki.org/browse/XWIKI-15182).\n                // - we want to set back the action in case no ResourceReferenceHandler was found to handle the URL\n                // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                String originalAction = context.getAction();\n                try {\n                    // Force the action in the context because of https://jira.xwiki.org/browse/XWIKI-15182.\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(entityResourceReference.getAction().getActionName());\n                    entityResourceReferenceHandler.handle(entityResourceReference,\n                        DefaultResourceReferenceHandlerChain.EMPTY);\n                    // Don't let the old actions kick in!\n                    return;\n                } catch (NotFoundResourceHandlerException e) {\n                    // No Entity Resource Action has been found. Don't do anything and let it go through\n                    // so that the old Action system kicks in...\n                    // Put back the action, because of https://jira.xwiki.org/browse/XWIKI-15182\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(originalAction);\n                }\n\n                getProgress().startStep(this, \"Execute action render\");\n\n                // Handle the XWiki.RedirectClass object that can be attached to the current document\n                boolean hasRedirect = false;\n                if (handleRedirectObject) {\n                    hasRedirect = handleRedirectObject(context);\n                }\n\n                // Then call the old Actions for backward compatibility (and because a lot of them have not been\n                // migrated to new Actions yet).\n                String renderResult = null;\n                XWikiDocument doc = context.getDoc();\n                docName = doc.getFullName();\n                if (!hasRedirect && action(context)) {\n                    renderResult = render(context);\n                }\n\n                if (renderResult != null) {\n                    if (doc.isNew() && \"view\".equals(context.getAction())\n                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))\n                        && !\"children\".equals(context.getRequest().get(\"viewer\"))\n                        && !\"siblings\".equals(context.getRequest().get(\"viewer\"))) {\n                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, context);\n                    } else {\n                        String page = Utils.getPage(context.getRequest(), renderResult);\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);\n                    }\n                }\n                return;\n            } catch (Throwable e) {\n                if (e instanceof IOException) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);\n                }\n\n                if (!(e instanceof XWikiException)) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,\n                        \"Uncaught exception\", e);\n                }\n\n                try {\n                    XWikiException xex = (XWikiException) e;\n                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        // Connection aborted from the client side, there's not much we can do on the server side. We\n                        // simply ignore it.\n                        LOGGER.debug(\"Connection aborted\", e);\n                        // We don't write any other message to the response, as the connection is broken, anyway.\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE\n                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                            context.put(\"cause\", \"disabled\");\n                        }\n                        // In case of user disabled or inactive, the resources are actually forbidden.\n                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);\n\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {\n                        context.put(\"message\", \"attachmentdoesnotexist\");\n                        Utils.parseTemplate(\n                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {\n                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));\n                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),\n                            context, vcontext);\n                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);\n                        return;\n                    }\n                    // Note: We don't use the vcontext variable computed above since apparently the velocity context\n                    // can have changed in between. Thus we get it again to be sure we're setting the binding in the\n                    // right one.\n                    velocityManager.getVelocityContext().put(\"exp\", e);\n                    if (LOGGER.isWarnEnabled()) {\n                        // Don't log \"Broken Pipe\" exceptions since they're not real errors and we don't want to pollute\n                        // the logs with unnecessary stack traces. It just means the client side has cancelled the\n                        // connection.\n                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {\n                            return;\n                        }\n                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);\n                    }\n                    // If the request is an AJAX request, we don't return a whole HTML page, but just the exception\n                    // inline.\n                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";\n                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);\n                    return;\n                } catch (XWikiException ex) {\n                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        LOGGER.error(\"Connection aborted\");\n                    }\n                } catch (Exception e2) {\n                    // I hope this never happens\n                    LOGGER.error(\"Uncaught exceptions (inner): \", e);\n                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);\n                }\n                return;\n            } finally {\n                // Let's make sure we have flushed content and closed\n                try {\n                    context.getResponse().getWriter().flush();\n                } catch (Throwable e) {\n                    // This might happen if the connection was closed, for example.\n                    // If we can't flush, then there's nothing more we can send to the client.\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"request\");\n                    monitor.startTimer(\"notify\");\n                }\n\n                if (eventSent) {\n                    // For the moment we're sending the XWiki context as the data, but this will be\n                    // changed in the future, when the whole platform will be written using components\n                    // and there won't be a need for the context.\n                    try {\n                        om.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);\n                    } catch (Throwable ex) {\n                        LOGGER.error(\"Cannot send action notifications for document [\" + docName + \" using action [\"\n                            + context.getAction() + \"]\", ex);\n                    }\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"notify\");\n                }\n\n                getProgress().startStep(this, \"Cleanup database connections\");\n\n                // Make sure we cleanup database connections\n                // There could be cases where we have some\n                xwiki.getStore().cleanUp(context);\n\n                getProgress().popLevelProgress(this);\n            }\n        } finally {\n            // End request\n            if (monitor != null) {\n                monitor.endRequest();\n            }\n\n            // Stop progress\n            if (actionProgress != null) {\n                getProgress().popLevelProgress(this);\n\n                om.removeListener(actionProgress.getName());\n            }\n\n            if (fileupload != null) {\n                fileupload.cleanFileList(context);\n            }\n        }\n    }\n\n    private void renderInit(XWikiContext xcontext) throws Exception\n    {\n        RenderingContext renderingContext = Utils.getComponent(RenderingContext.class);\n        MutableRenderingContext mutableRenderingContext =\n            renderingContext instanceof MutableRenderingContext ? (MutableRenderingContext) renderingContext : null;\n\n        if (mutableRenderingContext != null) {\n            mutableRenderingContext.push(renderingContext.getTransformation(), renderingContext.getXDOM(),\n                renderingContext.getDefaultSyntax(), \"init.vm\", renderingContext.isRestricted(), Syntax.XHTML_1_0);\n        }\n\n        xcontext.getResponse().setStatus(202);\n        xcontext.getResponse().setContentType(\"text/html; charset=UTF-8\");\n\n        try {\n            Utils.getComponent(TemplateManager.class).render(\"init.vm\", xcontext.getResponse().getWriter());\n        } finally {\n            if (mutableRenderingContext != null) {\n                mutableRenderingContext.pop();\n            }\n        }\n\n        xcontext.getResponse().flushBuffer();\n\n        xcontext.setFinished(true);\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse)\n        throws XWikiException, ServletException, InstantiationException, IllegalAccessException\n    {\n        XWikiForm form;\n        if (getFormClass() != null) {\n            form = getFormClass().newInstance();\n        } else {\n            form = null;\n        }\n\n        return initializeXWikiContext(servletRequest, servletResponse, form);\n    }\n\n    /**\n     * @return the name to put in the {@link XWikiContext}, by default the component role hint is used\n     * @since 13.0\n     */\n    @Unstable\n    protected String getName()\n    {\n        return this.componentDescriptor.getRoleHint();\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse, XWikiForm form) throws XWikiException, ServletException\n    {\n        String action = getName();\n\n        XWikiRequest request = new XWikiServletRequest(servletRequest);\n        XWikiResponse response = new XWikiServletResponse(servletResponse);\n        XWikiContext context = Utils.prepareContext(action, request, response,\n            new XWikiServletContext(servletRequest.getServletContext()));\n\n        if (form != null) {\n            form.reset(request);\n        }\n\n        // Add the form to the context\n        context.setForm(form);\n\n        // Initialize the Container component which is the new way of transporting the Context in the new\n        // component architecture.\n        initializeContainerComponent(context);\n\n        return context;\n    }\n\n    protected void initializeContainerComponent(XWikiContext context) throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request,\n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        ServletContainerInitializer containerInitializer = Utils.getComponent(ServletContainerInitializer.class);\n\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest(), context);\n            containerInitializer.initializeResponse(context.getResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize Request/Response or Session\", e);\n        }\n    }\n\n    protected void cleanupComponents()\n    {\n        // We must ensure we clean the ThreadLocal variables located in the Container and Execution\n        // components as otherwise we will have a potential memory leak.\n        container.removeRequest();\n        container.removeResponse();\n        container.removeSession();\n        execution.removeContext();\n    }\n\n    public String getRealPath(String path)\n    {\n        Request request = this.container.getRequest();\n\n        if (request instanceof ServletRequest) {\n            return ((ServletRequest) request).getHttpServletRequest().getServletContext().getRealPath(path);\n        }\n\n        return null;\n    }\n\n    // hook\n    public boolean action(XWikiContext context) throws XWikiException\n    {\n        return true;\n    }\n\n    // hook\n    public String render(XWikiContext context) throws XWikiException\n    {\n        return null;\n    }\n\n    /**\n     * Redirect the user to an other location if the document holds an XWiki.RedirectClass instance (used when a\n     * document is moved).\n     *\n     * @param context the XWiki context\n     * @return either or not a redirection have been sent\n     * @throws XWikiException if error occurs\n     * @since 8.0RC1\n     * @since 7.4.2\n     */\n    protected boolean handleRedirectObject(XWikiContext context) throws XWikiException\n    {\n        WikiReference wikiReference = context.getWikiReference();\n\n        // Look if the document has a redirect object\n        XWikiDocument doc = context.getDoc();\n        BaseObject redirectObj = doc.getXObject(RedirectClassDocumentInitializer.REFERENCE);\n        if (redirectObj == null) {\n            return false;\n        }\n\n        // Get the location\n        String location = redirectObj.getStringValue(\"location\");\n        if (StringUtils.isBlank(location)) {\n            return false;\n        }\n\n        // Resolve the location to get a reference\n        DocumentReferenceResolver<String> resolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);\n        EntityReference locationReference = resolver.resolve(location, wikiReference);\n\n        // Get the type of the current target\n        ResourceReference resourceReference = Utils.getComponent(ResourceReferenceManager.class).getResourceReference();\n        EntityResourceReference entityResource = (EntityResourceReference) resourceReference;\n        EntityReference entityReference = entityResource.getEntityReference();\n\n        // If the entity is inside a document, compute the new entity with the new document part.\n        if (entityReference.getType().ordinal() > EntityType.DOCUMENT.ordinal()) {\n            EntityReference parentDocument = entityReference.extractReference(EntityType.DOCUMENT);\n            locationReference = entityReference.replaceParent(parentDocument, locationReference);\n        }\n\n        // Get the URL corresponding to the location\n        // Note: the anchor part is lost in the process, because it is not sent to the server\n        // (see: http://stackoverflow.com/a/4276491)\n        String url = context.getWiki().getURL(locationReference, context.getAction(),\n            context.getRequest().getQueryString(), null, context);\n\n        // Send the redirection\n        try {\n            context.getResponse().sendRedirect(url);\n        } catch (IOException e) {\n            throw new XWikiException(\"Failed to redirect.\", e);\n        }\n\n        return true;\n    }\n\n    protected void handleRevision(XWikiContext context) throws XWikiException\n    {\n        String rev = context.getRequest().getParameter(\"rev\");\n        if (rev != null) {\n            context.put(\"rev\", rev);\n            XWikiDocument doc = (XWikiDocument) context.get(\"doc\");\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            // if the doc is deleted and we request a specific language, we have to set the locale so we can retrieve\n            // properly the document revision.\n            if (rev.startsWith(\"deleted\") && !StringUtils.isEmpty(context.getRequest().getParameter(\"language\"))\n                && doc == tdoc) {\n                Locale locale = LocaleUtils.toLocale(context.getRequest().getParameter(\"language\"), Locale.ROOT);\n                tdoc = new XWikiDocument(tdoc.getDocumentReference(), locale);\n            }\n            XWikiDocument rdoc =\n                (!doc.getLocale().equals(tdoc.getLocale())) ? doc : context.getWiki().getDocument(doc, rev, context);\n\n            XWikiDocument rtdoc =\n                (doc.getLocale().equals(tdoc.getLocale())) ? rdoc : context.getWiki().getDocument(tdoc, rev, context);\n\n            context.put(\"tdoc\", rtdoc);\n            context.put(\"cdoc\", rdoc);\n            context.put(\"doc\", rdoc);\n        }\n    }\n\n    /**\n     * Send redirection based on a regexp pattern (if any) set at the main wiki level. To enable this feature you must\n     * add xwiki.preferences.redirect=1 to your xwiki.cfg.\n     *\n     * @param response the servlet response\n     * @param url url of the request\n     * @param context the XWiki context\n     * @return true if a redirection has been sent\n     */\n    protected boolean sendGlobalRedirect(XWikiResponse response, String url, XWikiContext context) throws Exception\n    {\n        if (\"1\".equals(context.getWiki().Param(\"xwiki.preferences.redirect\"))) {\n            // Note: This implementation is not performant at all and will slow down the wiki as the number\n            // of redirects increases. A better implementation would use a cache of redirects and would use\n            // the notification mechanism to update the cache when the XWiki.XWikiPreferences document is\n            // modified.\n            XWikiDocument globalPreferences = context.getWiki().getDocument(\"xwiki:XWiki.XWikiPreferences\", context);\n            Vector<BaseObject> redirects = globalPreferences.getObjects(\"XWiki.GlobalRedirect\");\n\n            if (redirects != null) {\n                for (BaseObject redir : redirects) {\n                    if (redir != null) {\n                        String p = redir.getStringValue(\"pattern\");\n                        if (p != null && url.matches(p)) {\n                            String dest = redir.getStringValue(\"destination\");\n                            response.sendRedirect(url.replaceAll(p, dest));\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void sendRedirect(XWikiResponse response, String url) throws XWikiException\n    {\n        try {\n            if (url != null) {\n                response.sendRedirect(response.encodeRedirectURL(url));\n            }\n        } catch (IOException e) {\n            Object[] args = {url};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_REDIRECT_EXCEPTION,\n                \"Exception while sending redirect to page {0}\", e, args);\n        }\n    }\n\n    /**\n     * Gets the translated version of a document, in the specified language. If the translation does not exist, a new\n     * document translation is created. If the requested language does not correspond to a translation (is not defined\n     * or is the same as the main document), then the main document is returned.\n     *\n     * @param doc the main (default, untranslated) document to translate\n     * @param language the requested document language\n     * @param context the current request context\n     * @return the translated document, or the original untranslated document if the requested language is not a\n     *         translation\n     * @throws XWikiException if the translation cannot be retrieved from the database\n     */\n    protected XWikiDocument getTranslatedDocument(XWikiDocument doc, String language, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument tdoc;\n        if (StringUtils.isBlank(language) || language.equals(\"default\") || language.equals(doc.getDefaultLanguage())) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if (tdoc == doc) {\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n            }\n            tdoc.setTranslation(1);\n        }\n        return tdoc;\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     */\n    protected boolean csrfTokenCheck(XWikiContext context) throws XWikiException\n    {\n        return csrfTokenCheck(context, false);\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @param jsonAnswer if true, returns a JSON answer in case of AJAX request: allow to process it properly on client.\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     * @since 11.3RC1\n     */\n    protected boolean csrfTokenCheck(XWikiContext context, boolean jsonAnswer) throws XWikiException\n    {\n        final boolean isAjaxRequest = Utils.isAjaxRequest(context);\n        CSRFToken csrf = Utils.getComponent(CSRFToken.class);\n        try {\n            String token = context.getRequest().getParameter(\"form_token\");\n            if (!csrf.isTokenValid(token)) {\n                if (isAjaxRequest) {\n                    if (jsonAnswer) {\n                        Map<String, String> jsonObject = new LinkedHashMap<>();\n                        jsonObject.put(\"errorType\", \"CSRF\");\n                        jsonObject.put(\"resubmissionURI\", csrf.getRequestURI());\n                        jsonObject.put(\"newToken\", csrf.getToken());\n                        this.answerJSON(context, HttpServletResponse.SC_FORBIDDEN, jsonObject);\n                    } else {\n                        final String csrfCheckFailedMessage = localizePlainOrKey(\"core.editors.csrfCheckFailed\");\n                        writeAjaxErrorResponse(HttpServletResponse.SC_FORBIDDEN, csrfCheckFailedMessage, context);\n                    }\n                } else {\n                    sendRedirect(context.getResponse(), csrf.getResubmissionURL());\n                }\n\n                return false;\n            }\n        } catch (XWikiException exception) {\n            // too bad\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied, secret token verification failed\", exception);\n        }\n        return true;\n    }\n\n    /**\n     * In order to let users enter URLs to Spaces we do the following when receiving {@code /A/B} (where A and B are\n     * spaces):\n     * <ul>\n     * <li>check that the action is \"view\" (we only support this for the view action since otherwise this would break\n     * apps written before this concept was introduced in XWiki 7.2M1)</li>\n     * <li>if A.B exists then continue</li>\n     * <li>if A.B doesn't exist then forward to A.B.WebHome</li>\n     * </ul>\n     * In order to disable this redirect you should provide the {@code spaceRedirect=false} Query String parameter and\n     * value.\n     *\n     * @since 7.2M1\n     */\n    private boolean redirectSpaceURLs(String action, XWikiURLFactory urlf, XWiki xwiki, XWikiContext context)\n        throws Exception\n    {\n        if (\"view\".equals(action) && !\"false\".equalsIgnoreCase(context.getRequest().getParameter(\"spaceRedirect\"))) {\n            DocumentReference reference = xwiki.getDocumentReference(context.getRequest(), context);\n            if (!xwiki.exists(reference, context)) {\n                String defaultDocumentName = Utils.getComponent(EntityReferenceProvider.class)\n                    .getDefaultReference(EntityType.DOCUMENT).getName();\n                // Avoid an infinite loop by ensuring we're not on a WebHome already\n                if (!reference.getName().equals(defaultDocumentName)) {\n                    // Consider the reference as a Space Reference and Construct a new reference to the home of that\n                    // Space. Then generate the URL for it and forward to it\n                    SpaceReference spaceReference = new SpaceReference(reference.getName(), reference.getParent());\n                    // Extract the anchor\n                    String anchor = new URL(context.getRequest().getRequestURL().toString()).getRef();\n                    URL forwardURL = urlf.createURL(getLocalSerializer().serialize(spaceReference), defaultDocumentName,\n                        action, context.getRequest().getQueryString(), anchor,\n                        spaceReference.getWikiReference().getName(), context);\n                    // Since createURL() contain the webapp context and since RequestDispatcher should not contain it,\n                    // we need to remove it!\n                    String webappContext = xwiki.getWebAppPath(context);\n                    String relativeURL = urlf.getURL(forwardURL, context);\n                    relativeURL = '/' + StringUtils.substringAfter(relativeURL, webappContext);\n                    context.getRequest().getRequestDispatcher(relativeURL).forward(context.getRequest(),\n                        context.getResponse());\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Answer to a request with a JSON content.\n     * \n     * @param context the current context of the request.\n     * @param status the status code to send back.\n     * @param answer the content of the JSON answer.\n     * @throws XWikiException in case of error during the serialization of the JSON.\n     */\n    protected void answerJSON(XWikiContext context, int status, Map<String, String> answer) throws XWikiException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n\n        try {\n            String jsonAnswerAsString = mapper.writeValueAsString(answer);\n            context.getResponse().setContentType(\"application/json\");\n            context.getResponse().setContentLength(jsonAnswerAsString.length());\n            context.getResponse().setStatus(status);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(jsonAnswerAsString);\n        } catch (IOException e) {\n            throw new XWikiException(\"Error while sending JSON answer.\", e);\n        }\n    }\n\n    /**\n     * Make sure to set the right length (or nothing) in the response.\n     * \n     * @param response the response\n     * @param length the length to set in the response\n     * @since 11.10\n     * @since 10.11.10\n     * @since 11.3.6\n     */\n    protected void setContentLength(XWikiResponse response, long length)\n    {\n        // Set the content length in the response\n        response.setContentLengthLong(length);\n    }\n\n    /**\n     * Helper used resolve the template passed to the action if the current user have access to it.\n     * \n     * @param template the template to copy\n     * @return the reference of the template if not empty and the current user have access to it\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected DocumentReference resolveTemplate(String template)\n    {\n        if (StringUtils.isNotBlank(template)) {\n            DocumentReference templateReference = this.currentmixedReferenceResolver.resolve(template);\n\n            // Make sure the current user have access to the template document before copying it\n            if (this.autorization.hasAccess(Right.VIEW, templateReference)) {\n                return templateReference;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper used by various actions to initialize a document by copying a template to it.\n     * \n     * @param document the document to update\n     * @param template the template to copy\n     * @param context the XWiki context\n     * @return true if the document was updated, false otherwise (for example when the current user does not have view\n     *         right on the template document)\n     * @throws XWikiException when failing to copy the template\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    @Unstable\n    protected boolean readFromTemplate(XWikiDocument document, String template, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference templateReference = resolveTemplate(template);\n\n        if (templateReference != null) {\n            document.readFromTemplate(templateReference, context);\n\n            return true;\n        }\n\n        return false;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\n\nimport javax.inject.Provider;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link com.xpn.xwiki.web.CreateAction}.\n *\n * @version $Id$\n * @since 7.2M1\n */\n@ComponentList\n@ReferenceComponentList\n@OldcoreTest\nclass CreateActionTest\n{\n    @InjectMockitoOldcore\n    MockitoOldcore oldcore;\n\n    XWikiURLFactory mockURLFactory;\n\n    @InjectMockComponents\n    CreateAction action;\n\n    XWikiContext context;\n\n    XWikiRequest mockRequest;\n\n    XWikiResponse mockResponse;\n\n    Query mockTemplateProvidersQuery;\n\n    @BeforeEach\n    public void beforeEach() throws Exception\n    {\n        this.context = this.oldcore.getXWikiContext();\n\n        Utils.setComponentManager(this.oldcore.getMocker());\n\n        QueryManager mockSecureQueryManager =\n            this.oldcore.getMocker().registerMockComponent((Type) QueryManager.class, \"secure\");\n\n        this.mockTemplateProvidersQuery = mock(Query.class);\n        when(mockSecureQueryManager.createQuery(any(), any())).thenReturn(this.mockTemplateProvidersQuery);\n        when(this.mockTemplateProvidersQuery.execute()).thenReturn(Collections.emptyList());\n\n        when(this.oldcore.getMockContextualAuthorizationManager().hasAccess(any(Right.class),\n            any(EntityReference.class))).thenReturn(true);\n\n        Provider<DocumentReference> mockDocumentReferenceProvider =\n            this.oldcore.getMocker().registerMockComponent(DocumentReference.TYPE_PROVIDER);\n        when(mockDocumentReferenceProvider.get())\n            .thenReturn(new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\"));\n\n        this.mockURLFactory = mock(XWikiURLFactory.class);\n        this.context.setURLFactory(this.mockURLFactory);\n\n        this.mockRequest = mock(XWikiRequest.class);\n        this.context.setRequest(this.mockRequest);\n\n        this.mockResponse = mock(XWikiResponse.class);\n        this.context.setResponse(this.mockResponse);\n\n        when(this.mockRequest.get(\"type\")).thenReturn(\"plain\");\n\n        this.oldcore.getMocker().registerMockComponent(ObservationManager.class);\n    }\n\n    @Test\n    void newDocumentFromURL() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    void newDocumentButNonTerminalFromURL() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Pass the tocreate=nonterminal request parameter\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,\n            \"xwiki\", context);\n    }\n\n    @Test\n    void newDocumentFromURLWhenNoType() throws Exception\n    {\n        // No type has been set by the user\n        when(mockRequest.get(\"type\")).thenReturn(null);\n\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertEquals(\"create\", result);\n    }\n\n    @Test\n    void newDocumentWebHomeTopLevelFromURL() throws Exception\n    {\n        // new document = xwiki:X.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: The title is not \"WebHome\", but \"X\" (the space's name) to avoid exposing \"WebHome\" in the UI.\n        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    void newDocumentWebHomeFromURL() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: The bebavior is the same for both a top level space and a child space WebHome.\n        // Note2: The title is not \"WebHome\", but \"Y\" (the space's name) to avoid exposing \"WebHome\" in the UI.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,\n            \"xwiki\", context);\n    }\n\n    @Test\n    void newDocumentWebHomeButTerminalFromURL() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Pass the tocreate=terminal request parameter\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y instead of X.Y.WebHome because the tocreate parameter says \"terminal\".\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    void newDocumentWebHomeTopLevelSpaceButTerminalFromURL() throws Exception\n    {\n        // new document = xwiki:X.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Pass the tocreate=terminal request parameter\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to enter the missing values.\n        assertEquals(\"create\", result);\n\n        // Note: We can not create the \"X\" terminal document, since it is already at the top level of the hierarchy and\n        // none was able to be deducted from the given information. The user needs to specify more info in order to\n        // continue.\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));\n    }\n\n    @Test\n    void existingDocumentFromUINoName() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Just landed on the create page or submitted with no values (no name) specified.\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to enter the missing values.\n        assertEquals(\"create\", result);\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));\n    }\n\n    @Test\n    void existingDocumentFromUI() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.WebHome since we default to non-terminal documents.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,\n            \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUICheckEscaping() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X.Y&name=Z\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X.Y\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Z\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.Z.WebHome since we default to non-terminal documents.\n        verify(mockURLFactory).createURL(\"X.Y.Z\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null,\n            \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentTerminalFromUI() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&tocreate=terminal\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y instead of X.Y.WebHome because the tocreate parameter says \"terminal\".\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    void existingDocumentTerminalFromUICheckEscaping() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X.Y&name=Z&tocreate=termina\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X.Y\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Z\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.Z instead of X.Y.Z.WebHome because the tocreate parameter says \"terminal\".\n        verify(mockURLFactory).createURL(\"X.Y\", \"Z\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    void existingDocumentTerminalFromUIButAlreadyExisting() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n        // Mock it as existing in the DB as well with non-empty content\n        oldcore.getDocuments().put(new DocumentReference(documentReference, Locale.ROOT), document);\n        when(document.getContent()).thenReturn(\"Some non-empty content\");\n\n        // Submit from the UI spaceReference=X&name=Y&tocreate=terminal\n        // No diference if it was a non-terminal document, just easier to mock since we already have Main.WebHome set\n        // up.\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"Main\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"WebHome\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));\n    }\n\n    @Test\n    void notExistingDocumentFromUIButNameTooLong() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(10);\n        context.setDoc(document);\n\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"Main\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Foo123456789\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));\n    }\n\n    @Test\n    void notExistingDocumentFromUIButSpaceTooLong() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(10);\n        context.setDoc(document);\n\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"1.3.5.7.9.11\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Foo\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));\n    }\n\n    @Test\n    void existingDocumentFromUITopLevelDocument() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI name=Y\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.WebHome since we default to non-terminal documents.\n        verify(mockURLFactory).createURL(\"Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    /*\n     * Deprecated parameters\n     */\n\n    @Test\n    void existingDocumentFromUIDeprecated() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X&page=Y\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"page\")).thenReturn(\"Y\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y since the deprecated parameters were creating terminal documents by default.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    void existingDocumentFromUIDeprecatedCheckEscaping() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X.Y&page=Z\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X.Y\");\n        when(mockRequest.getParameter(\"page\")).thenReturn(\"Z\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: The space parameter was previously considered as space name, not space reference, so it is escaped.\n        // Note2: We are creating X\\.Y.Z since the deprecated parameters were creating terminal documents by default.\n        verify(mockURLFactory).createURL(\"X\\\\.Y\", \"Z\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    void existingDocumentNonTerminalFromUIDeprecated() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X&tocreate=space\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.WebHome because the tocreate parameter says \"space\".\n        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    void existingDocumentNonTerminalFromUIDeprecatedIgnoringPage() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X&page=Y&tocreate=space\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"page\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.WebHome instead of X.Y because the tocreate parameter says \"space\" and the page\n        // parameter is ignored.\n        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",\n            context);\n    }\n\n    @Test\n    void existingDocumentNonTerminalFromUIDeprecatedCheckEscaping() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI space=X.Y&tocreate=space\n        when(mockRequest.getParameter(\"space\")).thenReturn(\"X.Y\");\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: The space parameter was previously considered as space name, not space reference, so it is escaped.\n        // Note2: We are creating X\\.Y.WebHome because the tocreate parameter says \"space\".\n        verify(mockURLFactory).createURL(\"X\\\\.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X.Y\", null,\n            \"xwiki\", context);\n    }\n\n    /*\n     * Template providers\n     */\n\n    @Test\n    void existingDocumentFromUITemplateProviderExistingButNoneSelected() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(\"XWiki.MyTemplateProvider\",\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList());\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to enter the missing values.\n        assertEquals(\"create\", result);\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));\n    }\n\n    /**\n     * Mocks 1 existing template provider.\n     * <p>\n     * Note: Calling it multiple times does not add multiple providers.\n     */\n    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,\n        List<String> allowedSpaces) throws Exception\n    {\n        mockExistingTemplateProviders(fullName, resolvedDocumentReference, allowedSpaces, false);\n    }\n\n    /**\n     * Mocks 1 existing template provider.\n     * <p>\n     * Note: Calling it multiple times does not add multiple providers.\n     */\n    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,\n        List<String> allowedSpaces, Boolean terminal) throws Exception\n    {\n        mockExistingTemplateProviders(fullName, resolvedDocumentReference, allowedSpaces, terminal, null);\n    }\n\n    /**\n     * Mocks 1 existing template provider.\n     * <p>\n     * Note: Calling it multiple times does not add multiple providers.\n     */\n    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,\n        List<String> allowedSpaces, Boolean terminal, String type) throws Exception\n    {\n        mockExistingTemplateProviders(fullName, resolvedDocumentReference, allowedSpaces, terminal, type, null);\n    }\n\n    /**\n     * Mocks 1 existing template provider.\n     * <p>\n     * Note: Calling it multiple times does not add multiple providers.\n     */\n    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,\n        List<String> allowedSpaces, Boolean terminal, String type, String action) throws Exception\n    {\n        DocumentReference templateProviderClassReference =\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"TemplateProviderClass\");\n\n        // Mock to return at least 1 existing template provider\n        when(mockTemplateProvidersQuery.execute()).thenReturn(new ArrayList<Object>(Arrays.asList(fullName)));\n\n        // Mock the template document as existing.\n        XWikiDocument templateProviderDocument = mock(XWikiDocument.class);\n        when(templateProviderDocument.getDocumentReference()).thenReturn(resolvedDocumentReference);\n        oldcore.getDocuments().put(new DocumentReference(resolvedDocumentReference, Locale.ROOT),\n            templateProviderDocument);\n        // Mock the provider object (template + spaces properties)\n        BaseObject templateProviderObject = mock(BaseObject.class);\n        when(templateProviderObject.getListValue(\"creationRestrictions\")).thenReturn(allowedSpaces);\n        String templateDocumentFullName = fullName.substring(0, fullName.indexOf(\"Provider\"));\n        when(templateProviderObject.getStringValue(\"template\")).thenReturn(templateDocumentFullName);\n        if (terminal != null) {\n            when(templateProviderObject.getIntValue(\"terminal\", -1)).thenReturn(terminal ? 1 : 0);\n        } else {\n            when(templateProviderObject.getIntValue(\"terminal\", -1)).thenReturn(-1);\n        }\n        if (type != null) {\n            when(templateProviderObject.getStringValue(\"type\")).thenReturn(type);\n        }\n        if (action != null) {\n            when(templateProviderObject.getStringValue(\"action\")).thenReturn(action);\n        }\n        when(templateProviderDocument.getXObject(templateProviderClassReference)).thenReturn(templateProviderObject);\n\n        // Mock the template document as existing\n        String templateDocumentName =\n            resolvedDocumentReference.getName().substring(0, resolvedDocumentReference.getName().indexOf(\"Provider\"));\n        DocumentReference templateDocumentReference =\n            new DocumentReference(templateDocumentName, new SpaceReference(resolvedDocumentReference.getParent()));\n        mockTemplateDocumentExisting(templateDocumentFullName, templateDocumentReference);\n    }\n\n    /**\n     * @param templateDocumentFullName\n     * @param templateDocumentReference\n     * @throws XWikiException\n     */\n    private void mockTemplateDocumentExisting(String templateDocumentFullName,\n        DocumentReference templateDocumentReference) throws XWikiException\n    {\n        XWikiDocument templateDocument = mock(XWikiDocument.class);\n        when(templateDocument.getDocumentReference()).thenReturn(templateDocumentReference);\n        when(templateDocument.getDefaultEditMode(context)).thenReturn(\"edit\");\n        oldcore.getDocuments().put(new DocumentReference(templateDocumentReference, Locale.ROOT), templateDocument);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecified() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList());\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y and using the template extracted from the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecifiedRestrictionExists() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider that allows usage in target space.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Arrays.asList(\"X\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: We are allowed to create anything under space X, be it a terminal or a non-terminal document.\n        // Note2: We are creating X.Y and using the template extracted from the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecifiedRestrictionExistsOnParentSpace() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X.Y.Z&name=W&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X.Y.Z\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"W\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider that allows usage in one of the target space's parents (top level in this\n        // case).\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Arrays.asList(\"X\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note1: We are allowed to create anything under space X or its children, be it a terminal or a non-terminal\n        // document\n        // Note2: We are creating X.Y.Z.W and using the template extracted from the template provider.\n        verify(mockURLFactory).createURL(\"X.Y.Z.W\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=W\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecifiedButNotAllowed() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"),\n            Arrays.asList(\"AnythingButX\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_TEMPLATE_NOT_AVAILABLE, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));\n    }\n\n    @Test\n    void newDocumentFromURLTemplateProviderSpecifiedButNotAllowed() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference =\n            new DocumentReference(\"Y\", new SpaceReference(\"X\", new WikiReference(\"xwiki\")));\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"),\n            Arrays.asList(\"AnythingButX\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_TEMPLATE_NOT_AVAILABLE, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));\n    }\n\n    @Test\n    void newDocumentWebHomeFromURLTemplateProviderSpecifiedButNotAllowed() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"),\n            Arrays.asList(\"AnythingButX\"));\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify that the create template is rendered, so the UI is displayed for the user to see the error.\n        assertEquals(\"create\", result);\n\n        // Check that the exception is properly set in the context for the UI to display.\n        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");\n        assertNotNull(exception);\n        assertEquals(XWikiException.ERROR_XWIKI_APP_TEMPLATE_NOT_AVAILABLE, exception.getCode());\n\n        // We should not get this far so no redirect should be done, just the template will be rendered.\n        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));\n    }\n\n    @Test\n    void newDocumentWebHomeFromURLTemplateProviderSpecifiedTerminal() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(),\n            true);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal and using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    void newDocumentWebHomeFromURLTemplateProviderSpecifiedTerminalOverriddenFromUIToNonTerminal() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(),\n            true);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y.WebHome as non-terminal even if the template provider says otherwise.\n        // Also using a template, as specified in the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void newDocumentFromURLTemplateProviderSpecifiedNonTerminal() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", \"X\", \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(),\n            false);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal and using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void newDocumentFromURLTemplateProviderSpecifiedNonTerminalButOverriddenFromUITerminal() throws Exception\n    {\n        // new document = xwiki:X.Y\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", \"X\", \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(),\n            false);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal and using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateSpecified() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&template=XWiki.MyTemplate\n        String templateDocumentFullName = \"XWiki.MyTemplate\";\n        DocumentReference templateDocumentReference =\n            new DocumentReference(\"MyTemplate\", Arrays.asList(\"XWiki\"), \"xwiki\");\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"template\")).thenReturn(\"XWiki.MyTemplate\");\n\n        // Mock the passed template document as existing.\n        mockTemplateDocumentExisting(templateDocumentFullName, templateDocumentReference);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.WebHome and using the template specified in the request.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecifiedTerminal() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider that creates terminal documents.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(),\n            true);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal and using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecifiedTerminalOverridenFromUIToNonTerminal() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");\n\n        // Mock 1 existing template provider that creates terminal documents.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(),\n            true);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y.WebHome as non-terminal, even if the template provider says otherwise.\n        // Also using a template, as specified in the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecifiedNonTerminal() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider that creates terminal documents.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(),\n            false);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y.WebHome as non-terminal and using a template, as specified in the\n        // template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecifiedNonTerminalOverridenFromUIToTerminal() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        String spaceReferenceString = \"X\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(spaceReferenceString);\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Mock 1 existing template provider that creates terminal documents.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(),\n            false);\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal, even if the template provider says otherwise.\n        // Also using a template, as specified in the template provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    void newDocumentWebHomeFromURLTemplateProviderSpecifiedButOldPageType() throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(), null,\n            \"page\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y as terminal, since the template provider did not specify a \"terminal\"\n        // property and it used the old \"page\" type instead. Also using a template, as specified in the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    void newDocumentWebHomeFromURLTemplateProviderSpecifiedButOldPageTypeButOverriddenFromUIToNonTerminal()\n        throws Exception\n    {\n        // new document = xwiki:X.Y.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Specifying a template provider in the URL: templateprovider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(), null,\n            \"page\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating the document X.Y.WebHome as non-terminal, since even if the template provider did not\n        // specify a \"terminal\" property and it used the old \"page\" type, the UI explicitly asked for a non-terminal\n        // document. Also using a template, as specified in the template provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecifiedButOldSpaceType() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(), null,\n            \"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y.WebHome as non-terminal, since the template provider does not specify a \"terminal\"\n        // property and we fallback on the \"type\" property's value. Also using the template extracted from the template\n        // provider.\n        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\",\n            \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\", null, \"xwiki\", context);\n    }\n\n    @Test\n    void existingDocumentFromUITemplateProviderSpecifiedButOldSpaceTypeButOverridenFromUIToTerminal() throws Exception\n    {\n        // current document = xwiki:Main.WebHome\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(false);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        context.setDoc(document);\n\n        // Submit from the UI spaceReference=X&name=Y&templateProvider=XWiki.MyTemplateProvider\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");\n\n        // Mock 1 existing template provider\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(), null,\n            \"space\");\n\n        // Run the action\n        String result = action.render(context);\n\n        // The tests are below this line!\n\n        // Verify null is returned (this means the response has been returned)\n        assertNull(result);\n\n        // Note: We are creating X.Y as terminal, since it is overriden from the UI, regardless of any backwards\n        // compatibility resolutions. Also using the template extracted from the template provider.\n        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=XWiki.MyTemplate&parent=Main.WebHome&title=Y\",\n            null, \"xwiki\", context);\n    }\n\n    @Test\n    void newDocumentWebHomeFromURLTemplateProviderSpecifiedWithSaveAndEdit() throws Exception\n    {\n        // Mock the document to create.\n        DocumentReference documentReference = new DocumentReference(\"xwiki\", \"X\", \"Y\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getDocumentReferenceWithLocale()).thenReturn(documentReference);\n        when(document.isNew()).thenReturn(true);\n        when(document.getLocalReferenceMaxLength()).thenReturn(255);\n        when(document.getDefaultEditMode(this.context)).thenReturn(\"edit\");\n        when(document.getDefaultLocale()).thenReturn(Locale.ROOT);\n        when(document.clone()).thenReturn(document);\n\n        // Mock the XWiki context.\n        when(this.context.getWiki().getLocalePreference(this.context)).thenReturn(Locale.FRENCH);\n        when(this.context.getWiki().getDocument(documentReference, this.context)).thenReturn(document);\n        this.context.setDoc(document);\n        DocumentReference userReference = new DocumentReference(\"xwiki\", \"Users\", \"Alice\");\n        this.context.setUserReference(userReference);\n\n        // Mock the creation request.\n        when(this.mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");\n        when(this.mockRequest.getParameter(\"name\")).thenReturn(\"Y\");\n        when(this.mockRequest.getParameter(\"title\")).thenReturn(\"Yippee\");\n        String templateProviderFullName = \"XWiki.MyTemplateProvider\";\n        when(this.mockRequest.getParameter(\"templateprovider\")).thenReturn(templateProviderFullName);\n\n        // Mock the template provider.\n        mockExistingTemplateProviders(templateProviderFullName,\n            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList(), null,\n            \"page\", \"saveandedit\");\n\n        // Run the create action.\n        assertNull(this.action.render(this.context));\n\n        verify(document).setLocale(Locale.ROOT);\n        verify(document).setDefaultLocale(Locale.FRENCH);\n        verify(document).readFromTemplate(new DocumentReference(\"xwiki\", \"XWiki\", \"MyTemplate\"), this.context);\n        verify(document).setTitle(\"Yippee\");\n        verify(document).setCreatorReference(userReference);\n        verify(document).setAuthorReference(userReference);\n        verify(this.context.getWiki()).saveDocument(document, this.context);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.util.Collections;\nimport java.util.Date;\n\nimport javax.inject.Named;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.context.Execution;\nimport org.xwiki.job.Job;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.validation.EntityNameValidation;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.refactoring.job.CreateRequest;\nimport org.xwiki.refactoring.script.RefactoringScriptService;\nimport org.xwiki.refactoring.script.RequestFactory;\nimport org.xwiki.script.service.ScriptService;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiLock;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link SaveAction}.\n *\n * @version $Id$\n */\n@ComponentList\n@ReferenceComponentList\n@OldcoreTest(mockXWiki = false)\nclass SaveActionTest\n{\n    private static final DocumentReference USER_REFERENCE = new DocumentReference(\"xwiki\", \"XWiki\", \"FooBar\");\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    @InjectComponentManager\n    private MockitoComponentManager componentManager;\n\n    @MockComponent\n    private EntityNameValidationManager entityNameValidationManager;\n\n    @MockComponent\n    private EntityNameValidationConfiguration entityNameValidationConfiguration;\n\n    @MockComponent\n    private Execution execution;\n\n    @MockComponent\n    @Named(\"xwikiproperties\")\n    private ConfigurationSource propertiesConf;\n\n    @MockComponent\n    private ContextualAuthorizationManager autorization;\n\n    @MockComponent\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private XWikiContext context;\n\n    @InjectMockComponents\n    private SaveAction saveAction;\n\n    private XWikiRequest mockRequest;\n\n    private XWikiResponse mockResponse;\n\n    private XWikiDocument mockDocument;\n\n    private XWikiDocument mockClonedDocument;\n\n    private EditForm mockForm;\n\n    private XWiki xWiki;\n\n    @BeforeEach\n    void setup()\n    {\n        this.context = this.oldcore.getXWikiContext();\n\n        this.xWiki = mock(XWiki.class);\n        this.context.setWiki(this.xWiki);\n\n        this.mockRequest = mock(XWikiRequest.class);\n        this.context.setRequest(this.mockRequest);\n\n        this.mockResponse = mock(XWikiResponse.class);\n        this.context.setResponse(this.mockResponse);\n\n        this.mockDocument = mock(XWikiDocument.class);\n        this.context.setDoc(this.mockDocument);\n\n        this.mockClonedDocument = mock(XWikiDocument.class);\n        when(this.mockDocument.clone()).thenReturn(this.mockClonedDocument);\n\n        this.mockForm = mock(EditForm.class);\n        this.context.setForm(this.mockForm);\n        when(this.entityNameValidationConfiguration.useValidation()).thenReturn(false);\n\n        this.context.setUserReference(USER_REFERENCE);\n    }\n\n    @Test\n    void newDocumentInvalidName() throws Exception\n    {\n        when(mockDocument.isNew()).thenReturn(true);\n        DocumentReference documentReference = new DocumentReference(\"XWiki\", \"Foo\", \"Bar\");\n        when(mockDocument.getDocumentReference()).thenReturn(documentReference);\n        when(this.entityNameValidationConfiguration.useValidation()).thenReturn(true);\n        EntityNameValidation entityNameValidation = mock(EntityNameValidation.class);\n        when(this.entityNameValidationManager.getEntityReferenceNameStrategy()).thenReturn(entityNameValidation);\n        when(entityNameValidation.isValid(documentReference)).thenReturn(false);\n\n        assertTrue(saveAction.save(this.context));\n        assertEquals(\"entitynamevalidation.create.invalidname\", context.get(\"message\"));\n        assertArrayEquals(new Object[] {\"Foo.Bar\"}, (Object[]) context.get(\"messageParameters\"));\n    }\n\n    @Test\n    void validSave() throws Exception\n    {\n        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));\n        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");\n        when(mockClonedDocument.getLock(this.context)).thenReturn(mock(XWikiLock.class));\n        when(mockForm.getTemplate()).thenReturn(\"\");\n        assertFalse(saveAction.save(this.context));\n        assertEquals(new Version(\"1.2\"), this.context.get(\"SaveAction.savedObjectVersion\"));\n\n        verify(mockClonedDocument).setAuthor(\"XWiki.FooBar\");\n        verify(mockClonedDocument).setMetaDataDirty(true);\n        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);\n        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);\n        verify(mockClonedDocument).removeLock(this.context);\n    }\n\n    @Test\n    void validSaveNewTranslation() throws Exception\n    {\n        when(mockForm.getLanguage()).thenReturn(\"fr\");\n        when(mockClonedDocument.getTranslatedDocument(\"fr\", this.context)).thenReturn(mockClonedDocument);\n        when(mockClonedDocument.getDocumentReference()).thenReturn(new DocumentReference(\"xwiki\", \"My\", \"Page\"));\n        when(mockClonedDocument.getStore()).thenReturn(this.oldcore.getMockStore());\n        when(xWiki.getStore()).thenReturn(this.oldcore.getMockStore());\n        context.put(\"ajax\", true);\n        when(xWiki.isMultiLingual(this.context)).thenReturn(true);\n        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.1\");\n        when(mockRequest.getParameter(\"isNew\")).thenReturn(\"true\");\n        assertFalse(saveAction.save(this.context));\n        assertEquals(new Version(\"1.1\"), this.context.get(\"SaveAction.savedObjectVersion\"));\n        verify(this.xWiki).checkSavingDocument(eq(USER_REFERENCE), any(XWikiDocument.class), eq(\"\"), eq(false),\n            eq(this.context));\n        verify(this.xWiki).saveDocument(any(XWikiDocument.class), eq(\"\"), eq(false), eq(this.context));\n    }\n\n    @Test\n    void validSaveOldTranslation() throws Exception\n    {\n        when(mockForm.getLanguage()).thenReturn(\"fr\");\n        XWikiDocument translation = mock(XWikiDocument.class);\n        when(mockForm.getTemplate()).thenReturn(\"\");\n        when(mockClonedDocument.getTranslatedDocument(\"fr\", this.context)).thenReturn(translation);\n        when(translation.clone()).thenReturn(mockClonedDocument);\n        when(xWiki.getStore()).thenReturn(this.oldcore.getMockStore());\n        context.put(\"ajax\", true);\n        when(xWiki.isMultiLingual(this.context)).thenReturn(true);\n        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.3\");\n        when(mockRequest.getParameter(\"editingVersionDate\")).thenReturn(\"1000\");\n        when(translation.getRCSVersion()).thenReturn(new Version(\"1.3\"));\n        when(translation.getDate()).thenReturn(new Date(0));\n        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.4\"));\n        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");\n        assertFalse(saveAction.save(this.context));\n        assertEquals(new Version(\"1.4\"), this.context.get(\"SaveAction.savedObjectVersion\"));\n        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);\n        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);\n    }\n\n    /**\n     * This tests aims at checking the usecase when uploading an image in the WYSIWYG editor before the first save and\n     * saving afterwards.\n     */\n    @Test\n    void validSaveRequestImageUploadAndConflictCheck() throws Exception\n    {\n        when(mockDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));\n        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));\n        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");\n        when(mockClonedDocument.getLock(this.context)).thenReturn(mock(XWikiLock.class));\n        when(mockForm.getTemplate()).thenReturn(\"\");\n        when(this.propertiesConf.getProperty(\"edit.conflictChecking.enabled\")).thenReturn(true);\n        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.1\");\n        context.put(\"ajax\", true);\n        when(mockRequest.getParameter(\"forceSave\")).thenReturn(\"\");\n        when(mockRequest.getParameter(\"isNew\")).thenReturn(\"true\");\n\n        when(mockDocument.getDate()).thenReturn(new Date(42));\n        when(mockRequest.getParameter(\"editingVersionDate\")).thenReturn(\"43\");\n        when(this.documentRevisionProvider.getRevision(mockDocument, \"1.1\")).thenReturn(mock(XWikiDocument.class));\n        when(mockDocument.getContentDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());\n        when(mockDocument.getMetaDataDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());\n        when(mockDocument.getObjectDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());\n\n        assertFalse(saveAction.save(this.context));\n        assertEquals(new Version(\"1.2\"), this.context.get(\"SaveAction.savedObjectVersion\"));\n\n        verify(mockClonedDocument).setAuthor(\"XWiki.FooBar\");\n        verify(mockClonedDocument).setMetaDataDirty(true);\n        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);\n        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);\n        verify(mockClonedDocument).removeLock(this.context);\n    }\n\n    @Test\n    void saveFromTemplate() throws Exception\n    {\n        when(this.mockForm.getTemplate()).thenReturn(\"TemplateSpace.TemplateDocument\");\n        DocumentReference templateReference =\n            new DocumentReference(context.getWikiId(), \"TemplateSpace\", \"TemplateDocument\");\n\n        when(this.autorization.hasAccess(Right.VIEW, templateReference)).thenReturn(false);\n\n        assertFalse(this.saveAction.save(this.context));\n\n        verify(this.mockClonedDocument, never()).readFromTemplate(templateReference, this.context);\n\n        when(this.autorization.hasAccess(Right.VIEW, templateReference)).thenReturn(true);\n        RefactoringScriptService refactoring = mock(RefactoringScriptService.class);\n        RequestFactory requestFactory = mock(RequestFactory.class);\n        when(refactoring.getRequestFactory()).thenReturn(requestFactory);\n        CreateRequest request = mock(CreateRequest.class);\n        when(requestFactory.createCreateRequest(any())).thenReturn(request);\n        Job job = mock(Job.class);\n        when(refactoring.create(request)).thenReturn(job);\n        this.componentManager.registerComponent(ScriptService.class, \"refactoring\", refactoring);\n\n        assertFalse(this.saveAction.save(this.context));\n\n        verify(this.mockClonedDocument).readFromTemplate(templateReference, this.context);\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/AdminAction.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/CreateAction.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/EditAction.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/InlineAction.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/SaveAction.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/XWikiAction.java", "xwiki-platform-core/xwiki-platform-oldcore/src/test/java/com/xpn/xwiki/web/CreateActionTest.java", "xwiki-platform-core/xwiki-platform-oldcore/src/test/java/com/xpn/xwiki/web/SaveActionTest.java"], "buggy_code_start_loc": [132, 302, 105, 85, 196, 31, 31, 27], "buggy_code_end_loc": [133, 318, 106, 97, 591, 1138, 1567, 247], "fixing_code_start_loc": [132, 301, 105, 85, 196, 32, 31, 26], "fixing_code_end_loc": [133, 316, 106, 97, 589, 1198, 1562, 287], "type": "CWE-862", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In affected versions any user with edit right can copy the content of a page it does not have access to by using it as template of a new page. This issue has been patched in XWiki 13.2CR1 and 12.10.6. Users are advised to update. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-23617", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-09T21:15:07.937", "lastModified": "2022-02-15T19:56:17.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In affected versions any user with edit right can copy the content of a page it does not have access to by using it as template of a new page. This issue has been patched in XWiki 13.2CR1 and 12.10.6. Users are advised to update. There are no known workarounds for this issue."}, {"lang": "es", "value": "XWiki Platform es una plataforma wiki gen\u00e9rica que ofrece servicios de ejecuci\u00f3n para las aplicaciones construidas sobre ella. En las versiones afectadas cualquier usuario con derecho de edici\u00f3n puede copiar el contenido de una p\u00e1gina a la que no presenta acceso us\u00e1ndola como plantilla de una nueva p\u00e1gina. Este problema ha sido parcheado en XWiki versiones 13.2CR1 y 12.10.6. Es recomendado a usuarios actualizar. No se presentan medidas de mitigaci\u00f3n conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionEndIncluding": "12.10.5", "matchCriteriaId": "0A23AC9C-3160-4393-B09E-9218CD9FE4D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:13.0:*:*:*:*:*:*:*", "matchCriteriaId": "E8ED2C6F-77E6-4B53-A52D-0CD7FA08AFD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:13.1:-:*:*:*:*:*:*", "matchCriteriaId": "333C6A66-CDCD-46DC-A095-74D35B076A78"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/30c52b01559b8ef5ed1035dac7c34aaf805764d5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/commit/b35ef0edd4f2ff2c974cbeef6b80fcf9b5a44554", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-gf7x-2j2x-7f73", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-18430", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/30c52b01559b8ef5ed1035dac7c34aaf805764d5"}}