{"buggy_code": ["import type NodePath from \"./index.ts\";\nimport type * as t from \"@babel/types\";\n\n// This file contains Babels metainterpreter that can evaluate static code.\n\nconst VALID_OBJECT_CALLEES = [\"Number\", \"String\", \"Math\"] as const;\nconst VALID_IDENTIFIER_CALLEES = [\n  \"isFinite\",\n  \"isNaN\",\n  \"parseFloat\",\n  \"parseInt\",\n  \"decodeURI\",\n  \"decodeURIComponent\",\n  \"encodeURI\",\n  \"encodeURIComponent\",\n  process.env.BABEL_8_BREAKING ? \"btoa\" : null,\n  process.env.BABEL_8_BREAKING ? \"atob\" : null,\n] as const;\n\nconst INVALID_METHODS = [\"random\"] as const;\n\nfunction isValidObjectCallee(\n  val: string,\n): val is (typeof VALID_OBJECT_CALLEES)[number] {\n  return VALID_OBJECT_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isValidIdentifierCallee(\n  val: string,\n): val is (typeof VALID_IDENTIFIER_CALLEES)[number] {\n  return VALID_IDENTIFIER_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isInvalidMethod(val: string): val is (typeof INVALID_METHODS)[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nexport function evaluateTruthy(this: NodePath): boolean {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\ntype State = {\n  confident: boolean;\n  deoptPath: NodePath | null;\n  seen: Map<t.Node, Result>;\n};\n\ntype Result = {\n  resolved: boolean;\n  value?: any;\n};\n/**\n * Deopts the evaluation\n */\nfunction deopt(path: NodePath, state: State) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nconst Globals = new Map([\n  [\"undefined\", undefined],\n  [\"Infinity\", Infinity],\n  [\"NaN\", NaN],\n]);\n\n/**\n * We wrap the _evaluate method so we can track `seen` nodes, we push an item\n * to the map before we actually evaluate it so we can deopt on self recursive\n * nodes such as:\n *\n *   var g = a ? 1 : 2,\n *       a = g * this.foo\n */\nfunction evaluateCached(path: NodePath, state: State): any {\n  const { node } = path;\n  const { seen } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item: Result = { resolved: false };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (\n    path.isStringLiteral() ||\n    path.isNumericLiteral() ||\n    path.isBooleanLiteral()\n  ) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (\n    path.isTaggedTemplateExpression() &&\n    path.get(\"tag\").isMemberExpression()\n  ) {\n    const object = path.get(\"tag.object\") as NodePath;\n    const {\n      // @ts-expect-error todo(flow->ts): possible bug, object is can be any expression and so name might be undefined\n      node: { name },\n    } = object;\n    const property = path.get(\"tag.property\") as NodePath;\n\n    if (\n      object.isIdentifier() &&\n      name === \"String\" &&\n      // todo(flow->ts): was changed from getBinding(name, true)\n      //  should this be hasBinding(name, true) as the binding is never used later?\n      !path.scope.getBinding(name) &&\n      property.isIdentifier() &&\n      property.node.name === \"raw\"\n    ) {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    // TypeCastExpression, ExpressionStatement etc\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  // \"foo\".length, \"foo\"[0]\n  if (\n    path.isMemberExpression() &&\n    !path.parentPath.isCallExpression({ callee: path.node })\n  ) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral()) {\n      // @ts-expect-error todo(flow->ts): instead of typeof - would it be better to check type of ast node?\n      const value = object.node.value;\n      const type = typeof value;\n\n      let key = null;\n      if (path.node.computed) {\n        key = evaluateCached(property, state);\n        if (!state.confident) return;\n      } else if (property.isIdentifier()) {\n        key = property.node.name;\n      }\n      if (\n        (type === \"number\" || type === \"string\") &&\n        key != null &&\n        (typeof key === \"number\" || typeof key === \"string\")\n      ) {\n        return value[key];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding) {\n      if (\n        binding.constantViolations.length > 0 ||\n        path.node.start < binding.path.node.end\n      ) {\n        deopt(binding.path, state);\n        return;\n      }\n      if (binding.hasValue) {\n        return binding.value;\n      }\n    }\n\n    const name = path.node.name;\n    if (Globals.has(name)) {\n      if (!binding) {\n        return Globals.get(name);\n      }\n      deopt(binding.path, state);\n      return;\n    }\n\n    const resolved = path.resolve();\n    if (resolved === path) {\n      deopt(path, state);\n      return;\n    } else {\n      return evaluateCached(resolved, state);\n    }\n  }\n\n  if (path.isUnaryExpression({ prefix: true })) {\n    if (path.node.operator === \"void\") {\n      // we don't need to evaluate the argument to know what this will return\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n    if (\n      path.node.operator === \"typeof\" &&\n      (argument.isFunction() || argument.isClass())\n    ) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems: Array<NodePath> = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        deopt(elemValue.deopt, state);\n        return;\n      }\n    }\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        deopt(prop, state);\n        return;\n      }\n      const keyPath = (prop as NodePath<t.ObjectProperty>).get(\"key\");\n      let key;\n      // @ts-expect-error todo(flow->ts): type refinement issues ObjectMethod and SpreadElement somehow not excluded\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          deopt(key.deopt, state);\n          return;\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = (prop as NodePath<t.ObjectProperty>).get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        deopt(value.deopt, state);\n        return;\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    // If we are confident that the left side of an && is false, or the left\n    // side of an || is true, we can be confident about the entire expression\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        // TODO consider having a \"truthy type\" that doesn't bail on\n        // left uncertainty but can still evaluate to truthy.\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n\n        return left ?? right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right; // eslint-disable-line eqeqeq\n      case \"!=\":\n        return left != right;\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      (isValidObjectCallee(callee.node.name) ||\n        isValidIdentifierCallee(callee.node.name))\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidObjectCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        // @ts-expect-error property may not exist in context object\n        func = context[property.node.name];\n      }\n\n      // \"abc\".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(\n  path: NodePath<t.TaggedTemplateExpression | t.TemplateLiteral>,\n  quasis: Array<any>,\n  state: State,\n  raw = false,\n) {\n  let str = \"\";\n\n  let i = 0;\n  const exprs: Array<NodePath<t.Node>> = path.isTemplateLiteral()\n    ? path.get(\"expressions\")\n    : path.get(\"quasi.expressions\");\n\n  for (const elem of quasis) {\n    // not confident, evaluated an expression we don't like\n    if (!state.confident) break;\n\n    // add on element\n    str += raw ? elem.value.raw : elem.value.cooked;\n\n    // add on interpolated expression if it's present\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn't confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n", "import { parse } from \"@babel/parser\";\n\nimport _traverse from \"../lib/index.js\";\nconst traverse = _traverse.default || _traverse;\n\nfunction getPath(code) {\n  const ast = parse(code);\n  let path;\n  traverse(ast, {\n    Program: function (_path) {\n      path = _path;\n      _path.stop();\n    },\n  });\n  return path;\n}\n\nfunction addDeoptTest(code, type, expectedType) {\n  it(type + \" deopt: \" + code, function () {\n    const visitor = {};\n\n    visitor[type] = function (path) {\n      const evaluate = path.evaluate();\n      expect(evaluate.confident).toBeFalsy();\n      expect(evaluate.deopt.type).toEqual(expectedType);\n    };\n\n    traverse(\n      parse(code, {\n        plugins: [\"*\"],\n      }),\n      visitor,\n    );\n  });\n}\n\ndescribe(\"evaluation\", function () {\n  describe(\"evaluateTruthy\", function () {\n    it(\"should work with null\", function () {\n      expect(\n        getPath(\"false || a.length === 0;\").get(\"body\")[0].evaluateTruthy(),\n      ).toBeUndefined();\n    });\n\n    it(\"should not mistake lack of confidence for falsy\", function () {\n      expect(\n        getPath(\"foo || 'bar'\").get(\"body\")[0].evaluate().value,\n      ).toBeUndefined();\n    });\n  });\n\n  it(\"should bail out on recursive evaluation\", function () {\n    expect(\n      getPath(\"function fn(a) { var g = a ? 1 : 2, a = g * this.foo; }\")\n        .get(\"body.0.body.body.0.declarations.1.init\")\n        .evaluate().confident,\n    ).toBe(false);\n  });\n\n  it(\"should short-circuit && and ||\", function () {\n    expect(getPath(\"x === 'y' || 42\").get(\"body\")[0].evaluate().confident).toBe(\n      false,\n    );\n    expect(getPath(\"x === 'y' && 0\").get(\"body\")[0].evaluate().confident).toBe(\n      false,\n    );\n    expect(getPath(\"42 || x === 'y'\").get(\"body\")[0].evaluate().value).toBe(42);\n    expect(getPath(\"0 && x === 'y'\").get(\"body\")[0].evaluate().value).toBe(0);\n  });\n\n  it(\"should handle ??\", function () {\n    expect(getPath(\"null ?? 42\").get(\"body\")[0].evaluate().value).toBe(42);\n    expect(getPath(\"void 0 ?? 42\").get(\"body\")[0].evaluate().value).toBe(42);\n    expect(getPath(\"0 ?? 42\").get(\"body\")[0].evaluate().value).toBe(0);\n    expect(getPath(\"x ?? 42\").get(\"body\")[0].evaluate().confident).toBe(false);\n    expect(getPath(\"42 ?? x === 'y'\").get(\"body\")[0].evaluate().value).toBe(42);\n  });\n\n  it(\"should work with repeated, indeterminate identifiers\", function () {\n    expect(\n      getPath(\"var num = foo(); (num > 0 && num < 100);\")\n        .get(\"body\")[1]\n        .evaluateTruthy(),\n    ).toBeUndefined();\n  });\n\n  it(\"should work with repeated, determinate identifiers\", function () {\n    expect(\n      getPath(\"var num = 5; (num > 0 && num < 100);\")\n        .get(\"body\")[1]\n        .evaluateTruthy(),\n    ).toBe(true);\n  });\n\n  it(\"should deopt when var is redeclared in the same scope\", function () {\n    expect(\n      getPath(\"var x = 2; var y = x + 2; { var x = 3 }\")\n        .get(\"body.1.declarations.0.init\")\n        .evaluate().confident,\n    ).toBe(false);\n  });\n\n  describe(\"template literals\", function () {\n    it(\"should evaluate template literals\", function () {\n      expect(\n        getPath(\"var x = 8; var y = 1; var z = `value is ${x >>> y}`\")\n          .get(\"body.2.declarations.0.init\")\n          .evaluate().value,\n      ).toBe(\"value is 4\");\n    });\n\n    it(\"should evaluate String.raw tags\", function () {\n      expect(\n        getPath(\"String.raw`a\\\\n${1}\\\\u`;\").get(\"body.0.expression\").evaluate()\n          .value,\n      ).toBe(\"a\\\\n1\\\\u\");\n    });\n\n    addDeoptTest(\n      \"a`x${b}y`\",\n      \"TaggedTemplateExpression\",\n      \"TaggedTemplateExpression\",\n    );\n  });\n\n  it(\"should evaluate member expressions\", function () {\n    expect(\n      getPath(\"var x = 'foo'.length\")\n        .get(\"body.0.declarations.0.init\")\n        .evaluate().value,\n    ).toBe(3);\n    expect(\n      getPath(\"var x = 'hello world'[6]\")\n        .get(\"body.0.declarations.0.init\")\n        .evaluate().value,\n    ).toBe(\"w\");\n    expect(\n      getPath(\"var length = 1; var x = 'abc'[length];\")\n        .get(\"body.1.declarations.0.init\")\n        .evaluate().value,\n    ).toBe(\"b\");\n    const member_expr = getPath(\n      \"var x = Math.min(2,Math.max(3,4));var y = Math.random();\",\n    );\n    const eval_member_expr = member_expr\n      .get(\"body.0.declarations.0.init\")\n      .evaluate();\n    const eval_invalid_call = member_expr\n      .get(\"body.1.declarations.0.init\")\n      .evaluate();\n    expect(eval_member_expr.value).toBe(2);\n    expect(eval_invalid_call.confident).toBe(false);\n  });\n\n  it(\"should evaluate global call expressions\", function () {\n    expect(\n      getPath(\"isFinite(1);\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(true);\n\n    expect(\n      getPath(\"isFinite(Infinity);\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(false);\n\n    expect(\n      getPath(\"isNaN(NaN);\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(true);\n\n    expect(getPath(\"isNaN(1);\").get(\"body.0.expression\").evaluate().value).toBe(\n      false,\n    );\n\n    expect(\n      getPath(\"parseFloat('1.1');\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(1.1);\n\n    expect(\n      getPath(\"parseFloat('1');\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(1);\n\n    expect(\n      getPath(\"encodeURI('x 1');\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(\"x%201\");\n\n    expect(\n      getPath(\"decodeURI('x%201');\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(\"x 1\");\n\n    expect(\n      getPath(\"encodeURIComponent('?x=1');\").get(\"body.0.expression\").evaluate()\n        .value,\n    ).toBe(\"%3Fx%3D1\");\n\n    expect(\n      getPath(\"decodeURIComponent('%3Fx%3D1');\")\n        .get(\"body.0.expression\")\n        .evaluate().value,\n    ).toBe(\"?x=1\");\n\n    if (process.env.BABEL_8_BREAKING) {\n      // eslint-disable-next-line jest/no-conditional-expect\n      expect(\n        getPath(\"btoa('babel');\").get(\"body.0.expression\").evaluate().value,\n      ).toBe(\"YmFiZWw=\");\n\n      // eslint-disable-next-line jest/no-conditional-expect\n      expect(\n        getPath(\"atob('YmFiZWw=');\").get(\"body.0.expression\").evaluate().value,\n      ).toBe(\"babel\");\n    }\n  });\n\n  it(\"should not deopt vars in different scope\", function () {\n    const input =\n      \"var a = 5; function x() { var a = 5; var b = a + 1; } var b = a + 2\";\n    expect(\n      getPath(input).get(\"body.1.body.body.1.declarations.0.init\").evaluate()\n        .value,\n    ).toBe(6);\n    expect(\n      getPath(input).get(\"body.2.declarations.0.init\").evaluate().value,\n    ).toBe(7);\n  });\n\n  it(\"should not deopt let/const inside blocks\", function () {\n    expect(\n      getPath(\"let x = 5; { let x = 1; } let y = x + 5\")\n        .get(\"body.2.declarations.0.init\")\n        .evaluate().value,\n    ).toBe(10);\n    const constExample =\n      \"const d = true; if (d && true || false) { const d = false; d && 5; }\";\n    expect(getPath(constExample).get(\"body.1.test\").evaluate().value).toBe(\n      true,\n    );\n    expect(\n      getPath(constExample).get(\"body.1.consequent.body.1\").evaluate().value,\n    ).toBe(false);\n    const test_alternate = \"var y = (3 < 4)? 3 + 4: 3 + 4;\";\n    expect(\n      getPath(test_alternate)\n        .get(\"body.0.declarations.0.init.alternate\")\n        .evaluate().value,\n    ).toBe(7);\n  });\n\n  it(\"should deopt ids that are referenced before the bindings\", function () {\n    expect(\n      getPath(\"let x = y + 5; let y = 5;\")\n        .get(\"body.0.declarations.0.init\")\n        .evaluate().confident,\n    ).toBe(false);\n    expect(\n      getPath(\"if (typeof x === 'undefined') var x = {}\")\n        .get(\"body.0.test\")\n        .evaluate().confident,\n    ).toBe(false);\n  });\n\n  it(\"should evaluate undefined, NaN and Infinity\", () => {\n    expect(\n      getPath(\"undefined\").get(\"body.0.expression\").evaluate().confident,\n    ).toBe(true);\n    expect(getPath(\"NaN\").get(\"body.0.expression\").evaluate().confident).toBe(\n      true,\n    );\n    expect(\n      getPath(\"Infinity\").get(\"body.0.expression\").evaluate().confident,\n    ).toBe(true);\n  });\n\n  it(\"should deopt redefined primitives - undefined, NaN and Infinity\", () => {\n    const eval_undef = getPath(\"let undefined; undefined;\")\n      .get(\"body.1.expression\")\n      .evaluate();\n    const eval_nan = getPath(\"let NaN; NaN;\")\n      .get(\"body.1.expression\")\n      .evaluate();\n    const eval_inf = getPath(\"let Infinity; Infinity;\")\n      .get(\"body.1.expression\")\n      .evaluate();\n    expect(eval_undef.confident).toBe(false);\n    expect(eval_nan.confident).toBe(false);\n    expect(eval_inf.confident).toBe(false);\n\n    expect(eval_undef.deopt.type).toBe(\"VariableDeclarator\");\n    expect(eval_undef.deopt.parentPath.node.kind).toBe(\"let\");\n  });\n\n  it(\"should work with String.raw\", function () {\n    expect(getPath(\"String.raw`\\\\d`\").get(\"body\")[0].evaluate().value).toBe(\n      \"\\\\d\",\n    );\n\n    expect(\n      getPath(\"`${String.raw`\\\\d`}`\").get(\"body\")[0].evaluate().value,\n    ).toBe(\"\\\\d\");\n  });\n\n  it(\"sets deopt properly when not confident after evaluating multiple expressions\", () => {\n    const ast = parse(`\n      const parts = [foo, bar];\n      console.log(parts.join('-'));\n    `);\n\n    let result;\n\n    traverse(ast, {\n      MemberExpression: {\n        enter(path) {\n          result = path.get(\"object\").evaluate();\n        },\n      },\n    });\n\n    expect(result.confident).toBe(false);\n    expect(result.deopt.type).toBe(\"Identifier\");\n    expect(result.deopt.node.name).toBe(\"foo\");\n  });\n\n  it(\"sets deopt properly when confident after evaluating multiple expressions\", () => {\n    const ast = parse(`\n      const foo = 'foo';\n      const bar = 'bar';\n      const parts = [foo, bar];\n      console.log(parts.join('-'))\n    `);\n\n    let result;\n\n    traverse(ast, {\n      MemberExpression: {\n        enter(path) {\n          result = path.get(\"object\").evaluate();\n        },\n      },\n    });\n\n    expect(result.confident).toBe(true);\n    expect(result.deopt).toBeNull();\n    expect(result.value).toEqual([\"foo\", \"bar\"]);\n  });\n\n  addDeoptTest(\"({a:{b}})\", \"ObjectExpression\", \"Identifier\");\n  addDeoptTest(\"({[a + 'b']: 1})\", \"ObjectExpression\", \"Identifier\");\n  addDeoptTest(\"[{a}]\", \"ArrayExpression\", \"Identifier\");\n});\n"], "fixing_code": ["import type NodePath from \"./index.ts\";\nimport type * as t from \"@babel/types\";\n\n// This file contains Babels metainterpreter that can evaluate static code.\n\nconst VALID_OBJECT_CALLEES = [\"Number\", \"String\", \"Math\"] as const;\nconst VALID_IDENTIFIER_CALLEES = [\n  \"isFinite\",\n  \"isNaN\",\n  \"parseFloat\",\n  \"parseInt\",\n  \"decodeURI\",\n  \"decodeURIComponent\",\n  \"encodeURI\",\n  \"encodeURIComponent\",\n  process.env.BABEL_8_BREAKING ? \"btoa\" : null,\n  process.env.BABEL_8_BREAKING ? \"atob\" : null,\n] as const;\n\nconst INVALID_METHODS = [\"random\"] as const;\n\nfunction isValidObjectCallee(\n  val: string,\n): val is (typeof VALID_OBJECT_CALLEES)[number] {\n  return VALID_OBJECT_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isValidIdentifierCallee(\n  val: string,\n): val is (typeof VALID_IDENTIFIER_CALLEES)[number] {\n  return VALID_IDENTIFIER_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isInvalidMethod(val: string): val is (typeof INVALID_METHODS)[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nexport function evaluateTruthy(this: NodePath): boolean {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\ntype State = {\n  confident: boolean;\n  deoptPath: NodePath | null;\n  seen: Map<t.Node, Result>;\n};\n\ntype Result = {\n  resolved: boolean;\n  value?: any;\n};\n/**\n * Deopts the evaluation\n */\nfunction deopt(path: NodePath, state: State) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nconst Globals = new Map([\n  [\"undefined\", undefined],\n  [\"Infinity\", Infinity],\n  [\"NaN\", NaN],\n]);\n\n/**\n * We wrap the _evaluate method so we can track `seen` nodes, we push an item\n * to the map before we actually evaluate it so we can deopt on self recursive\n * nodes such as:\n *\n *   var g = a ? 1 : 2,\n *       a = g * this.foo\n */\nfunction evaluateCached(path: NodePath, state: State): any {\n  const { node } = path;\n  const { seen } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item: Result = { resolved: false };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (\n    path.isStringLiteral() ||\n    path.isNumericLiteral() ||\n    path.isBooleanLiteral()\n  ) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (\n    path.isTaggedTemplateExpression() &&\n    path.get(\"tag\").isMemberExpression()\n  ) {\n    const object = path.get(\"tag.object\") as NodePath;\n    const {\n      // @ts-expect-error todo(flow->ts): possible bug, object is can be any expression and so name might be undefined\n      node: { name },\n    } = object;\n    const property = path.get(\"tag.property\") as NodePath;\n\n    if (\n      object.isIdentifier() &&\n      name === \"String\" &&\n      // todo(flow->ts): was changed from getBinding(name, true)\n      //  should this be hasBinding(name, true) as the binding is never used later?\n      !path.scope.getBinding(name) &&\n      property.isIdentifier() &&\n      property.node.name === \"raw\"\n    ) {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    // TypeCastExpression, ExpressionStatement etc\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  // \"foo\".length, \"foo\"[0]\n  if (\n    path.isMemberExpression() &&\n    !path.parentPath.isCallExpression({ callee: path.node })\n  ) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral()) {\n      // @ts-expect-error todo(flow->ts): instead of typeof - would it be better to check type of ast node?\n      const value = object.node.value;\n      const type = typeof value;\n\n      let key = null;\n      if (path.node.computed) {\n        key = evaluateCached(property, state);\n        if (!state.confident) return;\n      } else if (property.isIdentifier()) {\n        key = property.node.name;\n      }\n      if (\n        (type === \"number\" || type === \"string\") &&\n        key != null &&\n        (typeof key === \"number\" || typeof key === \"string\")\n      ) {\n        return value[key];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding) {\n      if (\n        binding.constantViolations.length > 0 ||\n        path.node.start < binding.path.node.end\n      ) {\n        deopt(binding.path, state);\n        return;\n      }\n      if (binding.hasValue) {\n        return binding.value;\n      }\n    }\n\n    const name = path.node.name;\n    if (Globals.has(name)) {\n      if (!binding) {\n        return Globals.get(name);\n      }\n      deopt(binding.path, state);\n      return;\n    }\n\n    const resolved = path.resolve();\n    if (resolved === path) {\n      deopt(path, state);\n      return;\n    } else {\n      return evaluateCached(resolved, state);\n    }\n  }\n\n  if (path.isUnaryExpression({ prefix: true })) {\n    if (path.node.operator === \"void\") {\n      // we don't need to evaluate the argument to know what this will return\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n    if (\n      path.node.operator === \"typeof\" &&\n      (argument.isFunction() || argument.isClass())\n    ) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems: Array<NodePath> = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        deopt(elemValue.deopt, state);\n        return;\n      }\n    }\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        deopt(prop, state);\n        return;\n      }\n      const keyPath = (prop as NodePath<t.ObjectProperty>).get(\"key\");\n      let key;\n      // @ts-expect-error todo(flow->ts): type refinement issues ObjectMethod and SpreadElement somehow not excluded\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          deopt(key.deopt, state);\n          return;\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = (prop as NodePath<t.ObjectProperty>).get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        deopt(value.deopt, state);\n        return;\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    // If we are confident that the left side of an && is false, or the left\n    // side of an || is true, we can be confident about the entire expression\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        // TODO consider having a \"truthy type\" that doesn't bail on\n        // left uncertainty but can still evaluate to truthy.\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n\n        return left ?? right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right; // eslint-disable-line eqeqeq\n      case \"!=\":\n        return left != right;\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      (isValidObjectCallee(callee.node.name) ||\n        isValidIdentifierCallee(callee.node.name))\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidObjectCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        const key = property.node.name;\n        // TODO(Babel 8): Use Object.hasOwn\n        if (Object.hasOwnProperty.call(context, key)) {\n          func = context[key as keyof typeof context];\n        }\n      }\n\n      // \"abc\".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(\n  path: NodePath<t.TaggedTemplateExpression | t.TemplateLiteral>,\n  quasis: Array<any>,\n  state: State,\n  raw = false,\n) {\n  let str = \"\";\n\n  let i = 0;\n  const exprs: Array<NodePath<t.Node>> = path.isTemplateLiteral()\n    ? path.get(\"expressions\")\n    : path.get(\"quasi.expressions\");\n\n  for (const elem of quasis) {\n    // not confident, evaluated an expression we don't like\n    if (!state.confident) break;\n\n    // add on element\n    str += raw ? elem.value.raw : elem.value.cooked;\n\n    // add on interpolated expression if it's present\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn't confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n", "import { parse } from \"@babel/parser\";\n\nimport _traverse from \"../lib/index.js\";\nconst traverse = _traverse.default || _traverse;\n\nfunction getPath(code) {\n  const ast = parse(code);\n  let path;\n  traverse(ast, {\n    Program: function (_path) {\n      path = _path;\n      _path.stop();\n    },\n  });\n  return path;\n}\n\nfunction addDeoptTest(code, type, expectedType) {\n  it(type + \" deopt: \" + code, function () {\n    const visitor = {};\n\n    visitor[type] = function (path) {\n      const evaluate = path.evaluate();\n      expect(evaluate.confident).toBeFalsy();\n      expect(evaluate.deopt.type).toEqual(expectedType);\n    };\n\n    traverse(\n      parse(code, {\n        plugins: [\"*\"],\n      }),\n      visitor,\n    );\n  });\n}\n\ndescribe(\"evaluation\", function () {\n  describe(\"evaluateTruthy\", function () {\n    it(\"should work with null\", function () {\n      expect(\n        getPath(\"false || a.length === 0;\").get(\"body\")[0].evaluateTruthy(),\n      ).toBeUndefined();\n    });\n\n    it(\"should not mistake lack of confidence for falsy\", function () {\n      expect(\n        getPath(\"foo || 'bar'\").get(\"body\")[0].evaluate().value,\n      ).toBeUndefined();\n    });\n  });\n\n  it(\"should bail out on recursive evaluation\", function () {\n    expect(\n      getPath(\"function fn(a) { var g = a ? 1 : 2, a = g * this.foo; }\")\n        .get(\"body.0.body.body.0.declarations.1.init\")\n        .evaluate().confident,\n    ).toBe(false);\n  });\n\n  it(\"should short-circuit && and ||\", function () {\n    expect(getPath(\"x === 'y' || 42\").get(\"body\")[0].evaluate().confident).toBe(\n      false,\n    );\n    expect(getPath(\"x === 'y' && 0\").get(\"body\")[0].evaluate().confident).toBe(\n      false,\n    );\n    expect(getPath(\"42 || x === 'y'\").get(\"body\")[0].evaluate().value).toBe(42);\n    expect(getPath(\"0 && x === 'y'\").get(\"body\")[0].evaluate().value).toBe(0);\n  });\n\n  it(\"should handle ??\", function () {\n    expect(getPath(\"null ?? 42\").get(\"body\")[0].evaluate().value).toBe(42);\n    expect(getPath(\"void 0 ?? 42\").get(\"body\")[0].evaluate().value).toBe(42);\n    expect(getPath(\"0 ?? 42\").get(\"body\")[0].evaluate().value).toBe(0);\n    expect(getPath(\"x ?? 42\").get(\"body\")[0].evaluate().confident).toBe(false);\n    expect(getPath(\"42 ?? x === 'y'\").get(\"body\")[0].evaluate().value).toBe(42);\n  });\n\n  it(\"should work with repeated, indeterminate identifiers\", function () {\n    expect(\n      getPath(\"var num = foo(); (num > 0 && num < 100);\")\n        .get(\"body\")[1]\n        .evaluateTruthy(),\n    ).toBeUndefined();\n  });\n\n  it(\"should work with repeated, determinate identifiers\", function () {\n    expect(\n      getPath(\"var num = 5; (num > 0 && num < 100);\")\n        .get(\"body\")[1]\n        .evaluateTruthy(),\n    ).toBe(true);\n  });\n\n  it(\"should deopt when var is redeclared in the same scope\", function () {\n    expect(\n      getPath(\"var x = 2; var y = x + 2; { var x = 3 }\")\n        .get(\"body.1.declarations.0.init\")\n        .evaluate().confident,\n    ).toBe(false);\n  });\n\n  describe(\"template literals\", function () {\n    it(\"should evaluate template literals\", function () {\n      expect(\n        getPath(\"var x = 8; var y = 1; var z = `value is ${x >>> y}`\")\n          .get(\"body.2.declarations.0.init\")\n          .evaluate().value,\n      ).toBe(\"value is 4\");\n    });\n\n    it(\"should evaluate String.raw tags\", function () {\n      expect(\n        getPath(\"String.raw`a\\\\n${1}\\\\u`;\").get(\"body.0.expression\").evaluate()\n          .value,\n      ).toBe(\"a\\\\n1\\\\u\");\n    });\n\n    addDeoptTest(\n      \"a`x${b}y`\",\n      \"TaggedTemplateExpression\",\n      \"TaggedTemplateExpression\",\n    );\n  });\n\n  it(\"should evaluate member expressions\", function () {\n    expect(\n      getPath(\"var x = 'foo'.length\")\n        .get(\"body.0.declarations.0.init\")\n        .evaluate().value,\n    ).toBe(3);\n    expect(\n      getPath(\"var x = 'hello world'[6]\")\n        .get(\"body.0.declarations.0.init\")\n        .evaluate().value,\n    ).toBe(\"w\");\n    expect(\n      getPath(\"var length = 1; var x = 'abc'[length];\")\n        .get(\"body.1.declarations.0.init\")\n        .evaluate().value,\n    ).toBe(\"b\");\n    const member_expr = getPath(\n      \"var x = Math.min(2,Math.max(3,4));var y = Math.random();\",\n    );\n    const eval_member_expr = member_expr\n      .get(\"body.0.declarations.0.init\")\n      .evaluate();\n    const eval_invalid_call = member_expr\n      .get(\"body.1.declarations.0.init\")\n      .evaluate();\n    expect(eval_member_expr.value).toBe(2);\n    expect(eval_invalid_call.confident).toBe(false);\n  });\n\n  it(\"should not evaluate inherited methods\", function () {\n    const path = getPath(\"Math.hasOwnProperty('min')\");\n    const evalResult = path.get(\"body.0.expression\").evaluate();\n    expect(evalResult.confident).toBe(false);\n  });\n\n  it(\"should evaluate global call expressions\", function () {\n    expect(\n      getPath(\"isFinite(1);\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(true);\n\n    expect(\n      getPath(\"isFinite(Infinity);\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(false);\n\n    expect(\n      getPath(\"isNaN(NaN);\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(true);\n\n    expect(getPath(\"isNaN(1);\").get(\"body.0.expression\").evaluate().value).toBe(\n      false,\n    );\n\n    expect(\n      getPath(\"parseFloat('1.1');\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(1.1);\n\n    expect(\n      getPath(\"parseFloat('1');\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(1);\n\n    expect(\n      getPath(\"encodeURI('x 1');\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(\"x%201\");\n\n    expect(\n      getPath(\"decodeURI('x%201');\").get(\"body.0.expression\").evaluate().value,\n    ).toBe(\"x 1\");\n\n    expect(\n      getPath(\"encodeURIComponent('?x=1');\").get(\"body.0.expression\").evaluate()\n        .value,\n    ).toBe(\"%3Fx%3D1\");\n\n    expect(\n      getPath(\"decodeURIComponent('%3Fx%3D1');\")\n        .get(\"body.0.expression\")\n        .evaluate().value,\n    ).toBe(\"?x=1\");\n\n    if (process.env.BABEL_8_BREAKING) {\n      // eslint-disable-next-line jest/no-conditional-expect\n      expect(\n        getPath(\"btoa('babel');\").get(\"body.0.expression\").evaluate().value,\n      ).toBe(\"YmFiZWw=\");\n\n      // eslint-disable-next-line jest/no-conditional-expect\n      expect(\n        getPath(\"atob('YmFiZWw=');\").get(\"body.0.expression\").evaluate().value,\n      ).toBe(\"babel\");\n    }\n  });\n\n  it(\"should not deopt vars in different scope\", function () {\n    const input =\n      \"var a = 5; function x() { var a = 5; var b = a + 1; } var b = a + 2\";\n    expect(\n      getPath(input).get(\"body.1.body.body.1.declarations.0.init\").evaluate()\n        .value,\n    ).toBe(6);\n    expect(\n      getPath(input).get(\"body.2.declarations.0.init\").evaluate().value,\n    ).toBe(7);\n  });\n\n  it(\"should not deopt let/const inside blocks\", function () {\n    expect(\n      getPath(\"let x = 5; { let x = 1; } let y = x + 5\")\n        .get(\"body.2.declarations.0.init\")\n        .evaluate().value,\n    ).toBe(10);\n    const constExample =\n      \"const d = true; if (d && true || false) { const d = false; d && 5; }\";\n    expect(getPath(constExample).get(\"body.1.test\").evaluate().value).toBe(\n      true,\n    );\n    expect(\n      getPath(constExample).get(\"body.1.consequent.body.1\").evaluate().value,\n    ).toBe(false);\n    const test_alternate = \"var y = (3 < 4)? 3 + 4: 3 + 4;\";\n    expect(\n      getPath(test_alternate)\n        .get(\"body.0.declarations.0.init.alternate\")\n        .evaluate().value,\n    ).toBe(7);\n  });\n\n  it(\"should deopt ids that are referenced before the bindings\", function () {\n    expect(\n      getPath(\"let x = y + 5; let y = 5;\")\n        .get(\"body.0.declarations.0.init\")\n        .evaluate().confident,\n    ).toBe(false);\n    expect(\n      getPath(\"if (typeof x === 'undefined') var x = {}\")\n        .get(\"body.0.test\")\n        .evaluate().confident,\n    ).toBe(false);\n  });\n\n  it(\"should evaluate undefined, NaN and Infinity\", () => {\n    expect(\n      getPath(\"undefined\").get(\"body.0.expression\").evaluate().confident,\n    ).toBe(true);\n    expect(getPath(\"NaN\").get(\"body.0.expression\").evaluate().confident).toBe(\n      true,\n    );\n    expect(\n      getPath(\"Infinity\").get(\"body.0.expression\").evaluate().confident,\n    ).toBe(true);\n  });\n\n  it(\"should deopt redefined primitives - undefined, NaN and Infinity\", () => {\n    const eval_undef = getPath(\"let undefined; undefined;\")\n      .get(\"body.1.expression\")\n      .evaluate();\n    const eval_nan = getPath(\"let NaN; NaN;\")\n      .get(\"body.1.expression\")\n      .evaluate();\n    const eval_inf = getPath(\"let Infinity; Infinity;\")\n      .get(\"body.1.expression\")\n      .evaluate();\n    expect(eval_undef.confident).toBe(false);\n    expect(eval_nan.confident).toBe(false);\n    expect(eval_inf.confident).toBe(false);\n\n    expect(eval_undef.deopt.type).toBe(\"VariableDeclarator\");\n    expect(eval_undef.deopt.parentPath.node.kind).toBe(\"let\");\n  });\n\n  it(\"should work with String.raw\", function () {\n    expect(getPath(\"String.raw`\\\\d`\").get(\"body\")[0].evaluate().value).toBe(\n      \"\\\\d\",\n    );\n\n    expect(\n      getPath(\"`${String.raw`\\\\d`}`\").get(\"body\")[0].evaluate().value,\n    ).toBe(\"\\\\d\");\n  });\n\n  it(\"sets deopt properly when not confident after evaluating multiple expressions\", () => {\n    const ast = parse(`\n      const parts = [foo, bar];\n      console.log(parts.join('-'));\n    `);\n\n    let result;\n\n    traverse(ast, {\n      MemberExpression: {\n        enter(path) {\n          result = path.get(\"object\").evaluate();\n        },\n      },\n    });\n\n    expect(result.confident).toBe(false);\n    expect(result.deopt.type).toBe(\"Identifier\");\n    expect(result.deopt.node.name).toBe(\"foo\");\n  });\n\n  it(\"sets deopt properly when confident after evaluating multiple expressions\", () => {\n    const ast = parse(`\n      const foo = 'foo';\n      const bar = 'bar';\n      const parts = [foo, bar];\n      console.log(parts.join('-'))\n    `);\n\n    let result;\n\n    traverse(ast, {\n      MemberExpression: {\n        enter(path) {\n          result = path.get(\"object\").evaluate();\n        },\n      },\n    });\n\n    expect(result.confident).toBe(true);\n    expect(result.deopt).toBeNull();\n    expect(result.value).toEqual([\"foo\", \"bar\"]);\n  });\n\n  addDeoptTest(\"({a:{b}})\", \"ObjectExpression\", \"Identifier\");\n  addDeoptTest(\"({[a + 'b']: 1})\", \"ObjectExpression\", \"Identifier\");\n  addDeoptTest(\"[{a}]\", \"ArrayExpression\", \"Identifier\");\n});\n"], "filenames": ["packages/babel-traverse/src/path/evaluation.ts", "packages/babel-traverse/test/evaluation.js"], "buggy_code_start_loc": [447, 154], "buggy_code_end_loc": [449, 154], "fixing_code_start_loc": [447, 155], "fixing_code_end_loc": [452, 161], "type": "CWE-697", "message": "Babel is a compiler for writingJavaScript. In `@babel/traverse` prior to versions 7.23.2 and 8.0.0-alpha.4 and all versions of `babel-traverse`, using Babel to compile code that was specifically crafted by an attacker can lead to arbitrary code execution during compilation, when using plugins that rely on the `path.evaluate()`or `path.evaluateTruthy()` internal Babel methods. Known affected plugins are `@babel/plugin-transform-runtime`; `@babel/preset-env` when using its `useBuiltIns` option; and any \"polyfill provider\" plugin that depends on `@babel/helper-define-polyfill-provider`, such as `babel-plugin-polyfill-corejs3`, `babel-plugin-polyfill-corejs2`, `babel-plugin-polyfill-es-shims`, `babel-plugin-polyfill-regenerator`. No other plugins under the `@babel/` namespace are impacted, but third-party plugins might be. Users that only compile trusted code are not impacted. The vulnerability has been fixed in `@babel/traverse@7.23.2` and `@babel/traverse@8.0.0-alpha.4`. Those who cannot upgrade `@babel/traverse` and are using one of the affected packages mentioned above should upgrade them to their latest version to avoid triggering the vulnerable code path in affected `@babel/traverse` versions: `@babel/plugin-transform-runtime` v7.23.2, `@babel/preset-env` v7.23.2, `@babel/helper-define-polyfill-provider` v0.4.3, `babel-plugin-polyfill-corejs2` v0.4.6, `babel-plugin-polyfill-corejs3` v0.8.5, `babel-plugin-polyfill-es-shims` v0.10.0, `babel-plugin-polyfill-regenerator` v0.5.3.", "other": {"cve": {"id": "CVE-2023-45133", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-12T17:15:09.797", "lastModified": "2023-10-24T16:52:20.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Babel is a compiler for writingJavaScript. In `@babel/traverse` prior to versions 7.23.2 and 8.0.0-alpha.4 and all versions of `babel-traverse`, using Babel to compile code that was specifically crafted by an attacker can lead to arbitrary code execution during compilation, when using plugins that rely on the `path.evaluate()`or `path.evaluateTruthy()` internal Babel methods. Known affected plugins are `@babel/plugin-transform-runtime`; `@babel/preset-env` when using its `useBuiltIns` option; and any \"polyfill provider\" plugin that depends on `@babel/helper-define-polyfill-provider`, such as `babel-plugin-polyfill-corejs3`, `babel-plugin-polyfill-corejs2`, `babel-plugin-polyfill-es-shims`, `babel-plugin-polyfill-regenerator`. No other plugins under the `@babel/` namespace are impacted, but third-party plugins might be. Users that only compile trusted code are not impacted. The vulnerability has been fixed in `@babel/traverse@7.23.2` and `@babel/traverse@8.0.0-alpha.4`. Those who cannot upgrade `@babel/traverse` and are using one of the affected packages mentioned above should upgrade them to their latest version to avoid triggering the vulnerable code path in affected `@babel/traverse` versions: `@babel/plugin-transform-runtime` v7.23.2, `@babel/preset-env` v7.23.2, `@babel/helper-define-polyfill-provider` v0.4.3, `babel-plugin-polyfill-corejs2` v0.4.6, `babel-plugin-polyfill-corejs3` v0.8.5, `babel-plugin-polyfill-es-shims` v0.10.0, `babel-plugin-polyfill-regenerator` v0.5.3."}, {"lang": "es", "value": "Babel es un compilador para escribir JavaScript. En `@babel/traverse` anterior a las versiones 7.23.2 y 8.0.0-alpha.4 y en todas las versiones de `babel-traverse`, el uso de Babel para compilar c\u00f3digo manipulado espec\u00edficamente por un atacante puede provocar la ejecuci\u00f3n de c\u00f3digo arbitrario durante compilaci\u00f3n, cuando se utilizan complementos que se basan en los m\u00e9todos internos de Babel `path.evaluate()`o `path.evaluateTruthy()`. Los complementos afectados conocidos son `@babel/plugin-transform-runtime`; `@babel/preset-env` cuando se usa su opci\u00f3n `useBuiltIns`; y cualquier complemento de \"proveedor de polyfill\" que dependa de `@babel/helper-define-polyfill-provider`, como `babel-plugin-polyfill-corejs3`, `babel-plugin-polyfill-corejs2`, `babel-plugin- polyfill-es-shims`, `babel-plugin-polyfill-regenerator`. Ning\u00fan otro complemento bajo el espacio de nombres `@babel/` se ve afectado, pero los complementos de terceros podr\u00edan verse afectados. Los usuarios que solo compilan c\u00f3digo confiable no se ven afectados. La vulnerabilidad se ha solucionado en `@babel/traverse@7.23.2` y `@babel/traverse@8.0.0-alpha.4`. Aquellos que no puedan actualizar `@babel/traverse` y est\u00e9n usando uno de los paquetes afectados mencionados anteriormente deben actualizarlos a su \u00faltima versi\u00f3n para evitar activar la ruta de c\u00f3digo vulnerable en las versiones afectadas `@babel/traverse`: `@babel/plugin- transform-runtime` v7.23.2, `@babel/preset-env` v7.23.2, `@babel/helper-define-polyfill-provider` v0.4.3, `babel-plugin-polyfill-corejs2` v0.4.6, ` babel-plugin-polyfill-corejs3` v0.8.5, `babel-plugin-polyfill-es-shims` v0.10.0, `babel-plugin-polyfill-regenerator` v0.5.3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.5, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-697"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-184"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "46D69DCC-AE4D-4EA5-861C-D60951444C6C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel:*:*:*:*:*:nodejs:*:*", "versionEndExcluding": "7.23.2", "matchCriteriaId": "C20217DD-2967-42B5-A20D-3B7978DEC2D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel:8.0.0:alpha.0:*:*:*:nodejs:*:*", "matchCriteriaId": "3359A5D4-32F2-4128-8E6D-58C556FE5D4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel:8.0.0:alpha.1:*:*:*:nodejs:*:*", "matchCriteriaId": "B7A7E551-6CA9-4D22-A8BC-BDA8F3FE4CD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel:8.0.0:alpha.2:*:*:*:nodejs:*:*", "matchCriteriaId": "0214C42F-5EB9-410E-AB7E-206A5243FEB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel:8.0.0:alpha.3:*:*:*:nodejs:*:*", "matchCriteriaId": "9E8907AD-4095-4579-BF92-AED3416ADA1E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel-helper-define-polyfill-provider:*:*:*:*:*:nodejs:*:*", "versionEndExcluding": "0.4.3", "matchCriteriaId": "EA4E050F-1B8B-44F6-AA89-6457C7CC074F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel-plugin-polyfill-corejs2:*:*:*:*:*:nodejs:*:*", "versionEndExcluding": "0.4.6", "matchCriteriaId": "AE6CEB01-B369-401F-9103-4BBB2FDA267A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel-plugin-polyfill-corejs3:*:*:*:*:*:nodejs:*:*", "versionEndExcluding": "0.8.5", "matchCriteriaId": "3E9E5F4A-2CF4-483A-81F9-055E06913969"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel-plugin-polyfill-es-shims:*:*:*:*:*:nodejs:*:*", "versionEndExcluding": "0.10.0", "matchCriteriaId": "B9101BDF-A1D8-4CE4-94F3-B7D986548C7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel-plugin-polyfill-regenerator:*:*:*:*:*:nodejs:*:*", "versionEndExcluding": "0.5.3", "matchCriteriaId": "9350BCA6-00A4-4581-BC2B-A5077923E354"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel-plugin-transform-runtime:*:*:*:*:*:nodejs:*:*", "versionEndExcluding": "7.23.2", "matchCriteriaId": "F42788D8-5501-4FC1-828E-D487A4895986"}, {"vulnerable": true, "criteria": "cpe:2.3:a:babeljs:babel-preset-env:*:*:*:*:*:nodejs:*:*", "versionEndExcluding": "7.23.2", "matchCriteriaId": "90EF976D-050D-4478-9A6E-D694E7451BAA"}]}]}], "references": [{"url": "https://github.com/babel/babel/commit/b13376b346946e3f62fc0848c1d2a23223314c82", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/babel/babel/pull/16033", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/babel/babel/releases/tag/v7.23.2", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/babel/babel/releases/tag/v8.0.0-alpha.4", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/babel/babel/security/advisories/GHSA-67hx-6x53-jw92", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00026.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5528", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}]}, "github_commit_url": "https://github.com/babel/babel/commit/b13376b346946e3f62fc0848c1d2a23223314c82"}}