{"buggy_code": ["import type {\n  DeepMergeBuiltInMetaData,\n  DeepMergeHKT,\n  DeepMergeArraysDefaultHKT,\n  DeepMergeMergeFunctionsDefaultURIs,\n  DeepMergeMapsDefaultHKT,\n  DeepMergeMergeFunctionsURIs,\n  DeepMergeOptions,\n  DeepMergeRecordsDefaultHKT,\n  DeepMergeSetsDefaultHKT,\n  DeepMergeMergeFunctionUtils,\n  GetDeepMergeMergeFunctionsURIs,\n} from \"./types\";\nimport {\n  getIterableOfIterables,\n  getKeys,\n  getObjectType,\n  ObjectType,\n  objectHasProperty,\n} from \"./utils\";\n\nconst defaultMergeFunctions = {\n  mergeMaps: defaultMergeMaps,\n  mergeSets: defaultMergeSets,\n  mergeArrays: defaultMergeArrays,\n  mergeRecords: defaultMergeRecords,\n  mergeOthers: leaf,\n} as const;\n\n/**\n * Special values that tell deepmerge-ts to perform a certain action.\n */\nconst actions = {\n  defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n  skip: Symbol(\"deepmerge-ts: skip\"),\n} as const;\n\n/**\n * The default function to update meta data.\n */\nfunction defaultMetaDataUpdater<M>(\n  previousMeta: M,\n  metaMeta: DeepMergeBuiltInMetaData\n): DeepMergeBuiltInMetaData {\n  return metaMeta;\n}\n\n/**\n * The default merge functions.\n */\nexport type DeepMergeMergeFunctionsDefaults = typeof defaultMergeFunctions;\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nexport function deepmerge<Ts extends Readonly<ReadonlyArray<unknown>>>(\n  ...objects: readonly [...Ts]\n): DeepMergeHKT<\n  Ts,\n  DeepMergeMergeFunctionsDefaultURIs,\n  DeepMergeBuiltInMetaData\n> {\n  return deepmergeCustom({})(...objects) as DeepMergeHKT<\n    Ts,\n    DeepMergeMergeFunctionsDefaultURIs,\n    DeepMergeBuiltInMetaData\n  >;\n}\n\n/**\n * Deeply merge two or more objects using the given options.\n *\n * @param options - The options on how to customize the merge function.\n */\nexport function deepmergeCustom<\n  PMF extends Partial<DeepMergeMergeFunctionsURIs>\n>(\n  options: DeepMergeOptions<DeepMergeBuiltInMetaData, DeepMergeBuiltInMetaData>\n): <Ts extends ReadonlyArray<unknown>>(\n  ...objects: Ts\n) => DeepMergeHKT<\n  Ts,\n  GetDeepMergeMergeFunctionsURIs<PMF>,\n  DeepMergeBuiltInMetaData\n>;\n\n/**\n * Deeply merge two or more objects using the given options and meta data.\n *\n * @param options - The options on how to customize the merge function.\n * @param rootMetaData - The meta data passed to the root items' being merged.\n */\nexport function deepmergeCustom<\n  PMF extends Partial<DeepMergeMergeFunctionsURIs>,\n  MetaData,\n  MetaMetaData extends DeepMergeBuiltInMetaData = DeepMergeBuiltInMetaData\n>(\n  options: DeepMergeOptions<MetaData, MetaMetaData>,\n  rootMetaData?: MetaData\n): <Ts extends ReadonlyArray<unknown>>(\n  ...objects: Ts\n) => DeepMergeHKT<Ts, GetDeepMergeMergeFunctionsURIs<PMF>, MetaData>;\n\nexport function deepmergeCustom<\n  PMF extends Partial<DeepMergeMergeFunctionsURIs>,\n  MetaData,\n  MetaMetaData extends DeepMergeBuiltInMetaData\n>(\n  options: DeepMergeOptions<MetaData, MetaMetaData>,\n  rootMetaData?: MetaData\n): <Ts extends ReadonlyArray<unknown>>(\n  ...objects: Ts\n) => DeepMergeHKT<Ts, GetDeepMergeMergeFunctionsURIs<PMF>, MetaData> {\n  /**\n   * The type of the customized deepmerge function.\n   */\n  type CustomizedDeepmerge = <Ts extends ReadonlyArray<unknown>>(\n    ...objects: Ts\n  ) => DeepMergeHKT<Ts, GetDeepMergeMergeFunctionsURIs<PMF>, MetaData>;\n\n  const utils: DeepMergeMergeFunctionUtils<MetaData, MetaMetaData> = getUtils(\n    options,\n    customizedDeepmerge as CustomizedDeepmerge\n  );\n\n  /**\n   * The customized deepmerge function.\n   */\n  function customizedDeepmerge(...objects: ReadonlyArray<unknown>) {\n    return mergeUnknowns<\n      ReadonlyArray<unknown>,\n      typeof utils,\n      GetDeepMergeMergeFunctionsURIs<PMF>,\n      MetaData,\n      MetaMetaData\n    >(objects, utils, rootMetaData);\n  }\n\n  return customizedDeepmerge as CustomizedDeepmerge;\n}\n\n/**\n * The the full options with defaults apply.\n *\n * @param options - The options the user specified\n */\nfunction getUtils<M, MM extends DeepMergeBuiltInMetaData>(\n  options: DeepMergeOptions<M, MM>,\n  customizedDeepmerge: DeepMergeMergeFunctionUtils<M, MM>[\"deepmerge\"]\n): DeepMergeMergeFunctionUtils<M, MM> {\n  return {\n    defaultMergeFunctions,\n    mergeFunctions: {\n      ...defaultMergeFunctions,\n      ...Object.fromEntries(\n        Object.entries(options)\n          .filter(([key, option]) =>\n            Object.prototype.hasOwnProperty.call(defaultMergeFunctions, key)\n          )\n          .map(([key, option]) =>\n            option === false ? [key, leaf] : [key, option]\n          )\n      ),\n    } as DeepMergeMergeFunctionUtils<M, MM>[\"mergeFunctions\"],\n    metaDataUpdater: (options.metaDataUpdater ??\n      defaultMetaDataUpdater) as unknown as DeepMergeMergeFunctionUtils<\n      M,\n      MM\n    >[\"metaDataUpdater\"],\n    deepmerge: customizedDeepmerge,\n    useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n    actions,\n  };\n}\n\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns<\n  Ts extends ReadonlyArray<unknown>,\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(values: Ts, utils: U, meta: M | undefined): DeepMergeHKT<Ts, MF, M> {\n  if (values.length === 0) {\n    return undefined as DeepMergeHKT<Ts, MF, M>;\n  }\n  if (values.length === 1) {\n    return mergeOthers<U, M, MM>(values, utils, meta) as DeepMergeHKT<\n      Ts,\n      MF,\n      M\n    >;\n  }\n\n  const type = getObjectType(values[0]);\n\n  // eslint-disable-next-line functional/no-conditional-statement -- add an early escape for better performance.\n  if (type !== ObjectType.NOT && type !== ObjectType.OTHER) {\n    // eslint-disable-next-line functional/no-loop-statement -- using a loop here is more performant than mapping every value and then testing every value.\n    for (let mutableIndex = 1; mutableIndex < values.length; mutableIndex++) {\n      if (getObjectType(values[mutableIndex]) === type) {\n        continue;\n      }\n\n      return mergeOthers<U, M, MM>(values, utils, meta) as DeepMergeHKT<\n        Ts,\n        MF,\n        M\n      >;\n    }\n  }\n\n  switch (type) {\n    case ObjectType.RECORD:\n      return mergeRecords<U, MF, M, MM>(\n        values as ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    case ObjectType.ARRAY:\n      return mergeArrays<U, M, MM>(\n        values as ReadonlyArray<Readonly<ReadonlyArray<unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    case ObjectType.SET:\n      return mergeSets<U, M, MM>(\n        values as ReadonlyArray<Readonly<ReadonlySet<unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    case ObjectType.MAP:\n      return mergeMaps<U, M, MM>(\n        values as ReadonlyArray<Readonly<ReadonlyMap<unknown, unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    default:\n      return mergeOthers<U, M, MM>(values, utils, meta) as DeepMergeHKT<\n        Ts,\n        MF,\n        M\n      >;\n  }\n}\n\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeRecords !==\n        utils.defaultMergeFunctions.mergeRecords)\n  ) {\n    return utils.defaultMergeFunctions.mergeRecords<\n      ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>,\n      U,\n      MF,\n      M,\n      MM\n    >(values, utils, meta);\n  }\n\n  return result;\n}\n\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<ReadonlyArray<unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeArrays !==\n        utils.defaultMergeFunctions.mergeArrays)\n  ) {\n    return utils.defaultMergeFunctions.mergeArrays(values);\n  }\n  return result;\n}\n\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<ReadonlySet<unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)\n  ) {\n    return utils.defaultMergeFunctions.mergeSets(values);\n  }\n  return result;\n}\n\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<ReadonlyMap<unknown, unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)\n  ) {\n    return utils.defaultMergeFunctions.mergeMaps(values);\n  }\n  return result;\n}\n\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(values: ReadonlyArray<unknown>, utils: U, meta: M | undefined) {\n  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeOthers !==\n        utils.defaultMergeFunctions.mergeOthers)\n  ) {\n    return utils.defaultMergeFunctions.mergeOthers(values);\n  }\n  return result;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction defaultMergeRecords<\n  Ts extends ReadonlyArray<Record<PropertyKey, unknown>>,\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(values: Ts, utils: U, meta: M | undefined) {\n  const result: Record<PropertyKey, unknown> = {};\n\n  /* eslint-disable functional/no-loop-statement, functional/no-conditional-statement -- using a loop here is more performant. */\n\n  for (const key of getKeys(values)) {\n    const propValues = [];\n\n    for (const value of values) {\n      if (objectHasProperty(value, key)) {\n        propValues.push(value[key]);\n      }\n    }\n\n    // assert(propValues.length > 0);\n\n    const updatedMeta = utils.metaDataUpdater(meta, {\n      key,\n      parents: values,\n    } as unknown as MM);\n\n    const propertyResult = mergeUnknowns<ReadonlyArray<unknown>, U, MF, M, MM>(\n      propValues,\n      utils,\n      updatedMeta\n    );\n\n    if (propertyResult === actions.skip) {\n      continue;\n    }\n\n    result[key] = propertyResult;\n  }\n\n  /* eslint-enable functional/no-loop-statement, functional/no-conditional-statement */\n\n  return result as DeepMergeRecordsDefaultHKT<Ts, MF, M>;\n}\n\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction defaultMergeArrays<\n  Ts extends ReadonlyArray<ReadonlyArray<unknown>>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M\n>(values: Ts) {\n  return values.flat() as DeepMergeArraysDefaultHKT<Ts, MF, M>;\n}\n\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction defaultMergeSets<\n  Ts extends ReadonlyArray<Readonly<ReadonlySet<unknown>>>\n>(values: Ts) {\n  return new Set(getIterableOfIterables(values)) as DeepMergeSetsDefaultHKT<Ts>;\n}\n\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction defaultMergeMaps<\n  Ts extends ReadonlyArray<Readonly<ReadonlyMap<unknown, unknown>>>\n>(values: Ts) {\n  return new Map(getIterableOfIterables(values)) as DeepMergeMapsDefaultHKT<Ts>;\n}\n\n/**\n * Get the last value in the given array.\n */\nfunction leaf<Ts extends ReadonlyArray<unknown>>(values: Ts) {\n  return values[values.length - 1];\n}\n", "import test from \"ava\";\n\nimport { deepmerge } from \"@/deepmerge\";\n\ntest(\"return undefined when nothing to merge\", (t) => {\n  // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n  const merged = deepmerge();\n  t.is(merged, undefined);\n});\n\ntest(\"return the same object if only 1 is passed\", (t) => {\n  const foo = { prop: 1 };\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"return the same array if only 1 is passed\", (t) => {\n  const foo = [1];\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"return the same set if only 1 is passed\", (t) => {\n  const foo = new Set([1]);\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"return the same map if only 1 is passed\", (t) => {\n  const foo = new Map([[1, 2]]);\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"return the same date if only 1 is passed\", (t) => {\n  const foo = new Date();\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"can merge 2 objects with different props\", (t) => {\n  const x = { first: true };\n  const y = { second: false };\n\n  const expected = {\n    first: true,\n    second: false,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(\"can merge many objects with different props\", (t) => {\n  const v = { first: true };\n  const x = { second: false };\n  const y = { third: 123 };\n  const z = { fourth: \"abc\" };\n\n  const expected = {\n    first: true,\n    second: false,\n    third: 123,\n    fourth: \"abc\",\n  };\n\n  const merged = deepmerge(v, x, y, z);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(\"can merge with same props\", (t) => {\n  const x = { key1: \"value1\", key2: \"value2\" };\n  const y = { key1: \"changed\", key3: \"value3\" };\n  const z = { key3: \"changed\", key4: \"value4\" };\n\n  const expected = {\n    key1: \"changed\",\n    key2: \"value2\",\n    key3: \"changed\",\n    key4: \"value4\",\n  };\n\n  const merged = deepmerge(x, y, z);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(\"does not clone any elements\", (t) => {\n  const x = { a: { d: 123 } };\n  const y = { b: { e: true } };\n  const z = { c: { f: \"string\" } };\n\n  const merged = deepmerge(x, y, z);\n\n  t.is(merged.a, x.a);\n  t.is(merged.b, y.b);\n  t.is(merged.c, z.c);\n});\n\ntest(\"does not mutate inputs\", (t) => {\n  const x = { a: { d: 123 } };\n  const y = { b: { e: true } };\n  const z = { c: { f: \"string\" } };\n\n  deepmerge(x, y, z);\n\n  t.deepEqual(x, { a: { d: 123 } });\n  t.deepEqual(y, { b: { e: true } });\n  t.deepEqual(z, { c: { f: \"string\" } });\n});\n\ntest(\"merging with empty object shallow clones the object\", (t) => {\n  const value = { a: { d: 123 } };\n\n  const merged = deepmerge({}, value);\n\n  t.deepEqual(merged, value);\n  t.not(merged, value, \"Value should be shallow cloned.\");\n  t.is(merged.a, value.a, \"Value should not be deep cloned.\");\n});\n\ntest(`can merge nested objects`, (t) => {\n  const x = {\n    key1: {\n      subkey1: `value1`,\n      subkey2: `value2`,\n    },\n  };\n  const y = {\n    key1: {\n      subkey1: `changed`,\n      subkey3: `added`,\n    },\n  };\n\n  const expected = {\n    key1: {\n      subkey1: `changed`,\n      subkey2: `value2`,\n      subkey3: `added`,\n    },\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(x, {\n    key1: {\n      subkey1: `value1`,\n      subkey2: `value2`,\n    },\n  });\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces simple prop with nested object`, (t) => {\n  const x = {\n    key1: `value1`,\n    key2: `value2`,\n  };\n  const y = {\n    key1: {\n      subkey1: `subvalue1`,\n      subkey2: `subvalue2`,\n    },\n  };\n\n  const expected = {\n    key1: {\n      subkey1: `subvalue1`,\n      subkey2: `subvalue2`,\n    },\n    key2: `value2`,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`should add nested object in target`, (t) => {\n  const x = {\n    a: {},\n  };\n  const y = {\n    b: {\n      c: {},\n    },\n  };\n\n  const expected = {\n    a: {},\n    b: {\n      c: {},\n    },\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.is(merged.b, y.b, \"Value should not be deep cloned.\");\n});\n\ntest(`replaces nested object with simple prop`, (t) => {\n  const x = {\n    key1: {\n      subkey1: `subvalue1`,\n      subkey2: `subvalue2`,\n    },\n    key2: `value2`,\n  };\n  const y = { key1: `value1` };\n\n  const expected = { key1: `value1`, key2: `value2` };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(x, {\n    key1: {\n      subkey1: `subvalue1`,\n      subkey2: `subvalue2`,\n    },\n    key2: `value2`,\n  });\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces records with arrays`, (t) => {\n  const x = { key1: { subkey: `one` } };\n  const y = { key1: [`subkey`] };\n\n  const expected = { key1: [`subkey`] };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces arrays with records`, (t) => {\n  const x = { key1: [`subkey`] };\n  const y = { key1: { subkey: `one` } };\n\n  const expected = { key1: { subkey: `one` } };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces dates with records`, (t) => {\n  const x = { key1: new Date() };\n  const y = { key1: { subkey: `one` } };\n\n  const expected = { key1: { subkey: `one` } };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces records with dates`, (t) => {\n  const date = new Date();\n  const x = { key1: { subkey: `one` } };\n  const y = { key1: date };\n\n  const expected = { key1: date };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces null with records`, (t) => {\n  const x = { key1: null };\n  const y = { key1: { subkey: `one` } };\n\n  const expected = { key1: { subkey: `one` } };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces records with null`, (t) => {\n  const x = { key1: { subkey: `one` } };\n  const y = { key1: null };\n\n  const expected = { key1: null };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces undefined with records`, (t) => {\n  const x = { key1: undefined };\n  const y = { key1: { subkey: `one` } };\n\n  const expected = { key1: { subkey: `one` } };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces records with undefined`, (t) => {\n  const x = { key1: { subkey: `one` } };\n  const y = { key1: undefined };\n\n  const expected = { key1: undefined };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`can merge arrays`, (t) => {\n  const x = [`one`, `two`];\n  const y = [`one`, `three`];\n\n  const expected = [`one`, `two`, `one`, `three`];\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(Array.isArray(merged));\n});\n\ntest(`can merge sets`, (t) => {\n  const x = new Set([`one`, `two`]);\n  const y = new Set([`one`, `three`]);\n\n  const expected = new Set([`one`, `two`, `three`]);\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged instanceof Set);\n});\n\ntest(`can merge maps`, (t) => {\n  const x = new Map([\n    [\"key1\", \"value1\"],\n    [\"key2\", \"value2\"],\n  ]);\n  const y = new Map([\n    [\"key1\", \"changed\"],\n    [\"key3\", \"value3\"],\n  ]);\n\n  const expected = new Map([\n    [\"key1\", \"changed\"],\n    [\"key2\", \"value2\"],\n    [\"key3\", \"value3\"],\n  ]);\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged instanceof Map);\n});\n\ntest(`can merge array props`, (t) => {\n  const x = { a: [`one`, `two`] };\n  const y = { a: [`one`, `three`], b: [null] };\n\n  const expected = { a: [`one`, `two`, `one`, `three`], b: [null] };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(Array.isArray(merged.a));\n  t.true(Array.isArray(merged.b));\n});\n\ntest(`can merge set props`, (t) => {\n  const x = { a: new Set([`one`, `two`]) };\n  const y = { a: new Set([`one`, `three`]) };\n\n  const expected = { a: new Set([`one`, `two`, `three`]) };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged.a instanceof Set);\n});\n\ntest(`can merge map props`, (t) => {\n  const x = {\n    a: new Map([\n      [\"key1\", \"value1\"],\n      [\"key2\", \"value2\"],\n    ]),\n  };\n  const y = {\n    a: new Map([\n      [\"key1\", \"changed\"],\n      [\"key3\", \"value3\"],\n    ]),\n  };\n\n  const expected = {\n    a: new Map([\n      [\"key1\", \"changed\"],\n      [\"key2\", \"value2\"],\n      [\"key3\", \"value3\"],\n    ]),\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged.a instanceof Map);\n});\n\ntest(`works with regular expressions`, (t) => {\n  const x = { key1: /abc/u };\n  const y = { key1: /efg/u };\n\n  const expected = { key1: /efg/u };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged.key1 instanceof RegExp);\n  t.true(merged.key1.test(`efg`));\n});\n\ntest(`works with dates`, (t) => {\n  const x = { key1: new Date() };\n  const y = { key1: new Date() };\n\n  const expected = { key1: y.key1 };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged.key1 instanceof Date);\n});\n\ntest(`supports symbols`, (t) => {\n  const testSymbol1 = Symbol(\"test symbol 1\");\n  const testSymbol2 = Symbol(\"test symbol 2\");\n  const testSymbol3 = Symbol(\"test symbol 3\");\n\n  const x = { [testSymbol1]: `value1`, [testSymbol2]: `value2` };\n  const y = { [testSymbol1]: `changed`, [testSymbol3]: `value3` };\n\n  const expected = {\n    [testSymbol1]: `changed`,\n    [testSymbol2]: `value2`,\n    [testSymbol3]: `value3`,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(\n    Object.getOwnPropertySymbols(merged),\n    Object.getOwnPropertySymbols(expected)\n  );\n\n  t.deepEqual(merged[testSymbol1], expected[testSymbol1]);\n  t.deepEqual(merged[testSymbol2], expected[testSymbol2]);\n  t.deepEqual(merged[testSymbol3], expected[testSymbol3]);\n});\n\n/* eslint-disable no-proto, @typescript-eslint/naming-convention */\ntest(`merging objects with own __proto__`, (t) => {\n  const a = { key1: \"value1\" };\n  const malicious = { __proto__: { key2: \"value2\" } };\n\n  const merged = deepmerge(a, malicious);\n\n  t.false(\n    Object.prototype.hasOwnProperty.call(merged, \"__proto__\"),\n    `non-plain properties should not be merged`\n  );\n  t.false(\n    Object.prototype.hasOwnProperty.call(merged, \"key2\"),\n    `the destination should have an unmodified prototype`\n  );\n});\n/* eslint-enable no-proto, @typescript-eslint/naming-convention */\n\ntest(`merging objects with plain and non-plain properties`, (t) => {\n  const plainSymbolKey = Symbol(`plainSymbolKey`);\n  const parent = {\n    parentKey: `should be undefined`,\n  };\n\n  const x = Object.create(parent);\n  x.plainKey = `should be replaced`;\n  x[plainSymbolKey] = `should also be replaced`;\n\n  const y = {\n    plainKey: `bar`,\n    newKey: `baz`,\n    [plainSymbolKey]: `qux`,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.false(\n    Object.prototype.hasOwnProperty.call(merged, \"parentKey\"),\n    `inherited properties of target should be removed, not merged or ignored`\n  );\n  t.is(\n    merged.plainKey,\n    `bar`,\n    `enumerable own properties of target should be merged`\n  );\n  t.is(merged.newKey, `baz`, `property should be merged`);\n  t.is(\n    merged[plainSymbolKey],\n    `qux`,\n    `enumerable own symbol properties should be merged`\n  );\n});\n\ntest(`merging objects with null prototype`, (t) => {\n  const x = Object.create(null);\n  x.a = 1;\n  x.b = { c: [2] };\n\n  const y = Object.create(null);\n  y.b = { c: [3] };\n  y.d = 4;\n\n  const expected = {\n    a: 1,\n    b: {\n      c: [2, 3],\n    },\n    d: 4,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n"], "fixing_code": ["import type {\n  DeepMergeBuiltInMetaData,\n  DeepMergeHKT,\n  DeepMergeArraysDefaultHKT,\n  DeepMergeMergeFunctionsDefaultURIs,\n  DeepMergeMapsDefaultHKT,\n  DeepMergeMergeFunctionsURIs,\n  DeepMergeOptions,\n  DeepMergeRecordsDefaultHKT,\n  DeepMergeSetsDefaultHKT,\n  DeepMergeMergeFunctionUtils,\n  GetDeepMergeMergeFunctionsURIs,\n} from \"./types\";\nimport {\n  getIterableOfIterables,\n  getKeys,\n  getObjectType,\n  ObjectType,\n  objectHasProperty,\n} from \"./utils\";\n\nconst defaultMergeFunctions = {\n  mergeMaps: defaultMergeMaps,\n  mergeSets: defaultMergeSets,\n  mergeArrays: defaultMergeArrays,\n  mergeRecords: defaultMergeRecords,\n  mergeOthers: leaf,\n} as const;\n\n/**\n * Special values that tell deepmerge-ts to perform a certain action.\n */\nconst actions = {\n  defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n  skip: Symbol(\"deepmerge-ts: skip\"),\n} as const;\n\n/**\n * The default function to update meta data.\n */\nfunction defaultMetaDataUpdater<M>(\n  previousMeta: M,\n  metaMeta: DeepMergeBuiltInMetaData\n): DeepMergeBuiltInMetaData {\n  return metaMeta;\n}\n\n/**\n * The default merge functions.\n */\nexport type DeepMergeMergeFunctionsDefaults = typeof defaultMergeFunctions;\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nexport function deepmerge<Ts extends Readonly<ReadonlyArray<unknown>>>(\n  ...objects: readonly [...Ts]\n): DeepMergeHKT<\n  Ts,\n  DeepMergeMergeFunctionsDefaultURIs,\n  DeepMergeBuiltInMetaData\n> {\n  return deepmergeCustom({})(...objects) as DeepMergeHKT<\n    Ts,\n    DeepMergeMergeFunctionsDefaultURIs,\n    DeepMergeBuiltInMetaData\n  >;\n}\n\n/**\n * Deeply merge two or more objects using the given options.\n *\n * @param options - The options on how to customize the merge function.\n */\nexport function deepmergeCustom<\n  PMF extends Partial<DeepMergeMergeFunctionsURIs>\n>(\n  options: DeepMergeOptions<DeepMergeBuiltInMetaData, DeepMergeBuiltInMetaData>\n): <Ts extends ReadonlyArray<unknown>>(\n  ...objects: Ts\n) => DeepMergeHKT<\n  Ts,\n  GetDeepMergeMergeFunctionsURIs<PMF>,\n  DeepMergeBuiltInMetaData\n>;\n\n/**\n * Deeply merge two or more objects using the given options and meta data.\n *\n * @param options - The options on how to customize the merge function.\n * @param rootMetaData - The meta data passed to the root items' being merged.\n */\nexport function deepmergeCustom<\n  PMF extends Partial<DeepMergeMergeFunctionsURIs>,\n  MetaData,\n  MetaMetaData extends DeepMergeBuiltInMetaData = DeepMergeBuiltInMetaData\n>(\n  options: DeepMergeOptions<MetaData, MetaMetaData>,\n  rootMetaData?: MetaData\n): <Ts extends ReadonlyArray<unknown>>(\n  ...objects: Ts\n) => DeepMergeHKT<Ts, GetDeepMergeMergeFunctionsURIs<PMF>, MetaData>;\n\nexport function deepmergeCustom<\n  PMF extends Partial<DeepMergeMergeFunctionsURIs>,\n  MetaData,\n  MetaMetaData extends DeepMergeBuiltInMetaData\n>(\n  options: DeepMergeOptions<MetaData, MetaMetaData>,\n  rootMetaData?: MetaData\n): <Ts extends ReadonlyArray<unknown>>(\n  ...objects: Ts\n) => DeepMergeHKT<Ts, GetDeepMergeMergeFunctionsURIs<PMF>, MetaData> {\n  /**\n   * The type of the customized deepmerge function.\n   */\n  type CustomizedDeepmerge = <Ts extends ReadonlyArray<unknown>>(\n    ...objects: Ts\n  ) => DeepMergeHKT<Ts, GetDeepMergeMergeFunctionsURIs<PMF>, MetaData>;\n\n  const utils: DeepMergeMergeFunctionUtils<MetaData, MetaMetaData> = getUtils(\n    options,\n    customizedDeepmerge as CustomizedDeepmerge\n  );\n\n  /**\n   * The customized deepmerge function.\n   */\n  function customizedDeepmerge(...objects: ReadonlyArray<unknown>) {\n    return mergeUnknowns<\n      ReadonlyArray<unknown>,\n      typeof utils,\n      GetDeepMergeMergeFunctionsURIs<PMF>,\n      MetaData,\n      MetaMetaData\n    >(objects, utils, rootMetaData);\n  }\n\n  return customizedDeepmerge as CustomizedDeepmerge;\n}\n\n/**\n * The the full options with defaults apply.\n *\n * @param options - The options the user specified\n */\nfunction getUtils<M, MM extends DeepMergeBuiltInMetaData>(\n  options: DeepMergeOptions<M, MM>,\n  customizedDeepmerge: DeepMergeMergeFunctionUtils<M, MM>[\"deepmerge\"]\n): DeepMergeMergeFunctionUtils<M, MM> {\n  return {\n    defaultMergeFunctions,\n    mergeFunctions: {\n      ...defaultMergeFunctions,\n      ...Object.fromEntries(\n        Object.entries(options)\n          .filter(([key, option]) =>\n            Object.prototype.hasOwnProperty.call(defaultMergeFunctions, key)\n          )\n          .map(([key, option]) =>\n            option === false ? [key, leaf] : [key, option]\n          )\n      ),\n    } as DeepMergeMergeFunctionUtils<M, MM>[\"mergeFunctions\"],\n    metaDataUpdater: (options.metaDataUpdater ??\n      defaultMetaDataUpdater) as unknown as DeepMergeMergeFunctionUtils<\n      M,\n      MM\n    >[\"metaDataUpdater\"],\n    deepmerge: customizedDeepmerge,\n    useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n    actions,\n  };\n}\n\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns<\n  Ts extends ReadonlyArray<unknown>,\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(values: Ts, utils: U, meta: M | undefined): DeepMergeHKT<Ts, MF, M> {\n  if (values.length === 0) {\n    return undefined as DeepMergeHKT<Ts, MF, M>;\n  }\n  if (values.length === 1) {\n    return mergeOthers<U, M, MM>(values, utils, meta) as DeepMergeHKT<\n      Ts,\n      MF,\n      M\n    >;\n  }\n\n  const type = getObjectType(values[0]);\n\n  // eslint-disable-next-line functional/no-conditional-statement -- add an early escape for better performance.\n  if (type !== ObjectType.NOT && type !== ObjectType.OTHER) {\n    // eslint-disable-next-line functional/no-loop-statement -- using a loop here is more performant than mapping every value and then testing every value.\n    for (let mutableIndex = 1; mutableIndex < values.length; mutableIndex++) {\n      if (getObjectType(values[mutableIndex]) === type) {\n        continue;\n      }\n\n      return mergeOthers<U, M, MM>(values, utils, meta) as DeepMergeHKT<\n        Ts,\n        MF,\n        M\n      >;\n    }\n  }\n\n  switch (type) {\n    case ObjectType.RECORD:\n      return mergeRecords<U, MF, M, MM>(\n        values as ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    case ObjectType.ARRAY:\n      return mergeArrays<U, M, MM>(\n        values as ReadonlyArray<Readonly<ReadonlyArray<unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    case ObjectType.SET:\n      return mergeSets<U, M, MM>(\n        values as ReadonlyArray<Readonly<ReadonlySet<unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    case ObjectType.MAP:\n      return mergeMaps<U, M, MM>(\n        values as ReadonlyArray<Readonly<ReadonlyMap<unknown, unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    default:\n      return mergeOthers<U, M, MM>(values, utils, meta) as DeepMergeHKT<\n        Ts,\n        MF,\n        M\n      >;\n  }\n}\n\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeRecords !==\n        utils.defaultMergeFunctions.mergeRecords)\n  ) {\n    return utils.defaultMergeFunctions.mergeRecords<\n      ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>,\n      U,\n      MF,\n      M,\n      MM\n    >(values, utils, meta);\n  }\n\n  return result;\n}\n\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<ReadonlyArray<unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeArrays !==\n        utils.defaultMergeFunctions.mergeArrays)\n  ) {\n    return utils.defaultMergeFunctions.mergeArrays(values);\n  }\n  return result;\n}\n\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<ReadonlySet<unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)\n  ) {\n    return utils.defaultMergeFunctions.mergeSets(values);\n  }\n  return result;\n}\n\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<ReadonlyMap<unknown, unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)\n  ) {\n    return utils.defaultMergeFunctions.mergeMaps(values);\n  }\n  return result;\n}\n\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(values: ReadonlyArray<unknown>, utils: U, meta: M | undefined) {\n  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeOthers !==\n        utils.defaultMergeFunctions.mergeOthers)\n  ) {\n    return utils.defaultMergeFunctions.mergeOthers(values);\n  }\n  return result;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction defaultMergeRecords<\n  Ts extends ReadonlyArray<Record<PropertyKey, unknown>>,\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(values: Ts, utils: U, meta: M | undefined) {\n  const result: Record<PropertyKey, unknown> = {};\n\n  /* eslint-disable functional/no-loop-statement, functional/no-conditional-statement -- using a loop here is more performant. */\n\n  for (const key of getKeys(values)) {\n    const propValues = [];\n\n    for (const value of values) {\n      if (objectHasProperty(value, key)) {\n        propValues.push(value[key]);\n      }\n    }\n\n    // assert(propValues.length > 0);\n\n    const updatedMeta = utils.metaDataUpdater(meta, {\n      key,\n      parents: values,\n    } as unknown as MM);\n\n    const propertyResult = mergeUnknowns<ReadonlyArray<unknown>, U, MF, M, MM>(\n      propValues,\n      utils,\n      updatedMeta\n    );\n\n    if (propertyResult === actions.skip) {\n      continue;\n    }\n\n    if (key === \"__proto__\") {\n      Object.defineProperty(result, key, {\n        value: propertyResult,\n        configurable: true,\n        enumerable: true,\n        writable: true,\n      });\n    } else {\n      result[key] = propertyResult;\n    }\n  }\n\n  /* eslint-enable functional/no-loop-statement, functional/no-conditional-statement */\n\n  return result as DeepMergeRecordsDefaultHKT<Ts, MF, M>;\n}\n\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction defaultMergeArrays<\n  Ts extends ReadonlyArray<ReadonlyArray<unknown>>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M\n>(values: Ts) {\n  return values.flat() as DeepMergeArraysDefaultHKT<Ts, MF, M>;\n}\n\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction defaultMergeSets<\n  Ts extends ReadonlyArray<Readonly<ReadonlySet<unknown>>>\n>(values: Ts) {\n  return new Set(getIterableOfIterables(values)) as DeepMergeSetsDefaultHKT<Ts>;\n}\n\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction defaultMergeMaps<\n  Ts extends ReadonlyArray<Readonly<ReadonlyMap<unknown, unknown>>>\n>(values: Ts) {\n  return new Map(getIterableOfIterables(values)) as DeepMergeMapsDefaultHKT<Ts>;\n}\n\n/**\n * Get the last value in the given array.\n */\nfunction leaf<Ts extends ReadonlyArray<unknown>>(values: Ts) {\n  return values[values.length - 1];\n}\n", "import test from \"ava\";\n\nimport { deepmerge } from \"@/deepmerge\";\n\ntest(\"return undefined when nothing to merge\", (t) => {\n  // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n  const merged = deepmerge();\n  t.is(merged, undefined);\n});\n\ntest(\"return the same object if only 1 is passed\", (t) => {\n  const foo = { prop: 1 };\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"return the same array if only 1 is passed\", (t) => {\n  const foo = [1];\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"return the same set if only 1 is passed\", (t) => {\n  const foo = new Set([1]);\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"return the same map if only 1 is passed\", (t) => {\n  const foo = new Map([[1, 2]]);\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"return the same date if only 1 is passed\", (t) => {\n  const foo = new Date();\n  const merged = deepmerge(foo);\n  t.is(merged, foo);\n});\n\ntest(\"can merge 2 objects with different props\", (t) => {\n  const x = { first: true };\n  const y = { second: false };\n\n  const expected = {\n    first: true,\n    second: false,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(\"can merge many objects with different props\", (t) => {\n  const v = { first: true };\n  const x = { second: false };\n  const y = { third: 123 };\n  const z = { fourth: \"abc\" };\n\n  const expected = {\n    first: true,\n    second: false,\n    third: 123,\n    fourth: \"abc\",\n  };\n\n  const merged = deepmerge(v, x, y, z);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(\"can merge with same props\", (t) => {\n  const x = { key1: \"value1\", key2: \"value2\" };\n  const y = { key1: \"changed\", key3: \"value3\" };\n  const z = { key3: \"changed\", key4: \"value4\" };\n\n  const expected = {\n    key1: \"changed\",\n    key2: \"value2\",\n    key3: \"changed\",\n    key4: \"value4\",\n  };\n\n  const merged = deepmerge(x, y, z);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(\"does not clone any elements\", (t) => {\n  const x = { a: { d: 123 } };\n  const y = { b: { e: true } };\n  const z = { c: { f: \"string\" } };\n\n  const merged = deepmerge(x, y, z);\n\n  t.is(merged.a, x.a);\n  t.is(merged.b, y.b);\n  t.is(merged.c, z.c);\n});\n\ntest(\"does not mutate inputs\", (t) => {\n  const x = { a: { d: 123 } };\n  const y = { b: { e: true } };\n  const z = { c: { f: \"string\" } };\n\n  deepmerge(x, y, z);\n\n  t.deepEqual(x, { a: { d: 123 } });\n  t.deepEqual(y, { b: { e: true } });\n  t.deepEqual(z, { c: { f: \"string\" } });\n});\n\ntest(\"merging with empty object shallow clones the object\", (t) => {\n  const value = { a: { d: 123 } };\n\n  const merged = deepmerge({}, value);\n\n  t.deepEqual(merged, value);\n  t.not(merged, value, \"Value should be shallow cloned.\");\n  t.is(merged.a, value.a, \"Value should not be deep cloned.\");\n});\n\ntest(`can merge nested objects`, (t) => {\n  const x = {\n    key1: {\n      subkey1: `value1`,\n      subkey2: `value2`,\n    },\n  };\n  const y = {\n    key1: {\n      subkey1: `changed`,\n      subkey3: `added`,\n    },\n  };\n\n  const expected = {\n    key1: {\n      subkey1: `changed`,\n      subkey2: `value2`,\n      subkey3: `added`,\n    },\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(x, {\n    key1: {\n      subkey1: `value1`,\n      subkey2: `value2`,\n    },\n  });\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces simple prop with nested object`, (t) => {\n  const x = {\n    key1: `value1`,\n    key2: `value2`,\n  };\n  const y = {\n    key1: {\n      subkey1: `subvalue1`,\n      subkey2: `subvalue2`,\n    },\n  };\n\n  const expected = {\n    key1: {\n      subkey1: `subvalue1`,\n      subkey2: `subvalue2`,\n    },\n    key2: `value2`,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`should add nested object in target`, (t) => {\n  const x = {\n    a: {},\n  };\n  const y = {\n    b: {\n      c: {},\n    },\n  };\n\n  const expected = {\n    a: {},\n    b: {\n      c: {},\n    },\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.is(merged.b, y.b, \"Value should not be deep cloned.\");\n});\n\ntest(`replaces nested object with simple prop`, (t) => {\n  const x = {\n    key1: {\n      subkey1: `subvalue1`,\n      subkey2: `subvalue2`,\n    },\n    key2: `value2`,\n  };\n  const y = { key1: `value1` };\n\n  const expected = { key1: `value1`, key2: `value2` };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(x, {\n    key1: {\n      subkey1: `subvalue1`,\n      subkey2: `subvalue2`,\n    },\n    key2: `value2`,\n  });\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces records with arrays`, (t) => {\n  const x = { key1: { subkey: `one` } };\n  const y = { key1: [`subkey`] };\n\n  const expected = { key1: [`subkey`] };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces arrays with records`, (t) => {\n  const x = { key1: [`subkey`] };\n  const y = { key1: { subkey: `one` } };\n\n  const expected = { key1: { subkey: `one` } };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces dates with records`, (t) => {\n  const x = { key1: new Date() };\n  const y = { key1: { subkey: `one` } };\n\n  const expected = { key1: { subkey: `one` } };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces records with dates`, (t) => {\n  const date = new Date();\n  const x = { key1: { subkey: `one` } };\n  const y = { key1: date };\n\n  const expected = { key1: date };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces null with records`, (t) => {\n  const x = { key1: null };\n  const y = { key1: { subkey: `one` } };\n\n  const expected = { key1: { subkey: `one` } };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces records with null`, (t) => {\n  const x = { key1: { subkey: `one` } };\n  const y = { key1: null };\n\n  const expected = { key1: null };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces undefined with records`, (t) => {\n  const x = { key1: undefined };\n  const y = { key1: { subkey: `one` } };\n\n  const expected = { key1: { subkey: `one` } };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`replaces records with undefined`, (t) => {\n  const x = { key1: { subkey: `one` } };\n  const y = { key1: undefined };\n\n  const expected = { key1: undefined };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(`can merge arrays`, (t) => {\n  const x = [`one`, `two`];\n  const y = [`one`, `three`];\n\n  const expected = [`one`, `two`, `one`, `three`];\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(Array.isArray(merged));\n});\n\ntest(`can merge sets`, (t) => {\n  const x = new Set([`one`, `two`]);\n  const y = new Set([`one`, `three`]);\n\n  const expected = new Set([`one`, `two`, `three`]);\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged instanceof Set);\n});\n\ntest(`can merge maps`, (t) => {\n  const x = new Map([\n    [\"key1\", \"value1\"],\n    [\"key2\", \"value2\"],\n  ]);\n  const y = new Map([\n    [\"key1\", \"changed\"],\n    [\"key3\", \"value3\"],\n  ]);\n\n  const expected = new Map([\n    [\"key1\", \"changed\"],\n    [\"key2\", \"value2\"],\n    [\"key3\", \"value3\"],\n  ]);\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged instanceof Map);\n});\n\ntest(`can merge array props`, (t) => {\n  const x = { a: [`one`, `two`] };\n  const y = { a: [`one`, `three`], b: [null] };\n\n  const expected = { a: [`one`, `two`, `one`, `three`], b: [null] };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(Array.isArray(merged.a));\n  t.true(Array.isArray(merged.b));\n});\n\ntest(`can merge set props`, (t) => {\n  const x = { a: new Set([`one`, `two`]) };\n  const y = { a: new Set([`one`, `three`]) };\n\n  const expected = { a: new Set([`one`, `two`, `three`]) };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged.a instanceof Set);\n});\n\ntest(`can merge map props`, (t) => {\n  const x = {\n    a: new Map([\n      [\"key1\", \"value1\"],\n      [\"key2\", \"value2\"],\n    ]),\n  };\n  const y = {\n    a: new Map([\n      [\"key1\", \"changed\"],\n      [\"key3\", \"value3\"],\n    ]),\n  };\n\n  const expected = {\n    a: new Map([\n      [\"key1\", \"changed\"],\n      [\"key2\", \"value2\"],\n      [\"key3\", \"value3\"],\n    ]),\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged.a instanceof Map);\n});\n\ntest(`works with regular expressions`, (t) => {\n  const x = { key1: /abc/u };\n  const y = { key1: /efg/u };\n\n  const expected = { key1: /efg/u };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged.key1 instanceof RegExp);\n  t.true(merged.key1.test(`efg`));\n});\n\ntest(`works with dates`, (t) => {\n  const x = { key1: new Date() };\n  const y = { key1: new Date() };\n\n  const expected = { key1: y.key1 };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n  t.true(merged.key1 instanceof Date);\n});\n\ntest(`supports symbols`, (t) => {\n  const testSymbol1 = Symbol(\"test symbol 1\");\n  const testSymbol2 = Symbol(\"test symbol 2\");\n  const testSymbol3 = Symbol(\"test symbol 3\");\n\n  const x = { [testSymbol1]: `value1`, [testSymbol2]: `value2` };\n  const y = { [testSymbol1]: `changed`, [testSymbol3]: `value3` };\n\n  const expected = {\n    [testSymbol1]: `changed`,\n    [testSymbol2]: `value2`,\n    [testSymbol3]: `value3`,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(\n    Object.getOwnPropertySymbols(merged),\n    Object.getOwnPropertySymbols(expected)\n  );\n\n  t.deepEqual(merged[testSymbol1], expected[testSymbol1]);\n  t.deepEqual(merged[testSymbol2], expected[testSymbol2]);\n  t.deepEqual(merged[testSymbol3], expected[testSymbol3]);\n});\n\n/* eslint-disable no-proto, @typescript-eslint/naming-convention */\ntest(`merging objects with own __proto__`, (t) => {\n  const a = { key1: \"value1\" };\n  const malicious = { __proto__: { key2: \"value2\" } };\n\n  const merged = deepmerge(a, malicious);\n\n  t.false(\n    Object.prototype.hasOwnProperty.call(merged, \"__proto__\"),\n    `non-plain properties should not be merged`\n  );\n  t.false(\n    Object.prototype.hasOwnProperty.call(merged, \"key2\"),\n    `the destination should have an unmodified prototype`\n  );\n});\n/* eslint-enable no-proto, @typescript-eslint/naming-convention */\n\ntest(`merging objects with plain and non-plain properties`, (t) => {\n  const plainSymbolKey = Symbol(`plainSymbolKey`);\n  const parent = {\n    parentKey: `should be undefined`,\n  };\n\n  const x = Object.create(parent);\n  x.plainKey = `should be replaced`;\n  x[plainSymbolKey] = `should also be replaced`;\n\n  const y = {\n    plainKey: `bar`,\n    newKey: `baz`,\n    [plainSymbolKey]: `qux`,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.false(\n    Object.prototype.hasOwnProperty.call(merged, \"parentKey\"),\n    `inherited properties of target should be removed, not merged or ignored`\n  );\n  t.is(\n    merged.plainKey,\n    `bar`,\n    `enumerable own properties of target should be merged`\n  );\n  t.is(merged.newKey, `baz`, `property should be merged`);\n  t.is(\n    merged[plainSymbolKey],\n    `qux`,\n    `enumerable own symbol properties should be merged`\n  );\n});\n\ntest(`merging objects with null prototype`, (t) => {\n  const x = Object.create(null);\n  x.a = 1;\n  x.b = { c: [2] };\n\n  const y = Object.create(null);\n  y.b = { c: [3] };\n  y.d = 4;\n\n  const expected = {\n    a: 1,\n    b: {\n      c: [2, 3],\n    },\n    d: 4,\n  };\n\n  const merged = deepmerge(x, y);\n\n  t.deepEqual(merged, expected);\n});\n\ntest(\"prototype pollution\", (t) => {\n  const payload = '{\"__proto__\":{\"a0\":true}}';\n\n  const x: any = JSON.parse(payload);\n  const y: any = {};\n\n  const merged: any = deepmerge(x, y);\n\n  t.deepEqual(JSON.stringify(merged), payload);\n\n  t.not(({} as any).a0, true, \"Safe POJO\");\n  t.not(x.a0, true, \"Safe x input\");\n  t.not(y.a0, true, \"Safe y input\");\n  t.not(merged.a0, true, \"Safe output\");\n});\n"], "filenames": ["src/deepmerge.ts", "tests/deepmerge.test.ts"], "buggy_code_start_loc": [441, 541], "buggy_code_end_loc": [442, 541], "fixing_code_start_loc": [441, 542], "fixing_code_end_loc": [451, 558], "type": "CWE-1321", "message": "deepmerge-ts is a typescript library providing functionality to deep merging of javascript objects. deepmerge-ts is vulnerable to Prototype Pollution via file deepmerge.ts, function defaultMergeRecords(). This issue has been patched in version 4.0.2. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-24802", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-01T00:15:08.763", "lastModified": "2022-04-11T18:38:45.323", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "deepmerge-ts is a typescript library providing functionality to deep merging of javascript objects. deepmerge-ts is vulnerable to Prototype Pollution via file deepmerge.ts, function defaultMergeRecords(). This issue has been patched in version 4.0.2. There are no known workarounds for this issue."}, {"lang": "es", "value": "deepmerge-ts es una biblioteca typescript que proporciona funcionalidad para la fusi\u00f3n profunda de objetos javascript. deepmerge-ts es vulnerable a la contaminaci\u00f3n de prototipos por medio del archivo deepmerge.ts, funci\u00f3n defaultMergeRecords(). Este problema ha sido parcheado en versi\u00f3n 4.0.2. no se presentan medidas de mitigaci\u00f3n conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-915"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:deepmerge-ts_project:deepmerge-ts:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.0.2", "matchCriteriaId": "0A3F667D-3D8D-44BB-9224-DF58BF0C9AF5"}]}]}], "references": [{"url": "https://github.com/RebeccaStevens/deepmerge-ts/commit/b39f1a93d9e1c3541bd2fe159fd696a16dbe1c72", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/RebeccaStevens/deepmerge-ts/commit/d637db7e4fb2bfb113cb4bc1c85a125936d7081b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/RebeccaStevens/deepmerge-ts/security/advisories/GHSA-r9w3-g83q-m6hq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/RebeccaStevens/deepmerge-ts/commit/b39f1a93d9e1c3541bd2fe159fd696a16dbe1c72"}}