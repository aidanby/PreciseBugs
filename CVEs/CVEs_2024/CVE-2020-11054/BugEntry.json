{"buggy_code": ["# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2016-2020 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"Base class for a wrapper over QWebView/QWebEngineView.\"\"\"\n\nimport enum\nimport itertools\nimport typing\nimport functools\n\nimport attr\nfrom PyQt5.QtCore import (pyqtSignal, pyqtSlot, QUrl, QObject, QSizeF, Qt,\n                          QEvent, QPoint)\nfrom PyQt5.QtGui import QKeyEvent, QIcon\nfrom PyQt5.QtWidgets import QWidget, QApplication, QDialog\nfrom PyQt5.QtPrintSupport import QPrintDialog, QPrinter\nfrom PyQt5.QtNetwork import QNetworkAccessManager\n\nif typing.TYPE_CHECKING:\n    from PyQt5.QtWebKit import QWebHistory\n    from PyQt5.QtWebEngineWidgets import QWebEngineHistory\n\nimport pygments\nimport pygments.lexers\nimport pygments.formatters\n\nfrom qutebrowser.keyinput import modeman\nfrom qutebrowser.config import config\nfrom qutebrowser.utils import (utils, objreg, usertypes, log, qtutils,\n                               urlutils, message)\nfrom qutebrowser.misc import miscwidgets, objects, sessions\nfrom qutebrowser.browser import eventfilter\nfrom qutebrowser.qt import sip\n\nif typing.TYPE_CHECKING:\n    from qutebrowser.browser import webelem\n    from qutebrowser.browser.inspector import AbstractWebInspector\n\n\ntab_id_gen = itertools.count(0)\n\n\ndef create(win_id: int,\n           private: bool,\n           parent: QWidget = None) -> 'AbstractTab':\n    \"\"\"Get a QtWebKit/QtWebEngine tab object.\n\n    Args:\n        win_id: The window ID where the tab will be shown.\n        private: Whether the tab is a private/off the record tab.\n        parent: The Qt parent to set.\n    \"\"\"\n    # Importing modules here so we don't depend on QtWebEngine without the\n    # argument and to avoid circular imports.\n    mode_manager = modeman.instance(win_id)\n    if objects.backend == usertypes.Backend.QtWebEngine:\n        from qutebrowser.browser.webengine import webenginetab\n        tab_class = webenginetab.WebEngineTab\n    else:\n        from qutebrowser.browser.webkit import webkittab\n        tab_class = webkittab.WebKitTab\n    return tab_class(win_id=win_id, mode_manager=mode_manager, private=private,\n                     parent=parent)\n\n\ndef init() -> None:\n    \"\"\"Initialize backend-specific modules.\"\"\"\n    if objects.backend == usertypes.Backend.QtWebEngine:\n        from qutebrowser.browser.webengine import webenginetab\n        webenginetab.init()\n\n\nclass WebTabError(Exception):\n\n    \"\"\"Base class for various errors.\"\"\"\n\n\nclass UnsupportedOperationError(WebTabError):\n\n    \"\"\"Raised when an operation is not supported with the given backend.\"\"\"\n\n\nTerminationStatus = enum.Enum('TerminationStatus', [\n    'normal',\n    'abnormal',  # non-zero exit status\n    'crashed',   # e.g. segfault\n    'killed',\n    'unknown',\n])\n\n\n@attr.s\nclass TabData:\n\n    \"\"\"A simple namespace with a fixed set of attributes.\n\n    Attributes:\n        keep_icon: Whether the (e.g. cloned) icon should not be cleared on page\n                   load.\n        inspector: The QWebInspector used for this webview.\n        viewing_source: Set if we're currently showing a source view.\n                        Only used when sources are shown via pygments.\n        open_target: Where to open the next link.\n                     Only used for QtWebKit.\n        override_target: Override for open_target for fake clicks (like hints).\n                         Only used for QtWebKit.\n        pinned: Flag to pin the tab.\n        fullscreen: Whether the tab has a video shown fullscreen currently.\n        netrc_used: Whether netrc authentication was performed.\n        input_mode: current input mode for the tab.\n    \"\"\"\n\n    keep_icon = attr.ib(False)  # type: bool\n    viewing_source = attr.ib(False)  # type: bool\n    inspector = attr.ib(None)  # type: typing.Optional[AbstractWebInspector]\n    open_target = attr.ib(\n        usertypes.ClickTarget.normal)  # type: usertypes.ClickTarget\n    override_target = attr.ib(\n        None)  # type: typing.Optional[usertypes.ClickTarget]\n    pinned = attr.ib(False)  # type: bool\n    fullscreen = attr.ib(False)  # type: bool\n    netrc_used = attr.ib(False)  # type: bool\n    input_mode = attr.ib(usertypes.KeyMode.normal)  # type: usertypes.KeyMode\n    last_navigation = attr.ib(None)  # type: usertypes.NavigationRequest\n\n    def should_show_icon(self) -> bool:\n        return (config.val.tabs.favicons.show == 'always' or\n                config.val.tabs.favicons.show == 'pinned' and self.pinned)\n\n\nclass AbstractAction:\n\n    \"\"\"Attribute ``action`` of AbstractTab for Qt WebActions.\"\"\"\n\n    # The class actions are defined on (QWeb{Engine,}Page)\n    action_class = None  # type: type\n    # The type of the actions (QWeb{Engine,}Page.WebAction)\n    action_base = None  # type: type\n\n    def __init__(self, tab: 'AbstractTab') -> None:\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n\n    def exit_fullscreen(self) -> None:\n        \"\"\"Exit the fullscreen mode.\"\"\"\n        raise NotImplementedError\n\n    def save_page(self) -> None:\n        \"\"\"Save the current page.\"\"\"\n        raise NotImplementedError\n\n    def run_string(self, name: str) -> None:\n        \"\"\"Run a webaction based on its name.\"\"\"\n        member = getattr(self.action_class, name, None)\n        if not isinstance(member, self.action_base):\n            raise WebTabError(\"{} is not a valid web action!\".format(name))\n        self._widget.triggerPageAction(member)\n\n    def show_source(\n            self,\n            pygments: bool = False  # pylint: disable=redefined-outer-name\n    ) -> None:\n        \"\"\"Show the source of the current page in a new tab.\"\"\"\n        raise NotImplementedError\n\n    def _show_source_pygments(self) -> None:\n\n        def show_source_cb(source: str) -> None:\n            \"\"\"Show source as soon as it's ready.\"\"\"\n            # WORKAROUND for https://github.com/PyCQA/pylint/issues/491\n            # pylint: disable=no-member\n            lexer = pygments.lexers.HtmlLexer()\n            formatter = pygments.formatters.HtmlFormatter(\n                full=True, linenos='table')\n            # pylint: enable=no-member\n            highlighted = pygments.highlight(source, lexer, formatter)\n\n            tb = objreg.get('tabbed-browser', scope='window',\n                            window=self._tab.win_id)\n            new_tab = tb.tabopen(background=False, related=True)\n            new_tab.set_html(highlighted, self._tab.url())\n            new_tab.data.viewing_source = True\n\n        self._tab.dump_async(show_source_cb)\n\n\nclass AbstractPrinting:\n\n    \"\"\"Attribute ``printing`` of AbstractTab for printing the page.\"\"\"\n\n    def __init__(self, tab: 'AbstractTab') -> None:\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n\n    def check_pdf_support(self) -> None:\n        \"\"\"Check whether writing to PDFs is supported.\n\n        If it's not supported (by the current Qt version), a WebTabError is\n        raised.\n        \"\"\"\n        raise NotImplementedError\n\n    def check_printer_support(self) -> None:\n        \"\"\"Check whether writing to a printer is supported.\n\n        If it's not supported (by the current Qt version), a WebTabError is\n        raised.\n        \"\"\"\n        raise NotImplementedError\n\n    def check_preview_support(self) -> None:\n        \"\"\"Check whether showing a print preview is supported.\n\n        If it's not supported (by the current Qt version), a WebTabError is\n        raised.\n        \"\"\"\n        raise NotImplementedError\n\n    def to_pdf(self, filename: str) -> bool:\n        \"\"\"Print the tab to a PDF with the given filename.\"\"\"\n        raise NotImplementedError\n\n    def to_printer(self, printer: QPrinter,\n                   callback: typing.Callable[[bool], None] = None) -> None:\n        \"\"\"Print the tab.\n\n        Args:\n            printer: The QPrinter to print to.\n            callback: Called with a boolean\n                      (True if printing succeeded, False otherwise)\n        \"\"\"\n        raise NotImplementedError\n\n    def show_dialog(self) -> None:\n        \"\"\"Print with a QPrintDialog.\"\"\"\n        self.check_printer_support()\n\n        def print_callback(ok: bool) -> None:\n            \"\"\"Called when printing finished.\"\"\"\n            if not ok:\n                message.error(\"Printing failed!\")\n            diag.deleteLater()\n\n        def do_print() -> None:\n            \"\"\"Called when the dialog was closed.\"\"\"\n            self.to_printer(diag.printer(), print_callback)\n\n        diag = QPrintDialog(self._tab)\n        if utils.is_mac:\n            # For some reason we get a segfault when using open() on macOS\n            ret = diag.exec_()\n            if ret == QDialog.Accepted:\n                do_print()\n        else:\n            diag.open(do_print)\n\n\nclass AbstractSearch(QObject):\n\n    \"\"\"Attribute ``search`` of AbstractTab for doing searches.\n\n    Attributes:\n        text: The last thing this view was searched for.\n        search_displayed: Whether we're currently displaying search results in\n                          this view.\n        _flags: The flags of the last search (needs to be set by subclasses).\n        _widget: The underlying WebView widget.\n    \"\"\"\n\n    #: Signal emitted when a search was finished\n    #: (True if the text was found, False otherwise)\n    finished = pyqtSignal(bool)\n    #: Signal emitted when an existing search was cleared.\n    cleared = pyqtSignal()\n\n    _Callback = typing.Callable[[bool], None]\n\n    def __init__(self, tab: 'AbstractTab', parent: QWidget = None):\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        self.text = None  # type: typing.Optional[str]\n        self.search_displayed = False\n\n    def _is_case_sensitive(self, ignore_case: usertypes.IgnoreCase) -> bool:\n        \"\"\"Check if case-sensitivity should be used.\n\n        This assumes self.text is already set properly.\n\n        Arguments:\n            ignore_case: The ignore_case value from the config.\n        \"\"\"\n        assert self.text is not None\n        mapping = {\n            usertypes.IgnoreCase.smart: not self.text.islower(),\n            usertypes.IgnoreCase.never: True,\n            usertypes.IgnoreCase.always: False,\n        }\n        return mapping[ignore_case]\n\n    def search(self, text: str, *,\n               ignore_case: usertypes.IgnoreCase = usertypes.IgnoreCase.never,\n               reverse: bool = False,\n               wrap: bool = True,\n               result_cb: _Callback = None) -> None:\n        \"\"\"Find the given text on the page.\n\n        Args:\n            text: The text to search for.\n            ignore_case: Search case-insensitively.\n            reverse: Reverse search direction.\n            wrap: Allow wrapping at the top or bottom of the page.\n            result_cb: Called with a bool indicating whether a match was found.\n        \"\"\"\n        raise NotImplementedError\n\n    def clear(self) -> None:\n        \"\"\"Clear the current search.\"\"\"\n        raise NotImplementedError\n\n    def prev_result(self, *, result_cb: _Callback = None) -> None:\n        \"\"\"Go to the previous result of the current search.\n\n        Args:\n            result_cb: Called with a bool indicating whether a match was found.\n        \"\"\"\n        raise NotImplementedError\n\n    def next_result(self, *, result_cb: _Callback = None) -> None:\n        \"\"\"Go to the next result of the current search.\n\n        Args:\n            result_cb: Called with a bool indicating whether a match was found.\n        \"\"\"\n        raise NotImplementedError\n\n\nclass AbstractZoom(QObject):\n\n    \"\"\"Attribute ``zoom`` of AbstractTab for controlling zoom.\"\"\"\n\n    def __init__(self, tab: 'AbstractTab', parent: QWidget = None) -> None:\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        # Whether zoom was changed from the default.\n        self._default_zoom_changed = False\n        self._init_neighborlist()\n        config.instance.changed.connect(self._on_config_changed)\n        self._zoom_factor = float(config.val.zoom.default) / 100\n\n    @pyqtSlot(str)\n    def _on_config_changed(self, option: str) -> None:\n        if option in ['zoom.levels', 'zoom.default']:\n            if not self._default_zoom_changed:\n                factor = float(config.val.zoom.default) / 100\n                self.set_factor(factor)\n            self._init_neighborlist()\n\n    def _init_neighborlist(self) -> None:\n        \"\"\"Initialize self._neighborlist.\n\n        It is a NeighborList with the zoom levels.\"\"\"\n        levels = config.val.zoom.levels\n        self._neighborlist = usertypes.NeighborList(\n            levels, mode=usertypes.NeighborList.Modes.edge\n        )  # type: usertypes.NeighborList[float]\n        self._neighborlist.fuzzyval = config.val.zoom.default\n\n    def apply_offset(self, offset: int) -> float:\n        \"\"\"Increase/Decrease the zoom level by the given offset.\n\n        Args:\n            offset: The offset in the zoom level list.\n\n        Return:\n            The new zoom level.\n        \"\"\"\n        level = self._neighborlist.getitem(offset)\n        self.set_factor(float(level) / 100, fuzzyval=False)\n        return level\n\n    def _set_factor_internal(self, factor: float) -> None:\n        raise NotImplementedError\n\n    def set_factor(self, factor: float, *, fuzzyval: bool = True) -> None:\n        \"\"\"Zoom to a given zoom factor.\n\n        Args:\n            factor: The zoom factor as float.\n            fuzzyval: Whether to set the NeighborLists fuzzyval.\n        \"\"\"\n        if fuzzyval:\n            self._neighborlist.fuzzyval = int(factor * 100)\n        if factor < 0:\n            raise ValueError(\"Can't zoom to factor {}!\".format(factor))\n\n        default_zoom_factor = float(config.val.zoom.default) / 100\n        self._default_zoom_changed = (factor != default_zoom_factor)\n\n        self._zoom_factor = factor\n        self._set_factor_internal(factor)\n\n    def factor(self) -> float:\n        return self._zoom_factor\n\n    def apply_default(self) -> None:\n        self._set_factor_internal(float(config.val.zoom.default) / 100)\n\n    def reapply(self) -> None:\n        self._set_factor_internal(self._zoom_factor)\n\n\nclass AbstractCaret(QObject):\n\n    \"\"\"Attribute ``caret`` of AbstractTab for caret browsing.\"\"\"\n\n    #: Signal emitted when the selection was toggled.\n    #: (argument - whether the selection is now active)\n    selection_toggled = pyqtSignal(bool)\n    #: Emitted when a ``follow_selection`` action is done.\n    follow_selected_done = pyqtSignal()\n\n    def __init__(self,\n                 tab: 'AbstractTab',\n                 mode_manager: modeman.ModeManager,\n                 parent: QWidget = None) -> None:\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        self.selection_enabled = False\n        self._mode_manager = mode_manager\n        mode_manager.entered.connect(self._on_mode_entered)\n        mode_manager.left.connect(self._on_mode_left)\n\n    def _on_mode_entered(self, mode: usertypes.KeyMode) -> None:\n        raise NotImplementedError\n\n    def _on_mode_left(self, mode: usertypes.KeyMode) -> None:\n        raise NotImplementedError\n\n    def move_to_next_line(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_prev_line(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_next_char(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_prev_char(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_word(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_next_word(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_prev_word(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_start_of_line(self) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_line(self) -> None:\n        raise NotImplementedError\n\n    def move_to_start_of_next_block(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_start_of_prev_block(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_next_block(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_prev_block(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_start_of_document(self) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_document(self) -> None:\n        raise NotImplementedError\n\n    def toggle_selection(self) -> None:\n        raise NotImplementedError\n\n    def drop_selection(self) -> None:\n        raise NotImplementedError\n\n    def selection(self, callback: typing.Callable[[str], None]) -> None:\n        raise NotImplementedError\n\n    def reverse_selection(self) -> None:\n        raise NotImplementedError\n\n    def _follow_enter(self, tab: bool) -> None:\n        \"\"\"Follow a link by faking an enter press.\"\"\"\n        if tab:\n            self._tab.fake_key_press(Qt.Key_Enter, modifier=Qt.ControlModifier)\n        else:\n            self._tab.fake_key_press(Qt.Key_Enter)\n\n    def follow_selected(self, *, tab: bool = False) -> None:\n        raise NotImplementedError\n\n\nclass AbstractScroller(QObject):\n\n    \"\"\"Attribute ``scroller`` of AbstractTab to manage scroll position.\"\"\"\n\n    #: Signal emitted when the scroll position changed (int, int)\n    perc_changed = pyqtSignal(int, int)\n    #: Signal emitted before the user requested a jump.\n    #: Used to set the special ' mark so the user can return.\n    before_jump_requested = pyqtSignal()\n\n    def __init__(self, tab: 'AbstractTab', parent: QWidget = None):\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        if 'log-scroll-pos' in objects.debug_flags:\n            self.perc_changed.connect(self._log_scroll_pos_change)\n\n    @pyqtSlot()\n    def _log_scroll_pos_change(self) -> None:\n        log.webview.vdebug(  # type: ignore\n            \"Scroll position changed to {}\".format(self.pos_px()))\n\n    def _init_widget(self, widget: QWidget) -> None:\n        self._widget = widget\n\n    def pos_px(self) -> int:\n        raise NotImplementedError\n\n    def pos_perc(self) -> int:\n        raise NotImplementedError\n\n    def to_perc(self, x: int = None, y: int = None) -> None:\n        raise NotImplementedError\n\n    def to_point(self, point: QPoint) -> None:\n        raise NotImplementedError\n\n    def to_anchor(self, name: str) -> None:\n        raise NotImplementedError\n\n    def delta(self, x: int = 0, y: int = 0) -> None:\n        raise NotImplementedError\n\n    def delta_page(self, x: float = 0, y: float = 0) -> None:\n        raise NotImplementedError\n\n    def up(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def down(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def left(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def right(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def top(self) -> None:\n        raise NotImplementedError\n\n    def bottom(self) -> None:\n        raise NotImplementedError\n\n    def page_up(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def page_down(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def at_top(self) -> bool:\n        raise NotImplementedError\n\n    def at_bottom(self) -> bool:\n        raise NotImplementedError\n\n\nclass AbstractHistoryPrivate:\n\n    \"\"\"Private API related to the history.\"\"\"\n\n    def __init__(self, tab: 'AbstractTab'):\n        self._tab = tab\n        self._history = typing.cast(\n            typing.Union['QWebHistory', 'QWebEngineHistory'], None)\n\n    def serialize(self) -> bytes:\n        \"\"\"Serialize into an opaque format understood by self.deserialize.\"\"\"\n        raise NotImplementedError\n\n    def deserialize(self, data: bytes) -> None:\n        \"\"\"Deserialize from a format produced by self.serialize.\"\"\"\n        raise NotImplementedError\n\n    def load_items(self, items: typing.Sequence) -> None:\n        \"\"\"Deserialize from a list of WebHistoryItems.\"\"\"\n        raise NotImplementedError\n\n\nclass AbstractHistory:\n\n    \"\"\"The history attribute of a AbstractTab.\"\"\"\n\n    def __init__(self, tab: 'AbstractTab') -> None:\n        self._tab = tab\n        self._history = typing.cast(\n            typing.Union['QWebHistory', 'QWebEngineHistory'], None)\n        self.private_api = AbstractHistoryPrivate(tab)\n\n    def __len__(self) -> int:\n        raise NotImplementedError\n\n    def __iter__(self) -> typing.Iterable:\n        raise NotImplementedError\n\n    def _check_count(self, count: int) -> None:\n        \"\"\"Check whether the count is positive.\"\"\"\n        if count < 0:\n            raise WebTabError(\"count needs to be positive!\")\n\n    def current_idx(self) -> int:\n        raise NotImplementedError\n\n    def back(self, count: int = 1) -> None:\n        \"\"\"Go back in the tab's history.\"\"\"\n        self._check_count(count)\n        idx = self.current_idx() - count\n        if idx >= 0:\n            self._go_to_item(self._item_at(idx))\n        else:\n            self._go_to_item(self._item_at(0))\n            raise WebTabError(\"At beginning of history.\")\n\n    def forward(self, count: int = 1) -> None:\n        \"\"\"Go forward in the tab's history.\"\"\"\n        self._check_count(count)\n        idx = self.current_idx() + count\n        if idx < len(self):\n            self._go_to_item(self._item_at(idx))\n        else:\n            self._go_to_item(self._item_at(len(self) - 1))\n            raise WebTabError(\"At end of history.\")\n\n    def can_go_back(self) -> bool:\n        raise NotImplementedError\n\n    def can_go_forward(self) -> bool:\n        raise NotImplementedError\n\n    def _item_at(self, i: int) -> typing.Any:\n        raise NotImplementedError\n\n    def _go_to_item(self, item: typing.Any) -> None:\n        raise NotImplementedError\n\n\nclass AbstractElements:\n\n    \"\"\"Finding and handling of elements on the page.\"\"\"\n\n    _MultiCallback = typing.Callable[\n        [typing.Sequence['webelem.AbstractWebElement']], None]\n    _SingleCallback = typing.Callable[\n        [typing.Optional['webelem.AbstractWebElement']], None]\n    _ErrorCallback = typing.Callable[[Exception], None]\n\n    def __init__(self, tab: 'AbstractTab') -> None:\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n\n    def find_css(self, selector: str,\n                 callback: _MultiCallback,\n                 error_cb: _ErrorCallback, *,\n                 only_visible: bool = False) -> None:\n        \"\"\"Find all HTML elements matching a given selector async.\n\n        If there's an error, the callback is called with a webelem.Error\n        instance.\n\n        Args:\n            callback: The callback to be called when the search finished.\n            error_cb: The callback to be called when an error occurred.\n            selector: The CSS selector to search for.\n            only_visible: Only show elements which are visible on screen.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_id(self, elem_id: str, callback: _SingleCallback) -> None:\n        \"\"\"Find the HTML element with the given ID async.\n\n        Args:\n            callback: The callback to be called when the search finished.\n                      Called with a WebEngineElement or None.\n            elem_id: The ID to search for.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_focused(self, callback: _SingleCallback) -> None:\n        \"\"\"Find the focused element on the page async.\n\n        Args:\n            callback: The callback to be called when the search finished.\n                      Called with a WebEngineElement or None.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_at_pos(self, pos: QPoint, callback: _SingleCallback) -> None:\n        \"\"\"Find the element at the given position async.\n\n        This is also called \"hit test\" elsewhere.\n\n        Args:\n            pos: The QPoint to get the element for.\n            callback: The callback to be called when the search finished.\n                      Called with a WebEngineElement or None.\n        \"\"\"\n        raise NotImplementedError\n\n\nclass AbstractAudio(QObject):\n\n    \"\"\"Handling of audio/muting for this tab.\"\"\"\n\n    muted_changed = pyqtSignal(bool)\n    recently_audible_changed = pyqtSignal(bool)\n\n    def __init__(self, tab: 'AbstractTab', parent: QWidget = None) -> None:\n        super().__init__(parent)\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n\n    def set_muted(self, muted: bool, override: bool = False) -> None:\n        \"\"\"Set this tab as muted or not.\n\n        Arguments:\n            override: If set to True, muting/unmuting was done manually and\n                      overrides future automatic mute/unmute changes based on\n                      the URL.\n        \"\"\"\n        raise NotImplementedError\n\n    def is_muted(self) -> bool:\n        raise NotImplementedError\n\n    def is_recently_audible(self) -> bool:\n        \"\"\"Whether this tab has had audio playing recently.\"\"\"\n        raise NotImplementedError\n\n\nclass AbstractTabPrivate:\n\n    \"\"\"Tab-related methods which are only needed in the core.\n\n    Those methods are not part of the API which is exposed to extensions, and\n    should ideally be removed at some point in the future.\n    \"\"\"\n\n    def __init__(self, mode_manager: modeman.ModeManager,\n                 tab: 'AbstractTab') -> None:\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n        self._mode_manager = mode_manager\n\n    def event_target(self) -> QWidget:\n        \"\"\"Return the widget events should be sent to.\"\"\"\n        raise NotImplementedError\n\n    def handle_auto_insert_mode(self, ok: bool) -> None:\n        \"\"\"Handle `input.insert_mode.auto_load` after loading finished.\"\"\"\n        if not ok or not config.cache['input.insert_mode.auto_load']:\n            return\n\n        cur_mode = self._mode_manager.mode\n        if cur_mode == usertypes.KeyMode.insert:\n            return\n\n        def _auto_insert_mode_cb(\n                elem: typing.Optional['webelem.AbstractWebElement']\n        ) -> None:\n            \"\"\"Called from JS after finding the focused element.\"\"\"\n            if elem is None:\n                log.webview.debug(\"No focused element!\")\n                return\n            if elem.is_editable():\n                modeman.enter(self._tab.win_id, usertypes.KeyMode.insert,\n                              'load finished', only_if_normal=True)\n\n        self._tab.elements.find_focused(_auto_insert_mode_cb)\n\n    def clear_ssl_errors(self) -> None:\n        raise NotImplementedError\n\n    def networkaccessmanager(self) -> typing.Optional[QNetworkAccessManager]:\n        \"\"\"Get the QNetworkAccessManager for this tab.\n\n        This is only implemented for QtWebKit.\n        For QtWebEngine, always returns None.\n        \"\"\"\n        raise NotImplementedError\n\n    def shutdown(self) -> None:\n        raise NotImplementedError\n\n\nclass AbstractTab(QWidget):\n\n    \"\"\"An adapter for QWebView/QWebEngineView representing a single tab.\"\"\"\n\n    #: Signal emitted when a website requests to close this tab.\n    window_close_requested = pyqtSignal()\n    #: Signal emitted when a link is hovered (the hover text)\n    link_hovered = pyqtSignal(str)\n    #: Signal emitted when a page started loading\n    load_started = pyqtSignal()\n    #: Signal emitted when a page is loading (progress percentage)\n    load_progress = pyqtSignal(int)\n    #: Signal emitted when a page finished loading (success as bool)\n    load_finished = pyqtSignal(bool)\n    #: Signal emitted when a page's favicon changed (icon as QIcon)\n    icon_changed = pyqtSignal(QIcon)\n    #: Signal emitted when a page's title changed (new title as str)\n    title_changed = pyqtSignal(str)\n    #: Signal emitted when a new tab should be opened (url as QUrl)\n    new_tab_requested = pyqtSignal(QUrl)\n    #: Signal emitted when a page's URL changed (url as QUrl)\n    url_changed = pyqtSignal(QUrl)\n    #: Signal emitted when a tab's content size changed\n    #: (new size as QSizeF)\n    contents_size_changed = pyqtSignal(QSizeF)\n    #: Signal emitted when a page requested full-screen (bool)\n    fullscreen_requested = pyqtSignal(bool)\n    #: Signal emitted before load starts (URL as QUrl)\n    before_load_started = pyqtSignal(QUrl)\n\n    # Signal emitted when a page's load status changed\n    # (argument: usertypes.LoadStatus)\n    load_status_changed = pyqtSignal(usertypes.LoadStatus)\n    # Signal emitted before shutting down\n    shutting_down = pyqtSignal()\n    # Signal emitted when a history item should be added\n    history_item_triggered = pyqtSignal(QUrl, QUrl, str)\n    # Signal emitted when the underlying renderer process terminated.\n    # arg 0: A TerminationStatus member.\n    # arg 1: The exit code.\n    renderer_process_terminated = pyqtSignal(TerminationStatus, int)\n\n    def __init__(self, *, win_id: int, private: bool,\n                 parent: QWidget = None) -> None:\n        self.is_private = private\n        self.win_id = win_id\n        self.tab_id = next(tab_id_gen)\n        super().__init__(parent)\n\n        self.registry = objreg.ObjectRegistry()\n        tab_registry = objreg.get('tab-registry', scope='window',\n                                  window=win_id)\n        tab_registry[self.tab_id] = self\n        objreg.register('tab', self, registry=self.registry)\n\n        self.data = TabData()\n        self._layout = miscwidgets.WrapperLayout(self)\n        self._widget = typing.cast(QWidget, None)\n        self._progress = 0\n        self._has_ssl_errors = False\n        self._load_status = usertypes.LoadStatus.none\n        self._tab_event_filter = eventfilter.TabEventFilter(\n            self, parent=self)\n        self.backend = None  # type: typing.Optional[usertypes.Backend]\n\n        # If true, this tab has been requested to be removed (or is removed).\n        self.pending_removal = False\n        self.shutting_down.connect(functools.partial(\n            setattr, self, 'pending_removal', True))\n\n        self.before_load_started.connect(self._on_before_load_started)\n\n    def _set_widget(self, widget: QWidget) -> None:\n        # pylint: disable=protected-access\n        self._widget = widget\n        self._layout.wrap(self, widget)\n        self.history._history = widget.history()\n        self.history.private_api._history = widget.history()\n        self.scroller._init_widget(widget)\n        self.caret._widget = widget\n        self.zoom._widget = widget\n        self.search._widget = widget\n        self.printing._widget = widget\n        self.action._widget = widget\n        self.elements._widget = widget\n        self.audio._widget = widget\n        self.private_api._widget = widget\n        self.settings._settings = widget.settings()\n\n        self._install_event_filter()\n        self.zoom.apply_default()\n\n    def _install_event_filter(self) -> None:\n        raise NotImplementedError\n\n    def _set_load_status(self, val: usertypes.LoadStatus) -> None:\n        \"\"\"Setter for load_status.\"\"\"\n        if not isinstance(val, usertypes.LoadStatus):\n            raise TypeError(\"Type {} is no LoadStatus member!\".format(val))\n        log.webview.debug(\"load status for {}: {}\".format(repr(self), val))\n        self._load_status = val\n        self.load_status_changed.emit(val)\n\n    def send_event(self, evt: QEvent) -> None:\n        \"\"\"Send the given event to the underlying widget.\n\n        The event will be sent via QApplication.postEvent.\n        Note that a posted event must not be re-used in any way!\n        \"\"\"\n        # This only gives us some mild protection against re-using events, but\n        # it's certainly better than a segfault.\n        if getattr(evt, 'posted', False):\n            raise utils.Unreachable(\"Can't re-use an event which was already \"\n                                    \"posted!\")\n\n        recipient = self.private_api.event_target()\n        if recipient is None:\n            # https://github.com/qutebrowser/qutebrowser/issues/3888\n            log.webview.warning(\"Unable to find event target!\")\n            return\n\n        evt.posted = True\n        QApplication.postEvent(recipient, evt)\n\n    def navigation_blocked(self) -> bool:\n        \"\"\"Test if navigation is allowed on the current tab.\"\"\"\n        return self.data.pinned and config.val.tabs.pinned.frozen\n\n    @pyqtSlot(QUrl)\n    def _on_before_load_started(self, url: QUrl) -> None:\n        \"\"\"Adjust the title if we are going to visit a URL soon.\"\"\"\n        qtutils.ensure_valid(url)\n        url_string = url.toDisplayString()\n        log.webview.debug(\"Going to start loading: {}\".format(url_string))\n        self.title_changed.emit(url_string)\n\n    @pyqtSlot(QUrl)\n    def _on_url_changed(self, url: QUrl) -> None:\n        \"\"\"Update title when URL has changed and no title is available.\"\"\"\n        if url.isValid() and not self.title():\n            self.title_changed.emit(url.toDisplayString())\n        self.url_changed.emit(url)\n\n    @pyqtSlot()\n    def _on_load_started(self) -> None:\n        self._progress = 0\n        self._has_ssl_errors = False\n        self.data.viewing_source = False\n        self._set_load_status(usertypes.LoadStatus.loading)\n        self.load_started.emit()\n\n    @pyqtSlot(usertypes.NavigationRequest)\n    def _on_navigation_request(\n            self,\n            navigation: usertypes.NavigationRequest\n    ) -> None:\n        \"\"\"Handle common acceptNavigationRequest code.\"\"\"\n        url = utils.elide(navigation.url.toDisplayString(), 100)\n        log.webview.debug(\"navigation request: url {}, type {}, is_main_frame \"\n                          \"{}\".format(url,\n                                      navigation.navigation_type,\n                                      navigation.is_main_frame))\n\n        if navigation.is_main_frame:\n            self.data.last_navigation = navigation\n\n        if not navigation.url.isValid():\n            # Also a WORKAROUND for missing IDNA 2008 support in QUrl, see\n            # https://bugreports.qt.io/browse/QTBUG-60364\n\n            if navigation.navigation_type == navigation.Type.link_clicked:\n                msg = urlutils.get_errstring(navigation.url,\n                                             \"Invalid link clicked\")\n                message.error(msg)\n                self.data.open_target = usertypes.ClickTarget.normal\n\n            log.webview.debug(\"Ignoring invalid URL {} in \"\n                              \"acceptNavigationRequest: {}\".format(\n                                  navigation.url.toDisplayString(),\n                                  navigation.url.errorString()))\n            navigation.accepted = False\n\n    @pyqtSlot(bool)\n    def _on_load_finished(self, ok: bool) -> None:\n        assert self._widget is not None\n        if sip.isdeleted(self._widget):\n            # https://github.com/qutebrowser/qutebrowser/issues/3498\n            return\n\n        if sessions.session_manager is not None:\n            sessions.session_manager.save_autosave()\n\n        self.load_finished.emit(ok)\n\n        if not self.title():\n            self.title_changed.emit(self.url().toDisplayString())\n\n        self.zoom.reapply()\n\n    def _update_load_status(self, ok: bool) -> None:\n        \"\"\"Update the load status after a page finished loading.\n\n        Needs to be called by subclasses to trigger a load status update, e.g.\n        as a response to a loadFinished signal.\n        \"\"\"\n        if ok and not self._has_ssl_errors:\n            if self.url().scheme() == 'https':\n                self._set_load_status(usertypes.LoadStatus.success_https)\n            else:\n                self._set_load_status(usertypes.LoadStatus.success)\n        elif ok:\n            self._set_load_status(usertypes.LoadStatus.warn)\n        else:\n            self._set_load_status(usertypes.LoadStatus.error)\n\n    @pyqtSlot()\n    def _on_history_trigger(self) -> None:\n        \"\"\"Emit history_item_triggered based on backend-specific signal.\"\"\"\n        raise NotImplementedError\n\n    @pyqtSlot(int)\n    def _on_load_progress(self, perc: int) -> None:\n        self._progress = perc\n        self.load_progress.emit(perc)\n\n    def url(self, *, requested: bool = False) -> QUrl:\n        raise NotImplementedError\n\n    def progress(self) -> int:\n        return self._progress\n\n    def load_status(self) -> usertypes.LoadStatus:\n        return self._load_status\n\n    def _load_url_prepare(self, url: QUrl, *,\n                          emit_before_load_started: bool = True) -> None:\n        qtutils.ensure_valid(url)\n        if emit_before_load_started:\n            self.before_load_started.emit(url)\n\n    def load_url(self, url: QUrl, *,\n                 emit_before_load_started: bool = True) -> None:\n        raise NotImplementedError\n\n    def reload(self, *, force: bool = False) -> None:\n        raise NotImplementedError\n\n    def stop(self) -> None:\n        raise NotImplementedError\n\n    def fake_key_press(self,\n                       key: Qt.Key,\n                       modifier: Qt.KeyboardModifier = Qt.NoModifier) -> None:\n        \"\"\"Send a fake key event to this tab.\"\"\"\n        press_evt = QKeyEvent(QEvent.KeyPress, key, modifier, 0, 0, 0)\n        release_evt = QKeyEvent(QEvent.KeyRelease, key, modifier,\n                                0, 0, 0)\n        self.send_event(press_evt)\n        self.send_event(release_evt)\n\n    def dump_async(self,\n                   callback: typing.Callable[[str], None], *,\n                   plain: bool = False) -> None:\n        \"\"\"Dump the current page's html asynchronously.\n\n        The given callback will be called with the result when dumping is\n        complete.\n        \"\"\"\n        raise NotImplementedError\n\n    def run_js_async(\n            self,\n            code: str,\n            callback: typing.Callable[[typing.Any], None] = None, *,\n            world: typing.Union[usertypes.JsWorld, int] = None\n    ) -> None:\n        \"\"\"Run javascript async.\n\n        The given callback will be called with the result when running JS is\n        complete.\n\n        Args:\n            code: The javascript code to run.\n            callback: The callback to call with the result, or None.\n            world: A world ID (int or usertypes.JsWorld member) to run the JS\n                   in the main world or in another isolated world.\n        \"\"\"\n        raise NotImplementedError\n\n    def title(self) -> str:\n        raise NotImplementedError\n\n    def icon(self) -> None:\n        raise NotImplementedError\n\n    def set_html(self, html: str, base_url: QUrl = QUrl()) -> None:\n        raise NotImplementedError\n\n    def __repr__(self) -> str:\n        try:\n            qurl = self.url()\n            url = qurl.toDisplayString(QUrl.EncodeUnicode)  # type: ignore\n        except (AttributeError, RuntimeError) as exc:\n            url = '<{}>'.format(exc.__class__.__name__)\n        else:\n            url = utils.elide(url, 100)\n        return utils.get_repr(self, tab_id=self.tab_id, url=url)\n\n    def is_deleted(self) -> bool:\n        assert self._widget is not None\n        return sip.isdeleted(self._widget)\n", "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2016-2020 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"Wrapper over a QWebEngineView.\"\"\"\n\nimport math\nimport functools\nimport re\nimport html as html_utils\nimport typing\n\nfrom PyQt5.QtCore import (pyqtSignal, pyqtSlot, Qt, QPoint, QPointF, QUrl,\n                          QTimer, QObject)\nfrom PyQt5.QtNetwork import QAuthenticator\nfrom PyQt5.QtWidgets import QApplication, QWidget\nfrom PyQt5.QtWebEngineWidgets import QWebEnginePage, QWebEngineScript\n\nfrom qutebrowser.config import configdata, config\nfrom qutebrowser.browser import (browsertab, eventfilter, shared, webelem,\n                                 history, greasemonkey)\nfrom qutebrowser.browser.webengine import (webview, webengineelem, tabhistory,\n                                           interceptor, webenginequtescheme,\n                                           cookies, webenginedownloads,\n                                           webenginesettings, certificateerror)\nfrom qutebrowser.misc import miscwidgets, objects\nfrom qutebrowser.utils import (usertypes, qtutils, log, javascript, utils,\n                               message, objreg, jinja, debug)\nfrom qutebrowser.qt import sip\n\n\n_qute_scheme_handler = None\n\n\ndef init():\n    \"\"\"Initialize QtWebEngine-specific modules.\"\"\"\n    # For some reason we need to keep a reference, otherwise the scheme handler\n    # won't work...\n    # https://www.riverbankcomputing.com/pipermail/pyqt/2016-September/038075.html\n    global _qute_scheme_handler\n\n    app = QApplication.instance()\n    log.init.debug(\"Initializing qute://* handler...\")\n    _qute_scheme_handler = webenginequtescheme.QuteSchemeHandler(parent=app)\n    _qute_scheme_handler.install(webenginesettings.default_profile)\n    if webenginesettings.private_profile:\n        _qute_scheme_handler.install(webenginesettings.private_profile)\n\n    log.init.debug(\"Initializing request interceptor...\")\n    req_interceptor = interceptor.RequestInterceptor(parent=app)\n    req_interceptor.install(webenginesettings.default_profile)\n    if webenginesettings.private_profile:\n        req_interceptor.install(webenginesettings.private_profile)\n\n    log.init.debug(\"Initializing QtWebEngine downloads...\")\n    download_manager = webenginedownloads.DownloadManager(parent=app)\n    download_manager.install(webenginesettings.default_profile)\n    if webenginesettings.private_profile:\n        download_manager.install(webenginesettings.private_profile)\n    objreg.register('webengine-download-manager', download_manager)\n\n    log.init.debug(\"Initializing cookie filter...\")\n    cookies.install_filter(webenginesettings.default_profile)\n    if webenginesettings.private_profile:\n        cookies.install_filter(webenginesettings.private_profile)\n\n    # Clear visited links on web history clear\n    for p in [webenginesettings.default_profile,\n              webenginesettings.private_profile]:\n        if not p:\n            continue\n        history.web_history.history_cleared.connect(p.clearAllVisitedLinks)\n        history.web_history.url_cleared.connect(\n            lambda url, profile=p: profile.clearVisitedLinks([url]))\n\n\n# Mapping worlds from usertypes.JsWorld to QWebEngineScript world IDs.\n_JS_WORLD_MAP = {\n    usertypes.JsWorld.main: QWebEngineScript.MainWorld,\n    usertypes.JsWorld.application: QWebEngineScript.ApplicationWorld,\n    usertypes.JsWorld.user: QWebEngineScript.UserWorld,\n    usertypes.JsWorld.jseval: QWebEngineScript.UserWorld + 1,\n}\n\n\nclass WebEngineAction(browsertab.AbstractAction):\n\n    \"\"\"QtWebEngine implementations related to web actions.\"\"\"\n\n    action_class = QWebEnginePage\n    action_base = QWebEnginePage.WebAction\n\n    def exit_fullscreen(self):\n        self._widget.triggerPageAction(QWebEnginePage.ExitFullScreen)\n\n    def save_page(self):\n        \"\"\"Save the current page.\"\"\"\n        self._widget.triggerPageAction(QWebEnginePage.SavePage)\n\n    def show_source(self, pygments=False):\n        if pygments:\n            self._show_source_pygments()\n            return\n\n        try:\n            self._widget.triggerPageAction(QWebEnginePage.ViewSource)\n        except AttributeError:\n            # Qt < 5.8\n            tb = objreg.get('tabbed-browser', scope='window',\n                            window=self._tab.win_id)\n            urlstr = self._tab.url().toString(\n                QUrl.RemoveUserInfo)  # type: ignore\n            # The original URL becomes the path of a view-source: URL\n            # (without a host), but query/fragment should stay.\n            url = QUrl('view-source:' + urlstr)\n            tb.tabopen(url, background=False, related=True)\n\n\nclass WebEnginePrinting(browsertab.AbstractPrinting):\n\n    \"\"\"QtWebEngine implementations related to printing.\"\"\"\n\n    def check_pdf_support(self):\n        pass\n\n    def check_printer_support(self):\n        if not hasattr(self._widget.page(), 'print'):\n            raise browsertab.WebTabError(\n                \"Printing is unsupported with QtWebEngine on Qt < 5.8\")\n\n    def check_preview_support(self):\n        raise browsertab.WebTabError(\n            \"Print previews are unsupported with QtWebEngine\")\n\n    def to_pdf(self, filename):\n        self._widget.page().printToPdf(filename)\n\n    def to_printer(self, printer, callback=None):\n        if callback is None:\n            callback = lambda _ok: None\n        self._widget.page().print(printer, callback)\n\n\nclass _WebEngineSearchWrapHandler:\n\n    \"\"\"QtWebEngine implementations related to wrapping when searching.\n\n    Attributes:\n        flag_wrap: An additional flag indicating whether the last search\n                   used wrapping.\n        _active_match: The 1-based index of the currently active match\n                       on the page.\n        _total_matches: The total number of search matches on the page.\n        _nowrap_available: Whether the functionality to prevent wrapping\n                           is available.\n    \"\"\"\n\n    def __init__(self):\n        self._active_match = 0\n        self._total_matches = 0\n        self.flag_wrap = True\n        self._nowrap_available = False\n\n    def connect_signal(self, page):\n        \"\"\"Connect to the findTextFinished signal of the page.\n\n        Args:\n            page: The QtWebEnginePage to connect to this handler.\n        \"\"\"\n        if qtutils.version_check(\"5.14\"):\n            page.findTextFinished.connect(self._store_match_data)\n            self._nowrap_available = True\n\n    def _store_match_data(self, result):\n        \"\"\"Store information on the last match.\n\n        The information will be checked against when wrapping is turned off.\n\n        Args:\n            result: A FindTextResult passed by the findTextFinished signal.\n        \"\"\"\n        self._active_match = result.activeMatch()\n        self._total_matches = result.numberOfMatches()\n        log.webview.debug(\"Active search match: {}/{}\"\n                          .format(self._active_match, self._total_matches))\n\n    def reset_match_data(self):\n        \"\"\"Reset match information.\n\n        Stale information could lead to next_result or prev_result misbehaving.\n        \"\"\"\n        self._active_match = 0\n        self._total_matches = 0\n\n    def prevent_wrapping(self, *, going_up):\n        \"\"\"Prevent wrapping if possible and required.\n\n        Returns True if a wrap was prevented and False if not.\n\n        Args:\n            going_up: Whether the search would scroll the page up or down.\n        \"\"\"\n        if (not self._nowrap_available or\n                self.flag_wrap or self._total_matches == 0):\n            return False\n        elif going_up and self._active_match == 1:\n            message.info(\"Search hit TOP\")\n            return True\n        elif not going_up and self._active_match == self._total_matches:\n            message.info(\"Search hit BOTTOM\")\n            return True\n        else:\n            return False\n\n\nclass WebEngineSearch(browsertab.AbstractSearch):\n\n    \"\"\"QtWebEngine implementations related to searching on the page.\n\n    Attributes:\n        _flags: The QWebEnginePage.FindFlags of the last search.\n        _pending_searches: How many searches have been started but not called\n                           back yet.\n    \"\"\"\n\n    def __init__(self, tab, parent=None):\n        super().__init__(tab, parent)\n        self._flags = QWebEnginePage.FindFlags(0)  # type: ignore\n        self._pending_searches = 0\n        # The API necessary to stop wrapping was added in this version\n        self._wrap_handler = _WebEngineSearchWrapHandler()\n\n    def connect_signals(self):\n        self._wrap_handler.connect_signal(self._widget.page())\n\n    def _find(self, text, flags, callback, caller):\n        \"\"\"Call findText on the widget.\"\"\"\n        self.search_displayed = True\n        self._pending_searches += 1\n\n        def wrapped_callback(found):\n            \"\"\"Wrap the callback to do debug logging.\"\"\"\n            self._pending_searches -= 1\n            if self._pending_searches > 0:\n                # See https://github.com/qutebrowser/qutebrowser/issues/2442\n                # and https://github.com/qt/qtwebengine/blob/5.10/src/core/web_contents_adapter.cpp#L924-L934\n                log.webview.debug(\"Ignoring cancelled search callback with \"\n                                  \"{} pending searches\".format(\n                                      self._pending_searches))\n                return\n\n            if sip.isdeleted(self._widget):\n                # This happens when starting a search, and closing the tab\n                # before results arrive.\n                log.webview.debug(\"Ignoring finished search for deleted \"\n                                  \"widget\")\n                return\n\n            found_text = 'found' if found else \"didn't find\"\n            if flags:\n                flag_text = 'with flags {}'.format(debug.qflags_key(\n                    QWebEnginePage, flags, klass=QWebEnginePage.FindFlag))\n            else:\n                flag_text = ''\n            log.webview.debug(' '.join([caller, found_text, text, flag_text])\n                              .strip())\n\n            if callback is not None:\n                callback(found)\n            self.finished.emit(found)\n\n        self._widget.page().findText(text, flags, wrapped_callback)\n\n    def search(self, text, *, ignore_case=usertypes.IgnoreCase.never,\n               reverse=False, wrap=True, result_cb=None):\n        # Don't go to next entry on duplicate search\n        if self.text == text and self.search_displayed:\n            log.webview.debug(\"Ignoring duplicate search request\"\n                              \" for {}\".format(text))\n            return\n\n        self.text = text\n        self._flags = QWebEnginePage.FindFlags(0)  # type: ignore\n        self._wrap_handler.reset_match_data()\n        self._wrap_handler.flag_wrap = wrap\n        if self._is_case_sensitive(ignore_case):\n            self._flags |= QWebEnginePage.FindCaseSensitively\n        if reverse:\n            self._flags |= QWebEnginePage.FindBackward\n\n        self._find(text, self._flags, result_cb, 'search')\n\n    def clear(self):\n        if self.search_displayed:\n            self.cleared.emit()\n        self.search_displayed = False\n        self._wrap_handler.reset_match_data()\n        self._widget.page().findText('')\n\n    def prev_result(self, *, result_cb=None):\n        # The int() here makes sure we get a copy of the flags.\n        flags = QWebEnginePage.FindFlags(int(self._flags))  # type: ignore\n        if flags & QWebEnginePage.FindBackward:\n            if self._wrap_handler.prevent_wrapping(going_up=False):\n                return\n            flags &= ~QWebEnginePage.FindBackward\n        else:\n            if self._wrap_handler.prevent_wrapping(going_up=True):\n                return\n            flags |= QWebEnginePage.FindBackward\n        self._find(self.text, flags, result_cb, 'prev_result')\n\n    def next_result(self, *, result_cb=None):\n        going_up = self._flags & QWebEnginePage.FindBackward\n        if self._wrap_handler.prevent_wrapping(going_up=going_up):\n            return\n        self._find(self.text, self._flags, result_cb, 'next_result')\n\n\nclass WebEngineCaret(browsertab.AbstractCaret):\n\n    \"\"\"QtWebEngine implementations related to moving the cursor/selection.\"\"\"\n\n    def _flags(self):\n        \"\"\"Get flags to pass to JS.\"\"\"\n        flags = set()\n        if qtutils.version_check('5.7.1', compiled=False):\n            flags.add('filter-prefix')\n        if utils.is_windows:\n            flags.add('windows')\n        return list(flags)\n\n    @pyqtSlot(usertypes.KeyMode)\n    def _on_mode_entered(self, mode):\n        if mode != usertypes.KeyMode.caret:\n            return\n\n        if self._tab.search.search_displayed:\n            # We are currently in search mode.\n            # convert the search to a blue selection so we can operate on it\n            # https://bugreports.qt.io/browse/QTBUG-60673\n            self._tab.search.clear()\n\n        self._tab.run_js_async(\n            javascript.assemble('caret', 'setFlags', self._flags()))\n\n        self._js_call('setInitialCursor', callback=self._selection_cb)\n\n    def _selection_cb(self, enabled):\n        \"\"\"Emit selection_toggled based on setInitialCursor.\"\"\"\n        if self._mode_manager.mode != usertypes.KeyMode.caret:\n            log.webview.debug(\"Ignoring selection cb due to mode change.\")\n            return\n        if enabled is None:\n            log.webview.debug(\"Ignoring selection status None\")\n            return\n        self.selection_toggled.emit(enabled)\n\n    @pyqtSlot(usertypes.KeyMode)\n    def _on_mode_left(self, mode):\n        if mode != usertypes.KeyMode.caret:\n            return\n\n        self.drop_selection()\n        self._js_call('disableCaret')\n\n    def move_to_next_line(self, count=1):\n        self._js_call('moveDown', count)\n\n    def move_to_prev_line(self, count=1):\n        self._js_call('moveUp', count)\n\n    def move_to_next_char(self, count=1):\n        self._js_call('moveRight', count)\n\n    def move_to_prev_char(self, count=1):\n        self._js_call('moveLeft', count)\n\n    def move_to_end_of_word(self, count=1):\n        self._js_call('moveToEndOfWord', count)\n\n    def move_to_next_word(self, count=1):\n        self._js_call('moveToNextWord', count)\n\n    def move_to_prev_word(self, count=1):\n        self._js_call('moveToPreviousWord', count)\n\n    def move_to_start_of_line(self):\n        self._js_call('moveToStartOfLine')\n\n    def move_to_end_of_line(self):\n        self._js_call('moveToEndOfLine')\n\n    def move_to_start_of_next_block(self, count=1):\n        self._js_call('moveToStartOfNextBlock', count)\n\n    def move_to_start_of_prev_block(self, count=1):\n        self._js_call('moveToStartOfPrevBlock', count)\n\n    def move_to_end_of_next_block(self, count=1):\n        self._js_call('moveToEndOfNextBlock', count)\n\n    def move_to_end_of_prev_block(self, count=1):\n        self._js_call('moveToEndOfPrevBlock', count)\n\n    def move_to_start_of_document(self):\n        self._js_call('moveToStartOfDocument')\n\n    def move_to_end_of_document(self):\n        self._js_call('moveToEndOfDocument')\n\n    def toggle_selection(self):\n        self._js_call('toggleSelection', callback=self.selection_toggled.emit)\n\n    def drop_selection(self):\n        self._js_call('dropSelection')\n\n    def selection(self, callback):\n        # Not using selectedText() as WORKAROUND for\n        # https://bugreports.qt.io/browse/QTBUG-53134\n        # Even on Qt 5.10 selectedText() seems to work poorly, see\n        # https://github.com/qutebrowser/qutebrowser/issues/3523\n        self._tab.run_js_async(javascript.assemble('caret', 'getSelection'),\n                               callback)\n\n    def reverse_selection(self):\n        self._js_call('reverseSelection')\n\n    def _follow_selected_cb_wrapped(self, js_elem, tab):\n        try:\n            self._follow_selected_cb(js_elem, tab)\n        finally:\n            self.follow_selected_done.emit()\n\n    def _follow_selected_cb(self, js_elem, tab):\n        \"\"\"Callback for javascript which clicks the selected element.\n\n        Args:\n            js_elem: The element serialized from javascript.\n            tab: Open in a new tab.\n        \"\"\"\n        if js_elem is None:\n            return\n\n        if js_elem == \"focused\":\n            # we had a focused element, not a selected one. Just send <enter>\n            self._follow_enter(tab)\n            return\n\n        assert isinstance(js_elem, dict), js_elem\n        elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)\n        if tab:\n            click_type = usertypes.ClickTarget.tab\n        else:\n            click_type = usertypes.ClickTarget.normal\n\n        # Only click if we see a link\n        if elem.is_link():\n            log.webview.debug(\"Found link in selection, clicking. ClickTarget \"\n                              \"{}, elem {}\".format(click_type, elem))\n            try:\n                elem.click(click_type)\n            except webelem.Error as e:\n                message.error(str(e))\n\n    def follow_selected(self, *, tab=False):\n        if self._tab.search.search_displayed:\n            # We are currently in search mode.\n            # let's click the link via a fake-click\n            # https://bugreports.qt.io/browse/QTBUG-60673\n            self._tab.search.clear()\n\n            log.webview.debug(\"Clicking a searched link via fake key press.\")\n            # send a fake enter, clicking the orange selection box\n            self._follow_enter(tab)\n        else:\n            # click an existing blue selection\n            js_code = javascript.assemble('webelem',\n                                          'find_selected_focused_link')\n            self._tab.run_js_async(\n                js_code,\n                lambda jsret: self._follow_selected_cb_wrapped(jsret, tab))\n\n    def _js_call(self, command, *args, callback=None):\n        code = javascript.assemble('caret', command, *args)\n        self._tab.run_js_async(code, callback)\n\n\nclass WebEngineScroller(browsertab.AbstractScroller):\n\n    \"\"\"QtWebEngine implementations related to scrolling.\"\"\"\n\n    def __init__(self, tab, parent=None):\n        super().__init__(tab, parent)\n        self._pos_perc = (0, 0)\n        self._pos_px = QPoint()\n        self._at_bottom = False\n\n    def _init_widget(self, widget):\n        super()._init_widget(widget)\n        page = widget.page()\n        page.scrollPositionChanged.connect(self._update_pos)\n\n    def _repeated_key_press(self, key, count=1, modifier=Qt.NoModifier):\n        \"\"\"Send count fake key presses to this scroller's WebEngineTab.\"\"\"\n        for _ in range(min(count, 1000)):\n            self._tab.fake_key_press(key, modifier)\n\n    @pyqtSlot(QPointF)\n    def _update_pos(self, pos):\n        \"\"\"Update the scroll position attributes when it changed.\"\"\"\n        self._pos_px = pos.toPoint()\n        contents_size = self._widget.page().contentsSize()\n\n        scrollable_x = contents_size.width() - self._widget.width()\n        if scrollable_x == 0:\n            perc_x = 0\n        else:\n            try:\n                perc_x = min(100, round(100 / scrollable_x * pos.x()))\n            except ValueError:\n                # https://github.com/qutebrowser/qutebrowser/issues/3219\n                log.misc.debug(\"Got ValueError for perc_x!\")\n                log.misc.debug(\"contents_size.width(): {}\".format(\n                    contents_size.width()))\n                log.misc.debug(\"self._widget.width(): {}\".format(\n                    self._widget.width()))\n                log.misc.debug(\"scrollable_x: {}\".format(scrollable_x))\n                log.misc.debug(\"pos.x(): {}\".format(pos.x()))\n                raise\n\n        scrollable_y = contents_size.height() - self._widget.height()\n        if scrollable_y == 0:\n            perc_y = 0\n        else:\n            try:\n                perc_y = min(100, round(100 / scrollable_y * pos.y()))\n            except ValueError:\n                # https://github.com/qutebrowser/qutebrowser/issues/3219\n                log.misc.debug(\"Got ValueError for perc_y!\")\n                log.misc.debug(\"contents_size.height(): {}\".format(\n                    contents_size.height()))\n                log.misc.debug(\"self._widget.height(): {}\".format(\n                    self._widget.height()))\n                log.misc.debug(\"scrollable_y: {}\".format(scrollable_y))\n                log.misc.debug(\"pos.y(): {}\".format(pos.y()))\n                raise\n\n        self._at_bottom = math.ceil(pos.y()) >= scrollable_y\n\n        if (self._pos_perc != (perc_x, perc_y) or\n                'no-scroll-filtering' in objects.debug_flags):\n            self._pos_perc = perc_x, perc_y\n            self.perc_changed.emit(*self._pos_perc)\n\n    def pos_px(self):\n        return self._pos_px\n\n    def pos_perc(self):\n        return self._pos_perc\n\n    def to_perc(self, x=None, y=None):\n        js_code = javascript.assemble('scroll', 'to_perc', x, y)\n        self._tab.run_js_async(js_code)\n\n    def to_point(self, point):\n        js_code = javascript.assemble('window', 'scroll', point.x(), point.y())\n        self._tab.run_js_async(js_code)\n\n    def to_anchor(self, name):\n        url = self._tab.url()\n        url.setFragment(name)\n        self._tab.load_url(url)\n\n    def delta(self, x=0, y=0):\n        self._tab.run_js_async(javascript.assemble('window', 'scrollBy', x, y))\n\n    def delta_page(self, x=0, y=0):\n        js_code = javascript.assemble('scroll', 'delta_page', x, y)\n        self._tab.run_js_async(js_code)\n\n    def up(self, count=1):\n        self._repeated_key_press(Qt.Key_Up, count)\n\n    def down(self, count=1):\n        self._repeated_key_press(Qt.Key_Down, count)\n\n    def left(self, count=1):\n        self._repeated_key_press(Qt.Key_Left, count)\n\n    def right(self, count=1):\n        self._repeated_key_press(Qt.Key_Right, count)\n\n    def top(self):\n        self._tab.fake_key_press(Qt.Key_Home)\n\n    def bottom(self):\n        self._tab.fake_key_press(Qt.Key_End)\n\n    def page_up(self, count=1):\n        self._repeated_key_press(Qt.Key_PageUp, count)\n\n    def page_down(self, count=1):\n        self._repeated_key_press(Qt.Key_PageDown, count)\n\n    def at_top(self):\n        return self.pos_px().y() == 0\n\n    def at_bottom(self):\n        return self._at_bottom\n\n\nclass WebEngineHistoryPrivate(browsertab.AbstractHistoryPrivate):\n\n    \"\"\"History-related methods which are not part of the extension API.\"\"\"\n\n    def serialize(self):\n        if not qtutils.version_check('5.9', compiled=False):\n            # WORKAROUND for\n            # https://github.com/qutebrowser/qutebrowser/issues/2289\n            # Don't use the history's currentItem here, because of\n            # https://bugreports.qt.io/browse/QTBUG-59599 and because it doesn't\n            # contain view-source.\n            scheme = self._tab.url().scheme()\n            if scheme in ['view-source', 'chrome']:\n                raise browsertab.WebTabError(\"Can't serialize special URL!\")\n        return qtutils.serialize(self._history)\n\n    def deserialize(self, data):\n        qtutils.deserialize(data, self._history)\n\n    def load_items(self, items):\n        if qtutils.version_check('5.15', compiled=False):\n            # WORKAROUND for https://github.com/qutebrowser/qutebrowser/issues/5359\n            if items:\n                self._tab.load_url(items[-1].url)\n            return\n\n        if items:\n            self._tab.before_load_started.emit(items[-1].url)\n\n        stream, _data, cur_data = tabhistory.serialize(items)\n        qtutils.deserialize_stream(stream, self._history)\n\n        @pyqtSlot()\n        def _on_load_finished():\n            self._tab.scroller.to_point(cur_data['scroll-pos'])\n            self._tab.load_finished.disconnect(_on_load_finished)\n\n        if cur_data is not None:\n            if 'zoom' in cur_data:\n                self._tab.zoom.set_factor(cur_data['zoom'])\n            if ('scroll-pos' in cur_data and\n                    self._tab.scroller.pos_px() == QPoint(0, 0)):\n                self._tab.load_finished.connect(_on_load_finished)\n\n\nclass WebEngineHistory(browsertab.AbstractHistory):\n\n    \"\"\"QtWebEngine implementations related to page history.\"\"\"\n\n    def __init__(self, tab):\n        super().__init__(tab)\n        self.private_api = WebEngineHistoryPrivate(tab)\n\n    def __len__(self):\n        return len(self._history)\n\n    def __iter__(self):\n        return iter(self._history.items())\n\n    def current_idx(self):\n        return self._history.currentItemIndex()\n\n    def can_go_back(self):\n        return self._history.canGoBack()\n\n    def can_go_forward(self):\n        return self._history.canGoForward()\n\n    def _item_at(self, i):\n        return self._history.itemAt(i)\n\n    def _go_to_item(self, item):\n        self._tab.before_load_started.emit(item.url())\n        self._history.goToItem(item)\n\n\nclass WebEngineZoom(browsertab.AbstractZoom):\n\n    \"\"\"QtWebEngine implementations related to zooming.\"\"\"\n\n    def _set_factor_internal(self, factor):\n        self._widget.setZoomFactor(factor)\n\n\nclass WebEngineElements(browsertab.AbstractElements):\n\n    \"\"\"QtWebEngine implemementations related to elements on the page.\"\"\"\n\n    def _js_cb_multiple(self, callback, error_cb, js_elems):\n        \"\"\"Handle found elements coming from JS and call the real callback.\n\n        Args:\n            callback: The callback to call with the found elements.\n            error_cb: The callback to call in case of an error.\n            js_elems: The elements serialized from javascript.\n        \"\"\"\n        if js_elems is None:\n            error_cb(webelem.Error(\"Unknown error while getting \"\n                                   \"elements\"))\n            return\n        elif not js_elems['success']:\n            error_cb(webelem.Error(js_elems['error']))\n            return\n\n        elems = []\n        for js_elem in js_elems['result']:\n            elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)\n            elems.append(elem)\n        callback(elems)\n\n    def _js_cb_single(self, callback, js_elem):\n        \"\"\"Handle a found focus elem coming from JS and call the real callback.\n\n        Args:\n            callback: The callback to call with the found element.\n                      Called with a WebEngineElement or None.\n            js_elem: The element serialized from javascript.\n        \"\"\"\n        debug_str = ('None' if js_elem is None\n                     else utils.elide(repr(js_elem), 1000))\n        log.webview.debug(\"Got element from JS: {}\".format(debug_str))\n\n        if js_elem is None:\n            callback(None)\n        else:\n            elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)\n            callback(elem)\n\n    def find_css(self, selector, callback, error_cb, *,\n                 only_visible=False):\n        js_code = javascript.assemble('webelem', 'find_css', selector,\n                                      only_visible)\n        js_cb = functools.partial(self._js_cb_multiple, callback, error_cb)\n        self._tab.run_js_async(js_code, js_cb)\n\n    def find_id(self, elem_id, callback):\n        js_code = javascript.assemble('webelem', 'find_id', elem_id)\n        js_cb = functools.partial(self._js_cb_single, callback)\n        self._tab.run_js_async(js_code, js_cb)\n\n    def find_focused(self, callback):\n        js_code = javascript.assemble('webelem', 'find_focused')\n        js_cb = functools.partial(self._js_cb_single, callback)\n        self._tab.run_js_async(js_code, js_cb)\n\n    def find_at_pos(self, pos, callback):\n        assert pos.x() >= 0, pos\n        assert pos.y() >= 0, pos\n        pos /= self._tab.zoom.factor()\n        js_code = javascript.assemble('webelem', 'find_at_pos',\n                                      pos.x(), pos.y())\n        js_cb = functools.partial(self._js_cb_single, callback)\n        self._tab.run_js_async(js_code, js_cb)\n\n\nclass WebEngineAudio(browsertab.AbstractAudio):\n\n    \"\"\"QtWebEngine implemementations related to audio/muting.\n\n    Attributes:\n        _overridden: Whether the user toggled muting manually.\n                     If that's the case, we leave it alone.\n    \"\"\"\n\n    def __init__(self, tab, parent=None):\n        super().__init__(tab, parent)\n        self._overridden = False\n\n    def _connect_signals(self):\n        page = self._widget.page()\n        page.audioMutedChanged.connect(self.muted_changed)\n        page.recentlyAudibleChanged.connect(self.recently_audible_changed)\n        self._tab.url_changed.connect(self._on_url_changed)\n        config.instance.changed.connect(self._on_config_changed)\n\n    def set_muted(self, muted: bool, override: bool = False) -> None:\n        self._overridden = override\n        assert self._widget is not None\n        page = self._widget.page()\n        page.setAudioMuted(muted)\n\n    def is_muted(self):\n        page = self._widget.page()\n        return page.isAudioMuted()\n\n    def is_recently_audible(self):\n        page = self._widget.page()\n        return page.recentlyAudible()\n\n    @pyqtSlot(QUrl)\n    def _on_url_changed(self, url):\n        if self._overridden:\n            return\n        mute = config.instance.get('content.mute', url=url)\n        self.set_muted(mute)\n\n    @config.change_filter('content.mute')\n    def _on_config_changed(self):\n        self._on_url_changed(self._tab.url())\n\n\nclass _WebEnginePermissions(QObject):\n\n    \"\"\"Handling of various permission-related signals.\"\"\"\n\n    # Using 0 as WORKAROUND for:\n    # https://www.riverbankcomputing.com/pipermail/pyqt/2019-July/041903.html\n\n    _options = {\n        0: 'content.notifications',\n        QWebEnginePage.Geolocation: 'content.geolocation',\n        QWebEnginePage.MediaAudioCapture: 'content.media_capture',\n        QWebEnginePage.MediaVideoCapture: 'content.media_capture',\n        QWebEnginePage.MediaAudioVideoCapture: 'content.media_capture',\n    }\n\n    _messages = {\n        0: 'show notifications',\n        QWebEnginePage.Geolocation: 'access your location',\n        QWebEnginePage.MediaAudioCapture: 'record audio',\n        QWebEnginePage.MediaVideoCapture: 'record video',\n        QWebEnginePage.MediaAudioVideoCapture: 'record audio/video',\n    }\n\n    def __init__(self, tab, parent=None):\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n\n        try:\n            self._options.update({\n                QWebEnginePage.MouseLock:\n                    'content.mouse_lock',\n            })\n            self._messages.update({\n                QWebEnginePage.MouseLock:\n                    'hide your mouse pointer',\n            })\n        except AttributeError:\n            # Added in Qt 5.8\n            pass\n        try:\n            self._options.update({\n                QWebEnginePage.DesktopVideoCapture:\n                    'content.desktop_capture',\n                QWebEnginePage.DesktopAudioVideoCapture:\n                    'content.desktop_capture',\n            })\n            self._messages.update({\n                QWebEnginePage.DesktopVideoCapture:\n                    'capture your desktop',\n                QWebEnginePage.DesktopAudioVideoCapture:\n                    'capture your desktop and audio',\n            })\n        except AttributeError:\n            # Added in Qt 5.10\n            pass\n\n        assert self._options.keys() == self._messages.keys()\n\n    def connect_signals(self):\n        \"\"\"Connect related signals from the QWebEnginePage.\"\"\"\n        page = self._widget.page()\n        page.fullScreenRequested.connect(\n            self._on_fullscreen_requested)\n        page.featurePermissionRequested.connect(\n            self._on_feature_permission_requested)\n\n        if qtutils.version_check('5.11'):\n            page.quotaRequested.connect(\n                self._on_quota_requested)\n            page.registerProtocolHandlerRequested.connect(\n                self._on_register_protocol_handler_requested)\n\n    @pyqtSlot('QWebEngineFullScreenRequest')\n    def _on_fullscreen_requested(self, request):\n        request.accept()\n        on = request.toggleOn()\n\n        self._tab.data.fullscreen = on\n        self._tab.fullscreen_requested.emit(on)\n        if on:\n            timeout = config.val.content.fullscreen.overlay_timeout\n            if timeout != 0:\n                notification = miscwidgets.FullscreenNotification(self._widget)\n                notification.set_timeout(timeout)\n                notification.show()\n\n    @pyqtSlot(QUrl, 'QWebEnginePage::Feature')\n    def _on_feature_permission_requested(self, url, feature):\n        \"\"\"Ask the user for approval for geolocation/media/etc..\"\"\"\n        page = self._widget.page()\n        grant_permission = functools.partial(\n            page.setFeaturePermission, url, feature,\n            QWebEnginePage.PermissionGrantedByUser)\n        deny_permission = functools.partial(\n            page.setFeaturePermission, url, feature,\n            QWebEnginePage.PermissionDeniedByUser)\n\n        if feature not in self._options:\n            log.webview.error(\"Unhandled feature permission {}\".format(\n                debug.qenum_key(QWebEnginePage, feature)))\n            deny_permission()\n            return\n\n        if (\n                hasattr(QWebEnginePage, 'DesktopVideoCapture') and\n                feature in [QWebEnginePage.DesktopVideoCapture,\n                            QWebEnginePage.DesktopAudioVideoCapture] and\n                qtutils.version_check('5.13', compiled=False) and\n                not qtutils.version_check('5.13.2', compiled=False)\n        ):\n            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-78016\n            log.webview.warning(\"Ignoring desktop sharing request due to \"\n                                \"crashes in Qt < 5.13.2\")\n            deny_permission()\n            return\n\n        question = shared.feature_permission(\n            url=url.adjusted(QUrl.RemovePath),\n            option=self._options[feature], msg=self._messages[feature],\n            yes_action=grant_permission, no_action=deny_permission,\n            abort_on=[self._tab.abort_questions])\n\n        if question is not None:\n            page.featurePermissionRequestCanceled.connect(\n                functools.partial(self._on_feature_permission_cancelled,\n                                  question, url, feature))\n\n    def _on_feature_permission_cancelled(self, question, url, feature,\n                                         cancelled_url, cancelled_feature):\n        \"\"\"Slot invoked when a feature permission request was cancelled.\n\n        To be used with functools.partial.\n        \"\"\"\n        if url == cancelled_url and feature == cancelled_feature:\n            try:\n                question.abort()\n            except RuntimeError:\n                # The question could already be deleted, e.g. because it was\n                # aborted after a loadStarted signal.\n                pass\n\n    def _on_quota_requested(self, request):\n        size = utils.format_size(request.requestedSize())\n        shared.feature_permission(\n            url=request.origin().adjusted(QUrl.RemovePath),\n            option='content.persistent_storage',\n            msg='use {} of persistent storage'.format(size),\n            yes_action=request.accept, no_action=request.reject,\n            abort_on=[self._tab.abort_questions],\n            blocking=True)\n\n    def _on_register_protocol_handler_requested(self, request):\n        shared.feature_permission(\n            url=request.origin().adjusted(QUrl.RemovePath),\n            option='content.register_protocol_handler',\n            msg='open all {} links'.format(request.scheme()),\n            yes_action=request.accept, no_action=request.reject,\n            abort_on=[self._tab.abort_questions],\n            blocking=True)\n\n\nclass _WebEngineScripts(QObject):\n\n    def __init__(self, tab, parent=None):\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        self._greasemonkey = greasemonkey.gm_manager\n\n    def connect_signals(self):\n        \"\"\"Connect signals to our private slots.\"\"\"\n        config.instance.changed.connect(self._on_config_changed)\n\n        self._tab.search.cleared.connect(functools.partial(\n            self._update_stylesheet, searching=False))\n        self._tab.search.finished.connect(self._update_stylesheet)\n\n    @pyqtSlot(str)\n    def _on_config_changed(self, option):\n        if option in ['scrolling.bar', 'content.user_stylesheets']:\n            self._init_stylesheet()\n            self._update_stylesheet()\n\n    @pyqtSlot(bool)\n    def _update_stylesheet(self, searching=False):\n        \"\"\"Update the custom stylesheet in existing tabs.\"\"\"\n        css = shared.get_user_stylesheet(searching=searching)\n        code = javascript.assemble('stylesheet', 'set_css', css)\n        self._tab.run_js_async(code)\n\n    def _inject_early_js(self, name, js_code, *,\n                         world=QWebEngineScript.ApplicationWorld,\n                         subframes=False):\n        \"\"\"Inject the given script to run early on a page load.\n\n        This runs the script both on DocumentCreation and DocumentReady as on\n        some internal pages, DocumentCreation will not work.\n\n        That is a WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66011\n        \"\"\"\n        scripts = self._widget.page().scripts()\n        for injection in ['creation', 'ready']:\n            injection_points = {\n                'creation': QWebEngineScript.DocumentCreation,\n                'ready': QWebEngineScript.DocumentReady,\n            }\n            script = QWebEngineScript()\n            script.setInjectionPoint(injection_points[injection])\n            script.setSourceCode(js_code)\n            script.setWorldId(world)\n            script.setRunsOnSubFrames(subframes)\n            script.setName('_qute_{}_{}'.format(name, injection))\n            scripts.insert(script)\n\n    def _remove_early_js(self, name):\n        \"\"\"Remove an early QWebEngineScript.\"\"\"\n        scripts = self._widget.page().scripts()\n        for injection in ['creation', 'ready']:\n            full_name = '_qute_{}_{}'.format(name, injection)\n            script = scripts.findScript(full_name)\n            if not script.isNull():\n                scripts.remove(script)\n\n    def init(self):\n        \"\"\"Initialize global qutebrowser JavaScript.\"\"\"\n        js_code = javascript.wrap_global(\n            'scripts',\n            utils.read_file('javascript/scroll.js'),\n            utils.read_file('javascript/webelem.js'),\n            utils.read_file('javascript/caret.js'),\n        )\n        if not qtutils.version_check('5.12'):\n            # WORKAROUND for Qt versions < 5.12 not exposing window.print().\n            # Qt 5.12 has a printRequested() signal so we don't need this hack\n            # anymore.\n            self._inject_early_js('js',\n                                  utils.read_file('javascript/print.js'),\n                                  subframes=True,\n                                  world=QWebEngineScript.MainWorld)\n        # FIXME:qtwebengine what about subframes=True?\n        self._inject_early_js('js', js_code, subframes=True)\n        self._init_stylesheet()\n\n        # The Greasemonkey metadata block support in QtWebEngine only starts at\n        # Qt 5.8. With 5.7.1, we need to inject the scripts ourselves in\n        # response to urlChanged.\n        if not qtutils.version_check('5.8'):\n            self._tab.url_changed.connect(\n                self._inject_greasemonkey_scripts_for_url)\n        else:\n            self._greasemonkey.scripts_reloaded.connect(\n                self._inject_all_greasemonkey_scripts)\n            self._inject_all_greasemonkey_scripts()\n            self._inject_site_specific_quirks()\n\n    def _init_stylesheet(self):\n        \"\"\"Initialize custom stylesheets.\n\n        Partially inspired by QupZilla:\n        https://github.com/QupZilla/qupzilla/blob/v2.0/src/lib/app/mainapplication.cpp#L1063-L1101\n        \"\"\"\n        self._remove_early_js('stylesheet')\n        css = shared.get_user_stylesheet()\n        js_code = javascript.wrap_global(\n            'stylesheet',\n            utils.read_file('javascript/stylesheet.js'),\n            javascript.assemble('stylesheet', 'set_css', css),\n        )\n        self._inject_early_js('stylesheet', js_code, subframes=True)\n\n    @pyqtSlot(QUrl)\n    def _inject_greasemonkey_scripts_for_url(self, url):\n        matching_scripts = self._greasemonkey.scripts_for(url)\n        self._inject_greasemonkey_scripts(\n            matching_scripts.start, QWebEngineScript.DocumentCreation, True)\n        self._inject_greasemonkey_scripts(\n            matching_scripts.end, QWebEngineScript.DocumentReady, False)\n        self._inject_greasemonkey_scripts(\n            matching_scripts.idle, QWebEngineScript.Deferred, False)\n\n    @pyqtSlot()\n    def _inject_all_greasemonkey_scripts(self):\n        scripts = self._greasemonkey.all_scripts()\n        self._inject_greasemonkey_scripts(scripts)\n\n    def _remove_all_greasemonkey_scripts(self):\n        page_scripts = self._widget.page().scripts()\n        for script in page_scripts.toList():\n            if script.name().startswith(\"GM-\"):\n                log.greasemonkey.debug('Removing script: {}'\n                                       .format(script.name()))\n                removed = page_scripts.remove(script)\n                assert removed, script.name()\n\n    def _inject_greasemonkey_scripts(self, scripts=None, injection_point=None,\n                                     remove_first=True):\n        \"\"\"Register user JavaScript files with the current tab.\n\n        Args:\n            scripts: A list of GreasemonkeyScripts, or None to add all\n                     known by the Greasemonkey subsystem.\n            injection_point: The QWebEngineScript::InjectionPoint stage\n                             to inject the script into, None to use\n                             auto-detection.\n            remove_first: Whether to remove all previously injected\n                          scripts before adding these ones.\n        \"\"\"\n        if sip.isdeleted(self._widget):\n            return\n\n        # Since we are inserting scripts into a per-tab collection,\n        # rather than just injecting scripts on page load, we need to\n        # make sure we replace existing scripts, not just add new ones.\n        # While, taking care not to remove any other scripts that might\n        # have been added elsewhere, like the one for stylesheets.\n        page_scripts = self._widget.page().scripts()\n        if remove_first:\n            self._remove_all_greasemonkey_scripts()\n\n        if not scripts:\n            return\n\n        for script in scripts:\n            new_script = QWebEngineScript()\n            try:\n                world = int(script.jsworld)\n                if not 0 <= world <= qtutils.MAX_WORLD_ID:\n                    log.greasemonkey.error(\n                        \"script {} has invalid value for '@qute-js-world'\"\n                        \": {}, should be between 0 and {}\"\n                        .format(\n                            script.name,\n                            script.jsworld,\n                            qtutils.MAX_WORLD_ID))\n                    continue\n            except ValueError:\n                try:\n                    world = _JS_WORLD_MAP[usertypes.JsWorld[\n                        script.jsworld.lower()]]\n                except KeyError:\n                    log.greasemonkey.error(\n                        \"script {} has invalid value for '@qute-js-world'\"\n                        \": {}\".format(script.name, script.jsworld))\n                    continue\n            new_script.setWorldId(world)\n            new_script.setSourceCode(script.code())\n            new_script.setName(\"GM-{}\".format(script.name))\n            new_script.setRunsOnSubFrames(script.runs_on_sub_frames)\n\n            # Override the @run-at value parsed by QWebEngineScript if desired.\n            if injection_point:\n                new_script.setInjectionPoint(injection_point)\n            elif script.needs_document_end_workaround():\n                log.greasemonkey.debug(\"Forcing @run-at document-end for {}\"\n                                       .format(script.name))\n                new_script.setInjectionPoint(QWebEngineScript.DocumentReady)\n\n            log.greasemonkey.debug('adding script: {}'\n                                   .format(new_script.name()))\n            page_scripts.insert(new_script)\n\n    def _inject_site_specific_quirks(self):\n        \"\"\"Add site-specific quirk scripts.\n\n        NOTE: This isn't implemented for Qt 5.7 because of different UserScript\n        semantics there. We only have a quirk for WhatsApp Web right now. It\n        looks like that quirk isn't needed for Qt < 5.13.\n        \"\"\"\n        if not config.val.content.site_specific_quirks:\n            return\n\n        page_scripts = self._widget.page().scripts()\n\n        for filename in ['whatsapp_web_quirk']:\n            script = QWebEngineScript()\n            script.setName(filename)\n            script.setWorldId(QWebEngineScript.ApplicationWorld)\n            script.setInjectionPoint(QWebEngineScript.DocumentReady)\n            src = utils.read_file(\"javascript/{}.user.js\".format(filename))\n            script.setSourceCode(src)\n            page_scripts.insert(script)\n\n\nclass WebEngineTabPrivate(browsertab.AbstractTabPrivate):\n\n    \"\"\"QtWebEngine-related methods which aren't part of the public API.\"\"\"\n\n    def networkaccessmanager(self):\n        return None\n\n    def user_agent(self):\n        return None\n\n    def clear_ssl_errors(self):\n        raise browsertab.UnsupportedOperationError\n\n    def event_target(self):\n        return self._widget.render_widget()\n\n    def shutdown(self):\n        self._tab.shutting_down.emit()\n        self._tab.action.exit_fullscreen()\n        self._widget.shutdown()\n\n\nclass WebEngineTab(browsertab.AbstractTab):\n\n    \"\"\"A QtWebEngine tab in the browser.\n\n    Signals:\n        abort_questions: Emitted when a new load started or we're shutting\n            down.\n    \"\"\"\n\n    abort_questions = pyqtSignal()\n\n    def __init__(self, *, win_id, mode_manager, private, parent=None):\n        super().__init__(win_id=win_id, private=private, parent=parent)\n        widget = webview.WebEngineView(tabdata=self.data, win_id=win_id,\n                                       private=private)\n        self.history = WebEngineHistory(tab=self)\n        self.scroller = WebEngineScroller(tab=self, parent=self)\n        self.caret = WebEngineCaret(mode_manager=mode_manager,\n                                    tab=self, parent=self)\n        self.zoom = WebEngineZoom(tab=self, parent=self)\n        self.search = WebEngineSearch(tab=self, parent=self)\n        self.printing = WebEnginePrinting(tab=self)\n        self.elements = WebEngineElements(tab=self)\n        self.action = WebEngineAction(tab=self)\n        self.audio = WebEngineAudio(tab=self, parent=self)\n        self.private_api = WebEngineTabPrivate(mode_manager=mode_manager,\n                                               tab=self)\n        self._permissions = _WebEnginePermissions(tab=self, parent=self)\n        self._scripts = _WebEngineScripts(tab=self, parent=self)\n        # We're assigning settings in _set_widget\n        self.settings = webenginesettings.WebEngineSettings(settings=None)\n        self._set_widget(widget)\n        self._connect_signals()\n        self.backend = usertypes.Backend.QtWebEngine\n        self._child_event_filter = None\n        self._saved_zoom = None\n        self._reload_url = None  # type: typing.Optional[QUrl]\n        self._scripts.init()\n\n    def _set_widget(self, widget):\n        # pylint: disable=protected-access\n        super()._set_widget(widget)\n        self._permissions._widget = widget\n        self._scripts._widget = widget\n\n    def _install_event_filter(self):\n        fp = self._widget.focusProxy()\n        if fp is not None:\n            fp.installEventFilter(self._tab_event_filter)\n        self._child_event_filter = eventfilter.ChildEventFilter(\n            eventfilter=self._tab_event_filter, widget=self._widget,\n            win_id=self.win_id, parent=self)\n        self._widget.installEventFilter(self._child_event_filter)\n\n    @pyqtSlot()\n    def _restore_zoom(self):\n        if sip.isdeleted(self._widget):\n            # https://github.com/qutebrowser/qutebrowser/issues/3498\n            return\n        if self._saved_zoom is None:\n            return\n        self.zoom.set_factor(self._saved_zoom)\n        self._saved_zoom = None\n\n    def load_url(self, url, *, emit_before_load_started=True):\n        \"\"\"Load the given URL in this tab.\n\n        Arguments:\n            url: The QUrl to load.\n            emit_before_load_started: If set to False, before_load_started is\n                                      not emitted.\n        \"\"\"\n        if sip.isdeleted(self._widget):\n            # https://github.com/qutebrowser/qutebrowser/issues/3896\n            return\n        self._saved_zoom = self.zoom.factor()\n        self._load_url_prepare(\n            url, emit_before_load_started=emit_before_load_started)\n        self._widget.load(url)\n\n    def url(self, *, requested=False):\n        page = self._widget.page()\n        if requested:\n            return page.requestedUrl()\n        else:\n            return page.url()\n\n    def dump_async(self, callback, *, plain=False):\n        if plain:\n            self._widget.page().toPlainText(callback)\n        else:\n            self._widget.page().toHtml(callback)\n\n    def run_js_async(self, code, callback=None, *, world=None):\n        world_id_type = typing.Union[QWebEngineScript.ScriptWorldId, int]\n        if world is None:\n            world_id = QWebEngineScript.ApplicationWorld  # type: world_id_type\n        elif isinstance(world, int):\n            world_id = world\n            if not 0 <= world_id <= qtutils.MAX_WORLD_ID:\n                raise browsertab.WebTabError(\n                    \"World ID should be between 0 and {}\"\n                    .format(qtutils.MAX_WORLD_ID))\n        else:\n            world_id = _JS_WORLD_MAP[world]\n\n        if callback is None:\n            self._widget.page().runJavaScript(code, world_id)\n        else:\n            self._widget.page().runJavaScript(code, world_id, callback)\n\n    def reload(self, *, force=False):\n        if force:\n            action = QWebEnginePage.ReloadAndBypassCache\n        else:\n            action = QWebEnginePage.Reload\n        self._widget.triggerPageAction(action)\n\n    def stop(self):\n        self._widget.stop()\n\n    def title(self):\n        return self._widget.title()\n\n    def icon(self):\n        return self._widget.icon()\n\n    def set_html(self, html, base_url=QUrl()):\n        # FIXME:qtwebengine\n        # check this and raise an exception if too big:\n        # Warning: The content will be percent encoded before being sent to the\n        # renderer via IPC. This may increase its size. The maximum size of the\n        # percent encoded content is 2 megabytes minus 30 bytes.\n        self._widget.setHtml(html, base_url)\n\n    def _show_error_page(self, url, error):\n        \"\"\"Show an error page in the tab.\"\"\"\n        log.misc.debug(\"Showing error page for {}\".format(error))\n        url_string = url.toDisplayString()\n        error_page = jinja.render(\n            'error.html',\n            title=\"Error loading page: {}\".format(url_string),\n            url=url_string, error=error)\n        self.set_html(error_page)\n\n    @pyqtSlot()\n    def _on_history_trigger(self):\n        try:\n            self._widget.page()\n        except RuntimeError:\n            # Looks like this slot can be triggered on destroyed tabs:\n            # https://crashes.qutebrowser.org/view/3abffbed (Qt 5.9.1)\n            # wrapped C/C++ object of type WebEngineView has been deleted\n            log.misc.debug(\"Ignoring history trigger for destroyed tab\")\n            return\n\n        url = self.url()\n        requested_url = self.url(requested=True)\n\n        # Don't save the title if it's generated from the URL\n        title = self.title()\n        title_url = QUrl(url)\n        title_url.setScheme('')\n        title_url_str = title_url.toDisplayString(\n            QUrl.RemoveScheme)  # type: ignore\n        if title == title_url_str.strip('/'):\n            title = \"\"\n\n        # Don't add history entry if the URL is invalid anyways\n        if not url.isValid():\n            log.misc.debug(\"Ignoring invalid URL being added to history\")\n            return\n\n        self.history_item_triggered.emit(url, requested_url, title)\n\n    @pyqtSlot(QUrl, 'QAuthenticator*', 'QString')\n    def _on_proxy_authentication_required(self, url, authenticator,\n                                          proxy_host):\n        \"\"\"Called when a proxy needs authentication.\"\"\"\n        msg = \"<b>{}</b> requires a username and password.\".format(\n            html_utils.escape(proxy_host))\n        urlstr = url.toString(QUrl.RemovePassword | QUrl.FullyEncoded)\n        answer = message.ask(\n            title=\"Proxy authentication required\", text=msg,\n            mode=usertypes.PromptMode.user_pwd,\n            abort_on=[self.abort_questions], url=urlstr)\n        if answer is not None:\n            authenticator.setUser(answer.user)\n            authenticator.setPassword(answer.password)\n        else:\n            try:\n                sip.assign(authenticator, QAuthenticator())  # type: ignore\n            except AttributeError:\n                self._show_error_page(url, \"Proxy authentication required\")\n\n    @pyqtSlot(QUrl, 'QAuthenticator*')\n    def _on_authentication_required(self, url, authenticator):\n        log.network.debug(\"Authentication requested for {}, netrc_used {}\"\n                          .format(url.toDisplayString(), self.data.netrc_used))\n\n        netrc_success = False\n        if not self.data.netrc_used:\n            self.data.netrc_used = True\n            netrc_success = shared.netrc_authentication(url, authenticator)\n\n        if not netrc_success:\n            log.network.debug(\"Asking for credentials\")\n            answer = shared.authentication_required(\n                url, authenticator, abort_on=[self.abort_questions])\n        if not netrc_success and answer is None:\n            log.network.debug(\"Aborting auth\")\n            try:\n                sip.assign(authenticator, QAuthenticator())  # type: ignore\n            except AttributeError:\n                # WORKAROUND for\n                # https://www.riverbankcomputing.com/pipermail/pyqt/2016-December/038400.html\n                self._show_error_page(url, \"Authentication required\")\n\n    @pyqtSlot()\n    def _on_load_started(self):\n        \"\"\"Clear search when a new load is started if needed.\"\"\"\n        # WORKAROUND for\n        # https://bugreports.qt.io/browse/QTBUG-61506\n        # (seems to be back in later Qt versions as well)\n        self.search.clear()\n        super()._on_load_started()\n        self.data.netrc_used = False\n\n    @pyqtSlot(QWebEnginePage.RenderProcessTerminationStatus, int)\n    def _on_render_process_terminated(self, status, exitcode):\n        \"\"\"Show an error when the renderer process terminated.\"\"\"\n        if (status == QWebEnginePage.AbnormalTerminationStatus and\n                exitcode == 256):\n            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-58697\n            status = QWebEnginePage.CrashedTerminationStatus\n\n        status_map = {\n            QWebEnginePage.NormalTerminationStatus:\n                browsertab.TerminationStatus.normal,\n            QWebEnginePage.AbnormalTerminationStatus:\n                browsertab.TerminationStatus.abnormal,\n            QWebEnginePage.CrashedTerminationStatus:\n                browsertab.TerminationStatus.crashed,\n            QWebEnginePage.KilledTerminationStatus:\n                browsertab.TerminationStatus.killed,\n            -1:\n                browsertab.TerminationStatus.unknown,\n        }\n        self.renderer_process_terminated.emit(status_map[status], exitcode)\n\n    def _error_page_workaround(self, js_enabled, html):\n        \"\"\"Check if we're displaying a Chromium error page.\n\n        This gets called if we got a loadFinished(False), so we can display at\n        least some error page in situations where Chromium's can't be\n        displayed.\n\n        WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66643\n        WORKAROUND for https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=882805\n\n        Needs to check the page content as a WORKAROUND for\n        https://bugreports.qt.io/browse/QTBUG-66661\n        \"\"\"\n        match = re.search(r'\"errorCode\":\"([^\"]*)\"', html)\n        if match is None:\n            return\n\n        error = match.group(1)\n        log.webview.error(\"Load error: {}\".format(error))\n\n        missing_jst = 'jstProcess(' in html and 'jstProcess=' not in html\n        if js_enabled and not missing_jst:\n            return\n\n        self._show_error_page(self.url(), error=error)\n\n    @pyqtSlot(int)\n    def _on_load_progress(self, perc: int) -> None:\n        \"\"\"QtWebEngine-specific loadProgress workarounds.\n\n        WORKAROUND for https://bugreports.qt.io/browse/QTBUG-65223\n        \"\"\"\n        super()._on_load_progress(perc)\n        if (perc == 100 and\n                qtutils.version_check('5.10', compiled=False) and\n                self.load_status() != usertypes.LoadStatus.error):\n            self._update_load_status(ok=True)\n\n    @pyqtSlot(bool)\n    def _on_load_finished(self, ok: bool) -> None:\n        \"\"\"QtWebEngine-specific loadFinished workarounds.\"\"\"\n        super()._on_load_finished(ok)\n\n        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-65223\n        if qtutils.version_check('5.10', compiled=False):\n            if not ok:\n                self._update_load_status(ok)\n        else:\n            self._update_load_status(ok)\n\n        if not ok:\n            self.dump_async(functools.partial(\n                self._error_page_workaround,\n                self.settings.test_attribute('content.javascript.enabled')))\n\n        if ok and self._reload_url is not None:\n            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656\n            log.config.debug(\n                \"Loading {} again because of config change\".format(\n                    self._reload_url.toDisplayString()))\n            QTimer.singleShot(100, functools.partial(\n                self.load_url, self._reload_url,\n                emit_before_load_started=False))\n            self._reload_url = None\n\n    @pyqtSlot(certificateerror.CertificateErrorWrapper)\n    def _on_ssl_errors(self, error):\n        self._has_ssl_errors = True\n\n        url = error.url()\n        log.webview.debug(\"Certificate error: {}\".format(error))\n\n        if error.is_overridable():\n            error.ignore = shared.ignore_certificate_errors(\n                url, [error], abort_on=[self.abort_questions])\n        else:\n            log.webview.error(\"Non-overridable certificate error: \"\n                              \"{}\".format(error))\n\n        log.webview.debug(\"ignore {}, URL {}, requested {}\".format(\n            error.ignore, url, self.url(requested=True)))\n\n        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-56207\n        show_cert_error = (\n            not qtutils.version_check('5.9') and\n            not error.ignore\n        )\n        # WORKAROUND for https://codereview.qt-project.org/c/qt/qtwebengine/+/270556\n        show_non_overr_cert_error = (\n            not error.is_overridable() and (\n                # Affected Qt versions:\n                # 5.13 before 5.13.2\n                # 5.12 before 5.12.6\n                # < 5.12\n                (qtutils.version_check('5.13') and\n                 not qtutils.version_check('5.13.2')) or\n                (qtutils.version_check('5.12') and\n                 not qtutils.version_check('5.12.6')) or\n                not qtutils.version_check('5.12')\n            )\n        )\n\n        # We can't really know when to show an error page, as the error might\n        # have happened when loading some resource.\n        # However, self.url() is not available yet and the requested URL\n        # might not match the URL we get from the error - so we just apply a\n        # heuristic here.\n        if ((show_cert_error or show_non_overr_cert_error) and\n                url.matches(self.data.last_navigation.url, QUrl.RemoveScheme)):\n            self._show_error_page(url, str(error))\n\n    @pyqtSlot(QUrl)\n    def _on_before_load_started(self, url):\n        \"\"\"If we know we're going to visit a URL soon, change the settings.\n\n        This is a WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656\n        \"\"\"\n        super()._on_before_load_started(url)\n        if not qtutils.version_check('5.11.1', compiled=False):\n            self.settings.update_for_url(url)\n\n    @pyqtSlot()\n    def _on_print_requested(self):\n        \"\"\"Slot for window.print() in JS.\"\"\"\n        try:\n            self.printing.show_dialog()\n        except browsertab.WebTabError as e:\n            message.error(str(e))\n\n    @pyqtSlot(QUrl)\n    def _on_url_changed(self, url: QUrl) -> None:\n        \"\"\"Update settings for the current URL.\n\n        Normally this is done below in _on_navigation_request, but we also need\n        to do it here as WORKAROUND for\n        https://bugreports.qt.io/browse/QTBUG-77137\n\n        Since update_for_url() is idempotent, it doesn't matter much if we end\n        up doing it twice.\n        \"\"\"\n        super()._on_url_changed(url)\n        if url.isValid() and qtutils.version_check('5.13'):\n            self.settings.update_for_url(url)\n\n    @pyqtSlot(usertypes.NavigationRequest)\n    def _on_navigation_request(self, navigation):\n        super()._on_navigation_request(navigation)\n\n        if navigation.url == QUrl('qute://print'):\n            self._on_print_requested()\n            navigation.accepted = False\n\n        if not navigation.accepted or not navigation.is_main_frame:\n            return\n\n        settings_needing_reload = {\n            'content.plugins',\n            'content.javascript.enabled',\n            'content.javascript.can_access_clipboard',\n            'content.print_element_backgrounds',\n            'input.spatial_navigation',\n        }\n        assert settings_needing_reload.issubset(configdata.DATA)\n\n        changed = self.settings.update_for_url(navigation.url)\n        reload_needed = bool(changed & settings_needing_reload)\n\n        # On Qt < 5.11, we don't don't need a reload when type == link_clicked.\n        # On Qt 5.11.0, we always need a reload.\n        # On Qt > 5.11.0, we never need a reload:\n        # https://codereview.qt-project.org/#/c/229525/1\n        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656\n        if qtutils.version_check('5.11.1', compiled=False):\n            reload_needed = False\n        elif not qtutils.version_check('5.11.0', exact=True, compiled=False):\n            if navigation.navigation_type == navigation.Type.link_clicked:\n                reload_needed = False\n\n        if reload_needed:\n            self._reload_url = navigation.url\n\n    def _on_select_client_certificate(self, selection):\n        \"\"\"Handle client certificates.\n\n        Currently, we simply pick the first available certificate and show an\n        additional note if there are multiple matches.\n        \"\"\"\n        certificate = selection.certificates()[0]\n        text = ('<b>Subject:</b> {subj}<br/>'\n                '<b>Issuer:</b> {issuer}<br/>'\n                '<b>Serial:</b> {serial}'.format(\n                    subj=html_utils.escape(certificate.subjectDisplayName()),\n                    issuer=html_utils.escape(certificate.issuerDisplayName()),\n                    serial=bytes(certificate.serialNumber()).decode('ascii')))\n        if len(selection.certificates()) > 1:\n            text += ('<br/><br/><b>Note:</b> Multiple matching certificates '\n                     'were found, but certificate selection is not '\n                     'implemented yet!')\n        urlstr = selection.host().host()\n\n        present = message.ask(\n            title='Present client certificate to {}?'.format(urlstr),\n            text=text,\n            mode=usertypes.PromptMode.yesno,\n            abort_on=[self.abort_questions],\n            url=urlstr)\n\n        if present:\n            selection.select(certificate)\n        else:\n            selection.selectNone()\n\n    def _connect_signals(self):\n        view = self._widget\n        page = view.page()\n\n        page.windowCloseRequested.connect(self.window_close_requested)\n        page.linkHovered.connect(self.link_hovered)\n        page.loadProgress.connect(self._on_load_progress)\n        page.loadStarted.connect(self._on_load_started)\n        page.certificate_error.connect(self._on_ssl_errors)\n        page.authenticationRequired.connect(self._on_authentication_required)\n        page.proxyAuthenticationRequired.connect(\n            self._on_proxy_authentication_required)\n        page.contentsSizeChanged.connect(self.contents_size_changed)\n        page.navigation_request.connect(self._on_navigation_request)\n\n        if qtutils.version_check('5.12'):\n            page.printRequested.connect(self._on_print_requested)\n\n        try:\n            # pylint: disable=unused-import\n            from PyQt5.QtWebEngineWidgets import (  # type: ignore\n                QWebEngineClientCertificateSelection)\n        except ImportError:\n            pass\n        else:\n            page.selectClientCertificate.connect(\n                self._on_select_client_certificate)\n\n        view.titleChanged.connect(self.title_changed)\n        view.urlChanged.connect(self._on_url_changed)\n        view.renderProcessTerminated.connect(\n            self._on_render_process_terminated)\n        view.iconChanged.connect(self.icon_changed)\n\n        page.loadFinished.connect(self._on_history_trigger)\n        page.loadFinished.connect(self._restore_zoom)\n        page.loadFinished.connect(self._on_load_finished)\n\n        self.before_load_started.connect(self._on_before_load_started)\n        self.shutting_down.connect(self.abort_questions)  # type: ignore\n        self.load_started.connect(self.abort_questions)  # type: ignore\n\n        # pylint: disable=protected-access\n        self.audio._connect_signals()\n        self.search.connect_signals()\n        self._permissions.connect_signals()\n        self._scripts.connect_signals()\n", "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2016-2020 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"Wrapper over our (QtWebKit) WebView.\"\"\"\n\nimport re\nimport functools\nimport xml.etree.ElementTree\n\nfrom PyQt5.QtCore import pyqtSlot, Qt, QUrl, QPoint, QTimer, QSizeF, QSize\nfrom PyQt5.QtGui import QIcon\nfrom PyQt5.QtWebKitWidgets import QWebPage, QWebFrame\nfrom PyQt5.QtWebKit import QWebSettings\nfrom PyQt5.QtPrintSupport import QPrinter\n\nfrom qutebrowser.browser import browsertab, shared\nfrom qutebrowser.browser.webkit import (webview, tabhistory, webkitelem,\n                                        webkitsettings)\nfrom qutebrowser.utils import qtutils, usertypes, utils, log, debug\nfrom qutebrowser.qt import sip\n\n\nclass WebKitAction(browsertab.AbstractAction):\n\n    \"\"\"QtWebKit implementations related to web actions.\"\"\"\n\n    action_class = QWebPage\n    action_base = QWebPage.WebAction\n\n    def exit_fullscreen(self):\n        raise browsertab.UnsupportedOperationError\n\n    def save_page(self):\n        \"\"\"Save the current page.\"\"\"\n        raise browsertab.UnsupportedOperationError\n\n    def show_source(self, pygments=False):\n        self._show_source_pygments()\n\n\nclass WebKitPrinting(browsertab.AbstractPrinting):\n\n    \"\"\"QtWebKit implementations related to printing.\"\"\"\n\n    def check_pdf_support(self):\n        pass\n\n    def check_printer_support(self):\n        pass\n\n    def check_preview_support(self):\n        pass\n\n    def to_pdf(self, filename):\n        printer = QPrinter()\n        printer.setOutputFileName(filename)\n        self.to_printer(printer)\n\n    def to_printer(self, printer, callback=None):\n        self._widget.print(printer)\n        # Can't find out whether there was an error...\n        if callback is not None:\n            callback(True)\n\n\nclass WebKitSearch(browsertab.AbstractSearch):\n\n    \"\"\"QtWebKit implementations related to searching on the page.\"\"\"\n\n    def __init__(self, tab, parent=None):\n        super().__init__(tab, parent)\n        self._flags = QWebPage.FindFlags(0)  # type: ignore\n\n    def _call_cb(self, callback, found, text, flags, caller):\n        \"\"\"Call the given callback if it's non-None.\n\n        Delays the call via a QTimer so the website is re-rendered in between.\n\n        Args:\n            callback: What to call\n            found: If the text was found\n            text: The text searched for\n            flags: The flags searched with\n            caller: Name of the caller.\n        \"\"\"\n        found_text = 'found' if found else \"didn't find\"\n        # Removing FindWrapsAroundDocument to get the same logging as with\n        # QtWebEngine\n        debug_flags = debug.qflags_key(\n            QWebPage, flags & ~QWebPage.FindWrapsAroundDocument,\n            klass=QWebPage.FindFlag)\n        if debug_flags != '0x0000':\n            flag_text = 'with flags {}'.format(debug_flags)\n        else:\n            flag_text = ''\n        log.webview.debug(' '.join([caller, found_text, text, flag_text])\n                          .strip())\n        if callback is not None:\n            QTimer.singleShot(0, functools.partial(callback, found))\n\n        self.finished.emit(found)\n\n    def clear(self):\n        if self.search_displayed:\n            self.cleared.emit()\n        self.search_displayed = False\n        # We first clear the marked text, then the highlights\n        self._widget.findText('')\n        self._widget.findText('', QWebPage.HighlightAllOccurrences)\n\n    def search(self, text, *, ignore_case=usertypes.IgnoreCase.never,\n               reverse=False, wrap=True, result_cb=None):\n        # Don't go to next entry on duplicate search\n        if self.text == text and self.search_displayed:\n            log.webview.debug(\"Ignoring duplicate search request\"\n                              \" for {}\".format(text))\n            return\n\n        # Clear old search results, this is done automatically on QtWebEngine.\n        self.clear()\n\n        self.text = text\n        self.search_displayed = True\n        self._flags = QWebPage.FindFlags(0)  # type: ignore\n        if self._is_case_sensitive(ignore_case):\n            self._flags |= QWebPage.FindCaseSensitively\n        if reverse:\n            self._flags |= QWebPage.FindBackward\n        if wrap:\n            self._flags |= QWebPage.FindWrapsAroundDocument\n        # We actually search *twice* - once to highlight everything, then again\n        # to get a mark so we can navigate.\n        found = self._widget.findText(text, self._flags)\n        self._widget.findText(text,\n                              self._flags | QWebPage.HighlightAllOccurrences)\n        self._call_cb(result_cb, found, text, self._flags, 'search')\n\n    def next_result(self, *, result_cb=None):\n        self.search_displayed = True\n        found = self._widget.findText(self.text, self._flags)\n        self._call_cb(result_cb, found, self.text, self._flags, 'next_result')\n\n    def prev_result(self, *, result_cb=None):\n        self.search_displayed = True\n        # The int() here makes sure we get a copy of the flags.\n        flags = QWebPage.FindFlags(int(self._flags))  # type: ignore\n        if flags & QWebPage.FindBackward:\n            flags &= ~QWebPage.FindBackward\n        else:\n            flags |= QWebPage.FindBackward\n        found = self._widget.findText(self.text, flags)\n        self._call_cb(result_cb, found, self.text, flags, 'prev_result')\n\n\nclass WebKitCaret(browsertab.AbstractCaret):\n\n    \"\"\"QtWebKit implementations related to moving the cursor/selection.\"\"\"\n\n    @pyqtSlot(usertypes.KeyMode)\n    def _on_mode_entered(self, mode):\n        if mode != usertypes.KeyMode.caret:\n            return\n\n        self.selection_enabled = self._widget.hasSelection()\n        self.selection_toggled.emit(self.selection_enabled)\n        settings = self._widget.settings()\n        settings.setAttribute(QWebSettings.CaretBrowsingEnabled, True)\n\n        if self._widget.isVisible():\n            # Sometimes the caret isn't immediately visible, but unfocusing\n            # and refocusing it fixes that.\n            self._widget.clearFocus()\n            self._widget.setFocus(Qt.OtherFocusReason)\n\n            # Move the caret to the first element in the viewport if there\n            # isn't any text which is already selected.\n            #\n            # Note: We can't use hasSelection() here, as that's always\n            # true in caret mode.\n            if not self.selection_enabled:\n                self._widget.page().currentFrame().evaluateJavaScript(\n                    utils.read_file('javascript/position_caret.js'))\n\n    @pyqtSlot(usertypes.KeyMode)\n    def _on_mode_left(self, _mode):\n        settings = self._widget.settings()\n        if settings.testAttribute(QWebSettings.CaretBrowsingEnabled):\n            if self.selection_enabled and self._widget.hasSelection():\n                # Remove selection if it exists\n                self._widget.triggerPageAction(QWebPage.MoveToNextChar)\n            settings.setAttribute(QWebSettings.CaretBrowsingEnabled, False)\n            self.selection_enabled = False\n\n    def move_to_next_line(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToNextLine\n        else:\n            act = QWebPage.SelectNextLine\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_prev_line(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToPreviousLine\n        else:\n            act = QWebPage.SelectPreviousLine\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_next_char(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToNextChar\n        else:\n            act = QWebPage.SelectNextChar\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_prev_char(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToPreviousChar\n        else:\n            act = QWebPage.SelectPreviousChar\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_end_of_word(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToNextWord]\n            if utils.is_windows:  # pragma: no cover\n                act.append(QWebPage.MoveToPreviousChar)\n        else:\n            act = [QWebPage.SelectNextWord]\n            if utils.is_windows:  # pragma: no cover\n                act.append(QWebPage.SelectPreviousChar)\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_next_word(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToNextWord]\n            if not utils.is_windows:  # pragma: no branch\n                act.append(QWebPage.MoveToNextChar)\n        else:\n            act = [QWebPage.SelectNextWord]\n            if not utils.is_windows:  # pragma: no branch\n                act.append(QWebPage.SelectNextChar)\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_prev_word(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToPreviousWord\n        else:\n            act = QWebPage.SelectPreviousWord\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_start_of_line(self):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToStartOfLine\n        else:\n            act = QWebPage.SelectStartOfLine\n        self._widget.triggerPageAction(act)\n\n    def move_to_end_of_line(self):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToEndOfLine\n        else:\n            act = QWebPage.SelectEndOfLine\n        self._widget.triggerPageAction(act)\n\n    def move_to_start_of_next_block(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToNextLine,\n                   QWebPage.MoveToStartOfBlock]\n        else:\n            act = [QWebPage.SelectNextLine,\n                   QWebPage.SelectStartOfBlock]\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_start_of_prev_block(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToPreviousLine,\n                   QWebPage.MoveToStartOfBlock]\n        else:\n            act = [QWebPage.SelectPreviousLine,\n                   QWebPage.SelectStartOfBlock]\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_end_of_next_block(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToNextLine,\n                   QWebPage.MoveToEndOfBlock]\n        else:\n            act = [QWebPage.SelectNextLine,\n                   QWebPage.SelectEndOfBlock]\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_end_of_prev_block(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToPreviousLine, QWebPage.MoveToEndOfBlock]\n        else:\n            act = [QWebPage.SelectPreviousLine, QWebPage.SelectEndOfBlock]\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_start_of_document(self):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToStartOfDocument\n        else:\n            act = QWebPage.SelectStartOfDocument\n        self._widget.triggerPageAction(act)\n\n    def move_to_end_of_document(self):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToEndOfDocument\n        else:\n            act = QWebPage.SelectEndOfDocument\n        self._widget.triggerPageAction(act)\n\n    def toggle_selection(self):\n        self.selection_enabled = not self.selection_enabled\n        self.selection_toggled.emit(self.selection_enabled)\n\n    def drop_selection(self):\n        self._widget.triggerPageAction(QWebPage.MoveToNextChar)\n\n    def selection(self, callback):\n        callback(self._widget.selectedText())\n\n    def reverse_selection(self):\n        self._tab.run_js_async(\"\"\"{\n            const sel = window.getSelection();\n            sel.setBaseAndExtent(\n                sel.extentNode, sel.extentOffset, sel.baseNode,\n                sel.baseOffset\n            );\n        }\"\"\")\n\n    def _follow_selected(self, *, tab=False):\n        if QWebSettings.globalSettings().testAttribute(\n                QWebSettings.JavascriptEnabled):\n            if tab:\n                self._tab.data.override_target = usertypes.ClickTarget.tab\n            self._tab.run_js_async(\"\"\"\n                const aElm = document.activeElement;\n                if (window.getSelection().anchorNode) {\n                    window.getSelection().anchorNode.parentNode.click();\n                } else if (aElm && aElm !== document.body) {\n                    aElm.click();\n                }\n            \"\"\")\n        else:\n            selection = self._widget.selectedHtml()\n            if not selection:\n                # Getting here may mean we crashed, but we can't do anything\n                # about that until this commit is released:\n                # https://github.com/annulen/webkit/commit/0e75f3272d149bc64899c161f150eb341a2417af\n                # TODO find a way to check if something is focused\n                self._follow_enter(tab)\n                return\n            try:\n                selected_element = xml.etree.ElementTree.fromstring(\n                    '<html>{}</html>'.format(selection)).find('a')\n            except xml.etree.ElementTree.ParseError:\n                raise browsertab.WebTabError('Could not parse selected '\n                                             'element!')\n\n            if selected_element is not None:\n                try:\n                    url = selected_element.attrib['href']\n                except KeyError:\n                    raise browsertab.WebTabError('Anchor element without '\n                                                 'href!')\n                url = self._tab.url().resolved(QUrl(url))\n                if tab:\n                    self._tab.new_tab_requested.emit(url)\n                else:\n                    self._tab.load_url(url)\n\n    def follow_selected(self, *, tab=False):\n        try:\n            self._follow_selected(tab=tab)\n        finally:\n            self.follow_selected_done.emit()\n\n\nclass WebKitZoom(browsertab.AbstractZoom):\n\n    \"\"\"QtWebKit implementations related to zooming.\"\"\"\n\n    def _set_factor_internal(self, factor):\n        self._widget.setZoomFactor(factor)\n\n\nclass WebKitScroller(browsertab.AbstractScroller):\n\n    \"\"\"QtWebKit implementations related to scrolling.\"\"\"\n\n    # FIXME:qtwebengine When to use the main frame, when the current one?\n\n    def pos_px(self):\n        return self._widget.page().mainFrame().scrollPosition()\n\n    def pos_perc(self):\n        return self._widget.scroll_pos\n\n    def to_point(self, point):\n        self._widget.page().mainFrame().setScrollPosition(point)\n\n    def to_anchor(self, name):\n        self._widget.page().mainFrame().scrollToAnchor(name)\n\n    def delta(self, x: int = 0, y: int = 0) -> None:\n        qtutils.check_overflow(x, 'int')\n        qtutils.check_overflow(y, 'int')\n        self._widget.page().mainFrame().scroll(x, y)\n\n    def delta_page(self, x: float = 0.0, y: float = 0.0) -> None:\n        if y.is_integer():\n            y = int(y)\n            if y == 0:\n                pass\n            elif y < 0:\n                self.page_up(count=-y)\n            elif y > 0:\n                self.page_down(count=y)\n            y = 0\n        if x == 0 and y == 0:\n            return\n        size = self._widget.page().mainFrame().geometry()\n        self.delta(int(x * size.width()), int(y * size.height()))\n\n    def to_perc(self, x=None, y=None):\n        if x is None and y == 0:\n            self.top()\n        elif x is None and y == 100:\n            self.bottom()\n        else:\n            for val, orientation in [(x, Qt.Horizontal), (y, Qt.Vertical)]:\n                if val is not None:\n                    frame = self._widget.page().mainFrame()\n                    maximum = frame.scrollBarMaximum(orientation)\n                    if maximum == 0:\n                        continue\n                    pos = int(maximum * val / 100)\n                    pos = qtutils.check_overflow(pos, 'int', fatal=False)\n                    frame.setScrollBarValue(orientation, pos)\n\n    def _key_press(self, key, count=1, getter_name=None, direction=None):\n        frame = self._widget.page().mainFrame()\n        getter = None if getter_name is None else getattr(frame, getter_name)\n\n        # FIXME:qtwebengine needed?\n        # self._widget.setFocus()\n\n        for _ in range(min(count, 5000)):\n            # Abort scrolling if the minimum/maximum was reached.\n            if (getter is not None and\n                    frame.scrollBarValue(direction) == getter(direction)):\n                return\n            self._tab.fake_key_press(key)\n\n    def up(self, count=1):\n        self._key_press(Qt.Key_Up, count, 'scrollBarMinimum', Qt.Vertical)\n\n    def down(self, count=1):\n        self._key_press(Qt.Key_Down, count, 'scrollBarMaximum', Qt.Vertical)\n\n    def left(self, count=1):\n        self._key_press(Qt.Key_Left, count, 'scrollBarMinimum', Qt.Horizontal)\n\n    def right(self, count=1):\n        self._key_press(Qt.Key_Right, count, 'scrollBarMaximum', Qt.Horizontal)\n\n    def top(self):\n        self._key_press(Qt.Key_Home)\n\n    def bottom(self):\n        self._key_press(Qt.Key_End)\n\n    def page_up(self, count=1):\n        self._key_press(Qt.Key_PageUp, count, 'scrollBarMinimum', Qt.Vertical)\n\n    def page_down(self, count=1):\n        self._key_press(Qt.Key_PageDown, count, 'scrollBarMaximum',\n                        Qt.Vertical)\n\n    def at_top(self):\n        return self.pos_px().y() == 0\n\n    def at_bottom(self):\n        frame = self._widget.page().currentFrame()\n        return self.pos_px().y() >= frame.scrollBarMaximum(Qt.Vertical)\n\n\nclass WebKitHistoryPrivate(browsertab.AbstractHistoryPrivate):\n\n    \"\"\"History-related methods which are not part of the extension API.\"\"\"\n\n    def serialize(self):\n        return qtutils.serialize(self._history)\n\n    def deserialize(self, data):\n        qtutils.deserialize(data, self._history)\n\n    def load_items(self, items):\n        if items:\n            self._tab.before_load_started.emit(items[-1].url)\n\n        stream, _data, user_data = tabhistory.serialize(items)\n        qtutils.deserialize_stream(stream, self._history)\n        for i, data in enumerate(user_data):\n            self._history.itemAt(i).setUserData(data)\n        cur_data = self._history.currentItem().userData()\n        if cur_data is not None:\n            if 'zoom' in cur_data:\n                self._tab.zoom.set_factor(cur_data['zoom'])\n            if ('scroll-pos' in cur_data and\n                    self._tab.scroller.pos_px() == QPoint(0, 0)):\n                QTimer.singleShot(0, functools.partial(\n                    self._tab.scroller.to_point, cur_data['scroll-pos']))\n\n\nclass WebKitHistory(browsertab.AbstractHistory):\n\n    \"\"\"QtWebKit implementations related to page history.\"\"\"\n\n    def __init__(self, tab):\n        super().__init__(tab)\n        self.private_api = WebKitHistoryPrivate(tab)\n\n    def __len__(self):\n        return len(self._history)\n\n    def __iter__(self):\n        return iter(self._history.items())\n\n    def current_idx(self):\n        return self._history.currentItemIndex()\n\n    def can_go_back(self):\n        return self._history.canGoBack()\n\n    def can_go_forward(self):\n        return self._history.canGoForward()\n\n    def _item_at(self, i):\n        return self._history.itemAt(i)\n\n    def _go_to_item(self, item):\n        self._tab.before_load_started.emit(item.url())\n        self._history.goToItem(item)\n\n\nclass WebKitElements(browsertab.AbstractElements):\n\n    \"\"\"QtWebKit implemementations related to elements on the page.\"\"\"\n\n    def find_css(self, selector, callback, error_cb, *, only_visible=False):\n        utils.unused(error_cb)\n        mainframe = self._widget.page().mainFrame()\n        if mainframe is None:\n            raise browsertab.WebTabError(\"No frame focused!\")\n\n        elems = []\n        frames = webkitelem.get_child_frames(mainframe)\n        for f in frames:\n            for elem in f.findAllElements(selector):\n                elems.append(webkitelem.WebKitElement(elem, tab=self._tab))\n\n        if only_visible:\n            # pylint: disable=protected-access\n            elems = [e for e in elems if e._is_visible(mainframe)]\n            # pylint: enable=protected-access\n\n        callback(elems)\n\n    def find_id(self, elem_id, callback):\n        def find_id_cb(elems):\n            \"\"\"Call the real callback with the found elements.\"\"\"\n            if not elems:\n                callback(None)\n            else:\n                callback(elems[0])\n\n        # Escape non-alphanumeric characters in the selector\n        # https://www.w3.org/TR/CSS2/syndata.html#value-def-identifier\n        elem_id = re.sub(r'[^a-zA-Z0-9_-]', r'\\\\\\g<0>', elem_id)\n        self.find_css('#' + elem_id, find_id_cb, error_cb=lambda exc: None)\n\n    def find_focused(self, callback):\n        frame = self._widget.page().currentFrame()\n        if frame is None:\n            callback(None)\n            return\n\n        elem = frame.findFirstElement('*:focus')\n        if elem.isNull():\n            callback(None)\n        else:\n            callback(webkitelem.WebKitElement(elem, tab=self._tab))\n\n    def find_at_pos(self, pos, callback):\n        assert pos.x() >= 0\n        assert pos.y() >= 0\n        frame = self._widget.page().frameAt(pos)\n        if frame is None:\n            # This happens when we click inside the webview, but not actually\n            # on the QWebPage - for example when clicking the scrollbar\n            # sometimes.\n            log.webview.debug(\"Hit test at {} but frame is None!\".format(pos))\n            callback(None)\n            return\n\n        # You'd think we have to subtract frame.geometry().topLeft() from the\n        # position, but it seems QWebFrame::hitTestContent wants a position\n        # relative to the QWebView, not to the frame. This makes no sense to\n        # me, but it works this way.\n        hitresult = frame.hitTestContent(pos)\n        if hitresult.isNull():\n            # For some reason, the whole hit result can be null sometimes (e.g.\n            # on doodle menu links).\n            log.webview.debug(\"Hit test result is null!\")\n            callback(None)\n            return\n\n        try:\n            elem = webkitelem.WebKitElement(hitresult.element(), tab=self._tab)\n        except webkitelem.IsNullError:\n            # For some reason, the hit result element can be a null element\n            # sometimes (e.g. when clicking the timetable fields on\n            # http://www.sbb.ch/ ).\n            log.webview.debug(\"Hit test result element is null!\")\n            callback(None)\n            return\n\n        callback(elem)\n\n\nclass WebKitAudio(browsertab.AbstractAudio):\n\n    \"\"\"Dummy handling of audio status for QtWebKit.\"\"\"\n\n    def set_muted(self, muted: bool, override: bool = False) -> None:\n        raise browsertab.WebTabError('Muting is not supported on QtWebKit!')\n\n    def is_muted(self):\n        return False\n\n    def is_recently_audible(self):\n        return False\n\n\nclass WebKitTabPrivate(browsertab.AbstractTabPrivate):\n\n    \"\"\"QtWebKit-related methods which aren't part of the public API.\"\"\"\n\n    def networkaccessmanager(self):\n        return self._widget.page().networkAccessManager()\n\n    def clear_ssl_errors(self):\n        self.networkaccessmanager().clear_all_ssl_errors()\n\n    def event_target(self):\n        return self._widget\n\n    def shutdown(self):\n        self._widget.shutdown()\n\n\nclass WebKitTab(browsertab.AbstractTab):\n\n    \"\"\"A QtWebKit tab in the browser.\"\"\"\n\n    def __init__(self, *, win_id, mode_manager, private, parent=None):\n        super().__init__(win_id=win_id, private=private, parent=parent)\n        widget = webview.WebView(win_id=win_id, tab_id=self.tab_id,\n                                 private=private, tab=self)\n        if private:\n            self._make_private(widget)\n        self.history = WebKitHistory(tab=self)\n        self.scroller = WebKitScroller(tab=self, parent=self)\n        self.caret = WebKitCaret(mode_manager=mode_manager,\n                                 tab=self, parent=self)\n        self.zoom = WebKitZoom(tab=self, parent=self)\n        self.search = WebKitSearch(tab=self, parent=self)\n        self.printing = WebKitPrinting(tab=self)\n        self.elements = WebKitElements(tab=self)\n        self.action = WebKitAction(tab=self)\n        self.audio = WebKitAudio(tab=self, parent=self)\n        self.private_api = WebKitTabPrivate(mode_manager=mode_manager,\n                                            tab=self)\n        # We're assigning settings in _set_widget\n        self.settings = webkitsettings.WebKitSettings(settings=None)\n        self._set_widget(widget)\n        self._connect_signals()\n        self.backend = usertypes.Backend.QtWebKit\n\n    def _install_event_filter(self):\n        self._widget.installEventFilter(self._tab_event_filter)\n\n    def _make_private(self, widget):\n        settings = widget.settings()\n        settings.setAttribute(QWebSettings.PrivateBrowsingEnabled, True)\n\n    def load_url(self, url, *, emit_before_load_started=True):\n        self._load_url_prepare(\n            url, emit_before_load_started=emit_before_load_started)\n        self._widget.load(url)\n\n    def url(self, *, requested=False):\n        frame = self._widget.page().mainFrame()\n        if requested:\n            return frame.requestedUrl()\n        else:\n            return frame.url()\n\n    def dump_async(self, callback, *, plain=False):\n        frame = self._widget.page().mainFrame()\n        if plain:\n            callback(frame.toPlainText())\n        else:\n            callback(frame.toHtml())\n\n    def run_js_async(self, code, callback=None, *, world=None):\n        if world is not None and world != usertypes.JsWorld.jseval:\n            log.webview.warning(\"Ignoring world ID {}\".format(world))\n        document_element = self._widget.page().mainFrame().documentElement()\n        result = document_element.evaluateJavaScript(code)\n        if callback is not None:\n            callback(result)\n\n    def icon(self):\n        return self._widget.icon()\n\n    def reload(self, *, force=False):\n        if force:\n            action = QWebPage.ReloadAndBypassCache\n        else:\n            action = QWebPage.Reload\n        self._widget.triggerPageAction(action)\n\n    def stop(self):\n        self._widget.stop()\n\n    def title(self):\n        return self._widget.title()\n\n    @pyqtSlot()\n    def _on_history_trigger(self):\n        url = self.url()\n        requested_url = self.url(requested=True)\n        self.history_item_triggered.emit(url, requested_url, self.title())\n\n    def set_html(self, html, base_url=QUrl()):\n        self._widget.setHtml(html, base_url)\n\n    @pyqtSlot()\n    def _on_load_started(self):\n        super()._on_load_started()\n        nam = self._widget.page().networkAccessManager()\n        nam.netrc_used = False\n        # Make sure the icon is cleared when navigating to a page without one.\n        self.icon_changed.emit(QIcon())\n\n    @pyqtSlot(bool)\n    def _on_load_finished(self, ok: bool) -> None:\n        super()._on_load_finished(ok)\n        self._update_load_status(ok)\n\n    @pyqtSlot()\n    def _on_frame_load_finished(self):\n        \"\"\"Make sure we emit an appropriate status when loading finished.\n\n        While Qt has a bool \"ok\" attribute for loadFinished, it always is True\n        when using error pages... See\n        https://github.com/qutebrowser/qutebrowser/issues/84\n        \"\"\"\n        self._on_load_finished(not self._widget.page().error_occurred)\n\n    @pyqtSlot()\n    def _on_webkit_icon_changed(self):\n        \"\"\"Emit iconChanged with a QIcon like QWebEngineView does.\"\"\"\n        if sip.isdeleted(self._widget):\n            log.webview.debug(\"Got _on_webkit_icon_changed for deleted view!\")\n            return\n        self.icon_changed.emit(self._widget.icon())\n\n    @pyqtSlot(QWebFrame)\n    def _on_frame_created(self, frame):\n        \"\"\"Connect the contentsSizeChanged signal of each frame.\"\"\"\n        # FIXME:qtwebengine those could theoretically regress:\n        # https://github.com/qutebrowser/qutebrowser/issues/152\n        # https://github.com/qutebrowser/qutebrowser/issues/263\n        frame.contentsSizeChanged.connect(self._on_contents_size_changed)\n\n    @pyqtSlot(QSize)\n    def _on_contents_size_changed(self, size):\n        self.contents_size_changed.emit(QSizeF(size))\n\n    @pyqtSlot(usertypes.NavigationRequest)\n    def _on_navigation_request(self, navigation):\n        super()._on_navigation_request(navigation)\n        if not navigation.accepted:\n            return\n\n        log.webview.debug(\"target {} override {}\".format(\n            self.data.open_target, self.data.override_target))\n\n        if self.data.override_target is not None:\n            target = self.data.override_target\n            self.data.override_target = None\n        else:\n            target = self.data.open_target\n\n        if (navigation.navigation_type == navigation.Type.link_clicked and\n                target != usertypes.ClickTarget.normal):\n            tab = shared.get_tab(self.win_id, target)\n            tab.load_url(navigation.url)\n            self.data.open_target = usertypes.ClickTarget.normal\n            navigation.accepted = False\n\n        if navigation.is_main_frame:\n            self.settings.update_for_url(navigation.url)\n\n    @pyqtSlot()\n    def _on_ssl_errors(self):\n        self._has_ssl_errors = True\n\n    def _connect_signals(self):\n        view = self._widget\n        page = view.page()\n        frame = page.mainFrame()\n        page.windowCloseRequested.connect(self.window_close_requested)\n        page.linkHovered.connect(self.link_hovered)\n        page.loadProgress.connect(self._on_load_progress)\n        frame.loadStarted.connect(self._on_load_started)\n        view.scroll_pos_changed.connect(self.scroller.perc_changed)\n        view.titleChanged.connect(self.title_changed)\n        view.urlChanged.connect(self._on_url_changed)\n        view.shutting_down.connect(self.shutting_down)\n        page.networkAccessManager().sslErrors.connect(self._on_ssl_errors)\n        frame.loadFinished.connect(self._on_frame_load_finished)\n        view.iconChanged.connect(self._on_webkit_icon_changed)\n        page.frameCreated.connect(self._on_frame_created)\n        frame.contentsSizeChanged.connect(self._on_contents_size_changed)\n        frame.initialLayoutCompleted.connect(self._on_history_trigger)\n        page.navigation_request.connect(self._on_navigation_request)\n"], "fixing_code": ["# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2016-2020 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"Base class for a wrapper over QWebView/QWebEngineView.\"\"\"\n\nimport enum\nimport itertools\nimport typing\nimport functools\n\nimport attr\nfrom PyQt5.QtCore import (pyqtSignal, pyqtSlot, QUrl, QObject, QSizeF, Qt,\n                          QEvent, QPoint)\nfrom PyQt5.QtGui import QKeyEvent, QIcon\nfrom PyQt5.QtWidgets import QWidget, QApplication, QDialog\nfrom PyQt5.QtPrintSupport import QPrintDialog, QPrinter\nfrom PyQt5.QtNetwork import QNetworkAccessManager\n\nif typing.TYPE_CHECKING:\n    from PyQt5.QtWebKit import QWebHistory\n    from PyQt5.QtWebEngineWidgets import QWebEngineHistory\n\nimport pygments\nimport pygments.lexers\nimport pygments.formatters\n\nfrom qutebrowser.keyinput import modeman\nfrom qutebrowser.config import config\nfrom qutebrowser.utils import (utils, objreg, usertypes, log, qtutils,\n                               urlutils, message)\nfrom qutebrowser.misc import miscwidgets, objects, sessions\nfrom qutebrowser.browser import eventfilter\nfrom qutebrowser.qt import sip\n\nif typing.TYPE_CHECKING:\n    from qutebrowser.browser import webelem\n    from qutebrowser.browser.inspector import AbstractWebInspector\n\n\ntab_id_gen = itertools.count(0)\n\n\ndef create(win_id: int,\n           private: bool,\n           parent: QWidget = None) -> 'AbstractTab':\n    \"\"\"Get a QtWebKit/QtWebEngine tab object.\n\n    Args:\n        win_id: The window ID where the tab will be shown.\n        private: Whether the tab is a private/off the record tab.\n        parent: The Qt parent to set.\n    \"\"\"\n    # Importing modules here so we don't depend on QtWebEngine without the\n    # argument and to avoid circular imports.\n    mode_manager = modeman.instance(win_id)\n    if objects.backend == usertypes.Backend.QtWebEngine:\n        from qutebrowser.browser.webengine import webenginetab\n        tab_class = webenginetab.WebEngineTab\n    else:\n        from qutebrowser.browser.webkit import webkittab\n        tab_class = webkittab.WebKitTab\n    return tab_class(win_id=win_id, mode_manager=mode_manager, private=private,\n                     parent=parent)\n\n\ndef init() -> None:\n    \"\"\"Initialize backend-specific modules.\"\"\"\n    if objects.backend == usertypes.Backend.QtWebEngine:\n        from qutebrowser.browser.webengine import webenginetab\n        webenginetab.init()\n\n\nclass WebTabError(Exception):\n\n    \"\"\"Base class for various errors.\"\"\"\n\n\nclass UnsupportedOperationError(WebTabError):\n\n    \"\"\"Raised when an operation is not supported with the given backend.\"\"\"\n\n\nTerminationStatus = enum.Enum('TerminationStatus', [\n    'normal',\n    'abnormal',  # non-zero exit status\n    'crashed',   # e.g. segfault\n    'killed',\n    'unknown',\n])\n\n\n@attr.s\nclass TabData:\n\n    \"\"\"A simple namespace with a fixed set of attributes.\n\n    Attributes:\n        keep_icon: Whether the (e.g. cloned) icon should not be cleared on page\n                   load.\n        inspector: The QWebInspector used for this webview.\n        viewing_source: Set if we're currently showing a source view.\n                        Only used when sources are shown via pygments.\n        open_target: Where to open the next link.\n                     Only used for QtWebKit.\n        override_target: Override for open_target for fake clicks (like hints).\n                         Only used for QtWebKit.\n        pinned: Flag to pin the tab.\n        fullscreen: Whether the tab has a video shown fullscreen currently.\n        netrc_used: Whether netrc authentication was performed.\n        input_mode: current input mode for the tab.\n    \"\"\"\n\n    keep_icon = attr.ib(False)  # type: bool\n    viewing_source = attr.ib(False)  # type: bool\n    inspector = attr.ib(None)  # type: typing.Optional[AbstractWebInspector]\n    open_target = attr.ib(\n        usertypes.ClickTarget.normal)  # type: usertypes.ClickTarget\n    override_target = attr.ib(\n        None)  # type: typing.Optional[usertypes.ClickTarget]\n    pinned = attr.ib(False)  # type: bool\n    fullscreen = attr.ib(False)  # type: bool\n    netrc_used = attr.ib(False)  # type: bool\n    input_mode = attr.ib(usertypes.KeyMode.normal)  # type: usertypes.KeyMode\n    last_navigation = attr.ib(None)  # type: usertypes.NavigationRequest\n\n    def should_show_icon(self) -> bool:\n        return (config.val.tabs.favicons.show == 'always' or\n                config.val.tabs.favicons.show == 'pinned' and self.pinned)\n\n\nclass AbstractAction:\n\n    \"\"\"Attribute ``action`` of AbstractTab for Qt WebActions.\"\"\"\n\n    # The class actions are defined on (QWeb{Engine,}Page)\n    action_class = None  # type: type\n    # The type of the actions (QWeb{Engine,}Page.WebAction)\n    action_base = None  # type: type\n\n    def __init__(self, tab: 'AbstractTab') -> None:\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n\n    def exit_fullscreen(self) -> None:\n        \"\"\"Exit the fullscreen mode.\"\"\"\n        raise NotImplementedError\n\n    def save_page(self) -> None:\n        \"\"\"Save the current page.\"\"\"\n        raise NotImplementedError\n\n    def run_string(self, name: str) -> None:\n        \"\"\"Run a webaction based on its name.\"\"\"\n        member = getattr(self.action_class, name, None)\n        if not isinstance(member, self.action_base):\n            raise WebTabError(\"{} is not a valid web action!\".format(name))\n        self._widget.triggerPageAction(member)\n\n    def show_source(\n            self,\n            pygments: bool = False  # pylint: disable=redefined-outer-name\n    ) -> None:\n        \"\"\"Show the source of the current page in a new tab.\"\"\"\n        raise NotImplementedError\n\n    def _show_source_pygments(self) -> None:\n\n        def show_source_cb(source: str) -> None:\n            \"\"\"Show source as soon as it's ready.\"\"\"\n            # WORKAROUND for https://github.com/PyCQA/pylint/issues/491\n            # pylint: disable=no-member\n            lexer = pygments.lexers.HtmlLexer()\n            formatter = pygments.formatters.HtmlFormatter(\n                full=True, linenos='table')\n            # pylint: enable=no-member\n            highlighted = pygments.highlight(source, lexer, formatter)\n\n            tb = objreg.get('tabbed-browser', scope='window',\n                            window=self._tab.win_id)\n            new_tab = tb.tabopen(background=False, related=True)\n            new_tab.set_html(highlighted, self._tab.url())\n            new_tab.data.viewing_source = True\n\n        self._tab.dump_async(show_source_cb)\n\n\nclass AbstractPrinting:\n\n    \"\"\"Attribute ``printing`` of AbstractTab for printing the page.\"\"\"\n\n    def __init__(self, tab: 'AbstractTab') -> None:\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n\n    def check_pdf_support(self) -> None:\n        \"\"\"Check whether writing to PDFs is supported.\n\n        If it's not supported (by the current Qt version), a WebTabError is\n        raised.\n        \"\"\"\n        raise NotImplementedError\n\n    def check_printer_support(self) -> None:\n        \"\"\"Check whether writing to a printer is supported.\n\n        If it's not supported (by the current Qt version), a WebTabError is\n        raised.\n        \"\"\"\n        raise NotImplementedError\n\n    def check_preview_support(self) -> None:\n        \"\"\"Check whether showing a print preview is supported.\n\n        If it's not supported (by the current Qt version), a WebTabError is\n        raised.\n        \"\"\"\n        raise NotImplementedError\n\n    def to_pdf(self, filename: str) -> bool:\n        \"\"\"Print the tab to a PDF with the given filename.\"\"\"\n        raise NotImplementedError\n\n    def to_printer(self, printer: QPrinter,\n                   callback: typing.Callable[[bool], None] = None) -> None:\n        \"\"\"Print the tab.\n\n        Args:\n            printer: The QPrinter to print to.\n            callback: Called with a boolean\n                      (True if printing succeeded, False otherwise)\n        \"\"\"\n        raise NotImplementedError\n\n    def show_dialog(self) -> None:\n        \"\"\"Print with a QPrintDialog.\"\"\"\n        self.check_printer_support()\n\n        def print_callback(ok: bool) -> None:\n            \"\"\"Called when printing finished.\"\"\"\n            if not ok:\n                message.error(\"Printing failed!\")\n            diag.deleteLater()\n\n        def do_print() -> None:\n            \"\"\"Called when the dialog was closed.\"\"\"\n            self.to_printer(diag.printer(), print_callback)\n\n        diag = QPrintDialog(self._tab)\n        if utils.is_mac:\n            # For some reason we get a segfault when using open() on macOS\n            ret = diag.exec_()\n            if ret == QDialog.Accepted:\n                do_print()\n        else:\n            diag.open(do_print)\n\n\nclass AbstractSearch(QObject):\n\n    \"\"\"Attribute ``search`` of AbstractTab for doing searches.\n\n    Attributes:\n        text: The last thing this view was searched for.\n        search_displayed: Whether we're currently displaying search results in\n                          this view.\n        _flags: The flags of the last search (needs to be set by subclasses).\n        _widget: The underlying WebView widget.\n    \"\"\"\n\n    #: Signal emitted when a search was finished\n    #: (True if the text was found, False otherwise)\n    finished = pyqtSignal(bool)\n    #: Signal emitted when an existing search was cleared.\n    cleared = pyqtSignal()\n\n    _Callback = typing.Callable[[bool], None]\n\n    def __init__(self, tab: 'AbstractTab', parent: QWidget = None):\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        self.text = None  # type: typing.Optional[str]\n        self.search_displayed = False\n\n    def _is_case_sensitive(self, ignore_case: usertypes.IgnoreCase) -> bool:\n        \"\"\"Check if case-sensitivity should be used.\n\n        This assumes self.text is already set properly.\n\n        Arguments:\n            ignore_case: The ignore_case value from the config.\n        \"\"\"\n        assert self.text is not None\n        mapping = {\n            usertypes.IgnoreCase.smart: not self.text.islower(),\n            usertypes.IgnoreCase.never: True,\n            usertypes.IgnoreCase.always: False,\n        }\n        return mapping[ignore_case]\n\n    def search(self, text: str, *,\n               ignore_case: usertypes.IgnoreCase = usertypes.IgnoreCase.never,\n               reverse: bool = False,\n               wrap: bool = True,\n               result_cb: _Callback = None) -> None:\n        \"\"\"Find the given text on the page.\n\n        Args:\n            text: The text to search for.\n            ignore_case: Search case-insensitively.\n            reverse: Reverse search direction.\n            wrap: Allow wrapping at the top or bottom of the page.\n            result_cb: Called with a bool indicating whether a match was found.\n        \"\"\"\n        raise NotImplementedError\n\n    def clear(self) -> None:\n        \"\"\"Clear the current search.\"\"\"\n        raise NotImplementedError\n\n    def prev_result(self, *, result_cb: _Callback = None) -> None:\n        \"\"\"Go to the previous result of the current search.\n\n        Args:\n            result_cb: Called with a bool indicating whether a match was found.\n        \"\"\"\n        raise NotImplementedError\n\n    def next_result(self, *, result_cb: _Callback = None) -> None:\n        \"\"\"Go to the next result of the current search.\n\n        Args:\n            result_cb: Called with a bool indicating whether a match was found.\n        \"\"\"\n        raise NotImplementedError\n\n\nclass AbstractZoom(QObject):\n\n    \"\"\"Attribute ``zoom`` of AbstractTab for controlling zoom.\"\"\"\n\n    def __init__(self, tab: 'AbstractTab', parent: QWidget = None) -> None:\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        # Whether zoom was changed from the default.\n        self._default_zoom_changed = False\n        self._init_neighborlist()\n        config.instance.changed.connect(self._on_config_changed)\n        self._zoom_factor = float(config.val.zoom.default) / 100\n\n    @pyqtSlot(str)\n    def _on_config_changed(self, option: str) -> None:\n        if option in ['zoom.levels', 'zoom.default']:\n            if not self._default_zoom_changed:\n                factor = float(config.val.zoom.default) / 100\n                self.set_factor(factor)\n            self._init_neighborlist()\n\n    def _init_neighborlist(self) -> None:\n        \"\"\"Initialize self._neighborlist.\n\n        It is a NeighborList with the zoom levels.\"\"\"\n        levels = config.val.zoom.levels\n        self._neighborlist = usertypes.NeighborList(\n            levels, mode=usertypes.NeighborList.Modes.edge\n        )  # type: usertypes.NeighborList[float]\n        self._neighborlist.fuzzyval = config.val.zoom.default\n\n    def apply_offset(self, offset: int) -> float:\n        \"\"\"Increase/Decrease the zoom level by the given offset.\n\n        Args:\n            offset: The offset in the zoom level list.\n\n        Return:\n            The new zoom level.\n        \"\"\"\n        level = self._neighborlist.getitem(offset)\n        self.set_factor(float(level) / 100, fuzzyval=False)\n        return level\n\n    def _set_factor_internal(self, factor: float) -> None:\n        raise NotImplementedError\n\n    def set_factor(self, factor: float, *, fuzzyval: bool = True) -> None:\n        \"\"\"Zoom to a given zoom factor.\n\n        Args:\n            factor: The zoom factor as float.\n            fuzzyval: Whether to set the NeighborLists fuzzyval.\n        \"\"\"\n        if fuzzyval:\n            self._neighborlist.fuzzyval = int(factor * 100)\n        if factor < 0:\n            raise ValueError(\"Can't zoom to factor {}!\".format(factor))\n\n        default_zoom_factor = float(config.val.zoom.default) / 100\n        self._default_zoom_changed = (factor != default_zoom_factor)\n\n        self._zoom_factor = factor\n        self._set_factor_internal(factor)\n\n    def factor(self) -> float:\n        return self._zoom_factor\n\n    def apply_default(self) -> None:\n        self._set_factor_internal(float(config.val.zoom.default) / 100)\n\n    def reapply(self) -> None:\n        self._set_factor_internal(self._zoom_factor)\n\n\nclass AbstractCaret(QObject):\n\n    \"\"\"Attribute ``caret`` of AbstractTab for caret browsing.\"\"\"\n\n    #: Signal emitted when the selection was toggled.\n    #: (argument - whether the selection is now active)\n    selection_toggled = pyqtSignal(bool)\n    #: Emitted when a ``follow_selection`` action is done.\n    follow_selected_done = pyqtSignal()\n\n    def __init__(self,\n                 tab: 'AbstractTab',\n                 mode_manager: modeman.ModeManager,\n                 parent: QWidget = None) -> None:\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        self.selection_enabled = False\n        self._mode_manager = mode_manager\n        mode_manager.entered.connect(self._on_mode_entered)\n        mode_manager.left.connect(self._on_mode_left)\n\n    def _on_mode_entered(self, mode: usertypes.KeyMode) -> None:\n        raise NotImplementedError\n\n    def _on_mode_left(self, mode: usertypes.KeyMode) -> None:\n        raise NotImplementedError\n\n    def move_to_next_line(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_prev_line(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_next_char(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_prev_char(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_word(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_next_word(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_prev_word(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_start_of_line(self) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_line(self) -> None:\n        raise NotImplementedError\n\n    def move_to_start_of_next_block(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_start_of_prev_block(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_next_block(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_prev_block(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def move_to_start_of_document(self) -> None:\n        raise NotImplementedError\n\n    def move_to_end_of_document(self) -> None:\n        raise NotImplementedError\n\n    def toggle_selection(self) -> None:\n        raise NotImplementedError\n\n    def drop_selection(self) -> None:\n        raise NotImplementedError\n\n    def selection(self, callback: typing.Callable[[str], None]) -> None:\n        raise NotImplementedError\n\n    def reverse_selection(self) -> None:\n        raise NotImplementedError\n\n    def _follow_enter(self, tab: bool) -> None:\n        \"\"\"Follow a link by faking an enter press.\"\"\"\n        if tab:\n            self._tab.fake_key_press(Qt.Key_Enter, modifier=Qt.ControlModifier)\n        else:\n            self._tab.fake_key_press(Qt.Key_Enter)\n\n    def follow_selected(self, *, tab: bool = False) -> None:\n        raise NotImplementedError\n\n\nclass AbstractScroller(QObject):\n\n    \"\"\"Attribute ``scroller`` of AbstractTab to manage scroll position.\"\"\"\n\n    #: Signal emitted when the scroll position changed (int, int)\n    perc_changed = pyqtSignal(int, int)\n    #: Signal emitted before the user requested a jump.\n    #: Used to set the special ' mark so the user can return.\n    before_jump_requested = pyqtSignal()\n\n    def __init__(self, tab: 'AbstractTab', parent: QWidget = None):\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        if 'log-scroll-pos' in objects.debug_flags:\n            self.perc_changed.connect(self._log_scroll_pos_change)\n\n    @pyqtSlot()\n    def _log_scroll_pos_change(self) -> None:\n        log.webview.vdebug(  # type: ignore\n            \"Scroll position changed to {}\".format(self.pos_px()))\n\n    def _init_widget(self, widget: QWidget) -> None:\n        self._widget = widget\n\n    def pos_px(self) -> int:\n        raise NotImplementedError\n\n    def pos_perc(self) -> int:\n        raise NotImplementedError\n\n    def to_perc(self, x: int = None, y: int = None) -> None:\n        raise NotImplementedError\n\n    def to_point(self, point: QPoint) -> None:\n        raise NotImplementedError\n\n    def to_anchor(self, name: str) -> None:\n        raise NotImplementedError\n\n    def delta(self, x: int = 0, y: int = 0) -> None:\n        raise NotImplementedError\n\n    def delta_page(self, x: float = 0, y: float = 0) -> None:\n        raise NotImplementedError\n\n    def up(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def down(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def left(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def right(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def top(self) -> None:\n        raise NotImplementedError\n\n    def bottom(self) -> None:\n        raise NotImplementedError\n\n    def page_up(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def page_down(self, count: int = 1) -> None:\n        raise NotImplementedError\n\n    def at_top(self) -> bool:\n        raise NotImplementedError\n\n    def at_bottom(self) -> bool:\n        raise NotImplementedError\n\n\nclass AbstractHistoryPrivate:\n\n    \"\"\"Private API related to the history.\"\"\"\n\n    def __init__(self, tab: 'AbstractTab'):\n        self._tab = tab\n        self._history = typing.cast(\n            typing.Union['QWebHistory', 'QWebEngineHistory'], None)\n\n    def serialize(self) -> bytes:\n        \"\"\"Serialize into an opaque format understood by self.deserialize.\"\"\"\n        raise NotImplementedError\n\n    def deserialize(self, data: bytes) -> None:\n        \"\"\"Deserialize from a format produced by self.serialize.\"\"\"\n        raise NotImplementedError\n\n    def load_items(self, items: typing.Sequence) -> None:\n        \"\"\"Deserialize from a list of WebHistoryItems.\"\"\"\n        raise NotImplementedError\n\n\nclass AbstractHistory:\n\n    \"\"\"The history attribute of a AbstractTab.\"\"\"\n\n    def __init__(self, tab: 'AbstractTab') -> None:\n        self._tab = tab\n        self._history = typing.cast(\n            typing.Union['QWebHistory', 'QWebEngineHistory'], None)\n        self.private_api = AbstractHistoryPrivate(tab)\n\n    def __len__(self) -> int:\n        raise NotImplementedError\n\n    def __iter__(self) -> typing.Iterable:\n        raise NotImplementedError\n\n    def _check_count(self, count: int) -> None:\n        \"\"\"Check whether the count is positive.\"\"\"\n        if count < 0:\n            raise WebTabError(\"count needs to be positive!\")\n\n    def current_idx(self) -> int:\n        raise NotImplementedError\n\n    def back(self, count: int = 1) -> None:\n        \"\"\"Go back in the tab's history.\"\"\"\n        self._check_count(count)\n        idx = self.current_idx() - count\n        if idx >= 0:\n            self._go_to_item(self._item_at(idx))\n        else:\n            self._go_to_item(self._item_at(0))\n            raise WebTabError(\"At beginning of history.\")\n\n    def forward(self, count: int = 1) -> None:\n        \"\"\"Go forward in the tab's history.\"\"\"\n        self._check_count(count)\n        idx = self.current_idx() + count\n        if idx < len(self):\n            self._go_to_item(self._item_at(idx))\n        else:\n            self._go_to_item(self._item_at(len(self) - 1))\n            raise WebTabError(\"At end of history.\")\n\n    def can_go_back(self) -> bool:\n        raise NotImplementedError\n\n    def can_go_forward(self) -> bool:\n        raise NotImplementedError\n\n    def _item_at(self, i: int) -> typing.Any:\n        raise NotImplementedError\n\n    def _go_to_item(self, item: typing.Any) -> None:\n        raise NotImplementedError\n\n\nclass AbstractElements:\n\n    \"\"\"Finding and handling of elements on the page.\"\"\"\n\n    _MultiCallback = typing.Callable[\n        [typing.Sequence['webelem.AbstractWebElement']], None]\n    _SingleCallback = typing.Callable[\n        [typing.Optional['webelem.AbstractWebElement']], None]\n    _ErrorCallback = typing.Callable[[Exception], None]\n\n    def __init__(self, tab: 'AbstractTab') -> None:\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n\n    def find_css(self, selector: str,\n                 callback: _MultiCallback,\n                 error_cb: _ErrorCallback, *,\n                 only_visible: bool = False) -> None:\n        \"\"\"Find all HTML elements matching a given selector async.\n\n        If there's an error, the callback is called with a webelem.Error\n        instance.\n\n        Args:\n            callback: The callback to be called when the search finished.\n            error_cb: The callback to be called when an error occurred.\n            selector: The CSS selector to search for.\n            only_visible: Only show elements which are visible on screen.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_id(self, elem_id: str, callback: _SingleCallback) -> None:\n        \"\"\"Find the HTML element with the given ID async.\n\n        Args:\n            callback: The callback to be called when the search finished.\n                      Called with a WebEngineElement or None.\n            elem_id: The ID to search for.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_focused(self, callback: _SingleCallback) -> None:\n        \"\"\"Find the focused element on the page async.\n\n        Args:\n            callback: The callback to be called when the search finished.\n                      Called with a WebEngineElement or None.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_at_pos(self, pos: QPoint, callback: _SingleCallback) -> None:\n        \"\"\"Find the element at the given position async.\n\n        This is also called \"hit test\" elsewhere.\n\n        Args:\n            pos: The QPoint to get the element for.\n            callback: The callback to be called when the search finished.\n                      Called with a WebEngineElement or None.\n        \"\"\"\n        raise NotImplementedError\n\n\nclass AbstractAudio(QObject):\n\n    \"\"\"Handling of audio/muting for this tab.\"\"\"\n\n    muted_changed = pyqtSignal(bool)\n    recently_audible_changed = pyqtSignal(bool)\n\n    def __init__(self, tab: 'AbstractTab', parent: QWidget = None) -> None:\n        super().__init__(parent)\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n\n    def set_muted(self, muted: bool, override: bool = False) -> None:\n        \"\"\"Set this tab as muted or not.\n\n        Arguments:\n            override: If set to True, muting/unmuting was done manually and\n                      overrides future automatic mute/unmute changes based on\n                      the URL.\n        \"\"\"\n        raise NotImplementedError\n\n    def is_muted(self) -> bool:\n        raise NotImplementedError\n\n    def is_recently_audible(self) -> bool:\n        \"\"\"Whether this tab has had audio playing recently.\"\"\"\n        raise NotImplementedError\n\n\nclass AbstractTabPrivate:\n\n    \"\"\"Tab-related methods which are only needed in the core.\n\n    Those methods are not part of the API which is exposed to extensions, and\n    should ideally be removed at some point in the future.\n    \"\"\"\n\n    def __init__(self, mode_manager: modeman.ModeManager,\n                 tab: 'AbstractTab') -> None:\n        self._widget = typing.cast(QWidget, None)\n        self._tab = tab\n        self._mode_manager = mode_manager\n\n    def event_target(self) -> QWidget:\n        \"\"\"Return the widget events should be sent to.\"\"\"\n        raise NotImplementedError\n\n    def handle_auto_insert_mode(self, ok: bool) -> None:\n        \"\"\"Handle `input.insert_mode.auto_load` after loading finished.\"\"\"\n        if not ok or not config.cache['input.insert_mode.auto_load']:\n            return\n\n        cur_mode = self._mode_manager.mode\n        if cur_mode == usertypes.KeyMode.insert:\n            return\n\n        def _auto_insert_mode_cb(\n                elem: typing.Optional['webelem.AbstractWebElement']\n        ) -> None:\n            \"\"\"Called from JS after finding the focused element.\"\"\"\n            if elem is None:\n                log.webview.debug(\"No focused element!\")\n                return\n            if elem.is_editable():\n                modeman.enter(self._tab.win_id, usertypes.KeyMode.insert,\n                              'load finished', only_if_normal=True)\n\n        self._tab.elements.find_focused(_auto_insert_mode_cb)\n\n    def clear_ssl_errors(self) -> None:\n        raise NotImplementedError\n\n    def networkaccessmanager(self) -> typing.Optional[QNetworkAccessManager]:\n        \"\"\"Get the QNetworkAccessManager for this tab.\n\n        This is only implemented for QtWebKit.\n        For QtWebEngine, always returns None.\n        \"\"\"\n        raise NotImplementedError\n\n    def shutdown(self) -> None:\n        raise NotImplementedError\n\n\nclass AbstractTab(QWidget):\n\n    \"\"\"An adapter for QWebView/QWebEngineView representing a single tab.\"\"\"\n\n    #: Signal emitted when a website requests to close this tab.\n    window_close_requested = pyqtSignal()\n    #: Signal emitted when a link is hovered (the hover text)\n    link_hovered = pyqtSignal(str)\n    #: Signal emitted when a page started loading\n    load_started = pyqtSignal()\n    #: Signal emitted when a page is loading (progress percentage)\n    load_progress = pyqtSignal(int)\n    #: Signal emitted when a page finished loading (success as bool)\n    load_finished = pyqtSignal(bool)\n    #: Signal emitted when a page's favicon changed (icon as QIcon)\n    icon_changed = pyqtSignal(QIcon)\n    #: Signal emitted when a page's title changed (new title as str)\n    title_changed = pyqtSignal(str)\n    #: Signal emitted when a new tab should be opened (url as QUrl)\n    new_tab_requested = pyqtSignal(QUrl)\n    #: Signal emitted when a page's URL changed (url as QUrl)\n    url_changed = pyqtSignal(QUrl)\n    #: Signal emitted when a tab's content size changed\n    #: (new size as QSizeF)\n    contents_size_changed = pyqtSignal(QSizeF)\n    #: Signal emitted when a page requested full-screen (bool)\n    fullscreen_requested = pyqtSignal(bool)\n    #: Signal emitted before load starts (URL as QUrl)\n    before_load_started = pyqtSignal(QUrl)\n\n    # Signal emitted when a page's load status changed\n    # (argument: usertypes.LoadStatus)\n    load_status_changed = pyqtSignal(usertypes.LoadStatus)\n    # Signal emitted before shutting down\n    shutting_down = pyqtSignal()\n    # Signal emitted when a history item should be added\n    history_item_triggered = pyqtSignal(QUrl, QUrl, str)\n    # Signal emitted when the underlying renderer process terminated.\n    # arg 0: A TerminationStatus member.\n    # arg 1: The exit code.\n    renderer_process_terminated = pyqtSignal(TerminationStatus, int)\n\n    # Hosts for which a certificate error happened. Shared between all tabs.\n    #\n    # Note that we remember hosts here, without scheme/port:\n    # QtWebEngine/Chromium also only remembers hostnames, and certificates are\n    # for a given hostname anyways.\n    _insecure_hosts = set()  # type: typing.Set[str]\n\n    def __init__(self, *, win_id: int, private: bool,\n                 parent: QWidget = None) -> None:\n        self.is_private = private\n        self.win_id = win_id\n        self.tab_id = next(tab_id_gen)\n        super().__init__(parent)\n\n        self.registry = objreg.ObjectRegistry()\n        tab_registry = objreg.get('tab-registry', scope='window',\n                                  window=win_id)\n        tab_registry[self.tab_id] = self\n        objreg.register('tab', self, registry=self.registry)\n\n        self.data = TabData()\n        self._layout = miscwidgets.WrapperLayout(self)\n        self._widget = typing.cast(QWidget, None)\n        self._progress = 0\n        self._load_status = usertypes.LoadStatus.none\n        self._tab_event_filter = eventfilter.TabEventFilter(\n            self, parent=self)\n        self.backend = None  # type: typing.Optional[usertypes.Backend]\n\n        # If true, this tab has been requested to be removed (or is removed).\n        self.pending_removal = False\n        self.shutting_down.connect(functools.partial(\n            setattr, self, 'pending_removal', True))\n\n        self.before_load_started.connect(self._on_before_load_started)\n\n    def _set_widget(self, widget: QWidget) -> None:\n        # pylint: disable=protected-access\n        self._widget = widget\n        self._layout.wrap(self, widget)\n        self.history._history = widget.history()\n        self.history.private_api._history = widget.history()\n        self.scroller._init_widget(widget)\n        self.caret._widget = widget\n        self.zoom._widget = widget\n        self.search._widget = widget\n        self.printing._widget = widget\n        self.action._widget = widget\n        self.elements._widget = widget\n        self.audio._widget = widget\n        self.private_api._widget = widget\n        self.settings._settings = widget.settings()\n\n        self._install_event_filter()\n        self.zoom.apply_default()\n\n    def _install_event_filter(self) -> None:\n        raise NotImplementedError\n\n    def _set_load_status(self, val: usertypes.LoadStatus) -> None:\n        \"\"\"Setter for load_status.\"\"\"\n        if not isinstance(val, usertypes.LoadStatus):\n            raise TypeError(\"Type {} is no LoadStatus member!\".format(val))\n        log.webview.debug(\"load status for {}: {}\".format(repr(self), val))\n        self._load_status = val\n        self.load_status_changed.emit(val)\n\n    def send_event(self, evt: QEvent) -> None:\n        \"\"\"Send the given event to the underlying widget.\n\n        The event will be sent via QApplication.postEvent.\n        Note that a posted event must not be re-used in any way!\n        \"\"\"\n        # This only gives us some mild protection against re-using events, but\n        # it's certainly better than a segfault.\n        if getattr(evt, 'posted', False):\n            raise utils.Unreachable(\"Can't re-use an event which was already \"\n                                    \"posted!\")\n\n        recipient = self.private_api.event_target()\n        if recipient is None:\n            # https://github.com/qutebrowser/qutebrowser/issues/3888\n            log.webview.warning(\"Unable to find event target!\")\n            return\n\n        evt.posted = True\n        QApplication.postEvent(recipient, evt)\n\n    def navigation_blocked(self) -> bool:\n        \"\"\"Test if navigation is allowed on the current tab.\"\"\"\n        return self.data.pinned and config.val.tabs.pinned.frozen\n\n    @pyqtSlot(QUrl)\n    def _on_before_load_started(self, url: QUrl) -> None:\n        \"\"\"Adjust the title if we are going to visit a URL soon.\"\"\"\n        qtutils.ensure_valid(url)\n        url_string = url.toDisplayString()\n        log.webview.debug(\"Going to start loading: {}\".format(url_string))\n        self.title_changed.emit(url_string)\n\n    @pyqtSlot(QUrl)\n    def _on_url_changed(self, url: QUrl) -> None:\n        \"\"\"Update title when URL has changed and no title is available.\"\"\"\n        if url.isValid() and not self.title():\n            self.title_changed.emit(url.toDisplayString())\n        self.url_changed.emit(url)\n\n    @pyqtSlot()\n    def _on_load_started(self) -> None:\n        self._progress = 0\n        self.data.viewing_source = False\n        self._set_load_status(usertypes.LoadStatus.loading)\n        self.load_started.emit()\n\n    @pyqtSlot(usertypes.NavigationRequest)\n    def _on_navigation_request(\n            self,\n            navigation: usertypes.NavigationRequest\n    ) -> None:\n        \"\"\"Handle common acceptNavigationRequest code.\"\"\"\n        url = utils.elide(navigation.url.toDisplayString(), 100)\n        log.webview.debug(\"navigation request: url {}, type {}, is_main_frame \"\n                          \"{}\".format(url,\n                                      navigation.navigation_type,\n                                      navigation.is_main_frame))\n\n        if navigation.is_main_frame:\n            self.data.last_navigation = navigation\n\n        if not navigation.url.isValid():\n            # Also a WORKAROUND for missing IDNA 2008 support in QUrl, see\n            # https://bugreports.qt.io/browse/QTBUG-60364\n\n            if navigation.navigation_type == navigation.Type.link_clicked:\n                msg = urlutils.get_errstring(navigation.url,\n                                             \"Invalid link clicked\")\n                message.error(msg)\n                self.data.open_target = usertypes.ClickTarget.normal\n\n            log.webview.debug(\"Ignoring invalid URL {} in \"\n                              \"acceptNavigationRequest: {}\".format(\n                                  navigation.url.toDisplayString(),\n                                  navigation.url.errorString()))\n            navigation.accepted = False\n\n    @pyqtSlot(bool)\n    def _on_load_finished(self, ok: bool) -> None:\n        assert self._widget is not None\n        if sip.isdeleted(self._widget):\n            # https://github.com/qutebrowser/qutebrowser/issues/3498\n            return\n\n        if sessions.session_manager is not None:\n            sessions.session_manager.save_autosave()\n\n        self.load_finished.emit(ok)\n\n        if not self.title():\n            self.title_changed.emit(self.url().toDisplayString())\n\n        self.zoom.reapply()\n\n    def _update_load_status(self, ok: bool) -> None:\n        \"\"\"Update the load status after a page finished loading.\n\n        Needs to be called by subclasses to trigger a load status update, e.g.\n        as a response to a loadFinished signal.\n        \"\"\"\n        if ok:\n            if self.url().scheme() == 'https':\n                if self.url().host() in self._insecure_hosts:\n                    self._set_load_status(usertypes.LoadStatus.warn)\n                else:\n                    self._set_load_status(usertypes.LoadStatus.success_https)\n            else:\n                self._set_load_status(usertypes.LoadStatus.success)\n        elif ok:\n            self._set_load_status(usertypes.LoadStatus.warn)\n        else:\n            self._set_load_status(usertypes.LoadStatus.error)\n\n    @pyqtSlot()\n    def _on_history_trigger(self) -> None:\n        \"\"\"Emit history_item_triggered based on backend-specific signal.\"\"\"\n        raise NotImplementedError\n\n    @pyqtSlot(int)\n    def _on_load_progress(self, perc: int) -> None:\n        self._progress = perc\n        self.load_progress.emit(perc)\n\n    def url(self, *, requested: bool = False) -> QUrl:\n        raise NotImplementedError\n\n    def progress(self) -> int:\n        return self._progress\n\n    def load_status(self) -> usertypes.LoadStatus:\n        return self._load_status\n\n    def _load_url_prepare(self, url: QUrl, *,\n                          emit_before_load_started: bool = True) -> None:\n        qtutils.ensure_valid(url)\n        if emit_before_load_started:\n            self.before_load_started.emit(url)\n\n    def load_url(self, url: QUrl, *,\n                 emit_before_load_started: bool = True) -> None:\n        raise NotImplementedError\n\n    def reload(self, *, force: bool = False) -> None:\n        raise NotImplementedError\n\n    def stop(self) -> None:\n        raise NotImplementedError\n\n    def fake_key_press(self,\n                       key: Qt.Key,\n                       modifier: Qt.KeyboardModifier = Qt.NoModifier) -> None:\n        \"\"\"Send a fake key event to this tab.\"\"\"\n        press_evt = QKeyEvent(QEvent.KeyPress, key, modifier, 0, 0, 0)\n        release_evt = QKeyEvent(QEvent.KeyRelease, key, modifier,\n                                0, 0, 0)\n        self.send_event(press_evt)\n        self.send_event(release_evt)\n\n    def dump_async(self,\n                   callback: typing.Callable[[str], None], *,\n                   plain: bool = False) -> None:\n        \"\"\"Dump the current page's html asynchronously.\n\n        The given callback will be called with the result when dumping is\n        complete.\n        \"\"\"\n        raise NotImplementedError\n\n    def run_js_async(\n            self,\n            code: str,\n            callback: typing.Callable[[typing.Any], None] = None, *,\n            world: typing.Union[usertypes.JsWorld, int] = None\n    ) -> None:\n        \"\"\"Run javascript async.\n\n        The given callback will be called with the result when running JS is\n        complete.\n\n        Args:\n            code: The javascript code to run.\n            callback: The callback to call with the result, or None.\n            world: A world ID (int or usertypes.JsWorld member) to run the JS\n                   in the main world or in another isolated world.\n        \"\"\"\n        raise NotImplementedError\n\n    def title(self) -> str:\n        raise NotImplementedError\n\n    def icon(self) -> None:\n        raise NotImplementedError\n\n    def set_html(self, html: str, base_url: QUrl = QUrl()) -> None:\n        raise NotImplementedError\n\n    def __repr__(self) -> str:\n        try:\n            qurl = self.url()\n            url = qurl.toDisplayString(QUrl.EncodeUnicode)  # type: ignore\n        except (AttributeError, RuntimeError) as exc:\n            url = '<{}>'.format(exc.__class__.__name__)\n        else:\n            url = utils.elide(url, 100)\n        return utils.get_repr(self, tab_id=self.tab_id, url=url)\n\n    def is_deleted(self) -> bool:\n        assert self._widget is not None\n        return sip.isdeleted(self._widget)\n", "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2016-2020 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"Wrapper over a QWebEngineView.\"\"\"\n\nimport math\nimport functools\nimport re\nimport html as html_utils\nimport typing\n\nfrom PyQt5.QtCore import (pyqtSignal, pyqtSlot, Qt, QPoint, QPointF, QUrl,\n                          QTimer, QObject)\nfrom PyQt5.QtNetwork import QAuthenticator\nfrom PyQt5.QtWidgets import QApplication, QWidget\nfrom PyQt5.QtWebEngineWidgets import QWebEnginePage, QWebEngineScript\n\nfrom qutebrowser.config import configdata, config\nfrom qutebrowser.browser import (browsertab, eventfilter, shared, webelem,\n                                 history, greasemonkey)\nfrom qutebrowser.browser.webengine import (webview, webengineelem, tabhistory,\n                                           interceptor, webenginequtescheme,\n                                           cookies, webenginedownloads,\n                                           webenginesettings, certificateerror)\nfrom qutebrowser.misc import miscwidgets, objects\nfrom qutebrowser.utils import (usertypes, qtutils, log, javascript, utils,\n                               message, objreg, jinja, debug)\nfrom qutebrowser.qt import sip\n\n\n_qute_scheme_handler = None\n\n\ndef init():\n    \"\"\"Initialize QtWebEngine-specific modules.\"\"\"\n    # For some reason we need to keep a reference, otherwise the scheme handler\n    # won't work...\n    # https://www.riverbankcomputing.com/pipermail/pyqt/2016-September/038075.html\n    global _qute_scheme_handler\n\n    app = QApplication.instance()\n    log.init.debug(\"Initializing qute://* handler...\")\n    _qute_scheme_handler = webenginequtescheme.QuteSchemeHandler(parent=app)\n    _qute_scheme_handler.install(webenginesettings.default_profile)\n    if webenginesettings.private_profile:\n        _qute_scheme_handler.install(webenginesettings.private_profile)\n\n    log.init.debug(\"Initializing request interceptor...\")\n    req_interceptor = interceptor.RequestInterceptor(parent=app)\n    req_interceptor.install(webenginesettings.default_profile)\n    if webenginesettings.private_profile:\n        req_interceptor.install(webenginesettings.private_profile)\n\n    log.init.debug(\"Initializing QtWebEngine downloads...\")\n    download_manager = webenginedownloads.DownloadManager(parent=app)\n    download_manager.install(webenginesettings.default_profile)\n    if webenginesettings.private_profile:\n        download_manager.install(webenginesettings.private_profile)\n    objreg.register('webengine-download-manager', download_manager)\n\n    log.init.debug(\"Initializing cookie filter...\")\n    cookies.install_filter(webenginesettings.default_profile)\n    if webenginesettings.private_profile:\n        cookies.install_filter(webenginesettings.private_profile)\n\n    # Clear visited links on web history clear\n    for p in [webenginesettings.default_profile,\n              webenginesettings.private_profile]:\n        if not p:\n            continue\n        history.web_history.history_cleared.connect(p.clearAllVisitedLinks)\n        history.web_history.url_cleared.connect(\n            lambda url, profile=p: profile.clearVisitedLinks([url]))\n\n\n# Mapping worlds from usertypes.JsWorld to QWebEngineScript world IDs.\n_JS_WORLD_MAP = {\n    usertypes.JsWorld.main: QWebEngineScript.MainWorld,\n    usertypes.JsWorld.application: QWebEngineScript.ApplicationWorld,\n    usertypes.JsWorld.user: QWebEngineScript.UserWorld,\n    usertypes.JsWorld.jseval: QWebEngineScript.UserWorld + 1,\n}\n\n\nclass WebEngineAction(browsertab.AbstractAction):\n\n    \"\"\"QtWebEngine implementations related to web actions.\"\"\"\n\n    action_class = QWebEnginePage\n    action_base = QWebEnginePage.WebAction\n\n    def exit_fullscreen(self):\n        self._widget.triggerPageAction(QWebEnginePage.ExitFullScreen)\n\n    def save_page(self):\n        \"\"\"Save the current page.\"\"\"\n        self._widget.triggerPageAction(QWebEnginePage.SavePage)\n\n    def show_source(self, pygments=False):\n        if pygments:\n            self._show_source_pygments()\n            return\n\n        try:\n            self._widget.triggerPageAction(QWebEnginePage.ViewSource)\n        except AttributeError:\n            # Qt < 5.8\n            tb = objreg.get('tabbed-browser', scope='window',\n                            window=self._tab.win_id)\n            urlstr = self._tab.url().toString(\n                QUrl.RemoveUserInfo)  # type: ignore\n            # The original URL becomes the path of a view-source: URL\n            # (without a host), but query/fragment should stay.\n            url = QUrl('view-source:' + urlstr)\n            tb.tabopen(url, background=False, related=True)\n\n\nclass WebEnginePrinting(browsertab.AbstractPrinting):\n\n    \"\"\"QtWebEngine implementations related to printing.\"\"\"\n\n    def check_pdf_support(self):\n        pass\n\n    def check_printer_support(self):\n        if not hasattr(self._widget.page(), 'print'):\n            raise browsertab.WebTabError(\n                \"Printing is unsupported with QtWebEngine on Qt < 5.8\")\n\n    def check_preview_support(self):\n        raise browsertab.WebTabError(\n            \"Print previews are unsupported with QtWebEngine\")\n\n    def to_pdf(self, filename):\n        self._widget.page().printToPdf(filename)\n\n    def to_printer(self, printer, callback=None):\n        if callback is None:\n            callback = lambda _ok: None\n        self._widget.page().print(printer, callback)\n\n\nclass _WebEngineSearchWrapHandler:\n\n    \"\"\"QtWebEngine implementations related to wrapping when searching.\n\n    Attributes:\n        flag_wrap: An additional flag indicating whether the last search\n                   used wrapping.\n        _active_match: The 1-based index of the currently active match\n                       on the page.\n        _total_matches: The total number of search matches on the page.\n        _nowrap_available: Whether the functionality to prevent wrapping\n                           is available.\n    \"\"\"\n\n    def __init__(self):\n        self._active_match = 0\n        self._total_matches = 0\n        self.flag_wrap = True\n        self._nowrap_available = False\n\n    def connect_signal(self, page):\n        \"\"\"Connect to the findTextFinished signal of the page.\n\n        Args:\n            page: The QtWebEnginePage to connect to this handler.\n        \"\"\"\n        if qtutils.version_check(\"5.14\"):\n            page.findTextFinished.connect(self._store_match_data)\n            self._nowrap_available = True\n\n    def _store_match_data(self, result):\n        \"\"\"Store information on the last match.\n\n        The information will be checked against when wrapping is turned off.\n\n        Args:\n            result: A FindTextResult passed by the findTextFinished signal.\n        \"\"\"\n        self._active_match = result.activeMatch()\n        self._total_matches = result.numberOfMatches()\n        log.webview.debug(\"Active search match: {}/{}\"\n                          .format(self._active_match, self._total_matches))\n\n    def reset_match_data(self):\n        \"\"\"Reset match information.\n\n        Stale information could lead to next_result or prev_result misbehaving.\n        \"\"\"\n        self._active_match = 0\n        self._total_matches = 0\n\n    def prevent_wrapping(self, *, going_up):\n        \"\"\"Prevent wrapping if possible and required.\n\n        Returns True if a wrap was prevented and False if not.\n\n        Args:\n            going_up: Whether the search would scroll the page up or down.\n        \"\"\"\n        if (not self._nowrap_available or\n                self.flag_wrap or self._total_matches == 0):\n            return False\n        elif going_up and self._active_match == 1:\n            message.info(\"Search hit TOP\")\n            return True\n        elif not going_up and self._active_match == self._total_matches:\n            message.info(\"Search hit BOTTOM\")\n            return True\n        else:\n            return False\n\n\nclass WebEngineSearch(browsertab.AbstractSearch):\n\n    \"\"\"QtWebEngine implementations related to searching on the page.\n\n    Attributes:\n        _flags: The QWebEnginePage.FindFlags of the last search.\n        _pending_searches: How many searches have been started but not called\n                           back yet.\n    \"\"\"\n\n    def __init__(self, tab, parent=None):\n        super().__init__(tab, parent)\n        self._flags = QWebEnginePage.FindFlags(0)  # type: ignore\n        self._pending_searches = 0\n        # The API necessary to stop wrapping was added in this version\n        self._wrap_handler = _WebEngineSearchWrapHandler()\n\n    def connect_signals(self):\n        self._wrap_handler.connect_signal(self._widget.page())\n\n    def _find(self, text, flags, callback, caller):\n        \"\"\"Call findText on the widget.\"\"\"\n        self.search_displayed = True\n        self._pending_searches += 1\n\n        def wrapped_callback(found):\n            \"\"\"Wrap the callback to do debug logging.\"\"\"\n            self._pending_searches -= 1\n            if self._pending_searches > 0:\n                # See https://github.com/qutebrowser/qutebrowser/issues/2442\n                # and https://github.com/qt/qtwebengine/blob/5.10/src/core/web_contents_adapter.cpp#L924-L934\n                log.webview.debug(\"Ignoring cancelled search callback with \"\n                                  \"{} pending searches\".format(\n                                      self._pending_searches))\n                return\n\n            if sip.isdeleted(self._widget):\n                # This happens when starting a search, and closing the tab\n                # before results arrive.\n                log.webview.debug(\"Ignoring finished search for deleted \"\n                                  \"widget\")\n                return\n\n            found_text = 'found' if found else \"didn't find\"\n            if flags:\n                flag_text = 'with flags {}'.format(debug.qflags_key(\n                    QWebEnginePage, flags, klass=QWebEnginePage.FindFlag))\n            else:\n                flag_text = ''\n            log.webview.debug(' '.join([caller, found_text, text, flag_text])\n                              .strip())\n\n            if callback is not None:\n                callback(found)\n            self.finished.emit(found)\n\n        self._widget.page().findText(text, flags, wrapped_callback)\n\n    def search(self, text, *, ignore_case=usertypes.IgnoreCase.never,\n               reverse=False, wrap=True, result_cb=None):\n        # Don't go to next entry on duplicate search\n        if self.text == text and self.search_displayed:\n            log.webview.debug(\"Ignoring duplicate search request\"\n                              \" for {}\".format(text))\n            return\n\n        self.text = text\n        self._flags = QWebEnginePage.FindFlags(0)  # type: ignore\n        self._wrap_handler.reset_match_data()\n        self._wrap_handler.flag_wrap = wrap\n        if self._is_case_sensitive(ignore_case):\n            self._flags |= QWebEnginePage.FindCaseSensitively\n        if reverse:\n            self._flags |= QWebEnginePage.FindBackward\n\n        self._find(text, self._flags, result_cb, 'search')\n\n    def clear(self):\n        if self.search_displayed:\n            self.cleared.emit()\n        self.search_displayed = False\n        self._wrap_handler.reset_match_data()\n        self._widget.page().findText('')\n\n    def prev_result(self, *, result_cb=None):\n        # The int() here makes sure we get a copy of the flags.\n        flags = QWebEnginePage.FindFlags(int(self._flags))  # type: ignore\n        if flags & QWebEnginePage.FindBackward:\n            if self._wrap_handler.prevent_wrapping(going_up=False):\n                return\n            flags &= ~QWebEnginePage.FindBackward\n        else:\n            if self._wrap_handler.prevent_wrapping(going_up=True):\n                return\n            flags |= QWebEnginePage.FindBackward\n        self._find(self.text, flags, result_cb, 'prev_result')\n\n    def next_result(self, *, result_cb=None):\n        going_up = self._flags & QWebEnginePage.FindBackward\n        if self._wrap_handler.prevent_wrapping(going_up=going_up):\n            return\n        self._find(self.text, self._flags, result_cb, 'next_result')\n\n\nclass WebEngineCaret(browsertab.AbstractCaret):\n\n    \"\"\"QtWebEngine implementations related to moving the cursor/selection.\"\"\"\n\n    def _flags(self):\n        \"\"\"Get flags to pass to JS.\"\"\"\n        flags = set()\n        if qtutils.version_check('5.7.1', compiled=False):\n            flags.add('filter-prefix')\n        if utils.is_windows:\n            flags.add('windows')\n        return list(flags)\n\n    @pyqtSlot(usertypes.KeyMode)\n    def _on_mode_entered(self, mode):\n        if mode != usertypes.KeyMode.caret:\n            return\n\n        if self._tab.search.search_displayed:\n            # We are currently in search mode.\n            # convert the search to a blue selection so we can operate on it\n            # https://bugreports.qt.io/browse/QTBUG-60673\n            self._tab.search.clear()\n\n        self._tab.run_js_async(\n            javascript.assemble('caret', 'setFlags', self._flags()))\n\n        self._js_call('setInitialCursor', callback=self._selection_cb)\n\n    def _selection_cb(self, enabled):\n        \"\"\"Emit selection_toggled based on setInitialCursor.\"\"\"\n        if self._mode_manager.mode != usertypes.KeyMode.caret:\n            log.webview.debug(\"Ignoring selection cb due to mode change.\")\n            return\n        if enabled is None:\n            log.webview.debug(\"Ignoring selection status None\")\n            return\n        self.selection_toggled.emit(enabled)\n\n    @pyqtSlot(usertypes.KeyMode)\n    def _on_mode_left(self, mode):\n        if mode != usertypes.KeyMode.caret:\n            return\n\n        self.drop_selection()\n        self._js_call('disableCaret')\n\n    def move_to_next_line(self, count=1):\n        self._js_call('moveDown', count)\n\n    def move_to_prev_line(self, count=1):\n        self._js_call('moveUp', count)\n\n    def move_to_next_char(self, count=1):\n        self._js_call('moveRight', count)\n\n    def move_to_prev_char(self, count=1):\n        self._js_call('moveLeft', count)\n\n    def move_to_end_of_word(self, count=1):\n        self._js_call('moveToEndOfWord', count)\n\n    def move_to_next_word(self, count=1):\n        self._js_call('moveToNextWord', count)\n\n    def move_to_prev_word(self, count=1):\n        self._js_call('moveToPreviousWord', count)\n\n    def move_to_start_of_line(self):\n        self._js_call('moveToStartOfLine')\n\n    def move_to_end_of_line(self):\n        self._js_call('moveToEndOfLine')\n\n    def move_to_start_of_next_block(self, count=1):\n        self._js_call('moveToStartOfNextBlock', count)\n\n    def move_to_start_of_prev_block(self, count=1):\n        self._js_call('moveToStartOfPrevBlock', count)\n\n    def move_to_end_of_next_block(self, count=1):\n        self._js_call('moveToEndOfNextBlock', count)\n\n    def move_to_end_of_prev_block(self, count=1):\n        self._js_call('moveToEndOfPrevBlock', count)\n\n    def move_to_start_of_document(self):\n        self._js_call('moveToStartOfDocument')\n\n    def move_to_end_of_document(self):\n        self._js_call('moveToEndOfDocument')\n\n    def toggle_selection(self):\n        self._js_call('toggleSelection', callback=self.selection_toggled.emit)\n\n    def drop_selection(self):\n        self._js_call('dropSelection')\n\n    def selection(self, callback):\n        # Not using selectedText() as WORKAROUND for\n        # https://bugreports.qt.io/browse/QTBUG-53134\n        # Even on Qt 5.10 selectedText() seems to work poorly, see\n        # https://github.com/qutebrowser/qutebrowser/issues/3523\n        self._tab.run_js_async(javascript.assemble('caret', 'getSelection'),\n                               callback)\n\n    def reverse_selection(self):\n        self._js_call('reverseSelection')\n\n    def _follow_selected_cb_wrapped(self, js_elem, tab):\n        try:\n            self._follow_selected_cb(js_elem, tab)\n        finally:\n            self.follow_selected_done.emit()\n\n    def _follow_selected_cb(self, js_elem, tab):\n        \"\"\"Callback for javascript which clicks the selected element.\n\n        Args:\n            js_elem: The element serialized from javascript.\n            tab: Open in a new tab.\n        \"\"\"\n        if js_elem is None:\n            return\n\n        if js_elem == \"focused\":\n            # we had a focused element, not a selected one. Just send <enter>\n            self._follow_enter(tab)\n            return\n\n        assert isinstance(js_elem, dict), js_elem\n        elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)\n        if tab:\n            click_type = usertypes.ClickTarget.tab\n        else:\n            click_type = usertypes.ClickTarget.normal\n\n        # Only click if we see a link\n        if elem.is_link():\n            log.webview.debug(\"Found link in selection, clicking. ClickTarget \"\n                              \"{}, elem {}\".format(click_type, elem))\n            try:\n                elem.click(click_type)\n            except webelem.Error as e:\n                message.error(str(e))\n\n    def follow_selected(self, *, tab=False):\n        if self._tab.search.search_displayed:\n            # We are currently in search mode.\n            # let's click the link via a fake-click\n            # https://bugreports.qt.io/browse/QTBUG-60673\n            self._tab.search.clear()\n\n            log.webview.debug(\"Clicking a searched link via fake key press.\")\n            # send a fake enter, clicking the orange selection box\n            self._follow_enter(tab)\n        else:\n            # click an existing blue selection\n            js_code = javascript.assemble('webelem',\n                                          'find_selected_focused_link')\n            self._tab.run_js_async(\n                js_code,\n                lambda jsret: self._follow_selected_cb_wrapped(jsret, tab))\n\n    def _js_call(self, command, *args, callback=None):\n        code = javascript.assemble('caret', command, *args)\n        self._tab.run_js_async(code, callback)\n\n\nclass WebEngineScroller(browsertab.AbstractScroller):\n\n    \"\"\"QtWebEngine implementations related to scrolling.\"\"\"\n\n    def __init__(self, tab, parent=None):\n        super().__init__(tab, parent)\n        self._pos_perc = (0, 0)\n        self._pos_px = QPoint()\n        self._at_bottom = False\n\n    def _init_widget(self, widget):\n        super()._init_widget(widget)\n        page = widget.page()\n        page.scrollPositionChanged.connect(self._update_pos)\n\n    def _repeated_key_press(self, key, count=1, modifier=Qt.NoModifier):\n        \"\"\"Send count fake key presses to this scroller's WebEngineTab.\"\"\"\n        for _ in range(min(count, 1000)):\n            self._tab.fake_key_press(key, modifier)\n\n    @pyqtSlot(QPointF)\n    def _update_pos(self, pos):\n        \"\"\"Update the scroll position attributes when it changed.\"\"\"\n        self._pos_px = pos.toPoint()\n        contents_size = self._widget.page().contentsSize()\n\n        scrollable_x = contents_size.width() - self._widget.width()\n        if scrollable_x == 0:\n            perc_x = 0\n        else:\n            try:\n                perc_x = min(100, round(100 / scrollable_x * pos.x()))\n            except ValueError:\n                # https://github.com/qutebrowser/qutebrowser/issues/3219\n                log.misc.debug(\"Got ValueError for perc_x!\")\n                log.misc.debug(\"contents_size.width(): {}\".format(\n                    contents_size.width()))\n                log.misc.debug(\"self._widget.width(): {}\".format(\n                    self._widget.width()))\n                log.misc.debug(\"scrollable_x: {}\".format(scrollable_x))\n                log.misc.debug(\"pos.x(): {}\".format(pos.x()))\n                raise\n\n        scrollable_y = contents_size.height() - self._widget.height()\n        if scrollable_y == 0:\n            perc_y = 0\n        else:\n            try:\n                perc_y = min(100, round(100 / scrollable_y * pos.y()))\n            except ValueError:\n                # https://github.com/qutebrowser/qutebrowser/issues/3219\n                log.misc.debug(\"Got ValueError for perc_y!\")\n                log.misc.debug(\"contents_size.height(): {}\".format(\n                    contents_size.height()))\n                log.misc.debug(\"self._widget.height(): {}\".format(\n                    self._widget.height()))\n                log.misc.debug(\"scrollable_y: {}\".format(scrollable_y))\n                log.misc.debug(\"pos.y(): {}\".format(pos.y()))\n                raise\n\n        self._at_bottom = math.ceil(pos.y()) >= scrollable_y\n\n        if (self._pos_perc != (perc_x, perc_y) or\n                'no-scroll-filtering' in objects.debug_flags):\n            self._pos_perc = perc_x, perc_y\n            self.perc_changed.emit(*self._pos_perc)\n\n    def pos_px(self):\n        return self._pos_px\n\n    def pos_perc(self):\n        return self._pos_perc\n\n    def to_perc(self, x=None, y=None):\n        js_code = javascript.assemble('scroll', 'to_perc', x, y)\n        self._tab.run_js_async(js_code)\n\n    def to_point(self, point):\n        js_code = javascript.assemble('window', 'scroll', point.x(), point.y())\n        self._tab.run_js_async(js_code)\n\n    def to_anchor(self, name):\n        url = self._tab.url()\n        url.setFragment(name)\n        self._tab.load_url(url)\n\n    def delta(self, x=0, y=0):\n        self._tab.run_js_async(javascript.assemble('window', 'scrollBy', x, y))\n\n    def delta_page(self, x=0, y=0):\n        js_code = javascript.assemble('scroll', 'delta_page', x, y)\n        self._tab.run_js_async(js_code)\n\n    def up(self, count=1):\n        self._repeated_key_press(Qt.Key_Up, count)\n\n    def down(self, count=1):\n        self._repeated_key_press(Qt.Key_Down, count)\n\n    def left(self, count=1):\n        self._repeated_key_press(Qt.Key_Left, count)\n\n    def right(self, count=1):\n        self._repeated_key_press(Qt.Key_Right, count)\n\n    def top(self):\n        self._tab.fake_key_press(Qt.Key_Home)\n\n    def bottom(self):\n        self._tab.fake_key_press(Qt.Key_End)\n\n    def page_up(self, count=1):\n        self._repeated_key_press(Qt.Key_PageUp, count)\n\n    def page_down(self, count=1):\n        self._repeated_key_press(Qt.Key_PageDown, count)\n\n    def at_top(self):\n        return self.pos_px().y() == 0\n\n    def at_bottom(self):\n        return self._at_bottom\n\n\nclass WebEngineHistoryPrivate(browsertab.AbstractHistoryPrivate):\n\n    \"\"\"History-related methods which are not part of the extension API.\"\"\"\n\n    def serialize(self):\n        if not qtutils.version_check('5.9', compiled=False):\n            # WORKAROUND for\n            # https://github.com/qutebrowser/qutebrowser/issues/2289\n            # Don't use the history's currentItem here, because of\n            # https://bugreports.qt.io/browse/QTBUG-59599 and because it doesn't\n            # contain view-source.\n            scheme = self._tab.url().scheme()\n            if scheme in ['view-source', 'chrome']:\n                raise browsertab.WebTabError(\"Can't serialize special URL!\")\n        return qtutils.serialize(self._history)\n\n    def deserialize(self, data):\n        qtutils.deserialize(data, self._history)\n\n    def load_items(self, items):\n        if qtutils.version_check('5.15', compiled=False):\n            # WORKAROUND for https://github.com/qutebrowser/qutebrowser/issues/5359\n            if items:\n                self._tab.load_url(items[-1].url)\n            return\n\n        if items:\n            self._tab.before_load_started.emit(items[-1].url)\n\n        stream, _data, cur_data = tabhistory.serialize(items)\n        qtutils.deserialize_stream(stream, self._history)\n\n        @pyqtSlot()\n        def _on_load_finished():\n            self._tab.scroller.to_point(cur_data['scroll-pos'])\n            self._tab.load_finished.disconnect(_on_load_finished)\n\n        if cur_data is not None:\n            if 'zoom' in cur_data:\n                self._tab.zoom.set_factor(cur_data['zoom'])\n            if ('scroll-pos' in cur_data and\n                    self._tab.scroller.pos_px() == QPoint(0, 0)):\n                self._tab.load_finished.connect(_on_load_finished)\n\n\nclass WebEngineHistory(browsertab.AbstractHistory):\n\n    \"\"\"QtWebEngine implementations related to page history.\"\"\"\n\n    def __init__(self, tab):\n        super().__init__(tab)\n        self.private_api = WebEngineHistoryPrivate(tab)\n\n    def __len__(self):\n        return len(self._history)\n\n    def __iter__(self):\n        return iter(self._history.items())\n\n    def current_idx(self):\n        return self._history.currentItemIndex()\n\n    def can_go_back(self):\n        return self._history.canGoBack()\n\n    def can_go_forward(self):\n        return self._history.canGoForward()\n\n    def _item_at(self, i):\n        return self._history.itemAt(i)\n\n    def _go_to_item(self, item):\n        self._tab.before_load_started.emit(item.url())\n        self._history.goToItem(item)\n\n\nclass WebEngineZoom(browsertab.AbstractZoom):\n\n    \"\"\"QtWebEngine implementations related to zooming.\"\"\"\n\n    def _set_factor_internal(self, factor):\n        self._widget.setZoomFactor(factor)\n\n\nclass WebEngineElements(browsertab.AbstractElements):\n\n    \"\"\"QtWebEngine implemementations related to elements on the page.\"\"\"\n\n    def _js_cb_multiple(self, callback, error_cb, js_elems):\n        \"\"\"Handle found elements coming from JS and call the real callback.\n\n        Args:\n            callback: The callback to call with the found elements.\n            error_cb: The callback to call in case of an error.\n            js_elems: The elements serialized from javascript.\n        \"\"\"\n        if js_elems is None:\n            error_cb(webelem.Error(\"Unknown error while getting \"\n                                   \"elements\"))\n            return\n        elif not js_elems['success']:\n            error_cb(webelem.Error(js_elems['error']))\n            return\n\n        elems = []\n        for js_elem in js_elems['result']:\n            elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)\n            elems.append(elem)\n        callback(elems)\n\n    def _js_cb_single(self, callback, js_elem):\n        \"\"\"Handle a found focus elem coming from JS and call the real callback.\n\n        Args:\n            callback: The callback to call with the found element.\n                      Called with a WebEngineElement or None.\n            js_elem: The element serialized from javascript.\n        \"\"\"\n        debug_str = ('None' if js_elem is None\n                     else utils.elide(repr(js_elem), 1000))\n        log.webview.debug(\"Got element from JS: {}\".format(debug_str))\n\n        if js_elem is None:\n            callback(None)\n        else:\n            elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)\n            callback(elem)\n\n    def find_css(self, selector, callback, error_cb, *,\n                 only_visible=False):\n        js_code = javascript.assemble('webelem', 'find_css', selector,\n                                      only_visible)\n        js_cb = functools.partial(self._js_cb_multiple, callback, error_cb)\n        self._tab.run_js_async(js_code, js_cb)\n\n    def find_id(self, elem_id, callback):\n        js_code = javascript.assemble('webelem', 'find_id', elem_id)\n        js_cb = functools.partial(self._js_cb_single, callback)\n        self._tab.run_js_async(js_code, js_cb)\n\n    def find_focused(self, callback):\n        js_code = javascript.assemble('webelem', 'find_focused')\n        js_cb = functools.partial(self._js_cb_single, callback)\n        self._tab.run_js_async(js_code, js_cb)\n\n    def find_at_pos(self, pos, callback):\n        assert pos.x() >= 0, pos\n        assert pos.y() >= 0, pos\n        pos /= self._tab.zoom.factor()\n        js_code = javascript.assemble('webelem', 'find_at_pos',\n                                      pos.x(), pos.y())\n        js_cb = functools.partial(self._js_cb_single, callback)\n        self._tab.run_js_async(js_code, js_cb)\n\n\nclass WebEngineAudio(browsertab.AbstractAudio):\n\n    \"\"\"QtWebEngine implemementations related to audio/muting.\n\n    Attributes:\n        _overridden: Whether the user toggled muting manually.\n                     If that's the case, we leave it alone.\n    \"\"\"\n\n    def __init__(self, tab, parent=None):\n        super().__init__(tab, parent)\n        self._overridden = False\n\n    def _connect_signals(self):\n        page = self._widget.page()\n        page.audioMutedChanged.connect(self.muted_changed)\n        page.recentlyAudibleChanged.connect(self.recently_audible_changed)\n        self._tab.url_changed.connect(self._on_url_changed)\n        config.instance.changed.connect(self._on_config_changed)\n\n    def set_muted(self, muted: bool, override: bool = False) -> None:\n        self._overridden = override\n        assert self._widget is not None\n        page = self._widget.page()\n        page.setAudioMuted(muted)\n\n    def is_muted(self):\n        page = self._widget.page()\n        return page.isAudioMuted()\n\n    def is_recently_audible(self):\n        page = self._widget.page()\n        return page.recentlyAudible()\n\n    @pyqtSlot(QUrl)\n    def _on_url_changed(self, url):\n        if self._overridden:\n            return\n        mute = config.instance.get('content.mute', url=url)\n        self.set_muted(mute)\n\n    @config.change_filter('content.mute')\n    def _on_config_changed(self):\n        self._on_url_changed(self._tab.url())\n\n\nclass _WebEnginePermissions(QObject):\n\n    \"\"\"Handling of various permission-related signals.\"\"\"\n\n    # Using 0 as WORKAROUND for:\n    # https://www.riverbankcomputing.com/pipermail/pyqt/2019-July/041903.html\n\n    _options = {\n        0: 'content.notifications',\n        QWebEnginePage.Geolocation: 'content.geolocation',\n        QWebEnginePage.MediaAudioCapture: 'content.media_capture',\n        QWebEnginePage.MediaVideoCapture: 'content.media_capture',\n        QWebEnginePage.MediaAudioVideoCapture: 'content.media_capture',\n    }\n\n    _messages = {\n        0: 'show notifications',\n        QWebEnginePage.Geolocation: 'access your location',\n        QWebEnginePage.MediaAudioCapture: 'record audio',\n        QWebEnginePage.MediaVideoCapture: 'record video',\n        QWebEnginePage.MediaAudioVideoCapture: 'record audio/video',\n    }\n\n    def __init__(self, tab, parent=None):\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n\n        try:\n            self._options.update({\n                QWebEnginePage.MouseLock:\n                    'content.mouse_lock',\n            })\n            self._messages.update({\n                QWebEnginePage.MouseLock:\n                    'hide your mouse pointer',\n            })\n        except AttributeError:\n            # Added in Qt 5.8\n            pass\n        try:\n            self._options.update({\n                QWebEnginePage.DesktopVideoCapture:\n                    'content.desktop_capture',\n                QWebEnginePage.DesktopAudioVideoCapture:\n                    'content.desktop_capture',\n            })\n            self._messages.update({\n                QWebEnginePage.DesktopVideoCapture:\n                    'capture your desktop',\n                QWebEnginePage.DesktopAudioVideoCapture:\n                    'capture your desktop and audio',\n            })\n        except AttributeError:\n            # Added in Qt 5.10\n            pass\n\n        assert self._options.keys() == self._messages.keys()\n\n    def connect_signals(self):\n        \"\"\"Connect related signals from the QWebEnginePage.\"\"\"\n        page = self._widget.page()\n        page.fullScreenRequested.connect(\n            self._on_fullscreen_requested)\n        page.featurePermissionRequested.connect(\n            self._on_feature_permission_requested)\n\n        if qtutils.version_check('5.11'):\n            page.quotaRequested.connect(\n                self._on_quota_requested)\n            page.registerProtocolHandlerRequested.connect(\n                self._on_register_protocol_handler_requested)\n\n    @pyqtSlot('QWebEngineFullScreenRequest')\n    def _on_fullscreen_requested(self, request):\n        request.accept()\n        on = request.toggleOn()\n\n        self._tab.data.fullscreen = on\n        self._tab.fullscreen_requested.emit(on)\n        if on:\n            timeout = config.val.content.fullscreen.overlay_timeout\n            if timeout != 0:\n                notification = miscwidgets.FullscreenNotification(self._widget)\n                notification.set_timeout(timeout)\n                notification.show()\n\n    @pyqtSlot(QUrl, 'QWebEnginePage::Feature')\n    def _on_feature_permission_requested(self, url, feature):\n        \"\"\"Ask the user for approval for geolocation/media/etc..\"\"\"\n        page = self._widget.page()\n        grant_permission = functools.partial(\n            page.setFeaturePermission, url, feature,\n            QWebEnginePage.PermissionGrantedByUser)\n        deny_permission = functools.partial(\n            page.setFeaturePermission, url, feature,\n            QWebEnginePage.PermissionDeniedByUser)\n\n        if feature not in self._options:\n            log.webview.error(\"Unhandled feature permission {}\".format(\n                debug.qenum_key(QWebEnginePage, feature)))\n            deny_permission()\n            return\n\n        if (\n                hasattr(QWebEnginePage, 'DesktopVideoCapture') and\n                feature in [QWebEnginePage.DesktopVideoCapture,\n                            QWebEnginePage.DesktopAudioVideoCapture] and\n                qtutils.version_check('5.13', compiled=False) and\n                not qtutils.version_check('5.13.2', compiled=False)\n        ):\n            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-78016\n            log.webview.warning(\"Ignoring desktop sharing request due to \"\n                                \"crashes in Qt < 5.13.2\")\n            deny_permission()\n            return\n\n        question = shared.feature_permission(\n            url=url.adjusted(QUrl.RemovePath),\n            option=self._options[feature], msg=self._messages[feature],\n            yes_action=grant_permission, no_action=deny_permission,\n            abort_on=[self._tab.abort_questions])\n\n        if question is not None:\n            page.featurePermissionRequestCanceled.connect(\n                functools.partial(self._on_feature_permission_cancelled,\n                                  question, url, feature))\n\n    def _on_feature_permission_cancelled(self, question, url, feature,\n                                         cancelled_url, cancelled_feature):\n        \"\"\"Slot invoked when a feature permission request was cancelled.\n\n        To be used with functools.partial.\n        \"\"\"\n        if url == cancelled_url and feature == cancelled_feature:\n            try:\n                question.abort()\n            except RuntimeError:\n                # The question could already be deleted, e.g. because it was\n                # aborted after a loadStarted signal.\n                pass\n\n    def _on_quota_requested(self, request):\n        size = utils.format_size(request.requestedSize())\n        shared.feature_permission(\n            url=request.origin().adjusted(QUrl.RemovePath),\n            option='content.persistent_storage',\n            msg='use {} of persistent storage'.format(size),\n            yes_action=request.accept, no_action=request.reject,\n            abort_on=[self._tab.abort_questions],\n            blocking=True)\n\n    def _on_register_protocol_handler_requested(self, request):\n        shared.feature_permission(\n            url=request.origin().adjusted(QUrl.RemovePath),\n            option='content.register_protocol_handler',\n            msg='open all {} links'.format(request.scheme()),\n            yes_action=request.accept, no_action=request.reject,\n            abort_on=[self._tab.abort_questions],\n            blocking=True)\n\n\nclass _WebEngineScripts(QObject):\n\n    def __init__(self, tab, parent=None):\n        super().__init__(parent)\n        self._tab = tab\n        self._widget = typing.cast(QWidget, None)\n        self._greasemonkey = greasemonkey.gm_manager\n\n    def connect_signals(self):\n        \"\"\"Connect signals to our private slots.\"\"\"\n        config.instance.changed.connect(self._on_config_changed)\n\n        self._tab.search.cleared.connect(functools.partial(\n            self._update_stylesheet, searching=False))\n        self._tab.search.finished.connect(self._update_stylesheet)\n\n    @pyqtSlot(str)\n    def _on_config_changed(self, option):\n        if option in ['scrolling.bar', 'content.user_stylesheets']:\n            self._init_stylesheet()\n            self._update_stylesheet()\n\n    @pyqtSlot(bool)\n    def _update_stylesheet(self, searching=False):\n        \"\"\"Update the custom stylesheet in existing tabs.\"\"\"\n        css = shared.get_user_stylesheet(searching=searching)\n        code = javascript.assemble('stylesheet', 'set_css', css)\n        self._tab.run_js_async(code)\n\n    def _inject_early_js(self, name, js_code, *,\n                         world=QWebEngineScript.ApplicationWorld,\n                         subframes=False):\n        \"\"\"Inject the given script to run early on a page load.\n\n        This runs the script both on DocumentCreation and DocumentReady as on\n        some internal pages, DocumentCreation will not work.\n\n        That is a WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66011\n        \"\"\"\n        scripts = self._widget.page().scripts()\n        for injection in ['creation', 'ready']:\n            injection_points = {\n                'creation': QWebEngineScript.DocumentCreation,\n                'ready': QWebEngineScript.DocumentReady,\n            }\n            script = QWebEngineScript()\n            script.setInjectionPoint(injection_points[injection])\n            script.setSourceCode(js_code)\n            script.setWorldId(world)\n            script.setRunsOnSubFrames(subframes)\n            script.setName('_qute_{}_{}'.format(name, injection))\n            scripts.insert(script)\n\n    def _remove_early_js(self, name):\n        \"\"\"Remove an early QWebEngineScript.\"\"\"\n        scripts = self._widget.page().scripts()\n        for injection in ['creation', 'ready']:\n            full_name = '_qute_{}_{}'.format(name, injection)\n            script = scripts.findScript(full_name)\n            if not script.isNull():\n                scripts.remove(script)\n\n    def init(self):\n        \"\"\"Initialize global qutebrowser JavaScript.\"\"\"\n        js_code = javascript.wrap_global(\n            'scripts',\n            utils.read_file('javascript/scroll.js'),\n            utils.read_file('javascript/webelem.js'),\n            utils.read_file('javascript/caret.js'),\n        )\n        if not qtutils.version_check('5.12'):\n            # WORKAROUND for Qt versions < 5.12 not exposing window.print().\n            # Qt 5.12 has a printRequested() signal so we don't need this hack\n            # anymore.\n            self._inject_early_js('js',\n                                  utils.read_file('javascript/print.js'),\n                                  subframes=True,\n                                  world=QWebEngineScript.MainWorld)\n        # FIXME:qtwebengine what about subframes=True?\n        self._inject_early_js('js', js_code, subframes=True)\n        self._init_stylesheet()\n\n        # The Greasemonkey metadata block support in QtWebEngine only starts at\n        # Qt 5.8. With 5.7.1, we need to inject the scripts ourselves in\n        # response to urlChanged.\n        if not qtutils.version_check('5.8'):\n            self._tab.url_changed.connect(\n                self._inject_greasemonkey_scripts_for_url)\n        else:\n            self._greasemonkey.scripts_reloaded.connect(\n                self._inject_all_greasemonkey_scripts)\n            self._inject_all_greasemonkey_scripts()\n            self._inject_site_specific_quirks()\n\n    def _init_stylesheet(self):\n        \"\"\"Initialize custom stylesheets.\n\n        Partially inspired by QupZilla:\n        https://github.com/QupZilla/qupzilla/blob/v2.0/src/lib/app/mainapplication.cpp#L1063-L1101\n        \"\"\"\n        self._remove_early_js('stylesheet')\n        css = shared.get_user_stylesheet()\n        js_code = javascript.wrap_global(\n            'stylesheet',\n            utils.read_file('javascript/stylesheet.js'),\n            javascript.assemble('stylesheet', 'set_css', css),\n        )\n        self._inject_early_js('stylesheet', js_code, subframes=True)\n\n    @pyqtSlot(QUrl)\n    def _inject_greasemonkey_scripts_for_url(self, url):\n        matching_scripts = self._greasemonkey.scripts_for(url)\n        self._inject_greasemonkey_scripts(\n            matching_scripts.start, QWebEngineScript.DocumentCreation, True)\n        self._inject_greasemonkey_scripts(\n            matching_scripts.end, QWebEngineScript.DocumentReady, False)\n        self._inject_greasemonkey_scripts(\n            matching_scripts.idle, QWebEngineScript.Deferred, False)\n\n    @pyqtSlot()\n    def _inject_all_greasemonkey_scripts(self):\n        scripts = self._greasemonkey.all_scripts()\n        self._inject_greasemonkey_scripts(scripts)\n\n    def _remove_all_greasemonkey_scripts(self):\n        page_scripts = self._widget.page().scripts()\n        for script in page_scripts.toList():\n            if script.name().startswith(\"GM-\"):\n                log.greasemonkey.debug('Removing script: {}'\n                                       .format(script.name()))\n                removed = page_scripts.remove(script)\n                assert removed, script.name()\n\n    def _inject_greasemonkey_scripts(self, scripts=None, injection_point=None,\n                                     remove_first=True):\n        \"\"\"Register user JavaScript files with the current tab.\n\n        Args:\n            scripts: A list of GreasemonkeyScripts, or None to add all\n                     known by the Greasemonkey subsystem.\n            injection_point: The QWebEngineScript::InjectionPoint stage\n                             to inject the script into, None to use\n                             auto-detection.\n            remove_first: Whether to remove all previously injected\n                          scripts before adding these ones.\n        \"\"\"\n        if sip.isdeleted(self._widget):\n            return\n\n        # Since we are inserting scripts into a per-tab collection,\n        # rather than just injecting scripts on page load, we need to\n        # make sure we replace existing scripts, not just add new ones.\n        # While, taking care not to remove any other scripts that might\n        # have been added elsewhere, like the one for stylesheets.\n        page_scripts = self._widget.page().scripts()\n        if remove_first:\n            self._remove_all_greasemonkey_scripts()\n\n        if not scripts:\n            return\n\n        for script in scripts:\n            new_script = QWebEngineScript()\n            try:\n                world = int(script.jsworld)\n                if not 0 <= world <= qtutils.MAX_WORLD_ID:\n                    log.greasemonkey.error(\n                        \"script {} has invalid value for '@qute-js-world'\"\n                        \": {}, should be between 0 and {}\"\n                        .format(\n                            script.name,\n                            script.jsworld,\n                            qtutils.MAX_WORLD_ID))\n                    continue\n            except ValueError:\n                try:\n                    world = _JS_WORLD_MAP[usertypes.JsWorld[\n                        script.jsworld.lower()]]\n                except KeyError:\n                    log.greasemonkey.error(\n                        \"script {} has invalid value for '@qute-js-world'\"\n                        \": {}\".format(script.name, script.jsworld))\n                    continue\n            new_script.setWorldId(world)\n            new_script.setSourceCode(script.code())\n            new_script.setName(\"GM-{}\".format(script.name))\n            new_script.setRunsOnSubFrames(script.runs_on_sub_frames)\n\n            # Override the @run-at value parsed by QWebEngineScript if desired.\n            if injection_point:\n                new_script.setInjectionPoint(injection_point)\n            elif script.needs_document_end_workaround():\n                log.greasemonkey.debug(\"Forcing @run-at document-end for {}\"\n                                       .format(script.name))\n                new_script.setInjectionPoint(QWebEngineScript.DocumentReady)\n\n            log.greasemonkey.debug('adding script: {}'\n                                   .format(new_script.name()))\n            page_scripts.insert(new_script)\n\n    def _inject_site_specific_quirks(self):\n        \"\"\"Add site-specific quirk scripts.\n\n        NOTE: This isn't implemented for Qt 5.7 because of different UserScript\n        semantics there. We only have a quirk for WhatsApp Web right now. It\n        looks like that quirk isn't needed for Qt < 5.13.\n        \"\"\"\n        if not config.val.content.site_specific_quirks:\n            return\n\n        page_scripts = self._widget.page().scripts()\n\n        for filename in ['whatsapp_web_quirk']:\n            script = QWebEngineScript()\n            script.setName(filename)\n            script.setWorldId(QWebEngineScript.ApplicationWorld)\n            script.setInjectionPoint(QWebEngineScript.DocumentReady)\n            src = utils.read_file(\"javascript/{}.user.js\".format(filename))\n            script.setSourceCode(src)\n            page_scripts.insert(script)\n\n\nclass WebEngineTabPrivate(browsertab.AbstractTabPrivate):\n\n    \"\"\"QtWebEngine-related methods which aren't part of the public API.\"\"\"\n\n    def networkaccessmanager(self):\n        return None\n\n    def user_agent(self):\n        return None\n\n    def clear_ssl_errors(self):\n        raise browsertab.UnsupportedOperationError\n\n    def event_target(self):\n        return self._widget.render_widget()\n\n    def shutdown(self):\n        self._tab.shutting_down.emit()\n        self._tab.action.exit_fullscreen()\n        self._widget.shutdown()\n\n\nclass WebEngineTab(browsertab.AbstractTab):\n\n    \"\"\"A QtWebEngine tab in the browser.\n\n    Signals:\n        abort_questions: Emitted when a new load started or we're shutting\n            down.\n    \"\"\"\n\n    abort_questions = pyqtSignal()\n\n    def __init__(self, *, win_id, mode_manager, private, parent=None):\n        super().__init__(win_id=win_id, private=private, parent=parent)\n        widget = webview.WebEngineView(tabdata=self.data, win_id=win_id,\n                                       private=private)\n        self.history = WebEngineHistory(tab=self)\n        self.scroller = WebEngineScroller(tab=self, parent=self)\n        self.caret = WebEngineCaret(mode_manager=mode_manager,\n                                    tab=self, parent=self)\n        self.zoom = WebEngineZoom(tab=self, parent=self)\n        self.search = WebEngineSearch(tab=self, parent=self)\n        self.printing = WebEnginePrinting(tab=self)\n        self.elements = WebEngineElements(tab=self)\n        self.action = WebEngineAction(tab=self)\n        self.audio = WebEngineAudio(tab=self, parent=self)\n        self.private_api = WebEngineTabPrivate(mode_manager=mode_manager,\n                                               tab=self)\n        self._permissions = _WebEnginePermissions(tab=self, parent=self)\n        self._scripts = _WebEngineScripts(tab=self, parent=self)\n        # We're assigning settings in _set_widget\n        self.settings = webenginesettings.WebEngineSettings(settings=None)\n        self._set_widget(widget)\n        self._connect_signals()\n        self.backend = usertypes.Backend.QtWebEngine\n        self._child_event_filter = None\n        self._saved_zoom = None\n        self._reload_url = None  # type: typing.Optional[QUrl]\n        self._scripts.init()\n\n    def _set_widget(self, widget):\n        # pylint: disable=protected-access\n        super()._set_widget(widget)\n        self._permissions._widget = widget\n        self._scripts._widget = widget\n\n    def _install_event_filter(self):\n        fp = self._widget.focusProxy()\n        if fp is not None:\n            fp.installEventFilter(self._tab_event_filter)\n        self._child_event_filter = eventfilter.ChildEventFilter(\n            eventfilter=self._tab_event_filter, widget=self._widget,\n            win_id=self.win_id, parent=self)\n        self._widget.installEventFilter(self._child_event_filter)\n\n    @pyqtSlot()\n    def _restore_zoom(self):\n        if sip.isdeleted(self._widget):\n            # https://github.com/qutebrowser/qutebrowser/issues/3498\n            return\n        if self._saved_zoom is None:\n            return\n        self.zoom.set_factor(self._saved_zoom)\n        self._saved_zoom = None\n\n    def load_url(self, url, *, emit_before_load_started=True):\n        \"\"\"Load the given URL in this tab.\n\n        Arguments:\n            url: The QUrl to load.\n            emit_before_load_started: If set to False, before_load_started is\n                                      not emitted.\n        \"\"\"\n        if sip.isdeleted(self._widget):\n            # https://github.com/qutebrowser/qutebrowser/issues/3896\n            return\n        self._saved_zoom = self.zoom.factor()\n        self._load_url_prepare(\n            url, emit_before_load_started=emit_before_load_started)\n        self._widget.load(url)\n\n    def url(self, *, requested=False):\n        page = self._widget.page()\n        if requested:\n            return page.requestedUrl()\n        else:\n            return page.url()\n\n    def dump_async(self, callback, *, plain=False):\n        if plain:\n            self._widget.page().toPlainText(callback)\n        else:\n            self._widget.page().toHtml(callback)\n\n    def run_js_async(self, code, callback=None, *, world=None):\n        world_id_type = typing.Union[QWebEngineScript.ScriptWorldId, int]\n        if world is None:\n            world_id = QWebEngineScript.ApplicationWorld  # type: world_id_type\n        elif isinstance(world, int):\n            world_id = world\n            if not 0 <= world_id <= qtutils.MAX_WORLD_ID:\n                raise browsertab.WebTabError(\n                    \"World ID should be between 0 and {}\"\n                    .format(qtutils.MAX_WORLD_ID))\n        else:\n            world_id = _JS_WORLD_MAP[world]\n\n        if callback is None:\n            self._widget.page().runJavaScript(code, world_id)\n        else:\n            self._widget.page().runJavaScript(code, world_id, callback)\n\n    def reload(self, *, force=False):\n        if force:\n            action = QWebEnginePage.ReloadAndBypassCache\n        else:\n            action = QWebEnginePage.Reload\n        self._widget.triggerPageAction(action)\n\n    def stop(self):\n        self._widget.stop()\n\n    def title(self):\n        return self._widget.title()\n\n    def icon(self):\n        return self._widget.icon()\n\n    def set_html(self, html, base_url=QUrl()):\n        # FIXME:qtwebengine\n        # check this and raise an exception if too big:\n        # Warning: The content will be percent encoded before being sent to the\n        # renderer via IPC. This may increase its size. The maximum size of the\n        # percent encoded content is 2 megabytes minus 30 bytes.\n        self._widget.setHtml(html, base_url)\n\n    def _show_error_page(self, url, error):\n        \"\"\"Show an error page in the tab.\"\"\"\n        log.misc.debug(\"Showing error page for {}\".format(error))\n        url_string = url.toDisplayString()\n        error_page = jinja.render(\n            'error.html',\n            title=\"Error loading page: {}\".format(url_string),\n            url=url_string, error=error)\n        self.set_html(error_page)\n\n    @pyqtSlot()\n    def _on_history_trigger(self):\n        try:\n            self._widget.page()\n        except RuntimeError:\n            # Looks like this slot can be triggered on destroyed tabs:\n            # https://crashes.qutebrowser.org/view/3abffbed (Qt 5.9.1)\n            # wrapped C/C++ object of type WebEngineView has been deleted\n            log.misc.debug(\"Ignoring history trigger for destroyed tab\")\n            return\n\n        url = self.url()\n        requested_url = self.url(requested=True)\n\n        # Don't save the title if it's generated from the URL\n        title = self.title()\n        title_url = QUrl(url)\n        title_url.setScheme('')\n        title_url_str = title_url.toDisplayString(\n            QUrl.RemoveScheme)  # type: ignore\n        if title == title_url_str.strip('/'):\n            title = \"\"\n\n        # Don't add history entry if the URL is invalid anyways\n        if not url.isValid():\n            log.misc.debug(\"Ignoring invalid URL being added to history\")\n            return\n\n        self.history_item_triggered.emit(url, requested_url, title)\n\n    @pyqtSlot(QUrl, 'QAuthenticator*', 'QString')\n    def _on_proxy_authentication_required(self, url, authenticator,\n                                          proxy_host):\n        \"\"\"Called when a proxy needs authentication.\"\"\"\n        msg = \"<b>{}</b> requires a username and password.\".format(\n            html_utils.escape(proxy_host))\n        urlstr = url.toString(QUrl.RemovePassword | QUrl.FullyEncoded)\n        answer = message.ask(\n            title=\"Proxy authentication required\", text=msg,\n            mode=usertypes.PromptMode.user_pwd,\n            abort_on=[self.abort_questions], url=urlstr)\n        if answer is not None:\n            authenticator.setUser(answer.user)\n            authenticator.setPassword(answer.password)\n        else:\n            try:\n                sip.assign(authenticator, QAuthenticator())  # type: ignore\n            except AttributeError:\n                self._show_error_page(url, \"Proxy authentication required\")\n\n    @pyqtSlot(QUrl, 'QAuthenticator*')\n    def _on_authentication_required(self, url, authenticator):\n        log.network.debug(\"Authentication requested for {}, netrc_used {}\"\n                          .format(url.toDisplayString(), self.data.netrc_used))\n\n        netrc_success = False\n        if not self.data.netrc_used:\n            self.data.netrc_used = True\n            netrc_success = shared.netrc_authentication(url, authenticator)\n\n        if not netrc_success:\n            log.network.debug(\"Asking for credentials\")\n            answer = shared.authentication_required(\n                url, authenticator, abort_on=[self.abort_questions])\n        if not netrc_success and answer is None:\n            log.network.debug(\"Aborting auth\")\n            try:\n                sip.assign(authenticator, QAuthenticator())  # type: ignore\n            except AttributeError:\n                # WORKAROUND for\n                # https://www.riverbankcomputing.com/pipermail/pyqt/2016-December/038400.html\n                self._show_error_page(url, \"Authentication required\")\n\n    @pyqtSlot()\n    def _on_load_started(self):\n        \"\"\"Clear search when a new load is started if needed.\"\"\"\n        # WORKAROUND for\n        # https://bugreports.qt.io/browse/QTBUG-61506\n        # (seems to be back in later Qt versions as well)\n        self.search.clear()\n        super()._on_load_started()\n        self.data.netrc_used = False\n\n    @pyqtSlot(QWebEnginePage.RenderProcessTerminationStatus, int)\n    def _on_render_process_terminated(self, status, exitcode):\n        \"\"\"Show an error when the renderer process terminated.\"\"\"\n        if (status == QWebEnginePage.AbnormalTerminationStatus and\n                exitcode == 256):\n            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-58697\n            status = QWebEnginePage.CrashedTerminationStatus\n\n        status_map = {\n            QWebEnginePage.NormalTerminationStatus:\n                browsertab.TerminationStatus.normal,\n            QWebEnginePage.AbnormalTerminationStatus:\n                browsertab.TerminationStatus.abnormal,\n            QWebEnginePage.CrashedTerminationStatus:\n                browsertab.TerminationStatus.crashed,\n            QWebEnginePage.KilledTerminationStatus:\n                browsertab.TerminationStatus.killed,\n            -1:\n                browsertab.TerminationStatus.unknown,\n        }\n        self.renderer_process_terminated.emit(status_map[status], exitcode)\n\n    def _error_page_workaround(self, js_enabled, html):\n        \"\"\"Check if we're displaying a Chromium error page.\n\n        This gets called if we got a loadFinished(False), so we can display at\n        least some error page in situations where Chromium's can't be\n        displayed.\n\n        WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66643\n        WORKAROUND for https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=882805\n\n        Needs to check the page content as a WORKAROUND for\n        https://bugreports.qt.io/browse/QTBUG-66661\n        \"\"\"\n        match = re.search(r'\"errorCode\":\"([^\"]*)\"', html)\n        if match is None:\n            return\n\n        error = match.group(1)\n        log.webview.error(\"Load error: {}\".format(error))\n\n        missing_jst = 'jstProcess(' in html and 'jstProcess=' not in html\n        if js_enabled and not missing_jst:\n            return\n\n        self._show_error_page(self.url(), error=error)\n\n    @pyqtSlot(int)\n    def _on_load_progress(self, perc: int) -> None:\n        \"\"\"QtWebEngine-specific loadProgress workarounds.\n\n        WORKAROUND for https://bugreports.qt.io/browse/QTBUG-65223\n        \"\"\"\n        super()._on_load_progress(perc)\n        if (perc == 100 and\n                qtutils.version_check('5.10', compiled=False) and\n                self.load_status() != usertypes.LoadStatus.error):\n            self._update_load_status(ok=True)\n\n    @pyqtSlot(bool)\n    def _on_load_finished(self, ok: bool) -> None:\n        \"\"\"QtWebEngine-specific loadFinished workarounds.\"\"\"\n        super()._on_load_finished(ok)\n\n        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-65223\n        if qtutils.version_check('5.10', compiled=False):\n            if not ok:\n                self._update_load_status(ok)\n        else:\n            self._update_load_status(ok)\n\n        if not ok:\n            self.dump_async(functools.partial(\n                self._error_page_workaround,\n                self.settings.test_attribute('content.javascript.enabled')))\n\n        if ok and self._reload_url is not None:\n            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656\n            log.config.debug(\n                \"Loading {} again because of config change\".format(\n                    self._reload_url.toDisplayString()))\n            QTimer.singleShot(100, functools.partial(\n                self.load_url, self._reload_url,\n                emit_before_load_started=False))\n            self._reload_url = None\n\n    @pyqtSlot(certificateerror.CertificateErrorWrapper)\n    def _on_ssl_errors(self, error):\n        url = error.url()\n        self._insecure_hosts.add(url.host())\n\n        log.webview.debug(\"Certificate error: {}\".format(error))\n\n        if error.is_overridable():\n            error.ignore = shared.ignore_certificate_errors(\n                url, [error], abort_on=[self.abort_questions])\n        else:\n            log.webview.error(\"Non-overridable certificate error: \"\n                              \"{}\".format(error))\n\n        log.webview.debug(\"ignore {}, URL {}, requested {}\".format(\n            error.ignore, url, self.url(requested=True)))\n\n        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-56207\n        show_cert_error = (\n            not qtutils.version_check('5.9') and\n            not error.ignore\n        )\n        # WORKAROUND for https://codereview.qt-project.org/c/qt/qtwebengine/+/270556\n        show_non_overr_cert_error = (\n            not error.is_overridable() and (\n                # Affected Qt versions:\n                # 5.13 before 5.13.2\n                # 5.12 before 5.12.6\n                # < 5.12\n                (qtutils.version_check('5.13') and\n                 not qtutils.version_check('5.13.2')) or\n                (qtutils.version_check('5.12') and\n                 not qtutils.version_check('5.12.6')) or\n                not qtutils.version_check('5.12')\n            )\n        )\n\n        # We can't really know when to show an error page, as the error might\n        # have happened when loading some resource.\n        # However, self.url() is not available yet and the requested URL\n        # might not match the URL we get from the error - so we just apply a\n        # heuristic here.\n        if ((show_cert_error or show_non_overr_cert_error) and\n                url.matches(self.data.last_navigation.url, QUrl.RemoveScheme)):\n            self._show_error_page(url, str(error))\n\n    @pyqtSlot(QUrl)\n    def _on_before_load_started(self, url):\n        \"\"\"If we know we're going to visit a URL soon, change the settings.\n\n        This is a WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656\n        \"\"\"\n        super()._on_before_load_started(url)\n        if not qtutils.version_check('5.11.1', compiled=False):\n            self.settings.update_for_url(url)\n\n    @pyqtSlot()\n    def _on_print_requested(self):\n        \"\"\"Slot for window.print() in JS.\"\"\"\n        try:\n            self.printing.show_dialog()\n        except browsertab.WebTabError as e:\n            message.error(str(e))\n\n    @pyqtSlot(QUrl)\n    def _on_url_changed(self, url: QUrl) -> None:\n        \"\"\"Update settings for the current URL.\n\n        Normally this is done below in _on_navigation_request, but we also need\n        to do it here as WORKAROUND for\n        https://bugreports.qt.io/browse/QTBUG-77137\n\n        Since update_for_url() is idempotent, it doesn't matter much if we end\n        up doing it twice.\n        \"\"\"\n        super()._on_url_changed(url)\n        if url.isValid() and qtutils.version_check('5.13'):\n            self.settings.update_for_url(url)\n\n    @pyqtSlot(usertypes.NavigationRequest)\n    def _on_navigation_request(self, navigation):\n        super()._on_navigation_request(navigation)\n\n        if navigation.url == QUrl('qute://print'):\n            self._on_print_requested()\n            navigation.accepted = False\n\n        if not navigation.accepted or not navigation.is_main_frame:\n            return\n\n        settings_needing_reload = {\n            'content.plugins',\n            'content.javascript.enabled',\n            'content.javascript.can_access_clipboard',\n            'content.print_element_backgrounds',\n            'input.spatial_navigation',\n        }\n        assert settings_needing_reload.issubset(configdata.DATA)\n\n        changed = self.settings.update_for_url(navigation.url)\n        reload_needed = bool(changed & settings_needing_reload)\n\n        # On Qt < 5.11, we don't don't need a reload when type == link_clicked.\n        # On Qt 5.11.0, we always need a reload.\n        # On Qt > 5.11.0, we never need a reload:\n        # https://codereview.qt-project.org/#/c/229525/1\n        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656\n        if qtutils.version_check('5.11.1', compiled=False):\n            reload_needed = False\n        elif not qtutils.version_check('5.11.0', exact=True, compiled=False):\n            if navigation.navigation_type == navigation.Type.link_clicked:\n                reload_needed = False\n\n        if reload_needed:\n            self._reload_url = navigation.url\n\n    def _on_select_client_certificate(self, selection):\n        \"\"\"Handle client certificates.\n\n        Currently, we simply pick the first available certificate and show an\n        additional note if there are multiple matches.\n        \"\"\"\n        certificate = selection.certificates()[0]\n        text = ('<b>Subject:</b> {subj}<br/>'\n                '<b>Issuer:</b> {issuer}<br/>'\n                '<b>Serial:</b> {serial}'.format(\n                    subj=html_utils.escape(certificate.subjectDisplayName()),\n                    issuer=html_utils.escape(certificate.issuerDisplayName()),\n                    serial=bytes(certificate.serialNumber()).decode('ascii')))\n        if len(selection.certificates()) > 1:\n            text += ('<br/><br/><b>Note:</b> Multiple matching certificates '\n                     'were found, but certificate selection is not '\n                     'implemented yet!')\n        urlstr = selection.host().host()\n\n        present = message.ask(\n            title='Present client certificate to {}?'.format(urlstr),\n            text=text,\n            mode=usertypes.PromptMode.yesno,\n            abort_on=[self.abort_questions],\n            url=urlstr)\n\n        if present:\n            selection.select(certificate)\n        else:\n            selection.selectNone()\n\n    def _connect_signals(self):\n        view = self._widget\n        page = view.page()\n\n        page.windowCloseRequested.connect(self.window_close_requested)\n        page.linkHovered.connect(self.link_hovered)\n        page.loadProgress.connect(self._on_load_progress)\n        page.loadStarted.connect(self._on_load_started)\n        page.certificate_error.connect(self._on_ssl_errors)\n        page.authenticationRequired.connect(self._on_authentication_required)\n        page.proxyAuthenticationRequired.connect(\n            self._on_proxy_authentication_required)\n        page.contentsSizeChanged.connect(self.contents_size_changed)\n        page.navigation_request.connect(self._on_navigation_request)\n\n        if qtutils.version_check('5.12'):\n            page.printRequested.connect(self._on_print_requested)\n\n        try:\n            # pylint: disable=unused-import\n            from PyQt5.QtWebEngineWidgets import (  # type: ignore\n                QWebEngineClientCertificateSelection)\n        except ImportError:\n            pass\n        else:\n            page.selectClientCertificate.connect(\n                self._on_select_client_certificate)\n\n        view.titleChanged.connect(self.title_changed)\n        view.urlChanged.connect(self._on_url_changed)\n        view.renderProcessTerminated.connect(\n            self._on_render_process_terminated)\n        view.iconChanged.connect(self.icon_changed)\n\n        page.loadFinished.connect(self._on_history_trigger)\n        page.loadFinished.connect(self._restore_zoom)\n        page.loadFinished.connect(self._on_load_finished)\n\n        self.before_load_started.connect(self._on_before_load_started)\n        self.shutting_down.connect(self.abort_questions)  # type: ignore\n        self.load_started.connect(self.abort_questions)  # type: ignore\n\n        # pylint: disable=protected-access\n        self.audio._connect_signals()\n        self.search.connect_signals()\n        self._permissions.connect_signals()\n        self._scripts.connect_signals()\n", "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2016-2020 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"Wrapper over our (QtWebKit) WebView.\"\"\"\n\nimport re\nimport functools\nimport xml.etree.ElementTree\n\nfrom PyQt5.QtCore import pyqtSlot, Qt, QUrl, QPoint, QTimer, QSizeF, QSize\nfrom PyQt5.QtGui import QIcon\nfrom PyQt5.QtWebKitWidgets import QWebPage, QWebFrame\nfrom PyQt5.QtWebKit import QWebSettings\nfrom PyQt5.QtPrintSupport import QPrinter\n\nfrom qutebrowser.browser import browsertab, shared\nfrom qutebrowser.browser.webkit import (webview, tabhistory, webkitelem,\n                                        webkitsettings)\nfrom qutebrowser.utils import qtutils, usertypes, utils, log, debug\nfrom qutebrowser.qt import sip\n\n\nclass WebKitAction(browsertab.AbstractAction):\n\n    \"\"\"QtWebKit implementations related to web actions.\"\"\"\n\n    action_class = QWebPage\n    action_base = QWebPage.WebAction\n\n    def exit_fullscreen(self):\n        raise browsertab.UnsupportedOperationError\n\n    def save_page(self):\n        \"\"\"Save the current page.\"\"\"\n        raise browsertab.UnsupportedOperationError\n\n    def show_source(self, pygments=False):\n        self._show_source_pygments()\n\n\nclass WebKitPrinting(browsertab.AbstractPrinting):\n\n    \"\"\"QtWebKit implementations related to printing.\"\"\"\n\n    def check_pdf_support(self):\n        pass\n\n    def check_printer_support(self):\n        pass\n\n    def check_preview_support(self):\n        pass\n\n    def to_pdf(self, filename):\n        printer = QPrinter()\n        printer.setOutputFileName(filename)\n        self.to_printer(printer)\n\n    def to_printer(self, printer, callback=None):\n        self._widget.print(printer)\n        # Can't find out whether there was an error...\n        if callback is not None:\n            callback(True)\n\n\nclass WebKitSearch(browsertab.AbstractSearch):\n\n    \"\"\"QtWebKit implementations related to searching on the page.\"\"\"\n\n    def __init__(self, tab, parent=None):\n        super().__init__(tab, parent)\n        self._flags = QWebPage.FindFlags(0)  # type: ignore\n\n    def _call_cb(self, callback, found, text, flags, caller):\n        \"\"\"Call the given callback if it's non-None.\n\n        Delays the call via a QTimer so the website is re-rendered in between.\n\n        Args:\n            callback: What to call\n            found: If the text was found\n            text: The text searched for\n            flags: The flags searched with\n            caller: Name of the caller.\n        \"\"\"\n        found_text = 'found' if found else \"didn't find\"\n        # Removing FindWrapsAroundDocument to get the same logging as with\n        # QtWebEngine\n        debug_flags = debug.qflags_key(\n            QWebPage, flags & ~QWebPage.FindWrapsAroundDocument,\n            klass=QWebPage.FindFlag)\n        if debug_flags != '0x0000':\n            flag_text = 'with flags {}'.format(debug_flags)\n        else:\n            flag_text = ''\n        log.webview.debug(' '.join([caller, found_text, text, flag_text])\n                          .strip())\n        if callback is not None:\n            QTimer.singleShot(0, functools.partial(callback, found))\n\n        self.finished.emit(found)\n\n    def clear(self):\n        if self.search_displayed:\n            self.cleared.emit()\n        self.search_displayed = False\n        # We first clear the marked text, then the highlights\n        self._widget.findText('')\n        self._widget.findText('', QWebPage.HighlightAllOccurrences)\n\n    def search(self, text, *, ignore_case=usertypes.IgnoreCase.never,\n               reverse=False, wrap=True, result_cb=None):\n        # Don't go to next entry on duplicate search\n        if self.text == text and self.search_displayed:\n            log.webview.debug(\"Ignoring duplicate search request\"\n                              \" for {}\".format(text))\n            return\n\n        # Clear old search results, this is done automatically on QtWebEngine.\n        self.clear()\n\n        self.text = text\n        self.search_displayed = True\n        self._flags = QWebPage.FindFlags(0)  # type: ignore\n        if self._is_case_sensitive(ignore_case):\n            self._flags |= QWebPage.FindCaseSensitively\n        if reverse:\n            self._flags |= QWebPage.FindBackward\n        if wrap:\n            self._flags |= QWebPage.FindWrapsAroundDocument\n        # We actually search *twice* - once to highlight everything, then again\n        # to get a mark so we can navigate.\n        found = self._widget.findText(text, self._flags)\n        self._widget.findText(text,\n                              self._flags | QWebPage.HighlightAllOccurrences)\n        self._call_cb(result_cb, found, text, self._flags, 'search')\n\n    def next_result(self, *, result_cb=None):\n        self.search_displayed = True\n        found = self._widget.findText(self.text, self._flags)\n        self._call_cb(result_cb, found, self.text, self._flags, 'next_result')\n\n    def prev_result(self, *, result_cb=None):\n        self.search_displayed = True\n        # The int() here makes sure we get a copy of the flags.\n        flags = QWebPage.FindFlags(int(self._flags))  # type: ignore\n        if flags & QWebPage.FindBackward:\n            flags &= ~QWebPage.FindBackward\n        else:\n            flags |= QWebPage.FindBackward\n        found = self._widget.findText(self.text, flags)\n        self._call_cb(result_cb, found, self.text, flags, 'prev_result')\n\n\nclass WebKitCaret(browsertab.AbstractCaret):\n\n    \"\"\"QtWebKit implementations related to moving the cursor/selection.\"\"\"\n\n    @pyqtSlot(usertypes.KeyMode)\n    def _on_mode_entered(self, mode):\n        if mode != usertypes.KeyMode.caret:\n            return\n\n        self.selection_enabled = self._widget.hasSelection()\n        self.selection_toggled.emit(self.selection_enabled)\n        settings = self._widget.settings()\n        settings.setAttribute(QWebSettings.CaretBrowsingEnabled, True)\n\n        if self._widget.isVisible():\n            # Sometimes the caret isn't immediately visible, but unfocusing\n            # and refocusing it fixes that.\n            self._widget.clearFocus()\n            self._widget.setFocus(Qt.OtherFocusReason)\n\n            # Move the caret to the first element in the viewport if there\n            # isn't any text which is already selected.\n            #\n            # Note: We can't use hasSelection() here, as that's always\n            # true in caret mode.\n            if not self.selection_enabled:\n                self._widget.page().currentFrame().evaluateJavaScript(\n                    utils.read_file('javascript/position_caret.js'))\n\n    @pyqtSlot(usertypes.KeyMode)\n    def _on_mode_left(self, _mode):\n        settings = self._widget.settings()\n        if settings.testAttribute(QWebSettings.CaretBrowsingEnabled):\n            if self.selection_enabled and self._widget.hasSelection():\n                # Remove selection if it exists\n                self._widget.triggerPageAction(QWebPage.MoveToNextChar)\n            settings.setAttribute(QWebSettings.CaretBrowsingEnabled, False)\n            self.selection_enabled = False\n\n    def move_to_next_line(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToNextLine\n        else:\n            act = QWebPage.SelectNextLine\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_prev_line(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToPreviousLine\n        else:\n            act = QWebPage.SelectPreviousLine\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_next_char(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToNextChar\n        else:\n            act = QWebPage.SelectNextChar\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_prev_char(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToPreviousChar\n        else:\n            act = QWebPage.SelectPreviousChar\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_end_of_word(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToNextWord]\n            if utils.is_windows:  # pragma: no cover\n                act.append(QWebPage.MoveToPreviousChar)\n        else:\n            act = [QWebPage.SelectNextWord]\n            if utils.is_windows:  # pragma: no cover\n                act.append(QWebPage.SelectPreviousChar)\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_next_word(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToNextWord]\n            if not utils.is_windows:  # pragma: no branch\n                act.append(QWebPage.MoveToNextChar)\n        else:\n            act = [QWebPage.SelectNextWord]\n            if not utils.is_windows:  # pragma: no branch\n                act.append(QWebPage.SelectNextChar)\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_prev_word(self, count=1):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToPreviousWord\n        else:\n            act = QWebPage.SelectPreviousWord\n        for _ in range(count):\n            self._widget.triggerPageAction(act)\n\n    def move_to_start_of_line(self):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToStartOfLine\n        else:\n            act = QWebPage.SelectStartOfLine\n        self._widget.triggerPageAction(act)\n\n    def move_to_end_of_line(self):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToEndOfLine\n        else:\n            act = QWebPage.SelectEndOfLine\n        self._widget.triggerPageAction(act)\n\n    def move_to_start_of_next_block(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToNextLine,\n                   QWebPage.MoveToStartOfBlock]\n        else:\n            act = [QWebPage.SelectNextLine,\n                   QWebPage.SelectStartOfBlock]\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_start_of_prev_block(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToPreviousLine,\n                   QWebPage.MoveToStartOfBlock]\n        else:\n            act = [QWebPage.SelectPreviousLine,\n                   QWebPage.SelectStartOfBlock]\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_end_of_next_block(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToNextLine,\n                   QWebPage.MoveToEndOfBlock]\n        else:\n            act = [QWebPage.SelectNextLine,\n                   QWebPage.SelectEndOfBlock]\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_end_of_prev_block(self, count=1):\n        if not self.selection_enabled:\n            act = [QWebPage.MoveToPreviousLine, QWebPage.MoveToEndOfBlock]\n        else:\n            act = [QWebPage.SelectPreviousLine, QWebPage.SelectEndOfBlock]\n        for _ in range(count):\n            for a in act:\n                self._widget.triggerPageAction(a)\n\n    def move_to_start_of_document(self):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToStartOfDocument\n        else:\n            act = QWebPage.SelectStartOfDocument\n        self._widget.triggerPageAction(act)\n\n    def move_to_end_of_document(self):\n        if not self.selection_enabled:\n            act = QWebPage.MoveToEndOfDocument\n        else:\n            act = QWebPage.SelectEndOfDocument\n        self._widget.triggerPageAction(act)\n\n    def toggle_selection(self):\n        self.selection_enabled = not self.selection_enabled\n        self.selection_toggled.emit(self.selection_enabled)\n\n    def drop_selection(self):\n        self._widget.triggerPageAction(QWebPage.MoveToNextChar)\n\n    def selection(self, callback):\n        callback(self._widget.selectedText())\n\n    def reverse_selection(self):\n        self._tab.run_js_async(\"\"\"{\n            const sel = window.getSelection();\n            sel.setBaseAndExtent(\n                sel.extentNode, sel.extentOffset, sel.baseNode,\n                sel.baseOffset\n            );\n        }\"\"\")\n\n    def _follow_selected(self, *, tab=False):\n        if QWebSettings.globalSettings().testAttribute(\n                QWebSettings.JavascriptEnabled):\n            if tab:\n                self._tab.data.override_target = usertypes.ClickTarget.tab\n            self._tab.run_js_async(\"\"\"\n                const aElm = document.activeElement;\n                if (window.getSelection().anchorNode) {\n                    window.getSelection().anchorNode.parentNode.click();\n                } else if (aElm && aElm !== document.body) {\n                    aElm.click();\n                }\n            \"\"\")\n        else:\n            selection = self._widget.selectedHtml()\n            if not selection:\n                # Getting here may mean we crashed, but we can't do anything\n                # about that until this commit is released:\n                # https://github.com/annulen/webkit/commit/0e75f3272d149bc64899c161f150eb341a2417af\n                # TODO find a way to check if something is focused\n                self._follow_enter(tab)\n                return\n            try:\n                selected_element = xml.etree.ElementTree.fromstring(\n                    '<html>{}</html>'.format(selection)).find('a')\n            except xml.etree.ElementTree.ParseError:\n                raise browsertab.WebTabError('Could not parse selected '\n                                             'element!')\n\n            if selected_element is not None:\n                try:\n                    url = selected_element.attrib['href']\n                except KeyError:\n                    raise browsertab.WebTabError('Anchor element without '\n                                                 'href!')\n                url = self._tab.url().resolved(QUrl(url))\n                if tab:\n                    self._tab.new_tab_requested.emit(url)\n                else:\n                    self._tab.load_url(url)\n\n    def follow_selected(self, *, tab=False):\n        try:\n            self._follow_selected(tab=tab)\n        finally:\n            self.follow_selected_done.emit()\n\n\nclass WebKitZoom(browsertab.AbstractZoom):\n\n    \"\"\"QtWebKit implementations related to zooming.\"\"\"\n\n    def _set_factor_internal(self, factor):\n        self._widget.setZoomFactor(factor)\n\n\nclass WebKitScroller(browsertab.AbstractScroller):\n\n    \"\"\"QtWebKit implementations related to scrolling.\"\"\"\n\n    # FIXME:qtwebengine When to use the main frame, when the current one?\n\n    def pos_px(self):\n        return self._widget.page().mainFrame().scrollPosition()\n\n    def pos_perc(self):\n        return self._widget.scroll_pos\n\n    def to_point(self, point):\n        self._widget.page().mainFrame().setScrollPosition(point)\n\n    def to_anchor(self, name):\n        self._widget.page().mainFrame().scrollToAnchor(name)\n\n    def delta(self, x: int = 0, y: int = 0) -> None:\n        qtutils.check_overflow(x, 'int')\n        qtutils.check_overflow(y, 'int')\n        self._widget.page().mainFrame().scroll(x, y)\n\n    def delta_page(self, x: float = 0.0, y: float = 0.0) -> None:\n        if y.is_integer():\n            y = int(y)\n            if y == 0:\n                pass\n            elif y < 0:\n                self.page_up(count=-y)\n            elif y > 0:\n                self.page_down(count=y)\n            y = 0\n        if x == 0 and y == 0:\n            return\n        size = self._widget.page().mainFrame().geometry()\n        self.delta(int(x * size.width()), int(y * size.height()))\n\n    def to_perc(self, x=None, y=None):\n        if x is None and y == 0:\n            self.top()\n        elif x is None and y == 100:\n            self.bottom()\n        else:\n            for val, orientation in [(x, Qt.Horizontal), (y, Qt.Vertical)]:\n                if val is not None:\n                    frame = self._widget.page().mainFrame()\n                    maximum = frame.scrollBarMaximum(orientation)\n                    if maximum == 0:\n                        continue\n                    pos = int(maximum * val / 100)\n                    pos = qtutils.check_overflow(pos, 'int', fatal=False)\n                    frame.setScrollBarValue(orientation, pos)\n\n    def _key_press(self, key, count=1, getter_name=None, direction=None):\n        frame = self._widget.page().mainFrame()\n        getter = None if getter_name is None else getattr(frame, getter_name)\n\n        # FIXME:qtwebengine needed?\n        # self._widget.setFocus()\n\n        for _ in range(min(count, 5000)):\n            # Abort scrolling if the minimum/maximum was reached.\n            if (getter is not None and\n                    frame.scrollBarValue(direction) == getter(direction)):\n                return\n            self._tab.fake_key_press(key)\n\n    def up(self, count=1):\n        self._key_press(Qt.Key_Up, count, 'scrollBarMinimum', Qt.Vertical)\n\n    def down(self, count=1):\n        self._key_press(Qt.Key_Down, count, 'scrollBarMaximum', Qt.Vertical)\n\n    def left(self, count=1):\n        self._key_press(Qt.Key_Left, count, 'scrollBarMinimum', Qt.Horizontal)\n\n    def right(self, count=1):\n        self._key_press(Qt.Key_Right, count, 'scrollBarMaximum', Qt.Horizontal)\n\n    def top(self):\n        self._key_press(Qt.Key_Home)\n\n    def bottom(self):\n        self._key_press(Qt.Key_End)\n\n    def page_up(self, count=1):\n        self._key_press(Qt.Key_PageUp, count, 'scrollBarMinimum', Qt.Vertical)\n\n    def page_down(self, count=1):\n        self._key_press(Qt.Key_PageDown, count, 'scrollBarMaximum',\n                        Qt.Vertical)\n\n    def at_top(self):\n        return self.pos_px().y() == 0\n\n    def at_bottom(self):\n        frame = self._widget.page().currentFrame()\n        return self.pos_px().y() >= frame.scrollBarMaximum(Qt.Vertical)\n\n\nclass WebKitHistoryPrivate(browsertab.AbstractHistoryPrivate):\n\n    \"\"\"History-related methods which are not part of the extension API.\"\"\"\n\n    def serialize(self):\n        return qtutils.serialize(self._history)\n\n    def deserialize(self, data):\n        qtutils.deserialize(data, self._history)\n\n    def load_items(self, items):\n        if items:\n            self._tab.before_load_started.emit(items[-1].url)\n\n        stream, _data, user_data = tabhistory.serialize(items)\n        qtutils.deserialize_stream(stream, self._history)\n        for i, data in enumerate(user_data):\n            self._history.itemAt(i).setUserData(data)\n        cur_data = self._history.currentItem().userData()\n        if cur_data is not None:\n            if 'zoom' in cur_data:\n                self._tab.zoom.set_factor(cur_data['zoom'])\n            if ('scroll-pos' in cur_data and\n                    self._tab.scroller.pos_px() == QPoint(0, 0)):\n                QTimer.singleShot(0, functools.partial(\n                    self._tab.scroller.to_point, cur_data['scroll-pos']))\n\n\nclass WebKitHistory(browsertab.AbstractHistory):\n\n    \"\"\"QtWebKit implementations related to page history.\"\"\"\n\n    def __init__(self, tab):\n        super().__init__(tab)\n        self.private_api = WebKitHistoryPrivate(tab)\n\n    def __len__(self):\n        return len(self._history)\n\n    def __iter__(self):\n        return iter(self._history.items())\n\n    def current_idx(self):\n        return self._history.currentItemIndex()\n\n    def can_go_back(self):\n        return self._history.canGoBack()\n\n    def can_go_forward(self):\n        return self._history.canGoForward()\n\n    def _item_at(self, i):\n        return self._history.itemAt(i)\n\n    def _go_to_item(self, item):\n        self._tab.before_load_started.emit(item.url())\n        self._history.goToItem(item)\n\n\nclass WebKitElements(browsertab.AbstractElements):\n\n    \"\"\"QtWebKit implemementations related to elements on the page.\"\"\"\n\n    def find_css(self, selector, callback, error_cb, *, only_visible=False):\n        utils.unused(error_cb)\n        mainframe = self._widget.page().mainFrame()\n        if mainframe is None:\n            raise browsertab.WebTabError(\"No frame focused!\")\n\n        elems = []\n        frames = webkitelem.get_child_frames(mainframe)\n        for f in frames:\n            for elem in f.findAllElements(selector):\n                elems.append(webkitelem.WebKitElement(elem, tab=self._tab))\n\n        if only_visible:\n            # pylint: disable=protected-access\n            elems = [e for e in elems if e._is_visible(mainframe)]\n            # pylint: enable=protected-access\n\n        callback(elems)\n\n    def find_id(self, elem_id, callback):\n        def find_id_cb(elems):\n            \"\"\"Call the real callback with the found elements.\"\"\"\n            if not elems:\n                callback(None)\n            else:\n                callback(elems[0])\n\n        # Escape non-alphanumeric characters in the selector\n        # https://www.w3.org/TR/CSS2/syndata.html#value-def-identifier\n        elem_id = re.sub(r'[^a-zA-Z0-9_-]', r'\\\\\\g<0>', elem_id)\n        self.find_css('#' + elem_id, find_id_cb, error_cb=lambda exc: None)\n\n    def find_focused(self, callback):\n        frame = self._widget.page().currentFrame()\n        if frame is None:\n            callback(None)\n            return\n\n        elem = frame.findFirstElement('*:focus')\n        if elem.isNull():\n            callback(None)\n        else:\n            callback(webkitelem.WebKitElement(elem, tab=self._tab))\n\n    def find_at_pos(self, pos, callback):\n        assert pos.x() >= 0\n        assert pos.y() >= 0\n        frame = self._widget.page().frameAt(pos)\n        if frame is None:\n            # This happens when we click inside the webview, but not actually\n            # on the QWebPage - for example when clicking the scrollbar\n            # sometimes.\n            log.webview.debug(\"Hit test at {} but frame is None!\".format(pos))\n            callback(None)\n            return\n\n        # You'd think we have to subtract frame.geometry().topLeft() from the\n        # position, but it seems QWebFrame::hitTestContent wants a position\n        # relative to the QWebView, not to the frame. This makes no sense to\n        # me, but it works this way.\n        hitresult = frame.hitTestContent(pos)\n        if hitresult.isNull():\n            # For some reason, the whole hit result can be null sometimes (e.g.\n            # on doodle menu links).\n            log.webview.debug(\"Hit test result is null!\")\n            callback(None)\n            return\n\n        try:\n            elem = webkitelem.WebKitElement(hitresult.element(), tab=self._tab)\n        except webkitelem.IsNullError:\n            # For some reason, the hit result element can be a null element\n            # sometimes (e.g. when clicking the timetable fields on\n            # http://www.sbb.ch/ ).\n            log.webview.debug(\"Hit test result element is null!\")\n            callback(None)\n            return\n\n        callback(elem)\n\n\nclass WebKitAudio(browsertab.AbstractAudio):\n\n    \"\"\"Dummy handling of audio status for QtWebKit.\"\"\"\n\n    def set_muted(self, muted: bool, override: bool = False) -> None:\n        raise browsertab.WebTabError('Muting is not supported on QtWebKit!')\n\n    def is_muted(self):\n        return False\n\n    def is_recently_audible(self):\n        return False\n\n\nclass WebKitTabPrivate(browsertab.AbstractTabPrivate):\n\n    \"\"\"QtWebKit-related methods which aren't part of the public API.\"\"\"\n\n    def networkaccessmanager(self):\n        return self._widget.page().networkAccessManager()\n\n    def clear_ssl_errors(self):\n        self.networkaccessmanager().clear_all_ssl_errors()\n\n    def event_target(self):\n        return self._widget\n\n    def shutdown(self):\n        self._widget.shutdown()\n\n\nclass WebKitTab(browsertab.AbstractTab):\n\n    \"\"\"A QtWebKit tab in the browser.\"\"\"\n\n    def __init__(self, *, win_id, mode_manager, private, parent=None):\n        super().__init__(win_id=win_id, private=private, parent=parent)\n        widget = webview.WebView(win_id=win_id, tab_id=self.tab_id,\n                                 private=private, tab=self)\n        if private:\n            self._make_private(widget)\n        self.history = WebKitHistory(tab=self)\n        self.scroller = WebKitScroller(tab=self, parent=self)\n        self.caret = WebKitCaret(mode_manager=mode_manager,\n                                 tab=self, parent=self)\n        self.zoom = WebKitZoom(tab=self, parent=self)\n        self.search = WebKitSearch(tab=self, parent=self)\n        self.printing = WebKitPrinting(tab=self)\n        self.elements = WebKitElements(tab=self)\n        self.action = WebKitAction(tab=self)\n        self.audio = WebKitAudio(tab=self, parent=self)\n        self.private_api = WebKitTabPrivate(mode_manager=mode_manager,\n                                            tab=self)\n        # We're assigning settings in _set_widget\n        self.settings = webkitsettings.WebKitSettings(settings=None)\n        self._set_widget(widget)\n        self._connect_signals()\n        self.backend = usertypes.Backend.QtWebKit\n\n    def _install_event_filter(self):\n        self._widget.installEventFilter(self._tab_event_filter)\n\n    def _make_private(self, widget):\n        settings = widget.settings()\n        settings.setAttribute(QWebSettings.PrivateBrowsingEnabled, True)\n\n    def load_url(self, url, *, emit_before_load_started=True):\n        self._load_url_prepare(\n            url, emit_before_load_started=emit_before_load_started)\n        self._widget.load(url)\n\n    def url(self, *, requested=False):\n        frame = self._widget.page().mainFrame()\n        if requested:\n            return frame.requestedUrl()\n        else:\n            return frame.url()\n\n    def dump_async(self, callback, *, plain=False):\n        frame = self._widget.page().mainFrame()\n        if plain:\n            callback(frame.toPlainText())\n        else:\n            callback(frame.toHtml())\n\n    def run_js_async(self, code, callback=None, *, world=None):\n        if world is not None and world != usertypes.JsWorld.jseval:\n            log.webview.warning(\"Ignoring world ID {}\".format(world))\n        document_element = self._widget.page().mainFrame().documentElement()\n        result = document_element.evaluateJavaScript(code)\n        if callback is not None:\n            callback(result)\n\n    def icon(self):\n        return self._widget.icon()\n\n    def reload(self, *, force=False):\n        if force:\n            action = QWebPage.ReloadAndBypassCache\n        else:\n            action = QWebPage.Reload\n        self._widget.triggerPageAction(action)\n\n    def stop(self):\n        self._widget.stop()\n\n    def title(self):\n        return self._widget.title()\n\n    @pyqtSlot()\n    def _on_history_trigger(self):\n        url = self.url()\n        requested_url = self.url(requested=True)\n        self.history_item_triggered.emit(url, requested_url, self.title())\n\n    def set_html(self, html, base_url=QUrl()):\n        self._widget.setHtml(html, base_url)\n\n    @pyqtSlot()\n    def _on_load_started(self):\n        super()._on_load_started()\n        nam = self._widget.page().networkAccessManager()\n        nam.netrc_used = False\n        # Make sure the icon is cleared when navigating to a page without one.\n        self.icon_changed.emit(QIcon())\n\n    @pyqtSlot(bool)\n    def _on_load_finished(self, ok: bool) -> None:\n        super()._on_load_finished(ok)\n        self._update_load_status(ok)\n\n    @pyqtSlot()\n    def _on_frame_load_finished(self):\n        \"\"\"Make sure we emit an appropriate status when loading finished.\n\n        While Qt has a bool \"ok\" attribute for loadFinished, it always is True\n        when using error pages... See\n        https://github.com/qutebrowser/qutebrowser/issues/84\n        \"\"\"\n        self._on_load_finished(not self._widget.page().error_occurred)\n\n    @pyqtSlot()\n    def _on_webkit_icon_changed(self):\n        \"\"\"Emit iconChanged with a QIcon like QWebEngineView does.\"\"\"\n        if sip.isdeleted(self._widget):\n            log.webview.debug(\"Got _on_webkit_icon_changed for deleted view!\")\n            return\n        self.icon_changed.emit(self._widget.icon())\n\n    @pyqtSlot(QWebFrame)\n    def _on_frame_created(self, frame):\n        \"\"\"Connect the contentsSizeChanged signal of each frame.\"\"\"\n        # FIXME:qtwebengine those could theoretically regress:\n        # https://github.com/qutebrowser/qutebrowser/issues/152\n        # https://github.com/qutebrowser/qutebrowser/issues/263\n        frame.contentsSizeChanged.connect(self._on_contents_size_changed)\n\n    @pyqtSlot(QSize)\n    def _on_contents_size_changed(self, size):\n        self.contents_size_changed.emit(QSizeF(size))\n\n    @pyqtSlot(usertypes.NavigationRequest)\n    def _on_navigation_request(self, navigation):\n        super()._on_navigation_request(navigation)\n        if not navigation.accepted:\n            return\n\n        log.webview.debug(\"target {} override {}\".format(\n            self.data.open_target, self.data.override_target))\n\n        if self.data.override_target is not None:\n            target = self.data.override_target\n            self.data.override_target = None\n        else:\n            target = self.data.open_target\n\n        if (navigation.navigation_type == navigation.Type.link_clicked and\n                target != usertypes.ClickTarget.normal):\n            tab = shared.get_tab(self.win_id, target)\n            tab.load_url(navigation.url)\n            self.data.open_target = usertypes.ClickTarget.normal\n            navigation.accepted = False\n\n        if navigation.is_main_frame:\n            self.settings.update_for_url(navigation.url)\n\n    @pyqtSlot('QNetworkReply*')\n    def _on_ssl_errors(self, reply):\n        self._insecure_hosts.add(reply.url().host())\n\n    def _connect_signals(self):\n        view = self._widget\n        page = view.page()\n        frame = page.mainFrame()\n        page.windowCloseRequested.connect(self.window_close_requested)\n        page.linkHovered.connect(self.link_hovered)\n        page.loadProgress.connect(self._on_load_progress)\n        frame.loadStarted.connect(self._on_load_started)\n        view.scroll_pos_changed.connect(self.scroller.perc_changed)\n        view.titleChanged.connect(self.title_changed)\n        view.urlChanged.connect(self._on_url_changed)\n        view.shutting_down.connect(self.shutting_down)\n        page.networkAccessManager().sslErrors.connect(self._on_ssl_errors)\n        frame.loadFinished.connect(self._on_frame_load_finished)\n        view.iconChanged.connect(self._on_webkit_icon_changed)\n        page.frameCreated.connect(self._on_frame_created)\n        frame.contentsSizeChanged.connect(self._on_contents_size_changed)\n        frame.initialLayoutCompleted.connect(self._on_history_trigger)\n        page.navigation_request.connect(self._on_navigation_request)\n"], "filenames": ["qutebrowser/browser/browsertab.py", "qutebrowser/browser/webengine/webenginetab.py", "qutebrowser/browser/webkit/webkittab.py"], "buggy_code_start_loc": [871, 1552, 852], "buggy_code_end_loc": [1038, 1554, 855], "fixing_code_start_loc": [872, 1551, 852], "fixing_code_end_loc": [1046, 1555, 855], "type": "CWE-684", "message": "In qutebrowser versions less than 1.11.1, reloading a page with certificate errors shows a green URL. After a certificate error was overridden by the user, qutebrowser displays the URL as yellow (colors.statusbar.url.warn.fg). However, when the affected website was subsequently loaded again, the URL was mistakenly displayed as green (colors.statusbar.url.success_https). While the user already has seen a certificate error prompt at this point (or set content.ssl_strict to false, which is not recommended), this could still provide a false sense of security. This has been fixed in 1.11.1 and 1.12.0. All versions of qutebrowser are believed to be affected, though versions before v0.11.x couldn't be tested. Backported patches for older versions (greater than or equal to 1.4.0 and less than or equal to 1.10.2) are available, but no further releases are planned.", "other": {"cve": {"id": "CVE-2020-11054", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-07T21:15:11.590", "lastModified": "2023-01-27T15:00:28.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In qutebrowser versions less than 1.11.1, reloading a page with certificate errors shows a green URL. After a certificate error was overridden by the user, qutebrowser displays the URL as yellow (colors.statusbar.url.warn.fg). However, when the affected website was subsequently loaded again, the URL was mistakenly displayed as green (colors.statusbar.url.success_https). While the user already has seen a certificate error prompt at this point (or set content.ssl_strict to false, which is not recommended), this could still provide a false sense of security. This has been fixed in 1.11.1 and 1.12.0. All versions of qutebrowser are believed to be affected, though versions before v0.11.x couldn't be tested. Backported patches for older versions (greater than or equal to 1.4.0 and less than or equal to 1.10.2) are available, but no further releases are planned."}, {"lang": "es", "value": "En qutebrowser versiones anteriores a 1.11.1, el reinicio de una p\u00e1gina con errores de certificado muestra una URL verde. Luego que el usuario haya anulado un error de certificado, qutebrowser muestra la URL en amarillo (colors.statusbar.url.warn.fg). Sin embargo, cuando el sitio web afectado fue cargado posteriormente de nuevo, la URL se mostr\u00f3 err\u00f3neamente como verde (colors.statusbar.url.success_https). Aunque el usuario ya ha visto un mensaje de error de certificado en este momento (o establece content.ssl_strict en falso, lo cual no se recomienda), esto a\u00fan podr\u00eda proporcionar una falsa sensaci\u00f3n de seguridad. Esto se ha corregido en las versiones 1.11.1 y 1.12.0. Se cree que todas las versiones de qutebrowser est\u00e1n afectadas, aunque las versiones anteriores a v0.11.x no pudieron ser probadas. Los parches con backporting para versiones antiguas (posteriores o iguales a la versi\u00f3n 1.4.0 y versiones anteriores o iguales a 1.10.2) est\u00e1n disponibles, pero no se planean nuevas versiones."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-684"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qutebrowser:qutebrowser:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.11.1", "matchCriteriaId": "9ED914DB-F493-4DC0-96DF-ED7B32A0316E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}], "references": [{"url": "https://bugs.kde.org/show_bug.cgi?id=420902", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/021ab572a319ca3db5907a33a59774f502b3b975", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/19f01bb42d02da539446a52a25bb0c1232b86327", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/1b7946ed14b386a24db050f2d6dba81ba6518755", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/2281a205c3e70ec20f35ec8fafecee0d5c4f3478", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/4020210b193f77cf1785b21717f6ef7c5de5f0f8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/6821c236f9ae23adf21d46ce0d56768ac8d0c467", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/9bd1cf585fccdfe8318fff7af793730e74a04db3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/a45ca9c788f648d10cccce2af41405bf25ee2948", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/d28ed758d077a5bf19ddac4da468f7224114df23", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/commit/f5d801251aa5436aff44660c87d7013e29ac5864", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/issues/5403", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/qutebrowser/qutebrowser/security/advisories/GHSA-4rcq-jv2f-898j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7YWJ5QNHXKTGG5NLV7EGEOKPBVZBA5GS/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MKAZOOTJ2MBHTYVYQQ52NL53F5CB2XAP/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://tracker.die-offenbachs.homelinux.org/eric/issue328", "source": "security-advisories@github.com", "tags": ["Broken Link", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/qutebrowser/qutebrowser/commit/021ab572a319ca3db5907a33a59774f502b3b975"}}