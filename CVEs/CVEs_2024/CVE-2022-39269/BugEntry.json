{"buggy_code": ["/* $Id$ */\n/*\n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n */\n\n#include <pjmedia/transport_srtp.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/rtp.h>\n#include <pjlib-util/base64.h>\n#include <pj/array.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n#include <pj/lock.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n\n#if defined(PJMEDIA_HAS_SRTP) && (PJMEDIA_HAS_SRTP != 0)\n\n/* Enable this to test ROC initialization setting. For offerer,\n * it will send packets with ROC 1 and expect to receive ROC 2.\n * For answerer it will be the other way around.\n */\n#define TEST_ROC 0\n\n#if defined(PJ_HAS_SSL_SOCK) && PJ_HAS_SSL_SOCK != 0 && \\\n    (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_OPENSSL)\n#  include <openssl/rand.h>\n#  include <openssl/opensslv.h>\n\n/* Suppress compile warning of OpenSSL deprecation (OpenSSL is deprecated\n * since MacOSX 10.7).\n */\n#if defined(PJ_DARWINOS) && PJ_DARWINOS==1\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n\n#endif\n\n#if defined(PJMEDIA_EXTERNAL_SRTP)\n\n#if (PJMEDIA_EXTERNAL_SRTP == 1) \t/* External SRTP 1.x */\n#  include <srtp/srtp.h>\n#  include <srtp/crypto_kernel.h>\n#define srtp_crypto_policy_t \t\tcrypto_policy_t\n#define srtp_cipher_type_id_t \t\tcipher_type_id_t\n#define srtp_cipher_type_t\t\tcipher_type_t\n#define srtp_auth_type_id_t \t\tauth_type_id_t\n#define srtp_sec_serv_t\t\t\tsec_serv_t\n#define srtp_err_status_t\t\terr_status_t\n#define srtp_err_status_ok\t\terr_status_ok\n#define srtp_err_status_replay_old\terr_status_replay_old\n#define srtp_err_status_replay_fail\terr_status_replay_fail\n#define srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32 \\\n\t     crypto_policy_set_aes_cm_256_hmac_sha1_32\n#define srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80 \\\n\t     crypto_policy_set_aes_cm_256_hmac_sha1_80\n#define SRTP_NULL_CIPHER\t\tNULL_CIPHER\n#define SRTP_NULL_AUTH\t\t\tNULL_AUTH\n#define SRTP_AES_ICM_128\t\tAES_ICM\n#define SRTP_AES_ICM_192\t\tAES_ICM\n#define SRTP_AES_ICM_256\t\tAES_ICM\n#define SRTP_AES_GCM_128\t\tAES_128_GCM\n#define SRTP_AES_GCM_256\t\tAES_256_GCM\n#define SRTP_HMAC_SHA1\t\t\tHMAC_SHA1\n#define srtp_aes_gcm_256_openssl        aes_gcm_256_openssl\n#define srtp_aes_gcm_128_openssl        aes_gcm_128_openssl\n\n#else\t\t\t\t \t/* External SRTP 2.x */\n#  include <srtp2/srtp.h>\n#  include <srtp2/cipher.h>\n\n/* In libsrtp 2.0.0, the macro SRTP_AES_ICM_128 is not available. \n * Instead it was named with ICM at the end: SRTP_AES_128_ICM. \n */\n#  ifdef SRTP_AES_128_ICM\n#    define SRTP_AES_ICM_128\t\tSRTP_AES_128_ICM\n#    define SRTP_AES_ICM_192\t\tSRTP_AES_192_ICM\n#    define SRTP_AES_ICM_256\t\tSRTP_AES_256_ICM\n#    define SRTP_AES_GCM_128\t\tSRTP_AES_128_GCM\n#    define SRTP_AES_GCM_256\t\tSRTP_AES_256_GCM\n#  endif\n\n#endif\n\n#else\t\t\t\t\t/* Bundled SRTP */\n#  include <srtp.h>\n#  include <crypto_kernel.h>\n#endif\n\n#define THIS_FILE   \"transport_srtp.c\"\n\n/* Maximum size of outgoing packet */\n#define MAX_RTP_BUFFER_LEN\t    PJMEDIA_MAX_MTU\n#define MAX_RTCP_BUFFER_LEN\t    PJMEDIA_MAX_MTU\n\n/* Maximum SRTP crypto key length */\n#define MAX_KEY_LEN\t\t    128\n\n/* Initial value of probation counter. When probation counter > 0,\n * it means SRTP is in probation state, and it may restart when\n * srtp_unprotect() returns err_status_replay_*\n */\n#define PROBATION_CNT_INIT\t    100\n\n#define DEACTIVATE_MEDIA(pool, m)   pjmedia_sdp_media_deactivate(pool, m)\n\n#ifdef SRTP_MAX_TRAILER_LEN\n#   define MAX_TRAILER_LEN SRTP_MAX_TRAILER_LEN\n#else\n#   define MAX_TRAILER_LEN 10\n#endif\n\n/* Maximum number of SRTP keying method */\n#define MAX_KEYING\t\t    2\n\nstatic const pj_str_t ID_RTP_AVP  = { \"RTP/AVP\", 7 };\nstatic const pj_str_t ID_RTP_SAVP = { \"RTP/SAVP\", 8 };\n// static const pj_str_t ID_INACTIVE = { \"inactive\", 8 };\nstatic const pj_str_t ID_CRYPTO   = { \"crypto\", 6 };\n\ntypedef void (*crypto_method_t)(srtp_crypto_policy_t *policy);\n\ntypedef struct crypto_suite\n{\n    char\t\t*name;\n    srtp_cipher_type_id_t cipher_type;\n    unsigned\t\t cipher_key_len;    /* key + salt length    */\n    unsigned\t\t cipher_salt_len;   /* salt only length\t    */\n    srtp_auth_type_id_t\t auth_type;\n    unsigned\t\t auth_key_len;\n    unsigned\t\t srtp_auth_tag_len;\n    unsigned\t\t srtcp_auth_tag_len;\n    srtp_sec_serv_t\t service;\n    /* This is an attempt to validate crypto support by libsrtp, i.e: it should\n     * raise linking error if the libsrtp does not support the crypto. \n     */\n    srtp_cipher_type_t  *ext_cipher_type;\n    crypto_method_t      ext_crypto_method;\n} crypto_suite;\n\nextern srtp_cipher_type_t srtp_aes_gcm_256_openssl;\nextern srtp_cipher_type_t srtp_aes_gcm_128_openssl;\nextern srtp_cipher_type_t srtp_aes_icm_192;\n\n/* https://www.iana.org/assignments/sdp-security-descriptions/sdp-security-descriptions.xhtml */\nstatic crypto_suite crypto_suites[] = {\n    /* plain RTP/RTCP (no cipher & no auth) */\n    {\"NULL\", SRTP_NULL_CIPHER, 0, SRTP_NULL_AUTH, 0, 0, 0, sec_serv_none},\n\n#if defined(PJMEDIA_SRTP_HAS_AES_GCM_256)&&(PJMEDIA_SRTP_HAS_AES_GCM_256!=0)\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 16 octets */\n    {\"AEAD_AES_256_GCM\", SRTP_AES_GCM_256, 44, 12,\n\tSRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth,\n\t&srtp_aes_gcm_256_openssl},\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 8 octets */\n    {\"AEAD_AES_256_GCM_8\", SRTP_AES_GCM_256, 44, 12,\n\tSRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth,\n\t&srtp_aes_gcm_256_openssl},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_256)&&(PJMEDIA_SRTP_HAS_AES_CM_256!=0)\n\n    /* cipher AES_CM_256, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_256_CM_HMAC_SHA1_80\", SRTP_AES_ICM_256, 46, 14,\n\tSRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth,\n\tNULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80},\n\n    /* cipher AES_CM_256, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_256_CM_HMAC_SHA1_32\", SRTP_AES_ICM_256, 46, 14,\n\tSRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth,\n\tNULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_192)&&(PJMEDIA_SRTP_HAS_AES_CM_192!=0)\n\n    /* cipher AES_CM_192, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_192_CM_HMAC_SHA1_80\", SRTP_AES_ICM_192, 38, 14,\n\tSRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth,\n\t&srtp_aes_icm_192},\n\n    /* cipher AES_CM_192, auth SRTP_HMAC_SHA1, auth tag len = 4 octets */\n    {\"AES_192_CM_HMAC_SHA1_32\", SRTP_AES_ICM_192, 38, 14,\n\tSRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth,\n\t&srtp_aes_icm_192},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_GCM_128)&&(PJMEDIA_SRTP_HAS_AES_GCM_128!=0)\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 16 octets */\n    {\"AEAD_AES_128_GCM\", SRTP_AES_GCM_128, 28, 12,\n\tSRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth,\n\t&srtp_aes_gcm_128_openssl},\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 8 octets */\n    {\"AEAD_AES_128_GCM_8\", SRTP_AES_GCM_128, 28, 12,\n\tSRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth,\n\t&srtp_aes_gcm_128_openssl},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_128)&&(PJMEDIA_SRTP_HAS_AES_CM_128!=0)\n\n    /* cipher AES_CM_128, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_CM_128_HMAC_SHA1_80\", SRTP_AES_ICM_128, 30, 14,\n\tSRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth},\n\n    /* cipher AES_CM_128, auth SRTP_HMAC_SHA1, auth tag len = 4 octets */\n    {\"AES_CM_128_HMAC_SHA1_32\", SRTP_AES_ICM_128, 30, 14,\n\tSRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth},\n#endif\n\n    /*\n     * F8_128_HMAC_SHA1_8 not supported by libsrtp?\n     * {\"F8_128_HMAC_SHA1_8\", NULL_CIPHER, 0, 0, NULL_AUTH, 0, 0, 0,\n     *\tsec_serv_none}\n     */\n};\n\n\n/* SRTP transport */\ntypedef struct transport_srtp\n{\n    pjmedia_transport\t base;\t\t    /**< Base transport interface.  */\n    pj_pool_t\t\t*pool;\t\t    /**< Pool for transport SRTP.   */\n    pj_lock_t\t\t*mutex;\t\t    /**< Mutex for libsrtp contexts.*/\n    char\t\t rtp_tx_buffer[MAX_RTP_BUFFER_LEN];\n    char\t\t rtcp_tx_buffer[MAX_RTCP_BUFFER_LEN];\n    pjmedia_srtp_setting setting;\n    unsigned\t\t media_option;\n    pj_bool_t\t\t use_rtcp_mux;\t    /**< Use RTP& RTCP multiplexing?*/\n\n    /* SRTP policy */\n    pj_bool_t\t\t session_inited;\n    pj_bool_t\t\t offerer_side;\n    pj_bool_t\t\t bypass_srtp;\n    char\t\t tx_key[MAX_KEY_LEN];\n    char\t\t rx_key[MAX_KEY_LEN];\n    pjmedia_srtp_crypto  tx_policy;\n    pjmedia_srtp_crypto  rx_policy;\n\n    /* Temporary policy for negotiation */\n    pjmedia_srtp_crypto  tx_policy_neg;\n    pjmedia_srtp_crypto  rx_policy_neg;\n\n    /* libSRTP contexts */\n    srtp_t\t\t srtp_tx_ctx;\n    srtp_t\t\t srtp_rx_ctx;\n\n    /* Stream information */\n    void\t\t*user_data;\n    void\t\t(*rtp_cb)( void *user_data,\n\t\t\t\t   void *pkt,\n\t\t\t\t   pj_ssize_t size);\n    void  \t\t(*rtp_cb2)(pjmedia_tp_cb_param*);\n    void\t\t(*rtcp_cb)(void *user_data,\n\t\t\t\t   void *pkt,\n\t\t\t\t   pj_ssize_t size);\n\n    /* Transport information */\n    pjmedia_transport\t*member_tp; /**< Underlying transport.       */\n    pj_bool_t\t\t member_tp_attached;\n    pj_bool_t\t\t started;\n\n    /* SRTP usage policy of peer. This field is updated when media is starting.\n     * This is useful when SRTP is in optional mode and peer is using mandatory\n     * mode, so when local is about to reinvite/update, it should offer\n     * RTP/SAVP instead of offering RTP/AVP.\n     */\n    pjmedia_srtp_use\t peer_use;\n\n    /* When probation counter > 0, it means SRTP is in probation state,\n     * and it may restart when srtp_unprotect() returns err_status_replay_*\n     */\n    unsigned\t\t probation_cnt;\n\n    /* SRTP keying methods. The keying is implemented using media transport\n     * abstraction, so it will also be invoked when the SRTP media transport\n     * operation is invoked.\n     *\n     * As there can be multiple keying methods enabled (currently only SDES &\n     * DTLS-SRTP), each keying method will be given the chance to respond to\n     * remote SDP. If any keying operation returns non-success, it will be\n     * removed from the session. And once SRTP key is obtained via a keying\n     * method, any other keying methods will be stopped and destroyed.\n     */\n    unsigned\t\t all_keying_cnt;\n    pjmedia_transport\t*all_keying[MAX_KEYING];\n\n    /* Current active SRTP keying methods. */\n    unsigned\t\t keying_cnt;\n    pjmedia_transport\t*keying[MAX_KEYING];\n\n    /* If not zero, keying nego is ongoing (async-ly, e.g: by DTLS-SRTP).\n     * This field may be updated by keying method.\n     */\n    unsigned\t\t keying_pending_cnt;\n\n    /* RTP SSRC in receiving direction, used in getting and setting SRTP\n     * roll over counter (ROC) on SRTP restart.\n     */\n    pj_uint32_t\t\t rx_ssrc;\n\n    pj_uint32_t\t\t tx_ssrc;\n\n} transport_srtp;\n\n\n/*\n * This callback is called by transport when incoming rtp is received\n */\nstatic void srtp_rtp_cb(pjmedia_tp_cb_param *param);\n\n/*\n * This callback is called by transport when incoming rtcp is received\n */\nstatic void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size);\n\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n\t\t\t\t       pjmedia_transport_info *info);\n//static pj_status_t transport_attach   (pjmedia_transport *tp,\n//\t\t\t\t       void *user_data,\n//\t\t\t\t       const pj_sockaddr_t *rem_addr,\n//\t\t\t\t       const pj_sockaddr_t *rem_rtcp,\n//\t\t\t\t       unsigned addr_len,\n//\t\t\t\t       void (*rtp_cb)(void*,\n//\t\t\t\t\t\t      void*,\n//\t\t\t\t\t\t      pj_ssize_t),\n//\t\t\t\t       void (*rtcp_cb)(void*,\n//\t\t\t\t\t\t       void*,\n//\t\t\t\t\t\t       pj_ssize_t));\nstatic void\t   transport_detach   (pjmedia_transport *tp,\n\t\t\t\t       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n\t\t\t\t       const pj_sockaddr_t *addr,\n\t\t\t\t       unsigned addr_len,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n\t\t\t\t       pj_pool_t *sdp_pool,\n\t\t\t\t       unsigned options,\n\t\t\t\t       const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n\t\t\t\t       pj_pool_t *sdp_pool,\n\t\t\t\t       pjmedia_sdp_session *sdp_local,\n\t\t\t\t       const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t       unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n\t\t\t\t       pj_pool_t *pool,\n\t\t\t\t       const pjmedia_sdp_session *sdp_local,\n\t\t\t\t       const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n\t\t\t\t       pjmedia_dir dir,\n\t\t\t\t       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n\t\t\t\t       pjmedia_transport_attach_param *param);\n\n\n\nstatic pjmedia_transport_op transport_srtp_op =\n{\n    &transport_get_info,\n    NULL, //&transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\n/* Get crypto index from crypto name */\nstatic int get_crypto_idx(const pj_str_t* crypto_name);\n\n/* Is crypto empty (i.e: no name or key)? */\nstatic pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c);\n\n/* Compare crypto, return zero if same */\nstatic int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1,\n\t\t\t   const pjmedia_srtp_crypto* c2);\n\n/* Start SRTP */\nstatic pj_status_t start_srtp(transport_srtp *srtp);\n\n\n/* This function may also be used by other module, e.g: pjmedia/errno.c,\n * it should have C compatible declaration.\n */\nPJ_BEGIN_DECL\n    const char* get_libsrtp_errstr(int err);\nPJ_END_DECL\n\nconst char* get_libsrtp_errstr(int err)\n{\n#if defined(PJ_HAS_ERROR_STRING) && (PJ_HAS_ERROR_STRING != 0)\n    static char *liberr[] = {\n\t\"ok\",\t\t\t\t    /* srtp_err_status_ok       = 0  */\n\t\"unspecified failure\",\t\t    /* err_status_fail          = 1  */\n\t\"unsupported parameter\",\t    /* err_status_bad_param     = 2  */\n\t\"couldn't allocate memory\",\t    /* err_status_alloc_fail    = 3  */\n\t\"couldn't deallocate properly\",\t    /* err_status_dealloc_fail  = 4  */\n\t\"couldn't initialize\",\t\t    /* err_status_init_fail     = 5  */\n\t\"can't process as much data as requested\",\n\t\t\t\t\t    /* err_status_terminus      = 6  */\n\t\"authentication failure\",\t    /* err_status_auth_fail     = 7  */\n\t\"cipher failure\",\t\t    /* err_status_cipher_fail   = 8  */\n\t\"replay check failed (bad index)\",  /* err_status_replay_fail   = 9  */\n\t\"replay check failed (index too old)\",\n\t\t\t\t\t    /* err_status_replay_old    = 10 */\n\t\"algorithm failed test routine\",    /* err_status_algo_fail     = 11 */\n\t\"unsupported operation\",\t    /* err_status_no_such_op    = 12 */\n\t\"no appropriate context found\",\t    /* err_status_no_ctx        = 13 */\n\t\"unable to perform desired validation\",\n\t\t\t\t\t    /* err_status_cant_check    = 14 */\n\t\"can't use key any more\",\t    /* err_status_key_expired   = 15 */\n\t\"error in use of socket\",\t    /* err_status_socket_err    = 16 */\n\t\"error in use POSIX signals\",\t    /* err_status_signal_err    = 17 */\n\t\"nonce check failed\",\t\t    /* err_status_nonce_bad     = 18 */\n\t\"couldn't read data\",\t\t    /* err_status_read_fail     = 19 */\n\t\"couldn't write data\",\t\t    /* err_status_write_fail    = 20 */\n\t\"error pasring data\",\t\t    /* err_status_parse_err     = 21 */\n\t\"error encoding data\",\t\t    /* err_status_encode_err    = 22 */\n\t\"error while using semaphores\",\t    /* err_status_semaphore_err = 23 */\n\t\"error while using pfkey\"\t    /* err_status_pfkey_err     = 24 */\n    };\n    if (err >= 0 && err < (int)PJ_ARRAY_SIZE(liberr)) {\n\treturn liberr[err];\n    } else {\n\tstatic char msg[32];\n\tpj_ansi_snprintf(msg, sizeof(msg), \"Unknown libsrtp error %d\", err);\n\treturn msg;\n    }\n#else\n    static char msg[32];\n    pj_ansi_snprintf(msg, sizeof(msg), \"libsrtp error %d\", err);\n    return msg;\n#endif\n}\n\n/* SRTP keying method: Session Description */\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n#  include \"transport_srtp_sdes.c\"\n#endif\n\n/* SRTP keying method: DTLS */\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n#  include \"transport_srtp_dtls.c\"\n#else\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_start_nego(\n\t\t\t\tpjmedia_transport *srtp,\n\t\t\t\tconst pjmedia_srtp_dtls_nego_param *param)\n{\n    PJ_UNUSED_ARG(srtp);\n    PJ_UNUSED_ARG(param);\n    return PJ_ENOTSUP;\n}\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_get_fingerprint(\n\t\t\t\tpjmedia_transport *srtp,\n\t\t\t\tconst char *hash,\n\t\t\t\tchar *buf, pj_size_t *len)\n{\n    PJ_UNUSED_ARG(srtp);\n    PJ_UNUSED_ARG(hash);\n    PJ_UNUSED_ARG(buf);\n    PJ_UNUSED_ARG(len);\n    return PJ_ENOTSUP;\n}\n#endif\n\n\nstatic pj_bool_t libsrtp_initialized;\nstatic void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt);\n\nPJ_DEF(pj_status_t) pjmedia_srtp_init_lib(pjmedia_endpt *endpt)\n{\n    pj_status_t status = PJ_SUCCESS;\n\n    if (libsrtp_initialized)\n\treturn PJ_SUCCESS;\n\n#if PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n    /* Init libsrtp */\n    {\n\tsrtp_err_status_t err;\n\n\terr = srtp_init();\n\tif (err != srtp_err_status_ok) {\n\t    PJ_LOG(4, (THIS_FILE, \"Failed to initialize libsrtp: %s\",\n\t\t       get_libsrtp_errstr(err)));\n\t    return PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n\t}\n    }\n#endif\n\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    dtls_init();\n#endif\n\n    status = pjmedia_endpt_atexit(endpt, pjmedia_srtp_deinit_lib);\n    if (status != PJ_SUCCESS) {\n\t/* There will be memory leak when it fails to schedule libsrtp\n\t * deinitialization, however the memory leak could be harmless,\n\t * since in modern OS's memory used by an application is released\n\t * when the application terminates.\n\t */\n\tPJ_PERROR(4, (THIS_FILE, status,\n\t\t      \"Failed to register libsrtp deinit.\"));\n\n\t/* Ignore this error */\n\tstatus = PJ_SUCCESS;\n    }\n\n    libsrtp_initialized = PJ_TRUE;\n\n    return status;\n}\n\nstatic void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt)\n{\n    srtp_err_status_t err;\n\n    /* Note that currently this SRTP init/deinit is not equipped with\n     * reference counter, it should be safe as normally there is only\n     * one single instance of media endpoint and even if it isn't, the\n     * pjmedia_transport_srtp_create() will invoke SRTP init (the only\n     * drawback should be the delay described by #788).\n     */\n\n    PJ_UNUSED_ARG(endpt);\n\n#if !defined(PJMEDIA_SRTP_HAS_DEINIT) && !defined(PJMEDIA_SRTP_HAS_SHUTDOWN)\n# define PJMEDIA_SRTP_HAS_SHUTDOWN 1\n#endif\n\n#if PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n\n# if defined(PJMEDIA_SRTP_HAS_DEINIT) && PJMEDIA_SRTP_HAS_DEINIT!=0\n    err = srtp_deinit();\n# elif defined(PJMEDIA_SRTP_HAS_SHUTDOWN) && PJMEDIA_SRTP_HAS_SHUTDOWN!=0\n    err = srtp_shutdown();\n# else\n    err = srtp_err_status_ok;\n# endif\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(4, (THIS_FILE, \"Failed to deinitialize libsrtp: %s\",\n\t\t   get_libsrtp_errstr(err)));\n    }\n#endif // PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    dtls_deinit();\n#endif\n\n    libsrtp_initialized = PJ_FALSE;\n}\n\n\nstatic int get_crypto_idx(const pj_str_t* crypto_name)\n{\n    int i;\n    int cs_cnt = sizeof(crypto_suites)/sizeof(crypto_suites[0]);\n\n    /* treat unspecified crypto_name as crypto 'NULL' */\n    if (crypto_name->slen == 0)\n\treturn 0;\n\n    for (i=0; i<cs_cnt; ++i) {\n\tif (!pj_stricmp2(crypto_name, crypto_suites[i].name))\n\t    return i;\n    }\n\n    return -1;\n}\n\n\nstatic int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1,\n\t\t\t   const pjmedia_srtp_crypto* c2)\n{\n    int r;\n\n    r = pj_strcmp(&c1->key, &c2->key);\n    if (r != 0)\n\treturn r;\n\n    r = pj_stricmp(&c1->name, &c2->name);\n    if (r != 0)\n\treturn r;\n\n    return (c1->flags != c2->flags);\n}\n\n\nstatic pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c)\n{\n    return (c->name.slen==0 || c->key.slen==0);\n}\n\n\nPJ_DEF(void) pjmedia_srtp_setting_default(pjmedia_srtp_setting *opt)\n{\n    pj_assert(opt);\n\n    pj_bzero(opt, sizeof(pjmedia_srtp_setting));\n    opt->close_member_tp = PJ_TRUE;\n    opt->use = PJMEDIA_SRTP_OPTIONAL;\n}\n\n/*\n * Enumerate all SRTP cryptos, except \"NULL\".\n */\nPJ_DEF(pj_status_t) pjmedia_srtp_enum_crypto(unsigned *count,\n\t\t\t\t\t     pjmedia_srtp_crypto crypto[])\n{\n    unsigned i, max;\n\n    PJ_ASSERT_RETURN(count && crypto, PJ_EINVAL);\n\n    max = sizeof(crypto_suites) / sizeof(crypto_suites[0]) - 1;\n    if (*count > max)\n\t*count = max;\n\n    for (i=0; i<*count; ++i) {\n\tpj_bzero(&crypto[i], sizeof(crypto[0]));\n\tcrypto[i].name = pj_str(crypto_suites[i+1].name);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enumerate available SRTP keying methods.\n */\nPJ_DEF(pj_status_t) pjmedia_srtp_enum_keying(unsigned *count,\n\t\t\t\t      pjmedia_srtp_keying_method keying[])\n{\n    unsigned max;\n\n    PJ_ASSERT_RETURN(count && keying, PJ_EINVAL);\n\n    max = *count;\n    *count = 0;\n\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n    if (*count < max)\n\tkeying[(*count)++] = PJMEDIA_SRTP_KEYING_SDES;\n#endif\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    if (*count < max)\n\tkeying[(*count)++] = PJMEDIA_SRTP_KEYING_DTLS_SRTP;\n#endif\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create an SRTP media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_create(\n\t\t\t\t       pjmedia_endpt *endpt,\n\t\t\t\t       pjmedia_transport *tp,\n\t\t\t\t       const pjmedia_srtp_setting *opt,\n\t\t\t\t       pjmedia_transport **p_tp)\n{\n    pj_pool_t *pool;\n    transport_srtp *srtp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(endpt && tp && p_tp, PJ_EINVAL);\n\n    /* Check crypto */\n    if (opt && opt->use != PJMEDIA_SRTP_DISABLED) {\n\tfor (i=0; i < opt->crypto_count; ++i) {\n\t    int cs_idx = get_crypto_idx(&opt->crypto[i].name);\n\n\t    /* check crypto name */\n\t    if (cs_idx == -1)\n\t\treturn PJMEDIA_SRTP_ENOTSUPCRYPTO;\n\n\t    /* check key length */\n\t    if (opt->crypto[i].key.slen &&\n\t\topt->crypto[i].key.slen <\n\t\t(pj_ssize_t)crypto_suites[cs_idx].cipher_key_len)\n\t\treturn PJMEDIA_SRTP_EINKEYLEN;\n\t}\n    }\n\n    /* Init libsrtp. */\n    status = pjmedia_srtp_init_lib(endpt);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pool = pjmedia_endpt_create_pool(endpt, \"srtp%p\", 1000, 1000);\n    srtp = PJ_POOL_ZALLOC_T(pool, transport_srtp);\n\n    srtp->pool = pool;\n    srtp->session_inited = PJ_FALSE;\n    srtp->bypass_srtp = PJ_FALSE;\n    srtp->probation_cnt = PROBATION_CNT_INIT;\n\n    if (opt) {\n\tsrtp->setting = *opt;\n\tif (opt->use == PJMEDIA_SRTP_DISABLED)\n\t    srtp->setting.crypto_count = 0;\n\n\tfor (i=0; i < srtp->setting.crypto_count; ++i) {\n\t    int cs_idx = get_crypto_idx(&opt->crypto[i].name);\n\t    pj_str_t tmp_key = opt->crypto[i].key;\n\n\t    /* re-set crypto */\n\t    srtp->setting.crypto[i].name = pj_str(crypto_suites[cs_idx].name);\n\t    /* cut key length */\n\t    if (tmp_key.slen)\n\t\ttmp_key.slen = crypto_suites[cs_idx].cipher_key_len;\n\t    pj_strdup(pool, &srtp->setting.crypto[i].key, &tmp_key);\n\t}\n    } else {\n\tpjmedia_srtp_setting_default(&srtp->setting);\n    }\n\n    /* If crypto count is set to zero, setup default crypto-suites,\n     * i.e: all available crypto but 'NULL'.\n     */\n    if (srtp->setting.crypto_count == 0 && \n\tsrtp->setting.use != PJMEDIA_SRTP_DISABLED)\n    {\n\tsrtp->setting.crypto_count = PJMEDIA_SRTP_MAX_CRYPTOS;\n\tpjmedia_srtp_enum_crypto(&srtp->setting.crypto_count,\n\t\t\t\t srtp->setting.crypto);\n    }\n\n    status = pj_lock_create_recursive_mutex(pool, pool->obj_name,\n\t\t\t\t\t    &srtp->mutex);\n    if (status != PJ_SUCCESS) {\n\tpj_pool_release(pool);\n\treturn status;\n    }\n\n    /* Initialize base pjmedia_transport */\n    pj_memcpy(srtp->base.name, pool->obj_name, PJ_MAX_OBJ_NAME);\n    if (tp)\n\tsrtp->base.type = tp->type;\n    else\n\tsrtp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;\n    srtp->base.op = &transport_srtp_op;\n    srtp->base.user_data = srtp->setting.user_data;\n\n    /* Set underlying transport */\n    srtp->member_tp = tp;\n\n    /* Initialize peer's SRTP usage mode. */\n    srtp->peer_use = srtp->setting.use;\n\n    /* If keying count set to zero, setup default keying count & priorities */\n    if (srtp->setting.keying_count == 0) {\n\tsrtp->setting.keying_count = PJMEDIA_SRTP_KEYINGS_COUNT;\n\tpjmedia_srtp_enum_keying(&srtp->setting.keying_count,\n\t\t\t\t srtp->setting.keying);\n    }\n\n    /* Initialize SRTP keying method. */\n    for (i = 0; i < srtp->setting.keying_count && i < MAX_KEYING; ++i) {\n\tswitch(srtp->setting.keying[i]) {\n\n\tcase PJMEDIA_SRTP_KEYING_SDES:\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n\t    sdes_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);\n#endif\n\t    break;\n\n\tcase PJMEDIA_SRTP_KEYING_DTLS_SRTP:\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n\t    dtls_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);\n#endif\n\t    break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n    /* Done */\n    *p_tp = &srtp->base;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get SRTP media transport setting.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_get_setting(\n\t\t\t\t       pjmedia_transport *tp,\n\t\t\t\t       pjmedia_srtp_setting *opt)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    *opt = srtp->setting;\n    return PJ_SUCCESS;\n}\n\n/*\n * Modify SRTP media transport setting.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_modify_setting(\n\t\t\t\t       pjmedia_transport *tp,\n\t\t\t\t       const pjmedia_srtp_setting *opt)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    srtp->setting = *opt;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Initialize and start SRTP session with the given parameters.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_start(\n\t\t\t   pjmedia_transport *tp,\n\t\t\t   const pjmedia_srtp_crypto *tx,\n\t\t\t   const pjmedia_srtp_crypto *rx)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    srtp_policy_t    tx_;\n    srtp_policy_t    rx_;\n    srtp_err_status_t err;\n    int\t\t     cr_tx_idx = 0;\n    int\t\t     au_tx_idx = 0;\n    int\t\t     cr_rx_idx = 0;\n    int\t\t     au_rx_idx = 0;\n    pj_status_t\t     status = PJ_SUCCESS;\n\n    PJ_ASSERT_RETURN(tp && tx && rx, PJ_EINVAL);\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (srtp->session_inited) {\n\tpjmedia_transport_srtp_stop(tp);\n    }\n\n    /* Get encryption and authentication method */\n    cr_tx_idx = au_tx_idx = get_crypto_idx(&tx->name);\n    if (tx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)\n\tcr_tx_idx = 0;\n    if (tx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)\n\tau_tx_idx = 0;\n\n    cr_rx_idx = au_rx_idx = get_crypto_idx(&rx->name);\n    if (rx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)\n\tcr_rx_idx = 0;\n    if (rx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)\n\tau_rx_idx = 0;\n\n    /* Check whether the crypto-suite requested is supported */\n    if (cr_tx_idx == -1 || cr_rx_idx == -1 || au_tx_idx == -1 ||\n\tau_rx_idx == -1)\n    {\n\tstatus = PJMEDIA_SRTP_ENOTSUPCRYPTO;\n\tgoto on_return;\n    }\n\n    /* If all options points to 'NULL' method, just bypass SRTP */\n    if (cr_tx_idx == 0 && cr_rx_idx == 0 && au_tx_idx == 0 && au_rx_idx == 0) {\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tgoto on_return;\n    }\n\n    /* Check key length */\n    if (tx->key.slen != (pj_ssize_t)crypto_suites[cr_tx_idx].cipher_key_len ||\n        rx->key.slen != (pj_ssize_t)crypto_suites[cr_rx_idx].cipher_key_len)\n    {\n\tstatus = PJMEDIA_SRTP_EINKEYLEN;\n\tgoto on_return;\n    }\n\n    /* Init transmit direction */\n    pj_bzero(&tx_, sizeof(srtp_policy_t));\n    pj_memmove(srtp->tx_key, tx->key.ptr, tx->key.slen);\n    if (cr_tx_idx && au_tx_idx)\n\ttx_.rtp.sec_serv    = sec_serv_conf_and_auth;\n    else if (cr_tx_idx)\n\ttx_.rtp.sec_serv    = sec_serv_conf;\n    else if (au_tx_idx)\n\ttx_.rtp.sec_serv    = sec_serv_auth;\n    else\n\ttx_.rtp.sec_serv    = sec_serv_none;\n    tx_.key\t\t    = (uint8_t*)srtp->tx_key;\n    if (srtp->setting.tx_roc.roc != 0 &&\n        srtp->setting.tx_roc.ssrc != 0)\n    {\n\ttx_.ssrc.type\t    = ssrc_specific;\n\ttx_.ssrc.value\t    = srtp->setting.tx_roc.ssrc;\n    } else {\n\ttx_.ssrc.type\t    = ssrc_any_outbound;\n\ttx_.ssrc.value\t    = 0;\n    }\n    tx_.rtp.cipher_type\t    = crypto_suites[cr_tx_idx].cipher_type;\n    tx_.rtp.cipher_key_len  = crypto_suites[cr_tx_idx].cipher_key_len;\n    tx_.rtp.auth_type\t    = crypto_suites[au_tx_idx].auth_type;\n    tx_.rtp.auth_key_len    = crypto_suites[au_tx_idx].auth_key_len;\n    tx_.rtp.auth_tag_len    = crypto_suites[au_tx_idx].srtp_auth_tag_len;\n    tx_.rtcp\t\t    = tx_.rtp;\n    tx_.rtcp.auth_tag_len   = crypto_suites[au_tx_idx].srtcp_auth_tag_len;\n    tx_.next\t\t    = NULL;\n    err = srtp_create(&srtp->srtp_tx_ctx, &tx_);\n    if (err != srtp_err_status_ok) {\n\tstatus = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n\tgoto on_return;\n    }\n    if (srtp->setting.tx_roc.roc != 0 &&\n        srtp->setting.tx_roc.ssrc != 0)\n    {\n\terr = srtp_set_stream_roc(srtp->srtp_tx_ctx,\n\t\t\t\t  srtp->setting.tx_roc.ssrc,\n\t\t\t    \t  srtp->setting.tx_roc.roc);\n    \tPJ_LOG(4, (THIS_FILE, \"Initializing SRTP TX ROC to SSRC %d with \"\n    \t\t   \"ROC %d %s\\n\", srtp->setting.tx_roc.ssrc,\n    \t\t   srtp->setting.tx_roc.roc,\n    \t           (err == srtp_err_status_ok)? \"succeeded\": \"failed\"));\n    }\n    srtp->tx_policy = *tx;\n    pj_strset(&srtp->tx_policy.key,  srtp->tx_key, tx->key.slen);\n    srtp->tx_policy.name=pj_str(crypto_suites[get_crypto_idx(&tx->name)].name);\n\n\n    /* Init receive direction */\n    pj_bzero(&rx_, sizeof(srtp_policy_t));\n    pj_memmove(srtp->rx_key, rx->key.ptr, rx->key.slen);\n    if (cr_rx_idx && au_rx_idx)\n\trx_.rtp.sec_serv    = sec_serv_conf_and_auth;\n    else if (cr_rx_idx)\n\trx_.rtp.sec_serv    = sec_serv_conf;\n    else if (au_rx_idx)\n\trx_.rtp.sec_serv    = sec_serv_auth;\n    else\n\trx_.rtp.sec_serv    = sec_serv_none;\n    rx_.key\t\t    = (uint8_t*)srtp->rx_key;\n    if (srtp->setting.rx_roc.roc != 0 &&\n        srtp->setting.rx_roc.ssrc != 0)\n    {\n\trx_.ssrc.type\t    = ssrc_specific;\n\trx_.ssrc.value\t    = srtp->setting.rx_roc.ssrc;\n    } else {\n\trx_.ssrc.type\t    = ssrc_any_inbound;\n\trx_.ssrc.value\t    = 0;\n    }\n    rx_.rtp.sec_serv\t    = crypto_suites[cr_rx_idx].service;\n    rx_.rtp.cipher_type\t    = crypto_suites[cr_rx_idx].cipher_type;\n    rx_.rtp.cipher_key_len  = crypto_suites[cr_rx_idx].cipher_key_len;\n    rx_.rtp.auth_type\t    = crypto_suites[au_rx_idx].auth_type;\n    rx_.rtp.auth_key_len    = crypto_suites[au_rx_idx].auth_key_len;\n    rx_.rtp.auth_tag_len    = crypto_suites[au_rx_idx].srtp_auth_tag_len;\n    rx_.rtcp\t\t    = rx_.rtp;\n    rx_.rtcp.auth_tag_len   = crypto_suites[au_rx_idx].srtcp_auth_tag_len;\n    rx_.next\t\t    = NULL;\n    err = srtp_create(&srtp->srtp_rx_ctx, &rx_);\n    if (err != srtp_err_status_ok) {\n\tsrtp_dealloc(srtp->srtp_tx_ctx);\n\tstatus = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n\tgoto on_return;\n    }\n    if (srtp->setting.rx_roc.roc != 0 &&\n        srtp->setting.rx_roc.ssrc != 0)\n    {\n\terr = srtp_set_stream_roc(srtp->srtp_rx_ctx,\n\t\t\t\t  srtp->setting.rx_roc.ssrc,\n\t\t\t    \t  srtp->setting.rx_roc.roc);\n    \tPJ_LOG(4, (THIS_FILE, \"Initializing SRTP RX ROC from SSRC %d with \"\n    \t\t   \"ROC %d %s\\n\",\n    \t           srtp->setting.rx_roc.ssrc, srtp->setting.rx_roc.roc,\n    \t       \t   (err == srtp_err_status_ok)? \"succeeded\": \"failed\"));\n    }\n    srtp->rx_policy = *rx;\n    pj_strset(&srtp->rx_policy.key,  srtp->rx_key, rx->key.slen);\n    srtp->rx_policy.name=pj_str(crypto_suites[get_crypto_idx(&rx->name)].name);\n\n    /* Declare SRTP session initialized */\n    srtp->session_inited = PJ_TRUE;\n\n    /* Logging stuffs */\n#if PJ_LOG_MAX_LEVEL >= 5\n    {\n\tchar b64[PJ_BASE256_TO_BASE64_LEN(MAX_KEY_LEN)];\n\tint b64_len;\n\n\t/* TX crypto and key */\n\tb64_len = sizeof(b64);\n\tstatus = pj_base64_encode((pj_uint8_t*)tx->key.ptr, (int)tx->key.slen,\n\t\t\t\t  b64, &b64_len);\n\tif (status != PJ_SUCCESS)\n\t    b64_len = pj_ansi_sprintf(b64, \"--key too long--\");\n\telse\n\t    b64[b64_len] = '\\0';\n\n\tPJ_LOG(5, (srtp->pool->obj_name, \"TX: %s key=%s\",\n\t\t   srtp->tx_policy.name.ptr, b64));\n\tif (srtp->tx_policy.flags) {\n\t    PJ_LOG(5,(srtp->pool->obj_name, \"TX: disable%s%s\",\n\t\t      (cr_tx_idx?\"\":\" enc\"),\n\t\t      (au_tx_idx?\"\":\" auth\")));\n\t}\n\n\t/* RX crypto and key */\n\tb64_len = sizeof(b64);\n\tstatus = pj_base64_encode((pj_uint8_t*)rx->key.ptr, (int)rx->key.slen,\n\t\t\t\t  b64, &b64_len);\n\tif (status != PJ_SUCCESS)\n\t    b64_len = pj_ansi_sprintf(b64, \"--key too long--\");\n\telse\n\t    b64[b64_len] = '\\0';\n\n\tPJ_LOG(5, (srtp->pool->obj_name, \"RX: %s key=%s\",\n\t\t   srtp->rx_policy.name.ptr, b64));\n\tif (srtp->rx_policy.flags) {\n\t    PJ_LOG(5,(srtp->pool->obj_name,\"RX: disable%s%s\",\n\t\t      (cr_rx_idx?\"\":\" enc\"),\n\t\t      (au_rx_idx?\"\":\" auth\")));\n\t}\n    }\n#endif\n\non_return:\n    pj_lock_release(srtp->mutex);\n    return status;\n}\n\n/*\n * Stop SRTP session.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_stop(pjmedia_transport *srtp)\n{\n    transport_srtp *p_srtp = (transport_srtp*) srtp;\n    srtp_err_status_t err;\n\n    PJ_ASSERT_RETURN(srtp, PJ_EINVAL);\n\n    pj_lock_acquire(p_srtp->mutex);\n\n    if (!p_srtp->session_inited) {\n\tpj_lock_release(p_srtp->mutex);\n\treturn PJ_SUCCESS;\n    }\n\n    err = srtp_dealloc(p_srtp->srtp_rx_ctx);\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(4, (p_srtp->pool->obj_name,\n\t\t   \"Failed to dealloc RX SRTP context: %s\",\n\t\t   get_libsrtp_errstr(err)));\n    }\n    err = srtp_dealloc(p_srtp->srtp_tx_ctx);\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(4, (p_srtp->pool->obj_name,\n\t\t   \"Failed to dealloc TX SRTP context: %s\",\n\t\t   get_libsrtp_errstr(err)));\n    }\n    p_srtp->srtp_rx_ctx = NULL;\n    p_srtp->srtp_tx_ctx = NULL;\n\n    p_srtp->session_inited = PJ_FALSE;\n    pj_bzero(&p_srtp->rx_policy, sizeof(p_srtp->rx_policy));\n    pj_bzero(&p_srtp->tx_policy, sizeof(p_srtp->tx_policy));\n\n    pj_lock_release(p_srtp->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t start_srtp(transport_srtp *srtp)\n{\n    /* Make sure we have the SRTP policies */\n    if (srtp_crypto_empty(&srtp->tx_policy_neg) ||\n\tsrtp_crypto_empty(&srtp->rx_policy_neg))\n    {\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tsrtp->peer_use = PJMEDIA_SRTP_DISABLED;\n\tif (srtp->session_inited) {\n\t    pjmedia_transport_srtp_stop(&srtp->base);\n\t}\n\n\tPJ_LOG(4, (srtp->pool->obj_name, \"SRTP not active\"));\n\treturn PJ_SUCCESS;\n    }\n\n    /* Got policy_local & policy_remote, let's initalize the SRTP */\n\n    /* Ticket #1075: media_start() is called whenever media description\n     * gets updated, e.g: call hold, however we should restart SRTP only\n     * when the SRTP policy settings are updated.\n     */\n    if (srtp_crypto_cmp(&srtp->tx_policy_neg, &srtp->tx_policy) ||\n\tsrtp_crypto_cmp(&srtp->rx_policy_neg, &srtp->rx_policy))\n    {\n\tpj_status_t status;\n\tstatus = pjmedia_transport_srtp_start(&srtp->base,\n\t\t\t\t\t      &srtp->tx_policy_neg,\n\t\t\t\t\t      &srtp->rx_policy_neg);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\t/* Reset probation counts */\n\tsrtp->probation_cnt = PROBATION_CNT_INIT;\n\n\tPJ_LOG(4, (srtp->pool->obj_name,\n\t\t   \"SRTP started, keying=%s, crypto=%s\",\n\t\t   ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES?\n\t\t    \"SDES\":\"DTLS-SRTP\"),\n\t\t   srtp->tx_policy.name.ptr));\n    }\n\n    srtp->bypass_srtp = PJ_FALSE;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjmedia_transport *) pjmedia_transport_srtp_get_member(\n\t\t\t\t\t\tpjmedia_transport *tp)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n\n    PJ_ASSERT_RETURN(tp, NULL);\n\n    return srtp->member_tp;\n}\n\n\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n\t\t\t\t      pjmedia_transport_info *info)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n    pjmedia_srtp_info srtp_info;\n    int spc_info_idx;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp && info, PJ_EINVAL);\n    PJ_ASSERT_RETURN(info->specific_info_cnt <\n\t\t     PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXCNT, PJ_ETOOMANY);\n    PJ_ASSERT_RETURN(sizeof(pjmedia_srtp_info) <=\n\t\t     PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXSIZE, PJ_ENOMEM);\n\n    srtp_info.active = srtp->session_inited;\n    srtp_info.rx_policy = srtp->rx_policy;\n    srtp_info.tx_policy = srtp->tx_policy;\n    srtp_info.use = srtp->setting.use;\n    srtp_info.peer_use = srtp->peer_use;\n\n    pj_bzero(&srtp_info.tx_roc, sizeof(srtp_info.tx_roc));\n    pj_bzero(&srtp_info.rx_roc, sizeof(srtp_info.rx_roc));\n\n    if (srtp->srtp_rx_ctx && srtp->rx_ssrc != 0) {\n    \tsrtp_info.rx_roc.ssrc = srtp->rx_ssrc;\n    \tsrtp_get_stream_roc(srtp->srtp_rx_ctx, srtp->rx_ssrc,\n    \t\t\t    &srtp_info.rx_roc.roc);\n    } else if (srtp->setting.rx_roc.ssrc != 0) {\n    \tsrtp_info.rx_roc.ssrc = srtp->setting.rx_roc.ssrc;\n    \tsrtp_info.rx_roc.roc = srtp->setting.rx_roc.roc;\n    }\n    if (srtp->srtp_tx_ctx && srtp->tx_ssrc != 0) {\n    \tsrtp_info.tx_roc.ssrc = srtp->tx_ssrc;\n    \tsrtp_get_stream_roc(srtp->srtp_tx_ctx, srtp->tx_ssrc,\n    \t\t\t    &srtp_info.tx_roc.roc);\n    } else if (srtp->setting.tx_roc.ssrc != 0) {\n    \tsrtp_info.tx_roc.ssrc = srtp->setting.tx_roc.ssrc;\n    \tsrtp_info.tx_roc.roc = srtp->setting.tx_roc.roc;\n    }\n\n    spc_info_idx = info->specific_info_cnt++;\n    info->spc_info[spc_info_idx].type = PJMEDIA_TRANSPORT_TYPE_SRTP;\n    info->spc_info[spc_info_idx].tp = tp;\n    info->spc_info[spc_info_idx].cbsize = sizeof(srtp_info);\n    pj_memcpy(&info->spc_info[spc_info_idx].buffer, &srtp_info,\n\t      sizeof(srtp_info));\n\n    /* Invoke get_info() from any active keying method */\n    for (i=0; i < srtp->keying_cnt; i++)\n\tpjmedia_transport_get_info(srtp->keying[i], info);\n\n    return pjmedia_transport_get_info(srtp->member_tp, info);\n}\n\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n\t\t\t\t     pjmedia_transport_attach_param *param)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n    pjmedia_transport_attach_param member_param;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && param, PJ_EINVAL);\n\n    /* Save the callbacks */\n    pj_lock_acquire(srtp->mutex);\n    if (param->rtp_cb || param->rtp_cb2) {\n\t/* Do not update rtp_cb if not set, as attach() is called by\n\t * keying method.\n\t */\n\tsrtp->rtp_cb = param->rtp_cb;\n\tsrtp->rtp_cb2 = param->rtp_cb2;\n\tsrtp->rtcp_cb = param->rtcp_cb;\n\tsrtp->user_data = param->user_data;\n    }\n    pj_lock_release(srtp->mutex);\n\n    /* Attach self to member transport */\n    member_param = *param;\n    member_param.user_data = srtp;\n    member_param.rtp_cb = NULL;\n    member_param.rtp_cb2 = &srtp_rtp_cb;\n    member_param.rtcp_cb = &srtp_rtcp_cb;\n    status = pjmedia_transport_attach2(srtp->member_tp, &member_param);\n    if (status != PJ_SUCCESS) {\n\tpj_lock_acquire(srtp->mutex);\n\tsrtp->rtp_cb = NULL;\n\tsrtp->rtcp_cb = NULL;\n\tsrtp->user_data = NULL;\n\tpj_lock_release(srtp->mutex);\n\treturn status;\n    }\n\n    /* Check if we are multiplexing RTP & RTCP. */\n    srtp->use_rtcp_mux = (pj_sockaddr_has_addr(&param->rem_addr) &&\n    \t\t\t  pj_sockaddr_cmp(&param->rem_addr,\n    \t\t\t\t\t  &param->rem_rtcp) == 0);\n    srtp->member_tp_attached = PJ_TRUE;\n    return PJ_SUCCESS;\n}\n\nstatic void transport_detach(pjmedia_transport *tp, void *strm)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n\n    PJ_UNUSED_ARG(strm);\n    PJ_ASSERT_ON_FAIL(tp, return);\n\n    if (srtp->member_tp) {\n\tpjmedia_transport_detach(srtp->member_tp, srtp);\n    }\n\n    /* Clear up application infos from transport */\n    pj_lock_acquire(srtp->mutex);\n    srtp->rtp_cb = NULL;\n    srtp->rtp_cb2 = NULL;\n    srtp->rtcp_cb = NULL;\n    srtp->user_data = NULL;\n    pj_lock_release(srtp->mutex);\n    srtp->member_tp_attached = PJ_FALSE;\n}\n\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size)\n{\n    pj_status_t status;\n    transport_srtp *srtp = (transport_srtp*) tp;\n    int len = (int)size;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp)\n\treturn pjmedia_transport_send_rtp(srtp->member_tp, pkt, size);\n\n    if (size > sizeof(srtp->rtp_tx_buffer) - MAX_TRAILER_LEN)\n\treturn PJ_ETOOBIG;\n\n    pj_memcpy(srtp->rtp_tx_buffer, pkt, size);\n\n    pj_lock_acquire(srtp->mutex);\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn PJMEDIA_SRTP_EKEYNOTREADY;\n    }\n\n    /* Save outgoing SSRC */\n    srtp->tx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n\n#if TEST_ROC\n    if (srtp->setting.tx_roc.ssrc == 0) {\n\tsrtp_err_status_t status;\n    \tstatus = srtp_set_stream_roc(srtp->srtp_tx_ctx, srtp->tx_ssrc,\n    \t\t\t    \t     (srtp->offerer_side? 1: 2));\n    \tif (status == srtp_err_status_ok) {\n    \t    srtp->setting.tx_roc.ssrc = srtp->tx_ssrc;\n    \t    srtp->setting.tx_roc.roc = (srtp->offerer_side? 1: 2);\n\t    PJ_LOG(4, (THIS_FILE, \"Setting TX ROC to SSRC %d to %d\",\n\t\t   srtp->tx_ssrc, srtp->setting.tx_roc.roc));\n\t}\n    }\n#endif\n\n    err = srtp_protect(srtp->srtp_tx_ctx, srtp->rtp_tx_buffer, &len);\n    pj_lock_release(srtp->mutex);\n\n    if (err == srtp_err_status_ok) {\n\tstatus = pjmedia_transport_send_rtp(srtp->member_tp,\n\t\t\t\t\t    srtp->rtp_tx_buffer, len);\n    } else {\n\tstatus = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n    }\n\n    return status;\n}\n\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n\t\t\t\t        const pj_sockaddr_t *addr,\n\t\t\t\t        unsigned addr_len,\n\t\t\t\t        const void *pkt,\n\t\t\t\t        pj_size_t size)\n{\n    pj_status_t status;\n    transport_srtp *srtp = (transport_srtp*) tp;\n    int len = (int)size;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp) {\n\treturn pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len,\n\t                                    pkt, size);\n    }\n\n    if (size > sizeof(srtp->rtcp_tx_buffer) - (MAX_TRAILER_LEN+4))\n\treturn PJ_ETOOBIG;\n\n    pj_memcpy(srtp->rtcp_tx_buffer, pkt, size);\n\n    pj_lock_acquire(srtp->mutex);\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn PJMEDIA_SRTP_EKEYNOTREADY;\n    }\n    err = srtp_protect_rtcp(srtp->srtp_tx_ctx, srtp->rtcp_tx_buffer, &len);\n    pj_lock_release(srtp->mutex);\n\n    if (err == srtp_err_status_ok) {\n\tstatus = pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len,\n\t\t\t\t\t      srtp->rtcp_tx_buffer, len);\n    } else {\n\tstatus = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n    }\n\n    return status;\n}\n\n\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n\t\t\t\t\t   pjmedia_dir dir,\n\t\t\t\t\t   unsigned pct_lost)\n{\n    transport_srtp *srtp = (transport_srtp *) tp;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    return pjmedia_transport_simulate_lost(srtp->member_tp, dir, pct_lost);\n}\n\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    transport_srtp *srtp = (transport_srtp *) tp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* Close all keying. Note that any keying should not be destroyed before\n     * SRTP transport is destroyed as re-INVITE may initiate new keying method\n     * without destroying SRTP transport.\n     */\n    for (i=0; i < srtp->all_keying_cnt; i++)\n\tpjmedia_transport_close(srtp->all_keying[i]);\n\n    /* Close member if configured */\n    if (srtp->setting.close_member_tp && srtp->member_tp) {\n\tpjmedia_transport_close(srtp->member_tp);\n    }\n\n    status = pjmedia_transport_srtp_stop(tp);\n\n    /* In case mutex is being acquired by other thread */\n    pj_lock_acquire(srtp->mutex);\n    pj_lock_release(srtp->mutex);\n\n    pj_lock_destroy(srtp->mutex);\n    pj_pool_release(srtp->pool);\n\n    return status;\n}\n\n/*\n * This callback is called by transport when incoming rtp is received\n */\nstatic void srtp_rtp_cb(pjmedia_tp_cb_param *param)\n{\n    transport_srtp *srtp = (transport_srtp *) param->user_data;\n    void *pkt = param->pkt;\n    pj_ssize_t size = param->size;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void (*cb2)(pjmedia_tp_cb_param*) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n        if (srtp->rtp_cb2) {\n            pjmedia_tp_cb_param param2 = *param;\n            param2.user_data = srtp->user_data;\n            srtp->rtp_cb2(&param2);\n            param->rem_switch = param2.rem_switch;\n        } else if (srtp->rtp_cb) {\n\t    srtp->rtp_cb(srtp->user_data, pkt, size);\n\t}\n\treturn;\n    }\n\n    if (size < 0) {\n\treturn;\n    }\n\n    /* Give the packet to keying first by invoking its send_rtp() op.\n     * Yes, the usage of send_rtp() is rather hacky, but it is convenient\n     * as the signature suits the purpose and it is ready to use\n     * (no futher registration/setting needed), and it may never be used\n     * by any keying method in the future.\n     */\n    {\n\tunsigned i;\n\tpj_status_t status;\n\tfor (i=0; i < srtp->keying_cnt; i++) {\n\t    if (!srtp->keying[i]->op->send_rtp)\n\t\tcontinue;\n\t    status = pjmedia_transport_send_rtp(srtp->keying[i], pkt, size);\n\t    if (status != PJ_EIGNORED) {\n\t\t/* Packet is already consumed by the keying method */\n\t\treturn;\n\t    }\n\t}\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    if (srtp->probation_cnt > 0)\n\t--srtp->probation_cnt;\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn;\n    }\n\n    /* Check if multiplexing is allowed and the payload indicates RTCP. */\n    if (srtp->use_rtcp_mux) {\n    \tpjmedia_rtp_hdr *hdr = (pjmedia_rtp_hdr *)pkt;\n  \n\tif (hdr->pt >= 64 && hdr->pt <= 95) {   \n\t    pj_lock_release(srtp->mutex);\n\t    srtp_rtcp_cb(srtp, pkt, size);\n    \t    return;\n    \t}\n    }\n\n#if TEST_ROC\n    if (srtp->setting.rx_roc.ssrc == 0) {\n\tsrtp_err_status_t status;\n\t\n\tsrtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    \tstatus = srtp_set_stream_roc(srtp->srtp_rx_ctx, srtp->rx_ssrc, \n    \t\t\t    \t     (srtp->offerer_side? 2: 1));\n\tif (status == srtp_err_status_ok) {    \t\n    \t    srtp->setting.rx_roc.ssrc = srtp->rx_ssrc;\n\t    srtp->setting.rx_roc.roc = (srtp->offerer_side? 2: 1);\n\n\t    PJ_LOG(4, (THIS_FILE, \"Setting RX ROC from SSRC %d to %d\",\n\t\t   \t\t  srtp->rx_ssrc, srtp->setting.rx_roc.roc));\n\t} else {\n\t    PJ_LOG(4, (THIS_FILE, \"Setting RX ROC %s\",\n\t    \t       get_libsrtp_errstr(status)));\n\t}\n    }\n#endif\n    \n    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\n#if PJMEDIA_SRTP_CHECK_RTP_SEQ_ON_RESTART\n    if (srtp->probation_cnt > 0 &&\n\t(err == srtp_err_status_replay_old ||\n\t err == srtp_err_status_replay_fail))\n    {\n\t/* Handle such condition that stream is updated (RTP seq is reinited\n\t * & SRTP is restarted), but some old packets are still coming\n\t * so SRTP is learning wrong RTP seq. While the newly inited RTP seq\n\t * comes, SRTP thinks the RTP seq is replayed, so srtp_unprotect()\n\t * will return err_status_replay_*. Restarting SRTP can resolve this.\n\t */\n\tpjmedia_srtp_crypto tx, rx;\n\tpj_status_t status;\n\n\t/* Stop SRTP first, otherwise srtp_start() will maintain current\n\t * roll-over counter.\n\t */\n\tpjmedia_transport_srtp_stop((pjmedia_transport*)srtp);\n\n\ttx = srtp->tx_policy;\n\trx = srtp->rx_policy;\n\tstatus = pjmedia_transport_srtp_start((pjmedia_transport*)srtp,\n\t\t\t\t\t      &tx, &rx);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_LOG(5,(srtp->pool->obj_name, \"Failed to restart SRTP, err=%s\",\n\t\t      get_libsrtp_errstr(err)));\n\t} else if (!srtp->bypass_srtp) {\n\t    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\t}\n    }\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    else\n#endif\n#endif\n\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    if (srtp->probation_cnt > 0 && err == srtp_err_status_auth_fail &&\n\tsrtp->setting.prev_rx_roc.ssrc != 0 &&\n\tsrtp->setting.prev_rx_roc.ssrc == srtp->setting.rx_roc.ssrc &&\n\tsrtp->setting.prev_rx_roc.roc != srtp->setting.rx_roc.roc)\n    {\n        unsigned roc, new_roc;\n\tsrtp_err_status_t status;\n\n    \tsrtp_get_stream_roc(srtp->srtp_rx_ctx, srtp->setting.rx_roc.ssrc,\n    \t\t\t    &roc);\n    \tnew_roc = (roc == srtp->setting.rx_roc.roc?\n    \t\t   srtp->setting.prev_rx_roc.roc: srtp->setting.rx_roc.roc);\n    \tstatus = srtp_set_stream_roc(srtp->srtp_rx_ctx,\n    \t\t\t\t     srtp->setting.rx_roc.ssrc, new_roc);\n\tif (status == srtp_err_status_ok) {\n\t    PJ_LOG(4, (srtp->pool->obj_name,\n\t\t       \"Retrying to unprotect SRTP from ROC %d to new ROC %d\",\n\t\t       roc, new_roc));\n    \t    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n    \t}\n    }\n#endif\n\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(5,(srtp->pool->obj_name,\n\t\t  \"Failed to unprotect SRTP, pkt size=%d, err=%s\",\n\t\t  size, get_libsrtp_errstr(err)));\n    } else {\n\tcb = srtp->rtp_cb;\n\tcb2 = srtp->rtp_cb2;\n\tcb_data = srtp->user_data;\n\n\t/* Save SSRC after successful SRTP unprotect */\n\tsrtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb2) {\n        pjmedia_tp_cb_param param2 = *param;\n        param2.user_data = cb_data;\n        param2.pkt = pkt;\n        param2.size = len;\n        (*cb2)(&param2);\n        param->rem_switch = param2.rem_switch;\n    } else if (cb) {\n\t(*cb)(cb_data, pkt, len);\n    }\n}\n\n/*\n * This callback is called by transport when incoming rtcp is received\n */\nstatic void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size)\n{\n    transport_srtp *srtp = (transport_srtp *) user_data;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n\tsrtp->rtcp_cb(srtp->user_data, pkt, size);\n\treturn;\n    }\n\n    if (size < 0) {\n\treturn;\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn;\n    }\n    err = srtp_unprotect_rtcp(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(5,(srtp->pool->obj_name,\n\t\t  \"Failed to unprotect SRTCP, pkt size=%d, err=%s\",\n\t\t  size, get_libsrtp_errstr(err)));\n    } else {\n\tcb = srtp->rtcp_cb;\n\tcb_data = srtp->user_data;\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb) {\n\t(*cb)(cb_data, pkt, len);\n    }\n}\n\n\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n\t\t\t\t          pj_pool_t *sdp_pool,\n\t\t\t\t\t  unsigned options,\n\t\t\t\t          const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t\t  unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    unsigned member_tp_option;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    pj_bzero(&srtp->rx_policy_neg, sizeof(srtp->rx_policy_neg));\n    pj_bzero(&srtp->tx_policy_neg, sizeof(srtp->tx_policy_neg));\n\n    srtp->tx_ssrc = srtp->rx_ssrc = 0;\n    srtp->media_option = member_tp_option = options;\n    srtp->offerer_side = (sdp_remote == NULL);\n\n    if (srtp->offerer_side && srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n\t/* If we are offerer and SRTP is disabled, simply bypass SRTP and\n\t * skip keying.\n\t */\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tsrtp->keying_cnt = 0;\n    } else {\n\t/* If we are answerer and SRTP is disabled, we need to verify that\n\t * SRTP is disabled too in remote SDP, so we can't just skip keying.\n\t */\n\tsrtp->bypass_srtp = PJ_FALSE;\n\tsrtp->keying_cnt = srtp->all_keying_cnt;\n\tfor (i = 0; i < srtp->all_keying_cnt; ++i)\n\t    srtp->keying[i] = srtp->all_keying[i];\n\n\tmember_tp_option |= PJMEDIA_TPMED_NO_TRANSPORT_CHECKING;\n    }\n\n    status = pjmedia_transport_media_create(srtp->member_tp, sdp_pool,\n\t\t\t\t\t    member_tp_option, sdp_remote,\n\t\t\t\t\t    media_index);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Invoke media_create() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED:\n     *   - as offerer, nothing (keying is skipped).\n     *   - as answerer, verify remote SDP, make sure it has SRTP disabled too,\n     *     if not, return error.\n     * - OPTIONAL:\n     *   - as offerer, general initialization.\n     *   - as answerer, optionally verify SRTP attr in remote SDP (if any).\n     * - MANDATORY:\n     *   - as offerer, general initialization.\n     *   - as answerer, verify SRTP attr in remote SDP.\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n\tpj_status_t st;\n\tst = pjmedia_transport_media_create(srtp->keying[i], sdp_pool,\n\t\t\t\t\t    options, sdp_remote,\n\t\t\t\t\t    media_index);\n\tif (st != PJ_SUCCESS) {\n\t    /* This keying method returns error, remove it */\n\t    pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n\t\t\t   srtp->keying_cnt, i);\n\t    srtp->keying_cnt--;\n\t    keying_status = st;\n\t    continue;\n\t} else if (srtp->offerer_side) {\n\t    /* Currently we can send one keying only in outgoing offer */\n\t    srtp->keying[0] = srtp->keying[i];\n\t    srtp->keying_cnt = 1;\n\t    break;\n\t}\n\n\t++i;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0)\n\treturn keying_status;\n\n    /* Bypass SRTP & skip keying as SRTP is disabled and verification on\n     * remote SDP has been done.\n     */\n    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tsrtp->keying_cnt = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n\t\t\t\t\tpj_pool_t *sdp_pool,\n\t\t\t\t\tpjmedia_sdp_session *sdp_local,\n\t\t\t\t\tconst pjmedia_sdp_session *sdp_remote,\n\t\t\t\t\tunsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp && sdp_pool && sdp_local, PJ_EINVAL);\n\n    pj_bzero(&srtp->rx_policy_neg, sizeof(srtp->rx_policy_neg));\n    pj_bzero(&srtp->tx_policy_neg, sizeof(srtp->tx_policy_neg));\n\n    srtp->offerer_side = (sdp_remote == NULL);\n\n    if (!srtp->offerer_side && srtp->started) {\n\t/* This is may be incoming reoffer that may change keying */\n\tsrtp->keying_cnt = srtp->all_keying_cnt;\n\tfor (i = 0; i < srtp->all_keying_cnt; ++i)\n\t    srtp->keying[i] = srtp->all_keying[i];\n    }\n\n    status = pjmedia_transport_encode_sdp(srtp->member_tp, sdp_pool,\n\t\t\t\t\t  sdp_local, sdp_remote, media_index);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Invoke encode_sdp() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED: nothing (keying is skipped)\n     * - OPTIONAL:\n     *   - as offerer, generate offer.\n     *   - as answerer, if remote has the same SRTP keying in SDP, verify it,\n     *     generate answer, start crypto nego.\n     * - MANDATORY:\n     *   - as offerer, generate offer.\n     *   - as answerer, verify remote SDP, generate answer, start crypto nego.\n     *\n     * Note: because the SDP will be processed by other keying/components,\n     *       keying must do verification on remote SDP first (e.g: keying\n     *       is being used) before touching local SDP.\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n\tpj_status_t st;\n\tst = pjmedia_transport_encode_sdp(srtp->keying[i], sdp_pool,\n\t\t\t\t\t  sdp_local, sdp_remote,\n\t\t\t\t\t  media_index);\n\tif (st != PJ_SUCCESS) {\n\t    /* This keying method returns error, remove it */\n\t    pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n\t\t\t   srtp->keying_cnt, i);\n\t    srtp->keying_cnt--;\n\t    keying_status = st;\n\t    continue;\n\t} else if (!srtp->offerer_side) {\n\t    /* Answer with one keying only */\n\t    srtp->keying[0] = srtp->keying[i];\n\t    srtp->keying_cnt = 1;\n\t    break;\n\t}\n\n\ti++;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0) {\n\tif (keying_status != PJ_SUCCESS) {\n\t    DEACTIVATE_MEDIA(sdp_pool, sdp_local->media[media_index]);\n\t}\n\treturn keying_status;\n    }\n\n    /* Bypass SRTP & skip keying as SRTP is disabled and verification on\n     * remote SDP has been done.\n     */\n    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tsrtp->keying_cnt = 0;\n    }\n\n    if (srtp->keying_cnt != 0) {\n\t/* At this point for now, keying count should be 1 */\n\tpj_assert(srtp->keying_cnt == 1);\n\tPJ_LOG(4, (srtp->pool->obj_name, \"SRTP uses keying method %s\",\n\t\t   ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES?\n\t\t    \"SDES\":\"DTLS-SRTP\")));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n\t\t\t\t         pj_pool_t *pool,\n\t\t\t\t         const pjmedia_sdp_session *sdp_local,\n\t\t\t\t         const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t         unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* At this point for now, keying count should be 0 or 1 */\n    pj_assert(srtp->keying_cnt <= 1);\n\n    srtp->started = PJ_TRUE;\n\n    status = pjmedia_transport_media_start(srtp->member_tp, pool,\n\t\t\t\t\t   sdp_local, sdp_remote,\n\t\t\t\t           media_index);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Invoke media_start() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED: nothing (keying is skipped)\n     * - OPTIONAL:\n     *   - as offerer, if remote answer has the same SRTP keying in SDP,\n     *     verify it and start crypto nego.\n     *   - as answerer, start crypto nego if not yet (usually initated in\n     *     encode_sdp()).\n     * - MANDATORY:\n     *   - as offerer, verify remote answer and start crypto nego.\n     *   - as answerer, start crypto nego if not yet (usually initated in\n     *     encode_sdp()).\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n\tstatus = pjmedia_transport_media_start(srtp->keying[i], pool,\n\t\t\t\t\t       sdp_local, sdp_remote,\n\t\t\t\t\t       media_index);\n\tif (status != PJ_SUCCESS) {\n\t    /* This keying method returns error, remove it */\n\t    pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n\t\t\t   srtp->keying_cnt, i);\n\t    srtp->keying_cnt--;\n\t    keying_status = status;\n\t    continue;\n\t}\n\n\tif (!srtp_crypto_empty(&srtp->tx_policy_neg) &&\n\t    !srtp_crypto_empty(&srtp->rx_policy_neg))\n\t{\n\t    /* SRTP nego is done */\n\t    srtp->keying_cnt = 1;\n\t    srtp->keying[0] = srtp->keying[i];\n\t    srtp->keying_pending_cnt = 0;\n\t    break;\n\t}\n\n\ti++;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0)\n\treturn keying_status;\n\n    /* If SRTP key is being negotiated, just return now.\n     * The keying method should start the SRTP once keying nego is done.\n     */\n    if (srtp->keying_pending_cnt)\n\treturn PJ_SUCCESS;\n\n    /* Start SRTP */\n    status = start_srtp(srtp);\n\n    return status;\n}\n\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    srtp->started = PJ_FALSE;\n\n    /* Invoke media_stop() of all keying methods */\n    for (i=0; i < srtp->keying_cnt; ++i) {\n\tpjmedia_transport_media_stop(srtp->keying[i]);\n    }\n\n    /* Invoke media_stop() of member tp */\n    status = pjmedia_transport_media_stop(srtp->member_tp);\n    if (status != PJ_SUCCESS)\n\tPJ_PERROR(4, (srtp->pool->obj_name, status,\n\t\t      \"SRTP failed stop underlying media transport.\"));\n\n    /* Finally, stop SRTP */\n    return pjmedia_transport_srtp_stop(tp);\n}\n\n\n/* Utility */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_decrypt_pkt(pjmedia_transport *tp,\n\t\t\t\t\t\t       pj_bool_t is_rtp,\n\t\t\t\t\t\t       void *pkt,\n\t\t\t\t\t\t       int *pkt_len)\n{\n    transport_srtp *srtp = (transport_srtp *)tp;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp)\n\treturn PJ_SUCCESS;\n\n    PJ_ASSERT_RETURN(tp && pkt && (*pkt_len>0), PJ_EINVAL);\n    PJ_ASSERT_RETURN(srtp->session_inited, PJ_EINVALIDOP);\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return PJ_EINVAL);\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    if (is_rtp)\n\terr = srtp_unprotect(srtp->srtp_rx_ctx, pkt, pkt_len);\n    else\n\terr = srtp_unprotect_rtcp(srtp->srtp_rx_ctx, pkt, pkt_len);\n\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(5,(srtp->pool->obj_name,\n\t\t  \"Failed to unprotect SRTP, pkt size=%d, err=%s\",\n\t\t  *pkt_len, get_libsrtp_errstr(err)));\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    return (err==srtp_err_status_ok) ? PJ_SUCCESS :\n\t\t\t\t       PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n}\n\n#endif\n"], "fixing_code": ["/* $Id$ */\n/*\n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n */\n\n#include <pjmedia/transport_srtp.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/rtp.h>\n#include <pjlib-util/base64.h>\n#include <pj/array.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n#include <pj/lock.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n\n#if defined(PJMEDIA_HAS_SRTP) && (PJMEDIA_HAS_SRTP != 0)\n\n/* Enable this to test ROC initialization setting. For offerer,\n * it will send packets with ROC 1 and expect to receive ROC 2.\n * For answerer it will be the other way around.\n */\n#define TEST_ROC 0\n\n#if defined(PJ_HAS_SSL_SOCK) && PJ_HAS_SSL_SOCK != 0 && \\\n    (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_OPENSSL)\n#  include <openssl/rand.h>\n#  include <openssl/opensslv.h>\n\n/* Suppress compile warning of OpenSSL deprecation (OpenSSL is deprecated\n * since MacOSX 10.7).\n */\n#if defined(PJ_DARWINOS) && PJ_DARWINOS==1\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n\n#endif\n\n#if defined(PJMEDIA_EXTERNAL_SRTP)\n\n#if (PJMEDIA_EXTERNAL_SRTP == 1) \t/* External SRTP 1.x */\n#  include <srtp/srtp.h>\n#  include <srtp/crypto_kernel.h>\n#define srtp_crypto_policy_t \t\tcrypto_policy_t\n#define srtp_cipher_type_id_t \t\tcipher_type_id_t\n#define srtp_cipher_type_t\t\tcipher_type_t\n#define srtp_auth_type_id_t \t\tauth_type_id_t\n#define srtp_sec_serv_t\t\t\tsec_serv_t\n#define srtp_err_status_t\t\terr_status_t\n#define srtp_err_status_ok\t\terr_status_ok\n#define srtp_err_status_replay_old\terr_status_replay_old\n#define srtp_err_status_replay_fail\terr_status_replay_fail\n#define srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32 \\\n\t     crypto_policy_set_aes_cm_256_hmac_sha1_32\n#define srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80 \\\n\t     crypto_policy_set_aes_cm_256_hmac_sha1_80\n#define SRTP_NULL_CIPHER\t\tNULL_CIPHER\n#define SRTP_NULL_AUTH\t\t\tNULL_AUTH\n#define SRTP_AES_ICM_128\t\tAES_ICM\n#define SRTP_AES_ICM_192\t\tAES_ICM\n#define SRTP_AES_ICM_256\t\tAES_ICM\n#define SRTP_AES_GCM_128\t\tAES_128_GCM\n#define SRTP_AES_GCM_256\t\tAES_256_GCM\n#define SRTP_HMAC_SHA1\t\t\tHMAC_SHA1\n#define srtp_aes_gcm_256_openssl        aes_gcm_256_openssl\n#define srtp_aes_gcm_128_openssl        aes_gcm_128_openssl\n\n#else\t\t\t\t \t/* External SRTP 2.x */\n#  include <srtp2/srtp.h>\n#  include <srtp2/cipher.h>\n\n/* In libsrtp 2.0.0, the macro SRTP_AES_ICM_128 is not available. \n * Instead it was named with ICM at the end: SRTP_AES_128_ICM. \n */\n#  ifdef SRTP_AES_128_ICM\n#    define SRTP_AES_ICM_128\t\tSRTP_AES_128_ICM\n#    define SRTP_AES_ICM_192\t\tSRTP_AES_192_ICM\n#    define SRTP_AES_ICM_256\t\tSRTP_AES_256_ICM\n#    define SRTP_AES_GCM_128\t\tSRTP_AES_128_GCM\n#    define SRTP_AES_GCM_256\t\tSRTP_AES_256_GCM\n#  endif\n\n#endif\n\n#else\t\t\t\t\t/* Bundled SRTP */\n#  include <srtp.h>\n#  include <crypto_kernel.h>\n#endif\n\n#define THIS_FILE   \"transport_srtp.c\"\n\n/* Maximum size of outgoing packet */\n#define MAX_RTP_BUFFER_LEN\t    PJMEDIA_MAX_MTU\n#define MAX_RTCP_BUFFER_LEN\t    PJMEDIA_MAX_MTU\n\n/* Maximum SRTP crypto key length */\n#define MAX_KEY_LEN\t\t    128\n\n/* Initial value of probation counter. When probation counter > 0,\n * it means SRTP is in probation state, and it may restart when\n * srtp_unprotect() returns err_status_replay_*\n */\n#define PROBATION_CNT_INIT\t    100\n\n#define DEACTIVATE_MEDIA(pool, m)   pjmedia_sdp_media_deactivate(pool, m)\n\n#ifdef SRTP_MAX_TRAILER_LEN\n#   define MAX_TRAILER_LEN SRTP_MAX_TRAILER_LEN\n#else\n#   define MAX_TRAILER_LEN 10\n#endif\n\n/* Maximum number of SRTP keying method */\n#define MAX_KEYING\t\t    2\n\nstatic const pj_str_t ID_RTP_AVP  = { \"RTP/AVP\", 7 };\nstatic const pj_str_t ID_RTP_SAVP = { \"RTP/SAVP\", 8 };\n// static const pj_str_t ID_INACTIVE = { \"inactive\", 8 };\nstatic const pj_str_t ID_CRYPTO   = { \"crypto\", 6 };\n\ntypedef void (*crypto_method_t)(srtp_crypto_policy_t *policy);\n\ntypedef struct crypto_suite\n{\n    char\t\t*name;\n    srtp_cipher_type_id_t cipher_type;\n    unsigned\t\t cipher_key_len;    /* key + salt length    */\n    unsigned\t\t cipher_salt_len;   /* salt only length\t    */\n    srtp_auth_type_id_t\t auth_type;\n    unsigned\t\t auth_key_len;\n    unsigned\t\t srtp_auth_tag_len;\n    unsigned\t\t srtcp_auth_tag_len;\n    srtp_sec_serv_t\t service;\n    /* This is an attempt to validate crypto support by libsrtp, i.e: it should\n     * raise linking error if the libsrtp does not support the crypto. \n     */\n    srtp_cipher_type_t  *ext_cipher_type;\n    crypto_method_t      ext_crypto_method;\n} crypto_suite;\n\nextern srtp_cipher_type_t srtp_aes_gcm_256_openssl;\nextern srtp_cipher_type_t srtp_aes_gcm_128_openssl;\nextern srtp_cipher_type_t srtp_aes_icm_192;\n\n/* https://www.iana.org/assignments/sdp-security-descriptions/sdp-security-descriptions.xhtml */\nstatic crypto_suite crypto_suites[] = {\n    /* plain RTP/RTCP (no cipher & no auth) */\n    {\"NULL\", SRTP_NULL_CIPHER, 0, SRTP_NULL_AUTH, 0, 0, 0, sec_serv_none},\n\n#if defined(PJMEDIA_SRTP_HAS_AES_GCM_256)&&(PJMEDIA_SRTP_HAS_AES_GCM_256!=0)\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 16 octets */\n    {\"AEAD_AES_256_GCM\", SRTP_AES_GCM_256, 44, 12,\n\tSRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth,\n\t&srtp_aes_gcm_256_openssl},\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 8 octets */\n    {\"AEAD_AES_256_GCM_8\", SRTP_AES_GCM_256, 44, 12,\n\tSRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth,\n\t&srtp_aes_gcm_256_openssl},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_256)&&(PJMEDIA_SRTP_HAS_AES_CM_256!=0)\n\n    /* cipher AES_CM_256, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_256_CM_HMAC_SHA1_80\", SRTP_AES_ICM_256, 46, 14,\n\tSRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth,\n\tNULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80},\n\n    /* cipher AES_CM_256, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_256_CM_HMAC_SHA1_32\", SRTP_AES_ICM_256, 46, 14,\n\tSRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth,\n\tNULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_192)&&(PJMEDIA_SRTP_HAS_AES_CM_192!=0)\n\n    /* cipher AES_CM_192, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_192_CM_HMAC_SHA1_80\", SRTP_AES_ICM_192, 38, 14,\n\tSRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth,\n\t&srtp_aes_icm_192},\n\n    /* cipher AES_CM_192, auth SRTP_HMAC_SHA1, auth tag len = 4 octets */\n    {\"AES_192_CM_HMAC_SHA1_32\", SRTP_AES_ICM_192, 38, 14,\n\tSRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth,\n\t&srtp_aes_icm_192},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_GCM_128)&&(PJMEDIA_SRTP_HAS_AES_GCM_128!=0)\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 16 octets */\n    {\"AEAD_AES_128_GCM\", SRTP_AES_GCM_128, 28, 12,\n\tSRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth,\n\t&srtp_aes_gcm_128_openssl},\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 8 octets */\n    {\"AEAD_AES_128_GCM_8\", SRTP_AES_GCM_128, 28, 12,\n\tSRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth,\n\t&srtp_aes_gcm_128_openssl},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_128)&&(PJMEDIA_SRTP_HAS_AES_CM_128!=0)\n\n    /* cipher AES_CM_128, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_CM_128_HMAC_SHA1_80\", SRTP_AES_ICM_128, 30, 14,\n\tSRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth},\n\n    /* cipher AES_CM_128, auth SRTP_HMAC_SHA1, auth tag len = 4 octets */\n    {\"AES_CM_128_HMAC_SHA1_32\", SRTP_AES_ICM_128, 30, 14,\n\tSRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth},\n#endif\n\n    /*\n     * F8_128_HMAC_SHA1_8 not supported by libsrtp?\n     * {\"F8_128_HMAC_SHA1_8\", NULL_CIPHER, 0, 0, NULL_AUTH, 0, 0, 0,\n     *\tsec_serv_none}\n     */\n};\n\n\n/* SRTP transport */\ntypedef struct transport_srtp\n{\n    pjmedia_transport\t base;\t\t    /**< Base transport interface.  */\n    pj_pool_t\t\t*pool;\t\t    /**< Pool for transport SRTP.   */\n    pj_lock_t\t\t*mutex;\t\t    /**< Mutex for libsrtp contexts.*/\n    char\t\t rtp_tx_buffer[MAX_RTP_BUFFER_LEN];\n    char\t\t rtcp_tx_buffer[MAX_RTCP_BUFFER_LEN];\n    pjmedia_srtp_setting setting;\n    unsigned\t\t media_option;\n    pj_bool_t\t\t use_rtcp_mux;\t    /**< Use RTP& RTCP multiplexing?*/\n\n    /* SRTP policy */\n    pj_bool_t\t\t session_inited;\n    pj_bool_t\t\t offerer_side;\n    pj_bool_t\t\t bypass_srtp;\n    char\t\t tx_key[MAX_KEY_LEN];\n    char\t\t rx_key[MAX_KEY_LEN];\n    pjmedia_srtp_crypto  tx_policy;\n    pjmedia_srtp_crypto  rx_policy;\n\n    /* Temporary policy for negotiation */\n    pjmedia_srtp_crypto  tx_policy_neg;\n    pjmedia_srtp_crypto  rx_policy_neg;\n\n    /* libSRTP contexts */\n    srtp_t\t\t srtp_tx_ctx;\n    srtp_t\t\t srtp_rx_ctx;\n\n    /* Stream information */\n    void\t\t*user_data;\n    void\t\t(*rtp_cb)( void *user_data,\n\t\t\t\t   void *pkt,\n\t\t\t\t   pj_ssize_t size);\n    void  \t\t(*rtp_cb2)(pjmedia_tp_cb_param*);\n    void\t\t(*rtcp_cb)(void *user_data,\n\t\t\t\t   void *pkt,\n\t\t\t\t   pj_ssize_t size);\n\n    /* Transport information */\n    pjmedia_transport\t*member_tp; /**< Underlying transport.       */\n    pj_bool_t\t\t member_tp_attached;\n    pj_bool_t\t\t started;\n\n    /* SRTP usage policy of peer. This field is updated when media is starting.\n     * This is useful when SRTP is in optional mode and peer is using mandatory\n     * mode, so when local is about to reinvite/update, it should offer\n     * RTP/SAVP instead of offering RTP/AVP.\n     */\n    pjmedia_srtp_use\t peer_use;\n\n    /* When probation counter > 0, it means SRTP is in probation state,\n     * and it may restart when srtp_unprotect() returns err_status_replay_*\n     */\n    unsigned\t\t probation_cnt;\n\n    /* SRTP keying methods. The keying is implemented using media transport\n     * abstraction, so it will also be invoked when the SRTP media transport\n     * operation is invoked.\n     *\n     * As there can be multiple keying methods enabled (currently only SDES &\n     * DTLS-SRTP), each keying method will be given the chance to respond to\n     * remote SDP. If any keying operation returns non-success, it will be\n     * removed from the session. And once SRTP key is obtained via a keying\n     * method, any other keying methods will be stopped and destroyed.\n     */\n    unsigned\t\t all_keying_cnt;\n    pjmedia_transport\t*all_keying[MAX_KEYING];\n\n    /* Current active SRTP keying methods. */\n    unsigned\t\t keying_cnt;\n    pjmedia_transport\t*keying[MAX_KEYING];\n\n    /* If not zero, keying nego is ongoing (async-ly, e.g: by DTLS-SRTP).\n     * This field may be updated by keying method.\n     */\n    unsigned\t\t keying_pending_cnt;\n\n    /* RTP SSRC in receiving direction, used in getting and setting SRTP\n     * roll over counter (ROC) on SRTP restart.\n     */\n    pj_uint32_t\t\t rx_ssrc;\n\n    pj_uint32_t\t\t tx_ssrc;\n\n} transport_srtp;\n\n\n/*\n * This callback is called by transport when incoming rtp is received\n */\nstatic void srtp_rtp_cb(pjmedia_tp_cb_param *param);\n\n/*\n * This callback is called by transport when incoming rtcp is received\n */\nstatic void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size);\n\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n\t\t\t\t       pjmedia_transport_info *info);\n//static pj_status_t transport_attach   (pjmedia_transport *tp,\n//\t\t\t\t       void *user_data,\n//\t\t\t\t       const pj_sockaddr_t *rem_addr,\n//\t\t\t\t       const pj_sockaddr_t *rem_rtcp,\n//\t\t\t\t       unsigned addr_len,\n//\t\t\t\t       void (*rtp_cb)(void*,\n//\t\t\t\t\t\t      void*,\n//\t\t\t\t\t\t      pj_ssize_t),\n//\t\t\t\t       void (*rtcp_cb)(void*,\n//\t\t\t\t\t\t       void*,\n//\t\t\t\t\t\t       pj_ssize_t));\nstatic void\t   transport_detach   (pjmedia_transport *tp,\n\t\t\t\t       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n\t\t\t\t       const pj_sockaddr_t *addr,\n\t\t\t\t       unsigned addr_len,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n\t\t\t\t       pj_pool_t *sdp_pool,\n\t\t\t\t       unsigned options,\n\t\t\t\t       const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n\t\t\t\t       pj_pool_t *sdp_pool,\n\t\t\t\t       pjmedia_sdp_session *sdp_local,\n\t\t\t\t       const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t       unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n\t\t\t\t       pj_pool_t *pool,\n\t\t\t\t       const pjmedia_sdp_session *sdp_local,\n\t\t\t\t       const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n\t\t\t\t       pjmedia_dir dir,\n\t\t\t\t       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n\t\t\t\t       pjmedia_transport_attach_param *param);\n\n\n\nstatic pjmedia_transport_op transport_srtp_op =\n{\n    &transport_get_info,\n    NULL, //&transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\n/* Get crypto index from crypto name */\nstatic int get_crypto_idx(const pj_str_t* crypto_name);\n\n/* Is crypto empty (i.e: no name or key)? */\nstatic pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c);\n\n/* Compare crypto, return zero if same */\nstatic int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1,\n\t\t\t   const pjmedia_srtp_crypto* c2);\n\n/* Start SRTP */\nstatic pj_status_t start_srtp(transport_srtp *srtp);\n\n\n/* This function may also be used by other module, e.g: pjmedia/errno.c,\n * it should have C compatible declaration.\n */\nPJ_BEGIN_DECL\n    const char* get_libsrtp_errstr(int err);\nPJ_END_DECL\n\nconst char* get_libsrtp_errstr(int err)\n{\n#if defined(PJ_HAS_ERROR_STRING) && (PJ_HAS_ERROR_STRING != 0)\n    static char *liberr[] = {\n\t\"ok\",\t\t\t\t    /* srtp_err_status_ok       = 0  */\n\t\"unspecified failure\",\t\t    /* err_status_fail          = 1  */\n\t\"unsupported parameter\",\t    /* err_status_bad_param     = 2  */\n\t\"couldn't allocate memory\",\t    /* err_status_alloc_fail    = 3  */\n\t\"couldn't deallocate properly\",\t    /* err_status_dealloc_fail  = 4  */\n\t\"couldn't initialize\",\t\t    /* err_status_init_fail     = 5  */\n\t\"can't process as much data as requested\",\n\t\t\t\t\t    /* err_status_terminus      = 6  */\n\t\"authentication failure\",\t    /* err_status_auth_fail     = 7  */\n\t\"cipher failure\",\t\t    /* err_status_cipher_fail   = 8  */\n\t\"replay check failed (bad index)\",  /* err_status_replay_fail   = 9  */\n\t\"replay check failed (index too old)\",\n\t\t\t\t\t    /* err_status_replay_old    = 10 */\n\t\"algorithm failed test routine\",    /* err_status_algo_fail     = 11 */\n\t\"unsupported operation\",\t    /* err_status_no_such_op    = 12 */\n\t\"no appropriate context found\",\t    /* err_status_no_ctx        = 13 */\n\t\"unable to perform desired validation\",\n\t\t\t\t\t    /* err_status_cant_check    = 14 */\n\t\"can't use key any more\",\t    /* err_status_key_expired   = 15 */\n\t\"error in use of socket\",\t    /* err_status_socket_err    = 16 */\n\t\"error in use POSIX signals\",\t    /* err_status_signal_err    = 17 */\n\t\"nonce check failed\",\t\t    /* err_status_nonce_bad     = 18 */\n\t\"couldn't read data\",\t\t    /* err_status_read_fail     = 19 */\n\t\"couldn't write data\",\t\t    /* err_status_write_fail    = 20 */\n\t\"error pasring data\",\t\t    /* err_status_parse_err     = 21 */\n\t\"error encoding data\",\t\t    /* err_status_encode_err    = 22 */\n\t\"error while using semaphores\",\t    /* err_status_semaphore_err = 23 */\n\t\"error while using pfkey\"\t    /* err_status_pfkey_err     = 24 */\n    };\n    if (err >= 0 && err < (int)PJ_ARRAY_SIZE(liberr)) {\n\treturn liberr[err];\n    } else {\n\tstatic char msg[32];\n\tpj_ansi_snprintf(msg, sizeof(msg), \"Unknown libsrtp error %d\", err);\n\treturn msg;\n    }\n#else\n    static char msg[32];\n    pj_ansi_snprintf(msg, sizeof(msg), \"libsrtp error %d\", err);\n    return msg;\n#endif\n}\n\n/* SRTP keying method: Session Description */\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n#  include \"transport_srtp_sdes.c\"\n#endif\n\n/* SRTP keying method: DTLS */\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n#  include \"transport_srtp_dtls.c\"\n#else\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_start_nego(\n\t\t\t\tpjmedia_transport *srtp,\n\t\t\t\tconst pjmedia_srtp_dtls_nego_param *param)\n{\n    PJ_UNUSED_ARG(srtp);\n    PJ_UNUSED_ARG(param);\n    return PJ_ENOTSUP;\n}\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_get_fingerprint(\n\t\t\t\tpjmedia_transport *srtp,\n\t\t\t\tconst char *hash,\n\t\t\t\tchar *buf, pj_size_t *len)\n{\n    PJ_UNUSED_ARG(srtp);\n    PJ_UNUSED_ARG(hash);\n    PJ_UNUSED_ARG(buf);\n    PJ_UNUSED_ARG(len);\n    return PJ_ENOTSUP;\n}\n#endif\n\n\nstatic pj_bool_t libsrtp_initialized;\nstatic void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt);\n\nPJ_DEF(pj_status_t) pjmedia_srtp_init_lib(pjmedia_endpt *endpt)\n{\n    pj_status_t status = PJ_SUCCESS;\n\n    if (libsrtp_initialized)\n\treturn PJ_SUCCESS;\n\n#if PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n    /* Init libsrtp */\n    {\n\tsrtp_err_status_t err;\n\n\terr = srtp_init();\n\tif (err != srtp_err_status_ok) {\n\t    PJ_LOG(4, (THIS_FILE, \"Failed to initialize libsrtp: %s\",\n\t\t       get_libsrtp_errstr(err)));\n\t    return PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n\t}\n    }\n#endif\n\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    dtls_init();\n#endif\n\n    status = pjmedia_endpt_atexit(endpt, pjmedia_srtp_deinit_lib);\n    if (status != PJ_SUCCESS) {\n\t/* There will be memory leak when it fails to schedule libsrtp\n\t * deinitialization, however the memory leak could be harmless,\n\t * since in modern OS's memory used by an application is released\n\t * when the application terminates.\n\t */\n\tPJ_PERROR(4, (THIS_FILE, status,\n\t\t      \"Failed to register libsrtp deinit.\"));\n\n\t/* Ignore this error */\n\tstatus = PJ_SUCCESS;\n    }\n\n    libsrtp_initialized = PJ_TRUE;\n\n    return status;\n}\n\nstatic void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt)\n{\n    srtp_err_status_t err;\n\n    /* Note that currently this SRTP init/deinit is not equipped with\n     * reference counter, it should be safe as normally there is only\n     * one single instance of media endpoint and even if it isn't, the\n     * pjmedia_transport_srtp_create() will invoke SRTP init (the only\n     * drawback should be the delay described by #788).\n     */\n\n    PJ_UNUSED_ARG(endpt);\n\n#if !defined(PJMEDIA_SRTP_HAS_DEINIT) && !defined(PJMEDIA_SRTP_HAS_SHUTDOWN)\n# define PJMEDIA_SRTP_HAS_SHUTDOWN 1\n#endif\n\n#if PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n\n# if defined(PJMEDIA_SRTP_HAS_DEINIT) && PJMEDIA_SRTP_HAS_DEINIT!=0\n    err = srtp_deinit();\n# elif defined(PJMEDIA_SRTP_HAS_SHUTDOWN) && PJMEDIA_SRTP_HAS_SHUTDOWN!=0\n    err = srtp_shutdown();\n# else\n    err = srtp_err_status_ok;\n# endif\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(4, (THIS_FILE, \"Failed to deinitialize libsrtp: %s\",\n\t\t   get_libsrtp_errstr(err)));\n    }\n#endif // PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    dtls_deinit();\n#endif\n\n    libsrtp_initialized = PJ_FALSE;\n}\n\n\nstatic int get_crypto_idx(const pj_str_t* crypto_name)\n{\n    int i;\n    int cs_cnt = sizeof(crypto_suites)/sizeof(crypto_suites[0]);\n\n    /* treat unspecified crypto_name as crypto 'NULL' */\n    if (crypto_name->slen == 0)\n\treturn 0;\n\n    for (i=0; i<cs_cnt; ++i) {\n\tif (!pj_stricmp2(crypto_name, crypto_suites[i].name))\n\t    return i;\n    }\n\n    return -1;\n}\n\n\nstatic int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1,\n\t\t\t   const pjmedia_srtp_crypto* c2)\n{\n    int r;\n\n    r = pj_strcmp(&c1->key, &c2->key);\n    if (r != 0)\n\treturn r;\n\n    r = pj_stricmp(&c1->name, &c2->name);\n    if (r != 0)\n\treturn r;\n\n    return (c1->flags != c2->flags);\n}\n\n\nstatic pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c)\n{\n    return (c->name.slen==0 || c->key.slen==0);\n}\n\n\nPJ_DEF(void) pjmedia_srtp_setting_default(pjmedia_srtp_setting *opt)\n{\n    pj_assert(opt);\n\n    pj_bzero(opt, sizeof(pjmedia_srtp_setting));\n    opt->close_member_tp = PJ_TRUE;\n    opt->use = PJMEDIA_SRTP_OPTIONAL;\n}\n\n/*\n * Enumerate all SRTP cryptos, except \"NULL\".\n */\nPJ_DEF(pj_status_t) pjmedia_srtp_enum_crypto(unsigned *count,\n\t\t\t\t\t     pjmedia_srtp_crypto crypto[])\n{\n    unsigned i, max;\n\n    PJ_ASSERT_RETURN(count && crypto, PJ_EINVAL);\n\n    max = sizeof(crypto_suites) / sizeof(crypto_suites[0]) - 1;\n    if (*count > max)\n\t*count = max;\n\n    for (i=0; i<*count; ++i) {\n\tpj_bzero(&crypto[i], sizeof(crypto[0]));\n\tcrypto[i].name = pj_str(crypto_suites[i+1].name);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enumerate available SRTP keying methods.\n */\nPJ_DEF(pj_status_t) pjmedia_srtp_enum_keying(unsigned *count,\n\t\t\t\t      pjmedia_srtp_keying_method keying[])\n{\n    unsigned max;\n\n    PJ_ASSERT_RETURN(count && keying, PJ_EINVAL);\n\n    max = *count;\n    *count = 0;\n\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n    if (*count < max)\n\tkeying[(*count)++] = PJMEDIA_SRTP_KEYING_SDES;\n#endif\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    if (*count < max)\n\tkeying[(*count)++] = PJMEDIA_SRTP_KEYING_DTLS_SRTP;\n#endif\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create an SRTP media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_create(\n\t\t\t\t       pjmedia_endpt *endpt,\n\t\t\t\t       pjmedia_transport *tp,\n\t\t\t\t       const pjmedia_srtp_setting *opt,\n\t\t\t\t       pjmedia_transport **p_tp)\n{\n    pj_pool_t *pool;\n    transport_srtp *srtp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(endpt && tp && p_tp, PJ_EINVAL);\n\n    /* Check crypto */\n    if (opt && opt->use != PJMEDIA_SRTP_DISABLED) {\n\tfor (i=0; i < opt->crypto_count; ++i) {\n\t    int cs_idx = get_crypto_idx(&opt->crypto[i].name);\n\n\t    /* check crypto name */\n\t    if (cs_idx == -1)\n\t\treturn PJMEDIA_SRTP_ENOTSUPCRYPTO;\n\n\t    /* check key length */\n\t    if (opt->crypto[i].key.slen &&\n\t\topt->crypto[i].key.slen <\n\t\t(pj_ssize_t)crypto_suites[cs_idx].cipher_key_len)\n\t\treturn PJMEDIA_SRTP_EINKEYLEN;\n\t}\n    }\n\n    /* Init libsrtp. */\n    status = pjmedia_srtp_init_lib(endpt);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pool = pjmedia_endpt_create_pool(endpt, \"srtp%p\", 1000, 1000);\n    srtp = PJ_POOL_ZALLOC_T(pool, transport_srtp);\n\n    srtp->pool = pool;\n    srtp->session_inited = PJ_FALSE;\n    srtp->bypass_srtp = PJ_FALSE;\n    srtp->probation_cnt = PROBATION_CNT_INIT;\n\n    if (opt) {\n\tsrtp->setting = *opt;\n\tif (opt->use == PJMEDIA_SRTP_DISABLED)\n\t    srtp->setting.crypto_count = 0;\n\n\tfor (i=0; i < srtp->setting.crypto_count; ++i) {\n\t    int cs_idx = get_crypto_idx(&opt->crypto[i].name);\n\t    pj_str_t tmp_key = opt->crypto[i].key;\n\n\t    /* re-set crypto */\n\t    srtp->setting.crypto[i].name = pj_str(crypto_suites[cs_idx].name);\n\t    /* cut key length */\n\t    if (tmp_key.slen)\n\t\ttmp_key.slen = crypto_suites[cs_idx].cipher_key_len;\n\t    pj_strdup(pool, &srtp->setting.crypto[i].key, &tmp_key);\n\t}\n    } else {\n\tpjmedia_srtp_setting_default(&srtp->setting);\n    }\n\n    /* If crypto count is set to zero, setup default crypto-suites,\n     * i.e: all available crypto but 'NULL'.\n     */\n    if (srtp->setting.crypto_count == 0 && \n\tsrtp->setting.use != PJMEDIA_SRTP_DISABLED)\n    {\n\tsrtp->setting.crypto_count = PJMEDIA_SRTP_MAX_CRYPTOS;\n\tpjmedia_srtp_enum_crypto(&srtp->setting.crypto_count,\n\t\t\t\t srtp->setting.crypto);\n    }\n\n    status = pj_lock_create_recursive_mutex(pool, pool->obj_name,\n\t\t\t\t\t    &srtp->mutex);\n    if (status != PJ_SUCCESS) {\n\tpj_pool_release(pool);\n\treturn status;\n    }\n\n    /* Initialize base pjmedia_transport */\n    pj_memcpy(srtp->base.name, pool->obj_name, PJ_MAX_OBJ_NAME);\n    if (tp)\n\tsrtp->base.type = tp->type;\n    else\n\tsrtp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;\n    srtp->base.op = &transport_srtp_op;\n    srtp->base.user_data = srtp->setting.user_data;\n\n    /* Set underlying transport */\n    srtp->member_tp = tp;\n\n    /* Initialize peer's SRTP usage mode. */\n    srtp->peer_use = srtp->setting.use;\n\n    /* If keying count set to zero, setup default keying count & priorities */\n    if (srtp->setting.keying_count == 0) {\n\tsrtp->setting.keying_count = PJMEDIA_SRTP_KEYINGS_COUNT;\n\tpjmedia_srtp_enum_keying(&srtp->setting.keying_count,\n\t\t\t\t srtp->setting.keying);\n    }\n\n    /* Initialize SRTP keying method. */\n    for (i = 0; i < srtp->setting.keying_count && i < MAX_KEYING; ++i) {\n\tswitch(srtp->setting.keying[i]) {\n\n\tcase PJMEDIA_SRTP_KEYING_SDES:\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n\t    sdes_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);\n#endif\n\t    break;\n\n\tcase PJMEDIA_SRTP_KEYING_DTLS_SRTP:\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n\t    dtls_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);\n#endif\n\t    break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n    /* Done */\n    *p_tp = &srtp->base;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get SRTP media transport setting.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_get_setting(\n\t\t\t\t       pjmedia_transport *tp,\n\t\t\t\t       pjmedia_srtp_setting *opt)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    *opt = srtp->setting;\n    return PJ_SUCCESS;\n}\n\n/*\n * Modify SRTP media transport setting.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_modify_setting(\n\t\t\t\t       pjmedia_transport *tp,\n\t\t\t\t       const pjmedia_srtp_setting *opt)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    srtp->setting = *opt;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Initialize and start SRTP session with the given parameters.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_start(\n\t\t\t   pjmedia_transport *tp,\n\t\t\t   const pjmedia_srtp_crypto *tx,\n\t\t\t   const pjmedia_srtp_crypto *rx)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    srtp_policy_t    tx_;\n    srtp_policy_t    rx_;\n    srtp_err_status_t err;\n    int\t\t     cr_tx_idx = 0;\n    int\t\t     au_tx_idx = 0;\n    int\t\t     cr_rx_idx = 0;\n    int\t\t     au_rx_idx = 0;\n    pj_status_t\t     status = PJ_SUCCESS;\n\n    PJ_ASSERT_RETURN(tp && tx && rx, PJ_EINVAL);\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (srtp->session_inited) {\n\tpjmedia_transport_srtp_stop(tp);\n    }\n\n    /* Get encryption and authentication method */\n    cr_tx_idx = au_tx_idx = get_crypto_idx(&tx->name);\n    if (tx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)\n\tcr_tx_idx = 0;\n    if (tx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)\n\tau_tx_idx = 0;\n\n    cr_rx_idx = au_rx_idx = get_crypto_idx(&rx->name);\n    if (rx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)\n\tcr_rx_idx = 0;\n    if (rx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)\n\tau_rx_idx = 0;\n\n    /* Check whether the crypto-suite requested is supported */\n    if (cr_tx_idx == -1 || cr_rx_idx == -1 || au_tx_idx == -1 ||\n\tau_rx_idx == -1)\n    {\n\tstatus = PJMEDIA_SRTP_ENOTSUPCRYPTO;\n\tgoto on_return;\n    }\n\n    /* If all options points to 'NULL' method, just bypass SRTP */\n    if (cr_tx_idx == 0 && cr_rx_idx == 0 && au_tx_idx == 0 && au_rx_idx == 0) {\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tgoto on_return;\n    }\n\n    /* Check key length */\n    if (tx->key.slen != (pj_ssize_t)crypto_suites[cr_tx_idx].cipher_key_len ||\n        rx->key.slen != (pj_ssize_t)crypto_suites[cr_rx_idx].cipher_key_len)\n    {\n\tstatus = PJMEDIA_SRTP_EINKEYLEN;\n\tgoto on_return;\n    }\n\n    /* Init transmit direction */\n    pj_bzero(&tx_, sizeof(srtp_policy_t));\n    pj_memmove(srtp->tx_key, tx->key.ptr, tx->key.slen);\n    if (cr_tx_idx && au_tx_idx)\n\ttx_.rtp.sec_serv    = sec_serv_conf_and_auth;\n    else if (cr_tx_idx)\n\ttx_.rtp.sec_serv    = sec_serv_conf;\n    else if (au_tx_idx)\n\ttx_.rtp.sec_serv    = sec_serv_auth;\n    else\n\ttx_.rtp.sec_serv    = sec_serv_none;\n    tx_.key\t\t    = (uint8_t*)srtp->tx_key;\n    if (srtp->setting.tx_roc.roc != 0 &&\n        srtp->setting.tx_roc.ssrc != 0)\n    {\n\ttx_.ssrc.type\t    = ssrc_specific;\n\ttx_.ssrc.value\t    = srtp->setting.tx_roc.ssrc;\n    } else {\n\ttx_.ssrc.type\t    = ssrc_any_outbound;\n\ttx_.ssrc.value\t    = 0;\n    }\n    tx_.rtp.cipher_type\t    = crypto_suites[cr_tx_idx].cipher_type;\n    tx_.rtp.cipher_key_len  = crypto_suites[cr_tx_idx].cipher_key_len;\n    tx_.rtp.auth_type\t    = crypto_suites[au_tx_idx].auth_type;\n    tx_.rtp.auth_key_len    = crypto_suites[au_tx_idx].auth_key_len;\n    tx_.rtp.auth_tag_len    = crypto_suites[au_tx_idx].srtp_auth_tag_len;\n    tx_.rtcp\t\t    = tx_.rtp;\n    tx_.rtcp.auth_tag_len   = crypto_suites[au_tx_idx].srtcp_auth_tag_len;\n    tx_.next\t\t    = NULL;\n    err = srtp_create(&srtp->srtp_tx_ctx, &tx_);\n    if (err != srtp_err_status_ok) {\n\tstatus = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n\tgoto on_return;\n    }\n    if (srtp->setting.tx_roc.roc != 0 &&\n        srtp->setting.tx_roc.ssrc != 0)\n    {\n\terr = srtp_set_stream_roc(srtp->srtp_tx_ctx,\n\t\t\t\t  srtp->setting.tx_roc.ssrc,\n\t\t\t    \t  srtp->setting.tx_roc.roc);\n    \tPJ_LOG(4, (THIS_FILE, \"Initializing SRTP TX ROC to SSRC %d with \"\n    \t\t   \"ROC %d %s\\n\", srtp->setting.tx_roc.ssrc,\n    \t\t   srtp->setting.tx_roc.roc,\n    \t           (err == srtp_err_status_ok)? \"succeeded\": \"failed\"));\n    }\n    srtp->tx_policy = *tx;\n    pj_strset(&srtp->tx_policy.key,  srtp->tx_key, tx->key.slen);\n    srtp->tx_policy.name=pj_str(crypto_suites[get_crypto_idx(&tx->name)].name);\n\n\n    /* Init receive direction */\n    pj_bzero(&rx_, sizeof(srtp_policy_t));\n    pj_memmove(srtp->rx_key, rx->key.ptr, rx->key.slen);\n    if (cr_rx_idx && au_rx_idx)\n\trx_.rtp.sec_serv    = sec_serv_conf_and_auth;\n    else if (cr_rx_idx)\n\trx_.rtp.sec_serv    = sec_serv_conf;\n    else if (au_rx_idx)\n\trx_.rtp.sec_serv    = sec_serv_auth;\n    else\n\trx_.rtp.sec_serv    = sec_serv_none;\n    rx_.key\t\t    = (uint8_t*)srtp->rx_key;\n    if (srtp->setting.rx_roc.roc != 0 &&\n        srtp->setting.rx_roc.ssrc != 0)\n    {\n\trx_.ssrc.type\t    = ssrc_specific;\n\trx_.ssrc.value\t    = srtp->setting.rx_roc.ssrc;\n    } else {\n\trx_.ssrc.type\t    = ssrc_any_inbound;\n\trx_.ssrc.value\t    = 0;\n    }\n    rx_.rtp.sec_serv\t    = crypto_suites[cr_rx_idx].service;\n    rx_.rtp.cipher_type\t    = crypto_suites[cr_rx_idx].cipher_type;\n    rx_.rtp.cipher_key_len  = crypto_suites[cr_rx_idx].cipher_key_len;\n    rx_.rtp.auth_type\t    = crypto_suites[au_rx_idx].auth_type;\n    rx_.rtp.auth_key_len    = crypto_suites[au_rx_idx].auth_key_len;\n    rx_.rtp.auth_tag_len    = crypto_suites[au_rx_idx].srtp_auth_tag_len;\n    rx_.rtcp\t\t    = rx_.rtp;\n    rx_.rtcp.auth_tag_len   = crypto_suites[au_rx_idx].srtcp_auth_tag_len;\n    rx_.next\t\t    = NULL;\n    err = srtp_create(&srtp->srtp_rx_ctx, &rx_);\n    if (err != srtp_err_status_ok) {\n\tsrtp_dealloc(srtp->srtp_tx_ctx);\n\tstatus = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n\tgoto on_return;\n    }\n    if (srtp->setting.rx_roc.roc != 0 &&\n        srtp->setting.rx_roc.ssrc != 0)\n    {\n\terr = srtp_set_stream_roc(srtp->srtp_rx_ctx,\n\t\t\t\t  srtp->setting.rx_roc.ssrc,\n\t\t\t    \t  srtp->setting.rx_roc.roc);\n    \tPJ_LOG(4, (THIS_FILE, \"Initializing SRTP RX ROC from SSRC %d with \"\n    \t\t   \"ROC %d %s\\n\",\n    \t           srtp->setting.rx_roc.ssrc, srtp->setting.rx_roc.roc,\n    \t       \t   (err == srtp_err_status_ok)? \"succeeded\": \"failed\"));\n    }\n    srtp->rx_policy = *rx;\n    pj_strset(&srtp->rx_policy.key,  srtp->rx_key, rx->key.slen);\n    srtp->rx_policy.name=pj_str(crypto_suites[get_crypto_idx(&rx->name)].name);\n\n    /* Declare SRTP session initialized */\n    srtp->session_inited = PJ_TRUE;\n\n    /* Logging stuffs */\n#if PJ_LOG_MAX_LEVEL >= 5\n    {\n\tchar b64[PJ_BASE256_TO_BASE64_LEN(MAX_KEY_LEN)];\n\tint b64_len;\n\n\t/* TX crypto and key */\n\tb64_len = sizeof(b64);\n\tstatus = pj_base64_encode((pj_uint8_t*)tx->key.ptr, (int)tx->key.slen,\n\t\t\t\t  b64, &b64_len);\n\tif (status != PJ_SUCCESS)\n\t    b64_len = pj_ansi_sprintf(b64, \"--key too long--\");\n\telse\n\t    b64[b64_len] = '\\0';\n\n\tPJ_LOG(5, (srtp->pool->obj_name, \"TX: %s key=%s\",\n\t\t   srtp->tx_policy.name.ptr, b64));\n\tif (srtp->tx_policy.flags) {\n\t    PJ_LOG(5,(srtp->pool->obj_name, \"TX: disable%s%s\",\n\t\t      (cr_tx_idx?\"\":\" enc\"),\n\t\t      (au_tx_idx?\"\":\" auth\")));\n\t}\n\n\t/* RX crypto and key */\n\tb64_len = sizeof(b64);\n\tstatus = pj_base64_encode((pj_uint8_t*)rx->key.ptr, (int)rx->key.slen,\n\t\t\t\t  b64, &b64_len);\n\tif (status != PJ_SUCCESS)\n\t    b64_len = pj_ansi_sprintf(b64, \"--key too long--\");\n\telse\n\t    b64[b64_len] = '\\0';\n\n\tPJ_LOG(5, (srtp->pool->obj_name, \"RX: %s key=%s\",\n\t\t   srtp->rx_policy.name.ptr, b64));\n\tif (srtp->rx_policy.flags) {\n\t    PJ_LOG(5,(srtp->pool->obj_name,\"RX: disable%s%s\",\n\t\t      (cr_rx_idx?\"\":\" enc\"),\n\t\t      (au_rx_idx?\"\":\" auth\")));\n\t}\n    }\n#endif\n\non_return:\n    pj_lock_release(srtp->mutex);\n    return status;\n}\n\n/*\n * Stop SRTP session.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_stop(pjmedia_transport *srtp)\n{\n    transport_srtp *p_srtp = (transport_srtp*) srtp;\n    srtp_err_status_t err;\n\n    PJ_ASSERT_RETURN(srtp, PJ_EINVAL);\n\n    pj_lock_acquire(p_srtp->mutex);\n\n    if (!p_srtp->session_inited) {\n\tpj_lock_release(p_srtp->mutex);\n\treturn PJ_SUCCESS;\n    }\n\n    err = srtp_dealloc(p_srtp->srtp_rx_ctx);\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(4, (p_srtp->pool->obj_name,\n\t\t   \"Failed to dealloc RX SRTP context: %s\",\n\t\t   get_libsrtp_errstr(err)));\n    }\n    err = srtp_dealloc(p_srtp->srtp_tx_ctx);\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(4, (p_srtp->pool->obj_name,\n\t\t   \"Failed to dealloc TX SRTP context: %s\",\n\t\t   get_libsrtp_errstr(err)));\n    }\n    p_srtp->srtp_rx_ctx = NULL;\n    p_srtp->srtp_tx_ctx = NULL;\n\n    p_srtp->session_inited = PJ_FALSE;\n    pj_bzero(&p_srtp->rx_policy, sizeof(p_srtp->rx_policy));\n    pj_bzero(&p_srtp->tx_policy, sizeof(p_srtp->tx_policy));\n\n    pj_lock_release(p_srtp->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t start_srtp(transport_srtp *srtp)\n{\n    /* Make sure we have the SRTP policies */\n    if (srtp_crypto_empty(&srtp->tx_policy_neg) ||\n\tsrtp_crypto_empty(&srtp->rx_policy_neg))\n    {\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tsrtp->peer_use = PJMEDIA_SRTP_DISABLED;\n\tif (srtp->session_inited) {\n\t    pjmedia_transport_srtp_stop(&srtp->base);\n\t}\n\n\tPJ_LOG(4, (srtp->pool->obj_name, \"SRTP not active\"));\n\treturn PJ_SUCCESS;\n    }\n\n    /* Got policy_local & policy_remote, let's initalize the SRTP */\n\n    /* Ticket #1075: media_start() is called whenever media description\n     * gets updated, e.g: call hold, however we should restart SRTP only\n     * when the SRTP policy settings are updated.\n     */\n    if (srtp_crypto_cmp(&srtp->tx_policy_neg, &srtp->tx_policy) ||\n\tsrtp_crypto_cmp(&srtp->rx_policy_neg, &srtp->rx_policy))\n    {\n\tpj_status_t status;\n\tstatus = pjmedia_transport_srtp_start(&srtp->base,\n\t\t\t\t\t      &srtp->tx_policy_neg,\n\t\t\t\t\t      &srtp->rx_policy_neg);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\t/* Reset probation counts */\n\tsrtp->probation_cnt = PROBATION_CNT_INIT;\n\n\tPJ_LOG(4, (srtp->pool->obj_name,\n\t\t   \"SRTP started, keying=%s, crypto=%s\",\n\t\t   ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES?\n\t\t    \"SDES\":\"DTLS-SRTP\"),\n\t\t   srtp->tx_policy.name.ptr));\n    }\n\n    srtp->bypass_srtp = PJ_FALSE;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjmedia_transport *) pjmedia_transport_srtp_get_member(\n\t\t\t\t\t\tpjmedia_transport *tp)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n\n    PJ_ASSERT_RETURN(tp, NULL);\n\n    return srtp->member_tp;\n}\n\n\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n\t\t\t\t      pjmedia_transport_info *info)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n    pjmedia_srtp_info srtp_info;\n    int spc_info_idx;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp && info, PJ_EINVAL);\n    PJ_ASSERT_RETURN(info->specific_info_cnt <\n\t\t     PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXCNT, PJ_ETOOMANY);\n    PJ_ASSERT_RETURN(sizeof(pjmedia_srtp_info) <=\n\t\t     PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXSIZE, PJ_ENOMEM);\n\n    srtp_info.active = srtp->session_inited;\n    srtp_info.rx_policy = srtp->rx_policy;\n    srtp_info.tx_policy = srtp->tx_policy;\n    srtp_info.use = srtp->setting.use;\n    srtp_info.peer_use = srtp->peer_use;\n\n    pj_bzero(&srtp_info.tx_roc, sizeof(srtp_info.tx_roc));\n    pj_bzero(&srtp_info.rx_roc, sizeof(srtp_info.rx_roc));\n\n    if (srtp->srtp_rx_ctx && srtp->rx_ssrc != 0) {\n    \tsrtp_info.rx_roc.ssrc = srtp->rx_ssrc;\n    \tsrtp_get_stream_roc(srtp->srtp_rx_ctx, srtp->rx_ssrc,\n    \t\t\t    &srtp_info.rx_roc.roc);\n    } else if (srtp->setting.rx_roc.ssrc != 0) {\n    \tsrtp_info.rx_roc.ssrc = srtp->setting.rx_roc.ssrc;\n    \tsrtp_info.rx_roc.roc = srtp->setting.rx_roc.roc;\n    }\n    if (srtp->srtp_tx_ctx && srtp->tx_ssrc != 0) {\n    \tsrtp_info.tx_roc.ssrc = srtp->tx_ssrc;\n    \tsrtp_get_stream_roc(srtp->srtp_tx_ctx, srtp->tx_ssrc,\n    \t\t\t    &srtp_info.tx_roc.roc);\n    } else if (srtp->setting.tx_roc.ssrc != 0) {\n    \tsrtp_info.tx_roc.ssrc = srtp->setting.tx_roc.ssrc;\n    \tsrtp_info.tx_roc.roc = srtp->setting.tx_roc.roc;\n    }\n\n    spc_info_idx = info->specific_info_cnt++;\n    info->spc_info[spc_info_idx].type = PJMEDIA_TRANSPORT_TYPE_SRTP;\n    info->spc_info[spc_info_idx].tp = tp;\n    info->spc_info[spc_info_idx].cbsize = sizeof(srtp_info);\n    pj_memcpy(&info->spc_info[spc_info_idx].buffer, &srtp_info,\n\t      sizeof(srtp_info));\n\n    /* Invoke get_info() from any active keying method */\n    for (i=0; i < srtp->keying_cnt; i++)\n\tpjmedia_transport_get_info(srtp->keying[i], info);\n\n    return pjmedia_transport_get_info(srtp->member_tp, info);\n}\n\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n\t\t\t\t     pjmedia_transport_attach_param *param)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n    pjmedia_transport_attach_param member_param;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && param, PJ_EINVAL);\n\n    /* Save the callbacks */\n    pj_lock_acquire(srtp->mutex);\n    if (param->rtp_cb || param->rtp_cb2) {\n\t/* Do not update rtp_cb if not set, as attach() is called by\n\t * keying method.\n\t */\n\tsrtp->rtp_cb = param->rtp_cb;\n\tsrtp->rtp_cb2 = param->rtp_cb2;\n\tsrtp->rtcp_cb = param->rtcp_cb;\n\tsrtp->user_data = param->user_data;\n    }\n    pj_lock_release(srtp->mutex);\n\n    /* Attach self to member transport */\n    member_param = *param;\n    member_param.user_data = srtp;\n    member_param.rtp_cb = NULL;\n    member_param.rtp_cb2 = &srtp_rtp_cb;\n    member_param.rtcp_cb = &srtp_rtcp_cb;\n    status = pjmedia_transport_attach2(srtp->member_tp, &member_param);\n    if (status != PJ_SUCCESS) {\n\tpj_lock_acquire(srtp->mutex);\n\tsrtp->rtp_cb = NULL;\n\tsrtp->rtcp_cb = NULL;\n\tsrtp->user_data = NULL;\n\tpj_lock_release(srtp->mutex);\n\treturn status;\n    }\n\n    /* Check if we are multiplexing RTP & RTCP. */\n    srtp->use_rtcp_mux = (pj_sockaddr_has_addr(&param->rem_addr) &&\n    \t\t\t  pj_sockaddr_cmp(&param->rem_addr,\n    \t\t\t\t\t  &param->rem_rtcp) == 0);\n    srtp->member_tp_attached = PJ_TRUE;\n    return PJ_SUCCESS;\n}\n\nstatic void transport_detach(pjmedia_transport *tp, void *strm)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n\n    PJ_UNUSED_ARG(strm);\n    PJ_ASSERT_ON_FAIL(tp, return);\n\n    if (srtp->member_tp) {\n\tpjmedia_transport_detach(srtp->member_tp, srtp);\n    }\n\n    /* Clear up application infos from transport */\n    pj_lock_acquire(srtp->mutex);\n    srtp->rtp_cb = NULL;\n    srtp->rtp_cb2 = NULL;\n    srtp->rtcp_cb = NULL;\n    srtp->user_data = NULL;\n    pj_lock_release(srtp->mutex);\n    srtp->member_tp_attached = PJ_FALSE;\n}\n\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size)\n{\n    pj_status_t status;\n    transport_srtp *srtp = (transport_srtp*) tp;\n    int len = (int)size;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp)\n\treturn pjmedia_transport_send_rtp(srtp->member_tp, pkt, size);\n\n    if (size > sizeof(srtp->rtp_tx_buffer) - MAX_TRAILER_LEN)\n\treturn PJ_ETOOBIG;\n\n    pj_memcpy(srtp->rtp_tx_buffer, pkt, size);\n\n    pj_lock_acquire(srtp->mutex);\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn PJMEDIA_SRTP_EKEYNOTREADY;\n    }\n\n    /* Save outgoing SSRC */\n    srtp->tx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n\n#if TEST_ROC\n    if (srtp->setting.tx_roc.ssrc == 0) {\n\tsrtp_err_status_t status;\n    \tstatus = srtp_set_stream_roc(srtp->srtp_tx_ctx, srtp->tx_ssrc,\n    \t\t\t    \t     (srtp->offerer_side? 1: 2));\n    \tif (status == srtp_err_status_ok) {\n    \t    srtp->setting.tx_roc.ssrc = srtp->tx_ssrc;\n    \t    srtp->setting.tx_roc.roc = (srtp->offerer_side? 1: 2);\n\t    PJ_LOG(4, (THIS_FILE, \"Setting TX ROC to SSRC %d to %d\",\n\t\t   srtp->tx_ssrc, srtp->setting.tx_roc.roc));\n\t}\n    }\n#endif\n\n    err = srtp_protect(srtp->srtp_tx_ctx, srtp->rtp_tx_buffer, &len);\n    pj_lock_release(srtp->mutex);\n\n    if (err == srtp_err_status_ok) {\n\tstatus = pjmedia_transport_send_rtp(srtp->member_tp,\n\t\t\t\t\t    srtp->rtp_tx_buffer, len);\n    } else {\n\tstatus = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n    }\n\n    return status;\n}\n\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n\t\t\t\t       const void *pkt,\n\t\t\t\t       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n\t\t\t\t        const pj_sockaddr_t *addr,\n\t\t\t\t        unsigned addr_len,\n\t\t\t\t        const void *pkt,\n\t\t\t\t        pj_size_t size)\n{\n    pj_status_t status;\n    transport_srtp *srtp = (transport_srtp*) tp;\n    int len = (int)size;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp) {\n\treturn pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len,\n\t                                    pkt, size);\n    }\n\n    if (size > sizeof(srtp->rtcp_tx_buffer) - (MAX_TRAILER_LEN+4))\n\treturn PJ_ETOOBIG;\n\n    pj_memcpy(srtp->rtcp_tx_buffer, pkt, size);\n\n    pj_lock_acquire(srtp->mutex);\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn PJMEDIA_SRTP_EKEYNOTREADY;\n    }\n    err = srtp_protect_rtcp(srtp->srtp_tx_ctx, srtp->rtcp_tx_buffer, &len);\n    pj_lock_release(srtp->mutex);\n\n    if (err == srtp_err_status_ok) {\n\tstatus = pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len,\n\t\t\t\t\t      srtp->rtcp_tx_buffer, len);\n    } else {\n\tstatus = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n    }\n\n    return status;\n}\n\n\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n\t\t\t\t\t   pjmedia_dir dir,\n\t\t\t\t\t   unsigned pct_lost)\n{\n    transport_srtp *srtp = (transport_srtp *) tp;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    return pjmedia_transport_simulate_lost(srtp->member_tp, dir, pct_lost);\n}\n\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    transport_srtp *srtp = (transport_srtp *) tp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* Close all keying. Note that any keying should not be destroyed before\n     * SRTP transport is destroyed as re-INVITE may initiate new keying method\n     * without destroying SRTP transport.\n     */\n    for (i=0; i < srtp->all_keying_cnt; i++)\n\tpjmedia_transport_close(srtp->all_keying[i]);\n\n    /* Close member if configured */\n    if (srtp->setting.close_member_tp && srtp->member_tp) {\n\tpjmedia_transport_close(srtp->member_tp);\n    }\n\n    status = pjmedia_transport_srtp_stop(tp);\n\n    /* In case mutex is being acquired by other thread */\n    pj_lock_acquire(srtp->mutex);\n    pj_lock_release(srtp->mutex);\n\n    pj_lock_destroy(srtp->mutex);\n    pj_pool_release(srtp->pool);\n\n    return status;\n}\n\n/*\n * This callback is called by transport when incoming rtp is received\n */\nstatic void srtp_rtp_cb(pjmedia_tp_cb_param *param)\n{\n    transport_srtp *srtp = (transport_srtp *) param->user_data;\n    void *pkt = param->pkt;\n    pj_ssize_t size = param->size;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void (*cb2)(pjmedia_tp_cb_param*) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n        if (srtp->rtp_cb2) {\n            pjmedia_tp_cb_param param2 = *param;\n            param2.user_data = srtp->user_data;\n            srtp->rtp_cb2(&param2);\n            param->rem_switch = param2.rem_switch;\n        } else if (srtp->rtp_cb) {\n\t    srtp->rtp_cb(srtp->user_data, pkt, size);\n\t}\n\treturn;\n    }\n\n    if (size < 0) {\n\treturn;\n    }\n\n    /* Give the packet to keying first by invoking its send_rtp() op.\n     * Yes, the usage of send_rtp() is rather hacky, but it is convenient\n     * as the signature suits the purpose and it is ready to use\n     * (no futher registration/setting needed), and it may never be used\n     * by any keying method in the future.\n     */\n    {\n\tunsigned i;\n\tpj_status_t status;\n\tfor (i=0; i < srtp->keying_cnt; i++) {\n\t    if (!srtp->keying[i]->op->send_rtp)\n\t\tcontinue;\n\t    status = pjmedia_transport_send_rtp(srtp->keying[i], pkt, size);\n\t    if (status != PJ_EIGNORED) {\n\t\t/* Packet is already consumed by the keying method */\n\t\treturn;\n\t    }\n\t}\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    if (srtp->probation_cnt > 0)\n\t--srtp->probation_cnt;\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn;\n    }\n\n    /* Check if multiplexing is allowed and the payload indicates RTCP. */\n    if (srtp->use_rtcp_mux) {\n    \tpjmedia_rtp_hdr *hdr = (pjmedia_rtp_hdr *)pkt;\n  \n\tif (hdr->pt >= 64 && hdr->pt <= 95) {   \n\t    pj_lock_release(srtp->mutex);\n\t    srtp_rtcp_cb(srtp, pkt, size);\n    \t    return;\n    \t}\n    }\n\n#if TEST_ROC\n    if (srtp->setting.rx_roc.ssrc == 0) {\n\tsrtp_err_status_t status;\n\t\n\tsrtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    \tstatus = srtp_set_stream_roc(srtp->srtp_rx_ctx, srtp->rx_ssrc, \n    \t\t\t    \t     (srtp->offerer_side? 2: 1));\n\tif (status == srtp_err_status_ok) {    \t\n    \t    srtp->setting.rx_roc.ssrc = srtp->rx_ssrc;\n\t    srtp->setting.rx_roc.roc = (srtp->offerer_side? 2: 1);\n\n\t    PJ_LOG(4, (THIS_FILE, \"Setting RX ROC from SSRC %d to %d\",\n\t\t   \t\t  srtp->rx_ssrc, srtp->setting.rx_roc.roc));\n\t} else {\n\t    PJ_LOG(4, (THIS_FILE, \"Setting RX ROC %s\",\n\t    \t       get_libsrtp_errstr(status)));\n\t}\n    }\n#endif\n    \n    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\n#if PJMEDIA_SRTP_CHECK_RTP_SEQ_ON_RESTART\n    if (srtp->probation_cnt > 0 &&\n\t(err == srtp_err_status_replay_old ||\n\t err == srtp_err_status_replay_fail))\n    {\n\t/* Handle such condition that stream is updated (RTP seq is reinited\n\t * & SRTP is restarted), but some old packets are still coming\n\t * so SRTP is learning wrong RTP seq. While the newly inited RTP seq\n\t * comes, SRTP thinks the RTP seq is replayed, so srtp_unprotect()\n\t * will return err_status_replay_*. Restarting SRTP can resolve this.\n\t */\n\tpjmedia_srtp_crypto tx, rx;\n\tpj_status_t status;\n\n\ttx = srtp->tx_policy;\n\trx = srtp->rx_policy;\n\n\t/* Stop SRTP first, otherwise srtp_start() will maintain current\n\t * roll-over counter.\n\t */\n\tpjmedia_transport_srtp_stop((pjmedia_transport*)srtp);\n\n\tstatus = pjmedia_transport_srtp_start((pjmedia_transport*)srtp,\n\t\t\t\t\t      &tx, &rx);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_LOG(5,(srtp->pool->obj_name, \"Failed to restart SRTP, err=%s\",\n\t\t      get_libsrtp_errstr(err)));\n\t} else if (!srtp->bypass_srtp) {\n\t    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\t}\n    }\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    else\n#endif\n#endif\n\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    if (srtp->probation_cnt > 0 && err == srtp_err_status_auth_fail &&\n\tsrtp->setting.prev_rx_roc.ssrc != 0 &&\n\tsrtp->setting.prev_rx_roc.ssrc == srtp->setting.rx_roc.ssrc &&\n\tsrtp->setting.prev_rx_roc.roc != srtp->setting.rx_roc.roc)\n    {\n        unsigned roc, new_roc;\n\tsrtp_err_status_t status;\n\n    \tsrtp_get_stream_roc(srtp->srtp_rx_ctx, srtp->setting.rx_roc.ssrc,\n    \t\t\t    &roc);\n    \tnew_roc = (roc == srtp->setting.rx_roc.roc?\n    \t\t   srtp->setting.prev_rx_roc.roc: srtp->setting.rx_roc.roc);\n    \tstatus = srtp_set_stream_roc(srtp->srtp_rx_ctx,\n    \t\t\t\t     srtp->setting.rx_roc.ssrc, new_roc);\n\tif (status == srtp_err_status_ok) {\n\t    PJ_LOG(4, (srtp->pool->obj_name,\n\t\t       \"Retrying to unprotect SRTP from ROC %d to new ROC %d\",\n\t\t       roc, new_roc));\n    \t    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n    \t}\n    }\n#endif\n\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(5,(srtp->pool->obj_name,\n\t\t  \"Failed to unprotect SRTP, pkt size=%d, err=%s\",\n\t\t  size, get_libsrtp_errstr(err)));\n    } else {\n\tcb = srtp->rtp_cb;\n\tcb2 = srtp->rtp_cb2;\n\tcb_data = srtp->user_data;\n\n\t/* Save SSRC after successful SRTP unprotect */\n\tsrtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb2) {\n        pjmedia_tp_cb_param param2 = *param;\n        param2.user_data = cb_data;\n        param2.pkt = pkt;\n        param2.size = len;\n        (*cb2)(&param2);\n        param->rem_switch = param2.rem_switch;\n    } else if (cb) {\n\t(*cb)(cb_data, pkt, len);\n    }\n}\n\n/*\n * This callback is called by transport when incoming rtcp is received\n */\nstatic void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size)\n{\n    transport_srtp *srtp = (transport_srtp *) user_data;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n\tsrtp->rtcp_cb(srtp->user_data, pkt, size);\n\treturn;\n    }\n\n    if (size < 0) {\n\treturn;\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn;\n    }\n    err = srtp_unprotect_rtcp(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(5,(srtp->pool->obj_name,\n\t\t  \"Failed to unprotect SRTCP, pkt size=%d, err=%s\",\n\t\t  size, get_libsrtp_errstr(err)));\n    } else {\n\tcb = srtp->rtcp_cb;\n\tcb_data = srtp->user_data;\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb) {\n\t(*cb)(cb_data, pkt, len);\n    }\n}\n\n\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n\t\t\t\t          pj_pool_t *sdp_pool,\n\t\t\t\t\t  unsigned options,\n\t\t\t\t          const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t\t  unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    unsigned member_tp_option;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    pj_bzero(&srtp->rx_policy_neg, sizeof(srtp->rx_policy_neg));\n    pj_bzero(&srtp->tx_policy_neg, sizeof(srtp->tx_policy_neg));\n\n    srtp->tx_ssrc = srtp->rx_ssrc = 0;\n    srtp->media_option = member_tp_option = options;\n    srtp->offerer_side = (sdp_remote == NULL);\n\n    if (srtp->offerer_side && srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n\t/* If we are offerer and SRTP is disabled, simply bypass SRTP and\n\t * skip keying.\n\t */\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tsrtp->keying_cnt = 0;\n    } else {\n\t/* If we are answerer and SRTP is disabled, we need to verify that\n\t * SRTP is disabled too in remote SDP, so we can't just skip keying.\n\t */\n\tsrtp->bypass_srtp = PJ_FALSE;\n\tsrtp->keying_cnt = srtp->all_keying_cnt;\n\tfor (i = 0; i < srtp->all_keying_cnt; ++i)\n\t    srtp->keying[i] = srtp->all_keying[i];\n\n\tmember_tp_option |= PJMEDIA_TPMED_NO_TRANSPORT_CHECKING;\n    }\n\n    status = pjmedia_transport_media_create(srtp->member_tp, sdp_pool,\n\t\t\t\t\t    member_tp_option, sdp_remote,\n\t\t\t\t\t    media_index);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Invoke media_create() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED:\n     *   - as offerer, nothing (keying is skipped).\n     *   - as answerer, verify remote SDP, make sure it has SRTP disabled too,\n     *     if not, return error.\n     * - OPTIONAL:\n     *   - as offerer, general initialization.\n     *   - as answerer, optionally verify SRTP attr in remote SDP (if any).\n     * - MANDATORY:\n     *   - as offerer, general initialization.\n     *   - as answerer, verify SRTP attr in remote SDP.\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n\tpj_status_t st;\n\tst = pjmedia_transport_media_create(srtp->keying[i], sdp_pool,\n\t\t\t\t\t    options, sdp_remote,\n\t\t\t\t\t    media_index);\n\tif (st != PJ_SUCCESS) {\n\t    /* This keying method returns error, remove it */\n\t    pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n\t\t\t   srtp->keying_cnt, i);\n\t    srtp->keying_cnt--;\n\t    keying_status = st;\n\t    continue;\n\t} else if (srtp->offerer_side) {\n\t    /* Currently we can send one keying only in outgoing offer */\n\t    srtp->keying[0] = srtp->keying[i];\n\t    srtp->keying_cnt = 1;\n\t    break;\n\t}\n\n\t++i;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0)\n\treturn keying_status;\n\n    /* Bypass SRTP & skip keying as SRTP is disabled and verification on\n     * remote SDP has been done.\n     */\n    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tsrtp->keying_cnt = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n\t\t\t\t\tpj_pool_t *sdp_pool,\n\t\t\t\t\tpjmedia_sdp_session *sdp_local,\n\t\t\t\t\tconst pjmedia_sdp_session *sdp_remote,\n\t\t\t\t\tunsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp && sdp_pool && sdp_local, PJ_EINVAL);\n\n    pj_bzero(&srtp->rx_policy_neg, sizeof(srtp->rx_policy_neg));\n    pj_bzero(&srtp->tx_policy_neg, sizeof(srtp->tx_policy_neg));\n\n    srtp->offerer_side = (sdp_remote == NULL);\n\n    if (!srtp->offerer_side && srtp->started) {\n\t/* This is may be incoming reoffer that may change keying */\n\tsrtp->keying_cnt = srtp->all_keying_cnt;\n\tfor (i = 0; i < srtp->all_keying_cnt; ++i)\n\t    srtp->keying[i] = srtp->all_keying[i];\n    }\n\n    status = pjmedia_transport_encode_sdp(srtp->member_tp, sdp_pool,\n\t\t\t\t\t  sdp_local, sdp_remote, media_index);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Invoke encode_sdp() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED: nothing (keying is skipped)\n     * - OPTIONAL:\n     *   - as offerer, generate offer.\n     *   - as answerer, if remote has the same SRTP keying in SDP, verify it,\n     *     generate answer, start crypto nego.\n     * - MANDATORY:\n     *   - as offerer, generate offer.\n     *   - as answerer, verify remote SDP, generate answer, start crypto nego.\n     *\n     * Note: because the SDP will be processed by other keying/components,\n     *       keying must do verification on remote SDP first (e.g: keying\n     *       is being used) before touching local SDP.\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n\tpj_status_t st;\n\tst = pjmedia_transport_encode_sdp(srtp->keying[i], sdp_pool,\n\t\t\t\t\t  sdp_local, sdp_remote,\n\t\t\t\t\t  media_index);\n\tif (st != PJ_SUCCESS) {\n\t    /* This keying method returns error, remove it */\n\t    pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n\t\t\t   srtp->keying_cnt, i);\n\t    srtp->keying_cnt--;\n\t    keying_status = st;\n\t    continue;\n\t} else if (!srtp->offerer_side) {\n\t    /* Answer with one keying only */\n\t    srtp->keying[0] = srtp->keying[i];\n\t    srtp->keying_cnt = 1;\n\t    break;\n\t}\n\n\ti++;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0) {\n\tif (keying_status != PJ_SUCCESS) {\n\t    DEACTIVATE_MEDIA(sdp_pool, sdp_local->media[media_index]);\n\t}\n\treturn keying_status;\n    }\n\n    /* Bypass SRTP & skip keying as SRTP is disabled and verification on\n     * remote SDP has been done.\n     */\n    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n\tsrtp->bypass_srtp = PJ_TRUE;\n\tsrtp->keying_cnt = 0;\n    }\n\n    if (srtp->keying_cnt != 0) {\n\t/* At this point for now, keying count should be 1 */\n\tpj_assert(srtp->keying_cnt == 1);\n\tPJ_LOG(4, (srtp->pool->obj_name, \"SRTP uses keying method %s\",\n\t\t   ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES?\n\t\t    \"SDES\":\"DTLS-SRTP\")));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n\t\t\t\t         pj_pool_t *pool,\n\t\t\t\t         const pjmedia_sdp_session *sdp_local,\n\t\t\t\t         const pjmedia_sdp_session *sdp_remote,\n\t\t\t\t         unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* At this point for now, keying count should be 0 or 1 */\n    pj_assert(srtp->keying_cnt <= 1);\n\n    srtp->started = PJ_TRUE;\n\n    status = pjmedia_transport_media_start(srtp->member_tp, pool,\n\t\t\t\t\t   sdp_local, sdp_remote,\n\t\t\t\t           media_index);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Invoke media_start() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED: nothing (keying is skipped)\n     * - OPTIONAL:\n     *   - as offerer, if remote answer has the same SRTP keying in SDP,\n     *     verify it and start crypto nego.\n     *   - as answerer, start crypto nego if not yet (usually initated in\n     *     encode_sdp()).\n     * - MANDATORY:\n     *   - as offerer, verify remote answer and start crypto nego.\n     *   - as answerer, start crypto nego if not yet (usually initated in\n     *     encode_sdp()).\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n\tstatus = pjmedia_transport_media_start(srtp->keying[i], pool,\n\t\t\t\t\t       sdp_local, sdp_remote,\n\t\t\t\t\t       media_index);\n\tif (status != PJ_SUCCESS) {\n\t    /* This keying method returns error, remove it */\n\t    pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n\t\t\t   srtp->keying_cnt, i);\n\t    srtp->keying_cnt--;\n\t    keying_status = status;\n\t    continue;\n\t}\n\n\tif (!srtp_crypto_empty(&srtp->tx_policy_neg) &&\n\t    !srtp_crypto_empty(&srtp->rx_policy_neg))\n\t{\n\t    /* SRTP nego is done */\n\t    srtp->keying_cnt = 1;\n\t    srtp->keying[0] = srtp->keying[i];\n\t    srtp->keying_pending_cnt = 0;\n\t    break;\n\t}\n\n\ti++;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0)\n\treturn keying_status;\n\n    /* If SRTP key is being negotiated, just return now.\n     * The keying method should start the SRTP once keying nego is done.\n     */\n    if (srtp->keying_pending_cnt)\n\treturn PJ_SUCCESS;\n\n    /* Start SRTP */\n    status = start_srtp(srtp);\n\n    return status;\n}\n\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    srtp->started = PJ_FALSE;\n\n    /* Invoke media_stop() of all keying methods */\n    for (i=0; i < srtp->keying_cnt; ++i) {\n\tpjmedia_transport_media_stop(srtp->keying[i]);\n    }\n\n    /* Invoke media_stop() of member tp */\n    status = pjmedia_transport_media_stop(srtp->member_tp);\n    if (status != PJ_SUCCESS)\n\tPJ_PERROR(4, (srtp->pool->obj_name, status,\n\t\t      \"SRTP failed stop underlying media transport.\"));\n\n    /* Finally, stop SRTP */\n    return pjmedia_transport_srtp_stop(tp);\n}\n\n\n/* Utility */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_decrypt_pkt(pjmedia_transport *tp,\n\t\t\t\t\t\t       pj_bool_t is_rtp,\n\t\t\t\t\t\t       void *pkt,\n\t\t\t\t\t\t       int *pkt_len)\n{\n    transport_srtp *srtp = (transport_srtp *)tp;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp)\n\treturn PJ_SUCCESS;\n\n    PJ_ASSERT_RETURN(tp && pkt && (*pkt_len>0), PJ_EINVAL);\n    PJ_ASSERT_RETURN(srtp->session_inited, PJ_EINVALIDOP);\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return PJ_EINVAL);\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    if (is_rtp)\n\terr = srtp_unprotect(srtp->srtp_rx_ctx, pkt, pkt_len);\n    else\n\terr = srtp_unprotect_rtcp(srtp->srtp_rx_ctx, pkt, pkt_len);\n\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(5,(srtp->pool->obj_name,\n\t\t  \"Failed to unprotect SRTP, pkt size=%d, err=%s\",\n\t\t  *pkt_len, get_libsrtp_errstr(err)));\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    return (err==srtp_err_status_ok) ? PJ_SUCCESS :\n\t\t\t\t       PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n}\n\n#endif\n"], "filenames": ["pjmedia/src/pjmedia/transport_srtp.c"], "buggy_code_start_loc": [1533], "buggy_code_end_loc": [1541], "fixing_code_start_loc": [1534], "fixing_code_end_loc": [1541], "type": "NVD-CWE-noinfo", "message": "PJSIP is a free and open source multimedia communication library written in C. When processing certain packets, PJSIP may incorrectly switch from using SRTP media transport to using basic RTP upon SRTP restart, causing the media to be sent insecurely. The vulnerability impacts all PJSIP users that use SRTP. The patch is available as commit d2acb9a in the master branch of the project and will be included in version 2.13. Users are advised to manually patch or to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2022-39269", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-06T18:16:13.200", "lastModified": "2023-02-24T00:15:11.957", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C. When processing certain packets, PJSIP may incorrectly switch from using SRTP media transport to using basic RTP upon SRTP restart, causing the media to be sent insecurely. The vulnerability impacts all PJSIP users that use SRTP. The patch is available as commit d2acb9a in the master branch of the project and will be included in version 2.13. Users are advised to manually patch or to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "PJSIP es una librer\u00eda de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en C. Cuando procesa determinados paquetes, PJSIP puede cambiar incorrectamente de usar el transporte de medios SRTP a usar RTP b\u00e1sico al reiniciar SRTP, causando que los medios sean enviados de forma no segura. La vulnerabilidad afecta a todos los usuarios de PJSIP que usan SRTP. El parche est\u00e1 disponible como commit d2acb9a en la rama maestra del proyecto y ser\u00e1 incluida en versi\u00f3n 2.13. Se recomienda a usuarios aplicar el parche manualmente o actualizar. No se presentan mitigaciones conocidas para esta vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-319"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pjsip:pjsip:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.11", "versionEndExcluding": "2.13", "matchCriteriaId": "EDE35BC2-087A-4BF0-BF4A-E28BABC69F40"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/d2acb9af4e27b5ba75d658690406cec9c274c5cc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-wx5m-cj97-4wwg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/02/msg00029.html", "source": "security-advisories@github.com"}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5358", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/d2acb9af4e27b5ba75d658690406cec9c274c5cc"}}