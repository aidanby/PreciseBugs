{"buggy_code": ["/*\t$OpenBSD: lka_filter.c,v 1.64 2020/12/20 13:27:46 martijn Exp $\t*/\n\n/*\n * Copyright (c) 2018 Gilles Chehade <gilles@poolp.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/socket.h>\n\n#include <netinet/in.h>\n\n#include <errno.h>\n#include <event.h>\n#include <imsg.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"smtpd.h\"\n#include \"log.h\"\n\n#define\tPROTOCOL_VERSION\t\"0.6\"\n\nstruct filter;\nstruct filter_session;\nstatic void\tfilter_protocol_internal(struct filter_session *, uint64_t *, uint64_t, enum filter_phase, const char *);\nstatic void\tfilter_protocol(uint64_t, enum filter_phase, const char *);\nstatic void\tfilter_protocol_next(uint64_t, uint64_t, enum filter_phase);\nstatic void\tfilter_protocol_query(struct filter *, uint64_t, uint64_t, const char *, const char *);\n\nstatic void\tfilter_data_internal(struct filter_session *, uint64_t, uint64_t, const char *);\nstatic void\tfilter_data(uint64_t, const char *);\nstatic void\tfilter_data_next(uint64_t, uint64_t, const char *);\nstatic void\tfilter_data_query(struct filter *, uint64_t, uint64_t, const char *);\n\nstatic int\tfilter_builtins_notimpl(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_connect(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_helo(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_mail_from(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_rcpt_to(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_data(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_commit(struct filter_session *, struct filter *, uint64_t, const char *);\n\nstatic void\tfilter_result_proceed(uint64_t);\nstatic void\tfilter_result_junk(uint64_t);\nstatic void\tfilter_result_rewrite(uint64_t, const char *);\nstatic void\tfilter_result_reject(uint64_t, const char *);\nstatic void\tfilter_result_disconnect(uint64_t, const char *);\n\nstatic void\tfilter_session_io(struct io *, int, void *);\nvoid\t\tlka_filter_process_response(const char *, const char *);\n\n\nstruct filter_session {\n\tuint64_t\tid;\n\tstruct io\t*io;\n\n\tchar *lastparam;\n\n\tchar *filter_name;\n\tstruct sockaddr_storage ss_src;\n\tstruct sockaddr_storage ss_dest;\n\tchar *rdns;\n\tint fcrdns;\n\n\tchar *helo;\n\tchar *username;\n\tchar *mail_from;\n\t\n\tenum filter_phase\tphase;\n};\n\nstatic struct filter_exec {\n\tenum filter_phase\tphase;\n\tconst char\t       *phase_name;\n\tint\t\t       (*func)(struct filter_session *, struct filter *, uint64_t, const char *);\n} filter_execs[FILTER_PHASES_COUNT] = {\n\t{ FILTER_CONNECT,\t\"connect\",\tfilter_builtins_connect },\n\t{ FILTER_HELO,\t\t\"helo\",\t\tfilter_builtins_helo },\n\t{ FILTER_EHLO,\t\t\"ehlo\",\t\tfilter_builtins_helo },\n\t{ FILTER_STARTTLS,     \t\"starttls\",\tfilter_builtins_notimpl },\n\t{ FILTER_AUTH,     \t\"auth\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_MAIL_FROM,    \t\"mail-from\",\tfilter_builtins_mail_from },\n\t{ FILTER_RCPT_TO,    \t\"rcpt-to\",\tfilter_builtins_rcpt_to },\n\t{ FILTER_DATA,    \t\"data\",\t\tfilter_builtins_data },\n\t{ FILTER_DATA_LINE,    \t\"data-line\",   \tfilter_builtins_notimpl },\n\t{ FILTER_RSET,    \t\"rset\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_QUIT,    \t\"quit\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_NOOP,    \t\"noop\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_HELP,    \t\"help\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_WIZ,    \t\"wiz\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_COMMIT,    \t\"commit\",      \tfilter_builtins_commit },\n};\n\nstruct filter {\n\tuint64_t\t\tid;\n\tuint32_t\t\tphases;\n\tconst char\t       *name;\n\tconst char\t       *proc;\n\tstruct filter  \t      **chain;\n\tsize_t \t\t\tchain_size;\n\tstruct filter_config   *config;\n};\nstatic struct dict filters;\n\nstruct filter_entry {\n\tTAILQ_ENTRY(filter_entry)\tentries;\n\tuint64_t\t\t\tid;\n\tconst char\t\t       *name;\n};\n\nstruct filter_chain {\n\tTAILQ_HEAD(, filter_entry)\t\tchain[nitems(filter_execs)];\n};\n\nstatic struct dict\tfilter_smtp_in;\n\nstatic struct tree\tsessions;\nstatic int\t\tfilters_inited;\n\nstatic struct dict\tfilter_chains;\n\nstruct reporter_proc {\n\tTAILQ_ENTRY(reporter_proc)\tentries;\n\tconst char\t\t       *name;\n};\nTAILQ_HEAD(reporters, reporter_proc);\n\nstatic struct dict\treport_smtp_in;\nstatic struct dict\treport_smtp_out;\n\nstatic struct smtp_events {\n\tconst char     *event;\n} smtp_events[] = {\n\t{ \"link-connect\" },\n\t{ \"link-disconnect\" },\n\t{ \"link-greeting\" },\n\t{ \"link-identify\" },\n\t{ \"link-tls\" },\n\t{ \"link-auth\" },\n\n\t{ \"tx-reset\" },\n\t{ \"tx-begin\" },\n\t{ \"tx-mail\" },\n\t{ \"tx-rcpt\" },\n\t{ \"tx-envelope\" },\n\t{ \"tx-data\" },\n\t{ \"tx-commit\" },\n\t{ \"tx-rollback\" },\n\n\t{ \"protocol-client\" },\n\t{ \"protocol-server\" },\n\n\t{ \"filter-report\" },\n\t{ \"filter-response\" },\n\n\t{ \"timeout\" },\n};\n\nstatic int\t\t\tprocessors_inited = 0;\nstatic struct dict\t\tprocessors;\n\nstruct processor_instance {\n\tchar\t\t\t*name;\n\tstruct io\t\t*io;\n\tstruct io\t\t*errfd;\n\tint\t\t\t ready;\n\tuint32_t\t\t subsystems;\n};\n\nstatic void\tprocessor_io(struct io *, int, void *);\nstatic void\tprocessor_errfd(struct io *, int, void *);\nvoid\t\tlka_filter_process_response(const char *, const char *);\n\nint\nlka_proc_ready(void)\n{\n\tvoid\t*iter;\n\tstruct processor_instance\t*pi;\n\n\titer = NULL;\n\twhile (dict_iter(&processors, &iter, NULL, (void **)&pi))\n\t\tif (!pi->ready)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic void\nlka_proc_config(struct processor_instance *pi)\n{\n\tio_printf(pi->io, \"config|smtpd-version|%s\\n\", SMTPD_VERSION);\n\tio_printf(pi->io, \"config|smtp-session-timeout|%d\\n\", SMTPD_SESSION_TIMEOUT);\n\tif (pi->subsystems & FILTER_SUBSYSTEM_SMTP_IN)\n\t\tio_printf(pi->io, \"config|subsystem|smtp-in\\n\");\n\tif (pi->subsystems & FILTER_SUBSYSTEM_SMTP_OUT)\n\t\tio_printf(pi->io, \"config|subsystem|smtp-out\\n\");\n\tio_printf(pi->io, \"config|admd|%s\\n\",\n\t    env->sc_admd != NULL ? env->sc_admd : env->sc_hostname);\n\tio_printf(pi->io, \"config|ready\\n\");\n}\n\nvoid\nlka_proc_forked(const char *name, uint32_t subsystems, int fd)\n{\n\tstruct processor_instance\t*processor;\n\n\tif (!processors_inited) {\n\t\tdict_init(&processors);\n\t\tprocessors_inited = 1;\n\t}\n\n\tprocessor = xcalloc(1, sizeof *processor);\n\tprocessor->name = xstrdup(name);\n\tprocessor->io = io_new();\n\tprocessor->subsystems = subsystems;\n\n\tio_set_nonblocking(fd);\n\n\tio_set_fd(processor->io, fd);\n\tio_set_callback(processor->io, processor_io, processor->name);\n\tdict_xset(&processors, name, processor);\n}\n\nvoid\nlka_proc_errfd(const char *name, int fd)\n{\n\tstruct processor_instance\t*processor;\n\n\tprocessor = dict_xget(&processors, name);\n\n\tio_set_nonblocking(fd);\n\n\tprocessor->errfd = io_new();\n\tio_set_fd(processor->errfd, fd);\n\tio_set_callback(processor->errfd, processor_errfd, processor->name);\n\n\tlka_proc_config(processor);\n}\n\nstruct io *\nlka_proc_get_io(const char *name)\n{\n\tstruct processor_instance *processor;\n\n\tprocessor = dict_xget(&processors, name);\n\n\treturn processor->io;\n}\n\nstatic void\nprocessor_register(const char *name, const char *line)\n{\n\tstruct processor_instance *processor;\n\n\tprocessor = dict_xget(&processors, name);\n\n\tif (strcmp(line, \"register|ready\") == 0) {\n\t\tprocessor->ready = 1;\n\t\treturn;\n\t}\n\n\tif (strncmp(line, \"register|report|\", 16) == 0) {\n\t\tlka_report_register_hook(name, line+16);\n\t\treturn;\n\t}\n\n\tif (strncmp(line, \"register|filter|\", 16) == 0) {\n\t\tlka_filter_register_hook(name, line+16);\n\t\treturn;\n\t}\n\n\tfatalx(\"Invalid register line received: %s\", line);\n}\n\nstatic void\nprocessor_io(struct io *io, int evt, void *arg)\n{\n\tstruct processor_instance *processor;\n\tconst char\t\t*name = arg;\n\tchar\t\t\t*line = NULL;\n\tssize_t\t\t\t len;\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\t\twhile ((line = io_getline(io, &len)) != NULL) {\n\t\t\tif (strncmp(\"register|\", line, 9) == 0) {\n\t\t\t\tprocessor_register(name, line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tprocessor = dict_xget(&processors, name);\n\t\t\tif (!processor->ready)\n\t\t\t\tfatalx(\"Non-register message before register|\"\n\t\t\t\t    \"ready: %s\", line);\n\t\t\telse if (strncmp(line, \"filter-result|\", 14) == 0 ||\n\t\t\t    strncmp(line, \"filter-dataline|\", 16) == 0)\n\t\t\t\tlka_filter_process_response(name, line);\n\t\t\telse if (strncmp(line, \"report|\", 7) == 0)\n\t\t\t\tlka_report_proc(name, line);\n\t\t\telse\n\t\t\t\tfatalx(\"Invalid filter message type: %s\", line);\n\t\t}\n\t}\n}\n\nstatic void\nprocessor_errfd(struct io *io, int evt, void *arg)\n{\n\tconst char\t*name = arg;\n\tchar\t\t*line = NULL;\n\tssize_t\t\t len;\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\t\twhile ((line = io_getline(io, &len)) != NULL)\n\t\t\tlog_warnx(\"%s: %s\", name, line);\n\t}\n}\n\nvoid\nlka_filter_init(void)\n{\n\tvoid\t\t*iter;\n\tconst char\t*name;\n\tstruct filter  \t*filter;\n\tstruct filter_config\t*filter_config;\n\tsize_t\t\ti;\n\tchar\t\t buffer[LINE_MAX];\t/* for traces */\n\n\tdict_init(&filters);\n\tdict_init(&filter_chains);\n\n\t/* first pass, allocate and init individual filters */\n\titer = NULL;\n\twhile (dict_iter(env->sc_filters_dict, &iter, &name, (void **)&filter_config)) {\n\t\tswitch (filter_config->filter_type) {\n\t\tcase FILTER_TYPE_BUILTIN:\n\t\t\tfilter = xcalloc(1, sizeof(*filter));\n\t\t\tfilter->name = name;\n\t\t\tfilter->phases |= (1<<filter_config->phase);\n\t\t\tfilter->config = filter_config;\n\t\t\tdict_set(&filters, name, filter);\n\t\t\tlog_trace(TRACE_FILTERS, \"filters init type=builtin, name=%s, hooks=%08x\",\n\t\t\t    name, filter->phases);\n\t\t\tbreak;\n\n\t\tcase FILTER_TYPE_PROC:\n\t\t\tfilter = xcalloc(1, sizeof(*filter));\n\t\t\tfilter->name = name;\n\t\t\tfilter->proc = filter_config->proc;\n\t\t\tfilter->config = filter_config;\n\t\t\tdict_set(&filters, name, filter);\n\t\t\tlog_trace(TRACE_FILTERS, \"filters init type=proc, name=%s, proc=%s\",\n\t\t\t    name, filter_config->proc);\n\t\t\tbreak;\n\n\t\tcase FILTER_TYPE_CHAIN:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* second pass, allocate and init filter chains but don't build yet */\n\titer = NULL;\n\twhile (dict_iter(env->sc_filters_dict, &iter, &name, (void **)&filter_config)) {\n\t\tswitch (filter_config->filter_type) {\n\t\tcase FILTER_TYPE_CHAIN:\n\t\t\tfilter = xcalloc(1, sizeof(*filter));\n\t\t\tfilter->name = name;\n\t\t\tfilter->chain = xcalloc(filter_config->chain_size, sizeof(void **));\n\t\t\tfilter->chain_size = filter_config->chain_size;\n\t\t\tfilter->config = filter_config;\n\n\t\t\tbuffer[0] = '\\0';\n\t\t\tfor (i = 0; i < filter->chain_size; ++i) {\n\t\t\t\tfilter->chain[i] = dict_xget(&filters, filter_config->chain[i]);\n\t\t\t\tif (i)\n\t\t\t\t\t(void)strlcat(buffer, \", \", sizeof buffer);\n\t\t\t\t(void)strlcat(buffer, filter->chain[i]->name, sizeof buffer);\n\t\t\t}\n\t\t\tlog_trace(TRACE_FILTERS, \"filters init type=chain, name=%s { %s }\", name, buffer);\n\n\t\t\tdict_set(&filters, name, filter);\n\t\t\tbreak;\n\n\t\tcase FILTER_TYPE_BUILTIN:\n\t\tcase FILTER_TYPE_PROC:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid\nlka_filter_register_hook(const char *name, const char *hook)\n{\n\tstruct dict\t\t*subsystem;\n\tstruct filter\t\t*filter;\n\tconst char\t*filter_name;\n\tvoid\t\t*iter;\n\tsize_t\ti;\n\n\tif (strncasecmp(hook, \"smtp-in|\", 8) == 0) {\n\t\tsubsystem = &filter_smtp_in;\n\t\thook += 8;\n\t}\n\telse\n\t\tfatalx(\"Invalid message direction: %s\", hook);\n\n\tfor (i = 0; i < nitems(filter_execs); i++)\n\t\tif (strcmp(hook, filter_execs[i].phase_name) == 0)\n\t\t\tbreak;\n\tif (i == nitems(filter_execs))\n\t\tfatalx(\"Unrecognized report name: %s\", hook);\n\n\titer = NULL;\n\twhile (dict_iter(&filters, &iter, &filter_name, (void **)&filter))\n\t\tif (filter->proc && strcmp(name, filter->proc) == 0)\n\t\t\tfilter->phases |= (1<<filter_execs[i].phase);\n}\n\nvoid\nlka_filter_ready(void)\n{\n\tstruct filter  \t*filter;\n\tstruct filter  \t*subfilter;\n\tconst char\t*filter_name;\n\tstruct filter_entry\t*filter_entry;\n\tstruct filter_chain\t*filter_chain;\n\tvoid\t\t*iter;\n\tsize_t\t\ti;\n\tsize_t\t\tj;\n\n\t/* all filters are ready, actually build the filter chains */\n\titer = NULL;\n\twhile (dict_iter(&filters, &iter, &filter_name, (void **)&filter)) {\n\t\tfilter_chain = xcalloc(1, sizeof *filter_chain);\n\t\tfor (i = 0; i < nitems(filter_execs); i++)\n\t\t\tTAILQ_INIT(&filter_chain->chain[i]);\n\t\tdict_set(&filter_chains, filter_name, filter_chain);\n\n\t\tif (filter->chain) {\n\t\t\tfor (i = 0; i < filter->chain_size; i++) {\n\t\t\t\tsubfilter = filter->chain[i];\n\t\t\t\tfor (j = 0; j < nitems(filter_execs); ++j) {\n\t\t\t\t\tif (subfilter->phases & (1<<j)) {\n\t\t\t\t\t\tfilter_entry = xcalloc(1, sizeof *filter_entry);\n\t\t\t\t\t\tfilter_entry->id = generate_uid();\n\t\t\t\t\t\tfilter_entry->name = subfilter->name;\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&filter_chain->chain[j],\n\t\t\t\t\t\t    filter_entry, entries);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < nitems(filter_execs); ++i) {\n\t\t\tif (filter->phases & (1<<i)) {\n\t\t\t\tfilter_entry = xcalloc(1, sizeof *filter_entry);\n\t\t\t\tfilter_entry->id = generate_uid();\n\t\t\t\tfilter_entry->name = filter_name;\n\t\t\t\tTAILQ_INSERT_TAIL(&filter_chain->chain[i],\n\t\t\t\t    filter_entry, entries);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\nlka_filter_proc_in_session(uint64_t reqid, const char *proc)\n{\n\tstruct filter_session\t*fs;\n\tstruct filter\t\t*filter;\n\tsize_t\t\t\t i;\n\n\tif ((fs = tree_get(&sessions, reqid)) == NULL)\n\t\treturn 0;\n\n\tfilter = dict_get(&filters, fs->filter_name);\n\tif (filter == NULL || (filter->proc == NULL && filter->chain == NULL))\n\t\treturn 0;\n\n\tif (filter->proc)\n\t\treturn strcmp(filter->proc, proc) == 0 ? 1 : 0;\n\n\tfor (i = 0; i < filter->chain_size; i++)\n\t\tif (filter->chain[i]->proc &&\n\t\t    strcmp(filter->chain[i]->proc, proc) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid\nlka_filter_begin(uint64_t reqid, const char *filter_name)\n{\n\tstruct filter_session\t*fs;\n\n\tif (!filters_inited) {\n\t\ttree_init(&sessions);\n\t\tfilters_inited = 1;\n\t}\n\n\tfs = xcalloc(1, sizeof (struct filter_session));\n\tfs->id = reqid;\n\tfs->filter_name = xstrdup(filter_name);\n\ttree_xset(&sessions, fs->id, fs);\n\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters session-begin\", reqid);\n}\n\nvoid\nlka_filter_end(uint64_t reqid)\n{\n\tstruct filter_session\t*fs;\n\n\tfs = tree_xpop(&sessions, reqid);\n\tfree(fs->rdns);\n\tfree(fs->helo);\n\tfree(fs->mail_from);\n\tfree(fs->username);\n\tfree(fs->lastparam);\n\tfree(fs->filter_name);\n\tfree(fs);\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters session-end\", reqid);\n}\n\nvoid\nlka_filter_data_begin(uint64_t reqid)\n{\n\tstruct filter_session  *fs;\n\tint\tsp[2];\n\tint\tfd = -1;\n\n\tfs = tree_xget(&sessions, reqid);\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sp) == -1)\n\t\tgoto end;\n\tio_set_nonblocking(sp[0]);\n\tio_set_nonblocking(sp[1]);\n\tfd = sp[0];\n\tfs->io = io_new();\n\tio_set_fd(fs->io, sp[1]);\n\tio_set_callback(fs->io, filter_session_io, fs);\n\nend:\n\tm_create(p_pony, IMSG_FILTER_SMTP_DATA_BEGIN, 0, 0, fd);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, fd != -1 ? 1 : 0);\n\tm_close(p_pony);\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters data-begin fd=%d\", reqid, fd);\n}\n\nvoid\nlka_filter_data_end(uint64_t reqid)\n{\n\tstruct filter_session\t*fs;\n\n\tfs = tree_xget(&sessions, reqid);\n\tif (fs->io) {\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t}\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters data-end\", reqid);\n}\n\nstatic void\nfilter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tfilter_data(fs->id, line);\n\n\t\tgoto nextline;\n\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}\n\nvoid\nlka_filter_process_response(const char *name, const char *line)\n{\n\tuint64_t reqid;\n\tuint64_t token;\n\tchar buffer[LINE_MAX];\n\tchar *ep = NULL;\n\tchar *kind = NULL;\n\tchar *qid = NULL;\n\t/*char *phase = NULL;*/\n\tchar *response = NULL;\n\tchar *parameter = NULL;\n\tstruct filter_session *fs;\n\n\t(void)strlcpy(buffer, line, sizeof buffer);\n\tif ((ep = strchr(buffer, '|')) == NULL)\n\t\tfatalx(\"Missing token: %s\", line);\n\tep[0] = '\\0';\n\n\tkind = buffer;\n\n\tqid = ep+1;\n\tif ((ep = strchr(qid, '|')) == NULL)\n\t\tfatalx(\"Missing reqid: %s\", line);\n\tep[0] = '\\0';\n\n\treqid = strtoull(qid, &ep, 16);\n\tif (qid[0] == '\\0' || *ep != '\\0')\n\t\tfatalx(\"Invalid reqid: %s\", line);\n\tif (errno == ERANGE && reqid == ULLONG_MAX)\n\t\tfatal(\"Invalid reqid: %s\", line);\n\n\tqid = ep+1;\n\tif ((ep = strchr(qid, '|')) == NULL)\n\t\tfatal(\"Missing directive: %s\", line);\n\tep[0] = '\\0';\n\n\ttoken = strtoull(qid, &ep, 16);\n\tif (qid[0] == '\\0' || *ep != '\\0')\n\t\tfatalx(\"Invalid token: %s\", line);\n\tif (errno == ERANGE && token == ULLONG_MAX)\n\t\tfatal(\"Invalid token: %s\", line);\n\n\tresponse = ep+1;\n\n\t/* session can legitimately disappear on a resume */\n\tif ((fs = tree_get(&sessions, reqid)) == NULL)\n\t\treturn;\n\n\tif (strcmp(kind, \"filter-dataline\") == 0) {\n\t\tif (fs->phase != FILTER_DATA_LINE)\n\t\t\tfatalx(\"filter-dataline out of dataline phase\");\n\t\tfilter_data_next(token, reqid, response);\n\t\treturn;\n\t}\n\tif (fs->phase == FILTER_DATA_LINE)\n\t\tfatalx(\"filter-result in dataline phase\");\n\n\tif ((ep = strchr(response, '|'))) {\n\t\tparameter = ep + 1;\n\t\tep[0] = '\\0';\n\t}\n\n\tif (strcmp(response, \"proceed\") == 0) {\n\t\tif (parameter != NULL)\n\t\t\tfatalx(\"Unexpected parameter after proceed: %s\", line);\n\t\tfilter_protocol_next(token, reqid, 0);\n\t\treturn;\n\t} else if (strcmp(response, \"junk\") == 0) {\n\t\tif (parameter != NULL)\n\t\t\tfatalx(\"Unexpected parameter after junk: %s\", line);\n\t\tif (fs->phase == FILTER_COMMIT)\n\t\t\tfatalx(\"filter-reponse junk after DATA\");\n\t\tfilter_result_junk(reqid);\n\t\treturn;\n\t} else {\n\t\tif (parameter == NULL)\n\t\t\tfatalx(\"Missing parameter: %s\", line);\n\n\t\tif (strcmp(response, \"rewrite\") == 0)\n\t\t\tfilter_result_rewrite(reqid, parameter);\n\t\telse if (strcmp(response, \"reject\") == 0)\n\t\t\tfilter_result_reject(reqid, parameter);\n\t\telse if (strcmp(response, \"disconnect\") == 0)\n\t\t\tfilter_result_disconnect(reqid, parameter);\n\t\telse\n\t\t\tfatalx(\"Invalid directive: %s\", line);\n\t}\n}\n\nvoid\nlka_filter_protocol(uint64_t reqid, enum filter_phase phase, const char *param)\n{\n\tfilter_protocol(reqid, phase, param);\n}\n\nstatic void\nfilter_protocol_internal(struct filter_session *fs, uint64_t *token, uint64_t reqid, enum filter_phase phase, const char *param)\n{\n\tstruct filter_chain\t*filter_chain;\n\tstruct filter_entry\t*filter_entry;\n\tstruct filter\t\t*filter;\n\tstruct timeval\t\t tv;\n\tconst char\t\t*phase_name = filter_execs[phase].phase_name;\n\tint\t\t\t resume = 1;\n\n\tif (!*token) {\n\t\tfs->phase = phase;\n\t\tresume = 0;\n\t}\n\n\t/* XXX - this sanity check requires a protocol change, stub for now */\n\tphase = fs->phase;\n\tif (fs->phase != phase)\n\t\tfatalx(\"misbehaving filter\");\n\n\t/* based on token, identify the filter_entry we should apply  */\n\tfilter_chain = dict_get(&filter_chains, fs->filter_name);\n\tfilter_entry = TAILQ_FIRST(&filter_chain->chain[fs->phase]);\n\tif (*token) {\n\t\tTAILQ_FOREACH(filter_entry, &filter_chain->chain[fs->phase], entries)\n\t\t    if (filter_entry->id == *token)\n\t\t\t    break;\n\t\tif (filter_entry == NULL)\n\t\t\tfatalx(\"misbehaving filter\");\n\t\tfilter_entry = TAILQ_NEXT(filter_entry, entries);\n\t}\n\n\t/* no filter_entry, we either had none or reached end of chain */\n\tif (filter_entry == NULL) {\n\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, resume=%s, \"\n\t\t    \"action=proceed\",\n\t\t    fs->id, phase_name, resume ? \"y\" : \"n\");\n\t\tfilter_result_proceed(reqid);\n\t\treturn;\n\t}\n\n\t/* process param with current filter_entry */\n\t*token = filter_entry->id;\n\tfilter = dict_get(&filters, filter_entry->name);\n\tif (filter->proc) {\n\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t    \"resume=%s, action=deferred, filter=%s\",\n\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t    filter->name);\n\t\tfilter_protocol_query(filter, filter_entry->id, reqid,\n\t\t    filter_execs[fs->phase].phase_name, param);\n\t\treturn;\t/* deferred response */\n\t}\n\n\tif (filter_execs[fs->phase].func(fs, filter, reqid, param)) {\n\t\tif (filter->config->rewrite) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=rewrite, filter=%s, query=%s, response=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param,\n\t\t\t    filter->config->rewrite);\n\t\t\t    filter_result_rewrite(reqid, filter->config->rewrite);\n\t\t\treturn;\n\t\t}\n\t\telse if (filter->config->disconnect) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=disconnect, filter=%s, query=%s, response=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param,\n\t\t\t    filter->config->disconnect);\n\t\t\tfilter_result_disconnect(reqid, filter->config->disconnect);\n\t\t\treturn;\n\t\t}\n\t\telse if (filter->config->junk) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=junk, filter=%s, query=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param);\n\t\t\tfilter_result_junk(reqid);\n\t\t\treturn;\n\t\t} else if (filter->config->report) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=report, filter=%s, query=%s response=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param, filter->config->report);\n\n\t\t\tgettimeofday(&tv, NULL);\n\t\t\tlka_report_filter_report(fs->id, filter->name, 1,\n\t\t\t    \"smtp-in\", &tv, filter->config->report);\n\t\t} else if (filter->config->bypass) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=bypass, filter=%s, query=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param);\n\t\t\tfilter_result_proceed(reqid);\n\t\t\treturn;\n\t\t} else {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=reject, filter=%s, query=%s, response=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param,\n\t\t\t    filter->config->reject);\n\t\t\tfilter_result_reject(reqid, filter->config->reject);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t    \"resume=%s, action=proceed, filter=%s, query=%s\",\n\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t    filter->name,\n\t    param);\n\n\t/* filter_entry resulted in proceed, try next filter */\n\tfilter_protocol_internal(fs, token, reqid, phase, param);\n\treturn;\n}\n\nstatic void\nfilter_data_internal(struct filter_session *fs, uint64_t token, uint64_t reqid, const char *line)\n{\n\tstruct filter_chain\t*filter_chain;\n\tstruct filter_entry\t*filter_entry;\n\tstruct filter\t\t*filter;\n\n\tif (!token)\n\t\tfs->phase = FILTER_DATA_LINE;\n\tif (fs->phase != FILTER_DATA_LINE)\n\t\tfatalx(\"misbehaving filter\");\n\n\t/* based on token, identify the filter_entry we should apply  */\n\tfilter_chain = dict_get(&filter_chains, fs->filter_name);\n\tfilter_entry = TAILQ_FIRST(&filter_chain->chain[fs->phase]);\n\tif (token) {\n\t\tTAILQ_FOREACH(filter_entry, &filter_chain->chain[fs->phase], entries)\n\t\t    if (filter_entry->id == token)\n\t\t\t    break;\n\t\tif (filter_entry == NULL)\n\t\t\tfatalx(\"misbehaving filter\");\n\t\tfilter_entry = TAILQ_NEXT(filter_entry, entries);\n\t}\n\n\t/* no filter_entry, we either had none or reached end of chain */\n\tif (filter_entry == NULL) {\n\t\tio_printf(fs->io, \"%s\\n\", line);\n\t\treturn;\n\t}\n\n\t/* pass data to the filter */\n\tfilter = dict_get(&filters, filter_entry->name);\n\tfilter_data_query(filter, filter_entry->id, reqid, line);\n}\n\nstatic void\nfilter_protocol(uint64_t reqid, enum filter_phase phase, const char *param)\n{\n\tstruct filter_session  *fs;\n\tuint64_t\t\ttoken = 0;\n\tchar\t\t       *nparam = NULL;\n\t\n\tfs = tree_xget(&sessions, reqid);\n\n\tswitch (phase) {\n\tcase FILTER_HELO:\n\tcase FILTER_EHLO:\n\t\tfree(fs->helo);\n\t\tfs->helo = xstrdup(param);\n\t\tbreak;\n\tcase FILTER_MAIL_FROM:\n\t\tfree(fs->mail_from);\n\t\tfs->mail_from = xstrdup(param + 1);\n\t\t*strchr(fs->mail_from, '>') = '\\0';\n\t\tparam = fs->mail_from;\n\n\t\tbreak;\n\tcase FILTER_RCPT_TO:\n\t\tnparam = xstrdup(param + 1);\n\t\t*strchr(nparam, '>') = '\\0';\n\t\tparam = nparam;\n\t\tbreak;\n\tcase FILTER_STARTTLS:\n\t\t/* TBD */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfree(fs->lastparam);\n\tfs->lastparam = xstrdup(param);\n\n\tfilter_protocol_internal(fs, &token, reqid, phase, param);\n\tif (nparam)\n\t\tfree(nparam);\n}\n\nstatic void\nfilter_protocol_next(uint64_t token, uint64_t reqid, enum filter_phase phase)\n{\n\tstruct filter_session  *fs;\n\n\t/* session can legitimately disappear on a resume */\n\tif ((fs = tree_get(&sessions, reqid)) == NULL)\n\t\treturn;\n\n\tfilter_protocol_internal(fs, &token, reqid, phase, fs->lastparam);\n}\n\nstatic void\nfilter_data(uint64_t reqid, const char *line)\n{\n\tstruct filter_session  *fs;\n\n\tfs = tree_xget(&sessions, reqid);\n\n\tfilter_data_internal(fs, 0, reqid, line);\n}\n\nstatic void\nfilter_data_next(uint64_t token, uint64_t reqid, const char *line)\n{\n\tstruct filter_session  *fs;\n\n\t/* session can legitimately disappear on a resume */\n\tif ((fs = tree_get(&sessions, reqid)) == NULL)\n\t\treturn;\n\n\tfilter_data_internal(fs, token, reqid, line);\n}\n\nstatic void\nfilter_protocol_query(struct filter *filter, uint64_t token, uint64_t reqid, const char *phase, const char *param)\n{\n\tint\tn;\n\tstruct filter_session\t*fs;\n\tstruct timeval\ttv;\n\n\tgettimeofday(&tv, NULL);\n\t\n\tfs = tree_xget(&sessions, reqid);\n\tif (strcmp(phase, \"connect\") == 0)\n\t\tn = io_printf(lka_proc_get_io(filter->proc),\n\t\t    \"filter|%s|%lld.%06ld|smtp-in|%s|%016\"PRIx64\"|%016\"PRIx64\"|%s|%s\\n\",\n\t\t    PROTOCOL_VERSION,\n\t\t    tv.tv_sec, tv.tv_usec,\n\t\t    phase, reqid, token, fs->rdns, param);\n\telse\n\t\tn = io_printf(lka_proc_get_io(filter->proc),\n\t\t    \"filter|%s|%lld.%06ld|smtp-in|%s|%016\"PRIx64\"|%016\"PRIx64\"|%s\\n\",\n\t\t    PROTOCOL_VERSION,\n\t\t    tv.tv_sec, tv.tv_usec,\n\t\t    phase, reqid, token, param);\n\tif (n == -1)\n\t\tfatalx(\"failed to write to processor\");\n}\n\nstatic void\nfilter_data_query(struct filter *filter, uint64_t token, uint64_t reqid, const char *line)\n{\n\tint\tn;\n\tstruct timeval\ttv;\n\n\tgettimeofday(&tv, NULL);\n\n\tn = io_printf(lka_proc_get_io(filter->proc),\n\t    \"filter|%s|%lld.%06ld|smtp-in|data-line|\"\n\t    \"%016\"PRIx64\"|%016\"PRIx64\"|%s\\n\",\n\t    PROTOCOL_VERSION,\n\t    tv.tv_sec, tv.tv_usec,\n\t    reqid, token, line);\n\tif (n == -1)\n\t\tfatalx(\"failed to write to processor\");\n}\n\nstatic void\nfilter_result_proceed(uint64_t reqid)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_PROCEED);\n\tm_close(p_pony);\n}\n\nstatic void\nfilter_result_junk(uint64_t reqid)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_JUNK);\n\tm_close(p_pony);\n}\n\nstatic void\nfilter_result_rewrite(uint64_t reqid, const char *param)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_REWRITE);\n\tm_add_string(p_pony, param);\n\tm_close(p_pony);\n}\n\nstatic void\nfilter_result_reject(uint64_t reqid, const char *message)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_REJECT);\n\tm_add_string(p_pony, message);\n\tm_close(p_pony);\n}\n\nstatic void\nfilter_result_disconnect(uint64_t reqid, const char *message)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_DISCONNECT);\n\tm_add_string(p_pony, message);\n\tm_close(p_pony);\n}\n\n\n/* below is code for builtin filters */\n\nstatic int\nfilter_check_rdns_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->rdns_table == NULL)\n\t\treturn 0;\n\t\n\tif (table_match(filter->config->rdns_table, kind, key) > 0)\n\t\tret = 1;\n\n\treturn filter->config->not_rdns_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_rdns_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->rdns_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->rdns_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_rdns_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_src_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->src_table == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->src_table, kind, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_src_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_src_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->src_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->src_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_src_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_helo_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->helo_table == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->helo_table, kind, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_helo_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_helo_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->helo_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->helo_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_helo_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_auth(struct filter *filter, const char *username)\n{\n\tint ret = 0;\n\n\tif (!filter->config->auth)\n\t\treturn 0;\n\n\tret = username ? 1 : 0;\n\n\treturn filter->config->not_auth < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_auth_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->auth_table == NULL)\n\t\treturn 0;\n\t\n\tif (key && table_match(filter->config->auth_table, kind, key) > 0)\n\t\tret = 1;\n\n\treturn filter->config->not_auth_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_auth_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->auth_regex == NULL)\n\t\treturn 0;\n\n\tif (key && table_match(filter->config->auth_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_auth_regex < 0 ? !ret : ret;\n}\n\n\nstatic int\nfilter_check_mail_from_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->mail_from_table == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->mail_from_table, kind, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_mail_from_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_mail_from_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->mail_from_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->mail_from_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_mail_from_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_rcpt_to_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->rcpt_to_table == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->rcpt_to_table, kind, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_rcpt_to_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_rcpt_to_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->rcpt_to_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->rcpt_to_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_rcpt_to_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_fcrdns(struct filter *filter, int fcrdns)\n{\n\tint\tret = 0;\n\n\tif (!filter->config->fcrdns)\n\t\treturn 0;\n\n\tret = fcrdns == 1;\n\treturn filter->config->not_fcrdns < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_rdns(struct filter *filter, const char *hostname)\n{\n\tint\tret = 0;\n\tstruct netaddr\tnetaddr;\n\n\tif (!filter->config->rdns)\n\t\treturn 0;\n\n\t/* this is a hack until smtp session properly deals with lack of rdns */\n\tret = strcmp(\"<unknown>\", hostname);\n\tif (ret == 0)\n\t\treturn filter->config->not_rdns < 0 ? !ret : ret;\n\n\t/* if text_to_netaddress succeeds,\n\t * we don't have an rDNS so the filter should match\n\t */\n\tret = !text_to_netaddr(&netaddr, hostname);\n\treturn filter->config->not_rdns < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_builtins_notimpl(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn 0;\n}\n\nstatic int\nfilter_builtins_global(struct filter_session *fs, struct filter *filter, uint64_t reqid)\n{\n\treturn filter_check_fcrdns(filter, fs->fcrdns) ||\n\t    filter_check_rdns(filter, fs->rdns) ||\n\t    filter_check_rdns_table(filter, K_DOMAIN, fs->rdns) ||\n\t    filter_check_rdns_regex(filter, fs->rdns) ||\n\t    filter_check_src_table(filter, K_NETADDR, ss_to_text(&fs->ss_src)) ||\n\t    filter_check_src_regex(filter, ss_to_text(&fs->ss_src)) ||\n\t    filter_check_helo_table(filter, K_DOMAIN, fs->helo) ||\n\t    filter_check_helo_regex(filter, fs->helo) ||\n\t    filter_check_auth(filter, fs->username) ||\n\t    filter_check_auth_table(filter, K_STRING, fs->username) ||\n\t    filter_check_auth_table(filter, K_CREDENTIALS, fs->username) ||\n\t    filter_check_auth_regex(filter, fs->username) ||\n\t    filter_check_mail_from_table(filter, K_MAILADDR, fs->mail_from) ||\n\t    filter_check_mail_from_regex(filter, fs->mail_from);\n}\n\nstatic int\nfilter_builtins_connect(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic int\nfilter_builtins_helo(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic int\nfilter_builtins_mail_from(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic int\nfilter_builtins_rcpt_to(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid) ||\n\t    filter_check_rcpt_to_table(filter, K_MAILADDR, param) ||\n\t    filter_check_rcpt_to_regex(filter, param);\n}\n\nstatic int\nfilter_builtins_data(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic int\nfilter_builtins_commit(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic void\nreport_smtp_broadcast(uint64_t, const char *, struct timeval *, const char *,\n    const char *, ...) __attribute__((__format__ (printf, 5, 6)));\n\nvoid\nlka_report_init(void)\n{\n\tstruct reporters\t*tailq;\n\tsize_t\t\t\t i;\n\n\tdict_init(&report_smtp_in);\n\tdict_init(&report_smtp_out);\n\n\tfor (i = 0; i < nitems(smtp_events); ++i) {\n\t\ttailq = xcalloc(1, sizeof (struct reporters));\n\t\tTAILQ_INIT(tailq);\n\t\tdict_xset(&report_smtp_in, smtp_events[i].event, tailq);\n\n\t\ttailq = xcalloc(1, sizeof (struct reporters));\n\t\tTAILQ_INIT(tailq);\n\t\tdict_xset(&report_smtp_out, smtp_events[i].event, tailq);\n\t}\n}\n\nvoid\nlka_report_register_hook(const char *name, const char *hook)\n{\n\tstruct dict\t*subsystem;\n\tstruct reporter_proc\t*rp;\n\tstruct reporters\t*tailq;\n\tvoid *iter;\n\tsize_t\ti;\n\n\tif (strncmp(hook, \"smtp-in|\", 8) == 0) {\n\t\tsubsystem = &report_smtp_in;\n\t\thook += 8;\n\t}\n\telse if (strncmp(hook, \"smtp-out|\", 9) == 0) {\n\t\tsubsystem = &report_smtp_out;\n\t\thook += 9;\n\t}\n\telse\n\t\tfatalx(\"Invalid message direction: %s\", hook);\n\n\tif (strcmp(hook, \"*\") == 0) {\n\t\titer = NULL;\n\t\twhile (dict_iter(subsystem, &iter, NULL, (void **)&tailq)) {\n\t\t\trp = xcalloc(1, sizeof *rp);\n\t\t\trp->name = xstrdup(name);\n\t\t\tTAILQ_INSERT_TAIL(tailq, rp, entries);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nitems(smtp_events); i++)\n\t\tif (strcmp(hook, smtp_events[i].event) == 0)\n\t\t\tbreak;\n\tif (i == nitems(smtp_events))\n\t\tfatalx(\"Unrecognized report name: %s\", hook);\n\n\ttailq = dict_get(subsystem, hook);\n\trp = xcalloc(1, sizeof *rp);\n\trp->name = xstrdup(name);\n\tTAILQ_INSERT_TAIL(tailq, rp, entries);\n}\n\nstatic void\nreport_smtp_broadcast(uint64_t reqid, const char *direction, struct timeval *tv, const char *event,\n    const char *format, ...)\n{\n\tva_list\t\tap;\n\tstruct dict\t*d;\n\tstruct reporters\t*tailq;\n\tstruct reporter_proc\t*rp;\n\n\tif (strcmp(\"smtp-in\", direction) == 0)\n\t\td = &report_smtp_in;\n\n\telse if (strcmp(\"smtp-out\", direction) == 0)\n\t\td = &report_smtp_out;\n\n\telse\n\t\tfatalx(\"unexpected direction: %s\", direction);\n\n\ttailq = dict_xget(d, event);\n\tTAILQ_FOREACH(rp, tailq, entries) {\n\t\tif (!lka_filter_proc_in_session(reqid, rp->name))\n\t\t\tcontinue;\n\n\t\tva_start(ap, format);\n\t\tif (io_printf(lka_proc_get_io(rp->name),\n\t\t    \"report|%s|%lld.%06ld|%s|%s|%016\"PRIx64\"%s\",\n\t\t    PROTOCOL_VERSION, tv->tv_sec, tv->tv_usec, direction,\n\t\t    event, reqid, format[0] != '\\n' ? \"|\" : \"\") == -1 ||\n\t\t    io_vprintf(lka_proc_get_io(rp->name), format, ap) == -1)\n\t\t\tfatalx(\"failed to write to processor\");\n\t\tva_end(ap);\n\t}\n}\n\nvoid\nlka_report_smtp_link_connect(const char *direction, struct timeval *tv, uint64_t reqid, const char *rdns,\n    int fcrdns,\n    const struct sockaddr_storage *ss_src,\n    const struct sockaddr_storage *ss_dest)\n{\n\tstruct filter_session *fs;\n\tchar\tsrc[NI_MAXHOST + 5];\n\tchar\tdest[NI_MAXHOST + 5];\n\tuint16_t\tsrc_port = 0;\n\tuint16_t\tdest_port = 0;\n\tconst char     *fcrdns_str;\n\n\tif (ss_src->ss_family == AF_INET)\n\t\tsrc_port = ntohs(((const struct sockaddr_in *)ss_src)->sin_port);\n\telse if (ss_src->ss_family == AF_INET6)\n\t\tsrc_port = ntohs(((const struct sockaddr_in6 *)ss_src)->sin6_port);\n\n\tif (ss_dest->ss_family == AF_INET)\n\t\tdest_port = ntohs(((const struct sockaddr_in *)ss_dest)->sin_port);\n\telse if (ss_dest->ss_family == AF_INET6)\n\t\tdest_port = ntohs(((const struct sockaddr_in6 *)ss_dest)->sin6_port);\n\n\tif (strcmp(ss_to_text(ss_src), \"local\") == 0) {\n\t\t(void)snprintf(src, sizeof src, \"unix:%s\", SMTPD_SOCKET);\n\t\t(void)snprintf(dest, sizeof dest, \"unix:%s\", SMTPD_SOCKET);\n\t} else {\n\t\t(void)snprintf(src, sizeof src, \"%s:%d\", ss_to_text(ss_src), src_port);\n\t\t(void)snprintf(dest, sizeof dest, \"%s:%d\", ss_to_text(ss_dest), dest_port);\n\t}\n\n\tswitch (fcrdns) {\n\tcase 1:\n\t\tfcrdns_str = \"pass\";\n\t\tbreak;\n\tcase 0:\n\t\tfcrdns_str = \"fail\";\n\t\tbreak;\n\tdefault:\n\t\tfcrdns_str = \"error\";\n\t\tbreak;\n\t}\n\n\tfs = tree_xget(&sessions, reqid);\n\tfs->rdns = xstrdup(rdns);\n\tfs->fcrdns = fcrdns;\n\tfs->ss_src = *ss_src;\n\tfs->ss_dest = *ss_dest;\n\n\treport_smtp_broadcast(reqid, direction, tv, \"link-connect\",\n\t    \"%s|%s|%s|%s\\n\", rdns, fcrdns_str, src, dest);\n}\n\nvoid\nlka_report_smtp_link_disconnect(const char *direction, struct timeval *tv, uint64_t reqid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"link-disconnect\", \"\\n\");\n}\n\nvoid\nlka_report_smtp_link_greeting(const char *direction, uint64_t reqid,\n    struct timeval *tv, const char *domain)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"link-greeting\", \"%s\\n\",\n\t    domain);\n}\n\nvoid\nlka_report_smtp_link_auth(const char *direction, struct timeval *tv, uint64_t reqid,\n    const char *username, const char *result)\n{\n\tstruct filter_session *fs;\n\n\tif (strcmp(result, \"pass\") == 0) {\n\t\tfs = tree_xget(&sessions, reqid);\n\t\tfs->username = xstrdup(username);\n\t}\n\treport_smtp_broadcast(reqid, direction, tv, \"link-auth\", \"%s|%s\\n\",\n\t    username, result);\n}\n\nvoid\nlka_report_smtp_link_identify(const char *direction, struct timeval *tv,\n    uint64_t reqid, const char *method, const char *heloname)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"link-identify\", \"%s|%s\\n\",\n\t    method, heloname);\n}\n\nvoid\nlka_report_smtp_link_tls(const char *direction, struct timeval *tv, uint64_t reqid, const char *ciphers)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"link-tls\", \"%s\\n\",\n\t    ciphers);\n}\n\nvoid\nlka_report_smtp_tx_reset(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-reset\", \"%08x\\n\",\n\t    msgid);\n}\n\nvoid\nlka_report_smtp_tx_begin(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-begin\", \"%08x\\n\",\n\t    msgid);\n}\n\nvoid\nlka_report_smtp_tx_mail(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, const char *address, int ok)\n{\n\tconst char *result;\n\n\tswitch (ok) {\n\tcase 1:\n\t\tresult = \"ok\";\n\t\tbreak;\n\tcase 0:\n\t\tresult = \"permfail\";\n\t\tbreak;\n\tdefault:\n\t\tresult = \"tempfail\";\n\t\tbreak;\n\t}\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-mail\", \"%08x|%s|%s\\n\",\n\t    msgid, result, address);\n}\n\nvoid\nlka_report_smtp_tx_rcpt(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, const char *address, int ok)\n{\n\tconst char *result;\n\n\tswitch (ok) {\n\tcase 1:\n\t\tresult = \"ok\";\n\t\tbreak;\n\tcase 0:\n\t\tresult = \"permfail\";\n\t\tbreak;\n\tdefault:\n\t\tresult = \"tempfail\";\n\t\tbreak;\n\t}\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-rcpt\", \"%08x|%s|%s\\n\",\n\t    msgid, result, address);\n}\n\nvoid\nlka_report_smtp_tx_envelope(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, uint64_t evpid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-envelope\",\n\t    \"%08x|%016\"PRIx64\"\\n\", msgid, evpid);\n}\n\nvoid\nlka_report_smtp_tx_data(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, int ok)\n{\n\tconst char *result;\n\n\tswitch (ok) {\n\tcase 1:\n\t\tresult = \"ok\";\n\t\tbreak;\n\tcase 0:\n\t\tresult = \"permfail\";\n\t\tbreak;\n\tdefault:\n\t\tresult = \"tempfail\";\n\t\tbreak;\n\t}\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-data\", \"%08x|%s\\n\",\n\t    msgid, result);\n}\n\nvoid\nlka_report_smtp_tx_commit(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, size_t msgsz)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-commit\", \"%08x|%zd\\n\",\n\t    msgid, msgsz);\n}\n\nvoid\nlka_report_smtp_tx_rollback(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-rollback\", \"%08x\\n\",\n\t    msgid);\n}\n\nvoid\nlka_report_smtp_protocol_client(const char *direction, struct timeval *tv, uint64_t reqid, const char *command)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"protocol-client\", \"%s\\n\",\n\t    command);\n}\n\nvoid\nlka_report_smtp_protocol_server(const char *direction, struct timeval *tv, uint64_t reqid, const char *response)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"protocol-server\", \"%s\\n\",\n\t    response);\n}\n\nvoid\nlka_report_smtp_filter_response(const char *direction, struct timeval *tv, uint64_t reqid,\n    int phase, int response, const char *param)\n{\n\tconst char *phase_name;\n\tconst char *response_name;\n\n\tswitch (phase) {\n\tcase FILTER_CONNECT:\n\t\tphase_name = \"connected\";\n\t\tbreak;\n\tcase FILTER_HELO:\n\t\tphase_name = \"helo\";\n\t\tbreak;\n\tcase FILTER_EHLO:\n\t\tphase_name = \"ehlo\";\n\t\tbreak;\n\tcase FILTER_STARTTLS:\n\t\tphase_name = \"tls\";\n\t\tbreak;\n\tcase FILTER_AUTH:\n\t\tphase_name = \"auth\";\n\t\tbreak;\n\tcase FILTER_MAIL_FROM:\n\t\tphase_name = \"mail-from\";\n\t\tbreak;\n\tcase FILTER_RCPT_TO:\n\t\tphase_name = \"rcpt-to\";\n\t\tbreak;\n\tcase FILTER_DATA:\n\t\tphase_name = \"data\";\n\t\tbreak;\n\tcase FILTER_DATA_LINE:\n\t\tphase_name = \"data-line\";\n\t\tbreak;\n\tcase FILTER_RSET:\n\t\tphase_name = \"rset\";\n\t\tbreak;\n\tcase FILTER_QUIT:\n\t\tphase_name = \"quit\";\n\t\tbreak;\n\tcase FILTER_NOOP:\n\t\tphase_name = \"noop\";\n\t\tbreak;\n\tcase FILTER_HELP:\n\t\tphase_name = \"help\";\n\t\tbreak;\n\tcase FILTER_WIZ:\n\t\tphase_name = \"wiz\";\n\t\tbreak;\n\tcase FILTER_COMMIT:\n\t\tphase_name = \"commit\";\n\t\tbreak;\n\tdefault:\n\t\tphase_name = \"\";\n\t}\n\n\tswitch (response) {\n\tcase FILTER_PROCEED:\n\t\tresponse_name = \"proceed\";\n\t\tbreak;\n\tcase FILTER_JUNK:\n\t\tresponse_name = \"junk\";\n\t\tbreak;\n\tcase FILTER_REWRITE:\n\t\tresponse_name = \"rewrite\";\n\t\tbreak;\n\tcase FILTER_REJECT:\n\t\tresponse_name = \"reject\";\n\t\tbreak;\n\tcase FILTER_DISCONNECT:\n\t\tresponse_name = \"disconnect\";\n\t\tbreak;\n\tdefault:\n\t\tresponse_name = \"\";\n\t}\n\n\treport_smtp_broadcast(reqid, direction, tv, \"filter-response\",\n\t    \"%s|%s%s%s\\n\", phase_name, response_name, param ? \"|\" : \"\",\n\t    param ? param : \"\");\n}\n\nvoid\nlka_report_smtp_timeout(const char *direction, struct timeval *tv, uint64_t reqid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"timeout\", \"\\n\");\n}\n\nvoid\nlka_report_filter_report(uint64_t reqid, const char *name, int builtin,\n    const char *direction, struct timeval *tv, const char *message)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"filter-report\",\n\t    \"%s|%s|%s\\n\", builtin ? \"builtin\" : \"proc\",\n\t    name, message);\n}\n\nvoid\nlka_report_proc(const char *name, const char *line)\n{\n\tchar buffer[LINE_MAX];\n\tstruct timeval tv;\n\tchar *ep, *sp, *direction;\n\tuint64_t reqid;\n\n\tif (strlcpy(buffer, line + 7, sizeof(buffer)) >= sizeof(buffer))\n\t\tfatalx(\"Invalid report: line too long: %s\", line);\n\n\terrno = 0;\n\ttv.tv_sec = strtoll(buffer, &ep, 10);\n\tif (ep[0] != '.' || errno != 0)\n\t\tfatalx(\"Invalid report: invalid time: %s\", line);\n\tsp = ep + 1;\n\ttv.tv_usec = strtol(sp, &ep, 10);\n\tif (ep[0] != '|' || errno != 0)\n\t\tfatalx(\"Invalid report: invalid time: %s\", line);\n\tif (ep - sp != 6)\n\t\tfatalx(\"Invalid report: invalid time: %s\", line);\n\n\tdirection = ep + 1;\n\tif (strncmp(direction, \"smtp-in|\", 8) == 0) {\n\t\tdirection[7] = '\\0';\n\t\tdirection += 7;\n#if 0\n\t} else if (strncmp(direction, \"smtp-out|\", 9) == 0) {\n\t\tdirection[8] = '\\0';\n\t\tdirection += 8;\n#endif\n\t} else\n\t\tfatalx(\"Invalid report: invalid direction: %s\", line);\n\n\treqid = strtoull(sp, &ep, 16);\n\tif (ep[0] != '|' || errno != 0)\n\t\tfatalx(\"Invalid report: invalid reqid: %s\", line);\n\tsp = ep + 1;\n\n\tlka_report_filter_report(reqid, name, 0, direction, &tv, sp);\n}\n"], "fixing_code": ["/*\t$OpenBSD: lka_filter.c,v 1.65 2020/12/23 20:17:49 millert Exp $\t*/\n\n/*\n * Copyright (c) 2018 Gilles Chehade <gilles@poolp.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/socket.h>\n\n#include <netinet/in.h>\n\n#include <errno.h>\n#include <event.h>\n#include <imsg.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"smtpd.h\"\n#include \"log.h\"\n\n#define\tPROTOCOL_VERSION\t\"0.6\"\n\nstruct filter;\nstruct filter_session;\nstatic void\tfilter_protocol_internal(struct filter_session *, uint64_t *, uint64_t, enum filter_phase, const char *);\nstatic void\tfilter_protocol(uint64_t, enum filter_phase, const char *);\nstatic void\tfilter_protocol_next(uint64_t, uint64_t, enum filter_phase);\nstatic void\tfilter_protocol_query(struct filter *, uint64_t, uint64_t, const char *, const char *);\n\nstatic void\tfilter_data_internal(struct filter_session *, uint64_t, uint64_t, const char *);\nstatic void\tfilter_data(uint64_t, const char *);\nstatic void\tfilter_data_next(uint64_t, uint64_t, const char *);\nstatic void\tfilter_data_query(struct filter *, uint64_t, uint64_t, const char *);\n\nstatic int\tfilter_builtins_notimpl(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_connect(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_helo(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_mail_from(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_rcpt_to(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_data(struct filter_session *, struct filter *, uint64_t, const char *);\nstatic int\tfilter_builtins_commit(struct filter_session *, struct filter *, uint64_t, const char *);\n\nstatic void\tfilter_result_proceed(uint64_t);\nstatic void\tfilter_result_junk(uint64_t);\nstatic void\tfilter_result_rewrite(uint64_t, const char *);\nstatic void\tfilter_result_reject(uint64_t, const char *);\nstatic void\tfilter_result_disconnect(uint64_t, const char *);\n\nstatic void\tfilter_session_io(struct io *, int, void *);\nvoid\t\tlka_filter_process_response(const char *, const char *);\n\n\nstruct filter_session {\n\tuint64_t\tid;\n\tstruct io\t*io;\n\n\tchar *lastparam;\n\n\tchar *filter_name;\n\tstruct sockaddr_storage ss_src;\n\tstruct sockaddr_storage ss_dest;\n\tchar *rdns;\n\tint fcrdns;\n\n\tchar *helo;\n\tchar *username;\n\tchar *mail_from;\n\t\n\tenum filter_phase\tphase;\n};\n\nstatic struct filter_exec {\n\tenum filter_phase\tphase;\n\tconst char\t       *phase_name;\n\tint\t\t       (*func)(struct filter_session *, struct filter *, uint64_t, const char *);\n} filter_execs[FILTER_PHASES_COUNT] = {\n\t{ FILTER_CONNECT,\t\"connect\",\tfilter_builtins_connect },\n\t{ FILTER_HELO,\t\t\"helo\",\t\tfilter_builtins_helo },\n\t{ FILTER_EHLO,\t\t\"ehlo\",\t\tfilter_builtins_helo },\n\t{ FILTER_STARTTLS,     \t\"starttls\",\tfilter_builtins_notimpl },\n\t{ FILTER_AUTH,     \t\"auth\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_MAIL_FROM,    \t\"mail-from\",\tfilter_builtins_mail_from },\n\t{ FILTER_RCPT_TO,    \t\"rcpt-to\",\tfilter_builtins_rcpt_to },\n\t{ FILTER_DATA,    \t\"data\",\t\tfilter_builtins_data },\n\t{ FILTER_DATA_LINE,    \t\"data-line\",   \tfilter_builtins_notimpl },\n\t{ FILTER_RSET,    \t\"rset\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_QUIT,    \t\"quit\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_NOOP,    \t\"noop\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_HELP,    \t\"help\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_WIZ,    \t\"wiz\",\t\tfilter_builtins_notimpl },\n\t{ FILTER_COMMIT,    \t\"commit\",      \tfilter_builtins_commit },\n};\n\nstruct filter {\n\tuint64_t\t\tid;\n\tuint32_t\t\tphases;\n\tconst char\t       *name;\n\tconst char\t       *proc;\n\tstruct filter  \t      **chain;\n\tsize_t \t\t\tchain_size;\n\tstruct filter_config   *config;\n};\nstatic struct dict filters;\n\nstruct filter_entry {\n\tTAILQ_ENTRY(filter_entry)\tentries;\n\tuint64_t\t\t\tid;\n\tconst char\t\t       *name;\n};\n\nstruct filter_chain {\n\tTAILQ_HEAD(, filter_entry)\t\tchain[nitems(filter_execs)];\n};\n\nstatic struct dict\tfilter_smtp_in;\n\nstatic struct tree\tsessions;\nstatic int\t\tfilters_inited;\n\nstatic struct dict\tfilter_chains;\n\nstruct reporter_proc {\n\tTAILQ_ENTRY(reporter_proc)\tentries;\n\tconst char\t\t       *name;\n};\nTAILQ_HEAD(reporters, reporter_proc);\n\nstatic struct dict\treport_smtp_in;\nstatic struct dict\treport_smtp_out;\n\nstatic struct smtp_events {\n\tconst char     *event;\n} smtp_events[] = {\n\t{ \"link-connect\" },\n\t{ \"link-disconnect\" },\n\t{ \"link-greeting\" },\n\t{ \"link-identify\" },\n\t{ \"link-tls\" },\n\t{ \"link-auth\" },\n\n\t{ \"tx-reset\" },\n\t{ \"tx-begin\" },\n\t{ \"tx-mail\" },\n\t{ \"tx-rcpt\" },\n\t{ \"tx-envelope\" },\n\t{ \"tx-data\" },\n\t{ \"tx-commit\" },\n\t{ \"tx-rollback\" },\n\n\t{ \"protocol-client\" },\n\t{ \"protocol-server\" },\n\n\t{ \"filter-report\" },\n\t{ \"filter-response\" },\n\n\t{ \"timeout\" },\n};\n\nstatic int\t\t\tprocessors_inited = 0;\nstatic struct dict\t\tprocessors;\n\nstruct processor_instance {\n\tchar\t\t\t*name;\n\tstruct io\t\t*io;\n\tstruct io\t\t*errfd;\n\tint\t\t\t ready;\n\tuint32_t\t\t subsystems;\n};\n\nstatic void\tprocessor_io(struct io *, int, void *);\nstatic void\tprocessor_errfd(struct io *, int, void *);\nvoid\t\tlka_filter_process_response(const char *, const char *);\n\nint\nlka_proc_ready(void)\n{\n\tvoid\t*iter;\n\tstruct processor_instance\t*pi;\n\n\titer = NULL;\n\twhile (dict_iter(&processors, &iter, NULL, (void **)&pi))\n\t\tif (!pi->ready)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic void\nlka_proc_config(struct processor_instance *pi)\n{\n\tio_printf(pi->io, \"config|smtpd-version|%s\\n\", SMTPD_VERSION);\n\tio_printf(pi->io, \"config|smtp-session-timeout|%d\\n\", SMTPD_SESSION_TIMEOUT);\n\tif (pi->subsystems & FILTER_SUBSYSTEM_SMTP_IN)\n\t\tio_printf(pi->io, \"config|subsystem|smtp-in\\n\");\n\tif (pi->subsystems & FILTER_SUBSYSTEM_SMTP_OUT)\n\t\tio_printf(pi->io, \"config|subsystem|smtp-out\\n\");\n\tio_printf(pi->io, \"config|admd|%s\\n\",\n\t    env->sc_admd != NULL ? env->sc_admd : env->sc_hostname);\n\tio_printf(pi->io, \"config|ready\\n\");\n}\n\nvoid\nlka_proc_forked(const char *name, uint32_t subsystems, int fd)\n{\n\tstruct processor_instance\t*processor;\n\n\tif (!processors_inited) {\n\t\tdict_init(&processors);\n\t\tprocessors_inited = 1;\n\t}\n\n\tprocessor = xcalloc(1, sizeof *processor);\n\tprocessor->name = xstrdup(name);\n\tprocessor->io = io_new();\n\tprocessor->subsystems = subsystems;\n\n\tio_set_nonblocking(fd);\n\n\tio_set_fd(processor->io, fd);\n\tio_set_callback(processor->io, processor_io, processor->name);\n\tdict_xset(&processors, name, processor);\n}\n\nvoid\nlka_proc_errfd(const char *name, int fd)\n{\n\tstruct processor_instance\t*processor;\n\n\tprocessor = dict_xget(&processors, name);\n\n\tio_set_nonblocking(fd);\n\n\tprocessor->errfd = io_new();\n\tio_set_fd(processor->errfd, fd);\n\tio_set_callback(processor->errfd, processor_errfd, processor->name);\n\n\tlka_proc_config(processor);\n}\n\nstruct io *\nlka_proc_get_io(const char *name)\n{\n\tstruct processor_instance *processor;\n\n\tprocessor = dict_xget(&processors, name);\n\n\treturn processor->io;\n}\n\nstatic void\nprocessor_register(const char *name, const char *line)\n{\n\tstruct processor_instance *processor;\n\n\tprocessor = dict_xget(&processors, name);\n\n\tif (strcmp(line, \"register|ready\") == 0) {\n\t\tprocessor->ready = 1;\n\t\treturn;\n\t}\n\n\tif (strncmp(line, \"register|report|\", 16) == 0) {\n\t\tlka_report_register_hook(name, line+16);\n\t\treturn;\n\t}\n\n\tif (strncmp(line, \"register|filter|\", 16) == 0) {\n\t\tlka_filter_register_hook(name, line+16);\n\t\treturn;\n\t}\n\n\tfatalx(\"Invalid register line received: %s\", line);\n}\n\nstatic void\nprocessor_io(struct io *io, int evt, void *arg)\n{\n\tstruct processor_instance *processor;\n\tconst char\t\t*name = arg;\n\tchar\t\t\t*line = NULL;\n\tssize_t\t\t\t len;\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\t\twhile ((line = io_getline(io, &len)) != NULL) {\n\t\t\tif (strncmp(\"register|\", line, 9) == 0) {\n\t\t\t\tprocessor_register(name, line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tprocessor = dict_xget(&processors, name);\n\t\t\tif (!processor->ready)\n\t\t\t\tfatalx(\"Non-register message before register|\"\n\t\t\t\t    \"ready: %s\", line);\n\t\t\telse if (strncmp(line, \"filter-result|\", 14) == 0 ||\n\t\t\t    strncmp(line, \"filter-dataline|\", 16) == 0)\n\t\t\t\tlka_filter_process_response(name, line);\n\t\t\telse if (strncmp(line, \"report|\", 7) == 0)\n\t\t\t\tlka_report_proc(name, line);\n\t\t\telse\n\t\t\t\tfatalx(\"Invalid filter message type: %s\", line);\n\t\t}\n\t}\n}\n\nstatic void\nprocessor_errfd(struct io *io, int evt, void *arg)\n{\n\tconst char\t*name = arg;\n\tchar\t\t*line = NULL;\n\tssize_t\t\t len;\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\t\twhile ((line = io_getline(io, &len)) != NULL)\n\t\t\tlog_warnx(\"%s: %s\", name, line);\n\t}\n}\n\nvoid\nlka_filter_init(void)\n{\n\tvoid\t\t*iter;\n\tconst char\t*name;\n\tstruct filter  \t*filter;\n\tstruct filter_config\t*filter_config;\n\tsize_t\t\ti;\n\tchar\t\t buffer[LINE_MAX];\t/* for traces */\n\n\tdict_init(&filters);\n\tdict_init(&filter_chains);\n\n\t/* first pass, allocate and init individual filters */\n\titer = NULL;\n\twhile (dict_iter(env->sc_filters_dict, &iter, &name, (void **)&filter_config)) {\n\t\tswitch (filter_config->filter_type) {\n\t\tcase FILTER_TYPE_BUILTIN:\n\t\t\tfilter = xcalloc(1, sizeof(*filter));\n\t\t\tfilter->name = name;\n\t\t\tfilter->phases |= (1<<filter_config->phase);\n\t\t\tfilter->config = filter_config;\n\t\t\tdict_set(&filters, name, filter);\n\t\t\tlog_trace(TRACE_FILTERS, \"filters init type=builtin, name=%s, hooks=%08x\",\n\t\t\t    name, filter->phases);\n\t\t\tbreak;\n\n\t\tcase FILTER_TYPE_PROC:\n\t\t\tfilter = xcalloc(1, sizeof(*filter));\n\t\t\tfilter->name = name;\n\t\t\tfilter->proc = filter_config->proc;\n\t\t\tfilter->config = filter_config;\n\t\t\tdict_set(&filters, name, filter);\n\t\t\tlog_trace(TRACE_FILTERS, \"filters init type=proc, name=%s, proc=%s\",\n\t\t\t    name, filter_config->proc);\n\t\t\tbreak;\n\n\t\tcase FILTER_TYPE_CHAIN:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* second pass, allocate and init filter chains but don't build yet */\n\titer = NULL;\n\twhile (dict_iter(env->sc_filters_dict, &iter, &name, (void **)&filter_config)) {\n\t\tswitch (filter_config->filter_type) {\n\t\tcase FILTER_TYPE_CHAIN:\n\t\t\tfilter = xcalloc(1, sizeof(*filter));\n\t\t\tfilter->name = name;\n\t\t\tfilter->chain = xcalloc(filter_config->chain_size, sizeof(void **));\n\t\t\tfilter->chain_size = filter_config->chain_size;\n\t\t\tfilter->config = filter_config;\n\n\t\t\tbuffer[0] = '\\0';\n\t\t\tfor (i = 0; i < filter->chain_size; ++i) {\n\t\t\t\tfilter->chain[i] = dict_xget(&filters, filter_config->chain[i]);\n\t\t\t\tif (i)\n\t\t\t\t\t(void)strlcat(buffer, \", \", sizeof buffer);\n\t\t\t\t(void)strlcat(buffer, filter->chain[i]->name, sizeof buffer);\n\t\t\t}\n\t\t\tlog_trace(TRACE_FILTERS, \"filters init type=chain, name=%s { %s }\", name, buffer);\n\n\t\t\tdict_set(&filters, name, filter);\n\t\t\tbreak;\n\n\t\tcase FILTER_TYPE_BUILTIN:\n\t\tcase FILTER_TYPE_PROC:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid\nlka_filter_register_hook(const char *name, const char *hook)\n{\n\tstruct dict\t\t*subsystem;\n\tstruct filter\t\t*filter;\n\tconst char\t*filter_name;\n\tvoid\t\t*iter;\n\tsize_t\ti;\n\n\tif (strncasecmp(hook, \"smtp-in|\", 8) == 0) {\n\t\tsubsystem = &filter_smtp_in;\n\t\thook += 8;\n\t}\n\telse\n\t\tfatalx(\"Invalid message direction: %s\", hook);\n\n\tfor (i = 0; i < nitems(filter_execs); i++)\n\t\tif (strcmp(hook, filter_execs[i].phase_name) == 0)\n\t\t\tbreak;\n\tif (i == nitems(filter_execs))\n\t\tfatalx(\"Unrecognized report name: %s\", hook);\n\n\titer = NULL;\n\twhile (dict_iter(&filters, &iter, &filter_name, (void **)&filter))\n\t\tif (filter->proc && strcmp(name, filter->proc) == 0)\n\t\t\tfilter->phases |= (1<<filter_execs[i].phase);\n}\n\nvoid\nlka_filter_ready(void)\n{\n\tstruct filter  \t*filter;\n\tstruct filter  \t*subfilter;\n\tconst char\t*filter_name;\n\tstruct filter_entry\t*filter_entry;\n\tstruct filter_chain\t*filter_chain;\n\tvoid\t\t*iter;\n\tsize_t\t\ti;\n\tsize_t\t\tj;\n\n\t/* all filters are ready, actually build the filter chains */\n\titer = NULL;\n\twhile (dict_iter(&filters, &iter, &filter_name, (void **)&filter)) {\n\t\tfilter_chain = xcalloc(1, sizeof *filter_chain);\n\t\tfor (i = 0; i < nitems(filter_execs); i++)\n\t\t\tTAILQ_INIT(&filter_chain->chain[i]);\n\t\tdict_set(&filter_chains, filter_name, filter_chain);\n\n\t\tif (filter->chain) {\n\t\t\tfor (i = 0; i < filter->chain_size; i++) {\n\t\t\t\tsubfilter = filter->chain[i];\n\t\t\t\tfor (j = 0; j < nitems(filter_execs); ++j) {\n\t\t\t\t\tif (subfilter->phases & (1<<j)) {\n\t\t\t\t\t\tfilter_entry = xcalloc(1, sizeof *filter_entry);\n\t\t\t\t\t\tfilter_entry->id = generate_uid();\n\t\t\t\t\t\tfilter_entry->name = subfilter->name;\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&filter_chain->chain[j],\n\t\t\t\t\t\t    filter_entry, entries);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < nitems(filter_execs); ++i) {\n\t\t\tif (filter->phases & (1<<i)) {\n\t\t\t\tfilter_entry = xcalloc(1, sizeof *filter_entry);\n\t\t\t\tfilter_entry->id = generate_uid();\n\t\t\t\tfilter_entry->name = filter_name;\n\t\t\t\tTAILQ_INSERT_TAIL(&filter_chain->chain[i],\n\t\t\t\t    filter_entry, entries);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\nlka_filter_proc_in_session(uint64_t reqid, const char *proc)\n{\n\tstruct filter_session\t*fs;\n\tstruct filter\t\t*filter;\n\tsize_t\t\t\t i;\n\n\tif ((fs = tree_get(&sessions, reqid)) == NULL)\n\t\treturn 0;\n\n\tfilter = dict_get(&filters, fs->filter_name);\n\tif (filter == NULL || (filter->proc == NULL && filter->chain == NULL))\n\t\treturn 0;\n\n\tif (filter->proc)\n\t\treturn strcmp(filter->proc, proc) == 0 ? 1 : 0;\n\n\tfor (i = 0; i < filter->chain_size; i++)\n\t\tif (filter->chain[i]->proc &&\n\t\t    strcmp(filter->chain[i]->proc, proc) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid\nlka_filter_begin(uint64_t reqid, const char *filter_name)\n{\n\tstruct filter_session\t*fs;\n\n\tif (!filters_inited) {\n\t\ttree_init(&sessions);\n\t\tfilters_inited = 1;\n\t}\n\n\tfs = xcalloc(1, sizeof (struct filter_session));\n\tfs->id = reqid;\n\tfs->filter_name = xstrdup(filter_name);\n\ttree_xset(&sessions, fs->id, fs);\n\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters session-begin\", reqid);\n}\n\nvoid\nlka_filter_end(uint64_t reqid)\n{\n\tstruct filter_session\t*fs;\n\n\tfs = tree_xpop(&sessions, reqid);\n\tfree(fs->rdns);\n\tfree(fs->helo);\n\tfree(fs->mail_from);\n\tfree(fs->username);\n\tfree(fs->lastparam);\n\tfree(fs->filter_name);\n\tfree(fs);\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters session-end\", reqid);\n}\n\nvoid\nlka_filter_data_begin(uint64_t reqid)\n{\n\tstruct filter_session  *fs;\n\tint\tsp[2];\n\tint\tfd = -1;\n\n\tfs = tree_xget(&sessions, reqid);\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sp) == -1)\n\t\tgoto end;\n\tio_set_nonblocking(sp[0]);\n\tio_set_nonblocking(sp[1]);\n\tfd = sp[0];\n\tfs->io = io_new();\n\tio_set_fd(fs->io, sp[1]);\n\tio_set_callback(fs->io, filter_session_io, fs);\n\nend:\n\tm_create(p_pony, IMSG_FILTER_SMTP_DATA_BEGIN, 0, 0, fd);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, fd != -1 ? 1 : 0);\n\tm_close(p_pony);\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters data-begin fd=%d\", reqid, fd);\n}\n\nvoid\nlka_filter_data_end(uint64_t reqid)\n{\n\tstruct filter_session\t*fs;\n\n\tfs = tree_xget(&sessions, reqid);\n\tif (fs->io) {\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t}\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters data-end\", reqid);\n}\n\nstatic void\nfilter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tfilter_data(fs->id, line);\n\n\t\tgoto nextline;\n\t}\n}\n\nvoid\nlka_filter_process_response(const char *name, const char *line)\n{\n\tuint64_t reqid;\n\tuint64_t token;\n\tchar buffer[LINE_MAX];\n\tchar *ep = NULL;\n\tchar *kind = NULL;\n\tchar *qid = NULL;\n\t/*char *phase = NULL;*/\n\tchar *response = NULL;\n\tchar *parameter = NULL;\n\tstruct filter_session *fs;\n\n\t(void)strlcpy(buffer, line, sizeof buffer);\n\tif ((ep = strchr(buffer, '|')) == NULL)\n\t\tfatalx(\"Missing token: %s\", line);\n\tep[0] = '\\0';\n\n\tkind = buffer;\n\n\tqid = ep+1;\n\tif ((ep = strchr(qid, '|')) == NULL)\n\t\tfatalx(\"Missing reqid: %s\", line);\n\tep[0] = '\\0';\n\n\treqid = strtoull(qid, &ep, 16);\n\tif (qid[0] == '\\0' || *ep != '\\0')\n\t\tfatalx(\"Invalid reqid: %s\", line);\n\tif (errno == ERANGE && reqid == ULLONG_MAX)\n\t\tfatal(\"Invalid reqid: %s\", line);\n\n\tqid = ep+1;\n\tif ((ep = strchr(qid, '|')) == NULL)\n\t\tfatal(\"Missing directive: %s\", line);\n\tep[0] = '\\0';\n\n\ttoken = strtoull(qid, &ep, 16);\n\tif (qid[0] == '\\0' || *ep != '\\0')\n\t\tfatalx(\"Invalid token: %s\", line);\n\tif (errno == ERANGE && token == ULLONG_MAX)\n\t\tfatal(\"Invalid token: %s\", line);\n\n\tresponse = ep+1;\n\n\t/* session can legitimately disappear on a resume */\n\tif ((fs = tree_get(&sessions, reqid)) == NULL)\n\t\treturn;\n\n\tif (strcmp(kind, \"filter-dataline\") == 0) {\n\t\tif (fs->phase != FILTER_DATA_LINE)\n\t\t\tfatalx(\"filter-dataline out of dataline phase\");\n\t\tfilter_data_next(token, reqid, response);\n\t\treturn;\n\t}\n\tif (fs->phase == FILTER_DATA_LINE)\n\t\tfatalx(\"filter-result in dataline phase\");\n\n\tif ((ep = strchr(response, '|'))) {\n\t\tparameter = ep + 1;\n\t\tep[0] = '\\0';\n\t}\n\n\tif (strcmp(response, \"proceed\") == 0) {\n\t\tif (parameter != NULL)\n\t\t\tfatalx(\"Unexpected parameter after proceed: %s\", line);\n\t\tfilter_protocol_next(token, reqid, 0);\n\t\treturn;\n\t} else if (strcmp(response, \"junk\") == 0) {\n\t\tif (parameter != NULL)\n\t\t\tfatalx(\"Unexpected parameter after junk: %s\", line);\n\t\tif (fs->phase == FILTER_COMMIT)\n\t\t\tfatalx(\"filter-reponse junk after DATA\");\n\t\tfilter_result_junk(reqid);\n\t\treturn;\n\t} else {\n\t\tif (parameter == NULL)\n\t\t\tfatalx(\"Missing parameter: %s\", line);\n\n\t\tif (strcmp(response, \"rewrite\") == 0)\n\t\t\tfilter_result_rewrite(reqid, parameter);\n\t\telse if (strcmp(response, \"reject\") == 0)\n\t\t\tfilter_result_reject(reqid, parameter);\n\t\telse if (strcmp(response, \"disconnect\") == 0)\n\t\t\tfilter_result_disconnect(reqid, parameter);\n\t\telse\n\t\t\tfatalx(\"Invalid directive: %s\", line);\n\t}\n}\n\nvoid\nlka_filter_protocol(uint64_t reqid, enum filter_phase phase, const char *param)\n{\n\tfilter_protocol(reqid, phase, param);\n}\n\nstatic void\nfilter_protocol_internal(struct filter_session *fs, uint64_t *token, uint64_t reqid, enum filter_phase phase, const char *param)\n{\n\tstruct filter_chain\t*filter_chain;\n\tstruct filter_entry\t*filter_entry;\n\tstruct filter\t\t*filter;\n\tstruct timeval\t\t tv;\n\tconst char\t\t*phase_name = filter_execs[phase].phase_name;\n\tint\t\t\t resume = 1;\n\n\tif (!*token) {\n\t\tfs->phase = phase;\n\t\tresume = 0;\n\t}\n\n\t/* XXX - this sanity check requires a protocol change, stub for now */\n\tphase = fs->phase;\n\tif (fs->phase != phase)\n\t\tfatalx(\"misbehaving filter\");\n\n\t/* based on token, identify the filter_entry we should apply  */\n\tfilter_chain = dict_get(&filter_chains, fs->filter_name);\n\tfilter_entry = TAILQ_FIRST(&filter_chain->chain[fs->phase]);\n\tif (*token) {\n\t\tTAILQ_FOREACH(filter_entry, &filter_chain->chain[fs->phase], entries)\n\t\t    if (filter_entry->id == *token)\n\t\t\t    break;\n\t\tif (filter_entry == NULL)\n\t\t\tfatalx(\"misbehaving filter\");\n\t\tfilter_entry = TAILQ_NEXT(filter_entry, entries);\n\t}\n\n\t/* no filter_entry, we either had none or reached end of chain */\n\tif (filter_entry == NULL) {\n\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, resume=%s, \"\n\t\t    \"action=proceed\",\n\t\t    fs->id, phase_name, resume ? \"y\" : \"n\");\n\t\tfilter_result_proceed(reqid);\n\t\treturn;\n\t}\n\n\t/* process param with current filter_entry */\n\t*token = filter_entry->id;\n\tfilter = dict_get(&filters, filter_entry->name);\n\tif (filter->proc) {\n\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t    \"resume=%s, action=deferred, filter=%s\",\n\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t    filter->name);\n\t\tfilter_protocol_query(filter, filter_entry->id, reqid,\n\t\t    filter_execs[fs->phase].phase_name, param);\n\t\treturn;\t/* deferred response */\n\t}\n\n\tif (filter_execs[fs->phase].func(fs, filter, reqid, param)) {\n\t\tif (filter->config->rewrite) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=rewrite, filter=%s, query=%s, response=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param,\n\t\t\t    filter->config->rewrite);\n\t\t\t    filter_result_rewrite(reqid, filter->config->rewrite);\n\t\t\treturn;\n\t\t}\n\t\telse if (filter->config->disconnect) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=disconnect, filter=%s, query=%s, response=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param,\n\t\t\t    filter->config->disconnect);\n\t\t\tfilter_result_disconnect(reqid, filter->config->disconnect);\n\t\t\treturn;\n\t\t}\n\t\telse if (filter->config->junk) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=junk, filter=%s, query=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param);\n\t\t\tfilter_result_junk(reqid);\n\t\t\treturn;\n\t\t} else if (filter->config->report) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=report, filter=%s, query=%s response=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param, filter->config->report);\n\n\t\t\tgettimeofday(&tv, NULL);\n\t\t\tlka_report_filter_report(fs->id, filter->name, 1,\n\t\t\t    \"smtp-in\", &tv, filter->config->report);\n\t\t} else if (filter->config->bypass) {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=bypass, filter=%s, query=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param);\n\t\t\tfilter_result_proceed(reqid);\n\t\t\treturn;\n\t\t} else {\n\t\t\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t\t\t    \"resume=%s, action=reject, filter=%s, query=%s, response=%s\",\n\t\t\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t\t\t    filter->name,\n\t\t\t    param,\n\t\t\t    filter->config->reject);\n\t\t\tfilter_result_reject(reqid, filter->config->reject);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlog_trace(TRACE_FILTERS, \"%016\"PRIx64\" filters protocol phase=%s, \"\n\t    \"resume=%s, action=proceed, filter=%s, query=%s\",\n\t    fs->id, phase_name, resume ? \"y\" : \"n\",\n\t    filter->name,\n\t    param);\n\n\t/* filter_entry resulted in proceed, try next filter */\n\tfilter_protocol_internal(fs, token, reqid, phase, param);\n\treturn;\n}\n\nstatic void\nfilter_data_internal(struct filter_session *fs, uint64_t token, uint64_t reqid, const char *line)\n{\n\tstruct filter_chain\t*filter_chain;\n\tstruct filter_entry\t*filter_entry;\n\tstruct filter\t\t*filter;\n\n\tif (!token)\n\t\tfs->phase = FILTER_DATA_LINE;\n\tif (fs->phase != FILTER_DATA_LINE)\n\t\tfatalx(\"misbehaving filter\");\n\n\t/* based on token, identify the filter_entry we should apply  */\n\tfilter_chain = dict_get(&filter_chains, fs->filter_name);\n\tfilter_entry = TAILQ_FIRST(&filter_chain->chain[fs->phase]);\n\tif (token) {\n\t\tTAILQ_FOREACH(filter_entry, &filter_chain->chain[fs->phase], entries)\n\t\t    if (filter_entry->id == token)\n\t\t\t    break;\n\t\tif (filter_entry == NULL)\n\t\t\tfatalx(\"misbehaving filter\");\n\t\tfilter_entry = TAILQ_NEXT(filter_entry, entries);\n\t}\n\n\t/* no filter_entry, we either had none or reached end of chain */\n\tif (filter_entry == NULL) {\n\t\tio_printf(fs->io, \"%s\\n\", line);\n\t\treturn;\n\t}\n\n\t/* pass data to the filter */\n\tfilter = dict_get(&filters, filter_entry->name);\n\tfilter_data_query(filter, filter_entry->id, reqid, line);\n}\n\nstatic void\nfilter_protocol(uint64_t reqid, enum filter_phase phase, const char *param)\n{\n\tstruct filter_session  *fs;\n\tuint64_t\t\ttoken = 0;\n\tchar\t\t       *nparam = NULL;\n\t\n\tfs = tree_xget(&sessions, reqid);\n\n\tswitch (phase) {\n\tcase FILTER_HELO:\n\tcase FILTER_EHLO:\n\t\tfree(fs->helo);\n\t\tfs->helo = xstrdup(param);\n\t\tbreak;\n\tcase FILTER_MAIL_FROM:\n\t\tfree(fs->mail_from);\n\t\tfs->mail_from = xstrdup(param + 1);\n\t\t*strchr(fs->mail_from, '>') = '\\0';\n\t\tparam = fs->mail_from;\n\n\t\tbreak;\n\tcase FILTER_RCPT_TO:\n\t\tnparam = xstrdup(param + 1);\n\t\t*strchr(nparam, '>') = '\\0';\n\t\tparam = nparam;\n\t\tbreak;\n\tcase FILTER_STARTTLS:\n\t\t/* TBD */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfree(fs->lastparam);\n\tfs->lastparam = xstrdup(param);\n\n\tfilter_protocol_internal(fs, &token, reqid, phase, param);\n\tif (nparam)\n\t\tfree(nparam);\n}\n\nstatic void\nfilter_protocol_next(uint64_t token, uint64_t reqid, enum filter_phase phase)\n{\n\tstruct filter_session  *fs;\n\n\t/* session can legitimately disappear on a resume */\n\tif ((fs = tree_get(&sessions, reqid)) == NULL)\n\t\treturn;\n\n\tfilter_protocol_internal(fs, &token, reqid, phase, fs->lastparam);\n}\n\nstatic void\nfilter_data(uint64_t reqid, const char *line)\n{\n\tstruct filter_session  *fs;\n\n\tfs = tree_xget(&sessions, reqid);\n\n\tfilter_data_internal(fs, 0, reqid, line);\n}\n\nstatic void\nfilter_data_next(uint64_t token, uint64_t reqid, const char *line)\n{\n\tstruct filter_session  *fs;\n\n\t/* session can legitimately disappear on a resume */\n\tif ((fs = tree_get(&sessions, reqid)) == NULL)\n\t\treturn;\n\n\tfilter_data_internal(fs, token, reqid, line);\n}\n\nstatic void\nfilter_protocol_query(struct filter *filter, uint64_t token, uint64_t reqid, const char *phase, const char *param)\n{\n\tint\tn;\n\tstruct filter_session\t*fs;\n\tstruct timeval\ttv;\n\n\tgettimeofday(&tv, NULL);\n\t\n\tfs = tree_xget(&sessions, reqid);\n\tif (strcmp(phase, \"connect\") == 0)\n\t\tn = io_printf(lka_proc_get_io(filter->proc),\n\t\t    \"filter|%s|%lld.%06ld|smtp-in|%s|%016\"PRIx64\"|%016\"PRIx64\"|%s|%s\\n\",\n\t\t    PROTOCOL_VERSION,\n\t\t    tv.tv_sec, tv.tv_usec,\n\t\t    phase, reqid, token, fs->rdns, param);\n\telse\n\t\tn = io_printf(lka_proc_get_io(filter->proc),\n\t\t    \"filter|%s|%lld.%06ld|smtp-in|%s|%016\"PRIx64\"|%016\"PRIx64\"|%s\\n\",\n\t\t    PROTOCOL_VERSION,\n\t\t    tv.tv_sec, tv.tv_usec,\n\t\t    phase, reqid, token, param);\n\tif (n == -1)\n\t\tfatalx(\"failed to write to processor\");\n}\n\nstatic void\nfilter_data_query(struct filter *filter, uint64_t token, uint64_t reqid, const char *line)\n{\n\tint\tn;\n\tstruct timeval\ttv;\n\n\tgettimeofday(&tv, NULL);\n\n\tn = io_printf(lka_proc_get_io(filter->proc),\n\t    \"filter|%s|%lld.%06ld|smtp-in|data-line|\"\n\t    \"%016\"PRIx64\"|%016\"PRIx64\"|%s\\n\",\n\t    PROTOCOL_VERSION,\n\t    tv.tv_sec, tv.tv_usec,\n\t    reqid, token, line);\n\tif (n == -1)\n\t\tfatalx(\"failed to write to processor\");\n}\n\nstatic void\nfilter_result_proceed(uint64_t reqid)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_PROCEED);\n\tm_close(p_pony);\n}\n\nstatic void\nfilter_result_junk(uint64_t reqid)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_JUNK);\n\tm_close(p_pony);\n}\n\nstatic void\nfilter_result_rewrite(uint64_t reqid, const char *param)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_REWRITE);\n\tm_add_string(p_pony, param);\n\tm_close(p_pony);\n}\n\nstatic void\nfilter_result_reject(uint64_t reqid, const char *message)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_REJECT);\n\tm_add_string(p_pony, message);\n\tm_close(p_pony);\n}\n\nstatic void\nfilter_result_disconnect(uint64_t reqid, const char *message)\n{\n\tm_create(p_pony, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_pony, reqid);\n\tm_add_int(p_pony, FILTER_DISCONNECT);\n\tm_add_string(p_pony, message);\n\tm_close(p_pony);\n}\n\n\n/* below is code for builtin filters */\n\nstatic int\nfilter_check_rdns_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->rdns_table == NULL)\n\t\treturn 0;\n\t\n\tif (table_match(filter->config->rdns_table, kind, key) > 0)\n\t\tret = 1;\n\n\treturn filter->config->not_rdns_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_rdns_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->rdns_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->rdns_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_rdns_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_src_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->src_table == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->src_table, kind, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_src_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_src_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->src_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->src_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_src_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_helo_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->helo_table == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->helo_table, kind, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_helo_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_helo_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->helo_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->helo_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_helo_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_auth(struct filter *filter, const char *username)\n{\n\tint ret = 0;\n\n\tif (!filter->config->auth)\n\t\treturn 0;\n\n\tret = username ? 1 : 0;\n\n\treturn filter->config->not_auth < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_auth_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->auth_table == NULL)\n\t\treturn 0;\n\t\n\tif (key && table_match(filter->config->auth_table, kind, key) > 0)\n\t\tret = 1;\n\n\treturn filter->config->not_auth_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_auth_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->auth_regex == NULL)\n\t\treturn 0;\n\n\tif (key && table_match(filter->config->auth_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_auth_regex < 0 ? !ret : ret;\n}\n\n\nstatic int\nfilter_check_mail_from_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->mail_from_table == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->mail_from_table, kind, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_mail_from_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_mail_from_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->mail_from_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->mail_from_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_mail_from_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_rcpt_to_table(struct filter *filter, enum table_service kind, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->rcpt_to_table == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->rcpt_to_table, kind, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_rcpt_to_table < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_rcpt_to_regex(struct filter *filter, const char *key)\n{\n\tint\tret = 0;\n\n\tif (filter->config->rcpt_to_regex == NULL)\n\t\treturn 0;\n\n\tif (table_match(filter->config->rcpt_to_regex, K_REGEX, key) > 0)\n\t\tret = 1;\n\treturn filter->config->not_rcpt_to_regex < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_fcrdns(struct filter *filter, int fcrdns)\n{\n\tint\tret = 0;\n\n\tif (!filter->config->fcrdns)\n\t\treturn 0;\n\n\tret = fcrdns == 1;\n\treturn filter->config->not_fcrdns < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_check_rdns(struct filter *filter, const char *hostname)\n{\n\tint\tret = 0;\n\tstruct netaddr\tnetaddr;\n\n\tif (!filter->config->rdns)\n\t\treturn 0;\n\n\t/* this is a hack until smtp session properly deals with lack of rdns */\n\tret = strcmp(\"<unknown>\", hostname);\n\tif (ret == 0)\n\t\treturn filter->config->not_rdns < 0 ? !ret : ret;\n\n\t/* if text_to_netaddress succeeds,\n\t * we don't have an rDNS so the filter should match\n\t */\n\tret = !text_to_netaddr(&netaddr, hostname);\n\treturn filter->config->not_rdns < 0 ? !ret : ret;\n}\n\nstatic int\nfilter_builtins_notimpl(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn 0;\n}\n\nstatic int\nfilter_builtins_global(struct filter_session *fs, struct filter *filter, uint64_t reqid)\n{\n\treturn filter_check_fcrdns(filter, fs->fcrdns) ||\n\t    filter_check_rdns(filter, fs->rdns) ||\n\t    filter_check_rdns_table(filter, K_DOMAIN, fs->rdns) ||\n\t    filter_check_rdns_regex(filter, fs->rdns) ||\n\t    filter_check_src_table(filter, K_NETADDR, ss_to_text(&fs->ss_src)) ||\n\t    filter_check_src_regex(filter, ss_to_text(&fs->ss_src)) ||\n\t    filter_check_helo_table(filter, K_DOMAIN, fs->helo) ||\n\t    filter_check_helo_regex(filter, fs->helo) ||\n\t    filter_check_auth(filter, fs->username) ||\n\t    filter_check_auth_table(filter, K_STRING, fs->username) ||\n\t    filter_check_auth_table(filter, K_CREDENTIALS, fs->username) ||\n\t    filter_check_auth_regex(filter, fs->username) ||\n\t    filter_check_mail_from_table(filter, K_MAILADDR, fs->mail_from) ||\n\t    filter_check_mail_from_regex(filter, fs->mail_from);\n}\n\nstatic int\nfilter_builtins_connect(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic int\nfilter_builtins_helo(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic int\nfilter_builtins_mail_from(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic int\nfilter_builtins_rcpt_to(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid) ||\n\t    filter_check_rcpt_to_table(filter, K_MAILADDR, param) ||\n\t    filter_check_rcpt_to_regex(filter, param);\n}\n\nstatic int\nfilter_builtins_data(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic int\nfilter_builtins_commit(struct filter_session *fs, struct filter *filter, uint64_t reqid, const char *param)\n{\n\treturn filter_builtins_global(fs, filter, reqid);\n}\n\nstatic void\nreport_smtp_broadcast(uint64_t, const char *, struct timeval *, const char *,\n    const char *, ...) __attribute__((__format__ (printf, 5, 6)));\n\nvoid\nlka_report_init(void)\n{\n\tstruct reporters\t*tailq;\n\tsize_t\t\t\t i;\n\n\tdict_init(&report_smtp_in);\n\tdict_init(&report_smtp_out);\n\n\tfor (i = 0; i < nitems(smtp_events); ++i) {\n\t\ttailq = xcalloc(1, sizeof (struct reporters));\n\t\tTAILQ_INIT(tailq);\n\t\tdict_xset(&report_smtp_in, smtp_events[i].event, tailq);\n\n\t\ttailq = xcalloc(1, sizeof (struct reporters));\n\t\tTAILQ_INIT(tailq);\n\t\tdict_xset(&report_smtp_out, smtp_events[i].event, tailq);\n\t}\n}\n\nvoid\nlka_report_register_hook(const char *name, const char *hook)\n{\n\tstruct dict\t*subsystem;\n\tstruct reporter_proc\t*rp;\n\tstruct reporters\t*tailq;\n\tvoid *iter;\n\tsize_t\ti;\n\n\tif (strncmp(hook, \"smtp-in|\", 8) == 0) {\n\t\tsubsystem = &report_smtp_in;\n\t\thook += 8;\n\t}\n\telse if (strncmp(hook, \"smtp-out|\", 9) == 0) {\n\t\tsubsystem = &report_smtp_out;\n\t\thook += 9;\n\t}\n\telse\n\t\tfatalx(\"Invalid message direction: %s\", hook);\n\n\tif (strcmp(hook, \"*\") == 0) {\n\t\titer = NULL;\n\t\twhile (dict_iter(subsystem, &iter, NULL, (void **)&tailq)) {\n\t\t\trp = xcalloc(1, sizeof *rp);\n\t\t\trp->name = xstrdup(name);\n\t\t\tTAILQ_INSERT_TAIL(tailq, rp, entries);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nitems(smtp_events); i++)\n\t\tif (strcmp(hook, smtp_events[i].event) == 0)\n\t\t\tbreak;\n\tif (i == nitems(smtp_events))\n\t\tfatalx(\"Unrecognized report name: %s\", hook);\n\n\ttailq = dict_get(subsystem, hook);\n\trp = xcalloc(1, sizeof *rp);\n\trp->name = xstrdup(name);\n\tTAILQ_INSERT_TAIL(tailq, rp, entries);\n}\n\nstatic void\nreport_smtp_broadcast(uint64_t reqid, const char *direction, struct timeval *tv, const char *event,\n    const char *format, ...)\n{\n\tva_list\t\tap;\n\tstruct dict\t*d;\n\tstruct reporters\t*tailq;\n\tstruct reporter_proc\t*rp;\n\n\tif (strcmp(\"smtp-in\", direction) == 0)\n\t\td = &report_smtp_in;\n\n\telse if (strcmp(\"smtp-out\", direction) == 0)\n\t\td = &report_smtp_out;\n\n\telse\n\t\tfatalx(\"unexpected direction: %s\", direction);\n\n\ttailq = dict_xget(d, event);\n\tTAILQ_FOREACH(rp, tailq, entries) {\n\t\tif (!lka_filter_proc_in_session(reqid, rp->name))\n\t\t\tcontinue;\n\n\t\tva_start(ap, format);\n\t\tif (io_printf(lka_proc_get_io(rp->name),\n\t\t    \"report|%s|%lld.%06ld|%s|%s|%016\"PRIx64\"%s\",\n\t\t    PROTOCOL_VERSION, tv->tv_sec, tv->tv_usec, direction,\n\t\t    event, reqid, format[0] != '\\n' ? \"|\" : \"\") == -1 ||\n\t\t    io_vprintf(lka_proc_get_io(rp->name), format, ap) == -1)\n\t\t\tfatalx(\"failed to write to processor\");\n\t\tva_end(ap);\n\t}\n}\n\nvoid\nlka_report_smtp_link_connect(const char *direction, struct timeval *tv, uint64_t reqid, const char *rdns,\n    int fcrdns,\n    const struct sockaddr_storage *ss_src,\n    const struct sockaddr_storage *ss_dest)\n{\n\tstruct filter_session *fs;\n\tchar\tsrc[NI_MAXHOST + 5];\n\tchar\tdest[NI_MAXHOST + 5];\n\tuint16_t\tsrc_port = 0;\n\tuint16_t\tdest_port = 0;\n\tconst char     *fcrdns_str;\n\n\tif (ss_src->ss_family == AF_INET)\n\t\tsrc_port = ntohs(((const struct sockaddr_in *)ss_src)->sin_port);\n\telse if (ss_src->ss_family == AF_INET6)\n\t\tsrc_port = ntohs(((const struct sockaddr_in6 *)ss_src)->sin6_port);\n\n\tif (ss_dest->ss_family == AF_INET)\n\t\tdest_port = ntohs(((const struct sockaddr_in *)ss_dest)->sin_port);\n\telse if (ss_dest->ss_family == AF_INET6)\n\t\tdest_port = ntohs(((const struct sockaddr_in6 *)ss_dest)->sin6_port);\n\n\tif (strcmp(ss_to_text(ss_src), \"local\") == 0) {\n\t\t(void)snprintf(src, sizeof src, \"unix:%s\", SMTPD_SOCKET);\n\t\t(void)snprintf(dest, sizeof dest, \"unix:%s\", SMTPD_SOCKET);\n\t} else {\n\t\t(void)snprintf(src, sizeof src, \"%s:%d\", ss_to_text(ss_src), src_port);\n\t\t(void)snprintf(dest, sizeof dest, \"%s:%d\", ss_to_text(ss_dest), dest_port);\n\t}\n\n\tswitch (fcrdns) {\n\tcase 1:\n\t\tfcrdns_str = \"pass\";\n\t\tbreak;\n\tcase 0:\n\t\tfcrdns_str = \"fail\";\n\t\tbreak;\n\tdefault:\n\t\tfcrdns_str = \"error\";\n\t\tbreak;\n\t}\n\n\tfs = tree_xget(&sessions, reqid);\n\tfs->rdns = xstrdup(rdns);\n\tfs->fcrdns = fcrdns;\n\tfs->ss_src = *ss_src;\n\tfs->ss_dest = *ss_dest;\n\n\treport_smtp_broadcast(reqid, direction, tv, \"link-connect\",\n\t    \"%s|%s|%s|%s\\n\", rdns, fcrdns_str, src, dest);\n}\n\nvoid\nlka_report_smtp_link_disconnect(const char *direction, struct timeval *tv, uint64_t reqid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"link-disconnect\", \"\\n\");\n}\n\nvoid\nlka_report_smtp_link_greeting(const char *direction, uint64_t reqid,\n    struct timeval *tv, const char *domain)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"link-greeting\", \"%s\\n\",\n\t    domain);\n}\n\nvoid\nlka_report_smtp_link_auth(const char *direction, struct timeval *tv, uint64_t reqid,\n    const char *username, const char *result)\n{\n\tstruct filter_session *fs;\n\n\tif (strcmp(result, \"pass\") == 0) {\n\t\tfs = tree_xget(&sessions, reqid);\n\t\tfs->username = xstrdup(username);\n\t}\n\treport_smtp_broadcast(reqid, direction, tv, \"link-auth\", \"%s|%s\\n\",\n\t    username, result);\n}\n\nvoid\nlka_report_smtp_link_identify(const char *direction, struct timeval *tv,\n    uint64_t reqid, const char *method, const char *heloname)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"link-identify\", \"%s|%s\\n\",\n\t    method, heloname);\n}\n\nvoid\nlka_report_smtp_link_tls(const char *direction, struct timeval *tv, uint64_t reqid, const char *ciphers)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"link-tls\", \"%s\\n\",\n\t    ciphers);\n}\n\nvoid\nlka_report_smtp_tx_reset(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-reset\", \"%08x\\n\",\n\t    msgid);\n}\n\nvoid\nlka_report_smtp_tx_begin(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-begin\", \"%08x\\n\",\n\t    msgid);\n}\n\nvoid\nlka_report_smtp_tx_mail(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, const char *address, int ok)\n{\n\tconst char *result;\n\n\tswitch (ok) {\n\tcase 1:\n\t\tresult = \"ok\";\n\t\tbreak;\n\tcase 0:\n\t\tresult = \"permfail\";\n\t\tbreak;\n\tdefault:\n\t\tresult = \"tempfail\";\n\t\tbreak;\n\t}\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-mail\", \"%08x|%s|%s\\n\",\n\t    msgid, result, address);\n}\n\nvoid\nlka_report_smtp_tx_rcpt(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, const char *address, int ok)\n{\n\tconst char *result;\n\n\tswitch (ok) {\n\tcase 1:\n\t\tresult = \"ok\";\n\t\tbreak;\n\tcase 0:\n\t\tresult = \"permfail\";\n\t\tbreak;\n\tdefault:\n\t\tresult = \"tempfail\";\n\t\tbreak;\n\t}\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-rcpt\", \"%08x|%s|%s\\n\",\n\t    msgid, result, address);\n}\n\nvoid\nlka_report_smtp_tx_envelope(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, uint64_t evpid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-envelope\",\n\t    \"%08x|%016\"PRIx64\"\\n\", msgid, evpid);\n}\n\nvoid\nlka_report_smtp_tx_data(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, int ok)\n{\n\tconst char *result;\n\n\tswitch (ok) {\n\tcase 1:\n\t\tresult = \"ok\";\n\t\tbreak;\n\tcase 0:\n\t\tresult = \"permfail\";\n\t\tbreak;\n\tdefault:\n\t\tresult = \"tempfail\";\n\t\tbreak;\n\t}\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-data\", \"%08x|%s\\n\",\n\t    msgid, result);\n}\n\nvoid\nlka_report_smtp_tx_commit(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, size_t msgsz)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-commit\", \"%08x|%zd\\n\",\n\t    msgid, msgsz);\n}\n\nvoid\nlka_report_smtp_tx_rollback(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-rollback\", \"%08x\\n\",\n\t    msgid);\n}\n\nvoid\nlka_report_smtp_protocol_client(const char *direction, struct timeval *tv, uint64_t reqid, const char *command)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"protocol-client\", \"%s\\n\",\n\t    command);\n}\n\nvoid\nlka_report_smtp_protocol_server(const char *direction, struct timeval *tv, uint64_t reqid, const char *response)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"protocol-server\", \"%s\\n\",\n\t    response);\n}\n\nvoid\nlka_report_smtp_filter_response(const char *direction, struct timeval *tv, uint64_t reqid,\n    int phase, int response, const char *param)\n{\n\tconst char *phase_name;\n\tconst char *response_name;\n\n\tswitch (phase) {\n\tcase FILTER_CONNECT:\n\t\tphase_name = \"connected\";\n\t\tbreak;\n\tcase FILTER_HELO:\n\t\tphase_name = \"helo\";\n\t\tbreak;\n\tcase FILTER_EHLO:\n\t\tphase_name = \"ehlo\";\n\t\tbreak;\n\tcase FILTER_STARTTLS:\n\t\tphase_name = \"tls\";\n\t\tbreak;\n\tcase FILTER_AUTH:\n\t\tphase_name = \"auth\";\n\t\tbreak;\n\tcase FILTER_MAIL_FROM:\n\t\tphase_name = \"mail-from\";\n\t\tbreak;\n\tcase FILTER_RCPT_TO:\n\t\tphase_name = \"rcpt-to\";\n\t\tbreak;\n\tcase FILTER_DATA:\n\t\tphase_name = \"data\";\n\t\tbreak;\n\tcase FILTER_DATA_LINE:\n\t\tphase_name = \"data-line\";\n\t\tbreak;\n\tcase FILTER_RSET:\n\t\tphase_name = \"rset\";\n\t\tbreak;\n\tcase FILTER_QUIT:\n\t\tphase_name = \"quit\";\n\t\tbreak;\n\tcase FILTER_NOOP:\n\t\tphase_name = \"noop\";\n\t\tbreak;\n\tcase FILTER_HELP:\n\t\tphase_name = \"help\";\n\t\tbreak;\n\tcase FILTER_WIZ:\n\t\tphase_name = \"wiz\";\n\t\tbreak;\n\tcase FILTER_COMMIT:\n\t\tphase_name = \"commit\";\n\t\tbreak;\n\tdefault:\n\t\tphase_name = \"\";\n\t}\n\n\tswitch (response) {\n\tcase FILTER_PROCEED:\n\t\tresponse_name = \"proceed\";\n\t\tbreak;\n\tcase FILTER_JUNK:\n\t\tresponse_name = \"junk\";\n\t\tbreak;\n\tcase FILTER_REWRITE:\n\t\tresponse_name = \"rewrite\";\n\t\tbreak;\n\tcase FILTER_REJECT:\n\t\tresponse_name = \"reject\";\n\t\tbreak;\n\tcase FILTER_DISCONNECT:\n\t\tresponse_name = \"disconnect\";\n\t\tbreak;\n\tdefault:\n\t\tresponse_name = \"\";\n\t}\n\n\treport_smtp_broadcast(reqid, direction, tv, \"filter-response\",\n\t    \"%s|%s%s%s\\n\", phase_name, response_name, param ? \"|\" : \"\",\n\t    param ? param : \"\");\n}\n\nvoid\nlka_report_smtp_timeout(const char *direction, struct timeval *tv, uint64_t reqid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"timeout\", \"\\n\");\n}\n\nvoid\nlka_report_filter_report(uint64_t reqid, const char *name, int builtin,\n    const char *direction, struct timeval *tv, const char *message)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"filter-report\",\n\t    \"%s|%s|%s\\n\", builtin ? \"builtin\" : \"proc\",\n\t    name, message);\n}\n\nvoid\nlka_report_proc(const char *name, const char *line)\n{\n\tchar buffer[LINE_MAX];\n\tstruct timeval tv;\n\tchar *ep, *sp, *direction;\n\tuint64_t reqid;\n\n\tif (strlcpy(buffer, line + 7, sizeof(buffer)) >= sizeof(buffer))\n\t\tfatalx(\"Invalid report: line too long: %s\", line);\n\n\terrno = 0;\n\ttv.tv_sec = strtoll(buffer, &ep, 10);\n\tif (ep[0] != '.' || errno != 0)\n\t\tfatalx(\"Invalid report: invalid time: %s\", line);\n\tsp = ep + 1;\n\ttv.tv_usec = strtol(sp, &ep, 10);\n\tif (ep[0] != '|' || errno != 0)\n\t\tfatalx(\"Invalid report: invalid time: %s\", line);\n\tif (ep - sp != 6)\n\t\tfatalx(\"Invalid report: invalid time: %s\", line);\n\n\tdirection = ep + 1;\n\tif (strncmp(direction, \"smtp-in|\", 8) == 0) {\n\t\tdirection[7] = '\\0';\n\t\tdirection += 7;\n#if 0\n\t} else if (strncmp(direction, \"smtp-out|\", 9) == 0) {\n\t\tdirection[8] = '\\0';\n\t\tdirection += 8;\n#endif\n\t} else\n\t\tfatalx(\"Invalid report: invalid direction: %s\", line);\n\n\treqid = strtoull(sp, &ep, 16);\n\tif (ep[0] != '|' || errno != 0)\n\t\tfatalx(\"Invalid report: invalid reqid: %s\", line);\n\tsp = ep + 1;\n\n\tlka_report_filter_report(reqid, name, 0, direction, &tv, sp);\n}\n"], "filenames": ["usr.sbin/smtpd/lka_filter.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [608], "fixing_code_start_loc": [1], "fixing_code_end_loc": [602], "type": "CWE-476", "message": "smtpd/lka_filter.c in OpenSMTPD before 6.8.0p1, in certain configurations, allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted pattern of client activity, because the filter state machine does not properly maintain the I/O channel between the SMTP engine and the filters layer.", "other": {"cve": {"id": "CVE-2020-35680", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-24T16:15:15.600", "lastModified": "2022-09-02T03:47:31.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "smtpd/lka_filter.c in OpenSMTPD before 6.8.0p1, in certain configurations, allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted pattern of client activity, because the filter state machine does not properly maintain the I/O channel between the SMTP engine and the filters layer."}, {"lang": "es", "value": "El archivo smtpd/lka_filter.c en OpenSMTPD versiones anteriores a 6.8.0p1, en determinadas configuraciones, permite a atacantes remotos causar una denegaci\u00f3n de servicio (desreferencia del puntero NULL y fallo del demonio) por medio de un patr\u00f3n dise\u00f1ado de actividad del cliente, porque la m\u00e1quina de estado del filtro no mantiene apropiadamente el canal de I/O entre el motor SMTP y la capa de filtros"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensmtpd:opensmtpd:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.8.0", "matchCriteriaId": "95277BD3-1335-4B27-AE1A-61FB5C85FE60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensmtpd:opensmtpd:6.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "65FA0447-DC89-4609-824B-ED31E56AD47D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensmtpd:opensmtpd:6.8.0:patch1-rc1:*:*:*:*:*:*", "matchCriteriaId": "DDFB59E5-863A-454F-BDC4-8894E9A15B3D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://github.com/openbsd/src/commit/6c3220444ed06b5796dedfd53a0f4becd903c0d1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5LKTFBQCHGMVPR4IZWHQIYAPM5J3LN3J/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TYAYXRV2DM5K4RU7RHCDZSA2UF6VCTRC/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://poolp.org/posts/2020-12-24/december-2020-opensmtpd-6.8.0p1-released-fixed-several-bugs-proposed-several-diffs-book-is-on-github/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202105-12", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.mail-archive.com/misc@opensmtpd.org/msg05188.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openbsd/src/commit/6c3220444ed06b5796dedfd53a0f4becd903c0d1"}}