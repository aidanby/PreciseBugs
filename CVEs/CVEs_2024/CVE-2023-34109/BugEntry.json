{"buggy_code": ["import { buildRankedDictionary } from './helper'\nimport {\n  TranslationKeys,\n  OptionsType,\n  OptionsDictionary,\n  OptionsL33tTable,\n  OptionsGraph,\n  RankedDictionaries,\n  Matchers,\n  Matcher,\n} from './types'\nimport l33tTable from './data/l33tTable'\nimport translationKeys from './data/translationKeys'\nimport TrieNode from './matcher/dictionary/variants/matching/unmunger/TrieNode'\nimport l33tTableToTrieNode from './matcher/dictionary/variants/matching/unmunger/l33tTableToTrieNode'\n\nexport class Options {\n  matchers: Matchers = {}\n\n  l33tTable: OptionsL33tTable = l33tTable\n\n  trieNodeRoot: TrieNode = l33tTableToTrieNode(l33tTable, new TrieNode())\n\n  dictionary: OptionsDictionary = {\n    userInputs: [],\n  }\n\n  rankedDictionaries: RankedDictionaries = {}\n\n  rankedDictionariesMaxWordSize: Record<string, number> = {}\n\n  translations: TranslationKeys = translationKeys\n\n  graphs: OptionsGraph = {}\n\n  useLevenshteinDistance: boolean = false\n\n  levenshteinThreshold: number = 2\n\n  l33tMaxSubstitutions: number = 512\n\n  maxLength: number = 256\n\n  constructor() {\n    this.setRankedDictionaries()\n  }\n\n  // eslint-disable-next-line max-statements,complexity\n  setOptions(options: OptionsType = {}) {\n    if (options.l33tTable) {\n      this.l33tTable = options.l33tTable\n      this.trieNodeRoot = l33tTableToTrieNode(options.l33tTable, new TrieNode())\n    }\n\n    if (options.dictionary) {\n      this.dictionary = options.dictionary\n\n      this.setRankedDictionaries()\n    }\n\n    if (options.translations) {\n      this.setTranslations(options.translations)\n    }\n\n    if (options.graphs) {\n      this.graphs = options.graphs\n    }\n\n    if (options.useLevenshteinDistance !== undefined) {\n      this.useLevenshteinDistance = options.useLevenshteinDistance\n    }\n\n    if (options.levenshteinThreshold !== undefined) {\n      this.levenshteinThreshold = options.levenshteinThreshold\n    }\n\n    if (options.l33tMaxSubstitutions !== undefined) {\n      this.l33tMaxSubstitutions = options.l33tMaxSubstitutions\n    }\n\n    if (options.maxLength !== undefined) {\n      this.maxLength = options.maxLength\n    }\n  }\n\n  setTranslations(translations: TranslationKeys) {\n    if (this.checkCustomTranslations(translations)) {\n      this.translations = translations\n    } else {\n      throw new Error('Invalid translations object fallback to keys')\n    }\n  }\n\n  checkCustomTranslations(translations: TranslationKeys) {\n    let valid = true\n    Object.keys(translationKeys).forEach((type) => {\n      if (type in translations) {\n        const translationType = type as keyof typeof translationKeys\n        Object.keys(translationKeys[translationType]).forEach((key) => {\n          if (!(key in translations[translationType])) {\n            valid = false\n          }\n        })\n      } else {\n        valid = false\n      }\n    })\n    return valid\n  }\n\n  setRankedDictionaries() {\n    const rankedDictionaries: RankedDictionaries = {}\n    const rankedDictionariesMaxWorkSize: Record<string, number> = {}\n    Object.keys(this.dictionary).forEach((name) => {\n      rankedDictionaries[name] = this.getRankedDictionary(name)\n      rankedDictionariesMaxWorkSize[name] =\n        this.getRankedDictionariesMaxWordSize(name)\n    })\n    this.rankedDictionaries = rankedDictionaries\n    this.rankedDictionariesMaxWordSize = rankedDictionariesMaxWorkSize\n  }\n\n  getRankedDictionariesMaxWordSize(name: string) {\n    const data = this.dictionary[name].map((el) => {\n      if (typeof el !== 'string') {\n        return el.toString().length\n      }\n      return el.length\n    })\n\n    // do not use Math.max(...data) because it can result in max stack size error because every entry will be used as an argument\n    if (data.length === 0) {\n      return 0\n    }\n    return data.reduce((a, b) => Math.max(a, b), -Infinity)\n  }\n\n  getRankedDictionary(name: string) {\n    const list = this.dictionary[name]\n    if (name === 'userInputs') {\n      const sanitizedInputs: string[] = []\n\n      list.forEach((input: string | number | boolean) => {\n        const inputType = typeof input\n        if (\n          inputType === 'string' ||\n          inputType === 'number' ||\n          inputType === 'boolean'\n        ) {\n          sanitizedInputs.push(input.toString().toLowerCase())\n        }\n      })\n\n      return buildRankedDictionary(sanitizedInputs)\n    }\n    return buildRankedDictionary(list)\n  }\n\n  extendUserInputsDictionary(dictionary: (string | number)[]) {\n    if (this.dictionary.userInputs) {\n      this.dictionary.userInputs = [\n        ...this.dictionary.userInputs,\n        ...dictionary,\n      ]\n    } else {\n      this.dictionary.userInputs = dictionary\n    }\n\n    this.rankedDictionaries.userInputs = this.getRankedDictionary('userInputs')\n    this.rankedDictionariesMaxWordSize.userInputs =\n      this.getRankedDictionariesMaxWordSize('userInputs')\n  }\n\n  public addMatcher(name: string, matcher: Matcher) {\n    if (this.matchers[name]) {\n      console.info(`Matcher ${name} already exists`)\n    } else {\n      this.matchers[name] = matcher\n    }\n  }\n}\n\nexport const zxcvbnOptions = new Options()\n"], "fixing_code": ["import { buildRankedDictionary } from './helper'\nimport {\n  TranslationKeys,\n  OptionsType,\n  OptionsDictionary,\n  OptionsL33tTable,\n  OptionsGraph,\n  RankedDictionaries,\n  Matchers,\n  Matcher,\n} from './types'\nimport l33tTable from './data/l33tTable'\nimport translationKeys from './data/translationKeys'\nimport TrieNode from './matcher/dictionary/variants/matching/unmunger/TrieNode'\nimport l33tTableToTrieNode from './matcher/dictionary/variants/matching/unmunger/l33tTableToTrieNode'\n\nexport class Options {\n  matchers: Matchers = {}\n\n  l33tTable: OptionsL33tTable = l33tTable\n\n  trieNodeRoot: TrieNode = l33tTableToTrieNode(l33tTable, new TrieNode())\n\n  dictionary: OptionsDictionary = {\n    userInputs: [],\n  }\n\n  rankedDictionaries: RankedDictionaries = {}\n\n  rankedDictionariesMaxWordSize: Record<string, number> = {}\n\n  translations: TranslationKeys = translationKeys\n\n  graphs: OptionsGraph = {}\n\n  useLevenshteinDistance: boolean = false\n\n  levenshteinThreshold: number = 2\n\n  l33tMaxSubstitutions: number = 512\n\n  maxLength: number = 256\n\n  constructor() {\n    this.setRankedDictionaries()\n  }\n\n  // eslint-disable-next-line max-statements,complexity\n  setOptions(options: OptionsType = {}) {\n    if (options.l33tTable) {\n      this.l33tTable = options.l33tTable\n      this.trieNodeRoot = l33tTableToTrieNode(options.l33tTable, new TrieNode())\n    }\n\n    if (options.dictionary) {\n      this.dictionary = options.dictionary\n\n      this.setRankedDictionaries()\n    }\n\n    if (options.translations) {\n      this.setTranslations(options.translations)\n    }\n\n    if (options.graphs) {\n      this.graphs = options.graphs\n    }\n\n    if (options.useLevenshteinDistance !== undefined) {\n      this.useLevenshteinDistance = options.useLevenshteinDistance\n    }\n\n    if (options.levenshteinThreshold !== undefined) {\n      this.levenshteinThreshold = options.levenshteinThreshold\n    }\n\n    if (options.l33tMaxSubstitutions !== undefined) {\n      this.l33tMaxSubstitutions = options.l33tMaxSubstitutions\n    }\n\n    if (options.maxLength !== undefined) {\n      this.maxLength = options.maxLength\n    }\n  }\n\n  setTranslations(translations: TranslationKeys) {\n    if (this.checkCustomTranslations(translations)) {\n      this.translations = translations\n    } else {\n      throw new Error('Invalid translations object fallback to keys')\n    }\n  }\n\n  checkCustomTranslations(translations: TranslationKeys) {\n    let valid = true\n    Object.keys(translationKeys).forEach((type) => {\n      if (type in translations) {\n        const translationType = type as keyof typeof translationKeys\n        Object.keys(translationKeys[translationType]).forEach((key) => {\n          if (!(key in translations[translationType])) {\n            valid = false\n          }\n        })\n      } else {\n        valid = false\n      }\n    })\n    return valid\n  }\n\n  setRankedDictionaries() {\n    const rankedDictionaries: RankedDictionaries = {}\n    const rankedDictionariesMaxWorkSize: Record<string, number> = {}\n    Object.keys(this.dictionary).forEach((name) => {\n      rankedDictionaries[name] = buildRankedDictionary(this.dictionary[name])\n      rankedDictionariesMaxWorkSize[name] =\n        this.getRankedDictionariesMaxWordSize(this.dictionary[name])\n    })\n    this.rankedDictionaries = rankedDictionaries\n    this.rankedDictionariesMaxWordSize = rankedDictionariesMaxWorkSize\n  }\n\n  getRankedDictionariesMaxWordSize(list: (string | number)[]) {\n    const data = list.map((el) => {\n      if (typeof el !== 'string') {\n        return el.toString().length\n      }\n      return el.length\n    })\n\n    // do not use Math.max(...data) because it can result in max stack size error because every entry will be used as an argument\n    if (data.length === 0) {\n      return 0\n    }\n    return data.reduce((a, b) => Math.max(a, b), -Infinity)\n  }\n\n  buildSanitizedRankedDictionary(list: (string | number)[]) {\n    const sanitizedInputs: string[] = []\n\n    list.forEach((input: string | number | boolean) => {\n      const inputType = typeof input\n      if (\n        inputType === 'string' ||\n        inputType === 'number' ||\n        inputType === 'boolean'\n      ) {\n        sanitizedInputs.push(input.toString().toLowerCase())\n      }\n    })\n\n    return buildRankedDictionary(sanitizedInputs)\n  }\n\n  extendUserInputsDictionary(dictionary: (string | number)[]) {\n    if (!this.dictionary.userInputs) {\n      this.dictionary.userInputs = []\n    }\n\n    const newList = [...this.dictionary.userInputs, ...dictionary]\n    this.rankedDictionaries.userInputs =\n      this.buildSanitizedRankedDictionary(newList)\n    this.rankedDictionariesMaxWordSize.userInputs =\n      this.getRankedDictionariesMaxWordSize(newList)\n  }\n\n  public addMatcher(name: string, matcher: Matcher) {\n    if (this.matchers[name]) {\n      console.info(`Matcher ${name} already exists`)\n    } else {\n      this.matchers[name] = matcher\n    }\n  }\n}\n\nexport const zxcvbnOptions = new Options()\n"], "filenames": ["packages/libraries/main/src/Options.ts"], "buggy_code_start_loc": [115], "buggy_code_end_loc": [172], "fixing_code_start_loc": [115], "fixing_code_end_loc": [165], "type": "CWE-400", "message": "zxcvbn-ts is an open source password strength estimator written in typescript. This vulnerability affects users running on the nodeJS platform which are using the second argument of the zxcvbn function. It can result in an unbounded resource consumption as the user inputs array is extended with every function call. Browsers are impacted, too but a single user need to do a lot of input changes so that it affects the browser, while the node process gets the inputs of every user of a platform and can be killed that way. This problem has been patched in version 3.0.2. Users are advised to upgrade. Users unable to upgrade should stop using the second argument of the zxcvbn function and use the zxcvbnOptions.setOptions function.", "other": {"cve": {"id": "CVE-2023-34109", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-07T18:15:09.903", "lastModified": "2023-06-15T15:41:44.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "zxcvbn-ts is an open source password strength estimator written in typescript. This vulnerability affects users running on the nodeJS platform which are using the second argument of the zxcvbn function. It can result in an unbounded resource consumption as the user inputs array is extended with every function call. Browsers are impacted, too but a single user need to do a lot of input changes so that it affects the browser, while the node process gets the inputs of every user of a platform and can be killed that way. This problem has been patched in version 3.0.2. Users are advised to upgrade. Users unable to upgrade should stop using the second argument of the zxcvbn function and use the zxcvbnOptions.setOptions function."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zxcvbn-ts_project:zxcvbn-ts:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.0.2", "matchCriteriaId": "E2A6456F-CD46-4253-895D-095361029F3A"}]}]}], "references": [{"url": "https://github.com/zxcvbn-ts/zxcvbn/commit/3f9bed21b5d01f6f6863476822ca857355fba22f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/zxcvbn-ts/zxcvbn/security/advisories/GHSA-38hx-x5hq-5fg4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zxcvbn-ts/zxcvbn/commit/3f9bed21b5d01f6f6863476822ca857355fba22f"}}