{"buggy_code": ["/*\n * loader.c: Image Loader \n *\n * Authors:\n *   Paolo Molaro (lupus@ximian.com)\n *   Miguel de Icaza (miguel@ximian.com)\n *   Patrik Torstensson (patrik.torstensson@labs2.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n *\n * This file is used by the interpreter and the JIT engine to locate\n * assemblies.  Used to load AssemblyRef and later to resolve various\n * kinds of `Refs'.\n *\n * TODO:\n *   This should keep track of the assembly versions that we are loading.\n *\n */\n#include <config.h>\n#include <glib.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <mono/metadata/metadata.h>\n#include <mono/metadata/image.h>\n#include <mono/metadata/assembly.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/metadata-internals.h>\n#include <mono/metadata/loader.h>\n#include <mono/metadata/class-internals.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/reflection.h>\n#include <mono/metadata/profiler.h>\n#include <mono/metadata/profiler-private.h>\n#include <mono/metadata/exception.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/lock-tracer.h>\n#include <mono/metadata/verify-internals.h>\n#include <mono/utils/mono-logger-internal.h>\n#include <mono/utils/mono-dl.h>\n#include <mono/utils/mono-membar.h>\n#include <mono/utils/mono-counters.h>\n#include <mono/utils/mono-error-internals.h>\n\nMonoDefaults mono_defaults;\n\n/*\n * This lock protects the hash tables inside MonoImage used by the metadata \n * loading functions in class.c and loader.c.\n *\n * See domain-internals.h for locking policy in combination with the\n * domain lock.\n */\nstatic CRITICAL_SECTION loader_mutex;\nstatic gboolean loader_lock_inited;\n\n/* Statistics */\nstatic guint32 inflated_signatures_size;\nstatic guint32 memberref_sig_cache_size;\n\n/*\n * This TLS variable contains the last type load error encountered by the loader.\n */\nguint32 loader_error_thread_id;\n\n/*\n * This TLS variable holds how many times the current thread has acquired the loader \n * lock.\n */\nguint32 loader_lock_nest_id;\n\nstatic void dllmap_cleanup (void);\n\nvoid\nmono_loader_init ()\n{\n\tstatic gboolean inited;\n\n\tif (!inited) {\n\t\tInitializeCriticalSection (&loader_mutex);\n\t\tloader_lock_inited = TRUE;\n\n\t\tloader_error_thread_id = TlsAlloc ();\n\t\tloader_lock_nest_id = TlsAlloc ();\n\n\t\tmono_counters_register (\"Inflated signatures size\",\n\t\t\t\t\t\t\t\tMONO_COUNTER_GENERICS | MONO_COUNTER_INT, &inflated_signatures_size);\n\t\tmono_counters_register (\"Memberref signature cache size\",\n\t\t\t\t\t\t\t\tMONO_COUNTER_METADATA | MONO_COUNTER_INT, &memberref_sig_cache_size);\n\n\t\tinited = TRUE;\n\t}\n}\n\nvoid\nmono_loader_cleanup (void)\n{\n\tdllmap_cleanup ();\n\n\tTlsFree (loader_error_thread_id);\n\tTlsFree (loader_lock_nest_id);\n\n\tDeleteCriticalSection (&loader_mutex);\n\tloader_lock_inited = FALSE;\t\n}\n\n/*\n * Handling of type load errors should be done as follows:\n *\n *   If something could not be loaded, the loader should call one of the\n * mono_loader_set_error_XXX functions ()\n * with the appropriate arguments, then return NULL to report the failure. The error \n * should be propagated until it reaches code which can throw managed exceptions. At that\n * point, an exception should be thrown based on the information returned by\n * mono_loader_get_last_error (). Then the error should be cleared by calling \n * mono_loader_clear_error ().\n */\n\nstatic void\nset_loader_error (MonoLoaderError *error)\n{\n\tTlsSetValue (loader_error_thread_id, error);\n}\n\n/**\n * mono_loader_set_error_assembly_load:\n *\n * Set the loader error for this thread. \n */\nvoid\nmono_loader_set_error_assembly_load (const char *assembly_name, gboolean ref_only)\n{\n\tMonoLoaderError *error;\n\n\tif (mono_loader_get_last_error ()) \n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_FILE_NOT_FOUND;\n\terror->assembly_name = g_strdup (assembly_name);\n\terror->ref_only = ref_only;\n\n\t/* \n\t * This is not strictly needed, but some (most) of the loader code still\n\t * can't deal with load errors, and this message is more helpful than an\n\t * assert.\n\t */\n\tif (ref_only)\n\t\tg_warning (\"Cannot resolve dependency to assembly '%s' because it has not been preloaded. When using the ReflectionOnly APIs, dependent assemblies must be pre-loaded or loaded on demand through the ReflectionOnlyAssemblyResolve event.\", assembly_name);\n\telse\n\t\tg_warning (\"Could not load file or assembly '%s' or one of its dependencies.\", assembly_name);\n\n\tset_loader_error (error);\n}\n\n/**\n * mono_loader_set_error_type_load:\n *\n * Set the loader error for this thread. \n */\nvoid\nmono_loader_set_error_type_load (const char *class_name, const char *assembly_name)\n{\n\tMonoLoaderError *error;\n\n\tif (mono_loader_get_last_error ()) \n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_TYPE_LOAD;\n\terror->class_name = g_strdup (class_name);\n\terror->assembly_name = g_strdup (assembly_name);\n\n\t/* \n\t * This is not strictly needed, but some (most) of the loader code still\n\t * can't deal with load errors, and this message is more helpful than an\n\t * assert.\n\t */\n\tmono_trace_warning (MONO_TRACE_TYPE, \"The class %s could not be loaded, used in %s\", class_name, assembly_name);\n\n\tset_loader_error (error);\n}\n\n/*\n * mono_loader_set_error_method_load:\n *\n *   Set the loader error for this thread. MEMBER_NAME should point to a string\n * inside metadata.\n */\nvoid\nmono_loader_set_error_method_load (const char *class_name, const char *member_name)\n{\n\tMonoLoaderError *error;\n\n\t/* FIXME: Store the signature as well */\n\tif (mono_loader_get_last_error ())\n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_MISSING_METHOD;\n\terror->class_name = g_strdup (class_name);\n\terror->member_name = member_name;\n\n\tset_loader_error (error);\n}\n\n/*\n * mono_loader_set_error_field_load:\n *\n * Set the loader error for this thread. MEMBER_NAME should point to a string\n * inside metadata.\n */\nvoid\nmono_loader_set_error_field_load (MonoClass *klass, const char *member_name)\n{\n\tMonoLoaderError *error;\n\n\t/* FIXME: Store the signature as well */\n\tif (mono_loader_get_last_error ())\n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_MISSING_FIELD;\n\terror->klass = klass;\n\terror->member_name = member_name;\n\n\tset_loader_error (error);\n}\n\n/*\n * mono_loader_set_error_bad_image:\n *\n * Set the loader error for this thread. \n */\nvoid\nmono_loader_set_error_bad_image (char *msg)\n{\n\tMonoLoaderError *error;\n\n\tif (mono_loader_get_last_error ())\n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_BAD_IMAGE;\n\terror->msg = msg;\n\n\tset_loader_error (error);\n}\t\n\n\n/*\n * mono_loader_get_last_error:\n *\n *   Returns information about the last type load exception encountered by the loader, or\n * NULL. After use, the exception should be cleared by calling mono_loader_clear_error.\n */\nMonoLoaderError*\nmono_loader_get_last_error (void)\n{\n\treturn (MonoLoaderError*)TlsGetValue (loader_error_thread_id);\n}\n\n/**\n * mono_loader_clear_error:\n *\n * Disposes any loader error messages on this thread\n */\nvoid\nmono_loader_clear_error (void)\n{\n\tMonoLoaderError *ex = (MonoLoaderError*)TlsGetValue (loader_error_thread_id);\n\n\tif (ex) {\n\t\tg_free (ex->class_name);\n\t\tg_free (ex->assembly_name);\n\t\tg_free (ex->msg);\n\t\tg_free (ex);\n\t\n\t\tTlsSetValue (loader_error_thread_id, NULL);\n\t}\n}\n\n/**\n * mono_loader_error_prepare_exception:\n * @error: The MonoLoaderError to turn into an exception\n *\n * This turns a MonoLoaderError into an exception that can be thrown\n * and resets the Mono Loader Error state during this process.\n *\n */\nMonoException *\nmono_loader_error_prepare_exception (MonoLoaderError *error)\n{\n\tMonoException *ex = NULL;\n\n\tswitch (error->exception_type) {\n\tcase MONO_EXCEPTION_TYPE_LOAD: {\n\t\tchar *cname = g_strdup (error->class_name);\n\t\tchar *aname = g_strdup (error->assembly_name);\n\t\tMonoString *class_name;\n\t\t\n\t\tmono_loader_clear_error ();\n\t\t\n\t\tclass_name = mono_string_new (mono_domain_get (), cname);\n\n\t\tex = mono_get_exception_type_load (class_name, aname);\n\t\tg_free (cname);\n\t\tg_free (aname);\n\t\tbreak;\n        }\n\tcase MONO_EXCEPTION_MISSING_METHOD: {\n\t\tchar *cname = g_strdup (error->class_name);\n\t\tchar *aname = g_strdup (error->member_name);\n\t\t\n\t\tmono_loader_clear_error ();\n\t\tex = mono_get_exception_missing_method (cname, aname);\n\t\tg_free (cname);\n\t\tg_free (aname);\n\t\tbreak;\n\t}\n\t\t\n\tcase MONO_EXCEPTION_MISSING_FIELD: {\n\t\tchar *cnspace = g_strdup ((error->klass && *error->klass->name_space) ? error->klass->name_space : \"\");\n\t\tchar *cname = g_strdup (error->klass ? error->klass->name : \"\");\n\t\tchar *cmembername = g_strdup (error->member_name);\n                char *class_name;\n\n\t\tmono_loader_clear_error ();\n\t\tclass_name = g_strdup_printf (\"%s%s%s\", cnspace, cnspace ? \".\" : \"\", cname);\n\t\t\n\t\tex = mono_get_exception_missing_field (class_name, cmembername);\n\t\tg_free (class_name);\n\t\tg_free (cname);\n\t\tg_free (cmembername);\n\t\tg_free (cnspace);\n\t\tbreak;\n        }\n\t\n\tcase MONO_EXCEPTION_FILE_NOT_FOUND: {\n\t\tchar *msg;\n\t\tchar *filename;\n\n\t\tif (error->ref_only)\n\t\t\tmsg = g_strdup_printf (\"Cannot resolve dependency to assembly '%s' because it has not been preloaded. When using the ReflectionOnly APIs, dependent assemblies must be pre-loaded or loaded on demand through the ReflectionOnlyAssemblyResolve event.\", error->assembly_name);\n\t\telse\n\t\t\tmsg = g_strdup_printf (\"Could not load file or assembly '%s' or one of its dependencies.\", error->assembly_name);\n\t\tfilename = g_strdup (error->assembly_name);\n\t\t/* Has to call this before calling anything which might call mono_class_init () */\n\t\tmono_loader_clear_error ();\n\t\tex = mono_get_exception_file_not_found2 (msg, mono_string_new (mono_domain_get (), filename));\n\t\tg_free (msg);\n\t\tg_free (filename);\n\t\tbreak;\n\t}\n\n\tcase MONO_EXCEPTION_BAD_IMAGE: {\n\t\tchar *msg = g_strdup (error->msg);\n\t\tmono_loader_clear_error ();\n\t\tex = mono_get_exception_bad_image_format (msg);\n\t\tg_free (msg);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\treturn ex;\n}\n\n/*\n * find_cached_memberref_sig:\n *\n *   Return a cached copy of the memberref signature identified by SIG_IDX.\n * We use a gpointer since the cache stores both MonoTypes and MonoMethodSignatures.\n * A cache is needed since the type/signature parsing routines allocate everything \n * from a mempool, so without a cache, multiple requests for the same signature would \n * lead to unbounded memory growth. For normal methods/fields this is not a problem \n * since the resulting methods/fields are cached, but inflated methods/fields cannot\n * be cached.\n * LOCKING: Acquires the loader lock.\n */\nstatic gpointer\nfind_cached_memberref_sig (MonoImage *image, guint32 sig_idx)\n{\n\tgpointer res;\n\n\tmono_loader_lock ();\n\tres = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));\n\tmono_loader_unlock ();\n\n\treturn res;\n}\n\nstatic gpointer\ncache_memberref_sig (MonoImage *image, guint32 sig_idx, gpointer sig)\n{\n\tgpointer prev_sig;\n\n\tmono_loader_lock ();\n\tprev_sig = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));\n\tif (prev_sig) {\n\t\t/* Somebody got in before us */\n\t\tsig = prev_sig;\n\t}\n\telse {\n\t\tg_hash_table_insert (image->memberref_signatures, GUINT_TO_POINTER (sig_idx), sig);\n\t\t/* An approximation based on glib 2.18 */\n\t\tmemberref_sig_cache_size += sizeof (gpointer) * 4;\n\t}\n\n\tmono_loader_unlock ();\n\n\treturn sig;\n}\n\nstatic MonoClassField*\nfield_from_memberref (MonoImage *image, guint32 token, MonoClass **retklass,\n\t\t      MonoGenericContext *context)\n{\n\tMonoClass *klass;\n\tMonoClassField *field;\n\tMonoTableInfo *tables = image->tables;\n\tMonoType *sig_type;\n\tguint32 cols[6];\n\tguint32 nindex, class, class_table;\n\tconst char *fname;\n\tconst char *ptr;\n\tguint32 idx = mono_metadata_token_index (token);\n\n\tmono_metadata_decode_row (&tables [MONO_TABLE_MEMBERREF], idx-1, cols, MONO_MEMBERREF_SIZE);\n\tnindex = cols [MONO_MEMBERREF_CLASS] >> MONO_MEMBERREF_PARENT_BITS;\n\tclass = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\n\tfname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\tif (!mono_verifier_verify_memberref_signature (image, cols [MONO_MEMBERREF_SIGNATURE], NULL)) {\n\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad field signature class token 0x%08x field name %s token 0x%08x on image %s\", class, fname, token, image->name));\n\t\treturn NULL;\n\t}\n\n\tswitch (class) {\n\tcase MONO_MEMBERREF_PARENT_TYPEDEF:\n\t\tclass_table = MONO_TOKEN_TYPE_DEF;\n\t\tklass = mono_class_get (image, MONO_TOKEN_TYPE_DEF | nindex);\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPEREF:\n\t\tclass_table = MONO_TOKEN_TYPE_REF;\n\t\tklass = mono_class_from_typeref (image, MONO_TOKEN_TYPE_REF | nindex);\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPESPEC:\n\t\tclass_table = MONO_TOKEN_TYPE_SPEC;\n\t\tklass = mono_class_get_full (image, MONO_TOKEN_TYPE_SPEC | nindex, context);\n\t\tbreak;\n\tdefault:\n\t\t/*FIXME this must set a loader error!*/\n\t\tg_warning (\"field load from %x\", class);\n\t\treturn NULL;\n\t}\n\n\tif (!klass) {\n\t\tchar *name = mono_class_name_from_token (image, class_table | nindex);\n\t\tg_warning (\"Missing field %s in class %s (type token %d)\", fname, name, class_table | nindex);\n\t\tmono_loader_set_error_type_load (name, image->assembly_name);\n\t\tg_free (name);\n\t\treturn NULL;\n\t}\n\n\tptr = mono_metadata_blob_heap (image, cols [MONO_MEMBERREF_SIGNATURE]);\n\tmono_metadata_decode_blob_size (ptr, &ptr);\n\t/* we may want to check the signature here... */\n\n\tif (*ptr++ != 0x6) {\n\t\tg_warning (\"Bad field signature class token %08x field name %s token %08x\", class, fname, token);\n\t\tmono_loader_set_error_field_load (klass, fname);\n\t\treturn NULL;\n\t}\n\t/* FIXME: This needs a cache, especially for generic instances, since\n\t * mono_metadata_parse_type () allocates everything from a mempool.\n\t */\n\tsig_type = find_cached_memberref_sig (image, cols [MONO_MEMBERREF_SIGNATURE]);\n\tif (!sig_type) {\n\t\tsig_type = mono_metadata_parse_type (image, MONO_PARSE_TYPE, 0, ptr, &ptr);\n\t\tif (sig_type == NULL) {\n\t\t\tmono_loader_set_error_field_load (klass, fname);\n\t\t\treturn NULL;\n\t\t}\n\t\tsig_type = cache_memberref_sig (image, cols [MONO_MEMBERREF_SIGNATURE], sig_type);\n\t}\n\n\tmono_class_init (klass); /*FIXME is this really necessary?*/\n\tif (retklass)\n\t\t*retklass = klass;\n\tfield = mono_class_get_field_from_name_full (klass, fname, sig_type);\n\n\tif (!field)\n\t\tmono_loader_set_error_field_load (klass, fname);\n\n\treturn field;\n}\n\nMonoClassField*\nmono_field_from_token (MonoImage *image, guint32 token, MonoClass **retklass,\n\t\t       MonoGenericContext *context)\n{\n\tMonoClass *k;\n\tguint32 type;\n\tMonoClassField *field;\n\n\tif (image->dynamic) {\n\t\tMonoClassField *result;\n\t\tMonoClass *handle_class;\n\n\t\t*retklass = NULL;\n\t\tresult = mono_lookup_dynamic_token_class (image, token, TRUE, &handle_class, context);\n\t\t// This checks the memberref type as well\n\t\tif (!result || handle_class != mono_defaults.fieldhandle_class) {\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad field token 0x%08x on image %s.\", token, image->name));\n\t\t\treturn NULL;\n\t\t}\n\t\t*retklass = result->parent;\n\t\treturn result;\n\t}\n\n\tmono_loader_lock ();\n\tif ((field = g_hash_table_lookup (image->field_cache, GUINT_TO_POINTER (token)))) {\n\t\t*retklass = field->parent;\n\t\tmono_loader_unlock ();\n\t\treturn field;\n\t}\n\tmono_loader_unlock ();\n\n\tif (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF)\n\t\tfield = field_from_memberref (image, token, retklass, context);\n\telse {\n\t\ttype = mono_metadata_typedef_from_field (image, mono_metadata_token_index (token));\n\t\tif (!type)\n\t\t\treturn NULL;\n\t\tk = mono_class_get (image, MONO_TOKEN_TYPE_DEF | type);\n\t\tif (!k)\n\t\t\treturn NULL;\n\t\tmono_class_init (k);\n\t\tif (retklass)\n\t\t\t*retklass = k;\n\t\tfield = mono_class_get_field (k, token);\n\t}\n\n\tmono_loader_lock ();\n\tif (field && field->parent && !field->parent->generic_class && !field->parent->generic_container)\n\t\tg_hash_table_insert (image->field_cache, GUINT_TO_POINTER (token), field);\n\tmono_loader_unlock ();\n\treturn field;\n}\n\nstatic gboolean\nmono_metadata_signature_vararg_match (MonoMethodSignature *sig1, MonoMethodSignature *sig2)\n{\n\tint i;\n\n\tif (sig1->hasthis != sig2->hasthis ||\n\t    sig1->sentinelpos != sig2->sentinelpos)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < sig1->sentinelpos; i++) { \n\t\tMonoType *p1 = sig1->params[i];\n\t\tMonoType *p2 = sig2->params[i];\n\n\t\t/*if (p1->attrs != p2->attrs)\n\t\t\treturn FALSE;\n\t\t*/\n\t\tif (!mono_metadata_type_equal (p1, p2))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!mono_metadata_type_equal (sig1->ret, sig2->ret))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nstatic MonoMethod *\nfind_method_in_class (MonoClass *klass, const char *name, const char *qname, const char *fqname,\n\t\t      MonoMethodSignature *sig, MonoClass *from_class)\n{\n \tint i;\n\n\t/* Search directly in the metadata to avoid calling setup_methods () */\n\n\t/* FIXME: !from_class->generic_class condition causes test failures. */\n\tif (klass->type_token && !klass->image->dynamic && !klass->methods && !klass->rank && klass == from_class && !from_class->generic_class) {\n\t\tfor (i = 0; i < klass->method.count; ++i) {\n\t\t\tguint32 cols [MONO_METHOD_SIZE];\n\t\t\tMonoMethod *method;\n\t\t\tconst char *m_name;\n\t\t\tMonoMethodSignature *other_sig;\n\n\t\t\tmono_metadata_decode_table_row (klass->image, MONO_TABLE_METHOD, klass->method.first + i, cols, MONO_METHOD_SIZE);\n\n\t\t\tm_name = mono_metadata_string_heap (klass->image, cols [MONO_METHOD_NAME]);\n\n\t\t\tif (!((fqname && !strcmp (m_name, fqname)) ||\n\t\t\t\t  (qname && !strcmp (m_name, qname)) ||\n\t\t\t\t  (name && !strcmp (m_name, name))))\n\t\t\t\tcontinue;\n\n\t\t\tmethod = mono_get_method (klass->image, MONO_TOKEN_METHOD_DEF | (klass->method.first + i + 1), klass);\n\t\t\tother_sig = mono_method_signature (method);\n\t\t\tif (method && other_sig && (sig->call_convention != MONO_CALL_VARARG) && mono_metadata_signature_equal (sig, other_sig))\n\t\t\t\treturn method;\n\t\t}\n\t}\n\n\tmono_class_setup_methods (klass);\n\t/*\n\tWe can't fail lookup of methods otherwise the runtime will fail with MissingMethodException instead of TypeLoadException.\n\tSee mono/tests/generic-type-load-exception.2.il\n\tFIXME we should better report this error to the caller\n\t */\n\tif (!klass->methods)\n\t\treturn NULL;\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tMonoMethod *m = klass->methods [i];\n\t\tMonoMethodSignature *msig;\n\n\t\tif (!((fqname && !strcmp (m->name, fqname)) ||\n\t\t      (qname && !strcmp (m->name, qname)) ||\n\t\t      (name && !strcmp (m->name, name))))\n\t\t\tcontinue;\n\t\tmsig = mono_method_signature (m);\n\t\tif (!msig)\n\t\t\tcontinue;\n\n\t\tif (sig->call_convention == MONO_CALL_VARARG) {\n\t\t\tif (mono_metadata_signature_vararg_match (sig, msig))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (mono_metadata_signature_equal (sig, msig))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i < klass->method.count)\n\t\treturn mono_class_get_method_by_index (from_class, i);\n\treturn NULL;\n}\n\nstatic MonoMethod *\nfind_method (MonoClass *in_class, MonoClass *ic, const char* name, MonoMethodSignature *sig, MonoClass *from_class)\n{\n\tint i;\n\tchar *qname, *fqname, *class_name;\n\tgboolean is_interface;\n\tMonoMethod *result = NULL;\n\n\tis_interface = MONO_CLASS_IS_INTERFACE (in_class);\n\n\tif (ic) {\n\t\tclass_name = mono_type_get_name_full (&ic->byval_arg, MONO_TYPE_NAME_FORMAT_IL);\n\n\t\tqname = g_strconcat (class_name, \".\", name, NULL); \n\t\tif (ic->name_space && ic->name_space [0])\n\t\t\tfqname = g_strconcat (ic->name_space, \".\", class_name, \".\", name, NULL);\n\t\telse\n\t\t\tfqname = NULL;\n\t} else\n\t\tclass_name = qname = fqname = NULL;\n\n\twhile (in_class) {\n\t\tg_assert (from_class);\n\t\tresult = find_method_in_class (in_class, name, qname, fqname, sig, from_class);\n\t\tif (result)\n\t\t\tgoto out;\n\n\t\tif (name [0] == '.' && (!strcmp (name, \".ctor\") || !strcmp (name, \".cctor\")))\n\t\t\tbreak;\n\n\t\tg_assert (from_class->interface_offsets_count == in_class->interface_offsets_count);\n\t\tfor (i = 0; i < in_class->interface_offsets_count; i++) {\n\t\t\tMonoClass *in_ic = in_class->interfaces_packed [i];\n\t\t\tMonoClass *from_ic = from_class->interfaces_packed [i];\n\t\t\tchar *ic_qname, *ic_fqname, *ic_class_name;\n\t\t\t\n\t\t\tic_class_name = mono_type_get_name_full (&in_ic->byval_arg, MONO_TYPE_NAME_FORMAT_IL);\n\t\t\tic_qname = g_strconcat (ic_class_name, \".\", name, NULL); \n\t\t\tif (in_ic->name_space && in_ic->name_space [0])\n\t\t\t\tic_fqname = g_strconcat (in_ic->name_space, \".\", ic_class_name, \".\", name, NULL);\n\t\t\telse\n\t\t\t\tic_fqname = NULL;\n\n\t\t\tresult = find_method_in_class (in_ic, ic ? name : NULL, ic_qname, ic_fqname, sig, from_ic);\n\t\t\tg_free (ic_class_name);\n\t\t\tg_free (ic_fqname);\n\t\t\tg_free (ic_qname);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tin_class = in_class->parent;\n\t\tfrom_class = from_class->parent;\n\t}\n\tg_assert (!in_class == !from_class);\n\n\tif (is_interface)\n\t\tresult = find_method_in_class (mono_defaults.object_class, name, qname, fqname, sig, mono_defaults.object_class);\n\n out:\n\tg_free (class_name);\n\tg_free (fqname);\n\tg_free (qname);\n\treturn result;\n}\n\nstatic MonoMethodSignature*\ninflate_generic_signature_checked (MonoImage *image, MonoMethodSignature *sig, MonoGenericContext *context, MonoError *error)\n{\n\tMonoMethodSignature *res;\n\tgboolean is_open;\n\tint i;\n\n\tmono_error_init (error);\n\tif (!context)\n\t\treturn sig;\n\n\tres = g_malloc0 (MONO_SIZEOF_METHOD_SIGNATURE + ((gint32)sig->param_count) * sizeof (MonoType*));\n\tres->param_count = sig->param_count;\n\tres->sentinelpos = -1;\n\tres->ret = mono_class_inflate_generic_type_checked (sig->ret, context, error);\n\tif (!mono_error_ok (error))\n\t\tgoto fail;\n\tis_open = mono_class_is_open_constructed_type (res->ret);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tres->params [i] = mono_class_inflate_generic_type_checked (sig->params [i], context, error);\n\t\tif (!mono_error_ok (error))\n\t\t\tgoto fail;\n\n\t\tif (!is_open)\n\t\t\tis_open = mono_class_is_open_constructed_type (res->params [i]);\n\t}\n\tres->hasthis = sig->hasthis;\n\tres->explicit_this = sig->explicit_this;\n\tres->call_convention = sig->call_convention;\n\tres->pinvoke = sig->pinvoke;\n\tres->generic_param_count = sig->generic_param_count;\n\tres->sentinelpos = sig->sentinelpos;\n\tres->has_type_parameters = is_open;\n\tres->is_inflated = 1;\n\treturn res;\n\nfail:\n\tif (res->ret)\n\t\tmono_metadata_free_type (res->ret);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tif (res->params [i])\n\t\t\tmono_metadata_free_type (res->params [i]);\n\t}\n\tg_free (res);\n\treturn NULL;\n}\n\nstatic MonoMethodHeader*\ninflate_generic_header (MonoMethodHeader *header, MonoGenericContext *context)\n{\n\tMonoMethodHeader *res;\n\tint i;\n\tres = g_malloc0 (MONO_SIZEOF_METHOD_HEADER + sizeof (gpointer) * header->num_locals);\n\tres->code = header->code;\n\tres->code_size = header->code_size;\n\tres->max_stack = header->max_stack;\n\tres->num_clauses = header->num_clauses;\n\tres->init_locals = header->init_locals;\n\tres->num_locals = header->num_locals;\n\tres->clauses = header->clauses;\n\tfor (i = 0; i < header->num_locals; ++i)\n\t\tres->locals [i] = mono_class_inflate_generic_type (header->locals [i], context);\n\tif (res->num_clauses) {\n\t\tres->clauses = g_memdup (header->clauses, sizeof (MonoExceptionClause) * res->num_clauses);\n\t\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\t\tMonoExceptionClause *clause = &res->clauses [i];\n\t\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_NONE)\n\t\t\t\tcontinue;\n\t\t\tclause->data.catch_class = mono_class_inflate_generic_class (clause->data.catch_class, context);\n\t\t}\n\t}\n\treturn res;\n}\n\n/*\n * token is the method_ref/def/spec token used in a call IL instruction.\n */\nMonoMethodSignature*\nmono_method_get_signature_full (MonoMethod *method, MonoImage *image, guint32 token, MonoGenericContext *context)\n{\n\tint table = mono_metadata_token_table (token);\n\tint idx = mono_metadata_token_index (token);\n\tint sig_idx;\n\tguint32 cols [MONO_MEMBERREF_SIZE];\n\tMonoMethodSignature *sig;\n\tconst char *ptr;\n\n\t/* !table is for wrappers: we should really assign their own token to them */\n\tif (!table || table == MONO_TABLE_METHOD)\n\t\treturn mono_method_signature (method);\n\n\tif (table == MONO_TABLE_METHODSPEC) {\n\t\t/* the verifier (do_invoke_method) will turn the NULL into a verifier error */\n\t\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) || !method->is_inflated)\n\t\t\treturn NULL;\n\n\t\treturn mono_method_signature (method);\n\t}\n\n\tif (method->klass->generic_class)\n\t\treturn mono_method_signature (method);\n\n\tif (image->dynamic) {\n\t\tsig = mono_reflection_lookup_signature (image, method, token);\n\t} else {\n\t\tmono_metadata_decode_row (&image->tables [MONO_TABLE_MEMBERREF], idx-1, cols, MONO_MEMBERREF_SIZE);\n\t\tsig_idx = cols [MONO_MEMBERREF_SIGNATURE];\n\n\t\tsig = find_cached_memberref_sig (image, sig_idx);\n\t\tif (!sig) {\n\t\t\tif (!mono_verifier_verify_memberref_signature (image, sig_idx, NULL)) {\n\t\t\t\tguint32 class = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\t\t\t\tconst char *fname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\t\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad method signature class token 0x%08x field name %s token 0x%08x on image %s\", class, fname, token, image->name));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tptr = mono_metadata_blob_heap (image, sig_idx);\n\t\t\tmono_metadata_decode_blob_size (ptr, &ptr);\n\t\t\tsig = mono_metadata_parse_method_signature (image, 0, ptr, NULL);\n\t\t\tif (!sig)\n\t\t\t\treturn NULL;\n\t\t\tsig = cache_memberref_sig (image, sig_idx, sig);\n\t\t}\n\t\t/* FIXME: we probably should verify signature compat in the dynamic case too*/\n\t\tif (!mono_verifier_is_sig_compatible (image, method, sig)) {\n\t\t\tguint32 class = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\t\t\tconst char *fname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Incompatible method signature class token 0x%08x field name %s token 0x%08x on image %s\", class, fname, token, image->name));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tif (context) {\n\t\tMonoError error;\n\t\tMonoMethodSignature *cached;\n\n\t\t/* This signature is not owned by a MonoMethod, so need to cache */\n\t\tsig = inflate_generic_signature_checked (image, sig, context, &error);\n\t\tif (!mono_error_ok (&error)) {/*XXX bubble up this and kill one use of loader errors */\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Could not inflate signature %s\", mono_error_get_message (&error)));\n\t\t\tmono_error_cleanup (&error);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tcached = mono_metadata_get_inflated_signature (sig, context);\n\t\tif (cached != sig)\n\t\t\tmono_metadata_free_inflated_signature (sig);\n\t\telse\n\t\t\tinflated_signatures_size += mono_metadata_signature_size (cached);\n\t\tsig = cached;\n\t}\n\n\treturn sig;\n}\n\nMonoMethodSignature*\nmono_method_get_signature (MonoMethod *method, MonoImage *image, guint32 token)\n{\n\treturn mono_method_get_signature_full (method, image, token, NULL);\n}\n\n/* this is only for the typespec array methods */\nMonoMethod*\nmono_method_search_in_array_class (MonoClass *klass, const char *name, MonoMethodSignature *sig)\n{\n\tint i;\n\n\tmono_class_setup_methods (klass);\n\tg_assert (!klass->exception_type); /*FIXME this should not fail, right?*/\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tMonoMethod *method = klass->methods [i];\n\t\tif (strcmp (method->name, name) == 0 && sig->param_count == method->signature->param_count)\n\t\t\treturn method;\n\t}\n\treturn NULL;\n}\n\nstatic MonoMethod *\nmethod_from_memberref (MonoImage *image, guint32 idx, MonoGenericContext *typespec_context,\n\t\t       gboolean *used_context)\n{\n\tMonoClass *klass = NULL;\n\tMonoMethod *method = NULL;\n\tMonoTableInfo *tables = image->tables;\n\tguint32 cols[6];\n\tguint32 nindex, class, sig_idx;\n\tconst char *mname;\n\tMonoMethodSignature *sig;\n\tconst char *ptr;\n\n\tmono_metadata_decode_row (&tables [MONO_TABLE_MEMBERREF], idx-1, cols, 3);\n\tnindex = cols [MONO_MEMBERREF_CLASS] >> MONO_MEMBERREF_PARENT_BITS;\n\tclass = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\t/*g_print (\"methodref: 0x%x 0x%x %s\\n\", class, nindex,\n\t\tmono_metadata_string_heap (m, cols [MONO_MEMBERREF_NAME]));*/\n\n\tmname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\t/*\n\t * Whether we actually used the `typespec_context' or not.\n\t * This is used to tell our caller whether or not it's safe to insert the returned\n\t * method into a cache.\n\t */\n\tif (used_context)\n\t\t*used_context = class == MONO_MEMBERREF_PARENT_TYPESPEC;\n\n\tswitch (class) {\n\tcase MONO_MEMBERREF_PARENT_TYPEREF:\n\t\tklass = mono_class_from_typeref (image, MONO_TOKEN_TYPE_REF | nindex);\n\t\tif (!klass) {\n\t\t\tchar *name = mono_class_name_from_token (image, MONO_TOKEN_TYPE_REF | nindex);\n\t\t\tg_warning (\"Missing method %s in assembly %s, type %s\", mname, image->name, name);\n\t\t\tmono_loader_set_error_type_load (name, image->assembly_name);\n\t\t\tg_free (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPESPEC:\n\t\t/*\n\t\t * Parse the TYPESPEC in the parent's context.\n\t\t */\n\t\tklass = mono_class_get_full (image, MONO_TOKEN_TYPE_SPEC | nindex, typespec_context);\n\t\tif (!klass) {\n\t\t\tchar *name = mono_class_name_from_token (image, MONO_TOKEN_TYPE_SPEC | nindex);\n\t\t\tg_warning (\"Missing method %s in assembly %s, type %s\", mname, image->name, name);\n\t\t\tmono_loader_set_error_type_load (name, image->assembly_name);\n\t\t\tg_free (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPEDEF:\n\t\tklass = mono_class_get (image, MONO_TOKEN_TYPE_DEF | nindex);\n\t\tif (!klass) {\n\t\t\tchar *name = mono_class_name_from_token (image, MONO_TOKEN_TYPE_DEF | nindex);\n\t\t\tg_warning (\"Missing method %s in assembly %s, type %s\", mname, image->name, name);\n\t\t\tmono_loader_set_error_type_load (name, image->assembly_name);\n\t\t\tg_free (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_METHODDEF:\n\t\treturn mono_get_method (image, MONO_TOKEN_METHOD_DEF | nindex, NULL);\n\t\t\n\tdefault:\n\t\t{\n\t\t\t/* This message leaks */\n\t\t\tchar *message = g_strdup_printf (\"Memberref parent unknown: class: %d, index %d\", class, nindex);\n\t\t\tmono_loader_set_error_method_load (\"\", message);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tg_assert (klass);\n\tmono_class_init (klass);\n\n\tsig_idx = cols [MONO_MEMBERREF_SIGNATURE];\n\n\tif (!mono_verifier_verify_memberref_signature (image, sig_idx, NULL)) {\n\t\tmono_loader_set_error_method_load (klass->name, mname);\n\t\treturn NULL;\n\t}\n\n\tptr = mono_metadata_blob_heap (image, sig_idx);\n\tmono_metadata_decode_blob_size (ptr, &ptr);\n\n\tsig = find_cached_memberref_sig (image, sig_idx);\n\tif (!sig) {\n\t\tsig = mono_metadata_parse_method_signature (image, 0, ptr, NULL);\n\t\tif (sig == NULL)\n\t\t\treturn NULL;\n\n\t\tsig = cache_memberref_sig (image, sig_idx, sig);\n\t}\n\n\tswitch (class) {\n\tcase MONO_MEMBERREF_PARENT_TYPEREF:\n\tcase MONO_MEMBERREF_PARENT_TYPEDEF:\n\t\tmethod = find_method (klass, NULL, mname, sig, klass);\n\t\tbreak;\n\n\tcase MONO_MEMBERREF_PARENT_TYPESPEC: {\n\t\tMonoType *type;\n\n\t\ttype = &klass->byval_arg;\n\n\t\tif (type->type != MONO_TYPE_ARRAY && type->type != MONO_TYPE_SZARRAY) {\n\t\t\tMonoClass *in_class = klass->generic_class ? klass->generic_class->container_class : klass;\n\t\t\tmethod = find_method (in_class, NULL, mname, sig, klass);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* we're an array and we created these methods already in klass in mono_class_init () */\n\t\tmethod = mono_method_search_in_array_class (klass, mname, sig);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tg_error (\"Memberref parent unknown: class: %d, index %d\", class, nindex);\n\t\tg_assert_not_reached ();\n\t}\n\n\tif (!method) {\n\t\tchar *msig = mono_signature_get_desc (sig, FALSE);\n\t\tchar * class_name = mono_type_get_name (&klass->byval_arg);\n\t\tGString *s = g_string_new (mname);\n\t\tif (sig->generic_param_count)\n\t\t\tg_string_append_printf (s, \"<[%d]>\", sig->generic_param_count);\n\t\tg_string_append_printf (s, \"(%s)\", msig);\n\t\tg_free (msig);\n\t\tmsig = g_string_free (s, FALSE);\n\n\t\tg_warning (\n\t\t\t\"Missing method %s::%s in assembly %s, referenced in assembly %s\",\n\t\t\tclass_name, msig, klass->image->name, image->name);\n\t\tmono_loader_set_error_method_load (class_name, mname);\n\t\tg_free (msig);\n\t\tg_free (class_name);\n\t}\n\n\treturn method;\n}\n\nstatic MonoMethod *\nmethod_from_methodspec (MonoImage *image, MonoGenericContext *context, guint32 idx)\n{\n\tMonoError error;\n\tMonoMethod *method;\n\tMonoClass *klass;\n\tMonoTableInfo *tables = image->tables;\n\tMonoGenericContext new_context;\n\tMonoGenericInst *inst;\n\tconst char *ptr;\n\tguint32 cols [MONO_METHODSPEC_SIZE];\n\tguint32 token, nindex, param_count;\n\n\tmono_metadata_decode_row (&tables [MONO_TABLE_METHODSPEC], idx - 1, cols, MONO_METHODSPEC_SIZE);\n\ttoken = cols [MONO_METHODSPEC_METHOD];\n\tnindex = token >> MONO_METHODDEFORREF_BITS;\n\n\tif (!mono_verifier_verify_methodspec_signature (image, cols [MONO_METHODSPEC_SIGNATURE], NULL))\n\t\treturn NULL;\n\n\tptr = mono_metadata_blob_heap (image, cols [MONO_METHODSPEC_SIGNATURE]);\n\n\tmono_metadata_decode_value (ptr, &ptr);\n\tptr++;\n\tparam_count = mono_metadata_decode_value (ptr, &ptr);\n\tg_assert (param_count);\n\n\tinst = mono_metadata_parse_generic_inst (image, NULL, param_count, ptr, &ptr);\n\tif (context && inst->is_open) {\n\t\tinst = mono_metadata_inflate_generic_inst (inst, context, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tmono_error_cleanup (&error); /*FIXME don't swallow error message.*/\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif ((token & MONO_METHODDEFORREF_MASK) == MONO_METHODDEFORREF_METHODDEF)\n\t\tmethod = mono_get_method_full (image, MONO_TOKEN_METHOD_DEF | nindex, NULL, context);\n\telse\n\t\tmethod = method_from_memberref (image, nindex, context, NULL);\n\n\tif (!method)\n\t\treturn NULL;\n\n\tklass = method->klass;\n\n\tif (klass->generic_class) {\n\t\tg_assert (method->is_inflated);\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\t}\n\n\tnew_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\tnew_context.method_inst = inst;\n\n\treturn mono_class_inflate_generic_method_full (method, klass, &new_context);\n}\n\nstruct _MonoDllMap {\n\tchar *dll;\n\tchar *target;\n\tchar *func;\n\tchar *target_func;\n\tMonoDllMap *next;\n};\n\nstatic MonoDllMap *global_dll_map;\n\nstatic int \nmono_dllmap_lookup_list (MonoDllMap *dll_map, const char *dll, const char* func, const char **rdll, const char **rfunc) {\n\tint found = 0;\n\n\t*rdll = dll;\n\n\tif (!dll_map)\n\t\treturn 0;\n\n\tmono_loader_lock ();\n\n\t/* \n\t * we use the first entry we find that matches, since entries from\n\t * the config file are prepended to the list and we document that the\n\t * later entries win.\n\t */\n\tfor (; dll_map; dll_map = dll_map->next) {\n\t\tif (dll_map->dll [0] == 'i' && dll_map->dll [1] == ':') {\n\t\t\tif (g_ascii_strcasecmp (dll_map->dll + 2, dll))\n\t\t\t\tcontinue;\n\t\t} else if (strcmp (dll_map->dll, dll)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!found && dll_map->target) {\n\t\t\t*rdll = dll_map->target;\n\t\t\tfound = 1;\n\t\t\t/* we don't quit here, because we could find a full\n\t\t\t * entry that matches also function and that has priority.\n\t\t\t */\n\t\t}\n\t\tif (dll_map->func && strcmp (dll_map->func, func) == 0) {\n\t\t\t*rfunc = dll_map->target_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmono_loader_unlock ();\n\treturn found;\n}\n\nstatic int \nmono_dllmap_lookup (MonoImage *assembly, const char *dll, const char* func, const char **rdll, const char **rfunc)\n{\n\tint res;\n\tif (assembly && assembly->dll_map) {\n\t\tres = mono_dllmap_lookup_list (assembly->dll_map, dll, func, rdll, rfunc);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn mono_dllmap_lookup_list (global_dll_map, dll, func, rdll, rfunc);\n}\n\n/*\n * mono_dllmap_insert:\n *\n * LOCKING: Acquires the loader lock.\n *\n * NOTE: This can be called before the runtime is initialized, for example from\n * mono_config_parse ().\n */\nvoid\nmono_dllmap_insert (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)\n{\n\tMonoDllMap *entry;\n\n\tmono_loader_init ();\n\n\tmono_loader_lock ();\n\n\tif (!assembly) {\n\t\tentry = g_malloc0 (sizeof (MonoDllMap));\n\t\tentry->dll = dll? g_strdup (dll): NULL;\n\t\tentry->target = tdll? g_strdup (tdll): NULL;\n\t\tentry->func = func? g_strdup (func): NULL;\n\t\tentry->target_func = tfunc? g_strdup (tfunc): NULL;\n\t\tentry->next = global_dll_map;\n\t\tglobal_dll_map = entry;\n\t} else {\n\t\tentry = mono_image_alloc0 (assembly, sizeof (MonoDllMap));\n\t\tentry->dll = dll? mono_image_strdup (assembly, dll): NULL;\n\t\tentry->target = tdll? mono_image_strdup (assembly, tdll): NULL;\n\t\tentry->func = func? mono_image_strdup (assembly, func): NULL;\n\t\tentry->target_func = tfunc? mono_image_strdup (assembly, tfunc): NULL;\n\t\tentry->next = assembly->dll_map;\n\t\tassembly->dll_map = entry;\n\t}\n\n\tmono_loader_unlock ();\n}\n\nstatic void\nfree_dllmap (MonoDllMap *map)\n{\n\twhile (map) {\n\t\tMonoDllMap *next = map->next;\n\n\t\tg_free (map->dll);\n\t\tg_free (map->target);\n\t\tg_free (map->func);\n\t\tg_free (map->target_func);\n\t\tg_free (map);\n\t\tmap = next;\n\t}\n}\n\nstatic void\ndllmap_cleanup (void)\n{\n\tfree_dllmap (global_dll_map);\n\tglobal_dll_map = NULL;\n}\n\nstatic GHashTable *global_module_map;\n\nstatic MonoDl*\ncached_module_load (const char *name, int flags, char **err)\n{\n\tMonoDl *res;\n\n\tif (err)\n\t\t*err = NULL;\n\tmono_loader_lock ();\n\tif (!global_module_map)\n\t\tglobal_module_map = g_hash_table_new (g_str_hash, g_str_equal);\n\tres = g_hash_table_lookup (global_module_map, name);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\tres = mono_dl_open (name, flags, NULL);\n\tif (res)\n\t\tg_hash_table_insert (global_module_map, g_strdup (name), res);\n\tmono_loader_unlock ();\n\treturn res;\n}\n\ngpointer\nmono_lookup_pinvoke_call (MonoMethod *method, const char **exc_class, const char **exc_arg)\n{\n\tMonoImage *image = method->klass->image;\n\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)method;\n\tMonoTableInfo *tables = image->tables;\n\tMonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];\n\tMonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];\n\tguint32 im_cols [MONO_IMPLMAP_SIZE];\n\tguint32 scope_token;\n\tconst char *import = NULL;\n\tconst char *orig_scope;\n\tconst char *new_scope;\n\tchar *error_msg;\n\tchar *full_name, *file_name;\n\tint i;\n\tMonoDl *module = NULL;\n\n\tg_assert (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL);\n\n\tif (piinfo->addr)\n\t\treturn piinfo->addr;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (!method_aux)\n\t\t\treturn NULL;\n\n\t\timport = method_aux->dllentry;\n\t\torig_scope = method_aux->dll;\n\t}\n\telse {\n\t\tif (!piinfo->implmap_idx)\n\t\t\treturn NULL;\n\n\t\tmono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);\n\n\t\tpiinfo->piflags = im_cols [MONO_IMPLMAP_FLAGS];\n\t\timport = mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]);\n\t\tscope_token = mono_metadata_decode_row_col (mr, im_cols [MONO_IMPLMAP_SCOPE] - 1, MONO_MODULEREF_NAME);\n\t\torig_scope = mono_metadata_string_heap (image, scope_token);\n\t}\n\n\tmono_dllmap_lookup (image, orig_scope, import, &new_scope, &import);\n\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\"DllImport attempting to load: '%s'.\", new_scope);\n\n\tif (exc_class) {\n\t\t*exc_class = NULL;\n\t\t*exc_arg = NULL;\n\t}\n\n\t/* we allow a special name to dlopen from the running process namespace */\n\tif (strcmp (new_scope, \"__Internal\") == 0)\n\t\tmodule = mono_dl_open (NULL, MONO_DL_LAZY, &error_msg);\n\n\t/*\n\t * Try loading the module using a variety of names\n\t */\n\tfor (i = 0; i < 4; ++i) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\t/* Try the original name */\n\t\t\tfile_name = g_strdup (new_scope);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* Try trimming the .dll extension */\n\t\t\tif (strstr (new_scope, \".dll\") == (new_scope + strlen (new_scope) - 4)) {\n\t\t\t\tfile_name = g_strdup (new_scope);\n\t\t\t\tfile_name [strlen (new_scope) - 4] = '\\0';\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (strstr (new_scope, \"lib\") != new_scope) {\n\t\t\t\tfile_name = g_strdup_printf (\"lib%s\", new_scope);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n#ifndef TARGET_WIN32\n\t\t\tif (!g_ascii_strcasecmp (\"user32.dll\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"kernel32.dll\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"user32\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"kernel\", new_scope)) {\n\t\t\t\tfile_name = g_strdup (\"libMonoSupportW.so\");\n\t\t\t} else\n#endif\n\t\t\t\t    continue;\n#ifndef TARGET_WIN32\n\t\t\tbreak;\n#endif\n\t\t}\n\n\t\tif (!module) {\n\t\t\tvoid *iter = NULL;\n\t\t\twhile ((full_name = mono_dl_build_path (NULL, file_name, &iter))) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport loading location: '%s'.\", full_name);\n\t\t\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\t\t\tif (!module) {\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\"DllImport error loading library: '%s'.\",\n\t\t\t\t\t\t\terror_msg);\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t}\n\t\t\t\tg_free (full_name);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!module) {\n\t\t\tvoid *iter = NULL;\n\t\t\twhile ((full_name = mono_dl_build_path (\".\", file_name, &iter))) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport loading library: '%s'.\", full_name);\n\t\t\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\t\t\tif (!module) {\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s'.\",\n\t\t\t\t\t\terror_msg);\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t}\n\t\t\t\tg_free (full_name);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!module) {\n\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport loading: '%s'.\", file_name);\n\t\t\tmodule = cached_module_load (file_name, MONO_DL_LAZY, &error_msg);\n\t\t\tif (!module) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s'.\",\n\t\t\t\t\t\terror_msg);\n\t\t\t}\n\t\t}\n\n\t\tg_free (file_name);\n\n\t\tif (module)\n\t\t\tbreak;\n\t}\n\n\tif (!module) {\n\t\tmono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"DllImport unable to load library '%s'.\",\n\t\t\t\terror_msg);\n\t\tg_free (error_msg);\n\n\t\tif (exc_class) {\n\t\t\t*exc_class = \"DllNotFoundException\";\n\t\t\t*exc_arg = new_scope;\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef TARGET_WIN32\n\tif (import && import [0] == '#' && isdigit (import [1])) {\n\t\tchar *end;\n\t\tlong id;\n\n\t\tid = strtol (import + 1, &end, 10);\n\t\tif (id > 0 && *end == '\\0')\n\t\t\timport++;\n\t}\n#endif\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"Searching for '%s'.\", import);\n\n\tif (piinfo->piflags & PINVOKE_ATTRIBUTE_NO_MANGLE) {\n\t\terror_msg = mono_dl_symbol (module, import, &piinfo->addr); \n\t} else {\n\t\tchar *mangled_name = NULL, *mangled_name2 = NULL;\n\t\tint mangle_charset;\n\t\tint mangle_stdcall;\n\t\tint mangle_param_count;\n#ifdef TARGET_WIN32\n\t\tint param_count;\n#endif\n\n\t\t/*\n\t\t * Search using a variety of mangled names\n\t\t */\n\t\tfor (mangle_charset = 0; mangle_charset <= 1; mangle_charset ++) {\n\t\t\tfor (mangle_stdcall = 0; mangle_stdcall <= 1; mangle_stdcall ++) {\n\t\t\t\tgboolean need_param_count = FALSE;\n#ifdef TARGET_WIN32\n\t\t\t\tif (mangle_stdcall > 0)\n\t\t\t\t\tneed_param_count = TRUE;\n#endif\n\t\t\t\tfor (mangle_param_count = 0; mangle_param_count <= (need_param_count ? 256 : 0); mangle_param_count += 4) {\n\n\t\t\t\t\tif (piinfo->addr)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tmangled_name = (char*)import;\n\t\t\t\t\tswitch (piinfo->piflags & PINVOKE_ATTRIBUTE_CHAR_SET_MASK) {\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_UNICODE:\n\t\t\t\t\t\t/* Try the mangled name first */\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_AUTO:\n#ifdef TARGET_WIN32\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", NULL);\n#else\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", NULL);\n#endif\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_ANSI:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n#ifdef TARGET_WIN32\n\t\t\t\t\tif (mangle_param_count == 0)\n\t\t\t\t\t\tparam_count = mono_method_signature (method)->param_count * sizeof (gpointer);\n\t\t\t\t\telse\n\t\t\t\t\t\t/* Try brute force, since it would be very hard to compute the stack usage correctly */\n\t\t\t\t\t\tparam_count = mangle_param_count;\n\n\t\t\t\t\t/* Try the stdcall mangled name */\n\t\t\t\t\t/* \n\t\t\t\t\t * gcc under windows creates mangled names without the underscore, but MS.NET\n\t\t\t\t\t * doesn't support it, so we doesn't support it either.\n\t\t\t\t\t */\n\t\t\t\t\tif (mangle_stdcall == 1)\n\t\t\t\t\t\tmangled_name2 = g_strdup_printf (\"_%s@%d\", mangled_name, param_count);\n\t\t\t\t\telse\n\t\t\t\t\t\tmangled_name2 = mangled_name;\n#else\n\t\t\t\t\tmangled_name2 = mangled_name;\n#endif\n\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\"Probing '%s'.\", mangled_name2);\n\n\t\t\t\t\terror_msg = mono_dl_symbol (module, mangled_name2, &piinfo->addr);\n\n\t\t\t\t\tif (piinfo->addr)\n\t\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\t\"Found as '%s'.\", mangled_name2);\n\n\t\t\t\t\tif (mangled_name != mangled_name2)\n\t\t\t\t\t\tg_free (mangled_name2);\n\t\t\t\t\tif (mangled_name != import)\n\t\t\t\t\t\tg_free (mangled_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!piinfo->addr) {\n\t\tg_free (error_msg);\n\t\tif (exc_class) {\n\t\t\t*exc_class = \"EntryPointNotFoundException\";\n\t\t\t*exc_arg = import;\n\t\t}\n\t\treturn NULL;\n\t}\n\treturn piinfo->addr;\n}\n\n/*\n * LOCKING: assumes the loader lock to be taken.\n */\nstatic MonoMethod *\nmono_get_method_from_token (MonoImage *image, guint32 token, MonoClass *klass,\n\t\t\t    MonoGenericContext *context, gboolean *used_context)\n{\n\tMonoMethod *result;\n\tint table = mono_metadata_token_table (token);\n\tint idx = mono_metadata_token_index (token);\n\tMonoTableInfo *tables = image->tables;\n\tMonoGenericContainer *generic_container = NULL, *container = NULL;\n\tconst char *sig = NULL;\n\tint size;\n\tguint32 cols [MONO_TYPEDEF_SIZE];\n\n\tif (image->dynamic) {\n\t\tMonoClass *handle_class;\n\n\t\tresult = mono_lookup_dynamic_token_class (image, token, TRUE, &handle_class, context);\n\t\t// This checks the memberref type as well\n\t\tif (result && handle_class != mono_defaults.methodhandle_class) {\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad method token 0x%08x on image %s.\", token, image->name));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn result;\n\t}\n\n\tif (table != MONO_TABLE_METHOD) {\n\t\tif (table == MONO_TABLE_METHODSPEC) {\n\t\t\tif (used_context) *used_context = TRUE;\n\t\t\treturn method_from_methodspec (image, context, idx);\n\t\t}\n\t\tif (table != MONO_TABLE_MEMBERREF) {\n\t\t\tg_warning (\"got wrong token: 0x%08x\\n\", token);\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad method token 0x%08x on image %s.\", token, image->name));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn method_from_memberref (image, idx, context, used_context);\n\t}\n\n\tif (used_context) *used_context = FALSE;\n\n\tif (idx > image->tables [MONO_TABLE_METHOD].rows) {\n\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad method token 0x%08x on image %s.\", token, image->name));\n\t\treturn NULL;\n\t}\n\n\tmono_metadata_decode_row (&image->tables [MONO_TABLE_METHOD], idx - 1, cols, 6);\n\n\tif ((cols [2] & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t    (cols [1] & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL))\n\t\tresult = (MonoMethod *)mono_image_alloc0 (image, sizeof (MonoMethodPInvoke));\n\telse\n\t\tresult = (MonoMethod *)mono_image_alloc0 (image, sizeof (MonoMethod));\n\n\tmono_stats.method_count ++;\n\n\tif (!klass) { /*FIXME put this before the image alloc*/\n\t\tguint32 type = mono_metadata_typedef_from_method (image, token);\n\t\tif (!type)\n\t\t\treturn NULL;\n\t\tklass = mono_class_get (image, MONO_TOKEN_TYPE_DEF | type);\n\t\tif (klass == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tresult->slot = -1;\n\tresult->klass = klass;\n\tresult->flags = cols [2];\n\tresult->iflags = cols [1];\n\tresult->token = token;\n\tresult->name = mono_metadata_string_heap (image, cols [3]);\n\n\tif (!sig) /* already taken from the methodref */\n\t\tsig = mono_metadata_blob_heap (image, cols [4]);\n\tsize = mono_metadata_decode_blob_size (sig, &sig);\n\n\tcontainer = klass->generic_container;\n\n\t/* \n\t * load_generic_params does a binary search so only call it if the method \n\t * is generic.\n\t */\n\tif (*sig & 0x10)\n\t\tgeneric_container = mono_metadata_load_generic_params (image, token, container);\n\tif (generic_container) {\n\t\tresult->is_generic = TRUE;\n\t\tgeneric_container->owner.method = result;\n\t\t/*FIXME put this before the image alloc*/\n\t\tif (!mono_metadata_load_generic_param_constraints_full (image, token, generic_container))\n\t\t\treturn NULL;\n\n\t\tcontainer = generic_container;\n\t}\n\n\tif (cols [1] & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\tif (result->klass == mono_defaults.string_class && !strcmp (result->name, \".ctor\"))\n\t\t\tresult->string_ctor = 1;\n\t} else if (cols [2] & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)result;\n\n#ifdef TARGET_WIN32\n\t\t/* IJW is P/Invoke with a predefined function pointer. */\n\t\tif (image->is_module_handle && (cols [1] & METHOD_IMPL_ATTRIBUTE_NATIVE)) {\n\t\t\tpiinfo->addr = mono_image_rva_map (image, cols [0]);\n\t\t\tg_assert (piinfo->addr);\n\t\t}\n#endif\n\t\tpiinfo->implmap_idx = mono_metadata_implmap_from_method (image, idx - 1);\n\t\t/* Native methods can have no map. */\n\t\tif (piinfo->implmap_idx)\n\t\t\tpiinfo->piflags = mono_metadata_decode_row_col (&tables [MONO_TABLE_IMPLMAP], piinfo->implmap_idx - 1, MONO_IMPLMAP_FLAGS);\n\t}\n\n \tif (generic_container)\n \t\tmono_method_set_generic_container (result, generic_container);\n\n\treturn result;\n}\n\nMonoMethod *\nmono_get_method (MonoImage *image, guint32 token, MonoClass *klass)\n{\n\treturn mono_get_method_full (image, token, klass, NULL);\n}\n\nMonoMethod *\nmono_get_method_full (MonoImage *image, guint32 token, MonoClass *klass,\n\t\t      MonoGenericContext *context)\n{\n\tMonoMethod *result;\n\tgboolean used_context = FALSE;\n\n\t/* We do everything inside the lock to prevent creation races */\n\n\tmono_image_lock (image);\n\n\tif (mono_metadata_token_table (token) == MONO_TABLE_METHOD) {\n\t\tif (!image->method_cache)\n\t\t\timage->method_cache = g_hash_table_new (NULL, NULL);\n\t\tresult = g_hash_table_lookup (image->method_cache, GINT_TO_POINTER (mono_metadata_token_index (token)));\n\t} else {\n\t\tif (!image->methodref_cache)\n\t\t\timage->methodref_cache = g_hash_table_new (NULL, NULL);\n\t\tresult = g_hash_table_lookup (image->methodref_cache, GINT_TO_POINTER (token));\n\t}\n\tmono_image_unlock (image);\n\n\tif (result)\n\t\treturn result;\n\n\tresult = mono_get_method_from_token (image, token, klass, context, &used_context);\n\tif (!result)\n\t\treturn NULL;\n\n\tmono_image_lock (image);\n\tif (!used_context && !result->is_inflated) {\n\t\tMonoMethod *result2;\n\t\tif (mono_metadata_token_table (token) == MONO_TABLE_METHOD)\n\t\t\tresult2 = g_hash_table_lookup (image->method_cache, GINT_TO_POINTER (mono_metadata_token_index (token)));\n\t\telse\n\t\t\tresult2 = g_hash_table_lookup (image->methodref_cache, GINT_TO_POINTER (token));\n\n\t\tif (result2) {\n\t\t\tmono_image_unlock (image);\n\t\t\treturn result2;\n\t\t}\n\n\t\tif (mono_metadata_token_table (token) == MONO_TABLE_METHOD)\n\t\t\tg_hash_table_insert (image->method_cache, GINT_TO_POINTER (mono_metadata_token_index (token)), result);\n\t\telse\n\t\t\tg_hash_table_insert (image->methodref_cache, GINT_TO_POINTER (token), result);\n\t}\n\n\tmono_image_unlock (image);\n\n\treturn result;\n}\n\n/**\n * mono_get_method_constrained:\n *\n * This is used when JITing the `constrained.' opcode.\n *\n * This returns two values: the contrained method, which has been inflated\n * as the function return value;   And the original CIL-stream method as\n * declared in cil_method.  The later is used for verification.\n */\nMonoMethod *\nmono_get_method_constrained (MonoImage *image, guint32 token, MonoClass *constrained_class,\n\t\t\t     MonoGenericContext *context, MonoMethod **cil_method)\n{\n\tMonoMethod *method, *result;\n\tMonoClass *ic = NULL;\n\tMonoGenericContext *method_context = NULL;\n\tMonoMethodSignature *sig, *original_sig;\n\n\tmono_loader_lock ();\n\n\t*cil_method = mono_get_method_from_token (image, token, NULL, context, NULL);\n\tif (!*cil_method) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tmono_class_init (constrained_class);\n\tmethod = *cil_method;\n\toriginal_sig = sig = mono_method_signature (method);\n\tif (sig == NULL) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tif (method->is_inflated && sig->generic_param_count) {\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated *) method;\n\t\tsig = mono_method_signature (imethod->declaring); /*We assume that if the inflated method signature is valid, the declaring method is too*/\n\t\tmethod_context = mono_method_get_context (method);\n\n\t\toriginal_sig = sig;\n\t\t/*\n\t\t * We must inflate the signature with the class instantiation to work on\n\t\t * cases where a class inherit from a generic type and the override replaces\n\t\t * any type argument which a concrete type. See #325283.\n\t\t */\n\t\tif (method_context->class_inst) {\n\t\t\tMonoError error;\n\t\t\tMonoGenericContext ctx;\n\t\t\tctx.method_inst = NULL;\n\t\t\tctx.class_inst = method_context->class_inst;\n\t\t\t/*Fixme, property propagate this error*/\n\t\t\tsig = inflate_generic_signature_checked (method->klass->image, sig, &ctx, &error);\n\t\t\tif (!mono_error_ok (&error)) {\n\t\t\t\tmono_loader_unlock ();\n\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((constrained_class != method->klass) && (MONO_CLASS_IS_INTERFACE (method->klass)))\n\t\tic = method->klass;\n\n\tresult = find_method (constrained_class, ic, method->name, sig, constrained_class);\n\tif (sig != original_sig)\n\t\tmono_metadata_free_inflated_signature (sig);\n\n\tif (!result) {\n\t\tg_warning (\"Missing method %s.%s.%s in assembly %s token %x\", method->klass->name_space,\n\t\t\t   method->klass->name, method->name, image->name, token);\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tif (method_context)\n\t\tresult = mono_class_inflate_generic_method (result, method_context);\n\n\tmono_loader_unlock ();\n\treturn result;\n}\n\nvoid\nmono_free_method  (MonoMethod *method)\n{\n\tif (mono_profiler_get_events () & MONO_PROFILE_METHOD_EVENTS)\n\t\tmono_profiler_method_free (method);\n\t\n\t/* FIXME: This hack will go away when the profiler will support freeing methods */\n\tif (mono_profiler_get_events () != MONO_PROFILE_NONE)\n\t\treturn;\n\t\n\tif (method->signature) {\n\t\t/* \n\t\t * FIXME: This causes crashes because the types inside signatures and\n\t\t * locals are shared.\n\t\t */\n\t\t/* mono_metadata_free_method_signature (method->signature); */\n\t\t/* g_free (method->signature); */\n\t}\n\t\n\tif (method->dynamic) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper*)method;\n\t\tint i;\n\n\t\tmono_marshal_free_dynamic_wrappers (method);\n\n\t\tmono_image_property_remove (method->klass->image, method);\n\n\t\tg_free ((char*)method->name);\n\t\tif (mw->header) {\n\t\t\tg_free ((char*)mw->header->code);\n\t\t\tfor (i = 0; i < mw->header->num_locals; ++i)\n\t\t\t\tg_free (mw->header->locals [i]);\n\t\t\tg_free (mw->header->clauses);\n\t\t\tg_free (mw->header);\n\t\t}\n\t\tg_free (mw->method_data);\n\t\tg_free (method->signature);\n\t\tg_free (method);\n\t}\n}\n\nvoid\nmono_method_get_param_names (MonoMethod *method, const char **names)\n{\n\tint i, lastp;\n\tMonoClass *klass;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\tMonoMethodSignature *signature;\n\tguint32 idx;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tsignature = mono_method_signature (method);\n\t/*FIXME this check is somewhat redundant since the caller usally will have to get the signature to figure out the\n\t  number of arguments and allocate a properly sized array. */\n\tif (signature == NULL)\n\t\treturn;\n\n\tif (!signature->param_count)\n\t\treturn;\n\n\tfor (i = 0; i < signature->param_count; ++i)\n\t\tnames [i] = \"\";\n\n\tklass = method->klass;\n\tif (klass->rank)\n\t\treturn;\n\n\tmono_class_init (klass);\n\n\tif (klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (method_aux && method_aux->param_names) {\n\t\t\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i)\n\t\t\t\tif (method_aux->param_names [i + 1])\n\t\t\t\t\tnames [i] = method_aux->param_names [i + 1];\n\t\t}\n\t\treturn;\n\t}\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint32 cols [MONO_PARAM_SIZE];\n\t\tguint param_index;\n\n\t\tparam_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (idx < methodt->rows)\n\t\t\tlastp = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\t\telse\n\t\t\tlastp = paramt->rows + 1;\n\t\tfor (i = param_index; i < lastp; ++i) {\n\t\t\tmono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);\n\t\t\tif (cols [MONO_PARAM_SEQUENCE] && cols [MONO_PARAM_SEQUENCE] <= signature->param_count) /* skip return param spec and bounds check*/\n\t\t\t\tnames [cols [MONO_PARAM_SEQUENCE] - 1] = mono_metadata_string_heap (klass->image, cols [MONO_PARAM_NAME]);\n\t\t}\n\t}\n}\n\nguint32\nmono_method_get_param_token (MonoMethod *method, int index)\n{\n\tMonoClass *klass = method->klass;\n\tMonoTableInfo *methodt;\n\tguint32 idx;\n\n\tmono_class_init (klass);\n\n\tif (klass->image->dynamic) {\n\t\tg_assert_not_reached ();\n\t}\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint param_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (index == -1)\n\t\t\t/* Return value */\n\t\t\treturn mono_metadata_make_token (MONO_TABLE_PARAM, 0);\n\t\telse\n\t\t\treturn mono_metadata_make_token (MONO_TABLE_PARAM, param_index + index);\n\t}\n\n\treturn 0;\n}\n\nvoid\nmono_method_get_marshal_info (MonoMethod *method, MonoMarshalSpec **mspecs)\n{\n\tint i, lastp;\n\tMonoClass *klass = method->klass;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\tMonoMethodSignature *signature;\n\tguint32 idx;\n\n\tsignature = mono_method_signature (method);\n\tg_assert (signature); /*FIXME there is no way to signal error from this function*/\n\n\tfor (i = 0; i < signature->param_count + 1; ++i)\n\t\tmspecs [i] = NULL;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (method_aux && method_aux->param_marshall) {\n\t\t\tMonoMarshalSpec **dyn_specs = method_aux->param_marshall;\n\t\t\tfor (i = 0; i < signature->param_count + 1; ++i)\n\t\t\t\tif (dyn_specs [i]) {\n\t\t\t\t\tmspecs [i] = g_new0 (MonoMarshalSpec, 1);\n\t\t\t\t\tmemcpy (mspecs [i], dyn_specs [i], sizeof (MonoMarshalSpec));\n\t\t\t\t\tmspecs [i]->data.custom_data.custom_name = g_strdup (dyn_specs [i]->data.custom_data.custom_name);\n\t\t\t\t\tmspecs [i]->data.custom_data.cookie = g_strdup (dyn_specs [i]->data.custom_data.cookie);\n\t\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tmono_class_init (klass);\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint32 cols [MONO_PARAM_SIZE];\n\t\tguint param_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (idx < methodt->rows)\n\t\t\tlastp = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\t\telse\n\t\t\tlastp = paramt->rows + 1;\n\n\t\tfor (i = param_index; i < lastp; ++i) {\n\t\t\tmono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);\n\n\t\t\tif (cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_FIELD_MARSHAL && cols [MONO_PARAM_SEQUENCE] <= signature->param_count) {\n\t\t\t\tconst char *tp;\n\t\t\t\ttp = mono_metadata_get_marshal_info (klass->image, i - 1, FALSE);\n\t\t\t\tg_assert (tp);\n\t\t\t\tmspecs [cols [MONO_PARAM_SEQUENCE]]= mono_metadata_parse_marshal_spec (klass->image, tp);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n}\n\ngboolean\nmono_method_has_marshal_info (MonoMethod *method)\n{\n\tint i, lastp;\n\tMonoClass *klass = method->klass;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\tguint32 idx;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tMonoMarshalSpec **dyn_specs = method_aux->param_marshall;\n\t\tif (dyn_specs) {\n\t\t\tfor (i = 0; i < mono_method_signature (method)->param_count + 1; ++i)\n\t\t\t\tif (dyn_specs [i])\n\t\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tmono_class_init (klass);\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint32 cols [MONO_PARAM_SIZE];\n\t\tguint param_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (idx + 1 < methodt->rows)\n\t\t\tlastp = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\t\telse\n\t\t\tlastp = paramt->rows + 1;\n\n\t\tfor (i = param_index; i < lastp; ++i) {\n\t\t\tmono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);\n\n\t\t\tif (cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_FIELD_MARSHAL)\n\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn FALSE;\n}\n\ngpointer\nmono_method_get_wrapper_data (MonoMethod *method, guint32 id)\n{\n\tvoid **data;\n\tg_assert (method != NULL);\n\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\tdata = ((MonoMethodWrapper *)method)->method_data;\n\tg_assert (data != NULL);\n\tg_assert (id <= GPOINTER_TO_UINT (*data));\n\treturn data [id];\n}\n\nstatic void\ndefault_stack_walk (MonoStackWalk func, gboolean do_il_offset, gpointer user_data) {\n\tg_error (\"stack walk not installed\");\n}\n\nstatic MonoStackWalkImpl stack_walk = default_stack_walk;\n\nvoid\nmono_stack_walk (MonoStackWalk func, gpointer user_data)\n{\n\tstack_walk (func, TRUE, user_data);\n}\n\nvoid\nmono_stack_walk_no_il (MonoStackWalk func, gpointer user_data)\n{\n\tstack_walk (func, FALSE, user_data);\n}\n\nvoid\nmono_install_stack_walk (MonoStackWalkImpl func)\n{\n\tstack_walk = func;\n}\n\nstatic gboolean\nlast_managed (MonoMethod *m, gint no, gint ilo, gboolean managed, gpointer data)\n{\n\tMonoMethod **dest = data;\n\t*dest = m;\n\t/*g_print (\"In %s::%s [%d] [%d]\\n\", m->klass->name, m->name, no, ilo);*/\n\n\treturn managed;\n}\n\nMonoMethod*\nmono_method_get_last_managed (void)\n{\n\tMonoMethod *m = NULL;\n\tstack_walk (last_managed, FALSE, &m);\n\treturn m;\n}\n\nstatic gboolean loader_lock_track_ownership = FALSE;\n\n/**\n * mono_loader_lock:\n *\n * See docs/thread-safety.txt for the locking strategy.\n */\nvoid\nmono_loader_lock (void)\n{\n\tmono_locks_acquire (&loader_mutex, LoaderLock);\n\tif (G_UNLIKELY (loader_lock_track_ownership)) {\n\t\tTlsSetValue (loader_lock_nest_id, GUINT_TO_POINTER (GPOINTER_TO_UINT (TlsGetValue (loader_lock_nest_id)) + 1));\n\t}\n}\n\nvoid\nmono_loader_unlock (void)\n{\n\tmono_locks_release (&loader_mutex, LoaderLock);\n\tif (G_UNLIKELY (loader_lock_track_ownership)) {\n\t\tTlsSetValue (loader_lock_nest_id, GUINT_TO_POINTER (GPOINTER_TO_UINT (TlsGetValue (loader_lock_nest_id)) - 1));\n\t}\n}\n\n/*\n * mono_loader_lock_track_ownership:\n *\n *   Set whenever the runtime should track ownership of the loader lock. If set to TRUE,\n * the mono_loader_lock_is_owned_by_self () can be called to query whenever the current\n * thread owns the loader lock. \n */\nvoid\nmono_loader_lock_track_ownership (gboolean track)\n{\n\tloader_lock_track_ownership = track;\n}\n\n/*\n * mono_loader_lock_is_owned_by_self:\n *\n *   Return whenever the current thread owns the loader lock.\n * This is useful to avoid blocking operations while holding the loader lock.\n */\ngboolean\nmono_loader_lock_is_owned_by_self (void)\n{\n\tg_assert (loader_lock_track_ownership);\n\n\treturn GPOINTER_TO_UINT (TlsGetValue (loader_lock_nest_id)) > 0;\n}\n\n/*\n * mono_loader_lock_if_inited:\n *\n *   Acquire the loader lock if it has been initialized, no-op otherwise. This can\n * be used in runtime initialization code which can be executed before mono_loader_init ().\n */\nvoid\nmono_loader_lock_if_inited (void)\n{\n\tif (loader_lock_inited)\n\t\tmono_loader_lock ();\n}\n\nvoid\nmono_loader_unlock_if_inited (void)\n{\n\tif (loader_lock_inited)\n\t\tmono_loader_unlock ();\n}\n\n/**\n * mono_method_signature:\n *\n * Return the signature of the method M. On failure, returns NULL, and ERR is set.\n */\nMonoMethodSignature*\nmono_method_signature_checked (MonoMethod *m, MonoError *error)\n{\n\tint idx;\n\tint size;\n\tMonoImage* img;\n\tconst char *sig;\n\tgboolean can_cache_signature;\n\tMonoGenericContainer *container;\n\tMonoMethodSignature *signature = NULL;\n\tguint32 sig_offset;\n\n\t/* We need memory barriers below because of the double-checked locking pattern */ \n\n\tmono_error_init (error);\n\n\tif (m->signature)\n\t\treturn m->signature;\n\n\tmono_loader_lock ();\n\n\tif (m->signature) {\n\t\tmono_loader_unlock ();\n\t\treturn m->signature;\n\t}\n\n\tif (m->is_inflated) {\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated *) m;\n\t\t/* the lock is recursive */\n\t\tsignature = mono_method_signature (imethod->declaring);\n\t\tsignature = inflate_generic_signature_checked (imethod->declaring->klass->image, signature, mono_method_get_context (m), error);\n\t\tif (!mono_error_ok (error)) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn NULL;\n\t\t}\n\n\t\tinflated_signatures_size += mono_metadata_signature_size (signature);\n\n\t\tmono_memory_barrier ();\n\t\tm->signature = signature;\n\t\tmono_loader_unlock ();\n\t\treturn m->signature;\n\t}\n\n\tg_assert (mono_metadata_token_table (m->token) == MONO_TABLE_METHOD);\n\tidx = mono_metadata_token_index (m->token);\n\timg = m->klass->image;\n\n\tsig = mono_metadata_blob_heap (img, sig_offset = mono_metadata_decode_row_col (&img->tables [MONO_TABLE_METHOD], idx - 1, MONO_METHOD_SIGNATURE));\n\n\tg_assert (!m->klass->generic_class);\n\tcontainer = mono_method_get_generic_container (m);\n\tif (!container)\n\t\tcontainer = m->klass->generic_container;\n\n\t/* Generic signatures depend on the container so they cannot be cached */\n\t/* icall/pinvoke signatures cannot be cached cause we modify them below */\n\tcan_cache_signature = !(m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) && !(m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) && !container;\n\n\t/* If the method has parameter attributes, that can modify the signature */\n\tif (mono_metadata_method_has_param_attrs (img, idx))\n\t\tcan_cache_signature = FALSE;\n\n\tif (can_cache_signature)\n\t\tsignature = g_hash_table_lookup (img->method_signatures, sig);\n\n\tif (!signature) {\n\t\tconst char *sig_body;\n\t\t/*TODO we should cache the failure result somewhere*/\n\t\tif (!mono_verifier_verify_method_signature (img, sig_offset, error)) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsize = mono_metadata_decode_blob_size (sig, &sig_body);\n\n\t\tsignature = mono_metadata_parse_method_signature_full (img, container, idx, sig_body, NULL);\n\t\tif (!signature) {\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_error_set_method_load (error, m->klass, m->name, \"\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (can_cache_signature)\n\t\t\tg_hash_table_insert (img->method_signatures, (gpointer)sig, signature);\n\t}\n\n\t/* Verify metadata consistency */\n\tif (signature->generic_param_count) {\n\t\tif (!container || !container->is_method) {\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_error_set_method_load (error, m->klass, m->name, \"Signature claims method has generic parameters, but generic_params table says it doesn't for method 0x%08x from image %s\", idx, img->name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (container->type_argc != signature->generic_param_count) {\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_error_set_method_load (error, m->klass, m->name, \"Inconsistent generic parameter count.  Signature says %d, generic_params table says %d for method 0x%08x from image %s\", signature->generic_param_count, container->type_argc, idx, img->name);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (container && container->is_method && container->type_argc) {\n\t\tmono_loader_unlock ();\n\t\tmono_error_set_method_load (error, m->klass, m->name, \"generic_params table claims method has generic parameters, but signature says it doesn't for method 0x%08x from image %s\", idx, img->name);\n\t\treturn NULL;\n\t}\n\tif (m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL)\n\t\tsignature->pinvoke = 1;\n\telse if (m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tMonoCallConvention conv = 0;\n\t\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)m;\n\t\tsignature->pinvoke = 1;\n\n\t\tswitch (piinfo->piflags & PINVOKE_ATTRIBUTE_CALL_CONV_MASK) {\n\t\tcase 0: /* no call conv, so using default */\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_WINAPI:\n\t\t\tconv = MONO_CALL_DEFAULT;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_CDECL:\n\t\t\tconv = MONO_CALL_C;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_STDCALL:\n\t\t\tconv = MONO_CALL_STDCALL;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_THISCALL:\n\t\t\tconv = MONO_CALL_THISCALL;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_FASTCALL:\n\t\t\tconv = MONO_CALL_FASTCALL;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_GENERIC:\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_GENERICINST:\n\t\tdefault:\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_error_set_method_load (error, m->klass, m->name, \"unsupported calling convention : 0x%04x for method 0x%08x from image %s\", piinfo->piflags, idx, img->name);\n\t\t\treturn NULL;\n\t\t}\n\t\tsignature->call_convention = conv;\n\t}\n\n\tmono_memory_barrier ();\n\tm->signature = signature;\n\n\tmono_loader_unlock ();\n\treturn m->signature;\n}\n\n/**\n * mono_method_signature:\n *\n * Return the signature of the method M. On failure, returns NULL.\n */\nMonoMethodSignature*\nmono_method_signature (MonoMethod *m)\n{\n\tMonoError error;\n\tMonoMethodSignature *sig;\n\n\tsig = mono_method_signature_checked (m, &error);\n\tif (!sig) {\n\t\tchar *type_name = mono_type_get_full_name (m->klass);\n\t\tg_warning (\"Could not load signature of %s:%s due to: %s\", type_name, m->name, mono_error_get_message (&error));\n\t\tg_free (type_name);\n\t\tmono_error_cleanup (&error);\n\t}\n\n\treturn sig;\n}\n\nconst char*\nmono_method_get_name (MonoMethod *method)\n{\n\treturn method->name;\n}\n\nMonoClass*\nmono_method_get_class (MonoMethod *method)\n{\n\treturn method->klass;\n}\n\nguint32\nmono_method_get_token (MonoMethod *method)\n{\n\treturn method->token;\n}\n\nMonoMethodHeader*\nmono_method_get_header (MonoMethod *method)\n{\n\tint idx;\n\tguint32 rva;\n\tMonoImage* img;\n\tgpointer loc;\n\tMonoMethodHeader *header;\n\n\tif ((method->flags & METHOD_ATTRIBUTE_ABSTRACT) || (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) || (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) || (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\treturn NULL;\n\n\tif (method->is_inflated) {\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated *) method;\n\t\tMonoMethodHeader *header;\n\n\t\tmono_loader_lock ();\n\n\t\tif (imethod->header) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn imethod->header;\n\t\t}\n\n\t\theader = mono_method_get_header (imethod->declaring);\n\t\tif (!header) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn NULL;\n\t\t}\n\n\t\timethod->header = inflate_generic_header (header, mono_method_get_context (method));\n\t\tmono_loader_unlock ();\n\t\tmono_metadata_free_mh (header);\n\t\treturn imethod->header;\n\t}\n\n\tif (method->wrapper_type != MONO_WRAPPER_NONE || method->sre_method) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper *)method;\n\t\tg_assert (mw->header);\n\t\treturn mw->header;\n\t}\n\n\t/* \n\t * We don't need locks here: the new header is allocated from malloc memory\n\t * and is not stored anywhere in the runtime, the user needs to free it.\n\t */\n\tg_assert (mono_metadata_token_table (method->token) == MONO_TABLE_METHOD);\n\tidx = mono_metadata_token_index (method->token);\n\timg = method->klass->image;\n\trva = mono_metadata_decode_row_col (&img->tables [MONO_TABLE_METHOD], idx - 1, MONO_METHOD_RVA);\n\n\tif (!mono_verifier_verify_method_header (img, rva, NULL))\n\t\treturn NULL;\n\n\tloc = mono_image_rva_map (img, rva);\n\tif (!loc)\n\t\treturn NULL;\n\n\theader = mono_metadata_parse_mh_full (img, mono_method_get_generic_container (method), loc);\n\n\treturn header;\n}\n\nguint32\nmono_method_get_flags (MonoMethod *method, guint32 *iflags)\n{\n\tif (iflags)\n\t\t*iflags = method->iflags;\n\treturn method->flags;\n}\n\n/*\n * Find the method index in the metadata methodDef table.\n */\nguint32\nmono_method_get_index (MonoMethod *method) {\n\tMonoClass *klass = method->klass;\n\tint i;\n\n\tif (klass->rank)\n\t\t/* constructed array methods are not in the MethodDef table */\n\t\treturn 0;\n\n\tif (method->token)\n\t\treturn mono_metadata_token_index (method->token);\n\n\tmono_class_setup_methods (klass);\n\tif (klass->exception_type)\n\t\treturn 0;\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tif (method == klass->methods [i]) {\n\t\t\tif (klass->image->uncompressed_metadata)\n\t\t\t\treturn mono_metadata_translate_token_index (klass->image, MONO_TABLE_METHOD, klass->method.first + i + 1);\n\t\t\telse\n\t\t\t\treturn klass->method.first + i + 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"], "fixing_code": ["/*\n * loader.c: Image Loader \n *\n * Authors:\n *   Paolo Molaro (lupus@ximian.com)\n *   Miguel de Icaza (miguel@ximian.com)\n *   Patrik Torstensson (patrik.torstensson@labs2.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n *\n * This file is used by the interpreter and the JIT engine to locate\n * assemblies.  Used to load AssemblyRef and later to resolve various\n * kinds of `Refs'.\n *\n * TODO:\n *   This should keep track of the assembly versions that we are loading.\n *\n */\n#include <config.h>\n#include <glib.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <mono/metadata/metadata.h>\n#include <mono/metadata/image.h>\n#include <mono/metadata/assembly.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/metadata-internals.h>\n#include <mono/metadata/loader.h>\n#include <mono/metadata/class-internals.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/reflection.h>\n#include <mono/metadata/profiler.h>\n#include <mono/metadata/profiler-private.h>\n#include <mono/metadata/exception.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/lock-tracer.h>\n#include <mono/metadata/verify-internals.h>\n#include <mono/utils/mono-logger-internal.h>\n#include <mono/utils/mono-dl.h>\n#include <mono/utils/mono-membar.h>\n#include <mono/utils/mono-counters.h>\n#include <mono/utils/mono-error-internals.h>\n\nMonoDefaults mono_defaults;\n\n/*\n * This lock protects the hash tables inside MonoImage used by the metadata \n * loading functions in class.c and loader.c.\n *\n * See domain-internals.h for locking policy in combination with the\n * domain lock.\n */\nstatic CRITICAL_SECTION loader_mutex;\nstatic gboolean loader_lock_inited;\n\n/* Statistics */\nstatic guint32 inflated_signatures_size;\nstatic guint32 memberref_sig_cache_size;\n\n/*\n * This TLS variable contains the last type load error encountered by the loader.\n */\nguint32 loader_error_thread_id;\n\n/*\n * This TLS variable holds how many times the current thread has acquired the loader \n * lock.\n */\nguint32 loader_lock_nest_id;\n\nstatic void dllmap_cleanup (void);\n\nvoid\nmono_loader_init ()\n{\n\tstatic gboolean inited;\n\n\tif (!inited) {\n\t\tInitializeCriticalSection (&loader_mutex);\n\t\tloader_lock_inited = TRUE;\n\n\t\tloader_error_thread_id = TlsAlloc ();\n\t\tloader_lock_nest_id = TlsAlloc ();\n\n\t\tmono_counters_register (\"Inflated signatures size\",\n\t\t\t\t\t\t\t\tMONO_COUNTER_GENERICS | MONO_COUNTER_INT, &inflated_signatures_size);\n\t\tmono_counters_register (\"Memberref signature cache size\",\n\t\t\t\t\t\t\t\tMONO_COUNTER_METADATA | MONO_COUNTER_INT, &memberref_sig_cache_size);\n\n\t\tinited = TRUE;\n\t}\n}\n\nvoid\nmono_loader_cleanup (void)\n{\n\tdllmap_cleanup ();\n\n\tTlsFree (loader_error_thread_id);\n\tTlsFree (loader_lock_nest_id);\n\n\tDeleteCriticalSection (&loader_mutex);\n\tloader_lock_inited = FALSE;\t\n}\n\n/*\n * Handling of type load errors should be done as follows:\n *\n *   If something could not be loaded, the loader should call one of the\n * mono_loader_set_error_XXX functions ()\n * with the appropriate arguments, then return NULL to report the failure. The error \n * should be propagated until it reaches code which can throw managed exceptions. At that\n * point, an exception should be thrown based on the information returned by\n * mono_loader_get_last_error (). Then the error should be cleared by calling \n * mono_loader_clear_error ().\n */\n\nstatic void\nset_loader_error (MonoLoaderError *error)\n{\n\tTlsSetValue (loader_error_thread_id, error);\n}\n\n/**\n * mono_loader_set_error_assembly_load:\n *\n * Set the loader error for this thread. \n */\nvoid\nmono_loader_set_error_assembly_load (const char *assembly_name, gboolean ref_only)\n{\n\tMonoLoaderError *error;\n\n\tif (mono_loader_get_last_error ()) \n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_FILE_NOT_FOUND;\n\terror->assembly_name = g_strdup (assembly_name);\n\terror->ref_only = ref_only;\n\n\t/* \n\t * This is not strictly needed, but some (most) of the loader code still\n\t * can't deal with load errors, and this message is more helpful than an\n\t * assert.\n\t */\n\tif (ref_only)\n\t\tg_warning (\"Cannot resolve dependency to assembly '%s' because it has not been preloaded. When using the ReflectionOnly APIs, dependent assemblies must be pre-loaded or loaded on demand through the ReflectionOnlyAssemblyResolve event.\", assembly_name);\n\telse\n\t\tg_warning (\"Could not load file or assembly '%s' or one of its dependencies.\", assembly_name);\n\n\tset_loader_error (error);\n}\n\n/**\n * mono_loader_set_error_type_load:\n *\n * Set the loader error for this thread. \n */\nvoid\nmono_loader_set_error_type_load (const char *class_name, const char *assembly_name)\n{\n\tMonoLoaderError *error;\n\n\tif (mono_loader_get_last_error ()) \n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_TYPE_LOAD;\n\terror->class_name = g_strdup (class_name);\n\terror->assembly_name = g_strdup (assembly_name);\n\n\t/* \n\t * This is not strictly needed, but some (most) of the loader code still\n\t * can't deal with load errors, and this message is more helpful than an\n\t * assert.\n\t */\n\tmono_trace_warning (MONO_TRACE_TYPE, \"The class %s could not be loaded, used in %s\", class_name, assembly_name);\n\n\tset_loader_error (error);\n}\n\n/*\n * mono_loader_set_error_method_load:\n *\n *   Set the loader error for this thread. MEMBER_NAME should point to a string\n * inside metadata.\n */\nvoid\nmono_loader_set_error_method_load (const char *class_name, const char *member_name)\n{\n\tMonoLoaderError *error;\n\n\t/* FIXME: Store the signature as well */\n\tif (mono_loader_get_last_error ())\n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_MISSING_METHOD;\n\terror->class_name = g_strdup (class_name);\n\terror->member_name = member_name;\n\n\tset_loader_error (error);\n}\n\n/*\n * mono_loader_set_error_field_load:\n *\n * Set the loader error for this thread. MEMBER_NAME should point to a string\n * inside metadata.\n */\nvoid\nmono_loader_set_error_field_load (MonoClass *klass, const char *member_name)\n{\n\tMonoLoaderError *error;\n\n\t/* FIXME: Store the signature as well */\n\tif (mono_loader_get_last_error ())\n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_MISSING_FIELD;\n\terror->klass = klass;\n\terror->member_name = member_name;\n\n\tset_loader_error (error);\n}\n\n/*\n * mono_loader_set_error_bad_image:\n *\n * Set the loader error for this thread. \n */\nvoid\nmono_loader_set_error_bad_image (char *msg)\n{\n\tMonoLoaderError *error;\n\n\tif (mono_loader_get_last_error ())\n\t\treturn;\n\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_BAD_IMAGE;\n\terror->msg = msg;\n\n\tset_loader_error (error);\n}\t\n\n\n/*\n * mono_loader_get_last_error:\n *\n *   Returns information about the last type load exception encountered by the loader, or\n * NULL. After use, the exception should be cleared by calling mono_loader_clear_error.\n */\nMonoLoaderError*\nmono_loader_get_last_error (void)\n{\n\treturn (MonoLoaderError*)TlsGetValue (loader_error_thread_id);\n}\n\n/**\n * mono_loader_clear_error:\n *\n * Disposes any loader error messages on this thread\n */\nvoid\nmono_loader_clear_error (void)\n{\n\tMonoLoaderError *ex = (MonoLoaderError*)TlsGetValue (loader_error_thread_id);\n\n\tif (ex) {\n\t\tg_free (ex->class_name);\n\t\tg_free (ex->assembly_name);\n\t\tg_free (ex->msg);\n\t\tg_free (ex);\n\t\n\t\tTlsSetValue (loader_error_thread_id, NULL);\n\t}\n}\n\n/**\n * mono_loader_error_prepare_exception:\n * @error: The MonoLoaderError to turn into an exception\n *\n * This turns a MonoLoaderError into an exception that can be thrown\n * and resets the Mono Loader Error state during this process.\n *\n */\nMonoException *\nmono_loader_error_prepare_exception (MonoLoaderError *error)\n{\n\tMonoException *ex = NULL;\n\n\tswitch (error->exception_type) {\n\tcase MONO_EXCEPTION_TYPE_LOAD: {\n\t\tchar *cname = g_strdup (error->class_name);\n\t\tchar *aname = g_strdup (error->assembly_name);\n\t\tMonoString *class_name;\n\t\t\n\t\tmono_loader_clear_error ();\n\t\t\n\t\tclass_name = mono_string_new (mono_domain_get (), cname);\n\n\t\tex = mono_get_exception_type_load (class_name, aname);\n\t\tg_free (cname);\n\t\tg_free (aname);\n\t\tbreak;\n        }\n\tcase MONO_EXCEPTION_MISSING_METHOD: {\n\t\tchar *cname = g_strdup (error->class_name);\n\t\tchar *aname = g_strdup (error->member_name);\n\t\t\n\t\tmono_loader_clear_error ();\n\t\tex = mono_get_exception_missing_method (cname, aname);\n\t\tg_free (cname);\n\t\tg_free (aname);\n\t\tbreak;\n\t}\n\t\t\n\tcase MONO_EXCEPTION_MISSING_FIELD: {\n\t\tchar *cnspace = g_strdup ((error->klass && *error->klass->name_space) ? error->klass->name_space : \"\");\n\t\tchar *cname = g_strdup (error->klass ? error->klass->name : \"\");\n\t\tchar *cmembername = g_strdup (error->member_name);\n                char *class_name;\n\n\t\tmono_loader_clear_error ();\n\t\tclass_name = g_strdup_printf (\"%s%s%s\", cnspace, cnspace ? \".\" : \"\", cname);\n\t\t\n\t\tex = mono_get_exception_missing_field (class_name, cmembername);\n\t\tg_free (class_name);\n\t\tg_free (cname);\n\t\tg_free (cmembername);\n\t\tg_free (cnspace);\n\t\tbreak;\n        }\n\t\n\tcase MONO_EXCEPTION_FILE_NOT_FOUND: {\n\t\tchar *msg;\n\t\tchar *filename;\n\n\t\tif (error->ref_only)\n\t\t\tmsg = g_strdup_printf (\"Cannot resolve dependency to assembly '%s' because it has not been preloaded. When using the ReflectionOnly APIs, dependent assemblies must be pre-loaded or loaded on demand through the ReflectionOnlyAssemblyResolve event.\", error->assembly_name);\n\t\telse\n\t\t\tmsg = g_strdup_printf (\"Could not load file or assembly '%s' or one of its dependencies.\", error->assembly_name);\n\t\tfilename = g_strdup (error->assembly_name);\n\t\t/* Has to call this before calling anything which might call mono_class_init () */\n\t\tmono_loader_clear_error ();\n\t\tex = mono_get_exception_file_not_found2 (msg, mono_string_new (mono_domain_get (), filename));\n\t\tg_free (msg);\n\t\tg_free (filename);\n\t\tbreak;\n\t}\n\n\tcase MONO_EXCEPTION_BAD_IMAGE: {\n\t\tchar *msg = g_strdup (error->msg);\n\t\tmono_loader_clear_error ();\n\t\tex = mono_get_exception_bad_image_format (msg);\n\t\tg_free (msg);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\treturn ex;\n}\n\n/*\n * find_cached_memberref_sig:\n *\n *   Return a cached copy of the memberref signature identified by SIG_IDX.\n * We use a gpointer since the cache stores both MonoTypes and MonoMethodSignatures.\n * A cache is needed since the type/signature parsing routines allocate everything \n * from a mempool, so without a cache, multiple requests for the same signature would \n * lead to unbounded memory growth. For normal methods/fields this is not a problem \n * since the resulting methods/fields are cached, but inflated methods/fields cannot\n * be cached.\n * LOCKING: Acquires the loader lock.\n */\nstatic gpointer\nfind_cached_memberref_sig (MonoImage *image, guint32 sig_idx)\n{\n\tgpointer res;\n\n\tmono_loader_lock ();\n\tres = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));\n\tmono_loader_unlock ();\n\n\treturn res;\n}\n\nstatic gpointer\ncache_memberref_sig (MonoImage *image, guint32 sig_idx, gpointer sig)\n{\n\tgpointer prev_sig;\n\n\tmono_loader_lock ();\n\tprev_sig = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));\n\tif (prev_sig) {\n\t\t/* Somebody got in before us */\n\t\tsig = prev_sig;\n\t}\n\telse {\n\t\tg_hash_table_insert (image->memberref_signatures, GUINT_TO_POINTER (sig_idx), sig);\n\t\t/* An approximation based on glib 2.18 */\n\t\tmemberref_sig_cache_size += sizeof (gpointer) * 4;\n\t}\n\n\tmono_loader_unlock ();\n\n\treturn sig;\n}\n\nstatic MonoClassField*\nfield_from_memberref (MonoImage *image, guint32 token, MonoClass **retklass,\n\t\t      MonoGenericContext *context)\n{\n\tMonoClass *klass;\n\tMonoClassField *field;\n\tMonoTableInfo *tables = image->tables;\n\tMonoType *sig_type;\n\tguint32 cols[6];\n\tguint32 nindex, class, class_table;\n\tconst char *fname;\n\tconst char *ptr;\n\tguint32 idx = mono_metadata_token_index (token);\n\n\tmono_metadata_decode_row (&tables [MONO_TABLE_MEMBERREF], idx-1, cols, MONO_MEMBERREF_SIZE);\n\tnindex = cols [MONO_MEMBERREF_CLASS] >> MONO_MEMBERREF_PARENT_BITS;\n\tclass = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\n\tfname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\tif (!mono_verifier_verify_memberref_signature (image, cols [MONO_MEMBERREF_SIGNATURE], NULL)) {\n\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad field signature class token 0x%08x field name %s token 0x%08x on image %s\", class, fname, token, image->name));\n\t\treturn NULL;\n\t}\n\n\tswitch (class) {\n\tcase MONO_MEMBERREF_PARENT_TYPEDEF:\n\t\tclass_table = MONO_TOKEN_TYPE_DEF;\n\t\tklass = mono_class_get (image, MONO_TOKEN_TYPE_DEF | nindex);\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPEREF:\n\t\tclass_table = MONO_TOKEN_TYPE_REF;\n\t\tklass = mono_class_from_typeref (image, MONO_TOKEN_TYPE_REF | nindex);\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPESPEC:\n\t\tclass_table = MONO_TOKEN_TYPE_SPEC;\n\t\tklass = mono_class_get_full (image, MONO_TOKEN_TYPE_SPEC | nindex, context);\n\t\tbreak;\n\tdefault:\n\t\t/*FIXME this must set a loader error!*/\n\t\tg_warning (\"field load from %x\", class);\n\t\treturn NULL;\n\t}\n\n\tif (!klass) {\n\t\tchar *name = mono_class_name_from_token (image, class_table | nindex);\n\t\tg_warning (\"Missing field %s in class %s (type token %d)\", fname, name, class_table | nindex);\n\t\tmono_loader_set_error_type_load (name, image->assembly_name);\n\t\tg_free (name);\n\t\treturn NULL;\n\t}\n\n\tptr = mono_metadata_blob_heap (image, cols [MONO_MEMBERREF_SIGNATURE]);\n\tmono_metadata_decode_blob_size (ptr, &ptr);\n\t/* we may want to check the signature here... */\n\n\tif (*ptr++ != 0x6) {\n\t\tg_warning (\"Bad field signature class token %08x field name %s token %08x\", class, fname, token);\n\t\tmono_loader_set_error_field_load (klass, fname);\n\t\treturn NULL;\n\t}\n\t/* FIXME: This needs a cache, especially for generic instances, since\n\t * mono_metadata_parse_type () allocates everything from a mempool.\n\t */\n\tsig_type = find_cached_memberref_sig (image, cols [MONO_MEMBERREF_SIGNATURE]);\n\tif (!sig_type) {\n\t\tsig_type = mono_metadata_parse_type (image, MONO_PARSE_TYPE, 0, ptr, &ptr);\n\t\tif (sig_type == NULL) {\n\t\t\tmono_loader_set_error_field_load (klass, fname);\n\t\t\treturn NULL;\n\t\t}\n\t\tsig_type = cache_memberref_sig (image, cols [MONO_MEMBERREF_SIGNATURE], sig_type);\n\t}\n\n\tmono_class_init (klass); /*FIXME is this really necessary?*/\n\tif (retklass)\n\t\t*retklass = klass;\n\tfield = mono_class_get_field_from_name_full (klass, fname, sig_type);\n\n\tif (!field)\n\t\tmono_loader_set_error_field_load (klass, fname);\n\n\treturn field;\n}\n\nMonoClassField*\nmono_field_from_token (MonoImage *image, guint32 token, MonoClass **retklass,\n\t\t       MonoGenericContext *context)\n{\n\tMonoClass *k;\n\tguint32 type;\n\tMonoClassField *field;\n\n\tif (image->dynamic) {\n\t\tMonoClassField *result;\n\t\tMonoClass *handle_class;\n\n\t\t*retklass = NULL;\n\t\tresult = mono_lookup_dynamic_token_class (image, token, TRUE, &handle_class, context);\n\t\t// This checks the memberref type as well\n\t\tif (!result || handle_class != mono_defaults.fieldhandle_class) {\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad field token 0x%08x on image %s.\", token, image->name));\n\t\t\treturn NULL;\n\t\t}\n\t\t*retklass = result->parent;\n\t\treturn result;\n\t}\n\n\tmono_loader_lock ();\n\tif ((field = g_hash_table_lookup (image->field_cache, GUINT_TO_POINTER (token)))) {\n\t\t*retklass = field->parent;\n\t\tmono_loader_unlock ();\n\t\treturn field;\n\t}\n\tmono_loader_unlock ();\n\n\tif (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF)\n\t\tfield = field_from_memberref (image, token, retklass, context);\n\telse {\n\t\ttype = mono_metadata_typedef_from_field (image, mono_metadata_token_index (token));\n\t\tif (!type)\n\t\t\treturn NULL;\n\t\tk = mono_class_get (image, MONO_TOKEN_TYPE_DEF | type);\n\t\tif (!k)\n\t\t\treturn NULL;\n\t\tmono_class_init (k);\n\t\tif (retklass)\n\t\t\t*retklass = k;\n\t\tfield = mono_class_get_field (k, token);\n\t}\n\n\tmono_loader_lock ();\n\tif (field && field->parent && !field->parent->generic_class && !field->parent->generic_container)\n\t\tg_hash_table_insert (image->field_cache, GUINT_TO_POINTER (token), field);\n\tmono_loader_unlock ();\n\treturn field;\n}\n\nstatic gboolean\nmono_metadata_signature_vararg_match (MonoMethodSignature *sig1, MonoMethodSignature *sig2)\n{\n\tint i;\n\n\tif (sig1->hasthis != sig2->hasthis ||\n\t    sig1->sentinelpos != sig2->sentinelpos)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < sig1->sentinelpos; i++) { \n\t\tMonoType *p1 = sig1->params[i];\n\t\tMonoType *p2 = sig2->params[i];\n\n\t\t/*if (p1->attrs != p2->attrs)\n\t\t\treturn FALSE;\n\t\t*/\n\t\tif (!mono_metadata_type_equal (p1, p2))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!mono_metadata_type_equal (sig1->ret, sig2->ret))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nstatic MonoMethod *\nfind_method_in_class (MonoClass *klass, const char *name, const char *qname, const char *fqname,\n\t\t      MonoMethodSignature *sig, MonoClass *from_class)\n{\n \tint i;\n\n\t/* Search directly in the metadata to avoid calling setup_methods () */\n\n\t/* FIXME: !from_class->generic_class condition causes test failures. */\n\tif (klass->type_token && !klass->image->dynamic && !klass->methods && !klass->rank && klass == from_class && !from_class->generic_class) {\n\t\tfor (i = 0; i < klass->method.count; ++i) {\n\t\t\tguint32 cols [MONO_METHOD_SIZE];\n\t\t\tMonoMethod *method;\n\t\t\tconst char *m_name;\n\t\t\tMonoMethodSignature *other_sig;\n\n\t\t\tmono_metadata_decode_table_row (klass->image, MONO_TABLE_METHOD, klass->method.first + i, cols, MONO_METHOD_SIZE);\n\n\t\t\tm_name = mono_metadata_string_heap (klass->image, cols [MONO_METHOD_NAME]);\n\n\t\t\tif (!((fqname && !strcmp (m_name, fqname)) ||\n\t\t\t\t  (qname && !strcmp (m_name, qname)) ||\n\t\t\t\t  (name && !strcmp (m_name, name))))\n\t\t\t\tcontinue;\n\n\t\t\tmethod = mono_get_method (klass->image, MONO_TOKEN_METHOD_DEF | (klass->method.first + i + 1), klass);\n\t\t\tother_sig = mono_method_signature (method);\n\t\t\tif (method && other_sig && (sig->call_convention != MONO_CALL_VARARG) && mono_metadata_signature_equal (sig, other_sig))\n\t\t\t\treturn method;\n\t\t}\n\t}\n\n\tmono_class_setup_methods (klass);\n\t/*\n\tWe can't fail lookup of methods otherwise the runtime will fail with MissingMethodException instead of TypeLoadException.\n\tSee mono/tests/generic-type-load-exception.2.il\n\tFIXME we should better report this error to the caller\n\t */\n\tif (!klass->methods)\n\t\treturn NULL;\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tMonoMethod *m = klass->methods [i];\n\t\tMonoMethodSignature *msig;\n\n\t\tif (!((fqname && !strcmp (m->name, fqname)) ||\n\t\t      (qname && !strcmp (m->name, qname)) ||\n\t\t      (name && !strcmp (m->name, name))))\n\t\t\tcontinue;\n\t\tmsig = mono_method_signature (m);\n\t\tif (!msig)\n\t\t\tcontinue;\n\n\t\tif (sig->call_convention == MONO_CALL_VARARG) {\n\t\t\tif (mono_metadata_signature_vararg_match (sig, msig))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (mono_metadata_signature_equal (sig, msig))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i < klass->method.count)\n\t\treturn mono_class_get_method_by_index (from_class, i);\n\treturn NULL;\n}\n\nstatic MonoMethod *\nfind_method (MonoClass *in_class, MonoClass *ic, const char* name, MonoMethodSignature *sig, MonoClass *from_class)\n{\n\tint i;\n\tchar *qname, *fqname, *class_name;\n\tgboolean is_interface;\n\tMonoMethod *result = NULL;\n\n\tis_interface = MONO_CLASS_IS_INTERFACE (in_class);\n\n\tif (ic) {\n\t\tclass_name = mono_type_get_name_full (&ic->byval_arg, MONO_TYPE_NAME_FORMAT_IL);\n\n\t\tqname = g_strconcat (class_name, \".\", name, NULL); \n\t\tif (ic->name_space && ic->name_space [0])\n\t\t\tfqname = g_strconcat (ic->name_space, \".\", class_name, \".\", name, NULL);\n\t\telse\n\t\t\tfqname = NULL;\n\t} else\n\t\tclass_name = qname = fqname = NULL;\n\n\twhile (in_class) {\n\t\tg_assert (from_class);\n\t\tresult = find_method_in_class (in_class, name, qname, fqname, sig, from_class);\n\t\tif (result)\n\t\t\tgoto out;\n\n\t\tif (name [0] == '.' && (!strcmp (name, \".ctor\") || !strcmp (name, \".cctor\")))\n\t\t\tbreak;\n\n\t\tg_assert (from_class->interface_offsets_count == in_class->interface_offsets_count);\n\t\tfor (i = 0; i < in_class->interface_offsets_count; i++) {\n\t\t\tMonoClass *in_ic = in_class->interfaces_packed [i];\n\t\t\tMonoClass *from_ic = from_class->interfaces_packed [i];\n\t\t\tchar *ic_qname, *ic_fqname, *ic_class_name;\n\t\t\t\n\t\t\tic_class_name = mono_type_get_name_full (&in_ic->byval_arg, MONO_TYPE_NAME_FORMAT_IL);\n\t\t\tic_qname = g_strconcat (ic_class_name, \".\", name, NULL); \n\t\t\tif (in_ic->name_space && in_ic->name_space [0])\n\t\t\t\tic_fqname = g_strconcat (in_ic->name_space, \".\", ic_class_name, \".\", name, NULL);\n\t\t\telse\n\t\t\t\tic_fqname = NULL;\n\n\t\t\tresult = find_method_in_class (in_ic, ic ? name : NULL, ic_qname, ic_fqname, sig, from_ic);\n\t\t\tg_free (ic_class_name);\n\t\t\tg_free (ic_fqname);\n\t\t\tg_free (ic_qname);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tin_class = in_class->parent;\n\t\tfrom_class = from_class->parent;\n\t}\n\tg_assert (!in_class == !from_class);\n\n\tif (is_interface)\n\t\tresult = find_method_in_class (mono_defaults.object_class, name, qname, fqname, sig, mono_defaults.object_class);\n\n out:\n\tg_free (class_name);\n\tg_free (fqname);\n\tg_free (qname);\n\treturn result;\n}\n\nstatic MonoMethodSignature*\ninflate_generic_signature_checked (MonoImage *image, MonoMethodSignature *sig, MonoGenericContext *context, MonoError *error)\n{\n\tMonoMethodSignature *res;\n\tgboolean is_open;\n\tint i;\n\n\tmono_error_init (error);\n\tif (!context)\n\t\treturn sig;\n\n\tres = g_malloc0 (MONO_SIZEOF_METHOD_SIGNATURE + ((gint32)sig->param_count) * sizeof (MonoType*));\n\tres->param_count = sig->param_count;\n\tres->sentinelpos = -1;\n\tres->ret = mono_class_inflate_generic_type_checked (sig->ret, context, error);\n\tif (!mono_error_ok (error))\n\t\tgoto fail;\n\tis_open = mono_class_is_open_constructed_type (res->ret);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tres->params [i] = mono_class_inflate_generic_type_checked (sig->params [i], context, error);\n\t\tif (!mono_error_ok (error))\n\t\t\tgoto fail;\n\n\t\tif (!is_open)\n\t\t\tis_open = mono_class_is_open_constructed_type (res->params [i]);\n\t}\n\tres->hasthis = sig->hasthis;\n\tres->explicit_this = sig->explicit_this;\n\tres->call_convention = sig->call_convention;\n\tres->pinvoke = sig->pinvoke;\n\tres->generic_param_count = sig->generic_param_count;\n\tres->sentinelpos = sig->sentinelpos;\n\tres->has_type_parameters = is_open;\n\tres->is_inflated = 1;\n\treturn res;\n\nfail:\n\tif (res->ret)\n\t\tmono_metadata_free_type (res->ret);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tif (res->params [i])\n\t\t\tmono_metadata_free_type (res->params [i]);\n\t}\n\tg_free (res);\n\treturn NULL;\n}\n\nstatic MonoMethodHeader*\ninflate_generic_header (MonoMethodHeader *header, MonoGenericContext *context)\n{\n\tMonoMethodHeader *res;\n\tint i;\n\tres = g_malloc0 (MONO_SIZEOF_METHOD_HEADER + sizeof (gpointer) * header->num_locals);\n\tres->code = header->code;\n\tres->code_size = header->code_size;\n\tres->max_stack = header->max_stack;\n\tres->num_clauses = header->num_clauses;\n\tres->init_locals = header->init_locals;\n\tres->num_locals = header->num_locals;\n\tres->clauses = header->clauses;\n\tfor (i = 0; i < header->num_locals; ++i)\n\t\tres->locals [i] = mono_class_inflate_generic_type (header->locals [i], context);\n\tif (res->num_clauses) {\n\t\tres->clauses = g_memdup (header->clauses, sizeof (MonoExceptionClause) * res->num_clauses);\n\t\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\t\tMonoExceptionClause *clause = &res->clauses [i];\n\t\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_NONE)\n\t\t\t\tcontinue;\n\t\t\tclause->data.catch_class = mono_class_inflate_generic_class (clause->data.catch_class, context);\n\t\t}\n\t}\n\treturn res;\n}\n\n/*\n * token is the method_ref/def/spec token used in a call IL instruction.\n */\nMonoMethodSignature*\nmono_method_get_signature_full (MonoMethod *method, MonoImage *image, guint32 token, MonoGenericContext *context)\n{\n\tint table = mono_metadata_token_table (token);\n\tint idx = mono_metadata_token_index (token);\n\tint sig_idx;\n\tguint32 cols [MONO_MEMBERREF_SIZE];\n\tMonoMethodSignature *sig;\n\tconst char *ptr;\n\n\t/* !table is for wrappers: we should really assign their own token to them */\n\tif (!table || table == MONO_TABLE_METHOD)\n\t\treturn mono_method_signature (method);\n\n\tif (table == MONO_TABLE_METHODSPEC) {\n\t\t/* the verifier (do_invoke_method) will turn the NULL into a verifier error */\n\t\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) || !method->is_inflated)\n\t\t\treturn NULL;\n\n\t\treturn mono_method_signature (method);\n\t}\n\n\tif (method->klass->generic_class)\n\t\treturn mono_method_signature (method);\n\n\tif (image->dynamic) {\n\t\tsig = mono_reflection_lookup_signature (image, method, token);\n\t} else {\n\t\tmono_metadata_decode_row (&image->tables [MONO_TABLE_MEMBERREF], idx-1, cols, MONO_MEMBERREF_SIZE);\n\t\tsig_idx = cols [MONO_MEMBERREF_SIGNATURE];\n\n\t\tsig = find_cached_memberref_sig (image, sig_idx);\n\t\tif (!sig) {\n\t\t\tif (!mono_verifier_verify_memberref_signature (image, sig_idx, NULL)) {\n\t\t\t\tguint32 class = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\t\t\t\tconst char *fname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\t\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad method signature class token 0x%08x field name %s token 0x%08x on image %s\", class, fname, token, image->name));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tptr = mono_metadata_blob_heap (image, sig_idx);\n\t\t\tmono_metadata_decode_blob_size (ptr, &ptr);\n\t\t\tsig = mono_metadata_parse_method_signature (image, 0, ptr, NULL);\n\t\t\tif (!sig)\n\t\t\t\treturn NULL;\n\t\t\tsig = cache_memberref_sig (image, sig_idx, sig);\n\t\t}\n\t\t/* FIXME: we probably should verify signature compat in the dynamic case too*/\n\t\tif (!mono_verifier_is_sig_compatible (image, method, sig)) {\n\t\t\tguint32 class = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\t\t\tconst char *fname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Incompatible method signature class token 0x%08x field name %s token 0x%08x on image %s\", class, fname, token, image->name));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tif (context) {\n\t\tMonoError error;\n\t\tMonoMethodSignature *cached;\n\n\t\t/* This signature is not owned by a MonoMethod, so need to cache */\n\t\tsig = inflate_generic_signature_checked (image, sig, context, &error);\n\t\tif (!mono_error_ok (&error)) {/*XXX bubble up this and kill one use of loader errors */\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Could not inflate signature %s\", mono_error_get_message (&error)));\n\t\t\tmono_error_cleanup (&error);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tcached = mono_metadata_get_inflated_signature (sig, context);\n\t\tif (cached != sig)\n\t\t\tmono_metadata_free_inflated_signature (sig);\n\t\telse\n\t\t\tinflated_signatures_size += mono_metadata_signature_size (cached);\n\t\tsig = cached;\n\t}\n\n\treturn sig;\n}\n\nMonoMethodSignature*\nmono_method_get_signature (MonoMethod *method, MonoImage *image, guint32 token)\n{\n\treturn mono_method_get_signature_full (method, image, token, NULL);\n}\n\n/* this is only for the typespec array methods */\nMonoMethod*\nmono_method_search_in_array_class (MonoClass *klass, const char *name, MonoMethodSignature *sig)\n{\n\tint i;\n\n\tmono_class_setup_methods (klass);\n\tg_assert (!klass->exception_type); /*FIXME this should not fail, right?*/\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tMonoMethod *method = klass->methods [i];\n\t\tif (strcmp (method->name, name) == 0 && sig->param_count == method->signature->param_count)\n\t\t\treturn method;\n\t}\n\treturn NULL;\n}\n\nstatic MonoMethod *\nmethod_from_memberref (MonoImage *image, guint32 idx, MonoGenericContext *typespec_context,\n\t\t       gboolean *used_context)\n{\n\tMonoClass *klass = NULL;\n\tMonoMethod *method = NULL;\n\tMonoTableInfo *tables = image->tables;\n\tguint32 cols[6];\n\tguint32 nindex, class, sig_idx;\n\tconst char *mname;\n\tMonoMethodSignature *sig;\n\tconst char *ptr;\n\n\tmono_metadata_decode_row (&tables [MONO_TABLE_MEMBERREF], idx-1, cols, 3);\n\tnindex = cols [MONO_MEMBERREF_CLASS] >> MONO_MEMBERREF_PARENT_BITS;\n\tclass = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\t/*g_print (\"methodref: 0x%x 0x%x %s\\n\", class, nindex,\n\t\tmono_metadata_string_heap (m, cols [MONO_MEMBERREF_NAME]));*/\n\n\tmname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\t/*\n\t * Whether we actually used the `typespec_context' or not.\n\t * This is used to tell our caller whether or not it's safe to insert the returned\n\t * method into a cache.\n\t */\n\tif (used_context)\n\t\t*used_context = class == MONO_MEMBERREF_PARENT_TYPESPEC;\n\n\tswitch (class) {\n\tcase MONO_MEMBERREF_PARENT_TYPEREF:\n\t\tklass = mono_class_from_typeref (image, MONO_TOKEN_TYPE_REF | nindex);\n\t\tif (!klass) {\n\t\t\tchar *name = mono_class_name_from_token (image, MONO_TOKEN_TYPE_REF | nindex);\n\t\t\tg_warning (\"Missing method %s in assembly %s, type %s\", mname, image->name, name);\n\t\t\tmono_loader_set_error_type_load (name, image->assembly_name);\n\t\t\tg_free (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPESPEC:\n\t\t/*\n\t\t * Parse the TYPESPEC in the parent's context.\n\t\t */\n\t\tklass = mono_class_get_full (image, MONO_TOKEN_TYPE_SPEC | nindex, typespec_context);\n\t\tif (!klass) {\n\t\t\tchar *name = mono_class_name_from_token (image, MONO_TOKEN_TYPE_SPEC | nindex);\n\t\t\tg_warning (\"Missing method %s in assembly %s, type %s\", mname, image->name, name);\n\t\t\tmono_loader_set_error_type_load (name, image->assembly_name);\n\t\t\tg_free (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPEDEF:\n\t\tklass = mono_class_get (image, MONO_TOKEN_TYPE_DEF | nindex);\n\t\tif (!klass) {\n\t\t\tchar *name = mono_class_name_from_token (image, MONO_TOKEN_TYPE_DEF | nindex);\n\t\t\tg_warning (\"Missing method %s in assembly %s, type %s\", mname, image->name, name);\n\t\t\tmono_loader_set_error_type_load (name, image->assembly_name);\n\t\t\tg_free (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_METHODDEF:\n\t\treturn mono_get_method (image, MONO_TOKEN_METHOD_DEF | nindex, NULL);\n\t\t\n\tdefault:\n\t\t{\n\t\t\t/* This message leaks */\n\t\t\tchar *message = g_strdup_printf (\"Memberref parent unknown: class: %d, index %d\", class, nindex);\n\t\t\tmono_loader_set_error_method_load (\"\", message);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tg_assert (klass);\n\tmono_class_init (klass);\n\n\tsig_idx = cols [MONO_MEMBERREF_SIGNATURE];\n\n\tif (!mono_verifier_verify_memberref_signature (image, sig_idx, NULL)) {\n\t\tmono_loader_set_error_method_load (klass->name, mname);\n\t\treturn NULL;\n\t}\n\n\tptr = mono_metadata_blob_heap (image, sig_idx);\n\tmono_metadata_decode_blob_size (ptr, &ptr);\n\n\tsig = find_cached_memberref_sig (image, sig_idx);\n\tif (!sig) {\n\t\tsig = mono_metadata_parse_method_signature (image, 0, ptr, NULL);\n\t\tif (sig == NULL)\n\t\t\treturn NULL;\n\n\t\tsig = cache_memberref_sig (image, sig_idx, sig);\n\t}\n\n\tswitch (class) {\n\tcase MONO_MEMBERREF_PARENT_TYPEREF:\n\tcase MONO_MEMBERREF_PARENT_TYPEDEF:\n\t\tmethod = find_method (klass, NULL, mname, sig, klass);\n\t\tbreak;\n\n\tcase MONO_MEMBERREF_PARENT_TYPESPEC: {\n\t\tMonoType *type;\n\n\t\ttype = &klass->byval_arg;\n\n\t\tif (type->type != MONO_TYPE_ARRAY && type->type != MONO_TYPE_SZARRAY) {\n\t\t\tMonoClass *in_class = klass->generic_class ? klass->generic_class->container_class : klass;\n\t\t\tmethod = find_method (in_class, NULL, mname, sig, klass);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* we're an array and we created these methods already in klass in mono_class_init () */\n\t\tmethod = mono_method_search_in_array_class (klass, mname, sig);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tg_error (\"Memberref parent unknown: class: %d, index %d\", class, nindex);\n\t\tg_assert_not_reached ();\n\t}\n\n\tif (!method) {\n\t\tchar *msig = mono_signature_get_desc (sig, FALSE);\n\t\tchar * class_name = mono_type_get_name (&klass->byval_arg);\n\t\tGString *s = g_string_new (mname);\n\t\tif (sig->generic_param_count)\n\t\t\tg_string_append_printf (s, \"<[%d]>\", sig->generic_param_count);\n\t\tg_string_append_printf (s, \"(%s)\", msig);\n\t\tg_free (msig);\n\t\tmsig = g_string_free (s, FALSE);\n\n\t\tg_warning (\n\t\t\t\"Missing method %s::%s in assembly %s, referenced in assembly %s\",\n\t\t\tclass_name, msig, klass->image->name, image->name);\n\t\tmono_loader_set_error_method_load (class_name, mname);\n\t\tg_free (msig);\n\t\tg_free (class_name);\n\t}\n\n\treturn method;\n}\n\nstatic MonoMethod *\nmethod_from_methodspec (MonoImage *image, MonoGenericContext *context, guint32 idx)\n{\n\tMonoError error;\n\tMonoMethod *method;\n\tMonoClass *klass;\n\tMonoTableInfo *tables = image->tables;\n\tMonoGenericContext new_context;\n\tMonoGenericInst *inst;\n\tconst char *ptr;\n\tguint32 cols [MONO_METHODSPEC_SIZE];\n\tguint32 token, nindex, param_count;\n\n\tmono_metadata_decode_row (&tables [MONO_TABLE_METHODSPEC], idx - 1, cols, MONO_METHODSPEC_SIZE);\n\ttoken = cols [MONO_METHODSPEC_METHOD];\n\tnindex = token >> MONO_METHODDEFORREF_BITS;\n\n\tif (!mono_verifier_verify_methodspec_signature (image, cols [MONO_METHODSPEC_SIGNATURE], NULL))\n\t\treturn NULL;\n\n\tptr = mono_metadata_blob_heap (image, cols [MONO_METHODSPEC_SIGNATURE]);\n\n\tmono_metadata_decode_value (ptr, &ptr);\n\tptr++;\n\tparam_count = mono_metadata_decode_value (ptr, &ptr);\n\tg_assert (param_count);\n\n\tinst = mono_metadata_parse_generic_inst (image, NULL, param_count, ptr, &ptr);\n\tif (context && inst->is_open) {\n\t\tinst = mono_metadata_inflate_generic_inst (inst, context, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tmono_error_cleanup (&error); /*FIXME don't swallow error message.*/\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif ((token & MONO_METHODDEFORREF_MASK) == MONO_METHODDEFORREF_METHODDEF)\n\t\tmethod = mono_get_method_full (image, MONO_TOKEN_METHOD_DEF | nindex, NULL, context);\n\telse\n\t\tmethod = method_from_memberref (image, nindex, context, NULL);\n\n\tif (!method)\n\t\treturn NULL;\n\n\tklass = method->klass;\n\n\tif (klass->generic_class) {\n\t\tg_assert (method->is_inflated);\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\t}\n\n\tnew_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\tnew_context.method_inst = inst;\n\n\treturn mono_class_inflate_generic_method_full (method, klass, &new_context);\n}\n\nstruct _MonoDllMap {\n\tchar *dll;\n\tchar *target;\n\tchar *func;\n\tchar *target_func;\n\tMonoDllMap *next;\n};\n\nstatic MonoDllMap *global_dll_map;\n\nstatic int \nmono_dllmap_lookup_list (MonoDllMap *dll_map, const char *dll, const char* func, const char **rdll, const char **rfunc) {\n\tint found = 0;\n\n\t*rdll = dll;\n\n\tif (!dll_map)\n\t\treturn 0;\n\n\tmono_loader_lock ();\n\n\t/* \n\t * we use the first entry we find that matches, since entries from\n\t * the config file are prepended to the list and we document that the\n\t * later entries win.\n\t */\n\tfor (; dll_map; dll_map = dll_map->next) {\n\t\tif (dll_map->dll [0] == 'i' && dll_map->dll [1] == ':') {\n\t\t\tif (g_ascii_strcasecmp (dll_map->dll + 2, dll))\n\t\t\t\tcontinue;\n\t\t} else if (strcmp (dll_map->dll, dll)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!found && dll_map->target) {\n\t\t\t*rdll = dll_map->target;\n\t\t\tfound = 1;\n\t\t\t/* we don't quit here, because we could find a full\n\t\t\t * entry that matches also function and that has priority.\n\t\t\t */\n\t\t}\n\t\tif (dll_map->func && strcmp (dll_map->func, func) == 0) {\n\t\t\t*rfunc = dll_map->target_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmono_loader_unlock ();\n\treturn found;\n}\n\nstatic int \nmono_dllmap_lookup (MonoImage *assembly, const char *dll, const char* func, const char **rdll, const char **rfunc)\n{\n\tint res;\n\tif (assembly && assembly->dll_map) {\n\t\tres = mono_dllmap_lookup_list (assembly->dll_map, dll, func, rdll, rfunc);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn mono_dllmap_lookup_list (global_dll_map, dll, func, rdll, rfunc);\n}\n\n/*\n * mono_dllmap_insert:\n *\n * LOCKING: Acquires the loader lock.\n *\n * NOTE: This can be called before the runtime is initialized, for example from\n * mono_config_parse ().\n */\nvoid\nmono_dllmap_insert (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)\n{\n\tMonoDllMap *entry;\n\n\tmono_loader_init ();\n\n\tmono_loader_lock ();\n\n\tif (!assembly) {\n\t\tentry = g_malloc0 (sizeof (MonoDllMap));\n\t\tentry->dll = dll? g_strdup (dll): NULL;\n\t\tentry->target = tdll? g_strdup (tdll): NULL;\n\t\tentry->func = func? g_strdup (func): NULL;\n\t\tentry->target_func = tfunc? g_strdup (tfunc): NULL;\n\t\tentry->next = global_dll_map;\n\t\tglobal_dll_map = entry;\n\t} else {\n\t\tentry = mono_image_alloc0 (assembly, sizeof (MonoDllMap));\n\t\tentry->dll = dll? mono_image_strdup (assembly, dll): NULL;\n\t\tentry->target = tdll? mono_image_strdup (assembly, tdll): NULL;\n\t\tentry->func = func? mono_image_strdup (assembly, func): NULL;\n\t\tentry->target_func = tfunc? mono_image_strdup (assembly, tfunc): NULL;\n\t\tentry->next = assembly->dll_map;\n\t\tassembly->dll_map = entry;\n\t}\n\n\tmono_loader_unlock ();\n}\n\nstatic void\nfree_dllmap (MonoDllMap *map)\n{\n\twhile (map) {\n\t\tMonoDllMap *next = map->next;\n\n\t\tg_free (map->dll);\n\t\tg_free (map->target);\n\t\tg_free (map->func);\n\t\tg_free (map->target_func);\n\t\tg_free (map);\n\t\tmap = next;\n\t}\n}\n\nstatic void\ndllmap_cleanup (void)\n{\n\tfree_dllmap (global_dll_map);\n\tglobal_dll_map = NULL;\n}\n\nstatic GHashTable *global_module_map;\n\nstatic MonoDl*\ncached_module_load (const char *name, int flags, char **err)\n{\n\tMonoDl *res;\n\n\tif (err)\n\t\t*err = NULL;\n\tmono_loader_lock ();\n\tif (!global_module_map)\n\t\tglobal_module_map = g_hash_table_new (g_str_hash, g_str_equal);\n\tres = g_hash_table_lookup (global_module_map, name);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\tres = mono_dl_open (name, flags, NULL);\n\tif (res)\n\t\tg_hash_table_insert (global_module_map, g_strdup (name), res);\n\tmono_loader_unlock ();\n\treturn res;\n}\n\ngpointer\nmono_lookup_pinvoke_call (MonoMethod *method, const char **exc_class, const char **exc_arg)\n{\n\tMonoImage *image = method->klass->image;\n\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)method;\n\tMonoTableInfo *tables = image->tables;\n\tMonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];\n\tMonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];\n\tguint32 im_cols [MONO_IMPLMAP_SIZE];\n\tguint32 scope_token;\n\tconst char *import = NULL;\n\tconst char *orig_scope;\n\tconst char *new_scope;\n\tchar *error_msg;\n\tchar *full_name, *file_name;\n\tint i;\n\tMonoDl *module = NULL;\n\n\tg_assert (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL);\n\n\tif (piinfo->addr)\n\t\treturn piinfo->addr;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (!method_aux)\n\t\t\treturn NULL;\n\n\t\timport = method_aux->dllentry;\n\t\torig_scope = method_aux->dll;\n\t}\n\telse {\n\t\tif (!piinfo->implmap_idx)\n\t\t\treturn NULL;\n\n\t\tmono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);\n\n\t\tpiinfo->piflags = im_cols [MONO_IMPLMAP_FLAGS];\n\t\timport = mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]);\n\t\tscope_token = mono_metadata_decode_row_col (mr, im_cols [MONO_IMPLMAP_SCOPE] - 1, MONO_MODULEREF_NAME);\n\t\torig_scope = mono_metadata_string_heap (image, scope_token);\n\t}\n\n\tmono_dllmap_lookup (image, orig_scope, import, &new_scope, &import);\n\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\"DllImport attempting to load: '%s'.\", new_scope);\n\n\tif (exc_class) {\n\t\t*exc_class = NULL;\n\t\t*exc_arg = NULL;\n\t}\n\n\t/* we allow a special name to dlopen from the running process namespace */\n\tif (strcmp (new_scope, \"__Internal\") == 0)\n\t\tmodule = mono_dl_open (NULL, MONO_DL_LAZY, &error_msg);\n\n\t/*\n\t * Try loading the module using a variety of names\n\t */\n\tfor (i = 0; i < 4; ++i) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\t/* Try the original name */\n\t\t\tfile_name = g_strdup (new_scope);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* Try trimming the .dll extension */\n\t\t\tif (strstr (new_scope, \".dll\") == (new_scope + strlen (new_scope) - 4)) {\n\t\t\t\tfile_name = g_strdup (new_scope);\n\t\t\t\tfile_name [strlen (new_scope) - 4] = '\\0';\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (strstr (new_scope, \"lib\") != new_scope) {\n\t\t\t\tfile_name = g_strdup_printf (\"lib%s\", new_scope);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n#ifndef TARGET_WIN32\n\t\t\tif (!g_ascii_strcasecmp (\"user32.dll\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"kernel32.dll\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"user32\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"kernel\", new_scope)) {\n\t\t\t\tfile_name = g_strdup (\"libMonoSupportW.so\");\n\t\t\t} else\n#endif\n\t\t\t\t    continue;\n#ifndef TARGET_WIN32\n\t\t\tbreak;\n#endif\n\t\t}\n\n\t\tif (!module) {\n\t\t\tvoid *iter = NULL;\n\t\t\tchar *mdirname = g_path_get_dirname (image->name);\n\t\t\twhile ((full_name = mono_dl_build_path (mdirname, file_name, &iter))) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport loading library: '%s'.\", full_name);\n\t\t\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\t\t\tif (!module) {\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s'.\",\n\t\t\t\t\t\terror_msg);\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t}\n\t\t\t\tg_free (full_name);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg_free (mdirname);\n\t\t}\n\n\t\tif (!module) {\n\t\t\tvoid *iter = NULL;\n\t\t\twhile ((full_name = mono_dl_build_path (NULL, file_name, &iter))) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport loading location: '%s'.\", full_name);\n\t\t\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\t\t\tif (!module) {\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\"DllImport error loading library: '%s'.\",\n\t\t\t\t\t\t\terror_msg);\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t}\n\t\t\t\tg_free (full_name);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!module) {\n\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport loading: '%s'.\", file_name);\n\t\t\tmodule = cached_module_load (file_name, MONO_DL_LAZY, &error_msg);\n\t\t\tif (!module) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s'.\",\n\t\t\t\t\t\terror_msg);\n\t\t\t}\n\t\t}\n\n\t\tg_free (file_name);\n\n\t\tif (module)\n\t\t\tbreak;\n\t}\n\n\tif (!module) {\n\t\tmono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"DllImport unable to load library '%s'.\",\n\t\t\t\terror_msg);\n\t\tg_free (error_msg);\n\n\t\tif (exc_class) {\n\t\t\t*exc_class = \"DllNotFoundException\";\n\t\t\t*exc_arg = new_scope;\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef TARGET_WIN32\n\tif (import && import [0] == '#' && isdigit (import [1])) {\n\t\tchar *end;\n\t\tlong id;\n\n\t\tid = strtol (import + 1, &end, 10);\n\t\tif (id > 0 && *end == '\\0')\n\t\t\timport++;\n\t}\n#endif\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"Searching for '%s'.\", import);\n\n\tif (piinfo->piflags & PINVOKE_ATTRIBUTE_NO_MANGLE) {\n\t\terror_msg = mono_dl_symbol (module, import, &piinfo->addr); \n\t} else {\n\t\tchar *mangled_name = NULL, *mangled_name2 = NULL;\n\t\tint mangle_charset;\n\t\tint mangle_stdcall;\n\t\tint mangle_param_count;\n#ifdef TARGET_WIN32\n\t\tint param_count;\n#endif\n\n\t\t/*\n\t\t * Search using a variety of mangled names\n\t\t */\n\t\tfor (mangle_charset = 0; mangle_charset <= 1; mangle_charset ++) {\n\t\t\tfor (mangle_stdcall = 0; mangle_stdcall <= 1; mangle_stdcall ++) {\n\t\t\t\tgboolean need_param_count = FALSE;\n#ifdef TARGET_WIN32\n\t\t\t\tif (mangle_stdcall > 0)\n\t\t\t\t\tneed_param_count = TRUE;\n#endif\n\t\t\t\tfor (mangle_param_count = 0; mangle_param_count <= (need_param_count ? 256 : 0); mangle_param_count += 4) {\n\n\t\t\t\t\tif (piinfo->addr)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tmangled_name = (char*)import;\n\t\t\t\t\tswitch (piinfo->piflags & PINVOKE_ATTRIBUTE_CHAR_SET_MASK) {\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_UNICODE:\n\t\t\t\t\t\t/* Try the mangled name first */\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_AUTO:\n#ifdef TARGET_WIN32\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", NULL);\n#else\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", NULL);\n#endif\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_ANSI:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n#ifdef TARGET_WIN32\n\t\t\t\t\tif (mangle_param_count == 0)\n\t\t\t\t\t\tparam_count = mono_method_signature (method)->param_count * sizeof (gpointer);\n\t\t\t\t\telse\n\t\t\t\t\t\t/* Try brute force, since it would be very hard to compute the stack usage correctly */\n\t\t\t\t\t\tparam_count = mangle_param_count;\n\n\t\t\t\t\t/* Try the stdcall mangled name */\n\t\t\t\t\t/* \n\t\t\t\t\t * gcc under windows creates mangled names without the underscore, but MS.NET\n\t\t\t\t\t * doesn't support it, so we doesn't support it either.\n\t\t\t\t\t */\n\t\t\t\t\tif (mangle_stdcall == 1)\n\t\t\t\t\t\tmangled_name2 = g_strdup_printf (\"_%s@%d\", mangled_name, param_count);\n\t\t\t\t\telse\n\t\t\t\t\t\tmangled_name2 = mangled_name;\n#else\n\t\t\t\t\tmangled_name2 = mangled_name;\n#endif\n\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\"Probing '%s'.\", mangled_name2);\n\n\t\t\t\t\terror_msg = mono_dl_symbol (module, mangled_name2, &piinfo->addr);\n\n\t\t\t\t\tif (piinfo->addr)\n\t\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\t\"Found as '%s'.\", mangled_name2);\n\n\t\t\t\t\tif (mangled_name != mangled_name2)\n\t\t\t\t\t\tg_free (mangled_name2);\n\t\t\t\t\tif (mangled_name != import)\n\t\t\t\t\t\tg_free (mangled_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!piinfo->addr) {\n\t\tg_free (error_msg);\n\t\tif (exc_class) {\n\t\t\t*exc_class = \"EntryPointNotFoundException\";\n\t\t\t*exc_arg = import;\n\t\t}\n\t\treturn NULL;\n\t}\n\treturn piinfo->addr;\n}\n\n/*\n * LOCKING: assumes the loader lock to be taken.\n */\nstatic MonoMethod *\nmono_get_method_from_token (MonoImage *image, guint32 token, MonoClass *klass,\n\t\t\t    MonoGenericContext *context, gboolean *used_context)\n{\n\tMonoMethod *result;\n\tint table = mono_metadata_token_table (token);\n\tint idx = mono_metadata_token_index (token);\n\tMonoTableInfo *tables = image->tables;\n\tMonoGenericContainer *generic_container = NULL, *container = NULL;\n\tconst char *sig = NULL;\n\tint size;\n\tguint32 cols [MONO_TYPEDEF_SIZE];\n\n\tif (image->dynamic) {\n\t\tMonoClass *handle_class;\n\n\t\tresult = mono_lookup_dynamic_token_class (image, token, TRUE, &handle_class, context);\n\t\t// This checks the memberref type as well\n\t\tif (result && handle_class != mono_defaults.methodhandle_class) {\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad method token 0x%08x on image %s.\", token, image->name));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn result;\n\t}\n\n\tif (table != MONO_TABLE_METHOD) {\n\t\tif (table == MONO_TABLE_METHODSPEC) {\n\t\t\tif (used_context) *used_context = TRUE;\n\t\t\treturn method_from_methodspec (image, context, idx);\n\t\t}\n\t\tif (table != MONO_TABLE_MEMBERREF) {\n\t\t\tg_warning (\"got wrong token: 0x%08x\\n\", token);\n\t\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad method token 0x%08x on image %s.\", token, image->name));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn method_from_memberref (image, idx, context, used_context);\n\t}\n\n\tif (used_context) *used_context = FALSE;\n\n\tif (idx > image->tables [MONO_TABLE_METHOD].rows) {\n\t\tmono_loader_set_error_bad_image (g_strdup_printf (\"Bad method token 0x%08x on image %s.\", token, image->name));\n\t\treturn NULL;\n\t}\n\n\tmono_metadata_decode_row (&image->tables [MONO_TABLE_METHOD], idx - 1, cols, 6);\n\n\tif ((cols [2] & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t    (cols [1] & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL))\n\t\tresult = (MonoMethod *)mono_image_alloc0 (image, sizeof (MonoMethodPInvoke));\n\telse\n\t\tresult = (MonoMethod *)mono_image_alloc0 (image, sizeof (MonoMethod));\n\n\tmono_stats.method_count ++;\n\n\tif (!klass) { /*FIXME put this before the image alloc*/\n\t\tguint32 type = mono_metadata_typedef_from_method (image, token);\n\t\tif (!type)\n\t\t\treturn NULL;\n\t\tklass = mono_class_get (image, MONO_TOKEN_TYPE_DEF | type);\n\t\tif (klass == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tresult->slot = -1;\n\tresult->klass = klass;\n\tresult->flags = cols [2];\n\tresult->iflags = cols [1];\n\tresult->token = token;\n\tresult->name = mono_metadata_string_heap (image, cols [3]);\n\n\tif (!sig) /* already taken from the methodref */\n\t\tsig = mono_metadata_blob_heap (image, cols [4]);\n\tsize = mono_metadata_decode_blob_size (sig, &sig);\n\n\tcontainer = klass->generic_container;\n\n\t/* \n\t * load_generic_params does a binary search so only call it if the method \n\t * is generic.\n\t */\n\tif (*sig & 0x10)\n\t\tgeneric_container = mono_metadata_load_generic_params (image, token, container);\n\tif (generic_container) {\n\t\tresult->is_generic = TRUE;\n\t\tgeneric_container->owner.method = result;\n\t\t/*FIXME put this before the image alloc*/\n\t\tif (!mono_metadata_load_generic_param_constraints_full (image, token, generic_container))\n\t\t\treturn NULL;\n\n\t\tcontainer = generic_container;\n\t}\n\n\tif (cols [1] & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\tif (result->klass == mono_defaults.string_class && !strcmp (result->name, \".ctor\"))\n\t\t\tresult->string_ctor = 1;\n\t} else if (cols [2] & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)result;\n\n#ifdef TARGET_WIN32\n\t\t/* IJW is P/Invoke with a predefined function pointer. */\n\t\tif (image->is_module_handle && (cols [1] & METHOD_IMPL_ATTRIBUTE_NATIVE)) {\n\t\t\tpiinfo->addr = mono_image_rva_map (image, cols [0]);\n\t\t\tg_assert (piinfo->addr);\n\t\t}\n#endif\n\t\tpiinfo->implmap_idx = mono_metadata_implmap_from_method (image, idx - 1);\n\t\t/* Native methods can have no map. */\n\t\tif (piinfo->implmap_idx)\n\t\t\tpiinfo->piflags = mono_metadata_decode_row_col (&tables [MONO_TABLE_IMPLMAP], piinfo->implmap_idx - 1, MONO_IMPLMAP_FLAGS);\n\t}\n\n \tif (generic_container)\n \t\tmono_method_set_generic_container (result, generic_container);\n\n\treturn result;\n}\n\nMonoMethod *\nmono_get_method (MonoImage *image, guint32 token, MonoClass *klass)\n{\n\treturn mono_get_method_full (image, token, klass, NULL);\n}\n\nMonoMethod *\nmono_get_method_full (MonoImage *image, guint32 token, MonoClass *klass,\n\t\t      MonoGenericContext *context)\n{\n\tMonoMethod *result;\n\tgboolean used_context = FALSE;\n\n\t/* We do everything inside the lock to prevent creation races */\n\n\tmono_image_lock (image);\n\n\tif (mono_metadata_token_table (token) == MONO_TABLE_METHOD) {\n\t\tif (!image->method_cache)\n\t\t\timage->method_cache = g_hash_table_new (NULL, NULL);\n\t\tresult = g_hash_table_lookup (image->method_cache, GINT_TO_POINTER (mono_metadata_token_index (token)));\n\t} else {\n\t\tif (!image->methodref_cache)\n\t\t\timage->methodref_cache = g_hash_table_new (NULL, NULL);\n\t\tresult = g_hash_table_lookup (image->methodref_cache, GINT_TO_POINTER (token));\n\t}\n\tmono_image_unlock (image);\n\n\tif (result)\n\t\treturn result;\n\n\tresult = mono_get_method_from_token (image, token, klass, context, &used_context);\n\tif (!result)\n\t\treturn NULL;\n\n\tmono_image_lock (image);\n\tif (!used_context && !result->is_inflated) {\n\t\tMonoMethod *result2;\n\t\tif (mono_metadata_token_table (token) == MONO_TABLE_METHOD)\n\t\t\tresult2 = g_hash_table_lookup (image->method_cache, GINT_TO_POINTER (mono_metadata_token_index (token)));\n\t\telse\n\t\t\tresult2 = g_hash_table_lookup (image->methodref_cache, GINT_TO_POINTER (token));\n\n\t\tif (result2) {\n\t\t\tmono_image_unlock (image);\n\t\t\treturn result2;\n\t\t}\n\n\t\tif (mono_metadata_token_table (token) == MONO_TABLE_METHOD)\n\t\t\tg_hash_table_insert (image->method_cache, GINT_TO_POINTER (mono_metadata_token_index (token)), result);\n\t\telse\n\t\t\tg_hash_table_insert (image->methodref_cache, GINT_TO_POINTER (token), result);\n\t}\n\n\tmono_image_unlock (image);\n\n\treturn result;\n}\n\n/**\n * mono_get_method_constrained:\n *\n * This is used when JITing the `constrained.' opcode.\n *\n * This returns two values: the contrained method, which has been inflated\n * as the function return value;   And the original CIL-stream method as\n * declared in cil_method.  The later is used for verification.\n */\nMonoMethod *\nmono_get_method_constrained (MonoImage *image, guint32 token, MonoClass *constrained_class,\n\t\t\t     MonoGenericContext *context, MonoMethod **cil_method)\n{\n\tMonoMethod *method, *result;\n\tMonoClass *ic = NULL;\n\tMonoGenericContext *method_context = NULL;\n\tMonoMethodSignature *sig, *original_sig;\n\n\tmono_loader_lock ();\n\n\t*cil_method = mono_get_method_from_token (image, token, NULL, context, NULL);\n\tif (!*cil_method) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tmono_class_init (constrained_class);\n\tmethod = *cil_method;\n\toriginal_sig = sig = mono_method_signature (method);\n\tif (sig == NULL) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tif (method->is_inflated && sig->generic_param_count) {\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated *) method;\n\t\tsig = mono_method_signature (imethod->declaring); /*We assume that if the inflated method signature is valid, the declaring method is too*/\n\t\tmethod_context = mono_method_get_context (method);\n\n\t\toriginal_sig = sig;\n\t\t/*\n\t\t * We must inflate the signature with the class instantiation to work on\n\t\t * cases where a class inherit from a generic type and the override replaces\n\t\t * any type argument which a concrete type. See #325283.\n\t\t */\n\t\tif (method_context->class_inst) {\n\t\t\tMonoError error;\n\t\t\tMonoGenericContext ctx;\n\t\t\tctx.method_inst = NULL;\n\t\t\tctx.class_inst = method_context->class_inst;\n\t\t\t/*Fixme, property propagate this error*/\n\t\t\tsig = inflate_generic_signature_checked (method->klass->image, sig, &ctx, &error);\n\t\t\tif (!mono_error_ok (&error)) {\n\t\t\t\tmono_loader_unlock ();\n\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((constrained_class != method->klass) && (MONO_CLASS_IS_INTERFACE (method->klass)))\n\t\tic = method->klass;\n\n\tresult = find_method (constrained_class, ic, method->name, sig, constrained_class);\n\tif (sig != original_sig)\n\t\tmono_metadata_free_inflated_signature (sig);\n\n\tif (!result) {\n\t\tg_warning (\"Missing method %s.%s.%s in assembly %s token %x\", method->klass->name_space,\n\t\t\t   method->klass->name, method->name, image->name, token);\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tif (method_context)\n\t\tresult = mono_class_inflate_generic_method (result, method_context);\n\n\tmono_loader_unlock ();\n\treturn result;\n}\n\nvoid\nmono_free_method  (MonoMethod *method)\n{\n\tif (mono_profiler_get_events () & MONO_PROFILE_METHOD_EVENTS)\n\t\tmono_profiler_method_free (method);\n\t\n\t/* FIXME: This hack will go away when the profiler will support freeing methods */\n\tif (mono_profiler_get_events () != MONO_PROFILE_NONE)\n\t\treturn;\n\t\n\tif (method->signature) {\n\t\t/* \n\t\t * FIXME: This causes crashes because the types inside signatures and\n\t\t * locals are shared.\n\t\t */\n\t\t/* mono_metadata_free_method_signature (method->signature); */\n\t\t/* g_free (method->signature); */\n\t}\n\t\n\tif (method->dynamic) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper*)method;\n\t\tint i;\n\n\t\tmono_marshal_free_dynamic_wrappers (method);\n\n\t\tmono_image_property_remove (method->klass->image, method);\n\n\t\tg_free ((char*)method->name);\n\t\tif (mw->header) {\n\t\t\tg_free ((char*)mw->header->code);\n\t\t\tfor (i = 0; i < mw->header->num_locals; ++i)\n\t\t\t\tg_free (mw->header->locals [i]);\n\t\t\tg_free (mw->header->clauses);\n\t\t\tg_free (mw->header);\n\t\t}\n\t\tg_free (mw->method_data);\n\t\tg_free (method->signature);\n\t\tg_free (method);\n\t}\n}\n\nvoid\nmono_method_get_param_names (MonoMethod *method, const char **names)\n{\n\tint i, lastp;\n\tMonoClass *klass;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\tMonoMethodSignature *signature;\n\tguint32 idx;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tsignature = mono_method_signature (method);\n\t/*FIXME this check is somewhat redundant since the caller usally will have to get the signature to figure out the\n\t  number of arguments and allocate a properly sized array. */\n\tif (signature == NULL)\n\t\treturn;\n\n\tif (!signature->param_count)\n\t\treturn;\n\n\tfor (i = 0; i < signature->param_count; ++i)\n\t\tnames [i] = \"\";\n\n\tklass = method->klass;\n\tif (klass->rank)\n\t\treturn;\n\n\tmono_class_init (klass);\n\n\tif (klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (method_aux && method_aux->param_names) {\n\t\t\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i)\n\t\t\t\tif (method_aux->param_names [i + 1])\n\t\t\t\t\tnames [i] = method_aux->param_names [i + 1];\n\t\t}\n\t\treturn;\n\t}\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint32 cols [MONO_PARAM_SIZE];\n\t\tguint param_index;\n\n\t\tparam_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (idx < methodt->rows)\n\t\t\tlastp = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\t\telse\n\t\t\tlastp = paramt->rows + 1;\n\t\tfor (i = param_index; i < lastp; ++i) {\n\t\t\tmono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);\n\t\t\tif (cols [MONO_PARAM_SEQUENCE] && cols [MONO_PARAM_SEQUENCE] <= signature->param_count) /* skip return param spec and bounds check*/\n\t\t\t\tnames [cols [MONO_PARAM_SEQUENCE] - 1] = mono_metadata_string_heap (klass->image, cols [MONO_PARAM_NAME]);\n\t\t}\n\t}\n}\n\nguint32\nmono_method_get_param_token (MonoMethod *method, int index)\n{\n\tMonoClass *klass = method->klass;\n\tMonoTableInfo *methodt;\n\tguint32 idx;\n\n\tmono_class_init (klass);\n\n\tif (klass->image->dynamic) {\n\t\tg_assert_not_reached ();\n\t}\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint param_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (index == -1)\n\t\t\t/* Return value */\n\t\t\treturn mono_metadata_make_token (MONO_TABLE_PARAM, 0);\n\t\telse\n\t\t\treturn mono_metadata_make_token (MONO_TABLE_PARAM, param_index + index);\n\t}\n\n\treturn 0;\n}\n\nvoid\nmono_method_get_marshal_info (MonoMethod *method, MonoMarshalSpec **mspecs)\n{\n\tint i, lastp;\n\tMonoClass *klass = method->klass;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\tMonoMethodSignature *signature;\n\tguint32 idx;\n\n\tsignature = mono_method_signature (method);\n\tg_assert (signature); /*FIXME there is no way to signal error from this function*/\n\n\tfor (i = 0; i < signature->param_count + 1; ++i)\n\t\tmspecs [i] = NULL;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (method_aux && method_aux->param_marshall) {\n\t\t\tMonoMarshalSpec **dyn_specs = method_aux->param_marshall;\n\t\t\tfor (i = 0; i < signature->param_count + 1; ++i)\n\t\t\t\tif (dyn_specs [i]) {\n\t\t\t\t\tmspecs [i] = g_new0 (MonoMarshalSpec, 1);\n\t\t\t\t\tmemcpy (mspecs [i], dyn_specs [i], sizeof (MonoMarshalSpec));\n\t\t\t\t\tmspecs [i]->data.custom_data.custom_name = g_strdup (dyn_specs [i]->data.custom_data.custom_name);\n\t\t\t\t\tmspecs [i]->data.custom_data.cookie = g_strdup (dyn_specs [i]->data.custom_data.cookie);\n\t\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tmono_class_init (klass);\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint32 cols [MONO_PARAM_SIZE];\n\t\tguint param_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (idx < methodt->rows)\n\t\t\tlastp = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\t\telse\n\t\t\tlastp = paramt->rows + 1;\n\n\t\tfor (i = param_index; i < lastp; ++i) {\n\t\t\tmono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);\n\n\t\t\tif (cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_FIELD_MARSHAL && cols [MONO_PARAM_SEQUENCE] <= signature->param_count) {\n\t\t\t\tconst char *tp;\n\t\t\t\ttp = mono_metadata_get_marshal_info (klass->image, i - 1, FALSE);\n\t\t\t\tg_assert (tp);\n\t\t\t\tmspecs [cols [MONO_PARAM_SEQUENCE]]= mono_metadata_parse_marshal_spec (klass->image, tp);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n}\n\ngboolean\nmono_method_has_marshal_info (MonoMethod *method)\n{\n\tint i, lastp;\n\tMonoClass *klass = method->klass;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\tguint32 idx;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tMonoMarshalSpec **dyn_specs = method_aux->param_marshall;\n\t\tif (dyn_specs) {\n\t\t\tfor (i = 0; i < mono_method_signature (method)->param_count + 1; ++i)\n\t\t\t\tif (dyn_specs [i])\n\t\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tmono_class_init (klass);\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint32 cols [MONO_PARAM_SIZE];\n\t\tguint param_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (idx + 1 < methodt->rows)\n\t\t\tlastp = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\t\telse\n\t\t\tlastp = paramt->rows + 1;\n\n\t\tfor (i = param_index; i < lastp; ++i) {\n\t\t\tmono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);\n\n\t\t\tif (cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_FIELD_MARSHAL)\n\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn FALSE;\n}\n\ngpointer\nmono_method_get_wrapper_data (MonoMethod *method, guint32 id)\n{\n\tvoid **data;\n\tg_assert (method != NULL);\n\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\tdata = ((MonoMethodWrapper *)method)->method_data;\n\tg_assert (data != NULL);\n\tg_assert (id <= GPOINTER_TO_UINT (*data));\n\treturn data [id];\n}\n\nstatic void\ndefault_stack_walk (MonoStackWalk func, gboolean do_il_offset, gpointer user_data) {\n\tg_error (\"stack walk not installed\");\n}\n\nstatic MonoStackWalkImpl stack_walk = default_stack_walk;\n\nvoid\nmono_stack_walk (MonoStackWalk func, gpointer user_data)\n{\n\tstack_walk (func, TRUE, user_data);\n}\n\nvoid\nmono_stack_walk_no_il (MonoStackWalk func, gpointer user_data)\n{\n\tstack_walk (func, FALSE, user_data);\n}\n\nvoid\nmono_install_stack_walk (MonoStackWalkImpl func)\n{\n\tstack_walk = func;\n}\n\nstatic gboolean\nlast_managed (MonoMethod *m, gint no, gint ilo, gboolean managed, gpointer data)\n{\n\tMonoMethod **dest = data;\n\t*dest = m;\n\t/*g_print (\"In %s::%s [%d] [%d]\\n\", m->klass->name, m->name, no, ilo);*/\n\n\treturn managed;\n}\n\nMonoMethod*\nmono_method_get_last_managed (void)\n{\n\tMonoMethod *m = NULL;\n\tstack_walk (last_managed, FALSE, &m);\n\treturn m;\n}\n\nstatic gboolean loader_lock_track_ownership = FALSE;\n\n/**\n * mono_loader_lock:\n *\n * See docs/thread-safety.txt for the locking strategy.\n */\nvoid\nmono_loader_lock (void)\n{\n\tmono_locks_acquire (&loader_mutex, LoaderLock);\n\tif (G_UNLIKELY (loader_lock_track_ownership)) {\n\t\tTlsSetValue (loader_lock_nest_id, GUINT_TO_POINTER (GPOINTER_TO_UINT (TlsGetValue (loader_lock_nest_id)) + 1));\n\t}\n}\n\nvoid\nmono_loader_unlock (void)\n{\n\tmono_locks_release (&loader_mutex, LoaderLock);\n\tif (G_UNLIKELY (loader_lock_track_ownership)) {\n\t\tTlsSetValue (loader_lock_nest_id, GUINT_TO_POINTER (GPOINTER_TO_UINT (TlsGetValue (loader_lock_nest_id)) - 1));\n\t}\n}\n\n/*\n * mono_loader_lock_track_ownership:\n *\n *   Set whenever the runtime should track ownership of the loader lock. If set to TRUE,\n * the mono_loader_lock_is_owned_by_self () can be called to query whenever the current\n * thread owns the loader lock. \n */\nvoid\nmono_loader_lock_track_ownership (gboolean track)\n{\n\tloader_lock_track_ownership = track;\n}\n\n/*\n * mono_loader_lock_is_owned_by_self:\n *\n *   Return whenever the current thread owns the loader lock.\n * This is useful to avoid blocking operations while holding the loader lock.\n */\ngboolean\nmono_loader_lock_is_owned_by_self (void)\n{\n\tg_assert (loader_lock_track_ownership);\n\n\treturn GPOINTER_TO_UINT (TlsGetValue (loader_lock_nest_id)) > 0;\n}\n\n/*\n * mono_loader_lock_if_inited:\n *\n *   Acquire the loader lock if it has been initialized, no-op otherwise. This can\n * be used in runtime initialization code which can be executed before mono_loader_init ().\n */\nvoid\nmono_loader_lock_if_inited (void)\n{\n\tif (loader_lock_inited)\n\t\tmono_loader_lock ();\n}\n\nvoid\nmono_loader_unlock_if_inited (void)\n{\n\tif (loader_lock_inited)\n\t\tmono_loader_unlock ();\n}\n\n/**\n * mono_method_signature:\n *\n * Return the signature of the method M. On failure, returns NULL, and ERR is set.\n */\nMonoMethodSignature*\nmono_method_signature_checked (MonoMethod *m, MonoError *error)\n{\n\tint idx;\n\tint size;\n\tMonoImage* img;\n\tconst char *sig;\n\tgboolean can_cache_signature;\n\tMonoGenericContainer *container;\n\tMonoMethodSignature *signature = NULL;\n\tguint32 sig_offset;\n\n\t/* We need memory barriers below because of the double-checked locking pattern */ \n\n\tmono_error_init (error);\n\n\tif (m->signature)\n\t\treturn m->signature;\n\n\tmono_loader_lock ();\n\n\tif (m->signature) {\n\t\tmono_loader_unlock ();\n\t\treturn m->signature;\n\t}\n\n\tif (m->is_inflated) {\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated *) m;\n\t\t/* the lock is recursive */\n\t\tsignature = mono_method_signature (imethod->declaring);\n\t\tsignature = inflate_generic_signature_checked (imethod->declaring->klass->image, signature, mono_method_get_context (m), error);\n\t\tif (!mono_error_ok (error)) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn NULL;\n\t\t}\n\n\t\tinflated_signatures_size += mono_metadata_signature_size (signature);\n\n\t\tmono_memory_barrier ();\n\t\tm->signature = signature;\n\t\tmono_loader_unlock ();\n\t\treturn m->signature;\n\t}\n\n\tg_assert (mono_metadata_token_table (m->token) == MONO_TABLE_METHOD);\n\tidx = mono_metadata_token_index (m->token);\n\timg = m->klass->image;\n\n\tsig = mono_metadata_blob_heap (img, sig_offset = mono_metadata_decode_row_col (&img->tables [MONO_TABLE_METHOD], idx - 1, MONO_METHOD_SIGNATURE));\n\n\tg_assert (!m->klass->generic_class);\n\tcontainer = mono_method_get_generic_container (m);\n\tif (!container)\n\t\tcontainer = m->klass->generic_container;\n\n\t/* Generic signatures depend on the container so they cannot be cached */\n\t/* icall/pinvoke signatures cannot be cached cause we modify them below */\n\tcan_cache_signature = !(m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) && !(m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) && !container;\n\n\t/* If the method has parameter attributes, that can modify the signature */\n\tif (mono_metadata_method_has_param_attrs (img, idx))\n\t\tcan_cache_signature = FALSE;\n\n\tif (can_cache_signature)\n\t\tsignature = g_hash_table_lookup (img->method_signatures, sig);\n\n\tif (!signature) {\n\t\tconst char *sig_body;\n\t\t/*TODO we should cache the failure result somewhere*/\n\t\tif (!mono_verifier_verify_method_signature (img, sig_offset, error)) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsize = mono_metadata_decode_blob_size (sig, &sig_body);\n\n\t\tsignature = mono_metadata_parse_method_signature_full (img, container, idx, sig_body, NULL);\n\t\tif (!signature) {\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_error_set_method_load (error, m->klass, m->name, \"\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (can_cache_signature)\n\t\t\tg_hash_table_insert (img->method_signatures, (gpointer)sig, signature);\n\t}\n\n\t/* Verify metadata consistency */\n\tif (signature->generic_param_count) {\n\t\tif (!container || !container->is_method) {\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_error_set_method_load (error, m->klass, m->name, \"Signature claims method has generic parameters, but generic_params table says it doesn't for method 0x%08x from image %s\", idx, img->name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (container->type_argc != signature->generic_param_count) {\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_error_set_method_load (error, m->klass, m->name, \"Inconsistent generic parameter count.  Signature says %d, generic_params table says %d for method 0x%08x from image %s\", signature->generic_param_count, container->type_argc, idx, img->name);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (container && container->is_method && container->type_argc) {\n\t\tmono_loader_unlock ();\n\t\tmono_error_set_method_load (error, m->klass, m->name, \"generic_params table claims method has generic parameters, but signature says it doesn't for method 0x%08x from image %s\", idx, img->name);\n\t\treturn NULL;\n\t}\n\tif (m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL)\n\t\tsignature->pinvoke = 1;\n\telse if (m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tMonoCallConvention conv = 0;\n\t\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)m;\n\t\tsignature->pinvoke = 1;\n\n\t\tswitch (piinfo->piflags & PINVOKE_ATTRIBUTE_CALL_CONV_MASK) {\n\t\tcase 0: /* no call conv, so using default */\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_WINAPI:\n\t\t\tconv = MONO_CALL_DEFAULT;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_CDECL:\n\t\t\tconv = MONO_CALL_C;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_STDCALL:\n\t\t\tconv = MONO_CALL_STDCALL;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_THISCALL:\n\t\t\tconv = MONO_CALL_THISCALL;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_FASTCALL:\n\t\t\tconv = MONO_CALL_FASTCALL;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_GENERIC:\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_GENERICINST:\n\t\tdefault:\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_error_set_method_load (error, m->klass, m->name, \"unsupported calling convention : 0x%04x for method 0x%08x from image %s\", piinfo->piflags, idx, img->name);\n\t\t\treturn NULL;\n\t\t}\n\t\tsignature->call_convention = conv;\n\t}\n\n\tmono_memory_barrier ();\n\tm->signature = signature;\n\n\tmono_loader_unlock ();\n\treturn m->signature;\n}\n\n/**\n * mono_method_signature:\n *\n * Return the signature of the method M. On failure, returns NULL.\n */\nMonoMethodSignature*\nmono_method_signature (MonoMethod *m)\n{\n\tMonoError error;\n\tMonoMethodSignature *sig;\n\n\tsig = mono_method_signature_checked (m, &error);\n\tif (!sig) {\n\t\tchar *type_name = mono_type_get_full_name (m->klass);\n\t\tg_warning (\"Could not load signature of %s:%s due to: %s\", type_name, m->name, mono_error_get_message (&error));\n\t\tg_free (type_name);\n\t\tmono_error_cleanup (&error);\n\t}\n\n\treturn sig;\n}\n\nconst char*\nmono_method_get_name (MonoMethod *method)\n{\n\treturn method->name;\n}\n\nMonoClass*\nmono_method_get_class (MonoMethod *method)\n{\n\treturn method->klass;\n}\n\nguint32\nmono_method_get_token (MonoMethod *method)\n{\n\treturn method->token;\n}\n\nMonoMethodHeader*\nmono_method_get_header (MonoMethod *method)\n{\n\tint idx;\n\tguint32 rva;\n\tMonoImage* img;\n\tgpointer loc;\n\tMonoMethodHeader *header;\n\n\tif ((method->flags & METHOD_ATTRIBUTE_ABSTRACT) || (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) || (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) || (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\treturn NULL;\n\n\tif (method->is_inflated) {\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated *) method;\n\t\tMonoMethodHeader *header;\n\n\t\tmono_loader_lock ();\n\n\t\tif (imethod->header) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn imethod->header;\n\t\t}\n\n\t\theader = mono_method_get_header (imethod->declaring);\n\t\tif (!header) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn NULL;\n\t\t}\n\n\t\timethod->header = inflate_generic_header (header, mono_method_get_context (method));\n\t\tmono_loader_unlock ();\n\t\tmono_metadata_free_mh (header);\n\t\treturn imethod->header;\n\t}\n\n\tif (method->wrapper_type != MONO_WRAPPER_NONE || method->sre_method) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper *)method;\n\t\tg_assert (mw->header);\n\t\treturn mw->header;\n\t}\n\n\t/* \n\t * We don't need locks here: the new header is allocated from malloc memory\n\t * and is not stored anywhere in the runtime, the user needs to free it.\n\t */\n\tg_assert (mono_metadata_token_table (method->token) == MONO_TABLE_METHOD);\n\tidx = mono_metadata_token_index (method->token);\n\timg = method->klass->image;\n\trva = mono_metadata_decode_row_col (&img->tables [MONO_TABLE_METHOD], idx - 1, MONO_METHOD_RVA);\n\n\tif (!mono_verifier_verify_method_header (img, rva, NULL))\n\t\treturn NULL;\n\n\tloc = mono_image_rva_map (img, rva);\n\tif (!loc)\n\t\treturn NULL;\n\n\theader = mono_metadata_parse_mh_full (img, mono_method_get_generic_container (method), loc);\n\n\treturn header;\n}\n\nguint32\nmono_method_get_flags (MonoMethod *method, guint32 *iflags)\n{\n\tif (iflags)\n\t\t*iflags = method->iflags;\n\treturn method->flags;\n}\n\n/*\n * Find the method index in the metadata methodDef table.\n */\nguint32\nmono_method_get_index (MonoMethod *method) {\n\tMonoClass *klass = method->klass;\n\tint i;\n\n\tif (klass->rank)\n\t\t/* constructed array methods are not in the MethodDef table */\n\t\treturn 0;\n\n\tif (method->token)\n\t\treturn mono_metadata_token_index (method->token);\n\n\tmono_class_setup_methods (klass);\n\tif (klass->exception_type)\n\t\treturn 0;\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tif (method == klass->methods [i]) {\n\t\t\tif (klass->image->uncompressed_metadata)\n\t\t\t\treturn mono_metadata_translate_token_index (klass->image, MONO_TABLE_METHOD, klass->method.first + i + 1);\n\t\t\telse\n\t\t\t\treturn klass->method.first + i + 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"], "filenames": ["mono/metadata/loader.c"], "buggy_code_start_loc": [1342], "buggy_code_end_loc": [1369], "fixing_code_start_loc": [1343], "fixing_code_end_loc": [1370], "type": "NVD-CWE-Other", "message": "Untrusted search path vulnerability in metadata/loader.c in Mono 2.8 and earlier allows local users to gain privileges via a Trojan horse shared library in the current working directory.", "other": {"cve": {"id": "CVE-2010-4159", "sourceIdentifier": "secalert@redhat.com", "published": "2010-11-17T16:00:36.687", "lastModified": "2010-12-09T08:36:26.980", "vulnStatus": "Modified", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/426.html\r\n\r\n'CWE-426: Untrusted Search Path'", "descriptions": [{"lang": "en", "value": "Untrusted search path vulnerability in metadata/loader.c in Mono 2.8 and earlier allows local users to gain privileges via a Trojan horse shared library in the current working directory."}, {"lang": "es", "value": "Vulnerabilidad de b\u00fasqueda de ruta no confiable en metadata/loader.c en Mono v2.8, permite a usuarios locales obtener privilegios a trav\u00e9s de un troyano de la biblioteca compartida en el directorio de trabajo actual."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.7", "matchCriteriaId": "9C76ECD3-F1FA-4783-8E0A-919EA4042D73"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "B31A3175-7CC6-4367-9A3C-F3324156C818"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "D3309DF2-A3A7-4016-95D9-ABB4230083FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "098D040B-CD80-41A6-A3DF-06C379BCABA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "293D8EF8-8A6B-4EBE-B145-C909ADBE32E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "DBB77289-2AED-4BD4-9578-FEB0EC83701E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "CA1D2C56-70EA-48F4-A3B3-1080DF8ABC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B7E03067-D1B7-427A-8800-A40DDAF466FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "23B3DD31-D316-422F-A3E4-9C7D85E0F26C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "42E75C91-A3D2-479B-9F3F-B97BC75A5B57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "A4299404-6C79-4B21-BB8C-115FA1E3AC28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "944E7E22-41CA-4E2D-B31A-E602B41C34A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "D9F638AC-EBDC-4886-B798-42D12557573A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "FE6384D7-7899-4D7F-B478-BDEDDA415054"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "D7DEAABB-265B-45B3-8A87-86EB5CCEAE5E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "3E1B76E4-C12D-4BC6-8745-1AB5C5F32B53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "919CAD10-2F17-4F94-8116-815E77F5E998"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "2F79FC32-28BB-44F7-AA6E-E15B24692483"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "C0546335-1EEF-4946-8B94-69F91697D511"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "2D24AC82-5BCE-4D9F-8DF1-24BE6C255553"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "F1A85E81-0778-46B1-A932-C14B6DC08A68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "82CA587E-7272-4C7C-90D3-D0CCBAA76348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.11:*:*:*:*:*:*:*", "matchCriteriaId": "30593717-0C0E-4F05-8690-4A47CA724C20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.12:*:*:*:*:*:*:*", "matchCriteriaId": "723D4817-BB5F-4D65-9258-B0E2992F2738"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "A986CA3E-05A4-4D42-86E4-A7AA3A20298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.13:*:*:*:*:*:*:*", "matchCriteriaId": "19877D33-5DBF-40D7-87CB-545558C64771"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.13.2:*:*:*:*:*:*:*", "matchCriteriaId": "29CFCD33-C188-409F-B07A-1F1A064894DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.13.4:*:*:*:*:*:*:*", "matchCriteriaId": "F64E7267-E010-4FC8-879A-448C85BC250B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.13.5:*:*:*:*:*:*:*", "matchCriteriaId": "DC4D32E8-B90B-432D-B6A3-5F9DDEECC206"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.13.6:*:*:*:*:*:*:*", "matchCriteriaId": "683F75A5-E4E4-4416-8E1C-A2C694A30BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.13.7:*:*:*:*:*:*:*", "matchCriteriaId": "EBE3CDD7-8553-4CB7-A0A7-B059B4D75B0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.13.8:*:*:*:*:*:*:*", "matchCriteriaId": "2E7AE533-E1E8-494F-BE86-0BFDF30AD3B1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.13.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "0BB26E71-AC67-4B9E-BDAE-835DA8C2C443"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.14:*:*:*:*:*:*:*", "matchCriteriaId": "C9252266-4293-49E3-9492-67F4AF80335B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.15:*:*:*:*:*:*:*", "matchCriteriaId": "2D22A05F-650E-484D-9F78-8C821EA103E0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.16:*:*:*:*:*:*:*", "matchCriteriaId": "0034178B-13CC-43A0-BBBA-988EC558DA5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.16.1:*:*:*:*:*:*:*", "matchCriteriaId": "5014D928-E0E3-4B75-B4B8-44D193446505"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.17:*:*:*:*:*:*:*", "matchCriteriaId": "DE2C11F2-2A21-481E-8350-F3777A0A8033"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.17.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFC21FA7-648F-4E41-962B-664140FA4812"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.17.2:*:*:*:*:*:*:*", "matchCriteriaId": "9788C5D4-ECD7-4F2E-BE0F-F4FFE626A3A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.1.18:*:*:*:*:*:*:*", "matchCriteriaId": "A9FF02E9-070C-4AAA-ABB7-26FC9E56C7A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "AA4FE4B4-7514-460F-AD14-40184115092A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "2AA11C84-3102-429E-951A-698CE023FDB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "F6003FD8-B371-44AE-B565-6205F68117A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "CE1FD98F-ED5D-4247-BC79-1FABC1684557"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "87E41880-769F-499E-AFB3-62B78AB765F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "2F5558CC-9D71-472C-B9B5-20481A333AC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "0895ECCA-B8B3-46BD-9ADE-258AAF205D90"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "3F3AB679-5630-4F0B-9DF7-D64AFA970D44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "EC72C972-FF09-4A5D-9AD4-A422EDADF5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "28E60798-6722-4B4F-B06E-7C1E1FDF92EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "66E14236-3F37-4047-A3EF-32E9923C35FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.9:*:*:*:*:*:*:*", "matchCriteriaId": "18C24C8F-0967-4C1B-8F19-696707C2064B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:1.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "0D28CEA5-CA8A-4830-A134-1589AD98B334"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4BB536F-79EB-42AF-B17B-49BE47CFC215"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE2CA7F0-C5ED-450D-BAEE-300E27AAD13D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.2:*:*:*:*:*:*:*", "matchCriteriaId": "A08F0EFF-9F4D-4DD3-BD55-71F34B70648B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.4:*:*:*:*:*:*:*", "matchCriteriaId": "A12EEE2B-E956-4889-9C55-F23968C17E7D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "3E59557D-42A7-4189-97DD-45F31DC1AB6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.4.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "EA6DFB1E-1DBD-459C-95FE-841253F4F6A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.4.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E95734E0-1349-4C3C-9557-ADEEA1014C38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.4.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "BFBAA1F5-522B-4357-B9E8-FC15053C75A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "B25BDA5E-E1AB-4C9A-A53B-B8863F2A2A40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.6:*:*:*:*:*:*:*", "matchCriteriaId": "BD925F27-45C0-4319-A199-433289742952"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "2E8C5613-87D1-415D-B918-3CF64C0C40F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:2.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "73F75B9D-3DC1-4994-AB23-D0435C222910"}]}]}], "references": [{"url": "http://lists.ximian.com/pipermail/mono-patches/2010-October/177900.html", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://marc.info/?l=oss-security&m=128939873515821&w=2", "source": "secalert@redhat.com"}, {"url": "http://marc.info/?l=oss-security&m=128939912716499&w=2", "source": "secalert@redhat.com"}, {"url": "http://marc.info/?l=oss-security&m=128941802415318&w=2", "source": "secalert@redhat.com"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2010:240", "source": "secalert@redhat.com"}, {"url": "http://www.mono-project.com/Vulnerabilities#Mono_Runtime_Insecure_Native_Library_Loading", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/44810", "source": "secalert@redhat.com"}, {"url": "http://www.vupen.com/english/advisories/2010/3059", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=641915", "source": "secalert@redhat.com"}, {"url": "https://github.com/mono/mono/commit/8e890a3bf80a4620e417814dc14886b1bbd17625", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/mono/mono/commit/8e890a3bf80a4620e417814dc14886b1bbd17625"}}