{"buggy_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/plugins/manager/installer\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nfunc (hs *HTTPServer) GetPluginList(c *models.ReqContext) response.Response {\n\ttypeFilter := c.Query(\"type\")\n\tenabledFilter := c.Query(\"enabled\")\n\tembeddedFilter := c.Query(\"embedded\")\n\tcoreFilter := c.Query(\"core\")\n\n\t// For users with viewer role we only return core plugins\n\tif !c.HasRole(models.ROLE_ADMIN) {\n\t\tcoreFilter = \"1\"\n\t}\n\n\tpluginSettingsMap, err := hs.pluginSettings(c.Req.Context(), c.OrgId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get list of plugins\", err)\n\t}\n\n\tresult := make(dtos.PluginList, 0)\n\tfor _, pluginDef := range hs.pluginStore.Plugins(c.Req.Context()) {\n\t\t// filter out app sub plugins\n\t\tif embeddedFilter == \"0\" && pluginDef.IncludedInAppID != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out core plugins\n\t\tif (coreFilter == \"0\" && pluginDef.IsCorePlugin()) || (coreFilter == \"1\" && !pluginDef.IsCorePlugin()) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter on type\n\t\tif typeFilter != \"\" && typeFilter != string(pluginDef.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif pluginDef.State == plugins.AlphaRelease && !hs.Cfg.PluginsEnableAlpha {\n\t\t\tcontinue\n\t\t}\n\n\t\tlistItem := dtos.PluginListItem{\n\t\t\tId:            pluginDef.ID,\n\t\t\tName:          pluginDef.Name,\n\t\t\tType:          string(pluginDef.Type),\n\t\t\tCategory:      pluginDef.Category,\n\t\t\tInfo:          pluginDef.Info,\n\t\t\tDependencies:  pluginDef.Dependencies,\n\t\t\tLatestVersion: pluginDef.GrafanaComVersion,\n\t\t\tHasUpdate:     pluginDef.GrafanaComHasUpdate,\n\t\t\tDefaultNavUrl: pluginDef.DefaultNavURL,\n\t\t\tState:         pluginDef.State,\n\t\t\tSignature:     pluginDef.Signature,\n\t\t\tSignatureType: pluginDef.SignatureType,\n\t\t\tSignatureOrg:  pluginDef.SignatureOrg,\n\t\t}\n\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tlistItem.Enabled = pluginSetting.Enabled\n\t\t\tlistItem.Pinned = pluginSetting.Pinned\n\t\t}\n\n\t\tif listItem.DefaultNavUrl == \"\" || !listItem.Enabled {\n\t\t\tlistItem.DefaultNavUrl = hs.Cfg.AppSubURL + \"/plugins/\" + listItem.Id + \"/\"\n\t\t}\n\n\t\t// filter out disabled plugins\n\t\tif enabledFilter == \"1\" && !listItem.Enabled {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out built in plugins\n\t\tif pluginDef.BuiltIn {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult = append(result, listItem)\n\t}\n\n\tsort.Sort(result)\n\treturn response.JSON(200, result)\n}\n\nfunc (hs *HTTPServer) GetPluginSettingByID(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found, no installed plugin with that id\", nil)\n\t}\n\n\tdto := &dtos.PluginSetting{\n\t\tType:          string(plugin.Type),\n\t\tId:            plugin.ID,\n\t\tName:          plugin.Name,\n\t\tInfo:          plugin.Info,\n\t\tDependencies:  plugin.Dependencies,\n\t\tIncludes:      plugin.Includes,\n\t\tBaseUrl:       plugin.BaseURL,\n\t\tModule:        plugin.Module,\n\t\tDefaultNavUrl: plugin.DefaultNavURL,\n\t\tLatestVersion: plugin.GrafanaComVersion,\n\t\tHasUpdate:     plugin.GrafanaComHasUpdate,\n\t\tState:         plugin.State,\n\t\tSignature:     plugin.Signature,\n\t\tSignatureType: plugin.SignatureType,\n\t\tSignatureOrg:  plugin.SignatureOrg,\n\t}\n\n\tif plugin.IsApp() {\n\t\tdto.Enabled = plugin.AutoEnabled\n\t\tdto.Pinned = plugin.AutoEnabled\n\t}\n\n\tquery := models.GetPluginSettingByIdQuery{PluginId: pluginID, OrgId: c.OrgId}\n\tif err := bus.DispatchCtx(c.Req.Context(), &query); err != nil {\n\t\tif !errors.Is(err, models.ErrPluginSettingNotFound) {\n\t\t\treturn response.Error(500, \"Failed to get login settings\", nil)\n\t\t}\n\t} else {\n\t\tdto.Enabled = query.Result.Enabled\n\t\tdto.Pinned = query.Result.Pinned\n\t\tdto.JsonData = query.Result.JsonData\n\t}\n\n\treturn response.JSON(200, dto)\n}\n\nfunc (hs *HTTPServer) UpdatePluginSetting(c *models.ReqContext) response.Response {\n\tcmd := models.UpdatePluginSettingCmd{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tif _, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID); !exists {\n\t\treturn response.Error(404, \"Plugin not installed\", nil)\n\t}\n\n\tcmd.OrgId = c.OrgId\n\tcmd.PluginId = pluginID\n\tif err := bus.DispatchCtx(c.Req.Context(), &cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to update plugin setting\", err)\n\t}\n\n\treturn response.Success(\"Plugin settings updated\")\n}\n\nfunc (hs *HTTPServer) GetPluginDashboards(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tlist, err := hs.pluginDashboardManager.GetPluginDashboards(c.Req.Context(), c.OrgId, pluginID)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Failed to get plugin dashboards\", err)\n\t}\n\n\treturn response.JSON(200, list)\n}\n\nfunc (hs *HTTPServer) GetPluginMarkdown(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tname := web.Params(c.Req)[\":name\"]\n\n\tcontent, err := hs.pluginMarkdown(c.Req.Context(), pluginID, name)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Could not get markdown file\", err)\n\t}\n\n\t// fallback try readme\n\tif len(content) == 0 {\n\t\tcontent, err = hs.pluginMarkdown(c.Req.Context(), pluginID, \"readme\")\n\t\tif err != nil {\n\t\t\treturn response.Error(501, \"Could not get markdown file\", err)\n\t\t}\n\t}\n\n\tresp := response.Respond(200, content)\n\tresp.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n\treturn resp\n}\n\nfunc (hs *HTTPServer) ImportDashboard(c *models.ReqContext) response.Response {\n\tapiCmd := dtos.ImportDashboardCommand{}\n\tif err := web.Bind(c.Req, &apiCmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tvar err error\n\tif apiCmd.PluginId == \"\" && apiCmd.Dashboard == nil {\n\t\treturn response.Error(422, \"Dashboard must be set\", nil)\n\t}\n\n\tlimitReached, err := hs.QuotaService.QuotaReached(c, \"dashboard\")\n\tif err != nil {\n\t\treturn response.Error(500, \"failed to get quota\", err)\n\t}\n\tif limitReached {\n\t\treturn response.Error(403, \"Quota reached\", nil)\n\t}\n\n\ttrimDefaults := c.QueryBoolWithDefault(\"trimdefaults\", true)\n\tif trimDefaults && !hs.LoadSchemaService.IsDisabled() {\n\t\tapiCmd.Dashboard, err = hs.LoadSchemaService.DashboardApplyDefaults(apiCmd.Dashboard)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Error while applying default value to the dashboard json\", err)\n\t\t}\n\t}\n\n\tdashInfo, dash, err := hs.pluginDashboardManager.ImportDashboard(c.Req.Context(), apiCmd.PluginId, apiCmd.Path, c.OrgId, apiCmd.FolderId,\n\t\tapiCmd.Dashboard, apiCmd.Overwrite, apiCmd.Inputs, c.SignedInUser)\n\tif err != nil {\n\t\treturn hs.dashboardSaveErrorToApiResponse(c.Req.Context(), err)\n\t}\n\n\terr = hs.LibraryPanelService.ImportLibraryPanelsForDashboard(c.Req.Context(), c.SignedInUser, dash, apiCmd.FolderId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while importing library panels\", err)\n\t}\n\n\terr = hs.LibraryPanelService.ConnectLibraryPanelsForDashboard(c.Req.Context(), c.SignedInUser, dash)\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while connecting library panels\", err)\n\t}\n\n\treturn response.JSON(200, dashInfo)\n}\n\n// CollectPluginMetrics collect metrics from a plugin.\n//\n// /api/plugins/:pluginId/metrics\nfunc (hs *HTTPServer) CollectPluginMetrics(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CollectMetrics(c.Req.Context(), plugin.ID)\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\theaders := make(http.Header)\n\theaders.Set(\"Content-Type\", \"text/plain\")\n\n\treturn response.CreateNormalResponse(headers, resp.PrometheusMetrics, http.StatusOK)\n}\n\n// getPluginAssets returns public plugin assets (images, JS, etc.)\n//\n// /public/plugins/:pluginId/*\nfunc (hs *HTTPServer) getPluginAssets(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\t// prepend slash for cleaning relative paths\n\trequestedFile := filepath.Clean(filepath.Join(\"/\", web.Params(c.Req)[\"*\"]))\n\trel, err := filepath.Rel(\"/\", requestedFile)\n\tif err != nil {\n\t\t// slash is prepended above therefore this is not expected to fail\n\t\tc.JsonApiErr(500, \"Failed to get the relative path\", err)\n\t\treturn\n\t}\n\n\tif !plugin.IncludedInSignature(rel) {\n\t\ths.log.Warn(\"Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \"+\n\t\t\t\"is not included in the plugin signature\", \"file\", requestedFile)\n\t}\n\n\tabsPluginDir, err := filepath.Abs(plugin.PluginDir)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin absolute path\", nil)\n\t\treturn\n\t}\n\n\tpluginFilePath := filepath.Join(absPluginDir, rel)\n\t// It's safe to ignore gosec warning G304 since we already clean the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\t// nolint:gosec\n\tf, err := os.Open(pluginFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tc.JsonApiErr(404, \"Plugin file not found\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Could not open plugin file\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err := f.Close(); err != nil {\n\t\t\ths.log.Error(\"Failed to close file\", \"err\", err)\n\t\t}\n\t}()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Plugin file exists but could not open\", err)\n\t\treturn\n\t}\n\n\tif hs.Cfg.Env == setting.Dev {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"max-age=0, must-revalidate, no-cache\")\n\t} else {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"public, max-age=3600\")\n\t}\n\n\thttp.ServeContent(c.Resp, c.Req, pluginFilePath, fi.ModTime(), f)\n}\n\n// CheckHealth returns the health of a plugin.\n// /api/plugins/:pluginId/health\nfunc (hs *HTTPServer) CheckHealth(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get plugin settings\", err)\n\t}\n\tif !found {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), &backend.CheckHealthRequest{\n\t\tPluginContext: pCtx,\n\t})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(503, payload)\n\t}\n\n\treturn response.JSON(200, payload)\n}\n\n// CallResource passes a resource call from a plugin to the backend plugin.\n//\n// /api/plugins/:pluginId/resources/*\nfunc (hs *HTTPServer) CallResource(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\ths.pluginClient.CallResource(pCtx, c, web.Params(c.Req)[\"*\"])\n}\n\nfunc (hs *HTTPServer) GetPluginErrorsList(_ *models.ReqContext) response.Response {\n\treturn response.JSON(200, hs.pluginErrorResolver.PluginErrors())\n}\n\nfunc (hs *HTTPServer) InstallPlugin(c *models.ReqContext) response.Response {\n\tdto := dtos.InstallPluginCommand{}\n\tif err := web.Bind(c.Req, &dto); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Add(c.Req.Context(), pluginID, dto.Version, plugins.AddOpts{})\n\tif err != nil {\n\t\tvar dupeErr plugins.DuplicateError\n\t\tif errors.As(err, &dupeErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin already installed\", err)\n\t\t}\n\t\tvar versionUnsupportedErr installer.ErrVersionUnsupported\n\t\tif errors.As(err, &versionUnsupportedErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin version not supported\", err)\n\t\t}\n\t\tvar versionNotFoundErr installer.ErrVersionNotFound\n\t\tif errors.As(err, &versionNotFoundErr) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin version not found\", err)\n\t\t}\n\t\tvar clientError installer.Response4xxError\n\t\tif errors.As(err, &clientError) {\n\t\t\treturn response.Error(clientError.StatusCode, clientError.Message, err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrInstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot install or change a Core plugin\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to install plugin\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc (hs *HTTPServer) UninstallPlugin(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Remove(c.Req.Context(), pluginID)\n\tif err != nil {\n\t\tif errors.Is(err, plugins.ErrPluginNotInstalled) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin not installed\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a Core plugin\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallOutsideOfPluginDir) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a plugin outside of the plugins directory\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to uninstall plugin\", err)\n\t}\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc translatePluginRequestErrorToAPIError(err error) response.Response {\n\tif errors.Is(err, backendplugin.ErrPluginNotRegistered) {\n\t\treturn response.Error(404, \"Plugin not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treturn response.Error(404, \"Not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrHealthCheckFailed) {\n\t\treturn response.Error(500, \"Plugin health check failed\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treturn response.Error(503, \"Plugin unavailable\", err)\n\t}\n\n\treturn response.Error(500, \"Plugin request failed\", err)\n}\n\nfunc (hs *HTTPServer) pluginMarkdown(ctx context.Context, pluginId string, name string) ([]byte, error) {\n\tplugin, exists := hs.pluginStore.Plugin(ctx, pluginId)\n\tif !exists {\n\t\treturn nil, plugins.NotFoundError{PluginID: pluginId}\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning on this one because `plugin.PluginDir` is based\n\t// on plugin the folder structure on disk and not user input.\n\tpath := filepath.Join(plugin.PluginDir, fmt.Sprintf(\"%s.md\", strings.ToUpper(name)))\n\texists, err := fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\tpath = filepath.Join(plugin.PluginDir, fmt.Sprintf(\"%s.md\", strings.ToLower(name)))\n\t}\n\n\texists, err = fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn make([]byte, 0), nil\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning on this one because `plugin.PluginDir` is based\n\t// on plugin the folder structure on disk and not user input.\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n", "package testdatasource\n\nimport (\n\t\"context\"\n\t\"encoding/csv\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana-plugin-sdk-go/data\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n)\n\nfunc (s *Service) handleCsvContentScenario(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\tresp := backend.NewQueryDataResponse()\n\n\tfor _, q := range req.Queries {\n\t\tmodel, err := simplejson.NewJson(q.JSON)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse query json: %v\", err)\n\t\t}\n\n\t\tcsvContent := model.Get(\"csvContent\").MustString()\n\t\tif len(csvContent) == 0 {\n\t\t\treturn backend.NewQueryDataResponse(), nil\n\t\t}\n\n\t\talias := model.Get(\"alias\").MustString(\"\")\n\n\t\tframe, err := LoadCsvContent(strings.NewReader(csvContent), alias)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trespD := resp.Responses[q.RefID]\n\t\trespD.Frames = append(respD.Frames, frame)\n\t\tresp.Responses[q.RefID] = respD\n\t}\n\n\treturn resp, nil\n}\n\nfunc (s *Service) handleCsvFileScenario(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\tresp := backend.NewQueryDataResponse()\n\n\tfor _, q := range req.Queries {\n\t\tmodel, err := simplejson.NewJson(q.JSON)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse query json %v\", err)\n\t\t}\n\n\t\tfileName := model.Get(\"csvFileName\").MustString()\n\n\t\tif len(fileName) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tframe, err := s.loadCsvFile(fileName)\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trespD := resp.Responses[q.RefID]\n\t\trespD.Frames = append(respD.Frames, frame)\n\t\tresp.Responses[q.RefID] = respD\n\t}\n\n\treturn resp, nil\n}\n\nfunc (s *Service) loadCsvFile(fileName string) (*data.Frame, error) {\n\tvalidFileName := regexp.MustCompile(`([\\w_]+)\\.csv`)\n\n\tif !validFileName.MatchString(fileName) {\n\t\treturn nil, fmt.Errorf(\"invalid csv file name: %q\", fileName)\n\t}\n\n\tfilePath := filepath.Join(s.cfg.StaticRootPath, \"testdata\", fileName)\n\n\t// Can ignore gosec G304 here, because we check the file pattern above\n\t// nolint:gosec\n\tfileReader, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed open file: %v\", err)\n\t}\n\n\tdefer func() {\n\t\tif err := fileReader.Close(); err != nil {\n\t\t\ts.logger.Warn(\"Failed to close file\", \"err\", err, \"path\", fileName)\n\t\t}\n\t}()\n\n\treturn LoadCsvContent(fileReader, fileName)\n}\n\n// LoadCsvContent should be moved to the SDK\nfunc LoadCsvContent(ioReader io.Reader, name string) (*data.Frame, error) {\n\treader := csv.NewReader(ioReader)\n\n\t// Read the header records\n\theaderFields, err := reader.Read()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read header line: %v\", err)\n\t}\n\n\tfields := []*data.Field{}\n\tfieldNames := []string{}\n\tfieldRawValues := [][]string{}\n\n\tfor _, fieldName := range headerFields {\n\t\tfieldNames = append(fieldNames, strings.Trim(fieldName, \" \"))\n\t\tfieldRawValues = append(fieldRawValues, []string{})\n\t}\n\n\tfor {\n\t\tlineValues, err := reader.Read()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tbreak // reached end of the file\n\t\t} else if err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read line: %v\", err)\n\t\t}\n\n\t\tfor fieldIndex, value := range lineValues {\n\t\t\tfieldRawValues[fieldIndex] = append(fieldRawValues[fieldIndex], strings.Trim(value, \" \"))\n\t\t}\n\t}\n\n\tlongest := 0\n\tfor fieldIndex, rawValues := range fieldRawValues {\n\t\tfieldName := fieldNames[fieldIndex]\n\t\tfield, err := csvValuesToField(rawValues)\n\t\tif err == nil {\n\t\t\t// Check if the values are actually a time field\n\t\t\tif strings.Contains(strings.ToLower(fieldName), \"time\") {\n\t\t\t\ttimeField := toTimeField(field)\n\t\t\t\tif timeField != nil {\n\t\t\t\t\tfield = timeField\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfield.Name = fieldName\n\t\t\tfields = append(fields, field)\n\t\t\tif field.Len() > longest {\n\t\t\t\tlongest = field.Len()\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make all fields the same length\n\tfor _, field := range fields {\n\t\tdelta := field.Len() - longest\n\t\tif delta > 0 {\n\t\t\tfield.Extend(delta)\n\t\t}\n\t}\n\n\tframe := data.NewFrame(name, fields...)\n\treturn frame, nil\n}\n\nfunc csvLineToField(stringInput string) (*data.Field, error) {\n\treturn csvValuesToField(strings.Split(strings.ReplaceAll(stringInput, \" \", \"\"), \",\"))\n}\n\nfunc csvValuesToField(parts []string) (*data.Field, error) {\n\tif len(parts) < 1 {\n\t\treturn nil, fmt.Errorf(\"csv must have at least one value\")\n\t}\n\n\tfirst := strings.ToUpper(parts[0])\n\tif first == \"T\" || first == \"F\" || first == \"TRUE\" || first == \"FALSE\" {\n\t\tfield := data.NewFieldFromFieldType(data.FieldTypeNullableBool, len(parts))\n\t\tfor idx, strVal := range parts {\n\t\t\tstrVal = strings.ToUpper(strVal)\n\t\t\tif strVal == \"NULL\" || strVal == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfield.SetConcrete(idx, strVal == \"T\" || strVal == \"TRUE\")\n\t\t}\n\t\treturn field, nil\n\t}\n\n\t// Try parsing values as numbers\n\tok := false\n\tfield := data.NewFieldFromFieldType(data.FieldTypeNullableInt64, len(parts))\n\tfor idx, strVal := range parts {\n\t\tif strVal == \"null\" || strVal == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tval, err := strconv.ParseInt(strVal, 10, 64)\n\t\tif err != nil {\n\t\t\tok = false\n\t\t\tbreak\n\t\t}\n\t\tfield.SetConcrete(idx, val)\n\t\tok = true\n\t}\n\tif ok {\n\t\treturn field, nil\n\t}\n\n\t// Maybe floats\n\tfield = data.NewFieldFromFieldType(data.FieldTypeNullableFloat64, len(parts))\n\tfor idx, strVal := range parts {\n\t\tif strVal == \"null\" || strVal == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tval, err := strconv.ParseFloat(strVal, 64)\n\t\tif err != nil {\n\t\t\tok = false\n\t\t\tbreak\n\t\t}\n\t\tfield.SetConcrete(idx, val)\n\t\tok = true\n\t}\n\tif ok {\n\t\treturn field, nil\n\t}\n\n\t// Replace empty strings with null\n\tfield = data.NewFieldFromFieldType(data.FieldTypeNullableString, len(parts))\n\tfor idx, strVal := range parts {\n\t\tif strVal == \"null\" || strVal == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tfield.SetConcrete(idx, strVal)\n\t}\n\treturn field, nil\n}\n\n// This will try to convert the values to a timestamp\nfunc toTimeField(field *data.Field) *data.Field {\n\tfound := false\n\tcount := field.Len()\n\ttimeField := data.NewFieldFromFieldType(data.FieldTypeNullableTime, count)\n\ttimeField.Config = field.Config\n\ttimeField.Name = field.Name\n\ttimeField.Labels = field.Labels\n\tft := field.Type()\n\tif ft.Numeric() {\n\t\tfor i := 0; i < count; i++ {\n\t\t\tv, err := field.FloatAt(i)\n\t\t\tif err == nil {\n\t\t\t\tt := time.Unix(0, int64(v)*int64(time.Millisecond))\n\t\t\t\ttimeField.SetConcrete(i, t.UTC())\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn nil\n\t\t}\n\t\treturn timeField\n\t}\n\tif ft == data.FieldTypeNullableString || ft == data.FieldTypeString {\n\t\tfor i := 0; i < count; i++ {\n\t\t\tv, ok := field.ConcreteAt(i)\n\t\t\tif ok && v != nil {\n\t\t\t\tt, err := time.Parse(time.RFC3339, v.(string))\n\t\t\t\tif err == nil {\n\t\t\t\t\ttimeField.SetConcrete(i, t.UTC())\n\t\t\t\t\tfound = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn nil\n\t\t}\n\t\treturn timeField\n\t}\n\treturn nil\n}\n"], "fixing_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/plugins/manager/installer\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nfunc (hs *HTTPServer) GetPluginList(c *models.ReqContext) response.Response {\n\ttypeFilter := c.Query(\"type\")\n\tenabledFilter := c.Query(\"enabled\")\n\tembeddedFilter := c.Query(\"embedded\")\n\tcoreFilter := c.Query(\"core\")\n\n\t// For users with viewer role we only return core plugins\n\tif !c.HasRole(models.ROLE_ADMIN) {\n\t\tcoreFilter = \"1\"\n\t}\n\n\tpluginSettingsMap, err := hs.pluginSettings(c.Req.Context(), c.OrgId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get list of plugins\", err)\n\t}\n\n\tresult := make(dtos.PluginList, 0)\n\tfor _, pluginDef := range hs.pluginStore.Plugins(c.Req.Context()) {\n\t\t// filter out app sub plugins\n\t\tif embeddedFilter == \"0\" && pluginDef.IncludedInAppID != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out core plugins\n\t\tif (coreFilter == \"0\" && pluginDef.IsCorePlugin()) || (coreFilter == \"1\" && !pluginDef.IsCorePlugin()) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter on type\n\t\tif typeFilter != \"\" && typeFilter != string(pluginDef.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif pluginDef.State == plugins.AlphaRelease && !hs.Cfg.PluginsEnableAlpha {\n\t\t\tcontinue\n\t\t}\n\n\t\tlistItem := dtos.PluginListItem{\n\t\t\tId:            pluginDef.ID,\n\t\t\tName:          pluginDef.Name,\n\t\t\tType:          string(pluginDef.Type),\n\t\t\tCategory:      pluginDef.Category,\n\t\t\tInfo:          pluginDef.Info,\n\t\t\tDependencies:  pluginDef.Dependencies,\n\t\t\tLatestVersion: pluginDef.GrafanaComVersion,\n\t\t\tHasUpdate:     pluginDef.GrafanaComHasUpdate,\n\t\t\tDefaultNavUrl: pluginDef.DefaultNavURL,\n\t\t\tState:         pluginDef.State,\n\t\t\tSignature:     pluginDef.Signature,\n\t\t\tSignatureType: pluginDef.SignatureType,\n\t\t\tSignatureOrg:  pluginDef.SignatureOrg,\n\t\t}\n\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tlistItem.Enabled = pluginSetting.Enabled\n\t\t\tlistItem.Pinned = pluginSetting.Pinned\n\t\t}\n\n\t\tif listItem.DefaultNavUrl == \"\" || !listItem.Enabled {\n\t\t\tlistItem.DefaultNavUrl = hs.Cfg.AppSubURL + \"/plugins/\" + listItem.Id + \"/\"\n\t\t}\n\n\t\t// filter out disabled plugins\n\t\tif enabledFilter == \"1\" && !listItem.Enabled {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out built in plugins\n\t\tif pluginDef.BuiltIn {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult = append(result, listItem)\n\t}\n\n\tsort.Sort(result)\n\treturn response.JSON(200, result)\n}\n\nfunc (hs *HTTPServer) GetPluginSettingByID(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found, no installed plugin with that id\", nil)\n\t}\n\n\tdto := &dtos.PluginSetting{\n\t\tType:          string(plugin.Type),\n\t\tId:            plugin.ID,\n\t\tName:          plugin.Name,\n\t\tInfo:          plugin.Info,\n\t\tDependencies:  plugin.Dependencies,\n\t\tIncludes:      plugin.Includes,\n\t\tBaseUrl:       plugin.BaseURL,\n\t\tModule:        plugin.Module,\n\t\tDefaultNavUrl: plugin.DefaultNavURL,\n\t\tLatestVersion: plugin.GrafanaComVersion,\n\t\tHasUpdate:     plugin.GrafanaComHasUpdate,\n\t\tState:         plugin.State,\n\t\tSignature:     plugin.Signature,\n\t\tSignatureType: plugin.SignatureType,\n\t\tSignatureOrg:  plugin.SignatureOrg,\n\t}\n\n\tif plugin.IsApp() {\n\t\tdto.Enabled = plugin.AutoEnabled\n\t\tdto.Pinned = plugin.AutoEnabled\n\t}\n\n\tquery := models.GetPluginSettingByIdQuery{PluginId: pluginID, OrgId: c.OrgId}\n\tif err := bus.DispatchCtx(c.Req.Context(), &query); err != nil {\n\t\tif !errors.Is(err, models.ErrPluginSettingNotFound) {\n\t\t\treturn response.Error(500, \"Failed to get login settings\", nil)\n\t\t}\n\t} else {\n\t\tdto.Enabled = query.Result.Enabled\n\t\tdto.Pinned = query.Result.Pinned\n\t\tdto.JsonData = query.Result.JsonData\n\t}\n\n\treturn response.JSON(200, dto)\n}\n\nfunc (hs *HTTPServer) UpdatePluginSetting(c *models.ReqContext) response.Response {\n\tcmd := models.UpdatePluginSettingCmd{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tif _, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID); !exists {\n\t\treturn response.Error(404, \"Plugin not installed\", nil)\n\t}\n\n\tcmd.OrgId = c.OrgId\n\tcmd.PluginId = pluginID\n\tif err := bus.DispatchCtx(c.Req.Context(), &cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to update plugin setting\", err)\n\t}\n\n\treturn response.Success(\"Plugin settings updated\")\n}\n\nfunc (hs *HTTPServer) GetPluginDashboards(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tlist, err := hs.pluginDashboardManager.GetPluginDashboards(c.Req.Context(), c.OrgId, pluginID)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Failed to get plugin dashboards\", err)\n\t}\n\n\treturn response.JSON(200, list)\n}\n\nfunc (hs *HTTPServer) GetPluginMarkdown(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tname := web.Params(c.Req)[\":name\"]\n\n\tcontent, err := hs.pluginMarkdown(c.Req.Context(), pluginID, name)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Could not get markdown file\", err)\n\t}\n\n\t// fallback try readme\n\tif len(content) == 0 {\n\t\tcontent, err = hs.pluginMarkdown(c.Req.Context(), pluginID, \"readme\")\n\t\tif err != nil {\n\t\t\treturn response.Error(501, \"Could not get markdown file\", err)\n\t\t}\n\t}\n\n\tresp := response.Respond(200, content)\n\tresp.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n\treturn resp\n}\n\nfunc (hs *HTTPServer) ImportDashboard(c *models.ReqContext) response.Response {\n\tapiCmd := dtos.ImportDashboardCommand{}\n\tif err := web.Bind(c.Req, &apiCmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tvar err error\n\tif apiCmd.PluginId == \"\" && apiCmd.Dashboard == nil {\n\t\treturn response.Error(422, \"Dashboard must be set\", nil)\n\t}\n\n\tlimitReached, err := hs.QuotaService.QuotaReached(c, \"dashboard\")\n\tif err != nil {\n\t\treturn response.Error(500, \"failed to get quota\", err)\n\t}\n\tif limitReached {\n\t\treturn response.Error(403, \"Quota reached\", nil)\n\t}\n\n\ttrimDefaults := c.QueryBoolWithDefault(\"trimdefaults\", true)\n\tif trimDefaults && !hs.LoadSchemaService.IsDisabled() {\n\t\tapiCmd.Dashboard, err = hs.LoadSchemaService.DashboardApplyDefaults(apiCmd.Dashboard)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Error while applying default value to the dashboard json\", err)\n\t\t}\n\t}\n\n\tdashInfo, dash, err := hs.pluginDashboardManager.ImportDashboard(c.Req.Context(), apiCmd.PluginId, apiCmd.Path, c.OrgId, apiCmd.FolderId,\n\t\tapiCmd.Dashboard, apiCmd.Overwrite, apiCmd.Inputs, c.SignedInUser)\n\tif err != nil {\n\t\treturn hs.dashboardSaveErrorToApiResponse(c.Req.Context(), err)\n\t}\n\n\terr = hs.LibraryPanelService.ImportLibraryPanelsForDashboard(c.Req.Context(), c.SignedInUser, dash, apiCmd.FolderId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while importing library panels\", err)\n\t}\n\n\terr = hs.LibraryPanelService.ConnectLibraryPanelsForDashboard(c.Req.Context(), c.SignedInUser, dash)\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while connecting library panels\", err)\n\t}\n\n\treturn response.JSON(200, dashInfo)\n}\n\n// CollectPluginMetrics collect metrics from a plugin.\n//\n// /api/plugins/:pluginId/metrics\nfunc (hs *HTTPServer) CollectPluginMetrics(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CollectMetrics(c.Req.Context(), plugin.ID)\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\theaders := make(http.Header)\n\theaders.Set(\"Content-Type\", \"text/plain\")\n\n\treturn response.CreateNormalResponse(headers, resp.PrometheusMetrics, http.StatusOK)\n}\n\n// getPluginAssets returns public plugin assets (images, JS, etc.)\n//\n// /public/plugins/:pluginId/*\nfunc (hs *HTTPServer) getPluginAssets(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\t// prepend slash for cleaning relative paths\n\trequestedFile := filepath.Clean(filepath.Join(\"/\", web.Params(c.Req)[\"*\"]))\n\trel, err := filepath.Rel(\"/\", requestedFile)\n\tif err != nil {\n\t\t// slash is prepended above therefore this is not expected to fail\n\t\tc.JsonApiErr(500, \"Failed to get the relative path\", err)\n\t\treturn\n\t}\n\n\tif !plugin.IncludedInSignature(rel) {\n\t\ths.log.Warn(\"Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \"+\n\t\t\t\"is not included in the plugin signature\", \"file\", requestedFile)\n\t}\n\n\tabsPluginDir, err := filepath.Abs(plugin.PluginDir)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin absolute path\", nil)\n\t\treturn\n\t}\n\n\tpluginFilePath := filepath.Join(absPluginDir, rel)\n\t// It's safe to ignore gosec warning G304 since we already clean the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\t// nolint:gosec\n\tf, err := os.Open(pluginFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tc.JsonApiErr(404, \"Plugin file not found\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Could not open plugin file\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err := f.Close(); err != nil {\n\t\t\ths.log.Error(\"Failed to close file\", \"err\", err)\n\t\t}\n\t}()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Plugin file exists but could not open\", err)\n\t\treturn\n\t}\n\n\tif hs.Cfg.Env == setting.Dev {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"max-age=0, must-revalidate, no-cache\")\n\t} else {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"public, max-age=3600\")\n\t}\n\n\thttp.ServeContent(c.Resp, c.Req, pluginFilePath, fi.ModTime(), f)\n}\n\n// CheckHealth returns the health of a plugin.\n// /api/plugins/:pluginId/health\nfunc (hs *HTTPServer) CheckHealth(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get plugin settings\", err)\n\t}\n\tif !found {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), &backend.CheckHealthRequest{\n\t\tPluginContext: pCtx,\n\t})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(503, payload)\n\t}\n\n\treturn response.JSON(200, payload)\n}\n\n// CallResource passes a resource call from a plugin to the backend plugin.\n//\n// /api/plugins/:pluginId/resources/*\nfunc (hs *HTTPServer) CallResource(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\ths.pluginClient.CallResource(pCtx, c, web.Params(c.Req)[\"*\"])\n}\n\nfunc (hs *HTTPServer) GetPluginErrorsList(_ *models.ReqContext) response.Response {\n\treturn response.JSON(200, hs.pluginErrorResolver.PluginErrors())\n}\n\nfunc (hs *HTTPServer) InstallPlugin(c *models.ReqContext) response.Response {\n\tdto := dtos.InstallPluginCommand{}\n\tif err := web.Bind(c.Req, &dto); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Add(c.Req.Context(), pluginID, dto.Version, plugins.AddOpts{})\n\tif err != nil {\n\t\tvar dupeErr plugins.DuplicateError\n\t\tif errors.As(err, &dupeErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin already installed\", err)\n\t\t}\n\t\tvar versionUnsupportedErr installer.ErrVersionUnsupported\n\t\tif errors.As(err, &versionUnsupportedErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin version not supported\", err)\n\t\t}\n\t\tvar versionNotFoundErr installer.ErrVersionNotFound\n\t\tif errors.As(err, &versionNotFoundErr) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin version not found\", err)\n\t\t}\n\t\tvar clientError installer.Response4xxError\n\t\tif errors.As(err, &clientError) {\n\t\t\treturn response.Error(clientError.StatusCode, clientError.Message, err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrInstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot install or change a Core plugin\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to install plugin\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc (hs *HTTPServer) UninstallPlugin(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Remove(c.Req.Context(), pluginID)\n\tif err != nil {\n\t\tif errors.Is(err, plugins.ErrPluginNotInstalled) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin not installed\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a Core plugin\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallOutsideOfPluginDir) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a plugin outside of the plugins directory\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to uninstall plugin\", err)\n\t}\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc translatePluginRequestErrorToAPIError(err error) response.Response {\n\tif errors.Is(err, backendplugin.ErrPluginNotRegistered) {\n\t\treturn response.Error(404, \"Plugin not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treturn response.Error(404, \"Not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrHealthCheckFailed) {\n\t\treturn response.Error(500, \"Plugin health check failed\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treturn response.Error(503, \"Plugin unavailable\", err)\n\t}\n\n\treturn response.Error(500, \"Plugin request failed\", err)\n}\n\nfunc (hs *HTTPServer) pluginMarkdown(ctx context.Context, pluginId string, name string) ([]byte, error) {\n\tplugin, exists := hs.pluginStore.Plugin(ctx, pluginId)\n\tif !exists {\n\t\treturn nil, plugins.NotFoundError{PluginID: pluginId}\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tpath := filepath.Join(plugin.PluginDir, mdFilepath(strings.ToUpper(name)))\n\texists, err := fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\tpath = filepath.Join(plugin.PluginDir, mdFilepath(strings.ToLower(name)))\n\t}\n\n\texists, err = fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn make([]byte, 0), nil\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\nfunc mdFilepath(mdFilename string) string {\n\treturn filepath.Clean(filepath.Join(\"/\", fmt.Sprintf(\"%s.md\", mdFilename)))\n}\n", "package testdatasource\n\nimport (\n\t\"context\"\n\t\"encoding/csv\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana-plugin-sdk-go/data\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n)\n\nfunc (s *Service) handleCsvContentScenario(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\tresp := backend.NewQueryDataResponse()\n\n\tfor _, q := range req.Queries {\n\t\tmodel, err := simplejson.NewJson(q.JSON)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse query json: %v\", err)\n\t\t}\n\n\t\tcsvContent := model.Get(\"csvContent\").MustString()\n\t\tif len(csvContent) == 0 {\n\t\t\treturn backend.NewQueryDataResponse(), nil\n\t\t}\n\n\t\talias := model.Get(\"alias\").MustString(\"\")\n\n\t\tframe, err := LoadCsvContent(strings.NewReader(csvContent), alias)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trespD := resp.Responses[q.RefID]\n\t\trespD.Frames = append(respD.Frames, frame)\n\t\tresp.Responses[q.RefID] = respD\n\t}\n\n\treturn resp, nil\n}\n\nfunc (s *Service) handleCsvFileScenario(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\tresp := backend.NewQueryDataResponse()\n\n\tfor _, q := range req.Queries {\n\t\tmodel, err := simplejson.NewJson(q.JSON)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse query json %v\", err)\n\t\t}\n\n\t\tfileName := model.Get(\"csvFileName\").MustString()\n\n\t\tif len(fileName) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tframe, err := s.loadCsvFile(fileName)\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trespD := resp.Responses[q.RefID]\n\t\trespD.Frames = append(respD.Frames, frame)\n\t\tresp.Responses[q.RefID] = respD\n\t}\n\n\treturn resp, nil\n}\n\nfunc (s *Service) loadCsvFile(fileName string) (*data.Frame, error) {\n\tvalidFileName := regexp.MustCompile(`^\\w+\\.csv$`)\n\n\tif !validFileName.MatchString(fileName) {\n\t\treturn nil, fmt.Errorf(\"invalid csv file name: %q\", fileName)\n\t}\n\n\tcsvFilepath := filepath.Clean(filepath.Join(\"/\", fileName))\n\tfilePath := filepath.Join(s.cfg.StaticRootPath, \"testdata\", csvFilepath)\n\n\t// Can ignore gosec G304 here, because we check the file pattern above\n\t// nolint:gosec\n\tfileReader, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed open file: %v\", err)\n\t}\n\n\tdefer func() {\n\t\tif err := fileReader.Close(); err != nil {\n\t\t\ts.logger.Warn(\"Failed to close file\", \"err\", err, \"path\", fileName)\n\t\t}\n\t}()\n\n\treturn LoadCsvContent(fileReader, fileName)\n}\n\n// LoadCsvContent should be moved to the SDK\nfunc LoadCsvContent(ioReader io.Reader, name string) (*data.Frame, error) {\n\treader := csv.NewReader(ioReader)\n\n\t// Read the header records\n\theaderFields, err := reader.Read()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read header line: %v\", err)\n\t}\n\n\tfields := []*data.Field{}\n\tfieldNames := []string{}\n\tfieldRawValues := [][]string{}\n\n\tfor _, fieldName := range headerFields {\n\t\tfieldNames = append(fieldNames, strings.Trim(fieldName, \" \"))\n\t\tfieldRawValues = append(fieldRawValues, []string{})\n\t}\n\n\tfor {\n\t\tlineValues, err := reader.Read()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tbreak // reached end of the file\n\t\t} else if err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read line: %v\", err)\n\t\t}\n\n\t\tfor fieldIndex, value := range lineValues {\n\t\t\tfieldRawValues[fieldIndex] = append(fieldRawValues[fieldIndex], strings.Trim(value, \" \"))\n\t\t}\n\t}\n\n\tlongest := 0\n\tfor fieldIndex, rawValues := range fieldRawValues {\n\t\tfieldName := fieldNames[fieldIndex]\n\t\tfield, err := csvValuesToField(rawValues)\n\t\tif err == nil {\n\t\t\t// Check if the values are actually a time field\n\t\t\tif strings.Contains(strings.ToLower(fieldName), \"time\") {\n\t\t\t\ttimeField := toTimeField(field)\n\t\t\t\tif timeField != nil {\n\t\t\t\t\tfield = timeField\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfield.Name = fieldName\n\t\t\tfields = append(fields, field)\n\t\t\tif field.Len() > longest {\n\t\t\t\tlongest = field.Len()\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make all fields the same length\n\tfor _, field := range fields {\n\t\tdelta := field.Len() - longest\n\t\tif delta > 0 {\n\t\t\tfield.Extend(delta)\n\t\t}\n\t}\n\n\tframe := data.NewFrame(name, fields...)\n\treturn frame, nil\n}\n\nfunc csvLineToField(stringInput string) (*data.Field, error) {\n\treturn csvValuesToField(strings.Split(strings.ReplaceAll(stringInput, \" \", \"\"), \",\"))\n}\n\nfunc csvValuesToField(parts []string) (*data.Field, error) {\n\tif len(parts) < 1 {\n\t\treturn nil, fmt.Errorf(\"csv must have at least one value\")\n\t}\n\n\tfirst := strings.ToUpper(parts[0])\n\tif first == \"T\" || first == \"F\" || first == \"TRUE\" || first == \"FALSE\" {\n\t\tfield := data.NewFieldFromFieldType(data.FieldTypeNullableBool, len(parts))\n\t\tfor idx, strVal := range parts {\n\t\t\tstrVal = strings.ToUpper(strVal)\n\t\t\tif strVal == \"NULL\" || strVal == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfield.SetConcrete(idx, strVal == \"T\" || strVal == \"TRUE\")\n\t\t}\n\t\treturn field, nil\n\t}\n\n\t// Try parsing values as numbers\n\tok := false\n\tfield := data.NewFieldFromFieldType(data.FieldTypeNullableInt64, len(parts))\n\tfor idx, strVal := range parts {\n\t\tif strVal == \"null\" || strVal == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tval, err := strconv.ParseInt(strVal, 10, 64)\n\t\tif err != nil {\n\t\t\tok = false\n\t\t\tbreak\n\t\t}\n\t\tfield.SetConcrete(idx, val)\n\t\tok = true\n\t}\n\tif ok {\n\t\treturn field, nil\n\t}\n\n\t// Maybe floats\n\tfield = data.NewFieldFromFieldType(data.FieldTypeNullableFloat64, len(parts))\n\tfor idx, strVal := range parts {\n\t\tif strVal == \"null\" || strVal == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tval, err := strconv.ParseFloat(strVal, 64)\n\t\tif err != nil {\n\t\t\tok = false\n\t\t\tbreak\n\t\t}\n\t\tfield.SetConcrete(idx, val)\n\t\tok = true\n\t}\n\tif ok {\n\t\treturn field, nil\n\t}\n\n\t// Replace empty strings with null\n\tfield = data.NewFieldFromFieldType(data.FieldTypeNullableString, len(parts))\n\tfor idx, strVal := range parts {\n\t\tif strVal == \"null\" || strVal == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tfield.SetConcrete(idx, strVal)\n\t}\n\treturn field, nil\n}\n\n// This will try to convert the values to a timestamp\nfunc toTimeField(field *data.Field) *data.Field {\n\tfound := false\n\tcount := field.Len()\n\ttimeField := data.NewFieldFromFieldType(data.FieldTypeNullableTime, count)\n\ttimeField.Config = field.Config\n\ttimeField.Name = field.Name\n\ttimeField.Labels = field.Labels\n\tft := field.Type()\n\tif ft.Numeric() {\n\t\tfor i := 0; i < count; i++ {\n\t\t\tv, err := field.FloatAt(i)\n\t\t\tif err == nil {\n\t\t\t\tt := time.Unix(0, int64(v)*int64(time.Millisecond))\n\t\t\t\ttimeField.SetConcrete(i, t.UTC())\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn nil\n\t\t}\n\t\treturn timeField\n\t}\n\tif ft == data.FieldTypeNullableString || ft == data.FieldTypeString {\n\t\tfor i := 0; i < count; i++ {\n\t\t\tv, ok := field.ConcreteAt(i)\n\t\t\tif ok && v != nil {\n\t\t\t\tt, err := time.Parse(time.RFC3339, v.(string))\n\t\t\t\tif err == nil {\n\t\t\t\t\ttimeField.SetConcrete(i, t.UTC())\n\t\t\t\t\tfound = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn nil\n\t\t}\n\t\treturn timeField\n\t}\n\treturn nil\n}\n"], "filenames": ["pkg/api/plugins.go", "pkg/tsdb/testdatasource/csv_data.go"], "buggy_code_start_loc": [493, 80], "buggy_code_end_loc": [520, 87], "fixing_code_start_loc": [493, 80], "fixing_code_end_loc": [525, 88], "type": "CWE-22", "message": "Grafana is an open-source platform for monitoring and observability. Grafana prior to versions 8.3.2 and 7.5.12 has a directory traversal for arbitrary .csv files. It only affects instances that have the developer testing tool called TestData DB data source enabled and configured. The vulnerability is limited in scope, and only allows access to files with the extension .csv to authenticated users only. Grafana Cloud instances have not been affected by the vulnerability. Versions 8.3.2 and 7.5.12 contain a patch for this issue. There is a workaround available for users who cannot upgrade. Running a reverse proxy in front of Grafana that normalizes the PATH of the request will mitigate the vulnerability. The proxy will have to also be able to handle url encoded paths.", "other": {"cve": {"id": "CVE-2021-43815", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-10T21:15:09.497", "lastModified": "2022-03-31T16:31:33.833", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Grafana is an open-source platform for monitoring and observability. Grafana prior to versions 8.3.2 and 7.5.12 has a directory traversal for arbitrary .csv files. It only affects instances that have the developer testing tool called TestData DB data source enabled and configured. The vulnerability is limited in scope, and only allows access to files with the extension .csv to authenticated users only. Grafana Cloud instances have not been affected by the vulnerability. Versions 8.3.2 and 7.5.12 contain a patch for this issue. There is a workaround available for users who cannot upgrade. Running a reverse proxy in front of Grafana that normalizes the PATH of the request will mitigate the vulnerability. The proxy will have to also be able to handle url encoded paths."}, {"lang": "es", "value": "Grafana es una plataforma de c\u00f3digo abierto para la monitorizaci\u00f3n y la observabilidad. Grafana versiones anteriores a 8.3.2 y 7.5.12, presenta un salto de directorios para archivos .csv arbitrarios. S\u00f3lo afecta a las instancias que tienen habilitada y configurada la herramienta de pruebas para desarrolladores llamada fuente de datos TestData DB. La vulnerabilidad presenta un alcance limitado y s\u00f3lo permite el acceso a los archivos con la extensi\u00f3n .csv a usuarios autenticados. Las instancias de Grafana Cloud no se han visto afectadas por la vulnerabilidad. Las versiones 8.3.2 y 7.5.12 contienen un parche para este problema. Se presenta una soluci\u00f3n disponible para usuarios que no pueden actualizar. Ejecutar un proxy inverso frente a Grafana que normalice el PATH de la petici\u00f3n mitigar\u00e1 la vulnerabilidad. El proxy tambi\u00e9n tendr\u00e1 que ser capaz de manejar rutas codificadas con url"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.5.12", "matchCriteriaId": "9E8AA544-0EAE-40C6-8C0E-E1276C1A2D32"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.3.2", "matchCriteriaId": "072437F7-4A16-4373-9026-7C20B0D2AFB8"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/12/10/4", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/commit/d6ec6f8ad28f0212e584406730f939105ff6c6d3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/commit/fd48aee61e4328aae8d5303a9efd045fa0ca308d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/releases/tag/v8.3.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/security/advisories/GHSA-7533-c8qv-jm9m", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://grafana.com/blog/2021/12/10/grafana-8.3.2-and-7.5.12-released-with-moderate-severity-security-fix/", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220107-0006/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grafana/grafana/commit/d6ec6f8ad28f0212e584406730f939105ff6c6d3"}}