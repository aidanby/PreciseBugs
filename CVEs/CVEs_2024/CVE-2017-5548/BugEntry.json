{"buggy_code": ["/*\n * atusb.c - Driver for the ATUSB IEEE 802.15.4 dongle\n *\n * Written 2013 by Werner Almesberger <werner@almesberger.net>\n *\n * Copyright (c) 2015 - 2016 Stefan Schmidt <stefan@datenfreihafen.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, version 2\n *\n * Based on at86rf230.c and spi_atusb.c.\n * at86rf230.c is\n * Copyright (C) 2009 Siemens AG\n * Written by: Dmitry Eremin-Solenikov <dmitry.baryshkov@siemens.com>\n *\n * spi_atusb.c is\n * Copyright (c) 2011 Richard Sharpe <realrichardsharpe@gmail.com>\n * Copyright (c) 2011 Stefan Schmidt <stefan@datenfreihafen.org>\n * Copyright (c) 2011 Werner Almesberger <werner@almesberger.net>\n *\n * USB initialization is\n * Copyright (c) 2013 Alexander Aring <alex.aring@gmail.com>\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/usb.h>\n#include <linux/skbuff.h>\n\n#include <net/cfg802154.h>\n#include <net/mac802154.h>\n\n#include \"at86rf230.h\"\n#include \"atusb.h\"\n\n#define ATUSB_JEDEC_ATMEL\t0x1f\t/* JEDEC manufacturer ID */\n\n#define ATUSB_NUM_RX_URBS\t4\t/* allow for a bit of local latency */\n#define ATUSB_ALLOC_DELAY_MS\t100\t/* delay after failed allocation */\n#define ATUSB_TX_TIMEOUT_MS\t200\t/* on the air timeout */\n\nstruct atusb {\n\tstruct ieee802154_hw *hw;\n\tstruct usb_device *usb_dev;\n\tint shutdown;\t\t\t/* non-zero if shutting down */\n\tint err;\t\t\t/* set by first error */\n\n\t/* RX variables */\n\tstruct delayed_work work;\t/* memory allocations */\n\tstruct usb_anchor idle_urbs;\t/* URBs waiting to be submitted */\n\tstruct usb_anchor rx_urbs;\t/* URBs waiting for reception */\n\n\t/* TX variables */\n\tstruct usb_ctrlrequest tx_dr;\n\tstruct urb *tx_urb;\n\tstruct sk_buff *tx_skb;\n\tuint8_t tx_ack_seq;\t\t/* current TX ACK sequence number */\n\n\t/* Firmware variable */\n\tunsigned char fw_ver_maj;\t/* Firmware major version number */\n\tunsigned char fw_ver_min;\t/* Firmware minor version number */\n\tunsigned char fw_hw_type;\t/* Firmware hardware type */\n};\n\n/* ----- USB commands without data ----------------------------------------- */\n\n/* To reduce the number of error checks in the code, we record the first error\n * in atusb->err and reject all subsequent requests until the error is cleared.\n */\n\nstatic int atusb_control_msg(struct atusb *atusb, unsigned int pipe,\n\t\t\t     __u8 request, __u8 requesttype,\n\t\t\t     __u16 value, __u16 index,\n\t\t\t     void *data, __u16 size, int timeout)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\n\tif (atusb->err)\n\t\treturn atusb->err;\n\n\tret = usb_control_msg(usb_dev, pipe, request, requesttype,\n\t\t\t      value, index, data, size, timeout);\n\tif (ret < 0) {\n\t\tatusb->err = ret;\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"atusb_control_msg: req 0x%02x val 0x%x idx 0x%x, error %d\\n\",\n\t\t\trequest, value, index, ret);\n\t}\n\treturn ret;\n}\n\nstatic int atusb_command(struct atusb *atusb, uint8_t cmd, uint8_t arg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_command: cmd = 0x%x\\n\", cmd);\n\treturn atusb_control_msg(atusb, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t\t cmd, ATUSB_REQ_TO_DEV, arg, 0, NULL, 0, 1000);\n}\n\nstatic int atusb_write_reg(struct atusb *atusb, uint8_t reg, uint8_t value)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_write_reg: 0x%02x <- 0x%02x\\n\",\n\t\treg, value);\n\treturn atusb_control_msg(atusb, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t\t ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t\t value, reg, NULL, 0, 1000);\n}\n\nstatic int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}\n\nstatic int atusb_write_subreg(struct atusb *atusb, uint8_t reg, uint8_t mask,\n\t\t\t      uint8_t shift, uint8_t value)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tuint8_t orig, tmp;\n\tint ret = 0;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_write_subreg: 0x%02x <- 0x%02x\\n\",\n\t\treg, value);\n\n\torig = atusb_read_reg(atusb, reg);\n\n\t/* Write the value only into that part of the register which is allowed\n\t * by the mask. All other bits stay as before.\n\t */\n\ttmp = orig & ~mask;\n\ttmp |= (value << shift) & mask;\n\n\tif (tmp != orig)\n\t\tret = atusb_write_reg(atusb, reg, tmp);\n\n\treturn ret;\n}\n\nstatic int atusb_get_and_clear_error(struct atusb *atusb)\n{\n\tint err = atusb->err;\n\n\tatusb->err = 0;\n\treturn err;\n}\n\n/* ----- skb allocation ---------------------------------------------------- */\n\n#define MAX_PSDU\t127\n#define MAX_RX_XFER\t(1 + MAX_PSDU + 2 + 1)\t/* PHR+PSDU+CRC+LQI */\n\n#define SKB_ATUSB(skb)\t(*(struct atusb **)(skb)->cb)\n\nstatic void atusb_in(struct urb *urb);\n\nstatic int atusb_submit_rx_urb(struct atusb *atusb, struct urb *urb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tstruct sk_buff *skb = urb->context;\n\tint ret;\n\n\tif (!skb) {\n\t\tskb = alloc_skb(MAX_RX_XFER, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tdev_warn_ratelimited(&usb_dev->dev,\n\t\t\t\t\t     \"atusb_in: can't allocate skb\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_RX_XFER);\n\t\tSKB_ATUSB(skb) = atusb;\n\t}\n\n\tusb_fill_bulk_urb(urb, usb_dev, usb_rcvbulkpipe(usb_dev, 1),\n\t\t\t  skb->data, MAX_RX_XFER, atusb_in, skb);\n\tusb_anchor_urb(urb, &atusb->rx_urbs);\n\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tkfree_skb(skb);\n\t\turb->context = NULL;\n\t}\n\treturn ret;\n}\n\nstatic void atusb_work_urbs(struct work_struct *work)\n{\n\tstruct atusb *atusb =\n\t    container_of(to_delayed_work(work), struct atusb, work);\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tstruct urb *urb;\n\tint ret;\n\n\tif (atusb->shutdown)\n\t\treturn;\n\n\tdo {\n\t\turb = usb_get_from_anchor(&atusb->idle_urbs);\n\t\tif (!urb)\n\t\t\treturn;\n\t\tret = atusb_submit_rx_urb(atusb, urb);\n\t} while (!ret);\n\n\tusb_anchor_urb(urb, &atusb->idle_urbs);\n\tdev_warn_ratelimited(&usb_dev->dev,\n\t\t\t     \"atusb_in: can't allocate/submit URB (%d)\\n\", ret);\n\tschedule_delayed_work(&atusb->work,\n\t\t\t      msecs_to_jiffies(ATUSB_ALLOC_DELAY_MS) + 1);\n}\n\n/* ----- Asynchronous USB -------------------------------------------------- */\n\nstatic void atusb_tx_done(struct atusb *atusb, uint8_t seq)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tuint8_t expect = atusb->tx_ack_seq;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_tx_done (0x%02x/0x%02x)\\n\", seq, expect);\n\tif (seq == expect) {\n\t\t/* TODO check for ifs handling in firmware */\n\t\tieee802154_xmit_complete(atusb->hw, atusb->tx_skb, false);\n\t} else {\n\t\t/* TODO I experience this case when atusb has a tx complete\n\t\t * irq before probing, we should fix the firmware it's an\n\t\t * unlikely case now that seq == expect is then true, but can\n\t\t * happen and fail with a tx_skb = NULL;\n\t\t */\n\t\tieee802154_wake_queue(atusb->hw);\n\t\tif (atusb->tx_skb)\n\t\t\tdev_kfree_skb_irq(atusb->tx_skb);\n\t}\n}\n\nstatic void atusb_in_good(struct urb *urb)\n{\n\tstruct usb_device *usb_dev = urb->dev;\n\tstruct sk_buff *skb = urb->context;\n\tstruct atusb *atusb = SKB_ATUSB(skb);\n\tuint8_t len, lqi;\n\n\tif (!urb->actual_length) {\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: zero-sized URB ?\\n\");\n\t\treturn;\n\t}\n\n\tlen = *skb->data;\n\n\tif (urb->actual_length == 1) {\n\t\tatusb_tx_done(atusb, len);\n\t\treturn;\n\t}\n\n\tif (len + 1 > urb->actual_length - 1) {\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: frame len %d+1 > URB %u-1\\n\",\n\t\t\tlen, urb->actual_length);\n\t\treturn;\n\t}\n\n\tif (!ieee802154_is_valid_psdu_len(len)) {\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: frame corrupted\\n\");\n\t\treturn;\n\t}\n\n\tlqi = skb->data[len + 1];\n\tdev_dbg(&usb_dev->dev, \"atusb_in: rx len %d lqi 0x%02x\\n\", len, lqi);\n\tskb_pull(skb, 1);\t/* remove PHR */\n\tskb_trim(skb, len);\t/* get payload only */\n\tieee802154_rx_irqsafe(atusb->hw, skb, lqi);\n\turb->context = NULL;\t/* skb is gone */\n}\n\nstatic void atusb_in(struct urb *urb)\n{\n\tstruct usb_device *usb_dev = urb->dev;\n\tstruct sk_buff *skb = urb->context;\n\tstruct atusb *atusb = SKB_ATUSB(skb);\n\n\tdev_dbg(&usb_dev->dev, \"atusb_in: status %d len %d\\n\",\n\t\turb->status, urb->actual_length);\n\tif (urb->status) {\n\t\tif (urb->status == -ENOENT) { /* being killed */\n\t\t\tkfree_skb(skb);\n\t\t\turb->context = NULL;\n\t\t\treturn;\n\t\t}\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: URB error %d\\n\", urb->status);\n\t} else {\n\t\tatusb_in_good(urb);\n\t}\n\n\tusb_anchor_urb(urb, &atusb->idle_urbs);\n\tif (!atusb->shutdown)\n\t\tschedule_delayed_work(&atusb->work, 0);\n}\n\n/* ----- URB allocation/deallocation --------------------------------------- */\n\nstatic void atusb_free_urbs(struct atusb *atusb)\n{\n\tstruct urb *urb;\n\n\twhile (1) {\n\t\turb = usb_get_from_anchor(&atusb->idle_urbs);\n\t\tif (!urb)\n\t\t\tbreak;\n\t\tkfree_skb(urb->context);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic int atusb_alloc_urbs(struct atusb *atusb, int n)\n{\n\tstruct urb *urb;\n\n\twhile (n) {\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tatusb_free_urbs(atusb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_anchor_urb(urb, &atusb->idle_urbs);\n\t\tn--;\n\t}\n\treturn 0;\n}\n\n/* ----- IEEE 802.15.4 interface operations -------------------------------- */\n\nstatic void atusb_xmit_complete(struct urb *urb)\n{\n\tdev_dbg(&urb->dev->dev, \"atusb_xmit urb completed\");\n}\n\nstatic int atusb_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_xmit (%d)\\n\", skb->len);\n\tatusb->tx_skb = skb;\n\tatusb->tx_ack_seq++;\n\tatusb->tx_dr.wIndex = cpu_to_le16(atusb->tx_ack_seq);\n\tatusb->tx_dr.wLength = cpu_to_le16(skb->len);\n\n\tusb_fill_control_urb(atusb->tx_urb, usb_dev,\n\t\t\t     usb_sndctrlpipe(usb_dev, 0),\n\t\t\t     (unsigned char *)&atusb->tx_dr, skb->data,\n\t\t\t     skb->len, atusb_xmit_complete, NULL);\n\tret = usb_submit_urb(atusb->tx_urb, GFP_ATOMIC);\n\tdev_dbg(&usb_dev->dev, \"atusb_xmit done (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic int atusb_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret;\n\n\tret = atusb_write_subreg(atusb, SR_CHANNEL, channel);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(1);\t/* @@@ ugly synchronization */\n\treturn 0;\n}\n\nstatic int atusb_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tBUG_ON(!level);\n\t*level = 0xbe;\n\treturn 0;\n}\n\nstatic int atusb_set_hw_addr_filt(struct ieee802154_hw *hw,\n\t\t\t\t  struct ieee802154_hw_addr_filt *filt,\n\t\t\t\t  unsigned long changed)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct device *dev = &atusb->usb_dev->dev;\n\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tu16 addr = le16_to_cpu(filt->short_addr);\n\n\t\tdev_vdbg(dev, \"atusb_set_hw_addr_filt called for saddr\\n\");\n\t\tatusb_write_reg(atusb, RG_SHORT_ADDR_0, addr);\n\t\tatusb_write_reg(atusb, RG_SHORT_ADDR_1, addr >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tu16 pan = le16_to_cpu(filt->pan_id);\n\n\t\tdev_vdbg(dev, \"atusb_set_hw_addr_filt called for pan id\\n\");\n\t\tatusb_write_reg(atusb, RG_PAN_ID_0, pan);\n\t\tatusb_write_reg(atusb, RG_PAN_ID_1, pan >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tu8 i, addr[IEEE802154_EXTENDED_ADDR_LEN];\n\n\t\tmemcpy(addr, &filt->ieee_addr, IEEE802154_EXTENDED_ADDR_LEN);\n\t\tdev_vdbg(dev, \"atusb_set_hw_addr_filt called for IEEE addr\\n\");\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tatusb_write_reg(atusb, RG_IEEE_ADDR_0 + i, addr[i]);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANC_CHANGED) {\n\t\tdev_vdbg(dev,\n\t\t\t \"atusb_set_hw_addr_filt called for panc change\\n\");\n\t\tif (filt->pan_coord)\n\t\t\tatusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 1);\n\t\telse\n\t\t\tatusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 0);\n\t}\n\n\treturn atusb_get_and_clear_error(atusb);\n}\n\nstatic int atusb_start(struct ieee802154_hw *hw)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_start\\n\");\n\tschedule_delayed_work(&atusb->work, 0);\n\tatusb_command(atusb, ATUSB_RX_MODE, 1);\n\tret = atusb_get_and_clear_error(atusb);\n\tif (ret < 0)\n\t\tusb_kill_anchored_urbs(&atusb->idle_urbs);\n\treturn ret;\n}\n\nstatic void atusb_stop(struct ieee802154_hw *hw)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_stop\\n\");\n\tusb_kill_anchored_urbs(&atusb->idle_urbs);\n\tatusb_command(atusb, ATUSB_RX_MODE, 0);\n\tatusb_get_and_clear_error(atusb);\n}\n\n#define ATUSB_MAX_TX_POWERS 0xF\nstatic const s32 atusb_powers[ATUSB_MAX_TX_POWERS + 1] = {\n\t300, 280, 230, 180, 130, 70, 0, -100, -200, -300, -400, -500, -700,\n\t-900, -1200, -1700,\n};\n\nstatic int\natusb_set_txpower(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct atusb *atusb = hw->priv;\n\tu32 i;\n\n\tfor (i = 0; i < hw->phy->supported.tx_powers_size; i++) {\n\t\tif (hw->phy->supported.tx_powers[i] == mbm)\n\t\t\treturn atusb_write_subreg(atusb, SR_TX_PWR_23X, i);\n\t}\n\n\treturn -EINVAL;\n}\n\n#define ATUSB_MAX_ED_LEVELS 0xF\nstatic const s32 atusb_ed_levels[ATUSB_MAX_ED_LEVELS + 1] = {\n\t-9100, -8900, -8700, -8500, -8300, -8100, -7900, -7700, -7500, -7300,\n\t-7100, -6900, -6700, -6500, -6300, -6100,\n};\n\nstatic int\natusb_set_cca_mode(struct ieee802154_hw *hw, const struct wpan_phy_cca *cca)\n{\n\tstruct atusb *atusb = hw->priv;\n\tu8 val;\n\n\t/* mapping 802.15.4 to driver spec */\n\tswitch (cca->mode) {\n\tcase NL802154_CCA_ENERGY:\n\t\tval = 1;\n\t\tbreak;\n\tcase NL802154_CCA_CARRIER:\n\t\tval = 2;\n\t\tbreak;\n\tcase NL802154_CCA_ENERGY_CARRIER:\n\t\tswitch (cca->opt) {\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_AND:\n\t\t\tval = 3;\n\t\t\tbreak;\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_OR:\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn atusb_write_subreg(atusb, SR_CCA_MODE, val);\n}\n\nstatic int\natusb_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct atusb *atusb = hw->priv;\n\tu32 i;\n\n\tfor (i = 0; i < hw->phy->supported.cca_ed_levels_size; i++) {\n\t\tif (hw->phy->supported.cca_ed_levels[i] == mbm)\n\t\t\treturn atusb_write_subreg(atusb, SR_CCA_ED_THRES, i);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\natusb_set_csma_params(struct ieee802154_hw *hw, u8 min_be, u8 max_be, u8 retries)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret;\n\n\tret = atusb_write_subreg(atusb, SR_MIN_BE, min_be);\n\tif (ret)\n\t\treturn ret;\n\n\tret = atusb_write_subreg(atusb, SR_MAX_BE, max_be);\n\tif (ret)\n\t\treturn ret;\n\n\treturn atusb_write_subreg(atusb, SR_MAX_CSMA_RETRIES, retries);\n}\n\nstatic int\natusb_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct device *dev = &atusb->usb_dev->dev;\n\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 3) {\n\t\tdev_info(dev, \"Automatic frame retransmission is only available from \"\n\t\t\t\"firmware version 0.3. Please update if you want this feature.\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn atusb_write_subreg(atusb, SR_MAX_FRAME_RETRIES, retries);\n}\n\nstatic int\natusb_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret;\n\n\tif (on) {\n\t\tret = atusb_write_subreg(atusb, SR_AACK_DIS_ACK, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = atusb_write_subreg(atusb, SR_AACK_PROM_MODE, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = atusb_write_subreg(atusb, SR_AACK_PROM_MODE, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = atusb_write_subreg(atusb, SR_AACK_DIS_ACK, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ieee802154_ops atusb_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.xmit_async\t\t= atusb_xmit,\n\t.ed\t\t\t= atusb_ed,\n\t.set_channel\t\t= atusb_channel,\n\t.start\t\t\t= atusb_start,\n\t.stop\t\t\t= atusb_stop,\n\t.set_hw_addr_filt\t= atusb_set_hw_addr_filt,\n\t.set_txpower\t\t= atusb_set_txpower,\n\t.set_cca_mode\t\t= atusb_set_cca_mode,\n\t.set_cca_ed_level\t= atusb_set_cca_ed_level,\n\t.set_csma_params\t= atusb_set_csma_params,\n\t.set_frame_retries\t= atusb_set_frame_retries,\n\t.set_promiscuous_mode\t= atusb_set_promiscuous_mode,\n};\n\n/* ----- Firmware and chip version information ----------------------------- */\n\nstatic int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\treturn ret;\n}\n\nstatic int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar build[ATUSB_BUILD_SIZE + 1];\n\tint ret;\n\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\n\treturn ret;\n}\n\nstatic int atusb_get_and_show_chip(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tuint8_t man_id_0, man_id_1, part_num, version_num;\n\tconst char *chip;\n\n\tman_id_0 = atusb_read_reg(atusb, RG_MAN_ID_0);\n\tman_id_1 = atusb_read_reg(atusb, RG_MAN_ID_1);\n\tpart_num = atusb_read_reg(atusb, RG_PART_NUM);\n\tversion_num = atusb_read_reg(atusb, RG_VERSION_NUM);\n\n\tif (atusb->err)\n\t\treturn atusb->err;\n\n\tif ((man_id_1 << 8 | man_id_0) != ATUSB_JEDEC_ATMEL) {\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"non-Atmel transceiver xxxx%02x%02x\\n\",\n\t\t\tman_id_1, man_id_0);\n\t\tgoto fail;\n\t}\n\n\tswitch (part_num) {\n\tcase 2:\n\t\tchip = \"AT86RF230\";\n\t\tbreak;\n\tcase 3:\n\t\tchip = \"AT86RF231\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"unexpected transceiver, part 0x%02x version 0x%02x\\n\",\n\t\t\tpart_num, version_num);\n\t\tgoto fail;\n\t}\n\n\tdev_info(&usb_dev->dev, \"ATUSB: %s version %d\\n\", chip, version_num);\n\n\treturn 0;\n\nfail:\n\tatusb->err = -ENODEV;\n\treturn -ENODEV;\n}\n\nstatic int atusb_set_extended_addr(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[IEEE802154_EXTENDED_ADDR_LEN];\n\t__le64 extended_addr;\n\tu64 addr;\n\tint ret;\n\n\t/* Firmware versions before 0.3 do not support the EUI64_READ command.\n\t * Just use a random address and be done */\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 3) {\n\t\tieee802154_random_extended_addr(&atusb->hw->phy->perm_extended_addr);\n\t\treturn 0;\n\t}\n\n\t/* Firmware is new enough so we fetch the address from EEPROM */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_EUI64_READ, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, IEEE802154_EXTENDED_ADDR_LEN, 1000);\n\tif (ret < 0)\n\t\tdev_err(&usb_dev->dev, \"failed to fetch extended address\\n\");\n\n\tmemcpy(&extended_addr, buffer, IEEE802154_EXTENDED_ADDR_LEN);\n\t/* Check if read address is not empty and the unicast bit is set correctly */\n\tif (!ieee802154_is_valid_extended_unicast_addr(extended_addr)) {\n\t\tdev_info(&usb_dev->dev, \"no permanent extended address found, random address set\\n\");\n\t\tieee802154_random_extended_addr(&atusb->hw->phy->perm_extended_addr);\n\t} else {\n\t\tatusb->hw->phy->perm_extended_addr = extended_addr;\n\t\taddr = swab64((__force u64)atusb->hw->phy->perm_extended_addr);\n\t\tdev_info(&usb_dev->dev, \"Read permanent extended address %8phC from device\\n\",\n\t\t\t&addr);\n\t}\n\n\treturn ret;\n}\n\n/* ----- Setup ------------------------------------------------------------- */\n\nstatic int atusb_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(interface);\n\tstruct ieee802154_hw *hw;\n\tstruct atusb *atusb = NULL;\n\tint ret = -ENOMEM;\n\n\thw = ieee802154_alloc_hw(sizeof(struct atusb), &atusb_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tatusb = hw->priv;\n\tatusb->hw = hw;\n\tatusb->usb_dev = usb_get_dev(usb_dev);\n\tusb_set_intfdata(interface, atusb);\n\n\tatusb->shutdown = 0;\n\tatusb->err = 0;\n\tINIT_DELAYED_WORK(&atusb->work, atusb_work_urbs);\n\tinit_usb_anchor(&atusb->idle_urbs);\n\tinit_usb_anchor(&atusb->rx_urbs);\n\n\tif (atusb_alloc_urbs(atusb, ATUSB_NUM_RX_URBS))\n\t\tgoto fail;\n\n\tatusb->tx_dr.bRequestType = ATUSB_REQ_TO_DEV;\n\tatusb->tx_dr.bRequest = ATUSB_TX;\n\tatusb->tx_dr.wValue = cpu_to_le16(0);\n\n\tatusb->tx_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!atusb->tx_urb)\n\t\tgoto fail;\n\n\thw->parent = &usb_dev->dev;\n\thw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\n\t\t    IEEE802154_HW_PROMISCUOUS | IEEE802154_HW_CSMA_PARAMS |\n\t\t    IEEE802154_HW_FRAME_RETRIES;\n\n\thw->phy->flags = WPAN_PHY_FLAG_TXPOWER | WPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\t\t WPAN_PHY_FLAG_CCA_MODE;\n\n\thw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\n\t\tBIT(NL802154_CCA_CARRIER) | BIT(NL802154_CCA_ENERGY_CARRIER);\n\thw->phy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND) |\n\t\tBIT(NL802154_CCA_OPT_ENERGY_CARRIER_OR);\n\n\thw->phy->supported.cca_ed_levels = atusb_ed_levels;\n\thw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(atusb_ed_levels);\n\n\thw->phy->cca.mode = NL802154_CCA_ENERGY;\n\n\thw->phy->current_page = 0;\n\thw->phy->current_channel = 11;\t/* reset default */\n\thw->phy->supported.channels[0] = 0x7FFF800;\n\thw->phy->supported.tx_powers = atusb_powers;\n\thw->phy->supported.tx_powers_size = ARRAY_SIZE(atusb_powers);\n\thw->phy->transmit_power = hw->phy->supported.tx_powers[0];\n\thw->phy->cca_ed_level = hw->phy->supported.cca_ed_levels[7];\n\n\tatusb_command(atusb, ATUSB_RF_RESET, 0);\n\tatusb_get_and_show_chip(atusb);\n\tatusb_get_and_show_revision(atusb);\n\tatusb_get_and_show_build(atusb);\n\tatusb_set_extended_addr(atusb);\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (ret) {\n\t\tdev_err(&atusb->usb_dev->dev,\n\t\t\t\"%s: initialization failed, error = %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto fail;\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* If we just powered on, we're now in P_ON and need to enter TRX_OFF\n\t * explicitly. Any resets after that will send us straight to TRX_OFF,\n\t * making the command below redundant.\n\t */\n\tatusb_write_reg(atusb, RG_TRX_STATE, STATE_FORCE_TRX_OFF);\n\tmsleep(1);\t/* reset => TRX_OFF, tTR13 = 37 us */\n\n#if 0\n\t/* Calculating the maximum time available to empty the frame buffer\n\t * on reception:\n\t *\n\t * According to [1], the inter-frame gap is\n\t * R * 20 * 16 us + 128 us\n\t * where R is a random number from 0 to 7. Furthermore, we have 20 bit\n\t * times (80 us at 250 kbps) of SHR of the next frame before the\n\t * transceiver begins storing data in the frame buffer.\n\t *\n\t * This yields a minimum time of 208 us between the last data of a\n\t * frame and the first data of the next frame. This time is further\n\t * reduced by interrupt latency in the atusb firmware.\n\t *\n\t * atusb currently needs about 500 us to retrieve a maximum-sized\n\t * frame. We therefore have to allow reception of a new frame to begin\n\t * while we retrieve the previous frame.\n\t *\n\t * [1] \"JN-AN-1035 Calculating data rates in an IEEE 802.15.4-based\n\t *      network\", Jennic 2006.\n\t *     http://www.jennic.com/download_file.php?supportFile=JN-AN-1035%20Calculating%20802-15-4%20Data%20Rates-1v0.pdf\n\t */\n\n\tatusb_write_subreg(atusb, SR_RX_SAFE_MODE, 1);\n#endif\n\tatusb_write_reg(atusb, RG_IRQ_MASK, 0xff);\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (!ret)\n\t\treturn 0;\n\n\tdev_err(&atusb->usb_dev->dev,\n\t\t\"%s: setup failed, error = %d\\n\",\n\t\t__func__, ret);\n\n\tieee802154_unregister_hw(hw);\nfail:\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\tusb_put_dev(usb_dev);\n\tieee802154_free_hw(hw);\n\treturn ret;\n}\n\nstatic void atusb_disconnect(struct usb_interface *interface)\n{\n\tstruct atusb *atusb = usb_get_intfdata(interface);\n\n\tdev_dbg(&atusb->usb_dev->dev, \"atusb_disconnect\\n\");\n\n\tatusb->shutdown = 1;\n\tcancel_delayed_work_sync(&atusb->work);\n\n\tusb_kill_anchored_urbs(&atusb->rx_urbs);\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\n\tieee802154_unregister_hw(atusb->hw);\n\n\tieee802154_free_hw(atusb->hw);\n\n\tusb_set_intfdata(interface, NULL);\n\tusb_put_dev(atusb->usb_dev);\n\n\tpr_debug(\"atusb_disconnect done\\n\");\n}\n\n/* The devices we work with */\nstatic const struct usb_device_id atusb_device_table[] = {\n\t{\n\t\t.match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE |\n\t\t\t\t\t  USB_DEVICE_ID_MATCH_INT_INFO,\n\t\t.idVendor\t\t= ATUSB_VENDOR_ID,\n\t\t.idProduct\t\t= ATUSB_PRODUCT_ID,\n\t\t.bInterfaceClass\t= USB_CLASS_VENDOR_SPEC\n\t},\n\t/* end with null element */\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, atusb_device_table);\n\nstatic struct usb_driver atusb_driver = {\n\t.name\t\t= \"atusb\",\n\t.probe\t\t= atusb_probe,\n\t.disconnect\t= atusb_disconnect,\n\t.id_table\t= atusb_device_table,\n};\nmodule_usb_driver(atusb_driver);\n\nMODULE_AUTHOR(\"Alexander Aring <alex.aring@gmail.com>\");\nMODULE_AUTHOR(\"Richard Sharpe <realrichardsharpe@gmail.com>\");\nMODULE_AUTHOR(\"Stefan Schmidt <stefan@datenfreihafen.org>\");\nMODULE_AUTHOR(\"Werner Almesberger <werner@almesberger.net>\");\nMODULE_DESCRIPTION(\"ATUSB IEEE 802.15.4 Driver\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * atusb.c - Driver for the ATUSB IEEE 802.15.4 dongle\n *\n * Written 2013 by Werner Almesberger <werner@almesberger.net>\n *\n * Copyright (c) 2015 - 2016 Stefan Schmidt <stefan@datenfreihafen.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, version 2\n *\n * Based on at86rf230.c and spi_atusb.c.\n * at86rf230.c is\n * Copyright (C) 2009 Siemens AG\n * Written by: Dmitry Eremin-Solenikov <dmitry.baryshkov@siemens.com>\n *\n * spi_atusb.c is\n * Copyright (c) 2011 Richard Sharpe <realrichardsharpe@gmail.com>\n * Copyright (c) 2011 Stefan Schmidt <stefan@datenfreihafen.org>\n * Copyright (c) 2011 Werner Almesberger <werner@almesberger.net>\n *\n * USB initialization is\n * Copyright (c) 2013 Alexander Aring <alex.aring@gmail.com>\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/usb.h>\n#include <linux/skbuff.h>\n\n#include <net/cfg802154.h>\n#include <net/mac802154.h>\n\n#include \"at86rf230.h\"\n#include \"atusb.h\"\n\n#define ATUSB_JEDEC_ATMEL\t0x1f\t/* JEDEC manufacturer ID */\n\n#define ATUSB_NUM_RX_URBS\t4\t/* allow for a bit of local latency */\n#define ATUSB_ALLOC_DELAY_MS\t100\t/* delay after failed allocation */\n#define ATUSB_TX_TIMEOUT_MS\t200\t/* on the air timeout */\n\nstruct atusb {\n\tstruct ieee802154_hw *hw;\n\tstruct usb_device *usb_dev;\n\tint shutdown;\t\t\t/* non-zero if shutting down */\n\tint err;\t\t\t/* set by first error */\n\n\t/* RX variables */\n\tstruct delayed_work work;\t/* memory allocations */\n\tstruct usb_anchor idle_urbs;\t/* URBs waiting to be submitted */\n\tstruct usb_anchor rx_urbs;\t/* URBs waiting for reception */\n\n\t/* TX variables */\n\tstruct usb_ctrlrequest tx_dr;\n\tstruct urb *tx_urb;\n\tstruct sk_buff *tx_skb;\n\tuint8_t tx_ack_seq;\t\t/* current TX ACK sequence number */\n\n\t/* Firmware variable */\n\tunsigned char fw_ver_maj;\t/* Firmware major version number */\n\tunsigned char fw_ver_min;\t/* Firmware minor version number */\n\tunsigned char fw_hw_type;\t/* Firmware hardware type */\n};\n\n/* ----- USB commands without data ----------------------------------------- */\n\n/* To reduce the number of error checks in the code, we record the first error\n * in atusb->err and reject all subsequent requests until the error is cleared.\n */\n\nstatic int atusb_control_msg(struct atusb *atusb, unsigned int pipe,\n\t\t\t     __u8 request, __u8 requesttype,\n\t\t\t     __u16 value, __u16 index,\n\t\t\t     void *data, __u16 size, int timeout)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\n\tif (atusb->err)\n\t\treturn atusb->err;\n\n\tret = usb_control_msg(usb_dev, pipe, request, requesttype,\n\t\t\t      value, index, data, size, timeout);\n\tif (ret < 0) {\n\t\tatusb->err = ret;\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"atusb_control_msg: req 0x%02x val 0x%x idx 0x%x, error %d\\n\",\n\t\t\trequest, value, index, ret);\n\t}\n\treturn ret;\n}\n\nstatic int atusb_command(struct atusb *atusb, uint8_t cmd, uint8_t arg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_command: cmd = 0x%x\\n\", cmd);\n\treturn atusb_control_msg(atusb, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t\t cmd, ATUSB_REQ_TO_DEV, arg, 0, NULL, 0, 1000);\n}\n\nstatic int atusb_write_reg(struct atusb *atusb, uint8_t reg, uint8_t value)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_write_reg: 0x%02x <- 0x%02x\\n\",\n\t\treg, value);\n\treturn atusb_control_msg(atusb, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t\t ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t\t value, reg, NULL, 0, 1000);\n}\n\nstatic int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t *buffer;\n\tuint8_t value;\n\n\tbuffer = kmalloc(1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, buffer, 1, 1000);\n\n\tif (ret >= 0) {\n\t\tvalue = buffer[0];\n\t\tkfree(buffer);\n\t\treturn value;\n\t} else {\n\t\tkfree(buffer);\n\t\treturn ret;\n\t}\n}\n\nstatic int atusb_write_subreg(struct atusb *atusb, uint8_t reg, uint8_t mask,\n\t\t\t      uint8_t shift, uint8_t value)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tuint8_t orig, tmp;\n\tint ret = 0;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_write_subreg: 0x%02x <- 0x%02x\\n\",\n\t\treg, value);\n\n\torig = atusb_read_reg(atusb, reg);\n\n\t/* Write the value only into that part of the register which is allowed\n\t * by the mask. All other bits stay as before.\n\t */\n\ttmp = orig & ~mask;\n\ttmp |= (value << shift) & mask;\n\n\tif (tmp != orig)\n\t\tret = atusb_write_reg(atusb, reg, tmp);\n\n\treturn ret;\n}\n\nstatic int atusb_get_and_clear_error(struct atusb *atusb)\n{\n\tint err = atusb->err;\n\n\tatusb->err = 0;\n\treturn err;\n}\n\n/* ----- skb allocation ---------------------------------------------------- */\n\n#define MAX_PSDU\t127\n#define MAX_RX_XFER\t(1 + MAX_PSDU + 2 + 1)\t/* PHR+PSDU+CRC+LQI */\n\n#define SKB_ATUSB(skb)\t(*(struct atusb **)(skb)->cb)\n\nstatic void atusb_in(struct urb *urb);\n\nstatic int atusb_submit_rx_urb(struct atusb *atusb, struct urb *urb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tstruct sk_buff *skb = urb->context;\n\tint ret;\n\n\tif (!skb) {\n\t\tskb = alloc_skb(MAX_RX_XFER, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tdev_warn_ratelimited(&usb_dev->dev,\n\t\t\t\t\t     \"atusb_in: can't allocate skb\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_RX_XFER);\n\t\tSKB_ATUSB(skb) = atusb;\n\t}\n\n\tusb_fill_bulk_urb(urb, usb_dev, usb_rcvbulkpipe(usb_dev, 1),\n\t\t\t  skb->data, MAX_RX_XFER, atusb_in, skb);\n\tusb_anchor_urb(urb, &atusb->rx_urbs);\n\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tkfree_skb(skb);\n\t\turb->context = NULL;\n\t}\n\treturn ret;\n}\n\nstatic void atusb_work_urbs(struct work_struct *work)\n{\n\tstruct atusb *atusb =\n\t    container_of(to_delayed_work(work), struct atusb, work);\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tstruct urb *urb;\n\tint ret;\n\n\tif (atusb->shutdown)\n\t\treturn;\n\n\tdo {\n\t\turb = usb_get_from_anchor(&atusb->idle_urbs);\n\t\tif (!urb)\n\t\t\treturn;\n\t\tret = atusb_submit_rx_urb(atusb, urb);\n\t} while (!ret);\n\n\tusb_anchor_urb(urb, &atusb->idle_urbs);\n\tdev_warn_ratelimited(&usb_dev->dev,\n\t\t\t     \"atusb_in: can't allocate/submit URB (%d)\\n\", ret);\n\tschedule_delayed_work(&atusb->work,\n\t\t\t      msecs_to_jiffies(ATUSB_ALLOC_DELAY_MS) + 1);\n}\n\n/* ----- Asynchronous USB -------------------------------------------------- */\n\nstatic void atusb_tx_done(struct atusb *atusb, uint8_t seq)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tuint8_t expect = atusb->tx_ack_seq;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_tx_done (0x%02x/0x%02x)\\n\", seq, expect);\n\tif (seq == expect) {\n\t\t/* TODO check for ifs handling in firmware */\n\t\tieee802154_xmit_complete(atusb->hw, atusb->tx_skb, false);\n\t} else {\n\t\t/* TODO I experience this case when atusb has a tx complete\n\t\t * irq before probing, we should fix the firmware it's an\n\t\t * unlikely case now that seq == expect is then true, but can\n\t\t * happen and fail with a tx_skb = NULL;\n\t\t */\n\t\tieee802154_wake_queue(atusb->hw);\n\t\tif (atusb->tx_skb)\n\t\t\tdev_kfree_skb_irq(atusb->tx_skb);\n\t}\n}\n\nstatic void atusb_in_good(struct urb *urb)\n{\n\tstruct usb_device *usb_dev = urb->dev;\n\tstruct sk_buff *skb = urb->context;\n\tstruct atusb *atusb = SKB_ATUSB(skb);\n\tuint8_t len, lqi;\n\n\tif (!urb->actual_length) {\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: zero-sized URB ?\\n\");\n\t\treturn;\n\t}\n\n\tlen = *skb->data;\n\n\tif (urb->actual_length == 1) {\n\t\tatusb_tx_done(atusb, len);\n\t\treturn;\n\t}\n\n\tif (len + 1 > urb->actual_length - 1) {\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: frame len %d+1 > URB %u-1\\n\",\n\t\t\tlen, urb->actual_length);\n\t\treturn;\n\t}\n\n\tif (!ieee802154_is_valid_psdu_len(len)) {\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: frame corrupted\\n\");\n\t\treturn;\n\t}\n\n\tlqi = skb->data[len + 1];\n\tdev_dbg(&usb_dev->dev, \"atusb_in: rx len %d lqi 0x%02x\\n\", len, lqi);\n\tskb_pull(skb, 1);\t/* remove PHR */\n\tskb_trim(skb, len);\t/* get payload only */\n\tieee802154_rx_irqsafe(atusb->hw, skb, lqi);\n\turb->context = NULL;\t/* skb is gone */\n}\n\nstatic void atusb_in(struct urb *urb)\n{\n\tstruct usb_device *usb_dev = urb->dev;\n\tstruct sk_buff *skb = urb->context;\n\tstruct atusb *atusb = SKB_ATUSB(skb);\n\n\tdev_dbg(&usb_dev->dev, \"atusb_in: status %d len %d\\n\",\n\t\turb->status, urb->actual_length);\n\tif (urb->status) {\n\t\tif (urb->status == -ENOENT) { /* being killed */\n\t\t\tkfree_skb(skb);\n\t\t\turb->context = NULL;\n\t\t\treturn;\n\t\t}\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: URB error %d\\n\", urb->status);\n\t} else {\n\t\tatusb_in_good(urb);\n\t}\n\n\tusb_anchor_urb(urb, &atusb->idle_urbs);\n\tif (!atusb->shutdown)\n\t\tschedule_delayed_work(&atusb->work, 0);\n}\n\n/* ----- URB allocation/deallocation --------------------------------------- */\n\nstatic void atusb_free_urbs(struct atusb *atusb)\n{\n\tstruct urb *urb;\n\n\twhile (1) {\n\t\turb = usb_get_from_anchor(&atusb->idle_urbs);\n\t\tif (!urb)\n\t\t\tbreak;\n\t\tkfree_skb(urb->context);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic int atusb_alloc_urbs(struct atusb *atusb, int n)\n{\n\tstruct urb *urb;\n\n\twhile (n) {\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tatusb_free_urbs(atusb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_anchor_urb(urb, &atusb->idle_urbs);\n\t\tn--;\n\t}\n\treturn 0;\n}\n\n/* ----- IEEE 802.15.4 interface operations -------------------------------- */\n\nstatic void atusb_xmit_complete(struct urb *urb)\n{\n\tdev_dbg(&urb->dev->dev, \"atusb_xmit urb completed\");\n}\n\nstatic int atusb_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_xmit (%d)\\n\", skb->len);\n\tatusb->tx_skb = skb;\n\tatusb->tx_ack_seq++;\n\tatusb->tx_dr.wIndex = cpu_to_le16(atusb->tx_ack_seq);\n\tatusb->tx_dr.wLength = cpu_to_le16(skb->len);\n\n\tusb_fill_control_urb(atusb->tx_urb, usb_dev,\n\t\t\t     usb_sndctrlpipe(usb_dev, 0),\n\t\t\t     (unsigned char *)&atusb->tx_dr, skb->data,\n\t\t\t     skb->len, atusb_xmit_complete, NULL);\n\tret = usb_submit_urb(atusb->tx_urb, GFP_ATOMIC);\n\tdev_dbg(&usb_dev->dev, \"atusb_xmit done (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic int atusb_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret;\n\n\tret = atusb_write_subreg(atusb, SR_CHANNEL, channel);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(1);\t/* @@@ ugly synchronization */\n\treturn 0;\n}\n\nstatic int atusb_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tBUG_ON(!level);\n\t*level = 0xbe;\n\treturn 0;\n}\n\nstatic int atusb_set_hw_addr_filt(struct ieee802154_hw *hw,\n\t\t\t\t  struct ieee802154_hw_addr_filt *filt,\n\t\t\t\t  unsigned long changed)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct device *dev = &atusb->usb_dev->dev;\n\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tu16 addr = le16_to_cpu(filt->short_addr);\n\n\t\tdev_vdbg(dev, \"atusb_set_hw_addr_filt called for saddr\\n\");\n\t\tatusb_write_reg(atusb, RG_SHORT_ADDR_0, addr);\n\t\tatusb_write_reg(atusb, RG_SHORT_ADDR_1, addr >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tu16 pan = le16_to_cpu(filt->pan_id);\n\n\t\tdev_vdbg(dev, \"atusb_set_hw_addr_filt called for pan id\\n\");\n\t\tatusb_write_reg(atusb, RG_PAN_ID_0, pan);\n\t\tatusb_write_reg(atusb, RG_PAN_ID_1, pan >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tu8 i, addr[IEEE802154_EXTENDED_ADDR_LEN];\n\n\t\tmemcpy(addr, &filt->ieee_addr, IEEE802154_EXTENDED_ADDR_LEN);\n\t\tdev_vdbg(dev, \"atusb_set_hw_addr_filt called for IEEE addr\\n\");\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tatusb_write_reg(atusb, RG_IEEE_ADDR_0 + i, addr[i]);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANC_CHANGED) {\n\t\tdev_vdbg(dev,\n\t\t\t \"atusb_set_hw_addr_filt called for panc change\\n\");\n\t\tif (filt->pan_coord)\n\t\t\tatusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 1);\n\t\telse\n\t\t\tatusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 0);\n\t}\n\n\treturn atusb_get_and_clear_error(atusb);\n}\n\nstatic int atusb_start(struct ieee802154_hw *hw)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_start\\n\");\n\tschedule_delayed_work(&atusb->work, 0);\n\tatusb_command(atusb, ATUSB_RX_MODE, 1);\n\tret = atusb_get_and_clear_error(atusb);\n\tif (ret < 0)\n\t\tusb_kill_anchored_urbs(&atusb->idle_urbs);\n\treturn ret;\n}\n\nstatic void atusb_stop(struct ieee802154_hw *hw)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\n\tdev_dbg(&usb_dev->dev, \"atusb_stop\\n\");\n\tusb_kill_anchored_urbs(&atusb->idle_urbs);\n\tatusb_command(atusb, ATUSB_RX_MODE, 0);\n\tatusb_get_and_clear_error(atusb);\n}\n\n#define ATUSB_MAX_TX_POWERS 0xF\nstatic const s32 atusb_powers[ATUSB_MAX_TX_POWERS + 1] = {\n\t300, 280, 230, 180, 130, 70, 0, -100, -200, -300, -400, -500, -700,\n\t-900, -1200, -1700,\n};\n\nstatic int\natusb_set_txpower(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct atusb *atusb = hw->priv;\n\tu32 i;\n\n\tfor (i = 0; i < hw->phy->supported.tx_powers_size; i++) {\n\t\tif (hw->phy->supported.tx_powers[i] == mbm)\n\t\t\treturn atusb_write_subreg(atusb, SR_TX_PWR_23X, i);\n\t}\n\n\treturn -EINVAL;\n}\n\n#define ATUSB_MAX_ED_LEVELS 0xF\nstatic const s32 atusb_ed_levels[ATUSB_MAX_ED_LEVELS + 1] = {\n\t-9100, -8900, -8700, -8500, -8300, -8100, -7900, -7700, -7500, -7300,\n\t-7100, -6900, -6700, -6500, -6300, -6100,\n};\n\nstatic int\natusb_set_cca_mode(struct ieee802154_hw *hw, const struct wpan_phy_cca *cca)\n{\n\tstruct atusb *atusb = hw->priv;\n\tu8 val;\n\n\t/* mapping 802.15.4 to driver spec */\n\tswitch (cca->mode) {\n\tcase NL802154_CCA_ENERGY:\n\t\tval = 1;\n\t\tbreak;\n\tcase NL802154_CCA_CARRIER:\n\t\tval = 2;\n\t\tbreak;\n\tcase NL802154_CCA_ENERGY_CARRIER:\n\t\tswitch (cca->opt) {\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_AND:\n\t\t\tval = 3;\n\t\t\tbreak;\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_OR:\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn atusb_write_subreg(atusb, SR_CCA_MODE, val);\n}\n\nstatic int\natusb_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct atusb *atusb = hw->priv;\n\tu32 i;\n\n\tfor (i = 0; i < hw->phy->supported.cca_ed_levels_size; i++) {\n\t\tif (hw->phy->supported.cca_ed_levels[i] == mbm)\n\t\t\treturn atusb_write_subreg(atusb, SR_CCA_ED_THRES, i);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\natusb_set_csma_params(struct ieee802154_hw *hw, u8 min_be, u8 max_be, u8 retries)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret;\n\n\tret = atusb_write_subreg(atusb, SR_MIN_BE, min_be);\n\tif (ret)\n\t\treturn ret;\n\n\tret = atusb_write_subreg(atusb, SR_MAX_BE, max_be);\n\tif (ret)\n\t\treturn ret;\n\n\treturn atusb_write_subreg(atusb, SR_MAX_CSMA_RETRIES, retries);\n}\n\nstatic int\natusb_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct device *dev = &atusb->usb_dev->dev;\n\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 3) {\n\t\tdev_info(dev, \"Automatic frame retransmission is only available from \"\n\t\t\t\"firmware version 0.3. Please update if you want this feature.\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn atusb_write_subreg(atusb, SR_MAX_FRAME_RETRIES, retries);\n}\n\nstatic int\natusb_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret;\n\n\tif (on) {\n\t\tret = atusb_write_subreg(atusb, SR_AACK_DIS_ACK, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = atusb_write_subreg(atusb, SR_AACK_PROM_MODE, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = atusb_write_subreg(atusb, SR_AACK_PROM_MODE, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = atusb_write_subreg(atusb, SR_AACK_DIS_ACK, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ieee802154_ops atusb_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.xmit_async\t\t= atusb_xmit,\n\t.ed\t\t\t= atusb_ed,\n\t.set_channel\t\t= atusb_channel,\n\t.start\t\t\t= atusb_start,\n\t.stop\t\t\t= atusb_stop,\n\t.set_hw_addr_filt\t= atusb_set_hw_addr_filt,\n\t.set_txpower\t\t= atusb_set_txpower,\n\t.set_cca_mode\t\t= atusb_set_cca_mode,\n\t.set_cca_ed_level\t= atusb_set_cca_ed_level,\n\t.set_csma_params\t= atusb_set_csma_params,\n\t.set_frame_retries\t= atusb_set_frame_retries,\n\t.set_promiscuous_mode\t= atusb_set_promiscuous_mode,\n};\n\n/* ----- Firmware and chip version information ----------------------------- */\n\nstatic int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}\n\nstatic int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar *build;\n\tint ret;\n\n\tbuild = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);\n\tif (!build)\n\t\treturn -ENOMEM;\n\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\n\tkfree(build);\n\treturn ret;\n}\n\nstatic int atusb_get_and_show_chip(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tuint8_t man_id_0, man_id_1, part_num, version_num;\n\tconst char *chip;\n\n\tman_id_0 = atusb_read_reg(atusb, RG_MAN_ID_0);\n\tman_id_1 = atusb_read_reg(atusb, RG_MAN_ID_1);\n\tpart_num = atusb_read_reg(atusb, RG_PART_NUM);\n\tversion_num = atusb_read_reg(atusb, RG_VERSION_NUM);\n\n\tif (atusb->err)\n\t\treturn atusb->err;\n\n\tif ((man_id_1 << 8 | man_id_0) != ATUSB_JEDEC_ATMEL) {\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"non-Atmel transceiver xxxx%02x%02x\\n\",\n\t\t\tman_id_1, man_id_0);\n\t\tgoto fail;\n\t}\n\n\tswitch (part_num) {\n\tcase 2:\n\t\tchip = \"AT86RF230\";\n\t\tbreak;\n\tcase 3:\n\t\tchip = \"AT86RF231\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"unexpected transceiver, part 0x%02x version 0x%02x\\n\",\n\t\t\tpart_num, version_num);\n\t\tgoto fail;\n\t}\n\n\tdev_info(&usb_dev->dev, \"ATUSB: %s version %d\\n\", chip, version_num);\n\n\treturn 0;\n\nfail:\n\tatusb->err = -ENODEV;\n\treturn -ENODEV;\n}\n\nstatic int atusb_set_extended_addr(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[IEEE802154_EXTENDED_ADDR_LEN];\n\t__le64 extended_addr;\n\tu64 addr;\n\tint ret;\n\n\t/* Firmware versions before 0.3 do not support the EUI64_READ command.\n\t * Just use a random address and be done */\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 3) {\n\t\tieee802154_random_extended_addr(&atusb->hw->phy->perm_extended_addr);\n\t\treturn 0;\n\t}\n\n\t/* Firmware is new enough so we fetch the address from EEPROM */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_EUI64_READ, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, IEEE802154_EXTENDED_ADDR_LEN, 1000);\n\tif (ret < 0)\n\t\tdev_err(&usb_dev->dev, \"failed to fetch extended address\\n\");\n\n\tmemcpy(&extended_addr, buffer, IEEE802154_EXTENDED_ADDR_LEN);\n\t/* Check if read address is not empty and the unicast bit is set correctly */\n\tif (!ieee802154_is_valid_extended_unicast_addr(extended_addr)) {\n\t\tdev_info(&usb_dev->dev, \"no permanent extended address found, random address set\\n\");\n\t\tieee802154_random_extended_addr(&atusb->hw->phy->perm_extended_addr);\n\t} else {\n\t\tatusb->hw->phy->perm_extended_addr = extended_addr;\n\t\taddr = swab64((__force u64)atusb->hw->phy->perm_extended_addr);\n\t\tdev_info(&usb_dev->dev, \"Read permanent extended address %8phC from device\\n\",\n\t\t\t&addr);\n\t}\n\n\treturn ret;\n}\n\n/* ----- Setup ------------------------------------------------------------- */\n\nstatic int atusb_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(interface);\n\tstruct ieee802154_hw *hw;\n\tstruct atusb *atusb = NULL;\n\tint ret = -ENOMEM;\n\n\thw = ieee802154_alloc_hw(sizeof(struct atusb), &atusb_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tatusb = hw->priv;\n\tatusb->hw = hw;\n\tatusb->usb_dev = usb_get_dev(usb_dev);\n\tusb_set_intfdata(interface, atusb);\n\n\tatusb->shutdown = 0;\n\tatusb->err = 0;\n\tINIT_DELAYED_WORK(&atusb->work, atusb_work_urbs);\n\tinit_usb_anchor(&atusb->idle_urbs);\n\tinit_usb_anchor(&atusb->rx_urbs);\n\n\tif (atusb_alloc_urbs(atusb, ATUSB_NUM_RX_URBS))\n\t\tgoto fail;\n\n\tatusb->tx_dr.bRequestType = ATUSB_REQ_TO_DEV;\n\tatusb->tx_dr.bRequest = ATUSB_TX;\n\tatusb->tx_dr.wValue = cpu_to_le16(0);\n\n\tatusb->tx_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!atusb->tx_urb)\n\t\tgoto fail;\n\n\thw->parent = &usb_dev->dev;\n\thw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\n\t\t    IEEE802154_HW_PROMISCUOUS | IEEE802154_HW_CSMA_PARAMS |\n\t\t    IEEE802154_HW_FRAME_RETRIES;\n\n\thw->phy->flags = WPAN_PHY_FLAG_TXPOWER | WPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\t\t WPAN_PHY_FLAG_CCA_MODE;\n\n\thw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\n\t\tBIT(NL802154_CCA_CARRIER) | BIT(NL802154_CCA_ENERGY_CARRIER);\n\thw->phy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND) |\n\t\tBIT(NL802154_CCA_OPT_ENERGY_CARRIER_OR);\n\n\thw->phy->supported.cca_ed_levels = atusb_ed_levels;\n\thw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(atusb_ed_levels);\n\n\thw->phy->cca.mode = NL802154_CCA_ENERGY;\n\n\thw->phy->current_page = 0;\n\thw->phy->current_channel = 11;\t/* reset default */\n\thw->phy->supported.channels[0] = 0x7FFF800;\n\thw->phy->supported.tx_powers = atusb_powers;\n\thw->phy->supported.tx_powers_size = ARRAY_SIZE(atusb_powers);\n\thw->phy->transmit_power = hw->phy->supported.tx_powers[0];\n\thw->phy->cca_ed_level = hw->phy->supported.cca_ed_levels[7];\n\n\tatusb_command(atusb, ATUSB_RF_RESET, 0);\n\tatusb_get_and_show_chip(atusb);\n\tatusb_get_and_show_revision(atusb);\n\tatusb_get_and_show_build(atusb);\n\tatusb_set_extended_addr(atusb);\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (ret) {\n\t\tdev_err(&atusb->usb_dev->dev,\n\t\t\t\"%s: initialization failed, error = %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto fail;\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* If we just powered on, we're now in P_ON and need to enter TRX_OFF\n\t * explicitly. Any resets after that will send us straight to TRX_OFF,\n\t * making the command below redundant.\n\t */\n\tatusb_write_reg(atusb, RG_TRX_STATE, STATE_FORCE_TRX_OFF);\n\tmsleep(1);\t/* reset => TRX_OFF, tTR13 = 37 us */\n\n#if 0\n\t/* Calculating the maximum time available to empty the frame buffer\n\t * on reception:\n\t *\n\t * According to [1], the inter-frame gap is\n\t * R * 20 * 16 us + 128 us\n\t * where R is a random number from 0 to 7. Furthermore, we have 20 bit\n\t * times (80 us at 250 kbps) of SHR of the next frame before the\n\t * transceiver begins storing data in the frame buffer.\n\t *\n\t * This yields a minimum time of 208 us between the last data of a\n\t * frame and the first data of the next frame. This time is further\n\t * reduced by interrupt latency in the atusb firmware.\n\t *\n\t * atusb currently needs about 500 us to retrieve a maximum-sized\n\t * frame. We therefore have to allow reception of a new frame to begin\n\t * while we retrieve the previous frame.\n\t *\n\t * [1] \"JN-AN-1035 Calculating data rates in an IEEE 802.15.4-based\n\t *      network\", Jennic 2006.\n\t *     http://www.jennic.com/download_file.php?supportFile=JN-AN-1035%20Calculating%20802-15-4%20Data%20Rates-1v0.pdf\n\t */\n\n\tatusb_write_subreg(atusb, SR_RX_SAFE_MODE, 1);\n#endif\n\tatusb_write_reg(atusb, RG_IRQ_MASK, 0xff);\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (!ret)\n\t\treturn 0;\n\n\tdev_err(&atusb->usb_dev->dev,\n\t\t\"%s: setup failed, error = %d\\n\",\n\t\t__func__, ret);\n\n\tieee802154_unregister_hw(hw);\nfail:\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\tusb_put_dev(usb_dev);\n\tieee802154_free_hw(hw);\n\treturn ret;\n}\n\nstatic void atusb_disconnect(struct usb_interface *interface)\n{\n\tstruct atusb *atusb = usb_get_intfdata(interface);\n\n\tdev_dbg(&atusb->usb_dev->dev, \"atusb_disconnect\\n\");\n\n\tatusb->shutdown = 1;\n\tcancel_delayed_work_sync(&atusb->work);\n\n\tusb_kill_anchored_urbs(&atusb->rx_urbs);\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\n\tieee802154_unregister_hw(atusb->hw);\n\n\tieee802154_free_hw(atusb->hw);\n\n\tusb_set_intfdata(interface, NULL);\n\tusb_put_dev(atusb->usb_dev);\n\n\tpr_debug(\"atusb_disconnect done\\n\");\n}\n\n/* The devices we work with */\nstatic const struct usb_device_id atusb_device_table[] = {\n\t{\n\t\t.match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE |\n\t\t\t\t\t  USB_DEVICE_ID_MATCH_INT_INFO,\n\t\t.idVendor\t\t= ATUSB_VENDOR_ID,\n\t\t.idProduct\t\t= ATUSB_PRODUCT_ID,\n\t\t.bInterfaceClass\t= USB_CLASS_VENDOR_SPEC\n\t},\n\t/* end with null element */\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, atusb_device_table);\n\nstatic struct usb_driver atusb_driver = {\n\t.name\t\t= \"atusb\",\n\t.probe\t\t= atusb_probe,\n\t.disconnect\t= atusb_disconnect,\n\t.id_table\t= atusb_device_table,\n};\nmodule_usb_driver(atusb_driver);\n\nMODULE_AUTHOR(\"Alexander Aring <alex.aring@gmail.com>\");\nMODULE_AUTHOR(\"Richard Sharpe <realrichardsharpe@gmail.com>\");\nMODULE_AUTHOR(\"Stefan Schmidt <stefan@datenfreihafen.org>\");\nMODULE_AUTHOR(\"Werner Almesberger <werner@almesberger.net>\");\nMODULE_DESCRIPTION(\"ATUSB IEEE 802.15.4 Driver\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/net/ieee802154/atusb.c"], "buggy_code_start_loc": [119], "buggy_code_end_loc": [650], "fixing_code_start_loc": [120], "fixing_code_end_loc": [674], "type": "CWE-119", "message": "drivers/net/ieee802154/atusb.c in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-5548", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-06T06:59:00.577", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/net/ieee802154/atusb.c in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "drivers/net/ieee802154/atusb.c en el kernel de Linux 4.9.x en versiones anteriores a 4.9.6 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (ca\u00edda del sistema o corrupci\u00f3n de memoria) o posiblemente tener otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para una lista de dispersi\u00f3n de DMA."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "27B10B33-5F64-4039-8351-694A7AB6E4E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "686DF390-3DCA-4D64-9858-FF699FA21D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "D24EF446-2120-4F2F-9D84-F782BF1D85CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "DA879AFB-E995-458B-ABD2-87477376A70D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "719F2C9D-1897-480A-93CE-C2AC987B80AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "F1516D1D-261D-421C-83FF-05DD90DAEB50"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/21/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95710", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1416110", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655"}}