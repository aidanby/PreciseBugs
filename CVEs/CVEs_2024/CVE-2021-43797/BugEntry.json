{"buggy_code": ["/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.handler.codec.CharSequenceValueConverter;\nimport io.netty.handler.codec.DateFormatter;\nimport io.netty.handler.codec.DefaultHeaders;\nimport io.netty.handler.codec.DefaultHeaders.NameValidator;\nimport io.netty.handler.codec.DefaultHeadersImpl;\nimport io.netty.handler.codec.HeadersUtils;\nimport io.netty.handler.codec.ValueConverter;\nimport io.netty.util.AsciiString;\nimport io.netty.util.ByteProcessor;\nimport io.netty.util.internal.PlatformDependent;\n\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport static io.netty.util.AsciiString.CASE_INSENSITIVE_HASHER;\nimport static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;\n\n/**\n * Default implementation of {@link HttpHeaders}.\n */\npublic class DefaultHttpHeaders extends HttpHeaders {\n    private static final int HIGHEST_INVALID_VALUE_CHAR_MASK = ~15;\n    private static final ByteProcessor HEADER_NAME_VALIDATOR = new ByteProcessor() {\n        @Override\n        public boolean process(byte value) throws Exception {\n            validateHeaderNameElement(value);\n            return true;\n        }\n    };\n    static final NameValidator<CharSequence> HttpNameValidator = new NameValidator<CharSequence>() {\n        @Override\n        public void validateName(CharSequence name) {\n            if (name == null || name.length() == 0) {\n                throw new IllegalArgumentException(\"empty headers are not allowed [\" + name + \"]\");\n            }\n            if (name instanceof AsciiString) {\n                try {\n                    ((AsciiString) name).forEachByte(HEADER_NAME_VALIDATOR);\n                } catch (Exception e) {\n                    PlatformDependent.throwException(e);\n                }\n            } else {\n                // Go through each character in the name\n                for (int index = 0; index < name.length(); ++index) {\n                    validateHeaderNameElement(name.charAt(index));\n                }\n            }\n        }\n    };\n\n    private final DefaultHeaders<CharSequence, CharSequence, ?> headers;\n\n    public DefaultHttpHeaders() {\n        this(true);\n    }\n\n    /**\n     * <b>Warning!</b> Setting <code>validate</code> to <code>false</code> will mean that Netty won't\n     * validate & protect against user-supplied header values that are malicious.\n     * This can leave your server implementation vulnerable to\n     * <a href=\"https://cwe.mitre.org/data/definitions/113.html\">\n     *     CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')\n     * </a>.\n     * When disabling this validation, it is the responsibility of the caller to ensure that the values supplied\n     * do not contain a non-url-escaped carriage return (CR) and/or line feed (LF) characters.\n     *\n     * @param validate Should Netty validate Header values to ensure they aren't malicious.\n     */\n    public DefaultHttpHeaders(boolean validate) {\n        this(validate, nameValidator(validate));\n    }\n\n    protected DefaultHttpHeaders(boolean validate, NameValidator<CharSequence> nameValidator) {\n        this(new DefaultHeadersImpl<CharSequence, CharSequence>(CASE_INSENSITIVE_HASHER,\n                                                                valueConverter(validate),\n                                                                nameValidator));\n    }\n\n    protected DefaultHttpHeaders(DefaultHeaders<CharSequence, CharSequence, ?> headers) {\n        this.headers = headers;\n    }\n\n    @Override\n    public HttpHeaders add(HttpHeaders headers) {\n        if (headers instanceof DefaultHttpHeaders) {\n            this.headers.add(((DefaultHttpHeaders) headers).headers);\n            return this;\n        } else {\n            return super.add(headers);\n        }\n    }\n\n    @Override\n    public HttpHeaders set(HttpHeaders headers) {\n        if (headers instanceof DefaultHttpHeaders) {\n            this.headers.set(((DefaultHttpHeaders) headers).headers);\n            return this;\n        } else {\n            return super.set(headers);\n        }\n    }\n\n    @Override\n    public HttpHeaders add(String name, Object value) {\n        headers.addObject(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders add(CharSequence name, Object value) {\n        headers.addObject(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders add(String name, Iterable<?> values) {\n        headers.addObject(name, values);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders add(CharSequence name, Iterable<?> values) {\n        headers.addObject(name, values);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders addInt(CharSequence name, int value) {\n        headers.addInt(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders addShort(CharSequence name, short value) {\n        headers.addShort(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders remove(String name) {\n        headers.remove(name);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders remove(CharSequence name) {\n        headers.remove(name);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders set(String name, Object value) {\n        headers.setObject(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders set(CharSequence name, Object value) {\n        headers.setObject(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders set(String name, Iterable<?> values) {\n        headers.setObject(name, values);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders set(CharSequence name, Iterable<?> values) {\n        headers.setObject(name, values);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders setInt(CharSequence name, int value) {\n        headers.setInt(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders setShort(CharSequence name, short value) {\n        headers.setShort(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders clear() {\n        headers.clear();\n        return this;\n    }\n\n    @Override\n    public String get(String name) {\n        return get((CharSequence) name);\n    }\n\n    @Override\n    public String get(CharSequence name) {\n        return HeadersUtils.getAsString(headers, name);\n    }\n\n    @Override\n    public Integer getInt(CharSequence name) {\n        return headers.getInt(name);\n    }\n\n    @Override\n    public int getInt(CharSequence name, int defaultValue) {\n        return headers.getInt(name, defaultValue);\n    }\n\n    @Override\n    public Short getShort(CharSequence name) {\n        return headers.getShort(name);\n    }\n\n    @Override\n    public short getShort(CharSequence name, short defaultValue) {\n        return headers.getShort(name, defaultValue);\n    }\n\n    @Override\n    public Long getTimeMillis(CharSequence name) {\n        return headers.getTimeMillis(name);\n    }\n\n    @Override\n    public long getTimeMillis(CharSequence name, long defaultValue) {\n        return headers.getTimeMillis(name, defaultValue);\n    }\n\n    @Override\n    public List<String> getAll(String name) {\n        return getAll((CharSequence) name);\n    }\n\n    @Override\n    public List<String> getAll(CharSequence name) {\n        return HeadersUtils.getAllAsString(headers, name);\n    }\n\n    @Override\n    public List<Entry<String, String>> entries() {\n        if (isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<Entry<String, String>> entriesConverted = new ArrayList<Entry<String, String>>(\n                headers.size());\n        for (Entry<String, String> entry : this) {\n            entriesConverted.add(entry);\n        }\n        return entriesConverted;\n    }\n\n    @Deprecated\n    @Override\n    public Iterator<Map.Entry<String, String>> iterator() {\n        return HeadersUtils.iteratorAsString(headers);\n    }\n\n    @Override\n    public Iterator<Entry<CharSequence, CharSequence>> iteratorCharSequence() {\n        return headers.iterator();\n    }\n\n    @Override\n    public Iterator<String> valueStringIterator(CharSequence name) {\n        final Iterator<CharSequence> itr = valueCharSequenceIterator(name);\n        return new Iterator<String>() {\n            @Override\n            public boolean hasNext() {\n                return itr.hasNext();\n            }\n\n            @Override\n            public String next() {\n                return itr.next().toString();\n            }\n\n            @Override\n            public void remove() {\n                itr.remove();\n            }\n        };\n    }\n\n    @Override\n    public Iterator<CharSequence> valueCharSequenceIterator(CharSequence name) {\n        return headers.valueIterator(name);\n    }\n\n    @Override\n    public boolean contains(String name) {\n        return contains((CharSequence) name);\n    }\n\n    @Override\n    public boolean contains(CharSequence name) {\n        return headers.contains(name);\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return headers.isEmpty();\n    }\n\n    @Override\n    public int size() {\n        return headers.size();\n    }\n\n    @Override\n    public boolean contains(String name, String value, boolean ignoreCase) {\n        return contains((CharSequence) name, (CharSequence) value, ignoreCase);\n    }\n\n    @Override\n    public boolean contains(CharSequence name, CharSequence value, boolean ignoreCase) {\n        return headers.contains(name, value, ignoreCase ? CASE_INSENSITIVE_HASHER : CASE_SENSITIVE_HASHER);\n    }\n\n    @Override\n    public Set<String> names() {\n        return HeadersUtils.namesAsString(headers);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return o instanceof DefaultHttpHeaders\n                && headers.equals(((DefaultHttpHeaders) o).headers, CASE_SENSITIVE_HASHER);\n    }\n\n    @Override\n    public int hashCode() {\n        return headers.hashCode(CASE_SENSITIVE_HASHER);\n    }\n\n    @Override\n    public HttpHeaders copy() {\n        return new DefaultHttpHeaders(headers.copy());\n    }\n\n    private static void validateHeaderNameElement(byte value) {\n        switch (value) {\n        case 0x00:\n        case '\\t':\n        case '\\n':\n        case 0x0b:\n        case '\\f':\n        case '\\r':\n        case ' ':\n        case ',':\n        case ':':\n        case ';':\n        case '=':\n            throw new IllegalArgumentException(\n               \"a header name cannot contain the following prohibited characters: =,;: \\\\t\\\\r\\\\n\\\\v\\\\f: \" +\n                       value);\n        default:\n            // Check to see if the character is not an ASCII character, or invalid\n            if (value < 0) {\n                throw new IllegalArgumentException(\"a header name cannot contain non-ASCII character: \" + value);\n            }\n        }\n    }\n\n    private static void validateHeaderNameElement(char value) {\n        switch (value) {\n        case 0x00:\n        case '\\t':\n        case '\\n':\n        case 0x0b:\n        case '\\f':\n        case '\\r':\n        case ' ':\n        case ',':\n        case ':':\n        case ';':\n        case '=':\n            throw new IllegalArgumentException(\n               \"a header name cannot contain the following prohibited characters: =,;: \\\\t\\\\r\\\\n\\\\v\\\\f: \" +\n                       value);\n        default:\n            // Check to see if the character is not an ASCII character, or invalid\n            if (value > 127) {\n                throw new IllegalArgumentException(\"a header name cannot contain non-ASCII character: \" +\n                        value);\n            }\n        }\n    }\n\n    static ValueConverter<CharSequence> valueConverter(boolean validate) {\n        return validate ? HeaderValueConverterAndValidator.INSTANCE : HeaderValueConverter.INSTANCE;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static NameValidator<CharSequence> nameValidator(boolean validate) {\n        return validate ? HttpNameValidator : NameValidator.NOT_NULL;\n    }\n\n    private static class HeaderValueConverter extends CharSequenceValueConverter {\n        static final HeaderValueConverter INSTANCE = new HeaderValueConverter();\n\n        @Override\n        public CharSequence convertObject(Object value) {\n            if (value instanceof CharSequence) {\n                return (CharSequence) value;\n            }\n            if (value instanceof Date) {\n                return DateFormatter.format((Date) value);\n            }\n            if (value instanceof Calendar) {\n                return DateFormatter.format(((Calendar) value).getTime());\n            }\n            return value.toString();\n        }\n    }\n\n    private static final class HeaderValueConverterAndValidator extends HeaderValueConverter {\n        static final HeaderValueConverterAndValidator INSTANCE = new HeaderValueConverterAndValidator();\n\n        @Override\n        public CharSequence convertObject(Object value) {\n            CharSequence seq = super.convertObject(value);\n            int state = 0;\n            // Start looping through each of the character\n            for (int index = 0; index < seq.length(); index++) {\n                state = validateValueChar(seq, state, seq.charAt(index));\n            }\n\n            if (state != 0) {\n                throw new IllegalArgumentException(\"a header value must not end with '\\\\r' or '\\\\n':\" + seq);\n            }\n            return seq;\n        }\n\n        private static int validateValueChar(CharSequence seq, int state, char character) {\n            /*\n             * State:\n             * 0: Previous character was neither CR nor LF\n             * 1: The previous character was CR\n             * 2: The previous character was LF\n             */\n            if ((character & HIGHEST_INVALID_VALUE_CHAR_MASK) == 0) {\n                // Check the absolutely prohibited characters.\n                switch (character) {\n                case 0x0: // NULL\n                    throw new IllegalArgumentException(\"a header value contains a prohibited character '\\0': \" + seq);\n                case 0x0b: // Vertical tab\n                    throw new IllegalArgumentException(\"a header value contains a prohibited character '\\\\v': \" + seq);\n                case '\\f':\n                    throw new IllegalArgumentException(\"a header value contains a prohibited character '\\\\f': \" + seq);\n                default:\n                    break;\n                }\n            }\n\n            // Check the CRLF (HT | SP) pattern\n            switch (state) {\n                case 0:\n                    switch (character) {\n                        case '\\r':\n                            return 1;\n                        case '\\n':\n                            return 2;\n                        default:\n                            break;\n                    }\n                    break;\n                case 1:\n                    if (character == '\\n') {\n                        return 2;\n                    }\n                    throw new IllegalArgumentException(\"only '\\\\n' is allowed after '\\\\r': \" + seq);\n                case 2:\n                    switch (character) {\n                        case '\\t':\n                        case ' ':\n                            return 0;\n                        default:\n                            throw new IllegalArgumentException(\"only ' ' and '\\\\t' are allowed after '\\\\n': \" + seq);\n                    }\n                default:\n                    break;\n            }\n            return state;\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport static io.netty.util.internal.ObjectUtil.checkPositive;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.codec.DecoderResult;\nimport io.netty.handler.codec.PrematureChannelClosureException;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.ByteProcessor;\nimport io.netty.util.internal.AppendableCharSequence;\n\nimport java.util.List;\n\n/**\n * Decodes {@link ByteBuf}s into {@link HttpMessage}s and\n * {@link HttpContent}s.\n *\n * <h3>Parameters that prevents excessive memory consumption</h3>\n * <table border=\"1\">\n * <tr>\n * <th>Name</th><th>Default value</th><th>Meaning</th>\n * </tr>\n * <tr>\n * <td>{@code maxInitialLineLength}</td>\n * <td>{@value #DEFAULT_MAX_INITIAL_LINE_LENGTH}</td>\n * <td>The maximum length of the initial line\n *     (e.g. {@code \"GET / HTTP/1.0\"} or {@code \"HTTP/1.0 200 OK\"})\n *     If the length of the initial line exceeds this value, a\n *     {@link TooLongFrameException} will be raised.</td>\n * </tr>\n * <tr>\n * <td>{@code maxHeaderSize}</td>\n * <td>{@value #DEFAULT_MAX_HEADER_SIZE}</td>\n * <td>The maximum length of all headers.  If the sum of the length of each\n *     header exceeds this value, a {@link TooLongFrameException} will be raised.</td>\n * </tr>\n * <tr>\n * <td>{@code maxChunkSize}</td>\n * <td>{@value #DEFAULT_MAX_CHUNK_SIZE}</td>\n * <td>The maximum length of the content or each chunk.  If the content length\n *     (or the length of each chunk) exceeds this value, the content or chunk\n *     will be split into multiple {@link HttpContent}s whose length is\n *     {@code maxChunkSize} at maximum.</td>\n * </tr>\n * </table>\n *\n * <h3>Parameters that control parsing behavior</h3>\n * <table border=\"1\">\n * <tr>\n * <th>Name</th><th>Default value</th><th>Meaning</th>\n * </tr>\n * <tr>\n * <td>{@code allowDuplicateContentLengths}</td>\n * <td>{@value #DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS}</td>\n * <td>When set to {@code false}, will reject any messages that contain multiple Content-Length header fields.\n *     When set to {@code true}, will allow multiple Content-Length headers only if they are all the same decimal value.\n *     The duplicated field-values will be replaced with a single valid Content-Length field.\n *     See <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.2\">RFC 7230, Section 3.3.2</a>.</td>\n * </tr>\n * <tr>\n * <td>{@code allowPartialChunks}</td>\n * <td>{@value #DEFAULT_ALLOW_PARTIAL_CHUNKS}</td>\n * <td>If the length of a chunk exceeds the {@link ByteBuf}s readable bytes and {@code allowPartialChunks}\n *     is set to {@code true}, the chunk will be split into multiple {@link HttpContent}s.\n *     Otherwise, if the chunk size does not exceed {@code maxChunkSize} and {@code allowPartialChunks}\n *     is set to {@code false}, the {@link ByteBuf} is not decoded into an {@link HttpContent} until\n *     the readable bytes are greater or equal to the chunk size.</td>\n * </tr>\n * </table>\n *\n * <h3>Chunked Content</h3>\n *\n * If the content of an HTTP message is greater than {@code maxChunkSize} or\n * the transfer encoding of the HTTP message is 'chunked', this decoder\n * generates one {@link HttpMessage} instance and its following\n * {@link HttpContent}s per single HTTP message to avoid excessive memory\n * consumption. For example, the following HTTP message:\n * <pre>\n * GET / HTTP/1.1\n * Transfer-Encoding: chunked\n *\n * 1a\n * abcdefghijklmnopqrstuvwxyz\n * 10\n * 1234567890abcdef\n * 0\n * Content-MD5: ...\n * <i>[blank line]</i>\n * </pre>\n * triggers {@link HttpRequestDecoder} to generate 3 objects:\n * <ol>\n * <li>An {@link HttpRequest},</li>\n * <li>The first {@link HttpContent} whose content is {@code 'abcdefghijklmnopqrstuvwxyz'},</li>\n * <li>The second {@link LastHttpContent} whose content is {@code '1234567890abcdef'}, which marks\n * the end of the content.</li>\n * </ol>\n *\n * If you prefer not to handle {@link HttpContent}s by yourself for your\n * convenience, insert {@link HttpObjectAggregator} after this decoder in the\n * {@link ChannelPipeline}.  However, please note that your server might not\n * be as memory efficient as without the aggregator.\n *\n * <h3>Extensibility</h3>\n *\n * Please note that this decoder is designed to be extended to implement\n * a protocol derived from HTTP, such as\n * <a href=\"https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol\">RTSP</a> and\n * <a href=\"https://en.wikipedia.org/wiki/Internet_Content_Adaptation_Protocol\">ICAP</a>.\n * To implement the decoder of such a derived protocol, extend this class and\n * implement all abstract methods properly.\n */\npublic abstract class HttpObjectDecoder extends ByteToMessageDecoder {\n    public static final int DEFAULT_MAX_INITIAL_LINE_LENGTH = 4096;\n    public static final int DEFAULT_MAX_HEADER_SIZE = 8192;\n    public static final boolean DEFAULT_CHUNKED_SUPPORTED = true;\n    public static final boolean DEFAULT_ALLOW_PARTIAL_CHUNKS = true;\n    public static final int DEFAULT_MAX_CHUNK_SIZE = 8192;\n    public static final boolean DEFAULT_VALIDATE_HEADERS = true;\n    public static final int DEFAULT_INITIAL_BUFFER_SIZE = 128;\n    public static final boolean DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS = false;\n\n    private static final String EMPTY_VALUE = \"\";\n\n    private final int maxChunkSize;\n    private final boolean chunkedSupported;\n    private final boolean allowPartialChunks;\n    protected final boolean validateHeaders;\n    private final boolean allowDuplicateContentLengths;\n    private final HeaderParser headerParser;\n    private final LineParser lineParser;\n\n    private HttpMessage message;\n    private long chunkSize;\n    private long contentLength = Long.MIN_VALUE;\n    private volatile boolean resetRequested;\n\n    // These will be updated by splitHeader(...)\n    private CharSequence name;\n    private CharSequence value;\n\n    private LastHttpContent trailer;\n\n    /**\n     * The internal state of {@link HttpObjectDecoder}.\n     * <em>Internal use only</em>.\n     */\n    private enum State {\n        SKIP_CONTROL_CHARS,\n        READ_INITIAL,\n        READ_HEADER,\n        READ_VARIABLE_LENGTH_CONTENT,\n        READ_FIXED_LENGTH_CONTENT,\n        READ_CHUNK_SIZE,\n        READ_CHUNKED_CONTENT,\n        READ_CHUNK_DELIMITER,\n        READ_CHUNK_FOOTER,\n        BAD_MESSAGE,\n        UPGRADED\n    }\n\n    private State currentState = State.SKIP_CONTROL_CHARS;\n\n    /**\n     * Creates a new instance with the default\n     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and\n     * {@code maxChunkSize (8192)}.\n     */\n    protected HttpObjectDecoder() {\n        this(DEFAULT_MAX_INITIAL_LINE_LENGTH, DEFAULT_MAX_HEADER_SIZE, DEFAULT_MAX_CHUNK_SIZE,\n             DEFAULT_CHUNKED_SUPPORTED);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean chunkedSupported) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, DEFAULT_VALIDATE_HEADERS);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders,\n             DEFAULT_INITIAL_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders, initialBufferSize,\n             DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize,\n            boolean allowDuplicateContentLengths) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders, initialBufferSize,\n            allowDuplicateContentLengths, DEFAULT_ALLOW_PARTIAL_CHUNKS);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize,\n            boolean allowDuplicateContentLengths, boolean allowPartialChunks) {\n        checkPositive(maxInitialLineLength, \"maxInitialLineLength\");\n        checkPositive(maxHeaderSize, \"maxHeaderSize\");\n        checkPositive(maxChunkSize, \"maxChunkSize\");\n\n        AppendableCharSequence seq = new AppendableCharSequence(initialBufferSize);\n        lineParser = new LineParser(seq, maxInitialLineLength);\n        headerParser = new HeaderParser(seq, maxHeaderSize);\n        this.maxChunkSize = maxChunkSize;\n        this.chunkedSupported = chunkedSupported;\n        this.validateHeaders = validateHeaders;\n        this.allowDuplicateContentLengths = allowDuplicateContentLengths;\n        this.allowPartialChunks = allowPartialChunks;\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) {\n        case SKIP_CONTROL_CHARS:\n            // Fall-through\n        case READ_INITIAL: try {\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line);\n            if (initialLine.length < 3) {\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;\n                return;\n            }\n\n            message = createMessage(initialLine);\n            currentState = State.READ_HEADER;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {\n            State nextState = readHeaders(buffer);\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:\n                // fast-path\n                // No content is expected.\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE:\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:\n                /**\n                 * <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.3\">RFC 7230, 3.3.3</a> states that if a\n                 * request does not have either a transfer-encoding or a content-length header then the message body\n                 * length is 0. However for a response the body length is the number of octets received prior to the\n                 * server closing the connection. So we treat this as variable length chunked encoding.\n                 */\n                long contentLength = contentLength();\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                    resetNow();\n                    return;\n                }\n\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT;\n\n                out.add(message);\n\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength;\n                }\n\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {\n            int readLimit = buffer.readableBytes();\n\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create an HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);\n            chunkSize -= toRead;\n\n            if (chunkSize == 0) {\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow();\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: {\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            if (!allowPartialChunks && buffer.readableBytes() < toRead) {\n                return;\n            }\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n\n            out.add(chunk);\n\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        default:\n            break;\n        }\n    }\n\n    @Override\n    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        super.decodeLast(ctx, in, out);\n\n        if (resetRequested) {\n            // If a reset was requested by decodeLast() we need to do it now otherwise we may produce a\n            // LastHttpContent while there was already one.\n            resetNow();\n        }\n        // Handle the last unfinished message.\n        if (message != null) {\n            boolean chunked = HttpUtil.isTransferEncodingChunked(message);\n            if (currentState == State.READ_VARIABLE_LENGTH_CONTENT && !in.isReadable() && !chunked) {\n                // End of connection.\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            }\n\n            if (currentState == State.READ_HEADER) {\n                // If we are still in the state of reading headers we need to create a new invalid message that\n                // signals that the connection was closed before we received the headers.\n                out.add(invalidMessage(Unpooled.EMPTY_BUFFER,\n                        new PrematureChannelClosureException(\"Connection closed before received headers\")));\n                resetNow();\n                return;\n            }\n\n            // Check if the closure of the connection signifies the end of the content.\n            boolean prematureClosure;\n            if (isDecodingRequest() || chunked) {\n                // The last request did not wait for a response.\n                prematureClosure = true;\n            } else {\n                // Compare the length of the received content and the 'Content-Length' header.\n                // If the 'Content-Length' header is absent, the length of the content is determined by the end of the\n                // connection, so it is perfectly fine.\n                prematureClosure = contentLength() > 0;\n            }\n\n            if (!prematureClosure) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            }\n            resetNow();\n        }\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof HttpExpectationFailedEvent) {\n            switch (currentState) {\n            case READ_FIXED_LENGTH_CONTENT:\n            case READ_VARIABLE_LENGTH_CONTENT:\n            case READ_CHUNK_SIZE:\n                reset();\n                break;\n            default:\n                break;\n            }\n        }\n        super.userEventTriggered(ctx, evt);\n    }\n\n    protected boolean isContentAlwaysEmpty(HttpMessage msg) {\n        if (msg instanceof HttpResponse) {\n            HttpResponse res = (HttpResponse) msg;\n            int code = res.status().code();\n\n            // Correctly handle return codes of 1xx.\n            //\n            // See:\n            //     - https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html Section 4.4\n            //     - https://github.com/netty/netty/issues/222\n            if (code >= 100 && code < 200) {\n                // One exception: Hixie 76 websocket handshake response\n                return !(code == 101 && !res.headers().contains(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT)\n                         && res.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true));\n            }\n\n            switch (code) {\n            case 204: case 304:\n                return true;\n            default:\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the server switched to a different protocol than HTTP/1.0 or HTTP/1.1, e.g. HTTP/2 or Websocket.\n     * Returns false if the upgrade happened in a different layer, e.g. upgrade from HTTP/1.1 to HTTP/1.1 over TLS.\n     */\n    protected boolean isSwitchingToNonHttp1Protocol(HttpResponse msg) {\n        if (msg.status().code() != HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {\n            return false;\n        }\n        String newProtocol = msg.headers().get(HttpHeaderNames.UPGRADE);\n        return newProtocol == null ||\n                !newProtocol.contains(HttpVersion.HTTP_1_0.text()) &&\n                !newProtocol.contains(HttpVersion.HTTP_1_1.text());\n    }\n\n    /**\n     * Resets the state of the decoder so that it is ready to decode a new message.\n     * This method is useful for handling a rejected request with {@code Expect: 100-continue} header.\n     */\n    public void reset() {\n        resetRequested = true;\n    }\n\n    private void resetNow() {\n        HttpMessage message = this.message;\n        this.message = null;\n        name = null;\n        value = null;\n        contentLength = Long.MIN_VALUE;\n        lineParser.reset();\n        headerParser.reset();\n        trailer = null;\n        if (!isDecodingRequest()) {\n            HttpResponse res = (HttpResponse) message;\n            if (res != null && isSwitchingToNonHttp1Protocol(res)) {\n                currentState = State.UPGRADED;\n                return;\n            }\n        }\n\n        resetRequested = false;\n        currentState = State.SKIP_CONTROL_CHARS;\n    }\n\n    private HttpMessage invalidMessage(ByteBuf in, Exception cause) {\n        currentState = State.BAD_MESSAGE;\n\n        // Advance the readerIndex so that ByteToMessageDecoder does not complain\n        // when we produced an invalid message without consuming anything.\n        in.skipBytes(in.readableBytes());\n\n        if (message == null) {\n            message = createInvalidMessage();\n        }\n        message.setDecoderResult(DecoderResult.failure(cause));\n\n        HttpMessage ret = message;\n        message = null;\n        return ret;\n    }\n\n    private HttpContent invalidChunk(ByteBuf in, Exception cause) {\n        currentState = State.BAD_MESSAGE;\n\n        // Advance the readerIndex so that ByteToMessageDecoder does not complain\n        // when we produced an invalid message without consuming anything.\n        in.skipBytes(in.readableBytes());\n\n        HttpContent chunk = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER);\n        chunk.setDecoderResult(DecoderResult.failure(cause));\n        message = null;\n        trailer = null;\n        return chunk;\n    }\n\n    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        // Done parsing initial line and headers. Set decoder result.\n        HttpMessageDecoderResult decoderResult = new HttpMessageDecoderResult(lineParser.size, headerParser.size);\n        message.setDecoderResult(decoderResult);\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        if (!contentLengthFields.isEmpty()) {\n            HttpVersion version = message.protocolVersion();\n            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1\n                    && version.minorVersion() == 0);\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,\n                    isHttp10OrEarlier, allowDuplicateContentLengths);\n            if (contentLength != -1) {\n                headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);\n            }\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }\n\n    /**\n     * Invoked when a message with both a \"Transfer-Encoding: chunked\" and a \"Content-Length\" header field is detected.\n     * The default behavior is to <i>remove</i> the Content-Length field, but this method could be overridden\n     * to change the behavior (to, e.g., throw an exception and produce an invalid message).\n     * <p>\n     * See: https://tools.ietf.org/html/rfc7230#section-3.3.3\n     * <pre>\n     *     If a message is received with both a Transfer-Encoding and a\n     *     Content-Length header field, the Transfer-Encoding overrides the\n     *     Content-Length.  Such a message might indicate an attempt to\n     *     perform request smuggling (Section 9.5) or response splitting\n     *     (Section 9.4) and ought to be handled as an error.  A sender MUST\n     *     remove the received Content-Length field prior to forwarding such\n     *     a message downstream.\n     * </pre>\n     * Also see:\n     * https://github.com/apache/tomcat/blob/b693d7c1981fa7f51e58bc8c8e72e3fe80b7b773/\n     * java/org/apache/coyote/http11/Http11Processor.java#L747-L755\n     * https://github.com/nginx/nginx/blob/0ad4393e30c119d250415cb769e3d8bc8dce5186/\n     * src/http/ngx_http_request.c#L1946-L1953\n     */\n    protected void handleTransferEncodingChunkedWithContentLength(HttpMessage message) {\n        message.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n        contentLength = Long.MIN_VALUE;\n    }\n\n    private long contentLength() {\n        if (contentLength == Long.MIN_VALUE) {\n            contentLength = HttpUtil.getContentLength(message, -1L);\n        }\n        return contentLength;\n    }\n\n    private LastHttpContent readTrailingHeaders(ByteBuf buffer) {\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        LastHttpContent trailer = this.trailer;\n        if (line.length() == 0 && trailer == null) {\n            // We have received the empty line which signals the trailer is complete and did not parse any trailers\n            // before. Just return an empty last content to reduce allocations.\n            return LastHttpContent.EMPTY_LAST_CONTENT;\n        }\n\n        CharSequence lastHeader = null;\n        if (trailer == null) {\n            trailer = this.trailer = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);\n        }\n        while (line.length() > 0) {\n            char firstChar = line.charAtUnsafe(0);\n            if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                List<String> current = trailer.trailingHeaders().getAll(lastHeader);\n                if (!current.isEmpty()) {\n                    int lastPos = current.size() - 1;\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String lineTrimmed = line.toString().trim();\n                    String currentLastPos = current.get(lastPos);\n                    current.set(lastPos, currentLastPos + lineTrimmed);\n                }\n            } else {\n                splitHeader(line);\n                CharSequence headerName = name;\n                if (!HttpHeaderNames.CONTENT_LENGTH.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRANSFER_ENCODING.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRAILER.contentEqualsIgnoreCase(headerName)) {\n                    trailer.trailingHeaders().add(headerName, value);\n                }\n                lastHeader = name;\n                // reset name and value fields\n                name = null;\n                value = null;\n            }\n            line = headerParser.parse(buffer);\n            if (line == null) {\n                return null;\n            }\n        }\n\n        this.trailer = null;\n        return trailer;\n    }\n\n    protected abstract boolean isDecodingRequest();\n    protected abstract HttpMessage createMessage(String[] initialLine) throws Exception;\n    protected abstract HttpMessage createInvalidMessage();\n\n    private static int getChunkSize(String hex) {\n        hex = hex.trim();\n        for (int i = 0; i < hex.length(); i ++) {\n            char c = hex.charAt(i);\n            if (c == ';' || Character.isWhitespace(c) || Character.isISOControl(c)) {\n                hex = hex.substring(0, i);\n                break;\n            }\n        }\n\n        return Integer.parseInt(hex, 16);\n    }\n\n    private static String[] splitInitialLine(AppendableCharSequence sb) {\n        int aStart;\n        int aEnd;\n        int bStart;\n        int bEnd;\n        int cStart;\n        int cEnd;\n\n        aStart = findNonSPLenient(sb, 0);\n        aEnd = findSPLenient(sb, aStart);\n\n        bStart = findNonSPLenient(sb, aEnd);\n        bEnd = findSPLenient(sb, bStart);\n\n        cStart = findNonSPLenient(sb, bEnd);\n        cEnd = findEndOfString(sb);\n\n        return new String[] {\n                sb.subStringUnsafe(aStart, aEnd),\n                sb.subStringUnsafe(bStart, bEnd),\n                cStart < cEnd? sb.subStringUnsafe(cStart, cEnd) : \"\" };\n    }\n\n    private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0, false);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n            //\n            // No whitespace is allowed between the header field-name and colon. In\n            // the past, differences in the handling of such whitespace have led to\n            // security vulnerabilities in request routing and response handling. A\n            // server MUST reject any received request message that contains\n            // whitespace between a header field-name and colon with a response code\n            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n            // response message before forwarding the message downstream.\n            if (ch == ':' ||\n                    // In case of decoding a request we will just continue processing and header validation\n                    // is done in the DefaultHttpHeaders implementation.\n                    //\n                    // In the case of decoding a response we will \"skip\" the whitespace.\n                    (!isDecodingRequest() && isOWS(ch))) {\n                break;\n            }\n        }\n\n        if (nameEnd == length) {\n            // There was no colon present at all.\n            throw new IllegalArgumentException(\"No colon found\");\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd, true);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }\n\n    private static int findNonSPLenient(AppendableCharSequence sb, int offset) {\n        for (int result = offset; result < sb.length(); ++result) {\n            char c = sb.charAtUnsafe(result);\n            // See https://tools.ietf.org/html/rfc7230#section-3.5\n            if (isSPLenient(c)) {\n                continue;\n            }\n            if (Character.isWhitespace(c)) {\n                // Any other whitespace delimiter is invalid\n                throw new IllegalArgumentException(\"Invalid separator\");\n            }\n            return result;\n        }\n        return sb.length();\n    }\n\n    private static int findSPLenient(AppendableCharSequence sb, int offset) {\n        for (int result = offset; result < sb.length(); ++result) {\n            if (isSPLenient(sb.charAtUnsafe(result))) {\n                return result;\n            }\n        }\n        return sb.length();\n    }\n\n    private static boolean isSPLenient(char c) {\n        // See https://tools.ietf.org/html/rfc7230#section-3.5\n        return c == ' ' || c == (char) 0x09 || c == (char) 0x0B || c == (char) 0x0C || c == (char) 0x0D;\n    }\n\n    private static int findNonWhitespace(AppendableCharSequence sb, int offset, boolean validateOWS) {\n        for (int result = offset; result < sb.length(); ++result) {\n            char c = sb.charAtUnsafe(result);\n            if (!Character.isWhitespace(c)) {\n                return result;\n            } else if (validateOWS && !isOWS(c)) {\n                // Only OWS is supported for whitespace\n                throw new IllegalArgumentException(\"Invalid separator, only a single space or horizontal tab allowed,\" +\n                        \" but received a '\" + c + \"' (0x\" + Integer.toHexString(c) + \")\");\n            }\n        }\n        return sb.length();\n    }\n\n    private static int findEndOfString(AppendableCharSequence sb) {\n        for (int result = sb.length() - 1; result > 0; --result) {\n            if (!Character.isWhitespace(sb.charAtUnsafe(result))) {\n                return result + 1;\n            }\n        }\n        return 0;\n    }\n\n    private static boolean isOWS(char ch) {\n        return ch == ' ' || ch == (char) 0x09;\n    }\n\n    private static class HeaderParser implements ByteProcessor {\n        private final AppendableCharSequence seq;\n        private final int maxLength;\n        int size;\n\n        HeaderParser(AppendableCharSequence seq, int maxLength) {\n            this.seq = seq;\n            this.maxLength = maxLength;\n        }\n\n        public AppendableCharSequence parse(ByteBuf buffer) {\n            final int oldSize = size;\n            seq.reset();\n            int i = buffer.forEachByte(this);\n            if (i == -1) {\n                size = oldSize;\n                return null;\n            }\n            buffer.readerIndex(i + 1);\n            return seq;\n        }\n\n        public void reset() {\n            size = 0;\n        }\n\n        @Override\n        public boolean process(byte value) throws Exception {\n            char nextByte = (char) (value & 0xFF);\n            if (nextByte == HttpConstants.LF) {\n                int len = seq.length();\n                // Drop CR if we had a CRLF pair\n                if (len >= 1 && seq.charAtUnsafe(len - 1) == HttpConstants.CR) {\n                    -- size;\n                    seq.setLength(len - 1);\n                }\n                return false;\n            }\n\n            increaseCount();\n\n            seq.append(nextByte);\n            return true;\n        }\n\n        protected final void increaseCount() {\n            if (++ size > maxLength) {\n                // TODO: Respond with Bad Request and discard the traffic\n                //    or close the connection.\n                //       No need to notify the upstream handlers - just log.\n                //       If decoding a response, just throw an exception.\n                throw newException(maxLength);\n            }\n        }\n\n        protected TooLongFrameException newException(int maxLength) {\n            return new TooLongFrameException(\"HTTP header is larger than \" + maxLength + \" bytes.\");\n        }\n    }\n\n    private final class LineParser extends HeaderParser {\n\n        LineParser(AppendableCharSequence seq, int maxLength) {\n            super(seq, maxLength);\n        }\n\n        @Override\n        public AppendableCharSequence parse(ByteBuf buffer) {\n            // Suppress a warning because HeaderParser.reset() is supposed to be called\n            reset();    // lgtm[java/subtle-inherited-call]\n            return super.parse(buffer);\n        }\n\n        @Override\n        public boolean process(byte value) throws Exception {\n            if (currentState == State.SKIP_CONTROL_CHARS) {\n                char c = (char) (value & 0xFF);\n                if (Character.isISOControl(c) || Character.isWhitespace(c)) {\n                    increaseCount();\n                    return true;\n                }\n                currentState = State.READ_INITIAL;\n            }\n            return super.process(value);\n        }\n\n        @Override\n        protected TooLongFrameException newException(int maxLength) {\n            return new TooLongFrameException(\"An HTTP line is larger than \" + maxLength + \" bytes.\");\n        }\n    }\n}\n", "/*\n * Copyright 2013 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.AsciiString;\nimport io.netty.util.CharsetUtil;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static io.netty.handler.codec.http.HttpHeaderNames.*;\nimport static io.netty.handler.codec.http.HttpHeadersTestUtils.of;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class HttpRequestDecoderTest {\n    private static final byte[] CONTENT_CRLF_DELIMITERS = createContent(\"\\r\\n\");\n    private static final byte[] CONTENT_LF_DELIMITERS = createContent(\"\\n\");\n    private static final byte[] CONTENT_MIXED_DELIMITERS = createContent(\"\\r\\n\", \"\\n\");\n    private static final int CONTENT_LENGTH = 8;\n\n    private static byte[] createContent(String... lineDelimiters) {\n        String lineDelimiter;\n        String lineDelimiter2;\n        if (lineDelimiters.length == 2) {\n            lineDelimiter = lineDelimiters[0];\n            lineDelimiter2 = lineDelimiters[1];\n        } else {\n            lineDelimiter = lineDelimiters[0];\n            lineDelimiter2 = lineDelimiters[0];\n        }\n        return (\"GET /some/path?foo=bar&wibble=eek HTTP/1.1\" + \"\\r\\n\" +\n                \"Upgrade: WebSocket\" + lineDelimiter2 +\n                \"Connection: Upgrade\" + lineDelimiter +\n                \"Host: localhost\" + lineDelimiter2 +\n                \"Origin: http://localhost:8080\" + lineDelimiter +\n                \"Sec-WebSocket-Key1: 10  28 8V7 8 48     0\" + lineDelimiter2 +\n                \"Sec-WebSocket-Key2: 8 Xt754O3Q3QW 0   _60\" + lineDelimiter +\n                \"Content-Length: \" + CONTENT_LENGTH + lineDelimiter2 +\n                \"\\r\\n\"  +\n                \"12345678\").getBytes(CharsetUtil.US_ASCII);\n    }\n\n    @Test\n    public void testDecodeWholeRequestAtOnceCRLFDelimiters() {\n        testDecodeWholeRequestAtOnce(CONTENT_CRLF_DELIMITERS);\n    }\n\n    @Test\n    public void testDecodeWholeRequestAtOnceLFDelimiters() {\n        testDecodeWholeRequestAtOnce(CONTENT_LF_DELIMITERS);\n    }\n\n    @Test\n    public void testDecodeWholeRequestAtOnceMixedDelimiters() {\n        testDecodeWholeRequestAtOnce(CONTENT_MIXED_DELIMITERS);\n    }\n\n    private static void testDecodeWholeRequestAtOnce(byte[] content) {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(content)));\n        HttpRequest req = channel.readInbound();\n        assertNotNull(req);\n        checkHeaders(req.headers());\n        LastHttpContent c = channel.readInbound();\n        assertEquals(CONTENT_LENGTH, c.content().readableBytes());\n        assertEquals(\n                Unpooled.wrappedBuffer(content, content.length - CONTENT_LENGTH, CONTENT_LENGTH),\n                c.content().readSlice(CONTENT_LENGTH));\n        c.release();\n\n        assertFalse(channel.finish());\n        assertNull(channel.readInbound());\n    }\n\n    private static void checkHeaders(HttpHeaders headers) {\n        assertEquals(7, headers.names().size());\n        checkHeader(headers, \"Upgrade\", \"WebSocket\");\n        checkHeader(headers, \"Connection\", \"Upgrade\");\n        checkHeader(headers, \"Host\", \"localhost\");\n        checkHeader(headers, \"Origin\", \"http://localhost:8080\");\n        checkHeader(headers, \"Sec-WebSocket-Key1\", \"10  28 8V7 8 48     0\");\n        checkHeader(headers, \"Sec-WebSocket-Key2\", \"8 Xt754O3Q3QW 0   _60\");\n        checkHeader(headers, \"Content-Length\", String.valueOf(CONTENT_LENGTH));\n    }\n\n    private static void checkHeader(HttpHeaders headers, String name, String value) {\n        List<String> header1 = headers.getAll(of(name));\n        assertEquals(1, header1.size());\n        assertEquals(value, header1.get(0));\n    }\n\n    @Test\n    public void testDecodeWholeRequestInMultipleStepsCRLFDelimiters() {\n        testDecodeWholeRequestInMultipleSteps(CONTENT_CRLF_DELIMITERS);\n    }\n\n    @Test\n    public void testDecodeWholeRequestInMultipleStepsLFDelimiters() {\n        testDecodeWholeRequestInMultipleSteps(CONTENT_LF_DELIMITERS);\n    }\n\n    @Test\n    public void testDecodeWholeRequestInMultipleStepsMixedDelimiters() {\n        testDecodeWholeRequestInMultipleSteps(CONTENT_MIXED_DELIMITERS);\n    }\n\n    private static void testDecodeWholeRequestInMultipleSteps(byte[] content) {\n        for (int i = 1; i < content.length; i++) {\n            testDecodeWholeRequestInMultipleSteps(content, i);\n        }\n    }\n\n    private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fragmentSize) {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        int headerLength = content.length - CONTENT_LENGTH;\n\n        // split up the header\n        for (int a = 0; a < headerLength;) {\n            int amount = fragmentSize;\n            if (a + amount > headerLength) {\n                amount = headerLength -  a;\n            }\n\n            // if header is done it should produce an HttpRequest\n            channel.writeInbound(Unpooled.copiedBuffer(content, a, amount));\n            a += amount;\n        }\n\n        for (int i = CONTENT_LENGTH; i > 0; i --) {\n            // Should produce HttpContent\n            channel.writeInbound(Unpooled.copiedBuffer(content, content.length - i, 1));\n        }\n\n        HttpRequest req = channel.readInbound();\n        assertNotNull(req);\n        checkHeaders(req.headers());\n\n        for (int i = CONTENT_LENGTH; i > 1; i --) {\n            HttpContent c = channel.readInbound();\n            assertEquals(1, c.content().readableBytes());\n            assertEquals(content[content.length - i], c.content().readByte());\n            c.release();\n        }\n\n        LastHttpContent c = channel.readInbound();\n        assertEquals(1, c.content().readableBytes());\n        assertEquals(content[content.length - 1], c.content().readByte());\n        c.release();\n\n        assertFalse(channel.finish());\n        assertNull(channel.readInbound());\n    }\n\n    @Test\n    public void testMultiLineHeader() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        String crlf = \"\\r\\n\";\n        String request =  \"GET /some/path HTTP/1.1\" + crlf +\n                \"Host: localhost\" + crlf +\n                \"MyTestHeader: part1\" + crlf +\n                \"              newLinePart2\" + crlf +\n                \"MyTestHeader2: part21\" + crlf +\n                \"\\t            newLinePart22\"\n                + crlf + crlf;\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(request, CharsetUtil.US_ASCII)));\n        HttpRequest req = channel.readInbound();\n        assertEquals(\"part1 newLinePart2\", req.headers().get(of(\"MyTestHeader\")));\n        assertEquals(\"part21 newLinePart22\", req.headers().get(of(\"MyTestHeader2\")));\n\n        LastHttpContent c = channel.readInbound();\n        c.release();\n\n        assertFalse(channel.finish());\n        assertNull(channel.readInbound());\n    }\n\n    @Test\n    public void testEmptyHeaderValue() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        String crlf = \"\\r\\n\";\n        String request =  \"GET /some/path HTTP/1.1\" + crlf +\n                \"Host: localhost\" + crlf +\n                \"EmptyHeader:\" + crlf + crlf;\n        channel.writeInbound(Unpooled.copiedBuffer(request, CharsetUtil.US_ASCII));\n        HttpRequest req = channel.readInbound();\n        assertEquals(\"\", req.headers().get(of(\"EmptyHeader\")));\n    }\n\n    @Test\n    public void test100Continue() {\n        HttpRequestDecoder decoder = new HttpRequestDecoder();\n        EmbeddedChannel channel = new EmbeddedChannel(decoder);\n        String oversized =\n                \"PUT /file HTTP/1.1\\r\\n\" +\n                \"Expect: 100-continue\\r\\n\" +\n                \"Content-Length: 1048576000\\r\\n\\r\\n\";\n\n        channel.writeInbound(Unpooled.copiedBuffer(oversized, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));\n\n        // At this point, we assume that we sent '413 Entity Too Large' to the peer without closing the connection\n        // so that the client can try again.\n        decoder.reset();\n\n        String query = \"GET /max-file-size HTTP/1.1\\r\\n\\r\\n\";\n        channel.writeInbound(Unpooled.copiedBuffer(query, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));\n        assertThat(channel.readInbound(), is(instanceOf(LastHttpContent.class)));\n\n        assertThat(channel.finish(), is(false));\n    }\n\n    @Test\n    public void test100ContinueWithBadClient() {\n        HttpRequestDecoder decoder = new HttpRequestDecoder();\n        EmbeddedChannel channel = new EmbeddedChannel(decoder);\n        String oversized =\n                \"PUT /file HTTP/1.1\\r\\n\" +\n                \"Expect: 100-continue\\r\\n\" +\n                \"Content-Length: 1048576000\\r\\n\\r\\n\" +\n                \"WAY_TOO_LARGE_DATA_BEGINS\";\n\n        channel.writeInbound(Unpooled.copiedBuffer(oversized, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));\n\n        HttpContent prematureData = channel.readInbound();\n        prematureData.release();\n\n        assertThat(channel.readInbound(), is(nullValue()));\n\n        // At this point, we assume that we sent '413 Entity Too Large' to the peer without closing the connection\n        // so that the client can try again.\n        decoder.reset();\n\n        String query = \"GET /max-file-size HTTP/1.1\\r\\n\\r\\n\";\n        channel.writeInbound(Unpooled.copiedBuffer(query, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));\n        assertThat(channel.readInbound(), is(instanceOf(LastHttpContent.class)));\n\n        assertThat(channel.finish(), is(false));\n    }\n\n    @Test\n    public void testMessagesSplitBetweenMultipleBuffers() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        String crlf = \"\\r\\n\";\n        String str1 = \"GET /some/path HTTP/1.1\" + crlf +\n                \"Host: localhost1\" + crlf + crlf +\n                \"GET /some/other/path HTTP/1.0\" + crlf +\n                \"Hos\";\n        String str2 = \"t: localhost2\" + crlf +\n                \"content-length: 0\" + crlf + crlf;\n        channel.writeInbound(Unpooled.copiedBuffer(str1, CharsetUtil.US_ASCII));\n        HttpRequest req = channel.readInbound();\n        assertEquals(HttpVersion.HTTP_1_1, req.protocolVersion());\n        assertEquals(\"/some/path\", req.uri());\n        assertEquals(1, req.headers().size());\n        assertTrue(AsciiString.contentEqualsIgnoreCase(\"localhost1\", req.headers().get(HOST)));\n        LastHttpContent cnt = channel.readInbound();\n        cnt.release();\n\n        channel.writeInbound(Unpooled.copiedBuffer(str2, CharsetUtil.US_ASCII));\n        req = channel.readInbound();\n        assertEquals(HttpVersion.HTTP_1_0, req.protocolVersion());\n        assertEquals(\"/some/other/path\", req.uri());\n        assertEquals(2, req.headers().size());\n        assertTrue(AsciiString.contentEqualsIgnoreCase(\"localhost2\", req.headers().get(HOST)));\n        assertTrue(AsciiString.contentEqualsIgnoreCase(\"0\", req.headers().get(HttpHeaderNames.CONTENT_LENGTH)));\n        cnt = channel.readInbound();\n        cnt.release();\n        assertFalse(channel.finishAndReleaseAll());\n    }\n\n    @Test\n    public void testTooLargeInitialLine() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(10, 1024, 1024));\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Host: localhost1\\r\\n\\r\\n\";\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertTrue(request.decoderResult().isFailure());\n        assertTrue(request.decoderResult().cause() instanceof TooLongFrameException);\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testTooLargeInitialLineWithWSOnly() {\n        testTooLargeInitialLineWithControlCharsOnly(\"                    \");\n    }\n\n    @Test\n    public void testTooLargeInitialLineWithCRLFOnly() {\n        testTooLargeInitialLineWithControlCharsOnly(\"\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\");\n    }\n\n    private static void testTooLargeInitialLineWithControlCharsOnly(String controlChars) {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(15, 1024, 1024));\n        String requestStr = controlChars + \"GET / HTTP/1.1\\r\\n\" +\n                \"Host: localhost1\\r\\n\\r\\n\";\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertTrue(request.decoderResult().isFailure());\n        assertTrue(request.decoderResult().cause() instanceof TooLongFrameException);\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testInitialLineWithLeadingControlChars() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        String crlf = \"\\r\\n\";\n        String request =  crlf + \"GET /some/path HTTP/1.1\" + crlf +\n                \"Host: localhost\" + crlf + crlf;\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(request, CharsetUtil.US_ASCII)));\n        HttpRequest req = channel.readInbound();\n        assertEquals(HttpMethod.GET, req.method());\n        assertEquals(\"/some/path\", req.uri());\n        assertEquals(HttpVersion.HTTP_1_1, req.protocolVersion());\n        assertTrue(channel.finishAndReleaseAll());\n    }\n\n    @Test\n    public void testTooLargeHeaders() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(1024, 10, 1024));\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Host: localhost1\\r\\n\\r\\n\";\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertTrue(request.decoderResult().isFailure());\n        assertTrue(request.decoderResult().cause() instanceof TooLongFrameException);\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testWhitespace() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Transfer-Encoding : chunked\\r\\n\" +\n                \"Host: netty.io\\r\\n\\r\\n\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testWhitespaceBeforeTransferEncoding01() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \" Transfer-Encoding : chunked\\r\\n\" +\n                \"Content-Length: 1\\r\\n\" +\n                \"Host: netty.io\\r\\n\\r\\n\" +\n                \"a\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testWhitespaceBeforeTransferEncoding02() {\n        String requestStr = \"POST / HTTP/1.1\" +\n                \" Transfer-Encoding : chunked\\r\\n\" +\n                \"Host: target.com\" +\n                \"Content-Length: 65\\r\\n\\r\\n\" +\n                \"0\\r\\n\\r\\n\" +\n                \"GET /maliciousRequest HTTP/1.1\\r\\n\" +\n                \"Host: evilServer.com\\r\\n\" +\n                \"Foo: x\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testHeaderWithNoValueAndMissingColon() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 0\\r\\n\" +\n                \"Host:\\r\\n\" +\n                \"netty.io\\r\\n\\r\\n\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testMultipleContentLengthHeaders() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 1\\r\\n\" +\n                \"Content-Length: 0\\r\\n\\r\\n\" +\n                \"b\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testMultipleContentLengthHeaders2() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 1\\r\\n\" +\n                \"Connection: close\\r\\n\" +\n                \"Content-Length: 0\\r\\n\\r\\n\" +\n                \"b\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testContentLengthHeaderWithCommaValue() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 1,1\\r\\n\\r\\n\" +\n                \"b\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testMultipleContentLengthHeadersWithFolding() {\n        String requestStr = \"POST / HTTP/1.1\\r\\n\" +\n                \"Host: example.com\\r\\n\" +\n                \"Connection: close\\r\\n\" +\n                \"Content-Length: 5\\r\\n\" +\n                \"Content-Length:\\r\\n\" +\n                \"\\t6\\r\\n\\r\\n\" +\n                \"123456\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testContentLengthAndTransferEncodingHeadersWithVerticalTab() {\n        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0b, false);\n        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0b, true);\n    }\n\n    @Test\n    public void testContentLengthAndTransferEncodingHeadersWithCR() {\n        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0d, false);\n        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0d, true);\n    }\n\n    private static void testContentLengthAndTransferEncodingHeadersWithInvalidSeparator(\n            char separator, boolean extraLine) {\n        String requestStr = \"POST / HTTP/1.1\\r\\n\" +\n                \"Host: example.com\\r\\n\" +\n                \"Connection: close\\r\\n\" +\n                \"Content-Length: 9\\r\\n\" +\n                \"Transfer-Encoding:\" + separator + \"chunked\\r\\n\\r\\n\" +\n                (extraLine ? \"0\\r\\n\\r\\n\" : \"\") +\n                \"something\\r\\n\\r\\n\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testContentLengthHeaderAndChunked() {\n        String requestStr = \"POST / HTTP/1.1\\r\\n\" +\n                \"Host: example.com\\r\\n\" +\n                \"Connection: close\\r\\n\" +\n                \"Content-Length: 5\\r\\n\" +\n                \"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n                \"0\\r\\n\\r\\n\";\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertFalse(request.decoderResult().isFailure());\n        assertTrue(request.headers().contains(\"Transfer-Encoding\", \"chunked\", false));\n        assertFalse(request.headers().contains(\"Content-Length\"));\n        LastHttpContent c = channel.readInbound();\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testHttpMessageDecoderResult() {\n        String requestStr = \"PUT /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 11\\r\\n\" +\n                \"Connection: close\\r\\n\\r\\n\" +\n                \"Lorem ipsum\";\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertTrue(request.decoderResult().isSuccess());\n        assertThat(request.decoderResult(), instanceOf(HttpMessageDecoderResult.class));\n        HttpMessageDecoderResult decoderResult = (HttpMessageDecoderResult) request.decoderResult();\n        assertThat(decoderResult.initialLineLength(), is(23));\n        assertThat(decoderResult.headerSize(), is(35));\n        assertThat(decoderResult.totalSize(), is(58));\n        HttpContent c = channel.readInbound();\n        c.release();\n        assertFalse(channel.finish());\n    }\n\n    private static void testInvalidHeaders0(String requestStr) {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertTrue(request.decoderResult().isFailure());\n        assertTrue(request.decoderResult().cause() instanceof IllegalArgumentException);\n        assertFalse(channel.finish());\n    }\n}\n", "/*\n * Copyright 2013 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.handler.codec.PrematureChannelClosureException;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.CharsetUtil;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\nimport static io.netty.handler.codec.http.HttpHeadersTestUtils.of;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.not;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.CoreMatchers.sameInstance;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class HttpResponseDecoderTest {\n\n    /**\n     * The size of headers should be calculated correctly even if a single header is split into multiple fragments.\n     * @see <a href=\"https://github.com/netty/netty/issues/3445\">#3445</a>\n     */\n    @Test\n    public void testMaxHeaderSize1() {\n        final int maxHeaderSize = 8192;\n\n        final EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, maxHeaderSize, 8192));\n        final char[] bytes = new char[maxHeaderSize / 2 - 4];\n        Arrays.fill(bytes, 'a');\n\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Write two 4096-byte headers (= 8192 bytes)\n        ch.writeInbound(Unpooled.copiedBuffer(\"A:\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n        assertNull(ch.readInbound());\n        ch.writeInbound(Unpooled.copiedBuffer(\"B:\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertNull(res.decoderResult().cause());\n        assertTrue(res.decoderResult().isSuccess());\n\n        assertNull(ch.readInbound());\n        assertTrue(ch.finish());\n        assertThat(ch.readInbound(), instanceOf(LastHttpContent.class));\n    }\n\n    /**\n     * Complementary test case of {@link #testMaxHeaderSize1()} When it actually exceeds the maximum, it should fail.\n     */\n    @Test\n    public void testMaxHeaderSize2() {\n        final int maxHeaderSize = 8192;\n\n        final EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, maxHeaderSize, 8192));\n        final char[] bytes = new char[maxHeaderSize / 2 - 2];\n        Arrays.fill(bytes, 'a');\n\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Write a 4096-byte header and a 4097-byte header to test an off-by-one case (= 8193 bytes)\n        ch.writeInbound(Unpooled.copiedBuffer(\"A:\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n        assertNull(ch.readInbound());\n        ch.writeInbound(Unpooled.copiedBuffer(\"B: \", CharsetUtil.US_ASCII)); // Note an extra space.\n        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertTrue(res.decoderResult().cause() instanceof TooLongFrameException);\n\n        assertFalse(ch.finish());\n        assertNull(ch.readInbound());\n    }\n\n    @Test\n    public void testResponseChunked() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\",\n                CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        byte[] data = new byte[64];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(data.length) + \"\\r\\n\",\n                    CharsetUtil.US_ASCII)));\n            assertTrue(ch.writeInbound(Unpooled.copiedBuffer(data)));\n            HttpContent content = ch.readInbound();\n            assertEquals(data.length, content.content().readableBytes());\n\n            byte[] decodedData = new byte[data.length];\n            content.content().readBytes(decodedData);\n            assertArrayEquals(data, decodedData);\n            content.release();\n\n            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII)));\n        }\n\n        // Write the last chunk.\n        ch.writeInbound(Unpooled.copiedBuffer(\"0\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Ensure the last chunk was decoded.\n        LastHttpContent content = ch.readInbound();\n        assertFalse(content.content().isReadable());\n        content.release();\n\n        ch.finish();\n        assertNull(ch.readInbound());\n    }\n\n    @Test\n    public void testResponseDisallowPartialChunks() {\n        HttpResponseDecoder decoder = new HttpResponseDecoder(\n            HttpObjectDecoder.DEFAULT_MAX_INITIAL_LINE_LENGTH,\n            HttpObjectDecoder.DEFAULT_MAX_HEADER_SIZE,\n            HttpObjectDecoder.DEFAULT_MAX_CHUNK_SIZE,\n            HttpObjectDecoder.DEFAULT_VALIDATE_HEADERS,\n            HttpObjectDecoder.DEFAULT_INITIAL_BUFFER_SIZE,\n            HttpObjectDecoder.DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS,\n            false);\n        EmbeddedChannel ch = new EmbeddedChannel(decoder);\n\n        String headers = \"HTTP/1.1 200 OK\\r\\n\"\n            + \"Transfer-Encoding: chunked\\r\\n\"\n            + \"\\r\\n\";\n       assertTrue(ch.writeInbound(Unpooled.copiedBuffer(headers, CharsetUtil.US_ASCII)));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        byte[] chunkBytes = new byte[10];\n        Random random = new Random();\n        random.nextBytes(chunkBytes);\n        final ByteBuf chunk = ch.alloc().buffer().writeBytes(chunkBytes);\n        final int chunkSize = chunk.readableBytes();\n        ByteBuf partialChunk1 = chunk.retainedSlice(0, 5);\n        ByteBuf partialChunk2 = chunk.retainedSlice(5, 5);\n\n        assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(chunkSize)\n                                                          + \"\\r\\n\", CharsetUtil.US_ASCII)));\n        assertFalse(ch.writeInbound(partialChunk1));\n        assertTrue(ch.writeInbound(partialChunk2));\n\n        HttpContent content = ch.readInbound();\n        assertEquals(chunk, content.content());\n        content.release();\n        chunk.release();\n\n        assertFalse(ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII)));\n\n        // Write the last chunk.\n        assertTrue(ch.writeInbound(Unpooled.copiedBuffer(\"0\\r\\n\\r\\n\", CharsetUtil.US_ASCII)));\n\n        // Ensure the last chunk was decoded.\n        HttpContent lastContent = ch.readInbound();\n        assertFalse(lastContent.content().isReadable());\n        lastContent.release();\n\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testResponseChunkedExceedMaxChunkSize() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, 8192, 32));\n        ch.writeInbound(\n                Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        byte[] data = new byte[64];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(data.length) + \"\\r\\n\",\n                    CharsetUtil.US_ASCII)));\n            assertTrue(ch.writeInbound(Unpooled.copiedBuffer(data)));\n\n            byte[] decodedData = new byte[data.length];\n            HttpContent content = ch.readInbound();\n            assertEquals(32, content.content().readableBytes());\n            content.content().readBytes(decodedData, 0, 32);\n            content.release();\n\n            content = ch.readInbound();\n            assertEquals(32, content.content().readableBytes());\n\n            content.content().readBytes(decodedData, 32, 32);\n\n            assertArrayEquals(data, decodedData);\n            content.release();\n\n            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII)));\n        }\n\n        // Write the last chunk.\n        ch.writeInbound(Unpooled.copiedBuffer(\"0\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Ensure the last chunk was decoded.\n        LastHttpContent content = ch.readInbound();\n        assertFalse(content.content().isReadable());\n        content.release();\n\n        ch.finish();\n        assertNull(ch.readInbound());\n    }\n\n    @Test\n    public void testClosureWithoutContentLength1() throws Exception {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Read the response headers.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Close the connection without sending anything.\n        assertTrue(ch.finish());\n\n        // The decoder should still produce the last content.\n        LastHttpContent content = ch.readInbound();\n        assertThat(content.content().isReadable(), is(false));\n        content.release();\n\n        // But nothing more.\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testClosureWithoutContentLength2() throws Exception {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n\n        // Write the partial response.\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\\r\\n12345678\", CharsetUtil.US_ASCII));\n\n        // Read the response headers.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        // Read the partial content.\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().toString(CharsetUtil.US_ASCII), is(\"12345678\"));\n        assertThat(content, is(not(instanceOf(LastHttpContent.class))));\n        content.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Close the connection.\n        assertTrue(ch.finish());\n\n        // The decoder should still produce the last content.\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        lastContent.release();\n\n        // But nothing more.\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testPrematureClosureWithChunkedEncoding1() throws Exception {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(\n                Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Read the response headers.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is(\"chunked\"));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Close the connection without sending anything.\n        ch.finish();\n        // The decoder should not generate the last chunk because it's closed prematurely.\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testPrematureClosureWithChunkedEncoding2() throws Exception {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n\n        // Write the partial response.\n        ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n8\\r\\n12345678\", CharsetUtil.US_ASCII));\n\n        // Read the response headers.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is(\"chunked\"));\n\n        // Read the partial content.\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().toString(CharsetUtil.US_ASCII), is(\"12345678\"));\n        assertThat(content, is(not(instanceOf(LastHttpContent.class))));\n        content.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Close the connection.\n        ch.finish();\n\n        // The decoder should not generate the last chunk because it's closed prematurely.\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testLastResponseWithEmptyHeaderAndEmptyContent() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        assertThat(ch.finish(), is(true));\n\n        LastHttpContent content = ch.readInbound();\n        assertThat(content.content().isReadable(), is(false));\n        content.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testLastResponseWithoutContentLengthHeader() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().readableBytes(), is(1024));\n        content.release();\n\n        assertThat(ch.finish(), is(true));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        lastContent.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testLastResponseWithHeaderRemoveTrailingSpaces() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 200 OK\\r\\nX-Header: h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT       \\r\\n\\r\\n\",\n                CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(res.headers().get(of(\"X-Header\")), is(\"h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\"));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().readableBytes(), is(1024));\n        content.release();\n\n        assertThat(ch.finish(), is(true));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        lastContent.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testResetContentResponseWithTransferEncoding() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        assertTrue(ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 205 Reset Content\\r\\n\" +\n                \"Transfer-Encoding: chunked\\r\\n\" +\n                \"\\r\\n\" +\n                \"0\\r\\n\" +\n                \"\\r\\n\",\n                CharsetUtil.US_ASCII)));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.RESET_CONTENT));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n    }\n\n    @Test\n    public void testLastResponseWithTrailingHeader() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 200 OK\\r\\n\" +\n                        \"Transfer-Encoding: chunked\\r\\n\" +\n                        \"\\r\\n\" +\n                        \"0\\r\\n\" +\n                        \"Set-Cookie: t1=t1v1\\r\\n\" +\n                        \"Set-Cookie: t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\\r\\n\" +\n                        \"\\r\\n\",\n                CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        HttpHeaders headers = lastContent.trailingHeaders();\n        assertEquals(1, headers.names().size());\n        List<String> values = headers.getAll(of(\"Set-Cookie\"));\n        assertEquals(2, values.size());\n        assertTrue(values.contains(\"t1=t1v1\"));\n        assertTrue(values.contains(\"t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\"));\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testLastResponseWithTrailingHeaderFragmented() {\n        byte[] data = (\"HTTP/1.1 200 OK\\r\\n\" +\n                \"Transfer-Encoding: chunked\\r\\n\" +\n                \"\\r\\n\" +\n                \"0\\r\\n\" +\n                \"Set-Cookie: t1=t1v1\\r\\n\" +\n                \"Set-Cookie: t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\\r\\n\" +\n                \"\\r\\n\").getBytes(CharsetUtil.US_ASCII);\n\n        for (int i = 1; i < data.length; i++) {\n            testLastResponseWithTrailingHeaderFragmented(data, i);\n        }\n    }\n\n    private static void testLastResponseWithTrailingHeaderFragmented(byte[] content, int fragmentSize) {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        int headerLength = 47;\n        // split up the header\n        for (int a = 0; a < headerLength;) {\n            int amount = fragmentSize;\n            if (a + amount > headerLength) {\n                amount = headerLength -  a;\n            }\n\n            // if header is done it should produce an HttpRequest\n            boolean headerDone = a + amount == headerLength;\n            assertEquals(headerDone, ch.writeInbound(Unpooled.copiedBuffer(content, a, amount)));\n            a += amount;\n        }\n\n        ch.writeInbound(Unpooled.copiedBuffer(content, headerLength, content.length - headerLength));\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        HttpHeaders headers = lastContent.trailingHeaders();\n        assertEquals(1, headers.names().size());\n        List<String> values = headers.getAll(of(\"Set-Cookie\"));\n        assertEquals(2, values.size());\n        assertTrue(values.contains(\"t1=t1v1\"));\n        assertTrue(values.contains(\"t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\"));\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testResponseWithContentLength() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 200 OK\\r\\n\" +\n                        \"Content-Length: 10\\r\\n\" +\n                        \"\\r\\n\", CharsetUtil.US_ASCII));\n\n        byte[] data = new byte[10];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n        ch.writeInbound(Unpooled.copiedBuffer(data, 0, data.length / 2));\n        ch.writeInbound(Unpooled.copiedBuffer(data, 5, data.length / 2));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        HttpContent firstContent = ch.readInbound();\n        assertThat(firstContent.content().readableBytes(), is(5));\n        assertEquals(Unpooled.copiedBuffer(data, 0, 5), firstContent.content());\n        firstContent.release();\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertEquals(5, lastContent.content().readableBytes());\n        assertEquals(Unpooled.copiedBuffer(data, 5, 5), lastContent.content());\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testResponseWithContentLengthFragmented() {\n        byte[] data = (\"HTTP/1.1 200 OK\\r\\n\" +\n                \"Content-Length: 10\\r\\n\" +\n                \"\\r\\n\").getBytes(CharsetUtil.US_ASCII);\n\n        for (int i = 1; i < data.length; i++) {\n            testResponseWithContentLengthFragmented(data, i);\n        }\n    }\n\n    private static void testResponseWithContentLengthFragmented(byte[] header, int fragmentSize) {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        // split up the header\n        for (int a = 0; a < header.length;) {\n            int amount = fragmentSize;\n            if (a + amount > header.length) {\n                amount = header.length -  a;\n            }\n\n            ch.writeInbound(Unpooled.copiedBuffer(header, a, amount));\n            a += amount;\n        }\n        byte[] data = new byte[10];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n        ch.writeInbound(Unpooled.copiedBuffer(data, 0, data.length / 2));\n        ch.writeInbound(Unpooled.copiedBuffer(data, 5, data.length / 2));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        HttpContent firstContent = ch.readInbound();\n        assertThat(firstContent.content().readableBytes(), is(5));\n        assertEquals(Unpooled.wrappedBuffer(data, 0, 5), firstContent.content());\n        firstContent.release();\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertEquals(5, lastContent.content().readableBytes());\n        assertEquals(Unpooled.wrappedBuffer(data, 5, 5), lastContent.content());\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testWebSocketResponse() {\n        byte[] data = (\"HTTP/1.1 101 WebSocket Protocol Handshake\\r\\n\" +\n                \"Upgrade: WebSocket\\r\\n\" +\n                \"Connection: Upgrade\\r\\n\" +\n                \"Sec-WebSocket-Origin: http://localhost:8080\\r\\n\" +\n                \"Sec-WebSocket-Location: ws://localhost/some/path\\r\\n\" +\n                \"\\r\\n\" +\n                \"1234567812345678\").getBytes();\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.wrappedBuffer(data));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().readableBytes(), is(16));\n        content.release();\n\n        assertThat(ch.finish(), is(false));\n\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    // See https://github.com/netty/netty/issues/2173\n    @Test\n    public void testWebSocketResponseWithDataFollowing() {\n        byte[] data = (\"HTTP/1.1 101 WebSocket Protocol Handshake\\r\\n\" +\n                \"Upgrade: WebSocket\\r\\n\" +\n                \"Connection: Upgrade\\r\\n\" +\n                \"Sec-WebSocket-Origin: http://localhost:8080\\r\\n\" +\n                \"Sec-WebSocket-Location: ws://localhost/some/path\\r\\n\" +\n                \"\\r\\n\" +\n                \"1234567812345678\").getBytes();\n        byte[] otherData = {1, 2, 3, 4};\n\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(data, otherData));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().readableBytes(), is(16));\n        content.release();\n\n        assertThat(ch.finish(), is(true));\n\n        ByteBuf expected = Unpooled.wrappedBuffer(otherData);\n        ByteBuf buffer = ch.readInbound();\n        try {\n            assertEquals(expected, buffer);\n        } finally {\n            expected.release();\n            if (buffer != null) {\n                buffer.release();\n            }\n        }\n    }\n\n    @Test\n    public void testGarbageHeaders() {\n        // A response without headers - from https://github.com/netty/netty/issues/2103\n        byte[] data = (\"<html>\\r\\n\" +\n                \"<head><title>400 Bad Request</title></head>\\r\\n\" +\n                \"<body bgcolor=\\\"white\\\">\\r\\n\" +\n                \"<center><h1>400 Bad Request</h1></center>\\r\\n\" +\n                \"<hr><center>nginx/1.1.19</center>\\r\\n\" +\n                \"</body>\\r\\n\" +\n                \"</html>\\r\\n\").getBytes();\n\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n\n        ch.writeInbound(Unpooled.copiedBuffer(data));\n\n        // Garbage input should generate the 999 Unknown response.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_0));\n        assertThat(res.status().code(), is(999));\n        assertThat(res.decoderResult().isFailure(), is(true));\n        assertThat(res.decoderResult().isFinished(), is(true));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // More garbage should not generate anything (i.e. the decoder discards anything beyond this point.)\n        ch.writeInbound(Unpooled.copiedBuffer(data));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Closing the connection should not generate anything since the protocol has been violated.\n        ch.finish();\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    /**\n     * Tests if the decoder produces one and only {@link LastHttpContent} when an invalid chunk is received and\n     * the connection is closed.\n     */\n    @Test\n    public void testGarbageChunk() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());\n        String responseWithIllegalChunk =\n                \"HTTP/1.1 200 OK\\r\\n\" +\n                \"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n                \"NOT_A_CHUNK_LENGTH\\r\\n\";\n\n        channel.writeInbound(Unpooled.copiedBuffer(responseWithIllegalChunk, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpResponse.class)));\n\n        // Ensure that the decoder generates the last chunk with correct decoder result.\n        LastHttpContent invalidChunk = channel.readInbound();\n        assertThat(invalidChunk.decoderResult().isFailure(), is(true));\n        invalidChunk.release();\n\n        // And no more messages should be produced by the decoder.\n        assertThat(channel.readInbound(), is(nullValue()));\n\n        // .. even after the connection is closed.\n        assertThat(channel.finish(), is(false));\n    }\n\n    @Test\n    public void testConnectionClosedBeforeHeadersReceived() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());\n        String responseInitialLine =\n                \"HTTP/1.1 200 OK\\r\\n\";\n        assertFalse(channel.writeInbound(Unpooled.copiedBuffer(responseInitialLine, CharsetUtil.US_ASCII)));\n        assertTrue(channel.finish());\n        HttpMessage message = channel.readInbound();\n        assertTrue(message.decoderResult().isFailure());\n        assertThat(message.decoderResult().cause(), instanceOf(PrematureChannelClosureException.class));\n        assertNull(channel.readInbound());\n    }\n\n    @Test\n    public void testTrailerWithEmptyLineInSeparateBuffer() {\n        HttpResponseDecoder decoder = new HttpResponseDecoder();\n        EmbeddedChannel channel = new EmbeddedChannel(decoder);\n\n        String headers = \"HTTP/1.1 200 OK\\r\\n\"\n                + \"Transfer-Encoding: chunked\\r\\n\"\n                + \"Trailer: My-Trailer\\r\\n\";\n        assertFalse(channel.writeInbound(Unpooled.copiedBuffer(headers.getBytes(CharsetUtil.US_ASCII))));\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\".getBytes(CharsetUtil.US_ASCII))));\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(\"0\\r\\n\", CharsetUtil.US_ASCII)));\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(\"My-Trailer: 42\\r\\n\", CharsetUtil.US_ASCII)));\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII)));\n\n        HttpResponse response = channel.readInbound();\n        assertEquals(2, response.headers().size());\n        assertEquals(\"chunked\", response.headers().get(HttpHeaderNames.TRANSFER_ENCODING));\n        assertEquals(\"My-Trailer\", response.headers().get(HttpHeaderNames.TRAILER));\n\n        LastHttpContent lastContent = channel.readInbound();\n        assertEquals(1, lastContent.trailingHeaders().size());\n        assertEquals(\"42\", lastContent.trailingHeaders().get(\"My-Trailer\"));\n        assertEquals(0, lastContent.content().readableBytes());\n        lastContent.release();\n\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testWhitespace() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());\n        String requestStr = \"HTTP/1.1 200 OK\\r\\n\" +\n                \"Transfer-Encoding : chunked\\r\\n\" +\n                \"Host: netty.io\\n\\r\\n\";\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpResponse response = channel.readInbound();\n        assertFalse(response.decoderResult().isFailure());\n        assertEquals(HttpHeaderValues.CHUNKED.toString(), response.headers().get(HttpHeaderNames.TRANSFER_ENCODING));\n        assertEquals(\"netty.io\", response.headers().get(HttpHeaderNames.HOST));\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testHttpMessageDecoderResult() {\n        String responseStr = \"HTTP/1.1 200 OK\\r\\n\" +\n                \"Content-Length: 11\\r\\n\" +\n                \"Connection: close\\r\\n\\r\\n\" +\n                \"Lorem ipsum\";\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(responseStr, CharsetUtil.US_ASCII)));\n        HttpResponse response = channel.readInbound();\n        assertTrue(response.decoderResult().isSuccess());\n        assertThat(response.decoderResult(), instanceOf(HttpMessageDecoderResult.class));\n        HttpMessageDecoderResult decoderResult = (HttpMessageDecoderResult) response.decoderResult();\n        assertThat(decoderResult.initialLineLength(), is(15));\n        assertThat(decoderResult.headerSize(), is(35));\n        assertThat(decoderResult.totalSize(), is(50));\n        HttpContent c = channel.readInbound();\n        c.release();\n        assertFalse(channel.finish());\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.handler.codec.CharSequenceValueConverter;\nimport io.netty.handler.codec.DateFormatter;\nimport io.netty.handler.codec.DefaultHeaders;\nimport io.netty.handler.codec.DefaultHeaders.NameValidator;\nimport io.netty.handler.codec.DefaultHeadersImpl;\nimport io.netty.handler.codec.HeadersUtils;\nimport io.netty.handler.codec.ValueConverter;\nimport io.netty.util.AsciiString;\nimport io.netty.util.ByteProcessor;\nimport io.netty.util.internal.PlatformDependent;\n\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport static io.netty.util.AsciiString.CASE_INSENSITIVE_HASHER;\nimport static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;\n\n/**\n * Default implementation of {@link HttpHeaders}.\n */\npublic class DefaultHttpHeaders extends HttpHeaders {\n    private static final int HIGHEST_INVALID_VALUE_CHAR_MASK = ~15;\n    private static final ByteProcessor HEADER_NAME_VALIDATOR = new ByteProcessor() {\n        @Override\n        public boolean process(byte value) throws Exception {\n            validateHeaderNameElement(value);\n            return true;\n        }\n    };\n    static final NameValidator<CharSequence> HttpNameValidator = new NameValidator<CharSequence>() {\n        @Override\n        public void validateName(CharSequence name) {\n            if (name == null || name.length() == 0) {\n                throw new IllegalArgumentException(\"empty headers are not allowed [\" + name + \"]\");\n            }\n            if (name instanceof AsciiString) {\n                try {\n                    ((AsciiString) name).forEachByte(HEADER_NAME_VALIDATOR);\n                } catch (Exception e) {\n                    PlatformDependent.throwException(e);\n                }\n            } else {\n                // Go through each character in the name\n                for (int index = 0; index < name.length(); ++index) {\n                    validateHeaderNameElement(name.charAt(index));\n                }\n            }\n        }\n    };\n\n    private final DefaultHeaders<CharSequence, CharSequence, ?> headers;\n\n    public DefaultHttpHeaders() {\n        this(true);\n    }\n\n    /**\n     * <b>Warning!</b> Setting <code>validate</code> to <code>false</code> will mean that Netty won't\n     * validate & protect against user-supplied header values that are malicious.\n     * This can leave your server implementation vulnerable to\n     * <a href=\"https://cwe.mitre.org/data/definitions/113.html\">\n     *     CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')\n     * </a>.\n     * When disabling this validation, it is the responsibility of the caller to ensure that the values supplied\n     * do not contain a non-url-escaped carriage return (CR) and/or line feed (LF) characters.\n     *\n     * @param validate Should Netty validate Header values to ensure they aren't malicious.\n     */\n    public DefaultHttpHeaders(boolean validate) {\n        this(validate, nameValidator(validate));\n    }\n\n    protected DefaultHttpHeaders(boolean validate, NameValidator<CharSequence> nameValidator) {\n        this(new DefaultHeadersImpl<CharSequence, CharSequence>(CASE_INSENSITIVE_HASHER,\n                                                                valueConverter(validate),\n                                                                nameValidator));\n    }\n\n    protected DefaultHttpHeaders(DefaultHeaders<CharSequence, CharSequence, ?> headers) {\n        this.headers = headers;\n    }\n\n    @Override\n    public HttpHeaders add(HttpHeaders headers) {\n        if (headers instanceof DefaultHttpHeaders) {\n            this.headers.add(((DefaultHttpHeaders) headers).headers);\n            return this;\n        } else {\n            return super.add(headers);\n        }\n    }\n\n    @Override\n    public HttpHeaders set(HttpHeaders headers) {\n        if (headers instanceof DefaultHttpHeaders) {\n            this.headers.set(((DefaultHttpHeaders) headers).headers);\n            return this;\n        } else {\n            return super.set(headers);\n        }\n    }\n\n    @Override\n    public HttpHeaders add(String name, Object value) {\n        headers.addObject(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders add(CharSequence name, Object value) {\n        headers.addObject(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders add(String name, Iterable<?> values) {\n        headers.addObject(name, values);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders add(CharSequence name, Iterable<?> values) {\n        headers.addObject(name, values);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders addInt(CharSequence name, int value) {\n        headers.addInt(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders addShort(CharSequence name, short value) {\n        headers.addShort(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders remove(String name) {\n        headers.remove(name);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders remove(CharSequence name) {\n        headers.remove(name);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders set(String name, Object value) {\n        headers.setObject(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders set(CharSequence name, Object value) {\n        headers.setObject(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders set(String name, Iterable<?> values) {\n        headers.setObject(name, values);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders set(CharSequence name, Iterable<?> values) {\n        headers.setObject(name, values);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders setInt(CharSequence name, int value) {\n        headers.setInt(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders setShort(CharSequence name, short value) {\n        headers.setShort(name, value);\n        return this;\n    }\n\n    @Override\n    public HttpHeaders clear() {\n        headers.clear();\n        return this;\n    }\n\n    @Override\n    public String get(String name) {\n        return get((CharSequence) name);\n    }\n\n    @Override\n    public String get(CharSequence name) {\n        return HeadersUtils.getAsString(headers, name);\n    }\n\n    @Override\n    public Integer getInt(CharSequence name) {\n        return headers.getInt(name);\n    }\n\n    @Override\n    public int getInt(CharSequence name, int defaultValue) {\n        return headers.getInt(name, defaultValue);\n    }\n\n    @Override\n    public Short getShort(CharSequence name) {\n        return headers.getShort(name);\n    }\n\n    @Override\n    public short getShort(CharSequence name, short defaultValue) {\n        return headers.getShort(name, defaultValue);\n    }\n\n    @Override\n    public Long getTimeMillis(CharSequence name) {\n        return headers.getTimeMillis(name);\n    }\n\n    @Override\n    public long getTimeMillis(CharSequence name, long defaultValue) {\n        return headers.getTimeMillis(name, defaultValue);\n    }\n\n    @Override\n    public List<String> getAll(String name) {\n        return getAll((CharSequence) name);\n    }\n\n    @Override\n    public List<String> getAll(CharSequence name) {\n        return HeadersUtils.getAllAsString(headers, name);\n    }\n\n    @Override\n    public List<Entry<String, String>> entries() {\n        if (isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<Entry<String, String>> entriesConverted = new ArrayList<Entry<String, String>>(\n                headers.size());\n        for (Entry<String, String> entry : this) {\n            entriesConverted.add(entry);\n        }\n        return entriesConverted;\n    }\n\n    @Deprecated\n    @Override\n    public Iterator<Map.Entry<String, String>> iterator() {\n        return HeadersUtils.iteratorAsString(headers);\n    }\n\n    @Override\n    public Iterator<Entry<CharSequence, CharSequence>> iteratorCharSequence() {\n        return headers.iterator();\n    }\n\n    @Override\n    public Iterator<String> valueStringIterator(CharSequence name) {\n        final Iterator<CharSequence> itr = valueCharSequenceIterator(name);\n        return new Iterator<String>() {\n            @Override\n            public boolean hasNext() {\n                return itr.hasNext();\n            }\n\n            @Override\n            public String next() {\n                return itr.next().toString();\n            }\n\n            @Override\n            public void remove() {\n                itr.remove();\n            }\n        };\n    }\n\n    @Override\n    public Iterator<CharSequence> valueCharSequenceIterator(CharSequence name) {\n        return headers.valueIterator(name);\n    }\n\n    @Override\n    public boolean contains(String name) {\n        return contains((CharSequence) name);\n    }\n\n    @Override\n    public boolean contains(CharSequence name) {\n        return headers.contains(name);\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return headers.isEmpty();\n    }\n\n    @Override\n    public int size() {\n        return headers.size();\n    }\n\n    @Override\n    public boolean contains(String name, String value, boolean ignoreCase) {\n        return contains((CharSequence) name, (CharSequence) value, ignoreCase);\n    }\n\n    @Override\n    public boolean contains(CharSequence name, CharSequence value, boolean ignoreCase) {\n        return headers.contains(name, value, ignoreCase ? CASE_INSENSITIVE_HASHER : CASE_SENSITIVE_HASHER);\n    }\n\n    @Override\n    public Set<String> names() {\n        return HeadersUtils.namesAsString(headers);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return o instanceof DefaultHttpHeaders\n                && headers.equals(((DefaultHttpHeaders) o).headers, CASE_SENSITIVE_HASHER);\n    }\n\n    @Override\n    public int hashCode() {\n        return headers.hashCode(CASE_SENSITIVE_HASHER);\n    }\n\n    @Override\n    public HttpHeaders copy() {\n        return new DefaultHttpHeaders(headers.copy());\n    }\n\n    private static void validateHeaderNameElement(byte value) {\n        switch (value) {\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x00:\n        case '\\t':\n        case '\\n':\n        case 0x0b:\n        case '\\f':\n        case '\\r':\n        case ' ':\n        case ',':\n        case ':':\n        case ';':\n        case '=':\n            throw new IllegalArgumentException(\n               \"a header name cannot contain the following prohibited characters: =,;: \\\\t\\\\r\\\\n\\\\v\\\\f: \" +\n                       value);\n        default:\n            // Check to see if the character is not an ASCII character, or invalid\n            if (value < 0) {\n                throw new IllegalArgumentException(\"a header name cannot contain non-ASCII character: \" + value);\n            }\n        }\n    }\n\n    private static void validateHeaderNameElement(char value) {\n        switch (value) {\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x00:\n        case '\\t':\n        case '\\n':\n        case 0x0b:\n        case '\\f':\n        case '\\r':\n        case ' ':\n        case ',':\n        case ':':\n        case ';':\n        case '=':\n            throw new IllegalArgumentException(\n               \"a header name cannot contain the following prohibited characters: =,;: \\\\t\\\\r\\\\n\\\\v\\\\f: \" +\n                       value);\n        default:\n            // Check to see if the character is not an ASCII character, or invalid\n            if (value > 127) {\n                throw new IllegalArgumentException(\"a header name cannot contain non-ASCII character: \" +\n                        value);\n            }\n        }\n    }\n\n    static ValueConverter<CharSequence> valueConverter(boolean validate) {\n        return validate ? HeaderValueConverterAndValidator.INSTANCE : HeaderValueConverter.INSTANCE;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static NameValidator<CharSequence> nameValidator(boolean validate) {\n        return validate ? HttpNameValidator : NameValidator.NOT_NULL;\n    }\n\n    private static class HeaderValueConverter extends CharSequenceValueConverter {\n        static final HeaderValueConverter INSTANCE = new HeaderValueConverter();\n\n        @Override\n        public CharSequence convertObject(Object value) {\n            if (value instanceof CharSequence) {\n                return (CharSequence) value;\n            }\n            if (value instanceof Date) {\n                return DateFormatter.format((Date) value);\n            }\n            if (value instanceof Calendar) {\n                return DateFormatter.format(((Calendar) value).getTime());\n            }\n            return value.toString();\n        }\n    }\n\n    private static final class HeaderValueConverterAndValidator extends HeaderValueConverter {\n        static final HeaderValueConverterAndValidator INSTANCE = new HeaderValueConverterAndValidator();\n\n        @Override\n        public CharSequence convertObject(Object value) {\n            CharSequence seq = super.convertObject(value);\n            int state = 0;\n            // Start looping through each of the character\n            for (int index = 0; index < seq.length(); index++) {\n                state = validateValueChar(seq, state, seq.charAt(index));\n            }\n\n            if (state != 0) {\n                throw new IllegalArgumentException(\"a header value must not end with '\\\\r' or '\\\\n':\" + seq);\n            }\n            return seq;\n        }\n\n        private static int validateValueChar(CharSequence seq, int state, char character) {\n            /*\n             * State:\n             * 0: Previous character was neither CR nor LF\n             * 1: The previous character was CR\n             * 2: The previous character was LF\n             */\n            if ((character & HIGHEST_INVALID_VALUE_CHAR_MASK) == 0) {\n                // Check the absolutely prohibited characters.\n                switch (character) {\n                case 0x0: // NULL\n                    throw new IllegalArgumentException(\"a header value contains a prohibited character '\\0': \" + seq);\n                case 0x0b: // Vertical tab\n                    throw new IllegalArgumentException(\"a header value contains a prohibited character '\\\\v': \" + seq);\n                case '\\f':\n                    throw new IllegalArgumentException(\"a header value contains a prohibited character '\\\\f': \" + seq);\n                default:\n                    break;\n                }\n            }\n\n            // Check the CRLF (HT | SP) pattern\n            switch (state) {\n                case 0:\n                    switch (character) {\n                        case '\\r':\n                            return 1;\n                        case '\\n':\n                            return 2;\n                        default:\n                            break;\n                    }\n                    break;\n                case 1:\n                    if (character == '\\n') {\n                        return 2;\n                    }\n                    throw new IllegalArgumentException(\"only '\\\\n' is allowed after '\\\\r': \" + seq);\n                case 2:\n                    switch (character) {\n                        case '\\t':\n                        case ' ':\n                            return 0;\n                        default:\n                            throw new IllegalArgumentException(\"only ' ' and '\\\\t' are allowed after '\\\\n': \" + seq);\n                    }\n                default:\n                    break;\n            }\n            return state;\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport static io.netty.util.internal.ObjectUtil.checkPositive;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.codec.DecoderResult;\nimport io.netty.handler.codec.PrematureChannelClosureException;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.ByteProcessor;\nimport io.netty.util.internal.AppendableCharSequence;\n\nimport java.util.List;\n\n/**\n * Decodes {@link ByteBuf}s into {@link HttpMessage}s and\n * {@link HttpContent}s.\n *\n * <h3>Parameters that prevents excessive memory consumption</h3>\n * <table border=\"1\">\n * <tr>\n * <th>Name</th><th>Default value</th><th>Meaning</th>\n * </tr>\n * <tr>\n * <td>{@code maxInitialLineLength}</td>\n * <td>{@value #DEFAULT_MAX_INITIAL_LINE_LENGTH}</td>\n * <td>The maximum length of the initial line\n *     (e.g. {@code \"GET / HTTP/1.0\"} or {@code \"HTTP/1.0 200 OK\"})\n *     If the length of the initial line exceeds this value, a\n *     {@link TooLongFrameException} will be raised.</td>\n * </tr>\n * <tr>\n * <td>{@code maxHeaderSize}</td>\n * <td>{@value #DEFAULT_MAX_HEADER_SIZE}</td>\n * <td>The maximum length of all headers.  If the sum of the length of each\n *     header exceeds this value, a {@link TooLongFrameException} will be raised.</td>\n * </tr>\n * <tr>\n * <td>{@code maxChunkSize}</td>\n * <td>{@value #DEFAULT_MAX_CHUNK_SIZE}</td>\n * <td>The maximum length of the content or each chunk.  If the content length\n *     (or the length of each chunk) exceeds this value, the content or chunk\n *     will be split into multiple {@link HttpContent}s whose length is\n *     {@code maxChunkSize} at maximum.</td>\n * </tr>\n * </table>\n *\n * <h3>Parameters that control parsing behavior</h3>\n * <table border=\"1\">\n * <tr>\n * <th>Name</th><th>Default value</th><th>Meaning</th>\n * </tr>\n * <tr>\n * <td>{@code allowDuplicateContentLengths}</td>\n * <td>{@value #DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS}</td>\n * <td>When set to {@code false}, will reject any messages that contain multiple Content-Length header fields.\n *     When set to {@code true}, will allow multiple Content-Length headers only if they are all the same decimal value.\n *     The duplicated field-values will be replaced with a single valid Content-Length field.\n *     See <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.2\">RFC 7230, Section 3.3.2</a>.</td>\n * </tr>\n * <tr>\n * <td>{@code allowPartialChunks}</td>\n * <td>{@value #DEFAULT_ALLOW_PARTIAL_CHUNKS}</td>\n * <td>If the length of a chunk exceeds the {@link ByteBuf}s readable bytes and {@code allowPartialChunks}\n *     is set to {@code true}, the chunk will be split into multiple {@link HttpContent}s.\n *     Otherwise, if the chunk size does not exceed {@code maxChunkSize} and {@code allowPartialChunks}\n *     is set to {@code false}, the {@link ByteBuf} is not decoded into an {@link HttpContent} until\n *     the readable bytes are greater or equal to the chunk size.</td>\n * </tr>\n * </table>\n *\n * <h3>Chunked Content</h3>\n *\n * If the content of an HTTP message is greater than {@code maxChunkSize} or\n * the transfer encoding of the HTTP message is 'chunked', this decoder\n * generates one {@link HttpMessage} instance and its following\n * {@link HttpContent}s per single HTTP message to avoid excessive memory\n * consumption. For example, the following HTTP message:\n * <pre>\n * GET / HTTP/1.1\n * Transfer-Encoding: chunked\n *\n * 1a\n * abcdefghijklmnopqrstuvwxyz\n * 10\n * 1234567890abcdef\n * 0\n * Content-MD5: ...\n * <i>[blank line]</i>\n * </pre>\n * triggers {@link HttpRequestDecoder} to generate 3 objects:\n * <ol>\n * <li>An {@link HttpRequest},</li>\n * <li>The first {@link HttpContent} whose content is {@code 'abcdefghijklmnopqrstuvwxyz'},</li>\n * <li>The second {@link LastHttpContent} whose content is {@code '1234567890abcdef'}, which marks\n * the end of the content.</li>\n * </ol>\n *\n * If you prefer not to handle {@link HttpContent}s by yourself for your\n * convenience, insert {@link HttpObjectAggregator} after this decoder in the\n * {@link ChannelPipeline}.  However, please note that your server might not\n * be as memory efficient as without the aggregator.\n *\n * <h3>Extensibility</h3>\n *\n * Please note that this decoder is designed to be extended to implement\n * a protocol derived from HTTP, such as\n * <a href=\"https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol\">RTSP</a> and\n * <a href=\"https://en.wikipedia.org/wiki/Internet_Content_Adaptation_Protocol\">ICAP</a>.\n * To implement the decoder of such a derived protocol, extend this class and\n * implement all abstract methods properly.\n */\npublic abstract class HttpObjectDecoder extends ByteToMessageDecoder {\n    public static final int DEFAULT_MAX_INITIAL_LINE_LENGTH = 4096;\n    public static final int DEFAULT_MAX_HEADER_SIZE = 8192;\n    public static final boolean DEFAULT_CHUNKED_SUPPORTED = true;\n    public static final boolean DEFAULT_ALLOW_PARTIAL_CHUNKS = true;\n    public static final int DEFAULT_MAX_CHUNK_SIZE = 8192;\n    public static final boolean DEFAULT_VALIDATE_HEADERS = true;\n    public static final int DEFAULT_INITIAL_BUFFER_SIZE = 128;\n    public static final boolean DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS = false;\n\n    private static final String EMPTY_VALUE = \"\";\n\n    private final int maxChunkSize;\n    private final boolean chunkedSupported;\n    private final boolean allowPartialChunks;\n    protected final boolean validateHeaders;\n    private final boolean allowDuplicateContentLengths;\n    private final HeaderParser headerParser;\n    private final LineParser lineParser;\n\n    private HttpMessage message;\n    private long chunkSize;\n    private long contentLength = Long.MIN_VALUE;\n    private volatile boolean resetRequested;\n\n    // These will be updated by splitHeader(...)\n    private CharSequence name;\n    private CharSequence value;\n\n    private LastHttpContent trailer;\n\n    /**\n     * The internal state of {@link HttpObjectDecoder}.\n     * <em>Internal use only</em>.\n     */\n    private enum State {\n        SKIP_CONTROL_CHARS,\n        READ_INITIAL,\n        READ_HEADER,\n        READ_VARIABLE_LENGTH_CONTENT,\n        READ_FIXED_LENGTH_CONTENT,\n        READ_CHUNK_SIZE,\n        READ_CHUNKED_CONTENT,\n        READ_CHUNK_DELIMITER,\n        READ_CHUNK_FOOTER,\n        BAD_MESSAGE,\n        UPGRADED\n    }\n\n    private State currentState = State.SKIP_CONTROL_CHARS;\n\n    /**\n     * Creates a new instance with the default\n     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and\n     * {@code maxChunkSize (8192)}.\n     */\n    protected HttpObjectDecoder() {\n        this(DEFAULT_MAX_INITIAL_LINE_LENGTH, DEFAULT_MAX_HEADER_SIZE, DEFAULT_MAX_CHUNK_SIZE,\n             DEFAULT_CHUNKED_SUPPORTED);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean chunkedSupported) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, DEFAULT_VALIDATE_HEADERS);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders,\n             DEFAULT_INITIAL_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders, initialBufferSize,\n             DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize,\n            boolean allowDuplicateContentLengths) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders, initialBufferSize,\n            allowDuplicateContentLengths, DEFAULT_ALLOW_PARTIAL_CHUNKS);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize,\n            boolean allowDuplicateContentLengths, boolean allowPartialChunks) {\n        checkPositive(maxInitialLineLength, \"maxInitialLineLength\");\n        checkPositive(maxHeaderSize, \"maxHeaderSize\");\n        checkPositive(maxChunkSize, \"maxChunkSize\");\n\n        AppendableCharSequence seq = new AppendableCharSequence(initialBufferSize);\n        lineParser = new LineParser(seq, maxInitialLineLength);\n        headerParser = new HeaderParser(seq, maxHeaderSize);\n        this.maxChunkSize = maxChunkSize;\n        this.chunkedSupported = chunkedSupported;\n        this.validateHeaders = validateHeaders;\n        this.allowDuplicateContentLengths = allowDuplicateContentLengths;\n        this.allowPartialChunks = allowPartialChunks;\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) {\n        case SKIP_CONTROL_CHARS:\n            // Fall-through\n        case READ_INITIAL: try {\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line);\n            if (initialLine.length < 3) {\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;\n                return;\n            }\n\n            message = createMessage(initialLine);\n            currentState = State.READ_HEADER;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {\n            State nextState = readHeaders(buffer);\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:\n                // fast-path\n                // No content is expected.\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE:\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:\n                /**\n                 * <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.3\">RFC 7230, 3.3.3</a> states that if a\n                 * request does not have either a transfer-encoding or a content-length header then the message body\n                 * length is 0. However for a response the body length is the number of octets received prior to the\n                 * server closing the connection. So we treat this as variable length chunked encoding.\n                 */\n                long contentLength = contentLength();\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                    resetNow();\n                    return;\n                }\n\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT;\n\n                out.add(message);\n\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength;\n                }\n\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {\n            int readLimit = buffer.readableBytes();\n\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create an HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);\n            chunkSize -= toRead;\n\n            if (chunkSize == 0) {\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow();\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: {\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            if (!allowPartialChunks && buffer.readableBytes() < toRead) {\n                return;\n            }\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n\n            out.add(chunk);\n\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        default:\n            break;\n        }\n    }\n\n    @Override\n    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        super.decodeLast(ctx, in, out);\n\n        if (resetRequested) {\n            // If a reset was requested by decodeLast() we need to do it now otherwise we may produce a\n            // LastHttpContent while there was already one.\n            resetNow();\n        }\n        // Handle the last unfinished message.\n        if (message != null) {\n            boolean chunked = HttpUtil.isTransferEncodingChunked(message);\n            if (currentState == State.READ_VARIABLE_LENGTH_CONTENT && !in.isReadable() && !chunked) {\n                // End of connection.\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            }\n\n            if (currentState == State.READ_HEADER) {\n                // If we are still in the state of reading headers we need to create a new invalid message that\n                // signals that the connection was closed before we received the headers.\n                out.add(invalidMessage(Unpooled.EMPTY_BUFFER,\n                        new PrematureChannelClosureException(\"Connection closed before received headers\")));\n                resetNow();\n                return;\n            }\n\n            // Check if the closure of the connection signifies the end of the content.\n            boolean prematureClosure;\n            if (isDecodingRequest() || chunked) {\n                // The last request did not wait for a response.\n                prematureClosure = true;\n            } else {\n                // Compare the length of the received content and the 'Content-Length' header.\n                // If the 'Content-Length' header is absent, the length of the content is determined by the end of the\n                // connection, so it is perfectly fine.\n                prematureClosure = contentLength() > 0;\n            }\n\n            if (!prematureClosure) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            }\n            resetNow();\n        }\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof HttpExpectationFailedEvent) {\n            switch (currentState) {\n            case READ_FIXED_LENGTH_CONTENT:\n            case READ_VARIABLE_LENGTH_CONTENT:\n            case READ_CHUNK_SIZE:\n                reset();\n                break;\n            default:\n                break;\n            }\n        }\n        super.userEventTriggered(ctx, evt);\n    }\n\n    protected boolean isContentAlwaysEmpty(HttpMessage msg) {\n        if (msg instanceof HttpResponse) {\n            HttpResponse res = (HttpResponse) msg;\n            int code = res.status().code();\n\n            // Correctly handle return codes of 1xx.\n            //\n            // See:\n            //     - https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html Section 4.4\n            //     - https://github.com/netty/netty/issues/222\n            if (code >= 100 && code < 200) {\n                // One exception: Hixie 76 websocket handshake response\n                return !(code == 101 && !res.headers().contains(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT)\n                         && res.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true));\n            }\n\n            switch (code) {\n            case 204: case 304:\n                return true;\n            default:\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the server switched to a different protocol than HTTP/1.0 or HTTP/1.1, e.g. HTTP/2 or Websocket.\n     * Returns false if the upgrade happened in a different layer, e.g. upgrade from HTTP/1.1 to HTTP/1.1 over TLS.\n     */\n    protected boolean isSwitchingToNonHttp1Protocol(HttpResponse msg) {\n        if (msg.status().code() != HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {\n            return false;\n        }\n        String newProtocol = msg.headers().get(HttpHeaderNames.UPGRADE);\n        return newProtocol == null ||\n                !newProtocol.contains(HttpVersion.HTTP_1_0.text()) &&\n                !newProtocol.contains(HttpVersion.HTTP_1_1.text());\n    }\n\n    /**\n     * Resets the state of the decoder so that it is ready to decode a new message.\n     * This method is useful for handling a rejected request with {@code Expect: 100-continue} header.\n     */\n    public void reset() {\n        resetRequested = true;\n    }\n\n    private void resetNow() {\n        HttpMessage message = this.message;\n        this.message = null;\n        name = null;\n        value = null;\n        contentLength = Long.MIN_VALUE;\n        lineParser.reset();\n        headerParser.reset();\n        trailer = null;\n        if (!isDecodingRequest()) {\n            HttpResponse res = (HttpResponse) message;\n            if (res != null && isSwitchingToNonHttp1Protocol(res)) {\n                currentState = State.UPGRADED;\n                return;\n            }\n        }\n\n        resetRequested = false;\n        currentState = State.SKIP_CONTROL_CHARS;\n    }\n\n    private HttpMessage invalidMessage(ByteBuf in, Exception cause) {\n        currentState = State.BAD_MESSAGE;\n\n        // Advance the readerIndex so that ByteToMessageDecoder does not complain\n        // when we produced an invalid message without consuming anything.\n        in.skipBytes(in.readableBytes());\n\n        if (message == null) {\n            message = createInvalidMessage();\n        }\n        message.setDecoderResult(DecoderResult.failure(cause));\n\n        HttpMessage ret = message;\n        message = null;\n        return ret;\n    }\n\n    private HttpContent invalidChunk(ByteBuf in, Exception cause) {\n        currentState = State.BAD_MESSAGE;\n\n        // Advance the readerIndex so that ByteToMessageDecoder does not complain\n        // when we produced an invalid message without consuming anything.\n        in.skipBytes(in.readableBytes());\n\n        HttpContent chunk = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER);\n        chunk.setDecoderResult(DecoderResult.failure(cause));\n        message = null;\n        trailer = null;\n        return chunk;\n    }\n\n    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        // Done parsing initial line and headers. Set decoder result.\n        HttpMessageDecoderResult decoderResult = new HttpMessageDecoderResult(lineParser.size, headerParser.size);\n        message.setDecoderResult(decoderResult);\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        if (!contentLengthFields.isEmpty()) {\n            HttpVersion version = message.protocolVersion();\n            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1\n                    && version.minorVersion() == 0);\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,\n                    isHttp10OrEarlier, allowDuplicateContentLengths);\n            if (contentLength != -1) {\n                headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);\n            }\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }\n\n    /**\n     * Invoked when a message with both a \"Transfer-Encoding: chunked\" and a \"Content-Length\" header field is detected.\n     * The default behavior is to <i>remove</i> the Content-Length field, but this method could be overridden\n     * to change the behavior (to, e.g., throw an exception and produce an invalid message).\n     * <p>\n     * See: https://tools.ietf.org/html/rfc7230#section-3.3.3\n     * <pre>\n     *     If a message is received with both a Transfer-Encoding and a\n     *     Content-Length header field, the Transfer-Encoding overrides the\n     *     Content-Length.  Such a message might indicate an attempt to\n     *     perform request smuggling (Section 9.5) or response splitting\n     *     (Section 9.4) and ought to be handled as an error.  A sender MUST\n     *     remove the received Content-Length field prior to forwarding such\n     *     a message downstream.\n     * </pre>\n     * Also see:\n     * https://github.com/apache/tomcat/blob/b693d7c1981fa7f51e58bc8c8e72e3fe80b7b773/\n     * java/org/apache/coyote/http11/Http11Processor.java#L747-L755\n     * https://github.com/nginx/nginx/blob/0ad4393e30c119d250415cb769e3d8bc8dce5186/\n     * src/http/ngx_http_request.c#L1946-L1953\n     */\n    protected void handleTransferEncodingChunkedWithContentLength(HttpMessage message) {\n        message.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n        contentLength = Long.MIN_VALUE;\n    }\n\n    private long contentLength() {\n        if (contentLength == Long.MIN_VALUE) {\n            contentLength = HttpUtil.getContentLength(message, -1L);\n        }\n        return contentLength;\n    }\n\n    private LastHttpContent readTrailingHeaders(ByteBuf buffer) {\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        LastHttpContent trailer = this.trailer;\n        if (line.length() == 0 && trailer == null) {\n            // We have received the empty line which signals the trailer is complete and did not parse any trailers\n            // before. Just return an empty last content to reduce allocations.\n            return LastHttpContent.EMPTY_LAST_CONTENT;\n        }\n\n        CharSequence lastHeader = null;\n        if (trailer == null) {\n            trailer = this.trailer = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);\n        }\n        while (line.length() > 0) {\n            char firstChar = line.charAtUnsafe(0);\n            if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                List<String> current = trailer.trailingHeaders().getAll(lastHeader);\n                if (!current.isEmpty()) {\n                    int lastPos = current.size() - 1;\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String lineTrimmed = line.toString().trim();\n                    String currentLastPos = current.get(lastPos);\n                    current.set(lastPos, currentLastPos + lineTrimmed);\n                }\n            } else {\n                splitHeader(line);\n                CharSequence headerName = name;\n                if (!HttpHeaderNames.CONTENT_LENGTH.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRANSFER_ENCODING.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRAILER.contentEqualsIgnoreCase(headerName)) {\n                    trailer.trailingHeaders().add(headerName, value);\n                }\n                lastHeader = name;\n                // reset name and value fields\n                name = null;\n                value = null;\n            }\n            line = headerParser.parse(buffer);\n            if (line == null) {\n                return null;\n            }\n        }\n\n        this.trailer = null;\n        return trailer;\n    }\n\n    protected abstract boolean isDecodingRequest();\n    protected abstract HttpMessage createMessage(String[] initialLine) throws Exception;\n    protected abstract HttpMessage createInvalidMessage();\n\n    private static int getChunkSize(String hex) {\n        hex = hex.trim();\n        for (int i = 0; i < hex.length(); i ++) {\n            char c = hex.charAt(i);\n            if (c == ';' || Character.isWhitespace(c) || Character.isISOControl(c)) {\n                hex = hex.substring(0, i);\n                break;\n            }\n        }\n\n        return Integer.parseInt(hex, 16);\n    }\n\n    private static String[] splitInitialLine(AppendableCharSequence sb) {\n        int aStart;\n        int aEnd;\n        int bStart;\n        int bEnd;\n        int cStart;\n        int cEnd;\n\n        aStart = findNonSPLenient(sb, 0);\n        aEnd = findSPLenient(sb, aStart);\n\n        bStart = findNonSPLenient(sb, aEnd);\n        bEnd = findSPLenient(sb, bStart);\n\n        cStart = findNonSPLenient(sb, bEnd);\n        cEnd = findEndOfString(sb);\n\n        return new String[] {\n                sb.subStringUnsafe(aStart, aEnd),\n                sb.subStringUnsafe(bStart, bEnd),\n                cStart < cEnd? sb.subStringUnsafe(cStart, cEnd) : \"\" };\n    }\n\n    private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n            //\n            // No whitespace is allowed between the header field-name and colon. In\n            // the past, differences in the handling of such whitespace have led to\n            // security vulnerabilities in request routing and response handling. A\n            // server MUST reject any received request message that contains\n            // whitespace between a header field-name and colon with a response code\n            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n            // response message before forwarding the message downstream.\n            if (ch == ':' ||\n                    // In case of decoding a request we will just continue processing and header validation\n                    // is done in the DefaultHttpHeaders implementation.\n                    //\n                    // In the case of decoding a response we will \"skip\" the whitespace.\n                    (!isDecodingRequest() && isOWS(ch))) {\n                break;\n            }\n        }\n\n        if (nameEnd == length) {\n            // There was no colon present at all.\n            throw new IllegalArgumentException(\"No colon found\");\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }\n\n    private static int findNonSPLenient(AppendableCharSequence sb, int offset) {\n        for (int result = offset; result < sb.length(); ++result) {\n            char c = sb.charAtUnsafe(result);\n            // See https://tools.ietf.org/html/rfc7230#section-3.5\n            if (isSPLenient(c)) {\n                continue;\n            }\n            if (Character.isWhitespace(c)) {\n                // Any other whitespace delimiter is invalid\n                throw new IllegalArgumentException(\"Invalid separator\");\n            }\n            return result;\n        }\n        return sb.length();\n    }\n\n    private static int findSPLenient(AppendableCharSequence sb, int offset) {\n        for (int result = offset; result < sb.length(); ++result) {\n            if (isSPLenient(sb.charAtUnsafe(result))) {\n                return result;\n            }\n        }\n        return sb.length();\n    }\n\n    private static boolean isSPLenient(char c) {\n        // See https://tools.ietf.org/html/rfc7230#section-3.5\n        return c == ' ' || c == (char) 0x09 || c == (char) 0x0B || c == (char) 0x0C || c == (char) 0x0D;\n    }\n\n    private static int findNonWhitespace(AppendableCharSequence sb, int offset) {\n        for (int result = offset; result < sb.length(); ++result) {\n            char c = sb.charAtUnsafe(result);\n            if (!Character.isWhitespace(c)) {\n                return result;\n            } else if (!isOWS(c)) {\n                // Only OWS is supported for whitespace\n                throw new IllegalArgumentException(\"Invalid separator, only a single space or horizontal tab allowed,\" +\n                        \" but received a '\" + c + \"' (0x\" + Integer.toHexString(c) + \")\");\n            }\n        }\n        return sb.length();\n    }\n\n    private static int findEndOfString(AppendableCharSequence sb) {\n        for (int result = sb.length() - 1; result > 0; --result) {\n            if (!Character.isWhitespace(sb.charAtUnsafe(result))) {\n                return result + 1;\n            }\n        }\n        return 0;\n    }\n\n    private static boolean isOWS(char ch) {\n        return ch == ' ' || ch == (char) 0x09;\n    }\n\n    private static class HeaderParser implements ByteProcessor {\n        private final AppendableCharSequence seq;\n        private final int maxLength;\n        int size;\n\n        HeaderParser(AppendableCharSequence seq, int maxLength) {\n            this.seq = seq;\n            this.maxLength = maxLength;\n        }\n\n        public AppendableCharSequence parse(ByteBuf buffer) {\n            final int oldSize = size;\n            seq.reset();\n            int i = buffer.forEachByte(this);\n            if (i == -1) {\n                size = oldSize;\n                return null;\n            }\n            buffer.readerIndex(i + 1);\n            return seq;\n        }\n\n        public void reset() {\n            size = 0;\n        }\n\n        @Override\n        public boolean process(byte value) throws Exception {\n            char nextByte = (char) (value & 0xFF);\n            if (nextByte == HttpConstants.LF) {\n                int len = seq.length();\n                // Drop CR if we had a CRLF pair\n                if (len >= 1 && seq.charAtUnsafe(len - 1) == HttpConstants.CR) {\n                    -- size;\n                    seq.setLength(len - 1);\n                }\n                return false;\n            }\n\n            increaseCount();\n\n            seq.append(nextByte);\n            return true;\n        }\n\n        protected final void increaseCount() {\n            if (++ size > maxLength) {\n                // TODO: Respond with Bad Request and discard the traffic\n                //    or close the connection.\n                //       No need to notify the upstream handlers - just log.\n                //       If decoding a response, just throw an exception.\n                throw newException(maxLength);\n            }\n        }\n\n        protected TooLongFrameException newException(int maxLength) {\n            return new TooLongFrameException(\"HTTP header is larger than \" + maxLength + \" bytes.\");\n        }\n    }\n\n    private final class LineParser extends HeaderParser {\n\n        LineParser(AppendableCharSequence seq, int maxLength) {\n            super(seq, maxLength);\n        }\n\n        @Override\n        public AppendableCharSequence parse(ByteBuf buffer) {\n            // Suppress a warning because HeaderParser.reset() is supposed to be called\n            reset();    // lgtm[java/subtle-inherited-call]\n            return super.parse(buffer);\n        }\n\n        @Override\n        public boolean process(byte value) throws Exception {\n            if (currentState == State.SKIP_CONTROL_CHARS) {\n                char c = (char) (value & 0xFF);\n                if (Character.isISOControl(c) || Character.isWhitespace(c)) {\n                    increaseCount();\n                    return true;\n                }\n                currentState = State.READ_INITIAL;\n            }\n            return super.process(value);\n        }\n\n        @Override\n        protected TooLongFrameException newException(int maxLength) {\n            return new TooLongFrameException(\"An HTTP line is larger than \" + maxLength + \" bytes.\");\n        }\n    }\n}\n", "/*\n * Copyright 2013 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.AsciiString;\nimport io.netty.util.CharsetUtil;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static io.netty.handler.codec.http.HttpHeaderNames.*;\nimport static io.netty.handler.codec.http.HttpHeadersTestUtils.of;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class HttpRequestDecoderTest {\n    private static final byte[] CONTENT_CRLF_DELIMITERS = createContent(\"\\r\\n\");\n    private static final byte[] CONTENT_LF_DELIMITERS = createContent(\"\\n\");\n    private static final byte[] CONTENT_MIXED_DELIMITERS = createContent(\"\\r\\n\", \"\\n\");\n    private static final int CONTENT_LENGTH = 8;\n\n    private static byte[] createContent(String... lineDelimiters) {\n        String lineDelimiter;\n        String lineDelimiter2;\n        if (lineDelimiters.length == 2) {\n            lineDelimiter = lineDelimiters[0];\n            lineDelimiter2 = lineDelimiters[1];\n        } else {\n            lineDelimiter = lineDelimiters[0];\n            lineDelimiter2 = lineDelimiters[0];\n        }\n        return (\"GET /some/path?foo=bar&wibble=eek HTTP/1.1\" + \"\\r\\n\" +\n                \"Upgrade: WebSocket\" + lineDelimiter2 +\n                \"Connection: Upgrade\" + lineDelimiter +\n                \"Host: localhost\" + lineDelimiter2 +\n                \"Origin: http://localhost:8080\" + lineDelimiter +\n                \"Sec-WebSocket-Key1: 10  28 8V7 8 48     0\" + lineDelimiter2 +\n                \"Sec-WebSocket-Key2: 8 Xt754O3Q3QW 0   _60\" + lineDelimiter +\n                \"Content-Length: \" + CONTENT_LENGTH + lineDelimiter2 +\n                \"\\r\\n\"  +\n                \"12345678\").getBytes(CharsetUtil.US_ASCII);\n    }\n\n    @Test\n    public void testDecodeWholeRequestAtOnceCRLFDelimiters() {\n        testDecodeWholeRequestAtOnce(CONTENT_CRLF_DELIMITERS);\n    }\n\n    @Test\n    public void testDecodeWholeRequestAtOnceLFDelimiters() {\n        testDecodeWholeRequestAtOnce(CONTENT_LF_DELIMITERS);\n    }\n\n    @Test\n    public void testDecodeWholeRequestAtOnceMixedDelimiters() {\n        testDecodeWholeRequestAtOnce(CONTENT_MIXED_DELIMITERS);\n    }\n\n    private static void testDecodeWholeRequestAtOnce(byte[] content) {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(content)));\n        HttpRequest req = channel.readInbound();\n        assertNotNull(req);\n        checkHeaders(req.headers());\n        LastHttpContent c = channel.readInbound();\n        assertEquals(CONTENT_LENGTH, c.content().readableBytes());\n        assertEquals(\n                Unpooled.wrappedBuffer(content, content.length - CONTENT_LENGTH, CONTENT_LENGTH),\n                c.content().readSlice(CONTENT_LENGTH));\n        c.release();\n\n        assertFalse(channel.finish());\n        assertNull(channel.readInbound());\n    }\n\n    private static void checkHeaders(HttpHeaders headers) {\n        assertEquals(7, headers.names().size());\n        checkHeader(headers, \"Upgrade\", \"WebSocket\");\n        checkHeader(headers, \"Connection\", \"Upgrade\");\n        checkHeader(headers, \"Host\", \"localhost\");\n        checkHeader(headers, \"Origin\", \"http://localhost:8080\");\n        checkHeader(headers, \"Sec-WebSocket-Key1\", \"10  28 8V7 8 48     0\");\n        checkHeader(headers, \"Sec-WebSocket-Key2\", \"8 Xt754O3Q3QW 0   _60\");\n        checkHeader(headers, \"Content-Length\", String.valueOf(CONTENT_LENGTH));\n    }\n\n    private static void checkHeader(HttpHeaders headers, String name, String value) {\n        List<String> header1 = headers.getAll(of(name));\n        assertEquals(1, header1.size());\n        assertEquals(value, header1.get(0));\n    }\n\n    @Test\n    public void testDecodeWholeRequestInMultipleStepsCRLFDelimiters() {\n        testDecodeWholeRequestInMultipleSteps(CONTENT_CRLF_DELIMITERS);\n    }\n\n    @Test\n    public void testDecodeWholeRequestInMultipleStepsLFDelimiters() {\n        testDecodeWholeRequestInMultipleSteps(CONTENT_LF_DELIMITERS);\n    }\n\n    @Test\n    public void testDecodeWholeRequestInMultipleStepsMixedDelimiters() {\n        testDecodeWholeRequestInMultipleSteps(CONTENT_MIXED_DELIMITERS);\n    }\n\n    private static void testDecodeWholeRequestInMultipleSteps(byte[] content) {\n        for (int i = 1; i < content.length; i++) {\n            testDecodeWholeRequestInMultipleSteps(content, i);\n        }\n    }\n\n    private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fragmentSize) {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        int headerLength = content.length - CONTENT_LENGTH;\n\n        // split up the header\n        for (int a = 0; a < headerLength;) {\n            int amount = fragmentSize;\n            if (a + amount > headerLength) {\n                amount = headerLength -  a;\n            }\n\n            // if header is done it should produce an HttpRequest\n            channel.writeInbound(Unpooled.copiedBuffer(content, a, amount));\n            a += amount;\n        }\n\n        for (int i = CONTENT_LENGTH; i > 0; i --) {\n            // Should produce HttpContent\n            channel.writeInbound(Unpooled.copiedBuffer(content, content.length - i, 1));\n        }\n\n        HttpRequest req = channel.readInbound();\n        assertNotNull(req);\n        checkHeaders(req.headers());\n\n        for (int i = CONTENT_LENGTH; i > 1; i --) {\n            HttpContent c = channel.readInbound();\n            assertEquals(1, c.content().readableBytes());\n            assertEquals(content[content.length - i], c.content().readByte());\n            c.release();\n        }\n\n        LastHttpContent c = channel.readInbound();\n        assertEquals(1, c.content().readableBytes());\n        assertEquals(content[content.length - 1], c.content().readByte());\n        c.release();\n\n        assertFalse(channel.finish());\n        assertNull(channel.readInbound());\n    }\n\n    @Test\n    public void testMultiLineHeader() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        String crlf = \"\\r\\n\";\n        String request =  \"GET /some/path HTTP/1.1\" + crlf +\n                \"Host: localhost\" + crlf +\n                \"MyTestHeader: part1\" + crlf +\n                \"              newLinePart2\" + crlf +\n                \"MyTestHeader2: part21\" + crlf +\n                \"\\t            newLinePart22\"\n                + crlf + crlf;\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(request, CharsetUtil.US_ASCII)));\n        HttpRequest req = channel.readInbound();\n        assertEquals(\"part1 newLinePart2\", req.headers().get(of(\"MyTestHeader\")));\n        assertEquals(\"part21 newLinePart22\", req.headers().get(of(\"MyTestHeader2\")));\n\n        LastHttpContent c = channel.readInbound();\n        c.release();\n\n        assertFalse(channel.finish());\n        assertNull(channel.readInbound());\n    }\n\n    @Test\n    public void testEmptyHeaderValue() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        String crlf = \"\\r\\n\";\n        String request =  \"GET /some/path HTTP/1.1\" + crlf +\n                \"Host: localhost\" + crlf +\n                \"EmptyHeader:\" + crlf + crlf;\n        channel.writeInbound(Unpooled.copiedBuffer(request, CharsetUtil.US_ASCII));\n        HttpRequest req = channel.readInbound();\n        assertEquals(\"\", req.headers().get(of(\"EmptyHeader\")));\n    }\n\n    @Test\n    public void test100Continue() {\n        HttpRequestDecoder decoder = new HttpRequestDecoder();\n        EmbeddedChannel channel = new EmbeddedChannel(decoder);\n        String oversized =\n                \"PUT /file HTTP/1.1\\r\\n\" +\n                \"Expect: 100-continue\\r\\n\" +\n                \"Content-Length: 1048576000\\r\\n\\r\\n\";\n\n        channel.writeInbound(Unpooled.copiedBuffer(oversized, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));\n\n        // At this point, we assume that we sent '413 Entity Too Large' to the peer without closing the connection\n        // so that the client can try again.\n        decoder.reset();\n\n        String query = \"GET /max-file-size HTTP/1.1\\r\\n\\r\\n\";\n        channel.writeInbound(Unpooled.copiedBuffer(query, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));\n        assertThat(channel.readInbound(), is(instanceOf(LastHttpContent.class)));\n\n        assertThat(channel.finish(), is(false));\n    }\n\n    @Test\n    public void test100ContinueWithBadClient() {\n        HttpRequestDecoder decoder = new HttpRequestDecoder();\n        EmbeddedChannel channel = new EmbeddedChannel(decoder);\n        String oversized =\n                \"PUT /file HTTP/1.1\\r\\n\" +\n                \"Expect: 100-continue\\r\\n\" +\n                \"Content-Length: 1048576000\\r\\n\\r\\n\" +\n                \"WAY_TOO_LARGE_DATA_BEGINS\";\n\n        channel.writeInbound(Unpooled.copiedBuffer(oversized, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));\n\n        HttpContent prematureData = channel.readInbound();\n        prematureData.release();\n\n        assertThat(channel.readInbound(), is(nullValue()));\n\n        // At this point, we assume that we sent '413 Entity Too Large' to the peer without closing the connection\n        // so that the client can try again.\n        decoder.reset();\n\n        String query = \"GET /max-file-size HTTP/1.1\\r\\n\\r\\n\";\n        channel.writeInbound(Unpooled.copiedBuffer(query, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));\n        assertThat(channel.readInbound(), is(instanceOf(LastHttpContent.class)));\n\n        assertThat(channel.finish(), is(false));\n    }\n\n    @Test\n    public void testMessagesSplitBetweenMultipleBuffers() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        String crlf = \"\\r\\n\";\n        String str1 = \"GET /some/path HTTP/1.1\" + crlf +\n                \"Host: localhost1\" + crlf + crlf +\n                \"GET /some/other/path HTTP/1.0\" + crlf +\n                \"Hos\";\n        String str2 = \"t: localhost2\" + crlf +\n                \"content-length: 0\" + crlf + crlf;\n        channel.writeInbound(Unpooled.copiedBuffer(str1, CharsetUtil.US_ASCII));\n        HttpRequest req = channel.readInbound();\n        assertEquals(HttpVersion.HTTP_1_1, req.protocolVersion());\n        assertEquals(\"/some/path\", req.uri());\n        assertEquals(1, req.headers().size());\n        assertTrue(AsciiString.contentEqualsIgnoreCase(\"localhost1\", req.headers().get(HOST)));\n        LastHttpContent cnt = channel.readInbound();\n        cnt.release();\n\n        channel.writeInbound(Unpooled.copiedBuffer(str2, CharsetUtil.US_ASCII));\n        req = channel.readInbound();\n        assertEquals(HttpVersion.HTTP_1_0, req.protocolVersion());\n        assertEquals(\"/some/other/path\", req.uri());\n        assertEquals(2, req.headers().size());\n        assertTrue(AsciiString.contentEqualsIgnoreCase(\"localhost2\", req.headers().get(HOST)));\n        assertTrue(AsciiString.contentEqualsIgnoreCase(\"0\", req.headers().get(HttpHeaderNames.CONTENT_LENGTH)));\n        cnt = channel.readInbound();\n        cnt.release();\n        assertFalse(channel.finishAndReleaseAll());\n    }\n\n    @Test\n    public void testTooLargeInitialLine() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(10, 1024, 1024));\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Host: localhost1\\r\\n\\r\\n\";\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertTrue(request.decoderResult().isFailure());\n        assertTrue(request.decoderResult().cause() instanceof TooLongFrameException);\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testTooLargeInitialLineWithWSOnly() {\n        testTooLargeInitialLineWithControlCharsOnly(\"                    \");\n    }\n\n    @Test\n    public void testTooLargeInitialLineWithCRLFOnly() {\n        testTooLargeInitialLineWithControlCharsOnly(\"\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\");\n    }\n\n    private static void testTooLargeInitialLineWithControlCharsOnly(String controlChars) {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(15, 1024, 1024));\n        String requestStr = controlChars + \"GET / HTTP/1.1\\r\\n\" +\n                \"Host: localhost1\\r\\n\\r\\n\";\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertTrue(request.decoderResult().isFailure());\n        assertTrue(request.decoderResult().cause() instanceof TooLongFrameException);\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testInitialLineWithLeadingControlChars() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        String crlf = \"\\r\\n\";\n        String request =  crlf + \"GET /some/path HTTP/1.1\" + crlf +\n                \"Host: localhost\" + crlf + crlf;\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(request, CharsetUtil.US_ASCII)));\n        HttpRequest req = channel.readInbound();\n        assertEquals(HttpMethod.GET, req.method());\n        assertEquals(\"/some/path\", req.uri());\n        assertEquals(HttpVersion.HTTP_1_1, req.protocolVersion());\n        assertTrue(channel.finishAndReleaseAll());\n    }\n\n    @Test\n    public void testTooLargeHeaders() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(1024, 10, 1024));\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Host: localhost1\\r\\n\\r\\n\";\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertTrue(request.decoderResult().isFailure());\n        assertTrue(request.decoderResult().cause() instanceof TooLongFrameException);\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar1c() {\n        testHeaderNameStartsWithControlChar(0x1c);\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar1d() {\n        testHeaderNameStartsWithControlChar(0x1d);\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar1e() {\n        testHeaderNameStartsWithControlChar(0x1e);\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar1f() {\n        testHeaderNameStartsWithControlChar(0x1f);\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar0c() {\n        testHeaderNameStartsWithControlChar(0x0c);\n    }\n\n    private void testHeaderNameStartsWithControlChar(int controlChar) {\n        ByteBuf requestBuffer = Unpooled.buffer();\n        requestBuffer.writeCharSequence(\"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Host: netty.io\\r\\n\", CharsetUtil.US_ASCII);\n        requestBuffer.writeByte(controlChar);\n        requestBuffer.writeCharSequence(\"Transfer-Encoding: chunked\\r\\n\\r\\n\", CharsetUtil.US_ASCII);\n        testInvalidHeaders0(requestBuffer);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar1c() {\n        testHeaderNameEndsWithControlChar(0x1c);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar1d() {\n        testHeaderNameEndsWithControlChar(0x1d);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar1e() {\n        testHeaderNameEndsWithControlChar(0x1e);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar1f() {\n        testHeaderNameEndsWithControlChar(0x1f);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar0c() {\n        testHeaderNameEndsWithControlChar(0x0c);\n    }\n\n    private void testHeaderNameEndsWithControlChar(int controlChar) {\n        ByteBuf requestBuffer = Unpooled.buffer();\n        requestBuffer.writeCharSequence(\"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Host: netty.io\\r\\n\", CharsetUtil.US_ASCII);\n        requestBuffer.writeCharSequence(\"Transfer-Encoding\", CharsetUtil.US_ASCII);\n        requestBuffer.writeByte(controlChar);\n        requestBuffer.writeCharSequence(\": chunked\\r\\n\\r\\n\", CharsetUtil.US_ASCII);\n        testInvalidHeaders0(requestBuffer);\n    }\n\n    @Test\n    public void testWhitespace() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Transfer-Encoding : chunked\\r\\n\" +\n                \"Host: netty.io\\r\\n\\r\\n\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testWhitespaceInTransferEncoding01() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Transfer-Encoding : chunked\\r\\n\" +\n                \"Content-Length: 1\\r\\n\" +\n                \"Host: netty.io\\r\\n\\r\\n\" +\n                \"a\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testWhitespaceInTransferEncoding02() {\n        String requestStr = \"POST / HTTP/1.1\" +\n                \"Transfer-Encoding : chunked\\r\\n\" +\n                \"Host: target.com\" +\n                \"Content-Length: 65\\r\\n\\r\\n\" +\n                \"0\\r\\n\\r\\n\" +\n                \"GET /maliciousRequest HTTP/1.1\\r\\n\" +\n                \"Host: evilServer.com\\r\\n\" +\n                \"Foo: x\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testHeaderWithNoValueAndMissingColon() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 0\\r\\n\" +\n                \"Host:\\r\\n\" +\n                \"netty.io\\r\\n\\r\\n\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testMultipleContentLengthHeaders() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 1\\r\\n\" +\n                \"Content-Length: 0\\r\\n\\r\\n\" +\n                \"b\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testMultipleContentLengthHeaders2() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 1\\r\\n\" +\n                \"Connection: close\\r\\n\" +\n                \"Content-Length: 0\\r\\n\\r\\n\" +\n                \"b\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testContentLengthHeaderWithCommaValue() {\n        String requestStr = \"GET /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 1,1\\r\\n\\r\\n\" +\n                \"b\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testMultipleContentLengthHeadersWithFolding() {\n        String requestStr = \"POST / HTTP/1.1\\r\\n\" +\n                \"Host: example.com\\r\\n\" +\n                \"Connection: close\\r\\n\" +\n                \"Content-Length: 5\\r\\n\" +\n                \"Content-Length:\\r\\n\" +\n                \"\\t6\\r\\n\\r\\n\" +\n                \"123456\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testContentLengthAndTransferEncodingHeadersWithVerticalTab() {\n        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0b, false);\n        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0b, true);\n    }\n\n    @Test\n    public void testContentLengthAndTransferEncodingHeadersWithCR() {\n        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0d, false);\n        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0d, true);\n    }\n\n    private static void testContentLengthAndTransferEncodingHeadersWithInvalidSeparator(\n            char separator, boolean extraLine) {\n        String requestStr = \"POST / HTTP/1.1\\r\\n\" +\n                \"Host: example.com\\r\\n\" +\n                \"Connection: close\\r\\n\" +\n                \"Content-Length: 9\\r\\n\" +\n                \"Transfer-Encoding:\" + separator + \"chunked\\r\\n\\r\\n\" +\n                (extraLine ? \"0\\r\\n\\r\\n\" : \"\") +\n                \"something\\r\\n\\r\\n\";\n        testInvalidHeaders0(requestStr);\n    }\n\n    @Test\n    public void testContentLengthHeaderAndChunked() {\n        String requestStr = \"POST / HTTP/1.1\\r\\n\" +\n                \"Host: example.com\\r\\n\" +\n                \"Connection: close\\r\\n\" +\n                \"Content-Length: 5\\r\\n\" +\n                \"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n                \"0\\r\\n\\r\\n\";\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertFalse(request.decoderResult().isFailure());\n        assertTrue(request.headers().contains(\"Transfer-Encoding\", \"chunked\", false));\n        assertFalse(request.headers().contains(\"Content-Length\"));\n        LastHttpContent c = channel.readInbound();\n        c.release();\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testHttpMessageDecoderResult() {\n        String requestStr = \"PUT /some/path HTTP/1.1\\r\\n\" +\n                \"Content-Length: 11\\r\\n\" +\n                \"Connection: close\\r\\n\\r\\n\" +\n                \"Lorem ipsum\";\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpRequest request = channel.readInbound();\n        assertTrue(request.decoderResult().isSuccess());\n        assertThat(request.decoderResult(), instanceOf(HttpMessageDecoderResult.class));\n        HttpMessageDecoderResult decoderResult = (HttpMessageDecoderResult) request.decoderResult();\n        assertThat(decoderResult.initialLineLength(), is(23));\n        assertThat(decoderResult.headerSize(), is(35));\n        assertThat(decoderResult.totalSize(), is(58));\n        HttpContent c = channel.readInbound();\n        c.release();\n        assertFalse(channel.finish());\n    }\n\n    private static void testInvalidHeaders0(String requestStr) {\n        testInvalidHeaders0(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII));\n    }\n\n    private static void testInvalidHeaders0(ByteBuf requestBuffer) {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());\n        assertTrue(channel.writeInbound(requestBuffer));\n        HttpRequest request = channel.readInbound();\n        assertThat(request.decoderResult().cause(), instanceOf(IllegalArgumentException.class));\n        assertTrue(request.decoderResult().isFailure());\n        assertFalse(channel.finish());\n    }\n}\n", "/*\n * Copyright 2013 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.handler.codec.PrematureChannelClosureException;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.CharsetUtil;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\nimport static io.netty.handler.codec.http.HttpHeadersTestUtils.of;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.not;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.CoreMatchers.sameInstance;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class HttpResponseDecoderTest {\n\n    /**\n     * The size of headers should be calculated correctly even if a single header is split into multiple fragments.\n     * @see <a href=\"https://github.com/netty/netty/issues/3445\">#3445</a>\n     */\n    @Test\n    public void testMaxHeaderSize1() {\n        final int maxHeaderSize = 8192;\n\n        final EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, maxHeaderSize, 8192));\n        final char[] bytes = new char[maxHeaderSize / 2 - 4];\n        Arrays.fill(bytes, 'a');\n\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Write two 4096-byte headers (= 8192 bytes)\n        ch.writeInbound(Unpooled.copiedBuffer(\"A:\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n        assertNull(ch.readInbound());\n        ch.writeInbound(Unpooled.copiedBuffer(\"B:\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertNull(res.decoderResult().cause());\n        assertTrue(res.decoderResult().isSuccess());\n\n        assertNull(ch.readInbound());\n        assertTrue(ch.finish());\n        assertThat(ch.readInbound(), instanceOf(LastHttpContent.class));\n    }\n\n    /**\n     * Complementary test case of {@link #testMaxHeaderSize1()} When it actually exceeds the maximum, it should fail.\n     */\n    @Test\n    public void testMaxHeaderSize2() {\n        final int maxHeaderSize = 8192;\n\n        final EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, maxHeaderSize, 8192));\n        final char[] bytes = new char[maxHeaderSize / 2 - 2];\n        Arrays.fill(bytes, 'a');\n\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Write a 4096-byte header and a 4097-byte header to test an off-by-one case (= 8193 bytes)\n        ch.writeInbound(Unpooled.copiedBuffer(\"A:\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n        assertNull(ch.readInbound());\n        ch.writeInbound(Unpooled.copiedBuffer(\"B: \", CharsetUtil.US_ASCII)); // Note an extra space.\n        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n        ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertTrue(res.decoderResult().cause() instanceof TooLongFrameException);\n\n        assertFalse(ch.finish());\n        assertNull(ch.readInbound());\n    }\n\n    @Test\n    public void testResponseChunked() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\",\n                CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        byte[] data = new byte[64];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(data.length) + \"\\r\\n\",\n                    CharsetUtil.US_ASCII)));\n            assertTrue(ch.writeInbound(Unpooled.copiedBuffer(data)));\n            HttpContent content = ch.readInbound();\n            assertEquals(data.length, content.content().readableBytes());\n\n            byte[] decodedData = new byte[data.length];\n            content.content().readBytes(decodedData);\n            assertArrayEquals(data, decodedData);\n            content.release();\n\n            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII)));\n        }\n\n        // Write the last chunk.\n        ch.writeInbound(Unpooled.copiedBuffer(\"0\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Ensure the last chunk was decoded.\n        LastHttpContent content = ch.readInbound();\n        assertFalse(content.content().isReadable());\n        content.release();\n\n        ch.finish();\n        assertNull(ch.readInbound());\n    }\n\n    @Test\n    public void testResponseDisallowPartialChunks() {\n        HttpResponseDecoder decoder = new HttpResponseDecoder(\n            HttpObjectDecoder.DEFAULT_MAX_INITIAL_LINE_LENGTH,\n            HttpObjectDecoder.DEFAULT_MAX_HEADER_SIZE,\n            HttpObjectDecoder.DEFAULT_MAX_CHUNK_SIZE,\n            HttpObjectDecoder.DEFAULT_VALIDATE_HEADERS,\n            HttpObjectDecoder.DEFAULT_INITIAL_BUFFER_SIZE,\n            HttpObjectDecoder.DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS,\n            false);\n        EmbeddedChannel ch = new EmbeddedChannel(decoder);\n\n        String headers = \"HTTP/1.1 200 OK\\r\\n\"\n            + \"Transfer-Encoding: chunked\\r\\n\"\n            + \"\\r\\n\";\n       assertTrue(ch.writeInbound(Unpooled.copiedBuffer(headers, CharsetUtil.US_ASCII)));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        byte[] chunkBytes = new byte[10];\n        Random random = new Random();\n        random.nextBytes(chunkBytes);\n        final ByteBuf chunk = ch.alloc().buffer().writeBytes(chunkBytes);\n        final int chunkSize = chunk.readableBytes();\n        ByteBuf partialChunk1 = chunk.retainedSlice(0, 5);\n        ByteBuf partialChunk2 = chunk.retainedSlice(5, 5);\n\n        assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(chunkSize)\n                                                          + \"\\r\\n\", CharsetUtil.US_ASCII)));\n        assertFalse(ch.writeInbound(partialChunk1));\n        assertTrue(ch.writeInbound(partialChunk2));\n\n        HttpContent content = ch.readInbound();\n        assertEquals(chunk, content.content());\n        content.release();\n        chunk.release();\n\n        assertFalse(ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII)));\n\n        // Write the last chunk.\n        assertTrue(ch.writeInbound(Unpooled.copiedBuffer(\"0\\r\\n\\r\\n\", CharsetUtil.US_ASCII)));\n\n        // Ensure the last chunk was decoded.\n        HttpContent lastContent = ch.readInbound();\n        assertFalse(lastContent.content().isReadable());\n        lastContent.release();\n\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testResponseChunkedExceedMaxChunkSize() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, 8192, 32));\n        ch.writeInbound(\n                Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        byte[] data = new byte[64];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(data.length) + \"\\r\\n\",\n                    CharsetUtil.US_ASCII)));\n            assertTrue(ch.writeInbound(Unpooled.copiedBuffer(data)));\n\n            byte[] decodedData = new byte[data.length];\n            HttpContent content = ch.readInbound();\n            assertEquals(32, content.content().readableBytes());\n            content.content().readBytes(decodedData, 0, 32);\n            content.release();\n\n            content = ch.readInbound();\n            assertEquals(32, content.content().readableBytes());\n\n            content.content().readBytes(decodedData, 32, 32);\n\n            assertArrayEquals(data, decodedData);\n            content.release();\n\n            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII)));\n        }\n\n        // Write the last chunk.\n        ch.writeInbound(Unpooled.copiedBuffer(\"0\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Ensure the last chunk was decoded.\n        LastHttpContent content = ch.readInbound();\n        assertFalse(content.content().isReadable());\n        content.release();\n\n        ch.finish();\n        assertNull(ch.readInbound());\n    }\n\n    @Test\n    public void testClosureWithoutContentLength1() throws Exception {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Read the response headers.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Close the connection without sending anything.\n        assertTrue(ch.finish());\n\n        // The decoder should still produce the last content.\n        LastHttpContent content = ch.readInbound();\n        assertThat(content.content().isReadable(), is(false));\n        content.release();\n\n        // But nothing more.\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testClosureWithoutContentLength2() throws Exception {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n\n        // Write the partial response.\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\\r\\n12345678\", CharsetUtil.US_ASCII));\n\n        // Read the response headers.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        // Read the partial content.\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().toString(CharsetUtil.US_ASCII), is(\"12345678\"));\n        assertThat(content, is(not(instanceOf(LastHttpContent.class))));\n        content.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Close the connection.\n        assertTrue(ch.finish());\n\n        // The decoder should still produce the last content.\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        lastContent.release();\n\n        // But nothing more.\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testPrematureClosureWithChunkedEncoding1() throws Exception {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(\n                Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        // Read the response headers.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is(\"chunked\"));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Close the connection without sending anything.\n        ch.finish();\n        // The decoder should not generate the last chunk because it's closed prematurely.\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testPrematureClosureWithChunkedEncoding2() throws Exception {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n\n        // Write the partial response.\n        ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n8\\r\\n12345678\", CharsetUtil.US_ASCII));\n\n        // Read the response headers.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is(\"chunked\"));\n\n        // Read the partial content.\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().toString(CharsetUtil.US_ASCII), is(\"12345678\"));\n        assertThat(content, is(not(instanceOf(LastHttpContent.class))));\n        content.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Close the connection.\n        ch.finish();\n\n        // The decoder should not generate the last chunk because it's closed prematurely.\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testLastResponseWithEmptyHeaderAndEmptyContent() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        assertThat(ch.finish(), is(true));\n\n        LastHttpContent content = ch.readInbound();\n        assertThat(content.content().isReadable(), is(false));\n        content.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testLastResponseWithoutContentLengthHeader() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\"HTTP/1.1 200 OK\\r\\n\\r\\n\", CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().readableBytes(), is(1024));\n        content.release();\n\n        assertThat(ch.finish(), is(true));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        lastContent.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testLastResponseWithHeaderRemoveTrailingSpaces() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 200 OK\\r\\nX-Header: h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT       \\r\\n\\r\\n\",\n                CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n        assertThat(res.headers().get(of(\"X-Header\")), is(\"h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\"));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().readableBytes(), is(1024));\n        content.release();\n\n        assertThat(ch.finish(), is(true));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        lastContent.release();\n\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testResetContentResponseWithTransferEncoding() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        assertTrue(ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 205 Reset Content\\r\\n\" +\n                \"Transfer-Encoding: chunked\\r\\n\" +\n                \"\\r\\n\" +\n                \"0\\r\\n\" +\n                \"\\r\\n\",\n                CharsetUtil.US_ASCII)));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.RESET_CONTENT));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n    }\n\n    @Test\n    public void testLastResponseWithTrailingHeader() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 200 OK\\r\\n\" +\n                        \"Transfer-Encoding: chunked\\r\\n\" +\n                        \"\\r\\n\" +\n                        \"0\\r\\n\" +\n                        \"Set-Cookie: t1=t1v1\\r\\n\" +\n                        \"Set-Cookie: t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\\r\\n\" +\n                        \"\\r\\n\",\n                CharsetUtil.US_ASCII));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        HttpHeaders headers = lastContent.trailingHeaders();\n        assertEquals(1, headers.names().size());\n        List<String> values = headers.getAll(of(\"Set-Cookie\"));\n        assertEquals(2, values.size());\n        assertTrue(values.contains(\"t1=t1v1\"));\n        assertTrue(values.contains(\"t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\"));\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testLastResponseWithTrailingHeaderFragmented() {\n        byte[] data = (\"HTTP/1.1 200 OK\\r\\n\" +\n                \"Transfer-Encoding: chunked\\r\\n\" +\n                \"\\r\\n\" +\n                \"0\\r\\n\" +\n                \"Set-Cookie: t1=t1v1\\r\\n\" +\n                \"Set-Cookie: t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\\r\\n\" +\n                \"\\r\\n\").getBytes(CharsetUtil.US_ASCII);\n\n        for (int i = 1; i < data.length; i++) {\n            testLastResponseWithTrailingHeaderFragmented(data, i);\n        }\n    }\n\n    private static void testLastResponseWithTrailingHeaderFragmented(byte[] content, int fragmentSize) {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        int headerLength = 47;\n        // split up the header\n        for (int a = 0; a < headerLength;) {\n            int amount = fragmentSize;\n            if (a + amount > headerLength) {\n                amount = headerLength -  a;\n            }\n\n            // if header is done it should produce an HttpRequest\n            boolean headerDone = a + amount == headerLength;\n            assertEquals(headerDone, ch.writeInbound(Unpooled.copiedBuffer(content, a, amount)));\n            a += amount;\n        }\n\n        ch.writeInbound(Unpooled.copiedBuffer(content, headerLength, content.length - headerLength));\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertThat(lastContent.content().isReadable(), is(false));\n        HttpHeaders headers = lastContent.trailingHeaders();\n        assertEquals(1, headers.names().size());\n        List<String> values = headers.getAll(of(\"Set-Cookie\"));\n        assertEquals(2, values.size());\n        assertTrue(values.contains(\"t1=t1v1\"));\n        assertTrue(values.contains(\"t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\"));\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testResponseWithContentLength() {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(\n                \"HTTP/1.1 200 OK\\r\\n\" +\n                        \"Content-Length: 10\\r\\n\" +\n                        \"\\r\\n\", CharsetUtil.US_ASCII));\n\n        byte[] data = new byte[10];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n        ch.writeInbound(Unpooled.copiedBuffer(data, 0, data.length / 2));\n        ch.writeInbound(Unpooled.copiedBuffer(data, 5, data.length / 2));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        HttpContent firstContent = ch.readInbound();\n        assertThat(firstContent.content().readableBytes(), is(5));\n        assertEquals(Unpooled.copiedBuffer(data, 0, 5), firstContent.content());\n        firstContent.release();\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertEquals(5, lastContent.content().readableBytes());\n        assertEquals(Unpooled.copiedBuffer(data, 5, 5), lastContent.content());\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testResponseWithContentLengthFragmented() {\n        byte[] data = (\"HTTP/1.1 200 OK\\r\\n\" +\n                \"Content-Length: 10\\r\\n\" +\n                \"\\r\\n\").getBytes(CharsetUtil.US_ASCII);\n\n        for (int i = 1; i < data.length; i++) {\n            testResponseWithContentLengthFragmented(data, i);\n        }\n    }\n\n    private static void testResponseWithContentLengthFragmented(byte[] header, int fragmentSize) {\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        // split up the header\n        for (int a = 0; a < header.length;) {\n            int amount = fragmentSize;\n            if (a + amount > header.length) {\n                amount = header.length -  a;\n            }\n\n            ch.writeInbound(Unpooled.copiedBuffer(header, a, amount));\n            a += amount;\n        }\n        byte[] data = new byte[10];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n        ch.writeInbound(Unpooled.copiedBuffer(data, 0, data.length / 2));\n        ch.writeInbound(Unpooled.copiedBuffer(data, 5, data.length / 2));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.OK));\n\n        HttpContent firstContent = ch.readInbound();\n        assertThat(firstContent.content().readableBytes(), is(5));\n        assertEquals(Unpooled.wrappedBuffer(data, 0, 5), firstContent.content());\n        firstContent.release();\n\n        LastHttpContent lastContent = ch.readInbound();\n        assertEquals(5, lastContent.content().readableBytes());\n        assertEquals(Unpooled.wrappedBuffer(data, 5, 5), lastContent.content());\n        lastContent.release();\n\n        assertThat(ch.finish(), is(false));\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    @Test\n    public void testWebSocketResponse() {\n        byte[] data = (\"HTTP/1.1 101 WebSocket Protocol Handshake\\r\\n\" +\n                \"Upgrade: WebSocket\\r\\n\" +\n                \"Connection: Upgrade\\r\\n\" +\n                \"Sec-WebSocket-Origin: http://localhost:8080\\r\\n\" +\n                \"Sec-WebSocket-Location: ws://localhost/some/path\\r\\n\" +\n                \"\\r\\n\" +\n                \"1234567812345678\").getBytes();\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.wrappedBuffer(data));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().readableBytes(), is(16));\n        content.release();\n\n        assertThat(ch.finish(), is(false));\n\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    // See https://github.com/netty/netty/issues/2173\n    @Test\n    public void testWebSocketResponseWithDataFollowing() {\n        byte[] data = (\"HTTP/1.1 101 WebSocket Protocol Handshake\\r\\n\" +\n                \"Upgrade: WebSocket\\r\\n\" +\n                \"Connection: Upgrade\\r\\n\" +\n                \"Sec-WebSocket-Origin: http://localhost:8080\\r\\n\" +\n                \"Sec-WebSocket-Location: ws://localhost/some/path\\r\\n\" +\n                \"\\r\\n\" +\n                \"1234567812345678\").getBytes();\n        byte[] otherData = {1, 2, 3, 4};\n\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n        ch.writeInbound(Unpooled.copiedBuffer(data, otherData));\n\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));\n        assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));\n        HttpContent content = ch.readInbound();\n        assertThat(content.content().readableBytes(), is(16));\n        content.release();\n\n        assertThat(ch.finish(), is(true));\n\n        ByteBuf expected = Unpooled.wrappedBuffer(otherData);\n        ByteBuf buffer = ch.readInbound();\n        try {\n            assertEquals(expected, buffer);\n        } finally {\n            expected.release();\n            if (buffer != null) {\n                buffer.release();\n            }\n        }\n    }\n\n    @Test\n    public void testGarbageHeaders() {\n        // A response without headers - from https://github.com/netty/netty/issues/2103\n        byte[] data = (\"<html>\\r\\n\" +\n                \"<head><title>400 Bad Request</title></head>\\r\\n\" +\n                \"<body bgcolor=\\\"white\\\">\\r\\n\" +\n                \"<center><h1>400 Bad Request</h1></center>\\r\\n\" +\n                \"<hr><center>nginx/1.1.19</center>\\r\\n\" +\n                \"</body>\\r\\n\" +\n                \"</html>\\r\\n\").getBytes();\n\n        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());\n\n        ch.writeInbound(Unpooled.copiedBuffer(data));\n\n        // Garbage input should generate the 999 Unknown response.\n        HttpResponse res = ch.readInbound();\n        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_0));\n        assertThat(res.status().code(), is(999));\n        assertThat(res.decoderResult().isFailure(), is(true));\n        assertThat(res.decoderResult().isFinished(), is(true));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // More garbage should not generate anything (i.e. the decoder discards anything beyond this point.)\n        ch.writeInbound(Unpooled.copiedBuffer(data));\n        assertThat(ch.readInbound(), is(nullValue()));\n\n        // Closing the connection should not generate anything since the protocol has been violated.\n        ch.finish();\n        assertThat(ch.readInbound(), is(nullValue()));\n    }\n\n    /**\n     * Tests if the decoder produces one and only {@link LastHttpContent} when an invalid chunk is received and\n     * the connection is closed.\n     */\n    @Test\n    public void testGarbageChunk() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());\n        String responseWithIllegalChunk =\n                \"HTTP/1.1 200 OK\\r\\n\" +\n                \"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n                \"NOT_A_CHUNK_LENGTH\\r\\n\";\n\n        channel.writeInbound(Unpooled.copiedBuffer(responseWithIllegalChunk, CharsetUtil.US_ASCII));\n        assertThat(channel.readInbound(), is(instanceOf(HttpResponse.class)));\n\n        // Ensure that the decoder generates the last chunk with correct decoder result.\n        LastHttpContent invalidChunk = channel.readInbound();\n        assertThat(invalidChunk.decoderResult().isFailure(), is(true));\n        invalidChunk.release();\n\n        // And no more messages should be produced by the decoder.\n        assertThat(channel.readInbound(), is(nullValue()));\n\n        // .. even after the connection is closed.\n        assertThat(channel.finish(), is(false));\n    }\n\n    @Test\n    public void testConnectionClosedBeforeHeadersReceived() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());\n        String responseInitialLine =\n                \"HTTP/1.1 200 OK\\r\\n\";\n        assertFalse(channel.writeInbound(Unpooled.copiedBuffer(responseInitialLine, CharsetUtil.US_ASCII)));\n        assertTrue(channel.finish());\n        HttpMessage message = channel.readInbound();\n        assertTrue(message.decoderResult().isFailure());\n        assertThat(message.decoderResult().cause(), instanceOf(PrematureChannelClosureException.class));\n        assertNull(channel.readInbound());\n    }\n\n    @Test\n    public void testTrailerWithEmptyLineInSeparateBuffer() {\n        HttpResponseDecoder decoder = new HttpResponseDecoder();\n        EmbeddedChannel channel = new EmbeddedChannel(decoder);\n\n        String headers = \"HTTP/1.1 200 OK\\r\\n\"\n                + \"Transfer-Encoding: chunked\\r\\n\"\n                + \"Trailer: My-Trailer\\r\\n\";\n        assertFalse(channel.writeInbound(Unpooled.copiedBuffer(headers.getBytes(CharsetUtil.US_ASCII))));\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\".getBytes(CharsetUtil.US_ASCII))));\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(\"0\\r\\n\", CharsetUtil.US_ASCII)));\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(\"My-Trailer: 42\\r\\n\", CharsetUtil.US_ASCII)));\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(\"\\r\\n\", CharsetUtil.US_ASCII)));\n\n        HttpResponse response = channel.readInbound();\n        assertEquals(2, response.headers().size());\n        assertEquals(\"chunked\", response.headers().get(HttpHeaderNames.TRANSFER_ENCODING));\n        assertEquals(\"My-Trailer\", response.headers().get(HttpHeaderNames.TRAILER));\n\n        LastHttpContent lastContent = channel.readInbound();\n        assertEquals(1, lastContent.trailingHeaders().size());\n        assertEquals(\"42\", lastContent.trailingHeaders().get(\"My-Trailer\"));\n        assertEquals(0, lastContent.content().readableBytes());\n        lastContent.release();\n\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testWhitespace() {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());\n        String requestStr = \"HTTP/1.1 200 OK\\r\\n\" +\n                \"Transfer-Encoding : chunked\\r\\n\" +\n                \"Host: netty.io\\n\\r\\n\";\n\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));\n        HttpResponse response = channel.readInbound();\n        assertFalse(response.decoderResult().isFailure());\n        assertEquals(HttpHeaderValues.CHUNKED.toString(), response.headers().get(HttpHeaderNames.TRANSFER_ENCODING));\n        assertEquals(\"netty.io\", response.headers().get(HttpHeaderNames.HOST));\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testHttpMessageDecoderResult() {\n        String responseStr = \"HTTP/1.1 200 OK\\r\\n\" +\n                \"Content-Length: 11\\r\\n\" +\n                \"Connection: close\\r\\n\\r\\n\" +\n                \"Lorem ipsum\";\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());\n        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(responseStr, CharsetUtil.US_ASCII)));\n        HttpResponse response = channel.readInbound();\n        assertTrue(response.decoderResult().isSuccess());\n        assertThat(response.decoderResult(), instanceOf(HttpMessageDecoderResult.class));\n        HttpMessageDecoderResult decoderResult = (HttpMessageDecoderResult) response.decoderResult();\n        assertThat(decoderResult.initialLineLength(), is(15));\n        assertThat(decoderResult.headerSize(), is(35));\n        assertThat(decoderResult.totalSize(), is(50));\n        HttpContent c = channel.readInbound();\n        c.release();\n        assertFalse(channel.finish());\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar1c() {\n        testHeaderNameStartsWithControlChar(0x1c);\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar1d() {\n        testHeaderNameStartsWithControlChar(0x1d);\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar1e() {\n        testHeaderNameStartsWithControlChar(0x1e);\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar1f() {\n        testHeaderNameStartsWithControlChar(0x1f);\n    }\n\n    @Test\n    public void testHeaderNameStartsWithControlChar0c() {\n        testHeaderNameStartsWithControlChar(0x0c);\n    }\n\n    private void testHeaderNameStartsWithControlChar(int controlChar) {\n        ByteBuf responseBuffer = Unpooled.buffer();\n        responseBuffer.writeCharSequence(\"HTTP/1.1 200 OK\\r\\n\" +\n                \"Host: netty.io\\r\\n\", CharsetUtil.US_ASCII);\n        responseBuffer.writeByte(controlChar);\n        responseBuffer.writeCharSequence(\"Transfer-Encoding: chunked\\r\\n\\r\\n\", CharsetUtil.US_ASCII);\n        testInvalidHeaders0(responseBuffer);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar1c() {\n        testHeaderNameEndsWithControlChar(0x1c);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar1d() {\n        testHeaderNameEndsWithControlChar(0x1d);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar1e() {\n        testHeaderNameEndsWithControlChar(0x1e);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar1f() {\n        testHeaderNameEndsWithControlChar(0x1f);\n    }\n\n    @Test\n    public void testHeaderNameEndsWithControlChar0c() {\n        testHeaderNameEndsWithControlChar(0x0c);\n    }\n\n    private void testHeaderNameEndsWithControlChar(int controlChar) {\n        ByteBuf responseBuffer = Unpooled.buffer();\n        responseBuffer.writeCharSequence(\"HTTP/1.1 200 OK\\r\\n\" +\n                \"Host: netty.io\\r\\n\", CharsetUtil.US_ASCII);\n        responseBuffer.writeCharSequence(\"Transfer-Encoding\", CharsetUtil.US_ASCII);\n        responseBuffer.writeByte(controlChar);\n        responseBuffer.writeCharSequence(\": chunked\\r\\n\\r\\n\", CharsetUtil.US_ASCII);\n        testInvalidHeaders0(responseBuffer);\n    }\n\n    private static void testInvalidHeaders0(ByteBuf responseBuffer) {\n        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());\n        assertTrue(channel.writeInbound(responseBuffer));\n        HttpResponse response = channel.readInbound();\n        assertThat(response.decoderResult().cause(), instanceOf(IllegalArgumentException.class));\n        assertTrue(response.decoderResult().isFailure());\n        assertFalse(channel.finish());\n    }\n}\n"], "filenames": ["codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java", "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java", "codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java", "codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java"], "buggy_code_start_loc": [369, 827, 17, 801], "buggy_code_end_loc": [393, 907, 507, 801], "fixing_code_start_loc": [370, 827, 18, 802], "fixing_code_end_loc": [402, 907, 581, 880], "type": "CWE-444", "message": "Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. Netty prior to version 4.1.71.Final skips control chars when they are present at the beginning / end of the header name. It should instead fail fast as these are not allowed by the spec and could lead to HTTP request smuggling. Failing to do the validation might cause netty to \"sanitize\" header names before it forward these to another remote system when used as proxy. This remote system can't see the invalid usage anymore, and therefore does not do the validation itself. Users should upgrade to version 4.1.71.Final.", "other": {"cve": {"id": "CVE-2021-43797", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-09T19:15:07.960", "lastModified": "2023-02-24T15:47:11.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. Netty prior to version 4.1.71.Final skips control chars when they are present at the beginning / end of the header name. It should instead fail fast as these are not allowed by the spec and could lead to HTTP request smuggling. Failing to do the validation might cause netty to \"sanitize\" header names before it forward these to another remote system when used as proxy. This remote system can't see the invalid usage anymore, and therefore does not do the validation itself. Users should upgrade to version 4.1.71.Final."}, {"lang": "es", "value": "Netty es un marco de trabajo de aplicaciones de red as\u00edncronas impulsadas por eventos para el desarrollo r\u00e1pido de servidores y clientes de protocolo de alto rendimiento mantenibles. Netty antes de la versi\u00f3n 4.1.71.Final omite los caracteres de control cuando est\u00e1n presentes al principio/fin del nombre de la cabecera. En su lugar, deber\u00eda fallar r\u00e1pidamente ya que estos no est\u00e1n permitidos por la especificaci\u00f3n y podr\u00edan llevar a un contrabando de peticiones HTTP. No hacer la validaci\u00f3n podr\u00eda causar que netty \"sanee\" los nombres de las cabeceras antes de reenviarlas a otro sistema remoto cuando se usa como proxy. Este sistema remoto ya no puede ver el uso inv\u00e1lido, y por lo tanto no hace la validaci\u00f3n por s\u00ed mismo. Los usuarios deben actualizar a la versi\u00f3n 4.1.71.Final"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netty:netty:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.71", "matchCriteriaId": "F63C0F0C-1D4C-4383-820A-9325DE306780"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quarkus:quarkus:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.3", "matchCriteriaId": "9050DC4B-0A83-436F-9AE5-6DC28EC7F69D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapcenter:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDFB1169-41A0-4A86-8E4F-FDA9730B1E94"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_deposits_and_lines_of_credit_servicing:2.7:*:*:*:*:*:*:*", "matchCriteriaId": "ED63D221-31FA-480F-802F-844334F429F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_party_management:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "C542DC5E-6657-4178-9C69-46FD3C187D56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "132CE62A-FBFC-4001-81EC-35D81F73AF48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:coherence:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "2FF57C7A-92C9-4D71-A7B1-CC9DEFAA8193"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:coherence:14.1.1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "5FA64A1D-34F9-4441-857A-25C165E6DBB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_binding_support_function:1.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "10323322-F6C0-4EA7-9344-736F7A80AA5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_slice_selection_function:1.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "3AA09838-BF13-46AC-BB97-A69F48B73A8A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_policy:1.15.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4367D9B-BF81-47AD-A840-AC46317C774D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_security_edge_protection_proxy:1.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "BD4349FE-EEF8-489A-8ABF-5FCD55EC6DE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_unified_data_repository:1.15.0:*:*:*:*:*:*:*", "matchCriteriaId": "C6EAA723-2A23-4151-930B-86ACF9CC1C0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_design_studio:7.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "A67AA54B-258D-4D09-9ACB-4085E0B3E585"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_instant_messaging_server:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "47CE14F1-7E98-4C3B-A817-C54273F23464"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:helidon:1.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "4E7626D2-D9FF-416A-9581-852CED0D8C24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:helidon:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "99344A5D-F4B7-49B4-9AE6-0E2FB3874EA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.58:*:*:*:*:*:*:*", "matchCriteriaId": "D9DB4A14-2EF5-4B54-95D2-75E6CF9AA0A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.59:*:*:*:*:*:*:*", "matchCriteriaId": "C8AF00C6-B97F-414D-A8DF-057E6BFD8597"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/netty/netty/commit/07aa6b5938a8b6ed7a6586e066400e2643897323", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/netty/netty/security/advisories/GHSA-wx5j-54mm-rqqq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/01/msg00008.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220107-0003/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5316", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netty/netty/commit/07aa6b5938a8b6ed7a6586e066400e2643897323"}}