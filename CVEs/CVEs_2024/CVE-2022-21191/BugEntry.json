{"buggy_code": ["\"use strict\";\n\n// https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders\n\nconst childProcess = require(\"child_process\"),\n\tpath = require(\"path\"),\n\tfs = require(\"fs\"),\n\tprocessWrapper = require(\"./process-wrapper\");\n\nconst supportedPlatforms = [\n\t\"win32\",\n\t\"linux\",\n\t\"darwin\"\n];\n\nconst nodeModulesDirName = \"node_modules\";\n\nconst getNpmExecutable = (platform) => {\n\tlet npmExecutableName = \"npm\";\n\n\tif (platform === \"win32\") {\n\t\tnpmExecutableName += \".cmd\";\n\t}\n\n\treturn npmExecutableName;\n};\n\nconst getNpmPrefix = (pathToNpm) => {\n\ttry {\n\t\tconst npmPrefixStdout = childProcess.execSync(`${pathToNpm} config get prefix`);\n\t\treturn npmPrefixStdout && npmPrefixStdout.toString().trim();\n\t} catch (err) {\n\t\tconsole.error(err.message);\n\t}\n\n\treturn null;\n};\n\nconst getPathFromNpmConfig = (platform, packageName) => {\n\tconst pathToNpm = getNpmExecutable(platform),\n\t\tnpmConfigPrefix = getNpmPrefix(pathToNpm);\n\n\tif (npmConfigPrefix) {\n\t\tlet nodeModulesPath = path.join(npmConfigPrefix, nodeModulesDirName);\n\n\t\tif (platform !== \"win32\") {\n\t\t\tnodeModulesPath = path.join(npmConfigPrefix, \"lib\", nodeModulesDirName);\n\t\t}\n\n\t\tconst packagePath = path.join(nodeModulesPath, packageName);\n\t\tconst verifiedPath = getVerifiedPath(packagePath, packageName);\n\t\tif (verifiedPath) {\n\t\t\treturn verifiedPath;\n\t\t}\n\t}\n\n\treturn null;\n};\n\nconst getPathFromCmdContent = (packageName, pathToExecutable) => {\n\tif (fs.existsSync(pathToExecutable)) {\n\t\tconst executableContent = fs.readFileSync(pathToExecutable).toString();\n\n\t\tlet fullPath;\n\n\t\tlet windowsPathRegExp = /(%~dp0[\\w\\\\.-]+node_modules).*?\"/g;\n\t\tlet match = windowsPathRegExp.exec(executableContent);\n\n\t\tif (match && match[1]) {\n\t\t\tconst realPath = path.normalize(match[1].replace(\"%~dp0\", path.dirname(pathToExecutable)));\n\n\t\t\tfullPath = path.join(realPath, packageName);\n\t\t}\n\n\t\tif (!fullPath) {\n\t\t\twindowsPathRegExp = new RegExp(`(%~dp0[\\\\w\\\\\\\\.-]+?${packageName})(?:\\\\\\\\|\")`, \"g\");\n\t\t\tmatch = windowsPathRegExp.exec(executableContent);\n\n\t\t\tif (match && match[1]) {\n\t\t\t\tfullPath = path.normalize(match[1].replace(\"%~dp0\", path.dirname(pathToExecutable)));\n\t\t\t}\n\t\t}\n\n\t\tif (fullPath) {\n\t\t\tconst pathToPackage = getVerifiedPath(fullPath, packageName);\n\n\t\t\tif (pathToPackage) {\n\t\t\t\treturn pathToPackage;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst getVerifiedPath = (suggestedPath, packageName) => {\n\tconst pathToPackageJson = path.join(suggestedPath, \"package.json\");\n\tif (fs.existsSync(suggestedPath) && fs.existsSync(pathToPackageJson)) {\n\t\ttry {\n\t\t\tconst packageJsonContent = JSON.parse(fs.readFileSync(pathToPackageJson));\n\t\t\tif (packageJsonContent.name === packageName) {\n\t\t\t\treturn suggestedPath;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// do nothing\n\t\t}\n\t}\n};\n\nconst getPathFromExecutableNameOnWindows = (packageName, executableName) => {\n\ttry {\n\t\tconst whereResult = (childProcess.execSync(`where ${executableName}`) || \"\").toString().split(\"\\n\");\n\t\tfor (const line of whereResult) {\n\t\t\tconst pathToExecutable = line && line.trim();\n\n\t\t\tif (pathToExecutable) {\n\t\t\t\tconst pathToLib = path.join(path.dirname(pathToExecutable), nodeModulesDirName, packageName);\n\t\t\t\tconst verifiedPath = getVerifiedPath(pathToLib, packageName);\n\t\t\t\tif (verifiedPath) {\n\t\t\t\t\treturn verifiedPath;\n\t\t\t\t}\n\n\t\t\t\t// consider checking the content of the file - in most of the cases it contains the real path to the executable.\n\t\t\t\tconst pathToExecutableFromContent = getPathFromCmdContent(packageName, pathToExecutable);\n\t\t\t\tif (pathToExecutableFromContent) {\n\t\t\t\t\treturn pathToExecutableFromContent;\n\t\t\t\t}\n\n\t\t\t\t// In case the path to <package>/bin/ is added to the PATH\n\t\t\t\tconst resolvedPath = getPathWhenExecutableIsAddedDirectlyToPath(packageName, pathToExecutable);\n\t\t\t\tif (resolvedPath) {\n\t\t\t\t\treturn resolvedPath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err.message);\n\t}\n\n\treturn null;\n};\n\nconst getPathFromExecutableNameOnNonWindows = (packageName, executableName) => {\n\ttry {\n\t\t// Second way to find it is to use the result of which command\n\t\t// It will give path to the executable, which is a symlink in fact, so we can get the full path from it:\n\n\t\t// whichResult: /usr/local/nvm/versions/node/v4.2.1/bin/mobile-cli-lib\n\t\t// lsLResult: lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 /usr/local/nvm/versions/node/v4.2.1/bin/mobile-cli-lib -> ../lib/node_modules/mobile-cli-lib/bin/common-lib.js\n\t\tconst whichResult = (childProcess.execSync(`which ${executableName}`) || \"\").toString().trim(),\n\t\t\tlsLResult = (childProcess.execSync(`ls -l \\`which ${executableName}\\``) || \"\").toString().trim();\n\n\t\tif (whichResult && lsLResult) {\n\t\t\tconst regex = new RegExp(`${whichResult}\\\\s+->\\\\s+(.*?)$`),\n\t\t\t\tmatch = lsLResult.match(regex);\n\n\t\t\tif (match && match[1]) {\n\t\t\t\tconst pathToRealExecutable = fs.realpathSync(path.join(path.dirname(whichResult), match[1]));\n\n\t\t\t\t// The executable is somewhere inside node_modules/<package name>/ directory,\n\t\t\t\t// so after we have the full path to executable, we are safe to match the path to node_modules/<package name>/ from it - that's where our module is.\n\t\t\t\tconst packagePathMatch = pathToRealExecutable.match(new RegExp(`(.*?${path.join(nodeModulesDirName, packageName)}).*$`));\n\n\t\t\t\tif (packagePathMatch) {\n\t\t\t\t\tconst verifiedPath = getVerifiedPath(packagePathMatch[1], packageName);\n\t\t\t\t\tif (verifiedPath) {\n\t\t\t\t\t\treturn verifiedPath;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In case executable is added to PATH directly\n\t\t\treturn getPathWhenExecutableIsAddedDirectlyToPath(packageName, whichResult);\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err.message);\n\t}\n\n\treturn null;\n};\n\nconst getPathWhenExecutableIsAddedDirectlyToPath = (packageName, executablePath) => {\n\tconst pathToPackageJson = path.join(path.dirname(executablePath), \"..\", \"package.json\");\n\tif (fs.existsSync(pathToPackageJson)) {\n\t\tconst packageNameFromPackageJson = JSON.parse(fs.readFileSync(pathToPackageJson)).name;\n\t\tif (packageNameFromPackageJson === packageName) {\n\t\t\treturn path.dirname(pathToPackageJson);\n\t\t}\n\t}\n\n\treturn null;\n};\n\n// For some packages executable name is not the same as package name\n// For example our package is called nativescript, but the executable name is called \"tns\"\nconst getPath = (packageName, executableName) => {\n\tconst platform = processWrapper.getProcessPlatform();\n\n\tif (supportedPlatforms.indexOf(platform) === -1) {\n\t\tthrow new Error(`OS '${platform}' is not supported.'`);\n\t}\n\n\tlet foundPath = null;\n\n\tif (executableName) {\n\t\tfoundPath = platform === \"win32\" ?\n\t\t\tgetPathFromExecutableNameOnWindows(packageName, executableName) :\n\t\t\tgetPathFromExecutableNameOnNonWindows(packageName, executableName);\n\t}\n\n\tif (!foundPath) {\n\t\tfoundPath = getPathFromNpmConfig(platform, packageName);\n\t}\n\n\tif (foundPath) {\n\t\ttry {\n\t\t\tfoundPath = fs.realpathSync(foundPath);\n\t\t} catch (err) {\n\t\t\tconsole.error(err.message);\n\t\t}\n\t}\n\n\treturn foundPath;\n};\n\nmodule.exports = {\n\tgetPath: getPath\n};\n", "\"use strict\";\n\n// Linter rules, so mocha's methods will not be detected as undeclared.\n/* global describe, it, afterEach, beforeEach */\n\nconst assert = require(\"chai\").assert,\n\tpath = require(\"path\");\n\nconst index = require(\"../lib/index\");\n\nlet processWrapper = require(\"../lib/process-wrapper\");\nlet fs = require(\"fs\"),\n\tchildProcess = require(\"child_process\");\n\nconst originalExecSync = childProcess.execSync;\nconst originalConsoleError = console.error;\nconst originalExistsSync = fs.existsSync;\nconst originalReadFileSync = fs.readFileSync;\n\ndescribe(\"getPath\", () => {\n\n\tafterEach(() => {\n\t\tprocessWrapper.getProcessPlatform = () => process.platform;\n\t\tchildProcess.execSync = originalExecSync;\n\t\tconsole.error = originalConsoleError;\n\t\tfs.existsSync = originalExistsSync;\n\t\tfs.readFileSync = originalReadFileSync;\n\t});\n\n\t// platform independant tests. Execute them by simulating all supported platforms, but results should be the same.\n\tlet supportedPlatforms = [\"win32\", \"darwin\", \"linux\"];\n\n\tsupportedPlatforms.forEach(platform => {\n\t\tdescribe(`OS independant tests, on ${platform}`, () => {\n\t\t\tbeforeEach(() => {\n\t\t\t\tprocessWrapper.getProcessPlatform = () => platform;\n\t\t\t});\n\n\t\t\tdescribe(\"works correctly when npm prefix is used\", () => {\n\t\t\t\tit(\"does not throw error when getting npm prefix throws\", () => {\n\t\t\t\t\tconst expectedErrorMessage = \"npm throws\";\n\t\t\t\t\tlet errors = [];\n\t\t\t\t\tconsole.error = (message) => errors.push(message);\n\t\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\t\tif (command.indexOf(\"get prefix\") !== -1) {\n\t\t\t\t\t\t\tthrow new Error(expectedErrorMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Do not pass executable name here as we want to test only getting npm prefix.\n\t\t\t\t\tindex.getPath(\"test1\");\n\t\t\t\t\tassert.isTrue(errors.length === 1, \"Only single error should be thrown.\");\n\t\t\t\t\tassert.deepEqual(errors[0], expectedErrorMessage);\n\t\t\t\t});\n\n\t\t\t\tit(\"returns null when npm prefix returns value, but searched module is NOT installed there (and executable name is not passed)\", () => {\n\t\t\t\t\tconst npmConfigPrefix = \"/npm/dir\",\n\t\t\t\t\t\tpackageName = \"test1\";\n\n\t\t\t\t\tfs.existsSync = () => false;\n\n\t\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\t\tif (command.indexOf(\"get prefix\") !== -1) {\n\t\t\t\t\t\t\treturn npmConfigPrefix;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst resultPath = index.getPath(packageName);\n\t\t\t\t\tassert.deepEqual(resultPath, null);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tdescribe(\"works correctly when executableName is used\", () => {\n\t\t\t\tit(\"returns null when where result fails\", () => {\n\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\texecutableName = \"test1.js\";\n\n\t\t\t\t\tchildProcess.execSync = () => null;\n\n\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tconst getCorrectResultFromNpmPrefix = (npmConfigPrefix, packageName) => {\n\t\tfs.existsSync = () => true;\n\t\tfs.readFileSync = () => JSON.stringify({ name: packageName });\n\t\tchildProcess.execSync = (command) => {\n\t\t\tif (command.indexOf(\"get prefix\") !== -1) {\n\t\t\t\treturn npmConfigPrefix;\n\t\t\t}\n\t\t};\n\n\t\treturn index.getPath(packageName);\n\t};\n\n\t// Platform specific tests\n\tdescribe(\"on windows\", () => {\n\t\tbeforeEach(() => {\n\t\t\tprocessWrapper.getProcessPlatform = () => \"win32\";\n\t\t});\n\n\t\tdescribe(\"works correctly when npm prefix is used\", () => {\n\t\t\tit(\"uses npm.cmd for npm executable\", () => {\n\t\t\t\tlet commands = [];\n\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\tcommands.push(command);\n\t\t\t\t};\n\n\t\t\t\tindex.getPath(\"test1\");\n\t\t\t\tassert.isTrue(commands.indexOf(\"npm.cmd config get prefix\") !== -1);\n\t\t\t});\n\n\t\t\tit(\"returns path containing npm prefix when it returns correct result and the searched module is installed there\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\tnpmConfigPrefix = \"/bin/test\";\n\n\t\t\t\tconst resultPath = getCorrectResultFromNpmPrefix(npmConfigPrefix, packageName);\n\t\t\t\tassert.deepEqual(resultPath, path.join(npmConfigPrefix, \"node_modules\", packageName));\n\t\t\t});\n\n\t\t\tit(\"returns path containing npm prefix when it returns correct result and the searched module is installed there (and executable name is not passed), when npm prefix is not trimmed \", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\tnpmConfigPrefix = \"     /bin/test      \";\n\n\t\t\t\tconst resultPath = getCorrectResultFromNpmPrefix(npmConfigPrefix, packageName);\n\t\t\t\tassert.deepEqual(resultPath, path.join(npmConfigPrefix.trim(), \"node_modules\", packageName));\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"works correctly when executableName is used\", () => {\n\t\t\tit(\"returns null when where command throws\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texpectedErrorMessage = \"Where error\";\n\n\t\t\t\tlet errors = [];\n\t\t\t\tconsole.error = (message) => errors.push(message);\n\n\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\tthrow new Error(expectedErrorMessage);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\tassert.deepEqual(errors.length, 1, \"Only single error should be thrown.\");\n\t\t\t\tassert.deepEqual(errors[0], expectedErrorMessage);\n\t\t\t});\n\n\t\t\tit(\"returns correct result when where result is correct\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texecutableDirName = path.join(\"C:\", \"Users\", \"username\", \"AppData\", \"Roaming\", \"npm\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn whereResult;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, path.join(executableDirName, \"node_modules\", packageName));\n\t\t\t});\n\n\t\t\tit(\"returns correct result when yarn is used on Windows\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.cmd\",\n\t\t\t\t\tyarnDirPath = path.join(\"C:\", \"Users\", \"username\", \"AppData\", \"Roaming\", \"Local\", \"Yarn\"),\n\t\t\t\t\texecutableDirName = path.join(yarnDirPath, \"bin\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (pathToCheck) => pathToCheck !== path.join(executableDirName, \"node_modules\", packageName);\n\n\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn whereResult;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (path.basename(filePath) === executableName) {\n\t\t\t\t\t\treturn \"@\\\"%~dp0\\\\..\\\\Data\\\\global\\\\node_modules\\\\.bin\\\\test1.cmd\\\"   %*\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tconst expectedData = process.platform === \"win32\" ?\n\t\t\t\t\tpath.join(yarnDirPath, \"Data\", \"global\", \"node_modules\", packageName) :\n\t\t\t\t\tpath.join(yarnDirPath, \"bin\\\\..\\\\Data\\\\global\\\\node_modules\", packageName);\n\n\t\t\t\tassert.deepEqual(path.normalize(result), expectedData);\n\t\t\t});\n\n\t\t\tit(\"returns correct result when where result is correct, and package is added to PATH via a .bin dir\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.cmd\",\n\t\t\t\t\tnodeModulesDirName = path.join(\"C:\", \"Users\", \"username\", \"someDir\", \"node_modules\"),\n\t\t\t\t\texecutableDirName = path.join(nodeModulesDirName, \".bin\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (pathToCheck) => pathToCheck !== path.join(executableDirName, \"node_modules\", packageName);\n\n\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn whereResult;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (path.basename(filePath) === executableName) {\n\t\t\t\t\t\treturn \"@\\\"%~dp0\\\\..\\\\test1\\\\bin\\\\test1\\\" %*\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\n\t\t\t\tconst expectedData = process.platform === \"win32\" ?\n\t\t\t\t\tpath.join(path.dirname(executableDirName), packageName) :\n\t\t\t\t\tpath.join(nodeModulesDirName, \".bin\\\\..\\\\test1\");\n\n\t\t\t\tassert.deepEqual(result, expectedData);\n\t\t\t});\n\n\t\t\tit(\"returns correct result when where result is correct, and package is added to PATH via its bin dir\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texecutableDirName = path.join(\"C:\", \"Users\", \"username\", \"nativescript-cli\", \"bin\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\treturn filePath.indexOf(\"package.json\") !== -1;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn whereResult;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, path.join(path.dirname(executableDirName)));\n\t\t\t});\n\n\t\t\tit(\"returns null when package is added to PATH via its bin dir, but the name in package.json is incorrect\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texecutableDirName = path.join(\"C:\", \"Users\", \"username\", \"nativescript-cli\", \"bin\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\treturn filePath.indexOf(\"package.json\") !== -1;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": \"invalidName\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn whereResult;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, null);\n\t\t\t});\n\n\t\t\tit(\"returns correct result when where result returns multiple lines correct\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texecutableDirName = path.join(\"C:\", \"Users\", \"username\", \"AppData\", \"Roaming\", \"npm\"),\n\t\t\t\t\tinvalidName = \"invalidName\",\n\t\t\t\t\tinvalidLineOfWhereResult = path.join(executableDirName, invalidName, invalidName, executableName),\n\t\t\t\t\twhereResult = invalidLineOfWhereResult + \"\\n\" + invalidLineOfWhereResult + \"\\r\\n\" + path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\tif (filePath && filePath.indexOf(invalidName) !== -1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn whereResult;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, path.join(executableDirName, \"node_modules\", packageName));\n\t\t\t});\n\t\t});\n\t});\n\n\t// Remove win32 from supported platforms. Tests below are not for Windows.\n\tsupportedPlatforms.shift();\n\n\tsupportedPlatforms.forEach(platform => {\n\n\t\tdescribe(`on ${platform}`, () => {\n\t\t\tbeforeEach(() => {\n\t\t\t\tprocessWrapper.getProcessPlatform = () => platform;\n\t\t\t});\n\n\t\t\tit(\"uses npm for npm executable\", () => {\n\t\t\t\tlet commands = [];\n\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\tcommands.push(command);\n\t\t\t\t};\n\n\t\t\t\tindex.getPath(\"test1\");\n\n\t\t\t\tassert.isTrue(commands.indexOf(\"npm config get prefix\") !== -1);\n\t\t\t});\n\n\t\t\tit(\"returns path containing npm prefix when it returns correct result and the searched module is installed there (and executable name is not passed)\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\tnpmConfigPrefix = \"/bin/test\";\n\n\t\t\t\tconst resultPath = getCorrectResultFromNpmPrefix(npmConfigPrefix, packageName);\n\t\t\t\tassert.deepEqual(resultPath, path.join(npmConfigPrefix, \"lib\", \"node_modules\", packageName));\n\t\t\t});\n\n\t\t\tit(\"returns path containing npm prefix when it returns correct result and the searched module is installed there (and executable name is not passed), when npm prefix is not trimmed \", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\tnpmConfigPrefix = \"    /bin/test       \";\n\n\t\t\t\tconst resultPath = getCorrectResultFromNpmPrefix(npmConfigPrefix, packageName);\n\t\t\t\tassert.deepEqual(resultPath, path.join(npmConfigPrefix.trim(), \"lib\", \"node_modules\", packageName));\n\t\t\t});\n\n\t\t\tdescribe(\"works correctly when executableName is used\", () => {\n\t\t\t\tit(\"returns null when which command throws\", () => {\n\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\texpectedErrorMessage = \"Which error\";\n\n\t\t\t\t\tlet errors = [];\n\t\t\t\t\tconsole.error = (message) => errors.push(message);\n\n\t\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\t\tif (command.indexOf(\"which\") !== -1) {\n\t\t\t\t\t\t\tthrow new Error(expectedErrorMessage);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t};\n\n\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\tassert.deepEqual(errors.length, 1, \"Only single error should be thrown.\");\n\t\t\t\t\tassert.deepEqual(errors[0], expectedErrorMessage);\n\t\t\t\t});\n\n\t\t\t\tit(\"returns null when ls -l command throws\", () => {\n\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\texpectedErrorMessage = \"ls -l error\";\n\n\t\t\t\t\tlet errors = [];\n\t\t\t\t\tconsole.error = (message) => errors.push(message);\n\n\t\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\t\tchildProcess.execSync = (command) => {\n\t\t\t\t\t\tif (command.indexOf(\"ls -l\") !== -1) {\n\t\t\t\t\t\t\tthrow new Error(expectedErrorMessage);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t};\n\n\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\tassert.deepEqual(errors.length, 1, \"Only single error should be thrown.\");\n\t\t\t\t\tassert.deepEqual(errors[0], expectedErrorMessage);\n\t\t\t\t});\n\n\t\t\t\tif (process.platform === \"win32\") {\n\t\t\t\t\tconsole.log(\"Some tests cannot be executed on Windows. PR will execute them on Linux, so don't worry.\");\n\t\t\t\t} else {\n\n\t\t\t\t\tconst constructData = (packageName, executableName, lsLResult, whichResult, readFileResult) => {\n\t\t\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\t\t\tif (readFileResult !== undefined) {\n\t\t\t\t\t\t\t\treturn readFileResult;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfs.realpathSync = (filePath) => {\n\t\t\t\t\t\t\treturn filePath;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tchildProcess.execSync = (command) => {\n\n\t\t\t\t\t\t\tif (command.indexOf(\"ls -l\") !== -1) {\n\t\t\t\t\t\t\t\treturn lsLResult;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (command.indexOf(\"which\") !== -1) {\n\t\t\t\t\t\t\t\treturn whichResult;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tit(\"returns correct result when which and ls -l results are correct\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"local\", \"node\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 ${whichResult} -> ${path.join(\"..\", \"lib\", \"node_modules\", packageName, \"bin\", executableName)}`;\n\n\t\t\t\t\t\tconstructData(packageName, executableName, lsLResult, whichResult);\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\t\tassert.deepEqual(result, path.join(executableDirName, \"..\", \"lib\", \"node_modules\", packageName));\n\t\t\t\t\t});\n\n\t\t\t\t\tit(\"returns null when ls -l result is not the searched one\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"local\", \"node\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 incorrect ls -l -> ${path.join(\"..\", \"lib\", \"node_modules\", packageName, \"bin\", executableName)}`;\n\n\t\t\t\t\t\tconstructData(packageName, executableName, lsLResult);\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName, whichResult);\n\t\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\t});\n\n\t\t\t\t\tit(\"returns null when ls -l result is not the searched one (no node_modules in it)\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"local\", \"node\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 ${whichResult} -> incorrect`,\n\t\t\t\t\t\t\treadFileResult = \"{}\";\n\n\t\t\t\t\t\tconstructData(packageName, executableName, lsLResult, whichResult, readFileResult);\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\t});\n\n\t\t\t\t\tit(\"returns correct result when which result is correct, and package is added to PATH via its bin dir\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"username\", \"repository_name\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 ${whichResult} -> incorrect`;\n\n\t\t\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\t\t\treturn filePath.indexOf(\"package.json\") !== -1;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tchildProcess.execSync = (command) => {\n\n\t\t\t\t\t\t\tif (command.indexOf(\"ls -l\") !== -1) {\n\t\t\t\t\t\t\t\treturn lsLResult;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (command.indexOf(\"which\") !== -1) {\n\t\t\t\t\t\t\t\treturn whichResult;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\t\tassert.deepEqual(result, path.dirname(executableDirName));\n\t\t\t\t\t});\n\n\t\t\t\t\tit(\"returns null when package is added to PATH via its bin dir, but the name in package.json is incorrect\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"username\", \"repository_name\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 ${whichResult} -> incorrect`;\n\n\t\t\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\t\t\treturn filePath.indexOf(\"package.json\") !== -1;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tchildProcess.execSync = (command) => {\n\n\t\t\t\t\t\t\tif (command.indexOf(\"ls -l\") !== -1) {\n\t\t\t\t\t\t\t\treturn lsLResult;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (command.indexOf(\"which\") !== -1) {\n\t\t\t\t\t\t\t\treturn whichResult;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\t\t\"name\": \"invalid name\"\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n\n\tit(\"throws error when process.platform is not valid\", () => {\n\t\trequire(\"../lib/process-wrapper\").getProcessPlatform = () => \"1\";\n\t\tassert.throws(() => index.getPath(\"test1\", \"test1\"), \"OS '1' is not supported\");\n\t});\n\n});\n"], "fixing_code": ["\"use strict\";\n\n// https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders\n\nconst childProcess = require(\"child_process\"),\n\tpath = require(\"path\"),\n\tfs = require(\"fs\"),\n\tprocessWrapper = require(\"./process-wrapper\");\n\nconst supportedPlatforms = [\n\t\"win32\",\n\t\"linux\",\n\t\"darwin\"\n];\n\nconst nodeModulesDirName = \"node_modules\";\n\nconst getNpmExecutable = (platform) => {\n\tlet npmExecutableName = \"npm\";\n\n\tif (platform === \"win32\") {\n\t\tnpmExecutableName += \".cmd\";\n\t}\n\n\treturn npmExecutableName;\n};\n\nconst spawnSyncWrapper = (command, commandArgs) => {\n\tconst result = childProcess.spawnSync(command, commandArgs);\n\tif (!result) {\n\t\treturn null;\n\t}\n\n\tif (result.error) {\n\t\tthrow result.error;\n\t}\n\n\tif (result.stdout) {\n\t\treturn result.stdout.toString().trim();\n\t}\n\n\treturn null;\n};\n\nconst getNpmPrefix = (pathToNpm) => {\n\ttry {\n\t\tconst npmPrefixStdout = spawnSyncWrapper(pathToNpm, [\"config\", \"get\", \"prefix\"]);\n\t\treturn npmPrefixStdout && npmPrefixStdout.toString().trim();\n\t} catch (err) {\n\t\tconsole.error(err.message);\n\t}\n\n\treturn null;\n};\n\nconst getPathFromNpmConfig = (platform, packageName) => {\n\tconst pathToNpm = getNpmExecutable(platform),\n\t\tnpmConfigPrefix = getNpmPrefix(pathToNpm);\n\n\tif (npmConfigPrefix) {\n\t\tlet nodeModulesPath = path.join(npmConfigPrefix, nodeModulesDirName);\n\n\t\tif (platform !== \"win32\") {\n\t\t\tnodeModulesPath = path.join(npmConfigPrefix, \"lib\", nodeModulesDirName);\n\t\t}\n\n\t\tconst packagePath = path.join(nodeModulesPath, packageName);\n\t\tconst verifiedPath = getVerifiedPath(packagePath, packageName);\n\n\t\tif (verifiedPath) {\n\t\t\treturn verifiedPath;\n\t\t}\n\t}\n\n\treturn null;\n};\n\nconst getPathFromCmdContent = (packageName, pathToExecutable) => {\n\tif (fs.existsSync(pathToExecutable)) {\n\t\tconst executableContent = fs.readFileSync(pathToExecutable).toString();\n\n\t\tlet fullPath;\n\n\t\tlet windowsPathRegExp = /(%~dp0[\\w\\\\.-]+node_modules).*?\"/g;\n\t\tlet match = windowsPathRegExp.exec(executableContent);\n\n\t\tif (match && match[1]) {\n\t\t\tconst realPath = path.normalize(match[1].replace(\"%~dp0\", path.dirname(pathToExecutable)));\n\n\t\t\tfullPath = path.join(realPath, packageName);\n\t\t}\n\n\t\tif (!fullPath) {\n\t\t\twindowsPathRegExp = new RegExp(`(%~dp0[\\\\w\\\\\\\\.-]+?${packageName})(?:\\\\\\\\|\")`, \"g\");\n\t\t\tmatch = windowsPathRegExp.exec(executableContent);\n\n\t\t\tif (match && match[1]) {\n\t\t\t\tfullPath = path.normalize(match[1].replace(\"%~dp0\", path.dirname(pathToExecutable)));\n\t\t\t}\n\t\t}\n\n\t\tif (fullPath) {\n\t\t\tconst pathToPackage = getVerifiedPath(fullPath, packageName);\n\n\t\t\tif (pathToPackage) {\n\t\t\t\treturn pathToPackage;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst getVerifiedPath = (suggestedPath, packageName) => {\n\tconst pathToPackageJson = path.join(suggestedPath, \"package.json\");\n\tif (fs.existsSync(suggestedPath) && fs.existsSync(pathToPackageJson)) {\n\t\ttry {\n\t\t\tconst packageJsonContent = JSON.parse(fs.readFileSync(pathToPackageJson));\n\t\t\tif (packageJsonContent.name === packageName) {\n\t\t\t\treturn suggestedPath;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// do nothing\n\t\t}\n\t}\n};\n\nconst getPathFromExecutableNameOnWindows = (packageName, executableName) => {\n\ttry {\n\t\tconst whereResult = (spawnSyncWrapper(\"where\", executableName) || \"\").split(\"\\n\");\n\n\t\tfor (const line of whereResult) {\n\t\t\tconst pathToExecutable = line && line.trim();\n\n\t\t\tif (pathToExecutable) {\n\t\t\t\tconst pathToLib = path.join(path.dirname(pathToExecutable), nodeModulesDirName, packageName);\n\t\t\t\tconst verifiedPath = getVerifiedPath(pathToLib, packageName);\n\t\t\t\tif (verifiedPath) {\n\t\t\t\t\treturn verifiedPath;\n\t\t\t\t}\n\n\t\t\t\t// consider checking the content of the file - in most of the cases it contains the real path to the executable.\n\t\t\t\tconst pathToExecutableFromContent = getPathFromCmdContent(packageName, pathToExecutable);\n\t\t\t\tif (pathToExecutableFromContent) {\n\t\t\t\t\treturn pathToExecutableFromContent;\n\t\t\t\t}\n\n\t\t\t\t// In case the path to <package>/bin/ is added to the PATH\n\t\t\t\tconst resolvedPath = getPathWhenExecutableIsAddedDirectlyToPath(packageName, pathToExecutable);\n\t\t\t\tif (resolvedPath) {\n\t\t\t\t\treturn resolvedPath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err.message);\n\t}\n\n\treturn null;\n};\n\nconst getPathFromExecutableNameOnNonWindows = (packageName, executableName) => {\n\ttry {\n\t\t// Second way to find it is to use the result of which command\n\t\t// It will give path to the executable, which is a symlink in fact, so we can get the full path from it:\n\n\t\t// whichResult: /usr/local/nvm/versions/node/v4.2.1/bin/mobile-cli-lib\n\t\t// lsLResult: lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 /usr/local/nvm/versions/node/v4.2.1/bin/mobile-cli-lib -> ../lib/node_modules/mobile-cli-lib/bin/common-lib.js\n\t\tconst whichResult = spawnSyncWrapper(\"which\", [executableName]);\n\t\tconst lsLResult = spawnSyncWrapper(\"ls\", [\"-l\", whichResult]);\n\n\t\tif (whichResult && lsLResult) {\n\t\t\tconst regex = new RegExp(`${whichResult}\\\\s+->\\\\s+(.*?)$`),\n\t\t\t\tmatch = lsLResult.match(regex);\n\n\t\t\tif (match && match[1]) {\n\t\t\t\tconst pathToRealExecutable = fs.realpathSync(path.join(path.dirname(whichResult), match[1]));\n\n\t\t\t\t// The executable is somewhere inside node_modules/<package name>/ directory,\n\t\t\t\t// so after we have the full path to executable, we are safe to match the path to node_modules/<package name>/ from it - that's where our module is.\n\t\t\t\tconst packagePathMatch = pathToRealExecutable.match(new RegExp(`(.*?${path.join(nodeModulesDirName, packageName)}).*$`));\n\n\t\t\t\tif (packagePathMatch) {\n\t\t\t\t\tconst verifiedPath = getVerifiedPath(packagePathMatch[1], packageName);\n\t\t\t\t\tif (verifiedPath) {\n\t\t\t\t\t\treturn verifiedPath;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In case executable is added to PATH directly\n\t\t\treturn getPathWhenExecutableIsAddedDirectlyToPath(packageName, whichResult);\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err.message);\n\t}\n\n\treturn null;\n};\n\nconst getPathWhenExecutableIsAddedDirectlyToPath = (packageName, executablePath) => {\n\tconst pathToPackageJson = path.join(path.dirname(executablePath), \"..\", \"package.json\");\n\tif (fs.existsSync(pathToPackageJson)) {\n\t\tconst packageNameFromPackageJson = JSON.parse(fs.readFileSync(pathToPackageJson)).name;\n\t\tif (packageNameFromPackageJson === packageName) {\n\t\t\treturn path.dirname(pathToPackageJson);\n\t\t}\n\t}\n\n\treturn null;\n};\n\n// For some packages executable name is not the same as package name\n// For example our package is called nativescript, but the executable name is called \"tns\"\nconst getPath = (packageName, executableName) => {\n\tconst platform = processWrapper.getProcessPlatform();\n\n\tif (supportedPlatforms.indexOf(platform) === -1) {\n\t\tthrow new Error(`OS '${platform}' is not supported.'`);\n\t}\n\n\tlet foundPath = null;\n\n\tif (executableName) {\n\t\tfoundPath = platform === \"win32\" ?\n\t\t\tgetPathFromExecutableNameOnWindows(packageName, executableName) :\n\t\t\tgetPathFromExecutableNameOnNonWindows(packageName, executableName);\n\t}\n\n\tif (!foundPath) {\n\t\tfoundPath = getPathFromNpmConfig(platform, packageName);\n\t}\n\n\tif (foundPath) {\n\t\ttry {\n\t\t\tfoundPath = fs.realpathSync(foundPath);\n\t\t} catch (err) {\n\t\t\tconsole.error(err.message);\n\t\t}\n\t}\n\n\treturn foundPath;\n};\n\nmodule.exports = {\n\tgetPath: getPath\n};\n", "\"use strict\";\n\n// Linter rules, so mocha's methods will not be detected as undeclared.\n/* global describe, it, afterEach, beforeEach */\n\nconst assert = require(\"chai\").assert,\n\tpath = require(\"path\");\n\nconst index = require(\"../lib/index\");\n\nlet processWrapper = require(\"../lib/process-wrapper\");\nlet fs = require(\"fs\"),\n\tchildProcess = require(\"child_process\");\n\nconst originalspawnSync = childProcess.spawnSync;\nconst originalConsoleError = console.error;\nconst originalExistsSync = fs.existsSync;\nconst originalReadFileSync = fs.readFileSync;\n\ndescribe(\"getPath\", () => {\n\n\tafterEach(() => {\n\t\tprocessWrapper.getProcessPlatform = () => process.platform;\n\t\tchildProcess.spawnSync = originalspawnSync;\n\t\tconsole.error = originalConsoleError;\n\t\tfs.existsSync = originalExistsSync;\n\t\tfs.readFileSync = originalReadFileSync;\n\t});\n\n\t// platform independant tests. Execute them by simulating all supported platforms, but results should be the same.\n\tlet supportedPlatforms = [\"win32\", \"darwin\", \"linux\"];\n\n\tsupportedPlatforms.forEach(platform => {\n\t\tdescribe(`OS independant tests, on ${platform}`, () => {\n\t\t\tbeforeEach(() => {\n\t\t\t\tprocessWrapper.getProcessPlatform = () => platform;\n\t\t\t});\n\n\t\t\tdescribe(\"works correctly when npm prefix is used\", () => {\n\t\t\t\tit(\"does not throw error when getting npm prefix throws\", () => {\n\t\t\t\t\tconst expectedErrorMessage = \"npm throws\";\n\t\t\t\t\tlet errors = [];\n\t\t\t\t\tconsole.error = (message) => errors.push(message);\n\t\t\t\t\tchildProcess.spawnSync = (command, commandArgs) => {\n\t\t\t\t\t\tif (commandArgs.indexOf(\"get\") !== -1 && commandArgs.indexOf(\"prefix\") !== -1) {\n\t\t\t\t\t\t\treturn { error: new Error(expectedErrorMessage) };\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Do not pass executable name here as we want to test only getting npm prefix.\n\t\t\t\t\tindex.getPath(\"test1\");\n\t\t\t\t\tassert.isTrue(errors.length === 1, \"Only single error should be thrown.\");\n\t\t\t\t\tassert.deepEqual(errors[0], expectedErrorMessage);\n\t\t\t\t});\n\n\t\t\t\tit(\"returns null when npm prefix returns value, but searched module is NOT installed there (and executable name is not passed)\", () => {\n\t\t\t\t\tconst npmConfigPrefix = \"/npm/dir\",\n\t\t\t\t\t\tpackageName = \"test1\";\n\n\t\t\t\t\tfs.existsSync = () => false;\n\n\t\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\t\tif (command.indexOf(\"get prefix\") !== -1) {\n\t\t\t\t\t\t\treturn npmConfigPrefix;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst resultPath = index.getPath(packageName);\n\t\t\t\t\tassert.deepEqual(resultPath, null);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tdescribe(\"works correctly when executableName is used\", () => {\n\t\t\t\tit(\"returns null when where result fails\", () => {\n\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\texecutableName = \"test1.js\";\n\n\t\t\t\t\tchildProcess.spawnSync = () => null;\n\n\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tconst getCorrectResultFromNpmPrefix = (npmConfigPrefix, packageName) => {\n\t\tfs.existsSync = () => true;\n\t\tfs.readFileSync = () => JSON.stringify({ name: packageName });\n\t\tfs.realpathSync = (p) => p; \n\t\tchildProcess.spawnSync = (command, commandArgs) => {\n\t\t\tif (commandArgs.indexOf(\"get\") !== -1 && commandArgs.indexOf(\"prefix\") !== -1) {\n\t\t\t\treturn { stdout: npmConfigPrefix };\n\t\t\t}\n\t\t};\n\n\t\treturn index.getPath(packageName);\n\t};\n\n\t// Platform specific tests\n\tdescribe(\"on windows\", () => {\n\t\tbeforeEach(() => {\n\t\t\tprocessWrapper.getProcessPlatform = () => \"win32\";\n\t\t});\n\n\t\tdescribe(\"works correctly when npm prefix is used\", () => {\n\t\t\tit(\"uses npm.cmd for npm executable\", () => {\n\t\t\t\tlet commands = [];\n\t\t\t\tchildProcess.spawnSync = (command, commandArgs) => {\n\t\t\t\t\tcommands.push(`${command} ${(commandArgs || []).join(\" \")}`);\n\t\t\t\t};\n\n\t\t\t\tindex.getPath(\"test1\");\n\t\t\t\tassert.isTrue(commands.indexOf(\"npm.cmd config get prefix\") !== -1);\n\t\t\t});\n\n\t\t\tit(\"returns path containing npm prefix when it returns correct result and the searched module is installed there\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\tnpmConfigPrefix = \"/bin/test\";\n\n\t\t\t\tconst resultPath = getCorrectResultFromNpmPrefix(npmConfigPrefix, packageName);\n\t\t\t\tassert.deepEqual(resultPath, path.join(npmConfigPrefix, \"node_modules\", packageName));\n\t\t\t});\n\n\t\t\tit(\"returns path containing npm prefix when it returns correct result and the searched module is installed there (and executable name is not passed), when npm prefix is not trimmed \", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\tnpmConfigPrefix = \"     /bin/test      \";\n\n\t\t\t\tconst resultPath = getCorrectResultFromNpmPrefix(npmConfigPrefix, packageName);\n\t\t\t\tassert.deepEqual(resultPath, path.join(npmConfigPrefix.trim(), \"node_modules\", packageName));\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"works correctly when executableName is used\", () => {\n\t\t\tit(\"returns null when where command throws\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texpectedErrorMessage = \"Where error\";\n\n\t\t\t\tlet errors = [];\n\t\t\t\tconsole.error = (message) => errors.push(message);\n\n\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn { error: new Error(expectedErrorMessage) };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\tassert.deepEqual(errors.length, 1, \"Only single error should be thrown.\");\n\t\t\t\tassert.deepEqual(errors[0], expectedErrorMessage);\n\t\t\t});\n\n\t\t\tit(\"returns correct result when where result is correct\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texecutableDirName = path.join(\"C:\", \"Users\", \"username\", \"AppData\", \"Roaming\", \"npm\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn { stdout: whereResult };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, path.join(executableDirName, \"node_modules\", packageName));\n\t\t\t});\n\n\t\t\tit(\"returns correct result when yarn is used on Windows\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.cmd\",\n\t\t\t\t\tyarnDirPath = path.join(\"C:\", \"Users\", \"username\", \"AppData\", \"Roaming\", \"Local\", \"Yarn\"),\n\t\t\t\t\texecutableDirName = path.join(yarnDirPath, \"bin\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (pathToCheck) => pathToCheck !== path.join(executableDirName, \"node_modules\", packageName);\n\n\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn { stdout: whereResult };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (path.basename(filePath) === executableName) {\n\t\t\t\t\t\treturn \"@\\\"%~dp0\\\\..\\\\Data\\\\global\\\\node_modules\\\\.bin\\\\test1.cmd\\\"   %*\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tconst expectedData = process.platform === \"win32\" ?\n\t\t\t\t\tpath.join(yarnDirPath, \"Data\", \"global\", \"node_modules\", packageName) :\n\t\t\t\t\tpath.join(yarnDirPath, \"bin\\\\..\\\\Data\\\\global\\\\node_modules\", packageName);\n\n\t\t\t\tassert.deepEqual(path.normalize(result), expectedData);\n\t\t\t});\n\n\t\t\tit(\"returns correct result when where result is correct, and package is added to PATH via a .bin dir\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.cmd\",\n\t\t\t\t\tnodeModulesDirName = path.join(\"C:\", \"Users\", \"username\", \"someDir\", \"node_modules\"),\n\t\t\t\t\texecutableDirName = path.join(nodeModulesDirName, \".bin\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (pathToCheck) => pathToCheck !== path.join(executableDirName, \"node_modules\", packageName);\n\n\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn { stdout: whereResult };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (path.basename(filePath) === executableName) {\n\t\t\t\t\t\treturn \"@\\\"%~dp0\\\\..\\\\test1\\\\bin\\\\test1\\\" %*\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\n\t\t\t\tconst expectedData = process.platform === \"win32\" ?\n\t\t\t\t\tpath.join(path.dirname(executableDirName), packageName) :\n\t\t\t\t\tpath.join(nodeModulesDirName, \".bin\\\\..\\\\test1\");\n\n\t\t\t\tassert.deepEqual(result, expectedData);\n\t\t\t});\n\n\t\t\tit(\"returns correct result when where result is correct, and package is added to PATH via its bin dir\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texecutableDirName = path.join(\"C:\", \"Users\", \"username\", \"nativescript-cli\", \"bin\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\treturn filePath.indexOf(\"package.json\") !== -1;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn { stdout: whereResult };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, path.join(path.dirname(executableDirName)));\n\t\t\t});\n\n\t\t\tit(\"returns null when package is added to PATH via its bin dir, but the name in package.json is incorrect\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texecutableDirName = path.join(\"C:\", \"Users\", \"username\", \"nativescript-cli\", \"bin\"),\n\t\t\t\t\twhereResult = path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\treturn filePath.indexOf(\"package.json\") !== -1;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": \"invalidName\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn { stdout: whereResult };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, null);\n\t\t\t});\n\n\t\t\tit(\"returns correct result when where result returns multiple lines correct\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\texecutableDirName = path.join(\"C:\", \"Users\", \"username\", \"AppData\", \"Roaming\", \"npm\"),\n\t\t\t\t\tinvalidName = \"invalidName\",\n\t\t\t\t\tinvalidLineOfWhereResult = path.join(executableDirName, invalidName, invalidName, executableName),\n\t\t\t\t\twhereResult = invalidLineOfWhereResult + \"\\n\" + invalidLineOfWhereResult + \"\\r\\n\" + path.join(executableDirName, executableName);\n\n\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\tif (filePath && filePath.indexOf(invalidName) !== -1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t};\n\n\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\";\n\t\t\t\t};\n\n\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\tif (command.indexOf(\"where\") !== -1) {\n\t\t\t\t\t\treturn { stdout: whereResult };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\tassert.deepEqual(result, path.join(executableDirName, \"node_modules\", packageName));\n\t\t\t});\n\t\t});\n\t});\n\n\t// Remove win32 from supported platforms. Tests below are not for Windows.\n\tsupportedPlatforms.shift();\n\n\tsupportedPlatforms.forEach(platform => {\n\n\t\tdescribe(`on ${platform}`, () => {\n\t\t\tbeforeEach(() => {\n\t\t\t\tprocessWrapper.getProcessPlatform = () => platform;\n\t\t\t});\n\n\t\t\tit(\"uses npm for npm executable\", () => {\n\t\t\t\tlet commands = [];\n\t\t\t\tchildProcess.spawnSync = (command, commandArgs) => {\n\t\t\t\t\tcommands.push(`${command} ${(commandArgs || []).join(\" \")}`);\n\t\t\t\t};\n\n\t\t\t\tindex.getPath(\"test1\");\n\n\t\t\t\tassert.isTrue(commands.indexOf(\"npm config get prefix\") !== -1);\n\t\t\t});\n\n\t\t\tit(\"returns path containing npm prefix when it returns correct result and the searched module is installed there (and executable name is not passed)\", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\tnpmConfigPrefix = \"/bin/test\";\n\n\t\t\t\tconst resultPath = getCorrectResultFromNpmPrefix(npmConfigPrefix, packageName);\n\t\t\t\tassert.deepEqual(resultPath, path.join(npmConfigPrefix, \"lib\", \"node_modules\", packageName));\n\t\t\t});\n\n\t\t\tit(\"returns path containing npm prefix when it returns correct result and the searched module is installed there (and executable name is not passed), when npm prefix is not trimmed \", () => {\n\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\tnpmConfigPrefix = \"    /bin/test       \";\n\n\t\t\t\tconst resultPath = getCorrectResultFromNpmPrefix(npmConfigPrefix, packageName);\n\t\t\t\tassert.deepEqual(resultPath, path.join(npmConfigPrefix.trim(), \"lib\", \"node_modules\", packageName));\n\t\t\t});\n\n\t\t\tdescribe(\"works correctly when executableName is used\", () => {\n\t\t\t\tit(\"returns null when which command throws\", () => {\n\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\texpectedErrorMessage = \"Which error\";\n\n\t\t\t\t\tlet errors = [];\n\t\t\t\t\tconsole.error = (message) => errors.push(message);\n\n\t\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\t\tif (command.indexOf(\"which\") !== -1) {\n\t\t\t\t\t\t\tthrow new Error(expectedErrorMessage);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t};\n\n\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\tassert.deepEqual(errors.length, 1, \"Only single error should be thrown.\");\n\t\t\t\t\tassert.deepEqual(errors[0], expectedErrorMessage);\n\t\t\t\t});\n\n\t\t\t\tit(\"returns null when ls -l command throws\", () => {\n\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\texpectedErrorMessage = \"ls -l error\";\n\n\t\t\t\t\tlet errors = [];\n\t\t\t\t\tconsole.error = (message) => errors.push(message);\n\n\t\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\t\tchildProcess.spawnSync = (command) => {\n\t\t\t\t\t\tif (command === \"ls\") {\n\t\t\t\t\t\t\treturn { error: new Error(expectedErrorMessage) };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t};\n\n\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\tassert.deepEqual(errors.length, 1, \"Only single error should be thrown.\");\n\t\t\t\t\tassert.deepEqual(errors[0], expectedErrorMessage);\n\t\t\t\t});\n\n\t\t\t\tif (process.platform === \"win32\") {\n\t\t\t\t\tconsole.log(\"Some tests cannot be executed on Windows. PR will execute them on Linux, so don't worry.\");\n\t\t\t\t} else {\n\n\t\t\t\t\tconst constructData = (packageName, executableName, lsLResult, whichResult, readFileResult) => {\n\t\t\t\t\t\tfs.existsSync = () => true;\n\n\t\t\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\t\t\tif (readFileResult !== undefined) {\n\t\t\t\t\t\t\t\treturn readFileResult;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfs.realpathSync = (filePath) => {\n\t\t\t\t\t\t\treturn filePath;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tchildProcess.spawnSync = (command) => {\n\n\t\t\t\t\t\t\tif (command === \"ls\") {\n\t\t\t\t\t\t\t\treturn { stdout: lsLResult };\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (command == \"which\") {\n\t\t\t\t\t\t\t\treturn { stdout: whichResult };\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tit(\"returns correct result when which and ls -l results are correct\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"local\", \"node\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 ${whichResult} -> ${path.join(\"..\", \"lib\", \"node_modules\", packageName, \"bin\", executableName)}`;\n\n\t\t\t\t\t\tconstructData(packageName, executableName, lsLResult, whichResult);\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\t\tassert.deepEqual(result, path.join(executableDirName, \"..\", \"lib\", \"node_modules\", packageName));\n\t\t\t\t\t});\n\n\t\t\t\t\tit(\"returns null when ls -l result is not the searched one\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"local\", \"node\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 incorrect ls -l -> ${path.join(\"..\", \"lib\", \"node_modules\", packageName, \"bin\", executableName)}`;\n\n\t\t\t\t\t\tconstructData(packageName, executableName, lsLResult);\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName, whichResult);\n\t\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\t});\n\n\t\t\t\t\tit(\"returns null when ls -l result is not the searched one (no node_modules in it)\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"local\", \"node\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 ${whichResult} -> incorrect`,\n\t\t\t\t\t\t\treadFileResult = \"{}\";\n\n\t\t\t\t\t\tconstructData(packageName, executableName, lsLResult, whichResult, readFileResult);\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\t});\n\n\t\t\t\t\tit(\"returns correct result when which result is correct, and package is added to PATH via its bin dir\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"username\", \"repository_name\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 ${whichResult} -> incorrect`;\n\n\t\t\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\t\t\treturn filePath.indexOf(\"package.json\") !== -1;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tchildProcess.spawnSync = (command) => {\n\n\t\t\t\t\t\t\tif (command === \"ls\") {\n\t\t\t\t\t\t\t\treturn { stdout: lsLResult };\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (command == \"which\") {\n\t\t\t\t\t\t\t\treturn { stdout: whichResult };\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\t\t\"name\": packageName\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\t\tassert.deepEqual(result, path.dirname(executableDirName));\n\t\t\t\t\t});\n\n\t\t\t\t\tit(\"returns null when package is added to PATH via its bin dir, but the name in package.json is incorrect\", () => {\n\t\t\t\t\t\tconst packageName = \"test1\",\n\t\t\t\t\t\t\texecutableName = \"test1.js\",\n\t\t\t\t\t\t\texecutableDirName = path.join(\"/usr\", \"username\", \"repository_name\", \"bin\"),\n\t\t\t\t\t\t\twhichResult = path.join(executableDirName, executableName),\n\t\t\t\t\t\t\tlsLResult = `lrwxrwxrwx 1 rvladimirov rvladimirov 52 Oct 20 14:51 ${whichResult} -> incorrect`;\n\n\t\t\t\t\t\tfs.existsSync = (filePath) => {\n\t\t\t\t\t\t\treturn filePath.indexOf(\"package.json\") !== -1;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tchildProcess.spawnSync = (command) => {\n\n\t\t\t\t\t\t\tif (command === \"ls\") {\n\t\t\t\t\t\t\t\treturn { stdout: lsLResult };\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (command == \"which\") {\n\t\t\t\t\t\t\t\treturn { stdout: whichResult };\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfs.readFileSync = (filePath) => {\n\t\t\t\t\t\t\tif (filePath.indexOf(\"package.json\") !== -1) {\n\t\t\t\t\t\t\t\treturn JSON.stringify({\n\t\t\t\t\t\t\t\t\t\"name\": \"invalid name\"\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst result = index.getPath(packageName, executableName);\n\t\t\t\t\t\tassert.deepEqual(result, null);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n\n\tit(\"throws error when process.platform is not valid\", () => {\n\t\trequire(\"../lib/process-wrapper\").getProcessPlatform = () => \"1\";\n\t\tassert.throws(() => index.getPath(\"test1\", \"test1\"), \"OS '1' is not supported\");\n\t});\n\n});\n"], "filenames": ["lib/index.js", "test/index.js"], "buggy_code_start_loc": [27, 15], "buggy_code_end_loc": [150, 593], "fixing_code_start_loc": [28, 15], "fixing_code_end_loc": [169, 594], "type": "CWE-77", "message": "Versions of the package global-modules-path before 3.0.0 are vulnerable to Command Injection due to missing input sanitization or other checks and sandboxes being employed to the getPath function.", "other": {"cve": {"id": "CVE-2022-21191", "sourceIdentifier": "report@snyk.io", "published": "2023-01-13T05:15:19.150", "lastModified": "2023-01-20T07:12:30.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Versions of the package global-modules-path before 3.0.0 are vulnerable to Command Injection due to missing input sanitization or other checks and sandboxes being employed to the getPath function."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.4, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:global-modules-path_project:global-modules-path:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.0", "matchCriteriaId": "E0338CBB-839B-4EDE-9AA5-ECE664F2F3E2"}]}]}], "references": [{"url": "https://github.com/lorenzomigliorero/npm-node-utils/blob/b55dd81c597db657c9751332bb2242403fd3e26b/index.js%23L186", "source": "report@snyk.io", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://github.com/rosen-vladimirov/global-modules-path/commit/edbdaff077ea0cf295b1469923c06bbccad3c180", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rosen-vladimirov/global-modules-path/releases/tag/v3.0.0", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-GLOBALMODULESPATH-3167973", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rosen-vladimirov/global-modules-path/commit/edbdaff077ea0cf295b1469923c06bbccad3c180"}}