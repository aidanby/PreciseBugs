{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * message.c: functions for displaying messages on the command line\n */\n\n#define MESSAGE_FILE\t\t// don't include prototype for smsg()\n\n#include \"vim.h\"\n\nstatic void add_msg_hist(char_u *s, int len, int attr);\nstatic void hit_return_msg(void);\nstatic void msg_home_replace_attr(char_u *fname, int attr);\nstatic void msg_puts_attr_len(char *str, int maxlen, int attr);\nstatic void msg_puts_display(char_u *str, int maxlen, int attr, int recurse);\nstatic void msg_scroll_up(void);\nstatic void inc_msg_scrolled(void);\nstatic void store_sb_text(char_u **sb_str, char_u *s, int attr, int *sb_col, int finish);\nstatic void t_puts(int *t_col, char_u *t_s, char_u *s, int attr);\nstatic void msg_puts_printf(char_u *str, int maxlen);\nstatic int do_more_prompt(int typed_char);\nstatic void msg_screen_putchar(int c, int attr);\nstatic void msg_moremsg(int full);\nstatic int  msg_check_screen(void);\nstatic void redir_write(char_u *s, int maxlen);\n#ifdef FEAT_CON_DIALOG\nstatic char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton);\nstatic int\tconfirm_msg_used = FALSE;\t// displaying confirm_msg\nstatic char_u\t*confirm_msg = NULL;\t\t// \":confirm\" message\nstatic char_u\t*confirm_msg_tail;\t\t// tail of confirm_msg\nstatic void display_confirm_msg(void);\n#endif\n#ifdef FEAT_EVAL\nstatic int emsg_to_channel_log = FALSE;\n#endif\n\nstruct msg_hist\n{\n    struct msg_hist\t*next;\n    char_u\t\t*msg;\n    int\t\t\tattr;\n};\n\nstatic struct msg_hist *first_msg_hist = NULL;\nstatic struct msg_hist *last_msg_hist = NULL;\nstatic int msg_hist_len = 0;\n\nstatic FILE *verbose_fd = NULL;\nstatic int  verbose_did_open = FALSE;\n\n/*\n * When writing messages to the screen, there are many different situations.\n * A number of variables is used to remember the current state:\n * msg_didany\t    TRUE when messages were written since the last time the\n *\t\t    user reacted to a prompt.\n *\t\t    Reset: After hitting a key for the hit-return prompt,\n *\t\t    hitting <CR> for the command line or input().\n *\t\t    Set: When any message is written to the screen.\n * msg_didout\t    TRUE when something was written to the current line.\n *\t\t    Reset: When advancing to the next line, when the current\n *\t\t    text can be overwritten.\n *\t\t    Set: When any message is written to the screen.\n * msg_nowait\t    No extra delay for the last drawn message.\n *\t\t    Used in normal_cmd() before the mode message is drawn.\n * emsg_on_display  There was an error message recently.  Indicates that there\n *\t\t    should be a delay before redrawing.\n * msg_scroll\t    The next message should not overwrite the current one.\n * msg_scrolled\t    How many lines the screen has been scrolled (because of\n *\t\t    messages).  Used in update_screen() to scroll the screen\n *\t\t    back.  Incremented each time the screen scrolls a line.\n * msg_scrolled_ign  TRUE when msg_scrolled is non-zero and msg_puts_attr()\n *\t\t    writes something without scrolling should not make\n *\t\t    need_wait_return to be set.  This is a hack to make \":ts\"\n *\t\t    work without an extra prompt.\n * lines_left\t    Number of lines available for messages before the\n *\t\t    more-prompt is to be given.  -1 when not set.\n * need_wait_return TRUE when the hit-return prompt is needed.\n *\t\t    Reset: After giving the hit-return prompt, when the user\n *\t\t    has answered some other prompt.\n *\t\t    Set: When the ruler or typeahead display is overwritten,\n *\t\t    scrolling the screen for some message.\n * keep_msg\t    Message to be displayed after redrawing the screen, in\n *\t\t    main_loop().\n *\t\t    This is an allocated string or NULL when not used.\n */\n\n/*\n * msg(s) - displays the string 's' on the status line\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n * return TRUE if wait_return() not called\n */\n    int\nmsg(char *s)\n{\n    return msg_attr_keep(s, 0, FALSE);\n}\n\n/*\n * Like msg() but keep it silent when 'verbosefile' is set.\n */\n    int\nverb_msg(char *s)\n{\n    int\t\tn;\n\n    verbose_enter();\n    n = msg_attr_keep(s, 0, FALSE);\n    verbose_leave();\n\n    return n;\n}\n\n    int\nmsg_attr(char *s, int attr)\n{\n    return msg_attr_keep(s, attr, FALSE);\n}\n\n    int\nmsg_attr_keep(\n    char\t*s,\n    int\t\tattr,\n    int\t\tkeep)\t    // TRUE: set keep_msg if it doesn't scroll\n{\n    static int\tentered = 0;\n    int\t\tretval;\n    char_u\t*buf = NULL;\n\n    // Skip messages not matching \":filter pattern\".\n    // Don't filter when there is an error.\n    if (!emsg_on_display && message_filtered((char_u *)s))\n\treturn TRUE;\n\n#ifdef FEAT_EVAL\n    if (attr == 0)\n\tset_vim_var_string(VV_STATUSMSG, (char_u *)s, -1);\n#endif\n\n    /*\n     * It is possible that displaying a messages causes a problem (e.g.,\n     * when redrawing the window), which causes another message, etc..\tTo\n     * break this loop, limit the recursiveness to 3 levels.\n     */\n    if (entered >= 3)\n\treturn TRUE;\n    ++entered;\n\n    // Add message to history (unless it's a repeated kept message or a\n    // truncated message)\n    if ((char_u *)s != keep_msg\n\t    || (*s != '<'\n\t\t&& last_msg_hist != NULL\n\t\t&& last_msg_hist->msg != NULL\n\t\t&& STRCMP(s, last_msg_hist->msg)))\n\tadd_msg_hist((char_u *)s, -1, attr);\n\n#ifdef FEAT_EVAL\n    if (emsg_to_channel_log)\n\t// Write message in the channel log.\n\tch_log(NULL, \"ERROR: %s\", s);\n#endif\n\n    // Truncate the message if needed.\n    msg_start();\n    buf = msg_strtrunc((char_u *)s, FALSE);\n    if (buf != NULL)\n\ts = (char *)buf;\n\n    msg_outtrans_attr((char_u *)s, attr);\n    msg_clr_eos();\n    retval = msg_end();\n\n    if (keep && retval && vim_strsize((char_u *)s)\n\t\t\t    < (int)(Rows - cmdline_row - 1) * Columns + sc_col)\n\tset_keep_msg((char_u *)s, 0);\n\n    need_fileinfo = FALSE;\n\n    vim_free(buf);\n    --entered;\n    return retval;\n}\n\n/*\n * Truncate a string such that it can be printed without causing a scroll.\n * Returns an allocated string or NULL when no truncating is done.\n */\n    char_u *\nmsg_strtrunc(\n    char_u\t*s,\n    int\t\tforce)\t    // always truncate\n{\n    char_u\t*buf = NULL;\n    int\t\tlen;\n    int\t\troom;\n\n    // May truncate message to avoid a hit-return prompt\n    if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)\n\t\t\t       && !exmode_active && msg_silent == 0) || force)\n    {\n\tlen = vim_strsize(s);\n\tif (msg_scrolled != 0\n#ifdef HAS_MESSAGE_WINDOW\n\t\t|| in_echowindow\n#endif\n\t\t)\n\t    // Use all the columns.\n\t    room = (int)(Rows - msg_row) * Columns - 1;\n\telse\n\t    // Use up to 'showcmd' column.\n\t    room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\tif (len > room && room > 0)\n\t{\n\t    if (enc_utf8)\n\t\t// may have up to 18 bytes per cell (6 per char, up to two\n\t\t// composing chars)\n\t\tlen = (room + 2) * 18;\n\t    else if (enc_dbcs == DBCS_JPNU)\n\t\t// may have up to 2 bytes per cell for euc-jp\n\t\tlen = (room + 2) * 2;\n\t    else\n\t\tlen = room + 2;\n\t    buf = alloc(len);\n\t    if (buf != NULL)\n\t\ttrunc_string(s, buf, room, len);\n\t}\n    }\n    return buf;\n}\n\n/*\n * Truncate a string \"s\" to \"buf\" with cell width \"room\".\n * \"s\" and \"buf\" may be equal.\n */\n    void\ntrunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[e - 1] = NUL;\n    }\n}\n\n/*\n * Automatic prototype generation does not understand this function.\n * Note: Caller of smsg() and smsg_attr() must check the resulting string is\n * shorter than IOSIZE!!!\n */\n#ifndef PROTO\n\nint vim_snprintf(char *str, size_t str_m, const char *fmt, ...);\n\n    int\nsmsg(const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg((char *)s);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg((char *)IObuff);\n    }\n}\n\n    int\nsmsg_attr(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr((char *)s, attr);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg_attr((char *)IObuff, attr);\n    }\n}\n\n    int\nsmsg_attr_keep(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr_keep((char *)s, attr, TRUE);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg_attr_keep((char *)IObuff, attr, TRUE);\n    }\n}\n\n#endif\n\n/*\n * Remember the last sourcing name/lnum used in an error message, so that it\n * isn't printed each time when it didn't change.\n */\nstatic int\tlast_sourcing_lnum = 0;\nstatic char_u   *last_sourcing_name = NULL;\n\n/*\n * Reset the last used sourcing name/lnum.  Makes sure it is displayed again\n * for the next error message;\n */\n    void\nreset_last_sourcing(void)\n{\n    VIM_CLEAR(last_sourcing_name);\n    last_sourcing_lnum = 0;\n}\n\n/*\n * Return TRUE if \"SOURCING_NAME\" differs from \"last_sourcing_name\".\n */\n    static int\nother_sourcing_name(void)\n{\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL)\n    {\n\tif (last_sourcing_name != NULL)\n\t    return STRCMP(SOURCING_NAME, last_sourcing_name) != 0;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Get the message about the source, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_source(void)\n{\n    char_u\t*Buf, *p;\n\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL && other_sourcing_name())\n    {\n\tchar_u\t    *sname = estack_sfile(ESTACK_NONE);\n\tchar_u\t    *tofree = sname;\n\n\tif (sname == NULL)\n\t    sname = SOURCING_NAME;\n\n#ifdef FEAT_EVAL\n\tif (estack_compiling)\n\t    p = (char_u *)_(\"Error detected while compiling %s:\");\n\telse\n#endif\n\t    p = (char_u *)_(\"Error detected while processing %s:\");\n\tBuf = alloc(STRLEN(sname) + STRLEN(p));\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, sname);\n\tvim_free(tofree);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Get the message about the source lnum, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_lnum(void)\n{\n    char_u\t*Buf, *p;\n\n    // lnum is 0 when executing a command from the command line\n    // argument, we don't want a line number then\n    if (SOURCING_NAME != NULL\n\t    && (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)\n\t    && SOURCING_LNUM != 0)\n    {\n\tp = (char_u *)_(\"line %4ld:\");\n\tBuf = alloc(STRLEN(p) + 20);\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, (long)SOURCING_LNUM);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Display name and line number for the source of an error.\n * Remember the file name and line number, so that for the next error the info\n * is only displayed if it changed.\n */\n    void\nmsg_source(int attr)\n{\n    char_u\t*p;\n    static int\trecursive = FALSE;\n\n    // Bail out if something called here causes an error.\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n\n    ++no_wait_return;\n    p = get_emsg_source();\n    if (p != NULL)\n    {\n\tmsg_scroll = TRUE;  // this will take more than one line\n\tmsg_attr((char *)p, attr);\n\tvim_free(p);\n    }\n    p = get_emsg_lnum();\n    if (p != NULL)\n    {\n\tmsg_attr((char *)p, HL_ATTR(HLF_N));\n\tvim_free(p);\n\tlast_sourcing_lnum = SOURCING_LNUM;  // only once for each line\n    }\n\n    // remember the last sourcing name printed, also when it's empty\n    if (SOURCING_NAME == NULL || other_sourcing_name())\n    {\n\tVIM_CLEAR(last_sourcing_name);\n\tif (SOURCING_NAME != NULL)\n\t    last_sourcing_name = vim_strsave(SOURCING_NAME);\n    }\n    --no_wait_return;\n\n    recursive = FALSE;\n}\n\n/*\n * Return TRUE if not giving error messages right now:\n * If \"emsg_off\" is set: no error messages at the moment.\n * If \"msg\" is in 'debug': do error message but without side effects.\n * If \"emsg_skip\" is set: never do error messages.\n */\n    static int\nemsg_not_now(void)\n{\n    if ((emsg_off > 0 && vim_strchr(p_debug, 'm') == NULL\n\t\t\t\t\t  && vim_strchr(p_debug, 't') == NULL)\n#ifdef FEAT_EVAL\n\t    || emsg_skip > 0\n#endif\n\t    )\n\treturn TRUE;\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic garray_T ignore_error_list = GA_EMPTY;\n\n    void\nignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP(\"RESET\", error) == 0)\n\tga_clear_strings(&ignore_error_list);\n    else\n\tga_copy_string(&ignore_error_list, error);\n}\n\n    static int\nignore_error(char_u *msg)\n{\n    int i;\n\n    for (i = 0; i < ignore_error_list.ga_len; ++i)\n\tif (strstr((char *)msg,\n\t\t  (char *)((char_u **)(ignore_error_list.ga_data))[i]) != NULL)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n#if !defined(HAVE_STRERROR) || defined(PROTO)\n/*\n * Replacement for perror() that behaves more or less like emsg() was called.\n * v:errmsg will be set and called_emsg will be incremented.\n */\n    void\ndo_perror(char *msg)\n{\n    perror(msg);\n    ++emsg_silent;\n    emsg(msg);\n    --emsg_silent;\n}\n#endif\n\n/*\n * emsg_core() - display an error message\n *\n * Rings the bell, if appropriate, and calls message() to do the real work\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n *\n * Return TRUE if wait_return() not called.\n * Note: caller must check 'emsg_not_now()' before calling this.\n */\n    static int\nemsg_core(char_u *s)\n{\n    int\t\tattr;\n    char_u\t*p;\n    int\t\tr;\n#ifdef FEAT_EVAL\n    int\t\tignore = FALSE;\n    int\t\tsevere;\n#endif\n\n#ifdef FEAT_EVAL\n    // When testing some errors are turned into a normal message.\n    if (ignore_error(s))\n\t// don't call msg() if it results in a dialog\n\treturn msg_use_printf() ? FALSE : msg((char *)s);\n#endif\n\n    ++called_emsg;\n\n#ifdef FEAT_EVAL\n    // If \"emsg_severe\" is TRUE: When an error exception is to be thrown,\n    // prefer this message over previous messages for the same command.\n    severe = emsg_severe;\n    emsg_severe = FALSE;\n#endif\n\n    if (!emsg_off || vim_strchr(p_debug, 't') != NULL)\n    {\n#ifdef FEAT_EVAL\n\t/*\n\t * Cause a throw of an error exception if appropriate.  Don't display\n\t * the error message in this case.  (If no matching catch clause will\n\t * be found, the message will be displayed later on.)  \"ignore\" is set\n\t * when the message should be ignored completely (used for the\n\t * interrupt message).\n\t */\n\tif (cause_errthrow(s, severe, &ignore) == TRUE)\n\t{\n\t    if (!ignore)\n\t\t++did_emsg;\n\t    return TRUE;\n\t}\n\n\tif (in_assert_fails && emsg_assert_fails_msg == NULL)\n\t{\n\t    emsg_assert_fails_msg = vim_strsave(s);\n\t    emsg_assert_fails_lnum = SOURCING_LNUM;\n\t    vim_free(emsg_assert_fails_context);\n\t    emsg_assert_fails_context = vim_strsave(\n\t\t\t SOURCING_NAME == NULL ? (char_u *)\"\" : SOURCING_NAME);\n\t}\n\n\t// set \"v:errmsg\", also when using \":silent! cmd\"\n\tset_vim_var_string(VV_ERRMSG, s, -1);\n#endif\n\n\t/*\n\t * When using \":silent! cmd\" ignore error messages.\n\t * But do write it to the redirection file.\n\t */\n\tif (emsg_silent != 0)\n\t{\n#ifdef FEAT_EVAL\n\t    ++did_emsg_silent;\n#endif\n\t    if (emsg_noredir == 0)\n\t    {\n\t\tmsg_start();\n\t\tp = get_emsg_source();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tp = get_emsg_lnum();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tredir_write(s, -1);\n\t    }\n#ifdef FEAT_EVAL\n\t    // Only increment did_emsg_def when :silent! wasn't used inside the\n\t    // :def function.\n\t    if (emsg_silent == emsg_silent_def)\n\t\t++did_emsg_def;\n#endif\n#ifdef FEAT_EVAL\n\t    ch_log(NULL, \"ERROR silent: %s\", (char *)s);\n#endif\n\t    return TRUE;\n\t}\n\n\tex_exitval = 1;\n\n\t// Reset msg_silent, an error causes messages to be switched back on.\n\tmsg_silent = 0;\n\tcmd_silent = FALSE;\n\n\tif (global_busy)\t\t// break :global command\n\t    ++global_busy;\n\n\tif (p_eb)\n\t    beep_flush();\t\t// also includes flush_buffers()\n\telse\n\t    flush_buffers(FLUSH_MINIMAL);  // flush internal buffers\n\t++did_emsg;\t\t\t   // flag for DoOneCmd()\n#ifdef FEAT_EVAL\n\t++uncaught_emsg;\n#endif\n    }\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (!in_echowindow)\n#endif\n\temsg_on_display = TRUE;\t    // remember there is an error message\n\n    attr = HL_ATTR(HLF_E);\t    // set highlight mode for error messages\n    if (msg_scrolled != 0)\n\tneed_wait_return = TRUE;    // needed in case emsg() is called after\n\t\t\t\t    // wait_return() has reset need_wait_return\n\t\t\t\t    // and a redraw is expected because\n\t\t\t\t    // msg_scrolled is non-zero\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = TRUE;\n#endif\n    /*\n     * Display name and line number for the source of the error.\n     */\n    msg_scroll = TRUE;\n    msg_source(attr);\n\n    /*\n     * Display the error message itself.\n     */\n    msg_nowait = FALSE;\t\t\t// wait for this msg\n    r = msg_attr((char *)s, attr);\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = FALSE;\n#endif\n    return r;\n}\n\n/*\n * Print an error message.\n */\n    int\nemsg(char *s)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n\treturn emsg_core((char_u *)s);\n    return TRUE;\t\t// no error messages at the moment\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Print an error message with format string and variable arguments.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    int\nsemsg(const char *s, ...)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    return emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    return emsg_core(IObuff);\n\t}\n    }\n    return TRUE;\t\t// no error messages at the moment\n}\n#endif\n\n/*\n * Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n */\n    void\niemsg(char *s)\n{\n    if (!emsg_not_now())\n    {\n\temsg_core((char_u *)s);\n#if defined(ABORT_ON_INTERNAL_ERROR) && defined(FEAT_EVAL)\n\tset_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n\tmsg_putchar('\\n');  // avoid overwriting the error message\n\tout_flush();\n\tabort();\n#endif\n    }\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    void\nsiemsg(const char *s, ...)\n{\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    emsg_core(IObuff);\n\t}\n# ifdef ABORT_ON_INTERNAL_ERROR\n\tmsg_putchar('\\n');  // avoid overwriting the error message\n\tout_flush();\n\tabort();\n# endif\n    }\n}\n#endif\n\n/*\n * Give an \"Internal error\" message.\n */\n    void\ninternal_error(char *where)\n{\n    siemsg(_(e_internal_error_str), where);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Like internal_error() but do not call abort(), to avoid tests using\n * test_unknown() and test_void() causing Vim to exit.\n */\n    void\ninternal_error_no_abort(char *where)\n{\n     semsg(_(e_internal_error_str), where);\n}\n#endif\n\n// emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes.\n\n    void\nemsg_invreg(int name)\n{\n    semsg(_(e_invalid_register_name_str), transchar(name));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Give an error message which contains %s for \"name[len]\".\n */\n    void\nemsg_namelen(char *msg, char_u *name, int len)\n{\n    char_u *copy = vim_strnsave(name, len);\n\n    semsg(msg, copy == NULL ? \"NULL\" : (char *)copy);\n    vim_free(copy);\n}\n#endif\n\n/*\n * Like msg(), but truncate to a single line if p_shm contains 't', or when\n * \"force\" is TRUE.  This truncates in another way as for normal messages.\n * Careful: The string may be changed by msg_may_trunc()!\n * Returns a pointer to the printed message, if wait_return() not called.\n */\n    char *\nmsg_trunc_attr(char *s, int force, int attr)\n{\n    int\t\tn;\n    char\t*ts;\n\n    // Add message to history before truncating\n    add_msg_hist((char_u *)s, -1, attr);\n\n    ts = (char *)msg_may_trunc(force, (char_u *)s);\n\n    msg_hist_off = TRUE;\n    n = msg_attr(ts, attr);\n    msg_hist_off = FALSE;\n\n    if (n)\n\treturn ts;\n    return NULL;\n}\n\n/*\n * Check if message \"s\" should be truncated at the start (for filenames).\n * Return a pointer to where the truncated message starts.\n * Note: May change the message by replacing a character with '<'.\n */\n    char_u *\nmsg_may_trunc(int force, char_u *s)\n{\n    int\t\tn;\n    int\t\troom;\n\n    // If 'cmdheight' is zero or something unexpected happened \"room\" may be\n    // negative.\n    room = (int)(Rows - cmdline_row - 1) * Columns + sc_col - 1;\n    if (room > 0 && (force || (shortmess(SHM_TRUNC) && !exmode_active))\n\t    && (n = (int)STRLEN(s) - room) > 0)\n    {\n\tif (has_mbyte)\n\t{\n\t    int\tsize = vim_strsize(s);\n\n\t    // There may be room anyway when there are multibyte chars.\n\t    if (size <= room)\n\t\treturn s;\n\n\t    for (n = 0; size >= room; )\n\t    {\n\t\tsize -= (*mb_ptr2cells)(s + n);\n\t\tn += (*mb_ptr2len)(s + n);\n\t    }\n\t    --n;\n\t}\n\ts += n;\n\t*s = '<';\n    }\n    return s;\n}\n\n    static void\nadd_msg_hist(\n    char_u\t*s,\n    int\t\tlen,\t\t// -1 for undetermined length\n    int\t\tattr)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_off || msg_silent != 0)\n\treturn;\n\n    // Don't let the message history get too big\n    while (msg_hist_len > MAX_MSG_HIST_LEN)\n\t(void)delete_first_msg();\n\n    // allocate an entry and add the message at the end of the history\n    p = ALLOC_ONE(struct msg_hist);\n    if (p != NULL)\n    {\n\tif (len < 0)\n\t    len = (int)STRLEN(s);\n\t// remove leading and trailing newlines\n\twhile (len > 0 && *s == '\\n')\n\t{\n\t    ++s;\n\t    --len;\n\t}\n\twhile (len > 0 && s[len - 1] == '\\n')\n\t    --len;\n\tp->msg = vim_strnsave(s, len);\n\tp->next = NULL;\n\tp->attr = attr;\n\tif (last_msg_hist != NULL)\n\t    last_msg_hist->next = p;\n\tlast_msg_hist = p;\n\tif (first_msg_hist == NULL)\n\t    first_msg_hist = last_msg_hist;\n\t++msg_hist_len;\n    }\n}\n\n/*\n * Delete the first (oldest) message from the history.\n * Returns FAIL if there are no messages.\n */\n    int\ndelete_first_msg(void)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_len <= 0)\n\treturn FAIL;\n    p = first_msg_hist;\n    first_msg_hist = p->next;\n    if (first_msg_hist == NULL)\n\tlast_msg_hist = NULL;  // history is empty\n    vim_free(p->msg);\n    vim_free(p);\n    --msg_hist_len;\n    return OK;\n}\n\n/*\n * \":messages\" command.\n */\n    void\nex_messages(exarg_T *eap)\n{\n    struct msg_hist *p;\n    char_u\t    *s;\n    int\t\t    c = 0;\n\n    if (STRCMP(eap->arg, \"clear\") == 0)\n    {\n\tint keep = eap->addr_count == 0 ? 0 : eap->line2;\n\n\twhile (msg_hist_len > keep)\n\t    (void)delete_first_msg();\n\treturn;\n    }\n\n    if (*eap->arg != NUL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    msg_hist_off = TRUE;\n\n    p = first_msg_hist;\n    if (eap->addr_count != 0)\n    {\n\t// Count total messages\n\tfor (; p != NULL && !got_int; p = p->next)\n\t    c++;\n\n\tc -= eap->line2;\n\n\t// Skip without number of messages specified\n\tfor (p = first_msg_hist; p != NULL && !got_int && c > 0;\n\t\t\t\t\t\t    p = p->next, c--);\n    }\n\n    if (p == first_msg_hist)\n    {\n#ifdef FEAT_MULTI_LANG\n\ts = get_mess_lang();\n#else\n\ts = mch_getenv((char_u *)\"LANG\");\n#endif\n\tif (s != NULL && *s != NUL)\n\t    // The next comment is extracted by xgettext and put in po file for\n\t    // translators to read.\n\t    msg_attr(\n\t\t    // Translator: Please replace the name and email address\n\t\t    // with the appropriate text for your translation.\n\t\t    _(\"Messages maintainer: Bram Moolenaar <Bram@vim.org>\"),\n\t\t    HL_ATTR(HLF_T));\n    }\n\n    // Display what was not skipped.\n    for (; p != NULL && !got_int; p = p->next)\n\tif (p->msg != NULL)\n\t    msg_attr((char *)p->msg, p->attr);\n\n    msg_hist_off = FALSE;\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(FIND_REPLACE_DIALOG) || defined(PROTO)\n/*\n * Call this after prompting the user.  This will avoid a hit-return message\n * and a delay.\n */\n    void\nmsg_end_prompt(void)\n{\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    cmdline_row = msg_row;\n    msg_col = 0;\n    msg_clr_eos();\n    lines_left = -1;\n}\n#endif\n\n/*\n * Wait for the user to hit a key (normally Enter).\n * If \"redraw\" is TRUE, clear and redraw the screen.\n * If \"redraw\" is FALSE, just redraw the screen.\n * If \"redraw\" is -1, don't redraw at all.\n */\n    void\nwait_return(int redraw)\n{\n    int\t\tc;\n    int\t\toldState;\n    int\t\ttmpState;\n    int\t\thad_got_int;\n    int\t\tsave_reg_recording;\n    FILE\t*save_scriptout;\n\n    if (redraw == TRUE)\n\tset_must_redraw(UPD_CLEAR);\n\n    // If using \":silent cmd\", don't wait for a return.  Also don't set\n    // need_wait_return to do it later.\n    if (msg_silent != 0)\n\treturn;\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;\n#endif\n\n    /*\n     * When inside vgetc(), we can't wait for a typed character at all.\n     * With the global command (and some others) we only need one return at\n     * the end. Adjust cmdline_row to avoid the next message overwriting the\n     * last one.\n     */\n    if (vgetc_busy > 0)\n\treturn;\n    need_wait_return = TRUE;\n    if (no_wait_return)\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\treturn;\n    }\n\n    redir_off = TRUE;\t\t// don't redirect this message\n    oldState = State;\n    if (quit_more)\n    {\n\tc = CAR;\t\t// just pretend CR was hit\n\tquit_more = FALSE;\n\tgot_int = FALSE;\n    }\n    else if (exmode_active)\n    {\n\tmsg_puts(\" \");\t\t// make sure the cursor is on the right line\n\tc = CAR;\t\t// no need for a return in ex mode\n\tgot_int = FALSE;\n    }\n    else\n    {\n\t// Make sure the hit-return prompt is on screen when 'guioptions' was\n\t// just changed.\n\tscreenalloc(FALSE);\n\n\tState = MODE_HITRETURN;\n\tsetmouse();\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\tcmdline_row = msg_row;\n\n\t// Avoid the sequence that the user types \":\" at the hit-return prompt\n\t// to start an Ex command, but the file-changed dialog gets in the\n\t// way.\n\tif (need_check_timestamps)\n\t    check_timestamps(FALSE);\n\n\thit_return_msg();\n\n\tdo\n\t{\n\t    // Remember \"got_int\", if it is set vgetc() probably returns a\n\t    // CTRL-C, but we need to loop then.\n\t    had_got_int = got_int;\n\n\t    // Don't do mappings here, we put the character back in the\n\t    // typeahead buffer.\n\t    ++no_mapping;\n\t    ++allow_keys;\n\n\t    // Temporarily disable Recording. If Recording is active, the\n\t    // character will be recorded later, since it will be added to the\n\t    // typebuf after the loop\n\t    save_reg_recording = reg_recording;\n\t    save_scriptout = scriptout;\n\t    reg_recording = 0;\n\t    scriptout = NULL;\n\t    c = safe_vgetc();\n\t    if (had_got_int && !global_busy)\n\t\tgot_int = FALSE;\n\t    --no_mapping;\n\t    --allow_keys;\n\t    reg_recording = save_reg_recording;\n\t    scriptout = save_scriptout;\n\n#ifdef FEAT_CLIPBOARD\n\t    // Strange way to allow copying (yanking) a modeless selection at\n\t    // the hit-enter prompt.  Use CTRL-Y, because the same is used in\n\t    // Cmdline-mode and it's harmless when there is no selection.\n\t    if (c == Ctrl_Y && clip_star.state == SELECT_DONE)\n\t    {\n\t\tclip_copy_modeless_selection(TRUE);\n\t\tc = K_IGNORE;\n\t    }\n#endif\n\n\t    /*\n\t     * Allow scrolling back in the messages.\n\t     * Also accept scroll-down commands when messages fill the screen,\n\t     * to avoid that typing one 'j' too many makes the messages\n\t     * disappear.\n\t     */\n\t    if (p_more && !p_cp)\n\t    {\n\t\tif (c == 'b' || c == 'k' || c == 'u' || c == 'g'\n\t\t\t\t\t\t|| c == K_UP || c == K_PAGEUP)\n\t\t{\n\t\t    if (msg_scrolled > Rows)\n\t\t\t// scroll back to show older messages\n\t\t\tdo_more_prompt(c);\n\t\t    else\n\t\t    {\n\t\t\tmsg_didout = FALSE;\n\t\t\tc = K_IGNORE;\n\t\t\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t\t\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t\t\t    0;\n\t\t    }\n\t\t    if (quit_more)\n\t\t    {\n\t\t\tc = CAR;\t\t// just pretend CR was hit\n\t\t\tquit_more = FALSE;\n\t\t\tgot_int = FALSE;\n\t\t    }\n\t\t    else if (c != K_IGNORE)\n\t\t    {\n\t\t\tc = K_IGNORE;\n\t\t\thit_return_msg();\n\t\t    }\n\t\t}\n\t\telse if (msg_scrolled > Rows - 2\n\t\t\t && (c == 'j' || c == 'd' || c == 'f'\n\t\t\t\t\t   || c == K_DOWN || c == K_PAGEDOWN))\n\t\t    c = K_IGNORE;\n\t    }\n\t} while ((had_got_int && c == Ctrl_C)\n\t\t\t\t|| c == K_IGNORE\n#ifdef FEAT_GUI\n\t\t\t\t|| c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR\n#endif\n\t\t\t\t|| c == K_LEFTDRAG   || c == K_LEFTRELEASE\n\t\t\t\t|| c == K_MIDDLEDRAG || c == K_MIDDLERELEASE\n\t\t\t\t|| c == K_RIGHTDRAG  || c == K_RIGHTRELEASE\n\t\t\t\t|| c == K_MOUSELEFT  || c == K_MOUSERIGHT\n\t\t\t\t|| c == K_MOUSEDOWN  || c == K_MOUSEUP\n\t\t\t\t|| c == K_MOUSEMOVE\n\t\t\t\t|| (!mouse_has(MOUSE_RETURN)\n\t\t\t\t    && mouse_row < msg_row\n\t\t\t\t    && (c == K_LEFTMOUSE\n\t\t\t\t\t|| c == K_MIDDLEMOUSE\n\t\t\t\t\t|| c == K_RIGHTMOUSE\n\t\t\t\t\t|| c == K_X1MOUSE\n\t\t\t\t\t|| c == K_X2MOUSE))\n\t\t\t\t);\n\tui_breakcheck();\n\n\t// Avoid that the mouse-up event causes Visual mode to start.\n\tif (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE\n\t\t\t\t\t  || c == K_X1MOUSE || c == K_X2MOUSE)\n\t    (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);\n\telse if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C)\n\t{\n\t    // Put the character back in the typeahead buffer.  Don't use the\n\t    // stuff buffer, because lmaps wouldn't work.\n\t    ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\t    do_redraw = TRUE;\t    // need a redraw even though there is\n\t\t\t\t    // typeahead\n\t}\n    }\n    redir_off = FALSE;\n\n    /*\n     * If the user hits ':', '?' or '/' we get a command line from the next\n     * line.\n     */\n    if (c == ':' || c == '?' || c == '/')\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\tskip_redraw = TRUE;\t    // skip redraw once\n\tdo_redraw = FALSE;\n#ifdef FEAT_TERMINAL\n\tskip_term_loop = TRUE;\n#endif\n    }\n\n    /*\n     * If the window size changed set_shellsize() will redraw the screen.\n     * Otherwise the screen is only redrawn if 'redraw' is set and no ':'\n     * typed.\n     */\n    tmpState = State;\n    State = oldState;\t\t    // restore State before set_shellsize\n    setmouse();\n    msg_check();\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * When switching screens, we need to output an extra newline on exit.\n     */\n    if (swapping_screen() && !termcap_active)\n\tnewline_on_exit = TRUE;\n#endif\n\n    need_wait_return = FALSE;\n    did_wait_return = TRUE;\n    emsg_on_display = FALSE;\t// can delete error message now\n    lines_left = -1;\t\t// reset lines_left at next msg_start()\n    reset_last_sourcing();\n    if (keep_msg != NULL && vim_strsize(keep_msg) >=\n\t\t\t\t  (Rows - cmdline_row - 1) * Columns + sc_col)\n\tVIM_CLEAR(keep_msg);\t    // don't redisplay message, it's too long\n\n    if (tmpState == MODE_SETWSIZE)  // got resize event while in vgetc()\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tshell_resized();\n    }\n    else if (!skip_redraw\n\t    && (redraw == TRUE || (msg_scrolled != 0 && redraw != -1)))\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tredraw_later(UPD_VALID);\n    }\n}\n\n/*\n * Write the hit-return prompt.\n */\n    static void\nhit_return_msg(void)\n{\n    int\t\tsave_p_more = p_more;\n\n    p_more = FALSE;\t// don't want to see this message when scrolling back\n    if (msg_didout)\t// start on a new line\n\tmsg_putchar('\\n');\n    if (got_int)\n\tmsg_puts(_(\"Interrupt: \"));\n\n    msg_puts_attr(_(\"Press ENTER or type command to continue\"), HL_ATTR(HLF_R));\n    if (!msg_use_printf())\n\tmsg_clr_eos();\n    p_more = save_p_more;\n}\n\n/*\n * Set \"keep_msg\" to \"s\".  Free the old value and check for NULL pointer.\n */\n    void\nset_keep_msg(char_u *s, int attr)\n{\n    vim_free(keep_msg);\n    if (s != NULL && msg_silent == 0)\n\tkeep_msg = vim_strsave(s);\n    else\n\tkeep_msg = NULL;\n    keep_msg_more = FALSE;\n    keep_msg_attr = attr;\n}\n\n/*\n * If there currently is a message being displayed, set \"keep_msg\" to it, so\n * that it will be displayed again after redraw.\n */\n    void\nset_keep_msg_from_hist(void)\n{\n    if (keep_msg == NULL && last_msg_hist != NULL && msg_scrolled == 0\n\t\t\t\t\t\t      && (State & MODE_NORMAL))\n\tset_keep_msg(last_msg_hist->msg, last_msg_hist->attr);\n}\n\n/*\n * Prepare for outputting characters in the command line.\n */\n    void\nmsg_start(void)\n{\n    int\t\tdid_return = FALSE;\n\n    if (!msg_silent)\n    {\n\tVIM_CLEAR(keep_msg);\n\tneed_fileinfo = FALSE;\n    }\n\n#ifdef FEAT_EVAL\n    if (need_clr_eos)\n    {\n\t// Halfway an \":echo\" command and getting an (error) message: clear\n\t// any text from the command.\n\tneed_clr_eos = FALSE;\n\tmsg_clr_eos();\n    }\n#endif\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n    {\n\tif (popup_message_win_visible()\n\t\t    && ((msg_col > 0 && (msg_scroll || !full_screen))\n\t\t\t|| in_echowindow))\n\t{\n\t    win_T *wp = popup_get_message_win();\n\n\t    // start a new line\n\t    curbuf = wp->w_buffer;\n\t    ml_append(wp->w_buffer->b_ml.ml_line_count,\n\t\t\t\t\t      (char_u *)\"\", (colnr_T)0, FALSE);\n\t    curbuf = curwin->w_buffer;\n\t}\n\tmsg_col = 0;\n    }\n    else\n#endif\n\tif (!msg_scroll && full_screen)\t// overwrite last message\n    {\n\tmsg_row = cmdline_row;\n\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t    0;\n    }\n    else if (msg_didout || in_echowindow)\n    {\n\t// start message on next line\n\tmsg_putchar('\\n');\n\tdid_return = TRUE;\n\tif (exmode_active != EXMODE_NORMAL)\n\t    cmdline_row = msg_row;\n    }\n    if (!msg_didany || lines_left < 0)\n\tmsg_starthere();\n    if (msg_silent == 0)\n    {\n\tmsg_didout = FALSE;\t\t    // no output on current line yet\n\tcursor_off();\n    }\n\n    // when redirecting, may need to start a new line.\n    if (!did_return)\n\tredir_write((char_u *)\"\\n\", -1);\n}\n\n/*\n * Note that the current msg position is where messages start.\n */\n    void\nmsg_starthere(void)\n{\n    lines_left = cmdline_row;\n    msg_didany = FALSE;\n}\n\n    void\nmsg_putchar(int c)\n{\n    msg_putchar_attr(c, 0);\n}\n\n    void\nmsg_putchar_attr(int c, int attr)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (IS_SPECIAL(c))\n    {\n\tbuf[0] = K_SPECIAL;\n\tbuf[1] = K_SECOND(c);\n\tbuf[2] = K_THIRD(c);\n\tbuf[3] = NUL;\n    }\n    else\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    msg_puts_attr((char *)buf, attr);\n}\n\n    void\nmsg_outnum(long n)\n{\n    char\tbuf[20];\n\n    sprintf(buf, \"%ld\", n);\n    msg_puts(buf);\n}\n\n    void\nmsg_home_replace(char_u *fname)\n{\n    msg_home_replace_attr(fname, 0);\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n    void\nmsg_home_replace_hl(char_u *fname)\n{\n    msg_home_replace_attr(fname, HL_ATTR(HLF_D));\n}\n#endif\n\n    static void\nmsg_home_replace_attr(char_u *fname, int attr)\n{\n    char_u\t*name;\n\n    name = home_replace_save(NULL, fname);\n    if (name != NULL)\n\tmsg_outtrans_attr(name, attr);\n    vim_free(name);\n}\n\n/*\n * Output 'len' characters in 'str' (including NULs) with translation\n * if 'len' is -1, output up to a NUL character.\n * Use attributes 'attr'.\n * Return the number of characters it takes on the screen.\n */\n    int\nmsg_outtrans(char_u *str)\n{\n    return msg_outtrans_attr(str, 0);\n}\n\n    int\nmsg_outtrans_attr(char_u *str, int attr)\n{\n    return msg_outtrans_len_attr(str, (int)STRLEN(str), attr);\n}\n\n    int\nmsg_outtrans_len(char_u *str, int len)\n{\n    return msg_outtrans_len_attr(str, len, 0);\n}\n\n/*\n * Output one character at \"p\".  Return pointer to the next character.\n * Handles multi-byte characters.\n */\n    char_u *\nmsg_outtrans_one(char_u *p, int attr)\n{\n    int\t\tl;\n\n    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n    {\n\tmsg_outtrans_len_attr(p, l, attr);\n\treturn p + l;\n    }\n    msg_puts_attr((char *)transchar_byte(*p), attr);\n    return p + 1;\n}\n\n    int\nmsg_outtrans_len_attr(char_u *msgstr, int len, int attr)\n{\n    int\t\tretval = 0;\n    char_u\t*str = msgstr;\n    char_u\t*plain_start = msgstr;\n    char_u\t*s;\n    int\t\tmb_l;\n    int\t\tc;\n    int\t\tsave_got_int = got_int;\n\n    // Only quit when got_int was set in here.\n    got_int = FALSE;\n\n    // if MSG_HIST flag set, add message to history\n    if (attr & MSG_HIST)\n    {\n\tadd_msg_hist(str, len, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // If the string starts with a composing character first draw a space on\n    // which the composing char can be drawn.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))\n\tmsg_puts_attr(\" \", attr);\n\n    /*\n     * Go over the string.  Special characters are translated and printed.\n     * Normal characters are printed several at a time.\n     */\n    while (--len >= 0 && !got_int)\n    {\n\tif (enc_utf8)\n\t    // Don't include composing chars after the end.\n\t    mb_l = utfc_ptr2len_len(str, len + 1);\n\telse if (has_mbyte)\n\t    mb_l = (*mb_ptr2len)(str);\n\telse\n\t    mb_l = 1;\n\tif (has_mbyte && mb_l > 1)\n\t{\n\t    c = (*mb_ptr2char)(str);\n\t    if (vim_isprintc(c))\n\t\t// printable multi-byte char: count the cells.\n\t\tretval += (*mb_ptr2cells)(str);\n\t    else\n\t    {\n\t\t// unprintable multi-byte char: print the printable chars so\n\t\t// far and the translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + mb_l;\n\t\tmsg_puts_attr((char *)transchar(c),\n\t\t\t\t\t    attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += char2cells(c);\n\t    }\n\t    len -= mb_l - 1;\n\t    str += mb_l;\n\t}\n\telse\n\t{\n\t    s = transchar_byte(*str);\n\t    if (s[1] != NUL)\n\t    {\n\t\t// unprintable char: print the printable chars so far and the\n\t\t// translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + 1;\n\t\tmsg_puts_attr((char *)s, attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += (int)STRLEN(s);\n\t    }\n\t    else\n\t\t++retval;\n\t    ++str;\n\t}\n    }\n\n    if (str > plain_start && !got_int)\n\t// print the printable chars at the end\n\tmsg_puts_attr_len((char *)plain_start, (int)(str - plain_start), attr);\n\n    got_int |= save_got_int;\n\n    return retval;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    void\nmsg_make(char_u *arg)\n{\n    int\t    i;\n    static char_u *str = (char_u *)\"eeffoc\", *rs = (char_u *)\"Plon#dqg#vxjduB\";\n\n    arg = skipwhite(arg);\n    for (i = 5; *arg && i >= 0; --i)\n\tif (*arg++ != str[i])\n\t    break;\n    if (i < 0)\n    {\n\tmsg_putchar('\\n');\n\tfor (i = 0; rs[i]; ++i)\n\t    msg_putchar(rs[i] - 3);\n    }\n}\n#endif\n\n/*\n * Output the string 'str' up to a NUL character.\n * Return the number of characters it takes on the screen.\n *\n * If K_SPECIAL is encountered, then it is taken in conjunction with the\n * following character and shown as <F1>, <S-Up> etc.  Any other character\n * which is not printable shown in <> form.\n * If 'from' is TRUE (lhs of a mapping), a space is shown as <Space>.\n * If a character is displayed in one of these special ways, is also\n * highlighted (its highlight name is '8' in the p_hl variable).\n * Otherwise characters are not highlighted.\n * This function is used to show mappings, where we want to see how to type\n * the character/string -- webb\n */\n    int\nmsg_outtrans_special(\n    char_u\t*strstart,\n    int\t\tfrom,\t// TRUE for lhs of a mapping\n    int\t\tmaxlen) // screen columns, 0 for unlimited\n{\n    char_u\t*str = strstart;\n    int\t\tretval = 0;\n    char\t*text;\n    int\t\tattr;\n    int\t\tlen;\n\n    attr = HL_ATTR(HLF_8);\n    while (*str != NUL)\n    {\n\t// Leading and trailing spaces need to be displayed in <> form.\n\tif ((str == strstart || str[1] == NUL) && *str == ' ')\n\t{\n\t    text = \"<Space>\";\n\t    ++str;\n\t}\n\telse\n\t    text = (char *)str2special(&str, from, FALSE);\n\tif (text[0] != NUL && text[1] == NUL)\n\t    // single-byte character or illegal byte\n\t    text = (char *)transchar_byte((char_u)text[0]);\n\tlen = vim_strsize((char_u *)text);\n\tif (maxlen > 0 && retval + len >= maxlen)\n\t    break;\n\t// Highlight special keys\n\tmsg_puts_attr(text, len > 1\n\t\t&& (*mb_ptr2len)((char_u *)text) <= 1 ? attr : 0);\n\tretval += len;\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return the lhs or rhs of a mapping, with the key codes turned into printable\n * strings, in an allocated string.\n */\n    char_u *\nstr2special_save(\n    char_u  *str,\n    int\t    replace_spaces,\t// TRUE to replace \" \" with \"<Space>\".\n\t\t\t\t// used for the lhs of mapping and keytrans().\n    int\t    replace_lt)\t\t// TRUE to replace \"<\" with \"<lt>\".\n{\n    garray_T\tga;\n    char_u\t*p = str;\n\n    ga_init2(&ga, 1, 40);\n    while (*p != NUL)\n\tga_concat(&ga, str2special(&p, replace_spaces, replace_lt));\n    ga_append(&ga, NUL);\n    return (char_u *)ga.ga_data;\n}\n#endif\n\n/*\n * Return the printable string for the key codes at \"*sp\".\n * On illegal byte return a string with only that byte.\n * Used for translating the lhs or rhs of a mapping to printable chars.\n * Advances \"sp\" to the next code.\n */\n    char_u *\nstr2special(\n    char_u\t**sp,\n    int\t\treplace_spaces,\t// TRUE to replace \" \" with \"<Space>\".\n\t\t\t\t// used for the lhs of mapping and keytrans().\n    int\t\treplace_lt)\t// TRUE to replace \"<\" with \"<lt>\".\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\n\t// Try to un-escape a multi-byte character.  Return the un-escaped\n\t// string if it is a multi-byte character.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n\n    c = *str;\n    if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t// special key\n\t    special = TRUE;\n    }\n\n    if (has_mbyte && !IS_SPECIAL(c) && MB_BYTE2LEN(c) > 1)\n    {\n\tchar_u\t*p;\n\n\t*sp = str;\n\t// Try to un-escape a multi-byte character after modifiers.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    // Since 'special' is TRUE the multi-byte character 'c' will be\n\t    // processed by get_special_key_name()\n\t    c = (*mb_ptr2char)(p);\n\telse\n\t    // illegal byte\n\t    *sp = str + 1;\n    }\n    else\n\t// single-byte character, NUL or illegal byte\n\t*sp = str + (*str == NUL ? 0 : 1);\n\n    // Make special keys and C0 control characters in <> form, also <M-Space>.\n    if (special\n\t|| c < ' '\n\t|| (replace_spaces && c == ' ')\n\t|| (replace_lt && c == '<'))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}\n\n/*\n * Translate a key sequence into special key names.\n */\n    void\nstr2specialbuf(char_u *sp, char_u *buf, int len)\n{\n    char_u\t*s;\n\n    *buf = NUL;\n    while (*sp)\n    {\n\ts = str2special(&sp, FALSE, FALSE);\n\tif ((int)(STRLEN(s) + STRLEN(buf)) < len)\n\t    STRCAT(buf, s);\n    }\n}\n\n/*\n * print line for :print or :list command\n */\n    void\nmsg_prt_line(char_u *s, int list)\n{\n    int\t\tc;\n    int\t\tcol = 0;\n    int\t\tn_extra = 0;\n    int\t\tc_extra = 0;\n    int\t\tc_final = 0;\n    char_u\t*p_extra = NULL;\t    // init to make SASC shut up\n    int\t\tn;\n    int\t\tattr = 0;\n    char_u\t*trail = NULL;\n    char_u\t*lead = NULL;\n    int\t\tin_multispace = FALSE;\n    int\t\tmultispace_pos = 0;\n    int\t\tl;\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (curwin->w_p_list)\n\tlist = TRUE;\n\n    if (list)\n    {\n\t// find start of trailing whitespace\n\tif (curwin->w_lcs_chars.trail)\n\t{\n\t    trail = s + STRLEN(s);\n\t    while (trail > s && VIM_ISWHITE(trail[-1]))\n\t\t--trail;\n\t}\n\t// find end of leading whitespace\n\tif (curwin->w_lcs_chars.lead\n\t\t\t\t || curwin->w_lcs_chars.leadmultispace != NULL)\n\t{\n\t    lead = s;\n\t    while (VIM_ISWHITE(lead[0]))\n\t\tlead++;\n\t    // in a line full of spaces all of them are treated as trailing\n\t    if (*lead == NUL)\n\t\tlead = NULL;\n\t}\n    }\n\n    // output a space for an empty line, otherwise the line will be\n    // overwritten\n    if (*s == NUL && !(list && curwin->w_lcs_chars.eol != NUL))\n\tmsg_putchar(' ');\n\n    while (!got_int)\n    {\n\tif (n_extra > 0)\n\t{\n\t    --n_extra;\n\t    if (n_extra == 0 && c_final)\n\t\tc = c_final;\n\t    else if (c_extra)\n\t\tc = c_extra;\n\t    else\n\t\tc = *p_extra++;\n\t}\n\telse if (has_mbyte && (l = (*mb_ptr2len)(s)) > 1)\n\t{\n\t    col += (*mb_ptr2cells)(s);\n\t    if (l >= MB_MAXBYTES)\n\t    {\n\t\tSTRCPY(buf, \"?\");\n\t    }\n\t    else if (curwin->w_lcs_chars.nbsp != NUL && list\n\t\t    && (mb_ptr2char(s) == 160\n\t\t\t|| mb_ptr2char(s) == 0x202f))\n\t    {\n\t\tint len = mb_char2bytes(curwin->w_lcs_chars.nbsp, buf);\n\n\t\tbuf[len] = NUL;\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(buf, s, (size_t)l);\n\t\tbuf[l] = NUL;\n\t    }\n\t    msg_puts((char *)buf);\n\t    s += l;\n\t    continue;\n\t}\n\telse\n\t{\n\t    attr = 0;\n\t    c = *s++;\n\t    in_multispace = c == ' '\n\t\t&& ((col > 0 && s[-2] == ' ') || *s == ' ');\n\t    if (!in_multispace)\n\t\tmultispace_pos = 0;\n\t    if (c == TAB && (!list || curwin->w_lcs_chars.tab1))\n\t    {\n\t\t// tab amount depends on current column\n#ifdef FEAT_VARTABS\n\t\tn_extra = tabstop_padding(col, curbuf->b_p_ts,\n\t\t\t\t\t\t    curbuf->b_p_vts_array) - 1;\n#else\n\t\tn_extra = curbuf->b_p_ts - col % curbuf->b_p_ts - 1;\n#endif\n\t\tif (!list)\n\t\t{\n\t\t    c = ' ';\n\t\t    c_extra = ' ';\n\t\t    c_final = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = (n_extra == 0 && curwin->w_lcs_chars.tab3)\n\t\t\t\t\t\t? curwin->w_lcs_chars.tab3\n\t\t\t\t\t\t: curwin->w_lcs_chars.tab1;\n\t\t    c_extra = curwin->w_lcs_chars.tab2;\n\t\t    c_final = curwin->w_lcs_chars.tab3;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t    else if (c == 160 && list && curwin->w_lcs_chars.nbsp != NUL)\n\t    {\n\t\tc = curwin->w_lcs_chars.nbsp;\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == NUL && list && curwin->w_lcs_chars.eol != NUL)\n\t    {\n\t\tp_extra = (char_u *)\"\";\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tn_extra = 1;\n\t\tc = curwin->w_lcs_chars.eol;\n\t\tattr = HL_ATTR(HLF_AT);\n\t\t--s;\n\t    }\n\t    else if (c != NUL && (n = byte2cells(c)) > 1)\n\t    {\n\t\tn_extra = n - 1;\n\t\tp_extra = transchar_byte(c);\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tc = *p_extra++;\n\t\t// Use special coloring to be able to distinguish <hex> from\n\t\t// the same in plain text.\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == ' ')\n\t    {\n\t\tif (list && lead != NULL && s <= lead && in_multispace\n\t\t\t&& curwin->w_lcs_chars.leadmultispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.leadmultispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.leadmultispace[multispace_pos]\n\t\t\t\t\t\t\t\t\t== NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (lead != NULL && s <= lead\n\t\t\t\t\t    && curwin->w_lcs_chars.lead != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.lead;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (trail != NULL && s > trail)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.trail;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && in_multispace\n\t\t\t&& curwin->w_lcs_chars.multispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.multispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.multispace[multispace_pos] == NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && curwin->w_lcs_chars.space != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.space;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t}\n\n\tif (c == NUL)\n\t    break;\n\n\tmsg_putchar_attr(c, attr);\n\tcol++;\n    }\n    msg_clr_eos();\n}\n\n/*\n * Use screen_puts() to output one multi-byte character.\n * Return the pointer \"s\" advanced to the next character.\n */\n    static char_u *\nscreen_puts_mbyte(char_u *s, int l, int attr)\n{\n    int\t\tcw;\n\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    cw = (*mb_ptr2cells)(s);\n    if (cw > 1 && (\n#ifdef FEAT_RIGHTLEFT\n\t\tcmdmsg_rl ? msg_col <= 1 :\n#endif\n\t\tmsg_col == Columns - 1))\n    {\n\t// Doesn't fit, print a highlighted '>' to fill it up.\n\tmsg_screen_putchar('>', HL_ATTR(HLF_AT));\n\treturn s;\n    }\n\n    screen_puts_len(s, l, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_col -= cw;\n\tif (msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tmsg_col += cw;\n\tif (msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n    return s + l;\n}\n\n/*\n * Output a string to the screen at position msg_row, msg_col.\n * Update msg_row and msg_col for the next message.\n */\n    void\nmsg_puts(char *s)\n{\n    msg_puts_attr(s, 0);\n}\n\n    void\nmsg_puts_title(char *s)\n{\n    msg_puts_attr(s, HL_ATTR(HLF_T));\n}\n\n/*\n * Show a message in such a way that it always fits in the line.  Cut out a\n * part in the middle and replace it with \"...\" when necessary.\n * Does not handle multi-byte characters!\n */\n    static void\nmsg_outtrans_long_len_attr(char_u *longstr, int len, int attr)\n{\n    int\t\tslen = len;\n    int\t\troom;\n\n    room = Columns - msg_col;\n    if (len > room && room >= 20)\n    {\n\tslen = (room - 3) / 2;\n\tmsg_outtrans_len_attr(longstr, slen, attr);\n\tmsg_puts_attr(\"...\", HL_ATTR(HLF_8));\n    }\n    msg_outtrans_len_attr(longstr + len - slen, slen, attr);\n}\n\n    void\nmsg_outtrans_long_attr(char_u *longstr, int attr)\n{\n    msg_outtrans_long_len_attr(longstr, (int)STRLEN(longstr), attr);\n}\n\n/*\n * Basic function for writing a message with highlight attributes.\n */\n    void\nmsg_puts_attr(char *s, int attr)\n{\n    msg_puts_attr_len(s, -1, attr);\n}\n\n/*\n * Like msg_puts_attr(), but with a maximum length \"maxlen\" (in bytes).\n * When \"maxlen\" is -1 there is no maximum length.\n * When \"maxlen\" is >= 0 the message is not put in the history.\n */\n    static void\nmsg_puts_attr_len(char *str, int maxlen, int attr)\n{\n    /*\n     * If redirection is on, also write to the redirection file.\n     */\n    redir_write((char_u *)str, maxlen);\n\n    /*\n     * Don't print anything when using \":silent cmd\".\n     */\n    if (msg_silent != 0)\n\treturn;\n\n    // if MSG_HIST flag set, add message to history\n    if ((attr & MSG_HIST) && maxlen < 0)\n    {\n\tadd_msg_hist((char_u *)str, -1, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // When writing something to the screen after it has scrolled, requires a\n    // wait-return prompt later.  Needed when scrolling, resetting\n    // need_wait_return after some prompt, and then outputting something\n    // without scrolling\n    // Not needed when only using CR to move the cursor.\n    if (msg_scrolled != 0 && !msg_scrolled_ign && STRCMP(str, \"\\r\") != 0)\n\tneed_wait_return = TRUE;\n    msg_didany = TRUE;\t\t// remember that something was outputted\n\n    /*\n     * If there is no valid screen, use fprintf so we can see error messages.\n     * If termcap is not active, we may be writing in an alternate console\n     * window, cursor positioning may not work correctly (window size may be\n     * different, e.g. for Win32 console) or we just don't know where the\n     * cursor is.\n     */\n    if (msg_use_printf())\n\tmsg_puts_printf((char_u *)str, maxlen);\n    else\n\tmsg_puts_display((char_u *)str, maxlen, attr, FALSE);\n\n    need_fileinfo = FALSE;\n}\n\n// values for \"where\"\n#define PUT_APPEND 0\t\t// append to \"lnum\"\n#define PUT_TRUNC 1\t\t// replace \"lnum\"\n#define PUT_BELOW 2\t\t// add below \"lnum\"\n\t\t\t\t//\n#ifdef HAS_MESSAGE_WINDOW\n/*\n * Put text \"t_s\" until \"end\" in the message window.\n * \"where\" specifies where to put the text.\n */\n    static void\nput_msg_win(win_T *wp, int where, char_u *t_s, char_u *end, linenr_T lnum)\n{\n    char_u  *p;\n\n    if (where == PUT_BELOW)\n    {\n\tif (*end != NUL)\n\t{\n\t    p = vim_strnsave(t_s, end - t_s);\n\t    if (p == NULL)\n\t\treturn;\n\t}\n\telse\n\t    p = t_s;\n\tml_append_buf(wp->w_buffer, lnum, p, (colnr_T)0, FALSE);\n\tif (p != t_s)\n\t    vim_free(p);\n    }\n    else\n    {\n\tchar_u *newp;\n\n\tcurbuf = wp->w_buffer;\n\tif (where == PUT_APPEND)\n\t{\n\t    newp = concat_str(ml_get(lnum), t_s);\n\t    if (newp == NULL)\n\t\treturn;\n\t    if (*end != NUL)\n\t\tnewp[STRLEN(ml_get(lnum)) + (end - t_s)] = NUL;\n\t}\n\telse\n\t{\n\t    newp = vim_strnsave(t_s, end - t_s);\n\t    if (newp == NULL)\n\t\treturn;\n\t}\n\tml_replace(lnum, newp, FALSE);\n\tcurbuf = curwin->w_buffer;\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n\n    // set msg_col so that a newline is written if needed\n    msg_col += (int)(end - t_s);\n}\n#endif\n\n/*\n * The display part of msg_puts_attr_len().\n * May be called recursively to display scroll-back text.\n */\n    static void\nmsg_puts_display(\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tattr,\n    int\t\trecurse)\n{\n    char_u\t*s = str;\n    char_u\t*t_s = str;\t// string from \"t_s\" to \"s\" is still todo\n    int\t\tt_col = 0;\t// screen cells todo, 0 when \"t_s\" not used\n    int\t\tl;\n    int\t\tcw;\n    char_u\t*sb_str = str;\n    int\t\tsb_col = msg_col;\n    int\t\twrap;\n    int\t\tdid_last_char;\n#ifdef HAS_MESSAGE_WINDOW\n    int\t\twhere = PUT_APPEND;\n    win_T\t*msg_win = NULL;\n    linenr_T    lnum = 1;\n\n    if (in_echowindow)\n    {\n\tmsg_win = popup_get_message_win();\n\n\tif (msg_win != NULL)\n\t{\n\t    if (!popup_message_win_visible())\n\t    {\n\t\tif (*str == NL)\n\t\t{\n\t\t    // When not showing the message window and the output\n\t\t    // starts with a NL show the message normally.\n\t\t    msg_win = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // currently hidden, make it empty\n\t\t    curbuf = msg_win->w_buffer;\n\t\t    while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t\t\tml_delete(1);\n\t\t    curbuf = curwin->w_buffer;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tlnum = msg_win->w_buffer->b_ml.ml_line_count;\n\t\tif (msg_col == 0)\n\t\t    where = PUT_TRUNC;\n\t    }\n\t}\n    }\n#endif\n\n    did_wait_return = FALSE;\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\t/*\n\t * We are at the end of the screen line when:\n\t * - When outputting a newline.\n\t * - When outputting a character in the last column.\n\t */\n\tif (!recurse && msg_row >= Rows - 1 && (*s == '\\n' || (\n#ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl\n\t\t    ? (\n\t\t\tmsg_col <= 1\n\t\t      || (*s == TAB && msg_col <= 7)\n\t\t      || (has_mbyte && (*mb_ptr2cells)(s) > 1 && msg_col <= 2))\n\t\t    :\n#endif\n\t\t      ((*s != '\\r' && msg_col + t_col >= Columns - 1)\n\t\t       || (*s == TAB && msg_col + t_col >= ((Columns - 1) & ~7))\n\t\t       || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t && msg_col + t_col >= Columns - 2)))))\n\t{\n\t    /*\n\t     * The screen is scrolled up when at the last row (some terminals\n\t     * scroll automatically, some don't.  To avoid problems we scroll\n\t     * ourselves).\n\t     */\n\t    if (t_col > 0)\n\t    {\n\t\t// output postponed text\n#ifdef HAS_MESSAGE_WINDOW\n\t\tif (msg_win != NULL)\n\t\t{\n\t\t    put_msg_win(msg_win, where, t_s, s, lnum);\n\t\t    t_col = 0;\n\t\t    where = PUT_BELOW;\n\t\t}\n\t\telse\n#endif\n\t\t    t_puts(&t_col, t_s, s, attr);\n\t    }\n\n\t    // When no more prompt and no more room, truncate here\n\t    if (msg_no_more && lines_left == 0)\n\t\tbreak;\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win == NULL)\n#endif\n\t\t// Scroll the screen up one line.\n\t\tmsg_scroll_up();\n\n\t    msg_row = Rows - 2;\n\t    if (msg_col >= Columns)\t// can happen after screen resize\n\t\tmsg_col = Columns - 1;\n\n\t    // Display char in last column before showing more-prompt.\n\t    if (*s >= ' '\n#ifdef FEAT_RIGHTLEFT\n\t\t    && !cmdmsg_rl\n#endif\n\t       )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    if (enc_utf8 && maxlen >= 0)\n\t\t\t// avoid including composing chars after the end\n\t\t\tl = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\t    else\n\t\t\tl = (*mb_ptr2len)(s);\n\t\t    s = screen_puts_mbyte(s, l, attr);\n\t\t}\n\t\telse\n\t\t    msg_screen_putchar(*s++, attr);\n\t\tdid_last_char = TRUE;\n\t    }\n\t    else\n\t\tdid_last_char = FALSE;\n\n\t    if (p_more)\n\t\t// store text for scrolling back\n\t\tstore_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win == NULL)\n\t    {\n#endif\n\t\tinc_msg_scrolled();\n\t\tneed_wait_return = TRUE; // may need wait_return() in main()\n\t\tredraw_cmdline = TRUE;\n\t\tif (cmdline_row > 0 && !exmode_active)\n\t\t    --cmdline_row;\n\n\t\t/*\n\t\t * If screen is completely filled and 'more' is set then wait\n\t\t * for a character.\n\t\t */\n\t\tif (lines_left > 0)\n\t\t    --lines_left;\n#ifdef HAS_MESSAGE_WINDOW\n\t    }\n#endif\n\t    if (p_more && lines_left == 0 && State != MODE_HITRETURN\n\t\t\t\t\t    && !msg_no_more && !exmode_active)\n\t    {\n#ifdef FEAT_CON_DIALOG\n\t\tif (do_more_prompt(NUL))\n\t\t    s = confirm_msg_tail;\n#else\n\t\t(void)do_more_prompt(NUL);\n#endif\n\t\tif (quit_more)\n\t\t    return;\n\t    }\n\n\t    // When we displayed a char in last column need to check if there\n\t    // is still more.\n\t    if (did_last_char)\n\t\tcontinue;\n\t}\n\n\twrap = *s == '\\n'\n\t\t    || msg_col + t_col >= Columns\n\t\t    || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t    && msg_col + t_col >= Columns - 1);\n\tif (t_col > 0 && (wrap || *s == '\\r' || *s == '\\b'\n\t\t\t\t\t\t || *s == '\\t' || *s == BELL))\n\t{\n\t    // output any postponed text\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t    {\n\t\tput_msg_win(msg_win, where, t_s, s, lnum);\n\t\tt_col = 0;\n\t\twhere = PUT_BELOW;\n\t    }\n\t    else\n#endif\n\t\tt_puts(&t_col, t_s, s, attr);\n\t}\n\n\tif (wrap && p_more && !recurse)\n\t    // store text for scrolling back\n\t    store_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n\tif (*s == '\\n')\t\t    // go to next line\n\t{\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t    {\n\t\t// Ignore a NL when the buffer is empty, it is used to scroll\n\t\t// up the text.\n\t\tif ((msg_win->w_buffer->b_ml.ml_flags & ML_EMPTY) == 0)\n\t\t{\n\t\t    put_msg_win(msg_win, PUT_BELOW, t_s, t_s, lnum);\n\t\t    ++lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tmsg_didout = FALSE;\t    // remember that line is empty\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns - 1;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    if (++msg_row >= Rows)  // safety check\n\t\tmsg_row = Rows - 1;\n\t}\n\telse if (*s == '\\r')\t    // go to column 0\n\t{\n\t    msg_col = 0;\n#ifdef HAS_MESSAGE_WINDOW\n\t    where = PUT_TRUNC;\n#endif\n\t}\n\telse if (*s == '\\b')\t    // go to previous char\n\t{\n\t    if (msg_col)\n\t\t--msg_col;\n\t}\n\telse if (*s == TAB)\t    // translate Tab into spaces\n\t{\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t\tmsg_col = (msg_col + 7) % 8;\n\t    else\n#endif\n\t\tdo\n\t\t    msg_screen_putchar(' ', attr);\n\t\twhile (msg_col & 7);\n\t}\n\telse if (*s == BELL)\t\t// beep (from \":sh\")\n\t    vim_beep(BO_SH);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcw = (*mb_ptr2cells)(s);\n\t\tif (enc_utf8 && maxlen >= 0)\n\t\t    // avoid including composing chars after the end\n\t\t    l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\telse\n\t\t    l = (*mb_ptr2len)(s);\n\t    }\n\t    else\n\t    {\n\t\tcw = 1;\n\t\tl = 1;\n\t    }\n\n\t    // When drawing from right to left or when a double-wide character\n\t    // doesn't fit, draw a single character here.  Otherwise collect\n\t    // characters and draw them all at once later.\n\t    if (\n# ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl ||\n# endif\n\t\t    (cw > 1 && msg_col + t_col >= Columns - 1))\n\t    {\n\t\tif (l > 1)\n\t\t    s = screen_puts_mbyte(s, l, attr) - 1;\n\t\telse\n\t\t    msg_screen_putchar(*s, attr);\n\t    }\n\t    else\n\t    {\n\t\t// postpone this character until later\n\t\tif (t_col == 0)\n\t\t    t_s = s;\n\t\tt_col += cw;\n\t\ts += l - 1;\n\t    }\n\t}\n\t++s;\n    }\n\n    // output any postponed text\n    if (t_col > 0)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (msg_win != NULL)\n\t    put_msg_win(msg_win, where, t_s, s, lnum);\n\telse\n#endif\n\t    t_puts(&t_col, t_s, s, attr);\n    }\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (msg_win != NULL)\n\tpopup_show_message_win();\n#endif\n    // Store the text for scroll back, unless it's a newline by itself.\n    if (p_more && !recurse && !(s == sb_str + 1 && *sb_str == '\\n'))\n\tstore_sb_text(&sb_str, s, attr, &sb_col, FALSE);\n\n    msg_check();\n}\n\n/*\n * Return TRUE when \":filter pattern\" was used and \"msg\" does not match\n * \"pattern\".\n */\n    int\nmessage_filtered(char_u *msg)\n{\n    int match;\n\n    if (cmdmod.cmod_filter_regmatch.regprog == NULL)\n\treturn FALSE;\n    match = vim_regexec(&cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);\n    return cmdmod.cmod_filter_force ? match : !match;\n}\n\n/*\n * Scroll the screen up one line for displaying the next message line.\n */\n    static void\nmsg_scroll_up(void)\n{\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;\n#endif\n#ifdef FEAT_GUI\n    // Remove the cursor before scrolling, ScreenLines[] is going\n    // to become invalid.\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n    // scrolling up always works\n    mch_disable_flush();\n    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);\n    mch_enable_flush();\n\n    if (!can_clear((char_u *)\" \"))\n    {\n\t// Scrolling up doesn't result in the right background.  Set the\n\t// background here.  It's not efficient, but avoids that we have to do\n\t// it all over the code.\n\tscreen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\n\t// Also clear the last char of the last but one line if it was not\n\t// cleared before to avoid a scroll-up.\n\tif (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)\n\t    screen_fill((int)Rows - 2, (int)Rows - 1,\n\t\t\t\t (int)Columns - 1, (int)Columns, ' ', ' ', 0);\n    }\n}\n\n/*\n * Increment \"msg_scrolled\".\n */\n    static void\ninc_msg_scrolled(void)\n{\n#ifdef FEAT_EVAL\n    if (*get_vim_var_str(VV_SCROLLSTART) == NUL)\n    {\n\tchar_u\t    *p = SOURCING_NAME;\n\tchar_u\t    *tofree = NULL;\n\tint\t    len;\n\n\t// v:scrollstart is empty, set it to the script/function name and line\n\t// number\n\tif (p == NULL)\n\t    p = (char_u *)_(\"Unknown\");\n\telse\n\t{\n\t    len = (int)STRLEN(p) + 40;\n\t    tofree = alloc(len);\n\t    if (tofree != NULL)\n\t    {\n\t\tvim_snprintf((char *)tofree, len, _(\"%s line %ld\"),\n\t\t\t\t\t\t      p, (long)SOURCING_LNUM);\n\t\tp = tofree;\n\t    }\n\t}\n\tset_vim_var_string(VV_SCROLLSTART, p, -1);\n\tvim_free(tofree);\n    }\n#endif\n    ++msg_scrolled;\n    set_must_redraw(UPD_VALID);\n}\n\n/*\n * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to\n * store the displayed text and remember where screen lines start.\n */\ntypedef struct msgchunk_S msgchunk_T;\nstruct msgchunk_S\n{\n    msgchunk_T\t*sb_next;\n    msgchunk_T\t*sb_prev;\n    char\tsb_eol;\t\t// TRUE when line ends after this text\n    int\t\tsb_msg_col;\t// column in which text starts\n    int\t\tsb_attr;\t// text attributes\n    char_u\tsb_text[1];\t// text to be displayed, actually longer\n};\n\nstatic msgchunk_T *last_msgchunk = NULL; // last displayed text\n\nstatic msgchunk_T *msg_sb_start(msgchunk_T *mps);\n\ntypedef enum {\n    SB_CLEAR_NONE = 0,\n    SB_CLEAR_ALL,\n    SB_CLEAR_CMDLINE_BUSY,\n    SB_CLEAR_CMDLINE_DONE\n} sb_clear_T;\n\n// When to clear text on next msg.\nstatic sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;\n\n/*\n * Store part of a printed message for displaying when scrolling back.\n */\n    static void\nstore_sb_text(\n    char_u\t**sb_str,\t// start of string\n    char_u\t*s,\t\t// just after string\n    int\t\tattr,\n    int\t\t*sb_col,\n    int\t\tfinish)\t\t// line ends\n{\n    msgchunk_T\t*mp;\n\n    if (do_clear_sb_text == SB_CLEAR_ALL\n\t    || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE)\n    {\n\tclear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);\n\tmsg_sb_eol();  // prevent messages from overlapping\n\tdo_clear_sb_text = SB_CLEAR_NONE;\n    }\n\n    if (s > *sb_str)\n    {\n\tmp = alloc(sizeof(msgchunk_T) + (s - *sb_str));\n\tif (mp != NULL)\n\t{\n\t    mp->sb_eol = finish;\n\t    mp->sb_msg_col = *sb_col;\n\t    mp->sb_attr = attr;\n\t    vim_strncpy(mp->sb_text, *sb_str, s - *sb_str);\n\n\t    if (last_msgchunk == NULL)\n\t    {\n\t\tlast_msgchunk = mp;\n\t\tmp->sb_prev = NULL;\n\t    }\n\t    else\n\t    {\n\t\tmp->sb_prev = last_msgchunk;\n\t\tlast_msgchunk->sb_next = mp;\n\t\tlast_msgchunk = mp;\n\t    }\n\t    mp->sb_next = NULL;\n\t}\n    }\n    else if (finish && last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n\n    *sb_str = s;\n    *sb_col = 0;\n}\n\n/*\n * Finished showing messages, clear the scroll-back text on the next message.\n */\n    void\nmay_clear_sb_text(void)\n{\n    do_clear_sb_text = SB_CLEAR_ALL;\n}\n\n/*\n * Starting to edit the command line: do not clear messages now.\n */\n    void\nsb_text_start_cmdline(void)\n{\n    if (do_clear_sb_text == SB_CLEAR_CMDLINE_BUSY)\n\t// Invoking command line recursively: the previous-level command line\n\t// doesn't need to be remembered as it will be redrawn when returning\n\t// to that level.\n\tsb_text_restart_cmdline();\n    else\n    {\n\tmsg_sb_eol();\n\tdo_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n    }\n}\n\n/*\n * Redrawing the command line: clear the last unfinished line.\n */\n    void\nsb_text_restart_cmdline(void)\n{\n    msgchunk_T *tofree;\n\n    // Needed when returning from nested command line.\n    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n\n    if (last_msgchunk == NULL || last_msgchunk->sb_eol)\n\t// No unfinished line: don't clear anything.\n\treturn;\n\n    tofree = msg_sb_start(last_msgchunk);\n    last_msgchunk = tofree->sb_prev;\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_next = NULL;\n    while (tofree != NULL)\n    {\n\tmsgchunk_T *tofree_next = tofree->sb_next;\n\n\tvim_free(tofree);\n\ttofree = tofree_next;\n    }\n}\n\n/*\n * Ending to edit the command line: clear old lines but the last one later.\n */\n    void\nsb_text_end_cmdline(void)\n{\n    do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;\n}\n\n/*\n * Clear any text remembered for scrolling back.\n * When \"all\" is FALSE keep the last line.\n * Called when redrawing the screen.\n */\n    void\nclear_sb_text(int all)\n{\n    msgchunk_T\t*mp;\n    msgchunk_T\t**lastp;\n\n    if (all)\n\tlastp = &last_msgchunk;\n    else\n    {\n\tif (last_msgchunk == NULL)\n\t    return;\n\tlastp = &msg_sb_start(last_msgchunk)->sb_prev;\n    }\n\n    while (*lastp != NULL)\n    {\n\tmp = (*lastp)->sb_prev;\n\tvim_free(*lastp);\n\t*lastp = mp;\n    }\n}\n\n/*\n * \"g<\" command.\n */\n    void\nshow_sb_text(void)\n{\n    msgchunk_T\t*mp;\n\n    // Only show something if there is more than one line, otherwise it looks\n    // weird, typing a command without output results in one line.\n    mp = msg_sb_start(last_msgchunk);\n    if (mp == NULL || mp->sb_prev == NULL)\n\tvim_beep(BO_MESS);\n    else\n    {\n\tdo_more_prompt('G');\n\twait_return(FALSE);\n    }\n}\n\n/*\n * Move to the start of screen line in already displayed text.\n */\n    static msgchunk_T *\nmsg_sb_start(msgchunk_T *mps)\n{\n    msgchunk_T *mp = mps;\n\n    while (mp != NULL && mp->sb_prev != NULL && !mp->sb_prev->sb_eol)\n\tmp = mp->sb_prev;\n    return mp;\n}\n\n/*\n * Mark the last message chunk as finishing the line.\n */\n    void\nmsg_sb_eol(void)\n{\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n}\n\n/*\n * Display a screen line from previously displayed text at row \"row\".\n * When \"clear_to_eol\" is set clear the rest of the screen line.\n * Returns a pointer to the text for the next line (can be NULL).\n */\n    static msgchunk_T *\ndisp_sb_line(int row, msgchunk_T *smp, int clear_to_eol)\n{\n    msgchunk_T\t*mp = smp;\n    char_u\t*p;\n\n    for (;;)\n    {\n\tmsg_row = row;\n\tmsg_col = mp->sb_msg_col;\n\tp = mp->sb_text;\n\tif (*p == '\\n')\t    // don't display the line break\n\t    ++p;\n\tmsg_puts_display(p, -1, mp->sb_attr, TRUE);\n\n\t// If clearing the screen did not work (e.g. because of a background\n\t// color and t_ut isn't set) clear until the last column here.\n\tif (clear_to_eol)\n\t    screen_fill(row, row + 1, msg_col, (int)Columns, ' ', ' ', 0);\n\n\tif (mp->sb_eol || mp->sb_next == NULL)\n\t    break;\n\tmp = mp->sb_next;\n    }\n    return mp->sb_next;\n}\n\n/*\n * Output any postponed text for msg_puts_attr_len().\n */\n    static void\nt_puts(\n    int\t\t*t_col,\n    char_u\t*t_s,\n    char_u\t*s,\n    int\t\tattr)\n{\n    // output postponed text\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);\n    msg_col += *t_col;\n    *t_col = 0;\n    // If the string starts with a composing character don't increment the\n    // column position for it.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(t_s)))\n\t--msg_col;\n    if (msg_col >= Columns)\n    {\n\tmsg_col = 0;\n\t++msg_row;\n    }\n}\n\n/*\n * Returns TRUE when messages should be printed with mch_errmsg().\n * This is used when there is no valid screen, so we can see error messages.\n * If termcap is not active, we may be writing in an alternate console\n * window, cursor positioning may not work correctly (window size may be\n * different, e.g. for Win32 console) or we just don't know where the\n * cursor is.\n */\n    int\nmsg_use_printf(void)\n{\n    return (!msg_check_screen()\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\t    || (!gui.in_use && !termcap_active)\n# else\n\t    || !termcap_active\n# endif\n#endif\n\t    || (swapping_screen() && !termcap_active)\n\t       );\n}\n\n/*\n * Print a message when there is no valid screen.\n */\n    static void\nmsg_puts_printf(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    char_u\t*buf = NULL;\n    char_u\t*p = s;\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_COOK);\t// handle CR and NL correctly\n#endif\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\tif (!(silent_mode && p_verbose == 0))\n\t{\n\t    // NL --> CR NL translation (for Unix, not for \"--version\")\n\t    if (*s == NL)\n\t    {\n\t\tint n = (int)(s - p);\n\n\t\tbuf = alloc(n + 3);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    memcpy(buf, p, n);\n\t\t    if (!info_message)\n\t\t\tbuf[n++] = CAR;\n\t\t    buf[n++] = NL;\n\t\t    buf[n++] = NUL;\n\t\t    if (info_message)   // informative message, not an error\n\t\t\tmch_msg((char *)buf);\n\t\t    else\n\t\t\tmch_errmsg((char *)buf);\n\t\t    vim_free(buf);\n\t\t}\n\t\tp = s + 1;\n\t    }\n\t}\n\n\t// primitive way to compute the current column\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = Columns - 1;\n\t    else\n\t\t--msg_col;\n\t}\n\telse\n#endif\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = 0;\n\t    else\n\t\t++msg_col;\n\t}\n\t++s;\n    }\n\n    if (*p != NUL && !(silent_mode && p_verbose == 0))\n    {\n\tchar_u *tofree = NULL;\n\n\tif (maxlen > 0 && STRLEN(p) > (size_t)maxlen)\n\t{\n\t    tofree = vim_strnsave(p, (size_t)maxlen);\n\t    p = tofree;\n\t}\n\tif (p != NULL)\n\t{\n\t    if (info_message)\n\t\tmch_msg((char *)p);\n\t    else\n\t\tmch_errmsg((char *)p);\n\t    vim_free(tofree);\n\t}\n    }\n\n    msg_didout = TRUE;\t    // assume that line is not empty\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_RAW);\n#endif\n}\n\n/*\n * Show the more-prompt and handle the user response.\n * This takes care of scrolling back and displaying previously displayed text.\n * When at hit-enter prompt \"typed_char\" is the already typed character,\n * otherwise it's NUL.\n * Returns TRUE when jumping ahead to \"confirm_msg_tail\".\n */\n    static int\ndo_more_prompt(int typed_char)\n{\n    static int\tentered = FALSE;\n    int\t\tused_typed_char = typed_char;\n    int\t\toldState = State;\n    int\t\tc;\n#ifdef FEAT_CON_DIALOG\n    int\t\tretval = FALSE;\n#endif\n    int\t\ttoscroll;\n    msgchunk_T\t*mp_last = NULL;\n    msgchunk_T\t*mp;\n    int\t\ti;\n\n    // We get called recursively when a timer callback outputs a message. In\n    // that case don't show another prompt. Also when at the hit-Enter prompt\n    // and nothing was typed.\n    if (entered || (State == MODE_HITRETURN && typed_char == 0))\n\treturn FALSE;\n    entered = TRUE;\n\n    if (typed_char == 'G')\n    {\n\t// \"g<\": Find first line on the last page.\n\tmp_last = msg_sb_start(last_msgchunk);\n\tfor (i = 0; i < Rows - 2 && mp_last != NULL\n\t\t\t\t\t     && mp_last->sb_prev != NULL; ++i)\n\t    mp_last = msg_sb_start(mp_last->sb_prev);\n    }\n\n    State = MODE_ASKMORE;\n    setmouse();\n    if (typed_char == NUL)\n\tmsg_moremsg(FALSE);\n    for (;;)\n    {\n\t/*\n\t * Get a typed character directly from the user.\n\t */\n\tif (used_typed_char != NUL)\n\t{\n\t    c = used_typed_char;\t// was typed at hit-enter prompt\n\t    used_typed_char = NUL;\n\t}\n\telse\n\t    c = get_keystroke();\n\n#if defined(FEAT_MENU) && defined(FEAT_GUI)\n\tif (c == K_MENU)\n\t{\n\t    int idx = get_menu_index(current_menu, MODE_ASKMORE);\n\n\t    // Used a menu.  If it starts with CTRL-Y, it must\n\t    // be a \"Copy\" for the clipboard.  Otherwise\n\t    // assume that we end\n\t    if (idx == MENU_INDEX_INVALID)\n\t\tcontinue;\n\t    c = *current_menu->strings[idx];\n\t    if (c != NUL && current_menu->strings[idx][1] != NUL)\n\t\tins_typebuf(current_menu->strings[idx] + 1,\n\t\t\t\tcurrent_menu->noremap[idx], 0, TRUE,\n\t\t\t\t\t\t   current_menu->silent[idx]);\n\t}\n#endif\n\n\ttoscroll = 0;\n\tswitch (c)\n\t{\n\tcase BS:\t\t// scroll one line back\n\tcase K_BS:\n\tcase 'k':\n\tcase K_UP:\n\t    toscroll = -1;\n\t    break;\n\n\tcase CAR:\t\t// one extra line\n\tcase NL:\n\tcase 'j':\n\tcase K_DOWN:\n\t    toscroll = 1;\n\t    break;\n\n\tcase 'u':\t\t// Up half a page\n\t    toscroll = -(Rows / 2);\n\t    break;\n\n\tcase 'd':\t\t// Down half a page\n\t    toscroll = Rows / 2;\n\t    break;\n\n\tcase 'b':\t\t// one page back\n\tcase K_PAGEUP:\n\t    toscroll = -(Rows - 1);\n\t    break;\n\n\tcase ' ':\t\t// one extra page\n\tcase 'f':\n\tcase K_PAGEDOWN:\n\tcase K_LEFTMOUSE:\n\t    toscroll = Rows - 1;\n\t    break;\n\n\tcase 'g':\t\t// all the way back to the start\n\t    toscroll = -999999;\n\t    break;\n\n\tcase 'G':\t\t// all the way to the end\n\t    toscroll = 999999;\n\t    lines_left = 999999;\n\t    break;\n\n\tcase ':':\t\t// start new command line\n#ifdef FEAT_CON_DIALOG\n\t    if (!confirm_msg_used)\n#endif\n\t    {\n\t\t// Since got_int is set all typeahead will be flushed, but we\n\t\t// want to keep this ':', remember that in a special way.\n\t\ttypeahead_noflush(':');\n#ifdef FEAT_TERMINAL\n\t\tskip_term_loop = TRUE;\n#endif\n\t\tcmdline_row = Rows - 1;\t\t// put ':' on this line\n\t\tskip_redraw = TRUE;\t\t// skip redraw once\n\t\tneed_wait_return = FALSE;\t// don't wait in main()\n\t    }\n\t    // FALLTHROUGH\n\tcase 'q':\t\t// quit\n\tcase Ctrl_C:\n\tcase ESC:\n#ifdef FEAT_CON_DIALOG\n\t    if (confirm_msg_used)\n\t    {\n\t\t// Jump to the choices of the dialog.\n\t\tretval = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tgot_int = TRUE;\n\t\tquit_more = TRUE;\n\t    }\n\t    // When there is some more output (wrapping line) display that\n\t    // without another prompt.\n\t    lines_left = Rows - 1;\n\t    break;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t    // Strange way to allow copying (yanking) a modeless\n\t    // selection at the more prompt.  Use CTRL-Y,\n\t    // because the same is used in Cmdline-mode and at the\n\t    // hit-enter prompt.  However, scrolling one line up\n\t    // might be expected...\n\t    if (clip_star.state == SELECT_DONE)\n\t\tclip_copy_modeless_selection(TRUE);\n\t    continue;\n#endif\n\tdefault:\t\t// no valid response\n\t    msg_moremsg(TRUE);\n\t    continue;\n\t}\n\n\tif (toscroll != 0)\n\t{\n\t    if (toscroll < 0)\n\t    {\n\t\t// go to start of last line\n\t\tif (mp_last == NULL)\n\t\t    mp = msg_sb_start(last_msgchunk);\n\t\telse if (mp_last->sb_prev != NULL)\n\t\t    mp = msg_sb_start(mp_last->sb_prev);\n\t\telse\n\t\t    mp = NULL;\n\n\t\t// go to start of line at top of the screen\n\t\tfor (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;\n\t\t\t\t\t\t\t\t\t  ++i)\n\t\t    mp = msg_sb_start(mp->sb_prev);\n\n\t\tif (mp != NULL && mp->sb_prev != NULL)\n\t\t{\n\t\t    // Find line to be displayed at top.\n\t\t    for (i = 0; i > toscroll; --i)\n\t\t    {\n\t\t\tif (mp == NULL || mp->sb_prev == NULL)\n\t\t\t    break;\n\t\t\tmp = msg_sb_start(mp->sb_prev);\n\t\t\tif (mp_last == NULL)\n\t\t\t    mp_last = msg_sb_start(last_msgchunk);\n\t\t\telse\n\t\t\t    mp_last = msg_sb_start(mp_last->sb_prev);\n\t\t    }\n\n\t\t    if (toscroll == -1 && screen_ins_lines(0, 0, 1,\n\t\t\t\t\t\t     (int)Rows, 0, NULL) == OK)\n\t\t    {\n\t\t\t// display line at top\n\t\t\t(void)disp_sb_line(0, mp, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tint did_clear = screenclear();\n\n\t\t\t// redisplay all lines\n\t\t\tfor (i = 0; mp != NULL && i < Rows - 1; ++i)\n\t\t\t{\n\t\t\t    mp = disp_sb_line(i, mp, !did_clear);\n\t\t\t    ++msg_scrolled;\n\t\t\t}\n\t\t    }\n\t\t    toscroll = 0;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// First display any text that we scrolled back.\n\t\twhile (toscroll > 0 && mp_last != NULL)\n\t\t{\n\t\t    // scroll up, display line at bottom\n\t\t    msg_scroll_up();\n\t\t    inc_msg_scrolled();\n\t\t    screen_fill((int)Rows - 2, (int)Rows - 1, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\t    mp_last = disp_sb_line((int)Rows - 2, mp_last, FALSE);\n\t\t    --toscroll;\n\t\t}\n\t    }\n\n\t    if (toscroll <= 0)\n\t    {\n\t\t// displayed the requested text, more prompt again\n\t\tscreen_fill((int)Rows - 1, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\tmsg_moremsg(FALSE);\n\t\tcontinue;\n\t    }\n\n\t    // display more text, return to caller\n\t    lines_left = toscroll;\n\t}\n\n\tbreak;\n    }\n\n    // clear the --more-- message\n    screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n    State = oldState;\n    setmouse();\n    if (quit_more)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n#ifdef FEAT_RIGHTLEFT\n    else if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n#endif\n\n    entered = FALSE;\n#ifdef FEAT_CON_DIALOG\n    return retval;\n#else\n    return FALSE;\n#endif\n}\n\n#if defined(USE_MCH_ERRMSG) || defined(PROTO)\n\n#ifdef mch_errmsg\n# undef mch_errmsg\n#endif\n#ifdef mch_msg\n# undef mch_msg\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_errmsg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode = 0;\n    HANDLE  h = GetStdHandle(STD_ERROR_HANDLE);\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tfprintf(stderr, \"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give an error message.  To be used when the screen hasn't been initialized\n * yet.  When stderr can't be used, collect error messages until the GUI has\n * started and they can be displayed in a message box.\n */\n    void\nmch_errmsg(char *str)\n{\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    int\t\tlen;\n#endif\n\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stderr if it's a tty.\n    // When not going to start the GUI also use stderr.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tfprintf(stderr, \"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_errmsg_c(str);\n\treturn;\n    }\n#endif\n\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    // avoid a delay for a message that isn't there\n    emsg_on_display = FALSE;\n\n    len = (int)STRLEN(str) + 1;\n    if (error_ga.ga_growsize == 0)\n    {\n\terror_ga.ga_growsize = 80;\n\terror_ga.ga_itemsize = 1;\n    }\n    if (ga_grow(&error_ga, len) == OK)\n    {\n\tmch_memmove((char_u *)error_ga.ga_data + error_ga.ga_len,\n\t\t\t\t\t\t\t  (char_u *)str, len);\n# ifdef UNIX\n\t// remove CR characters, they are displayed\n\t{\n\t    char_u\t*p;\n\n\t    p = (char_u *)error_ga.ga_data + error_ga.ga_len;\n\t    for (;;)\n\t    {\n\t\tp = vim_strchr(p, '\\r');\n\t\tif (p == NULL)\n\t\t    break;\n\t\t*p = ' ';\n\t    }\n\t}\n# endif\n\t--len;\t\t// don't count the NUL at the end\n\terror_ga.ga_len += len;\n    }\n#endif\n}\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_msg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode;\n    HANDLE  h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tprintf(\"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give a message.  To be used when the screen hasn't been initialized yet.\n * When there is no tty, collect messages until the GUI has started and they\n * can be displayed in a message box.\n */\n    void\nmch_msg(char *str)\n{\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stdout if we have a tty.  This allows \"vim -h | more\" and\n    // uses mch_errmsg() when started from the desktop.\n    // When not going to start the GUI also use stdout.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tprintf(\"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_msg_c(str);\n\treturn;\n    }\n#endif\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    mch_errmsg(str);\n#endif\n}\n#endif // USE_MCH_ERRMSG\n\n/*\n * Put a character on the screen at the current message position and advance\n * to the next position.  Only for printable ASCII!\n */\n    static void\nmsg_screen_putchar(int c, int attr)\n{\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_putchar(c, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tif (--msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tif (++msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n}\n\n    static void\nmsg_moremsg(int full)\n{\n    int\t\tattr;\n    char_u\t*s = (char_u *)_(\"-- More --\");\n\n    attr = HL_ATTR(HLF_M);\n    screen_puts(s, (int)Rows - 1, 0, attr);\n    if (full)\n\tscreen_puts((char_u *)\n\t\t_(\" SPACE/d/j: screen/page/line down, b/u/k: up, q: quit \"),\n\t\t(int)Rows - 1, vim_strsize(s), attr);\n}\n\n/*\n * Repeat the message for the current mode: MODE_ASKMORE, MODE_EXTERNCMD,\n * MODE_CONFIRM or exmode_active.\n */\n    void\nrepeat_message(void)\n{\n    if (State == MODE_ASKMORE)\n    {\n\tmsg_moremsg(TRUE);\t// display --more-- message again\n\tmsg_row = Rows - 1;\n    }\n#ifdef FEAT_CON_DIALOG\n    else if (State == MODE_CONFIRM)\n    {\n\tdisplay_confirm_msg();\t// display \":confirm\" message again\n\tmsg_row = Rows - 1;\n    }\n#endif\n    else if (State == MODE_EXTERNCMD)\n    {\n\twindgoto(msg_row, msg_col); // put cursor back\n    }\n    else if (State == MODE_HITRETURN || State == MODE_SETWSIZE)\n    {\n\tif (msg_row == Rows - 1)\n\t{\n\t    // Avoid drawing the \"hit-enter\" prompt below the previous one,\n\t    // overwrite it.  Esp. useful when regaining focus and a\n\t    // FocusGained autocmd exists but didn't draw anything.\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    msg_clr_eos();\n\t}\n\thit_return_msg();\n\tmsg_row = Rows - 1;\n    }\n}\n\n/*\n * msg_check_screen - check if the screen is initialized.\n * Also check msg_row and msg_col, if they are too big it may cause a crash.\n * While starting the GUI the terminal codes will be set for the GUI, but the\n * output goes to the terminal.  Don't use the terminal codes then.\n */\n    static int\nmsg_check_screen(void)\n{\n    if (!full_screen || !screen_valid(FALSE))\n\treturn FALSE;\n\n    if (msg_row >= Rows)\n\tmsg_row = Rows - 1;\n    if (msg_col >= Columns)\n\tmsg_col = Columns - 1;\n    return TRUE;\n}\n\n/*\n * Clear from current message position to end of screen.\n * Skip this when \":silent\" was used, no need to clear for redirection.\n */\n    void\nmsg_clr_eos(void)\n{\n    if (msg_silent == 0)\n\tmsg_clr_eos_force();\n}\n\n/*\n * Clear from current message position to end of screen.\n * Note: msg_col is not updated, so we remember the end of the message\n * for msg_check().\n */\n    void\nmsg_clr_eos_force(void)\n{\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;  // messages go into a popup\n#endif\n    if (msg_use_printf())\n    {\n\tif (full_screen)\t// only when termcap codes are valid\n\t{\n\t    if (*T_CD)\n\t\tout_str(T_CD);\t// clear to end of display\n\t    else if (*T_CE)\n\t\tout_str(T_CE);\t// clear to end of line\n\t}\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    screen_fill(msg_row, msg_row + 1, 0, msg_col + 1, ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n\telse\n#endif\n\t{\n\t    screen_fill(msg_row, msg_row + 1, msg_col, (int)Columns,\n\t\t\t\t\t\t\t\t ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n    }\n}\n\n/*\n * Clear the command line.\n */\n    void\nmsg_clr_cmdline(void)\n{\n    msg_row = cmdline_row;\n    msg_col = 0;\n    msg_clr_eos_force();\n}\n\n/*\n * end putting a message on the screen\n * call wait_return() if the message does not fit in the available space\n * return TRUE if wait_return() not called.\n */\n    int\nmsg_end(void)\n{\n    /*\n     * If the string is larger than the window,\n     * or the ruler option is set and we run into it,\n     * we have to redraw the window.\n     * Do not do this if we are abandoning the file or editing the command line.\n     */\n    if (!exiting && need_wait_return && !(State & MODE_CMDLINE))\n    {\n\twait_return(FALSE);\n\treturn FALSE;\n    }\n    out_flush();\n    return TRUE;\n}\n\n/*\n * If the written message runs into the shown command or ruler, we have to\n * wait for hit-return and redraw the window later.\n */\n    void\nmsg_check(void)\n{\n    if (msg_row == Rows - 1 && msg_col >= sc_col\n#ifdef HAS_MESSAGE_WINDOW\n\t\t&& !in_echowindow\n#endif\n\t    )\n    {\n\tneed_wait_return = TRUE;\n\tredraw_cmdline = TRUE;\n    }\n}\n\n/*\n * May write a string to the redirection file.\n * When \"maxlen\" is -1 write the whole string, otherwise up to \"maxlen\" bytes.\n */\n    static void\nredir_write(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    static int\tcur_col = 0;\n\n    // Don't do anything for displaying prompts and the like.\n    if (redir_off)\n\treturn;\n\n    // If 'verbosefile' is set prepare for writing in that file.\n    if (*p_vfile != NUL && verbose_fd == NULL)\n\tverbose_open();\n\n    if (redirecting())\n    {\n\t// If the string doesn't start with CR or NL, go to msg_col\n\tif (*s != '\\n' && *s != '\\r')\n\t{\n\t    while (cur_col < msg_col)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (redir_execute)\n\t\t    execute_redir_str((char_u *)\" \", -1);\n\t\telse if (redir_reg)\n\t\t    write_reg_contents(redir_reg, (char_u *)\" \", -1, TRUE);\n\t\telse if (redir_vname)\n\t\t    var_redir_str((char_u *)\" \", -1);\n\t\telse\n#endif\n\t\t    if (redir_fd != NULL)\n\t\t    fputs(\" \", redir_fd);\n\t\tif (verbose_fd != NULL)\n\t\t    fputs(\" \", verbose_fd);\n\t\t++cur_col;\n\t    }\n\t}\n\n#ifdef FEAT_EVAL\n\tif (redir_execute)\n\t    execute_redir_str(s, maxlen);\n\telse if (redir_reg)\n\t    write_reg_contents(redir_reg, s, maxlen, TRUE);\n\telse if (redir_vname)\n\t    var_redir_str(s, maxlen);\n#endif\n\n\t// Write and adjust the current column.\n\twhile (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))\n\t{\n#ifdef FEAT_EVAL\n\t    if (!redir_reg && !redir_vname && !redir_execute)\n#endif\n\t\tif (redir_fd != NULL)\n\t\t    putc(*s, redir_fd);\n\t    if (verbose_fd != NULL)\n\t\tputc(*s, verbose_fd);\n\t    if (*s == '\\r' || *s == '\\n')\n\t\tcur_col = 0;\n\t    else if (*s == '\\t')\n\t\tcur_col += (8 - cur_col % 8);\n\t    else\n\t\t++cur_col;\n\t    ++s;\n\t}\n\n\tif (msg_silent != 0)\t// should update msg_col\n\t    msg_col = cur_col;\n    }\n}\n\n    int\nredirecting(void)\n{\n    return redir_fd != NULL || *p_vfile != NUL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname || redir_execute\n#endif\n\t\t\t\t       ;\n}\n\n/*\n * Before giving verbose message.\n * Must always be called paired with verbose_leave()!\n */\n    void\nverbose_enter(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n}\n\n/*\n * After giving verbose message.\n * Must always be called paired with verbose_enter()!\n */\n    void\nverbose_leave(void)\n{\n    if (*p_vfile != NUL)\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n}\n\n/*\n * Like verbose_enter() and set msg_scroll when displaying the message.\n */\n    void\nverbose_enter_scroll(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n    else\n\t// always scroll up, don't overwrite\n\tmsg_scroll = TRUE;\n}\n\n/*\n * Like verbose_leave() and set cmdline_row when displaying the message.\n */\n    void\nverbose_leave_scroll(void)\n{\n    if (*p_vfile != NUL)\n    {\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n    }\n    else\n\tcmdline_row = msg_row;\n}\n\n/*\n * Called when 'verbosefile' is set: stop writing to the file.\n */\n    void\nverbose_stop(void)\n{\n    if (verbose_fd != NULL)\n    {\n\tfclose(verbose_fd);\n\tverbose_fd = NULL;\n    }\n    verbose_did_open = FALSE;\n}\n\n/*\n * Open the file 'verbosefile'.\n * Return FAIL or OK.\n */\n    int\nverbose_open(void)\n{\n    if (verbose_fd == NULL && !verbose_did_open)\n    {\n\t// Only give the error message once.\n\tverbose_did_open = TRUE;\n\n\tverbose_fd = mch_fopen((char *)p_vfile, \"a\");\n\tif (verbose_fd == NULL)\n\t{\n\t    semsg(_(e_cant_open_file_str), p_vfile);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Give a warning message (for searching).\n * Use 'w' highlighting and may repeat the message after redrawing\n */\n    void\ngive_warning(char_u *message, int hl)\n{\n    give_warning_with_source(message, hl, FALSE);\n}\n\n    void\ngive_warning_with_source(char_u *message, int hl, int with_source)\n{\n    // Don't do this for \":silent\".\n    if (msg_silent != 0)\n\treturn;\n\n    // Don't want a hit-enter prompt here.\n    ++no_wait_return;\n\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_WARNINGMSG, message, -1);\n#endif\n    VIM_CLEAR(keep_msg);\n    if (hl)\n\tkeep_msg_attr = HL_ATTR(HLF_W);\n    else\n\tkeep_msg_attr = 0;\n\n    if (with_source)\n    {\n\t// Do what msg() does, but with a column offset if the warning should\n\t// be after the mode message.\n\tmsg_start();\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_puts(\" \");\n\tmsg_puts_attr((char *)message, HL_ATTR(HLF_W) | MSG_HIST);\n\tmsg_clr_eos();\n\t(void)msg_end();\n    }\n    else if (msg_attr((char *)message, keep_msg_attr) && msg_scrolled == 0)\n\tset_keep_msg(message, keep_msg_attr);\n\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n\n    --no_wait_return;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\ngive_warning2(char_u *message, char_u *a1, int hl)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just give\n\t// the raw message so the user at least gets a hint.\n\tgive_warning(message, hl);\n    }\n    else\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, (char *)message, a1);\n\tgive_warning(IObuff, hl);\n    }\n}\n#endif\n\n/*\n * Advance msg cursor to column \"col\".\n */\n    void\nmsg_advance(int col)\n{\n    if (msg_silent != 0)\t// nothing to advance to\n    {\n\tmsg_col = col;\t\t// for redirection, may fill it up later\n\treturn;\n    }\n    if (col >= Columns)\t\t// not enough room\n\tcol = Columns - 1;\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\twhile (msg_col > Columns - col)\n\t    msg_putchar(' ');\n    else\n#endif\n\twhile (msg_col < col)\n\t    msg_putchar(' ');\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Used for \"confirm()\" function, and the :confirm command prefix.\n * Versions which haven't got flexible dialogs yet, and console\n * versions, get this generic handler which uses the command line.\n *\n * type  = one of:\n *\t   VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC\n * title = title string (can be NULL for default)\n * (neither used in console dialogs at the moment)\n *\n * Format of the \"buttons\" string:\n * \"Button1Name\\nButton2Name\\nButton3Name\"\n * The first button should normally be the default/accept\n * The second button should be the 'Cancel' button\n * Other buttons- use your imagination!\n * A '&' in a button name becomes a shortcut, so each '&' should be before a\n * different letter.\n *\n * Returns 0 if cancelled, otherwise the nth button (1-indexed).\n */\n    int\ndo_dialog(\n    int\t\ttype UNUSED,\n    char_u\t*title UNUSED,\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton,\n    char_u\t*textfield UNUSED,\t// IObuff for inputdialog(), NULL\n\t\t\t\t\t// otherwise\n    int\t\tex_cmd)\t    // when TRUE pressing : accepts default and starts\n\t\t\t    // Ex command\n{\n    int\t\toldState;\n    int\t\tretval = 0;\n    char_u\t*hotkeys;\n    int\t\tc;\n    int\t\ti;\n    tmode_T\tsave_tmode;\n\n#ifndef NO_CONSOLE\n    // Don't output anything in silent mode (\"ex -s\")\n    if (silent_mode)\n\treturn dfltbutton;   // return default option\n#endif\n\n#ifdef FEAT_GUI_DIALOG\n    // When GUI is running and 'c' not in 'guioptions', use the GUI dialog\n    if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)\n    {\n\t// --gui-dialog-file: write text to a file\n\tif (gui_dialog_log(title, message))\n\t    c = dfltbutton;\n\telse\n\t    c = gui_mch_dialog(type, title, message, buttons, dfltbutton,\n\t\t\t\t\t\t\t   textfield, ex_cmd);\n\t// avoid a hit-enter prompt without clearing the cmdline\n\tneed_wait_return = FALSE;\n\temsg_on_display = FALSE;\n\tcmdline_row = msg_row;\n\n\t// Flush output to avoid that further messages and redrawing is done\n\t// in the wrong order.\n\tout_flush();\n\tgui_mch_update();\n\n\treturn c;\n    }\n#endif\n\n    oldState = State;\n    State = MODE_CONFIRM;\n    setmouse();\n\n    // Ensure raw mode here.\n    save_tmode = cur_tmode;\n    settmode(TMODE_RAW);\n\n    /*\n     * Since we wait for a keypress, don't make the\n     * user press RETURN as well afterwards.\n     */\n    ++no_wait_return;\n    hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);\n\n    if (hotkeys != NULL)\n    {\n\tfor (;;)\n\t{\n\t    // Get a typed character directly from the user.\n\t    c = get_keystroke();\n\t    switch (c)\n\t    {\n\t    case CAR:\t\t// User accepts default option\n\t    case NL:\n\t\tretval = dfltbutton;\n\t\tbreak;\n\t    case Ctrl_C:\t// User aborts/cancels\n\t    case ESC:\n\t\tretval = 0;\n\t\tbreak;\n\t    default:\t\t// Could be a hotkey?\n\t\tif (c < 0)\t// special keys are ignored here\n\t\t    continue;\n\t\tif (c == ':' && ex_cmd)\n\t\t{\n\t\t    retval = dfltbutton;\n\t\t    ins_char_typebuf(':', 0);\n\t\t    break;\n\t\t}\n\n\t\t// Make the character lowercase, as chars in \"hotkeys\" are.\n\t\tc = MB_TOLOWER(c);\n\t\tretval = 1;\n\t\tfor (i = 0; hotkeys[i]; ++i)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif ((*mb_ptr2char)(hotkeys + i) == c)\n\t\t\t    break;\n\t\t\ti += (*mb_ptr2len)(hotkeys + i) - 1;\n\t\t    }\n\t\t    else\n\t\t\tif (hotkeys[i] == c)\n\t\t\t    break;\n\t\t    ++retval;\n\t\t}\n\t\tif (hotkeys[i])\n\t\t    break;\n\t\t// No hotkey match, so keep waiting\n\t\tcontinue;\n\t    }\n\t    break;\n\t}\n\n\tvim_free(hotkeys);\n    }\n\n    settmode(save_tmode);\n    State = oldState;\n    setmouse();\n    --no_wait_return;\n    msg_end_prompt();\n\n    return retval;\n}\n\n/*\n * Copy one character from \"*from\" to \"*to\", taking care of multi-byte\n * characters.  Return the length of the character in bytes.\n */\n    static int\ncopy_char(\n    char_u\t*from,\n    char_u\t*to,\n    int\t\tlowercase)\t// make character lower case\n{\n    int\t\tlen;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tif (lowercase)\n\t{\n\t    c = MB_TOLOWER((*mb_ptr2char)(from));\n\t    return (*mb_char2bytes)(c, to);\n\t}\n\telse\n\t{\n\t    len = (*mb_ptr2len)(from);\n\t    mch_memmove(to, from, (size_t)len);\n\t    return len;\n\t}\n    }\n    else\n    {\n\tif (lowercase)\n\t    *to = (char_u)TOLOWER_LOC(*from);\n\telse\n\t    *to = *from;\n\treturn 1;\n    }\n}\n\n/*\n * Format the dialog string, and display it at the bottom of\n * the screen. Return a string of hotkey chars (if defined) for\n * each 'button'. If a button has no hotkey defined, the first character of\n * the button is used.\n * The hotkeys can be multi-byte characters, but without combining chars.\n *\n * Returns an allocated string with hotkeys, or NULL for error.\n */\n    static char_u *\nmsg_show_console_dialog(\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton)\n{\n    int\t\tlen = 0;\n#define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)\n    int\t\tlenhotkey = HOTK_LEN;\t// count first button\n    char_u\t*hotk = NULL;\n    char_u\t*msgp = NULL;\n    char_u\t*hotkp = NULL;\n    char_u\t*r;\n    int\t\tcopy;\n#define HAS_HOTKEY_LEN 30\n    char_u\thas_hotkey[HAS_HOTKEY_LEN];\n    int\t\tfirst_hotkey = FALSE;\t// first char of button is hotkey\n    int\t\tidx;\n\n    has_hotkey[0] = FALSE;\n\n    /*\n     * First loop: compute the size of memory to allocate.\n     * Second loop: copy to the allocated memory.\n     */\n    for (copy = 0; copy <= 1; ++copy)\n    {\n\tr = buttons;\n\tidx = 0;\n\twhile (*r)\n\t{\n\t    if (*r == DLG_BUTTON_SEP)\n\t    {\n\t\tif (copy)\n\t\t{\n\t\t    *msgp++ = ',';\n\t\t    *msgp++ = ' ';\t    // '\\n' -> ', '\n\n\t\t    // advance to next hotkey and set default hotkey\n\t\t    if (has_mbyte)\n\t\t\thotkp += STRLEN(hotkp);\n\t\t    else\n\t\t\t++hotkp;\n\t\t    hotkp[copy_char(r + 1, hotkp, TRUE)] = NUL;\n\t\t    if (dfltbutton)\n\t\t\t--dfltbutton;\n\n\t\t    // If no hotkey is specified first char is used.\n\t\t    if (idx < HAS_HOTKEY_LEN - 1 && !has_hotkey[++idx])\n\t\t\tfirst_hotkey = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    len += 3;\t\t    // '\\n' -> ', '; 'x' -> '(x)'\n\t\t    lenhotkey += HOTK_LEN;  // each button needs a hotkey\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[++idx] = FALSE;\n\t\t}\n\t    }\n\t    else if (*r == DLG_HOTKEY_CHAR || first_hotkey)\n\t    {\n\t\tif (*r == DLG_HOTKEY_CHAR)\n\t\t    ++r;\n\t\tfirst_hotkey = FALSE;\n\t\tif (copy)\n\t\t{\n\t\t    if (*r == DLG_HOTKEY_CHAR)\t\t// '&&a' -> '&a'\n\t\t\t*msgp++ = *r;\n\t\t    else\n\t\t    {\n\t\t\t// '&a' -> '[a]'\n\t\t\t*msgp++ = (dfltbutton == 1) ? '[' : '(';\n\t\t\tmsgp += copy_char(r, msgp, FALSE);\n\t\t\t*msgp++ = (dfltbutton == 1) ? ']' : ')';\n\n\t\t\t// redefine hotkey\n\t\t\thotkp[copy_char(r, hotkp, TRUE)] = NUL;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++len;\t    // '&a' -> '[a]'\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[idx] = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// everything else copy literally\n\t\tif (copy)\n\t\t    msgp += copy_char(r, msgp, FALSE);\n\t    }\n\n\t    // advance to the next character\n\t    MB_PTR_ADV(r);\n\t}\n\n\tif (copy)\n\t{\n\t    *msgp++ = ':';\n\t    *msgp++ = ' ';\n\t    *msgp = NUL;\n\t}\n\telse\n\t{\n\t    len += (int)(STRLEN(message)\n\t\t\t+ 2\t\t\t// for the NL's\n\t\t\t+ STRLEN(buttons)\n\t\t\t+ 3);\t\t\t// for the \": \" and NUL\n\t    lenhotkey++;\t\t\t// for the NUL\n\n\t    // If no hotkey is specified first char is used.\n\t    if (!has_hotkey[0])\n\t    {\n\t\tfirst_hotkey = TRUE;\n\t\tlen += 2;\t\t// \"x\" -> \"[x]\"\n\t    }\n\n\t    /*\n\t     * Now allocate and load the strings\n\t     */\n\t    vim_free(confirm_msg);\n\t    confirm_msg = alloc(len);\n\t    if (confirm_msg == NULL)\n\t\treturn NULL;\n\t    *confirm_msg = NUL;\n\t    hotk = alloc(lenhotkey);\n\t    if (hotk == NULL)\n\t\treturn NULL;\n\n\t    *confirm_msg = '\\n';\n\t    STRCPY(confirm_msg + 1, message);\n\n\t    msgp = confirm_msg + 1 + STRLEN(message);\n\t    hotkp = hotk;\n\n\t    // Define first default hotkey.  Keep the hotkey string NUL\n\t    // terminated to avoid reading past the end.\n\t    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;\n\n\t    // Remember where the choices start, displaying starts here when\n\t    // \"hotkp\" typed at the more prompt.\n\t    confirm_msg_tail = msgp;\n\t    *msgp++ = '\\n';\n\t}\n    }\n\n    display_confirm_msg();\n    return hotk;\n}\n\n/*\n * Display the \":confirm\" message.  Also called when screen resized.\n */\n    static void\ndisplay_confirm_msg(void)\n{\n    // avoid that 'q' at the more prompt truncates the message here\n    ++confirm_msg_used;\n    if (confirm_msg != NULL)\n\tmsg_puts_attr((char *)confirm_msg, HL_ATTR(HLF_M));\n    --confirm_msg_used;\n}\n\n#endif // FEAT_CON_DIALOG\n\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\n    int\nvim_dialog_yesno(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    if (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)\n\treturn VIM_YES;\n    return VIM_NO;\n}\n\n    int\nvim_dialog_yesnocancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n    }\n    return VIM_CANCEL;\n}\n\n    int\nvim_dialog_yesnoallcancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)\"Question\" : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),\n\t\t\t\t\t\t\t   dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n\tcase 3: return VIM_ALL;\n\tcase 4: return VIM_DISCARDALL;\n    }\n    return VIM_CANCEL;\n}\n\n#endif // FEAT_GUI_DIALOG || FEAT_CON_DIALOG\n", "/* strings.c */\nchar_u *vim_strsave(char_u *string);\nchar_u *vim_strnsave(char_u *string, size_t len);\nchar_u *vim_strsave_escaped(char_u *string, char_u *esc_chars);\nchar_u *vim_strsave_escaped_ext(char_u *string, char_u *esc_chars, int cc, int bsl);\nint csh_like_shell(void);\nchar_u *vim_strsave_shellescape(char_u *string, int do_special, int do_newline);\nchar_u *vim_strsave_up(char_u *string);\nchar_u *vim_strnsave_up(char_u *string, size_t len);\nvoid vim_strup(char_u *p);\nchar_u *strlow_save(char_u *orig);\nvoid del_trailing_spaces(char_u *ptr);\nvoid vim_strncpy(char_u *to, char_u *from, size_t len);\nvoid vim_strcat(char_u *to, char_u *from, size_t tosize);\nint vim_stricmp(char *s1, char *s2);\nint vim_strnicmp(char *s1, char *s2, size_t len);\nchar_u *vim_strchr(char_u *string, int c);\nchar_u *vim_strbyte(char_u *string, int c);\nchar_u *vim_strrchr(char_u *string, int c);\nvoid sort_strings(char_u **files, int count);\nint has_non_ascii(char_u *s);\nchar_u *concat_str(char_u *str1, char_u *str2);\nchar_u *string_quote(char_u *str, int function);\nlong string_count(char_u *haystack, char_u *needle, int ic);\nvoid string_filter_map(char_u *str, filtermap_T filtermap, typval_T *expr, typval_T *rettv);\nvoid string_reduce(typval_T *argvars, typval_T *expr, typval_T *rettv);\nvoid f_byteidx(typval_T *argvars, typval_T *rettv);\nvoid f_byteidxcomp(typval_T *argvars, typval_T *rettv);\nvoid f_charidx(typval_T *argvars, typval_T *rettv);\nvoid f_str2list(typval_T *argvars, typval_T *rettv);\nvoid f_str2nr(typval_T *argvars, typval_T *rettv);\nvoid f_strgetchar(typval_T *argvars, typval_T *rettv);\nvoid f_stridx(typval_T *argvars, typval_T *rettv);\nvoid f_string(typval_T *argvars, typval_T *rettv);\nvoid f_strlen(typval_T *argvars, typval_T *rettv);\nvoid f_strcharlen(typval_T *argvars, typval_T *rettv);\nvoid f_strchars(typval_T *argvars, typval_T *rettv);\nvoid f_strdisplaywidth(typval_T *argvars, typval_T *rettv);\nvoid f_strwidth(typval_T *argvars, typval_T *rettv);\nvoid f_strcharpart(typval_T *argvars, typval_T *rettv);\nvoid f_strpart(typval_T *argvars, typval_T *rettv);\nvoid f_strridx(typval_T *argvars, typval_T *rettv);\nvoid f_strtrans(typval_T *argvars, typval_T *rettv);\nvoid f_tolower(typval_T *argvars, typval_T *rettv);\nvoid f_toupper(typval_T *argvars, typval_T *rettv);\nvoid f_tr(typval_T *argvars, typval_T *rettv);\nvoid f_trim(typval_T *argvars, typval_T *rettv);\n/* vim: set ft=c : */\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * strings.c: string manipulation functions\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n/*\n * Copy \"string\" into newly allocated memory.\n */\n    char_u *\nvim_strsave(char_u *string)\n{\n    char_u\t*p;\n    size_t\tlen;\n\n    len = STRLEN(string) + 1;\n    p = alloc(len);\n    if (p != NULL)\n\tmch_memmove(p, string, len);\n    return p;\n}\n\n/*\n * Copy up to \"len\" bytes of \"string\" into newly allocated memory and\n * terminate with a NUL.\n * The allocated memory always has size \"len + 1\", also when \"string\" is\n * shorter.\n */\n    char_u *\nvim_strnsave(char_u *string, size_t len)\n{\n    char_u\t*p;\n\n    p = alloc(len + 1);\n    if (p != NULL)\n    {\n\tSTRNCPY(p, string, len);\n\tp[len] = NUL;\n    }\n    return p;\n}\n\n/*\n * Same as vim_strsave(), but any characters found in esc_chars are preceded\n * by a backslash.\n */\n    char_u *\nvim_strsave_escaped(char_u *string, char_u *esc_chars)\n{\n    return vim_strsave_escaped_ext(string, esc_chars, '\\\\', FALSE);\n}\n\n/*\n * Same as vim_strsave_escaped(), but when \"bsl\" is TRUE also escape\n * characters where rem_backslash() would remove the backslash.\n * Escape the characters with \"cc\".\n */\n    char_u *\nvim_strsave_escaped_ext(\n    char_u\t*string,\n    char_u\t*esc_chars,\n    int\t\tcc,\n    int\t\tbsl)\n{\n    char_u\t*p;\n    char_u\t*p2;\n    char_u\t*escaped_string;\n    unsigned\tlength;\n    int\t\tl;\n\n    // First count the number of backslashes required.\n    // Then allocate the memory and insert them.\n    length = 1;\t\t\t\t// count the trailing NUL\n    for (p = string; *p; p++)\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    length += l;\t\t// count a multibyte char\n\t    p += l - 1;\n\t    continue;\n\t}\n\tif (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))\n\t    ++length;\t\t\t// count a backslash\n\t++length;\t\t\t// count an ordinary char\n    }\n    escaped_string = alloc(length);\n    if (escaped_string != NULL)\n    {\n\tp2 = escaped_string;\n\tfor (p = string; *p; p++)\n\t{\n\t    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    {\n\t\tmch_memmove(p2, p, (size_t)l);\n\t\tp2 += l;\n\t\tp += l - 1;\t\t// skip multibyte char\n\t\tcontinue;\n\t    }\n\t    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))\n\t\t*p2++ = cc;\n\t    *p2++ = *p;\n\t}\n\t*p2 = NUL;\n    }\n    return escaped_string;\n}\n\n/*\n * Return TRUE when 'shell' has \"csh\" in the tail.\n */\n    int\ncsh_like_shell(void)\n{\n    return (strstr((char *)gettail(p_sh), \"csh\") != NULL);\n}\n\n/*\n * Return TRUE when 'shell' has \"fish\" in the tail.\n */\n    static int\nfish_like_shell(void)\n{\n    return (strstr((char *)gettail(p_sh), \"fish\") != NULL);\n}\n\n/*\n * Escape \"string\" for use as a shell argument with system().\n * This uses single quotes, except when we know we need to use double quotes\n * (MS-DOS and MS-Windows not using PowerShell and without 'shellslash' set).\n * PowerShell also uses a novel escaping for enclosed single quotes - double\n * them up.\n * Escape a newline, depending on the 'shell' option.\n * When \"do_special\" is TRUE also replace \"!\", \"%\", \"#\" and things starting\n * with \"<\" like \"<cfile>\".\n * When \"do_newline\" is FALSE do not escape newline unless it is csh shell.\n * Returns the result in allocated memory, NULL if we have run out.\n */\n    char_u *\nvim_strsave_shellescape(char_u *string, int do_special, int do_newline)\n{\n    unsigned\tlength;\n    char_u\t*p;\n    char_u\t*d;\n    char_u\t*escaped_string;\n    int\t\tl;\n    int\t\tcsh_like;\n    int\t\tfish_like;\n    char_u\t*shname;\n    int\t\tpowershell;\n# ifdef MSWIN\n    int\t\tdouble_quotes;\n# endif\n\n    // Only csh and similar shells expand '!' within single quotes.  For sh and\n    // the like we must not put a backslash before it, it will be taken\n    // literally.  If do_special is set the '!' will be escaped twice.\n    // Csh also needs to have \"\\n\" escaped twice when do_special is set.\n    csh_like = csh_like_shell();\n\n    // Fish shell uses '\\' as an escape character within single quotes, so '\\'\n    // itself must be escaped to get a literal '\\'.\n    fish_like = fish_like_shell();\n\n    // PowerShell uses its own version for quoting single quotes\n    shname = gettail(p_sh);\n    powershell = strstr((char *)shname, \"pwsh\") != NULL;\n# ifdef MSWIN\n    powershell = powershell || strstr((char *)shname, \"powershell\") != NULL;\n    // PowerShell only accepts single quotes so override shellslash.\n    double_quotes = !powershell && !p_ssl;\n# endif\n\n    // First count the number of extra bytes required.\n    length = (unsigned)STRLEN(string) + 3;  // two quotes and a trailing NUL\n    for (p = string; *p != NUL; MB_PTR_ADV(p))\n    {\n# ifdef MSWIN\n\tif (double_quotes)\n\t{\n\t    if (*p == '\"')\n\t\t++length;\t\t// \" -> \"\"\n\t}\n\telse\n# endif\n\tif (*p == '\\'')\n\t{\n\t    if (powershell)\n\t\tlength +=2;\t\t// ' => ''\n\t    else\n\t\tlength += 3;\t\t// ' => '\\''\n\t}\n\tif ((*p == '\\n' && (csh_like || do_newline))\n\t\t|| (*p == '!' && (csh_like || do_special)))\n\t{\n\t    ++length;\t\t\t// insert backslash\n\t    if (csh_like && do_special)\n\t\t++length;\t\t// insert backslash\n\t}\n\tif (do_special && find_cmdline_var(p, &l) >= 0)\n\t{\n\t    ++length;\t\t\t// insert backslash\n\t    p += l - 1;\n\t}\n\tif (*p == '\\\\' && fish_like)\n\t    ++length;\t\t\t// insert backslash\n    }\n\n    // Allocate memory for the result and fill it.\n    escaped_string = alloc(length);\n    if (escaped_string != NULL)\n    {\n\td = escaped_string;\n\n\t// add opening quote\n# ifdef MSWIN\n\tif (double_quotes)\n\t    *d++ = '\"';\n\telse\n# endif\n\t    *d++ = '\\'';\n\n\tfor (p = string; *p != NUL; )\n\t{\n# ifdef MSWIN\n\t    if (double_quotes)\n\t    {\n\t\tif (*p == '\"')\n\t\t{\n\t\t    *d++ = '\"';\n\t\t    *d++ = '\"';\n\t\t    ++p;\n\t\t    continue;\n\t\t}\n\t    }\n\t    else\n# endif\n\t    if (*p == '\\'')\n\t    {\n\t\tif (powershell)\n\t\t{\n\t\t    *d++ = '\\'';\n\t\t    *d++ = '\\'';\n\t\t}\n\t\telse\n\t\t{\n\t\t    *d++ = '\\'';\n\t\t    *d++ = '\\\\';\n\t\t    *d++ = '\\'';\n\t\t    *d++ = '\\'';\n\t\t}\n\t\t++p;\n\t\tcontinue;\n\t    }\n\t    if ((*p == '\\n' && (csh_like || do_newline))\n\t\t    || (*p == '!' && (csh_like || do_special)))\n\t    {\n\t\t*d++ = '\\\\';\n\t\tif (csh_like && do_special)\n\t\t    *d++ = '\\\\';\n\t\t*d++ = *p++;\n\t\tcontinue;\n\t    }\n\t    if (do_special && find_cmdline_var(p, &l) >= 0)\n\t    {\n\t\t*d++ = '\\\\';\t\t// insert backslash\n\t\twhile (--l >= 0)\t// copy the var\n\t\t    *d++ = *p++;\n\t\tcontinue;\n\t    }\n\t    if (*p == '\\\\' && fish_like)\n\t    {\n\t\t*d++ = '\\\\';\n\t\t*d++ = *p++;\n\t\tcontinue;\n\t    }\n\n\t    MB_COPY_CHAR(p, d);\n\t}\n\n\t// add terminating quote and finish with a NUL\n# ifdef MSWIN\n\tif (double_quotes)\n\t    *d++ = '\"';\n\telse\n# endif\n\t    *d++ = '\\'';\n\t*d = NUL;\n    }\n\n    return escaped_string;\n}\n\n/*\n * Like vim_strsave(), but make all characters uppercase.\n * This uses ASCII lower-to-upper case translation, language independent.\n */\n    char_u *\nvim_strsave_up(char_u *string)\n{\n    char_u *p1;\n\n    p1 = vim_strsave(string);\n    vim_strup(p1);\n    return p1;\n}\n\n/*\n * Like vim_strnsave(), but make all characters uppercase.\n * This uses ASCII lower-to-upper case translation, language independent.\n */\n    char_u *\nvim_strnsave_up(char_u *string, size_t len)\n{\n    char_u *p1;\n\n    p1 = vim_strnsave(string, len);\n    vim_strup(p1);\n    return p1;\n}\n\n/*\n * ASCII lower-to-upper case translation, language independent.\n */\n    void\nvim_strup(\n    char_u\t*p)\n{\n    char_u  *p2;\n    int\t    c;\n\n    if (p != NULL)\n    {\n\tp2 = p;\n\twhile ((c = *p2) != NUL)\n\t    *p2++ = (c < 'a' || c > 'z') ? c : (c - 0x20);\n    }\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Make string \"s\" all upper-case and return it in allocated memory.\n * Handles multi-byte characters as well as possible.\n * Returns NULL when out of memory.\n */\n    static char_u *\nstrup_save(char_u *orig)\n{\n    char_u\t*p;\n    char_u\t*res;\n\n    res = p = vim_strsave(orig);\n\n    if (res != NULL)\n\twhile (*p != NUL)\n\t{\n\t    int\t\tl;\n\n\t    if (enc_utf8)\n\t    {\n\t\tint\tc, uc;\n\t\tint\tnewl;\n\t\tchar_u\t*s;\n\n\t\tc = utf_ptr2char(p);\n\t\tl = utf_ptr2len(p);\n\t\tif (c == 0)\n\t\t{\n\t\t    // overlong sequence, use only the first byte\n\t\t    c = *p;\n\t\t    l = 1;\n\t\t}\n\t\tuc = utf_toupper(c);\n\n\t\t// Reallocate string when byte count changes.  This is rare,\n\t\t// thus it's OK to do another malloc()/free().\n\t\tnewl = utf_char2len(uc);\n\t\tif (newl != l)\n\t\t{\n\t\t    s = alloc(STRLEN(res) + 1 + newl - l);\n\t\t    if (s == NULL)\n\t\t    {\n\t\t\tvim_free(res);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    mch_memmove(s, res, p - res);\n\t\t    STRCPY(s + (p - res) + newl, p + l);\n\t\t    p = s + (p - res);\n\t\t    vim_free(res);\n\t\t    res = s;\n\t\t}\n\n\t\tutf_char2bytes(uc, p);\n\t\tp += newl;\n\t    }\n\t    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t\tp += l;\t\t// skip multi-byte character\n\t    else\n\t    {\n\t\t*p = TOUPPER_LOC(*p); // note that toupper() can be a macro\n\t\tp++;\n\t    }\n\t}\n\n    return res;\n}\n\n/*\n * Make string \"s\" all lower-case and return it in allocated memory.\n * Handles multi-byte characters as well as possible.\n * Returns NULL when out of memory.\n */\n    char_u *\nstrlow_save(char_u *orig)\n{\n    char_u\t*p;\n    char_u\t*res;\n\n    res = p = vim_strsave(orig);\n\n    if (res != NULL)\n\twhile (*p != NUL)\n\t{\n\t    int\t\tl;\n\n\t    if (enc_utf8)\n\t    {\n\t\tint\tc, lc;\n\t\tint\tnewl;\n\t\tchar_u\t*s;\n\n\t\tc = utf_ptr2char(p);\n\t\tl = utf_ptr2len(p);\n\t\tif (c == 0)\n\t\t{\n\t\t    // overlong sequence, use only the first byte\n\t\t    c = *p;\n\t\t    l = 1;\n\t\t}\n\t\tlc = utf_tolower(c);\n\n\t\t// Reallocate string when byte count changes.  This is rare,\n\t\t// thus it's OK to do another malloc()/free().\n\t\tnewl = utf_char2len(lc);\n\t\tif (newl != l)\n\t\t{\n\t\t    s = alloc(STRLEN(res) + 1 + newl - l);\n\t\t    if (s == NULL)\n\t\t    {\n\t\t\tvim_free(res);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    mch_memmove(s, res, p - res);\n\t\t    STRCPY(s + (p - res) + newl, p + l);\n\t\t    p = s + (p - res);\n\t\t    vim_free(res);\n\t\t    res = s;\n\t\t}\n\n\t\tutf_char2bytes(lc, p);\n\t\tp += newl;\n\t    }\n\t    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t\tp += l;\t\t// skip multi-byte character\n\t    else\n\t    {\n\t\t*p = TOLOWER_LOC(*p); // note that tolower() can be a macro\n\t\tp++;\n\t    }\n\t}\n\n    return res;\n}\n#endif\n\n/*\n * delete spaces at the end of a string\n */\n    void\ndel_trailing_spaces(char_u *ptr)\n{\n    char_u\t*q;\n\n    q = ptr + STRLEN(ptr);\n    while (--q > ptr && VIM_ISWHITE(q[0]) && q[-1] != '\\\\' && q[-1] != Ctrl_V)\n\t*q = NUL;\n}\n\n/*\n * Like strncpy(), but always terminate the result with one NUL.\n * \"to\" must be \"len + 1\" long!\n */\n    void\nvim_strncpy(char_u *to, char_u *from, size_t len)\n{\n    STRNCPY(to, from, len);\n    to[len] = NUL;\n}\n\n/*\n * Like strcat(), but make sure the result fits in \"tosize\" bytes and is\n * always NUL terminated. \"from\" and \"to\" may overlap.\n */\n    void\nvim_strcat(char_u *to, char_u *from, size_t tosize)\n{\n    size_t tolen = STRLEN(to);\n    size_t fromlen = STRLEN(from);\n\n    if (tolen + fromlen + 1 > tosize)\n    {\n\tmch_memmove(to + tolen, from, tosize - tolen - 1);\n\tto[tosize - 1] = NUL;\n    }\n    else\n\tmch_memmove(to + tolen, from, fromlen + 1);\n}\n\n#if (!defined(HAVE_STRCASECMP) && !defined(HAVE_STRICMP)) || defined(PROTO)\n/*\n * Compare two strings, ignoring case, using current locale.\n * Doesn't work for multi-byte characters.\n * return 0 for match, < 0 for smaller, > 0 for bigger\n */\n    int\nvim_stricmp(char *s1, char *s2)\n{\n    int\t\ti;\n\n    for (;;)\n    {\n\ti = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);\n\tif (i != 0)\n\t    return i;\t\t\t    // this character different\n\tif (*s1 == NUL)\n\t    break;\t\t\t    // strings match until NUL\n\t++s1;\n\t++s2;\n    }\n    return 0;\t\t\t\t    // strings match\n}\n#endif\n\n#if (!defined(HAVE_STRNCASECMP) && !defined(HAVE_STRNICMP)) || defined(PROTO)\n/*\n * Compare two strings, for length \"len\", ignoring case, using current locale.\n * Doesn't work for multi-byte characters.\n * return 0 for match, < 0 for smaller, > 0 for bigger\n */\n    int\nvim_strnicmp(char *s1, char *s2, size_t len)\n{\n    int\t\ti;\n\n    while (len > 0)\n    {\n\ti = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);\n\tif (i != 0)\n\t    return i;\t\t\t    // this character different\n\tif (*s1 == NUL)\n\t    break;\t\t\t    // strings match until NUL\n\t++s1;\n\t++s2;\n\t--len;\n    }\n    return 0;\t\t\t\t    // strings match\n}\n#endif\n\n/*\n * Search for first occurrence of \"c\" in \"string\".\n * Version of strchr() that handles unsigned char strings with characters from\n * 128 to 255 correctly.  It also doesn't return a pointer to the NUL at the\n * end of the string.\n */\n    char_u  *\nvim_strchr(char_u *string, int c)\n{\n    char_u\t*p;\n    int\t\tb;\n\n    p = string;\n    if (enc_utf8 && c >= 0x80)\n    {\n\twhile (*p != NUL)\n\t{\n\t    int l = utfc_ptr2len(p);\n\n\t    // Avoid matching an illegal byte here.\n\t    if (utf_ptr2char(p) == c && l > 1)\n\t\treturn p;\n\t    p += l;\n\t}\n\treturn NULL;\n    }\n    if (enc_dbcs != 0 && c > 255)\n    {\n\tint\tn2 = c & 0xff;\n\n\tc = ((unsigned)c >> 8) & 0xff;\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c && p[1] == n2)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    if (has_mbyte)\n    {\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    while ((b = *p) != NUL)\n    {\n\tif (b == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}\n\n/*\n * Version of strchr() that only works for bytes and handles unsigned char\n * strings with characters above 128 correctly. It also doesn't return a\n * pointer to the NUL at the end of the string.\n */\n    char_u  *\nvim_strbyte(char_u *string, int c)\n{\n    char_u\t*p = string;\n\n    while (*p != NUL)\n    {\n\tif (*p == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}\n\n/*\n * Search for last occurrence of \"c\" in \"string\".\n * Version of strrchr() that handles unsigned char strings with characters from\n * 128 to 255 correctly.  It also doesn't return a pointer to the NUL at the\n * end of the string.\n * Return NULL if not found.\n * Does not handle multi-byte char for \"c\"!\n */\n    char_u  *\nvim_strrchr(char_u *string, int c)\n{\n    char_u\t*retval = NULL;\n    char_u\t*p = string;\n\n    while (*p)\n    {\n\tif (*p == c)\n\t    retval = p;\n\tMB_PTR_ADV(p);\n    }\n    return retval;\n}\n\n/*\n * Vim's version of strpbrk(), in case it's missing.\n * Don't generate a prototype for this, causes problems when it's not used.\n */\n#ifndef PROTO\n# ifndef HAVE_STRPBRK\n#  ifdef vim_strpbrk\n#   undef vim_strpbrk\n#  endif\n    char_u *\nvim_strpbrk(char_u *s, char_u *charset)\n{\n    while (*s)\n    {\n\tif (vim_strchr(charset, *s) != NULL)\n\t    return s;\n\tMB_PTR_ADV(s);\n    }\n    return NULL;\n}\n# endif\n#endif\n\n/*\n * Sort an array of strings.\n */\nstatic int sort_compare(const void *s1, const void *s2);\n\n    static int\nsort_compare(const void *s1, const void *s2)\n{\n    return STRCMP(*(char **)s1, *(char **)s2);\n}\n\n    void\nsort_strings(\n    char_u\t**files,\n    int\t\tcount)\n{\n    qsort((void *)files, (size_t)count, sizeof(char_u *), sort_compare);\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return TRUE if string \"s\" contains a non-ASCII character (128 or higher).\n * When \"s\" is NULL FALSE is returned.\n */\n    int\nhas_non_ascii(char_u *s)\n{\n    char_u\t*p;\n\n    if (s != NULL)\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p >= 128)\n\t\treturn TRUE;\n    return FALSE;\n}\n#endif\n\n/*\n * Concatenate two strings and return the result in allocated memory.\n * Returns NULL when out of memory.\n */\n    char_u  *\nconcat_str(char_u *str1, char_u *str2)\n{\n    char_u  *dest;\n    size_t  l = str1 == NULL ? 0 : STRLEN(str1);\n\n    dest = alloc(l + (str2 == NULL ? 0 : STRLEN(str2)) + 1L);\n    if (dest != NULL)\n    {\n\tif (str1 == NULL)\n\t    *dest = NUL;\n\telse\n\t    STRCPY(dest, str1);\n\tif (str2 != NULL)\n\t    STRCPY(dest + l, str2);\n    }\n    return dest;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return string \"str\" in ' quotes, doubling ' characters.\n * If \"str\" is NULL an empty string is assumed.\n * If \"function\" is TRUE make it function('string').\n */\n    char_u *\nstring_quote(char_u *str, int function)\n{\n    unsigned\tlen;\n    char_u\t*p, *r, *s;\n\n    len = (function ? 13 : 3);\n    if (str != NULL)\n    {\n\tlen += (unsigned)STRLEN(str);\n\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t    if (*p == '\\'')\n\t\t++len;\n    }\n    s = r = alloc(len);\n    if (r != NULL)\n    {\n\tif (function)\n\t{\n\t    STRCPY(r, \"function('\");\n\t    r += 10;\n\t}\n\telse\n\t    *r++ = '\\'';\n\tif (str != NULL)\n\t    for (p = str; *p != NUL; )\n\t    {\n\t\tif (*p == '\\'')\n\t\t    *r++ = '\\'';\n\t\tMB_COPY_CHAR(p, r);\n\t    }\n\t*r++ = '\\'';\n\tif (function)\n\t    *r++ = ')';\n\t*r++ = NUL;\n    }\n    return s;\n}\n\n/*\n * Count the number of times \"needle\" occurs in string \"haystack\". Case is\n * ignored if \"ic\" is TRUE.\n */\n    long\nstring_count(char_u *haystack, char_u *needle, int ic)\n{\n    long\tn = 0;\n    char_u\t*p = haystack;\n    char_u\t*next;\n\n    if (p == NULL || needle == NULL || *needle == NUL)\n\treturn 0;\n\n    if (ic)\n    {\n\tsize_t len = STRLEN(needle);\n\n\twhile (*p != NUL)\n\t{\n\t    if (MB_STRNICMP(p, needle, len) == 0)\n\t    {\n\t\t++n;\n\t\tp += len;\n\t    }\n\t    else\n\t\tMB_PTR_ADV(p);\n\t}\n    }\n    else\n\twhile ((next = (char_u *)strstr((char *)p, (char *)needle)) != NULL)\n\t{\n\t    ++n;\n\t    p = next + STRLEN(needle);\n\t}\n\n    return n;\n}\n\n/*\n * Make a typval_T of the first character of \"input\" and store it in \"output\".\n * Return OK or FAIL.\n */\n    static int\ncopy_first_char_to_tv(char_u *input, typval_T *output)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\tlen;\n\n    if (input == NULL || output == NULL)\n\treturn FAIL;\n\n    len = has_mbyte ? mb_ptr2len(input) : 1;\n    STRNCPY(buf, input, len);\n    buf[len] = NUL;\n    output->v_type = VAR_STRING;\n    output->vval.v_string = vim_strsave(buf);\n\n    return output->vval.v_string == NULL ? FAIL : OK;\n}\n\n/*\n * Implementation of map() and filter() for a String. Apply \"expr\" to every\n * character in string \"str\" and return the result in \"rettv\".\n */\n    void\nstring_filter_map(\n\tchar_u\t\t*str,\n\tfiltermap_T\tfiltermap,\n\ttypval_T\t*expr,\n\ttypval_T\t*rettv)\n{\n    char_u\t*p;\n    typval_T\ttv;\n    garray_T\tga;\n    int\t\tlen = 0;\n    int\t\tidx = 0;\n    int\t\trem;\n    typval_T\tnewtv;\n    funccall_T\t*fc;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    // set_vim_var_nr() doesn't set the type\n    set_vim_var_type(VV_KEY, VAR_NUMBER);\n\n    // Create one funccal_T for all eval_expr_typval() calls.\n    fc = eval_expr_get_funccal(expr, &newtv);\n\n    ga_init2(&ga, sizeof(char), 80);\n    for (p = str; *p != NUL; p += len)\n    {\n\tif (copy_first_char_to_tv(p, &tv) == FAIL)\n\t    break;\n\tlen = (int)STRLEN(tv.vval.v_string);\n\n\tnewtv.v_type = VAR_UNKNOWN;\n\tset_vim_var_nr(VV_KEY, idx);\n\tif (filter_map_one(&tv, expr, filtermap, fc, &newtv, &rem) == FAIL\n\t\t|| did_emsg)\n\t{\n\t    clear_tv(&newtv);\n\t    clear_tv(&tv);\n\t    break;\n\t}\n\telse if (filtermap != FILTERMAP_FILTER)\n\t{\n\t    if (newtv.v_type != VAR_STRING)\n\t    {\n\t\tclear_tv(&newtv);\n\t\tclear_tv(&tv);\n\t\temsg(_(e_string_required));\n\t\tbreak;\n\t    }\n\t    else\n\t\tga_concat(&ga, newtv.vval.v_string);\n\t}\n\telse if (!rem)\n\t    ga_concat(&ga, tv.vval.v_string);\n\n\tclear_tv(&newtv);\n\tclear_tv(&tv);\n\n\t++idx;\n    }\n    ga_append(&ga, NUL);\n    rettv->vval.v_string = ga.ga_data;\n    if (fc != NULL)\n\tremove_funccal();\n}\n\n/*\n * Implementation of reduce() for String \"argvars[0]\" using the function \"expr\"\n * starting with the optional initial value \"argvars[2]\" and return the result\n * in \"rettv\".\n */\n    void\nstring_reduce(\n\ttypval_T\t*argvars,\n\ttypval_T\t*expr,\n\ttypval_T\t*rettv)\n{\n    char_u\t*p = tv_get_string(&argvars[0]);\n    int\t\tlen;\n    typval_T\targv[3];\n    int\t\tr;\n    int\t\tcalled_emsg_start = called_emsg;\n    funccall_T\t*fc;\n\n    if (argvars[2].v_type == VAR_UNKNOWN)\n    {\n\tif (*p == NUL)\n\t{\n\t    semsg(_(e_reduce_of_an_empty_str_with_no_initial_value), \"String\");\n\t    return;\n\t}\n\tif (copy_first_char_to_tv(p, rettv) == FAIL)\n\t    return;\n\tp += STRLEN(rettv->vval.v_string);\n    }\n    else if (check_for_string_arg(argvars, 2) == FAIL)\n\treturn;\n    else\n\tcopy_tv(&argvars[2], rettv);\n\n    // Create one funccal_T for all eval_expr_typval() calls.\n    fc = eval_expr_get_funccal(expr, rettv);\n\n    for ( ; *p != NUL; p += len)\n    {\n\targv[0] = *rettv;\n\tif (copy_first_char_to_tv(p, &argv[1]) == FAIL)\n\t    break;\n\tlen = (int)STRLEN(argv[1].vval.v_string);\n\n\tr = eval_expr_typval(expr, argv, 2, fc, rettv);\n\n\tclear_tv(&argv[0]);\n\tclear_tv(&argv[1]);\n\tif (r == FAIL || called_emsg != called_emsg_start)\n\t    return;\n    }\n\n    if (fc != NULL)\n\tremove_funccal();\n}\n\n    static void\nbyteidx(typval_T *argvars, typval_T *rettv, int comp UNUSED)\n{\n    char_u\t*t;\n    char_u\t*str;\n    varnumber_T\tidx;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\n    idx = tv_get_number_chk(&argvars[1], NULL);\n    if (str == NULL || idx < 0)\n\treturn;\n\n    t = str;\n    for ( ; idx > 0; idx--)\n    {\n\tif (*t == NUL)\t\t// EOL reached\n\t    return;\n\tif (enc_utf8 && comp)\n\t    t += utf_ptr2len(t);\n\telse\n\t    t += (*mb_ptr2len)(t);\n    }\n    rettv->vval.v_number = (varnumber_T)(t - str);\n}\n\n/*\n * \"byteidx()\" function\n */\n    void\nf_byteidx(typval_T *argvars, typval_T *rettv)\n{\n    byteidx(argvars, rettv, FALSE);\n}\n\n/*\n * \"byteidxcomp()\" function\n */\n    void\nf_byteidxcomp(typval_T *argvars, typval_T *rettv)\n{\n    byteidx(argvars, rettv, TRUE);\n}\n\n/*\n * \"charidx()\" function\n */\n    void\nf_charidx(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    varnumber_T\tidx;\n    varnumber_T\tcountcc = FALSE;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\t(*ptr2len)(char_u *);\n\n    rettv->vval.v_number = -1;\n\n    if ((check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 2) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\n    idx = tv_get_number_chk(&argvars[1], NULL);\n    if (str == NULL || idx < 0)\n\treturn;\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n\tcountcc = tv_get_bool(&argvars[2]);\n    if (countcc < 0 || countcc > 1)\n    {\n\tsemsg(_(e_using_number_as_bool_nr), countcc);\n\treturn;\n    }\n\n    if (enc_utf8 && countcc)\n\tptr2len = utf_ptr2len;\n    else\n\tptr2len = mb_ptr2len;\n\n    for (p = str, len = 0; p <= str + idx; len++)\n    {\n\tif (*p == NUL)\n\t    return;\n\tp += ptr2len(p);\n    }\n\n    rettv->vval.v_number = len > 0 ? len - 1 : 0;\n}\n\n/*\n * \"str2list()\" function\n */\n    void\nf_str2list(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n    int\t\tutf8 = FALSE;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tutf8 = (int)tv_get_bool_chk(&argvars[1], NULL);\n\n    p = tv_get_string(&argvars[0]);\n\n    if (has_mbyte || utf8)\n    {\n\tint (*ptr2len)(char_u *);\n\tint (*ptr2char)(char_u *);\n\n\tif (utf8 || enc_utf8)\n\t{\n\t    ptr2len = utf_ptr2len;\n\t    ptr2char = utf_ptr2char;\n\t}\n\telse\n\t{\n\t    ptr2len = mb_ptr2len;\n\t    ptr2char = mb_ptr2char;\n\t}\n\n\tfor ( ; *p != NUL; p += (*ptr2len)(p))\n\t    list_append_number(rettv->vval.v_list, (*ptr2char)(p));\n    }\n    else\n\tfor ( ; *p != NUL; ++p)\n\t    list_append_number(rettv->vval.v_list, *p);\n}\n\n/*\n * \"str2nr()\" function\n */\n    void\nf_str2nr(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tbase = 10;\n    char_u\t*p;\n    varnumber_T\tn;\n    int\t\twhat = 0;\n    int\t\tisneg;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_bool_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tbase = (int)tv_get_number(&argvars[1]);\n\tif (base != 2 && base != 8 && base != 10 && base != 16)\n\t{\n\t    emsg(_(e_invalid_argument));\n\t    return;\n\t}\n\tif (argvars[2].v_type != VAR_UNKNOWN && tv_get_bool(&argvars[2]))\n\t    what |= STR2NR_QUOTE;\n    }\n\n    p = skipwhite(tv_get_string_strict(&argvars[0]));\n    isneg = (*p == '-');\n    if (*p == '+' || *p == '-')\n\tp = skipwhite(p + 1);\n    switch (base)\n    {\n\tcase 2: what |= STR2NR_BIN + STR2NR_FORCE; break;\n\tcase 8: what |= STR2NR_OCT + STR2NR_OOCT + STR2NR_FORCE; break;\n\tcase 16: what |= STR2NR_HEX + STR2NR_FORCE; break;\n    }\n    vim_str2nr(p, NULL, NULL, what, &n, NULL, 0, FALSE);\n    // Text after the number is silently ignored.\n    if (isneg)\n\trettv->vval.v_number = -n;\n    else\n\trettv->vval.v_number = n;\n\n}\n\n/*\n * \"strgetchar()\" function\n */\n    void\nf_strgetchar(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    int\t\tlen;\n    int\t\terror = FALSE;\n    int\t\tcharidx;\n    int\t\tbyteidx = 0;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\n    if (str == NULL)\n\treturn;\n    len = (int)STRLEN(str);\n    charidx = (int)tv_get_number_chk(&argvars[1], &error);\n    if (error)\n\treturn;\n\n    while (charidx >= 0 && byteidx < len)\n    {\n\tif (charidx == 0)\n\t{\n\t    rettv->vval.v_number = mb_ptr2char(str + byteidx);\n\t    break;\n\t}\n\t--charidx;\n\tbyteidx += MB_CPTR2LEN(str + byteidx);\n    }\n}\n\n/*\n * \"stridx()\" function\n */\n    void\nf_stridx(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf[NUMBUFLEN];\n    char_u\t*needle;\n    char_u\t*haystack;\n    char_u\t*save_haystack;\n    char_u\t*pos;\n    int\t\tstart_idx;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    needle = tv_get_string_chk(&argvars[1]);\n    save_haystack = haystack = tv_get_string_buf_chk(&argvars[0], buf);\n    rettv->vval.v_number = -1;\n    if (needle == NULL || haystack == NULL)\n\treturn;\t\t// type error; errmsg already given\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tint\t    error = FALSE;\n\n\tstart_idx = (int)tv_get_number_chk(&argvars[2], &error);\n\tif (error || start_idx >= (int)STRLEN(haystack))\n\t    return;\n\tif (start_idx >= 0)\n\t    haystack += start_idx;\n    }\n\n    pos\t= (char_u *)strstr((char *)haystack, (char *)needle);\n    if (pos != NULL)\n\trettv->vval.v_number = (varnumber_T)(pos - save_haystack);\n}\n\n/*\n * \"string()\" function\n */\n    void\nf_string(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = tv2string(&argvars[0], &tofree, numbuf,\n\t\t\t\t\t\t\t\tget_copyID());\n    // Make a copy if we have a value but it's not in allocated memory.\n    if (rettv->vval.v_string != NULL && tofree == NULL)\n\trettv->vval.v_string = vim_strsave(rettv->vval.v_string);\n}\n\n/*\n * \"strlen()\" function\n */\n    void\nf_strlen(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && check_for_string_or_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = (varnumber_T)(STRLEN(\n\t\t\t\t\t      tv_get_string(&argvars[0])));\n}\n\n    static void\nstrchar_common(typval_T *argvars, typval_T *rettv, int skipcc)\n{\n    char_u\t\t*s = tv_get_string(&argvars[0]);\n    varnumber_T\t\tlen = 0;\n    int\t\t\t(*func_mb_ptr2char_adv)(char_u **pp);\n\n    func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;\n    while (*s != NUL)\n    {\n\tfunc_mb_ptr2char_adv(&s);\n\t++len;\n    }\n    rettv->vval.v_number = len;\n}\n\n/*\n * \"strcharlen()\" function\n */\n    void\nf_strcharlen(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && check_for_string_or_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    strchar_common(argvars, rettv, TRUE);\n}\n\n/*\n * \"strchars()\" function\n */\n    void\nf_strchars(typval_T *argvars, typval_T *rettv)\n{\n    varnumber_T\t\tskipcc = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tskipcc = tv_get_bool(&argvars[1]);\n    if (skipcc < 0 || skipcc > 1)\n\tsemsg(_(e_using_number_as_bool_nr), skipcc);\n    else\n\tstrchar_common(argvars, rettv, skipcc);\n}\n\n/*\n * \"strdisplaywidth()\" function\n */\n    void\nf_strdisplaywidth(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*s;\n    int\t\tcol = 0;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    s = tv_get_string(&argvars[0]);\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tcol = (int)tv_get_number(&argvars[1]);\n\n    rettv->vval.v_number = (varnumber_T)(linetabsize_col(col, s) - col);\n}\n\n/*\n * \"strwidth()\" function\n */\n    void\nf_strwidth(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*s;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    s = tv_get_string_strict(&argvars[0]);\n    rettv->vval.v_number = (varnumber_T)(mb_string2cells(s, -1));\n}\n\n/*\n * \"strcharpart()\" function\n */\n    void\nf_strcharpart(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n    int\t\tnchar;\n    int\t\tnbyte = 0;\n    int\t\tcharlen;\n    int\t\tskipcc = FALSE;\n    int\t\tlen = 0;\n    int\t\tslen;\n    int\t\terror = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_bool_arg(argvars, 3) == FAIL)))\n\treturn;\n\n    p = tv_get_string(&argvars[0]);\n    slen = (int)STRLEN(p);\n\n    nchar = (int)tv_get_number_chk(&argvars[1], &error);\n    if (!error)\n    {\n\tif (argvars[2].v_type != VAR_UNKNOWN\n\t\t\t\t\t   && argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    skipcc = tv_get_bool(&argvars[3]);\n\t    if (skipcc < 0 || skipcc > 1)\n\t    {\n\t\tsemsg(_(e_using_number_as_bool_nr), skipcc);\n\t\treturn;\n\t    }\n\t}\n\n\tif (nchar > 0)\n\t    while (nchar > 0 && nbyte < slen)\n\t    {\n\t\tif (skipcc)\n\t\t    nbyte += mb_ptr2len(p + nbyte);\n\t\telse\n\t\t    nbyte += MB_CPTR2LEN(p + nbyte);\n\t\t--nchar;\n\t    }\n\telse\n\t    nbyte = nchar;\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    charlen = (int)tv_get_number(&argvars[2]);\n\t    while (charlen > 0 && nbyte + len < slen)\n\t    {\n\t\tint off = nbyte + len;\n\n\t\tif (off < 0)\n\t\t    len += 1;\n\t\telse\n\t\t{\n\t\t    if (skipcc)\n\t\t\tlen += mb_ptr2len(p + off);\n\t\t    else\n\t\t\tlen += MB_CPTR2LEN(p + off);\n\t\t}\n\t\t--charlen;\n\t    }\n\t}\n\telse\n\t    len = slen - nbyte;    // default: all bytes that are available.\n    }\n\n    // Only return the overlap between the specified part and the actual\n    // string.\n    if (nbyte < 0)\n    {\n\tlen += nbyte;\n\tnbyte = 0;\n    }\n    else if (nbyte > slen)\n\tnbyte = slen;\n    if (len < 0)\n\tlen = 0;\n    else if (nbyte + len > slen)\n\tlen = slen - nbyte;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = vim_strnsave(p + nbyte, len);\n}\n\n/*\n * \"strpart()\" function\n */\n    void\nf_strpart(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n    int\t\tn;\n    int\t\tlen;\n    int\t\tslen;\n    int\t\terror = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_bool_arg(argvars, 3) == FAIL)))\n\treturn;\n\n    p = tv_get_string(&argvars[0]);\n    slen = (int)STRLEN(p);\n\n    n = (int)tv_get_number_chk(&argvars[1], &error);\n    if (error)\n\tlen = 0;\n    else if (argvars[2].v_type != VAR_UNKNOWN)\n\tlen = (int)tv_get_number(&argvars[2]);\n    else\n\tlen = slen - n;\t    // default len: all bytes that are available.\n\n    // Only return the overlap between the specified part and the actual\n    // string.\n    if (n < 0)\n    {\n\tlen += n;\n\tn = 0;\n    }\n    else if (n > slen)\n\tn = slen;\n    if (len < 0)\n\tlen = 0;\n    else if (n + len > slen)\n\tlen = slen - n;\n\n    if (argvars[2].v_type != VAR_UNKNOWN && argvars[3].v_type != VAR_UNKNOWN)\n    {\n\tint off;\n\n\t// length in characters\n\tfor (off = n; off < slen && len > 0; --len)\n\t    off += mb_ptr2len(p + off);\n\tlen = off - n;\n    }\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = vim_strnsave(p + n, len);\n}\n\n/*\n * \"strridx()\" function\n */\n    void\nf_strridx(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf[NUMBUFLEN];\n    char_u\t*needle;\n    char_u\t*haystack;\n    char_u\t*rest;\n    char_u\t*lastmatch = NULL;\n    int\t\thaystack_len, end_idx;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    needle = tv_get_string_chk(&argvars[1]);\n    haystack = tv_get_string_buf_chk(&argvars[0], buf);\n\n    rettv->vval.v_number = -1;\n    if (needle == NULL || haystack == NULL)\n\treturn;\t\t// type error; errmsg already given\n\n    haystack_len = (int)STRLEN(haystack);\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\t// Third argument: upper limit for index\n\tend_idx = (int)tv_get_number_chk(&argvars[2], NULL);\n\tif (end_idx < 0)\n\t    return;\t// can never find a match\n    }\n    else\n\tend_idx = haystack_len;\n\n    if (*needle == NUL)\n    {\n\t// Empty string matches past the end.\n\tlastmatch = haystack + end_idx;\n    }\n    else\n    {\n\tfor (rest = haystack; *rest != '\\0'; ++rest)\n\t{\n\t    rest = (char_u *)strstr((char *)rest, (char *)needle);\n\t    if (rest == NULL || rest > haystack + end_idx)\n\t\tbreak;\n\t    lastmatch = rest;\n\t}\n    }\n\n    if (lastmatch == NULL)\n\trettv->vval.v_number = -1;\n    else\n\trettv->vval.v_number = (varnumber_T)(lastmatch - haystack);\n}\n\n/*\n * \"strtrans()\" function\n */\n    void\nf_strtrans(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = transstr(tv_get_string(&argvars[0]));\n}\n\n/*\n * \"tolower(string)\" function\n */\n    void\nf_tolower(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = strlow_save(tv_get_string(&argvars[0]));\n}\n\n/*\n * \"toupper(string)\" function\n */\n    void\nf_toupper(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = strup_save(tv_get_string(&argvars[0]));\n}\n\n/*\n * \"tr(string, fromstr, tostr)\" function\n */\n    void\nf_tr(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*in_str;\n    char_u\t*fromstr;\n    char_u\t*tostr;\n    char_u\t*p;\n    int\t\tinlen;\n    int\t\tfromlen;\n    int\t\ttolen;\n    int\t\tidx;\n    char_u\t*cpstr;\n    int\t\tcplen;\n    int\t\tfirst = TRUE;\n    char_u\tbuf[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    garray_T\tga;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    in_str = tv_get_string(&argvars[0]);\n    fromstr = tv_get_string_buf_chk(&argvars[1], buf);\n    tostr = tv_get_string_buf_chk(&argvars[2], buf2);\n\n    // Default return value: empty string.\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (fromstr == NULL || tostr == NULL)\n\t    return;\t\t// type error; errmsg already given\n    ga_init2(&ga, sizeof(char), 80);\n\n    if (!has_mbyte)\n\t// not multi-byte: fromstr and tostr must be the same length\n\tif (STRLEN(fromstr) != STRLEN(tostr))\n\t{\nerror:\n\t    semsg(_(e_invalid_argument_str), fromstr);\n\t    ga_clear(&ga);\n\t    return;\n\t}\n\n    // fromstr and tostr have to contain the same number of chars\n    while (*in_str != NUL)\n    {\n\tif (has_mbyte)\n\t{\n\t    inlen = (*mb_ptr2len)(in_str);\n\t    cpstr = in_str;\n\t    cplen = inlen;\n\t    idx = 0;\n\t    for (p = fromstr; *p != NUL; p += fromlen)\n\t    {\n\t\tfromlen = (*mb_ptr2len)(p);\n\t\tif (fromlen == inlen && STRNCMP(in_str, p, inlen) == 0)\n\t\t{\n\t\t    for (p = tostr; *p != NUL; p += tolen)\n\t\t    {\n\t\t\ttolen = (*mb_ptr2len)(p);\n\t\t\tif (idx-- == 0)\n\t\t\t{\n\t\t\t    cplen = tolen;\n\t\t\t    cpstr = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (*p == NUL)\t// tostr is shorter than fromstr\n\t\t\tgoto error;\n\t\t    break;\n\t\t}\n\t\t++idx;\n\t    }\n\n\t    if (first && cpstr == in_str)\n\t    {\n\t\t// Check that fromstr and tostr have the same number of\n\t\t// (multi-byte) characters.  Done only once when a character\n\t\t// of in_str doesn't appear in fromstr.\n\t\tfirst = FALSE;\n\t\tfor (p = tostr; *p != NUL; p += tolen)\n\t\t{\n\t\t    tolen = (*mb_ptr2len)(p);\n\t\t    --idx;\n\t\t}\n\t\tif (idx != 0)\n\t\t    goto error;\n\t    }\n\n\t    (void)ga_grow(&ga, cplen);\n\t    mch_memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);\n\t    ga.ga_len += cplen;\n\n\t    in_str += inlen;\n\t}\n\telse\n\t{\n\t    // When not using multi-byte chars we can do it faster.\n\t    p = vim_strchr(fromstr, *in_str);\n\t    if (p != NULL)\n\t\tga_append(&ga, tostr[p - fromstr]);\n\t    else\n\t\tga_append(&ga, *in_str);\n\t    ++in_str;\n\t}\n    }\n\n    // add a terminating NUL\n    (void)ga_grow(&ga, 1);\n    ga_append(&ga, NUL);\n\n    rettv->vval.v_string = ga.ga_data;\n}\n\n/*\n * \"trim({expr})\" function\n */\n    void\nf_trim(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    char_u\t*head;\n    char_u\t*mask = NULL;\n    char_u\t*tail;\n    char_u\t*prev;\n    char_u\t*p;\n    int\t\tc1;\n    int\t\tdir = 0;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    head = tv_get_string_buf_chk(&argvars[0], buf1);\n    if (head == NULL)\n\treturn;\n\n    if (check_for_opt_string_arg(argvars, 1) == FAIL)\n\treturn;\n\n    if (argvars[1].v_type == VAR_STRING)\n    {\n\tmask = tv_get_string_buf_chk(&argvars[1], buf2);\n\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    int\terror = 0;\n\n\t    // leading or trailing characters to trim\n\t    dir = (int)tv_get_number_chk(&argvars[2], &error);\n\t    if (error)\n\t\treturn;\n\t    if (dir < 0 || dir > 2)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&argvars[2]));\n\t\treturn;\n\t    }\n\t}\n    }\n\n    if (dir == 0 || dir == 1)\n    {\n\t// Trim leading characters\n\twhile (*head != NUL)\n\t{\n\t    c1 = PTR2CHAR(head);\n\t    if (mask == NULL)\n\t    {\n\t\tif (c1 > ' ' && c1 != 0xa0)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tfor (p = mask; *p != NUL; MB_PTR_ADV(p))\n\t\t    if (c1 == PTR2CHAR(p))\n\t\t\tbreak;\n\t\tif (*p == NUL)\n\t\t    break;\n\t    }\n\t    MB_PTR_ADV(head);\n\t}\n    }\n\n    tail = head + STRLEN(head);\n    if (dir == 0 || dir == 2)\n    {\n\t// Trim trailing characters\n\tfor (; tail > head; tail = prev)\n\t{\n\t    prev = tail;\n\t    MB_PTR_BACK(head, prev);\n\t    c1 = PTR2CHAR(prev);\n\t    if (mask == NULL)\n\t    {\n\t\tif (c1 > ' ' && c1 != 0xa0)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tfor (p = mask; *p != NUL; MB_PTR_ADV(p))\n\t\t    if (c1 == PTR2CHAR(p))\n\t\t\tbreak;\n\t\tif (*p == NUL)\n\t\t    break;\n\t    }\n\t}\n    }\n    rettv->vval.v_string = vim_strnsave(head, tail - head);\n}\n\nstatic char *e_printf = N_(e_insufficient_arguments_for_printf);\n\n/*\n * Get number argument from \"idxp\" entry in \"tvs\".  First entry is 1.\n */\n    static varnumber_T\ntv_nr(typval_T *tvs, int *idxp)\n{\n    int\t\tidx = *idxp - 1;\n    varnumber_T\tn = 0;\n    int\t\terr = FALSE;\n\n    if (tvs[idx].v_type == VAR_UNKNOWN)\n\temsg(_(e_printf));\n    else\n    {\n\t++*idxp;\n\tn = tv_get_number_chk(&tvs[idx], &err);\n\tif (err)\n\t    n = 0;\n    }\n    return n;\n}\n\n/*\n * Get string argument from \"idxp\" entry in \"tvs\".  First entry is 1.\n * If \"tofree\" is NULL tv_get_string_chk() is used.  Some types (e.g. List)\n * are not converted to a string.\n * If \"tofree\" is not NULL echo_string() is used.  All types are converted to\n * a string with the same format as \":echo\".  The caller must free \"*tofree\".\n * Returns NULL for an error.\n */\n    static char *\ntv_str(typval_T *tvs, int *idxp, char_u **tofree)\n{\n    int\t\t    idx = *idxp - 1;\n    char\t    *s = NULL;\n    static char_u   numbuf[NUMBUFLEN];\n\n    if (tvs[idx].v_type == VAR_UNKNOWN)\n\temsg(_(e_printf));\n    else\n    {\n\t++*idxp;\n\tif (tofree != NULL)\n\t    s = (char *)echo_string(&tvs[idx], tofree, numbuf, get_copyID());\n\telse\n\t    s = (char *)tv_get_string_chk(&tvs[idx]);\n    }\n    return s;\n}\n\n/*\n * Get float argument from \"idxp\" entry in \"tvs\".  First entry is 1.\n */\n    static double\ntv_float(typval_T *tvs, int *idxp)\n{\n    int\t\tidx = *idxp - 1;\n    double\tf = 0;\n\n    if (tvs[idx].v_type == VAR_UNKNOWN)\n\temsg(_(e_printf));\n    else\n    {\n\t++*idxp;\n\tif (tvs[idx].v_type == VAR_FLOAT)\n\t    f = tvs[idx].vval.v_float;\n\telse if (tvs[idx].v_type == VAR_NUMBER)\n\t    f = (double)tvs[idx].vval.v_number;\n\telse\n\t    emsg(_(e_expected_float_argument_for_printf));\n    }\n    return f;\n}\n\n#endif\n\n/*\n * Return the representation of infinity for printf() function:\n * \"-inf\", \"inf\", \"+inf\", \" inf\", \"-INF\", \"INF\", \"+INF\" or \" INF\".\n */\n    static const char *\ninfinity_str(int positive,\n\t     char fmt_spec,\n\t     int force_sign,\n\t     int space_for_positive)\n{\n    static const char *table[] =\n    {\n\t\"-inf\", \"inf\", \"+inf\", \" inf\",\n\t\"-INF\", \"INF\", \"+INF\", \" INF\"\n    };\n    int idx = positive * (1 + force_sign + force_sign * space_for_positive);\n\n    if (ASCII_ISUPPER(fmt_spec))\n\tidx += 4;\n    return table[idx];\n}\n\n/*\n * This code was included to provide a portable vsnprintf() and snprintf().\n * Some systems may provide their own, but we always use this one for\n * consistency.\n *\n * This code is based on snprintf.c - a portable implementation of snprintf\n * by Mark Martinec <mark.martinec@ijs.si>, Version 2.2, 2000-10-06.\n * Included with permission.  It was heavily modified to fit in Vim.\n * The original code, including useful comments, can be found here:\n *\thttp://www.ijs.si/software/snprintf/\n *\n * This snprintf() only supports the following conversion specifiers:\n * s, c, d, u, o, x, X, p  (and synonyms: i, D, U, O - see below)\n * with flags: '-', '+', ' ', '0' and '#'.\n * An asterisk is supported for field width as well as precision.\n *\n * Limited support for floating point was added: 'f', 'F', 'e', 'E', 'g', 'G'.\n *\n * Length modifiers 'h' (short int) and 'l' (long int) and 'll' (long long int)\n * are supported.  NOTE: for 'll' the argument is varnumber_T or uvarnumber_T.\n *\n * The locale is not used, the string is used as a byte string.  This is only\n * relevant for double-byte encodings where the second byte may be '%'.\n *\n * It is permitted for \"str_m\" to be zero, and it is permitted to specify NULL\n * pointer for resulting string argument if \"str_m\" is zero (as per ISO C99).\n *\n * The return value is the number of characters which would be generated\n * for the given input, excluding the trailing NUL. If this value\n * is greater or equal to \"str_m\", not all characters from the result\n * have been stored in str, output bytes beyond the (\"str_m\"-1) -th character\n * are discarded. If \"str_m\" is greater than zero it is guaranteed\n * the resulting string will be NUL-terminated.\n */\n\n/*\n * When va_list is not supported we only define vim_snprintf().\n *\n * vim_vsnprintf_typval() can be invoked with either \"va_list\" or a list of\n * \"typval_T\".  When the latter is not used it must be NULL.\n */\n\n// When generating prototypes all of this is skipped, cproto doesn't\n// understand this.\n#ifndef PROTO\n\n// Like vim_vsnprintf() but append to the string.\n    int\nvim_snprintf_add(char *str, size_t str_m, const char *fmt, ...)\n{\n    va_list\tap;\n    int\t\tstr_l;\n    size_t\tlen = STRLEN(str);\n    size_t\tspace;\n\n    if (str_m <= len)\n\tspace = 0;\n    else\n\tspace = str_m - len;\n    va_start(ap, fmt);\n    str_l = vim_vsnprintf(str + len, space, fmt, ap);\n    va_end(ap);\n    return str_l;\n}\n\n    int\nvim_snprintf(char *str, size_t str_m, const char *fmt, ...)\n{\n    va_list\tap;\n    int\t\tstr_l;\n\n    va_start(ap, fmt);\n    str_l = vim_vsnprintf(str, str_m, fmt, ap);\n    va_end(ap);\n    return str_l;\n}\n\n    int\nvim_vsnprintf(\n    char\t*str,\n    size_t\tstr_m,\n    const char\t*fmt,\n    va_list\tap)\n{\n    return vim_vsnprintf_typval(str, str_m, fmt, ap, NULL);\n}\n\n    int\nvim_vsnprintf_typval(\n    char\t*str,\n    size_t\tstr_m,\n    const char\t*fmt,\n    va_list\tap,\n    typval_T\t*tvs)\n{\n    size_t\tstr_l = 0;\n    const char\t*p = fmt;\n    int\t\targ_idx = 1;\n\n    if (p == NULL)\n\tp = \"\";\n    while (*p != NUL)\n    {\n\tif (*p != '%')\n\t{\n\t    char    *q = strchr(p + 1, '%');\n\t    size_t  n = (q == NULL) ? STRLEN(p) : (size_t)(q - p);\n\n\t    // Copy up to the next '%' or NUL without any changes.\n\t    if (str_l < str_m)\n\t    {\n\t\tsize_t avail = str_m - str_l;\n\n\t\tmch_memmove(str + str_l, p, n > avail ? avail : n);\n\t    }\n\t    p += n;\n\t    str_l += n;\n\t}\n\telse\n\t{\n\t    size_t  min_field_width = 0, precision = 0;\n\t    int\t    zero_padding = 0, precision_specified = 0, justify_left = 0;\n\t    int\t    alternate_form = 0, force_sign = 0;\n\n\t    // If both the ' ' and '+' flags appear, the ' ' flag should be\n\t    // ignored.\n\t    int\t    space_for_positive = 1;\n\n\t    // allowed values: \\0, h, l, L\n\t    char    length_modifier = '\\0';\n\n\t    // temporary buffer for simple numeric->string conversion\n# define TMP_LEN 350\t// On my system 1e308 is the biggest number possible.\n\t\t\t// That sounds reasonable to use as the maximum\n\t\t\t// printable.\n\t    char    tmp[TMP_LEN];\n\n\t    // string address in case of string argument\n\t    const char  *str_arg = NULL;\n\n\t    // natural field width of arg without padding and sign\n\t    size_t  str_arg_l;\n\n\t    // unsigned char argument value - only defined for c conversion.\n\t    // N.B. standard explicitly states the char argument for the c\n\t    // conversion is unsigned\n\t    unsigned char uchar_arg;\n\n\t    // number of zeros to be inserted for numeric conversions as\n\t    // required by the precision or minimal field width\n\t    size_t  number_of_zeros_to_pad = 0;\n\n\t    // index into tmp where zero padding is to be inserted\n\t    size_t  zero_padding_insertion_ind = 0;\n\n\t    // current conversion specifier character\n\t    char    fmt_spec = '\\0';\n\n\t    // buffer for 's' and 'S' specs\n\t    char_u  *tofree = NULL;\n\n\n\t    p++;  // skip '%'\n\n\t    // parse flags\n\t    while (*p == '0' || *p == '-' || *p == '+' || *p == ' '\n\t\t\t\t\t\t   || *p == '#' || *p == '\\'')\n\t    {\n\t\tswitch (*p)\n\t\t{\n\t\t    case '0': zero_padding = 1; break;\n\t\t    case '-': justify_left = 1; break;\n\t\t    case '+': force_sign = 1; space_for_positive = 0; break;\n\t\t    case ' ': force_sign = 1;\n\t\t\t      // If both the ' ' and '+' flags appear, the ' '\n\t\t\t      // flag should be ignored\n\t\t\t      break;\n\t\t    case '#': alternate_form = 1; break;\n\t\t    case '\\'': break;\n\t\t}\n\t\tp++;\n\t    }\n\t    // If the '0' and '-' flags both appear, the '0' flag should be\n\t    // ignored.\n\n\t    // parse field width\n\t    if (*p == '*')\n\t    {\n\t\tint j;\n\n\t\tp++;\n\t\tj =\n# if defined(FEAT_EVAL)\n\t\t    tvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\tva_arg(ap, int);\n\t\tif (j >= 0)\n\t\t    min_field_width = j;\n\t\telse\n\t\t{\n\t\t    min_field_width = -j;\n\t\t    justify_left = 1;\n\t\t}\n\t    }\n\t    else if (VIM_ISDIGIT((int)(*p)))\n\t    {\n\t\t// size_t could be wider than unsigned int; make sure we treat\n\t\t// argument like common implementations do\n\t\tunsigned int uj = *p++ - '0';\n\n\t\twhile (VIM_ISDIGIT((int)(*p)))\n\t\t    uj = 10 * uj + (unsigned int)(*p++ - '0');\n\t\tmin_field_width = uj;\n\t    }\n\n\t    // parse precision\n\t    if (*p == '.')\n\t    {\n\t\tp++;\n\t\tprecision_specified = 1;\n\t\tif (*p == '*')\n\t\t{\n\t\t    int j;\n\n\t\t    j =\n# if defined(FEAT_EVAL)\n\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t    va_arg(ap, int);\n\t\t    p++;\n\t\t    if (j >= 0)\n\t\t\tprecision = j;\n\t\t    else\n\t\t    {\n\t\t\tprecision_specified = 0;\n\t\t\tprecision = 0;\n\t\t    }\n\t\t}\n\t\telse if (VIM_ISDIGIT((int)(*p)))\n\t\t{\n\t\t    // size_t could be wider than unsigned int; make sure we\n\t\t    // treat argument like common implementations do\n\t\t    unsigned int uj = *p++ - '0';\n\n\t\t    while (VIM_ISDIGIT((int)(*p)))\n\t\t\tuj = 10 * uj + (unsigned int)(*p++ - '0');\n\t\t    precision = uj;\n\t\t}\n\t    }\n\n\t    // parse 'h', 'l' and 'll' length modifiers\n\t    if (*p == 'h' || *p == 'l')\n\t    {\n\t\tlength_modifier = *p;\n\t\tp++;\n\t\tif (length_modifier == 'l' && *p == 'l')\n\t\t{\n\t\t    // double l = __int64 / varnumber_T\n\t\t    length_modifier = 'L';\n\t\t    p++;\n\t\t}\n\t    }\n\t    fmt_spec = *p;\n\n\t    // common synonyms:\n\t    switch (fmt_spec)\n\t    {\n\t\tcase 'i': fmt_spec = 'd'; break;\n\t\tcase 'D': fmt_spec = 'd'; length_modifier = 'l'; break;\n\t\tcase 'U': fmt_spec = 'u'; length_modifier = 'l'; break;\n\t\tcase 'O': fmt_spec = 'o'; length_modifier = 'l'; break;\n\t\tdefault: break;\n\t    }\n\n# if defined(FEAT_EVAL)\n\t    switch (fmt_spec)\n\t    {\n\t\tcase 'd': case 'u': case 'o': case 'x': case 'X':\n\t\t    if (tvs != NULL && length_modifier == '\\0')\n\t\t\tlength_modifier = 'L';\n\t    }\n# endif\n\n\t    // get parameter value, do initial processing\n\t    switch (fmt_spec)\n\t    {\n\t\t// '%' and 'c' behave similar to 's' regarding flags and field\n\t\t// widths\n\t    case '%':\n\t    case 'c':\n\t    case 's':\n\t    case 'S':\n\t\tstr_arg_l = 1;\n\t\tswitch (fmt_spec)\n\t\t{\n\t\tcase '%':\n\t\t    str_arg = p;\n\t\t    break;\n\n\t\tcase 'c':\n\t\t    {\n\t\t\tint j;\n\n\t\t\tj =\n# if defined(FEAT_EVAL)\n\t\t\t    tvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\tva_arg(ap, int);\n\t\t\t// standard demands unsigned char\n\t\t\tuchar_arg = (unsigned char)j;\n\t\t\tstr_arg = (char *)&uchar_arg;\n\t\t\tbreak;\n\t\t    }\n\n\t\tcase 's':\n\t\tcase 'S':\n\t\t    str_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\ttvs != NULL ? tv_str(tvs, &arg_idx, &tofree) :\n# endif\n\t\t\t\t    va_arg(ap, char *);\n\t\t    if (str_arg == NULL)\n\t\t    {\n\t\t\tstr_arg = \"[NULL]\";\n\t\t\tstr_arg_l = 6;\n\t\t    }\n\t\t    // make sure not to address string beyond the specified\n\t\t    // precision !!!\n\t\t    else if (!precision_specified)\n\t\t\tstr_arg_l = strlen(str_arg);\n\t\t    // truncate string if necessary as requested by precision\n\t\t    else if (precision == 0)\n\t\t\tstr_arg_l = 0;\n\t\t    else\n\t\t    {\n\t\t\t// Don't put the #if inside memchr(), it can be a\n\t\t\t// macro.\n\t\t\t// memchr on HP does not like n > 2^31  !!!\n\t\t\tchar *q = memchr(str_arg, '\\0',\n\t\t\t\t  precision <= (size_t)0x7fffffffL ? precision\n\t\t\t\t\t\t       : (size_t)0x7fffffffL);\n\n\t\t\tstr_arg_l = (q == NULL) ? precision\n\t\t\t\t\t\t      : (size_t)(q - str_arg);\n\t\t    }\n\t\t    if (fmt_spec == 'S')\n\t\t    {\n\t\t\tchar_u\t*p1;\n\t\t\tsize_t\ti;\n\t\t\tint\tcell;\n\n\t\t\tfor (i = 0, p1 = (char_u *)str_arg; *p1;\n\t\t\t\t\t\t\t  p1 += mb_ptr2len(p1))\n\t\t\t{\n\t\t\t    cell = mb_ptr2cells(p1);\n\t\t\t    if (precision_specified && i + cell > precision)\n\t\t\t\tbreak;\n\t\t\t    i += cell;\n\t\t\t}\n\n\t\t\tstr_arg_l = p1 - (char_u *)str_arg;\n\t\t\tif (min_field_width != 0)\n\t\t\t    min_field_width += str_arg_l - i;\n\t\t    }\n\t\t    break;\n\n\t\tdefault:\n\t\t    break;\n\t\t}\n\t\tbreak;\n\n\t    case 'd': case 'u':\n\t    case 'b': case 'B':\n\t    case 'o':\n\t    case 'x': case 'X':\n\t    case 'p':\n\t\t{\n\t\t    // NOTE: the u, b, o, x, X and p conversion specifiers\n\t\t    // imply the value is unsigned;  d implies a signed\n\t\t    // value\n\n\t\t    // 0 if numeric argument is zero (or if pointer is\n\t\t    // NULL for 'p'), +1 if greater than zero (or nonzero\n\t\t    // for unsigned arguments), -1 if negative (unsigned\n\t\t    // argument is never negative)\n\t\t    int arg_sign = 0;\n\n\t\t    // only set for length modifier h, or for no length\n\t\t    // modifiers\n\t\t    int int_arg = 0;\n\t\t    unsigned int uint_arg = 0;\n\n\t\t    // only set for length modifier l\n\t\t    long int long_arg = 0;\n\t\t    unsigned long int ulong_arg = 0;\n\n\t\t    // only set for length modifier ll\n\t\t    varnumber_T llong_arg = 0;\n\t\t    uvarnumber_T ullong_arg = 0;\n\n\t\t    // only set for b conversion\n\t\t    uvarnumber_T bin_arg = 0;\n\n\t\t    // pointer argument value -only defined for p\n\t\t    // conversion\n\t\t    void *ptr_arg = NULL;\n\n\t\t    if (fmt_spec == 'p')\n\t\t    {\n\t\t\tlength_modifier = '\\0';\n\t\t\tptr_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t tvs != NULL ? (void *)tv_str(tvs, &arg_idx,\n\t\t\t\t\t\t\t\t\tNULL) :\n# endif\n\t\t\t\t\tva_arg(ap, void *);\n\t\t\tif (ptr_arg != NULL)\n\t\t\t    arg_sign = 1;\n\t\t    }\n\t\t    else if (fmt_spec == 'b' || fmt_spec == 'B')\n\t\t    {\n\t\t\tbin_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t    tvs != NULL ?\n\t\t\t\t\t   (uvarnumber_T)tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\tva_arg(ap, uvarnumber_T);\n\t\t\tif (bin_arg != 0)\n\t\t\t    arg_sign = 1;\n\t\t    }\n\t\t    else if (fmt_spec == 'd')\n\t\t    {\n\t\t\t// signed\n\t\t\tswitch (length_modifier)\n\t\t\t{\n\t\t\tcase '\\0':\n\t\t\tcase 'h':\n\t\t\t    // char and short arguments are passed as int.\n\t\t\t    int_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t    va_arg(ap, int);\n\t\t\t    if (int_arg > 0)\n\t\t\t\targ_sign =  1;\n\t\t\t    else if (int_arg < 0)\n\t\t\t\targ_sign = -1;\n\t\t\t    break;\n\t\t\tcase 'l':\n\t\t\t    long_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t    va_arg(ap, long int);\n\t\t\t    if (long_arg > 0)\n\t\t\t\targ_sign =  1;\n\t\t\t    else if (long_arg < 0)\n\t\t\t\targ_sign = -1;\n\t\t\t    break;\n\t\t\tcase 'L':\n\t\t\t    llong_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t    va_arg(ap, varnumber_T);\n\t\t\t    if (llong_arg > 0)\n\t\t\t\targ_sign =  1;\n\t\t\t    else if (llong_arg < 0)\n\t\t\t\targ_sign = -1;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// unsigned\n\t\t\tswitch (length_modifier)\n\t\t\t{\n\t\t\t    case '\\0':\n\t\t\t    case 'h':\n\t\t\t\tuint_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\t    tvs != NULL ? (unsigned)\n\t\t\t\t\t\t\ttv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t\tva_arg(ap, unsigned int);\n\t\t\t\tif (uint_arg != 0)\n\t\t\t\t    arg_sign = 1;\n\t\t\t\tbreak;\n\t\t\t    case 'l':\n\t\t\t\tulong_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\t    tvs != NULL ? (unsigned long)\n\t\t\t\t\t\t\ttv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t\tva_arg(ap, unsigned long int);\n\t\t\t\tif (ulong_arg != 0)\n\t\t\t\t    arg_sign = 1;\n\t\t\t\tbreak;\n\t\t\t    case 'L':\n\t\t\t\tullong_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\t    tvs != NULL ? (uvarnumber_T)\n\t\t\t\t\t\t\ttv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t\tva_arg(ap, uvarnumber_T);\n\t\t\t\tif (ullong_arg != 0)\n\t\t\t\t    arg_sign = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\n\t\t    str_arg = tmp;\n\t\t    str_arg_l = 0;\n\n\t\t    // NOTE:\n\t\t    //   For d, i, u, o, x, and X conversions, if precision is\n\t\t    //   specified, the '0' flag should be ignored. This is so\n\t\t    //   with Solaris 2.6, Digital UNIX 4.0, HPUX 10, Linux,\n\t\t    //   FreeBSD, NetBSD; but not with Perl.\n\t\t    if (precision_specified)\n\t\t\tzero_padding = 0;\n\t\t    if (fmt_spec == 'd')\n\t\t    {\n\t\t\tif (force_sign && arg_sign >= 0)\n\t\t\t    tmp[str_arg_l++] = space_for_positive ? ' ' : '+';\n\t\t\t// leave negative numbers for sprintf to handle, to\n\t\t\t// avoid handling tricky cases like (short int)-32768\n\t\t    }\n\t\t    else if (alternate_form)\n\t\t    {\n\t\t\tif (arg_sign != 0\n\t\t\t\t     && (fmt_spec == 'b' || fmt_spec == 'B'\n\t\t\t\t      || fmt_spec == 'x' || fmt_spec == 'X') )\n\t\t\t{\n\t\t\t    tmp[str_arg_l++] = '0';\n\t\t\t    tmp[str_arg_l++] = fmt_spec;\n\t\t\t}\n\t\t\t// alternate form should have no effect for p\n\t\t\t// conversion, but ...\n\t\t    }\n\n\t\t    zero_padding_insertion_ind = str_arg_l;\n\t\t    if (!precision_specified)\n\t\t\tprecision = 1;   // default precision is 1\n\t\t    if (precision == 0 && arg_sign == 0)\n\t\t    {\n\t\t\t// When zero value is formatted with an explicit\n\t\t\t// precision 0, the resulting formatted string is\n\t\t\t// empty (d, i, u, b, B, o, x, X, p).\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tchar\tf[6];\n\t\t\tint\tf_l = 0;\n\n\t\t\t// construct a simple format string for sprintf\n\t\t\tf[f_l++] = '%';\n\t\t\tif (!length_modifier)\n\t\t\t    ;\n\t\t\telse if (length_modifier == 'L')\n\t\t\t{\n# ifdef MSWIN\n\t\t\t    f[f_l++] = 'I';\n\t\t\t    f[f_l++] = '6';\n\t\t\t    f[f_l++] = '4';\n# else\n\t\t\t    f[f_l++] = 'l';\n\t\t\t    f[f_l++] = 'l';\n# endif\n\t\t\t}\n\t\t\telse\n\t\t\t    f[f_l++] = length_modifier;\n\t\t\tf[f_l++] = fmt_spec;\n\t\t\tf[f_l++] = '\\0';\n\n\t\t\tif (fmt_spec == 'p')\n\t\t\t    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);\n\t\t\telse if (fmt_spec == 'b' || fmt_spec == 'B')\n\t\t\t{\n\t\t\t    char\t    b[8 * sizeof(uvarnumber_T)];\n\t\t\t    size_t\t    b_l = 0;\n\t\t\t    uvarnumber_T    bn = bin_arg;\n\n\t\t\t    do\n\t\t\t    {\n\t\t\t\tb[sizeof(b) - ++b_l] = '0' + (bn & 0x1);\n\t\t\t\tbn >>= 1;\n\t\t\t    }\n\t\t\t    while (bn != 0);\n\n\t\t\t    memcpy(tmp + str_arg_l, b + sizeof(b) - b_l, b_l);\n\t\t\t    str_arg_l += b_l;\n\t\t\t}\n\t\t\telse if (fmt_spec == 'd')\n\t\t\t{\n\t\t\t    // signed\n\t\t\t    switch (length_modifier)\n\t\t\t    {\n\t\t\t    case '\\0': str_arg_l += sprintf(\n\t\t\t\t\t\t tmp + str_arg_l, f,\n\t\t\t\t\t\t int_arg);\n\t\t\t\t       break;\n\t\t\t    case 'h': str_arg_l += sprintf(\n\t\t\t\t\t\t tmp + str_arg_l, f,\n\t\t\t\t\t\t (short)int_arg);\n\t\t\t\t      break;\n\t\t\t    case 'l': str_arg_l += sprintf(\n\t\t\t\t\t\ttmp + str_arg_l, f, long_arg);\n\t\t\t\t      break;\n\t\t\t    case 'L': str_arg_l += sprintf(\n\t\t\t\t\t       tmp + str_arg_l, f, llong_arg);\n\t\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // unsigned\n\t\t\t    switch (length_modifier)\n\t\t\t    {\n\t\t\t    case '\\0': str_arg_l += sprintf(\n\t\t\t\t\t\ttmp + str_arg_l, f,\n\t\t\t\t\t\tuint_arg);\n\t\t\t\t       break;\n\t\t\t    case 'h': str_arg_l += sprintf(\n\t\t\t\t\t\ttmp + str_arg_l, f,\n\t\t\t\t\t\t(unsigned short)uint_arg);\n\t\t\t\t      break;\n\t\t\t    case 'l': str_arg_l += sprintf(\n\t\t\t\t\t       tmp + str_arg_l, f, ulong_arg);\n\t\t\t\t      break;\n\t\t\t    case 'L': str_arg_l += sprintf(\n\t\t\t\t\t      tmp + str_arg_l, f, ullong_arg);\n\t\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// include the optional minus sign and possible\n\t\t\t// \"0x\" in the region before the zero padding\n\t\t\t// insertion point\n\t\t\tif (zero_padding_insertion_ind < str_arg_l\n\t\t\t\t&& tmp[zero_padding_insertion_ind] == '-')\n\t\t\t    zero_padding_insertion_ind++;\n\t\t\tif (zero_padding_insertion_ind + 1 < str_arg_l\n\t\t\t\t&& tmp[zero_padding_insertion_ind]   == '0'\n\t\t\t\t&& (tmp[zero_padding_insertion_ind + 1] == 'x'\n\t\t\t\t || tmp[zero_padding_insertion_ind + 1] == 'X'))\n\t\t\t    zero_padding_insertion_ind += 2;\n\t\t    }\n\n\t\t    {\n\t\t\tsize_t num_of_digits = str_arg_l\n\t\t\t\t\t\t - zero_padding_insertion_ind;\n\n\t\t\tif (alternate_form && fmt_spec == 'o'\n\t\t\t\t// unless zero is already the first\n\t\t\t\t// character\n\t\t\t\t&& !(zero_padding_insertion_ind < str_arg_l\n\t\t\t\t    && tmp[zero_padding_insertion_ind] == '0'))\n\t\t\t{\n\t\t\t    // assure leading zero for alternate-form\n\t\t\t    // octal numbers\n\t\t\t    if (!precision_specified\n\t\t\t\t\t     || precision < num_of_digits + 1)\n\t\t\t    {\n\t\t\t\t// precision is increased to force the\n\t\t\t\t// first character to be zero, except if a\n\t\t\t\t// zero value is formatted with an\n\t\t\t\t// explicit precision of zero\n\t\t\t\tprecision = num_of_digits + 1;\n\t\t\t    }\n\t\t\t}\n\t\t\t// zero padding to specified precision?\n\t\t\tif (num_of_digits < precision)\n\t\t\t    number_of_zeros_to_pad = precision - num_of_digits;\n\t\t    }\n\t\t    // zero padding to specified minimal field width?\n\t\t    if (!justify_left && zero_padding)\n\t\t    {\n\t\t\tint n = (int)(min_field_width - (str_arg_l\n\t\t\t\t\t\t    + number_of_zeros_to_pad));\n\t\t\tif (n > 0)\n\t\t\t    number_of_zeros_to_pad += n;\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t    case 'f':\n\t    case 'F':\n\t    case 'e':\n\t    case 'E':\n\t    case 'g':\n\t    case 'G':\n\t\t{\n\t\t    // Floating point.\n\t\t    double\tf;\n\t\t    double\tabs_f;\n\t\t    char\tformat[40];\n\t\t    int\t\tl;\n\t\t    int\t\tremove_trailing_zeroes = FALSE;\n\n\t\t    f =\n# if defined(FEAT_EVAL)\n\t\t\ttvs != NULL ? tv_float(tvs, &arg_idx) :\n# endif\n\t\t\t    va_arg(ap, double);\n\t\t    abs_f = f < 0 ? -f : f;\n\n\t\t    if (fmt_spec == 'g' || fmt_spec == 'G')\n\t\t    {\n\t\t\t// Would be nice to use %g directly, but it prints\n\t\t\t// \"1.0\" as \"1\", we don't want that.\n\t\t\tif ((abs_f >= 0.001 && abs_f < 10000000.0)\n\t\t\t\t\t\t\t      || abs_f == 0.0)\n\t\t\t    fmt_spec = ASCII_ISUPPER(fmt_spec) ? 'F' : 'f';\n\t\t\telse\n\t\t\t    fmt_spec = fmt_spec == 'g' ? 'e' : 'E';\n\t\t\tremove_trailing_zeroes = TRUE;\n\t\t    }\n\n\t\t    if ((fmt_spec == 'f' || fmt_spec == 'F') &&\n# ifdef VAX\n\t\t\t    abs_f > 1.0e38\n# else\n\t\t\t    abs_f > 1.0e307\n# endif\n\t\t\t    )\n\t\t    {\n\t\t\t// Avoid a buffer overflow\n\t\t\tSTRCPY(tmp, infinity_str(f > 0.0, fmt_spec,\n\t\t\t\t\t      force_sign, space_for_positive));\n\t\t\tstr_arg_l = STRLEN(tmp);\n\t\t\tzero_padding = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (isnan(f))\n\t\t\t{\n\t\t\t    // Not a number: nan or NAN\n\t\t\t    STRCPY(tmp, ASCII_ISUPPER(fmt_spec) ? \"NAN\"\n\t\t\t\t\t\t\t\t      : \"nan\");\n\t\t\t    str_arg_l = 3;\n\t\t\t    zero_padding = 0;\n\t\t\t}\n\t\t\telse if (isinf(f))\n\t\t\t{\n\t\t\t    STRCPY(tmp, infinity_str(f > 0.0, fmt_spec,\n\t\t\t\t\t      force_sign, space_for_positive));\n\t\t\t    str_arg_l = STRLEN(tmp);\n\t\t\t    zero_padding = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Regular float number\n\t\t\t    format[0] = '%';\n\t\t\t    l = 1;\n\t\t\t    if (force_sign)\n\t\t\t\tformat[l++] = space_for_positive ? ' ' : '+';\n\t\t\t    if (precision_specified)\n\t\t\t    {\n\t\t\t\tsize_t max_prec = TMP_LEN - 10;\n\n\t\t\t\t// Make sure we don't get more digits than we\n\t\t\t\t// have room for.\n\t\t\t\tif ((fmt_spec == 'f' || fmt_spec == 'F')\n\t\t\t\t\t\t\t\t&& abs_f > 1.0)\n\t\t\t\t    max_prec -= (size_t)log10(abs_f);\n\t\t\t\tif (precision > max_prec)\n\t\t\t\t    precision = max_prec;\n\t\t\t\tl += sprintf(format + l, \".%d\", (int)precision);\n\t\t\t    }\n\t\t\t    format[l] = fmt_spec == 'F' ? 'f' : fmt_spec;\n\t\t\t    format[l + 1] = NUL;\n\n\t\t\t    str_arg_l = sprintf(tmp, format, f);\n\t\t\t}\n\n\t\t\tif (remove_trailing_zeroes)\n\t\t\t{\n\t\t\t    int i;\n\t\t\t    char *tp;\n\n\t\t\t    // Using %g or %G: remove superfluous zeroes.\n\t\t\t    if (fmt_spec == 'f' || fmt_spec == 'F')\n\t\t\t\ttp = tmp + str_arg_l - 1;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\ttp = (char *)vim_strchr((char_u *)tmp,\n\t\t\t\t\t\t fmt_spec == 'e' ? 'e' : 'E');\n\t\t\t\tif (tp != NULL)\n\t\t\t\t{\n\t\t\t\t    // Remove superfluous '+' and leading\n\t\t\t\t    // zeroes from the exponent.\n\t\t\t\t    if (tp[1] == '+')\n\t\t\t\t    {\n\t\t\t\t\t// Change \"1.0e+07\" to \"1.0e07\"\n\t\t\t\t\tSTRMOVE(tp + 1, tp + 2);\n\t\t\t\t\t--str_arg_l;\n\t\t\t\t    }\n\t\t\t\t    i = (tp[1] == '-') ? 2 : 1;\n\t\t\t\t    while (tp[i] == '0')\n\t\t\t\t    {\n\t\t\t\t\t// Change \"1.0e07\" to \"1.0e7\"\n\t\t\t\t\tSTRMOVE(tp + i, tp + i + 1);\n\t\t\t\t\t--str_arg_l;\n\t\t\t\t    }\n\t\t\t\t    --tp;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (tp != NULL && !precision_specified)\n\t\t\t\t// Remove trailing zeroes, but keep the one\n\t\t\t\t// just after a dot.\n\t\t\t\twhile (tp > tmp + 2 && *tp == '0'\n\t\t\t\t\t\t\t     && tp[-1] != '.')\n\t\t\t\t{\n\t\t\t\t    STRMOVE(tp, tp + 1);\n\t\t\t\t    --tp;\n\t\t\t\t    --str_arg_l;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char *tp;\n\n\t\t\t    // Be consistent: some printf(\"%e\") use 1.0e+12\n\t\t\t    // and some 1.0e+012.  Remove one zero in the last\n\t\t\t    // case.\n\t\t\t    tp = (char *)vim_strchr((char_u *)tmp,\n\t\t\t\t\t\t fmt_spec == 'e' ? 'e' : 'E');\n\t\t\t    if (tp != NULL && (tp[1] == '+' || tp[1] == '-')\n\t\t\t\t\t  && tp[2] == '0'\n\t\t\t\t\t  && vim_isdigit(tp[3])\n\t\t\t\t\t  && vim_isdigit(tp[4]))\n\t\t\t    {\n\t\t\t\tSTRMOVE(tp + 2, tp + 3);\n\t\t\t\t--str_arg_l;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (zero_padding && min_field_width > str_arg_l\n\t\t\t\t\t      && (tmp[0] == '-' || force_sign))\n\t\t    {\n\t\t\t// padding 0's should be inserted after the sign\n\t\t\tnumber_of_zeros_to_pad = min_field_width - str_arg_l;\n\t\t\tzero_padding_insertion_ind = 1;\n\t\t    }\n\t\t    str_arg = tmp;\n\t\t    break;\n\t\t}\n\n\t    default:\n\t\t// unrecognized conversion specifier, keep format string\n\t\t// as-is\n\t\tzero_padding = 0;  // turn zero padding off for non-numeric\n\t\t\t\t   // conversion\n\t\tjustify_left = 1;\n\t\tmin_field_width = 0;\t\t    // reset flags\n\n\t\t// discard the unrecognized conversion, just keep *\n\t\t// the unrecognized conversion character\n\t\tstr_arg = p;\n\t\tstr_arg_l = 0;\n\t\tif (*p != NUL)\n\t\t    str_arg_l++;  // include invalid conversion specifier\n\t\t\t\t  // unchanged if not at end-of-string\n\t\tbreak;\n\t    }\n\n\t    if (*p != NUL)\n\t\tp++;     // step over the just processed conversion specifier\n\n\t    // insert padding to the left as requested by min_field_width;\n\t    // this does not include the zero padding in case of numerical\n\t    // conversions\n\t    if (!justify_left)\n\t    {\n\t\t// left padding with blank or zero\n\t\tint pn = (int)(min_field_width - (str_arg_l + number_of_zeros_to_pad));\n\n\t\tif (pn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tvim_memset(str + str_l, zero_padding ? '0' : ' ',\n\t\t\t\t\t     (size_t)pn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)pn);\n\t\t    }\n\t\t    str_l += pn;\n\t\t}\n\t    }\n\n\t    // zero padding as requested by the precision or by the minimal\n\t    // field width for numeric conversions required?\n\t    if (number_of_zeros_to_pad == 0)\n\t    {\n\t\t// will not copy first part of numeric right now, *\n\t\t// force it to be copied later in its entirety\n\t\tzero_padding_insertion_ind = 0;\n\t    }\n\t    else\n\t    {\n\t\t// insert first part of numerics (sign or '0x') before zero\n\t\t// padding\n\t\tint zn = (int)zero_padding_insertion_ind;\n\n\t\tif (zn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tmch_memmove(str + str_l, str_arg,\n\t\t\t\t\t     (size_t)zn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)zn);\n\t\t    }\n\t\t    str_l += zn;\n\t\t}\n\n\t\t// insert zero padding as requested by the precision or min\n\t\t// field width\n\t\tzn = (int)number_of_zeros_to_pad;\n\t\tif (zn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tvim_memset(str + str_l, '0',\n\t\t\t\t\t     (size_t)zn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)zn);\n\t\t    }\n\t\t    str_l += zn;\n\t\t}\n\t    }\n\n\t    // insert formatted string\n\t    // (or as-is conversion specifier for unknown conversions)\n\t    {\n\t\tint sn = (int)(str_arg_l - zero_padding_insertion_ind);\n\n\t\tif (sn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tmch_memmove(str + str_l,\n\t\t\t\tstr_arg + zero_padding_insertion_ind,\n\t\t\t\t(size_t)sn > avail ? avail : (size_t)sn);\n\t\t    }\n\t\t    str_l += sn;\n\t\t}\n\t    }\n\n\t    // insert right padding\n\t    if (justify_left)\n\t    {\n\t\t// right blank padding to the field width\n\t\tint pn = (int)(min_field_width\n\t\t\t\t      - (str_arg_l + number_of_zeros_to_pad));\n\n\t\tif (pn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tvim_memset(str + str_l, ' ',\n\t\t\t\t\t     (size_t)pn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)pn);\n\t\t    }\n\t\t    str_l += pn;\n\t\t}\n\t    }\n\t    vim_free(tofree);\n\t}\n    }\n\n    if (str_m > 0)\n    {\n\t// make sure the string is nul-terminated even at the expense of\n\t// overwriting the last character (shouldn't happen, but just in case)\n\t//\n\tstr[str_l <= str_m - 1 ? str_l : str_m - 1] = '\\0';\n    }\n\n    if (tvs != NULL && tvs[arg_idx - 1].v_type != VAR_UNKNOWN)\n\temsg(_(e_too_many_arguments_to_printf));\n\n    // Return the number of characters formatted (excluding trailing nul\n    // character), that is, the number of characters that would have been\n    // written to the buffer if it were large enough.\n    return (int)str_l;\n}\n\n#endif // PROTO\n", "\" Tests for editing the command line.\n\nsource check.vim\nsource screendump.vim\nsource view_util.vim\nsource shared.vim\nimport './vim9.vim' as v9\n\nfunc SetUp()\n  func SaveLastScreenLine()\n    let g:Sline = Screenline(&lines - 1)\n    return ''\n  endfunc\n  cnoremap <expr> <F4> SaveLastScreenLine()\nendfunc\n\nfunc TearDown()\n  delfunc SaveLastScreenLine\n  cunmap <F4>\nendfunc\n\nfunc Test_complete_tab()\n  call writefile(['testfile'], 'Xtestfile', 'D')\n  call feedkeys(\":e Xtest\\t\\r\", \"tx\")\n  call assert_equal('testfile', getline(1))\n\n  \" Pressing <Tab> after '%' completes the current file, also on MS-Windows\n  call feedkeys(\":e %\\t\\r\", \"tx\")\n  call assert_equal('e Xtestfile', @:)\nendfunc\n\nfunc Test_complete_list()\n  \" We can't see the output, but at least we check the code runs properly.\n  call feedkeys(\":e test\\<C-D>\\r\", \"tx\")\n  call assert_equal('test', expand('%:t'))\n\n  \" If a command doesn't support completion, then CTRL-D should be literally\n  \" used.\n  call feedkeys(\":chistory \\<C-D>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"chistory \\<C-D>\", @:)\n\n  \" Test for displaying the tail of the completion matches\n  set wildmode=longest,full\n  call mkdir('Xtest', 'R')\n  call writefile([], 'Xtest/a.c')\n  call writefile([], 'Xtest/a.h')\n  let g:Sline = ''\n  call feedkeys(\":e Xtest/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('a.c  a.h', g:Sline)\n  call assert_equal('\"e Xtest/', @:)\n  if has('win32')\n    \" Test for 'completeslash'\n    set completeslash=backslash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\', @:)\n    call feedkeys(\":e Xtest/\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\a.', @:)\n    set completeslash=slash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/', @:)\n    call feedkeys(\":e Xtest\\\\\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/a.', @:)\n    set completeslash&\n  endif\n\n  \" Test for displaying the tail with wildcards\n  let g:Sline = ''\n  call feedkeys(\":e Xtes?/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes?/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes*/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes*/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes[/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(':e Xtes[/', g:Sline)\n  call assert_equal('\"e Xtes[/', @:)\n\n  set wildmode&\nendfunc\n\nfunc Test_complete_wildmenu()\n  call mkdir('Xwilddir1/Xdir2', 'pR')\n  call writefile(['testfile1'], 'Xwilddir1/Xtestfile1')\n  call writefile(['testfile2'], 'Xwilddir1/Xtestfile2')\n  call writefile(['testfile3'], 'Xwilddir1/Xdir2/Xtestfile3')\n  call writefile(['testfile3'], 'Xwilddir1/Xdir2/Xtestfile4')\n  set wildmenu\n\n  \" Pressing <Tab> completes, and moves to next files when pressing again.\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n\n  \" <S-Tab> is like <Tab> but begin with the last match and then go to\n  \" previous.\n  call feedkeys(\":e Xwilddir1/Xtest\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xwilddir1/Xtest\\<S-Tab>\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Left>/<Right> to move to previous/next file.\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Right>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Right>\\<Right>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Up>/<Down> to go up/down directories.\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Down>\\<CR>\", 'tx')\n  call assert_equal('testfile3', getline(1))\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Down>\\<Up>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" this fails in some Unix GUIs, not sure why\n  if !has('unix') || !has('gui_running')\n    \" <C-J>/<C-K> mappings to go up/down directories when 'wildcharm' is\n    \" different than 'wildchar'.\n    set wildcharm=<C-Z>\n    cnoremap <C-J> <Down><C-Z>\n    cnoremap <C-K> <Up><C-Z>\n    call feedkeys(\":e Xwilddir1/\\<Tab>\\<C-J>\\<CR>\", 'tx')\n    call assert_equal('testfile3', getline(1))\n    call feedkeys(\":e Xwilddir1/\\<Tab>\\<C-J>\\<C-K>\\<CR>\", 'tx')\n    call assert_equal('testfile1', getline(1))\n    set wildcharm=0\n    cunmap <C-J>\n    cunmap <C-K>\n  endif\n\n  \" Test for canceling the wild menu by adding a character\n  redrawstatus\n  call feedkeys(\":e Xwilddir1/\\<Tab>x\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xwilddir1/Xdir2/x', @:)\n\n  \" Completion using a relative path\n  cd Xwilddir1/Xdir2\n  call feedkeys(\":e ../\\<Tab>\\<Right>\\<Down>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xtestfile3 Xtestfile4', @:)\n  cd -\n\n  \" test for wildmenumode()\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":cd Xwilddir\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cd Xwilddir1/0', @:)\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xwilddir1/Xdir2/1', @:)\n  cunmap <F2>\n\n  \" Test for canceling the wild menu by pressing <PageDown> or <PageUp>.\n  \" After this pressing <Left> or <Right> should not change the selection.\n  call feedkeys(\":sign \\<Tab>\\<PageDown>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign define', @:)\n  call histadd('cmd', 'TestWildMenu')\n  call feedkeys(\":sign \\<Tab>\\<PageUp>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"TestWildMenu', @:)\n\n  \" cleanup\n  %bwipe\n  set nowildmenu\nendfunc\n\nfunc Test_wildmenu_screendump()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    set wildmenu hlsearch\n  [SCRIPT]\n  call writefile(lines, 'XTest_wildmenu', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_wildmenu', {'rows': 8})\n  call term_sendkeys(buf, \":vim\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_1', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_2', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_3', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_4', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_redraw_in_autocmd()\n  CheckScreendump\n\n  let lines =<< trim END\n      set cmdheight=2\n      autocmd CmdlineChanged * redraw\n  END\n  call writefile(lines, 'XTest_redraw', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_redraw', {'rows': 8})\n  call term_sendkeys(buf, \":for i in range(3)\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_1', {})\n\n  call term_sendkeys(buf, \"let i =\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_redrawstatus_in_autocmd()\n  CheckScreendump\n\n  let lines =<< trim END\n      set laststatus=2\n      set statusline=%=:%{getcmdline()}\n      autocmd CmdlineChanged * redrawstatus\n  END\n  call writefile(lines, 'XTest_redrawstatus', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_redrawstatus', {'rows': 8})\n  \" :redrawstatus is postponed if messages have scrolled\n  call term_sendkeys(buf, \":echo \\\"one\\\\ntwo\\\\nthree\\\\nfour\\\"\\<CR>\")\n  call term_sendkeys(buf, \":foobar\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_1', {})\n  \" it is not postponed if messages have not scrolled\n  call term_sendkeys(buf, \"\\<Esc>:for in in range(3)\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_2', {})\n  \" with cmdheight=1 messages have scrolled when typing :endfor\n  call term_sendkeys(buf, \"\\<CR>:endfor\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_3', {})\n  call term_sendkeys(buf, \"\\<CR>:set cmdheight=2\\<CR>\")\n  \" with cmdheight=2 messages haven't scrolled when typing :for or :endfor\n  call term_sendkeys(buf, \":for in in range(3)\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_4', {})\n  call term_sendkeys(buf, \"\\<CR>:endfor\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_5', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_changing_cmdheight()\n  CheckScreendump\n\n  let lines =<< trim END\n      set cmdheight=1 laststatus=2\n      func EchoTwo()\n        set laststatus=2\n        set cmdheight=5\n        echo 'foo'\n        echo 'bar'\n        set cmdheight=1\n      endfunc\n  END\n  call writefile(lines, 'XTest_cmdheight', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_cmdheight', {'rows': 8})\n  call term_sendkeys(buf, \":resize -3\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_1', {})\n\n  \" using the space available doesn't change the status line\n  call term_sendkeys(buf, \":set cmdheight+=3\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_2', {})\n\n  \" using more space moves the status line up\n  call term_sendkeys(buf, \":set cmdheight+=1\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_3', {})\n\n  \" reducing cmdheight moves status line down\n  call term_sendkeys(buf, \":set cmdheight-=2\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_4', {})\n\n  \" reducing window size and then setting cmdheight \n  call term_sendkeys(buf, \":resize -1\\<CR>\")\n  call term_sendkeys(buf, \":set cmdheight=1\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_5', {})\n\n  \" setting 'cmdheight' works after outputting two messages\n  call term_sendkeys(buf, \":call EchoTwo()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_6', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_cmdheight_tabline()\n  CheckScreendump\n\n  let buf = RunVimInTerminal('-c \"set ls=2\" -c \"set stal=2\" -c \"set cmdheight=1\"', {'rows': 6})\n  call VerifyScreenDump(buf, 'Test_cmdheight_tabline_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_map_completion()\n  call feedkeys(\":map <unique> <si\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <unique> <silent>', getreg(':'))\n  call feedkeys(\":map <script> <un\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <script> <unique>', getreg(':'))\n  call feedkeys(\":map <expr> <sc\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <expr> <script>', getreg(':'))\n  call feedkeys(\":map <buffer> <e\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <buffer> <expr>', getreg(':'))\n  call feedkeys(\":map <nowait> <b\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <nowait> <buffer>', getreg(':'))\n  call feedkeys(\":map <special> <no\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <special> <nowait>', getreg(':'))\n  call feedkeys(\":map <silent> <sp\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <silent> <special>', getreg(':'))\n\n  map <Middle>x middle\n\n  map ,f commaf\n  map ,g commaf\n  map <Left> left\n  map <A-Left>x shiftleft\n  call feedkeys(\":map ,\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,f', getreg(':'))\n  call feedkeys(\":map ,\\<Tab>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,g', getreg(':'))\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <A-Left>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <A-Left>\\<Tab>\", getreg(':'))\n  unmap ,f\n  unmap ,g\n  unmap <Left>\n  unmap <A-Left>x\n\n  set cpo-=< cpo-=B cpo-=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <M\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <M\\<Tab>\", getreg(':'))\n  unmap <Left>\n\n  set cpo+=<\n  map <Left> left\n  exe \"set t_k6=\\<Esc>[17~\"\n  call feedkeys(\":map \\<Esc>[17~x f6x\\<CR>\", 'xt')\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  if !has('gui_running')\n    call feedkeys(\":map \\<Esc>[17~\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"map <F6>x\", getreg(':'))\n  endif\n  unmap <Left>\n  call feedkeys(\":unmap \\<Esc>[17~x\\<CR>\", 'xt')\n  set cpo-=<\n\n  set cpo+=B\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=B\n\n  set cpo+=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=k\n\n  call assert_fails('call feedkeys(\":map \\\\\\\\%(\\<Tab>\\<Home>\\\"\\<CR>\", \"xt\")', 'E53:')\n\n  unmap <Middle>x\n  set cpo&vim\nendfunc\n\nfunc Test_match_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":match \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match Aardig', @:)\n  call feedkeys(\":match \\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match none', @:)\n  call feedkeys(\":match | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match | chistory', @:)\nendfunc\n\nfunc Test_highlight_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":hi \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi Aardig', getreg(':'))\n  call feedkeys(\":hi default \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default Aardig', getreg(':'))\n  call feedkeys(\":hi clear Aa\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig', getreg(':'))\n  call feedkeys(\":hi li\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi link', getreg(':'))\n  call feedkeys(\":hi d\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default', getreg(':'))\n  call feedkeys(\":hi c\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear', getreg(':'))\n  call feedkeys(\":hi clear Aardig Aard\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig Aardig', getreg(':'))\n  call feedkeys(\":hi Aardig \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Aardig \\t\", getreg(':'))\n\n  \" A cleared group does not show up in completions.\n  hi Anders ctermfg=green\n  call assert_equal(['Aardig', 'Anders'], getcompletion('A', 'highlight'))\n  hi clear Aardig\n  call assert_equal(['Anders'], getcompletion('A', 'highlight'))\n  hi clear Anders\n  call assert_equal([], getcompletion('A', 'highlight'))\nendfunc\n\n\" Test for command-line expansion of \"hi Ni \" (easter egg)\nfunc Test_highlight_easter_egg()\n  call test_override('ui_delay', 1)\n  call feedkeys(\":hi Ni \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Ni \\<Tab>\", @:)\n  call test_override('ALL', 0)\nendfunc\n\nfunc Test_getcompletion()\n  let groupcount = len(getcompletion('', 'event'))\n  call assert_true(groupcount > 0)\n  let matchcount = len('File'->getcompletion('event'))\n  call assert_true(matchcount > 0)\n  call assert_true(groupcount > matchcount)\n\n  if has('menu')\n    source $VIMRUNTIME/menu.vim\n    let matchcount = len(getcompletion('', 'menu'))\n    call assert_true(matchcount > 0)\n    call assert_equal(['File.'], getcompletion('File', 'menu'))\n    call assert_true(matchcount > 0)\n    let matchcount = len(getcompletion('File.', 'menu'))\n    call assert_true(matchcount > 0)\n  endif\n\n  let l = getcompletion('v:n', 'var')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('v:notexists', 'var')\n  call assert_equal([], l)\n\n  args a.c b.c\n  let l = getcompletion('', 'arglist')\n  call assert_equal(['a.c', 'b.c'], l)\n  let l = getcompletion('a.', 'buffer')\n  call assert_equal(['a.c'], l)\n  %argdelete\n\n  let l = getcompletion('', 'augroup')\n  call assert_true(index(l, 'END') >= 0)\n  let l = getcompletion('blahblah', 'augroup')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'behave')\n  call assert_true(index(l, 'mswin') >= 0)\n  let l = getcompletion('not', 'behave')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'color')\n  call assert_true(index(l, 'default') >= 0)\n  let l = getcompletion('dirty', 'color')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'command')\n  call assert_true(index(l, 'sleep') >= 0)\n  let l = getcompletion('awake', 'command')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'dir')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('NoMatch', 'dir')\n  call assert_equal([], l)\n\n  if glob('~/*') !=# ''\n    let l = getcompletion('~/', 'dir')\n    call assert_true(l[0][0] ==# '~')\n  endif\n\n  let l = getcompletion('exe', 'expression')\n  call assert_true(index(l, 'executable(') >= 0)\n  let l = getcompletion('kill', 'expression')\n  call assert_equal([], l)\n\n  let l = getcompletion('tag', 'function')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('paint', 'function')\n  call assert_equal([], l)\n\n  let Flambda = {-> 'hello'}\n  let l = getcompletion('', 'function')\n  let l = filter(l, {i, v -> v =~ 'lambda'})\n  call assert_equal([], l)\n\n  let l = getcompletion('run', 'file')\n  call assert_true(index(l, 'runtest.vim') >= 0)\n  let l = getcompletion('walk', 'file')\n  call assert_equal([], l)\n  set wildignore=*.vim\n  let l = getcompletion('run', 'file', 1)\n  call assert_true(index(l, 'runtest.vim') < 0)\n  set wildignore&\n  \" Directory name with space character\n  call mkdir('Xdir with space', 'D')\n  call assert_equal(['Xdir with space/'], getcompletion('Xdir\\ w', 'shellcmd'))\n  call assert_equal(['./Xdir with space/'], getcompletion('./Xdir', 'shellcmd'))\n\n  let l = getcompletion('ha', 'filetype')\n  call assert_true(index(l, 'hamster') >= 0)\n  let l = getcompletion('horse', 'filetype')\n  call assert_equal([], l)\n\n  let l = getcompletion('z', 'syntax')\n  call assert_true(index(l, 'zimbu') >= 0)\n  let l = getcompletion('emacs', 'syntax')\n  call assert_equal([], l)\n\n  let l = getcompletion('jikes', 'compiler')\n  call assert_true(index(l, 'jikes') >= 0)\n  let l = getcompletion('break', 'compiler')\n  call assert_equal([], l)\n\n  let l = getcompletion('last', 'help')\n  call assert_true(index(l, ':tablast') >= 0)\n  let l = getcompletion('giveup', 'help')\n  call assert_equal([], l)\n\n  let l = getcompletion('time', 'option')\n  call assert_true(index(l, 'timeoutlen') >= 0)\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n\n  let l = getcompletion('er', 'highlight')\n  call assert_true(index(l, 'ErrorMsg') >= 0)\n  let l = getcompletion('dark', 'highlight')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'messages')\n  call assert_true(index(l, 'clear') >= 0)\n  let l = getcompletion('not', 'messages')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'mapclear')\n  call assert_true(index(l, '<buffer>') >= 0)\n  let l = getcompletion('not', 'mapclear')\n  call assert_equal([], l)\n\n  let l = getcompletion('.', 'shellcmd')\n  call assert_equal(['./', '../'], filter(l, 'v:val =~ \"\\\\./\"'))\n  call assert_equal(-1, match(l[2:], '^\\.\\.\\?/$'))\n  let root = has('win32') ? 'C:\\\\' : '/'\n  let l = getcompletion(root, 'shellcmd')\n  let expected = map(filter(glob(root . '*', 0, 1),\n        \\ 'isdirectory(v:val) || executable(v:val)'), 'isdirectory(v:val) ? v:val . ''/'' : v:val')\n  call assert_equal(expected, l)\n\n  if has('cscope')\n    let l = getcompletion('', 'cscope')\n    let cmds = ['add', 'find', 'help', 'kill', 'reset', 'show']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":cscope find \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'cscope')\n    call assert_equal(cmds, l)\n    let keys = ['a', 'c', 'd', 'e', 'f', 'g', 'i', 's', 't']\n    let l = getcompletion('find ', 'cscope')\n    call assert_equal(keys, l)\n  endif\n\n  if has('signs')\n    sign define Testing linehl=Comment\n    let l = getcompletion('', 'sign')\n    let cmds = ['define', 'jump', 'list', 'place', 'undefine', 'unplace']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":sign list \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'sign')\n    call assert_equal(cmds, l)\n    let l = getcompletion('list ', 'sign')\n    call assert_equal(['Testing'], l)\n    let l = getcompletion('de*', 'sign')\n    call assert_equal(['define'], l)\n    let l = getcompletion('p?', 'sign')\n    call assert_equal(['place'], l)\n    let l = getcompletion('j.', 'sign')\n    call assert_equal(['jump'], l)\n  endif\n\n  \" Command line completion tests\n  let l = getcompletion('cd ', 'cmdline')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('cd NoMatch', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('let v:n', 'cmdline')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('let v:notexists', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('call tag', 'cmdline')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('call paint', 'cmdline')\n  call assert_equal([], l)\n\n  func T(a, c, p)\n    let g:cmdline_compl_params = [a:a, a:c, a:p]\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n  let l = getcompletion('MyCmd ', 'cmdline')\n  call assert_equal(['oneA', 'oneB', 'oneC'], l)\n  call assert_equal(['', 'MyCmd ', 6], g:cmdline_compl_params)\n\n  delcommand MyCmd\n  delfunc T\n  unlet g:cmdline_compl_params\n\n  \" For others test if the name is recognized.\n  let names = ['buffer', 'environment', 'file_in_path', 'mapping', 'tag', 'tag_listfiles', 'user']\n  if has('cmdline_hist')\n    call add(names, 'history')\n  endif\n  if has('gettext')\n    call add(names, 'locale')\n  endif\n  if has('profile')\n    call add(names, 'syntime')\n  endif\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\", \"word\\tfile\\tcmd\"], 'Xtags', 'D')\n\n  for name in names\n    let matchcount = len(getcompletion('', name))\n    call assert_true(matchcount >= 0, 'No matches for ' . name)\n  endfor\n\n  set tags&\n\n  edit a~b\n  enew\n  call assert_equal(['a~b'], getcompletion('a~', 'buffer'))\n  bw a~b\n\n  if has('unix')\n    edit Xtest\\\n    enew\n    call assert_equal(['Xtest\\'], getcompletion('Xtest\\', 'buffer'))\n    bw Xtest\\\n  endif\n\n  call assert_fails(\"call getcompletion('\\\\\\\\@!\\\\\\\\@=', 'buffer')\", 'E871:')\n  call assert_fails('call getcompletion(\"\", \"burp\")', 'E475:')\n  call assert_fails('call getcompletion(\"abc\", [])', 'E1174:')\nendfunc\n\n\" Test for getcompletion() with \"fuzzy\" in 'wildoptions'\nfunc Test_getcompletion_wildoptions()\n  let save_wildoptions = &wildoptions\n  set wildoptions&\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n  let l = getcompletion('ier', 'command')\n  call assert_equal([], l)\n  set wildoptions=fuzzy\n  let l = getcompletion('space', 'option')\n  call assert_true(index(l, 'backspace') >= 0)\n  let l = getcompletion('ier', 'command')\n  call assert_true(index(l, 'compiler') >= 0)\n  let &wildoptions = save_wildoptions\nendfunc\n\nfunc Test_complete_autoload_error()\n  let save_rtp = &rtp\n  let lines =<< trim END\n      vim9script\n      export def Complete(..._): string\n        return 'match'\n      enddef\n      echo this will cause an error\n  END\n  call mkdir('Xdir/autoload', 'pR')\n  call writefile(lines, 'Xdir/autoload/script.vim')\n  exe 'set rtp+=' .. getcwd() .. '/Xdir'\n\n  let lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      command -nargs=* -complete=custom,script.Complete Cmd eval 0 + 0\n      &wildcharm = char2nr(\"\\<Tab>\")\n      feedkeys(\":Cmd \\<Tab>\", 'xt')\n  END\n  call v9.CheckScriptFailure(lines, 'E121: Undefined variable: this')\n\n  let &rtp = save_rtp\nendfunc\n\nfunc Test_fullcommand()\n  let tests = {\n        \\ '':           '',\n        \\ ':':          '',\n        \\ ':::':        '',\n        \\ ':::5':       '',\n        \\ 'not_a_cmd':  '',\n        \\ 'Check':      '',\n        \\ 'syntax':     'syntax',\n        \\ ':syntax':    'syntax',\n        \\ '::::syntax': 'syntax',\n        \\ 'sy':         'syntax',\n        \\ 'syn':        'syntax',\n        \\ 'synt':       'syntax',\n        \\ ':sy':        'syntax',\n        \\ '::::sy':     'syntax',\n        \\ 'match':      'match',\n        \\ '2match':     'match',\n        \\ '3match':     'match',\n        \\ 'aboveleft':  'aboveleft',\n        \\ 'abo':        'aboveleft',\n        \\ 'en':         'endif',\n        \\ 'end':        'endif',\n        \\ 'endi':        'endif',\n        \\ 's':          'substitute',\n        \\ '5s':         'substitute',\n        \\ ':5s':        'substitute',\n        \\ \"'<,'>s\":     'substitute',\n        \\ \":'<,'>s\":    'substitute',\n        \\ 'CheckLin':   'CheckLinux',\n        \\ 'CheckLinux': 'CheckLinux',\n  \\ }\n\n  for [in, want] in items(tests)\n    call assert_equal(want, fullcommand(in))\n  endfor\n  call assert_equal('', fullcommand(test_null_string()))\n\n  call assert_equal('syntax', 'syn'->fullcommand())\n\n  command -buffer BufferLocalCommand :\n  command GlobalCommand :\n  call assert_equal('GlobalCommand', fullcommand('GlobalCom'))\n  call assert_equal('BufferLocalCommand', fullcommand('BufferL'))\n  delcommand BufferLocalCommand\n  delcommand GlobalCommand\nendfunc\n\nfunc Test_shellcmd_completion()\n  let save_path = $PATH\n\n  call mkdir('Xpathdir/Xpathsubdir', 'pR')\n  call writefile([''], 'Xpathdir/Xfile.exe')\n  call setfperm('Xpathdir/Xfile.exe', 'rwx------')\n\n  \" Set PATH to example directory without trailing slash.\n  let $PATH = getcwd() . '/Xpathdir'\n\n  \" Test for the \":!<TAB>\" case.  Previously, this would include subdirs of\n  \" dirs in the PATH, even though they won't be executed.  We check that only\n  \" subdirs of the PWD and executables from the PATH are included in the\n  \" suggestions.\n  let actual = getcompletion('X', 'shellcmd')\n  let expected = map(filter(glob('*', 0, 1), 'isdirectory(v:val) && v:val[0] == \"X\"'), 'v:val . \"/\"')\n  call insert(expected, 'Xfile.exe')\n  call assert_equal(expected, actual)\n\n  let $PATH = save_path\nendfunc\n\nfunc Test_expand_star_star()\n  call mkdir('a/b', 'pR')\n  call writefile(['asdfasdf'], 'a/b/fileXname')\n  call feedkeys(\":find **/fileXname\\<Tab>\\<CR>\", 'xt')\n  call assert_equal('find a/b/fileXname', @:)\n  bwipe!\nendfunc\n\nfunc Test_cmdline_paste()\n  let @a = \"def\"\n  call feedkeys(\":abc \\<C-R>a ghi\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"abc def ghi', @:)\n\n  new\n  call setline(1, 'asdf.x /tmp/some verylongword a;b-c*d ')\n\n  call feedkeys(\":aaa \\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa asdf bbb', @:)\n\n  call feedkeys(\"ft:aaa \\<C-R>\\<C-F> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa /tmp/some bbb', @:)\n\n  call feedkeys(\":aaa \\<C-R>\\<C-L> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa '.getline(1).' bbb', @:)\n\n  set incsearch\n  call feedkeys(\"fy:aaa veryl\\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa verylongword bbb', @:)\n\n  call feedkeys(\"f;:aaa \\<C-R>\\<C-A> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa a;b-c*d bbb', @:)\n\n  call feedkeys(\":\\<C-\\>etoupper(getline(1))\\<CR>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"ASDF.X /TMP/SOME VERYLONGWORD A;B-C*D ', @:)\n  bwipe!\n\n  \" Error while typing a command used to cause that it was not executed\n  \" in the end.\n  new\n  try\n    call feedkeys(\":file \\<C-R>%Xtestfile\\<CR>\", 'tx')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E32/\n    \" ignore error E32\n  endtry\n  call assert_equal(\"Xtestfile\", bufname(\"%\"))\n\n  \" Try to paste an invalid register using <C-R>\n  call feedkeys(\":\\\"one\\<C-R>\\<C-X>two\\<CR>\", 'xt')\n  call assert_equal('\"onetwo', @:)\n\n  \" Test for pasting register containing CTRL-H using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-H>z\"\n  call feedkeys(\":\\\"\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal('\"xz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-O>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n\n  \" Test for pasting register containing CTRL-V using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-V>z\"\n  call feedkeys(\":\\\"\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal('\"xyz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-V>z\", @:)\n\n  call assert_beeps('call feedkeys(\":\\<C-R>=\\<C-R>=\\<Esc>\", \"xt\")')\n\n  bwipe!\nendfunc\n\nfunc Test_cmdline_remove_char()\n  let encoding_save = &encoding\n\n  for e in ['utf8', 'latin1']\n    exe 'set encoding=' . e\n\n    call feedkeys(\":abc def\\<S-Left>\\<Del>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ef', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<BS>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abcdef', @:)\n\n    call feedkeys(\":abc def ghi\\<S-Left>\\<C-W>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ghi', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<C-U>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"def', @:, e)\n\n    \" This was going before the start in latin1.\n    call feedkeys(\": \\<C-W>\\<CR>\", 'tx')\n  endfor\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdline_keymap_ctrl_hat()\n  CheckFeature keymap\n\n  set keymap=esperanto\n  call feedkeys(\":\\\"Jxauxdo \\<C-^>Jxauxdo \\<C-^>Jxauxdo\\<CR>\", 'tx')\n  call assert_equal('\"Jxauxdo \u0134a\u016ddo Jxauxdo', @:)\n  set keymap=\nendfunc\n\nfunc Test_illegal_address1()\n  new\n  2;'(\n  2;')\n  quit\nendfunc\n\nfunc Test_illegal_address2()\n  call writefile(['c', 'x', '  x', '.', '1;y'], 'Xtest.vim', 'D')\n  new\n  source Xtest.vim\n  \" Trigger calling validate_cursor()\n  diffsp Xtest.vim\n  quit!\n  bwipe!\nendfunc\n\nfunc Test_mark_from_line_zero()\n  \" this was reading past the end of the first (empty) line\n  new\n  norm oxxxx\n  call assert_fails(\"0;'(\", 'E20:')\n  bwipe!\nendfunc\n\nfunc Test_cmdline_complete_wildoptions()\n  help\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let a = join(sort(split(@:)),' ')\n  set wildoptions=tagfile\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let b = join(sort(split(@:)),' ')\n  call assert_equal(a, b)\n  bw!\nendfunc\n\nfunc Test_cmdline_complete_user_cmd()\n  command! -complete=color -nargs=1 Foo :\n  call feedkeys(\":Foo \\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo a b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo a blue', @:)\n  call feedkeys(\":Foo b\\\\\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\', @:)\n  call feedkeys(\":Foo b\\\\x\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\x', @:)\n  delcommand Foo\n\n  redraw\n  call assert_equal('~', Screenline(&lines - 1))\n  command! FooOne :\n  command! FooTwo :\n\n  set nowildmenu\n  call feedkeys(\":Foo\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"FooOne', @:)\n  call assert_equal('~', Screenline(&lines - 1))\n\n  call feedkeys(\":Foo\\<S-Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"FooTwo', @:)\n  call assert_equal('~', Screenline(&lines - 1))\n\n  delcommand FooOne\n  delcommand FooTwo\n  set wildmenu&\nendfunc\n\nfunc Test_complete_user_cmd()\n  command FooBar echo 'global'\n  command -buffer FooBar echo 'local'\n  call feedkeys(\":Foo\\<C-A>\\<Home>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"FooBar', @:)\n\n  delcommand -buffer FooBar\n  delcommand FooBar\nendfunc\n\nfunc s:ScriptLocalFunction()\n  echo 'yes'\nendfunc\n\nfunc Test_cmdline_complete_user_func()\n  call feedkeys(\":func Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func Test_cmdline_complete_user_', @:)\n  call feedkeys(\":func s:ScriptL\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func <SNR>\\d\\+_ScriptLocalFunction', @:)\n\n  \" g: prefix also works\n  call feedkeys(\":echo g:Test_cmdline_complete_user_f\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:Test_cmdline_complete_user_func', @:)\n\n  \" using g: prefix does not result in just \"g:\" matches from a lambda\n  let Fx = { a ->  a }\n  call feedkeys(\":echo g:\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:[A-Z]', @:)\n\n  \" existence of script-local dict function does not break user function name\n  \" completion\n  function s:a_dict_func() dict\n  endfunction\n  call feedkeys(\":call Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"call Test_cmdline_complete_user_', @:)\n  delfunction s:a_dict_func\nendfunc\n\nfunc Test_cmdline_complete_user_names()\n  if has('unix') && executable('whoami')\n    let whoami = systemlist('whoami')[0]\n    let first_letter = whoami[0]\n    if len(first_letter) > 0\n      \" Trying completion of  :e ~x  where x is the first letter of\n      \" the user name should complete to at least the user name.\n      call feedkeys(':e ~' . first_letter . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*\\<' . whoami . '\\>', @:)\n    endif\n  elseif has('win32')\n    \" Just in case: check that the system has an Administrator account.\n    let names = system('net user')\n    if names =~ 'Administrator'\n      \" Trying completion of  :e ~A  should complete to Administrator.\n      \" There could be other names starting with \"A\" before Administrator.\n      call feedkeys(':e ~A' . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*Administrator', @:)\n    endif\n  else\n    throw 'Skipped: does not work on this platform'\n  endif\nendfunc\n\nfunc Test_cmdline_complete_bang()\n  CheckExecutable whoami\n  call feedkeys(\":!whoam\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('^\".*\\<whoami\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_languages()\n  let lang = substitute(execute('language time'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lc_time)\n\n  let lang = substitute(execute('language ctype'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:ctype)\n\n  let lang = substitute(execute('language collate'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:collate)\n\n  let lang = substitute(execute('language messages'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lang)\n\n  call feedkeys(\":language \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<collate\\>.*\\<ctype\\>.*\\<messages\\>.*\\<time\\>', @:)\n\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language messages \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language ctype \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language time \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language collate \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_env_variable()\n  let $X_VIM_TEST_COMPLETE_ENV = 'foo'\n  call feedkeys(\":edit $X_VIM_TEST_COMPLETE_E\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"edit $X_VIM_TEST_COMPLETE_ENV', @:)\n  unlet $X_VIM_TEST_COMPLETE_ENV\nendfunc\n\nfunc Test_cmdline_complete_expression()\n  let g:SomeVar = 'blah'\n  for cmd in ['exe', 'echo', 'echon', 'echomsg']\n    call feedkeys(\":\" .. cmd .. \" SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' SomeVar', @:)\n    call feedkeys(\":\" .. cmd .. \" foo SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' foo SomeVar', @:)\n  endfor\n  unlet g:SomeVar\nendfunc\n\n\" Unique function name for completion below\nfunc s:WeirdFunc()\n  echo 'weird'\nendfunc\n\n\" Test for various command-line completion\nfunc Test_cmdline_complete_various()\n  \" completion for a command starting with a comment\n  call feedkeys(\": :|\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\" :|\\\"\\<C-A>\", @:)\n\n  \" completion for a range followed by a comment\n  call feedkeys(\":1,2\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"1,2\\\"\\<C-A>\", @:)\n\n  \" completion for :k command\n  call feedkeys(\":ka\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ka\\<C-A>\", @:)\n\n  \" completion for short version of the :s command\n  call feedkeys(\":sI \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"sI \\<C-A>\", @:)\n\n  \" completion for :write command\n  call mkdir('Xcwdir', 'R')\n  call writefile(['one'], 'Xcwdir/Xfile1')\n  let save_cwd = getcwd()\n  cd Xcwdir\n  call feedkeys(\":w >> \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w >> Xfile1\", @:)\n  call chdir(save_cwd)\n\n  \" completion for :w ! and :r ! commands\n  call feedkeys(\":w !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w !invalid_xyz_cmd\", @:)\n  call feedkeys(\":r !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"r !invalid_xyz_cmd\", @:)\n\n  \" completion for :>> and :<< commands\n  call feedkeys(\":>>>\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\">>>\\<C-A>\", @:)\n  call feedkeys(\":<<<\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"<<<\\<C-A>\", @:)\n\n  \" completion for command with +cmd argument\n  call feedkeys(\":buffer +/pat Xabc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat Xabc\", @:)\n  call feedkeys(\":buffer +/pat\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat\\<C-A>\", @:)\n\n  \" completion for a command with a trailing comment\n  call feedkeys(\":ls \\\" comment\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\\" comment\\<C-A>\", @:)\n\n  \" completion for a command with a trailing command\n  call feedkeys(\":ls | ls\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls | ls\", @:)\n\n  \" completion for a command with an CTRL-V escaped argument\n  call feedkeys(\":ls \\<C-V>\\<C-V>a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\<C-V>a\\<C-A>\", @:)\n\n  \" completion for a command that doesn't take additional arguments\n  call feedkeys(\":all abc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"all abc\\<C-A>\", @:)\n\n  \" completion for :wincmd with :horizontal modifier\n  call feedkeys(\":horizontal wincm\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"horizontal wincmd\", @:)\n\n  \" completion for a command with a command modifier\n  call feedkeys(\":topleft new\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"topleft new\", @:)\n\n  \" completion for vim9 and legacy commands\n  call feedkeys(\":vim9 call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"vim9 call strlen(\", @:)\n  call feedkeys(\":legac call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"legac call strlen(\", @:)\n\n  \" completion for the :disassemble command\n  call feedkeys(\":disas deb\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug\", @:)\n  call feedkeys(\":disas pro\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile\", @:)\n  call feedkeys(\":disas debug Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas profile Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas Test_cmdline_complete_various\", @:)\n\n  call feedkeys(\":disas s:WeirdF\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_WeirdFunc', @:)\n\n  call feedkeys(\":disas \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_', @:)\n  call feedkeys(\":disas debug \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas debug <SNR>\\d\\+_', @:)\n\n  \" completion for the :match command\n  call feedkeys(\":match Search /pat/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"match Search /pat/\\<C-A>\", @:)\n\n  \" completion for the :doautocmd command\n  call feedkeys(\":doautocmd User MyCmd a.c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd User MyCmd a.c\\<C-A>\", @:)\n\n  \" completion of autocmd group after comma\n  call feedkeys(\":doautocmd BufNew,BufEn\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufNew,BufEnter\", @:)\n\n  \" completion of file name in :doautocmd\n  call writefile([], 'Xvarfile1', 'D')\n  call writefile([], 'Xvarfile2', 'D')\n  call feedkeys(\":doautocmd BufEnter Xvarfi\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufEnter Xvarfile1 Xvarfile2\", @:)\n\n  \" completion for the :augroup command\n  augroup XTest.test\n  augroup END\n  call feedkeys(\":augroup X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"augroup XTest.test\", @:)\n\n  \" group name completion in :autocmd\n  call feedkeys(\":au X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n  call feedkeys(\":au XTest.test\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n\n  augroup! XTest.test\n\n  \" autocmd pattern completion\n  call feedkeys(\":au BufEnter *.py\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au BufEnter *.py\\t\", @:)\n\n  \" completion for the :unlet command\n  call feedkeys(\":unlet one two\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"unlet one two\", @:)\n\n  \" completion for the :buffer command with curlies\n  \" FIXME: what should happen on MS-Windows?\n  if !has('win32')\n    edit \\{someFile}\n    call feedkeys(\":buf someFile\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"buf {someFile}\", @:)\n    bwipe {someFile}\n  endif\n\n  \" completion for the :bdelete command\n  call feedkeys(\":bdel a b c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"bdel a b c\", @:)\n\n  \" completion for the :mapclear command\n  call feedkeys(\":mapclear \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"mapclear <buffer>\", @:)\n\n  \" completion for user defined commands with menu names\n  menu Test.foo :ls<CR>\n  com -nargs=* -complete=menu MyCmd\n  call feedkeys(\":MyCmd Te\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd Test.', @:)\n  delcom MyCmd\n  unmenu Test\n\n  \" completion for user defined commands with mappings\n  mapclear\n  map <F3> :ls<CR>\n  com -nargs=* -complete=mapping MyCmd\n  call feedkeys(\":MyCmd <F\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd <F3> <F4>', @:)\n  mapclear\n  delcom MyCmd\n\n  \" completion for :set path= with multiple backslashes\n  call feedkeys(\":set path=a\\\\\\\\\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set path=a\\\\\\ b', @:)\n\n  \" completion for :set dir= with a backslash\n  call feedkeys(\":set dir=a\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set dir=a\\ b', @:)\n\n  \" completion for the :py3 commands\n  call feedkeys(\":py3\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3 py3do py3file', @:)\n\n  \" completion for the :vim9 commands\n  call feedkeys(\":vim9\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"vim9cmd vim9script', @:)\n\n  \" redir @\" is not the start of a comment. So complete after that\n  call feedkeys(\":redir @\\\" | cwin\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"redir @\" | cwindow', @:)\n\n  \" completion after a backtick\n  call feedkeys(\":e `a1b2c\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e `a1b2c', @:)\n\n  \" completion for :language command with an invalid argument\n  call feedkeys(\":language dummy \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"language dummy \\t\", @:)\n\n  \" completion for commands after a :global command\n  call feedkeys(\":g/a\\\\xb/clearj\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n\n  \" completion with ambiguous user defined commands\n  com TCmd1 echo 'TCmd1'\n  com TCmd2 echo 'TCmd2'\n  call feedkeys(\":TCmd \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"TCmd ', @:)\n  delcom TCmd1\n  delcom TCmd2\n\n  \" completion after a range followed by a pipe (|) character\n  call feedkeys(\":1,10 | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"1,10 | chistory', @:)\n\n  \" completion after a :global command\n  call feedkeys(\":g/a/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a/chistory', @:)\n  call feedkeys(\":g/a\\\\/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"g/a\\\\/chist\\t\", @:)\n\n  \" use <Esc> as the 'wildchar' for completion\n  set wildchar=<Esc>\n  call feedkeys(\":g/a\\\\xb/clearj\\<Esc>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  \" pressing <esc> twice should cancel the command\n  call feedkeys(\":chist\\<Esc>\\<Esc>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  set wildchar&\n\n  if has('unix')\n    \" should be able to complete a file name that starts with a '~'.\n    call writefile([], '~Xtest')\n    call feedkeys(\":e \\\\~X\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\~Xtest', @:)\n    call delete('~Xtest')\n\n    \" should be able to complete a file name that has a '*'\n    call writefile([], 'Xx*Yy')\n    call feedkeys(\":e Xx\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xx\\*Yy', @:)\n    call delete('Xx*Yy')\n\n    \" use a literal star\n    call feedkeys(\":e \\\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\*', @:)\n  endif\n\n  call feedkeys(\":py3f\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3file', @:)\nendfunc\n\n\" Test for 'wildignorecase'\nfunc Test_cmdline_wildignorecase()\n  CheckUnix\n  call writefile([], 'XTEST', 'D')\n  set wildignorecase\n  call feedkeys(\":e xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e XTEST', @:)\n  call assert_equal(['XTEST'], getcompletion('xt', 'file'))\n  let g:Sline = ''\n  call feedkeys(\":e xt\\<C-d>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e xt', @:)\n  call assert_equal('XTEST', g:Sline)\n  set wildignorecase&\nendfunc\n\nfunc Test_cmdline_write_alternatefile()\n  new\n  call setline('.', ['one', 'two'])\n  f foo.txt\n  new\n  f #-A\n  call assert_equal('foo.txt-A', expand('%'))\n  f #<-B.txt\n  call assert_equal('foo-B.txt', expand('%'))\n  f %<\n  call assert_equal('foo-B', expand('%'))\n  new\n  call assert_fails('f #<', 'E95:')\n  bw!\n  f foo-B.txt\n  f %<-A\n  call assert_equal('foo-B-A', expand('%'))\n  bw!\n  bw!\nendfunc\n\nfunc Test_cmdline_expand_cur_alt_file()\n  enew\n  file http://some.com/file.txt\n  call feedkeys(\":e %\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e http://some.com/file.txt', @:)\n  edit another\n  call feedkeys(\":e #\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e http://some.com/file.txt', @:)\n  bwipe\n  bwipe http://some.com/file.txt\nendfunc\n\n\" using a leading backslash here\nset cpo+=C\n\nfunc Test_cmdline_search_range()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  /d\n  1,\\/s/b/B/\n  call assert_equal('B', getline(2))\n\n  /a\n  $\n  \\?,4s/c/C/\n  call assert_equal('C', getline(3))\n\n  call setline(1, ['a', 'b', 'c', 'd'])\n  %s/c/c/\n  1,\\&s/b/B/\n  call assert_equal('B', getline(2))\n\n  let @/ = 'apple'\n  call assert_fails('\\/print', ['E486:.*apple'])\n\n  bwipe!\nendfunc\n\n\" Test for the tick mark (') in an excmd range\nfunc Test_tick_mark_in_range()\n  \" If only the tick is passed as a range and no command is specified, there\n  \" should not be an error\n  call feedkeys(\":'\\<CR>\", 'xt')\n  call assert_equal(\"'\", @:)\n  call assert_fails(\"',print\", 'E78:')\nendfunc\n\n\" Test for using a line number followed by a search pattern as range\nfunc Test_lnum_and_pattern_as_range()\n  new\n  call setline(1, ['foo 1', 'foo 2', 'foo 3'])\n  let @\" = ''\n  2/foo/yank\n  call assert_equal(\"foo 3\\n\", @\")\n  call assert_equal(1, line('.'))\n  close!\nendfunc\n\n\" Tests for getcmdline(), getcmdpos() and getcmdtype()\nfunc Check_cmdline(cmdtype)\n  call assert_equal('MyCmd a', getcmdline())\n  call assert_equal(8, getcmdpos())\n  call assert_equal(a:cmdtype, getcmdtype())\n  return ''\nendfunc\n\nset cpo&\n\nfunc Test_getcmdtype()\n  call feedkeys(\":MyCmd a\\<C-R>=Check_cmdline(':')\\<CR>\\<Esc>\", \"xt\")\n\n  let cmdtype = ''\n  debuggreedy\n  call feedkeys(\":debug echo 'test'\\<CR>\", \"t\")\n  call feedkeys(\"let cmdtype = \\<C-R>=string(getcmdtype())\\<CR>\\<CR>\", \"t\")\n  call feedkeys(\"cont\\<CR>\", \"xt\")\n  0debuggreedy\n  call assert_equal('>', cmdtype)\n\n  call feedkeys(\"/MyCmd a\\<C-R>=Check_cmdline('/')\\<CR>\\<Esc>\", \"xt\")\n  call feedkeys(\"?MyCmd a\\<C-R>=Check_cmdline('?')\\<CR>\\<Esc>\", \"xt\")\n\n  call feedkeys(\":call input('Answer?')\\<CR>\", \"t\")\n  call feedkeys(\"MyCmd a\\<C-R>=Check_cmdline('@')\\<CR>\\<C-C>\", \"xt\")\n\n  call feedkeys(\":insert\\<CR>MyCmd a\\<C-R>=Check_cmdline('-')\\<CR>\\<Esc>\", \"xt\")\n\n  cnoremap <expr> <F6> Check_cmdline('=')\n  call feedkeys(\"a\\<C-R>=MyCmd a\\<F6>\\<Esc>\\<Esc>\", \"xt\")\n  cunmap <F6>\n\n  call assert_equal('', getcmdline())\nendfunc\n\nfunc Test_verbosefile()\n  set verbosefile=Xlog\n  echomsg 'foo'\n  echomsg 'bar'\n  set verbosefile=\n  let log = readfile('Xlog')\n  call assert_match(\"foo\\nbar\", join(log, \"\\n\"))\n  call delete('Xlog')\n\n  call mkdir('Xdir', 'D')\n  call assert_fails('set verbosefile=Xdir', ['E484:.*Xdir', 'E474:'])\nendfunc\n\nfunc Test_verbose_option()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    command DoSomething echo 'hello' |set ts=4 |let v = '123' |echo v\n    call feedkeys(\"\\r\", 't') \" for the hit-enter prompt\n    set verbose=20\n  [SCRIPT]\n  call writefile(lines, 'XTest_verbose', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_verbose', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":DoSomething\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_verbose_option_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_setcmdpos()\n  func InsertTextAtPos(text, pos)\n    call assert_equal(0, setcmdpos(a:pos))\n    return a:text\n  endfunc\n\n  \" setcmdpos() with position in the middle of the command line.\n  call feedkeys(\":\\\"12\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1ab2', @:)\n\n  call feedkeys(\":\\\"12\\<C-R>\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1b2a', @:)\n\n  \" setcmdpos() with position beyond the end of the command line.\n  call feedkeys(\":\\\"12\\<C-B>\\<C-R>=InsertTextAtPos('a', 10)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"12ab', @:)\n\n  \" setcmdpos() returns 1 when not editing the command line.\n  call assert_equal(1, 3->setcmdpos())\nendfunc\n\nfunc Test_cmdline_overstrike()\n  let encodings = ['latin1', 'utf8']\n  let encoding_save = &encoding\n\n  for e in encodings\n    exe 'set encoding=' . e\n\n    \" Test overstrike in the middle of the command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cd4', @:, e)\n\n    \" Test overstrike going beyond end of command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cdefgh\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cdefgh', @:, e)\n\n    \" Test toggling insert/overstrike a few times.\n    call feedkeys(\":\\\"01234\\<home>\\<right>ab\\<right>\\<insert>cd\\<right>\\<insert>ef\\<enter>\", 'xt')\n    call assert_equal('\"ab0cd3ef4', @:, e)\n  endfor\n\n  \" Test overstrike with multi-byte characters.\n  call feedkeys(\":\\\"\u30c6\u30ad\u30b9\u30c8\u30a8\u30c7\u30a3\u30bf\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n  call assert_equal('\"\u30c6ab\u30adcd\u30a8\u30c7\u30a3\u30bf', @:, e)\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_buffers_lastused()\n  \" check that buffers are sorted by time when wildmode has lastused\n  call test_settime(1550020000)\t  \" middle\n  edit bufa\n  enew\n  call test_settime(1550030000)\t  \" newest\n  edit bufb\n  enew\n  call test_settime(1550010000)\t  \" oldest\n  edit bufc\n  enew\n  call test_settime(0)\n  enew\n\n  call assert_equal(['bufa', 'bufb', 'bufc'],\n\t\\ getcompletion('', 'buffer'))\n\n  let save_wildmode = &wildmode\n  set wildmode=full:lastused\n\n  let cap = \"\\<c-r>=execute('let X=getcmdline()')\\<cr>\"\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  edit other\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  let &wildmode = save_wildmode\n\n  bwipeout bufa\n  bwipeout bufb\n  bwipeout bufc\nendfunc\n\nfunc Test_cmdlineclear_tabenter()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    call setline(1, range(30))\n  [SCRIPT]\n\n  call writefile(lines, 'XtestCmdlineClearTabenter', 'D')\n  let buf = RunVimInTerminal('-S XtestCmdlineClearTabenter', #{rows: 10})\n  call TermWait(buf, 25)\n  \" in one tab make the command line higher with CTRL-W -\n  call term_sendkeys(buf, \":tabnew\\<cr>\\<C-w>-\\<C-w>-gtgt\")\n  call VerifyScreenDump(buf, 'Test_cmdlineclear_tabenter', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for expanding special keywords in cmdline\nfunc Test_cmdline_expand_special()\n  %bwipe!\n  call assert_fails('e #', 'E194:')\n  call assert_fails('e <afile>', 'E495:')\n  call assert_fails('e <abuf>', 'E496:')\n  call assert_fails('e <amatch>', 'E497:')\n\n  call writefile([], 'Xfile.cpp', 'D')\n  call writefile([], 'Xfile.java', 'D')\n  new Xfile.cpp\n  call feedkeys(\":e %:r\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.cpp Xfile.java', @:)\n  close\nendfunc\n\n\" Test for backtick expression in the command line\nfunc Test_cmd_backtick()\n  %argd\n  argadd `=['a', 'b', 'c']`\n  call assert_equal(['a', 'b', 'c'], argv())\n  %argd\n\n  argadd `echo abc def`\n  call assert_equal(['abc def'], argv())\n  %argd\nendfunc\n\n\" Test for the :! command\nfunc Test_cmd_bang()\n  CheckUnix\n\n  let lines =<< trim [SCRIPT]\n    \" Test for no previous command\n    call assert_fails('!!', 'E34:')\n    set nomore\n    \" Test for cmdline expansion with :!\n    call setline(1, 'foo!')\n    silent !echo <cWORD> > Xfile.out\n    call assert_equal(['foo!'], readfile('Xfile.out'))\n    \" Test for using previous command\n    silent !echo \\! !\n    call assert_equal(['! echo foo!'], readfile('Xfile.out'))\n    call writefile(v:errors, 'Xresult')\n    call delete('Xfile.out')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xresult')\nendfunc\n\n\" Test error: \"E135: *Filter* Autocommands must not change current buffer\"\nfunc Test_cmd_bang_E135()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  augroup test_cmd_filter_E135\n    au!\n    autocmd FilterReadPost * help\n  augroup END\n  call assert_fails('2,3!echo \"x\"', 'E135:')\n\n  augroup test_cmd_filter_E135\n    au!\n  augroup END\n  %bwipe!\nendfunc\n\nfunc Test_cmd_bang_args()\n  new\n  :.!\n  call assert_equal(0, v:shell_error)\n\n  \" Note that below there is one space char after the '!'.  This caused a\n  \" shell error in the past, see https://github.com/vim/vim/issues/11495.\n  :.! \n  call assert_equal(0, v:shell_error)\n  bwipe!\n\n  CheckUnix\n  :.!pwd\n  call assert_equal(0, v:shell_error)\n  :.! pwd\n  call assert_equal(0, v:shell_error)\n\n  \" Note there is one space after 'pwd'.\n  :.! pwd \n  call assert_equal(0, v:shell_error)\n\n  \" Note there are two spaces after 'pwd'.\n  :.!  pwd  \n  call assert_equal(0, v:shell_error)\n  :.!ls ~\n  call assert_equal(0, v:shell_error)\n\n  \" Note there is one space char after '~'.\n  :.!ls  ~ \n  call assert_equal(0, v:shell_error)\n\n  \" Note there are two spaces after '~'.\n  :.!ls  ~  \n  call assert_equal(0, v:shell_error)\n\n  :.!echo \"foo\"\n  call assert_equal(getline('.'), \"foo\")\n  :.!echo \"foo  \"\n  call assert_equal(getline('.'), \"foo  \")\n  :.!echo \" foo  \"\n  call assert_equal(getline('.'), \" foo  \")\n  :.!echo  \" foo  \"\n  call assert_equal(getline('.'), \" foo  \")\n\n  %bwipe!\nendfunc\n\n\" Test for using ~ for home directory in cmdline completion matches\nfunc Test_cmdline_expand_home()\n  call mkdir('Xexpdir', 'R')\n  call writefile([], 'Xexpdir/Xfile1')\n  call writefile([], 'Xexpdir/Xfile2')\n  cd Xexpdir\n  let save_HOME = $HOME\n  let $HOME = getcwd()\n  call feedkeys(\":e ~/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ~/Xfile1 ~/Xfile2', @:)\n  let $HOME = save_HOME\n  cd ..\nendfunc\n\n\" Test for using CTRL-\\ CTRL-G in the command line to go back to normal mode\n\" or insert mode (when 'insertmode' is set)\nfunc Test_cmdline_ctrl_g()\n  new\n  call setline(1, 'abc')\n  call cursor(1, 3)\n  \" If command line is entered from insert mode, using C-\\ C-G should back to\n  \" insert mode\n  call feedkeys(\"i\\<C-O>:\\<C-\\>\\<C-G>xy\", 'xt')\n  call assert_equal('abxyc', getline(1))\n  call assert_equal(4, col('.'))\n\n  \" If command line is entered in 'insertmode', using C-\\ C-G should back to\n  \" 'insertmode'\n  call feedkeys(\":set im\\<cr>\\<C-L>:\\<C-\\>\\<C-G>12\\<C-L>:set noim\\<cr>\", 'xt')\n  call assert_equal('ab12xyc', getline(1))\n  close!\nendfunc\n\n\" Test for 'wildmode'\nfunc Wildmode_tests()\n  func T(a, c, p)\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n\n  set nowildmenu\n  set wildmode=full,list\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd oneA', @:)\n\n  set wildmode=longest,full\n  call feedkeys(\":MyCmd o\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n  call feedkeys(\":MyCmd o\\t\\t\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneC', @:)\n\n  set wildmode=longest\n  call feedkeys(\":MyCmd one\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=list:longest\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=\"\"\n  call feedkeys(\":MyCmd \\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA', @:)\n\n  \" Test for wildmode=longest with 'fileignorecase' set\n  set wildmode=longest\n  set fileignorecase\n  argadd AAA AAAA AAAAA\n  call feedkeys(\":buffer a\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"buffer AAA', @:)\n  set fileignorecase&\n\n  \" Test for listing files with wildmode=list\n  set wildmode=list\n  let g:Sline = ''\n  call feedkeys(\":b A\\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('AAA    AAAA   AAAAA', g:Sline)\n  call assert_equal('\"b A', @:)\n\n  \" when using longest completion match, matches shorter than the argument\n  \" should be ignored (happens with :help)\n  set wildmode=longest,full\n  set wildmenu\n  call feedkeys(\":help a*\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"help a', @:)\n  \" non existing file\n  call feedkeys(\":e a1b2y3z4\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e a1b2y3z4', @:)\n  set wildmenu&\n\n  \" Test for longest file name completion with 'fileignorecase'\n  \" On MS-Windows, file names are case insensitive.\n  if has('unix')\n    call writefile([], 'XTESTfoo', 'D')\n    call writefile([], 'Xtestbar', 'D')\n    set nofileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e XTESTfoo', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtestbar', @:)\n    set fileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    set fileignorecase&\n  endif\n\n  %argdelete\n  delcommand MyCmd\n  delfunc T\n  set wildmode&\n  %bwipe!\nendfunc\n\nfunc Test_wildmode()\n  \" Test with utf-8 encoding\n  call Wildmode_tests()\n\n  \" Test with latin1 encoding\n  let save_encoding = &encoding\n  set encoding=latin1\n  call Wildmode_tests()\n  let &encoding = save_encoding\nendfunc\n\nfunc Test_custom_complete_autoload()\n  call mkdir('Xcustdir/autoload', 'pR')\n  let save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xcustdir'\n  let lines =<< trim END\n      func vim8#Complete(a, c, p)\n        return \"oneA\\noneB\\noneC\"\n      endfunc\n  END\n  call writefile(lines, 'Xcustdir/autoload/vim8.vim')\n\n  command -nargs=1 -complete=custom,vim8#Complete MyCmd\n  set nowildmenu\n  set wildmode=full,list\n  call feedkeys(\":MyCmd \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA oneB oneC', @:)\n\n  let &rtp = save_rtp\n  set wildmode& wildmenu&\n  delcommand MyCmd\nendfunc\n\n\" Test for interrupting the command-line completion\nfunc Test_interrupt_compl()\n  func F(lead, cmdl, p)\n    if a:lead =~ 'tw'\n      call interrupt()\n      return\n    endif\n    return \"one\\ntwo\\nthree\"\n  endfunc\n  command -nargs=1 -complete=custom,F Tcmd\n\n  set nowildmenu\n  set wildmode=full\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<C-d>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  delcommand Tcmd\n  delfunc F\n  set wildmode&\nendfunc\n\n\" Test for moving the cursor on the : command line\nfunc Test_cmdline_edit()\n  let str = \":one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Left>five\\<Right>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Left>one \"\n  let str ..= \"\\<C-Right> three\"\n  let str ..= \"\\<End>\\<S-Left>four \"\n  let str ..= \"\\<S-Right> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call feedkeys(str, 'xt')\n  call assert_equal(\"\\\"one two three four five six seven\", @:)\nendfunc\n\n\" Test for moving the cursor on the / command line in 'rightleft' mode\nfunc Test_cmdline_edit_rightleft()\n  CheckFeature rightleft\n  set rightleft\n  set rightleftcmd=search\n  let str = \"/one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Right>five\\<Left>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Right>one \"\n  let str ..= \"\\<C-Left> three\"\n  let str ..= \"\\<End>\\<S-Right>four \"\n  let str ..= \"\\<S-Left> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call assert_fails(\"call feedkeys(str, 'xt')\", 'E486:')\n  call assert_equal(\"\\\"one two three four five six seven\", @/)\n  set rightleftcmd&\n  set rightleft&\nendfunc\n\n\" Test for using <C-\\>e in the command line to evaluate an expression\nfunc Test_cmdline_expr()\n  \" Evaluate an expression from the beginning of a command line\n  call feedkeys(\":abc\\<C-B>\\<C-\\>e\\\"\\\\\\\"hello\\\"\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"hello', @:)\n\n  \" Use an invalid expression for <C-\\>e\n  call assert_beeps('call feedkeys(\":\\<C-\\>einvalid\\<CR>\", \"tx\")')\n\n  \" Insert literal <CTRL-\\> in the command line\n  call feedkeys(\":\\\"e \\<C-\\>\\<C-Y>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"e \\<C-\\>\\<C-Y>\", @:)\nendfunc\n\n\" This was making the insert position negative\nfunc Test_cmdline_expr_register()\n  exe \"sil! norm! ?\\<C-\\>e0\\<C-R>0\\<Esc>?\\<C-\\>e0\\<CR>\"\nendfunc\n\n\" Test for 'imcmdline' and 'imsearch'\n\" This test doesn't actually test the input method functionality.\nfunc Test_cmdline_inputmethod()\n  new\n  call setline(1, ['', 'abc', ''])\n  set imcmdline\n\n  call feedkeys(\":\\\"abc\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\":\\\"\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  set imsearch=2\n  call cursor(1, 1)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call cursor(1, 1)\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable&\n  set imsearch&\n\n  set imcmdline&\n  %bwipe!\nendfunc\n\n\" Test for using CTRL-_ in the command line with 'allowrevins'\nfunc Test_cmdline_revins()\n  CheckNotMSWindows\n  CheckFeature rightleft\n  call feedkeys(\":\\\"abc\\<c-_>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"abc\\<c-_>\", @:)\n  set allowrevins\n  call feedkeys(\":\\\"abc\\<c-_>xyz\\<c-_>\\<CR>\", 'xt')\n  call assert_equal('\"abc\u00f1\u00e8\u00e6', @:)\n  set allowrevins&\nendfunc\n\n\" Test for typing UTF-8 composing characters in the command line\nfunc Test_cmdline_composing_chars()\n  call feedkeys(\":\\\"\\<C-V>u3046\\<C-V>u3099\\<CR>\", 'xt')\n  call assert_equal('\"\u3046\u3099', @:)\nendfunc\n\n\" test that \";\" works to find a match at the start of the first line\nfunc Test_zero_line_search()\n  new\n  call setline(1, [\"1, pattern\", \"2, \", \"3, pattern\"])\n  call cursor(1,1)\n  0;/pattern/d\n  call assert_equal([\"2, \", \"3, pattern\"], getline(1,'$'))\n  q!\nendfunc\n\nfunc Test_read_shellcmd()\n  CheckUnix\n  if executable('ls')\n    \" There should be ls in the $PATH\n    call feedkeys(\":r! l\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_match('^\"r! .*\\<ls\\>', @:)\n  endif\n\n  if executable('rm')\n    call feedkeys(\":r! ++enc=utf-8 r\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r!.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r!.*\\<rm\\>', @:)\n\n    call feedkeys(\":r ++enc=utf-8 !rm\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r ++enc\\S\\+ !.*\\<rm\\>', @:)\n  endif\nendfunc\n\n\" Test for going up and down the directory tree using 'wildmenu'\nfunc Test_wildmenu_dirstack()\n  CheckUnix\n  %bw!\n  call mkdir('Xwildmenu/dir2/dir3/dir4', 'pR')\n  call writefile([], 'Xwildmenu/file1_1.txt')\n  call writefile([], 'Xwildmenu/file1_2.txt')\n  call writefile([], 'Xwildmenu/dir2/file2_1.txt')\n  call writefile([], 'Xwildmenu/dir2/file2_2.txt')\n  call writefile([], 'Xwildmenu/dir2/dir3/file3_1.txt')\n  call writefile([], 'Xwildmenu/dir2/dir3/file3_2.txt')\n  call writefile([], 'Xwildmenu/dir2/dir3/dir4/file4_1.txt')\n  call writefile([], 'Xwildmenu/dir2/dir3/dir4/file4_2.txt')\n  set wildmenu\n\n  cd Xwildmenu/dir2/dir3/dir4\n  call feedkeys(\":e \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e file4_1.txt', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../../dir2/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/file4_1.txt', @:)\n  cd -\n  call feedkeys(\":e Xwildmenu/\\<Tab>\\<Down>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xwildmenu/dir2/dir3/dir4/file4_1.txt', @:)\n\n  set wildmenu&\nendfunc\n\n\" Test for recalling newer or older cmdline from history with <Up>, <Down>,\n\" <S-Up>, <S-Down>, <PageUp>, <PageDown>, <kPageUp>, <kPageDown>, <C-p>, or\n\" <C-n>.\nfunc Test_recalling_cmdline()\n  CheckFeature cmdline_hist\n\n  let g:cmdlines = []\n  cnoremap <Plug>(save-cmdline) <Cmd>let g:cmdlines += [getcmdline()]<CR>\n\n  let histories = [\n  \\  #{name: 'cmd',    enter: ':',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'search', enter: '/',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'expr',   enter: \":\\<C-r>=\",             exit: \"\\<Esc>\\<Esc>\"},\n  \\  #{name: 'input',  enter: \":call input('')\\<CR>\", exit: \"\\<CR>\"},\n  \"\\ TODO: {'name': 'debug', ...}\n  \\]\n  let keypairs = [\n  \\  #{older: \"\\<Up>\",     newer: \"\\<Down>\",     prefixmatch: v:true},\n  \\  #{older: \"\\<S-Up>\",   newer: \"\\<S-Down>\",   prefixmatch: v:false},\n  \\  #{older: \"\\<PageUp>\", newer: \"\\<PageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<kPageUp>\", newer: \"\\<kPageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<C-p>\",    newer: \"\\<C-n>\",      prefixmatch: v:false},\n  \\]\n  let prefix = 'vi'\n  for h in histories\n    call histadd(h.name, 'vim')\n    call histadd(h.name, 'virtue')\n    call histadd(h.name, 'Virgo')\n    call histadd(h.name, 'vogue')\n    call histadd(h.name, 'emacs')\n    for k in keypairs\n      let g:cmdlines = []\n      let keyseqs = h.enter\n      \\          .. prefix\n      \\          .. repeat(k.older .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. repeat(k.newer .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. h.exit\n      call feedkeys(keyseqs, 'xt')\n      call histdel(h.name, -1) \" delete the history added by feedkeys above\n      let expect = k.prefixmatch\n      \\          ? ['virtue', 'vim',   'virtue', prefix]\n      \\          : ['emacs',  'vogue', 'emacs',  prefix]\n      call assert_equal(expect, g:cmdlines)\n    endfor\n  endfor\n\n  unlet g:cmdlines\n  cunmap <Plug>(save-cmdline)\nendfunc\n\nfunc Test_cmd_map_cmdlineChanged()\n  let g:log = []\n  cnoremap <F1> l<Cmd><CR>s\n  augroup test\n    autocmd!\n    autocmd CmdlineChanged : let g:log += [getcmdline()]\n  augroup END\n\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['l', 'ls'], g:log)\n\n  let @b = 'b'\n  cnoremap <F1> a<C-R>b\n  let g:log = []\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['a', 'ab'], g:log)\n\n  unlet g:log\n  cunmap <F1>\n  augroup test\n    autocmd!\n  augroup END\nendfunc\n\n\" Test for the 'suffixes' option\nfunc Test_suffixes_opt()\n  call writefile([], 'Xsuffile', 'D')\n  call writefile([], 'Xsuffile.c', 'D')\n  call writefile([], 'Xsuffile.o', 'D')\n  set suffixes=\n  call feedkeys(\":e Xsuffi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile Xsuffile.c Xsuffile.o', @:)\n  call feedkeys(\":e Xsuffi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile.c', @:)\n  set suffixes=.c\n  call feedkeys(\":e Xsuffi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile Xsuffile.o Xsuffile.c', @:)\n  call feedkeys(\":e Xsuffi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile.o', @:)\n  set suffixes=,,\n  call feedkeys(\":e Xsuffi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile.c Xsuffile.o Xsuffile', @:)\n  call feedkeys(\":e Xsuffi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile.o', @:)\n  set suffixes&\n  \" Test for getcompletion() with different patterns\n  call assert_equal(['Xsuffile', 'Xsuffile.c', 'Xsuffile.o'], getcompletion('Xsuffile', 'file'))\n  call assert_equal(['Xsuffile'], getcompletion('Xsuffile$', 'file'))\nendfunc\n\n\" Test for using a popup menu for the command line completion matches\n\" (wildoptions=pum)\nfunc Test_wildmenu_pum()\n  CheckRunVimInTerminal\n\n  let commands =<< trim [CODE]\n    set wildmenu\n    set wildoptions=pum\n    set shm+=I\n    set noruler\n    set noshowcmd\n\n    func CmdCompl(a, b, c)\n      return repeat(['aaaa'], 120)\n    endfunc\n    command -nargs=* -complete=customlist,CmdCompl Tcmd\n\n    func MyStatusLine() abort\n      return 'status'\n    endfunc\n    func SetupStatusline()\n      set statusline=%!MyStatusLine()\n      set laststatus=2\n    endfunc\n\n    func MyTabLine()\n      return 'my tab line'\n    endfunc\n    func SetupTabline()\n      set statusline=\n      set tabline=%!MyTabLine()\n      set showtabline=2\n    endfunc\n\n    func DoFeedKeys()\n      let &wildcharm = char2nr(\"\\t\")\n      call feedkeys(\":edit $VIMRUNTIME/\\<Tab>\\<Left>\\<C-U>ab\\<Tab>\")\n    endfunc\n  [CODE]\n  call writefile(commands, 'Xtest', 'D')\n\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n\n  call term_sendkeys(buf, \":sign \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_01', {})\n\n  \" going down the popup menu using <Down>\n  call term_sendkeys(buf, \"\\<Down>\\<Down>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_02', {})\n\n  \" going down the popup menu using <C-N>\n  call term_sendkeys(buf, \"\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_03', {})\n\n  \" going up the popup menu using <C-P>\n  call term_sendkeys(buf, \"\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_04', {})\n\n  \" going up the popup menu using <Up>\n  call term_sendkeys(buf, \"\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_05', {})\n\n  \" pressing <C-E> should end completion and go back to the original match\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_06', {})\n\n  \" pressing <C-Y> should select the current match and end completion\n  call term_sendkeys(buf, \"\\<Tab>\\<C-P>\\<C-P>\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_07', {})\n\n  \" With 'wildmode' set to 'longest,full', completing a match should display\n  \" the longest match, the wildmenu should not be displayed.\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=longest,full\\<CR>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":sign u\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_08', {})\n\n  \" pressing <Tab> should display the wildmenu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_09', {})\n\n  \" pressing <Tab> second time should select the next entry in the menu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_10', {})\n\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=full\\<CR>\")\n  \" showing popup menu in different columns in the cmdline\n  call term_sendkeys(buf, \":sign define \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_11', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_12', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_13', {})\n\n  \" Directory name completion\n  call mkdir('Xnamedir/XdirA/XdirB', 'pR')\n  call writefile([], 'Xnamedir/XfileA')\n  call writefile([], 'Xnamedir/XdirA/XfileB')\n  call writefile([], 'Xnamedir/XdirA/XdirB/XfileC')\n\n  call term_sendkeys(buf, \"\\<C-U>e Xnamedi\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_14', {})\n\n  \" Pressing <Right> on a directory name should go into that directory\n  call term_sendkeys(buf, \"\\<Right>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_15', {})\n\n  \" Pressing <Left> on a directory name should go to the parent directory\n  call term_sendkeys(buf, \"\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_16', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches but the popup menu should still remain\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-A>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_17', {})\n\n  \" Pressing <C-D> when the popup menu is displayed should remove the popup\n  \" menu\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-D>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_18', {})\n\n  \" Pressing <S-Tab> should open the popup menu with the last entry selected\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<S-Tab>\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_19', {})\n\n  \" Pressing <Esc> should close the popup menu and cancel the cmd line\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<Tab>\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_20', {})\n\n  \" Typing a character when the popup is open, should close the popup\n  call term_sendkeys(buf, \":sign \\<Tab>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_21', {})\n\n  \" When the popup is open, entering the cmdline window should close the popup\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-F>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_22', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n\n  \" After the last popup menu item, <C-N> should show the original string\n  call term_sendkeys(buf, \":sign u\\<Tab>\\<C-N>\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_23', {})\n\n  \" Use the popup menu for the command name\n  call term_sendkeys(buf, \"\\<C-U>bu\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_24', {})\n\n  \" Pressing the left arrow should remove the popup menu\n  call term_sendkeys(buf, \"\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_25', {})\n\n  \" Pressing <BS> should remove the popup menu and erase the last character\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_26', {})\n\n  \" Pressing <C-W> should remove the popup menu and erase the previous word\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-W>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_27', {})\n\n  \" Pressing <C-U> should remove the popup menu and erase the entire line\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-U>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_28', {})\n\n  \" Using <C-E> to cancel the popup menu and then pressing <Up> should recall\n  \" the cmdline from history\n  call term_sendkeys(buf, \"sign xyz\\<Esc>:sign \\<Tab>\\<C-E>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_29', {})\n\n  \" Check \"list\" still works\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=longest,list\\<CR>\")\n  call term_sendkeys(buf, \":cn\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_30', {})\n  call term_sendkeys(buf, \"s\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_31', {})\n\n  \" Tests a directory name contained full-width characters.\n  call mkdir('Xnamedir/\u3042\u3044\u3046', 'p')\n  call writefile([], 'Xnamedir/\u3042\u3044\u3046/abc')\n  call writefile([], 'Xnamedir/\u3042\u3044\u3046/xyz')\n  call writefile([], 'Xnamedir/\u3042\u3044\u3046/123')\n\n  call term_sendkeys(buf, \"\\<C-U>set wildmode&\\<CR>\")\n  call term_sendkeys(buf, \":\\<C-U>e Xnamedir/\u3042\u3044\u3046/\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_32', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing a key after that should remove the popup menu\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=full\\<CR>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_33', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing <Left> after that should move the cursor\n  call term_sendkeys(buf, \"\\<C-U>abc\\<Esc>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_34', {})\n\n  \" When <C-A> displays a lot of matches (screen scrolls), all the matches\n  \" should be displayed correctly on the screen.\n  call term_sendkeys(buf, \"\\<End>\\<C-U>Tcmd \\<Tab>\\<C-A>\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_35', {})\n\n  \" After using <C-A> to expand all the filename matches, pressing <Up>\n  \" should not open the popup menu again.\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd Xnamedir/XdirA\\<CR>\")\n  call term_sendkeys(buf, \":e \\<Tab>\\<C-A>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_36', {})\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd -\\<CR>\")\n\n  \" After using <C-A> to expand all the matches, pressing <S-Tab> used to\n  \" crash Vim\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<S-Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_37', {})\n\n  \" After removing the pum the command line is redrawn\n  call term_sendkeys(buf, \":edit foo\\<CR>\")\n  call term_sendkeys(buf, \":edit bar\\<CR>\")\n  call term_sendkeys(buf, \":ls\\<CR>\")\n  call term_sendkeys(buf, \":com\\<Tab> \")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_38', {})\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n\n  \" Esc still works to abort the command when 'statusline' is set\n  call term_sendkeys(buf, \":call SetupStatusline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_39', {})\n\n  \" Esc still works to abort the command when 'tabline' is set\n  call term_sendkeys(buf, \":call SetupTabline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_40', {})\n\n  \" popup is cleared also when 'lazyredraw' is set\n  call term_sendkeys(buf, \":set showtabline=1 laststatus=1 lazyredraw\\<CR>\")\n  call term_sendkeys(buf, \":call DoFeedKeys()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_41', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Pressing <PageDown> should scroll the menu downward\n  call term_sendkeys(buf, \":sign \\<Tab>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_42', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_43', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_44', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_45', {})\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<Down>\\<Down>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_46', {})\n\n  \" Pressing <PageUp> should scroll the menu upward\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_47', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_48', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_49', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_50', {})\n\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for wildmenumode() with the cmdline popup menu\nfunc Test_wildmenumode_with_pum()\n  set wildmenu\n  set wildoptions=pum\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":sign \\<Tab>\\<F2>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define10', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-A>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define jump list place undefine unplace0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-E>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign 0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-Y>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define0', @:)\n  set nowildmenu wildoptions&\n  cunmap <F2>\nendfunc\n\nfunc Test_wildmenu_with_pum_foldexpr()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      call setline(1, ['folded one', 'folded two', 'some more text'])\n      func MyFoldText()\n        return 'foo'\n      endfunc\n      set foldtext=MyFoldText() wildoptions=pum\n      normal ggzfj\n  END\n  call writefile(lines, 'Xpumfold', 'D')\n  let buf = RunVimInTerminal('-S Xpumfold', #{rows: 10})\n  call term_sendkeys(buf, \":set\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for opening the cmdline completion popup menu from the terminal window.\n\" The popup menu should be positioned correctly over the status line of the\n\" bottom-most window.\nfunc Test_wildmenu_pum_from_terminal()\n  CheckRunVimInTerminal\n  let python = PythonProg()\n  call CheckPython(python)\n\n  %bw!\n  let cmds = ['set wildmenu wildoptions=pum']\n  let pcmd = python .. ' -c \"import sys; sys.stdout.write(sys.stdin.read())\"'\n  call add(cmds, \"call term_start('\" .. pcmd .. \"')\")\n  call writefile(cmds, 'Xtest', 'D')\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n  call term_sendkeys(buf, \"\\r\\r\\r\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \"\\<C-W>:sign \\<Tab>\")\n  call term_wait(buf)\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_term_01', {})\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_wildmenu_pum_clear_entries()\n  CheckRunVimInTerminal\n\n  \" This was using freed memory.  Run in a terminal to get the pum to update.\n  let lines =<< trim END\n    set wildoptions=pum\n    set wildchar=<C-E>\n  END\n  call writefile(lines, 'XwildmenuTest', 'D')\n  let buf = RunVimInTerminal('-S XwildmenuTest', #{rows: 10})\n\n  call term_sendkeys(buf, \":\\<C-E>\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_clear_entries_1', {})\n\n  set wildoptions& wildchar&\nendfunc\n\n\" Test for completion after a :substitute command followed by a pipe (|)\n\" character\nfunc Test_cmdline_complete_substitute()\n  call feedkeys(\":s | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s | \\t\", @:)\n  call feedkeys(\":s/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/ | \\t\", @:)\n  call feedkeys(\":s/one | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one | \\t\", @:)\n  call feedkeys(\":s/one/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/ | \\t\", @:)\n  call feedkeys(\":s/one/two | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two | \\t\", @:)\n  call feedkeys(\":s/one/two/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/two/ | chistory', @:)\n  call feedkeys(\":s/one/two/g \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g \\t\", @:)\n  call feedkeys(\":s/one/two/g | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g | chistory\", @:)\n  call feedkeys(\":s/one/t\\\\/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/t\\\\/ | \\t\", @:)\n  call feedkeys(\":s/one/t\\\"o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t\"o/ | chistory', @:)\n  call feedkeys(\":s/one/t|o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t|o/ | chistory', @:)\n  call feedkeys(\":&\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"&\\t\", @:)\nendfunc\n\n\" Test for the :dlist command completion\nfunc Test_cmdline_complete_dlist()\n  call feedkeys(\":dlist 10 /pat/ a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ a\\<C-A>\", @:)\n  call feedkeys(\":dlist 10 /pat/ \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ \\t\", @:)\n  call feedkeys(\":dlist 10 /pa\\\\t/\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pa\\\\t/\\t\", @:)\n  call feedkeys(\":dlist 10 /pat\\\\\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat\\\\\\t\", @:)\n  call feedkeys(\":dlist 10 /pat/ | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ | chistory\", @:)\nendfunc\n\n\" argument list (only for :argdel) fuzzy completion\nfunc Test_fuzzy_completion_arglist()\n  argadd change.py count.py charge.py\n  set wildoptions&\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel cge', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel change.py charge.py', @:)\n  %argdelete\n  set wildoptions&\nendfunc\n\n\" autocmd group name fuzzy completion\nfunc Test_fuzzy_completion_autocmd()\n  set wildoptions&\n  augroup MyFuzzyGroup\n  augroup END\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup mfg', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup My*p', @:)\n  augroup! MyFuzzyGroup\n  set wildoptions&\nendfunc\n\n\" buffer name fuzzy completion\nfunc Test_fuzzy_completion_bufname()\n  set wildoptions&\n  \" Use a long name to reduce the risk of matching a random directory name\n  edit SomeRandomFileWithLetters.txt\n  enew\n  call feedkeys(\":b SRFWL\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SRFWL', @:)\n  call feedkeys(\":b S*FileWithLetters.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeRandomFileWithLetters.txt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b SRFWL\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeRandomFileWithLetters.txt', @:)\n  call feedkeys(\":b S*FileWithLetters.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b S*FileWithLetters.txt', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" buffer name (full path) fuzzy completion\nfunc Test_fuzzy_completion_bufname_fullpath()\n  CheckUnix\n  set wildoptions&\n  call mkdir('Xcmd/Xstate/Xfile.js', 'pR')\n  edit Xcmd/Xstate/Xfile.js\n  cd Xcmd/Xstate\n  enew\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b CmdStateFile', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('Xcmd/Xstate/Xfile.js$', @:)\n  cd -\n  set wildoptions&\nendfunc\n\n\" :behave suboptions fuzzy completion\nfunc Test_fuzzy_completion_behave()\n  set wildoptions&\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xt*m', @:)\n  let g:Sline = ''\n  call feedkeys(\":behave win\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('mswin', g:Sline)\n  call assert_equal('\"behave win', @:)\n  set wildoptions&\nendfunc\n\n\" \" colorscheme name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_colorscheme()\n\" endfunc\n\n\" built-in command name fuzzy completion\nfunc Test_fuzzy_completion_cmdname()\n  set wildoptions&\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbwin', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbr*d', @:)\n  set wildoptions&\nendfunc\n\n\" \" compiler name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_compiler()\n\" endfunc\n\n\" :cscope suboptions fuzzy completion\nfunc Test_fuzzy_completion_cscope()\n  CheckFeature cscope\n  set wildoptions&\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope ret', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope re*t', @:)\n  set wildoptions&\nendfunc\n\n\" :diffget/:diffput buffer name fuzzy completion\nfunc Test_fuzzy_completion_diff()\n  new SomeBuffer\n  diffthis\n  new OtherBuffer\n  diffthis\n  set wildoptions&\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget sbuf', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput sbuf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget SomeBuffer', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput SomeBuffer', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" \" directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_dirname()\n\" endfunc\n\n\" environment variable name fuzzy completion\nfunc Test_fuzzy_completion_env()\n  set wildoptions&\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VUT', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VIMRUNTIME', @:)\n  set wildoptions&\nendfunc\n\n\" autocmd event fuzzy completion\nfunc Test_fuzzy_completion_autocmd_event()\n  set wildoptions&\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BWout', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BufWipeout', @:)\n  set wildoptions&\nendfunc\n\n\" vim expression fuzzy completion\nfunc Test_fuzzy_completion_expr()\n  let g:PerPlaceCount = 10\n  set wildoptions&\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = ppc', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = PerPlaceCount', @:)\n  set wildoptions&\nendfunc\n\n\" \" file name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filename()\n\" endfunc\n\n\" \" files in path fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filesinpath()\n\" endfunc\n\n\" \" filetype name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filetype()\n\" endfunc\n\n\" user defined function name completion\nfunc Test_fuzzy_completion_userdefined_func()\n  set wildoptions&\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_f_u_f', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_fuzzy_completion_userdefined_func()', @:)\n  set wildoptions&\nendfunc\n\n\" <SNR> functions should be sorted to the end\nfunc Test_fuzzy_completion_userdefined_snr_func()\n  func s:Sendmail()\n  endfunc\n  func SendSomemail()\n  endfunc\n  func S1e2n3dmail()\n  endfunc\n  set wildoptions=fuzzy\n  call feedkeys(\":call sendmail\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"call SendSomemail() S1e2n3dmail() <SNR>\\d\\+_Sendmail()', @:)\n  set wildoptions&\n  delfunc s:Sendmail\n  delfunc SendSomemail\n  delfunc S1e2n3dmail\nendfunc\n\n\" user defined command name completion\nfunc Test_fuzzy_completion_userdefined_cmd()\n  set wildoptions&\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MsFeat', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MissingFeature', @:)\n  set wildoptions&\nendfunc\n\n\" \" :help tag fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_helptag()\n\" endfunc\n\n\" highlight group name fuzzy completion\nfunc Test_fuzzy_completion_hlgroup()\n  set wildoptions&\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight Sp*Key', @:)\n  set wildoptions&\nendfunc\n\n\" :history suboptions fuzzy completion\nfunc Test_fuzzy_completion_history()\n  set wildoptions&\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history dg', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history search', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history debug', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history se*h', @:)\n  set wildoptions&\nendfunc\n\n\" :language locale name fuzzy completion\nfunc Test_fuzzy_completion_lang()\n  CheckUnix\n  set wildoptions&\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang psx', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang POSIX', @:)\n  set wildoptions&\nendfunc\n\n\" :mapclear buffer argument fuzzy completion\nfunc Test_fuzzy_completion_mapclear()\n  set wildoptions&\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear buf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear <buffer>', @:)\n  set wildoptions&\nendfunc\n\n\" map name fuzzy completion\nfunc Test_fuzzy_completion_mapname()\n  \" test regex completion works\n  set wildoptions=fuzzy\n  call feedkeys(\":cnoremap <ex\\<Tab> <esc> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"cnoremap <expr> <esc> \\<Tab>\", @:)\n  nmap <plug>MyLongMap :p<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  call feedkeys(\":nmap MLM \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap MLM \\t\", @:)\n  call feedkeys(\":nmap <F2> one two \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <F2> one two \\t\", @:)\n  \" duplicate entries should be removed\n  vmap <plug>MyLongMap :<C-U>#<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  nunmap <plug>MyLongMap\n  vunmap <plug>MyLongMap\n  call feedkeys(\":nmap ABC\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap ABC\\t\", @:)\n  \" results should be sorted by best match\n  nmap <Plug>format :\n  nmap <Plug>goformat :\n  nmap <Plug>TestFOrmat :\n  nmap <Plug>fendoff :\n  nmap <Plug>state :\n  nmap <Plug>FendingOff :\n  call feedkeys(\":nmap <Plug>fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>format <Plug>TestFOrmat <Plug>FendingOff <Plug>goformat <Plug>fendoff\", @:)\n  nunmap <Plug>format\n  nunmap <Plug>goformat\n  nunmap <Plug>TestFOrmat\n  nunmap <Plug>fendoff\n  nunmap <Plug>state\n  nunmap <Plug>FendingOff\n  set wildoptions&\nendfunc\n\n\" abbreviation fuzzy completion\nfunc Test_fuzzy_completion_abbr()\n  set wildoptions=fuzzy\n  call feedkeys(\":iabbr wait\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr <nowait>\", @:)\n  iabbr WaitForCompletion WFC\n  call feedkeys(\":iabbr fcl\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr WaitForCompletion\", @:)\n  call feedkeys(\":iabbr a1z\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr a1z\\t\", @:)\n  iunabbrev WaitForCompletion\n  set wildoptions&\nendfunc\n\n\" menu name fuzzy completion\nfunc Test_fuzzy_completion_menu()\n  CheckGui\n  set wildoptions&\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu pup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu PopUp.', @:)\n  set wildoptions&\nendfunc\n\n\" :messages suboptions fuzzy completion\nfunc Test_fuzzy_completion_messages()\n  set wildoptions&\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clear', @:)\n  set wildoptions&\nendfunc\n\n\" :set option name fuzzy completion\nfunc Test_fuzzy_completion_option()\n  set wildoptions&\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set brkopt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set breakindentopt', @:)\n  set wildoptions&\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions&\nendfunc\n\n\" :set <term_option>\nfunc Test_fuzzy_completion_term_option()\n  set wildoptions&\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions&\nendfunc\n\n\" \" :packadd directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_packadd()\n\" endfunc\n\n\" \" shell command name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_shellcmd()\n\" endfunc\n\n\" :sign suboptions fuzzy completion\nfunc Test_fuzzy_completion_sign()\n  set wildoptions&\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign ufe', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign undefine', @:)\n  set wildoptions&\nendfunc\n\n\" :syntax suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntax_cmd()\n  set wildoptions&\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax kwd', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax keyword', @:)\n  set wildoptions&\nendfunc\n\n\" syntax group name fuzzy completion\nfunc Test_fuzzy_completion_syntax_group()\n  set wildoptions&\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list mpar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list MatchParen', @:)\n  set wildoptions&\nendfunc\n\n\" :syntime suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntime()\n  CheckFeature profile\n  set wildoptions&\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clear', @:)\n  set wildoptions&\nendfunc\n\n\" \" tag name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagname()\n\" endfunc\n\n\" \" tag name and file fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagfile()\n\" endfunc\n\n\" \" user names fuzzy completion - how to test this functionality?\n\" func Test_fuzzy_completion_username()\n\" endfunc\n\n\" user defined variable name fuzzy completion\nfunc Test_fuzzy_completion_userdefined_var()\n  let g:SomeVariable=10\n  set wildoptions&\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SVar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SomeVariable', @:)\n  set wildoptions&\nendfunc\n\n\" Test for sorting the results by the best match\nfunc Test_fuzzy_completion_cmd_sort_results()\n  %bw!\n  command T123format :\n  command T123goformat :\n  command T123TestFOrmat :\n  command T123fendoff :\n  command T123state :\n  command T123FendingOff :\n  set wildoptions=fuzzy\n  call feedkeys(\":T123fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"T123format T123TestFOrmat T123FendingOff T123goformat T123fendoff', @:)\n  delcommand T123format\n  delcommand T123goformat\n  delcommand T123TestFOrmat\n  delcommand T123fendoff\n  delcommand T123state\n  delcommand T123FendingOff\n  %bw\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion of a command with lower case letters and a number\nfunc Test_fuzzy_completion_cmd_alnum()\n  command Foo2Bar :\n  set wildoptions=fuzzy\n  call feedkeys(\":foo2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":foo\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":bar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  delcommand Foo2Bar\n  set wildoptions&\nendfunc\n\n\" Test for command completion for a command starting with 'k'\nfunc Test_fuzzy_completion_cmd_k()\n  command KillKillKill :\n  set wildoptions&\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"killkill\\<Tab>\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"KillKillKill', @:)\n  delcom KillKillKill\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion for user defined custom completion function\nfunc Test_fuzzy_completion_custom_func()\n  func Tcompl(a, c, p)\n    return \"format\\ngoformat\\nTestFOrmat\\nfendoff\\nstate\"\n  endfunc\n  command -nargs=* -complete=custom,Tcompl Fuzzy :\n  set wildoptions&\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy ttt\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":Fuzzy \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format goformat TestFOrmat fendoff state\", @:)\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format TestFOrmat goformat fendoff\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy TestFOrmat\", @:)\n  delcom Fuzzy\n  set wildoptions&\nendfunc\n\n\" Test for :breakadd argument completion\nfunc Test_cmdline_complete_breakadd()\n  call feedkeys(\":breakadd \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr file func here\", @:)\n  call feedkeys(\":breakadd \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr\", @:)\n  call feedkeys(\":breakadd    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr\", @:)\n  call feedkeys(\":breakadd he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here\", @:)\n  call feedkeys(\":breakadd    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    here\", @:)\n  call feedkeys(\":breakadd abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd abc\", @:)\n  call assert_equal(['expr', 'file', 'func', 'here'], getcompletion('', 'breakpoint'))\n  let l = getcompletion('not', 'breakpoint')\n  call assert_equal([], l)\n\n  \" Test for :breakadd file [lnum] <file>\n  call writefile([], 'Xscript', 'D')\n  call feedkeys(\":breakadd file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript\", @:)\n  call feedkeys(\":breakadd   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   Xscript\", @:)\n  call feedkeys(\":breakadd file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20 Xscript\", @:)\n  call feedkeys(\":breakadd   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   20   Xscript\", @:)\n  call feedkeys(\":breakadd file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakadd file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20\\t\", @:)\n  call feedkeys(\":breakadd file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x\\t\", @:)\n  call feedkeys(\":breakadd file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript  \", @:)\n  call feedkeys(\":breakadd file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file X1B2C3\", @:)\n\n  \" Test for :breakadd func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakadd func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func\", @:)\n  call feedkeys(\":breakadd    func    Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    func    Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakadd   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakadd func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20\\t\", @:)\n  call feedkeys(\":breakadd func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x\\t\", @:)\n  call feedkeys(\":breakadd func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func  \", @:)\n  call feedkeys(\":breakadd func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakadd expr <expression>\n  let g:Xtest_var = 10\n  call feedkeys(\":breakadd expr Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var\", @:)\n  call feedkeys(\":breakadd    expr    Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr    Xtest_var\", @:)\n  call feedkeys(\":breakadd expr Xtest_var  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var  \", @:)\n  call feedkeys(\":breakadd expr X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr X1B2C3\", @:)\n  unlet g:Xtest_var\n\n  \" Test for :breakadd here\n  call feedkeys(\":breakadd here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here Xtest\", @:)\n  call feedkeys(\":breakadd   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   here   Xtest\", @:)\n  call feedkeys(\":breakadd here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here \", @:)\nendfunc\n\n\" Test for :breakdel argument completion\nfunc Test_cmdline_complete_breakdel()\n  call feedkeys(\":breakdel \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file func here\", @:)\n  call feedkeys(\":breakdel \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file\", @:)\n  call feedkeys(\":breakdel    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    file\", @:)\n  call feedkeys(\":breakdel he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here\", @:)\n  call feedkeys(\":breakdel    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    here\", @:)\n  call feedkeys(\":breakdel abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel abc\", @:)\n\n  \" Test for :breakdel file [lnum] <file>\n  call writefile([], 'Xscript', 'D')\n  call feedkeys(\":breakdel file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript\", @:)\n  call feedkeys(\":breakdel   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   Xscript\", @:)\n  call feedkeys(\":breakdel file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20 Xscript\", @:)\n  call feedkeys(\":breakdel   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   20   Xscript\", @:)\n  call feedkeys(\":breakdel file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakdel file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20\\t\", @:)\n  call feedkeys(\":breakdel file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x\\t\", @:)\n  call feedkeys(\":breakdel file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript  \", @:)\n  call feedkeys(\":breakdel file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file X1B2C3\", @:)\n\n  \" Test for :breakdel func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakdel func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakdel func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20\\t\", @:)\n  call feedkeys(\":breakdel func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x\\t\", @:)\n  call feedkeys(\":breakdel func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func  \", @:)\n  call feedkeys(\":breakdel func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakdel here\n  call feedkeys(\":breakdel here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here Xtest\", @:)\n  call feedkeys(\":breakdel   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   here   Xtest\", @:)\n  call feedkeys(\":breakdel here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here \", @:)\nendfunc\n\n\" Test for :scriptnames argument completion\nfunc Test_cmdline_complete_scriptnames()\n  set wildmenu\n  call writefile(['let a = 1'], 'Xa1b2c3.vim', 'D')\n  source Xa1b2c3.vim\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script    \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script b2c3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script b2c3\", @:)\n  call feedkeys(\":script 2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script 2\\<Tab>$\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim $\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script \", @:)\n  call assert_match('Xa1b2c3.vim$', getcompletion('.*Xa1b2.*', 'scriptnames')[0])\n  call assert_equal([], getcompletion('Xa1b2', 'scriptnames'))\n  new\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('Xa1b2c3.vim', fnamemodify(@%, ':t'))\n  bw!\n  set wildmenu&\nendfunc\n\n\" this was going over the end of IObuff\nfunc Test_report_error_with_composing()\n  let caught = 'no'\n  try\n    exe repeat('0', 987) .. \"0\\xdd\\x80\\xdd\\x80\\xdd\\x80\\xdd\\x80\"\n  catch /E492:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\n\" Test for expanding 2-letter and 3-letter :substitute command arguments.\n\" These commands don't accept an argument.\nfunc Test_cmdline_complete_substitute_short()\n  for cmd in ['sc', 'sce', 'scg', 'sci', 'scI', 'scn', 'scp', 'scl',\n        \\ 'sgc', 'sge', 'sg', 'sgi', 'sgI', 'sgn', 'sgp', 'sgl', 'sgr',\n        \\ 'sic', 'sie', 'si', 'siI', 'sin', 'sip', 'sir',\n        \\ 'sIc', 'sIe', 'sIg', 'sIi', 'sI', 'sIn', 'sIp', 'sIl', 'sIr',\n        \\ 'src', 'srg', 'sri', 'srI', 'srn', 'srp', 'srl', 'sr']\n    call feedkeys(':' .. cmd .. \" \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"' .. cmd .. \" \\<Tab>\", @:)\n  endfor\nendfunc\n\n\" Test for :! shell command argument completion\nfunc Test_cmdline_complete_bang_cmd_argument()\n  set wildoptions=fuzzy\n  call feedkeys(\":!vim test_cmdline.\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"!vim test_cmdline.vim', @:)\n  set wildoptions&\n  call feedkeys(\":!vim test_cmdline.\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"!vim test_cmdline.vim', @:)\nendfunc\n\nfunc Check_completion()\n  call assert_equal('let a', getcmdline())\n  call assert_equal(6, getcmdpos())\n  call assert_equal(7, getcmdscreenpos())\n  call assert_equal('var', getcmdcompltype())\n  return ''\nendfunc\n\nfunc Test_screenpos_and_completion()\n  call feedkeys(\":let a\\<C-R>=Check_completion()\\<CR>\\<Esc>\", \"xt\")\nendfunc\n\nfunc Test_recursive_register()\n  let @= = ''\n  silent! ?\u001ce\u0012/\n  let caught = 'no'\n  try\n    normal /\u0012/ \n  catch /E169:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\nfunc Test_long_error_message()\n  \" the error should be truncated, not overrun IObuff\n  silent! norm Q00000000000000\u00a0\u00a0\u00a0\u00a0\u00a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nendfunc\n\nfunc Test_cmdline_redraw_tabline()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      set showtabline=2\n      autocmd CmdlineEnter * set tabline=foo\n  END\n  call writefile(lines, 'Xcmdline_redraw_tabline', 'D')\n  let buf = RunVimInTerminal('-S Xcmdline_redraw_tabline', #{rows: 6})\n  call term_sendkeys(buf, ':')\n  call WaitForAssert({-> assert_match('^foo', term_getline(buf, 1))})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_wildmenu_pum_disable_while_shown()\n  set wildoptions=pum\n  set wildmenu\n  cnoremap <F2> <Cmd>set nowildmenu<CR>\n  call feedkeys(\":sign \\<Tab>\\<F2>\\<Esc>\", 'tx')\n  call assert_equal(0, pumvisible())\n  cunmap <F2>\n  set wildoptions& wildmenu&\nendfunc\n\nfunc Test_setcmdline()\n  func SetText(text, pos)\n    autocmd CmdlineChanged * let g:cmdtype = expand('<afile>')\n    call assert_equal(0, setcmdline(a:text))\n    call assert_equal(a:text, getcmdline())\n    call assert_equal(len(a:text) + 1, getcmdpos())\n    call assert_equal(getcmdtype(), g:cmdtype)\n    unlet g:cmdtype\n    autocmd! CmdlineChanged\n\n    call assert_equal(0, setcmdline(a:text, a:pos))\n    call assert_equal(a:text, getcmdline())\n    call assert_equal(a:pos, getcmdpos())\n\n    call assert_fails('call setcmdline(\"' .. a:text .. '\", -1)', 'E487:')\n    call assert_fails('call setcmdline({}, 0)', 'E1174:')\n    call assert_fails('call setcmdline(\"' .. a:text .. '\", {})', 'E1210:')\n\n    return ''\n  endfunc\n\n  call feedkeys(\":\\<C-R>=SetText('set rtp?', 2)\\<CR>\\<CR>\", 'xt')\n  call assert_equal('set rtp?', @:)\n\n  call feedkeys(\":let g:str = input('? ')\\<CR>\", 't')\n  call feedkeys(\"\\<C-R>=SetText('foo', 4)\\<CR>\\<CR>\", 'xt')\n  call assert_equal('foo', g:str)\n  unlet g:str\n\n  delfunc SetText\n\n  \" setcmdline() returns 1 when not editing the command line.\n  call assert_equal(1, 'foo'->setcmdline())\n\n  \" Called in custom function\n  func CustomComplete(A, L, P)\n    call assert_equal(0, setcmdline(\"DoCmd \"))\n    return \"January\\nFebruary\\nMars\\n\"\n  endfunc\n\n  com! -nargs=* -complete=custom,CustomComplete DoCmd :\n  call feedkeys(\":DoCmd \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"DoCmd January February Mars', @:)\n  delcom DoCmd\n  delfunc CustomComplete\n\n  \" Called in <expr>\n  cnoremap <expr>a setcmdline('let foo=')\n  call feedkeys(\":a\\<CR>\", 'tx')\n  call assert_equal('let foo=0', @:)\n  cunmap a\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * message.c: functions for displaying messages on the command line\n */\n\n#define MESSAGE_FILE\t\t// don't include prototype for smsg()\n\n#include \"vim.h\"\n\nstatic void add_msg_hist(char_u *s, int len, int attr);\nstatic void hit_return_msg(void);\nstatic void msg_home_replace_attr(char_u *fname, int attr);\nstatic void msg_puts_attr_len(char *str, int maxlen, int attr);\nstatic void msg_puts_display(char_u *str, int maxlen, int attr, int recurse);\nstatic void msg_scroll_up(void);\nstatic void inc_msg_scrolled(void);\nstatic void store_sb_text(char_u **sb_str, char_u *s, int attr, int *sb_col, int finish);\nstatic void t_puts(int *t_col, char_u *t_s, char_u *s, int attr);\nstatic void msg_puts_printf(char_u *str, int maxlen);\nstatic int do_more_prompt(int typed_char);\nstatic void msg_screen_putchar(int c, int attr);\nstatic void msg_moremsg(int full);\nstatic int  msg_check_screen(void);\nstatic void redir_write(char_u *s, int maxlen);\n#ifdef FEAT_CON_DIALOG\nstatic char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton);\nstatic int\tconfirm_msg_used = FALSE;\t// displaying confirm_msg\nstatic char_u\t*confirm_msg = NULL;\t\t// \":confirm\" message\nstatic char_u\t*confirm_msg_tail;\t\t// tail of confirm_msg\nstatic void display_confirm_msg(void);\n#endif\n#ifdef FEAT_EVAL\nstatic int emsg_to_channel_log = FALSE;\n#endif\n\nstruct msg_hist\n{\n    struct msg_hist\t*next;\n    char_u\t\t*msg;\n    int\t\t\tattr;\n};\n\nstatic struct msg_hist *first_msg_hist = NULL;\nstatic struct msg_hist *last_msg_hist = NULL;\nstatic int msg_hist_len = 0;\n\nstatic FILE *verbose_fd = NULL;\nstatic int  verbose_did_open = FALSE;\n\n/*\n * When writing messages to the screen, there are many different situations.\n * A number of variables is used to remember the current state:\n * msg_didany\t    TRUE when messages were written since the last time the\n *\t\t    user reacted to a prompt.\n *\t\t    Reset: After hitting a key for the hit-return prompt,\n *\t\t    hitting <CR> for the command line or input().\n *\t\t    Set: When any message is written to the screen.\n * msg_didout\t    TRUE when something was written to the current line.\n *\t\t    Reset: When advancing to the next line, when the current\n *\t\t    text can be overwritten.\n *\t\t    Set: When any message is written to the screen.\n * msg_nowait\t    No extra delay for the last drawn message.\n *\t\t    Used in normal_cmd() before the mode message is drawn.\n * emsg_on_display  There was an error message recently.  Indicates that there\n *\t\t    should be a delay before redrawing.\n * msg_scroll\t    The next message should not overwrite the current one.\n * msg_scrolled\t    How many lines the screen has been scrolled (because of\n *\t\t    messages).  Used in update_screen() to scroll the screen\n *\t\t    back.  Incremented each time the screen scrolls a line.\n * msg_scrolled_ign  TRUE when msg_scrolled is non-zero and msg_puts_attr()\n *\t\t    writes something without scrolling should not make\n *\t\t    need_wait_return to be set.  This is a hack to make \":ts\"\n *\t\t    work without an extra prompt.\n * lines_left\t    Number of lines available for messages before the\n *\t\t    more-prompt is to be given.  -1 when not set.\n * need_wait_return TRUE when the hit-return prompt is needed.\n *\t\t    Reset: After giving the hit-return prompt, when the user\n *\t\t    has answered some other prompt.\n *\t\t    Set: When the ruler or typeahead display is overwritten,\n *\t\t    scrolling the screen for some message.\n * keep_msg\t    Message to be displayed after redrawing the screen, in\n *\t\t    main_loop().\n *\t\t    This is an allocated string or NULL when not used.\n */\n\n/*\n * msg(s) - displays the string 's' on the status line\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n * return TRUE if wait_return() not called\n */\n    int\nmsg(char *s)\n{\n    return msg_attr_keep(s, 0, FALSE);\n}\n\n/*\n * Like msg() but keep it silent when 'verbosefile' is set.\n */\n    int\nverb_msg(char *s)\n{\n    int\t\tn;\n\n    verbose_enter();\n    n = msg_attr_keep(s, 0, FALSE);\n    verbose_leave();\n\n    return n;\n}\n\n    int\nmsg_attr(char *s, int attr)\n{\n    return msg_attr_keep(s, attr, FALSE);\n}\n\n    int\nmsg_attr_keep(\n    char\t*s,\n    int\t\tattr,\n    int\t\tkeep)\t    // TRUE: set keep_msg if it doesn't scroll\n{\n    static int\tentered = 0;\n    int\t\tretval;\n    char_u\t*buf = NULL;\n\n    // Skip messages not matching \":filter pattern\".\n    // Don't filter when there is an error.\n    if (!emsg_on_display && message_filtered((char_u *)s))\n\treturn TRUE;\n\n#ifdef FEAT_EVAL\n    if (attr == 0)\n\tset_vim_var_string(VV_STATUSMSG, (char_u *)s, -1);\n#endif\n\n    /*\n     * It is possible that displaying a messages causes a problem (e.g.,\n     * when redrawing the window), which causes another message, etc..\tTo\n     * break this loop, limit the recursiveness to 3 levels.\n     */\n    if (entered >= 3)\n\treturn TRUE;\n    ++entered;\n\n    // Add message to history (unless it's a repeated kept message or a\n    // truncated message)\n    if ((char_u *)s != keep_msg\n\t    || (*s != '<'\n\t\t&& last_msg_hist != NULL\n\t\t&& last_msg_hist->msg != NULL\n\t\t&& STRCMP(s, last_msg_hist->msg)))\n\tadd_msg_hist((char_u *)s, -1, attr);\n\n#ifdef FEAT_EVAL\n    if (emsg_to_channel_log)\n\t// Write message in the channel log.\n\tch_log(NULL, \"ERROR: %s\", s);\n#endif\n\n    // Truncate the message if needed.\n    msg_start();\n    buf = msg_strtrunc((char_u *)s, FALSE);\n    if (buf != NULL)\n\ts = (char *)buf;\n\n    msg_outtrans_attr((char_u *)s, attr);\n    msg_clr_eos();\n    retval = msg_end();\n\n    if (keep && retval && vim_strsize((char_u *)s)\n\t\t\t    < (int)(Rows - cmdline_row - 1) * Columns + sc_col)\n\tset_keep_msg((char_u *)s, 0);\n\n    need_fileinfo = FALSE;\n\n    vim_free(buf);\n    --entered;\n    return retval;\n}\n\n/*\n * Truncate a string such that it can be printed without causing a scroll.\n * Returns an allocated string or NULL when no truncating is done.\n */\n    char_u *\nmsg_strtrunc(\n    char_u\t*s,\n    int\t\tforce)\t    // always truncate\n{\n    char_u\t*buf = NULL;\n    int\t\tlen;\n    int\t\troom;\n\n    // May truncate message to avoid a hit-return prompt\n    if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)\n\t\t\t       && !exmode_active && msg_silent == 0) || force)\n    {\n\tlen = vim_strsize(s);\n\tif (msg_scrolled != 0\n#ifdef HAS_MESSAGE_WINDOW\n\t\t|| in_echowindow\n#endif\n\t\t)\n\t    // Use all the columns.\n\t    room = (int)(Rows - msg_row) * Columns - 1;\n\telse\n\t    // Use up to 'showcmd' column.\n\t    room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\tif (len > room && room > 0)\n\t{\n\t    if (enc_utf8)\n\t\t// may have up to 18 bytes per cell (6 per char, up to two\n\t\t// composing chars)\n\t\tlen = (room + 2) * 18;\n\t    else if (enc_dbcs == DBCS_JPNU)\n\t\t// may have up to 2 bytes per cell for euc-jp\n\t\tlen = (room + 2) * 2;\n\t    else\n\t\tlen = room + 2;\n\t    buf = alloc(len);\n\t    if (buf != NULL)\n\t\ttrunc_string(s, buf, room, len);\n\t}\n    }\n    return buf;\n}\n\n/*\n * Truncate a string \"s\" to \"buf\" with cell width \"room\".\n * \"s\" and \"buf\" may be equal.\n */\n    void\ntrunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[e - 1] = NUL;\n    }\n}\n\n/*\n * Automatic prototype generation does not understand this function.\n * Note: Caller of smsg() and smsg_attr() must check the resulting string is\n * shorter than IOSIZE!!!\n */\n#ifndef PROTO\n\nint vim_snprintf(char *str, size_t str_m, const char *fmt, ...);\n\n    int\nsmsg(const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg((char *)s);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg((char *)IObuff);\n    }\n}\n\n    int\nsmsg_attr(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr((char *)s, attr);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg_attr((char *)IObuff, attr);\n    }\n}\n\n    int\nsmsg_attr_keep(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr_keep((char *)s, attr, TRUE);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg_attr_keep((char *)IObuff, attr, TRUE);\n    }\n}\n\n#endif\n\n/*\n * Remember the last sourcing name/lnum used in an error message, so that it\n * isn't printed each time when it didn't change.\n */\nstatic int\tlast_sourcing_lnum = 0;\nstatic char_u   *last_sourcing_name = NULL;\n\n/*\n * Reset the last used sourcing name/lnum.  Makes sure it is displayed again\n * for the next error message;\n */\n    void\nreset_last_sourcing(void)\n{\n    VIM_CLEAR(last_sourcing_name);\n    last_sourcing_lnum = 0;\n}\n\n/*\n * Return TRUE if \"SOURCING_NAME\" differs from \"last_sourcing_name\".\n */\n    static int\nother_sourcing_name(void)\n{\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL)\n    {\n\tif (last_sourcing_name != NULL)\n\t    return STRCMP(SOURCING_NAME, last_sourcing_name) != 0;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Get the message about the source, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_source(void)\n{\n    char_u\t*Buf, *p;\n\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL && other_sourcing_name())\n    {\n\tchar_u\t    *sname = estack_sfile(ESTACK_NONE);\n\tchar_u\t    *tofree = sname;\n\n\tif (sname == NULL)\n\t    sname = SOURCING_NAME;\n\n#ifdef FEAT_EVAL\n\tif (estack_compiling)\n\t    p = (char_u *)_(\"Error detected while compiling %s:\");\n\telse\n#endif\n\t    p = (char_u *)_(\"Error detected while processing %s:\");\n\tBuf = alloc(STRLEN(sname) + STRLEN(p));\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, sname);\n\tvim_free(tofree);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Get the message about the source lnum, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_lnum(void)\n{\n    char_u\t*Buf, *p;\n\n    // lnum is 0 when executing a command from the command line\n    // argument, we don't want a line number then\n    if (SOURCING_NAME != NULL\n\t    && (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)\n\t    && SOURCING_LNUM != 0)\n    {\n\tp = (char_u *)_(\"line %4ld:\");\n\tBuf = alloc(STRLEN(p) + 20);\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, (long)SOURCING_LNUM);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Display name and line number for the source of an error.\n * Remember the file name and line number, so that for the next error the info\n * is only displayed if it changed.\n */\n    void\nmsg_source(int attr)\n{\n    char_u\t*p;\n    static int\trecursive = FALSE;\n\n    // Bail out if something called here causes an error.\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n\n    ++no_wait_return;\n    p = get_emsg_source();\n    if (p != NULL)\n    {\n\tmsg_scroll = TRUE;  // this will take more than one line\n\tmsg_attr((char *)p, attr);\n\tvim_free(p);\n    }\n    p = get_emsg_lnum();\n    if (p != NULL)\n    {\n\tmsg_attr((char *)p, HL_ATTR(HLF_N));\n\tvim_free(p);\n\tlast_sourcing_lnum = SOURCING_LNUM;  // only once for each line\n    }\n\n    // remember the last sourcing name printed, also when it's empty\n    if (SOURCING_NAME == NULL || other_sourcing_name())\n    {\n\tVIM_CLEAR(last_sourcing_name);\n\tif (SOURCING_NAME != NULL)\n\t    last_sourcing_name = vim_strsave(SOURCING_NAME);\n    }\n    --no_wait_return;\n\n    recursive = FALSE;\n}\n\n/*\n * Return TRUE if not giving error messages right now:\n * If \"emsg_off\" is set: no error messages at the moment.\n * If \"msg\" is in 'debug': do error message but without side effects.\n * If \"emsg_skip\" is set: never do error messages.\n */\n    static int\nemsg_not_now(void)\n{\n    if ((emsg_off > 0 && vim_strchr(p_debug, 'm') == NULL\n\t\t\t\t\t  && vim_strchr(p_debug, 't') == NULL)\n#ifdef FEAT_EVAL\n\t    || emsg_skip > 0\n#endif\n\t    )\n\treturn TRUE;\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic garray_T ignore_error_list = GA_EMPTY;\n\n    void\nignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP(\"RESET\", error) == 0)\n\tga_clear_strings(&ignore_error_list);\n    else\n\tga_copy_string(&ignore_error_list, error);\n}\n\n    static int\nignore_error(char_u *msg)\n{\n    int i;\n\n    for (i = 0; i < ignore_error_list.ga_len; ++i)\n\tif (strstr((char *)msg,\n\t\t  (char *)((char_u **)(ignore_error_list.ga_data))[i]) != NULL)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n#if !defined(HAVE_STRERROR) || defined(PROTO)\n/*\n * Replacement for perror() that behaves more or less like emsg() was called.\n * v:errmsg will be set and called_emsg will be incremented.\n */\n    void\ndo_perror(char *msg)\n{\n    perror(msg);\n    ++emsg_silent;\n    emsg(msg);\n    --emsg_silent;\n}\n#endif\n\n/*\n * emsg_core() - display an error message\n *\n * Rings the bell, if appropriate, and calls message() to do the real work\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n *\n * Return TRUE if wait_return() not called.\n * Note: caller must check 'emsg_not_now()' before calling this.\n */\n    static int\nemsg_core(char_u *s)\n{\n    int\t\tattr;\n    char_u\t*p;\n    int\t\tr;\n#ifdef FEAT_EVAL\n    int\t\tignore = FALSE;\n    int\t\tsevere;\n#endif\n\n#ifdef FEAT_EVAL\n    // When testing some errors are turned into a normal message.\n    if (ignore_error(s))\n\t// don't call msg() if it results in a dialog\n\treturn msg_use_printf() ? FALSE : msg((char *)s);\n#endif\n\n    ++called_emsg;\n\n#ifdef FEAT_EVAL\n    // If \"emsg_severe\" is TRUE: When an error exception is to be thrown,\n    // prefer this message over previous messages for the same command.\n    severe = emsg_severe;\n    emsg_severe = FALSE;\n#endif\n\n    if (!emsg_off || vim_strchr(p_debug, 't') != NULL)\n    {\n#ifdef FEAT_EVAL\n\t/*\n\t * Cause a throw of an error exception if appropriate.  Don't display\n\t * the error message in this case.  (If no matching catch clause will\n\t * be found, the message will be displayed later on.)  \"ignore\" is set\n\t * when the message should be ignored completely (used for the\n\t * interrupt message).\n\t */\n\tif (cause_errthrow(s, severe, &ignore) == TRUE)\n\t{\n\t    if (!ignore)\n\t\t++did_emsg;\n\t    return TRUE;\n\t}\n\n\tif (in_assert_fails && emsg_assert_fails_msg == NULL)\n\t{\n\t    emsg_assert_fails_msg = vim_strsave(s);\n\t    emsg_assert_fails_lnum = SOURCING_LNUM;\n\t    vim_free(emsg_assert_fails_context);\n\t    emsg_assert_fails_context = vim_strsave(\n\t\t\t SOURCING_NAME == NULL ? (char_u *)\"\" : SOURCING_NAME);\n\t}\n\n\t// set \"v:errmsg\", also when using \":silent! cmd\"\n\tset_vim_var_string(VV_ERRMSG, s, -1);\n#endif\n\n\t/*\n\t * When using \":silent! cmd\" ignore error messages.\n\t * But do write it to the redirection file.\n\t */\n\tif (emsg_silent != 0)\n\t{\n#ifdef FEAT_EVAL\n\t    ++did_emsg_silent;\n#endif\n\t    if (emsg_noredir == 0)\n\t    {\n\t\tmsg_start();\n\t\tp = get_emsg_source();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tp = get_emsg_lnum();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tredir_write(s, -1);\n\t    }\n#ifdef FEAT_EVAL\n\t    // Only increment did_emsg_def when :silent! wasn't used inside the\n\t    // :def function.\n\t    if (emsg_silent == emsg_silent_def)\n\t\t++did_emsg_def;\n#endif\n#ifdef FEAT_EVAL\n\t    ch_log(NULL, \"ERROR silent: %s\", (char *)s);\n#endif\n\t    return TRUE;\n\t}\n\n\tex_exitval = 1;\n\n\t// Reset msg_silent, an error causes messages to be switched back on.\n\tmsg_silent = 0;\n\tcmd_silent = FALSE;\n\n\tif (global_busy)\t\t// break :global command\n\t    ++global_busy;\n\n\tif (p_eb)\n\t    beep_flush();\t\t// also includes flush_buffers()\n\telse\n\t    flush_buffers(FLUSH_MINIMAL);  // flush internal buffers\n\t++did_emsg;\t\t\t   // flag for DoOneCmd()\n#ifdef FEAT_EVAL\n\t++uncaught_emsg;\n#endif\n    }\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (!in_echowindow)\n#endif\n\temsg_on_display = TRUE;\t    // remember there is an error message\n\n    attr = HL_ATTR(HLF_E);\t    // set highlight mode for error messages\n    if (msg_scrolled != 0)\n\tneed_wait_return = TRUE;    // needed in case emsg() is called after\n\t\t\t\t    // wait_return() has reset need_wait_return\n\t\t\t\t    // and a redraw is expected because\n\t\t\t\t    // msg_scrolled is non-zero\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = TRUE;\n#endif\n    /*\n     * Display name and line number for the source of the error.\n     */\n    msg_scroll = TRUE;\n    msg_source(attr);\n\n    /*\n     * Display the error message itself.\n     */\n    msg_nowait = FALSE;\t\t\t// wait for this msg\n    r = msg_attr((char *)s, attr);\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = FALSE;\n#endif\n    return r;\n}\n\n/*\n * Print an error message.\n */\n    int\nemsg(char *s)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n\treturn emsg_core((char_u *)s);\n    return TRUE;\t\t// no error messages at the moment\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Print an error message with format string and variable arguments.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    int\nsemsg(const char *s, ...)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    return emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    return emsg_core(IObuff);\n\t}\n    }\n    return TRUE;\t\t// no error messages at the moment\n}\n#endif\n\n/*\n * Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n */\n    void\niemsg(char *s)\n{\n    if (!emsg_not_now())\n    {\n\temsg_core((char_u *)s);\n#if defined(ABORT_ON_INTERNAL_ERROR) && defined(FEAT_EVAL)\n\tset_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n\tmsg_putchar('\\n');  // avoid overwriting the error message\n\tout_flush();\n\tabort();\n#endif\n    }\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    void\nsiemsg(const char *s, ...)\n{\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    emsg_core(IObuff);\n\t}\n# ifdef ABORT_ON_INTERNAL_ERROR\n\tmsg_putchar('\\n');  // avoid overwriting the error message\n\tout_flush();\n\tabort();\n# endif\n    }\n}\n#endif\n\n/*\n * Give an \"Internal error\" message.\n */\n    void\ninternal_error(char *where)\n{\n    siemsg(_(e_internal_error_str), where);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Like internal_error() but do not call abort(), to avoid tests using\n * test_unknown() and test_void() causing Vim to exit.\n */\n    void\ninternal_error_no_abort(char *where)\n{\n     semsg(_(e_internal_error_str), where);\n}\n#endif\n\n// emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes.\n\n    void\nemsg_invreg(int name)\n{\n    semsg(_(e_invalid_register_name_str), transchar(name));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Give an error message which contains %s for \"name[len]\".\n */\n    void\nemsg_namelen(char *msg, char_u *name, int len)\n{\n    char_u *copy = vim_strnsave(name, len);\n\n    semsg(msg, copy == NULL ? \"NULL\" : (char *)copy);\n    vim_free(copy);\n}\n#endif\n\n/*\n * Like msg(), but truncate to a single line if p_shm contains 't', or when\n * \"force\" is TRUE.  This truncates in another way as for normal messages.\n * Careful: The string may be changed by msg_may_trunc()!\n * Returns a pointer to the printed message, if wait_return() not called.\n */\n    char *\nmsg_trunc_attr(char *s, int force, int attr)\n{\n    int\t\tn;\n    char\t*ts;\n\n    // Add message to history before truncating\n    add_msg_hist((char_u *)s, -1, attr);\n\n    ts = (char *)msg_may_trunc(force, (char_u *)s);\n\n    msg_hist_off = TRUE;\n    n = msg_attr(ts, attr);\n    msg_hist_off = FALSE;\n\n    if (n)\n\treturn ts;\n    return NULL;\n}\n\n/*\n * Check if message \"s\" should be truncated at the start (for filenames).\n * Return a pointer to where the truncated message starts.\n * Note: May change the message by replacing a character with '<'.\n */\n    char_u *\nmsg_may_trunc(int force, char_u *s)\n{\n    int\t\tn;\n    int\t\troom;\n\n    // If 'cmdheight' is zero or something unexpected happened \"room\" may be\n    // negative.\n    room = (int)(Rows - cmdline_row - 1) * Columns + sc_col - 1;\n    if (room > 0 && (force || (shortmess(SHM_TRUNC) && !exmode_active))\n\t    && (n = (int)STRLEN(s) - room) > 0)\n    {\n\tif (has_mbyte)\n\t{\n\t    int\tsize = vim_strsize(s);\n\n\t    // There may be room anyway when there are multibyte chars.\n\t    if (size <= room)\n\t\treturn s;\n\n\t    for (n = 0; size >= room; )\n\t    {\n\t\tsize -= (*mb_ptr2cells)(s + n);\n\t\tn += (*mb_ptr2len)(s + n);\n\t    }\n\t    --n;\n\t}\n\ts += n;\n\t*s = '<';\n    }\n    return s;\n}\n\n    static void\nadd_msg_hist(\n    char_u\t*s,\n    int\t\tlen,\t\t// -1 for undetermined length\n    int\t\tattr)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_off || msg_silent != 0)\n\treturn;\n\n    // Don't let the message history get too big\n    while (msg_hist_len > MAX_MSG_HIST_LEN)\n\t(void)delete_first_msg();\n\n    // allocate an entry and add the message at the end of the history\n    p = ALLOC_ONE(struct msg_hist);\n    if (p != NULL)\n    {\n\tif (len < 0)\n\t    len = (int)STRLEN(s);\n\t// remove leading and trailing newlines\n\twhile (len > 0 && *s == '\\n')\n\t{\n\t    ++s;\n\t    --len;\n\t}\n\twhile (len > 0 && s[len - 1] == '\\n')\n\t    --len;\n\tp->msg = vim_strnsave(s, len);\n\tp->next = NULL;\n\tp->attr = attr;\n\tif (last_msg_hist != NULL)\n\t    last_msg_hist->next = p;\n\tlast_msg_hist = p;\n\tif (first_msg_hist == NULL)\n\t    first_msg_hist = last_msg_hist;\n\t++msg_hist_len;\n    }\n}\n\n/*\n * Delete the first (oldest) message from the history.\n * Returns FAIL if there are no messages.\n */\n    int\ndelete_first_msg(void)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_len <= 0)\n\treturn FAIL;\n    p = first_msg_hist;\n    first_msg_hist = p->next;\n    if (first_msg_hist == NULL)\n\tlast_msg_hist = NULL;  // history is empty\n    vim_free(p->msg);\n    vim_free(p);\n    --msg_hist_len;\n    return OK;\n}\n\n/*\n * \":messages\" command.\n */\n    void\nex_messages(exarg_T *eap)\n{\n    struct msg_hist *p;\n    char_u\t    *s;\n    int\t\t    c = 0;\n\n    if (STRCMP(eap->arg, \"clear\") == 0)\n    {\n\tint keep = eap->addr_count == 0 ? 0 : eap->line2;\n\n\twhile (msg_hist_len > keep)\n\t    (void)delete_first_msg();\n\treturn;\n    }\n\n    if (*eap->arg != NUL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    msg_hist_off = TRUE;\n\n    p = first_msg_hist;\n    if (eap->addr_count != 0)\n    {\n\t// Count total messages\n\tfor (; p != NULL && !got_int; p = p->next)\n\t    c++;\n\n\tc -= eap->line2;\n\n\t// Skip without number of messages specified\n\tfor (p = first_msg_hist; p != NULL && !got_int && c > 0;\n\t\t\t\t\t\t    p = p->next, c--);\n    }\n\n    if (p == first_msg_hist)\n    {\n#ifdef FEAT_MULTI_LANG\n\ts = get_mess_lang();\n#else\n\ts = mch_getenv((char_u *)\"LANG\");\n#endif\n\tif (s != NULL && *s != NUL)\n\t    // The next comment is extracted by xgettext and put in po file for\n\t    // translators to read.\n\t    msg_attr(\n\t\t    // Translator: Please replace the name and email address\n\t\t    // with the appropriate text for your translation.\n\t\t    _(\"Messages maintainer: Bram Moolenaar <Bram@vim.org>\"),\n\t\t    HL_ATTR(HLF_T));\n    }\n\n    // Display what was not skipped.\n    for (; p != NULL && !got_int; p = p->next)\n\tif (p->msg != NULL)\n\t    msg_attr((char *)p->msg, p->attr);\n\n    msg_hist_off = FALSE;\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(FIND_REPLACE_DIALOG) || defined(PROTO)\n/*\n * Call this after prompting the user.  This will avoid a hit-return message\n * and a delay.\n */\n    void\nmsg_end_prompt(void)\n{\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    cmdline_row = msg_row;\n    msg_col = 0;\n    msg_clr_eos();\n    lines_left = -1;\n}\n#endif\n\n/*\n * Wait for the user to hit a key (normally Enter).\n * If \"redraw\" is TRUE, clear and redraw the screen.\n * If \"redraw\" is FALSE, just redraw the screen.\n * If \"redraw\" is -1, don't redraw at all.\n */\n    void\nwait_return(int redraw)\n{\n    int\t\tc;\n    int\t\toldState;\n    int\t\ttmpState;\n    int\t\thad_got_int;\n    int\t\tsave_reg_recording;\n    FILE\t*save_scriptout;\n\n    if (redraw == TRUE)\n\tset_must_redraw(UPD_CLEAR);\n\n    // If using \":silent cmd\", don't wait for a return.  Also don't set\n    // need_wait_return to do it later.\n    if (msg_silent != 0)\n\treturn;\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;\n#endif\n\n    /*\n     * When inside vgetc(), we can't wait for a typed character at all.\n     * With the global command (and some others) we only need one return at\n     * the end. Adjust cmdline_row to avoid the next message overwriting the\n     * last one.\n     */\n    if (vgetc_busy > 0)\n\treturn;\n    need_wait_return = TRUE;\n    if (no_wait_return)\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\treturn;\n    }\n\n    redir_off = TRUE;\t\t// don't redirect this message\n    oldState = State;\n    if (quit_more)\n    {\n\tc = CAR;\t\t// just pretend CR was hit\n\tquit_more = FALSE;\n\tgot_int = FALSE;\n    }\n    else if (exmode_active)\n    {\n\tmsg_puts(\" \");\t\t// make sure the cursor is on the right line\n\tc = CAR;\t\t// no need for a return in ex mode\n\tgot_int = FALSE;\n    }\n    else\n    {\n\t// Make sure the hit-return prompt is on screen when 'guioptions' was\n\t// just changed.\n\tscreenalloc(FALSE);\n\n\tState = MODE_HITRETURN;\n\tsetmouse();\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\tcmdline_row = msg_row;\n\n\t// Avoid the sequence that the user types \":\" at the hit-return prompt\n\t// to start an Ex command, but the file-changed dialog gets in the\n\t// way.\n\tif (need_check_timestamps)\n\t    check_timestamps(FALSE);\n\n\thit_return_msg();\n\n\tdo\n\t{\n\t    // Remember \"got_int\", if it is set vgetc() probably returns a\n\t    // CTRL-C, but we need to loop then.\n\t    had_got_int = got_int;\n\n\t    // Don't do mappings here, we put the character back in the\n\t    // typeahead buffer.\n\t    ++no_mapping;\n\t    ++allow_keys;\n\n\t    // Temporarily disable Recording. If Recording is active, the\n\t    // character will be recorded later, since it will be added to the\n\t    // typebuf after the loop\n\t    save_reg_recording = reg_recording;\n\t    save_scriptout = scriptout;\n\t    reg_recording = 0;\n\t    scriptout = NULL;\n\t    c = safe_vgetc();\n\t    if (had_got_int && !global_busy)\n\t\tgot_int = FALSE;\n\t    --no_mapping;\n\t    --allow_keys;\n\t    reg_recording = save_reg_recording;\n\t    scriptout = save_scriptout;\n\n#ifdef FEAT_CLIPBOARD\n\t    // Strange way to allow copying (yanking) a modeless selection at\n\t    // the hit-enter prompt.  Use CTRL-Y, because the same is used in\n\t    // Cmdline-mode and it's harmless when there is no selection.\n\t    if (c == Ctrl_Y && clip_star.state == SELECT_DONE)\n\t    {\n\t\tclip_copy_modeless_selection(TRUE);\n\t\tc = K_IGNORE;\n\t    }\n#endif\n\n\t    /*\n\t     * Allow scrolling back in the messages.\n\t     * Also accept scroll-down commands when messages fill the screen,\n\t     * to avoid that typing one 'j' too many makes the messages\n\t     * disappear.\n\t     */\n\t    if (p_more && !p_cp)\n\t    {\n\t\tif (c == 'b' || c == 'k' || c == 'u' || c == 'g'\n\t\t\t\t\t\t|| c == K_UP || c == K_PAGEUP)\n\t\t{\n\t\t    if (msg_scrolled > Rows)\n\t\t\t// scroll back to show older messages\n\t\t\tdo_more_prompt(c);\n\t\t    else\n\t\t    {\n\t\t\tmsg_didout = FALSE;\n\t\t\tc = K_IGNORE;\n\t\t\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t\t\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t\t\t    0;\n\t\t    }\n\t\t    if (quit_more)\n\t\t    {\n\t\t\tc = CAR;\t\t// just pretend CR was hit\n\t\t\tquit_more = FALSE;\n\t\t\tgot_int = FALSE;\n\t\t    }\n\t\t    else if (c != K_IGNORE)\n\t\t    {\n\t\t\tc = K_IGNORE;\n\t\t\thit_return_msg();\n\t\t    }\n\t\t}\n\t\telse if (msg_scrolled > Rows - 2\n\t\t\t && (c == 'j' || c == 'd' || c == 'f'\n\t\t\t\t\t   || c == K_DOWN || c == K_PAGEDOWN))\n\t\t    c = K_IGNORE;\n\t    }\n\t} while ((had_got_int && c == Ctrl_C)\n\t\t\t\t|| c == K_IGNORE\n#ifdef FEAT_GUI\n\t\t\t\t|| c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR\n#endif\n\t\t\t\t|| c == K_LEFTDRAG   || c == K_LEFTRELEASE\n\t\t\t\t|| c == K_MIDDLEDRAG || c == K_MIDDLERELEASE\n\t\t\t\t|| c == K_RIGHTDRAG  || c == K_RIGHTRELEASE\n\t\t\t\t|| c == K_MOUSELEFT  || c == K_MOUSERIGHT\n\t\t\t\t|| c == K_MOUSEDOWN  || c == K_MOUSEUP\n\t\t\t\t|| c == K_MOUSEMOVE\n\t\t\t\t|| (!mouse_has(MOUSE_RETURN)\n\t\t\t\t    && mouse_row < msg_row\n\t\t\t\t    && (c == K_LEFTMOUSE\n\t\t\t\t\t|| c == K_MIDDLEMOUSE\n\t\t\t\t\t|| c == K_RIGHTMOUSE\n\t\t\t\t\t|| c == K_X1MOUSE\n\t\t\t\t\t|| c == K_X2MOUSE))\n\t\t\t\t);\n\tui_breakcheck();\n\n\t// Avoid that the mouse-up event causes Visual mode to start.\n\tif (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE\n\t\t\t\t\t  || c == K_X1MOUSE || c == K_X2MOUSE)\n\t    (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);\n\telse if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C)\n\t{\n\t    // Put the character back in the typeahead buffer.  Don't use the\n\t    // stuff buffer, because lmaps wouldn't work.\n\t    ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\t    do_redraw = TRUE;\t    // need a redraw even though there is\n\t\t\t\t    // typeahead\n\t}\n    }\n    redir_off = FALSE;\n\n    /*\n     * If the user hits ':', '?' or '/' we get a command line from the next\n     * line.\n     */\n    if (c == ':' || c == '?' || c == '/')\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\tskip_redraw = TRUE;\t    // skip redraw once\n\tdo_redraw = FALSE;\n#ifdef FEAT_TERMINAL\n\tskip_term_loop = TRUE;\n#endif\n    }\n\n    /*\n     * If the window size changed set_shellsize() will redraw the screen.\n     * Otherwise the screen is only redrawn if 'redraw' is set and no ':'\n     * typed.\n     */\n    tmpState = State;\n    State = oldState;\t\t    // restore State before set_shellsize\n    setmouse();\n    msg_check();\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * When switching screens, we need to output an extra newline on exit.\n     */\n    if (swapping_screen() && !termcap_active)\n\tnewline_on_exit = TRUE;\n#endif\n\n    need_wait_return = FALSE;\n    did_wait_return = TRUE;\n    emsg_on_display = FALSE;\t// can delete error message now\n    lines_left = -1;\t\t// reset lines_left at next msg_start()\n    reset_last_sourcing();\n    if (keep_msg != NULL && vim_strsize(keep_msg) >=\n\t\t\t\t  (Rows - cmdline_row - 1) * Columns + sc_col)\n\tVIM_CLEAR(keep_msg);\t    // don't redisplay message, it's too long\n\n    if (tmpState == MODE_SETWSIZE)  // got resize event while in vgetc()\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tshell_resized();\n    }\n    else if (!skip_redraw\n\t    && (redraw == TRUE || (msg_scrolled != 0 && redraw != -1)))\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tredraw_later(UPD_VALID);\n    }\n}\n\n/*\n * Write the hit-return prompt.\n */\n    static void\nhit_return_msg(void)\n{\n    int\t\tsave_p_more = p_more;\n\n    p_more = FALSE;\t// don't want to see this message when scrolling back\n    if (msg_didout)\t// start on a new line\n\tmsg_putchar('\\n');\n    if (got_int)\n\tmsg_puts(_(\"Interrupt: \"));\n\n    msg_puts_attr(_(\"Press ENTER or type command to continue\"), HL_ATTR(HLF_R));\n    if (!msg_use_printf())\n\tmsg_clr_eos();\n    p_more = save_p_more;\n}\n\n/*\n * Set \"keep_msg\" to \"s\".  Free the old value and check for NULL pointer.\n */\n    void\nset_keep_msg(char_u *s, int attr)\n{\n    vim_free(keep_msg);\n    if (s != NULL && msg_silent == 0)\n\tkeep_msg = vim_strsave(s);\n    else\n\tkeep_msg = NULL;\n    keep_msg_more = FALSE;\n    keep_msg_attr = attr;\n}\n\n/*\n * If there currently is a message being displayed, set \"keep_msg\" to it, so\n * that it will be displayed again after redraw.\n */\n    void\nset_keep_msg_from_hist(void)\n{\n    if (keep_msg == NULL && last_msg_hist != NULL && msg_scrolled == 0\n\t\t\t\t\t\t      && (State & MODE_NORMAL))\n\tset_keep_msg(last_msg_hist->msg, last_msg_hist->attr);\n}\n\n/*\n * Prepare for outputting characters in the command line.\n */\n    void\nmsg_start(void)\n{\n    int\t\tdid_return = FALSE;\n\n    if (!msg_silent)\n    {\n\tVIM_CLEAR(keep_msg);\n\tneed_fileinfo = FALSE;\n    }\n\n#ifdef FEAT_EVAL\n    if (need_clr_eos)\n    {\n\t// Halfway an \":echo\" command and getting an (error) message: clear\n\t// any text from the command.\n\tneed_clr_eos = FALSE;\n\tmsg_clr_eos();\n    }\n#endif\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n    {\n\tif (popup_message_win_visible()\n\t\t    && ((msg_col > 0 && (msg_scroll || !full_screen))\n\t\t\t|| in_echowindow))\n\t{\n\t    win_T *wp = popup_get_message_win();\n\n\t    // start a new line\n\t    curbuf = wp->w_buffer;\n\t    ml_append(wp->w_buffer->b_ml.ml_line_count,\n\t\t\t\t\t      (char_u *)\"\", (colnr_T)0, FALSE);\n\t    curbuf = curwin->w_buffer;\n\t}\n\tmsg_col = 0;\n    }\n    else\n#endif\n\tif (!msg_scroll && full_screen)\t// overwrite last message\n    {\n\tmsg_row = cmdline_row;\n\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t    0;\n    }\n    else if (msg_didout || in_echowindow)\n    {\n\t// start message on next line\n\tmsg_putchar('\\n');\n\tdid_return = TRUE;\n\tif (exmode_active != EXMODE_NORMAL)\n\t    cmdline_row = msg_row;\n    }\n    if (!msg_didany || lines_left < 0)\n\tmsg_starthere();\n    if (msg_silent == 0)\n    {\n\tmsg_didout = FALSE;\t\t    // no output on current line yet\n\tcursor_off();\n    }\n\n    // when redirecting, may need to start a new line.\n    if (!did_return)\n\tredir_write((char_u *)\"\\n\", -1);\n}\n\n/*\n * Note that the current msg position is where messages start.\n */\n    void\nmsg_starthere(void)\n{\n    lines_left = cmdline_row;\n    msg_didany = FALSE;\n}\n\n    void\nmsg_putchar(int c)\n{\n    msg_putchar_attr(c, 0);\n}\n\n    void\nmsg_putchar_attr(int c, int attr)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (IS_SPECIAL(c))\n    {\n\tbuf[0] = K_SPECIAL;\n\tbuf[1] = K_SECOND(c);\n\tbuf[2] = K_THIRD(c);\n\tbuf[3] = NUL;\n    }\n    else\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    msg_puts_attr((char *)buf, attr);\n}\n\n    void\nmsg_outnum(long n)\n{\n    char\tbuf[20];\n\n    sprintf(buf, \"%ld\", n);\n    msg_puts(buf);\n}\n\n    void\nmsg_home_replace(char_u *fname)\n{\n    msg_home_replace_attr(fname, 0);\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n    void\nmsg_home_replace_hl(char_u *fname)\n{\n    msg_home_replace_attr(fname, HL_ATTR(HLF_D));\n}\n#endif\n\n    static void\nmsg_home_replace_attr(char_u *fname, int attr)\n{\n    char_u\t*name;\n\n    name = home_replace_save(NULL, fname);\n    if (name != NULL)\n\tmsg_outtrans_attr(name, attr);\n    vim_free(name);\n}\n\n/*\n * Output 'len' characters in 'str' (including NULs) with translation\n * if 'len' is -1, output up to a NUL character.\n * Use attributes 'attr'.\n * Return the number of characters it takes on the screen.\n */\n    int\nmsg_outtrans(char_u *str)\n{\n    return msg_outtrans_attr(str, 0);\n}\n\n    int\nmsg_outtrans_attr(char_u *str, int attr)\n{\n    return msg_outtrans_len_attr(str, (int)STRLEN(str), attr);\n}\n\n    int\nmsg_outtrans_len(char_u *str, int len)\n{\n    return msg_outtrans_len_attr(str, len, 0);\n}\n\n/*\n * Output one character at \"p\".  Return pointer to the next character.\n * Handles multi-byte characters.\n */\n    char_u *\nmsg_outtrans_one(char_u *p, int attr)\n{\n    int\t\tl;\n\n    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n    {\n\tmsg_outtrans_len_attr(p, l, attr);\n\treturn p + l;\n    }\n    msg_puts_attr((char *)transchar_byte(*p), attr);\n    return p + 1;\n}\n\n    int\nmsg_outtrans_len_attr(char_u *msgstr, int len, int attr)\n{\n    int\t\tretval = 0;\n    char_u\t*str = msgstr;\n    char_u\t*plain_start = msgstr;\n    char_u\t*s;\n    int\t\tmb_l;\n    int\t\tc;\n    int\t\tsave_got_int = got_int;\n\n    // Only quit when got_int was set in here.\n    got_int = FALSE;\n\n    // if MSG_HIST flag set, add message to history\n    if (attr & MSG_HIST)\n    {\n\tadd_msg_hist(str, len, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // If the string starts with a composing character first draw a space on\n    // which the composing char can be drawn.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))\n\tmsg_puts_attr(\" \", attr);\n\n    /*\n     * Go over the string.  Special characters are translated and printed.\n     * Normal characters are printed several at a time.\n     */\n    while (--len >= 0 && !got_int)\n    {\n\tif (enc_utf8)\n\t    // Don't include composing chars after the end.\n\t    mb_l = utfc_ptr2len_len(str, len + 1);\n\telse if (has_mbyte)\n\t    mb_l = (*mb_ptr2len)(str);\n\telse\n\t    mb_l = 1;\n\tif (has_mbyte && mb_l > 1)\n\t{\n\t    c = (*mb_ptr2char)(str);\n\t    if (vim_isprintc(c))\n\t\t// printable multi-byte char: count the cells.\n\t\tretval += (*mb_ptr2cells)(str);\n\t    else\n\t    {\n\t\t// unprintable multi-byte char: print the printable chars so\n\t\t// far and the translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + mb_l;\n\t\tmsg_puts_attr((char *)transchar(c),\n\t\t\t\t\t    attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += char2cells(c);\n\t    }\n\t    len -= mb_l - 1;\n\t    str += mb_l;\n\t}\n\telse\n\t{\n\t    s = transchar_byte(*str);\n\t    if (s[1] != NUL)\n\t    {\n\t\t// unprintable char: print the printable chars so far and the\n\t\t// translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + 1;\n\t\tmsg_puts_attr((char *)s, attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += (int)STRLEN(s);\n\t    }\n\t    else\n\t\t++retval;\n\t    ++str;\n\t}\n    }\n\n    if (str > plain_start && !got_int)\n\t// print the printable chars at the end\n\tmsg_puts_attr_len((char *)plain_start, (int)(str - plain_start), attr);\n\n    got_int |= save_got_int;\n\n    return retval;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    void\nmsg_make(char_u *arg)\n{\n    int\t    i;\n    static char_u *str = (char_u *)\"eeffoc\", *rs = (char_u *)\"Plon#dqg#vxjduB\";\n\n    arg = skipwhite(arg);\n    for (i = 5; *arg && i >= 0; --i)\n\tif (*arg++ != str[i])\n\t    break;\n    if (i < 0)\n    {\n\tmsg_putchar('\\n');\n\tfor (i = 0; rs[i]; ++i)\n\t    msg_putchar(rs[i] - 3);\n    }\n}\n#endif\n\n/*\n * Output the string 'str' up to a NUL character.\n * Return the number of characters it takes on the screen.\n *\n * If K_SPECIAL is encountered, then it is taken in conjunction with the\n * following character and shown as <F1>, <S-Up> etc.  Any other character\n * which is not printable shown in <> form.\n * If 'from' is TRUE (lhs of a mapping), a space is shown as <Space>.\n * If a character is displayed in one of these special ways, is also\n * highlighted (its highlight name is '8' in the p_hl variable).\n * Otherwise characters are not highlighted.\n * This function is used to show mappings, where we want to see how to type\n * the character/string -- webb\n */\n    int\nmsg_outtrans_special(\n    char_u\t*strstart,\n    int\t\tfrom,\t// TRUE for lhs of a mapping\n    int\t\tmaxlen) // screen columns, 0 for unlimited\n{\n    char_u\t*str = strstart;\n    int\t\tretval = 0;\n    char\t*text;\n    int\t\tattr;\n    int\t\tlen;\n\n    attr = HL_ATTR(HLF_8);\n    while (*str != NUL)\n    {\n\t// Leading and trailing spaces need to be displayed in <> form.\n\tif ((str == strstart || str[1] == NUL) && *str == ' ')\n\t{\n\t    text = \"<Space>\";\n\t    ++str;\n\t}\n\telse\n\t    text = (char *)str2special(&str, from, FALSE);\n\tif (text[0] != NUL && text[1] == NUL)\n\t    // single-byte character or illegal byte\n\t    text = (char *)transchar_byte((char_u)text[0]);\n\tlen = vim_strsize((char_u *)text);\n\tif (maxlen > 0 && retval + len >= maxlen)\n\t    break;\n\t// Highlight special keys\n\tmsg_puts_attr(text, len > 1\n\t\t&& (*mb_ptr2len)((char_u *)text) <= 1 ? attr : 0);\n\tretval += len;\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return the lhs or rhs of a mapping, with the key codes turned into printable\n * strings, in an allocated string.\n */\n    char_u *\nstr2special_save(\n    char_u  *str,\n    int\t    replace_spaces,\t// TRUE to replace \" \" with \"<Space>\".\n\t\t\t\t// used for the lhs of mapping and keytrans().\n    int\t    replace_lt)\t\t// TRUE to replace \"<\" with \"<lt>\".\n{\n    garray_T\tga;\n    char_u\t*p = str;\n\n    ga_init2(&ga, 1, 40);\n    while (*p != NUL)\n\tga_concat(&ga, str2special(&p, replace_spaces, replace_lt));\n    ga_append(&ga, NUL);\n    return (char_u *)ga.ga_data;\n}\n#endif\n\n/*\n * Return the printable string for the key codes at \"*sp\".\n * On illegal byte return a string with only that byte.\n * Used for translating the lhs or rhs of a mapping to printable chars.\n * Advances \"sp\" to the next code.\n */\n    char_u *\nstr2special(\n    char_u\t**sp,\n    int\t\treplace_spaces,\t// TRUE to replace \" \" with \"<Space>\".\n\t\t\t\t// used for the lhs of mapping and keytrans().\n    int\t\treplace_lt)\t// TRUE to replace \"<\" with \"<lt>\".\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\n\t// Try to un-escape a multi-byte character.  Return the un-escaped\n\t// string if it is a multi-byte character.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n\n    c = *str;\n    if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t// special key\n\t    special = TRUE;\n    }\n\n    if (has_mbyte && !IS_SPECIAL(c) && MB_BYTE2LEN(c) > 1)\n    {\n\tchar_u\t*p;\n\n\t*sp = str;\n\t// Try to un-escape a multi-byte character after modifiers.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    // Since 'special' is TRUE the multi-byte character 'c' will be\n\t    // processed by get_special_key_name()\n\t    c = (*mb_ptr2char)(p);\n\telse\n\t    // illegal byte\n\t    *sp = str + 1;\n    }\n    else\n\t// single-byte character, NUL or illegal byte\n\t*sp = str + (*str == NUL ? 0 : 1);\n\n    // Make special keys and C0 control characters in <> form, also <M-Space>.\n    if (special\n\t|| c < ' '\n\t|| (replace_spaces && c == ' ')\n\t|| (replace_lt && c == '<'))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}\n\n/*\n * Translate a key sequence into special key names.\n */\n    void\nstr2specialbuf(char_u *sp, char_u *buf, int len)\n{\n    char_u\t*s;\n\n    *buf = NUL;\n    while (*sp)\n    {\n\ts = str2special(&sp, FALSE, FALSE);\n\tif ((int)(STRLEN(s) + STRLEN(buf)) < len)\n\t    STRCAT(buf, s);\n    }\n}\n\n/*\n * print line for :print or :list command\n */\n    void\nmsg_prt_line(char_u *s, int list)\n{\n    int\t\tc;\n    int\t\tcol = 0;\n    int\t\tn_extra = 0;\n    int\t\tc_extra = 0;\n    int\t\tc_final = 0;\n    char_u\t*p_extra = NULL;\t    // init to make SASC shut up\n    int\t\tn;\n    int\t\tattr = 0;\n    char_u\t*trail = NULL;\n    char_u\t*lead = NULL;\n    int\t\tin_multispace = FALSE;\n    int\t\tmultispace_pos = 0;\n    int\t\tl;\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (curwin->w_p_list)\n\tlist = TRUE;\n\n    if (list)\n    {\n\t// find start of trailing whitespace\n\tif (curwin->w_lcs_chars.trail)\n\t{\n\t    trail = s + STRLEN(s);\n\t    while (trail > s && VIM_ISWHITE(trail[-1]))\n\t\t--trail;\n\t}\n\t// find end of leading whitespace\n\tif (curwin->w_lcs_chars.lead\n\t\t\t\t || curwin->w_lcs_chars.leadmultispace != NULL)\n\t{\n\t    lead = s;\n\t    while (VIM_ISWHITE(lead[0]))\n\t\tlead++;\n\t    // in a line full of spaces all of them are treated as trailing\n\t    if (*lead == NUL)\n\t\tlead = NULL;\n\t}\n    }\n\n    // output a space for an empty line, otherwise the line will be\n    // overwritten\n    if (*s == NUL && !(list && curwin->w_lcs_chars.eol != NUL))\n\tmsg_putchar(' ');\n\n    while (!got_int)\n    {\n\tif (n_extra > 0)\n\t{\n\t    --n_extra;\n\t    if (n_extra == 0 && c_final)\n\t\tc = c_final;\n\t    else if (c_extra)\n\t\tc = c_extra;\n\t    else\n\t\tc = *p_extra++;\n\t}\n\telse if (has_mbyte && (l = (*mb_ptr2len)(s)) > 1)\n\t{\n\t    col += (*mb_ptr2cells)(s);\n\t    if (l >= MB_MAXBYTES)\n\t    {\n\t\tSTRCPY(buf, \"?\");\n\t    }\n\t    else if (curwin->w_lcs_chars.nbsp != NUL && list\n\t\t    && (mb_ptr2char(s) == 160\n\t\t\t|| mb_ptr2char(s) == 0x202f))\n\t    {\n\t\tint len = mb_char2bytes(curwin->w_lcs_chars.nbsp, buf);\n\n\t\tbuf[len] = NUL;\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(buf, s, (size_t)l);\n\t\tbuf[l] = NUL;\n\t    }\n\t    msg_puts((char *)buf);\n\t    s += l;\n\t    continue;\n\t}\n\telse\n\t{\n\t    attr = 0;\n\t    c = *s++;\n\t    in_multispace = c == ' '\n\t\t&& ((col > 0 && s[-2] == ' ') || *s == ' ');\n\t    if (!in_multispace)\n\t\tmultispace_pos = 0;\n\t    if (c == TAB && (!list || curwin->w_lcs_chars.tab1))\n\t    {\n\t\t// tab amount depends on current column\n#ifdef FEAT_VARTABS\n\t\tn_extra = tabstop_padding(col, curbuf->b_p_ts,\n\t\t\t\t\t\t    curbuf->b_p_vts_array) - 1;\n#else\n\t\tn_extra = curbuf->b_p_ts - col % curbuf->b_p_ts - 1;\n#endif\n\t\tif (!list)\n\t\t{\n\t\t    c = ' ';\n\t\t    c_extra = ' ';\n\t\t    c_final = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = (n_extra == 0 && curwin->w_lcs_chars.tab3)\n\t\t\t\t\t\t? curwin->w_lcs_chars.tab3\n\t\t\t\t\t\t: curwin->w_lcs_chars.tab1;\n\t\t    c_extra = curwin->w_lcs_chars.tab2;\n\t\t    c_final = curwin->w_lcs_chars.tab3;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t    else if (c == 160 && list && curwin->w_lcs_chars.nbsp != NUL)\n\t    {\n\t\tc = curwin->w_lcs_chars.nbsp;\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == NUL && list && curwin->w_lcs_chars.eol != NUL)\n\t    {\n\t\tp_extra = (char_u *)\"\";\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tn_extra = 1;\n\t\tc = curwin->w_lcs_chars.eol;\n\t\tattr = HL_ATTR(HLF_AT);\n\t\t--s;\n\t    }\n\t    else if (c != NUL && (n = byte2cells(c)) > 1)\n\t    {\n\t\tn_extra = n - 1;\n\t\tp_extra = transchar_byte(c);\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tc = *p_extra++;\n\t\t// Use special coloring to be able to distinguish <hex> from\n\t\t// the same in plain text.\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == ' ')\n\t    {\n\t\tif (list && lead != NULL && s <= lead && in_multispace\n\t\t\t&& curwin->w_lcs_chars.leadmultispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.leadmultispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.leadmultispace[multispace_pos]\n\t\t\t\t\t\t\t\t\t== NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (lead != NULL && s <= lead\n\t\t\t\t\t    && curwin->w_lcs_chars.lead != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.lead;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (trail != NULL && s > trail)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.trail;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && in_multispace\n\t\t\t&& curwin->w_lcs_chars.multispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.multispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.multispace[multispace_pos] == NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && curwin->w_lcs_chars.space != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.space;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t}\n\n\tif (c == NUL)\n\t    break;\n\n\tmsg_putchar_attr(c, attr);\n\tcol++;\n    }\n    msg_clr_eos();\n}\n\n/*\n * Use screen_puts() to output one multi-byte character.\n * Return the pointer \"s\" advanced to the next character.\n */\n    static char_u *\nscreen_puts_mbyte(char_u *s, int l, int attr)\n{\n    int\t\tcw;\n\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    cw = (*mb_ptr2cells)(s);\n    if (cw > 1 && (\n#ifdef FEAT_RIGHTLEFT\n\t\tcmdmsg_rl ? msg_col <= 1 :\n#endif\n\t\tmsg_col == Columns - 1))\n    {\n\t// Doesn't fit, print a highlighted '>' to fill it up.\n\tmsg_screen_putchar('>', HL_ATTR(HLF_AT));\n\treturn s;\n    }\n\n    screen_puts_len(s, l, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_col -= cw;\n\tif (msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tmsg_col += cw;\n\tif (msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n    return s + l;\n}\n\n/*\n * Output a string to the screen at position msg_row, msg_col.\n * Update msg_row and msg_col for the next message.\n */\n    void\nmsg_puts(char *s)\n{\n    msg_puts_attr(s, 0);\n}\n\n    void\nmsg_puts_title(char *s)\n{\n    msg_puts_attr(s, HL_ATTR(HLF_T));\n}\n\n/*\n * Show a message in such a way that it always fits in the line.  Cut out a\n * part in the middle and replace it with \"...\" when necessary.\n * Does not handle multi-byte characters!\n */\n    static void\nmsg_outtrans_long_len_attr(char_u *longstr, int len, int attr)\n{\n    int\t\tslen = len;\n    int\t\troom;\n\n    room = Columns - msg_col;\n    if (len > room && room >= 20)\n    {\n\tslen = (room - 3) / 2;\n\tmsg_outtrans_len_attr(longstr, slen, attr);\n\tmsg_puts_attr(\"...\", HL_ATTR(HLF_8));\n    }\n    msg_outtrans_len_attr(longstr + len - slen, slen, attr);\n}\n\n    void\nmsg_outtrans_long_attr(char_u *longstr, int attr)\n{\n    msg_outtrans_long_len_attr(longstr, (int)STRLEN(longstr), attr);\n}\n\n/*\n * Basic function for writing a message with highlight attributes.\n */\n    void\nmsg_puts_attr(char *s, int attr)\n{\n    msg_puts_attr_len(s, -1, attr);\n}\n\n/*\n * Like msg_puts_attr(), but with a maximum length \"maxlen\" (in bytes).\n * When \"maxlen\" is -1 there is no maximum length.\n * When \"maxlen\" is >= 0 the message is not put in the history.\n */\n    static void\nmsg_puts_attr_len(char *str, int maxlen, int attr)\n{\n    /*\n     * If redirection is on, also write to the redirection file.\n     */\n    redir_write((char_u *)str, maxlen);\n\n    /*\n     * Don't print anything when using \":silent cmd\".\n     */\n    if (msg_silent != 0)\n\treturn;\n\n    // if MSG_HIST flag set, add message to history\n    if ((attr & MSG_HIST) && maxlen < 0)\n    {\n\tadd_msg_hist((char_u *)str, -1, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // When writing something to the screen after it has scrolled, requires a\n    // wait-return prompt later.  Needed when scrolling, resetting\n    // need_wait_return after some prompt, and then outputting something\n    // without scrolling\n    // Not needed when only using CR to move the cursor.\n    if (msg_scrolled != 0 && !msg_scrolled_ign && STRCMP(str, \"\\r\") != 0)\n\tneed_wait_return = TRUE;\n    msg_didany = TRUE;\t\t// remember that something was outputted\n\n    /*\n     * If there is no valid screen, use fprintf so we can see error messages.\n     * If termcap is not active, we may be writing in an alternate console\n     * window, cursor positioning may not work correctly (window size may be\n     * different, e.g. for Win32 console) or we just don't know where the\n     * cursor is.\n     */\n    if (msg_use_printf())\n\tmsg_puts_printf((char_u *)str, maxlen);\n    else\n\tmsg_puts_display((char_u *)str, maxlen, attr, FALSE);\n\n    need_fileinfo = FALSE;\n}\n\n// values for \"where\"\n#define PUT_APPEND 0\t\t// append to \"lnum\"\n#define PUT_TRUNC 1\t\t// replace \"lnum\"\n#define PUT_BELOW 2\t\t// add below \"lnum\"\n\t\t\t\t//\n#ifdef HAS_MESSAGE_WINDOW\n/*\n * Put text \"t_s\" until \"end\" in the message window.\n * \"where\" specifies where to put the text.\n */\n    static void\nput_msg_win(win_T *wp, int where, char_u *t_s, char_u *end, linenr_T lnum)\n{\n    char_u  *p;\n\n    if (where == PUT_BELOW)\n    {\n\tif (*end != NUL)\n\t{\n\t    p = vim_strnsave(t_s, end - t_s);\n\t    if (p == NULL)\n\t\treturn;\n\t}\n\telse\n\t    p = t_s;\n\tml_append_buf(wp->w_buffer, lnum, p, (colnr_T)0, FALSE);\n\tif (p != t_s)\n\t    vim_free(p);\n    }\n    else\n    {\n\tchar_u *newp;\n\n\tcurbuf = wp->w_buffer;\n\tif (where == PUT_APPEND)\n\t{\n\t    newp = concat_str(ml_get(lnum), t_s);\n\t    if (newp == NULL)\n\t\treturn;\n\t    if (*end != NUL)\n\t\tnewp[STRLEN(ml_get(lnum)) + (end - t_s)] = NUL;\n\t}\n\telse\n\t{\n\t    newp = vim_strnsave(t_s, end - t_s);\n\t    if (newp == NULL)\n\t\treturn;\n\t}\n\tml_replace(lnum, newp, FALSE);\n\tcurbuf = curwin->w_buffer;\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n\n    // set msg_col so that a newline is written if needed\n    msg_col += (int)(end - t_s);\n}\n#endif\n\n/*\n * The display part of msg_puts_attr_len().\n * May be called recursively to display scroll-back text.\n */\n    static void\nmsg_puts_display(\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tattr,\n    int\t\trecurse)\n{\n    char_u\t*s = str;\n    char_u\t*t_s = str;\t// string from \"t_s\" to \"s\" is still todo\n    int\t\tt_col = 0;\t// screen cells todo, 0 when \"t_s\" not used\n    int\t\tl;\n    int\t\tcw;\n    char_u\t*sb_str = str;\n    int\t\tsb_col = msg_col;\n    int\t\twrap;\n    int\t\tdid_last_char;\n#ifdef HAS_MESSAGE_WINDOW\n    int\t\twhere = PUT_APPEND;\n    win_T\t*msg_win = NULL;\n    linenr_T    lnum = 1;\n\n    if (in_echowindow)\n    {\n\tmsg_win = popup_get_message_win();\n\n\tif (msg_win != NULL)\n\t{\n\t    if (!popup_message_win_visible())\n\t    {\n\t\tif (*str == NL)\n\t\t{\n\t\t    // When not showing the message window and the output\n\t\t    // starts with a NL show the message normally.\n\t\t    msg_win = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // currently hidden, make it empty\n\t\t    curbuf = msg_win->w_buffer;\n\t\t    while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t\t\tml_delete(1);\n\t\t    curbuf = curwin->w_buffer;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tlnum = msg_win->w_buffer->b_ml.ml_line_count;\n\t\tif (msg_col == 0)\n\t\t    where = PUT_TRUNC;\n\t    }\n\t}\n    }\n#endif\n\n    did_wait_return = FALSE;\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\t/*\n\t * We are at the end of the screen line when:\n\t * - When outputting a newline.\n\t * - When outputting a character in the last column.\n\t */\n\tif (!recurse && msg_row >= Rows - 1 && (*s == '\\n' || (\n#ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl\n\t\t    ? (\n\t\t\tmsg_col <= 1\n\t\t      || (*s == TAB && msg_col <= 7)\n\t\t      || (has_mbyte && (*mb_ptr2cells)(s) > 1 && msg_col <= 2))\n\t\t    :\n#endif\n\t\t      ((*s != '\\r' && msg_col + t_col >= Columns - 1)\n\t\t       || (*s == TAB && msg_col + t_col >= ((Columns - 1) & ~7))\n\t\t       || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t && msg_col + t_col >= Columns - 2)))))\n\t{\n\t    /*\n\t     * The screen is scrolled up when at the last row (some terminals\n\t     * scroll automatically, some don't.  To avoid problems we scroll\n\t     * ourselves).\n\t     */\n\t    if (t_col > 0)\n\t    {\n\t\t// output postponed text\n#ifdef HAS_MESSAGE_WINDOW\n\t\tif (msg_win != NULL)\n\t\t{\n\t\t    put_msg_win(msg_win, where, t_s, s, lnum);\n\t\t    t_col = 0;\n\t\t    where = PUT_BELOW;\n\t\t}\n\t\telse\n#endif\n\t\t    t_puts(&t_col, t_s, s, attr);\n\t    }\n\n\t    // When no more prompt and no more room, truncate here\n\t    if (msg_no_more && lines_left == 0)\n\t\tbreak;\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win == NULL)\n#endif\n\t\t// Scroll the screen up one line.\n\t\tmsg_scroll_up();\n\n\t    msg_row = Rows - 2;\n\t    if (msg_col >= Columns)\t// can happen after screen resize\n\t\tmsg_col = Columns - 1;\n\n\t    // Display char in last column before showing more-prompt.\n\t    if (*s >= ' '\n#ifdef FEAT_RIGHTLEFT\n\t\t    && !cmdmsg_rl\n#endif\n\t       )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    if (enc_utf8 && maxlen >= 0)\n\t\t\t// avoid including composing chars after the end\n\t\t\tl = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\t    else\n\t\t\tl = (*mb_ptr2len)(s);\n\t\t    s = screen_puts_mbyte(s, l, attr);\n\t\t}\n\t\telse\n\t\t    msg_screen_putchar(*s++, attr);\n\t\tdid_last_char = TRUE;\n\t    }\n\t    else\n\t\tdid_last_char = FALSE;\n\n\t    if (p_more)\n\t\t// store text for scrolling back\n\t\tstore_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win == NULL)\n\t    {\n#endif\n\t\tinc_msg_scrolled();\n\t\tneed_wait_return = TRUE; // may need wait_return() in main()\n\t\tredraw_cmdline = TRUE;\n\t\tif (cmdline_row > 0 && !exmode_active)\n\t\t    --cmdline_row;\n\n\t\t/*\n\t\t * If screen is completely filled and 'more' is set then wait\n\t\t * for a character.\n\t\t */\n\t\tif (lines_left > 0)\n\t\t    --lines_left;\n#ifdef HAS_MESSAGE_WINDOW\n\t    }\n#endif\n\t    if (p_more && lines_left == 0 && State != MODE_HITRETURN\n\t\t\t\t\t    && !msg_no_more && !exmode_active)\n\t    {\n#ifdef FEAT_CON_DIALOG\n\t\tif (do_more_prompt(NUL))\n\t\t    s = confirm_msg_tail;\n#else\n\t\t(void)do_more_prompt(NUL);\n#endif\n\t\tif (quit_more)\n\t\t    return;\n\t    }\n\n\t    // When we displayed a char in last column need to check if there\n\t    // is still more.\n\t    if (did_last_char)\n\t\tcontinue;\n\t}\n\n\twrap = *s == '\\n'\n\t\t    || msg_col + t_col >= Columns\n\t\t    || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t    && msg_col + t_col >= Columns - 1);\n\tif (t_col > 0 && (wrap || *s == '\\r' || *s == '\\b'\n\t\t\t\t\t\t || *s == '\\t' || *s == BELL))\n\t{\n\t    // output any postponed text\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t    {\n\t\tput_msg_win(msg_win, where, t_s, s, lnum);\n\t\tt_col = 0;\n\t\twhere = PUT_BELOW;\n\t    }\n\t    else\n#endif\n\t\tt_puts(&t_col, t_s, s, attr);\n\t}\n\n\tif (wrap && p_more && !recurse)\n\t    // store text for scrolling back\n\t    store_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n\tif (*s == '\\n')\t\t    // go to next line\n\t{\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t    {\n\t\t// Ignore a NL when the buffer is empty, it is used to scroll\n\t\t// up the text.\n\t\tif ((msg_win->w_buffer->b_ml.ml_flags & ML_EMPTY) == 0)\n\t\t{\n\t\t    put_msg_win(msg_win, PUT_BELOW, t_s, t_s, lnum);\n\t\t    ++lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tmsg_didout = FALSE;\t    // remember that line is empty\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns - 1;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    if (++msg_row >= Rows)  // safety check\n\t\tmsg_row = Rows - 1;\n\t}\n\telse if (*s == '\\r')\t    // go to column 0\n\t{\n\t    msg_col = 0;\n#ifdef HAS_MESSAGE_WINDOW\n\t    where = PUT_TRUNC;\n#endif\n\t}\n\telse if (*s == '\\b')\t    // go to previous char\n\t{\n\t    if (msg_col)\n\t\t--msg_col;\n\t}\n\telse if (*s == TAB)\t    // translate Tab into spaces\n\t{\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t\tmsg_col = (msg_col + 7) % 8;\n\t    else\n#endif\n\t\tdo\n\t\t    msg_screen_putchar(' ', attr);\n\t\twhile (msg_col & 7);\n\t}\n\telse if (*s == BELL)\t\t// beep (from \":sh\")\n\t    vim_beep(BO_SH);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcw = (*mb_ptr2cells)(s);\n\t\tif (enc_utf8 && maxlen >= 0)\n\t\t    // avoid including composing chars after the end\n\t\t    l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\telse\n\t\t    l = (*mb_ptr2len)(s);\n\t    }\n\t    else\n\t    {\n\t\tcw = 1;\n\t\tl = 1;\n\t    }\n\n\t    // When drawing from right to left or when a double-wide character\n\t    // doesn't fit, draw a single character here.  Otherwise collect\n\t    // characters and draw them all at once later.\n\t    if (\n# ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl ||\n# endif\n\t\t    (cw > 1 && msg_col + t_col >= Columns - 1))\n\t    {\n\t\tif (l > 1)\n\t\t    s = screen_puts_mbyte(s, l, attr) - 1;\n\t\telse\n\t\t    msg_screen_putchar(*s, attr);\n\t    }\n\t    else\n\t    {\n\t\t// postpone this character until later\n\t\tif (t_col == 0)\n\t\t    t_s = s;\n\t\tt_col += cw;\n\t\ts += l - 1;\n\t    }\n\t}\n\t++s;\n    }\n\n    // output any postponed text\n    if (t_col > 0)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (msg_win != NULL)\n\t    put_msg_win(msg_win, where, t_s, s, lnum);\n\telse\n#endif\n\t    t_puts(&t_col, t_s, s, attr);\n    }\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (msg_win != NULL)\n\tpopup_show_message_win();\n#endif\n    // Store the text for scroll back, unless it's a newline by itself.\n    if (p_more && !recurse && !(s == sb_str + 1 && *sb_str == '\\n'))\n\tstore_sb_text(&sb_str, s, attr, &sb_col, FALSE);\n\n    msg_check();\n}\n\n/*\n * Return TRUE when \":filter pattern\" was used and \"msg\" does not match\n * \"pattern\".\n */\n    int\nmessage_filtered(char_u *msg)\n{\n    int match;\n\n    if (cmdmod.cmod_filter_regmatch.regprog == NULL)\n\treturn FALSE;\n    match = vim_regexec(&cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);\n    return cmdmod.cmod_filter_force ? match : !match;\n}\n\n/*\n * Scroll the screen up one line for displaying the next message line.\n */\n    static void\nmsg_scroll_up(void)\n{\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;\n#endif\n#ifdef FEAT_GUI\n    // Remove the cursor before scrolling, ScreenLines[] is going\n    // to become invalid.\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n    // scrolling up always works\n    mch_disable_flush();\n    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);\n    mch_enable_flush();\n\n    if (!can_clear((char_u *)\" \"))\n    {\n\t// Scrolling up doesn't result in the right background.  Set the\n\t// background here.  It's not efficient, but avoids that we have to do\n\t// it all over the code.\n\tscreen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\n\t// Also clear the last char of the last but one line if it was not\n\t// cleared before to avoid a scroll-up.\n\tif (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)\n\t    screen_fill((int)Rows - 2, (int)Rows - 1,\n\t\t\t\t (int)Columns - 1, (int)Columns, ' ', ' ', 0);\n    }\n}\n\n/*\n * Increment \"msg_scrolled\".\n */\n    static void\ninc_msg_scrolled(void)\n{\n#ifdef FEAT_EVAL\n    if (*get_vim_var_str(VV_SCROLLSTART) == NUL)\n    {\n\tchar_u\t    *p = SOURCING_NAME;\n\tchar_u\t    *tofree = NULL;\n\tint\t    len;\n\n\t// v:scrollstart is empty, set it to the script/function name and line\n\t// number\n\tif (p == NULL)\n\t    p = (char_u *)_(\"Unknown\");\n\telse\n\t{\n\t    len = (int)STRLEN(p) + 40;\n\t    tofree = alloc(len);\n\t    if (tofree != NULL)\n\t    {\n\t\tvim_snprintf((char *)tofree, len, _(\"%s line %ld\"),\n\t\t\t\t\t\t      p, (long)SOURCING_LNUM);\n\t\tp = tofree;\n\t    }\n\t}\n\tset_vim_var_string(VV_SCROLLSTART, p, -1);\n\tvim_free(tofree);\n    }\n#endif\n    ++msg_scrolled;\n    set_must_redraw(UPD_VALID);\n}\n\n/*\n * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to\n * store the displayed text and remember where screen lines start.\n */\ntypedef struct msgchunk_S msgchunk_T;\nstruct msgchunk_S\n{\n    msgchunk_T\t*sb_next;\n    msgchunk_T\t*sb_prev;\n    char\tsb_eol;\t\t// TRUE when line ends after this text\n    int\t\tsb_msg_col;\t// column in which text starts\n    int\t\tsb_attr;\t// text attributes\n    char_u\tsb_text[1];\t// text to be displayed, actually longer\n};\n\nstatic msgchunk_T *last_msgchunk = NULL; // last displayed text\n\nstatic msgchunk_T *msg_sb_start(msgchunk_T *mps);\n\ntypedef enum {\n    SB_CLEAR_NONE = 0,\n    SB_CLEAR_ALL,\n    SB_CLEAR_CMDLINE_BUSY,\n    SB_CLEAR_CMDLINE_DONE\n} sb_clear_T;\n\n// When to clear text on next msg.\nstatic sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;\n\n/*\n * Store part of a printed message for displaying when scrolling back.\n */\n    static void\nstore_sb_text(\n    char_u\t**sb_str,\t// start of string\n    char_u\t*s,\t\t// just after string\n    int\t\tattr,\n    int\t\t*sb_col,\n    int\t\tfinish)\t\t// line ends\n{\n    msgchunk_T\t*mp;\n\n    if (do_clear_sb_text == SB_CLEAR_ALL\n\t    || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE)\n    {\n\tclear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);\n\tmsg_sb_eol();  // prevent messages from overlapping\n\tdo_clear_sb_text = SB_CLEAR_NONE;\n    }\n\n    if (s > *sb_str)\n    {\n\tmp = alloc(sizeof(msgchunk_T) + (s - *sb_str));\n\tif (mp != NULL)\n\t{\n\t    mp->sb_eol = finish;\n\t    mp->sb_msg_col = *sb_col;\n\t    mp->sb_attr = attr;\n\t    vim_strncpy(mp->sb_text, *sb_str, s - *sb_str);\n\n\t    if (last_msgchunk == NULL)\n\t    {\n\t\tlast_msgchunk = mp;\n\t\tmp->sb_prev = NULL;\n\t    }\n\t    else\n\t    {\n\t\tmp->sb_prev = last_msgchunk;\n\t\tlast_msgchunk->sb_next = mp;\n\t\tlast_msgchunk = mp;\n\t    }\n\t    mp->sb_next = NULL;\n\t}\n    }\n    else if (finish && last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n\n    *sb_str = s;\n    *sb_col = 0;\n}\n\n/*\n * Finished showing messages, clear the scroll-back text on the next message.\n */\n    void\nmay_clear_sb_text(void)\n{\n    do_clear_sb_text = SB_CLEAR_ALL;\n}\n\n/*\n * Starting to edit the command line: do not clear messages now.\n */\n    void\nsb_text_start_cmdline(void)\n{\n    if (do_clear_sb_text == SB_CLEAR_CMDLINE_BUSY)\n\t// Invoking command line recursively: the previous-level command line\n\t// doesn't need to be remembered as it will be redrawn when returning\n\t// to that level.\n\tsb_text_restart_cmdline();\n    else\n    {\n\tmsg_sb_eol();\n\tdo_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n    }\n}\n\n/*\n * Redrawing the command line: clear the last unfinished line.\n */\n    void\nsb_text_restart_cmdline(void)\n{\n    msgchunk_T *tofree;\n\n    // Needed when returning from nested command line.\n    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n\n    if (last_msgchunk == NULL || last_msgchunk->sb_eol)\n\t// No unfinished line: don't clear anything.\n\treturn;\n\n    tofree = msg_sb_start(last_msgchunk);\n    last_msgchunk = tofree->sb_prev;\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_next = NULL;\n    while (tofree != NULL)\n    {\n\tmsgchunk_T *tofree_next = tofree->sb_next;\n\n\tvim_free(tofree);\n\ttofree = tofree_next;\n    }\n}\n\n/*\n * Ending to edit the command line: clear old lines but the last one later.\n */\n    void\nsb_text_end_cmdline(void)\n{\n    do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;\n}\n\n/*\n * Clear any text remembered for scrolling back.\n * When \"all\" is FALSE keep the last line.\n * Called when redrawing the screen.\n */\n    void\nclear_sb_text(int all)\n{\n    msgchunk_T\t*mp;\n    msgchunk_T\t**lastp;\n\n    if (all)\n\tlastp = &last_msgchunk;\n    else\n    {\n\tif (last_msgchunk == NULL)\n\t    return;\n\tlastp = &msg_sb_start(last_msgchunk)->sb_prev;\n    }\n\n    while (*lastp != NULL)\n    {\n\tmp = (*lastp)->sb_prev;\n\tvim_free(*lastp);\n\t*lastp = mp;\n    }\n}\n\n/*\n * \"g<\" command.\n */\n    void\nshow_sb_text(void)\n{\n    msgchunk_T\t*mp;\n\n    // Only show something if there is more than one line, otherwise it looks\n    // weird, typing a command without output results in one line.\n    mp = msg_sb_start(last_msgchunk);\n    if (mp == NULL || mp->sb_prev == NULL)\n\tvim_beep(BO_MESS);\n    else\n    {\n\tdo_more_prompt('G');\n\twait_return(FALSE);\n    }\n}\n\n/*\n * Move to the start of screen line in already displayed text.\n */\n    static msgchunk_T *\nmsg_sb_start(msgchunk_T *mps)\n{\n    msgchunk_T *mp = mps;\n\n    while (mp != NULL && mp->sb_prev != NULL && !mp->sb_prev->sb_eol)\n\tmp = mp->sb_prev;\n    return mp;\n}\n\n/*\n * Mark the last message chunk as finishing the line.\n */\n    void\nmsg_sb_eol(void)\n{\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n}\n\n/*\n * Display a screen line from previously displayed text at row \"row\".\n * When \"clear_to_eol\" is set clear the rest of the screen line.\n * Returns a pointer to the text for the next line (can be NULL).\n */\n    static msgchunk_T *\ndisp_sb_line(int row, msgchunk_T *smp, int clear_to_eol)\n{\n    msgchunk_T\t*mp = smp;\n    char_u\t*p;\n\n    for (;;)\n    {\n\tmsg_row = row;\n\tmsg_col = mp->sb_msg_col;\n\tp = mp->sb_text;\n\tif (*p == '\\n')\t    // don't display the line break\n\t    ++p;\n\tmsg_puts_display(p, -1, mp->sb_attr, TRUE);\n\n\t// If clearing the screen did not work (e.g. because of a background\n\t// color and t_ut isn't set) clear until the last column here.\n\tif (clear_to_eol)\n\t    screen_fill(row, row + 1, msg_col, (int)Columns, ' ', ' ', 0);\n\n\tif (mp->sb_eol || mp->sb_next == NULL)\n\t    break;\n\tmp = mp->sb_next;\n    }\n    return mp->sb_next;\n}\n\n/*\n * Output any postponed text for msg_puts_attr_len().\n */\n    static void\nt_puts(\n    int\t\t*t_col,\n    char_u\t*t_s,\n    char_u\t*s,\n    int\t\tattr)\n{\n    // output postponed text\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);\n    msg_col += *t_col;\n    *t_col = 0;\n    // If the string starts with a composing character don't increment the\n    // column position for it.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(t_s)))\n\t--msg_col;\n    if (msg_col >= Columns)\n    {\n\tmsg_col = 0;\n\t++msg_row;\n    }\n}\n\n/*\n * Returns TRUE when messages should be printed with mch_errmsg().\n * This is used when there is no valid screen, so we can see error messages.\n * If termcap is not active, we may be writing in an alternate console\n * window, cursor positioning may not work correctly (window size may be\n * different, e.g. for Win32 console) or we just don't know where the\n * cursor is.\n */\n    int\nmsg_use_printf(void)\n{\n    return (!msg_check_screen()\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\t    || (!gui.in_use && !termcap_active)\n# else\n\t    || !termcap_active\n# endif\n#endif\n\t    || (swapping_screen() && !termcap_active)\n\t       );\n}\n\n/*\n * Print a message when there is no valid screen.\n */\n    static void\nmsg_puts_printf(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    char_u\t*buf = NULL;\n    char_u\t*p = s;\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_COOK);\t// handle CR and NL correctly\n#endif\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\tif (!(silent_mode && p_verbose == 0))\n\t{\n\t    // NL --> CR NL translation (for Unix, not for \"--version\")\n\t    if (*s == NL)\n\t    {\n\t\tint n = (int)(s - p);\n\n\t\tbuf = alloc(n + 3);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    memcpy(buf, p, n);\n\t\t    if (!info_message)\n\t\t\tbuf[n++] = CAR;\n\t\t    buf[n++] = NL;\n\t\t    buf[n++] = NUL;\n\t\t    if (info_message)   // informative message, not an error\n\t\t\tmch_msg((char *)buf);\n\t\t    else\n\t\t\tmch_errmsg((char *)buf);\n\t\t    vim_free(buf);\n\t\t}\n\t\tp = s + 1;\n\t    }\n\t}\n\n\t// primitive way to compute the current column\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = Columns - 1;\n\t    else\n\t\t--msg_col;\n\t}\n\telse\n#endif\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = 0;\n\t    else\n\t\t++msg_col;\n\t}\n\t++s;\n    }\n\n    if (*p != NUL && !(silent_mode && p_verbose == 0))\n    {\n\tchar_u *tofree = NULL;\n\n\tif (maxlen > 0 && vim_strlen_maxlen((char *)p, (size_t)maxlen)\n\t\t\t\t\t\t\t     >= (size_t)maxlen)\n\t{\n\t    tofree = vim_strnsave(p, (size_t)maxlen);\n\t    p = tofree;\n\t}\n\tif (p != NULL)\n\t{\n\t    if (info_message)\n\t\tmch_msg((char *)p);\n\t    else\n\t\tmch_errmsg((char *)p);\n\t    vim_free(tofree);\n\t}\n    }\n\n    msg_didout = TRUE;\t    // assume that line is not empty\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_RAW);\n#endif\n}\n\n/*\n * Show the more-prompt and handle the user response.\n * This takes care of scrolling back and displaying previously displayed text.\n * When at hit-enter prompt \"typed_char\" is the already typed character,\n * otherwise it's NUL.\n * Returns TRUE when jumping ahead to \"confirm_msg_tail\".\n */\n    static int\ndo_more_prompt(int typed_char)\n{\n    static int\tentered = FALSE;\n    int\t\tused_typed_char = typed_char;\n    int\t\toldState = State;\n    int\t\tc;\n#ifdef FEAT_CON_DIALOG\n    int\t\tretval = FALSE;\n#endif\n    int\t\ttoscroll;\n    msgchunk_T\t*mp_last = NULL;\n    msgchunk_T\t*mp;\n    int\t\ti;\n\n    // We get called recursively when a timer callback outputs a message. In\n    // that case don't show another prompt. Also when at the hit-Enter prompt\n    // and nothing was typed.\n    if (entered || (State == MODE_HITRETURN && typed_char == 0))\n\treturn FALSE;\n    entered = TRUE;\n\n    if (typed_char == 'G')\n    {\n\t// \"g<\": Find first line on the last page.\n\tmp_last = msg_sb_start(last_msgchunk);\n\tfor (i = 0; i < Rows - 2 && mp_last != NULL\n\t\t\t\t\t     && mp_last->sb_prev != NULL; ++i)\n\t    mp_last = msg_sb_start(mp_last->sb_prev);\n    }\n\n    State = MODE_ASKMORE;\n    setmouse();\n    if (typed_char == NUL)\n\tmsg_moremsg(FALSE);\n    for (;;)\n    {\n\t/*\n\t * Get a typed character directly from the user.\n\t */\n\tif (used_typed_char != NUL)\n\t{\n\t    c = used_typed_char;\t// was typed at hit-enter prompt\n\t    used_typed_char = NUL;\n\t}\n\telse\n\t    c = get_keystroke();\n\n#if defined(FEAT_MENU) && defined(FEAT_GUI)\n\tif (c == K_MENU)\n\t{\n\t    int idx = get_menu_index(current_menu, MODE_ASKMORE);\n\n\t    // Used a menu.  If it starts with CTRL-Y, it must\n\t    // be a \"Copy\" for the clipboard.  Otherwise\n\t    // assume that we end\n\t    if (idx == MENU_INDEX_INVALID)\n\t\tcontinue;\n\t    c = *current_menu->strings[idx];\n\t    if (c != NUL && current_menu->strings[idx][1] != NUL)\n\t\tins_typebuf(current_menu->strings[idx] + 1,\n\t\t\t\tcurrent_menu->noremap[idx], 0, TRUE,\n\t\t\t\t\t\t   current_menu->silent[idx]);\n\t}\n#endif\n\n\ttoscroll = 0;\n\tswitch (c)\n\t{\n\tcase BS:\t\t// scroll one line back\n\tcase K_BS:\n\tcase 'k':\n\tcase K_UP:\n\t    toscroll = -1;\n\t    break;\n\n\tcase CAR:\t\t// one extra line\n\tcase NL:\n\tcase 'j':\n\tcase K_DOWN:\n\t    toscroll = 1;\n\t    break;\n\n\tcase 'u':\t\t// Up half a page\n\t    toscroll = -(Rows / 2);\n\t    break;\n\n\tcase 'd':\t\t// Down half a page\n\t    toscroll = Rows / 2;\n\t    break;\n\n\tcase 'b':\t\t// one page back\n\tcase K_PAGEUP:\n\t    toscroll = -(Rows - 1);\n\t    break;\n\n\tcase ' ':\t\t// one extra page\n\tcase 'f':\n\tcase K_PAGEDOWN:\n\tcase K_LEFTMOUSE:\n\t    toscroll = Rows - 1;\n\t    break;\n\n\tcase 'g':\t\t// all the way back to the start\n\t    toscroll = -999999;\n\t    break;\n\n\tcase 'G':\t\t// all the way to the end\n\t    toscroll = 999999;\n\t    lines_left = 999999;\n\t    break;\n\n\tcase ':':\t\t// start new command line\n#ifdef FEAT_CON_DIALOG\n\t    if (!confirm_msg_used)\n#endif\n\t    {\n\t\t// Since got_int is set all typeahead will be flushed, but we\n\t\t// want to keep this ':', remember that in a special way.\n\t\ttypeahead_noflush(':');\n#ifdef FEAT_TERMINAL\n\t\tskip_term_loop = TRUE;\n#endif\n\t\tcmdline_row = Rows - 1;\t\t// put ':' on this line\n\t\tskip_redraw = TRUE;\t\t// skip redraw once\n\t\tneed_wait_return = FALSE;\t// don't wait in main()\n\t    }\n\t    // FALLTHROUGH\n\tcase 'q':\t\t// quit\n\tcase Ctrl_C:\n\tcase ESC:\n#ifdef FEAT_CON_DIALOG\n\t    if (confirm_msg_used)\n\t    {\n\t\t// Jump to the choices of the dialog.\n\t\tretval = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tgot_int = TRUE;\n\t\tquit_more = TRUE;\n\t    }\n\t    // When there is some more output (wrapping line) display that\n\t    // without another prompt.\n\t    lines_left = Rows - 1;\n\t    break;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t    // Strange way to allow copying (yanking) a modeless\n\t    // selection at the more prompt.  Use CTRL-Y,\n\t    // because the same is used in Cmdline-mode and at the\n\t    // hit-enter prompt.  However, scrolling one line up\n\t    // might be expected...\n\t    if (clip_star.state == SELECT_DONE)\n\t\tclip_copy_modeless_selection(TRUE);\n\t    continue;\n#endif\n\tdefault:\t\t// no valid response\n\t    msg_moremsg(TRUE);\n\t    continue;\n\t}\n\n\tif (toscroll != 0)\n\t{\n\t    if (toscroll < 0)\n\t    {\n\t\t// go to start of last line\n\t\tif (mp_last == NULL)\n\t\t    mp = msg_sb_start(last_msgchunk);\n\t\telse if (mp_last->sb_prev != NULL)\n\t\t    mp = msg_sb_start(mp_last->sb_prev);\n\t\telse\n\t\t    mp = NULL;\n\n\t\t// go to start of line at top of the screen\n\t\tfor (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;\n\t\t\t\t\t\t\t\t\t  ++i)\n\t\t    mp = msg_sb_start(mp->sb_prev);\n\n\t\tif (mp != NULL && mp->sb_prev != NULL)\n\t\t{\n\t\t    // Find line to be displayed at top.\n\t\t    for (i = 0; i > toscroll; --i)\n\t\t    {\n\t\t\tif (mp == NULL || mp->sb_prev == NULL)\n\t\t\t    break;\n\t\t\tmp = msg_sb_start(mp->sb_prev);\n\t\t\tif (mp_last == NULL)\n\t\t\t    mp_last = msg_sb_start(last_msgchunk);\n\t\t\telse\n\t\t\t    mp_last = msg_sb_start(mp_last->sb_prev);\n\t\t    }\n\n\t\t    if (toscroll == -1 && screen_ins_lines(0, 0, 1,\n\t\t\t\t\t\t     (int)Rows, 0, NULL) == OK)\n\t\t    {\n\t\t\t// display line at top\n\t\t\t(void)disp_sb_line(0, mp, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tint did_clear = screenclear();\n\n\t\t\t// redisplay all lines\n\t\t\tfor (i = 0; mp != NULL && i < Rows - 1; ++i)\n\t\t\t{\n\t\t\t    mp = disp_sb_line(i, mp, !did_clear);\n\t\t\t    ++msg_scrolled;\n\t\t\t}\n\t\t    }\n\t\t    toscroll = 0;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// First display any text that we scrolled back.\n\t\twhile (toscroll > 0 && mp_last != NULL)\n\t\t{\n\t\t    // scroll up, display line at bottom\n\t\t    msg_scroll_up();\n\t\t    inc_msg_scrolled();\n\t\t    screen_fill((int)Rows - 2, (int)Rows - 1, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\t    mp_last = disp_sb_line((int)Rows - 2, mp_last, FALSE);\n\t\t    --toscroll;\n\t\t}\n\t    }\n\n\t    if (toscroll <= 0)\n\t    {\n\t\t// displayed the requested text, more prompt again\n\t\tscreen_fill((int)Rows - 1, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\tmsg_moremsg(FALSE);\n\t\tcontinue;\n\t    }\n\n\t    // display more text, return to caller\n\t    lines_left = toscroll;\n\t}\n\n\tbreak;\n    }\n\n    // clear the --more-- message\n    screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n    State = oldState;\n    setmouse();\n    if (quit_more)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n#ifdef FEAT_RIGHTLEFT\n    else if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n#endif\n\n    entered = FALSE;\n#ifdef FEAT_CON_DIALOG\n    return retval;\n#else\n    return FALSE;\n#endif\n}\n\n#if defined(USE_MCH_ERRMSG) || defined(PROTO)\n\n#ifdef mch_errmsg\n# undef mch_errmsg\n#endif\n#ifdef mch_msg\n# undef mch_msg\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_errmsg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode = 0;\n    HANDLE  h = GetStdHandle(STD_ERROR_HANDLE);\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tfprintf(stderr, \"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give an error message.  To be used when the screen hasn't been initialized\n * yet.  When stderr can't be used, collect error messages until the GUI has\n * started and they can be displayed in a message box.\n */\n    void\nmch_errmsg(char *str)\n{\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    int\t\tlen;\n#endif\n\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stderr if it's a tty.\n    // When not going to start the GUI also use stderr.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tfprintf(stderr, \"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_errmsg_c(str);\n\treturn;\n    }\n#endif\n\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    // avoid a delay for a message that isn't there\n    emsg_on_display = FALSE;\n\n    len = (int)STRLEN(str) + 1;\n    if (error_ga.ga_growsize == 0)\n    {\n\terror_ga.ga_growsize = 80;\n\terror_ga.ga_itemsize = 1;\n    }\n    if (ga_grow(&error_ga, len) == OK)\n    {\n\tmch_memmove((char_u *)error_ga.ga_data + error_ga.ga_len,\n\t\t\t\t\t\t\t  (char_u *)str, len);\n# ifdef UNIX\n\t// remove CR characters, they are displayed\n\t{\n\t    char_u\t*p;\n\n\t    p = (char_u *)error_ga.ga_data + error_ga.ga_len;\n\t    for (;;)\n\t    {\n\t\tp = vim_strchr(p, '\\r');\n\t\tif (p == NULL)\n\t\t    break;\n\t\t*p = ' ';\n\t    }\n\t}\n# endif\n\t--len;\t\t// don't count the NUL at the end\n\terror_ga.ga_len += len;\n    }\n#endif\n}\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_msg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode;\n    HANDLE  h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tprintf(\"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give a message.  To be used when the screen hasn't been initialized yet.\n * When there is no tty, collect messages until the GUI has started and they\n * can be displayed in a message box.\n */\n    void\nmch_msg(char *str)\n{\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stdout if we have a tty.  This allows \"vim -h | more\" and\n    // uses mch_errmsg() when started from the desktop.\n    // When not going to start the GUI also use stdout.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tprintf(\"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_msg_c(str);\n\treturn;\n    }\n#endif\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    mch_errmsg(str);\n#endif\n}\n#endif // USE_MCH_ERRMSG\n\n/*\n * Put a character on the screen at the current message position and advance\n * to the next position.  Only for printable ASCII!\n */\n    static void\nmsg_screen_putchar(int c, int attr)\n{\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_putchar(c, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tif (--msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tif (++msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n}\n\n    static void\nmsg_moremsg(int full)\n{\n    int\t\tattr;\n    char_u\t*s = (char_u *)_(\"-- More --\");\n\n    attr = HL_ATTR(HLF_M);\n    screen_puts(s, (int)Rows - 1, 0, attr);\n    if (full)\n\tscreen_puts((char_u *)\n\t\t_(\" SPACE/d/j: screen/page/line down, b/u/k: up, q: quit \"),\n\t\t(int)Rows - 1, vim_strsize(s), attr);\n}\n\n/*\n * Repeat the message for the current mode: MODE_ASKMORE, MODE_EXTERNCMD,\n * MODE_CONFIRM or exmode_active.\n */\n    void\nrepeat_message(void)\n{\n    if (State == MODE_ASKMORE)\n    {\n\tmsg_moremsg(TRUE);\t// display --more-- message again\n\tmsg_row = Rows - 1;\n    }\n#ifdef FEAT_CON_DIALOG\n    else if (State == MODE_CONFIRM)\n    {\n\tdisplay_confirm_msg();\t// display \":confirm\" message again\n\tmsg_row = Rows - 1;\n    }\n#endif\n    else if (State == MODE_EXTERNCMD)\n    {\n\twindgoto(msg_row, msg_col); // put cursor back\n    }\n    else if (State == MODE_HITRETURN || State == MODE_SETWSIZE)\n    {\n\tif (msg_row == Rows - 1)\n\t{\n\t    // Avoid drawing the \"hit-enter\" prompt below the previous one,\n\t    // overwrite it.  Esp. useful when regaining focus and a\n\t    // FocusGained autocmd exists but didn't draw anything.\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    msg_clr_eos();\n\t}\n\thit_return_msg();\n\tmsg_row = Rows - 1;\n    }\n}\n\n/*\n * msg_check_screen - check if the screen is initialized.\n * Also check msg_row and msg_col, if they are too big it may cause a crash.\n * While starting the GUI the terminal codes will be set for the GUI, but the\n * output goes to the terminal.  Don't use the terminal codes then.\n */\n    static int\nmsg_check_screen(void)\n{\n    if (!full_screen || !screen_valid(FALSE))\n\treturn FALSE;\n\n    if (msg_row >= Rows)\n\tmsg_row = Rows - 1;\n    if (msg_col >= Columns)\n\tmsg_col = Columns - 1;\n    return TRUE;\n}\n\n/*\n * Clear from current message position to end of screen.\n * Skip this when \":silent\" was used, no need to clear for redirection.\n */\n    void\nmsg_clr_eos(void)\n{\n    if (msg_silent == 0)\n\tmsg_clr_eos_force();\n}\n\n/*\n * Clear from current message position to end of screen.\n * Note: msg_col is not updated, so we remember the end of the message\n * for msg_check().\n */\n    void\nmsg_clr_eos_force(void)\n{\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;  // messages go into a popup\n#endif\n    if (msg_use_printf())\n    {\n\tif (full_screen)\t// only when termcap codes are valid\n\t{\n\t    if (*T_CD)\n\t\tout_str(T_CD);\t// clear to end of display\n\t    else if (*T_CE)\n\t\tout_str(T_CE);\t// clear to end of line\n\t}\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    screen_fill(msg_row, msg_row + 1, 0, msg_col + 1, ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n\telse\n#endif\n\t{\n\t    screen_fill(msg_row, msg_row + 1, msg_col, (int)Columns,\n\t\t\t\t\t\t\t\t ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n    }\n}\n\n/*\n * Clear the command line.\n */\n    void\nmsg_clr_cmdline(void)\n{\n    msg_row = cmdline_row;\n    msg_col = 0;\n    msg_clr_eos_force();\n}\n\n/*\n * end putting a message on the screen\n * call wait_return() if the message does not fit in the available space\n * return TRUE if wait_return() not called.\n */\n    int\nmsg_end(void)\n{\n    /*\n     * If the string is larger than the window,\n     * or the ruler option is set and we run into it,\n     * we have to redraw the window.\n     * Do not do this if we are abandoning the file or editing the command line.\n     */\n    if (!exiting && need_wait_return && !(State & MODE_CMDLINE))\n    {\n\twait_return(FALSE);\n\treturn FALSE;\n    }\n    out_flush();\n    return TRUE;\n}\n\n/*\n * If the written message runs into the shown command or ruler, we have to\n * wait for hit-return and redraw the window later.\n */\n    void\nmsg_check(void)\n{\n    if (msg_row == Rows - 1 && msg_col >= sc_col\n#ifdef HAS_MESSAGE_WINDOW\n\t\t&& !in_echowindow\n#endif\n\t    )\n    {\n\tneed_wait_return = TRUE;\n\tredraw_cmdline = TRUE;\n    }\n}\n\n/*\n * May write a string to the redirection file.\n * When \"maxlen\" is -1 write the whole string, otherwise up to \"maxlen\" bytes.\n */\n    static void\nredir_write(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    static int\tcur_col = 0;\n\n    // Don't do anything for displaying prompts and the like.\n    if (redir_off)\n\treturn;\n\n    // If 'verbosefile' is set prepare for writing in that file.\n    if (*p_vfile != NUL && verbose_fd == NULL)\n\tverbose_open();\n\n    if (redirecting())\n    {\n\t// If the string doesn't start with CR or NL, go to msg_col\n\tif (*s != '\\n' && *s != '\\r')\n\t{\n\t    while (cur_col < msg_col)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (redir_execute)\n\t\t    execute_redir_str((char_u *)\" \", -1);\n\t\telse if (redir_reg)\n\t\t    write_reg_contents(redir_reg, (char_u *)\" \", -1, TRUE);\n\t\telse if (redir_vname)\n\t\t    var_redir_str((char_u *)\" \", -1);\n\t\telse\n#endif\n\t\t    if (redir_fd != NULL)\n\t\t    fputs(\" \", redir_fd);\n\t\tif (verbose_fd != NULL)\n\t\t    fputs(\" \", verbose_fd);\n\t\t++cur_col;\n\t    }\n\t}\n\n#ifdef FEAT_EVAL\n\tif (redir_execute)\n\t    execute_redir_str(s, maxlen);\n\telse if (redir_reg)\n\t    write_reg_contents(redir_reg, s, maxlen, TRUE);\n\telse if (redir_vname)\n\t    var_redir_str(s, maxlen);\n#endif\n\n\t// Write and adjust the current column.\n\twhile (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))\n\t{\n#ifdef FEAT_EVAL\n\t    if (!redir_reg && !redir_vname && !redir_execute)\n#endif\n\t\tif (redir_fd != NULL)\n\t\t    putc(*s, redir_fd);\n\t    if (verbose_fd != NULL)\n\t\tputc(*s, verbose_fd);\n\t    if (*s == '\\r' || *s == '\\n')\n\t\tcur_col = 0;\n\t    else if (*s == '\\t')\n\t\tcur_col += (8 - cur_col % 8);\n\t    else\n\t\t++cur_col;\n\t    ++s;\n\t}\n\n\tif (msg_silent != 0)\t// should update msg_col\n\t    msg_col = cur_col;\n    }\n}\n\n    int\nredirecting(void)\n{\n    return redir_fd != NULL || *p_vfile != NUL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname || redir_execute\n#endif\n\t\t\t\t       ;\n}\n\n/*\n * Before giving verbose message.\n * Must always be called paired with verbose_leave()!\n */\n    void\nverbose_enter(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n}\n\n/*\n * After giving verbose message.\n * Must always be called paired with verbose_enter()!\n */\n    void\nverbose_leave(void)\n{\n    if (*p_vfile != NUL)\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n}\n\n/*\n * Like verbose_enter() and set msg_scroll when displaying the message.\n */\n    void\nverbose_enter_scroll(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n    else\n\t// always scroll up, don't overwrite\n\tmsg_scroll = TRUE;\n}\n\n/*\n * Like verbose_leave() and set cmdline_row when displaying the message.\n */\n    void\nverbose_leave_scroll(void)\n{\n    if (*p_vfile != NUL)\n    {\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n    }\n    else\n\tcmdline_row = msg_row;\n}\n\n/*\n * Called when 'verbosefile' is set: stop writing to the file.\n */\n    void\nverbose_stop(void)\n{\n    if (verbose_fd != NULL)\n    {\n\tfclose(verbose_fd);\n\tverbose_fd = NULL;\n    }\n    verbose_did_open = FALSE;\n}\n\n/*\n * Open the file 'verbosefile'.\n * Return FAIL or OK.\n */\n    int\nverbose_open(void)\n{\n    if (verbose_fd == NULL && !verbose_did_open)\n    {\n\t// Only give the error message once.\n\tverbose_did_open = TRUE;\n\n\tverbose_fd = mch_fopen((char *)p_vfile, \"a\");\n\tif (verbose_fd == NULL)\n\t{\n\t    semsg(_(e_cant_open_file_str), p_vfile);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Give a warning message (for searching).\n * Use 'w' highlighting and may repeat the message after redrawing\n */\n    void\ngive_warning(char_u *message, int hl)\n{\n    give_warning_with_source(message, hl, FALSE);\n}\n\n    void\ngive_warning_with_source(char_u *message, int hl, int with_source)\n{\n    // Don't do this for \":silent\".\n    if (msg_silent != 0)\n\treturn;\n\n    // Don't want a hit-enter prompt here.\n    ++no_wait_return;\n\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_WARNINGMSG, message, -1);\n#endif\n    VIM_CLEAR(keep_msg);\n    if (hl)\n\tkeep_msg_attr = HL_ATTR(HLF_W);\n    else\n\tkeep_msg_attr = 0;\n\n    if (with_source)\n    {\n\t// Do what msg() does, but with a column offset if the warning should\n\t// be after the mode message.\n\tmsg_start();\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_puts(\" \");\n\tmsg_puts_attr((char *)message, HL_ATTR(HLF_W) | MSG_HIST);\n\tmsg_clr_eos();\n\t(void)msg_end();\n    }\n    else if (msg_attr((char *)message, keep_msg_attr) && msg_scrolled == 0)\n\tset_keep_msg(message, keep_msg_attr);\n\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n\n    --no_wait_return;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\ngive_warning2(char_u *message, char_u *a1, int hl)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just give\n\t// the raw message so the user at least gets a hint.\n\tgive_warning(message, hl);\n    }\n    else\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, (char *)message, a1);\n\tgive_warning(IObuff, hl);\n    }\n}\n#endif\n\n/*\n * Advance msg cursor to column \"col\".\n */\n    void\nmsg_advance(int col)\n{\n    if (msg_silent != 0)\t// nothing to advance to\n    {\n\tmsg_col = col;\t\t// for redirection, may fill it up later\n\treturn;\n    }\n    if (col >= Columns)\t\t// not enough room\n\tcol = Columns - 1;\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\twhile (msg_col > Columns - col)\n\t    msg_putchar(' ');\n    else\n#endif\n\twhile (msg_col < col)\n\t    msg_putchar(' ');\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Used for \"confirm()\" function, and the :confirm command prefix.\n * Versions which haven't got flexible dialogs yet, and console\n * versions, get this generic handler which uses the command line.\n *\n * type  = one of:\n *\t   VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC\n * title = title string (can be NULL for default)\n * (neither used in console dialogs at the moment)\n *\n * Format of the \"buttons\" string:\n * \"Button1Name\\nButton2Name\\nButton3Name\"\n * The first button should normally be the default/accept\n * The second button should be the 'Cancel' button\n * Other buttons- use your imagination!\n * A '&' in a button name becomes a shortcut, so each '&' should be before a\n * different letter.\n *\n * Returns 0 if cancelled, otherwise the nth button (1-indexed).\n */\n    int\ndo_dialog(\n    int\t\ttype UNUSED,\n    char_u\t*title UNUSED,\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton,\n    char_u\t*textfield UNUSED,\t// IObuff for inputdialog(), NULL\n\t\t\t\t\t// otherwise\n    int\t\tex_cmd)\t    // when TRUE pressing : accepts default and starts\n\t\t\t    // Ex command\n{\n    int\t\toldState;\n    int\t\tretval = 0;\n    char_u\t*hotkeys;\n    int\t\tc;\n    int\t\ti;\n    tmode_T\tsave_tmode;\n\n#ifndef NO_CONSOLE\n    // Don't output anything in silent mode (\"ex -s\")\n    if (silent_mode)\n\treturn dfltbutton;   // return default option\n#endif\n\n#ifdef FEAT_GUI_DIALOG\n    // When GUI is running and 'c' not in 'guioptions', use the GUI dialog\n    if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)\n    {\n\t// --gui-dialog-file: write text to a file\n\tif (gui_dialog_log(title, message))\n\t    c = dfltbutton;\n\telse\n\t    c = gui_mch_dialog(type, title, message, buttons, dfltbutton,\n\t\t\t\t\t\t\t   textfield, ex_cmd);\n\t// avoid a hit-enter prompt without clearing the cmdline\n\tneed_wait_return = FALSE;\n\temsg_on_display = FALSE;\n\tcmdline_row = msg_row;\n\n\t// Flush output to avoid that further messages and redrawing is done\n\t// in the wrong order.\n\tout_flush();\n\tgui_mch_update();\n\n\treturn c;\n    }\n#endif\n\n    oldState = State;\n    State = MODE_CONFIRM;\n    setmouse();\n\n    // Ensure raw mode here.\n    save_tmode = cur_tmode;\n    settmode(TMODE_RAW);\n\n    /*\n     * Since we wait for a keypress, don't make the\n     * user press RETURN as well afterwards.\n     */\n    ++no_wait_return;\n    hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);\n\n    if (hotkeys != NULL)\n    {\n\tfor (;;)\n\t{\n\t    // Get a typed character directly from the user.\n\t    c = get_keystroke();\n\t    switch (c)\n\t    {\n\t    case CAR:\t\t// User accepts default option\n\t    case NL:\n\t\tretval = dfltbutton;\n\t\tbreak;\n\t    case Ctrl_C:\t// User aborts/cancels\n\t    case ESC:\n\t\tretval = 0;\n\t\tbreak;\n\t    default:\t\t// Could be a hotkey?\n\t\tif (c < 0)\t// special keys are ignored here\n\t\t    continue;\n\t\tif (c == ':' && ex_cmd)\n\t\t{\n\t\t    retval = dfltbutton;\n\t\t    ins_char_typebuf(':', 0);\n\t\t    break;\n\t\t}\n\n\t\t// Make the character lowercase, as chars in \"hotkeys\" are.\n\t\tc = MB_TOLOWER(c);\n\t\tretval = 1;\n\t\tfor (i = 0; hotkeys[i]; ++i)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif ((*mb_ptr2char)(hotkeys + i) == c)\n\t\t\t    break;\n\t\t\ti += (*mb_ptr2len)(hotkeys + i) - 1;\n\t\t    }\n\t\t    else\n\t\t\tif (hotkeys[i] == c)\n\t\t\t    break;\n\t\t    ++retval;\n\t\t}\n\t\tif (hotkeys[i])\n\t\t    break;\n\t\t// No hotkey match, so keep waiting\n\t\tcontinue;\n\t    }\n\t    break;\n\t}\n\n\tvim_free(hotkeys);\n    }\n\n    settmode(save_tmode);\n    State = oldState;\n    setmouse();\n    --no_wait_return;\n    msg_end_prompt();\n\n    return retval;\n}\n\n/*\n * Copy one character from \"*from\" to \"*to\", taking care of multi-byte\n * characters.  Return the length of the character in bytes.\n */\n    static int\ncopy_char(\n    char_u\t*from,\n    char_u\t*to,\n    int\t\tlowercase)\t// make character lower case\n{\n    int\t\tlen;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tif (lowercase)\n\t{\n\t    c = MB_TOLOWER((*mb_ptr2char)(from));\n\t    return (*mb_char2bytes)(c, to);\n\t}\n\telse\n\t{\n\t    len = (*mb_ptr2len)(from);\n\t    mch_memmove(to, from, (size_t)len);\n\t    return len;\n\t}\n    }\n    else\n    {\n\tif (lowercase)\n\t    *to = (char_u)TOLOWER_LOC(*from);\n\telse\n\t    *to = *from;\n\treturn 1;\n    }\n}\n\n/*\n * Format the dialog string, and display it at the bottom of\n * the screen. Return a string of hotkey chars (if defined) for\n * each 'button'. If a button has no hotkey defined, the first character of\n * the button is used.\n * The hotkeys can be multi-byte characters, but without combining chars.\n *\n * Returns an allocated string with hotkeys, or NULL for error.\n */\n    static char_u *\nmsg_show_console_dialog(\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton)\n{\n    int\t\tlen = 0;\n#define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)\n    int\t\tlenhotkey = HOTK_LEN;\t// count first button\n    char_u\t*hotk = NULL;\n    char_u\t*msgp = NULL;\n    char_u\t*hotkp = NULL;\n    char_u\t*r;\n    int\t\tcopy;\n#define HAS_HOTKEY_LEN 30\n    char_u\thas_hotkey[HAS_HOTKEY_LEN];\n    int\t\tfirst_hotkey = FALSE;\t// first char of button is hotkey\n    int\t\tidx;\n\n    has_hotkey[0] = FALSE;\n\n    /*\n     * First loop: compute the size of memory to allocate.\n     * Second loop: copy to the allocated memory.\n     */\n    for (copy = 0; copy <= 1; ++copy)\n    {\n\tr = buttons;\n\tidx = 0;\n\twhile (*r)\n\t{\n\t    if (*r == DLG_BUTTON_SEP)\n\t    {\n\t\tif (copy)\n\t\t{\n\t\t    *msgp++ = ',';\n\t\t    *msgp++ = ' ';\t    // '\\n' -> ', '\n\n\t\t    // advance to next hotkey and set default hotkey\n\t\t    if (has_mbyte)\n\t\t\thotkp += STRLEN(hotkp);\n\t\t    else\n\t\t\t++hotkp;\n\t\t    hotkp[copy_char(r + 1, hotkp, TRUE)] = NUL;\n\t\t    if (dfltbutton)\n\t\t\t--dfltbutton;\n\n\t\t    // If no hotkey is specified first char is used.\n\t\t    if (idx < HAS_HOTKEY_LEN - 1 && !has_hotkey[++idx])\n\t\t\tfirst_hotkey = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    len += 3;\t\t    // '\\n' -> ', '; 'x' -> '(x)'\n\t\t    lenhotkey += HOTK_LEN;  // each button needs a hotkey\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[++idx] = FALSE;\n\t\t}\n\t    }\n\t    else if (*r == DLG_HOTKEY_CHAR || first_hotkey)\n\t    {\n\t\tif (*r == DLG_HOTKEY_CHAR)\n\t\t    ++r;\n\t\tfirst_hotkey = FALSE;\n\t\tif (copy)\n\t\t{\n\t\t    if (*r == DLG_HOTKEY_CHAR)\t\t// '&&a' -> '&a'\n\t\t\t*msgp++ = *r;\n\t\t    else\n\t\t    {\n\t\t\t// '&a' -> '[a]'\n\t\t\t*msgp++ = (dfltbutton == 1) ? '[' : '(';\n\t\t\tmsgp += copy_char(r, msgp, FALSE);\n\t\t\t*msgp++ = (dfltbutton == 1) ? ']' : ')';\n\n\t\t\t// redefine hotkey\n\t\t\thotkp[copy_char(r, hotkp, TRUE)] = NUL;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++len;\t    // '&a' -> '[a]'\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[idx] = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// everything else copy literally\n\t\tif (copy)\n\t\t    msgp += copy_char(r, msgp, FALSE);\n\t    }\n\n\t    // advance to the next character\n\t    MB_PTR_ADV(r);\n\t}\n\n\tif (copy)\n\t{\n\t    *msgp++ = ':';\n\t    *msgp++ = ' ';\n\t    *msgp = NUL;\n\t}\n\telse\n\t{\n\t    len += (int)(STRLEN(message)\n\t\t\t+ 2\t\t\t// for the NL's\n\t\t\t+ STRLEN(buttons)\n\t\t\t+ 3);\t\t\t// for the \": \" and NUL\n\t    lenhotkey++;\t\t\t// for the NUL\n\n\t    // If no hotkey is specified first char is used.\n\t    if (!has_hotkey[0])\n\t    {\n\t\tfirst_hotkey = TRUE;\n\t\tlen += 2;\t\t// \"x\" -> \"[x]\"\n\t    }\n\n\t    /*\n\t     * Now allocate and load the strings\n\t     */\n\t    vim_free(confirm_msg);\n\t    confirm_msg = alloc(len);\n\t    if (confirm_msg == NULL)\n\t\treturn NULL;\n\t    *confirm_msg = NUL;\n\t    hotk = alloc(lenhotkey);\n\t    if (hotk == NULL)\n\t\treturn NULL;\n\n\t    *confirm_msg = '\\n';\n\t    STRCPY(confirm_msg + 1, message);\n\n\t    msgp = confirm_msg + 1 + STRLEN(message);\n\t    hotkp = hotk;\n\n\t    // Define first default hotkey.  Keep the hotkey string NUL\n\t    // terminated to avoid reading past the end.\n\t    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;\n\n\t    // Remember where the choices start, displaying starts here when\n\t    // \"hotkp\" typed at the more prompt.\n\t    confirm_msg_tail = msgp;\n\t    *msgp++ = '\\n';\n\t}\n    }\n\n    display_confirm_msg();\n    return hotk;\n}\n\n/*\n * Display the \":confirm\" message.  Also called when screen resized.\n */\n    static void\ndisplay_confirm_msg(void)\n{\n    // avoid that 'q' at the more prompt truncates the message here\n    ++confirm_msg_used;\n    if (confirm_msg != NULL)\n\tmsg_puts_attr((char *)confirm_msg, HL_ATTR(HLF_M));\n    --confirm_msg_used;\n}\n\n#endif // FEAT_CON_DIALOG\n\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\n    int\nvim_dialog_yesno(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    if (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)\n\treturn VIM_YES;\n    return VIM_NO;\n}\n\n    int\nvim_dialog_yesnocancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n    }\n    return VIM_CANCEL;\n}\n\n    int\nvim_dialog_yesnoallcancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)\"Question\" : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),\n\t\t\t\t\t\t\t   dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n\tcase 3: return VIM_ALL;\n\tcase 4: return VIM_DISCARDALL;\n    }\n    return VIM_CANCEL;\n}\n\n#endif // FEAT_GUI_DIALOG || FEAT_CON_DIALOG\n", "/* strings.c */\nchar_u *vim_strsave(char_u *string);\nchar_u *vim_strnsave(char_u *string, size_t len);\nchar_u *vim_strsave_escaped(char_u *string, char_u *esc_chars);\nchar_u *vim_strsave_escaped_ext(char_u *string, char_u *esc_chars, int cc, int bsl);\nint csh_like_shell(void);\nchar_u *vim_strsave_shellescape(char_u *string, int do_special, int do_newline);\nchar_u *vim_strsave_up(char_u *string);\nchar_u *vim_strnsave_up(char_u *string, size_t len);\nvoid vim_strup(char_u *p);\nchar_u *strlow_save(char_u *orig);\nvoid del_trailing_spaces(char_u *ptr);\nvoid vim_strncpy(char_u *to, char_u *from, size_t len);\nvoid vim_strcat(char_u *to, char_u *from, size_t tosize);\nsize_t vim_strlen_maxlen(char *s, size_t maxlen);\nint vim_stricmp(char *s1, char *s2);\nint vim_strnicmp(char *s1, char *s2, size_t len);\nchar_u *vim_strchr(char_u *string, int c);\nchar_u *vim_strbyte(char_u *string, int c);\nchar_u *vim_strrchr(char_u *string, int c);\nvoid sort_strings(char_u **files, int count);\nint has_non_ascii(char_u *s);\nchar_u *concat_str(char_u *str1, char_u *str2);\nchar_u *string_quote(char_u *str, int function);\nlong string_count(char_u *haystack, char_u *needle, int ic);\nvoid string_filter_map(char_u *str, filtermap_T filtermap, typval_T *expr, typval_T *rettv);\nvoid string_reduce(typval_T *argvars, typval_T *expr, typval_T *rettv);\nvoid f_byteidx(typval_T *argvars, typval_T *rettv);\nvoid f_byteidxcomp(typval_T *argvars, typval_T *rettv);\nvoid f_charidx(typval_T *argvars, typval_T *rettv);\nvoid f_str2list(typval_T *argvars, typval_T *rettv);\nvoid f_str2nr(typval_T *argvars, typval_T *rettv);\nvoid f_strgetchar(typval_T *argvars, typval_T *rettv);\nvoid f_stridx(typval_T *argvars, typval_T *rettv);\nvoid f_string(typval_T *argvars, typval_T *rettv);\nvoid f_strlen(typval_T *argvars, typval_T *rettv);\nvoid f_strcharlen(typval_T *argvars, typval_T *rettv);\nvoid f_strchars(typval_T *argvars, typval_T *rettv);\nvoid f_strdisplaywidth(typval_T *argvars, typval_T *rettv);\nvoid f_strwidth(typval_T *argvars, typval_T *rettv);\nvoid f_strcharpart(typval_T *argvars, typval_T *rettv);\nvoid f_strpart(typval_T *argvars, typval_T *rettv);\nvoid f_strridx(typval_T *argvars, typval_T *rettv);\nvoid f_strtrans(typval_T *argvars, typval_T *rettv);\nvoid f_tolower(typval_T *argvars, typval_T *rettv);\nvoid f_toupper(typval_T *argvars, typval_T *rettv);\nvoid f_tr(typval_T *argvars, typval_T *rettv);\nvoid f_trim(typval_T *argvars, typval_T *rettv);\n/* vim: set ft=c : */\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * strings.c: string manipulation functions\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n/*\n * Copy \"string\" into newly allocated memory.\n */\n    char_u *\nvim_strsave(char_u *string)\n{\n    char_u\t*p;\n    size_t\tlen;\n\n    len = STRLEN(string) + 1;\n    p = alloc(len);\n    if (p != NULL)\n\tmch_memmove(p, string, len);\n    return p;\n}\n\n/*\n * Copy up to \"len\" bytes of \"string\" into newly allocated memory and\n * terminate with a NUL.\n * The allocated memory always has size \"len + 1\", also when \"string\" is\n * shorter.\n */\n    char_u *\nvim_strnsave(char_u *string, size_t len)\n{\n    char_u\t*p;\n\n    p = alloc(len + 1);\n    if (p != NULL)\n    {\n\tSTRNCPY(p, string, len);\n\tp[len] = NUL;\n    }\n    return p;\n}\n\n/*\n * Same as vim_strsave(), but any characters found in esc_chars are preceded\n * by a backslash.\n */\n    char_u *\nvim_strsave_escaped(char_u *string, char_u *esc_chars)\n{\n    return vim_strsave_escaped_ext(string, esc_chars, '\\\\', FALSE);\n}\n\n/*\n * Same as vim_strsave_escaped(), but when \"bsl\" is TRUE also escape\n * characters where rem_backslash() would remove the backslash.\n * Escape the characters with \"cc\".\n */\n    char_u *\nvim_strsave_escaped_ext(\n    char_u\t*string,\n    char_u\t*esc_chars,\n    int\t\tcc,\n    int\t\tbsl)\n{\n    char_u\t*p;\n    char_u\t*p2;\n    char_u\t*escaped_string;\n    unsigned\tlength;\n    int\t\tl;\n\n    // First count the number of backslashes required.\n    // Then allocate the memory and insert them.\n    length = 1;\t\t\t\t// count the trailing NUL\n    for (p = string; *p; p++)\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    length += l;\t\t// count a multibyte char\n\t    p += l - 1;\n\t    continue;\n\t}\n\tif (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))\n\t    ++length;\t\t\t// count a backslash\n\t++length;\t\t\t// count an ordinary char\n    }\n    escaped_string = alloc(length);\n    if (escaped_string != NULL)\n    {\n\tp2 = escaped_string;\n\tfor (p = string; *p; p++)\n\t{\n\t    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    {\n\t\tmch_memmove(p2, p, (size_t)l);\n\t\tp2 += l;\n\t\tp += l - 1;\t\t// skip multibyte char\n\t\tcontinue;\n\t    }\n\t    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))\n\t\t*p2++ = cc;\n\t    *p2++ = *p;\n\t}\n\t*p2 = NUL;\n    }\n    return escaped_string;\n}\n\n/*\n * Return TRUE when 'shell' has \"csh\" in the tail.\n */\n    int\ncsh_like_shell(void)\n{\n    return (strstr((char *)gettail(p_sh), \"csh\") != NULL);\n}\n\n/*\n * Return TRUE when 'shell' has \"fish\" in the tail.\n */\n    static int\nfish_like_shell(void)\n{\n    return (strstr((char *)gettail(p_sh), \"fish\") != NULL);\n}\n\n/*\n * Escape \"string\" for use as a shell argument with system().\n * This uses single quotes, except when we know we need to use double quotes\n * (MS-DOS and MS-Windows not using PowerShell and without 'shellslash' set).\n * PowerShell also uses a novel escaping for enclosed single quotes - double\n * them up.\n * Escape a newline, depending on the 'shell' option.\n * When \"do_special\" is TRUE also replace \"!\", \"%\", \"#\" and things starting\n * with \"<\" like \"<cfile>\".\n * When \"do_newline\" is FALSE do not escape newline unless it is csh shell.\n * Returns the result in allocated memory, NULL if we have run out.\n */\n    char_u *\nvim_strsave_shellescape(char_u *string, int do_special, int do_newline)\n{\n    unsigned\tlength;\n    char_u\t*p;\n    char_u\t*d;\n    char_u\t*escaped_string;\n    int\t\tl;\n    int\t\tcsh_like;\n    int\t\tfish_like;\n    char_u\t*shname;\n    int\t\tpowershell;\n# ifdef MSWIN\n    int\t\tdouble_quotes;\n# endif\n\n    // Only csh and similar shells expand '!' within single quotes.  For sh and\n    // the like we must not put a backslash before it, it will be taken\n    // literally.  If do_special is set the '!' will be escaped twice.\n    // Csh also needs to have \"\\n\" escaped twice when do_special is set.\n    csh_like = csh_like_shell();\n\n    // Fish shell uses '\\' as an escape character within single quotes, so '\\'\n    // itself must be escaped to get a literal '\\'.\n    fish_like = fish_like_shell();\n\n    // PowerShell uses its own version for quoting single quotes\n    shname = gettail(p_sh);\n    powershell = strstr((char *)shname, \"pwsh\") != NULL;\n# ifdef MSWIN\n    powershell = powershell || strstr((char *)shname, \"powershell\") != NULL;\n    // PowerShell only accepts single quotes so override shellslash.\n    double_quotes = !powershell && !p_ssl;\n# endif\n\n    // First count the number of extra bytes required.\n    length = (unsigned)STRLEN(string) + 3;  // two quotes and a trailing NUL\n    for (p = string; *p != NUL; MB_PTR_ADV(p))\n    {\n# ifdef MSWIN\n\tif (double_quotes)\n\t{\n\t    if (*p == '\"')\n\t\t++length;\t\t// \" -> \"\"\n\t}\n\telse\n# endif\n\tif (*p == '\\'')\n\t{\n\t    if (powershell)\n\t\tlength +=2;\t\t// ' => ''\n\t    else\n\t\tlength += 3;\t\t// ' => '\\''\n\t}\n\tif ((*p == '\\n' && (csh_like || do_newline))\n\t\t|| (*p == '!' && (csh_like || do_special)))\n\t{\n\t    ++length;\t\t\t// insert backslash\n\t    if (csh_like && do_special)\n\t\t++length;\t\t// insert backslash\n\t}\n\tif (do_special && find_cmdline_var(p, &l) >= 0)\n\t{\n\t    ++length;\t\t\t// insert backslash\n\t    p += l - 1;\n\t}\n\tif (*p == '\\\\' && fish_like)\n\t    ++length;\t\t\t// insert backslash\n    }\n\n    // Allocate memory for the result and fill it.\n    escaped_string = alloc(length);\n    if (escaped_string != NULL)\n    {\n\td = escaped_string;\n\n\t// add opening quote\n# ifdef MSWIN\n\tif (double_quotes)\n\t    *d++ = '\"';\n\telse\n# endif\n\t    *d++ = '\\'';\n\n\tfor (p = string; *p != NUL; )\n\t{\n# ifdef MSWIN\n\t    if (double_quotes)\n\t    {\n\t\tif (*p == '\"')\n\t\t{\n\t\t    *d++ = '\"';\n\t\t    *d++ = '\"';\n\t\t    ++p;\n\t\t    continue;\n\t\t}\n\t    }\n\t    else\n# endif\n\t    if (*p == '\\'')\n\t    {\n\t\tif (powershell)\n\t\t{\n\t\t    *d++ = '\\'';\n\t\t    *d++ = '\\'';\n\t\t}\n\t\telse\n\t\t{\n\t\t    *d++ = '\\'';\n\t\t    *d++ = '\\\\';\n\t\t    *d++ = '\\'';\n\t\t    *d++ = '\\'';\n\t\t}\n\t\t++p;\n\t\tcontinue;\n\t    }\n\t    if ((*p == '\\n' && (csh_like || do_newline))\n\t\t    || (*p == '!' && (csh_like || do_special)))\n\t    {\n\t\t*d++ = '\\\\';\n\t\tif (csh_like && do_special)\n\t\t    *d++ = '\\\\';\n\t\t*d++ = *p++;\n\t\tcontinue;\n\t    }\n\t    if (do_special && find_cmdline_var(p, &l) >= 0)\n\t    {\n\t\t*d++ = '\\\\';\t\t// insert backslash\n\t\twhile (--l >= 0)\t// copy the var\n\t\t    *d++ = *p++;\n\t\tcontinue;\n\t    }\n\t    if (*p == '\\\\' && fish_like)\n\t    {\n\t\t*d++ = '\\\\';\n\t\t*d++ = *p++;\n\t\tcontinue;\n\t    }\n\n\t    MB_COPY_CHAR(p, d);\n\t}\n\n\t// add terminating quote and finish with a NUL\n# ifdef MSWIN\n\tif (double_quotes)\n\t    *d++ = '\"';\n\telse\n# endif\n\t    *d++ = '\\'';\n\t*d = NUL;\n    }\n\n    return escaped_string;\n}\n\n/*\n * Like vim_strsave(), but make all characters uppercase.\n * This uses ASCII lower-to-upper case translation, language independent.\n */\n    char_u *\nvim_strsave_up(char_u *string)\n{\n    char_u *p1;\n\n    p1 = vim_strsave(string);\n    vim_strup(p1);\n    return p1;\n}\n\n/*\n * Like vim_strnsave(), but make all characters uppercase.\n * This uses ASCII lower-to-upper case translation, language independent.\n */\n    char_u *\nvim_strnsave_up(char_u *string, size_t len)\n{\n    char_u *p1;\n\n    p1 = vim_strnsave(string, len);\n    vim_strup(p1);\n    return p1;\n}\n\n/*\n * ASCII lower-to-upper case translation, language independent.\n */\n    void\nvim_strup(\n    char_u\t*p)\n{\n    char_u  *p2;\n    int\t    c;\n\n    if (p != NULL)\n    {\n\tp2 = p;\n\twhile ((c = *p2) != NUL)\n\t    *p2++ = (c < 'a' || c > 'z') ? c : (c - 0x20);\n    }\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Make string \"s\" all upper-case and return it in allocated memory.\n * Handles multi-byte characters as well as possible.\n * Returns NULL when out of memory.\n */\n    static char_u *\nstrup_save(char_u *orig)\n{\n    char_u\t*p;\n    char_u\t*res;\n\n    res = p = vim_strsave(orig);\n\n    if (res != NULL)\n\twhile (*p != NUL)\n\t{\n\t    int\t\tl;\n\n\t    if (enc_utf8)\n\t    {\n\t\tint\tc, uc;\n\t\tint\tnewl;\n\t\tchar_u\t*s;\n\n\t\tc = utf_ptr2char(p);\n\t\tl = utf_ptr2len(p);\n\t\tif (c == 0)\n\t\t{\n\t\t    // overlong sequence, use only the first byte\n\t\t    c = *p;\n\t\t    l = 1;\n\t\t}\n\t\tuc = utf_toupper(c);\n\n\t\t// Reallocate string when byte count changes.  This is rare,\n\t\t// thus it's OK to do another malloc()/free().\n\t\tnewl = utf_char2len(uc);\n\t\tif (newl != l)\n\t\t{\n\t\t    s = alloc(STRLEN(res) + 1 + newl - l);\n\t\t    if (s == NULL)\n\t\t    {\n\t\t\tvim_free(res);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    mch_memmove(s, res, p - res);\n\t\t    STRCPY(s + (p - res) + newl, p + l);\n\t\t    p = s + (p - res);\n\t\t    vim_free(res);\n\t\t    res = s;\n\t\t}\n\n\t\tutf_char2bytes(uc, p);\n\t\tp += newl;\n\t    }\n\t    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t\tp += l;\t\t// skip multi-byte character\n\t    else\n\t    {\n\t\t*p = TOUPPER_LOC(*p); // note that toupper() can be a macro\n\t\tp++;\n\t    }\n\t}\n\n    return res;\n}\n\n/*\n * Make string \"s\" all lower-case and return it in allocated memory.\n * Handles multi-byte characters as well as possible.\n * Returns NULL when out of memory.\n */\n    char_u *\nstrlow_save(char_u *orig)\n{\n    char_u\t*p;\n    char_u\t*res;\n\n    res = p = vim_strsave(orig);\n\n    if (res != NULL)\n\twhile (*p != NUL)\n\t{\n\t    int\t\tl;\n\n\t    if (enc_utf8)\n\t    {\n\t\tint\tc, lc;\n\t\tint\tnewl;\n\t\tchar_u\t*s;\n\n\t\tc = utf_ptr2char(p);\n\t\tl = utf_ptr2len(p);\n\t\tif (c == 0)\n\t\t{\n\t\t    // overlong sequence, use only the first byte\n\t\t    c = *p;\n\t\t    l = 1;\n\t\t}\n\t\tlc = utf_tolower(c);\n\n\t\t// Reallocate string when byte count changes.  This is rare,\n\t\t// thus it's OK to do another malloc()/free().\n\t\tnewl = utf_char2len(lc);\n\t\tif (newl != l)\n\t\t{\n\t\t    s = alloc(STRLEN(res) + 1 + newl - l);\n\t\t    if (s == NULL)\n\t\t    {\n\t\t\tvim_free(res);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    mch_memmove(s, res, p - res);\n\t\t    STRCPY(s + (p - res) + newl, p + l);\n\t\t    p = s + (p - res);\n\t\t    vim_free(res);\n\t\t    res = s;\n\t\t}\n\n\t\tutf_char2bytes(lc, p);\n\t\tp += newl;\n\t    }\n\t    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t\tp += l;\t\t// skip multi-byte character\n\t    else\n\t    {\n\t\t*p = TOLOWER_LOC(*p); // note that tolower() can be a macro\n\t\tp++;\n\t    }\n\t}\n\n    return res;\n}\n#endif\n\n/*\n * delete spaces at the end of a string\n */\n    void\ndel_trailing_spaces(char_u *ptr)\n{\n    char_u\t*q;\n\n    q = ptr + STRLEN(ptr);\n    while (--q > ptr && VIM_ISWHITE(q[0]) && q[-1] != '\\\\' && q[-1] != Ctrl_V)\n\t*q = NUL;\n}\n\n/*\n * Like strncpy(), but always terminate the result with one NUL.\n * \"to\" must be \"len + 1\" long!\n */\n    void\nvim_strncpy(char_u *to, char_u *from, size_t len)\n{\n    STRNCPY(to, from, len);\n    to[len] = NUL;\n}\n\n/*\n * Like strcat(), but make sure the result fits in \"tosize\" bytes and is\n * always NUL terminated. \"from\" and \"to\" may overlap.\n */\n    void\nvim_strcat(char_u *to, char_u *from, size_t tosize)\n{\n    size_t tolen = STRLEN(to);\n    size_t fromlen = STRLEN(from);\n\n    if (tolen + fromlen + 1 > tosize)\n    {\n\tmch_memmove(to + tolen, from, tosize - tolen - 1);\n\tto[tosize - 1] = NUL;\n    }\n    else\n\tmch_memmove(to + tolen, from, fromlen + 1);\n}\n\n/*\n * A version of strlen() that has a maximum length.\n */\n    size_t\nvim_strlen_maxlen(char *s, size_t maxlen)\n{\n    size_t i;\n    for (i = 0; i < maxlen; ++i)\n\tif (s[i] == NUL)\n\t    break;\n    return i;\n}\n\n#if (!defined(HAVE_STRCASECMP) && !defined(HAVE_STRICMP)) || defined(PROTO)\n/*\n * Compare two strings, ignoring case, using current locale.\n * Doesn't work for multi-byte characters.\n * return 0 for match, < 0 for smaller, > 0 for bigger\n */\n    int\nvim_stricmp(char *s1, char *s2)\n{\n    int\t\ti;\n\n    for (;;)\n    {\n\ti = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);\n\tif (i != 0)\n\t    return i;\t\t\t    // this character different\n\tif (*s1 == NUL)\n\t    break;\t\t\t    // strings match until NUL\n\t++s1;\n\t++s2;\n    }\n    return 0;\t\t\t\t    // strings match\n}\n#endif\n\n#if (!defined(HAVE_STRNCASECMP) && !defined(HAVE_STRNICMP)) || defined(PROTO)\n/*\n * Compare two strings, for length \"len\", ignoring case, using current locale.\n * Doesn't work for multi-byte characters.\n * return 0 for match, < 0 for smaller, > 0 for bigger\n */\n    int\nvim_strnicmp(char *s1, char *s2, size_t len)\n{\n    int\t\ti;\n\n    while (len > 0)\n    {\n\ti = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);\n\tif (i != 0)\n\t    return i;\t\t\t    // this character different\n\tif (*s1 == NUL)\n\t    break;\t\t\t    // strings match until NUL\n\t++s1;\n\t++s2;\n\t--len;\n    }\n    return 0;\t\t\t\t    // strings match\n}\n#endif\n\n/*\n * Search for first occurrence of \"c\" in \"string\".\n * Version of strchr() that handles unsigned char strings with characters from\n * 128 to 255 correctly.  It also doesn't return a pointer to the NUL at the\n * end of the string.\n */\n    char_u *\nvim_strchr(char_u *string, int c)\n{\n    char_u\t*p;\n    int\t\tb;\n\n    p = string;\n    if (enc_utf8 && c >= 0x80)\n    {\n\twhile (*p != NUL)\n\t{\n\t    int l = utfc_ptr2len(p);\n\n\t    // Avoid matching an illegal byte here.\n\t    if (utf_ptr2char(p) == c && l > 1)\n\t\treturn p;\n\t    p += l;\n\t}\n\treturn NULL;\n    }\n    if (enc_dbcs != 0 && c > 255)\n    {\n\tint\tn2 = c & 0xff;\n\n\tc = ((unsigned)c >> 8) & 0xff;\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c && p[1] == n2)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    if (has_mbyte)\n    {\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    while ((b = *p) != NUL)\n    {\n\tif (b == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}\n\n/*\n * Version of strchr() that only works for bytes and handles unsigned char\n * strings with characters above 128 correctly. It also doesn't return a\n * pointer to the NUL at the end of the string.\n */\n    char_u  *\nvim_strbyte(char_u *string, int c)\n{\n    char_u\t*p = string;\n\n    while (*p != NUL)\n    {\n\tif (*p == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}\n\n/*\n * Search for last occurrence of \"c\" in \"string\".\n * Version of strrchr() that handles unsigned char strings with characters from\n * 128 to 255 correctly.  It also doesn't return a pointer to the NUL at the\n * end of the string.\n * Return NULL if not found.\n * Does not handle multi-byte char for \"c\"!\n */\n    char_u  *\nvim_strrchr(char_u *string, int c)\n{\n    char_u\t*retval = NULL;\n    char_u\t*p = string;\n\n    while (*p)\n    {\n\tif (*p == c)\n\t    retval = p;\n\tMB_PTR_ADV(p);\n    }\n    return retval;\n}\n\n/*\n * Vim's version of strpbrk(), in case it's missing.\n * Don't generate a prototype for this, causes problems when it's not used.\n */\n#ifndef PROTO\n# ifndef HAVE_STRPBRK\n#  ifdef vim_strpbrk\n#   undef vim_strpbrk\n#  endif\n    char_u *\nvim_strpbrk(char_u *s, char_u *charset)\n{\n    while (*s)\n    {\n\tif (vim_strchr(charset, *s) != NULL)\n\t    return s;\n\tMB_PTR_ADV(s);\n    }\n    return NULL;\n}\n# endif\n#endif\n\n/*\n * Sort an array of strings.\n */\nstatic int sort_compare(const void *s1, const void *s2);\n\n    static int\nsort_compare(const void *s1, const void *s2)\n{\n    return STRCMP(*(char **)s1, *(char **)s2);\n}\n\n    void\nsort_strings(\n    char_u\t**files,\n    int\t\tcount)\n{\n    qsort((void *)files, (size_t)count, sizeof(char_u *), sort_compare);\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return TRUE if string \"s\" contains a non-ASCII character (128 or higher).\n * When \"s\" is NULL FALSE is returned.\n */\n    int\nhas_non_ascii(char_u *s)\n{\n    char_u\t*p;\n\n    if (s != NULL)\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p >= 128)\n\t\treturn TRUE;\n    return FALSE;\n}\n#endif\n\n/*\n * Concatenate two strings and return the result in allocated memory.\n * Returns NULL when out of memory.\n */\n    char_u  *\nconcat_str(char_u *str1, char_u *str2)\n{\n    char_u  *dest;\n    size_t  l = str1 == NULL ? 0 : STRLEN(str1);\n\n    dest = alloc(l + (str2 == NULL ? 0 : STRLEN(str2)) + 1L);\n    if (dest != NULL)\n    {\n\tif (str1 == NULL)\n\t    *dest = NUL;\n\telse\n\t    STRCPY(dest, str1);\n\tif (str2 != NULL)\n\t    STRCPY(dest + l, str2);\n    }\n    return dest;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return string \"str\" in ' quotes, doubling ' characters.\n * If \"str\" is NULL an empty string is assumed.\n * If \"function\" is TRUE make it function('string').\n */\n    char_u *\nstring_quote(char_u *str, int function)\n{\n    unsigned\tlen;\n    char_u\t*p, *r, *s;\n\n    len = (function ? 13 : 3);\n    if (str != NULL)\n    {\n\tlen += (unsigned)STRLEN(str);\n\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t    if (*p == '\\'')\n\t\t++len;\n    }\n    s = r = alloc(len);\n    if (r != NULL)\n    {\n\tif (function)\n\t{\n\t    STRCPY(r, \"function('\");\n\t    r += 10;\n\t}\n\telse\n\t    *r++ = '\\'';\n\tif (str != NULL)\n\t    for (p = str; *p != NUL; )\n\t    {\n\t\tif (*p == '\\'')\n\t\t    *r++ = '\\'';\n\t\tMB_COPY_CHAR(p, r);\n\t    }\n\t*r++ = '\\'';\n\tif (function)\n\t    *r++ = ')';\n\t*r++ = NUL;\n    }\n    return s;\n}\n\n/*\n * Count the number of times \"needle\" occurs in string \"haystack\". Case is\n * ignored if \"ic\" is TRUE.\n */\n    long\nstring_count(char_u *haystack, char_u *needle, int ic)\n{\n    long\tn = 0;\n    char_u\t*p = haystack;\n    char_u\t*next;\n\n    if (p == NULL || needle == NULL || *needle == NUL)\n\treturn 0;\n\n    if (ic)\n    {\n\tsize_t len = STRLEN(needle);\n\n\twhile (*p != NUL)\n\t{\n\t    if (MB_STRNICMP(p, needle, len) == 0)\n\t    {\n\t\t++n;\n\t\tp += len;\n\t    }\n\t    else\n\t\tMB_PTR_ADV(p);\n\t}\n    }\n    else\n\twhile ((next = (char_u *)strstr((char *)p, (char *)needle)) != NULL)\n\t{\n\t    ++n;\n\t    p = next + STRLEN(needle);\n\t}\n\n    return n;\n}\n\n/*\n * Make a typval_T of the first character of \"input\" and store it in \"output\".\n * Return OK or FAIL.\n */\n    static int\ncopy_first_char_to_tv(char_u *input, typval_T *output)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\tlen;\n\n    if (input == NULL || output == NULL)\n\treturn FAIL;\n\n    len = has_mbyte ? mb_ptr2len(input) : 1;\n    STRNCPY(buf, input, len);\n    buf[len] = NUL;\n    output->v_type = VAR_STRING;\n    output->vval.v_string = vim_strsave(buf);\n\n    return output->vval.v_string == NULL ? FAIL : OK;\n}\n\n/*\n * Implementation of map() and filter() for a String. Apply \"expr\" to every\n * character in string \"str\" and return the result in \"rettv\".\n */\n    void\nstring_filter_map(\n\tchar_u\t\t*str,\n\tfiltermap_T\tfiltermap,\n\ttypval_T\t*expr,\n\ttypval_T\t*rettv)\n{\n    char_u\t*p;\n    typval_T\ttv;\n    garray_T\tga;\n    int\t\tlen = 0;\n    int\t\tidx = 0;\n    int\t\trem;\n    typval_T\tnewtv;\n    funccall_T\t*fc;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    // set_vim_var_nr() doesn't set the type\n    set_vim_var_type(VV_KEY, VAR_NUMBER);\n\n    // Create one funccal_T for all eval_expr_typval() calls.\n    fc = eval_expr_get_funccal(expr, &newtv);\n\n    ga_init2(&ga, sizeof(char), 80);\n    for (p = str; *p != NUL; p += len)\n    {\n\tif (copy_first_char_to_tv(p, &tv) == FAIL)\n\t    break;\n\tlen = (int)STRLEN(tv.vval.v_string);\n\n\tnewtv.v_type = VAR_UNKNOWN;\n\tset_vim_var_nr(VV_KEY, idx);\n\tif (filter_map_one(&tv, expr, filtermap, fc, &newtv, &rem) == FAIL\n\t\t|| did_emsg)\n\t{\n\t    clear_tv(&newtv);\n\t    clear_tv(&tv);\n\t    break;\n\t}\n\telse if (filtermap != FILTERMAP_FILTER)\n\t{\n\t    if (newtv.v_type != VAR_STRING)\n\t    {\n\t\tclear_tv(&newtv);\n\t\tclear_tv(&tv);\n\t\temsg(_(e_string_required));\n\t\tbreak;\n\t    }\n\t    else\n\t\tga_concat(&ga, newtv.vval.v_string);\n\t}\n\telse if (!rem)\n\t    ga_concat(&ga, tv.vval.v_string);\n\n\tclear_tv(&newtv);\n\tclear_tv(&tv);\n\n\t++idx;\n    }\n    ga_append(&ga, NUL);\n    rettv->vval.v_string = ga.ga_data;\n    if (fc != NULL)\n\tremove_funccal();\n}\n\n/*\n * Implementation of reduce() for String \"argvars[0]\" using the function \"expr\"\n * starting with the optional initial value \"argvars[2]\" and return the result\n * in \"rettv\".\n */\n    void\nstring_reduce(\n\ttypval_T\t*argvars,\n\ttypval_T\t*expr,\n\ttypval_T\t*rettv)\n{\n    char_u\t*p = tv_get_string(&argvars[0]);\n    int\t\tlen;\n    typval_T\targv[3];\n    int\t\tr;\n    int\t\tcalled_emsg_start = called_emsg;\n    funccall_T\t*fc;\n\n    if (argvars[2].v_type == VAR_UNKNOWN)\n    {\n\tif (*p == NUL)\n\t{\n\t    semsg(_(e_reduce_of_an_empty_str_with_no_initial_value), \"String\");\n\t    return;\n\t}\n\tif (copy_first_char_to_tv(p, rettv) == FAIL)\n\t    return;\n\tp += STRLEN(rettv->vval.v_string);\n    }\n    else if (check_for_string_arg(argvars, 2) == FAIL)\n\treturn;\n    else\n\tcopy_tv(&argvars[2], rettv);\n\n    // Create one funccal_T for all eval_expr_typval() calls.\n    fc = eval_expr_get_funccal(expr, rettv);\n\n    for ( ; *p != NUL; p += len)\n    {\n\targv[0] = *rettv;\n\tif (copy_first_char_to_tv(p, &argv[1]) == FAIL)\n\t    break;\n\tlen = (int)STRLEN(argv[1].vval.v_string);\n\n\tr = eval_expr_typval(expr, argv, 2, fc, rettv);\n\n\tclear_tv(&argv[0]);\n\tclear_tv(&argv[1]);\n\tif (r == FAIL || called_emsg != called_emsg_start)\n\t    return;\n    }\n\n    if (fc != NULL)\n\tremove_funccal();\n}\n\n    static void\nbyteidx(typval_T *argvars, typval_T *rettv, int comp UNUSED)\n{\n    char_u\t*t;\n    char_u\t*str;\n    varnumber_T\tidx;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\n    idx = tv_get_number_chk(&argvars[1], NULL);\n    if (str == NULL || idx < 0)\n\treturn;\n\n    t = str;\n    for ( ; idx > 0; idx--)\n    {\n\tif (*t == NUL)\t\t// EOL reached\n\t    return;\n\tif (enc_utf8 && comp)\n\t    t += utf_ptr2len(t);\n\telse\n\t    t += (*mb_ptr2len)(t);\n    }\n    rettv->vval.v_number = (varnumber_T)(t - str);\n}\n\n/*\n * \"byteidx()\" function\n */\n    void\nf_byteidx(typval_T *argvars, typval_T *rettv)\n{\n    byteidx(argvars, rettv, FALSE);\n}\n\n/*\n * \"byteidxcomp()\" function\n */\n    void\nf_byteidxcomp(typval_T *argvars, typval_T *rettv)\n{\n    byteidx(argvars, rettv, TRUE);\n}\n\n/*\n * \"charidx()\" function\n */\n    void\nf_charidx(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    varnumber_T\tidx;\n    varnumber_T\tcountcc = FALSE;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\t(*ptr2len)(char_u *);\n\n    rettv->vval.v_number = -1;\n\n    if ((check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 2) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\n    idx = tv_get_number_chk(&argvars[1], NULL);\n    if (str == NULL || idx < 0)\n\treturn;\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n\tcountcc = tv_get_bool(&argvars[2]);\n    if (countcc < 0 || countcc > 1)\n    {\n\tsemsg(_(e_using_number_as_bool_nr), countcc);\n\treturn;\n    }\n\n    if (enc_utf8 && countcc)\n\tptr2len = utf_ptr2len;\n    else\n\tptr2len = mb_ptr2len;\n\n    for (p = str, len = 0; p <= str + idx; len++)\n    {\n\tif (*p == NUL)\n\t    return;\n\tp += ptr2len(p);\n    }\n\n    rettv->vval.v_number = len > 0 ? len - 1 : 0;\n}\n\n/*\n * \"str2list()\" function\n */\n    void\nf_str2list(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n    int\t\tutf8 = FALSE;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tutf8 = (int)tv_get_bool_chk(&argvars[1], NULL);\n\n    p = tv_get_string(&argvars[0]);\n\n    if (has_mbyte || utf8)\n    {\n\tint (*ptr2len)(char_u *);\n\tint (*ptr2char)(char_u *);\n\n\tif (utf8 || enc_utf8)\n\t{\n\t    ptr2len = utf_ptr2len;\n\t    ptr2char = utf_ptr2char;\n\t}\n\telse\n\t{\n\t    ptr2len = mb_ptr2len;\n\t    ptr2char = mb_ptr2char;\n\t}\n\n\tfor ( ; *p != NUL; p += (*ptr2len)(p))\n\t    list_append_number(rettv->vval.v_list, (*ptr2char)(p));\n    }\n    else\n\tfor ( ; *p != NUL; ++p)\n\t    list_append_number(rettv->vval.v_list, *p);\n}\n\n/*\n * \"str2nr()\" function\n */\n    void\nf_str2nr(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tbase = 10;\n    char_u\t*p;\n    varnumber_T\tn;\n    int\t\twhat = 0;\n    int\t\tisneg;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_bool_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tbase = (int)tv_get_number(&argvars[1]);\n\tif (base != 2 && base != 8 && base != 10 && base != 16)\n\t{\n\t    emsg(_(e_invalid_argument));\n\t    return;\n\t}\n\tif (argvars[2].v_type != VAR_UNKNOWN && tv_get_bool(&argvars[2]))\n\t    what |= STR2NR_QUOTE;\n    }\n\n    p = skipwhite(tv_get_string_strict(&argvars[0]));\n    isneg = (*p == '-');\n    if (*p == '+' || *p == '-')\n\tp = skipwhite(p + 1);\n    switch (base)\n    {\n\tcase 2: what |= STR2NR_BIN + STR2NR_FORCE; break;\n\tcase 8: what |= STR2NR_OCT + STR2NR_OOCT + STR2NR_FORCE; break;\n\tcase 16: what |= STR2NR_HEX + STR2NR_FORCE; break;\n    }\n    vim_str2nr(p, NULL, NULL, what, &n, NULL, 0, FALSE);\n    // Text after the number is silently ignored.\n    if (isneg)\n\trettv->vval.v_number = -n;\n    else\n\trettv->vval.v_number = n;\n\n}\n\n/*\n * \"strgetchar()\" function\n */\n    void\nf_strgetchar(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    int\t\tlen;\n    int\t\terror = FALSE;\n    int\t\tcharidx;\n    int\t\tbyteidx = 0;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    str = tv_get_string_chk(&argvars[0]);\n    if (str == NULL)\n\treturn;\n    len = (int)STRLEN(str);\n    charidx = (int)tv_get_number_chk(&argvars[1], &error);\n    if (error)\n\treturn;\n\n    while (charidx >= 0 && byteidx < len)\n    {\n\tif (charidx == 0)\n\t{\n\t    rettv->vval.v_number = mb_ptr2char(str + byteidx);\n\t    break;\n\t}\n\t--charidx;\n\tbyteidx += MB_CPTR2LEN(str + byteidx);\n    }\n}\n\n/*\n * \"stridx()\" function\n */\n    void\nf_stridx(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf[NUMBUFLEN];\n    char_u\t*needle;\n    char_u\t*haystack;\n    char_u\t*save_haystack;\n    char_u\t*pos;\n    int\t\tstart_idx;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    needle = tv_get_string_chk(&argvars[1]);\n    save_haystack = haystack = tv_get_string_buf_chk(&argvars[0], buf);\n    rettv->vval.v_number = -1;\n    if (needle == NULL || haystack == NULL)\n\treturn;\t\t// type error; errmsg already given\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tint\t    error = FALSE;\n\n\tstart_idx = (int)tv_get_number_chk(&argvars[2], &error);\n\tif (error || start_idx >= (int)STRLEN(haystack))\n\t    return;\n\tif (start_idx >= 0)\n\t    haystack += start_idx;\n    }\n\n    pos\t= (char_u *)strstr((char *)haystack, (char *)needle);\n    if (pos != NULL)\n\trettv->vval.v_number = (varnumber_T)(pos - save_haystack);\n}\n\n/*\n * \"string()\" function\n */\n    void\nf_string(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = tv2string(&argvars[0], &tofree, numbuf,\n\t\t\t\t\t\t\t\tget_copyID());\n    // Make a copy if we have a value but it's not in allocated memory.\n    if (rettv->vval.v_string != NULL && tofree == NULL)\n\trettv->vval.v_string = vim_strsave(rettv->vval.v_string);\n}\n\n/*\n * \"strlen()\" function\n */\n    void\nf_strlen(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && check_for_string_or_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = (varnumber_T)(STRLEN(\n\t\t\t\t\t      tv_get_string(&argvars[0])));\n}\n\n    static void\nstrchar_common(typval_T *argvars, typval_T *rettv, int skipcc)\n{\n    char_u\t\t*s = tv_get_string(&argvars[0]);\n    varnumber_T\t\tlen = 0;\n    int\t\t\t(*func_mb_ptr2char_adv)(char_u **pp);\n\n    func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;\n    while (*s != NUL)\n    {\n\tfunc_mb_ptr2char_adv(&s);\n\t++len;\n    }\n    rettv->vval.v_number = len;\n}\n\n/*\n * \"strcharlen()\" function\n */\n    void\nf_strcharlen(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && check_for_string_or_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    strchar_common(argvars, rettv, TRUE);\n}\n\n/*\n * \"strchars()\" function\n */\n    void\nf_strchars(typval_T *argvars, typval_T *rettv)\n{\n    varnumber_T\t\tskipcc = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tskipcc = tv_get_bool(&argvars[1]);\n    if (skipcc < 0 || skipcc > 1)\n\tsemsg(_(e_using_number_as_bool_nr), skipcc);\n    else\n\tstrchar_common(argvars, rettv, skipcc);\n}\n\n/*\n * \"strdisplaywidth()\" function\n */\n    void\nf_strdisplaywidth(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*s;\n    int\t\tcol = 0;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    s = tv_get_string(&argvars[0]);\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tcol = (int)tv_get_number(&argvars[1]);\n\n    rettv->vval.v_number = (varnumber_T)(linetabsize_col(col, s) - col);\n}\n\n/*\n * \"strwidth()\" function\n */\n    void\nf_strwidth(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*s;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    s = tv_get_string_strict(&argvars[0]);\n    rettv->vval.v_number = (varnumber_T)(mb_string2cells(s, -1));\n}\n\n/*\n * \"strcharpart()\" function\n */\n    void\nf_strcharpart(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n    int\t\tnchar;\n    int\t\tnbyte = 0;\n    int\t\tcharlen;\n    int\t\tskipcc = FALSE;\n    int\t\tlen = 0;\n    int\t\tslen;\n    int\t\terror = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_bool_arg(argvars, 3) == FAIL)))\n\treturn;\n\n    p = tv_get_string(&argvars[0]);\n    slen = (int)STRLEN(p);\n\n    nchar = (int)tv_get_number_chk(&argvars[1], &error);\n    if (!error)\n    {\n\tif (argvars[2].v_type != VAR_UNKNOWN\n\t\t\t\t\t   && argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    skipcc = tv_get_bool(&argvars[3]);\n\t    if (skipcc < 0 || skipcc > 1)\n\t    {\n\t\tsemsg(_(e_using_number_as_bool_nr), skipcc);\n\t\treturn;\n\t    }\n\t}\n\n\tif (nchar > 0)\n\t    while (nchar > 0 && nbyte < slen)\n\t    {\n\t\tif (skipcc)\n\t\t    nbyte += mb_ptr2len(p + nbyte);\n\t\telse\n\t\t    nbyte += MB_CPTR2LEN(p + nbyte);\n\t\t--nchar;\n\t    }\n\telse\n\t    nbyte = nchar;\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    charlen = (int)tv_get_number(&argvars[2]);\n\t    while (charlen > 0 && nbyte + len < slen)\n\t    {\n\t\tint off = nbyte + len;\n\n\t\tif (off < 0)\n\t\t    len += 1;\n\t\telse\n\t\t{\n\t\t    if (skipcc)\n\t\t\tlen += mb_ptr2len(p + off);\n\t\t    else\n\t\t\tlen += MB_CPTR2LEN(p + off);\n\t\t}\n\t\t--charlen;\n\t    }\n\t}\n\telse\n\t    len = slen - nbyte;    // default: all bytes that are available.\n    }\n\n    // Only return the overlap between the specified part and the actual\n    // string.\n    if (nbyte < 0)\n    {\n\tlen += nbyte;\n\tnbyte = 0;\n    }\n    else if (nbyte > slen)\n\tnbyte = slen;\n    if (len < 0)\n\tlen = 0;\n    else if (nbyte + len > slen)\n\tlen = slen - nbyte;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = vim_strnsave(p + nbyte, len);\n}\n\n/*\n * \"strpart()\" function\n */\n    void\nf_strpart(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n    int\t\tn;\n    int\t\tlen;\n    int\t\tslen;\n    int\t\terror = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_bool_arg(argvars, 3) == FAIL)))\n\treturn;\n\n    p = tv_get_string(&argvars[0]);\n    slen = (int)STRLEN(p);\n\n    n = (int)tv_get_number_chk(&argvars[1], &error);\n    if (error)\n\tlen = 0;\n    else if (argvars[2].v_type != VAR_UNKNOWN)\n\tlen = (int)tv_get_number(&argvars[2]);\n    else\n\tlen = slen - n;\t    // default len: all bytes that are available.\n\n    // Only return the overlap between the specified part and the actual\n    // string.\n    if (n < 0)\n    {\n\tlen += n;\n\tn = 0;\n    }\n    else if (n > slen)\n\tn = slen;\n    if (len < 0)\n\tlen = 0;\n    else if (n + len > slen)\n\tlen = slen - n;\n\n    if (argvars[2].v_type != VAR_UNKNOWN && argvars[3].v_type != VAR_UNKNOWN)\n    {\n\tint off;\n\n\t// length in characters\n\tfor (off = n; off < slen && len > 0; --len)\n\t    off += mb_ptr2len(p + off);\n\tlen = off - n;\n    }\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = vim_strnsave(p + n, len);\n}\n\n/*\n * \"strridx()\" function\n */\n    void\nf_strridx(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf[NUMBUFLEN];\n    char_u\t*needle;\n    char_u\t*haystack;\n    char_u\t*rest;\n    char_u\t*lastmatch = NULL;\n    int\t\thaystack_len, end_idx;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    needle = tv_get_string_chk(&argvars[1]);\n    haystack = tv_get_string_buf_chk(&argvars[0], buf);\n\n    rettv->vval.v_number = -1;\n    if (needle == NULL || haystack == NULL)\n\treturn;\t\t// type error; errmsg already given\n\n    haystack_len = (int)STRLEN(haystack);\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\t// Third argument: upper limit for index\n\tend_idx = (int)tv_get_number_chk(&argvars[2], NULL);\n\tif (end_idx < 0)\n\t    return;\t// can never find a match\n    }\n    else\n\tend_idx = haystack_len;\n\n    if (*needle == NUL)\n    {\n\t// Empty string matches past the end.\n\tlastmatch = haystack + end_idx;\n    }\n    else\n    {\n\tfor (rest = haystack; *rest != '\\0'; ++rest)\n\t{\n\t    rest = (char_u *)strstr((char *)rest, (char *)needle);\n\t    if (rest == NULL || rest > haystack + end_idx)\n\t\tbreak;\n\t    lastmatch = rest;\n\t}\n    }\n\n    if (lastmatch == NULL)\n\trettv->vval.v_number = -1;\n    else\n\trettv->vval.v_number = (varnumber_T)(lastmatch - haystack);\n}\n\n/*\n * \"strtrans()\" function\n */\n    void\nf_strtrans(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = transstr(tv_get_string(&argvars[0]));\n}\n\n/*\n * \"tolower(string)\" function\n */\n    void\nf_tolower(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = strlow_save(tv_get_string(&argvars[0]));\n}\n\n/*\n * \"toupper(string)\" function\n */\n    void\nf_toupper(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = strup_save(tv_get_string(&argvars[0]));\n}\n\n/*\n * \"tr(string, fromstr, tostr)\" function\n */\n    void\nf_tr(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*in_str;\n    char_u\t*fromstr;\n    char_u\t*tostr;\n    char_u\t*p;\n    int\t\tinlen;\n    int\t\tfromlen;\n    int\t\ttolen;\n    int\t\tidx;\n    char_u\t*cpstr;\n    int\t\tcplen;\n    int\t\tfirst = TRUE;\n    char_u\tbuf[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    garray_T\tga;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    in_str = tv_get_string(&argvars[0]);\n    fromstr = tv_get_string_buf_chk(&argvars[1], buf);\n    tostr = tv_get_string_buf_chk(&argvars[2], buf2);\n\n    // Default return value: empty string.\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (fromstr == NULL || tostr == NULL)\n\t    return;\t\t// type error; errmsg already given\n    ga_init2(&ga, sizeof(char), 80);\n\n    if (!has_mbyte)\n\t// not multi-byte: fromstr and tostr must be the same length\n\tif (STRLEN(fromstr) != STRLEN(tostr))\n\t{\nerror:\n\t    semsg(_(e_invalid_argument_str), fromstr);\n\t    ga_clear(&ga);\n\t    return;\n\t}\n\n    // fromstr and tostr have to contain the same number of chars\n    while (*in_str != NUL)\n    {\n\tif (has_mbyte)\n\t{\n\t    inlen = (*mb_ptr2len)(in_str);\n\t    cpstr = in_str;\n\t    cplen = inlen;\n\t    idx = 0;\n\t    for (p = fromstr; *p != NUL; p += fromlen)\n\t    {\n\t\tfromlen = (*mb_ptr2len)(p);\n\t\tif (fromlen == inlen && STRNCMP(in_str, p, inlen) == 0)\n\t\t{\n\t\t    for (p = tostr; *p != NUL; p += tolen)\n\t\t    {\n\t\t\ttolen = (*mb_ptr2len)(p);\n\t\t\tif (idx-- == 0)\n\t\t\t{\n\t\t\t    cplen = tolen;\n\t\t\t    cpstr = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (*p == NUL)\t// tostr is shorter than fromstr\n\t\t\tgoto error;\n\t\t    break;\n\t\t}\n\t\t++idx;\n\t    }\n\n\t    if (first && cpstr == in_str)\n\t    {\n\t\t// Check that fromstr and tostr have the same number of\n\t\t// (multi-byte) characters.  Done only once when a character\n\t\t// of in_str doesn't appear in fromstr.\n\t\tfirst = FALSE;\n\t\tfor (p = tostr; *p != NUL; p += tolen)\n\t\t{\n\t\t    tolen = (*mb_ptr2len)(p);\n\t\t    --idx;\n\t\t}\n\t\tif (idx != 0)\n\t\t    goto error;\n\t    }\n\n\t    (void)ga_grow(&ga, cplen);\n\t    mch_memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);\n\t    ga.ga_len += cplen;\n\n\t    in_str += inlen;\n\t}\n\telse\n\t{\n\t    // When not using multi-byte chars we can do it faster.\n\t    p = vim_strchr(fromstr, *in_str);\n\t    if (p != NULL)\n\t\tga_append(&ga, tostr[p - fromstr]);\n\t    else\n\t\tga_append(&ga, *in_str);\n\t    ++in_str;\n\t}\n    }\n\n    // add a terminating NUL\n    (void)ga_grow(&ga, 1);\n    ga_append(&ga, NUL);\n\n    rettv->vval.v_string = ga.ga_data;\n}\n\n/*\n * \"trim({expr})\" function\n */\n    void\nf_trim(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    char_u\t*head;\n    char_u\t*mask = NULL;\n    char_u\t*tail;\n    char_u\t*prev;\n    char_u\t*p;\n    int\t\tc1;\n    int\t\tdir = 0;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    head = tv_get_string_buf_chk(&argvars[0], buf1);\n    if (head == NULL)\n\treturn;\n\n    if (check_for_opt_string_arg(argvars, 1) == FAIL)\n\treturn;\n\n    if (argvars[1].v_type == VAR_STRING)\n    {\n\tmask = tv_get_string_buf_chk(&argvars[1], buf2);\n\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    int\terror = 0;\n\n\t    // leading or trailing characters to trim\n\t    dir = (int)tv_get_number_chk(&argvars[2], &error);\n\t    if (error)\n\t\treturn;\n\t    if (dir < 0 || dir > 2)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&argvars[2]));\n\t\treturn;\n\t    }\n\t}\n    }\n\n    if (dir == 0 || dir == 1)\n    {\n\t// Trim leading characters\n\twhile (*head != NUL)\n\t{\n\t    c1 = PTR2CHAR(head);\n\t    if (mask == NULL)\n\t    {\n\t\tif (c1 > ' ' && c1 != 0xa0)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tfor (p = mask; *p != NUL; MB_PTR_ADV(p))\n\t\t    if (c1 == PTR2CHAR(p))\n\t\t\tbreak;\n\t\tif (*p == NUL)\n\t\t    break;\n\t    }\n\t    MB_PTR_ADV(head);\n\t}\n    }\n\n    tail = head + STRLEN(head);\n    if (dir == 0 || dir == 2)\n    {\n\t// Trim trailing characters\n\tfor (; tail > head; tail = prev)\n\t{\n\t    prev = tail;\n\t    MB_PTR_BACK(head, prev);\n\t    c1 = PTR2CHAR(prev);\n\t    if (mask == NULL)\n\t    {\n\t\tif (c1 > ' ' && c1 != 0xa0)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tfor (p = mask; *p != NUL; MB_PTR_ADV(p))\n\t\t    if (c1 == PTR2CHAR(p))\n\t\t\tbreak;\n\t\tif (*p == NUL)\n\t\t    break;\n\t    }\n\t}\n    }\n    rettv->vval.v_string = vim_strnsave(head, tail - head);\n}\n\nstatic char *e_printf = N_(e_insufficient_arguments_for_printf);\n\n/*\n * Get number argument from \"idxp\" entry in \"tvs\".  First entry is 1.\n */\n    static varnumber_T\ntv_nr(typval_T *tvs, int *idxp)\n{\n    int\t\tidx = *idxp - 1;\n    varnumber_T\tn = 0;\n    int\t\terr = FALSE;\n\n    if (tvs[idx].v_type == VAR_UNKNOWN)\n\temsg(_(e_printf));\n    else\n    {\n\t++*idxp;\n\tn = tv_get_number_chk(&tvs[idx], &err);\n\tif (err)\n\t    n = 0;\n    }\n    return n;\n}\n\n/*\n * Get string argument from \"idxp\" entry in \"tvs\".  First entry is 1.\n * If \"tofree\" is NULL tv_get_string_chk() is used.  Some types (e.g. List)\n * are not converted to a string.\n * If \"tofree\" is not NULL echo_string() is used.  All types are converted to\n * a string with the same format as \":echo\".  The caller must free \"*tofree\".\n * Returns NULL for an error.\n */\n    static char *\ntv_str(typval_T *tvs, int *idxp, char_u **tofree)\n{\n    int\t\t    idx = *idxp - 1;\n    char\t    *s = NULL;\n    static char_u   numbuf[NUMBUFLEN];\n\n    if (tvs[idx].v_type == VAR_UNKNOWN)\n\temsg(_(e_printf));\n    else\n    {\n\t++*idxp;\n\tif (tofree != NULL)\n\t    s = (char *)echo_string(&tvs[idx], tofree, numbuf, get_copyID());\n\telse\n\t    s = (char *)tv_get_string_chk(&tvs[idx]);\n    }\n    return s;\n}\n\n/*\n * Get float argument from \"idxp\" entry in \"tvs\".  First entry is 1.\n */\n    static double\ntv_float(typval_T *tvs, int *idxp)\n{\n    int\t\tidx = *idxp - 1;\n    double\tf = 0;\n\n    if (tvs[idx].v_type == VAR_UNKNOWN)\n\temsg(_(e_printf));\n    else\n    {\n\t++*idxp;\n\tif (tvs[idx].v_type == VAR_FLOAT)\n\t    f = tvs[idx].vval.v_float;\n\telse if (tvs[idx].v_type == VAR_NUMBER)\n\t    f = (double)tvs[idx].vval.v_number;\n\telse\n\t    emsg(_(e_expected_float_argument_for_printf));\n    }\n    return f;\n}\n\n#endif\n\n/*\n * Return the representation of infinity for printf() function:\n * \"-inf\", \"inf\", \"+inf\", \" inf\", \"-INF\", \"INF\", \"+INF\" or \" INF\".\n */\n    static const char *\ninfinity_str(int positive,\n\t     char fmt_spec,\n\t     int force_sign,\n\t     int space_for_positive)\n{\n    static const char *table[] =\n    {\n\t\"-inf\", \"inf\", \"+inf\", \" inf\",\n\t\"-INF\", \"INF\", \"+INF\", \" INF\"\n    };\n    int idx = positive * (1 + force_sign + force_sign * space_for_positive);\n\n    if (ASCII_ISUPPER(fmt_spec))\n\tidx += 4;\n    return table[idx];\n}\n\n/*\n * This code was included to provide a portable vsnprintf() and snprintf().\n * Some systems may provide their own, but we always use this one for\n * consistency.\n *\n * This code is based on snprintf.c - a portable implementation of snprintf\n * by Mark Martinec <mark.martinec@ijs.si>, Version 2.2, 2000-10-06.\n * Included with permission.  It was heavily modified to fit in Vim.\n * The original code, including useful comments, can be found here:\n *\thttp://www.ijs.si/software/snprintf/\n *\n * This snprintf() only supports the following conversion specifiers:\n * s, c, d, u, o, x, X, p  (and synonyms: i, D, U, O - see below)\n * with flags: '-', '+', ' ', '0' and '#'.\n * An asterisk is supported for field width as well as precision.\n *\n * Limited support for floating point was added: 'f', 'F', 'e', 'E', 'g', 'G'.\n *\n * Length modifiers 'h' (short int) and 'l' (long int) and 'll' (long long int)\n * are supported.  NOTE: for 'll' the argument is varnumber_T or uvarnumber_T.\n *\n * The locale is not used, the string is used as a byte string.  This is only\n * relevant for double-byte encodings where the second byte may be '%'.\n *\n * It is permitted for \"str_m\" to be zero, and it is permitted to specify NULL\n * pointer for resulting string argument if \"str_m\" is zero (as per ISO C99).\n *\n * The return value is the number of characters which would be generated\n * for the given input, excluding the trailing NUL. If this value\n * is greater or equal to \"str_m\", not all characters from the result\n * have been stored in str, output bytes beyond the (\"str_m\"-1) -th character\n * are discarded. If \"str_m\" is greater than zero it is guaranteed\n * the resulting string will be NUL-terminated.\n */\n\n/*\n * When va_list is not supported we only define vim_snprintf().\n *\n * vim_vsnprintf_typval() can be invoked with either \"va_list\" or a list of\n * \"typval_T\".  When the latter is not used it must be NULL.\n */\n\n// When generating prototypes all of this is skipped, cproto doesn't\n// understand this.\n#ifndef PROTO\n\n// Like vim_vsnprintf() but append to the string.\n    int\nvim_snprintf_add(char *str, size_t str_m, const char *fmt, ...)\n{\n    va_list\tap;\n    int\t\tstr_l;\n    size_t\tlen = STRLEN(str);\n    size_t\tspace;\n\n    if (str_m <= len)\n\tspace = 0;\n    else\n\tspace = str_m - len;\n    va_start(ap, fmt);\n    str_l = vim_vsnprintf(str + len, space, fmt, ap);\n    va_end(ap);\n    return str_l;\n}\n\n    int\nvim_snprintf(char *str, size_t str_m, const char *fmt, ...)\n{\n    va_list\tap;\n    int\t\tstr_l;\n\n    va_start(ap, fmt);\n    str_l = vim_vsnprintf(str, str_m, fmt, ap);\n    va_end(ap);\n    return str_l;\n}\n\n    int\nvim_vsnprintf(\n    char\t*str,\n    size_t\tstr_m,\n    const char\t*fmt,\n    va_list\tap)\n{\n    return vim_vsnprintf_typval(str, str_m, fmt, ap, NULL);\n}\n\n    int\nvim_vsnprintf_typval(\n    char\t*str,\n    size_t\tstr_m,\n    const char\t*fmt,\n    va_list\tap,\n    typval_T\t*tvs)\n{\n    size_t\tstr_l = 0;\n    const char\t*p = fmt;\n    int\t\targ_idx = 1;\n\n    if (p == NULL)\n\tp = \"\";\n    while (*p != NUL)\n    {\n\tif (*p != '%')\n\t{\n\t    char    *q = strchr(p + 1, '%');\n\t    size_t  n = (q == NULL) ? STRLEN(p) : (size_t)(q - p);\n\n\t    // Copy up to the next '%' or NUL without any changes.\n\t    if (str_l < str_m)\n\t    {\n\t\tsize_t avail = str_m - str_l;\n\n\t\tmch_memmove(str + str_l, p, n > avail ? avail : n);\n\t    }\n\t    p += n;\n\t    str_l += n;\n\t}\n\telse\n\t{\n\t    size_t  min_field_width = 0, precision = 0;\n\t    int\t    zero_padding = 0, precision_specified = 0, justify_left = 0;\n\t    int\t    alternate_form = 0, force_sign = 0;\n\n\t    // If both the ' ' and '+' flags appear, the ' ' flag should be\n\t    // ignored.\n\t    int\t    space_for_positive = 1;\n\n\t    // allowed values: \\0, h, l, L\n\t    char    length_modifier = '\\0';\n\n\t    // temporary buffer for simple numeric->string conversion\n# define TMP_LEN 350\t// On my system 1e308 is the biggest number possible.\n\t\t\t// That sounds reasonable to use as the maximum\n\t\t\t// printable.\n\t    char    tmp[TMP_LEN];\n\n\t    // string address in case of string argument\n\t    const char  *str_arg = NULL;\n\n\t    // natural field width of arg without padding and sign\n\t    size_t  str_arg_l;\n\n\t    // unsigned char argument value - only defined for c conversion.\n\t    // N.B. standard explicitly states the char argument for the c\n\t    // conversion is unsigned\n\t    unsigned char uchar_arg;\n\n\t    // number of zeros to be inserted for numeric conversions as\n\t    // required by the precision or minimal field width\n\t    size_t  number_of_zeros_to_pad = 0;\n\n\t    // index into tmp where zero padding is to be inserted\n\t    size_t  zero_padding_insertion_ind = 0;\n\n\t    // current conversion specifier character\n\t    char    fmt_spec = '\\0';\n\n\t    // buffer for 's' and 'S' specs\n\t    char_u  *tofree = NULL;\n\n\n\t    p++;  // skip '%'\n\n\t    // parse flags\n\t    while (*p == '0' || *p == '-' || *p == '+' || *p == ' '\n\t\t\t\t\t\t   || *p == '#' || *p == '\\'')\n\t    {\n\t\tswitch (*p)\n\t\t{\n\t\t    case '0': zero_padding = 1; break;\n\t\t    case '-': justify_left = 1; break;\n\t\t    case '+': force_sign = 1; space_for_positive = 0; break;\n\t\t    case ' ': force_sign = 1;\n\t\t\t      // If both the ' ' and '+' flags appear, the ' '\n\t\t\t      // flag should be ignored\n\t\t\t      break;\n\t\t    case '#': alternate_form = 1; break;\n\t\t    case '\\'': break;\n\t\t}\n\t\tp++;\n\t    }\n\t    // If the '0' and '-' flags both appear, the '0' flag should be\n\t    // ignored.\n\n\t    // parse field width\n\t    if (*p == '*')\n\t    {\n\t\tint j;\n\n\t\tp++;\n\t\tj =\n# if defined(FEAT_EVAL)\n\t\t    tvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\tva_arg(ap, int);\n\t\tif (j >= 0)\n\t\t    min_field_width = j;\n\t\telse\n\t\t{\n\t\t    min_field_width = -j;\n\t\t    justify_left = 1;\n\t\t}\n\t    }\n\t    else if (VIM_ISDIGIT((int)(*p)))\n\t    {\n\t\t// size_t could be wider than unsigned int; make sure we treat\n\t\t// argument like common implementations do\n\t\tunsigned int uj = *p++ - '0';\n\n\t\twhile (VIM_ISDIGIT((int)(*p)))\n\t\t    uj = 10 * uj + (unsigned int)(*p++ - '0');\n\t\tmin_field_width = uj;\n\t    }\n\n\t    // parse precision\n\t    if (*p == '.')\n\t    {\n\t\tp++;\n\t\tprecision_specified = 1;\n\t\tif (*p == '*')\n\t\t{\n\t\t    int j;\n\n\t\t    j =\n# if defined(FEAT_EVAL)\n\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t    va_arg(ap, int);\n\t\t    p++;\n\t\t    if (j >= 0)\n\t\t\tprecision = j;\n\t\t    else\n\t\t    {\n\t\t\tprecision_specified = 0;\n\t\t\tprecision = 0;\n\t\t    }\n\t\t}\n\t\telse if (VIM_ISDIGIT((int)(*p)))\n\t\t{\n\t\t    // size_t could be wider than unsigned int; make sure we\n\t\t    // treat argument like common implementations do\n\t\t    unsigned int uj = *p++ - '0';\n\n\t\t    while (VIM_ISDIGIT((int)(*p)))\n\t\t\tuj = 10 * uj + (unsigned int)(*p++ - '0');\n\t\t    precision = uj;\n\t\t}\n\t    }\n\n\t    // parse 'h', 'l' and 'll' length modifiers\n\t    if (*p == 'h' || *p == 'l')\n\t    {\n\t\tlength_modifier = *p;\n\t\tp++;\n\t\tif (length_modifier == 'l' && *p == 'l')\n\t\t{\n\t\t    // double l = __int64 / varnumber_T\n\t\t    length_modifier = 'L';\n\t\t    p++;\n\t\t}\n\t    }\n\t    fmt_spec = *p;\n\n\t    // common synonyms:\n\t    switch (fmt_spec)\n\t    {\n\t\tcase 'i': fmt_spec = 'd'; break;\n\t\tcase 'D': fmt_spec = 'd'; length_modifier = 'l'; break;\n\t\tcase 'U': fmt_spec = 'u'; length_modifier = 'l'; break;\n\t\tcase 'O': fmt_spec = 'o'; length_modifier = 'l'; break;\n\t\tdefault: break;\n\t    }\n\n# if defined(FEAT_EVAL)\n\t    switch (fmt_spec)\n\t    {\n\t\tcase 'd': case 'u': case 'o': case 'x': case 'X':\n\t\t    if (tvs != NULL && length_modifier == '\\0')\n\t\t\tlength_modifier = 'L';\n\t    }\n# endif\n\n\t    // get parameter value, do initial processing\n\t    switch (fmt_spec)\n\t    {\n\t\t// '%' and 'c' behave similar to 's' regarding flags and field\n\t\t// widths\n\t    case '%':\n\t    case 'c':\n\t    case 's':\n\t    case 'S':\n\t\tstr_arg_l = 1;\n\t\tswitch (fmt_spec)\n\t\t{\n\t\tcase '%':\n\t\t    str_arg = p;\n\t\t    break;\n\n\t\tcase 'c':\n\t\t    {\n\t\t\tint j;\n\n\t\t\tj =\n# if defined(FEAT_EVAL)\n\t\t\t    tvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\tva_arg(ap, int);\n\t\t\t// standard demands unsigned char\n\t\t\tuchar_arg = (unsigned char)j;\n\t\t\tstr_arg = (char *)&uchar_arg;\n\t\t\tbreak;\n\t\t    }\n\n\t\tcase 's':\n\t\tcase 'S':\n\t\t    str_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\ttvs != NULL ? tv_str(tvs, &arg_idx, &tofree) :\n# endif\n\t\t\t\t    va_arg(ap, char *);\n\t\t    if (str_arg == NULL)\n\t\t    {\n\t\t\tstr_arg = \"[NULL]\";\n\t\t\tstr_arg_l = 6;\n\t\t    }\n\t\t    // make sure not to address string beyond the specified\n\t\t    // precision !!!\n\t\t    else if (!precision_specified)\n\t\t\tstr_arg_l = strlen(str_arg);\n\t\t    // truncate string if necessary as requested by precision\n\t\t    else if (precision == 0)\n\t\t\tstr_arg_l = 0;\n\t\t    else\n\t\t    {\n\t\t\t// Don't put the #if inside memchr(), it can be a\n\t\t\t// macro.\n\t\t\t// memchr on HP does not like n > 2^31  !!!\n\t\t\tchar *q = memchr(str_arg, '\\0',\n\t\t\t\t  precision <= (size_t)0x7fffffffL ? precision\n\t\t\t\t\t\t       : (size_t)0x7fffffffL);\n\n\t\t\tstr_arg_l = (q == NULL) ? precision\n\t\t\t\t\t\t      : (size_t)(q - str_arg);\n\t\t    }\n\t\t    if (fmt_spec == 'S')\n\t\t    {\n\t\t\tchar_u\t*p1;\n\t\t\tsize_t\ti;\n\t\t\tint\tcell;\n\n\t\t\tfor (i = 0, p1 = (char_u *)str_arg; *p1;\n\t\t\t\t\t\t\t  p1 += mb_ptr2len(p1))\n\t\t\t{\n\t\t\t    cell = mb_ptr2cells(p1);\n\t\t\t    if (precision_specified && i + cell > precision)\n\t\t\t\tbreak;\n\t\t\t    i += cell;\n\t\t\t}\n\n\t\t\tstr_arg_l = p1 - (char_u *)str_arg;\n\t\t\tif (min_field_width != 0)\n\t\t\t    min_field_width += str_arg_l - i;\n\t\t    }\n\t\t    break;\n\n\t\tdefault:\n\t\t    break;\n\t\t}\n\t\tbreak;\n\n\t    case 'd': case 'u':\n\t    case 'b': case 'B':\n\t    case 'o':\n\t    case 'x': case 'X':\n\t    case 'p':\n\t\t{\n\t\t    // NOTE: the u, b, o, x, X and p conversion specifiers\n\t\t    // imply the value is unsigned;  d implies a signed\n\t\t    // value\n\n\t\t    // 0 if numeric argument is zero (or if pointer is\n\t\t    // NULL for 'p'), +1 if greater than zero (or nonzero\n\t\t    // for unsigned arguments), -1 if negative (unsigned\n\t\t    // argument is never negative)\n\t\t    int arg_sign = 0;\n\n\t\t    // only set for length modifier h, or for no length\n\t\t    // modifiers\n\t\t    int int_arg = 0;\n\t\t    unsigned int uint_arg = 0;\n\n\t\t    // only set for length modifier l\n\t\t    long int long_arg = 0;\n\t\t    unsigned long int ulong_arg = 0;\n\n\t\t    // only set for length modifier ll\n\t\t    varnumber_T llong_arg = 0;\n\t\t    uvarnumber_T ullong_arg = 0;\n\n\t\t    // only set for b conversion\n\t\t    uvarnumber_T bin_arg = 0;\n\n\t\t    // pointer argument value -only defined for p\n\t\t    // conversion\n\t\t    void *ptr_arg = NULL;\n\n\t\t    if (fmt_spec == 'p')\n\t\t    {\n\t\t\tlength_modifier = '\\0';\n\t\t\tptr_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t tvs != NULL ? (void *)tv_str(tvs, &arg_idx,\n\t\t\t\t\t\t\t\t\tNULL) :\n# endif\n\t\t\t\t\tva_arg(ap, void *);\n\t\t\tif (ptr_arg != NULL)\n\t\t\t    arg_sign = 1;\n\t\t    }\n\t\t    else if (fmt_spec == 'b' || fmt_spec == 'B')\n\t\t    {\n\t\t\tbin_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t    tvs != NULL ?\n\t\t\t\t\t   (uvarnumber_T)tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\tva_arg(ap, uvarnumber_T);\n\t\t\tif (bin_arg != 0)\n\t\t\t    arg_sign = 1;\n\t\t    }\n\t\t    else if (fmt_spec == 'd')\n\t\t    {\n\t\t\t// signed\n\t\t\tswitch (length_modifier)\n\t\t\t{\n\t\t\tcase '\\0':\n\t\t\tcase 'h':\n\t\t\t    // char and short arguments are passed as int.\n\t\t\t    int_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t    va_arg(ap, int);\n\t\t\t    if (int_arg > 0)\n\t\t\t\targ_sign =  1;\n\t\t\t    else if (int_arg < 0)\n\t\t\t\targ_sign = -1;\n\t\t\t    break;\n\t\t\tcase 'l':\n\t\t\t    long_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t    va_arg(ap, long int);\n\t\t\t    if (long_arg > 0)\n\t\t\t\targ_sign =  1;\n\t\t\t    else if (long_arg < 0)\n\t\t\t\targ_sign = -1;\n\t\t\t    break;\n\t\t\tcase 'L':\n\t\t\t    llong_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t    va_arg(ap, varnumber_T);\n\t\t\t    if (llong_arg > 0)\n\t\t\t\targ_sign =  1;\n\t\t\t    else if (llong_arg < 0)\n\t\t\t\targ_sign = -1;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// unsigned\n\t\t\tswitch (length_modifier)\n\t\t\t{\n\t\t\t    case '\\0':\n\t\t\t    case 'h':\n\t\t\t\tuint_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\t    tvs != NULL ? (unsigned)\n\t\t\t\t\t\t\ttv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t\tva_arg(ap, unsigned int);\n\t\t\t\tif (uint_arg != 0)\n\t\t\t\t    arg_sign = 1;\n\t\t\t\tbreak;\n\t\t\t    case 'l':\n\t\t\t\tulong_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\t    tvs != NULL ? (unsigned long)\n\t\t\t\t\t\t\ttv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t\tva_arg(ap, unsigned long int);\n\t\t\t\tif (ulong_arg != 0)\n\t\t\t\t    arg_sign = 1;\n\t\t\t\tbreak;\n\t\t\t    case 'L':\n\t\t\t\tullong_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\t    tvs != NULL ? (uvarnumber_T)\n\t\t\t\t\t\t\ttv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t\tva_arg(ap, uvarnumber_T);\n\t\t\t\tif (ullong_arg != 0)\n\t\t\t\t    arg_sign = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\n\t\t    str_arg = tmp;\n\t\t    str_arg_l = 0;\n\n\t\t    // NOTE:\n\t\t    //   For d, i, u, o, x, and X conversions, if precision is\n\t\t    //   specified, the '0' flag should be ignored. This is so\n\t\t    //   with Solaris 2.6, Digital UNIX 4.0, HPUX 10, Linux,\n\t\t    //   FreeBSD, NetBSD; but not with Perl.\n\t\t    if (precision_specified)\n\t\t\tzero_padding = 0;\n\t\t    if (fmt_spec == 'd')\n\t\t    {\n\t\t\tif (force_sign && arg_sign >= 0)\n\t\t\t    tmp[str_arg_l++] = space_for_positive ? ' ' : '+';\n\t\t\t// leave negative numbers for sprintf to handle, to\n\t\t\t// avoid handling tricky cases like (short int)-32768\n\t\t    }\n\t\t    else if (alternate_form)\n\t\t    {\n\t\t\tif (arg_sign != 0\n\t\t\t\t     && (fmt_spec == 'b' || fmt_spec == 'B'\n\t\t\t\t      || fmt_spec == 'x' || fmt_spec == 'X') )\n\t\t\t{\n\t\t\t    tmp[str_arg_l++] = '0';\n\t\t\t    tmp[str_arg_l++] = fmt_spec;\n\t\t\t}\n\t\t\t// alternate form should have no effect for p\n\t\t\t// conversion, but ...\n\t\t    }\n\n\t\t    zero_padding_insertion_ind = str_arg_l;\n\t\t    if (!precision_specified)\n\t\t\tprecision = 1;   // default precision is 1\n\t\t    if (precision == 0 && arg_sign == 0)\n\t\t    {\n\t\t\t// When zero value is formatted with an explicit\n\t\t\t// precision 0, the resulting formatted string is\n\t\t\t// empty (d, i, u, b, B, o, x, X, p).\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tchar\tf[6];\n\t\t\tint\tf_l = 0;\n\n\t\t\t// construct a simple format string for sprintf\n\t\t\tf[f_l++] = '%';\n\t\t\tif (!length_modifier)\n\t\t\t    ;\n\t\t\telse if (length_modifier == 'L')\n\t\t\t{\n# ifdef MSWIN\n\t\t\t    f[f_l++] = 'I';\n\t\t\t    f[f_l++] = '6';\n\t\t\t    f[f_l++] = '4';\n# else\n\t\t\t    f[f_l++] = 'l';\n\t\t\t    f[f_l++] = 'l';\n# endif\n\t\t\t}\n\t\t\telse\n\t\t\t    f[f_l++] = length_modifier;\n\t\t\tf[f_l++] = fmt_spec;\n\t\t\tf[f_l++] = '\\0';\n\n\t\t\tif (fmt_spec == 'p')\n\t\t\t    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);\n\t\t\telse if (fmt_spec == 'b' || fmt_spec == 'B')\n\t\t\t{\n\t\t\t    char\t    b[8 * sizeof(uvarnumber_T)];\n\t\t\t    size_t\t    b_l = 0;\n\t\t\t    uvarnumber_T    bn = bin_arg;\n\n\t\t\t    do\n\t\t\t    {\n\t\t\t\tb[sizeof(b) - ++b_l] = '0' + (bn & 0x1);\n\t\t\t\tbn >>= 1;\n\t\t\t    }\n\t\t\t    while (bn != 0);\n\n\t\t\t    memcpy(tmp + str_arg_l, b + sizeof(b) - b_l, b_l);\n\t\t\t    str_arg_l += b_l;\n\t\t\t}\n\t\t\telse if (fmt_spec == 'd')\n\t\t\t{\n\t\t\t    // signed\n\t\t\t    switch (length_modifier)\n\t\t\t    {\n\t\t\t    case '\\0': str_arg_l += sprintf(\n\t\t\t\t\t\t tmp + str_arg_l, f,\n\t\t\t\t\t\t int_arg);\n\t\t\t\t       break;\n\t\t\t    case 'h': str_arg_l += sprintf(\n\t\t\t\t\t\t tmp + str_arg_l, f,\n\t\t\t\t\t\t (short)int_arg);\n\t\t\t\t      break;\n\t\t\t    case 'l': str_arg_l += sprintf(\n\t\t\t\t\t\ttmp + str_arg_l, f, long_arg);\n\t\t\t\t      break;\n\t\t\t    case 'L': str_arg_l += sprintf(\n\t\t\t\t\t       tmp + str_arg_l, f, llong_arg);\n\t\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // unsigned\n\t\t\t    switch (length_modifier)\n\t\t\t    {\n\t\t\t    case '\\0': str_arg_l += sprintf(\n\t\t\t\t\t\ttmp + str_arg_l, f,\n\t\t\t\t\t\tuint_arg);\n\t\t\t\t       break;\n\t\t\t    case 'h': str_arg_l += sprintf(\n\t\t\t\t\t\ttmp + str_arg_l, f,\n\t\t\t\t\t\t(unsigned short)uint_arg);\n\t\t\t\t      break;\n\t\t\t    case 'l': str_arg_l += sprintf(\n\t\t\t\t\t       tmp + str_arg_l, f, ulong_arg);\n\t\t\t\t      break;\n\t\t\t    case 'L': str_arg_l += sprintf(\n\t\t\t\t\t      tmp + str_arg_l, f, ullong_arg);\n\t\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// include the optional minus sign and possible\n\t\t\t// \"0x\" in the region before the zero padding\n\t\t\t// insertion point\n\t\t\tif (zero_padding_insertion_ind < str_arg_l\n\t\t\t\t&& tmp[zero_padding_insertion_ind] == '-')\n\t\t\t    zero_padding_insertion_ind++;\n\t\t\tif (zero_padding_insertion_ind + 1 < str_arg_l\n\t\t\t\t&& tmp[zero_padding_insertion_ind]   == '0'\n\t\t\t\t&& (tmp[zero_padding_insertion_ind + 1] == 'x'\n\t\t\t\t || tmp[zero_padding_insertion_ind + 1] == 'X'))\n\t\t\t    zero_padding_insertion_ind += 2;\n\t\t    }\n\n\t\t    {\n\t\t\tsize_t num_of_digits = str_arg_l\n\t\t\t\t\t\t - zero_padding_insertion_ind;\n\n\t\t\tif (alternate_form && fmt_spec == 'o'\n\t\t\t\t// unless zero is already the first\n\t\t\t\t// character\n\t\t\t\t&& !(zero_padding_insertion_ind < str_arg_l\n\t\t\t\t    && tmp[zero_padding_insertion_ind] == '0'))\n\t\t\t{\n\t\t\t    // assure leading zero for alternate-form\n\t\t\t    // octal numbers\n\t\t\t    if (!precision_specified\n\t\t\t\t\t     || precision < num_of_digits + 1)\n\t\t\t    {\n\t\t\t\t// precision is increased to force the\n\t\t\t\t// first character to be zero, except if a\n\t\t\t\t// zero value is formatted with an\n\t\t\t\t// explicit precision of zero\n\t\t\t\tprecision = num_of_digits + 1;\n\t\t\t    }\n\t\t\t}\n\t\t\t// zero padding to specified precision?\n\t\t\tif (num_of_digits < precision)\n\t\t\t    number_of_zeros_to_pad = precision - num_of_digits;\n\t\t    }\n\t\t    // zero padding to specified minimal field width?\n\t\t    if (!justify_left && zero_padding)\n\t\t    {\n\t\t\tint n = (int)(min_field_width - (str_arg_l\n\t\t\t\t\t\t    + number_of_zeros_to_pad));\n\t\t\tif (n > 0)\n\t\t\t    number_of_zeros_to_pad += n;\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t    case 'f':\n\t    case 'F':\n\t    case 'e':\n\t    case 'E':\n\t    case 'g':\n\t    case 'G':\n\t\t{\n\t\t    // Floating point.\n\t\t    double\tf;\n\t\t    double\tabs_f;\n\t\t    char\tformat[40];\n\t\t    int\t\tl;\n\t\t    int\t\tremove_trailing_zeroes = FALSE;\n\n\t\t    f =\n# if defined(FEAT_EVAL)\n\t\t\ttvs != NULL ? tv_float(tvs, &arg_idx) :\n# endif\n\t\t\t    va_arg(ap, double);\n\t\t    abs_f = f < 0 ? -f : f;\n\n\t\t    if (fmt_spec == 'g' || fmt_spec == 'G')\n\t\t    {\n\t\t\t// Would be nice to use %g directly, but it prints\n\t\t\t// \"1.0\" as \"1\", we don't want that.\n\t\t\tif ((abs_f >= 0.001 && abs_f < 10000000.0)\n\t\t\t\t\t\t\t      || abs_f == 0.0)\n\t\t\t    fmt_spec = ASCII_ISUPPER(fmt_spec) ? 'F' : 'f';\n\t\t\telse\n\t\t\t    fmt_spec = fmt_spec == 'g' ? 'e' : 'E';\n\t\t\tremove_trailing_zeroes = TRUE;\n\t\t    }\n\n\t\t    if ((fmt_spec == 'f' || fmt_spec == 'F') &&\n# ifdef VAX\n\t\t\t    abs_f > 1.0e38\n# else\n\t\t\t    abs_f > 1.0e307\n# endif\n\t\t\t    )\n\t\t    {\n\t\t\t// Avoid a buffer overflow\n\t\t\tSTRCPY(tmp, infinity_str(f > 0.0, fmt_spec,\n\t\t\t\t\t      force_sign, space_for_positive));\n\t\t\tstr_arg_l = STRLEN(tmp);\n\t\t\tzero_padding = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (isnan(f))\n\t\t\t{\n\t\t\t    // Not a number: nan or NAN\n\t\t\t    STRCPY(tmp, ASCII_ISUPPER(fmt_spec) ? \"NAN\"\n\t\t\t\t\t\t\t\t      : \"nan\");\n\t\t\t    str_arg_l = 3;\n\t\t\t    zero_padding = 0;\n\t\t\t}\n\t\t\telse if (isinf(f))\n\t\t\t{\n\t\t\t    STRCPY(tmp, infinity_str(f > 0.0, fmt_spec,\n\t\t\t\t\t      force_sign, space_for_positive));\n\t\t\t    str_arg_l = STRLEN(tmp);\n\t\t\t    zero_padding = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Regular float number\n\t\t\t    format[0] = '%';\n\t\t\t    l = 1;\n\t\t\t    if (force_sign)\n\t\t\t\tformat[l++] = space_for_positive ? ' ' : '+';\n\t\t\t    if (precision_specified)\n\t\t\t    {\n\t\t\t\tsize_t max_prec = TMP_LEN - 10;\n\n\t\t\t\t// Make sure we don't get more digits than we\n\t\t\t\t// have room for.\n\t\t\t\tif ((fmt_spec == 'f' || fmt_spec == 'F')\n\t\t\t\t\t\t\t\t&& abs_f > 1.0)\n\t\t\t\t    max_prec -= (size_t)log10(abs_f);\n\t\t\t\tif (precision > max_prec)\n\t\t\t\t    precision = max_prec;\n\t\t\t\tl += sprintf(format + l, \".%d\", (int)precision);\n\t\t\t    }\n\t\t\t    format[l] = fmt_spec == 'F' ? 'f' : fmt_spec;\n\t\t\t    format[l + 1] = NUL;\n\n\t\t\t    str_arg_l = sprintf(tmp, format, f);\n\t\t\t}\n\n\t\t\tif (remove_trailing_zeroes)\n\t\t\t{\n\t\t\t    int i;\n\t\t\t    char *tp;\n\n\t\t\t    // Using %g or %G: remove superfluous zeroes.\n\t\t\t    if (fmt_spec == 'f' || fmt_spec == 'F')\n\t\t\t\ttp = tmp + str_arg_l - 1;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\ttp = (char *)vim_strchr((char_u *)tmp,\n\t\t\t\t\t\t fmt_spec == 'e' ? 'e' : 'E');\n\t\t\t\tif (tp != NULL)\n\t\t\t\t{\n\t\t\t\t    // Remove superfluous '+' and leading\n\t\t\t\t    // zeroes from the exponent.\n\t\t\t\t    if (tp[1] == '+')\n\t\t\t\t    {\n\t\t\t\t\t// Change \"1.0e+07\" to \"1.0e07\"\n\t\t\t\t\tSTRMOVE(tp + 1, tp + 2);\n\t\t\t\t\t--str_arg_l;\n\t\t\t\t    }\n\t\t\t\t    i = (tp[1] == '-') ? 2 : 1;\n\t\t\t\t    while (tp[i] == '0')\n\t\t\t\t    {\n\t\t\t\t\t// Change \"1.0e07\" to \"1.0e7\"\n\t\t\t\t\tSTRMOVE(tp + i, tp + i + 1);\n\t\t\t\t\t--str_arg_l;\n\t\t\t\t    }\n\t\t\t\t    --tp;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (tp != NULL && !precision_specified)\n\t\t\t\t// Remove trailing zeroes, but keep the one\n\t\t\t\t// just after a dot.\n\t\t\t\twhile (tp > tmp + 2 && *tp == '0'\n\t\t\t\t\t\t\t     && tp[-1] != '.')\n\t\t\t\t{\n\t\t\t\t    STRMOVE(tp, tp + 1);\n\t\t\t\t    --tp;\n\t\t\t\t    --str_arg_l;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char *tp;\n\n\t\t\t    // Be consistent: some printf(\"%e\") use 1.0e+12\n\t\t\t    // and some 1.0e+012.  Remove one zero in the last\n\t\t\t    // case.\n\t\t\t    tp = (char *)vim_strchr((char_u *)tmp,\n\t\t\t\t\t\t fmt_spec == 'e' ? 'e' : 'E');\n\t\t\t    if (tp != NULL && (tp[1] == '+' || tp[1] == '-')\n\t\t\t\t\t  && tp[2] == '0'\n\t\t\t\t\t  && vim_isdigit(tp[3])\n\t\t\t\t\t  && vim_isdigit(tp[4]))\n\t\t\t    {\n\t\t\t\tSTRMOVE(tp + 2, tp + 3);\n\t\t\t\t--str_arg_l;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (zero_padding && min_field_width > str_arg_l\n\t\t\t\t\t      && (tmp[0] == '-' || force_sign))\n\t\t    {\n\t\t\t// padding 0's should be inserted after the sign\n\t\t\tnumber_of_zeros_to_pad = min_field_width - str_arg_l;\n\t\t\tzero_padding_insertion_ind = 1;\n\t\t    }\n\t\t    str_arg = tmp;\n\t\t    break;\n\t\t}\n\n\t    default:\n\t\t// unrecognized conversion specifier, keep format string\n\t\t// as-is\n\t\tzero_padding = 0;  // turn zero padding off for non-numeric\n\t\t\t\t   // conversion\n\t\tjustify_left = 1;\n\t\tmin_field_width = 0;\t\t    // reset flags\n\n\t\t// discard the unrecognized conversion, just keep *\n\t\t// the unrecognized conversion character\n\t\tstr_arg = p;\n\t\tstr_arg_l = 0;\n\t\tif (*p != NUL)\n\t\t    str_arg_l++;  // include invalid conversion specifier\n\t\t\t\t  // unchanged if not at end-of-string\n\t\tbreak;\n\t    }\n\n\t    if (*p != NUL)\n\t\tp++;     // step over the just processed conversion specifier\n\n\t    // insert padding to the left as requested by min_field_width;\n\t    // this does not include the zero padding in case of numerical\n\t    // conversions\n\t    if (!justify_left)\n\t    {\n\t\t// left padding with blank or zero\n\t\tint pn = (int)(min_field_width - (str_arg_l + number_of_zeros_to_pad));\n\n\t\tif (pn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tvim_memset(str + str_l, zero_padding ? '0' : ' ',\n\t\t\t\t\t     (size_t)pn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)pn);\n\t\t    }\n\t\t    str_l += pn;\n\t\t}\n\t    }\n\n\t    // zero padding as requested by the precision or by the minimal\n\t    // field width for numeric conversions required?\n\t    if (number_of_zeros_to_pad == 0)\n\t    {\n\t\t// will not copy first part of numeric right now, *\n\t\t// force it to be copied later in its entirety\n\t\tzero_padding_insertion_ind = 0;\n\t    }\n\t    else\n\t    {\n\t\t// insert first part of numerics (sign or '0x') before zero\n\t\t// padding\n\t\tint zn = (int)zero_padding_insertion_ind;\n\n\t\tif (zn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tmch_memmove(str + str_l, str_arg,\n\t\t\t\t\t     (size_t)zn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)zn);\n\t\t    }\n\t\t    str_l += zn;\n\t\t}\n\n\t\t// insert zero padding as requested by the precision or min\n\t\t// field width\n\t\tzn = (int)number_of_zeros_to_pad;\n\t\tif (zn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tvim_memset(str + str_l, '0',\n\t\t\t\t\t     (size_t)zn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)zn);\n\t\t    }\n\t\t    str_l += zn;\n\t\t}\n\t    }\n\n\t    // insert formatted string\n\t    // (or as-is conversion specifier for unknown conversions)\n\t    {\n\t\tint sn = (int)(str_arg_l - zero_padding_insertion_ind);\n\n\t\tif (sn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tmch_memmove(str + str_l,\n\t\t\t\tstr_arg + zero_padding_insertion_ind,\n\t\t\t\t(size_t)sn > avail ? avail : (size_t)sn);\n\t\t    }\n\t\t    str_l += sn;\n\t\t}\n\t    }\n\n\t    // insert right padding\n\t    if (justify_left)\n\t    {\n\t\t// right blank padding to the field width\n\t\tint pn = (int)(min_field_width\n\t\t\t\t      - (str_arg_l + number_of_zeros_to_pad));\n\n\t\tif (pn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tvim_memset(str + str_l, ' ',\n\t\t\t\t\t     (size_t)pn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)pn);\n\t\t    }\n\t\t    str_l += pn;\n\t\t}\n\t    }\n\t    vim_free(tofree);\n\t}\n    }\n\n    if (str_m > 0)\n    {\n\t// make sure the string is nul-terminated even at the expense of\n\t// overwriting the last character (shouldn't happen, but just in case)\n\t//\n\tstr[str_l <= str_m - 1 ? str_l : str_m - 1] = '\\0';\n    }\n\n    if (tvs != NULL && tvs[arg_idx - 1].v_type != VAR_UNKNOWN)\n\temsg(_(e_too_many_arguments_to_printf));\n\n    // Return the number of characters formatted (excluding trailing nul\n    // character), that is, the number of characters that would have been\n    // written to the buffer if it were large enough.\n    return (int)str_l;\n}\n\n#endif // PROTO\n", "\" Tests for editing the command line.\n\nsource check.vim\nsource screendump.vim\nsource view_util.vim\nsource shared.vim\nimport './vim9.vim' as v9\n\nfunc SetUp()\n  func SaveLastScreenLine()\n    let g:Sline = Screenline(&lines - 1)\n    return ''\n  endfunc\n  cnoremap <expr> <F4> SaveLastScreenLine()\nendfunc\n\nfunc TearDown()\n  delfunc SaveLastScreenLine\n  cunmap <F4>\nendfunc\n\nfunc Test_complete_tab()\n  call writefile(['testfile'], 'Xtestfile', 'D')\n  call feedkeys(\":e Xtest\\t\\r\", \"tx\")\n  call assert_equal('testfile', getline(1))\n\n  \" Pressing <Tab> after '%' completes the current file, also on MS-Windows\n  call feedkeys(\":e %\\t\\r\", \"tx\")\n  call assert_equal('e Xtestfile', @:)\nendfunc\n\nfunc Test_complete_list()\n  \" We can't see the output, but at least we check the code runs properly.\n  call feedkeys(\":e test\\<C-D>\\r\", \"tx\")\n  call assert_equal('test', expand('%:t'))\n\n  \" If a command doesn't support completion, then CTRL-D should be literally\n  \" used.\n  call feedkeys(\":chistory \\<C-D>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"chistory \\<C-D>\", @:)\n\n  \" Test for displaying the tail of the completion matches\n  set wildmode=longest,full\n  call mkdir('Xtest', 'R')\n  call writefile([], 'Xtest/a.c')\n  call writefile([], 'Xtest/a.h')\n  let g:Sline = ''\n  call feedkeys(\":e Xtest/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('a.c  a.h', g:Sline)\n  call assert_equal('\"e Xtest/', @:)\n  if has('win32')\n    \" Test for 'completeslash'\n    set completeslash=backslash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\', @:)\n    call feedkeys(\":e Xtest/\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\a.', @:)\n    set completeslash=slash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/', @:)\n    call feedkeys(\":e Xtest\\\\\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/a.', @:)\n    set completeslash&\n  endif\n\n  \" Test for displaying the tail with wildcards\n  let g:Sline = ''\n  call feedkeys(\":e Xtes?/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes?/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes*/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes*/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes[/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(':e Xtes[/', g:Sline)\n  call assert_equal('\"e Xtes[/', @:)\n\n  set wildmode&\nendfunc\n\nfunc Test_complete_wildmenu()\n  call mkdir('Xwilddir1/Xdir2', 'pR')\n  call writefile(['testfile1'], 'Xwilddir1/Xtestfile1')\n  call writefile(['testfile2'], 'Xwilddir1/Xtestfile2')\n  call writefile(['testfile3'], 'Xwilddir1/Xdir2/Xtestfile3')\n  call writefile(['testfile3'], 'Xwilddir1/Xdir2/Xtestfile4')\n  set wildmenu\n\n  \" Pressing <Tab> completes, and moves to next files when pressing again.\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n\n  \" <S-Tab> is like <Tab> but begin with the last match and then go to\n  \" previous.\n  call feedkeys(\":e Xwilddir1/Xtest\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xwilddir1/Xtest\\<S-Tab>\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Left>/<Right> to move to previous/next file.\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Right>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Right>\\<Right>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Up>/<Down> to go up/down directories.\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Down>\\<CR>\", 'tx')\n  call assert_equal('testfile3', getline(1))\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<Down>\\<Up>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" this fails in some Unix GUIs, not sure why\n  if !has('unix') || !has('gui_running')\n    \" <C-J>/<C-K> mappings to go up/down directories when 'wildcharm' is\n    \" different than 'wildchar'.\n    set wildcharm=<C-Z>\n    cnoremap <C-J> <Down><C-Z>\n    cnoremap <C-K> <Up><C-Z>\n    call feedkeys(\":e Xwilddir1/\\<Tab>\\<C-J>\\<CR>\", 'tx')\n    call assert_equal('testfile3', getline(1))\n    call feedkeys(\":e Xwilddir1/\\<Tab>\\<C-J>\\<C-K>\\<CR>\", 'tx')\n    call assert_equal('testfile1', getline(1))\n    set wildcharm=0\n    cunmap <C-J>\n    cunmap <C-K>\n  endif\n\n  \" Test for canceling the wild menu by adding a character\n  redrawstatus\n  call feedkeys(\":e Xwilddir1/\\<Tab>x\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xwilddir1/Xdir2/x', @:)\n\n  \" Completion using a relative path\n  cd Xwilddir1/Xdir2\n  call feedkeys(\":e ../\\<Tab>\\<Right>\\<Down>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xtestfile3 Xtestfile4', @:)\n  cd -\n\n  \" test for wildmenumode()\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":cd Xwilddir\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cd Xwilddir1/0', @:)\n  call feedkeys(\":e Xwilddir1/\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xwilddir1/Xdir2/1', @:)\n  cunmap <F2>\n\n  \" Test for canceling the wild menu by pressing <PageDown> or <PageUp>.\n  \" After this pressing <Left> or <Right> should not change the selection.\n  call feedkeys(\":sign \\<Tab>\\<PageDown>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign define', @:)\n  call histadd('cmd', 'TestWildMenu')\n  call feedkeys(\":sign \\<Tab>\\<PageUp>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"TestWildMenu', @:)\n\n  \" cleanup\n  %bwipe\n  set nowildmenu\nendfunc\n\nfunc Test_wildmenu_screendump()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    set wildmenu hlsearch\n  [SCRIPT]\n  call writefile(lines, 'XTest_wildmenu', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_wildmenu', {'rows': 8})\n  call term_sendkeys(buf, \":vim\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_1', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_2', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_3', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_4', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_redraw_in_autocmd()\n  CheckScreendump\n\n  let lines =<< trim END\n      set cmdheight=2\n      autocmd CmdlineChanged * redraw\n  END\n  call writefile(lines, 'XTest_redraw', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_redraw', {'rows': 8})\n  call term_sendkeys(buf, \":for i in range(3)\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_1', {})\n\n  call term_sendkeys(buf, \"let i =\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_redrawstatus_in_autocmd()\n  CheckScreendump\n\n  let lines =<< trim END\n      set laststatus=2\n      set statusline=%=:%{getcmdline()}\n      autocmd CmdlineChanged * redrawstatus\n  END\n  call writefile(lines, 'XTest_redrawstatus', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_redrawstatus', {'rows': 8})\n  \" :redrawstatus is postponed if messages have scrolled\n  call term_sendkeys(buf, \":echo \\\"one\\\\ntwo\\\\nthree\\\\nfour\\\"\\<CR>\")\n  call term_sendkeys(buf, \":foobar\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_1', {})\n  \" it is not postponed if messages have not scrolled\n  call term_sendkeys(buf, \"\\<Esc>:for in in range(3)\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_2', {})\n  \" with cmdheight=1 messages have scrolled when typing :endfor\n  call term_sendkeys(buf, \"\\<CR>:endfor\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_3', {})\n  call term_sendkeys(buf, \"\\<CR>:set cmdheight=2\\<CR>\")\n  \" with cmdheight=2 messages haven't scrolled when typing :for or :endfor\n  call term_sendkeys(buf, \":for in in range(3)\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_4', {})\n  call term_sendkeys(buf, \"\\<CR>:endfor\")\n  call VerifyScreenDump(buf, 'Test_redrawstatus_in_autocmd_5', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_changing_cmdheight()\n  CheckScreendump\n\n  let lines =<< trim END\n      set cmdheight=1 laststatus=2\n      func EchoTwo()\n        set laststatus=2\n        set cmdheight=5\n        echo 'foo'\n        echo 'bar'\n        set cmdheight=1\n      endfunc\n  END\n  call writefile(lines, 'XTest_cmdheight', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_cmdheight', {'rows': 8})\n  call term_sendkeys(buf, \":resize -3\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_1', {})\n\n  \" using the space available doesn't change the status line\n  call term_sendkeys(buf, \":set cmdheight+=3\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_2', {})\n\n  \" using more space moves the status line up\n  call term_sendkeys(buf, \":set cmdheight+=1\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_3', {})\n\n  \" reducing cmdheight moves status line down\n  call term_sendkeys(buf, \":set cmdheight-=2\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_4', {})\n\n  \" reducing window size and then setting cmdheight \n  call term_sendkeys(buf, \":resize -1\\<CR>\")\n  call term_sendkeys(buf, \":set cmdheight=1\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_5', {})\n\n  \" setting 'cmdheight' works after outputting two messages\n  call term_sendkeys(buf, \":call EchoTwo()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_changing_cmdheight_6', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_cmdheight_tabline()\n  CheckScreendump\n\n  let buf = RunVimInTerminal('-c \"set ls=2\" -c \"set stal=2\" -c \"set cmdheight=1\"', {'rows': 6})\n  call VerifyScreenDump(buf, 'Test_cmdheight_tabline_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_map_completion()\n  call feedkeys(\":map <unique> <si\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <unique> <silent>', getreg(':'))\n  call feedkeys(\":map <script> <un\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <script> <unique>', getreg(':'))\n  call feedkeys(\":map <expr> <sc\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <expr> <script>', getreg(':'))\n  call feedkeys(\":map <buffer> <e\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <buffer> <expr>', getreg(':'))\n  call feedkeys(\":map <nowait> <b\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <nowait> <buffer>', getreg(':'))\n  call feedkeys(\":map <special> <no\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <special> <nowait>', getreg(':'))\n  call feedkeys(\":map <silent> <sp\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <silent> <special>', getreg(':'))\n\n  map <Middle>x middle\n\n  map ,f commaf\n  map ,g commaf\n  map <Left> left\n  map <A-Left>x shiftleft\n  call feedkeys(\":map ,\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,f', getreg(':'))\n  call feedkeys(\":map ,\\<Tab>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,g', getreg(':'))\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <A-Left>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <A-Left>\\<Tab>\", getreg(':'))\n  unmap ,f\n  unmap ,g\n  unmap <Left>\n  unmap <A-Left>x\n\n  set cpo-=< cpo-=B cpo-=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <M\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <M\\<Tab>\", getreg(':'))\n  unmap <Left>\n\n  set cpo+=<\n  map <Left> left\n  exe \"set t_k6=\\<Esc>[17~\"\n  call feedkeys(\":map \\<Esc>[17~x f6x\\<CR>\", 'xt')\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  if !has('gui_running')\n    call feedkeys(\":map \\<Esc>[17~\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"map <F6>x\", getreg(':'))\n  endif\n  unmap <Left>\n  call feedkeys(\":unmap \\<Esc>[17~x\\<CR>\", 'xt')\n  set cpo-=<\n\n  set cpo+=B\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=B\n\n  set cpo+=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=k\n\n  call assert_fails('call feedkeys(\":map \\\\\\\\%(\\<Tab>\\<Home>\\\"\\<CR>\", \"xt\")', 'E53:')\n\n  unmap <Middle>x\n  set cpo&vim\nendfunc\n\nfunc Test_match_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":match \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match Aardig', @:)\n  call feedkeys(\":match \\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match none', @:)\n  call feedkeys(\":match | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match | chistory', @:)\nendfunc\n\nfunc Test_highlight_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":hi \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi Aardig', getreg(':'))\n  call feedkeys(\":hi default \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default Aardig', getreg(':'))\n  call feedkeys(\":hi clear Aa\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig', getreg(':'))\n  call feedkeys(\":hi li\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi link', getreg(':'))\n  call feedkeys(\":hi d\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default', getreg(':'))\n  call feedkeys(\":hi c\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear', getreg(':'))\n  call feedkeys(\":hi clear Aardig Aard\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig Aardig', getreg(':'))\n  call feedkeys(\":hi Aardig \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Aardig \\t\", getreg(':'))\n\n  \" A cleared group does not show up in completions.\n  hi Anders ctermfg=green\n  call assert_equal(['Aardig', 'Anders'], getcompletion('A', 'highlight'))\n  hi clear Aardig\n  call assert_equal(['Anders'], getcompletion('A', 'highlight'))\n  hi clear Anders\n  call assert_equal([], getcompletion('A', 'highlight'))\nendfunc\n\n\" Test for command-line expansion of \"hi Ni \" (easter egg)\nfunc Test_highlight_easter_egg()\n  call test_override('ui_delay', 1)\n  call feedkeys(\":hi Ni \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Ni \\<Tab>\", @:)\n  call test_override('ALL', 0)\nendfunc\n\nfunc Test_getcompletion()\n  let groupcount = len(getcompletion('', 'event'))\n  call assert_true(groupcount > 0)\n  let matchcount = len('File'->getcompletion('event'))\n  call assert_true(matchcount > 0)\n  call assert_true(groupcount > matchcount)\n\n  if has('menu')\n    source $VIMRUNTIME/menu.vim\n    let matchcount = len(getcompletion('', 'menu'))\n    call assert_true(matchcount > 0)\n    call assert_equal(['File.'], getcompletion('File', 'menu'))\n    call assert_true(matchcount > 0)\n    let matchcount = len(getcompletion('File.', 'menu'))\n    call assert_true(matchcount > 0)\n  endif\n\n  let l = getcompletion('v:n', 'var')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('v:notexists', 'var')\n  call assert_equal([], l)\n\n  args a.c b.c\n  let l = getcompletion('', 'arglist')\n  call assert_equal(['a.c', 'b.c'], l)\n  let l = getcompletion('a.', 'buffer')\n  call assert_equal(['a.c'], l)\n  %argdelete\n\n  let l = getcompletion('', 'augroup')\n  call assert_true(index(l, 'END') >= 0)\n  let l = getcompletion('blahblah', 'augroup')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'behave')\n  call assert_true(index(l, 'mswin') >= 0)\n  let l = getcompletion('not', 'behave')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'color')\n  call assert_true(index(l, 'default') >= 0)\n  let l = getcompletion('dirty', 'color')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'command')\n  call assert_true(index(l, 'sleep') >= 0)\n  let l = getcompletion('awake', 'command')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'dir')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('NoMatch', 'dir')\n  call assert_equal([], l)\n\n  if glob('~/*') !=# ''\n    let l = getcompletion('~/', 'dir')\n    call assert_true(l[0][0] ==# '~')\n  endif\n\n  let l = getcompletion('exe', 'expression')\n  call assert_true(index(l, 'executable(') >= 0)\n  let l = getcompletion('kill', 'expression')\n  call assert_equal([], l)\n\n  let l = getcompletion('tag', 'function')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('paint', 'function')\n  call assert_equal([], l)\n\n  let Flambda = {-> 'hello'}\n  let l = getcompletion('', 'function')\n  let l = filter(l, {i, v -> v =~ 'lambda'})\n  call assert_equal([], l)\n\n  let l = getcompletion('run', 'file')\n  call assert_true(index(l, 'runtest.vim') >= 0)\n  let l = getcompletion('walk', 'file')\n  call assert_equal([], l)\n  set wildignore=*.vim\n  let l = getcompletion('run', 'file', 1)\n  call assert_true(index(l, 'runtest.vim') < 0)\n  set wildignore&\n  \" Directory name with space character\n  call mkdir('Xdir with space', 'D')\n  call assert_equal(['Xdir with space/'], getcompletion('Xdir\\ w', 'shellcmd'))\n  call assert_equal(['./Xdir with space/'], getcompletion('./Xdir', 'shellcmd'))\n\n  let l = getcompletion('ha', 'filetype')\n  call assert_true(index(l, 'hamster') >= 0)\n  let l = getcompletion('horse', 'filetype')\n  call assert_equal([], l)\n\n  let l = getcompletion('z', 'syntax')\n  call assert_true(index(l, 'zimbu') >= 0)\n  let l = getcompletion('emacs', 'syntax')\n  call assert_equal([], l)\n\n  let l = getcompletion('jikes', 'compiler')\n  call assert_true(index(l, 'jikes') >= 0)\n  let l = getcompletion('break', 'compiler')\n  call assert_equal([], l)\n\n  let l = getcompletion('last', 'help')\n  call assert_true(index(l, ':tablast') >= 0)\n  let l = getcompletion('giveup', 'help')\n  call assert_equal([], l)\n\n  let l = getcompletion('time', 'option')\n  call assert_true(index(l, 'timeoutlen') >= 0)\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n\n  let l = getcompletion('er', 'highlight')\n  call assert_true(index(l, 'ErrorMsg') >= 0)\n  let l = getcompletion('dark', 'highlight')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'messages')\n  call assert_true(index(l, 'clear') >= 0)\n  let l = getcompletion('not', 'messages')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'mapclear')\n  call assert_true(index(l, '<buffer>') >= 0)\n  let l = getcompletion('not', 'mapclear')\n  call assert_equal([], l)\n\n  let l = getcompletion('.', 'shellcmd')\n  call assert_equal(['./', '../'], filter(l, 'v:val =~ \"\\\\./\"'))\n  call assert_equal(-1, match(l[2:], '^\\.\\.\\?/$'))\n  let root = has('win32') ? 'C:\\\\' : '/'\n  let l = getcompletion(root, 'shellcmd')\n  let expected = map(filter(glob(root . '*', 0, 1),\n        \\ 'isdirectory(v:val) || executable(v:val)'), 'isdirectory(v:val) ? v:val . ''/'' : v:val')\n  call assert_equal(expected, l)\n\n  if has('cscope')\n    let l = getcompletion('', 'cscope')\n    let cmds = ['add', 'find', 'help', 'kill', 'reset', 'show']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":cscope find \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'cscope')\n    call assert_equal(cmds, l)\n    let keys = ['a', 'c', 'd', 'e', 'f', 'g', 'i', 's', 't']\n    let l = getcompletion('find ', 'cscope')\n    call assert_equal(keys, l)\n  endif\n\n  if has('signs')\n    sign define Testing linehl=Comment\n    let l = getcompletion('', 'sign')\n    let cmds = ['define', 'jump', 'list', 'place', 'undefine', 'unplace']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":sign list \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'sign')\n    call assert_equal(cmds, l)\n    let l = getcompletion('list ', 'sign')\n    call assert_equal(['Testing'], l)\n    let l = getcompletion('de*', 'sign')\n    call assert_equal(['define'], l)\n    let l = getcompletion('p?', 'sign')\n    call assert_equal(['place'], l)\n    let l = getcompletion('j.', 'sign')\n    call assert_equal(['jump'], l)\n  endif\n\n  \" Command line completion tests\n  let l = getcompletion('cd ', 'cmdline')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('cd NoMatch', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('let v:n', 'cmdline')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('let v:notexists', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('call tag', 'cmdline')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('call paint', 'cmdline')\n  call assert_equal([], l)\n\n  func T(a, c, p)\n    let g:cmdline_compl_params = [a:a, a:c, a:p]\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n  let l = getcompletion('MyCmd ', 'cmdline')\n  call assert_equal(['oneA', 'oneB', 'oneC'], l)\n  call assert_equal(['', 'MyCmd ', 6], g:cmdline_compl_params)\n\n  delcommand MyCmd\n  delfunc T\n  unlet g:cmdline_compl_params\n\n  \" For others test if the name is recognized.\n  let names = ['buffer', 'environment', 'file_in_path', 'mapping', 'tag', 'tag_listfiles', 'user']\n  if has('cmdline_hist')\n    call add(names, 'history')\n  endif\n  if has('gettext')\n    call add(names, 'locale')\n  endif\n  if has('profile')\n    call add(names, 'syntime')\n  endif\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\", \"word\\tfile\\tcmd\"], 'Xtags', 'D')\n\n  for name in names\n    let matchcount = len(getcompletion('', name))\n    call assert_true(matchcount >= 0, 'No matches for ' . name)\n  endfor\n\n  set tags&\n\n  edit a~b\n  enew\n  call assert_equal(['a~b'], getcompletion('a~', 'buffer'))\n  bw a~b\n\n  if has('unix')\n    edit Xtest\\\n    enew\n    call assert_equal(['Xtest\\'], getcompletion('Xtest\\', 'buffer'))\n    bw Xtest\\\n  endif\n\n  call assert_fails(\"call getcompletion('\\\\\\\\@!\\\\\\\\@=', 'buffer')\", 'E871:')\n  call assert_fails('call getcompletion(\"\", \"burp\")', 'E475:')\n  call assert_fails('call getcompletion(\"abc\", [])', 'E1174:')\nendfunc\n\nfunc Test_multibyte_expression()\n  \" This was using uninitialized memory.\n  let lines =<< trim END\n      set verbose=6\n      norm @=\u0677\n      qall!\n  END\n  call writefile(lines, 'XmultiScript', 'D')\n  call RunVim('', '', '-u NONE -n -e -s -S XmultiScript')\nendfunc\n\n\" Test for getcompletion() with \"fuzzy\" in 'wildoptions'\nfunc Test_getcompletion_wildoptions()\n  let save_wildoptions = &wildoptions\n  set wildoptions&\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n  let l = getcompletion('ier', 'command')\n  call assert_equal([], l)\n  set wildoptions=fuzzy\n  let l = getcompletion('space', 'option')\n  call assert_true(index(l, 'backspace') >= 0)\n  let l = getcompletion('ier', 'command')\n  call assert_true(index(l, 'compiler') >= 0)\n  let &wildoptions = save_wildoptions\nendfunc\n\nfunc Test_complete_autoload_error()\n  let save_rtp = &rtp\n  let lines =<< trim END\n      vim9script\n      export def Complete(..._): string\n        return 'match'\n      enddef\n      echo this will cause an error\n  END\n  call mkdir('Xdir/autoload', 'pR')\n  call writefile(lines, 'Xdir/autoload/script.vim')\n  exe 'set rtp+=' .. getcwd() .. '/Xdir'\n\n  let lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      command -nargs=* -complete=custom,script.Complete Cmd eval 0 + 0\n      &wildcharm = char2nr(\"\\<Tab>\")\n      feedkeys(\":Cmd \\<Tab>\", 'xt')\n  END\n  call v9.CheckScriptFailure(lines, 'E121: Undefined variable: this')\n\n  let &rtp = save_rtp\nendfunc\n\nfunc Test_fullcommand()\n  let tests = {\n        \\ '':           '',\n        \\ ':':          '',\n        \\ ':::':        '',\n        \\ ':::5':       '',\n        \\ 'not_a_cmd':  '',\n        \\ 'Check':      '',\n        \\ 'syntax':     'syntax',\n        \\ ':syntax':    'syntax',\n        \\ '::::syntax': 'syntax',\n        \\ 'sy':         'syntax',\n        \\ 'syn':        'syntax',\n        \\ 'synt':       'syntax',\n        \\ ':sy':        'syntax',\n        \\ '::::sy':     'syntax',\n        \\ 'match':      'match',\n        \\ '2match':     'match',\n        \\ '3match':     'match',\n        \\ 'aboveleft':  'aboveleft',\n        \\ 'abo':        'aboveleft',\n        \\ 'en':         'endif',\n        \\ 'end':        'endif',\n        \\ 'endi':        'endif',\n        \\ 's':          'substitute',\n        \\ '5s':         'substitute',\n        \\ ':5s':        'substitute',\n        \\ \"'<,'>s\":     'substitute',\n        \\ \":'<,'>s\":    'substitute',\n        \\ 'CheckLin':   'CheckLinux',\n        \\ 'CheckLinux': 'CheckLinux',\n  \\ }\n\n  for [in, want] in items(tests)\n    call assert_equal(want, fullcommand(in))\n  endfor\n  call assert_equal('', fullcommand(test_null_string()))\n\n  call assert_equal('syntax', 'syn'->fullcommand())\n\n  command -buffer BufferLocalCommand :\n  command GlobalCommand :\n  call assert_equal('GlobalCommand', fullcommand('GlobalCom'))\n  call assert_equal('BufferLocalCommand', fullcommand('BufferL'))\n  delcommand BufferLocalCommand\n  delcommand GlobalCommand\nendfunc\n\nfunc Test_shellcmd_completion()\n  let save_path = $PATH\n\n  call mkdir('Xpathdir/Xpathsubdir', 'pR')\n  call writefile([''], 'Xpathdir/Xfile.exe')\n  call setfperm('Xpathdir/Xfile.exe', 'rwx------')\n\n  \" Set PATH to example directory without trailing slash.\n  let $PATH = getcwd() . '/Xpathdir'\n\n  \" Test for the \":!<TAB>\" case.  Previously, this would include subdirs of\n  \" dirs in the PATH, even though they won't be executed.  We check that only\n  \" subdirs of the PWD and executables from the PATH are included in the\n  \" suggestions.\n  let actual = getcompletion('X', 'shellcmd')\n  let expected = map(filter(glob('*', 0, 1), 'isdirectory(v:val) && v:val[0] == \"X\"'), 'v:val . \"/\"')\n  call insert(expected, 'Xfile.exe')\n  call assert_equal(expected, actual)\n\n  let $PATH = save_path\nendfunc\n\nfunc Test_expand_star_star()\n  call mkdir('a/b', 'pR')\n  call writefile(['asdfasdf'], 'a/b/fileXname')\n  call feedkeys(\":find **/fileXname\\<Tab>\\<CR>\", 'xt')\n  call assert_equal('find a/b/fileXname', @:)\n  bwipe!\nendfunc\n\nfunc Test_cmdline_paste()\n  let @a = \"def\"\n  call feedkeys(\":abc \\<C-R>a ghi\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"abc def ghi', @:)\n\n  new\n  call setline(1, 'asdf.x /tmp/some verylongword a;b-c*d ')\n\n  call feedkeys(\":aaa \\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa asdf bbb', @:)\n\n  call feedkeys(\"ft:aaa \\<C-R>\\<C-F> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa /tmp/some bbb', @:)\n\n  call feedkeys(\":aaa \\<C-R>\\<C-L> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa '.getline(1).' bbb', @:)\n\n  set incsearch\n  call feedkeys(\"fy:aaa veryl\\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa verylongword bbb', @:)\n\n  call feedkeys(\"f;:aaa \\<C-R>\\<C-A> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa a;b-c*d bbb', @:)\n\n  call feedkeys(\":\\<C-\\>etoupper(getline(1))\\<CR>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"ASDF.X /TMP/SOME VERYLONGWORD A;B-C*D ', @:)\n  bwipe!\n\n  \" Error while typing a command used to cause that it was not executed\n  \" in the end.\n  new\n  try\n    call feedkeys(\":file \\<C-R>%Xtestfile\\<CR>\", 'tx')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E32/\n    \" ignore error E32\n  endtry\n  call assert_equal(\"Xtestfile\", bufname(\"%\"))\n\n  \" Try to paste an invalid register using <C-R>\n  call feedkeys(\":\\\"one\\<C-R>\\<C-X>two\\<CR>\", 'xt')\n  call assert_equal('\"onetwo', @:)\n\n  \" Test for pasting register containing CTRL-H using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-H>z\"\n  call feedkeys(\":\\\"\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal('\"xz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-O>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n\n  \" Test for pasting register containing CTRL-V using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-V>z\"\n  call feedkeys(\":\\\"\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal('\"xyz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-V>z\", @:)\n\n  call assert_beeps('call feedkeys(\":\\<C-R>=\\<C-R>=\\<Esc>\", \"xt\")')\n\n  bwipe!\nendfunc\n\nfunc Test_cmdline_remove_char()\n  let encoding_save = &encoding\n\n  for e in ['utf8', 'latin1']\n    exe 'set encoding=' . e\n\n    call feedkeys(\":abc def\\<S-Left>\\<Del>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ef', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<BS>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abcdef', @:)\n\n    call feedkeys(\":abc def ghi\\<S-Left>\\<C-W>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ghi', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<C-U>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"def', @:, e)\n\n    \" This was going before the start in latin1.\n    call feedkeys(\": \\<C-W>\\<CR>\", 'tx')\n  endfor\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdline_keymap_ctrl_hat()\n  CheckFeature keymap\n\n  set keymap=esperanto\n  call feedkeys(\":\\\"Jxauxdo \\<C-^>Jxauxdo \\<C-^>Jxauxdo\\<CR>\", 'tx')\n  call assert_equal('\"Jxauxdo \u0134a\u016ddo Jxauxdo', @:)\n  set keymap=\nendfunc\n\nfunc Test_illegal_address1()\n  new\n  2;'(\n  2;')\n  quit\nendfunc\n\nfunc Test_illegal_address2()\n  call writefile(['c', 'x', '  x', '.', '1;y'], 'Xtest.vim', 'D')\n  new\n  source Xtest.vim\n  \" Trigger calling validate_cursor()\n  diffsp Xtest.vim\n  quit!\n  bwipe!\nendfunc\n\nfunc Test_mark_from_line_zero()\n  \" this was reading past the end of the first (empty) line\n  new\n  norm oxxxx\n  call assert_fails(\"0;'(\", 'E20:')\n  bwipe!\nendfunc\n\nfunc Test_cmdline_complete_wildoptions()\n  help\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let a = join(sort(split(@:)),' ')\n  set wildoptions=tagfile\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let b = join(sort(split(@:)),' ')\n  call assert_equal(a, b)\n  bw!\nendfunc\n\nfunc Test_cmdline_complete_user_cmd()\n  command! -complete=color -nargs=1 Foo :\n  call feedkeys(\":Foo \\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo a b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo a blue', @:)\n  call feedkeys(\":Foo b\\\\\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\', @:)\n  call feedkeys(\":Foo b\\\\x\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\x', @:)\n  delcommand Foo\n\n  redraw\n  call assert_equal('~', Screenline(&lines - 1))\n  command! FooOne :\n  command! FooTwo :\n\n  set nowildmenu\n  call feedkeys(\":Foo\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"FooOne', @:)\n  call assert_equal('~', Screenline(&lines - 1))\n\n  call feedkeys(\":Foo\\<S-Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"FooTwo', @:)\n  call assert_equal('~', Screenline(&lines - 1))\n\n  delcommand FooOne\n  delcommand FooTwo\n  set wildmenu&\nendfunc\n\nfunc Test_complete_user_cmd()\n  command FooBar echo 'global'\n  command -buffer FooBar echo 'local'\n  call feedkeys(\":Foo\\<C-A>\\<Home>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"FooBar', @:)\n\n  delcommand -buffer FooBar\n  delcommand FooBar\nendfunc\n\nfunc s:ScriptLocalFunction()\n  echo 'yes'\nendfunc\n\nfunc Test_cmdline_complete_user_func()\n  call feedkeys(\":func Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func Test_cmdline_complete_user_', @:)\n  call feedkeys(\":func s:ScriptL\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func <SNR>\\d\\+_ScriptLocalFunction', @:)\n\n  \" g: prefix also works\n  call feedkeys(\":echo g:Test_cmdline_complete_user_f\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:Test_cmdline_complete_user_func', @:)\n\n  \" using g: prefix does not result in just \"g:\" matches from a lambda\n  let Fx = { a ->  a }\n  call feedkeys(\":echo g:\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:[A-Z]', @:)\n\n  \" existence of script-local dict function does not break user function name\n  \" completion\n  function s:a_dict_func() dict\n  endfunction\n  call feedkeys(\":call Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"call Test_cmdline_complete_user_', @:)\n  delfunction s:a_dict_func\nendfunc\n\nfunc Test_cmdline_complete_user_names()\n  if has('unix') && executable('whoami')\n    let whoami = systemlist('whoami')[0]\n    let first_letter = whoami[0]\n    if len(first_letter) > 0\n      \" Trying completion of  :e ~x  where x is the first letter of\n      \" the user name should complete to at least the user name.\n      call feedkeys(':e ~' . first_letter . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*\\<' . whoami . '\\>', @:)\n    endif\n  elseif has('win32')\n    \" Just in case: check that the system has an Administrator account.\n    let names = system('net user')\n    if names =~ 'Administrator'\n      \" Trying completion of  :e ~A  should complete to Administrator.\n      \" There could be other names starting with \"A\" before Administrator.\n      call feedkeys(':e ~A' . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*Administrator', @:)\n    endif\n  else\n    throw 'Skipped: does not work on this platform'\n  endif\nendfunc\n\nfunc Test_cmdline_complete_bang()\n  CheckExecutable whoami\n  call feedkeys(\":!whoam\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('^\".*\\<whoami\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_languages()\n  let lang = substitute(execute('language time'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lc_time)\n\n  let lang = substitute(execute('language ctype'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:ctype)\n\n  let lang = substitute(execute('language collate'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:collate)\n\n  let lang = substitute(execute('language messages'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lang)\n\n  call feedkeys(\":language \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<collate\\>.*\\<ctype\\>.*\\<messages\\>.*\\<time\\>', @:)\n\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language messages \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language ctype \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language time \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language collate \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_env_variable()\n  let $X_VIM_TEST_COMPLETE_ENV = 'foo'\n  call feedkeys(\":edit $X_VIM_TEST_COMPLETE_E\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"edit $X_VIM_TEST_COMPLETE_ENV', @:)\n  unlet $X_VIM_TEST_COMPLETE_ENV\nendfunc\n\nfunc Test_cmdline_complete_expression()\n  let g:SomeVar = 'blah'\n  for cmd in ['exe', 'echo', 'echon', 'echomsg']\n    call feedkeys(\":\" .. cmd .. \" SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' SomeVar', @:)\n    call feedkeys(\":\" .. cmd .. \" foo SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' foo SomeVar', @:)\n  endfor\n  unlet g:SomeVar\nendfunc\n\n\" Unique function name for completion below\nfunc s:WeirdFunc()\n  echo 'weird'\nendfunc\n\n\" Test for various command-line completion\nfunc Test_cmdline_complete_various()\n  \" completion for a command starting with a comment\n  call feedkeys(\": :|\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\" :|\\\"\\<C-A>\", @:)\n\n  \" completion for a range followed by a comment\n  call feedkeys(\":1,2\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"1,2\\\"\\<C-A>\", @:)\n\n  \" completion for :k command\n  call feedkeys(\":ka\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ka\\<C-A>\", @:)\n\n  \" completion for short version of the :s command\n  call feedkeys(\":sI \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"sI \\<C-A>\", @:)\n\n  \" completion for :write command\n  call mkdir('Xcwdir', 'R')\n  call writefile(['one'], 'Xcwdir/Xfile1')\n  let save_cwd = getcwd()\n  cd Xcwdir\n  call feedkeys(\":w >> \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w >> Xfile1\", @:)\n  call chdir(save_cwd)\n\n  \" completion for :w ! and :r ! commands\n  call feedkeys(\":w !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w !invalid_xyz_cmd\", @:)\n  call feedkeys(\":r !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"r !invalid_xyz_cmd\", @:)\n\n  \" completion for :>> and :<< commands\n  call feedkeys(\":>>>\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\">>>\\<C-A>\", @:)\n  call feedkeys(\":<<<\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"<<<\\<C-A>\", @:)\n\n  \" completion for command with +cmd argument\n  call feedkeys(\":buffer +/pat Xabc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat Xabc\", @:)\n  call feedkeys(\":buffer +/pat\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat\\<C-A>\", @:)\n\n  \" completion for a command with a trailing comment\n  call feedkeys(\":ls \\\" comment\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\\" comment\\<C-A>\", @:)\n\n  \" completion for a command with a trailing command\n  call feedkeys(\":ls | ls\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls | ls\", @:)\n\n  \" completion for a command with an CTRL-V escaped argument\n  call feedkeys(\":ls \\<C-V>\\<C-V>a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\<C-V>a\\<C-A>\", @:)\n\n  \" completion for a command that doesn't take additional arguments\n  call feedkeys(\":all abc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"all abc\\<C-A>\", @:)\n\n  \" completion for :wincmd with :horizontal modifier\n  call feedkeys(\":horizontal wincm\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"horizontal wincmd\", @:)\n\n  \" completion for a command with a command modifier\n  call feedkeys(\":topleft new\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"topleft new\", @:)\n\n  \" completion for vim9 and legacy commands\n  call feedkeys(\":vim9 call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"vim9 call strlen(\", @:)\n  call feedkeys(\":legac call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"legac call strlen(\", @:)\n\n  \" completion for the :disassemble command\n  call feedkeys(\":disas deb\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug\", @:)\n  call feedkeys(\":disas pro\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile\", @:)\n  call feedkeys(\":disas debug Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas profile Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas Test_cmdline_complete_various\", @:)\n\n  call feedkeys(\":disas s:WeirdF\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_WeirdFunc', @:)\n\n  call feedkeys(\":disas \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_', @:)\n  call feedkeys(\":disas debug \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas debug <SNR>\\d\\+_', @:)\n\n  \" completion for the :match command\n  call feedkeys(\":match Search /pat/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"match Search /pat/\\<C-A>\", @:)\n\n  \" completion for the :doautocmd command\n  call feedkeys(\":doautocmd User MyCmd a.c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd User MyCmd a.c\\<C-A>\", @:)\n\n  \" completion of autocmd group after comma\n  call feedkeys(\":doautocmd BufNew,BufEn\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufNew,BufEnter\", @:)\n\n  \" completion of file name in :doautocmd\n  call writefile([], 'Xvarfile1', 'D')\n  call writefile([], 'Xvarfile2', 'D')\n  call feedkeys(\":doautocmd BufEnter Xvarfi\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufEnter Xvarfile1 Xvarfile2\", @:)\n\n  \" completion for the :augroup command\n  augroup XTest.test\n  augroup END\n  call feedkeys(\":augroup X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"augroup XTest.test\", @:)\n\n  \" group name completion in :autocmd\n  call feedkeys(\":au X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n  call feedkeys(\":au XTest.test\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n\n  augroup! XTest.test\n\n  \" autocmd pattern completion\n  call feedkeys(\":au BufEnter *.py\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au BufEnter *.py\\t\", @:)\n\n  \" completion for the :unlet command\n  call feedkeys(\":unlet one two\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"unlet one two\", @:)\n\n  \" completion for the :buffer command with curlies\n  \" FIXME: what should happen on MS-Windows?\n  if !has('win32')\n    edit \\{someFile}\n    call feedkeys(\":buf someFile\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"buf {someFile}\", @:)\n    bwipe {someFile}\n  endif\n\n  \" completion for the :bdelete command\n  call feedkeys(\":bdel a b c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"bdel a b c\", @:)\n\n  \" completion for the :mapclear command\n  call feedkeys(\":mapclear \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"mapclear <buffer>\", @:)\n\n  \" completion for user defined commands with menu names\n  menu Test.foo :ls<CR>\n  com -nargs=* -complete=menu MyCmd\n  call feedkeys(\":MyCmd Te\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd Test.', @:)\n  delcom MyCmd\n  unmenu Test\n\n  \" completion for user defined commands with mappings\n  mapclear\n  map <F3> :ls<CR>\n  com -nargs=* -complete=mapping MyCmd\n  call feedkeys(\":MyCmd <F\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd <F3> <F4>', @:)\n  mapclear\n  delcom MyCmd\n\n  \" completion for :set path= with multiple backslashes\n  call feedkeys(\":set path=a\\\\\\\\\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set path=a\\\\\\ b', @:)\n\n  \" completion for :set dir= with a backslash\n  call feedkeys(\":set dir=a\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set dir=a\\ b', @:)\n\n  \" completion for the :py3 commands\n  call feedkeys(\":py3\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3 py3do py3file', @:)\n\n  \" completion for the :vim9 commands\n  call feedkeys(\":vim9\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"vim9cmd vim9script', @:)\n\n  \" redir @\" is not the start of a comment. So complete after that\n  call feedkeys(\":redir @\\\" | cwin\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"redir @\" | cwindow', @:)\n\n  \" completion after a backtick\n  call feedkeys(\":e `a1b2c\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e `a1b2c', @:)\n\n  \" completion for :language command with an invalid argument\n  call feedkeys(\":language dummy \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"language dummy \\t\", @:)\n\n  \" completion for commands after a :global command\n  call feedkeys(\":g/a\\\\xb/clearj\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n\n  \" completion with ambiguous user defined commands\n  com TCmd1 echo 'TCmd1'\n  com TCmd2 echo 'TCmd2'\n  call feedkeys(\":TCmd \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"TCmd ', @:)\n  delcom TCmd1\n  delcom TCmd2\n\n  \" completion after a range followed by a pipe (|) character\n  call feedkeys(\":1,10 | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"1,10 | chistory', @:)\n\n  \" completion after a :global command\n  call feedkeys(\":g/a/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a/chistory', @:)\n  call feedkeys(\":g/a\\\\/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"g/a\\\\/chist\\t\", @:)\n\n  \" use <Esc> as the 'wildchar' for completion\n  set wildchar=<Esc>\n  call feedkeys(\":g/a\\\\xb/clearj\\<Esc>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  \" pressing <esc> twice should cancel the command\n  call feedkeys(\":chist\\<Esc>\\<Esc>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  set wildchar&\n\n  if has('unix')\n    \" should be able to complete a file name that starts with a '~'.\n    call writefile([], '~Xtest')\n    call feedkeys(\":e \\\\~X\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\~Xtest', @:)\n    call delete('~Xtest')\n\n    \" should be able to complete a file name that has a '*'\n    call writefile([], 'Xx*Yy')\n    call feedkeys(\":e Xx\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xx\\*Yy', @:)\n    call delete('Xx*Yy')\n\n    \" use a literal star\n    call feedkeys(\":e \\\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\*', @:)\n  endif\n\n  call feedkeys(\":py3f\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3file', @:)\nendfunc\n\n\" Test for 'wildignorecase'\nfunc Test_cmdline_wildignorecase()\n  CheckUnix\n  call writefile([], 'XTEST', 'D')\n  set wildignorecase\n  call feedkeys(\":e xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e XTEST', @:)\n  call assert_equal(['XTEST'], getcompletion('xt', 'file'))\n  let g:Sline = ''\n  call feedkeys(\":e xt\\<C-d>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e xt', @:)\n  call assert_equal('XTEST', g:Sline)\n  set wildignorecase&\nendfunc\n\nfunc Test_cmdline_write_alternatefile()\n  new\n  call setline('.', ['one', 'two'])\n  f foo.txt\n  new\n  f #-A\n  call assert_equal('foo.txt-A', expand('%'))\n  f #<-B.txt\n  call assert_equal('foo-B.txt', expand('%'))\n  f %<\n  call assert_equal('foo-B', expand('%'))\n  new\n  call assert_fails('f #<', 'E95:')\n  bw!\n  f foo-B.txt\n  f %<-A\n  call assert_equal('foo-B-A', expand('%'))\n  bw!\n  bw!\nendfunc\n\nfunc Test_cmdline_expand_cur_alt_file()\n  enew\n  file http://some.com/file.txt\n  call feedkeys(\":e %\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e http://some.com/file.txt', @:)\n  edit another\n  call feedkeys(\":e #\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e http://some.com/file.txt', @:)\n  bwipe\n  bwipe http://some.com/file.txt\nendfunc\n\n\" using a leading backslash here\nset cpo+=C\n\nfunc Test_cmdline_search_range()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  /d\n  1,\\/s/b/B/\n  call assert_equal('B', getline(2))\n\n  /a\n  $\n  \\?,4s/c/C/\n  call assert_equal('C', getline(3))\n\n  call setline(1, ['a', 'b', 'c', 'd'])\n  %s/c/c/\n  1,\\&s/b/B/\n  call assert_equal('B', getline(2))\n\n  let @/ = 'apple'\n  call assert_fails('\\/print', ['E486:.*apple'])\n\n  bwipe!\nendfunc\n\n\" Test for the tick mark (') in an excmd range\nfunc Test_tick_mark_in_range()\n  \" If only the tick is passed as a range and no command is specified, there\n  \" should not be an error\n  call feedkeys(\":'\\<CR>\", 'xt')\n  call assert_equal(\"'\", @:)\n  call assert_fails(\"',print\", 'E78:')\nendfunc\n\n\" Test for using a line number followed by a search pattern as range\nfunc Test_lnum_and_pattern_as_range()\n  new\n  call setline(1, ['foo 1', 'foo 2', 'foo 3'])\n  let @\" = ''\n  2/foo/yank\n  call assert_equal(\"foo 3\\n\", @\")\n  call assert_equal(1, line('.'))\n  close!\nendfunc\n\n\" Tests for getcmdline(), getcmdpos() and getcmdtype()\nfunc Check_cmdline(cmdtype)\n  call assert_equal('MyCmd a', getcmdline())\n  call assert_equal(8, getcmdpos())\n  call assert_equal(a:cmdtype, getcmdtype())\n  return ''\nendfunc\n\nset cpo&\n\nfunc Test_getcmdtype()\n  call feedkeys(\":MyCmd a\\<C-R>=Check_cmdline(':')\\<CR>\\<Esc>\", \"xt\")\n\n  let cmdtype = ''\n  debuggreedy\n  call feedkeys(\":debug echo 'test'\\<CR>\", \"t\")\n  call feedkeys(\"let cmdtype = \\<C-R>=string(getcmdtype())\\<CR>\\<CR>\", \"t\")\n  call feedkeys(\"cont\\<CR>\", \"xt\")\n  0debuggreedy\n  call assert_equal('>', cmdtype)\n\n  call feedkeys(\"/MyCmd a\\<C-R>=Check_cmdline('/')\\<CR>\\<Esc>\", \"xt\")\n  call feedkeys(\"?MyCmd a\\<C-R>=Check_cmdline('?')\\<CR>\\<Esc>\", \"xt\")\n\n  call feedkeys(\":call input('Answer?')\\<CR>\", \"t\")\n  call feedkeys(\"MyCmd a\\<C-R>=Check_cmdline('@')\\<CR>\\<C-C>\", \"xt\")\n\n  call feedkeys(\":insert\\<CR>MyCmd a\\<C-R>=Check_cmdline('-')\\<CR>\\<Esc>\", \"xt\")\n\n  cnoremap <expr> <F6> Check_cmdline('=')\n  call feedkeys(\"a\\<C-R>=MyCmd a\\<F6>\\<Esc>\\<Esc>\", \"xt\")\n  cunmap <F6>\n\n  call assert_equal('', getcmdline())\nendfunc\n\nfunc Test_verbosefile()\n  set verbosefile=Xlog\n  echomsg 'foo'\n  echomsg 'bar'\n  set verbosefile=\n  let log = readfile('Xlog')\n  call assert_match(\"foo\\nbar\", join(log, \"\\n\"))\n  call delete('Xlog')\n\n  call mkdir('Xdir', 'D')\n  call assert_fails('set verbosefile=Xdir', ['E484:.*Xdir', 'E474:'])\nendfunc\n\nfunc Test_verbose_option()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    command DoSomething echo 'hello' |set ts=4 |let v = '123' |echo v\n    call feedkeys(\"\\r\", 't') \" for the hit-enter prompt\n    set verbose=20\n  [SCRIPT]\n  call writefile(lines, 'XTest_verbose', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_verbose', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":DoSomething\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_verbose_option_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_setcmdpos()\n  func InsertTextAtPos(text, pos)\n    call assert_equal(0, setcmdpos(a:pos))\n    return a:text\n  endfunc\n\n  \" setcmdpos() with position in the middle of the command line.\n  call feedkeys(\":\\\"12\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1ab2', @:)\n\n  call feedkeys(\":\\\"12\\<C-R>\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1b2a', @:)\n\n  \" setcmdpos() with position beyond the end of the command line.\n  call feedkeys(\":\\\"12\\<C-B>\\<C-R>=InsertTextAtPos('a', 10)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"12ab', @:)\n\n  \" setcmdpos() returns 1 when not editing the command line.\n  call assert_equal(1, 3->setcmdpos())\nendfunc\n\nfunc Test_cmdline_overstrike()\n  let encodings = ['latin1', 'utf8']\n  let encoding_save = &encoding\n\n  for e in encodings\n    exe 'set encoding=' . e\n\n    \" Test overstrike in the middle of the command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cd4', @:, e)\n\n    \" Test overstrike going beyond end of command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cdefgh\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cdefgh', @:, e)\n\n    \" Test toggling insert/overstrike a few times.\n    call feedkeys(\":\\\"01234\\<home>\\<right>ab\\<right>\\<insert>cd\\<right>\\<insert>ef\\<enter>\", 'xt')\n    call assert_equal('\"ab0cd3ef4', @:, e)\n  endfor\n\n  \" Test overstrike with multi-byte characters.\n  call feedkeys(\":\\\"\u30c6\u30ad\u30b9\u30c8\u30a8\u30c7\u30a3\u30bf\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n  call assert_equal('\"\u30c6ab\u30adcd\u30a8\u30c7\u30a3\u30bf', @:, e)\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_buffers_lastused()\n  \" check that buffers are sorted by time when wildmode has lastused\n  call test_settime(1550020000)\t  \" middle\n  edit bufa\n  enew\n  call test_settime(1550030000)\t  \" newest\n  edit bufb\n  enew\n  call test_settime(1550010000)\t  \" oldest\n  edit bufc\n  enew\n  call test_settime(0)\n  enew\n\n  call assert_equal(['bufa', 'bufb', 'bufc'],\n\t\\ getcompletion('', 'buffer'))\n\n  let save_wildmode = &wildmode\n  set wildmode=full:lastused\n\n  let cap = \"\\<c-r>=execute('let X=getcmdline()')\\<cr>\"\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  edit other\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  let &wildmode = save_wildmode\n\n  bwipeout bufa\n  bwipeout bufb\n  bwipeout bufc\nendfunc\n\nfunc Test_cmdlineclear_tabenter()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    call setline(1, range(30))\n  [SCRIPT]\n\n  call writefile(lines, 'XtestCmdlineClearTabenter', 'D')\n  let buf = RunVimInTerminal('-S XtestCmdlineClearTabenter', #{rows: 10})\n  call TermWait(buf, 25)\n  \" in one tab make the command line higher with CTRL-W -\n  call term_sendkeys(buf, \":tabnew\\<cr>\\<C-w>-\\<C-w>-gtgt\")\n  call VerifyScreenDump(buf, 'Test_cmdlineclear_tabenter', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for expanding special keywords in cmdline\nfunc Test_cmdline_expand_special()\n  %bwipe!\n  call assert_fails('e #', 'E194:')\n  call assert_fails('e <afile>', 'E495:')\n  call assert_fails('e <abuf>', 'E496:')\n  call assert_fails('e <amatch>', 'E497:')\n\n  call writefile([], 'Xfile.cpp', 'D')\n  call writefile([], 'Xfile.java', 'D')\n  new Xfile.cpp\n  call feedkeys(\":e %:r\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.cpp Xfile.java', @:)\n  close\nendfunc\n\n\" Test for backtick expression in the command line\nfunc Test_cmd_backtick()\n  %argd\n  argadd `=['a', 'b', 'c']`\n  call assert_equal(['a', 'b', 'c'], argv())\n  %argd\n\n  argadd `echo abc def`\n  call assert_equal(['abc def'], argv())\n  %argd\nendfunc\n\n\" Test for the :! command\nfunc Test_cmd_bang()\n  CheckUnix\n\n  let lines =<< trim [SCRIPT]\n    \" Test for no previous command\n    call assert_fails('!!', 'E34:')\n    set nomore\n    \" Test for cmdline expansion with :!\n    call setline(1, 'foo!')\n    silent !echo <cWORD> > Xfile.out\n    call assert_equal(['foo!'], readfile('Xfile.out'))\n    \" Test for using previous command\n    silent !echo \\! !\n    call assert_equal(['! echo foo!'], readfile('Xfile.out'))\n    call writefile(v:errors, 'Xresult')\n    call delete('Xfile.out')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xresult')\nendfunc\n\n\" Test error: \"E135: *Filter* Autocommands must not change current buffer\"\nfunc Test_cmd_bang_E135()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  augroup test_cmd_filter_E135\n    au!\n    autocmd FilterReadPost * help\n  augroup END\n  call assert_fails('2,3!echo \"x\"', 'E135:')\n\n  augroup test_cmd_filter_E135\n    au!\n  augroup END\n  %bwipe!\nendfunc\n\nfunc Test_cmd_bang_args()\n  new\n  :.!\n  call assert_equal(0, v:shell_error)\n\n  \" Note that below there is one space char after the '!'.  This caused a\n  \" shell error in the past, see https://github.com/vim/vim/issues/11495.\n  :.! \n  call assert_equal(0, v:shell_error)\n  bwipe!\n\n  CheckUnix\n  :.!pwd\n  call assert_equal(0, v:shell_error)\n  :.! pwd\n  call assert_equal(0, v:shell_error)\n\n  \" Note there is one space after 'pwd'.\n  :.! pwd \n  call assert_equal(0, v:shell_error)\n\n  \" Note there are two spaces after 'pwd'.\n  :.!  pwd  \n  call assert_equal(0, v:shell_error)\n  :.!ls ~\n  call assert_equal(0, v:shell_error)\n\n  \" Note there is one space char after '~'.\n  :.!ls  ~ \n  call assert_equal(0, v:shell_error)\n\n  \" Note there are two spaces after '~'.\n  :.!ls  ~  \n  call assert_equal(0, v:shell_error)\n\n  :.!echo \"foo\"\n  call assert_equal(getline('.'), \"foo\")\n  :.!echo \"foo  \"\n  call assert_equal(getline('.'), \"foo  \")\n  :.!echo \" foo  \"\n  call assert_equal(getline('.'), \" foo  \")\n  :.!echo  \" foo  \"\n  call assert_equal(getline('.'), \" foo  \")\n\n  %bwipe!\nendfunc\n\n\" Test for using ~ for home directory in cmdline completion matches\nfunc Test_cmdline_expand_home()\n  call mkdir('Xexpdir', 'R')\n  call writefile([], 'Xexpdir/Xfile1')\n  call writefile([], 'Xexpdir/Xfile2')\n  cd Xexpdir\n  let save_HOME = $HOME\n  let $HOME = getcwd()\n  call feedkeys(\":e ~/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ~/Xfile1 ~/Xfile2', @:)\n  let $HOME = save_HOME\n  cd ..\nendfunc\n\n\" Test for using CTRL-\\ CTRL-G in the command line to go back to normal mode\n\" or insert mode (when 'insertmode' is set)\nfunc Test_cmdline_ctrl_g()\n  new\n  call setline(1, 'abc')\n  call cursor(1, 3)\n  \" If command line is entered from insert mode, using C-\\ C-G should back to\n  \" insert mode\n  call feedkeys(\"i\\<C-O>:\\<C-\\>\\<C-G>xy\", 'xt')\n  call assert_equal('abxyc', getline(1))\n  call assert_equal(4, col('.'))\n\n  \" If command line is entered in 'insertmode', using C-\\ C-G should back to\n  \" 'insertmode'\n  call feedkeys(\":set im\\<cr>\\<C-L>:\\<C-\\>\\<C-G>12\\<C-L>:set noim\\<cr>\", 'xt')\n  call assert_equal('ab12xyc', getline(1))\n  close!\nendfunc\n\n\" Test for 'wildmode'\nfunc Wildmode_tests()\n  func T(a, c, p)\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n\n  set nowildmenu\n  set wildmode=full,list\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd oneA', @:)\n\n  set wildmode=longest,full\n  call feedkeys(\":MyCmd o\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n  call feedkeys(\":MyCmd o\\t\\t\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneC', @:)\n\n  set wildmode=longest\n  call feedkeys(\":MyCmd one\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=list:longest\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=\"\"\n  call feedkeys(\":MyCmd \\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA', @:)\n\n  \" Test for wildmode=longest with 'fileignorecase' set\n  set wildmode=longest\n  set fileignorecase\n  argadd AAA AAAA AAAAA\n  call feedkeys(\":buffer a\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"buffer AAA', @:)\n  set fileignorecase&\n\n  \" Test for listing files with wildmode=list\n  set wildmode=list\n  let g:Sline = ''\n  call feedkeys(\":b A\\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('AAA    AAAA   AAAAA', g:Sline)\n  call assert_equal('\"b A', @:)\n\n  \" when using longest completion match, matches shorter than the argument\n  \" should be ignored (happens with :help)\n  set wildmode=longest,full\n  set wildmenu\n  call feedkeys(\":help a*\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"help a', @:)\n  \" non existing file\n  call feedkeys(\":e a1b2y3z4\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e a1b2y3z4', @:)\n  set wildmenu&\n\n  \" Test for longest file name completion with 'fileignorecase'\n  \" On MS-Windows, file names are case insensitive.\n  if has('unix')\n    call writefile([], 'XTESTfoo', 'D')\n    call writefile([], 'Xtestbar', 'D')\n    set nofileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e XTESTfoo', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtestbar', @:)\n    set fileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    set fileignorecase&\n  endif\n\n  %argdelete\n  delcommand MyCmd\n  delfunc T\n  set wildmode&\n  %bwipe!\nendfunc\n\nfunc Test_wildmode()\n  \" Test with utf-8 encoding\n  call Wildmode_tests()\n\n  \" Test with latin1 encoding\n  let save_encoding = &encoding\n  set encoding=latin1\n  call Wildmode_tests()\n  let &encoding = save_encoding\nendfunc\n\nfunc Test_custom_complete_autoload()\n  call mkdir('Xcustdir/autoload', 'pR')\n  let save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xcustdir'\n  let lines =<< trim END\n      func vim8#Complete(a, c, p)\n        return \"oneA\\noneB\\noneC\"\n      endfunc\n  END\n  call writefile(lines, 'Xcustdir/autoload/vim8.vim')\n\n  command -nargs=1 -complete=custom,vim8#Complete MyCmd\n  set nowildmenu\n  set wildmode=full,list\n  call feedkeys(\":MyCmd \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA oneB oneC', @:)\n\n  let &rtp = save_rtp\n  set wildmode& wildmenu&\n  delcommand MyCmd\nendfunc\n\n\" Test for interrupting the command-line completion\nfunc Test_interrupt_compl()\n  func F(lead, cmdl, p)\n    if a:lead =~ 'tw'\n      call interrupt()\n      return\n    endif\n    return \"one\\ntwo\\nthree\"\n  endfunc\n  command -nargs=1 -complete=custom,F Tcmd\n\n  set nowildmenu\n  set wildmode=full\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<C-d>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  delcommand Tcmd\n  delfunc F\n  set wildmode&\nendfunc\n\n\" Test for moving the cursor on the : command line\nfunc Test_cmdline_edit()\n  let str = \":one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Left>five\\<Right>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Left>one \"\n  let str ..= \"\\<C-Right> three\"\n  let str ..= \"\\<End>\\<S-Left>four \"\n  let str ..= \"\\<S-Right> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call feedkeys(str, 'xt')\n  call assert_equal(\"\\\"one two three four five six seven\", @:)\nendfunc\n\n\" Test for moving the cursor on the / command line in 'rightleft' mode\nfunc Test_cmdline_edit_rightleft()\n  CheckFeature rightleft\n  set rightleft\n  set rightleftcmd=search\n  let str = \"/one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Right>five\\<Left>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Right>one \"\n  let str ..= \"\\<C-Left> three\"\n  let str ..= \"\\<End>\\<S-Right>four \"\n  let str ..= \"\\<S-Left> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call assert_fails(\"call feedkeys(str, 'xt')\", 'E486:')\n  call assert_equal(\"\\\"one two three four five six seven\", @/)\n  set rightleftcmd&\n  set rightleft&\nendfunc\n\n\" Test for using <C-\\>e in the command line to evaluate an expression\nfunc Test_cmdline_expr()\n  \" Evaluate an expression from the beginning of a command line\n  call feedkeys(\":abc\\<C-B>\\<C-\\>e\\\"\\\\\\\"hello\\\"\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"hello', @:)\n\n  \" Use an invalid expression for <C-\\>e\n  call assert_beeps('call feedkeys(\":\\<C-\\>einvalid\\<CR>\", \"tx\")')\n\n  \" Insert literal <CTRL-\\> in the command line\n  call feedkeys(\":\\\"e \\<C-\\>\\<C-Y>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"e \\<C-\\>\\<C-Y>\", @:)\nendfunc\n\n\" This was making the insert position negative\nfunc Test_cmdline_expr_register()\n  exe \"sil! norm! ?\\<C-\\>e0\\<C-R>0\\<Esc>?\\<C-\\>e0\\<CR>\"\nendfunc\n\n\" Test for 'imcmdline' and 'imsearch'\n\" This test doesn't actually test the input method functionality.\nfunc Test_cmdline_inputmethod()\n  new\n  call setline(1, ['', 'abc', ''])\n  set imcmdline\n\n  call feedkeys(\":\\\"abc\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\":\\\"\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  set imsearch=2\n  call cursor(1, 1)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call cursor(1, 1)\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable&\n  set imsearch&\n\n  set imcmdline&\n  %bwipe!\nendfunc\n\n\" Test for using CTRL-_ in the command line with 'allowrevins'\nfunc Test_cmdline_revins()\n  CheckNotMSWindows\n  CheckFeature rightleft\n  call feedkeys(\":\\\"abc\\<c-_>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"abc\\<c-_>\", @:)\n  set allowrevins\n  call feedkeys(\":\\\"abc\\<c-_>xyz\\<c-_>\\<CR>\", 'xt')\n  call assert_equal('\"abc\u00f1\u00e8\u00e6', @:)\n  set allowrevins&\nendfunc\n\n\" Test for typing UTF-8 composing characters in the command line\nfunc Test_cmdline_composing_chars()\n  call feedkeys(\":\\\"\\<C-V>u3046\\<C-V>u3099\\<CR>\", 'xt')\n  call assert_equal('\"\u3046\u3099', @:)\nendfunc\n\n\" test that \";\" works to find a match at the start of the first line\nfunc Test_zero_line_search()\n  new\n  call setline(1, [\"1, pattern\", \"2, \", \"3, pattern\"])\n  call cursor(1,1)\n  0;/pattern/d\n  call assert_equal([\"2, \", \"3, pattern\"], getline(1,'$'))\n  q!\nendfunc\n\nfunc Test_read_shellcmd()\n  CheckUnix\n  if executable('ls')\n    \" There should be ls in the $PATH\n    call feedkeys(\":r! l\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_match('^\"r! .*\\<ls\\>', @:)\n  endif\n\n  if executable('rm')\n    call feedkeys(\":r! ++enc=utf-8 r\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r!.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r!.*\\<rm\\>', @:)\n\n    call feedkeys(\":r ++enc=utf-8 !rm\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r ++enc\\S\\+ !.*\\<rm\\>', @:)\n  endif\nendfunc\n\n\" Test for going up and down the directory tree using 'wildmenu'\nfunc Test_wildmenu_dirstack()\n  CheckUnix\n  %bw!\n  call mkdir('Xwildmenu/dir2/dir3/dir4', 'pR')\n  call writefile([], 'Xwildmenu/file1_1.txt')\n  call writefile([], 'Xwildmenu/file1_2.txt')\n  call writefile([], 'Xwildmenu/dir2/file2_1.txt')\n  call writefile([], 'Xwildmenu/dir2/file2_2.txt')\n  call writefile([], 'Xwildmenu/dir2/dir3/file3_1.txt')\n  call writefile([], 'Xwildmenu/dir2/dir3/file3_2.txt')\n  call writefile([], 'Xwildmenu/dir2/dir3/dir4/file4_1.txt')\n  call writefile([], 'Xwildmenu/dir2/dir3/dir4/file4_2.txt')\n  set wildmenu\n\n  cd Xwildmenu/dir2/dir3/dir4\n  call feedkeys(\":e \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e file4_1.txt', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../../dir2/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/file4_1.txt', @:)\n  cd -\n  call feedkeys(\":e Xwildmenu/\\<Tab>\\<Down>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xwildmenu/dir2/dir3/dir4/file4_1.txt', @:)\n\n  set wildmenu&\nendfunc\n\n\" Test for recalling newer or older cmdline from history with <Up>, <Down>,\n\" <S-Up>, <S-Down>, <PageUp>, <PageDown>, <kPageUp>, <kPageDown>, <C-p>, or\n\" <C-n>.\nfunc Test_recalling_cmdline()\n  CheckFeature cmdline_hist\n\n  let g:cmdlines = []\n  cnoremap <Plug>(save-cmdline) <Cmd>let g:cmdlines += [getcmdline()]<CR>\n\n  let histories = [\n  \\  #{name: 'cmd',    enter: ':',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'search', enter: '/',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'expr',   enter: \":\\<C-r>=\",             exit: \"\\<Esc>\\<Esc>\"},\n  \\  #{name: 'input',  enter: \":call input('')\\<CR>\", exit: \"\\<CR>\"},\n  \"\\ TODO: {'name': 'debug', ...}\n  \\]\n  let keypairs = [\n  \\  #{older: \"\\<Up>\",     newer: \"\\<Down>\",     prefixmatch: v:true},\n  \\  #{older: \"\\<S-Up>\",   newer: \"\\<S-Down>\",   prefixmatch: v:false},\n  \\  #{older: \"\\<PageUp>\", newer: \"\\<PageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<kPageUp>\", newer: \"\\<kPageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<C-p>\",    newer: \"\\<C-n>\",      prefixmatch: v:false},\n  \\]\n  let prefix = 'vi'\n  for h in histories\n    call histadd(h.name, 'vim')\n    call histadd(h.name, 'virtue')\n    call histadd(h.name, 'Virgo')\n    call histadd(h.name, 'vogue')\n    call histadd(h.name, 'emacs')\n    for k in keypairs\n      let g:cmdlines = []\n      let keyseqs = h.enter\n      \\          .. prefix\n      \\          .. repeat(k.older .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. repeat(k.newer .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. h.exit\n      call feedkeys(keyseqs, 'xt')\n      call histdel(h.name, -1) \" delete the history added by feedkeys above\n      let expect = k.prefixmatch\n      \\          ? ['virtue', 'vim',   'virtue', prefix]\n      \\          : ['emacs',  'vogue', 'emacs',  prefix]\n      call assert_equal(expect, g:cmdlines)\n    endfor\n  endfor\n\n  unlet g:cmdlines\n  cunmap <Plug>(save-cmdline)\nendfunc\n\nfunc Test_cmd_map_cmdlineChanged()\n  let g:log = []\n  cnoremap <F1> l<Cmd><CR>s\n  augroup test\n    autocmd!\n    autocmd CmdlineChanged : let g:log += [getcmdline()]\n  augroup END\n\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['l', 'ls'], g:log)\n\n  let @b = 'b'\n  cnoremap <F1> a<C-R>b\n  let g:log = []\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['a', 'ab'], g:log)\n\n  unlet g:log\n  cunmap <F1>\n  augroup test\n    autocmd!\n  augroup END\nendfunc\n\n\" Test for the 'suffixes' option\nfunc Test_suffixes_opt()\n  call writefile([], 'Xsuffile', 'D')\n  call writefile([], 'Xsuffile.c', 'D')\n  call writefile([], 'Xsuffile.o', 'D')\n  set suffixes=\n  call feedkeys(\":e Xsuffi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile Xsuffile.c Xsuffile.o', @:)\n  call feedkeys(\":e Xsuffi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile.c', @:)\n  set suffixes=.c\n  call feedkeys(\":e Xsuffi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile Xsuffile.o Xsuffile.c', @:)\n  call feedkeys(\":e Xsuffi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile.o', @:)\n  set suffixes=,,\n  call feedkeys(\":e Xsuffi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile.c Xsuffile.o Xsuffile', @:)\n  call feedkeys(\":e Xsuffi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xsuffile.o', @:)\n  set suffixes&\n  \" Test for getcompletion() with different patterns\n  call assert_equal(['Xsuffile', 'Xsuffile.c', 'Xsuffile.o'], getcompletion('Xsuffile', 'file'))\n  call assert_equal(['Xsuffile'], getcompletion('Xsuffile$', 'file'))\nendfunc\n\n\" Test for using a popup menu for the command line completion matches\n\" (wildoptions=pum)\nfunc Test_wildmenu_pum()\n  CheckRunVimInTerminal\n\n  let commands =<< trim [CODE]\n    set wildmenu\n    set wildoptions=pum\n    set shm+=I\n    set noruler\n    set noshowcmd\n\n    func CmdCompl(a, b, c)\n      return repeat(['aaaa'], 120)\n    endfunc\n    command -nargs=* -complete=customlist,CmdCompl Tcmd\n\n    func MyStatusLine() abort\n      return 'status'\n    endfunc\n    func SetupStatusline()\n      set statusline=%!MyStatusLine()\n      set laststatus=2\n    endfunc\n\n    func MyTabLine()\n      return 'my tab line'\n    endfunc\n    func SetupTabline()\n      set statusline=\n      set tabline=%!MyTabLine()\n      set showtabline=2\n    endfunc\n\n    func DoFeedKeys()\n      let &wildcharm = char2nr(\"\\t\")\n      call feedkeys(\":edit $VIMRUNTIME/\\<Tab>\\<Left>\\<C-U>ab\\<Tab>\")\n    endfunc\n  [CODE]\n  call writefile(commands, 'Xtest', 'D')\n\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n\n  call term_sendkeys(buf, \":sign \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_01', {})\n\n  \" going down the popup menu using <Down>\n  call term_sendkeys(buf, \"\\<Down>\\<Down>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_02', {})\n\n  \" going down the popup menu using <C-N>\n  call term_sendkeys(buf, \"\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_03', {})\n\n  \" going up the popup menu using <C-P>\n  call term_sendkeys(buf, \"\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_04', {})\n\n  \" going up the popup menu using <Up>\n  call term_sendkeys(buf, \"\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_05', {})\n\n  \" pressing <C-E> should end completion and go back to the original match\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_06', {})\n\n  \" pressing <C-Y> should select the current match and end completion\n  call term_sendkeys(buf, \"\\<Tab>\\<C-P>\\<C-P>\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_07', {})\n\n  \" With 'wildmode' set to 'longest,full', completing a match should display\n  \" the longest match, the wildmenu should not be displayed.\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=longest,full\\<CR>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":sign u\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_08', {})\n\n  \" pressing <Tab> should display the wildmenu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_09', {})\n\n  \" pressing <Tab> second time should select the next entry in the menu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_10', {})\n\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=full\\<CR>\")\n  \" showing popup menu in different columns in the cmdline\n  call term_sendkeys(buf, \":sign define \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_11', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_12', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_13', {})\n\n  \" Directory name completion\n  call mkdir('Xnamedir/XdirA/XdirB', 'pR')\n  call writefile([], 'Xnamedir/XfileA')\n  call writefile([], 'Xnamedir/XdirA/XfileB')\n  call writefile([], 'Xnamedir/XdirA/XdirB/XfileC')\n\n  call term_sendkeys(buf, \"\\<C-U>e Xnamedi\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_14', {})\n\n  \" Pressing <Right> on a directory name should go into that directory\n  call term_sendkeys(buf, \"\\<Right>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_15', {})\n\n  \" Pressing <Left> on a directory name should go to the parent directory\n  call term_sendkeys(buf, \"\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_16', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches but the popup menu should still remain\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-A>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_17', {})\n\n  \" Pressing <C-D> when the popup menu is displayed should remove the popup\n  \" menu\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-D>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_18', {})\n\n  \" Pressing <S-Tab> should open the popup menu with the last entry selected\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<S-Tab>\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_19', {})\n\n  \" Pressing <Esc> should close the popup menu and cancel the cmd line\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<Tab>\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_20', {})\n\n  \" Typing a character when the popup is open, should close the popup\n  call term_sendkeys(buf, \":sign \\<Tab>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_21', {})\n\n  \" When the popup is open, entering the cmdline window should close the popup\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-F>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_22', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n\n  \" After the last popup menu item, <C-N> should show the original string\n  call term_sendkeys(buf, \":sign u\\<Tab>\\<C-N>\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_23', {})\n\n  \" Use the popup menu for the command name\n  call term_sendkeys(buf, \"\\<C-U>bu\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_24', {})\n\n  \" Pressing the left arrow should remove the popup menu\n  call term_sendkeys(buf, \"\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_25', {})\n\n  \" Pressing <BS> should remove the popup menu and erase the last character\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_26', {})\n\n  \" Pressing <C-W> should remove the popup menu and erase the previous word\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-W>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_27', {})\n\n  \" Pressing <C-U> should remove the popup menu and erase the entire line\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-U>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_28', {})\n\n  \" Using <C-E> to cancel the popup menu and then pressing <Up> should recall\n  \" the cmdline from history\n  call term_sendkeys(buf, \"sign xyz\\<Esc>:sign \\<Tab>\\<C-E>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_29', {})\n\n  \" Check \"list\" still works\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=longest,list\\<CR>\")\n  call term_sendkeys(buf, \":cn\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_30', {})\n  call term_sendkeys(buf, \"s\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_31', {})\n\n  \" Tests a directory name contained full-width characters.\n  call mkdir('Xnamedir/\u3042\u3044\u3046', 'p')\n  call writefile([], 'Xnamedir/\u3042\u3044\u3046/abc')\n  call writefile([], 'Xnamedir/\u3042\u3044\u3046/xyz')\n  call writefile([], 'Xnamedir/\u3042\u3044\u3046/123')\n\n  call term_sendkeys(buf, \"\\<C-U>set wildmode&\\<CR>\")\n  call term_sendkeys(buf, \":\\<C-U>e Xnamedir/\u3042\u3044\u3046/\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_32', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing a key after that should remove the popup menu\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=full\\<CR>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_33', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing <Left> after that should move the cursor\n  call term_sendkeys(buf, \"\\<C-U>abc\\<Esc>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_34', {})\n\n  \" When <C-A> displays a lot of matches (screen scrolls), all the matches\n  \" should be displayed correctly on the screen.\n  call term_sendkeys(buf, \"\\<End>\\<C-U>Tcmd \\<Tab>\\<C-A>\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_35', {})\n\n  \" After using <C-A> to expand all the filename matches, pressing <Up>\n  \" should not open the popup menu again.\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd Xnamedir/XdirA\\<CR>\")\n  call term_sendkeys(buf, \":e \\<Tab>\\<C-A>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_36', {})\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd -\\<CR>\")\n\n  \" After using <C-A> to expand all the matches, pressing <S-Tab> used to\n  \" crash Vim\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<S-Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_37', {})\n\n  \" After removing the pum the command line is redrawn\n  call term_sendkeys(buf, \":edit foo\\<CR>\")\n  call term_sendkeys(buf, \":edit bar\\<CR>\")\n  call term_sendkeys(buf, \":ls\\<CR>\")\n  call term_sendkeys(buf, \":com\\<Tab> \")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_38', {})\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n\n  \" Esc still works to abort the command when 'statusline' is set\n  call term_sendkeys(buf, \":call SetupStatusline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_39', {})\n\n  \" Esc still works to abort the command when 'tabline' is set\n  call term_sendkeys(buf, \":call SetupTabline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_40', {})\n\n  \" popup is cleared also when 'lazyredraw' is set\n  call term_sendkeys(buf, \":set showtabline=1 laststatus=1 lazyredraw\\<CR>\")\n  call term_sendkeys(buf, \":call DoFeedKeys()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_41', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Pressing <PageDown> should scroll the menu downward\n  call term_sendkeys(buf, \":sign \\<Tab>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_42', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_43', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_44', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_45', {})\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<Down>\\<Down>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_46', {})\n\n  \" Pressing <PageUp> should scroll the menu upward\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_47', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_48', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_49', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_50', {})\n\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for wildmenumode() with the cmdline popup menu\nfunc Test_wildmenumode_with_pum()\n  set wildmenu\n  set wildoptions=pum\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":sign \\<Tab>\\<F2>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define10', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-A>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define jump list place undefine unplace0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-E>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign 0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-Y>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define0', @:)\n  set nowildmenu wildoptions&\n  cunmap <F2>\nendfunc\n\nfunc Test_wildmenu_with_pum_foldexpr()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      call setline(1, ['folded one', 'folded two', 'some more text'])\n      func MyFoldText()\n        return 'foo'\n      endfunc\n      set foldtext=MyFoldText() wildoptions=pum\n      normal ggzfj\n  END\n  call writefile(lines, 'Xpumfold', 'D')\n  let buf = RunVimInTerminal('-S Xpumfold', #{rows: 10})\n  call term_sendkeys(buf, \":set\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for opening the cmdline completion popup menu from the terminal window.\n\" The popup menu should be positioned correctly over the status line of the\n\" bottom-most window.\nfunc Test_wildmenu_pum_from_terminal()\n  CheckRunVimInTerminal\n  let python = PythonProg()\n  call CheckPython(python)\n\n  %bw!\n  let cmds = ['set wildmenu wildoptions=pum']\n  let pcmd = python .. ' -c \"import sys; sys.stdout.write(sys.stdin.read())\"'\n  call add(cmds, \"call term_start('\" .. pcmd .. \"')\")\n  call writefile(cmds, 'Xtest', 'D')\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n  call term_sendkeys(buf, \"\\r\\r\\r\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \"\\<C-W>:sign \\<Tab>\")\n  call term_wait(buf)\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_term_01', {})\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_wildmenu_pum_clear_entries()\n  CheckRunVimInTerminal\n\n  \" This was using freed memory.  Run in a terminal to get the pum to update.\n  let lines =<< trim END\n    set wildoptions=pum\n    set wildchar=<C-E>\n  END\n  call writefile(lines, 'XwildmenuTest', 'D')\n  let buf = RunVimInTerminal('-S XwildmenuTest', #{rows: 10})\n\n  call term_sendkeys(buf, \":\\<C-E>\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_clear_entries_1', {})\n\n  set wildoptions& wildchar&\nendfunc\n\n\" Test for completion after a :substitute command followed by a pipe (|)\n\" character\nfunc Test_cmdline_complete_substitute()\n  call feedkeys(\":s | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s | \\t\", @:)\n  call feedkeys(\":s/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/ | \\t\", @:)\n  call feedkeys(\":s/one | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one | \\t\", @:)\n  call feedkeys(\":s/one/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/ | \\t\", @:)\n  call feedkeys(\":s/one/two | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two | \\t\", @:)\n  call feedkeys(\":s/one/two/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/two/ | chistory', @:)\n  call feedkeys(\":s/one/two/g \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g \\t\", @:)\n  call feedkeys(\":s/one/two/g | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g | chistory\", @:)\n  call feedkeys(\":s/one/t\\\\/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/t\\\\/ | \\t\", @:)\n  call feedkeys(\":s/one/t\\\"o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t\"o/ | chistory', @:)\n  call feedkeys(\":s/one/t|o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t|o/ | chistory', @:)\n  call feedkeys(\":&\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"&\\t\", @:)\nendfunc\n\n\" Test for the :dlist command completion\nfunc Test_cmdline_complete_dlist()\n  call feedkeys(\":dlist 10 /pat/ a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ a\\<C-A>\", @:)\n  call feedkeys(\":dlist 10 /pat/ \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ \\t\", @:)\n  call feedkeys(\":dlist 10 /pa\\\\t/\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pa\\\\t/\\t\", @:)\n  call feedkeys(\":dlist 10 /pat\\\\\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat\\\\\\t\", @:)\n  call feedkeys(\":dlist 10 /pat/ | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ | chistory\", @:)\nendfunc\n\n\" argument list (only for :argdel) fuzzy completion\nfunc Test_fuzzy_completion_arglist()\n  argadd change.py count.py charge.py\n  set wildoptions&\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel cge', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel change.py charge.py', @:)\n  %argdelete\n  set wildoptions&\nendfunc\n\n\" autocmd group name fuzzy completion\nfunc Test_fuzzy_completion_autocmd()\n  set wildoptions&\n  augroup MyFuzzyGroup\n  augroup END\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup mfg', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup My*p', @:)\n  augroup! MyFuzzyGroup\n  set wildoptions&\nendfunc\n\n\" buffer name fuzzy completion\nfunc Test_fuzzy_completion_bufname()\n  set wildoptions&\n  \" Use a long name to reduce the risk of matching a random directory name\n  edit SomeRandomFileWithLetters.txt\n  enew\n  call feedkeys(\":b SRFWL\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SRFWL', @:)\n  call feedkeys(\":b S*FileWithLetters.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeRandomFileWithLetters.txt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b SRFWL\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeRandomFileWithLetters.txt', @:)\n  call feedkeys(\":b S*FileWithLetters.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b S*FileWithLetters.txt', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" buffer name (full path) fuzzy completion\nfunc Test_fuzzy_completion_bufname_fullpath()\n  CheckUnix\n  set wildoptions&\n  call mkdir('Xcmd/Xstate/Xfile.js', 'pR')\n  edit Xcmd/Xstate/Xfile.js\n  cd Xcmd/Xstate\n  enew\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b CmdStateFile', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('Xcmd/Xstate/Xfile.js$', @:)\n  cd -\n  set wildoptions&\nendfunc\n\n\" :behave suboptions fuzzy completion\nfunc Test_fuzzy_completion_behave()\n  set wildoptions&\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xt*m', @:)\n  let g:Sline = ''\n  call feedkeys(\":behave win\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('mswin', g:Sline)\n  call assert_equal('\"behave win', @:)\n  set wildoptions&\nendfunc\n\n\" \" colorscheme name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_colorscheme()\n\" endfunc\n\n\" built-in command name fuzzy completion\nfunc Test_fuzzy_completion_cmdname()\n  set wildoptions&\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbwin', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbr*d', @:)\n  set wildoptions&\nendfunc\n\n\" \" compiler name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_compiler()\n\" endfunc\n\n\" :cscope suboptions fuzzy completion\nfunc Test_fuzzy_completion_cscope()\n  CheckFeature cscope\n  set wildoptions&\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope ret', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope re*t', @:)\n  set wildoptions&\nendfunc\n\n\" :diffget/:diffput buffer name fuzzy completion\nfunc Test_fuzzy_completion_diff()\n  new SomeBuffer\n  diffthis\n  new OtherBuffer\n  diffthis\n  set wildoptions&\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget sbuf', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput sbuf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget SomeBuffer', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput SomeBuffer', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" \" directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_dirname()\n\" endfunc\n\n\" environment variable name fuzzy completion\nfunc Test_fuzzy_completion_env()\n  set wildoptions&\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VUT', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VIMRUNTIME', @:)\n  set wildoptions&\nendfunc\n\n\" autocmd event fuzzy completion\nfunc Test_fuzzy_completion_autocmd_event()\n  set wildoptions&\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BWout', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BufWipeout', @:)\n  set wildoptions&\nendfunc\n\n\" vim expression fuzzy completion\nfunc Test_fuzzy_completion_expr()\n  let g:PerPlaceCount = 10\n  set wildoptions&\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = ppc', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = PerPlaceCount', @:)\n  set wildoptions&\nendfunc\n\n\" \" file name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filename()\n\" endfunc\n\n\" \" files in path fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filesinpath()\n\" endfunc\n\n\" \" filetype name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filetype()\n\" endfunc\n\n\" user defined function name completion\nfunc Test_fuzzy_completion_userdefined_func()\n  set wildoptions&\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_f_u_f', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_fuzzy_completion_userdefined_func()', @:)\n  set wildoptions&\nendfunc\n\n\" <SNR> functions should be sorted to the end\nfunc Test_fuzzy_completion_userdefined_snr_func()\n  func s:Sendmail()\n  endfunc\n  func SendSomemail()\n  endfunc\n  func S1e2n3dmail()\n  endfunc\n  set wildoptions=fuzzy\n  call feedkeys(\":call sendmail\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"call SendSomemail() S1e2n3dmail() <SNR>\\d\\+_Sendmail()', @:)\n  set wildoptions&\n  delfunc s:Sendmail\n  delfunc SendSomemail\n  delfunc S1e2n3dmail\nendfunc\n\n\" user defined command name completion\nfunc Test_fuzzy_completion_userdefined_cmd()\n  set wildoptions&\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MsFeat', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MissingFeature', @:)\n  set wildoptions&\nendfunc\n\n\" \" :help tag fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_helptag()\n\" endfunc\n\n\" highlight group name fuzzy completion\nfunc Test_fuzzy_completion_hlgroup()\n  set wildoptions&\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight Sp*Key', @:)\n  set wildoptions&\nendfunc\n\n\" :history suboptions fuzzy completion\nfunc Test_fuzzy_completion_history()\n  set wildoptions&\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history dg', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history search', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history debug', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history se*h', @:)\n  set wildoptions&\nendfunc\n\n\" :language locale name fuzzy completion\nfunc Test_fuzzy_completion_lang()\n  CheckUnix\n  set wildoptions&\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang psx', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang POSIX', @:)\n  set wildoptions&\nendfunc\n\n\" :mapclear buffer argument fuzzy completion\nfunc Test_fuzzy_completion_mapclear()\n  set wildoptions&\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear buf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear <buffer>', @:)\n  set wildoptions&\nendfunc\n\n\" map name fuzzy completion\nfunc Test_fuzzy_completion_mapname()\n  \" test regex completion works\n  set wildoptions=fuzzy\n  call feedkeys(\":cnoremap <ex\\<Tab> <esc> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"cnoremap <expr> <esc> \\<Tab>\", @:)\n  nmap <plug>MyLongMap :p<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  call feedkeys(\":nmap MLM \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap MLM \\t\", @:)\n  call feedkeys(\":nmap <F2> one two \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <F2> one two \\t\", @:)\n  \" duplicate entries should be removed\n  vmap <plug>MyLongMap :<C-U>#<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  nunmap <plug>MyLongMap\n  vunmap <plug>MyLongMap\n  call feedkeys(\":nmap ABC\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap ABC\\t\", @:)\n  \" results should be sorted by best match\n  nmap <Plug>format :\n  nmap <Plug>goformat :\n  nmap <Plug>TestFOrmat :\n  nmap <Plug>fendoff :\n  nmap <Plug>state :\n  nmap <Plug>FendingOff :\n  call feedkeys(\":nmap <Plug>fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>format <Plug>TestFOrmat <Plug>FendingOff <Plug>goformat <Plug>fendoff\", @:)\n  nunmap <Plug>format\n  nunmap <Plug>goformat\n  nunmap <Plug>TestFOrmat\n  nunmap <Plug>fendoff\n  nunmap <Plug>state\n  nunmap <Plug>FendingOff\n  set wildoptions&\nendfunc\n\n\" abbreviation fuzzy completion\nfunc Test_fuzzy_completion_abbr()\n  set wildoptions=fuzzy\n  call feedkeys(\":iabbr wait\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr <nowait>\", @:)\n  iabbr WaitForCompletion WFC\n  call feedkeys(\":iabbr fcl\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr WaitForCompletion\", @:)\n  call feedkeys(\":iabbr a1z\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr a1z\\t\", @:)\n  iunabbrev WaitForCompletion\n  set wildoptions&\nendfunc\n\n\" menu name fuzzy completion\nfunc Test_fuzzy_completion_menu()\n  CheckGui\n  set wildoptions&\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu pup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu PopUp.', @:)\n  set wildoptions&\nendfunc\n\n\" :messages suboptions fuzzy completion\nfunc Test_fuzzy_completion_messages()\n  set wildoptions&\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clear', @:)\n  set wildoptions&\nendfunc\n\n\" :set option name fuzzy completion\nfunc Test_fuzzy_completion_option()\n  set wildoptions&\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set brkopt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set breakindentopt', @:)\n  set wildoptions&\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions&\nendfunc\n\n\" :set <term_option>\nfunc Test_fuzzy_completion_term_option()\n  set wildoptions&\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions&\nendfunc\n\n\" \" :packadd directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_packadd()\n\" endfunc\n\n\" \" shell command name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_shellcmd()\n\" endfunc\n\n\" :sign suboptions fuzzy completion\nfunc Test_fuzzy_completion_sign()\n  set wildoptions&\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign ufe', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign undefine', @:)\n  set wildoptions&\nendfunc\n\n\" :syntax suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntax_cmd()\n  set wildoptions&\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax kwd', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax keyword', @:)\n  set wildoptions&\nendfunc\n\n\" syntax group name fuzzy completion\nfunc Test_fuzzy_completion_syntax_group()\n  set wildoptions&\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list mpar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list MatchParen', @:)\n  set wildoptions&\nendfunc\n\n\" :syntime suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntime()\n  CheckFeature profile\n  set wildoptions&\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clear', @:)\n  set wildoptions&\nendfunc\n\n\" \" tag name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagname()\n\" endfunc\n\n\" \" tag name and file fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagfile()\n\" endfunc\n\n\" \" user names fuzzy completion - how to test this functionality?\n\" func Test_fuzzy_completion_username()\n\" endfunc\n\n\" user defined variable name fuzzy completion\nfunc Test_fuzzy_completion_userdefined_var()\n  let g:SomeVariable=10\n  set wildoptions&\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SVar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SomeVariable', @:)\n  set wildoptions&\nendfunc\n\n\" Test for sorting the results by the best match\nfunc Test_fuzzy_completion_cmd_sort_results()\n  %bw!\n  command T123format :\n  command T123goformat :\n  command T123TestFOrmat :\n  command T123fendoff :\n  command T123state :\n  command T123FendingOff :\n  set wildoptions=fuzzy\n  call feedkeys(\":T123fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"T123format T123TestFOrmat T123FendingOff T123goformat T123fendoff', @:)\n  delcommand T123format\n  delcommand T123goformat\n  delcommand T123TestFOrmat\n  delcommand T123fendoff\n  delcommand T123state\n  delcommand T123FendingOff\n  %bw\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion of a command with lower case letters and a number\nfunc Test_fuzzy_completion_cmd_alnum()\n  command Foo2Bar :\n  set wildoptions=fuzzy\n  call feedkeys(\":foo2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":foo\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":bar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  delcommand Foo2Bar\n  set wildoptions&\nendfunc\n\n\" Test for command completion for a command starting with 'k'\nfunc Test_fuzzy_completion_cmd_k()\n  command KillKillKill :\n  set wildoptions&\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"killkill\\<Tab>\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"KillKillKill', @:)\n  delcom KillKillKill\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion for user defined custom completion function\nfunc Test_fuzzy_completion_custom_func()\n  func Tcompl(a, c, p)\n    return \"format\\ngoformat\\nTestFOrmat\\nfendoff\\nstate\"\n  endfunc\n  command -nargs=* -complete=custom,Tcompl Fuzzy :\n  set wildoptions&\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy ttt\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":Fuzzy \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format goformat TestFOrmat fendoff state\", @:)\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format TestFOrmat goformat fendoff\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy TestFOrmat\", @:)\n  delcom Fuzzy\n  set wildoptions&\nendfunc\n\n\" Test for :breakadd argument completion\nfunc Test_cmdline_complete_breakadd()\n  call feedkeys(\":breakadd \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr file func here\", @:)\n  call feedkeys(\":breakadd \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr\", @:)\n  call feedkeys(\":breakadd    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr\", @:)\n  call feedkeys(\":breakadd he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here\", @:)\n  call feedkeys(\":breakadd    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    here\", @:)\n  call feedkeys(\":breakadd abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd abc\", @:)\n  call assert_equal(['expr', 'file', 'func', 'here'], getcompletion('', 'breakpoint'))\n  let l = getcompletion('not', 'breakpoint')\n  call assert_equal([], l)\n\n  \" Test for :breakadd file [lnum] <file>\n  call writefile([], 'Xscript', 'D')\n  call feedkeys(\":breakadd file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript\", @:)\n  call feedkeys(\":breakadd   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   Xscript\", @:)\n  call feedkeys(\":breakadd file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20 Xscript\", @:)\n  call feedkeys(\":breakadd   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   20   Xscript\", @:)\n  call feedkeys(\":breakadd file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakadd file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20\\t\", @:)\n  call feedkeys(\":breakadd file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x\\t\", @:)\n  call feedkeys(\":breakadd file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript  \", @:)\n  call feedkeys(\":breakadd file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file X1B2C3\", @:)\n\n  \" Test for :breakadd func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakadd func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func\", @:)\n  call feedkeys(\":breakadd    func    Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    func    Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakadd   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakadd func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20\\t\", @:)\n  call feedkeys(\":breakadd func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x\\t\", @:)\n  call feedkeys(\":breakadd func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func  \", @:)\n  call feedkeys(\":breakadd func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakadd expr <expression>\n  let g:Xtest_var = 10\n  call feedkeys(\":breakadd expr Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var\", @:)\n  call feedkeys(\":breakadd    expr    Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr    Xtest_var\", @:)\n  call feedkeys(\":breakadd expr Xtest_var  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var  \", @:)\n  call feedkeys(\":breakadd expr X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr X1B2C3\", @:)\n  unlet g:Xtest_var\n\n  \" Test for :breakadd here\n  call feedkeys(\":breakadd here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here Xtest\", @:)\n  call feedkeys(\":breakadd   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   here   Xtest\", @:)\n  call feedkeys(\":breakadd here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here \", @:)\nendfunc\n\n\" Test for :breakdel argument completion\nfunc Test_cmdline_complete_breakdel()\n  call feedkeys(\":breakdel \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file func here\", @:)\n  call feedkeys(\":breakdel \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file\", @:)\n  call feedkeys(\":breakdel    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    file\", @:)\n  call feedkeys(\":breakdel he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here\", @:)\n  call feedkeys(\":breakdel    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    here\", @:)\n  call feedkeys(\":breakdel abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel abc\", @:)\n\n  \" Test for :breakdel file [lnum] <file>\n  call writefile([], 'Xscript', 'D')\n  call feedkeys(\":breakdel file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript\", @:)\n  call feedkeys(\":breakdel   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   Xscript\", @:)\n  call feedkeys(\":breakdel file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20 Xscript\", @:)\n  call feedkeys(\":breakdel   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   20   Xscript\", @:)\n  call feedkeys(\":breakdel file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakdel file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20\\t\", @:)\n  call feedkeys(\":breakdel file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x\\t\", @:)\n  call feedkeys(\":breakdel file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript  \", @:)\n  call feedkeys(\":breakdel file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file X1B2C3\", @:)\n\n  \" Test for :breakdel func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakdel func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakdel func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20\\t\", @:)\n  call feedkeys(\":breakdel func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x\\t\", @:)\n  call feedkeys(\":breakdel func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func  \", @:)\n  call feedkeys(\":breakdel func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakdel here\n  call feedkeys(\":breakdel here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here Xtest\", @:)\n  call feedkeys(\":breakdel   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   here   Xtest\", @:)\n  call feedkeys(\":breakdel here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here \", @:)\nendfunc\n\n\" Test for :scriptnames argument completion\nfunc Test_cmdline_complete_scriptnames()\n  set wildmenu\n  call writefile(['let a = 1'], 'Xa1b2c3.vim', 'D')\n  source Xa1b2c3.vim\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script    \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script b2c3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script b2c3\", @:)\n  call feedkeys(\":script 2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script 2\\<Tab>$\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim $\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script \", @:)\n  call assert_match('Xa1b2c3.vim$', getcompletion('.*Xa1b2.*', 'scriptnames')[0])\n  call assert_equal([], getcompletion('Xa1b2', 'scriptnames'))\n  new\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('Xa1b2c3.vim', fnamemodify(@%, ':t'))\n  bw!\n  set wildmenu&\nendfunc\n\n\" this was going over the end of IObuff\nfunc Test_report_error_with_composing()\n  let caught = 'no'\n  try\n    exe repeat('0', 987) .. \"0\\xdd\\x80\\xdd\\x80\\xdd\\x80\\xdd\\x80\"\n  catch /E492:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\n\" Test for expanding 2-letter and 3-letter :substitute command arguments.\n\" These commands don't accept an argument.\nfunc Test_cmdline_complete_substitute_short()\n  for cmd in ['sc', 'sce', 'scg', 'sci', 'scI', 'scn', 'scp', 'scl',\n        \\ 'sgc', 'sge', 'sg', 'sgi', 'sgI', 'sgn', 'sgp', 'sgl', 'sgr',\n        \\ 'sic', 'sie', 'si', 'siI', 'sin', 'sip', 'sir',\n        \\ 'sIc', 'sIe', 'sIg', 'sIi', 'sI', 'sIn', 'sIp', 'sIl', 'sIr',\n        \\ 'src', 'srg', 'sri', 'srI', 'srn', 'srp', 'srl', 'sr']\n    call feedkeys(':' .. cmd .. \" \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"' .. cmd .. \" \\<Tab>\", @:)\n  endfor\nendfunc\n\n\" Test for :! shell command argument completion\nfunc Test_cmdline_complete_bang_cmd_argument()\n  set wildoptions=fuzzy\n  call feedkeys(\":!vim test_cmdline.\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"!vim test_cmdline.vim', @:)\n  set wildoptions&\n  call feedkeys(\":!vim test_cmdline.\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"!vim test_cmdline.vim', @:)\nendfunc\n\nfunc Check_completion()\n  call assert_equal('let a', getcmdline())\n  call assert_equal(6, getcmdpos())\n  call assert_equal(7, getcmdscreenpos())\n  call assert_equal('var', getcmdcompltype())\n  return ''\nendfunc\n\nfunc Test_screenpos_and_completion()\n  call feedkeys(\":let a\\<C-R>=Check_completion()\\<CR>\\<Esc>\", \"xt\")\nendfunc\n\nfunc Test_recursive_register()\n  let @= = ''\n  silent! ?\u001ce\u0012/\n  let caught = 'no'\n  try\n    normal /\u0012/ \n  catch /E169:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\nfunc Test_long_error_message()\n  \" the error should be truncated, not overrun IObuff\n  silent! norm Q00000000000000\u00a0\u00a0\u00a0\u00a0\u00a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nendfunc\n\nfunc Test_cmdline_redraw_tabline()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      set showtabline=2\n      autocmd CmdlineEnter * set tabline=foo\n  END\n  call writefile(lines, 'Xcmdline_redraw_tabline', 'D')\n  let buf = RunVimInTerminal('-S Xcmdline_redraw_tabline', #{rows: 6})\n  call term_sendkeys(buf, ':')\n  call WaitForAssert({-> assert_match('^foo', term_getline(buf, 1))})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_wildmenu_pum_disable_while_shown()\n  set wildoptions=pum\n  set wildmenu\n  cnoremap <F2> <Cmd>set nowildmenu<CR>\n  call feedkeys(\":sign \\<Tab>\\<F2>\\<Esc>\", 'tx')\n  call assert_equal(0, pumvisible())\n  cunmap <F2>\n  set wildoptions& wildmenu&\nendfunc\n\nfunc Test_setcmdline()\n  func SetText(text, pos)\n    autocmd CmdlineChanged * let g:cmdtype = expand('<afile>')\n    call assert_equal(0, setcmdline(a:text))\n    call assert_equal(a:text, getcmdline())\n    call assert_equal(len(a:text) + 1, getcmdpos())\n    call assert_equal(getcmdtype(), g:cmdtype)\n    unlet g:cmdtype\n    autocmd! CmdlineChanged\n\n    call assert_equal(0, setcmdline(a:text, a:pos))\n    call assert_equal(a:text, getcmdline())\n    call assert_equal(a:pos, getcmdpos())\n\n    call assert_fails('call setcmdline(\"' .. a:text .. '\", -1)', 'E487:')\n    call assert_fails('call setcmdline({}, 0)', 'E1174:')\n    call assert_fails('call setcmdline(\"' .. a:text .. '\", {})', 'E1210:')\n\n    return ''\n  endfunc\n\n  call feedkeys(\":\\<C-R>=SetText('set rtp?', 2)\\<CR>\\<CR>\", 'xt')\n  call assert_equal('set rtp?', @:)\n\n  call feedkeys(\":let g:str = input('? ')\\<CR>\", 't')\n  call feedkeys(\"\\<C-R>=SetText('foo', 4)\\<CR>\\<CR>\", 'xt')\n  call assert_equal('foo', g:str)\n  unlet g:str\n\n  delfunc SetText\n\n  \" setcmdline() returns 1 when not editing the command line.\n  call assert_equal(1, 'foo'->setcmdline())\n\n  \" Called in custom function\n  func CustomComplete(A, L, P)\n    call assert_equal(0, setcmdline(\"DoCmd \"))\n    return \"January\\nFebruary\\nMars\\n\"\n  endfunc\n\n  com! -nargs=* -complete=custom,CustomComplete DoCmd :\n  call feedkeys(\":DoCmd \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"DoCmd January February Mars', @:)\n  delcom DoCmd\n  delfunc CustomComplete\n\n  \" Called in <expr>\n  cnoremap <expr>a setcmdline('let foo=')\n  call feedkeys(\":a\\<CR>\", 'tx')\n  call assert_equal('let foo=0', @:)\n  cunmap a\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/message.c", "src/proto/strings.pro", "src/strings.c", "src/testdir/test_cmdline.vim", "src/version.c"], "buggy_code_start_loc": [3058, 14, 527, 654, 697], "buggy_code_end_loc": [3059, 14, 586, 654, 697], "fixing_code_start_loc": [3058, 15, 528, 655, 698], "fixing_code_end_loc": [3060, 16, 599, 666, 700], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1144.", "other": {"cve": {"id": "CVE-2023-0051", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-04T18:15:09.287", "lastModified": "2023-05-03T12:16:43.637", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1144."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1144", "matchCriteriaId": "0350CD80-58F9-4C55-A48A-1F46BBB22DEA"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2023/Mar/17", "source": "security@huntr.dev"}, {"url": "https://github.com/vim/vim/commit/c32949b0779106ed5710ae3bffc5053e49083ab4", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1c8686db-baa6-42dc-ba45-aed322802de9", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213670", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/c32949b0779106ed5710ae3bffc5053e49083ab4"}}