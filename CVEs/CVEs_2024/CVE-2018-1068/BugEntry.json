{"buggy_code": ["/*\n *  ebtables\n *\n *  Author:\n *  Bart De Schuymer\t\t<bdschuym@pandora.be>\n *\n *  ebtables.c,v 2.0, July, 2002\n *\n *  This code is strongly inspired by the iptables code which is\n *  Copyright (C) 1999 Paul `Rusty' Russell & Michael J. Neuling\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License\n *  as published by the Free Software Foundation; either version\n *  2 of the License, or (at your option) any later version.\n */\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/smp.h>\n#include <linux/cpumask.h>\n#include <linux/audit.h>\n#include <net/sock.h>\n/* needed for logical [in,out]-dev filtering */\n#include \"../br_private.h\"\n\n#define BUGPRINT(format, args...) printk(\"kernel msg: ebtables bug: please \"\\\n\t\t\t\t\t \"report to author: \"format, ## args)\n/* #define BUGPRINT(format, args...) */\n\n/* Each cpu has its own set of counters, so there is no need for write_lock in\n * the softirq\n * For reading or updating the counters, the user context needs to\n * get a write_lock\n */\n\n/* The size of each set of counters is altered to get cache alignment */\n#define SMP_ALIGN(x) (((x) + SMP_CACHE_BYTES-1) & ~(SMP_CACHE_BYTES-1))\n#define COUNTER_OFFSET(n) (SMP_ALIGN(n * sizeof(struct ebt_counter)))\n#define COUNTER_BASE(c, n, cpu) ((struct ebt_counter *)(((char *)c) + \\\n\t\t\t\t COUNTER_OFFSET(n) * cpu))\n\n\n\nstatic DEFINE_MUTEX(ebt_mutex);\n\n#ifdef CONFIG_COMPAT\nstatic void ebt_standard_compat_from_user(void *dst, const void *src)\n{\n\tint v = *(compat_int_t *)src;\n\n\tif (v >= 0)\n\t\tv += xt_compat_calc_jump(NFPROTO_BRIDGE, v);\n\tmemcpy(dst, &v, sizeof(v));\n}\n\nstatic int ebt_standard_compat_to_user(void __user *dst, const void *src)\n{\n\tcompat_int_t cv = *(int *)src;\n\n\tif (cv >= 0)\n\t\tcv -= xt_compat_calc_jump(NFPROTO_BRIDGE, cv);\n\treturn copy_to_user(dst, &cv, sizeof(cv)) ? -EFAULT : 0;\n}\n#endif\n\n\nstatic struct xt_target ebt_standard_target = {\n\t.name       = \"standard\",\n\t.revision   = 0,\n\t.family     = NFPROTO_BRIDGE,\n\t.targetsize = sizeof(int),\n#ifdef CONFIG_COMPAT\n\t.compatsize = sizeof(compat_int_t),\n\t.compat_from_user = ebt_standard_compat_from_user,\n\t.compat_to_user =  ebt_standard_compat_to_user,\n#endif\n};\n\nstatic inline int\nebt_do_watcher(const struct ebt_entry_watcher *w, struct sk_buff *skb,\n\t       struct xt_action_param *par)\n{\n\tpar->target   = w->u.watcher;\n\tpar->targinfo = w->data;\n\tw->u.watcher->target(skb, par);\n\t/* watchers don't give a verdict */\n\treturn 0;\n}\n\nstatic inline int\nebt_do_match(struct ebt_entry_match *m, const struct sk_buff *skb,\n\t     struct xt_action_param *par)\n{\n\tpar->match     = m->u.match;\n\tpar->matchinfo = m->data;\n\treturn m->u.match->match(skb, par) ? EBT_MATCH : EBT_NOMATCH;\n}\n\nstatic inline int\nebt_dev_check(const char *entry, const struct net_device *device)\n{\n\tint i = 0;\n\tconst char *devname;\n\n\tif (*entry == '\\0')\n\t\treturn 0;\n\tif (!device)\n\t\treturn 1;\n\tdevname = device->name;\n\t/* 1 is the wildcard token */\n\twhile (entry[i] != '\\0' && entry[i] != 1 && entry[i] == devname[i])\n\t\ti++;\n\treturn devname[i] != entry[i] && entry[i] != 1;\n}\n\n/* process standard matches */\nstatic inline int\nebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\n\t\tconst struct net_device *in, const struct net_device *out)\n{\n\tconst struct ethhdr *h = eth_hdr(skb);\n\tconst struct net_bridge_port *p;\n\t__be16 ethproto;\n\n\tif (skb_vlan_tag_present(skb))\n\t\tethproto = htons(ETH_P_8021Q);\n\telse\n\t\tethproto = h->h_proto;\n\n\tif (e->bitmask & EBT_802_3) {\n\t\tif (NF_INVF(e, EBT_IPROTO, eth_proto_is_802_3(ethproto)))\n\t\t\treturn 1;\n\t} else if (!(e->bitmask & EBT_NOPROTO) &&\n\t\t   NF_INVF(e, EBT_IPROTO, e->ethproto != ethproto))\n\t\treturn 1;\n\n\tif (NF_INVF(e, EBT_IIN, ebt_dev_check(e->in, in)))\n\t\treturn 1;\n\tif (NF_INVF(e, EBT_IOUT, ebt_dev_check(e->out, out)))\n\t\treturn 1;\n\t/* rcu_read_lock()ed by nf_hook_thresh */\n\tif (in && (p = br_port_get_rcu(in)) != NULL &&\n\t    NF_INVF(e, EBT_ILOGICALIN,\n\t\t    ebt_dev_check(e->logical_in, p->br->dev)))\n\t\treturn 1;\n\tif (out && (p = br_port_get_rcu(out)) != NULL &&\n\t    NF_INVF(e, EBT_ILOGICALOUT,\n\t\t    ebt_dev_check(e->logical_out, p->br->dev)))\n\t\treturn 1;\n\n\tif (e->bitmask & EBT_SOURCEMAC) {\n\t\tif (NF_INVF(e, EBT_ISOURCE,\n\t\t\t    !ether_addr_equal_masked(h->h_source, e->sourcemac,\n\t\t\t\t\t\t     e->sourcemsk)))\n\t\t\treturn 1;\n\t}\n\tif (e->bitmask & EBT_DESTMAC) {\n\t\tif (NF_INVF(e, EBT_IDEST,\n\t\t\t    !ether_addr_equal_masked(h->h_dest, e->destmac,\n\t\t\t\t\t\t     e->destmsk)))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline\nstruct ebt_entry *ebt_next_entry(const struct ebt_entry *entry)\n{\n\treturn (void *)entry + entry->next_offset;\n}\n\n/* Do some firewalling */\nunsigned int ebt_do_table(struct sk_buff *skb,\n\t\t\t  const struct nf_hook_state *state,\n\t\t\t  struct ebt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tint i, nentries;\n\tstruct ebt_entry *point;\n\tstruct ebt_counter *counter_base, *cb_base;\n\tconst struct ebt_entry_target *t;\n\tint verdict, sp = 0;\n\tstruct ebt_chainstack *cs;\n\tstruct ebt_entries *chaininfo;\n\tconst char *base;\n\tconst struct ebt_table_info *private;\n\tstruct xt_action_param acpar;\n\n\tacpar.state   = state;\n\tacpar.hotdrop = false;\n\n\tread_lock_bh(&table->lock);\n\tprivate = table->private;\n\tcb_base = COUNTER_BASE(private->counters, private->nentries,\n\t   smp_processor_id());\n\tif (private->chainstack)\n\t\tcs = private->chainstack[smp_processor_id()];\n\telse\n\t\tcs = NULL;\n\tchaininfo = private->hook_entry[hook];\n\tnentries = private->hook_entry[hook]->nentries;\n\tpoint = (struct ebt_entry *)(private->hook_entry[hook]->data);\n\tcounter_base = cb_base + private->hook_entry[hook]->counter_offset;\n\t/* base for chain jumps */\n\tbase = private->entries;\n\ti = 0;\n\twhile (i < nentries) {\n\t\tif (ebt_basic_match(point, skb, state->in, state->out))\n\t\t\tgoto letscontinue;\n\n\t\tif (EBT_MATCH_ITERATE(point, ebt_do_match, skb, &acpar) != 0)\n\t\t\tgoto letscontinue;\n\t\tif (acpar.hotdrop) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\t/* increase counter */\n\t\t(*(counter_base + i)).pcnt++;\n\t\t(*(counter_base + i)).bcnt += skb->len;\n\n\t\t/* these should only watch: not modify, nor tell us\n\t\t * what to do with the packet\n\t\t */\n\t\tEBT_WATCHER_ITERATE(point, ebt_do_watcher, skb, &acpar);\n\n\t\tt = (struct ebt_entry_target *)\n\t\t   (((char *)point) + point->target_offset);\n\t\t/* standard target */\n\t\tif (!t->u.target->target)\n\t\t\tverdict = ((struct ebt_standard_target *)t)->verdict;\n\t\telse {\n\t\t\tacpar.target   = t->u.target;\n\t\t\tacpar.targinfo = t->data;\n\t\t\tverdict = t->u.target->target(skb, &acpar);\n\t\t}\n\t\tif (verdict == EBT_ACCEPT) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_ACCEPT;\n\t\t}\n\t\tif (verdict == EBT_DROP) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\t\tif (verdict == EBT_RETURN) {\nletsreturn:\n\t\t\tif (WARN(sp == 0, \"RETURN on base chain\")) {\n\t\t\t\t/* act like this is EBT_CONTINUE */\n\t\t\t\tgoto letscontinue;\n\t\t\t}\n\n\t\t\tsp--;\n\t\t\t/* put all the local variables right */\n\t\t\ti = cs[sp].n;\n\t\t\tchaininfo = cs[sp].chaininfo;\n\t\t\tnentries = chaininfo->nentries;\n\t\t\tpoint = cs[sp].e;\n\t\t\tcounter_base = cb_base +\n\t\t\t   chaininfo->counter_offset;\n\t\t\tcontinue;\n\t\t}\n\t\tif (verdict == EBT_CONTINUE)\n\t\t\tgoto letscontinue;\n\n\t\tif (WARN(verdict < 0, \"bogus standard verdict\\n\")) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\t/* jump to a udc */\n\t\tcs[sp].n = i + 1;\n\t\tcs[sp].chaininfo = chaininfo;\n\t\tcs[sp].e = ebt_next_entry(point);\n\t\ti = 0;\n\t\tchaininfo = (struct ebt_entries *) (base + verdict);\n\n\t\tif (WARN(chaininfo->distinguisher, \"jump to non-chain\\n\")) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\tnentries = chaininfo->nentries;\n\t\tpoint = (struct ebt_entry *)chaininfo->data;\n\t\tcounter_base = cb_base + chaininfo->counter_offset;\n\t\tsp++;\n\t\tcontinue;\nletscontinue:\n\t\tpoint = ebt_next_entry(point);\n\t\ti++;\n\t}\n\n\t/* I actually like this :) */\n\tif (chaininfo->policy == EBT_RETURN)\n\t\tgoto letsreturn;\n\tif (chaininfo->policy == EBT_ACCEPT) {\n\t\tread_unlock_bh(&table->lock);\n\t\treturn NF_ACCEPT;\n\t}\n\tread_unlock_bh(&table->lock);\n\treturn NF_DROP;\n}\n\n/* If it succeeds, returns element and locks mutex */\nstatic inline void *\nfind_inlist_lock_noload(struct list_head *head, const char *name, int *error,\n\t\t\tstruct mutex *mutex)\n{\n\tstruct {\n\t\tstruct list_head list;\n\t\tchar name[EBT_FUNCTION_MAXNAMELEN];\n\t} *e;\n\n\tmutex_lock(mutex);\n\tlist_for_each_entry(e, head, list) {\n\t\tif (strcmp(e->name, name) == 0)\n\t\t\treturn e;\n\t}\n\t*error = -ENOENT;\n\tmutex_unlock(mutex);\n\treturn NULL;\n}\n\nstatic void *\nfind_inlist_lock(struct list_head *head, const char *name, const char *prefix,\n\t\t int *error, struct mutex *mutex)\n{\n\treturn try_then_request_module(\n\t\t\tfind_inlist_lock_noload(head, name, error, mutex),\n\t\t\t\"%s%s\", prefix, name);\n}\n\nstatic inline struct ebt_table *\nfind_table_lock(struct net *net, const char *name, int *error,\n\t\tstruct mutex *mutex)\n{\n\treturn find_inlist_lock(&net->xt.tables[NFPROTO_BRIDGE], name,\n\t\t\t\t\"ebtable_\", error, mutex);\n}\n\nstatic inline int\nebt_check_match(struct ebt_entry_match *m, struct xt_mtchk_param *par,\n\t\tunsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_match *match;\n\tsize_t left = ((char *)e + e->watchers_offset) - (char *)m;\n\tint ret;\n\n\tif (left < sizeof(struct ebt_entry_match) ||\n\t    left - sizeof(struct ebt_entry_match) < m->match_size)\n\t\treturn -EINVAL;\n\n\tmatch = xt_find_match(NFPROTO_BRIDGE, m->u.name, 0);\n\tif (IS_ERR(match) || match->family != NFPROTO_BRIDGE) {\n\t\tif (!IS_ERR(match))\n\t\t\tmodule_put(match->me);\n\t\trequest_module(\"ebt_%s\", m->u.name);\n\t\tmatch = xt_find_match(NFPROTO_BRIDGE, m->u.name, 0);\n\t}\n\tif (IS_ERR(match))\n\t\treturn PTR_ERR(match);\n\tm->u.match = match;\n\n\tpar->match     = match;\n\tpar->matchinfo = m->data;\n\tret = xt_check_match(par, m->match_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(match->me);\n\t\treturn ret;\n\t}\n\n\t(*cnt)++;\n\treturn 0;\n}\n\nstatic inline int\nebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,\n\t\t  unsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_target *watcher;\n\tsize_t left = ((char *)e + e->target_offset) - (char *)w;\n\tint ret;\n\n\tif (left < sizeof(struct ebt_entry_watcher) ||\n\t   left - sizeof(struct ebt_entry_watcher) < w->watcher_size)\n\t\treturn -EINVAL;\n\n\twatcher = xt_request_find_target(NFPROTO_BRIDGE, w->u.name, 0);\n\tif (IS_ERR(watcher))\n\t\treturn PTR_ERR(watcher);\n\tw->u.watcher = watcher;\n\n\tpar->target   = watcher;\n\tpar->targinfo = w->data;\n\tret = xt_check_target(par, w->watcher_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(watcher->me);\n\t\treturn ret;\n\t}\n\n\t(*cnt)++;\n\treturn 0;\n}\n\nstatic int ebt_verify_pointers(const struct ebt_replace *repl,\n\t\t\t       struct ebt_table_info *newinfo)\n{\n\tunsigned int limit = repl->entries_size;\n\tunsigned int valid_hooks = repl->valid_hooks;\n\tunsigned int offset = 0;\n\tint i;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++)\n\t\tnewinfo->hook_entry[i] = NULL;\n\n\tnewinfo->entries_size = repl->entries_size;\n\tnewinfo->nentries = repl->nentries;\n\n\twhile (offset < limit) {\n\t\tsize_t left = limit - offset;\n\t\tstruct ebt_entry *e = (void *)newinfo->entries + offset;\n\n\t\tif (left < sizeof(unsigned int))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\t\tif ((valid_hooks & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((char __user *)repl->hook_entry[i] ==\n\t\t\t     repl->entries + offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i != NF_BR_NUMHOOKS || !(e->bitmask & EBT_ENTRY_OR_ENTRIES)) {\n\t\t\tif (e->bitmask != 0) {\n\t\t\t\t/* we make userspace set this right,\n\t\t\t\t * so there is no misunderstanding\n\t\t\t\t */\n\t\t\t\tBUGPRINT(\"EBT_ENTRY_OR_ENTRIES shouldn't be set \"\n\t\t\t\t\t \"in distinguisher\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (i != NF_BR_NUMHOOKS)\n\t\t\t\tnewinfo->hook_entry[i] = (struct ebt_entries *)e;\n\t\t\tif (left < sizeof(struct ebt_entries))\n\t\t\t\tbreak;\n\t\t\toffset += sizeof(struct ebt_entries);\n\t\t} else {\n\t\t\tif (left < sizeof(struct ebt_entry))\n\t\t\t\tbreak;\n\t\t\tif (left < e->next_offset)\n\t\t\t\tbreak;\n\t\t\tif (e->next_offset < sizeof(struct ebt_entry))\n\t\t\t\treturn -EINVAL;\n\t\t\toffset += e->next_offset;\n\t\t}\n\t}\n\tif (offset != limit) {\n\t\tBUGPRINT(\"entries_size too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if all valid hooks have a chain */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (!newinfo->hook_entry[i] &&\n\t\t   (valid_hooks & (1 << i))) {\n\t\t\tBUGPRINT(\"Valid hook without chain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* this one is very careful, as it is the first function\n * to parse the userspace data\n */\nstatic inline int\nebt_check_entry_size_and_hooks(const struct ebt_entry *e,\n\t\t\t       const struct ebt_table_info *newinfo,\n\t\t\t       unsigned int *n, unsigned int *cnt,\n\t\t\t       unsigned int *totalcnt, unsigned int *udc_cnt)\n{\n\tint i;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif ((void *)e == (void *)newinfo->hook_entry[i])\n\t\t\tbreak;\n\t}\n\t/* beginning of a new chain\n\t * if i == NF_BR_NUMHOOKS it must be a user defined chain\n\t */\n\tif (i != NF_BR_NUMHOOKS || !e->bitmask) {\n\t\t/* this checks if the previous chain has as many entries\n\t\t * as it said it has\n\t\t */\n\t\tif (*n != *cnt) {\n\t\t\tBUGPRINT(\"nentries does not equal the nr of entries \"\n\t\t\t\t \"in the chain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (((struct ebt_entries *)e)->policy != EBT_DROP &&\n\t\t   ((struct ebt_entries *)e)->policy != EBT_ACCEPT) {\n\t\t\t/* only RETURN from udc */\n\t\t\tif (i != NF_BR_NUMHOOKS ||\n\t\t\t   ((struct ebt_entries *)e)->policy != EBT_RETURN) {\n\t\t\t\tBUGPRINT(\"bad policy\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (i == NF_BR_NUMHOOKS) /* it's a user defined chain */\n\t\t\t(*udc_cnt)++;\n\t\tif (((struct ebt_entries *)e)->counter_offset != *totalcnt) {\n\t\t\tBUGPRINT(\"counter_offset != totalcnt\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*n = ((struct ebt_entries *)e)->nentries;\n\t\t*cnt = 0;\n\t\treturn 0;\n\t}\n\t/* a plain old entry, heh */\n\tif (sizeof(struct ebt_entry) > e->watchers_offset ||\n\t   e->watchers_offset > e->target_offset ||\n\t   e->target_offset >= e->next_offset) {\n\t\tBUGPRINT(\"entry offsets not in right order\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* this is not checked anywhere else */\n\tif (e->next_offset - e->target_offset < sizeof(struct ebt_entry_target)) {\n\t\tBUGPRINT(\"target size too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\t(*cnt)++;\n\t(*totalcnt)++;\n\treturn 0;\n}\n\nstruct ebt_cl_stack {\n\tstruct ebt_chainstack cs;\n\tint from;\n\tunsigned int hookmask;\n};\n\n/* We need these positions to check that the jumps to a different part of the\n * entries is a jump to the beginning of a new chain.\n */\nstatic inline int\nebt_get_udc_positions(struct ebt_entry *e, struct ebt_table_info *newinfo,\n\t\t      unsigned int *n, struct ebt_cl_stack *udc)\n{\n\tint i;\n\n\t/* we're only interested in chain starts */\n\tif (e->bitmask)\n\t\treturn 0;\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (newinfo->hook_entry[i] == (struct ebt_entries *)e)\n\t\t\tbreak;\n\t}\n\t/* only care about udc */\n\tif (i != NF_BR_NUMHOOKS)\n\t\treturn 0;\n\n\tudc[*n].cs.chaininfo = (struct ebt_entries *)e;\n\t/* these initialisations are depended on later in check_chainloops() */\n\tudc[*n].cs.n = 0;\n\tudc[*n].hookmask = 0;\n\n\t(*n)++;\n\treturn 0;\n}\n\nstatic inline int\nebt_cleanup_match(struct ebt_entry_match *m, struct net *net, unsigned int *i)\n{\n\tstruct xt_mtdtor_param par;\n\n\tif (i && (*i)-- == 0)\n\t\treturn 1;\n\n\tpar.net       = net;\n\tpar.match     = m->u.match;\n\tpar.matchinfo = m->data;\n\tpar.family    = NFPROTO_BRIDGE;\n\tif (par.match->destroy != NULL)\n\t\tpar.match->destroy(&par);\n\tmodule_put(par.match->me);\n\treturn 0;\n}\n\nstatic inline int\nebt_cleanup_watcher(struct ebt_entry_watcher *w, struct net *net, unsigned int *i)\n{\n\tstruct xt_tgdtor_param par;\n\n\tif (i && (*i)-- == 0)\n\t\treturn 1;\n\n\tpar.net      = net;\n\tpar.target   = w->u.watcher;\n\tpar.targinfo = w->data;\n\tpar.family   = NFPROTO_BRIDGE;\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\tmodule_put(par.target->me);\n\treturn 0;\n}\n\nstatic inline int\nebt_cleanup_entry(struct ebt_entry *e, struct net *net, unsigned int *cnt)\n{\n\tstruct xt_tgdtor_param par;\n\tstruct ebt_entry_target *t;\n\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\t/* we're done */\n\tif (cnt && (*cnt)-- == 0)\n\t\treturn 1;\n\tEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, NULL);\n\tEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, NULL);\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\n\tpar.net      = net;\n\tpar.target   = t->u.target;\n\tpar.targinfo = t->data;\n\tpar.family   = NFPROTO_BRIDGE;\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\tmodule_put(par.target->me);\n\treturn 0;\n}\n\nstatic inline int\nebt_check_entry(struct ebt_entry *e, struct net *net,\n\t\tconst struct ebt_table_info *newinfo,\n\t\tconst char *name, unsigned int *cnt,\n\t\tstruct ebt_cl_stack *cl_s, unsigned int udc_cnt)\n{\n\tstruct ebt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int i, j, hook = 0, hookmask = 0;\n\tsize_t gap;\n\tint ret;\n\tstruct xt_mtchk_param mtpar;\n\tstruct xt_tgchk_param tgpar;\n\n\t/* don't mess with the struct ebt_entries */\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\n\tif (e->bitmask & ~EBT_F_MASK) {\n\t\tBUGPRINT(\"Unknown flag for bitmask\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (e->invflags & ~EBT_INV_MASK) {\n\t\tBUGPRINT(\"Unknown flag for inv bitmask\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((e->bitmask & EBT_NOPROTO) && (e->bitmask & EBT_802_3)) {\n\t\tBUGPRINT(\"NOPROTO & 802_3 not allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* what hook do we belong to? */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (!newinfo->hook_entry[i])\n\t\t\tcontinue;\n\t\tif ((char *)newinfo->hook_entry[i] < (char *)e)\n\t\t\thook = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/* (1 << NF_BR_NUMHOOKS) tells the check functions the rule is on\n\t * a base chain\n\t */\n\tif (i < NF_BR_NUMHOOKS)\n\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\telse {\n\t\tfor (i = 0; i < udc_cnt; i++)\n\t\t\tif ((char *)(cl_s[i].cs.chaininfo) > (char *)e)\n\t\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\t\telse\n\t\t\thookmask = cl_s[i - 1].hookmask;\n\t}\n\ti = 0;\n\n\tmtpar.net\t= tgpar.net       = net;\n\tmtpar.table     = tgpar.table     = name;\n\tmtpar.entryinfo = tgpar.entryinfo = e;\n\tmtpar.hook_mask = tgpar.hook_mask = hookmask;\n\tmtpar.family    = tgpar.family    = NFPROTO_BRIDGE;\n\tret = EBT_MATCH_ITERATE(e, ebt_check_match, &mtpar, &i);\n\tif (ret != 0)\n\t\tgoto cleanup_matches;\n\tj = 0;\n\tret = EBT_WATCHER_ITERATE(e, ebt_check_watcher, &tgpar, &j);\n\tif (ret != 0)\n\t\tgoto cleanup_watchers;\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\tgap = e->next_offset - e->target_offset;\n\n\ttarget = xt_request_find_target(NFPROTO_BRIDGE, t->u.name, 0);\n\tif (IS_ERR(target)) {\n\t\tret = PTR_ERR(target);\n\t\tgoto cleanup_watchers;\n\t}\n\n\tt->u.target = target;\n\tif (t->u.target == &ebt_standard_target) {\n\t\tif (gap < sizeof(struct ebt_standard_target)) {\n\t\t\tBUGPRINT(\"Standard target size too big\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t\tif (((struct ebt_standard_target *)t)->verdict <\n\t\t   -NUM_STANDARD_TARGETS) {\n\t\t\tBUGPRINT(\"Invalid standard target\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t} else if (t->target_size > gap - sizeof(struct ebt_entry_target)) {\n\t\tmodule_put(t->u.target->me);\n\t\tret = -EFAULT;\n\t\tgoto cleanup_watchers;\n\t}\n\n\ttgpar.target   = target;\n\ttgpar.targinfo = t->data;\n\tret = xt_check_target(&tgpar, t->target_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(target->me);\n\t\tgoto cleanup_watchers;\n\t}\n\t(*cnt)++;\n\treturn 0;\ncleanup_watchers:\n\tEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, &j);\ncleanup_matches:\n\tEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, &i);\n\treturn ret;\n}\n\n/* checks for loops and sets the hook mask for udc\n * the hook mask for udc tells us from which base chains the udc can be\n * accessed. This mask is a parameter to the check() functions of the extensions\n */\nstatic int check_chainloops(const struct ebt_entries *chain, struct ebt_cl_stack *cl_s,\n\t\t\t    unsigned int udc_cnt, unsigned int hooknr, char *base)\n{\n\tint i, chain_nr = -1, pos = 0, nentries = chain->nentries, verdict;\n\tconst struct ebt_entry *e = (struct ebt_entry *)chain->data;\n\tconst struct ebt_entry_target *t;\n\n\twhile (pos < nentries || chain_nr != -1) {\n\t\t/* end of udc, go back one 'recursion' step */\n\t\tif (pos == nentries) {\n\t\t\t/* put back values of the time when this chain was called */\n\t\t\te = cl_s[chain_nr].cs.e;\n\t\t\tif (cl_s[chain_nr].from != -1)\n\t\t\t\tnentries =\n\t\t\t\tcl_s[cl_s[chain_nr].from].cs.chaininfo->nentries;\n\t\t\telse\n\t\t\t\tnentries = chain->nentries;\n\t\t\tpos = cl_s[chain_nr].cs.n;\n\t\t\t/* make sure we won't see a loop that isn't one */\n\t\t\tcl_s[chain_nr].cs.n = 0;\n\t\t\tchain_nr = cl_s[chain_nr].from;\n\t\t\tif (pos == nentries)\n\t\t\t\tcontinue;\n\t\t}\n\t\tt = (struct ebt_entry_target *)\n\t\t   (((char *)e) + e->target_offset);\n\t\tif (strcmp(t->u.name, EBT_STANDARD_TARGET))\n\t\t\tgoto letscontinue;\n\t\tif (e->target_offset + sizeof(struct ebt_standard_target) >\n\t\t   e->next_offset) {\n\t\t\tBUGPRINT(\"Standard target size too big\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tverdict = ((struct ebt_standard_target *)t)->verdict;\n\t\tif (verdict >= 0) { /* jump to another chain */\n\t\t\tstruct ebt_entries *hlp2 =\n\t\t\t   (struct ebt_entries *)(base + verdict);\n\t\t\tfor (i = 0; i < udc_cnt; i++)\n\t\t\t\tif (hlp2 == cl_s[i].cs.chaininfo)\n\t\t\t\t\tbreak;\n\t\t\t/* bad destination or loop */\n\t\t\tif (i == udc_cnt) {\n\t\t\t\tBUGPRINT(\"bad destination\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (cl_s[i].cs.n) {\n\t\t\t\tBUGPRINT(\"loop\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (cl_s[i].hookmask & (1 << hooknr))\n\t\t\t\tgoto letscontinue;\n\t\t\t/* this can't be 0, so the loop test is correct */\n\t\t\tcl_s[i].cs.n = pos + 1;\n\t\t\tpos = 0;\n\t\t\tcl_s[i].cs.e = ebt_next_entry(e);\n\t\t\te = (struct ebt_entry *)(hlp2->data);\n\t\t\tnentries = hlp2->nentries;\n\t\t\tcl_s[i].from = chain_nr;\n\t\t\tchain_nr = i;\n\t\t\t/* this udc is accessible from the base chain for hooknr */\n\t\t\tcl_s[i].hookmask |= (1 << hooknr);\n\t\t\tcontinue;\n\t\t}\nletscontinue:\n\t\te = ebt_next_entry(e);\n\t\tpos++;\n\t}\n\treturn 0;\n}\n\n/* do the parsing of the table/chains/entries/matches/watchers/targets, heh */\nstatic int translate_table(struct net *net, const char *name,\n\t\t\t   struct ebt_table_info *newinfo)\n{\n\tunsigned int i, j, k, udc_cnt;\n\tint ret;\n\tstruct ebt_cl_stack *cl_s = NULL; /* used in the checking for chain loops */\n\n\ti = 0;\n\twhile (i < NF_BR_NUMHOOKS && !newinfo->hook_entry[i])\n\t\ti++;\n\tif (i == NF_BR_NUMHOOKS) {\n\t\tBUGPRINT(\"No valid hooks specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (newinfo->hook_entry[i] != (struct ebt_entries *)newinfo->entries) {\n\t\tBUGPRINT(\"Chains don't start at beginning\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* make sure chains are ordered after each other in same order\n\t * as their corresponding hooks\n\t */\n\tfor (j = i + 1; j < NF_BR_NUMHOOKS; j++) {\n\t\tif (!newinfo->hook_entry[j])\n\t\t\tcontinue;\n\t\tif (newinfo->hook_entry[j] <= newinfo->hook_entry[i]) {\n\t\t\tBUGPRINT(\"Hook order must be followed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti = j;\n\t}\n\n\t/* do some early checkings and initialize some things */\n\ti = 0; /* holds the expected nr. of entries for the chain */\n\tj = 0; /* holds the up to now counted entries for the chain */\n\tk = 0; /* holds the total nr. of entries, should equal\n\t\t* newinfo->nentries afterwards\n\t\t*/\n\tudc_cnt = 0; /* will hold the nr. of user defined chains (udc) */\n\tret = EBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t   ebt_check_entry_size_and_hooks, newinfo,\n\t   &i, &j, &k, &udc_cnt);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (i != j) {\n\t\tBUGPRINT(\"nentries does not equal the nr of entries in the \"\n\t\t\t \"(last) chain\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (k != newinfo->nentries) {\n\t\tBUGPRINT(\"Total nentries is wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* get the location of the udc, put them in an array\n\t * while we're at it, allocate the chainstack\n\t */\n\tif (udc_cnt) {\n\t\t/* this will get free'd in do_replace()/ebt_register_table()\n\t\t * if an error occurs\n\t\t */\n\t\tnewinfo->chainstack =\n\t\t\tvmalloc(nr_cpu_ids * sizeof(*(newinfo->chainstack)));\n\t\tif (!newinfo->chainstack)\n\t\t\treturn -ENOMEM;\n\t\tfor_each_possible_cpu(i) {\n\t\t\tnewinfo->chainstack[i] =\n\t\t\t  vmalloc(udc_cnt * sizeof(*(newinfo->chainstack[0])));\n\t\t\tif (!newinfo->chainstack[i]) {\n\t\t\t\twhile (i)\n\t\t\t\t\tvfree(newinfo->chainstack[--i]);\n\t\t\t\tvfree(newinfo->chainstack);\n\t\t\t\tnewinfo->chainstack = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tcl_s = vmalloc(udc_cnt * sizeof(*cl_s));\n\t\tif (!cl_s)\n\t\t\treturn -ENOMEM;\n\t\ti = 0; /* the i'th udc */\n\t\tEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t\t   ebt_get_udc_positions, newinfo, &i, cl_s);\n\t\t/* sanity check */\n\t\tif (i != udc_cnt) {\n\t\t\tBUGPRINT(\"i != udc_cnt\\n\");\n\t\t\tvfree(cl_s);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\t/* Check for loops */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++)\n\t\tif (newinfo->hook_entry[i])\n\t\t\tif (check_chainloops(newinfo->hook_entry[i],\n\t\t\t   cl_s, udc_cnt, i, newinfo->entries)) {\n\t\t\t\tvfree(cl_s);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t/* we now know the following (along with E=mc\u00b2):\n\t *  - the nr of entries in each chain is right\n\t *  - the size of the allocated space is right\n\t *  - all valid hooks have a corresponding chain\n\t *  - there are no loops\n\t *  - wrong data can still be on the level of a single entry\n\t *  - could be there are jumps to places that are not the\n\t *    beginning of a chain. This can only occur in chains that\n\t *    are not accessible from any base chains, so we don't care.\n\t */\n\n\t/* used to know what we need to clean up if something goes wrong */\n\ti = 0;\n\tret = EBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t   ebt_check_entry, net, newinfo, name, &i, cl_s, udc_cnt);\n\tif (ret != 0) {\n\t\tEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t\t\t\t  ebt_cleanup_entry, net, &i);\n\t}\n\tvfree(cl_s);\n\treturn ret;\n}\n\n/* called under write_lock */\nstatic void get_counters(const struct ebt_counter *oldcounters,\n\t\t\t struct ebt_counter *counters, unsigned int nentries)\n{\n\tint i, cpu;\n\tstruct ebt_counter *counter_base;\n\n\t/* counters of cpu 0 */\n\tmemcpy(counters, oldcounters,\n\t       sizeof(struct ebt_counter) * nentries);\n\n\t/* add other counters to those of cpu 0 */\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == 0)\n\t\t\tcontinue;\n\t\tcounter_base = COUNTER_BASE(oldcounters, nentries, cpu);\n\t\tfor (i = 0; i < nentries; i++) {\n\t\t\tcounters[i].pcnt += counter_base[i].pcnt;\n\t\t\tcounters[i].bcnt += counter_base[i].bcnt;\n\t\t}\n\t}\n}\n\nstatic int do_replace_finish(struct net *net, struct ebt_replace *repl,\n\t\t\t      struct ebt_table_info *newinfo)\n{\n\tint ret, i;\n\tstruct ebt_counter *counterstmp = NULL;\n\t/* used to be able to unlock earlier */\n\tstruct ebt_table_info *table;\n\tstruct ebt_table *t;\n\n\t/* the user wants counters back\n\t * the check on the size is done later, when we have the lock\n\t */\n\tif (repl->num_counters) {\n\t\tunsigned long size = repl->num_counters * sizeof(*counterstmp);\n\t\tcounterstmp = vmalloc(size);\n\t\tif (!counterstmp)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tnewinfo->chainstack = NULL;\n\tret = ebt_verify_pointers(repl, newinfo);\n\tif (ret != 0)\n\t\tgoto free_counterstmp;\n\n\tret = translate_table(net, repl->name, newinfo);\n\n\tif (ret != 0)\n\t\tgoto free_counterstmp;\n\n\tt = find_table_lock(net, repl->name, &ret, &ebt_mutex);\n\tif (!t) {\n\t\tret = -ENOENT;\n\t\tgoto free_iterate;\n\t}\n\n\t/* the table doesn't like it */\n\tif (t->check && (ret = t->check(newinfo, repl->valid_hooks)))\n\t\tgoto free_unlock;\n\n\tif (repl->num_counters && repl->num_counters != t->private->nentries) {\n\t\tBUGPRINT(\"Wrong nr. of counters requested\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_unlock;\n\t}\n\n\t/* we have the mutex lock, so no danger in reading this pointer */\n\ttable = t->private;\n\t/* make sure the table can only be rmmod'ed if it contains no rules */\n\tif (!table->nentries && newinfo->nentries && !try_module_get(t->me)) {\n\t\tret = -ENOENT;\n\t\tgoto free_unlock;\n\t} else if (table->nentries && !newinfo->nentries)\n\t\tmodule_put(t->me);\n\t/* we need an atomic snapshot of the counters */\n\twrite_lock_bh(&t->lock);\n\tif (repl->num_counters)\n\t\tget_counters(t->private->counters, counterstmp,\n\t\t   t->private->nentries);\n\n\tt->private = newinfo;\n\twrite_unlock_bh(&t->lock);\n\tmutex_unlock(&ebt_mutex);\n\t/* so, a user can change the chains while having messed up her counter\n\t * allocation. Only reason why this is done is because this way the lock\n\t * is held only once, while this doesn't bring the kernel into a\n\t * dangerous state.\n\t */\n\tif (repl->num_counters &&\n\t   copy_to_user(repl->counters, counterstmp,\n\t   repl->num_counters * sizeof(struct ebt_counter))) {\n\t\t/* Silent error, can't fail, new table is already in place */\n\t\tnet_warn_ratelimited(\"ebtables: counters copy to user failed while replacing table\\n\");\n\t}\n\n\t/* decrease module count and free resources */\n\tEBT_ENTRY_ITERATE(table->entries, table->entries_size,\n\t\t\t  ebt_cleanup_entry, net, NULL);\n\n\tvfree(table->entries);\n\tif (table->chainstack) {\n\t\tfor_each_possible_cpu(i)\n\t\t\tvfree(table->chainstack[i]);\n\t\tvfree(table->chainstack);\n\t}\n\tvfree(table);\n\n\tvfree(counterstmp);\n\n#ifdef CONFIG_AUDIT\n\tif (audit_enabled) {\n\t\taudit_log(current->audit_context, GFP_KERNEL,\n\t\t\t  AUDIT_NETFILTER_CFG,\n\t\t\t  \"table=%s family=%u entries=%u\",\n\t\t\t  repl->name, AF_BRIDGE, repl->nentries);\n\t}\n#endif\n\treturn ret;\n\nfree_unlock:\n\tmutex_unlock(&ebt_mutex);\nfree_iterate:\n\tEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t\t\t  ebt_cleanup_entry, net, NULL);\nfree_counterstmp:\n\tvfree(counterstmp);\n\t/* can be initialized in translate_table() */\n\tif (newinfo->chainstack) {\n\t\tfor_each_possible_cpu(i)\n\t\t\tvfree(newinfo->chainstack[i]);\n\t\tvfree(newinfo->chainstack);\n\t}\n\treturn ret;\n}\n\n/* replace the table */\nstatic int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* overflow check */\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\n\ttmp.name[sizeof(tmp.name) - 1] = 0;\n\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}\n\nstatic void __ebt_unregister_table(struct net *net, struct ebt_table *table)\n{\n\tint i;\n\n\tmutex_lock(&ebt_mutex);\n\tlist_del(&table->list);\n\tmutex_unlock(&ebt_mutex);\n\tEBT_ENTRY_ITERATE(table->private->entries, table->private->entries_size,\n\t\t\t  ebt_cleanup_entry, net, NULL);\n\tif (table->private->nentries)\n\t\tmodule_put(table->me);\n\tvfree(table->private->entries);\n\tif (table->private->chainstack) {\n\t\tfor_each_possible_cpu(i)\n\t\t\tvfree(table->private->chainstack[i]);\n\t\tvfree(table->private->chainstack);\n\t}\n\tvfree(table->private);\n\tkfree(table);\n}\n\nint ebt_register_table(struct net *net, const struct ebt_table *input_table,\n\t\t       const struct nf_hook_ops *ops, struct ebt_table **res)\n{\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_table *t, *table;\n\tstruct ebt_replace_kernel *repl;\n\tint ret, i, countersize;\n\tvoid *p;\n\n\tif (input_table == NULL || (repl = input_table->table) == NULL ||\n\t    repl->entries == NULL || repl->entries_size == 0 ||\n\t    repl->counters != NULL || input_table->private != NULL) {\n\t\tBUGPRINT(\"Bad table data for ebt_register_table!!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Don't add one table to multiple lists. */\n\ttable = kmemdup(input_table, sizeof(struct ebt_table), GFP_KERNEL);\n\tif (!table) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcountersize = COUNTER_OFFSET(repl->nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tret = -ENOMEM;\n\tif (!newinfo)\n\t\tgoto free_table;\n\n\tp = vmalloc(repl->entries_size);\n\tif (!p)\n\t\tgoto free_newinfo;\n\n\tmemcpy(p, repl->entries, repl->entries_size);\n\tnewinfo->entries = p;\n\n\tnewinfo->entries_size = repl->entries_size;\n\tnewinfo->nentries = repl->nentries;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\t/* fill in newinfo and parse the entries */\n\tnewinfo->chainstack = NULL;\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif ((repl->valid_hooks & (1 << i)) == 0)\n\t\t\tnewinfo->hook_entry[i] = NULL;\n\t\telse\n\t\t\tnewinfo->hook_entry[i] = p +\n\t\t\t\t((char *)repl->hook_entry[i] - repl->entries);\n\t}\n\tret = translate_table(net, repl->name, newinfo);\n\tif (ret != 0) {\n\t\tBUGPRINT(\"Translate_table failed\\n\");\n\t\tgoto free_chainstack;\n\t}\n\n\tif (table->check && table->check(newinfo, table->valid_hooks)) {\n\t\tBUGPRINT(\"The table doesn't like its own initial data, lol\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_chainstack;\n\t}\n\n\ttable->private = newinfo;\n\trwlock_init(&table->lock);\n\tmutex_lock(&ebt_mutex);\n\tlist_for_each_entry(t, &net->xt.tables[NFPROTO_BRIDGE], list) {\n\t\tif (strcmp(t->name, table->name) == 0) {\n\t\t\tret = -EEXIST;\n\t\t\tBUGPRINT(\"Table name already exists\\n\");\n\t\t\tgoto free_unlock;\n\t\t}\n\t}\n\n\t/* Hold a reference count if the chains aren't empty */\n\tif (newinfo->nentries && !try_module_get(table->me)) {\n\t\tret = -ENOENT;\n\t\tgoto free_unlock;\n\t}\n\tlist_add(&table->list, &net->xt.tables[NFPROTO_BRIDGE]);\n\tmutex_unlock(&ebt_mutex);\n\n\tWRITE_ONCE(*res, table);\n\n\tif (!ops)\n\t\treturn 0;\n\n\tret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));\n\tif (ret) {\n\t\t__ebt_unregister_table(net, table);\n\t\t*res = NULL;\n\t}\n\n\treturn ret;\nfree_unlock:\n\tmutex_unlock(&ebt_mutex);\nfree_chainstack:\n\tif (newinfo->chainstack) {\n\t\tfor_each_possible_cpu(i)\n\t\t\tvfree(newinfo->chainstack[i]);\n\t\tvfree(newinfo->chainstack);\n\t}\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\nfree_table:\n\tkfree(table);\nout:\n\treturn ret;\n}\n\nvoid ebt_unregister_table(struct net *net, struct ebt_table *table,\n\t\t\t  const struct nf_hook_ops *ops)\n{\n\tif (ops)\n\t\tnf_unregister_net_hooks(net, ops, hweight32(table->valid_hooks));\n\t__ebt_unregister_table(net, table);\n}\n\n/* userspace just supplied us with counters */\nstatic int do_update_counters(struct net *net, const char *name,\n\t\t\t\tstruct ebt_counter __user *counters,\n\t\t\t\tunsigned int num_counters,\n\t\t\t\tconst void __user *user, unsigned int len)\n{\n\tint i, ret;\n\tstruct ebt_counter *tmp;\n\tstruct ebt_table *t;\n\n\tif (num_counters == 0)\n\t\treturn -EINVAL;\n\n\ttmp = vmalloc(num_counters * sizeof(*tmp));\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tt = find_table_lock(net, name, &ret, &ebt_mutex);\n\tif (!t)\n\t\tgoto free_tmp;\n\n\tif (num_counters != t->private->nentries) {\n\t\tBUGPRINT(\"Wrong nr of counters\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unlock_mutex;\n\t}\n\n\tif (copy_from_user(tmp, counters, num_counters * sizeof(*counters))) {\n\t\tret = -EFAULT;\n\t\tgoto unlock_mutex;\n\t}\n\n\t/* we want an atomic add of the counters */\n\twrite_lock_bh(&t->lock);\n\n\t/* we add to the counters of the first cpu */\n\tfor (i = 0; i < num_counters; i++) {\n\t\tt->private->counters[i].pcnt += tmp[i].pcnt;\n\t\tt->private->counters[i].bcnt += tmp[i].bcnt;\n\t}\n\n\twrite_unlock_bh(&t->lock);\n\tret = 0;\nunlock_mutex:\n\tmutex_unlock(&ebt_mutex);\nfree_tmp:\n\tvfree(tmp);\n\treturn ret;\n}\n\nstatic int update_counters(struct net *net, const void __user *user,\n\t\t\t    unsigned int len)\n{\n\tstruct ebt_replace hlp;\n\n\tif (copy_from_user(&hlp, user, sizeof(hlp)))\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(hlp) + hlp.num_counters * sizeof(struct ebt_counter))\n\t\treturn -EINVAL;\n\n\treturn do_update_counters(net, hlp.name, hlp.counters,\n\t\t\t\thlp.num_counters, user, len);\n}\n\nstatic inline int ebt_obj_to_user(char __user *um, const char *_name,\n\t\t\t\t  const char *data, int entrysize,\n\t\t\t\t  int usersize, int datasize)\n{\n\tchar name[EBT_FUNCTION_MAXNAMELEN] = {0};\n\n\t/* ebtables expects 32 bytes long names but xt_match names are 29 bytes\n\t * long. Copy 29 bytes and fill remaining bytes with zeroes.\n\t */\n\tstrlcpy(name, _name, sizeof(name));\n\tif (copy_to_user(um, name, EBT_FUNCTION_MAXNAMELEN) ||\n\t    put_user(datasize, (int __user *)(um + EBT_FUNCTION_MAXNAMELEN)) ||\n\t    xt_data_to_user(um + entrysize, data, usersize, datasize,\n\t\t\t    XT_ALIGN(datasize)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic inline int ebt_match_to_user(const struct ebt_entry_match *m,\n\t\t\t\t    const char *base, char __user *ubase)\n{\n\treturn ebt_obj_to_user(ubase + ((char *)m - base),\n\t\t\t       m->u.match->name, m->data, sizeof(*m),\n\t\t\t       m->u.match->usersize, m->match_size);\n}\n\nstatic inline int ebt_watcher_to_user(const struct ebt_entry_watcher *w,\n\t\t\t\t      const char *base, char __user *ubase)\n{\n\treturn ebt_obj_to_user(ubase + ((char *)w - base),\n\t\t\t       w->u.watcher->name, w->data, sizeof(*w),\n\t\t\t       w->u.watcher->usersize, w->watcher_size);\n}\n\nstatic inline int ebt_entry_to_user(struct ebt_entry *e, const char *base,\n\t\t\t\t    char __user *ubase)\n{\n\tint ret;\n\tchar __user *hlp;\n\tconst struct ebt_entry_target *t;\n\n\tif (e->bitmask == 0) {\n\t\t/* special case !EBT_ENTRY_OR_ENTRIES */\n\t\tif (copy_to_user(ubase + ((char *)e - base), e,\n\t\t\t\t sizeof(struct ebt_entries)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tif (copy_to_user(ubase + ((char *)e - base), e, sizeof(*e)))\n\t\treturn -EFAULT;\n\n\thlp = ubase + (((char *)e + e->target_offset) - base);\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\n\tret = EBT_MATCH_ITERATE(e, ebt_match_to_user, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = EBT_WATCHER_ITERATE(e, ebt_watcher_to_user, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = ebt_obj_to_user(hlp, t->u.target->name, t->data, sizeof(*t),\n\t\t\t      t->u.target->usersize, t->target_size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int copy_counters_to_user(struct ebt_table *t,\n\t\t\t\t const struct ebt_counter *oldcounters,\n\t\t\t\t void __user *user, unsigned int num_counters,\n\t\t\t\t unsigned int nentries)\n{\n\tstruct ebt_counter *counterstmp;\n\tint ret = 0;\n\n\t/* userspace might not need the counters */\n\tif (num_counters == 0)\n\t\treturn 0;\n\n\tif (num_counters != nentries) {\n\t\tBUGPRINT(\"Num_counters wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcounterstmp = vmalloc(nentries * sizeof(*counterstmp));\n\tif (!counterstmp)\n\t\treturn -ENOMEM;\n\n\twrite_lock_bh(&t->lock);\n\tget_counters(oldcounters, counterstmp, nentries);\n\twrite_unlock_bh(&t->lock);\n\n\tif (copy_to_user(user, counterstmp,\n\t   nentries * sizeof(struct ebt_counter)))\n\t\tret = -EFAULT;\n\tvfree(counterstmp);\n\treturn ret;\n}\n\n/* called with ebt_mutex locked */\nstatic int copy_everything_to_user(struct ebt_table *t, void __user *user,\n\t\t\t\t   const int *len, int cmd)\n{\n\tstruct ebt_replace tmp;\n\tconst struct ebt_counter *oldcounters;\n\tunsigned int entries_size, nentries;\n\tint ret;\n\tchar *entries;\n\n\tif (cmd == EBT_SO_GET_ENTRIES) {\n\t\tentries_size = t->private->entries_size;\n\t\tnentries = t->private->nentries;\n\t\tentries = t->private->entries;\n\t\toldcounters = t->private->counters;\n\t} else {\n\t\tentries_size = t->table->entries_size;\n\t\tnentries = t->table->nentries;\n\t\tentries = t->table->entries;\n\t\toldcounters = t->table->counters;\n\t}\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (*len != sizeof(struct ebt_replace) + entries_size +\n\t   (tmp.num_counters ? nentries * sizeof(struct ebt_counter) : 0))\n\t\treturn -EINVAL;\n\n\tif (tmp.nentries != nentries) {\n\t\tBUGPRINT(\"Nentries wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size != entries_size) {\n\t\tBUGPRINT(\"Wrong size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = copy_counters_to_user(t, oldcounters, tmp.counters,\n\t\t\t\t\ttmp.num_counters, nentries);\n\tif (ret)\n\t\treturn ret;\n\n\t/* set the match/watcher/target names right */\n\treturn EBT_ENTRY_ITERATE(entries, entries_size,\n\t   ebt_entry_to_user, entries, tmp.entries);\n}\n\nstatic int do_ebt_set_ctl(struct sock *sk,\n\tint cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase EBT_SO_SET_ENTRIES:\n\t\tret = do_replace(net, user, len);\n\t\tbreak;\n\tcase EBT_SO_SET_COUNTERS:\n\t\tret = update_counters(net, user, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int do_ebt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\tstruct ebt_replace tmp;\n\tstruct ebt_table *t;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\ttmp.name[sizeof(tmp.name) - 1] = '\\0';\n\n\tt = find_table_lock(net, tmp.name, &ret, &ebt_mutex);\n\tif (!t)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase EBT_SO_GET_INFO:\n\tcase EBT_SO_GET_INIT_INFO:\n\t\tif (*len != sizeof(struct ebt_replace)) {\n\t\t\tret = -EINVAL;\n\t\t\tmutex_unlock(&ebt_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tif (cmd == EBT_SO_GET_INFO) {\n\t\t\ttmp.nentries = t->private->nentries;\n\t\t\ttmp.entries_size = t->private->entries_size;\n\t\t\ttmp.valid_hooks = t->valid_hooks;\n\t\t} else {\n\t\t\ttmp.nentries = t->table->nentries;\n\t\t\ttmp.entries_size = t->table->entries_size;\n\t\t\ttmp.valid_hooks = t->table->valid_hooks;\n\t\t}\n\t\tmutex_unlock(&ebt_mutex);\n\t\tif (copy_to_user(user, &tmp, *len) != 0) {\n\t\t\tBUGPRINT(\"c2u Didn't work\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\n\tcase EBT_SO_GET_ENTRIES:\n\tcase EBT_SO_GET_INIT_ENTRIES:\n\t\tret = copy_everything_to_user(t, user, len, cmd);\n\t\tmutex_unlock(&ebt_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&ebt_mutex);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n/* 32 bit-userspace compatibility definitions. */\nstruct compat_ebt_replace {\n\tchar name[EBT_TABLE_MAXNAMELEN];\n\tcompat_uint_t valid_hooks;\n\tcompat_uint_t nentries;\n\tcompat_uint_t entries_size;\n\t/* start of the chains */\n\tcompat_uptr_t hook_entry[NF_BR_NUMHOOKS];\n\t/* nr of counters userspace expects back */\n\tcompat_uint_t num_counters;\n\t/* where the kernel will put the old counters. */\n\tcompat_uptr_t counters;\n\tcompat_uptr_t entries;\n};\n\n/* struct ebt_entry_match, _target and _watcher have same layout */\nstruct compat_ebt_entry_mwt {\n\tunion {\n\t\tchar name[EBT_FUNCTION_MAXNAMELEN];\n\t\tcompat_uptr_t ptr;\n\t} u;\n\tcompat_uint_t match_size;\n\tcompat_uint_t data[0];\n};\n\n/* account for possible padding between match_size and ->data */\nstatic int ebt_compat_entry_padsize(void)\n{\n\tBUILD_BUG_ON(XT_ALIGN(sizeof(struct ebt_entry_match)) <\n\t\t\tCOMPAT_XT_ALIGN(sizeof(struct compat_ebt_entry_mwt)));\n\treturn (int) XT_ALIGN(sizeof(struct ebt_entry_match)) -\n\t\t\tCOMPAT_XT_ALIGN(sizeof(struct compat_ebt_entry_mwt));\n}\n\nstatic int ebt_compat_match_offset(const struct xt_match *match,\n\t\t\t\t   unsigned int userlen)\n{\n\t/* ebt_among needs special handling. The kernel .matchsize is\n\t * set to -1 at registration time; at runtime an EBT_ALIGN()ed\n\t * value is expected.\n\t * Example: userspace sends 4500, ebt_among.c wants 4504.\n\t */\n\tif (unlikely(match->matchsize == -1))\n\t\treturn XT_ALIGN(userlen) - COMPAT_XT_ALIGN(userlen);\n\treturn xt_compat_match_offset(match);\n}\n\nstatic int compat_match_to_user(struct ebt_entry_match *m, void __user **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tconst struct xt_match *match = m->u.match;\n\tstruct compat_ebt_entry_mwt __user *cm = *dstptr;\n\tint off = ebt_compat_match_offset(match, m->match_size);\n\tcompat_uint_t msize = m->match_size - off;\n\n\tif (WARN_ON(off >= m->match_size))\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(cm->u.name, match->name,\n\t    strlen(match->name) + 1) || put_user(msize, &cm->match_size))\n\t\treturn -EFAULT;\n\n\tif (match->compat_to_user) {\n\t\tif (match->compat_to_user(cm->data, m->data))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (xt_data_to_user(cm->data, m->data, match->usersize, msize,\n\t\t\t\t    COMPAT_XT_ALIGN(msize)))\n\t\t\treturn -EFAULT;\n\t}\n\n\t*size -= ebt_compat_entry_padsize() + off;\n\t*dstptr = cm->data;\n\t*dstptr += msize;\n\treturn 0;\n}\n\nstatic int compat_target_to_user(struct ebt_entry_target *t,\n\t\t\t\t void __user **dstptr,\n\t\t\t\t unsigned int *size)\n{\n\tconst struct xt_target *target = t->u.target;\n\tstruct compat_ebt_entry_mwt __user *cm = *dstptr;\n\tint off = xt_compat_target_offset(target);\n\tcompat_uint_t tsize = t->target_size - off;\n\n\tif (WARN_ON(off >= t->target_size))\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(cm->u.name, target->name,\n\t    strlen(target->name) + 1) || put_user(tsize, &cm->match_size))\n\t\treturn -EFAULT;\n\n\tif (target->compat_to_user) {\n\t\tif (target->compat_to_user(cm->data, t->data))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (xt_data_to_user(cm->data, t->data, target->usersize, tsize,\n\t\t\t\t    COMPAT_XT_ALIGN(tsize)))\n\t\t\treturn -EFAULT;\n\t}\n\n\t*size -= ebt_compat_entry_padsize() + off;\n\t*dstptr = cm->data;\n\t*dstptr += tsize;\n\treturn 0;\n}\n\nstatic int compat_watcher_to_user(struct ebt_entry_watcher *w,\n\t\t\t\t  void __user **dstptr,\n\t\t\t\t  unsigned int *size)\n{\n\treturn compat_target_to_user((struct ebt_entry_target *)w,\n\t\t\t\t\t\t\tdstptr, size);\n}\n\nstatic int compat_copy_entry_to_user(struct ebt_entry *e, void __user **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tstruct ebt_entry_target *t;\n\tstruct ebt_entry __user *ce;\n\tu32 watchers_offset, target_offset, next_offset;\n\tcompat_uint_t origsize;\n\tint ret;\n\n\tif (e->bitmask == 0) {\n\t\tif (*size < sizeof(struct ebt_entries))\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(*dstptr, e, sizeof(struct ebt_entries)))\n\t\t\treturn -EFAULT;\n\n\t\t*dstptr += sizeof(struct ebt_entries);\n\t\t*size -= sizeof(struct ebt_entries);\n\t\treturn 0;\n\t}\n\n\tif (*size < sizeof(*ce))\n\t\treturn -EINVAL;\n\n\tce = *dstptr;\n\tif (copy_to_user(ce, e, sizeof(*ce)))\n\t\treturn -EFAULT;\n\n\torigsize = *size;\n\t*dstptr += sizeof(*ce);\n\n\tret = EBT_MATCH_ITERATE(e, compat_match_to_user, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\twatchers_offset = e->watchers_offset - (origsize - *size);\n\n\tret = EBT_WATCHER_ITERATE(e, compat_watcher_to_user, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\ttarget_offset = e->target_offset - (origsize - *size);\n\n\tt = (struct ebt_entry_target *) ((char *) e + e->target_offset);\n\n\tret = compat_target_to_user(t, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\tnext_offset = e->next_offset - (origsize - *size);\n\n\tif (put_user(watchers_offset, &ce->watchers_offset) ||\n\t    put_user(target_offset, &ce->target_offset) ||\n\t    put_user(next_offset, &ce->next_offset))\n\t\treturn -EFAULT;\n\n\t*size -= sizeof(*ce);\n\treturn 0;\n}\n\nstatic int compat_calc_match(struct ebt_entry_match *m, int *off)\n{\n\t*off += ebt_compat_match_offset(m->u.match, m->match_size);\n\t*off += ebt_compat_entry_padsize();\n\treturn 0;\n}\n\nstatic int compat_calc_watcher(struct ebt_entry_watcher *w, int *off)\n{\n\t*off += xt_compat_target_offset(w->u.watcher);\n\t*off += ebt_compat_entry_padsize();\n\treturn 0;\n}\n\nstatic int compat_calc_entry(const struct ebt_entry *e,\n\t\t\t     const struct ebt_table_info *info,\n\t\t\t     const void *base,\n\t\t\t     struct compat_ebt_replace *newinfo)\n{\n\tconst struct ebt_entry_target *t;\n\tunsigned int entry_offset;\n\tint off, ret, i;\n\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\n\toff = 0;\n\tentry_offset = (void *)e - base;\n\n\tEBT_MATCH_ITERATE(e, compat_calc_match, &off);\n\tEBT_WATCHER_ITERATE(e, compat_calc_watcher, &off);\n\n\tt = (const struct ebt_entry_target *) ((char *) e + e->target_offset);\n\n\toff += xt_compat_target_offset(t->u.target);\n\toff += ebt_compat_entry_padsize();\n\n\tnewinfo->entries_size -= off;\n\n\tret = xt_compat_add_offset(NFPROTO_BRIDGE, entry_offset, off);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tconst void *hookptr = info->hook_entry[i];\n\t\tif (info->hook_entry[i] &&\n\t\t    (e < (struct ebt_entry *)(base - hookptr))) {\n\t\t\tnewinfo->hook_entry[i] -= off;\n\t\t\tpr_debug(\"0x%08X -> 0x%08X\\n\",\n\t\t\t\t\tnewinfo->hook_entry[i] + off,\n\t\t\t\t\tnewinfo->hook_entry[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int compat_table_info(const struct ebt_table_info *info,\n\t\t\t     struct compat_ebt_replace *newinfo)\n{\n\tunsigned int size = info->entries_size;\n\tconst void *entries = info->entries;\n\n\tnewinfo->entries_size = size;\n\n\txt_compat_init_offsets(NFPROTO_BRIDGE, info->nentries);\n\treturn EBT_ENTRY_ITERATE(entries, size, compat_calc_entry, info,\n\t\t\t\t\t\t\tentries, newinfo);\n}\n\nstatic int compat_copy_everything_to_user(struct ebt_table *t,\n\t\t\t\t\t  void __user *user, int *len, int cmd)\n{\n\tstruct compat_ebt_replace repl, tmp;\n\tstruct ebt_counter *oldcounters;\n\tstruct ebt_table_info tinfo;\n\tint ret;\n\tvoid __user *pos;\n\n\tmemset(&tinfo, 0, sizeof(tinfo));\n\n\tif (cmd == EBT_SO_GET_ENTRIES) {\n\t\ttinfo.entries_size = t->private->entries_size;\n\t\ttinfo.nentries = t->private->nentries;\n\t\ttinfo.entries = t->private->entries;\n\t\toldcounters = t->private->counters;\n\t} else {\n\t\ttinfo.entries_size = t->table->entries_size;\n\t\ttinfo.nentries = t->table->nentries;\n\t\ttinfo.entries = t->table->entries;\n\t\toldcounters = t->table->counters;\n\t}\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (tmp.nentries != tinfo.nentries ||\n\t   (tmp.num_counters && tmp.num_counters != tinfo.nentries))\n\t\treturn -EINVAL;\n\n\tmemcpy(&repl, &tmp, sizeof(repl));\n\tif (cmd == EBT_SO_GET_ENTRIES)\n\t\tret = compat_table_info(t->private, &repl);\n\telse\n\t\tret = compat_table_info(&tinfo, &repl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*len != sizeof(tmp) + repl.entries_size +\n\t   (tmp.num_counters? tinfo.nentries * sizeof(struct ebt_counter): 0)) {\n\t\tpr_err(\"wrong size: *len %d, entries_size %u, replsz %d\\n\",\n\t\t\t\t*len, tinfo.entries_size, repl.entries_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* userspace might not need the counters */\n\tret = copy_counters_to_user(t, oldcounters, compat_ptr(tmp.counters),\n\t\t\t\t\ttmp.num_counters, tinfo.nentries);\n\tif (ret)\n\t\treturn ret;\n\n\tpos = compat_ptr(tmp.entries);\n\treturn EBT_ENTRY_ITERATE(tinfo.entries, tinfo.entries_size,\n\t\t\tcompat_copy_entry_to_user, &pos, &tmp.entries_size);\n}\n\nstruct ebt_entries_buf_state {\n\tchar *buf_kern_start;\t/* kernel buffer to copy (translated) data to */\n\tu32 buf_kern_len;\t/* total size of kernel buffer */\n\tu32 buf_kern_offset;\t/* amount of data copied so far */\n\tu32 buf_user_offset;\t/* read position in userspace buffer */\n};\n\nstatic int ebt_buf_count(struct ebt_entries_buf_state *state, unsigned int sz)\n{\n\tstate->buf_kern_offset += sz;\n\treturn state->buf_kern_offset >= sz ? 0 : -EINVAL;\n}\n\nstatic int ebt_buf_add(struct ebt_entries_buf_state *state,\n\t\t       void *data, unsigned int sz)\n{\n\tif (state->buf_kern_start == NULL)\n\t\tgoto count_only;\n\n\tif (WARN_ON(state->buf_kern_offset + sz > state->buf_kern_len))\n\t\treturn -EINVAL;\n\n\tmemcpy(state->buf_kern_start + state->buf_kern_offset, data, sz);\n\n count_only:\n\tstate->buf_user_offset += sz;\n\treturn ebt_buf_count(state, sz);\n}\n\nstatic int ebt_buf_add_pad(struct ebt_entries_buf_state *state, unsigned int sz)\n{\n\tchar *b = state->buf_kern_start;\n\n\tif (WARN_ON(b && state->buf_kern_offset > state->buf_kern_len))\n\t\treturn -EINVAL;\n\n\tif (b != NULL && sz > 0)\n\t\tmemset(b + state->buf_kern_offset, 0, sz);\n\t/* do not adjust ->buf_user_offset here, we added kernel-side padding */\n\treturn ebt_buf_count(state, sz);\n}\n\nenum compat_mwt {\n\tEBT_COMPAT_MATCH,\n\tEBT_COMPAT_WATCHER,\n\tEBT_COMPAT_TARGET,\n};\n\nstatic int compat_mtw_from_user(struct compat_ebt_entry_mwt *mwt,\n\t\t\t\tenum compat_mwt compat_mwt,\n\t\t\t\tstruct ebt_entries_buf_state *state,\n\t\t\t\tconst unsigned char *base)\n{\n\tchar name[EBT_FUNCTION_MAXNAMELEN];\n\tstruct xt_match *match;\n\tstruct xt_target *wt;\n\tvoid *dst = NULL;\n\tint off, pad = 0;\n\tunsigned int size_kern, match_size = mwt->match_size;\n\n\tstrlcpy(name, mwt->u.name, sizeof(name));\n\n\tif (state->buf_kern_start)\n\t\tdst = state->buf_kern_start + state->buf_kern_offset;\n\n\tswitch (compat_mwt) {\n\tcase EBT_COMPAT_MATCH:\n\t\tmatch = xt_request_find_match(NFPROTO_BRIDGE, name, 0);\n\t\tif (IS_ERR(match))\n\t\t\treturn PTR_ERR(match);\n\n\t\toff = ebt_compat_match_offset(match, match_size);\n\t\tif (dst) {\n\t\t\tif (match->compat_from_user)\n\t\t\t\tmatch->compat_from_user(dst, mwt->data);\n\t\t\telse\n\t\t\t\tmemcpy(dst, mwt->data, match_size);\n\t\t}\n\n\t\tsize_kern = match->matchsize;\n\t\tif (unlikely(size_kern == -1))\n\t\t\tsize_kern = match_size;\n\t\tmodule_put(match->me);\n\t\tbreak;\n\tcase EBT_COMPAT_WATCHER: /* fallthrough */\n\tcase EBT_COMPAT_TARGET:\n\t\twt = xt_request_find_target(NFPROTO_BRIDGE, name, 0);\n\t\tif (IS_ERR(wt))\n\t\t\treturn PTR_ERR(wt);\n\t\toff = xt_compat_target_offset(wt);\n\n\t\tif (dst) {\n\t\t\tif (wt->compat_from_user)\n\t\t\t\twt->compat_from_user(dst, mwt->data);\n\t\t\telse\n\t\t\t\tmemcpy(dst, mwt->data, match_size);\n\t\t}\n\n\t\tsize_kern = wt->targetsize;\n\t\tmodule_put(wt->me);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstate->buf_kern_offset += match_size + off;\n\tstate->buf_user_offset += match_size;\n\tpad = XT_ALIGN(size_kern) - size_kern;\n\n\tif (pad > 0 && dst) {\n\t\tif (WARN_ON(state->buf_kern_len <= pad))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(state->buf_kern_offset - (match_size + off) + size_kern > state->buf_kern_len - pad))\n\t\t\treturn -EINVAL;\n\t\tmemset(dst + size_kern, 0, pad);\n\t}\n\treturn off + match_size;\n}\n\n/* return size of all matches, watchers or target, including necessary\n * alignment and padding.\n */\nstatic int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\n\tif (size_left == 0)\n\t\treturn 0;\n\n\tbuf = (char *) match32;\n\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\n\t\t/* add padding before match->data (if any) */\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\n\t\tsize_left -= match32->match_size;\n\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\n\treturn growth;\n}\n\n/* called for all ebt_entry structures. */\nstatic int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,\n\t\t\t  unsigned int *total,\n\t\t\t  struct ebt_entries_buf_state *state)\n{\n\tunsigned int i, j, startoff, new_offset = 0;\n\t/* stores match/watchers/targets & offset of next struct ebt_entry: */\n\tunsigned int offsets[4];\n\tunsigned int *offsets_update = NULL;\n\tint ret;\n\tchar *buf_start;\n\n\tif (*total < sizeof(struct ebt_entries))\n\t\treturn -EINVAL;\n\n\tif (!entry->bitmask) {\n\t\t*total -= sizeof(struct ebt_entries);\n\t\treturn ebt_buf_add(state, entry, sizeof(struct ebt_entries));\n\t}\n\tif (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))\n\t\treturn -EINVAL;\n\n\tstartoff = state->buf_user_offset;\n\t/* pull in most part of ebt_entry, it does not need to be changed. */\n\tret = ebt_buf_add(state, entry,\n\t\t\toffsetof(struct ebt_entry, watchers_offset));\n\tif (ret < 0)\n\t\treturn ret;\n\n\toffsets[0] = sizeof(struct ebt_entry); /* matches come first */\n\tmemcpy(&offsets[1], &entry->watchers_offset,\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\n\tif (state->buf_kern_start) {\n\t\tbuf_start = state->buf_kern_start + state->buf_kern_offset;\n\t\toffsets_update = (unsigned int *) buf_start;\n\t}\n\tret = ebt_buf_add(state, &offsets[1],\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf_start = (char *) entry;\n\t/* 0: matches offset, always follows ebt_entry.\n\t * 1: watchers offset, from ebt_entry structure\n\t * 2: target offset, from ebt_entry structure\n\t * 3: next ebt_entry offset, from ebt_entry structure\n\t *\n\t * offsets are relative to beginning of struct ebt_entry (i.e., 0).\n\t */\n\tfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\n\t\tstruct compat_ebt_entry_mwt *match32;\n\t\tunsigned int size;\n\t\tchar *buf = buf_start + offsets[i];\n\n\t\tif (offsets[i] > offsets[j])\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t\tsize = offsets[j] - offsets[i];\n\t\tret = ebt_size_mwt(match32, size, i, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_offset += ret;\n\t\tif (offsets_update && new_offset) {\n\t\t\tpr_debug(\"change offset %d to %d\\n\",\n\t\t\t\toffsets_update[i], offsets[j] + new_offset);\n\t\t\toffsets_update[i] = offsets[j] + new_offset;\n\t\t}\n\t}\n\n\tif (state->buf_kern_start == NULL) {\n\t\tunsigned int offset = buf_start - (char *) base;\n\n\t\tret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstartoff = state->buf_user_offset - startoff;\n\n\tif (WARN_ON(*total < startoff))\n\t\treturn -EINVAL;\n\t*total -= startoff;\n\treturn 0;\n}\n\n/* repl->entries_size is the size of the ebt_entry blob in userspace.\n * It might need more memory when copied to a 64 bit kernel in case\n * userspace is 32-bit. So, first task: find out how much memory is needed.\n *\n * Called before validation is performed.\n */\nstatic int compat_copy_entries(unsigned char *data, unsigned int size_user,\n\t\t\t\tstruct ebt_entries_buf_state *state)\n{\n\tunsigned int size_remaining = size_user;\n\tint ret;\n\n\tret = EBT_ENTRY_ITERATE(data, size_user, size_entry_mwt, data,\n\t\t\t\t\t&size_remaining, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tWARN_ON(size_remaining);\n\treturn state->buf_kern_offset;\n}\n\n\nstatic int compat_copy_ebt_replace_from_user(struct ebt_replace *repl,\n\t\t\t\t\t    void __user *user, unsigned int len)\n{\n\tstruct compat_ebt_replace tmp;\n\tint i;\n\n\tif (len < sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size)\n\t\treturn -EINVAL;\n\n\tif (tmp.entries_size == 0)\n\t\treturn -EINVAL;\n\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\n\tmemcpy(repl, &tmp, offsetof(struct ebt_replace, hook_entry));\n\n\t/* starting with hook_entry, 32 vs. 64 bit structures are different */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++)\n\t\trepl->hook_entry[i] = compat_ptr(tmp.hook_entry[i]);\n\n\trepl->num_counters = tmp.num_counters;\n\trepl->counters = compat_ptr(tmp.counters);\n\trepl->entries = compat_ptr(tmp.entries);\n\treturn 0;\n}\n\nstatic int compat_do_replace(struct net *net, void __user *user,\n\t\t\t     unsigned int len)\n{\n\tint ret, i, countersize, size64;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\tstruct ebt_entries_buf_state state;\n\tvoid *entries_tmp;\n\n\tret = compat_copy_ebt_replace_from_user(&tmp, user, len);\n\tif (ret) {\n\t\t/* try real handler in case userland supplied needed padding */\n\t\tif (ret == -EINVAL && do_replace(net, user, len) == 0)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tmemset(&state, 0, sizeof(state));\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tentries_tmp = newinfo->entries;\n\n\txt_compat_lock(NFPROTO_BRIDGE);\n\n\txt_compat_init_offsets(NFPROTO_BRIDGE, tmp.nentries);\n\tret = compat_copy_entries(entries_tmp, tmp.entries_size, &state);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tpr_debug(\"tmp.entries_size %d, kern off %d, user off %d delta %d\\n\",\n\t\ttmp.entries_size, state.buf_kern_offset, state.buf_user_offset,\n\t\txt_compat_calc_jump(NFPROTO_BRIDGE, tmp.entries_size));\n\n\tsize64 = ret;\n\tnewinfo->entries = vmalloc(size64);\n\tif (!newinfo->entries) {\n\t\tvfree(entries_tmp);\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.buf_kern_start = newinfo->entries;\n\tstate.buf_kern_len = size64;\n\n\tret = compat_copy_entries(entries_tmp, tmp.entries_size, &state);\n\tif (WARN_ON(ret < 0))\n\t\tgoto out_unlock;\n\n\tvfree(entries_tmp);\n\ttmp.entries_size = size64;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tchar __user *usrptr;\n\t\tif (tmp.hook_entry[i]) {\n\t\t\tunsigned int delta;\n\t\t\tusrptr = (char __user *) tmp.hook_entry[i];\n\t\t\tdelta = usrptr - tmp.entries;\n\t\t\tusrptr += xt_compat_calc_jump(NFPROTO_BRIDGE, delta);\n\t\t\ttmp.hook_entry[i] = (struct ebt_entries __user *)usrptr;\n\t\t}\n\t}\n\n\txt_compat_flush_offsets(NFPROTO_BRIDGE);\n\txt_compat_unlock(NFPROTO_BRIDGE);\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(NFPROTO_BRIDGE);\n\txt_compat_unlock(NFPROTO_BRIDGE);\n\tgoto free_entries;\n}\n\nstatic int compat_update_counters(struct net *net, void __user *user,\n\t\t\t\t  unsigned int len)\n{\n\tstruct compat_ebt_replace hlp;\n\n\tif (copy_from_user(&hlp, user, sizeof(hlp)))\n\t\treturn -EFAULT;\n\n\t/* try real handler in case userland supplied needed padding */\n\tif (len != sizeof(hlp) + hlp.num_counters * sizeof(struct ebt_counter))\n\t\treturn update_counters(net, user, len);\n\n\treturn do_update_counters(net, hlp.name, compat_ptr(hlp.counters),\n\t\t\t\t\thlp.num_counters, user, len);\n}\n\nstatic int compat_do_ebt_set_ctl(struct sock *sk,\n\t\tint cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase EBT_SO_SET_ENTRIES:\n\t\tret = compat_do_replace(net, user, len);\n\t\tbreak;\n\tcase EBT_SO_SET_COUNTERS:\n\t\tret = compat_update_counters(net, user, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int compat_do_ebt_get_ctl(struct sock *sk, int cmd,\n\t\tvoid __user *user, int *len)\n{\n\tint ret;\n\tstruct compat_ebt_replace tmp;\n\tstruct ebt_table *t;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\t/* try real handler in case userland supplied needed padding */\n\tif ((cmd == EBT_SO_GET_INFO ||\n\t     cmd == EBT_SO_GET_INIT_INFO) && *len != sizeof(tmp))\n\t\t\treturn do_ebt_get_ctl(sk, cmd, user, len);\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\ttmp.name[sizeof(tmp.name) - 1] = '\\0';\n\n\tt = find_table_lock(net, tmp.name, &ret, &ebt_mutex);\n\tif (!t)\n\t\treturn ret;\n\n\txt_compat_lock(NFPROTO_BRIDGE);\n\tswitch (cmd) {\n\tcase EBT_SO_GET_INFO:\n\t\ttmp.nentries = t->private->nentries;\n\t\tret = compat_table_info(t->private, &tmp);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\ttmp.valid_hooks = t->valid_hooks;\n\n\t\tif (copy_to_user(user, &tmp, *len) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase EBT_SO_GET_INIT_INFO:\n\t\ttmp.nentries = t->table->nentries;\n\t\ttmp.entries_size = t->table->entries_size;\n\t\ttmp.valid_hooks = t->table->valid_hooks;\n\n\t\tif (copy_to_user(user, &tmp, *len) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase EBT_SO_GET_ENTRIES:\n\tcase EBT_SO_GET_INIT_ENTRIES:\n\t\t/* try real handler first in case of userland-side padding.\n\t\t * in case we are dealing with an 'ordinary' 32 bit binary\n\t\t * without 64bit compatibility padding, this will fail right\n\t\t * after copy_from_user when the *len argument is validated.\n\t\t *\n\t\t * the compat_ variant needs to do one pass over the kernel\n\t\t * data set to adjust for size differences before it the check.\n\t\t */\n\t\tif (copy_everything_to_user(t, user, len, cmd) == 0)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = compat_copy_everything_to_user(t, user, len, cmd);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n out:\n\txt_compat_flush_offsets(NFPROTO_BRIDGE);\n\txt_compat_unlock(NFPROTO_BRIDGE);\n\tmutex_unlock(&ebt_mutex);\n\treturn ret;\n}\n#endif\n\nstatic struct nf_sockopt_ops ebt_sockopts = {\n\t.pf\t\t= PF_INET,\n\t.set_optmin\t= EBT_BASE_CTL,\n\t.set_optmax\t= EBT_SO_SET_MAX + 1,\n\t.set\t\t= do_ebt_set_ctl,\n#ifdef CONFIG_COMPAT\n\t.compat_set\t= compat_do_ebt_set_ctl,\n#endif\n\t.get_optmin\t= EBT_BASE_CTL,\n\t.get_optmax\t= EBT_SO_GET_MAX + 1,\n\t.get\t\t= do_ebt_get_ctl,\n#ifdef CONFIG_COMPAT\n\t.compat_get\t= compat_do_ebt_get_ctl,\n#endif\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init ebtables_init(void)\n{\n\tint ret;\n\n\tret = xt_register_target(&ebt_standard_target);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = nf_register_sockopt(&ebt_sockopts);\n\tif (ret < 0) {\n\t\txt_unregister_target(&ebt_standard_target);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit ebtables_fini(void)\n{\n\tnf_unregister_sockopt(&ebt_sockopts);\n\txt_unregister_target(&ebt_standard_target);\n}\n\nEXPORT_SYMBOL(ebt_register_table);\nEXPORT_SYMBOL(ebt_unregister_table);\nEXPORT_SYMBOL(ebt_do_table);\nmodule_init(ebtables_init);\nmodule_exit(ebtables_fini);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n *  ebtables\n *\n *  Author:\n *  Bart De Schuymer\t\t<bdschuym@pandora.be>\n *\n *  ebtables.c,v 2.0, July, 2002\n *\n *  This code is strongly inspired by the iptables code which is\n *  Copyright (C) 1999 Paul `Rusty' Russell & Michael J. Neuling\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License\n *  as published by the Free Software Foundation; either version\n *  2 of the License, or (at your option) any later version.\n */\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/smp.h>\n#include <linux/cpumask.h>\n#include <linux/audit.h>\n#include <net/sock.h>\n/* needed for logical [in,out]-dev filtering */\n#include \"../br_private.h\"\n\n#define BUGPRINT(format, args...) printk(\"kernel msg: ebtables bug: please \"\\\n\t\t\t\t\t \"report to author: \"format, ## args)\n/* #define BUGPRINT(format, args...) */\n\n/* Each cpu has its own set of counters, so there is no need for write_lock in\n * the softirq\n * For reading or updating the counters, the user context needs to\n * get a write_lock\n */\n\n/* The size of each set of counters is altered to get cache alignment */\n#define SMP_ALIGN(x) (((x) + SMP_CACHE_BYTES-1) & ~(SMP_CACHE_BYTES-1))\n#define COUNTER_OFFSET(n) (SMP_ALIGN(n * sizeof(struct ebt_counter)))\n#define COUNTER_BASE(c, n, cpu) ((struct ebt_counter *)(((char *)c) + \\\n\t\t\t\t COUNTER_OFFSET(n) * cpu))\n\n\n\nstatic DEFINE_MUTEX(ebt_mutex);\n\n#ifdef CONFIG_COMPAT\nstatic void ebt_standard_compat_from_user(void *dst, const void *src)\n{\n\tint v = *(compat_int_t *)src;\n\n\tif (v >= 0)\n\t\tv += xt_compat_calc_jump(NFPROTO_BRIDGE, v);\n\tmemcpy(dst, &v, sizeof(v));\n}\n\nstatic int ebt_standard_compat_to_user(void __user *dst, const void *src)\n{\n\tcompat_int_t cv = *(int *)src;\n\n\tif (cv >= 0)\n\t\tcv -= xt_compat_calc_jump(NFPROTO_BRIDGE, cv);\n\treturn copy_to_user(dst, &cv, sizeof(cv)) ? -EFAULT : 0;\n}\n#endif\n\n\nstatic struct xt_target ebt_standard_target = {\n\t.name       = \"standard\",\n\t.revision   = 0,\n\t.family     = NFPROTO_BRIDGE,\n\t.targetsize = sizeof(int),\n#ifdef CONFIG_COMPAT\n\t.compatsize = sizeof(compat_int_t),\n\t.compat_from_user = ebt_standard_compat_from_user,\n\t.compat_to_user =  ebt_standard_compat_to_user,\n#endif\n};\n\nstatic inline int\nebt_do_watcher(const struct ebt_entry_watcher *w, struct sk_buff *skb,\n\t       struct xt_action_param *par)\n{\n\tpar->target   = w->u.watcher;\n\tpar->targinfo = w->data;\n\tw->u.watcher->target(skb, par);\n\t/* watchers don't give a verdict */\n\treturn 0;\n}\n\nstatic inline int\nebt_do_match(struct ebt_entry_match *m, const struct sk_buff *skb,\n\t     struct xt_action_param *par)\n{\n\tpar->match     = m->u.match;\n\tpar->matchinfo = m->data;\n\treturn m->u.match->match(skb, par) ? EBT_MATCH : EBT_NOMATCH;\n}\n\nstatic inline int\nebt_dev_check(const char *entry, const struct net_device *device)\n{\n\tint i = 0;\n\tconst char *devname;\n\n\tif (*entry == '\\0')\n\t\treturn 0;\n\tif (!device)\n\t\treturn 1;\n\tdevname = device->name;\n\t/* 1 is the wildcard token */\n\twhile (entry[i] != '\\0' && entry[i] != 1 && entry[i] == devname[i])\n\t\ti++;\n\treturn devname[i] != entry[i] && entry[i] != 1;\n}\n\n/* process standard matches */\nstatic inline int\nebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\n\t\tconst struct net_device *in, const struct net_device *out)\n{\n\tconst struct ethhdr *h = eth_hdr(skb);\n\tconst struct net_bridge_port *p;\n\t__be16 ethproto;\n\n\tif (skb_vlan_tag_present(skb))\n\t\tethproto = htons(ETH_P_8021Q);\n\telse\n\t\tethproto = h->h_proto;\n\n\tif (e->bitmask & EBT_802_3) {\n\t\tif (NF_INVF(e, EBT_IPROTO, eth_proto_is_802_3(ethproto)))\n\t\t\treturn 1;\n\t} else if (!(e->bitmask & EBT_NOPROTO) &&\n\t\t   NF_INVF(e, EBT_IPROTO, e->ethproto != ethproto))\n\t\treturn 1;\n\n\tif (NF_INVF(e, EBT_IIN, ebt_dev_check(e->in, in)))\n\t\treturn 1;\n\tif (NF_INVF(e, EBT_IOUT, ebt_dev_check(e->out, out)))\n\t\treturn 1;\n\t/* rcu_read_lock()ed by nf_hook_thresh */\n\tif (in && (p = br_port_get_rcu(in)) != NULL &&\n\t    NF_INVF(e, EBT_ILOGICALIN,\n\t\t    ebt_dev_check(e->logical_in, p->br->dev)))\n\t\treturn 1;\n\tif (out && (p = br_port_get_rcu(out)) != NULL &&\n\t    NF_INVF(e, EBT_ILOGICALOUT,\n\t\t    ebt_dev_check(e->logical_out, p->br->dev)))\n\t\treturn 1;\n\n\tif (e->bitmask & EBT_SOURCEMAC) {\n\t\tif (NF_INVF(e, EBT_ISOURCE,\n\t\t\t    !ether_addr_equal_masked(h->h_source, e->sourcemac,\n\t\t\t\t\t\t     e->sourcemsk)))\n\t\t\treturn 1;\n\t}\n\tif (e->bitmask & EBT_DESTMAC) {\n\t\tif (NF_INVF(e, EBT_IDEST,\n\t\t\t    !ether_addr_equal_masked(h->h_dest, e->destmac,\n\t\t\t\t\t\t     e->destmsk)))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline\nstruct ebt_entry *ebt_next_entry(const struct ebt_entry *entry)\n{\n\treturn (void *)entry + entry->next_offset;\n}\n\n/* Do some firewalling */\nunsigned int ebt_do_table(struct sk_buff *skb,\n\t\t\t  const struct nf_hook_state *state,\n\t\t\t  struct ebt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tint i, nentries;\n\tstruct ebt_entry *point;\n\tstruct ebt_counter *counter_base, *cb_base;\n\tconst struct ebt_entry_target *t;\n\tint verdict, sp = 0;\n\tstruct ebt_chainstack *cs;\n\tstruct ebt_entries *chaininfo;\n\tconst char *base;\n\tconst struct ebt_table_info *private;\n\tstruct xt_action_param acpar;\n\n\tacpar.state   = state;\n\tacpar.hotdrop = false;\n\n\tread_lock_bh(&table->lock);\n\tprivate = table->private;\n\tcb_base = COUNTER_BASE(private->counters, private->nentries,\n\t   smp_processor_id());\n\tif (private->chainstack)\n\t\tcs = private->chainstack[smp_processor_id()];\n\telse\n\t\tcs = NULL;\n\tchaininfo = private->hook_entry[hook];\n\tnentries = private->hook_entry[hook]->nentries;\n\tpoint = (struct ebt_entry *)(private->hook_entry[hook]->data);\n\tcounter_base = cb_base + private->hook_entry[hook]->counter_offset;\n\t/* base for chain jumps */\n\tbase = private->entries;\n\ti = 0;\n\twhile (i < nentries) {\n\t\tif (ebt_basic_match(point, skb, state->in, state->out))\n\t\t\tgoto letscontinue;\n\n\t\tif (EBT_MATCH_ITERATE(point, ebt_do_match, skb, &acpar) != 0)\n\t\t\tgoto letscontinue;\n\t\tif (acpar.hotdrop) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\t/* increase counter */\n\t\t(*(counter_base + i)).pcnt++;\n\t\t(*(counter_base + i)).bcnt += skb->len;\n\n\t\t/* these should only watch: not modify, nor tell us\n\t\t * what to do with the packet\n\t\t */\n\t\tEBT_WATCHER_ITERATE(point, ebt_do_watcher, skb, &acpar);\n\n\t\tt = (struct ebt_entry_target *)\n\t\t   (((char *)point) + point->target_offset);\n\t\t/* standard target */\n\t\tif (!t->u.target->target)\n\t\t\tverdict = ((struct ebt_standard_target *)t)->verdict;\n\t\telse {\n\t\t\tacpar.target   = t->u.target;\n\t\t\tacpar.targinfo = t->data;\n\t\t\tverdict = t->u.target->target(skb, &acpar);\n\t\t}\n\t\tif (verdict == EBT_ACCEPT) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_ACCEPT;\n\t\t}\n\t\tif (verdict == EBT_DROP) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\t\tif (verdict == EBT_RETURN) {\nletsreturn:\n\t\t\tif (WARN(sp == 0, \"RETURN on base chain\")) {\n\t\t\t\t/* act like this is EBT_CONTINUE */\n\t\t\t\tgoto letscontinue;\n\t\t\t}\n\n\t\t\tsp--;\n\t\t\t/* put all the local variables right */\n\t\t\ti = cs[sp].n;\n\t\t\tchaininfo = cs[sp].chaininfo;\n\t\t\tnentries = chaininfo->nentries;\n\t\t\tpoint = cs[sp].e;\n\t\t\tcounter_base = cb_base +\n\t\t\t   chaininfo->counter_offset;\n\t\t\tcontinue;\n\t\t}\n\t\tif (verdict == EBT_CONTINUE)\n\t\t\tgoto letscontinue;\n\n\t\tif (WARN(verdict < 0, \"bogus standard verdict\\n\")) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\t/* jump to a udc */\n\t\tcs[sp].n = i + 1;\n\t\tcs[sp].chaininfo = chaininfo;\n\t\tcs[sp].e = ebt_next_entry(point);\n\t\ti = 0;\n\t\tchaininfo = (struct ebt_entries *) (base + verdict);\n\n\t\tif (WARN(chaininfo->distinguisher, \"jump to non-chain\\n\")) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\tnentries = chaininfo->nentries;\n\t\tpoint = (struct ebt_entry *)chaininfo->data;\n\t\tcounter_base = cb_base + chaininfo->counter_offset;\n\t\tsp++;\n\t\tcontinue;\nletscontinue:\n\t\tpoint = ebt_next_entry(point);\n\t\ti++;\n\t}\n\n\t/* I actually like this :) */\n\tif (chaininfo->policy == EBT_RETURN)\n\t\tgoto letsreturn;\n\tif (chaininfo->policy == EBT_ACCEPT) {\n\t\tread_unlock_bh(&table->lock);\n\t\treturn NF_ACCEPT;\n\t}\n\tread_unlock_bh(&table->lock);\n\treturn NF_DROP;\n}\n\n/* If it succeeds, returns element and locks mutex */\nstatic inline void *\nfind_inlist_lock_noload(struct list_head *head, const char *name, int *error,\n\t\t\tstruct mutex *mutex)\n{\n\tstruct {\n\t\tstruct list_head list;\n\t\tchar name[EBT_FUNCTION_MAXNAMELEN];\n\t} *e;\n\n\tmutex_lock(mutex);\n\tlist_for_each_entry(e, head, list) {\n\t\tif (strcmp(e->name, name) == 0)\n\t\t\treturn e;\n\t}\n\t*error = -ENOENT;\n\tmutex_unlock(mutex);\n\treturn NULL;\n}\n\nstatic void *\nfind_inlist_lock(struct list_head *head, const char *name, const char *prefix,\n\t\t int *error, struct mutex *mutex)\n{\n\treturn try_then_request_module(\n\t\t\tfind_inlist_lock_noload(head, name, error, mutex),\n\t\t\t\"%s%s\", prefix, name);\n}\n\nstatic inline struct ebt_table *\nfind_table_lock(struct net *net, const char *name, int *error,\n\t\tstruct mutex *mutex)\n{\n\treturn find_inlist_lock(&net->xt.tables[NFPROTO_BRIDGE], name,\n\t\t\t\t\"ebtable_\", error, mutex);\n}\n\nstatic inline int\nebt_check_match(struct ebt_entry_match *m, struct xt_mtchk_param *par,\n\t\tunsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_match *match;\n\tsize_t left = ((char *)e + e->watchers_offset) - (char *)m;\n\tint ret;\n\n\tif (left < sizeof(struct ebt_entry_match) ||\n\t    left - sizeof(struct ebt_entry_match) < m->match_size)\n\t\treturn -EINVAL;\n\n\tmatch = xt_find_match(NFPROTO_BRIDGE, m->u.name, 0);\n\tif (IS_ERR(match) || match->family != NFPROTO_BRIDGE) {\n\t\tif (!IS_ERR(match))\n\t\t\tmodule_put(match->me);\n\t\trequest_module(\"ebt_%s\", m->u.name);\n\t\tmatch = xt_find_match(NFPROTO_BRIDGE, m->u.name, 0);\n\t}\n\tif (IS_ERR(match))\n\t\treturn PTR_ERR(match);\n\tm->u.match = match;\n\n\tpar->match     = match;\n\tpar->matchinfo = m->data;\n\tret = xt_check_match(par, m->match_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(match->me);\n\t\treturn ret;\n\t}\n\n\t(*cnt)++;\n\treturn 0;\n}\n\nstatic inline int\nebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,\n\t\t  unsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_target *watcher;\n\tsize_t left = ((char *)e + e->target_offset) - (char *)w;\n\tint ret;\n\n\tif (left < sizeof(struct ebt_entry_watcher) ||\n\t   left - sizeof(struct ebt_entry_watcher) < w->watcher_size)\n\t\treturn -EINVAL;\n\n\twatcher = xt_request_find_target(NFPROTO_BRIDGE, w->u.name, 0);\n\tif (IS_ERR(watcher))\n\t\treturn PTR_ERR(watcher);\n\tw->u.watcher = watcher;\n\n\tpar->target   = watcher;\n\tpar->targinfo = w->data;\n\tret = xt_check_target(par, w->watcher_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(watcher->me);\n\t\treturn ret;\n\t}\n\n\t(*cnt)++;\n\treturn 0;\n}\n\nstatic int ebt_verify_pointers(const struct ebt_replace *repl,\n\t\t\t       struct ebt_table_info *newinfo)\n{\n\tunsigned int limit = repl->entries_size;\n\tunsigned int valid_hooks = repl->valid_hooks;\n\tunsigned int offset = 0;\n\tint i;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++)\n\t\tnewinfo->hook_entry[i] = NULL;\n\n\tnewinfo->entries_size = repl->entries_size;\n\tnewinfo->nentries = repl->nentries;\n\n\twhile (offset < limit) {\n\t\tsize_t left = limit - offset;\n\t\tstruct ebt_entry *e = (void *)newinfo->entries + offset;\n\n\t\tif (left < sizeof(unsigned int))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\t\tif ((valid_hooks & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((char __user *)repl->hook_entry[i] ==\n\t\t\t     repl->entries + offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i != NF_BR_NUMHOOKS || !(e->bitmask & EBT_ENTRY_OR_ENTRIES)) {\n\t\t\tif (e->bitmask != 0) {\n\t\t\t\t/* we make userspace set this right,\n\t\t\t\t * so there is no misunderstanding\n\t\t\t\t */\n\t\t\t\tBUGPRINT(\"EBT_ENTRY_OR_ENTRIES shouldn't be set \"\n\t\t\t\t\t \"in distinguisher\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (i != NF_BR_NUMHOOKS)\n\t\t\t\tnewinfo->hook_entry[i] = (struct ebt_entries *)e;\n\t\t\tif (left < sizeof(struct ebt_entries))\n\t\t\t\tbreak;\n\t\t\toffset += sizeof(struct ebt_entries);\n\t\t} else {\n\t\t\tif (left < sizeof(struct ebt_entry))\n\t\t\t\tbreak;\n\t\t\tif (left < e->next_offset)\n\t\t\t\tbreak;\n\t\t\tif (e->next_offset < sizeof(struct ebt_entry))\n\t\t\t\treturn -EINVAL;\n\t\t\toffset += e->next_offset;\n\t\t}\n\t}\n\tif (offset != limit) {\n\t\tBUGPRINT(\"entries_size too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if all valid hooks have a chain */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (!newinfo->hook_entry[i] &&\n\t\t   (valid_hooks & (1 << i))) {\n\t\t\tBUGPRINT(\"Valid hook without chain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* this one is very careful, as it is the first function\n * to parse the userspace data\n */\nstatic inline int\nebt_check_entry_size_and_hooks(const struct ebt_entry *e,\n\t\t\t       const struct ebt_table_info *newinfo,\n\t\t\t       unsigned int *n, unsigned int *cnt,\n\t\t\t       unsigned int *totalcnt, unsigned int *udc_cnt)\n{\n\tint i;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif ((void *)e == (void *)newinfo->hook_entry[i])\n\t\t\tbreak;\n\t}\n\t/* beginning of a new chain\n\t * if i == NF_BR_NUMHOOKS it must be a user defined chain\n\t */\n\tif (i != NF_BR_NUMHOOKS || !e->bitmask) {\n\t\t/* this checks if the previous chain has as many entries\n\t\t * as it said it has\n\t\t */\n\t\tif (*n != *cnt) {\n\t\t\tBUGPRINT(\"nentries does not equal the nr of entries \"\n\t\t\t\t \"in the chain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (((struct ebt_entries *)e)->policy != EBT_DROP &&\n\t\t   ((struct ebt_entries *)e)->policy != EBT_ACCEPT) {\n\t\t\t/* only RETURN from udc */\n\t\t\tif (i != NF_BR_NUMHOOKS ||\n\t\t\t   ((struct ebt_entries *)e)->policy != EBT_RETURN) {\n\t\t\t\tBUGPRINT(\"bad policy\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (i == NF_BR_NUMHOOKS) /* it's a user defined chain */\n\t\t\t(*udc_cnt)++;\n\t\tif (((struct ebt_entries *)e)->counter_offset != *totalcnt) {\n\t\t\tBUGPRINT(\"counter_offset != totalcnt\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*n = ((struct ebt_entries *)e)->nentries;\n\t\t*cnt = 0;\n\t\treturn 0;\n\t}\n\t/* a plain old entry, heh */\n\tif (sizeof(struct ebt_entry) > e->watchers_offset ||\n\t   e->watchers_offset > e->target_offset ||\n\t   e->target_offset >= e->next_offset) {\n\t\tBUGPRINT(\"entry offsets not in right order\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* this is not checked anywhere else */\n\tif (e->next_offset - e->target_offset < sizeof(struct ebt_entry_target)) {\n\t\tBUGPRINT(\"target size too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\t(*cnt)++;\n\t(*totalcnt)++;\n\treturn 0;\n}\n\nstruct ebt_cl_stack {\n\tstruct ebt_chainstack cs;\n\tint from;\n\tunsigned int hookmask;\n};\n\n/* We need these positions to check that the jumps to a different part of the\n * entries is a jump to the beginning of a new chain.\n */\nstatic inline int\nebt_get_udc_positions(struct ebt_entry *e, struct ebt_table_info *newinfo,\n\t\t      unsigned int *n, struct ebt_cl_stack *udc)\n{\n\tint i;\n\n\t/* we're only interested in chain starts */\n\tif (e->bitmask)\n\t\treturn 0;\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (newinfo->hook_entry[i] == (struct ebt_entries *)e)\n\t\t\tbreak;\n\t}\n\t/* only care about udc */\n\tif (i != NF_BR_NUMHOOKS)\n\t\treturn 0;\n\n\tudc[*n].cs.chaininfo = (struct ebt_entries *)e;\n\t/* these initialisations are depended on later in check_chainloops() */\n\tudc[*n].cs.n = 0;\n\tudc[*n].hookmask = 0;\n\n\t(*n)++;\n\treturn 0;\n}\n\nstatic inline int\nebt_cleanup_match(struct ebt_entry_match *m, struct net *net, unsigned int *i)\n{\n\tstruct xt_mtdtor_param par;\n\n\tif (i && (*i)-- == 0)\n\t\treturn 1;\n\n\tpar.net       = net;\n\tpar.match     = m->u.match;\n\tpar.matchinfo = m->data;\n\tpar.family    = NFPROTO_BRIDGE;\n\tif (par.match->destroy != NULL)\n\t\tpar.match->destroy(&par);\n\tmodule_put(par.match->me);\n\treturn 0;\n}\n\nstatic inline int\nebt_cleanup_watcher(struct ebt_entry_watcher *w, struct net *net, unsigned int *i)\n{\n\tstruct xt_tgdtor_param par;\n\n\tif (i && (*i)-- == 0)\n\t\treturn 1;\n\n\tpar.net      = net;\n\tpar.target   = w->u.watcher;\n\tpar.targinfo = w->data;\n\tpar.family   = NFPROTO_BRIDGE;\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\tmodule_put(par.target->me);\n\treturn 0;\n}\n\nstatic inline int\nebt_cleanup_entry(struct ebt_entry *e, struct net *net, unsigned int *cnt)\n{\n\tstruct xt_tgdtor_param par;\n\tstruct ebt_entry_target *t;\n\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\t/* we're done */\n\tif (cnt && (*cnt)-- == 0)\n\t\treturn 1;\n\tEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, NULL);\n\tEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, NULL);\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\n\tpar.net      = net;\n\tpar.target   = t->u.target;\n\tpar.targinfo = t->data;\n\tpar.family   = NFPROTO_BRIDGE;\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\tmodule_put(par.target->me);\n\treturn 0;\n}\n\nstatic inline int\nebt_check_entry(struct ebt_entry *e, struct net *net,\n\t\tconst struct ebt_table_info *newinfo,\n\t\tconst char *name, unsigned int *cnt,\n\t\tstruct ebt_cl_stack *cl_s, unsigned int udc_cnt)\n{\n\tstruct ebt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int i, j, hook = 0, hookmask = 0;\n\tsize_t gap;\n\tint ret;\n\tstruct xt_mtchk_param mtpar;\n\tstruct xt_tgchk_param tgpar;\n\n\t/* don't mess with the struct ebt_entries */\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\n\tif (e->bitmask & ~EBT_F_MASK) {\n\t\tBUGPRINT(\"Unknown flag for bitmask\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (e->invflags & ~EBT_INV_MASK) {\n\t\tBUGPRINT(\"Unknown flag for inv bitmask\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((e->bitmask & EBT_NOPROTO) && (e->bitmask & EBT_802_3)) {\n\t\tBUGPRINT(\"NOPROTO & 802_3 not allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* what hook do we belong to? */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (!newinfo->hook_entry[i])\n\t\t\tcontinue;\n\t\tif ((char *)newinfo->hook_entry[i] < (char *)e)\n\t\t\thook = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/* (1 << NF_BR_NUMHOOKS) tells the check functions the rule is on\n\t * a base chain\n\t */\n\tif (i < NF_BR_NUMHOOKS)\n\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\telse {\n\t\tfor (i = 0; i < udc_cnt; i++)\n\t\t\tif ((char *)(cl_s[i].cs.chaininfo) > (char *)e)\n\t\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\t\telse\n\t\t\thookmask = cl_s[i - 1].hookmask;\n\t}\n\ti = 0;\n\n\tmtpar.net\t= tgpar.net       = net;\n\tmtpar.table     = tgpar.table     = name;\n\tmtpar.entryinfo = tgpar.entryinfo = e;\n\tmtpar.hook_mask = tgpar.hook_mask = hookmask;\n\tmtpar.family    = tgpar.family    = NFPROTO_BRIDGE;\n\tret = EBT_MATCH_ITERATE(e, ebt_check_match, &mtpar, &i);\n\tif (ret != 0)\n\t\tgoto cleanup_matches;\n\tj = 0;\n\tret = EBT_WATCHER_ITERATE(e, ebt_check_watcher, &tgpar, &j);\n\tif (ret != 0)\n\t\tgoto cleanup_watchers;\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\tgap = e->next_offset - e->target_offset;\n\n\ttarget = xt_request_find_target(NFPROTO_BRIDGE, t->u.name, 0);\n\tif (IS_ERR(target)) {\n\t\tret = PTR_ERR(target);\n\t\tgoto cleanup_watchers;\n\t}\n\n\tt->u.target = target;\n\tif (t->u.target == &ebt_standard_target) {\n\t\tif (gap < sizeof(struct ebt_standard_target)) {\n\t\t\tBUGPRINT(\"Standard target size too big\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t\tif (((struct ebt_standard_target *)t)->verdict <\n\t\t   -NUM_STANDARD_TARGETS) {\n\t\t\tBUGPRINT(\"Invalid standard target\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t} else if (t->target_size > gap - sizeof(struct ebt_entry_target)) {\n\t\tmodule_put(t->u.target->me);\n\t\tret = -EFAULT;\n\t\tgoto cleanup_watchers;\n\t}\n\n\ttgpar.target   = target;\n\ttgpar.targinfo = t->data;\n\tret = xt_check_target(&tgpar, t->target_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(target->me);\n\t\tgoto cleanup_watchers;\n\t}\n\t(*cnt)++;\n\treturn 0;\ncleanup_watchers:\n\tEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, &j);\ncleanup_matches:\n\tEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, &i);\n\treturn ret;\n}\n\n/* checks for loops and sets the hook mask for udc\n * the hook mask for udc tells us from which base chains the udc can be\n * accessed. This mask is a parameter to the check() functions of the extensions\n */\nstatic int check_chainloops(const struct ebt_entries *chain, struct ebt_cl_stack *cl_s,\n\t\t\t    unsigned int udc_cnt, unsigned int hooknr, char *base)\n{\n\tint i, chain_nr = -1, pos = 0, nentries = chain->nentries, verdict;\n\tconst struct ebt_entry *e = (struct ebt_entry *)chain->data;\n\tconst struct ebt_entry_target *t;\n\n\twhile (pos < nentries || chain_nr != -1) {\n\t\t/* end of udc, go back one 'recursion' step */\n\t\tif (pos == nentries) {\n\t\t\t/* put back values of the time when this chain was called */\n\t\t\te = cl_s[chain_nr].cs.e;\n\t\t\tif (cl_s[chain_nr].from != -1)\n\t\t\t\tnentries =\n\t\t\t\tcl_s[cl_s[chain_nr].from].cs.chaininfo->nentries;\n\t\t\telse\n\t\t\t\tnentries = chain->nentries;\n\t\t\tpos = cl_s[chain_nr].cs.n;\n\t\t\t/* make sure we won't see a loop that isn't one */\n\t\t\tcl_s[chain_nr].cs.n = 0;\n\t\t\tchain_nr = cl_s[chain_nr].from;\n\t\t\tif (pos == nentries)\n\t\t\t\tcontinue;\n\t\t}\n\t\tt = (struct ebt_entry_target *)\n\t\t   (((char *)e) + e->target_offset);\n\t\tif (strcmp(t->u.name, EBT_STANDARD_TARGET))\n\t\t\tgoto letscontinue;\n\t\tif (e->target_offset + sizeof(struct ebt_standard_target) >\n\t\t   e->next_offset) {\n\t\t\tBUGPRINT(\"Standard target size too big\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tverdict = ((struct ebt_standard_target *)t)->verdict;\n\t\tif (verdict >= 0) { /* jump to another chain */\n\t\t\tstruct ebt_entries *hlp2 =\n\t\t\t   (struct ebt_entries *)(base + verdict);\n\t\t\tfor (i = 0; i < udc_cnt; i++)\n\t\t\t\tif (hlp2 == cl_s[i].cs.chaininfo)\n\t\t\t\t\tbreak;\n\t\t\t/* bad destination or loop */\n\t\t\tif (i == udc_cnt) {\n\t\t\t\tBUGPRINT(\"bad destination\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (cl_s[i].cs.n) {\n\t\t\t\tBUGPRINT(\"loop\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (cl_s[i].hookmask & (1 << hooknr))\n\t\t\t\tgoto letscontinue;\n\t\t\t/* this can't be 0, so the loop test is correct */\n\t\t\tcl_s[i].cs.n = pos + 1;\n\t\t\tpos = 0;\n\t\t\tcl_s[i].cs.e = ebt_next_entry(e);\n\t\t\te = (struct ebt_entry *)(hlp2->data);\n\t\t\tnentries = hlp2->nentries;\n\t\t\tcl_s[i].from = chain_nr;\n\t\t\tchain_nr = i;\n\t\t\t/* this udc is accessible from the base chain for hooknr */\n\t\t\tcl_s[i].hookmask |= (1 << hooknr);\n\t\t\tcontinue;\n\t\t}\nletscontinue:\n\t\te = ebt_next_entry(e);\n\t\tpos++;\n\t}\n\treturn 0;\n}\n\n/* do the parsing of the table/chains/entries/matches/watchers/targets, heh */\nstatic int translate_table(struct net *net, const char *name,\n\t\t\t   struct ebt_table_info *newinfo)\n{\n\tunsigned int i, j, k, udc_cnt;\n\tint ret;\n\tstruct ebt_cl_stack *cl_s = NULL; /* used in the checking for chain loops */\n\n\ti = 0;\n\twhile (i < NF_BR_NUMHOOKS && !newinfo->hook_entry[i])\n\t\ti++;\n\tif (i == NF_BR_NUMHOOKS) {\n\t\tBUGPRINT(\"No valid hooks specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (newinfo->hook_entry[i] != (struct ebt_entries *)newinfo->entries) {\n\t\tBUGPRINT(\"Chains don't start at beginning\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* make sure chains are ordered after each other in same order\n\t * as their corresponding hooks\n\t */\n\tfor (j = i + 1; j < NF_BR_NUMHOOKS; j++) {\n\t\tif (!newinfo->hook_entry[j])\n\t\t\tcontinue;\n\t\tif (newinfo->hook_entry[j] <= newinfo->hook_entry[i]) {\n\t\t\tBUGPRINT(\"Hook order must be followed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti = j;\n\t}\n\n\t/* do some early checkings and initialize some things */\n\ti = 0; /* holds the expected nr. of entries for the chain */\n\tj = 0; /* holds the up to now counted entries for the chain */\n\tk = 0; /* holds the total nr. of entries, should equal\n\t\t* newinfo->nentries afterwards\n\t\t*/\n\tudc_cnt = 0; /* will hold the nr. of user defined chains (udc) */\n\tret = EBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t   ebt_check_entry_size_and_hooks, newinfo,\n\t   &i, &j, &k, &udc_cnt);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (i != j) {\n\t\tBUGPRINT(\"nentries does not equal the nr of entries in the \"\n\t\t\t \"(last) chain\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (k != newinfo->nentries) {\n\t\tBUGPRINT(\"Total nentries is wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* get the location of the udc, put them in an array\n\t * while we're at it, allocate the chainstack\n\t */\n\tif (udc_cnt) {\n\t\t/* this will get free'd in do_replace()/ebt_register_table()\n\t\t * if an error occurs\n\t\t */\n\t\tnewinfo->chainstack =\n\t\t\tvmalloc(nr_cpu_ids * sizeof(*(newinfo->chainstack)));\n\t\tif (!newinfo->chainstack)\n\t\t\treturn -ENOMEM;\n\t\tfor_each_possible_cpu(i) {\n\t\t\tnewinfo->chainstack[i] =\n\t\t\t  vmalloc(udc_cnt * sizeof(*(newinfo->chainstack[0])));\n\t\t\tif (!newinfo->chainstack[i]) {\n\t\t\t\twhile (i)\n\t\t\t\t\tvfree(newinfo->chainstack[--i]);\n\t\t\t\tvfree(newinfo->chainstack);\n\t\t\t\tnewinfo->chainstack = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tcl_s = vmalloc(udc_cnt * sizeof(*cl_s));\n\t\tif (!cl_s)\n\t\t\treturn -ENOMEM;\n\t\ti = 0; /* the i'th udc */\n\t\tEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t\t   ebt_get_udc_positions, newinfo, &i, cl_s);\n\t\t/* sanity check */\n\t\tif (i != udc_cnt) {\n\t\t\tBUGPRINT(\"i != udc_cnt\\n\");\n\t\t\tvfree(cl_s);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\t/* Check for loops */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++)\n\t\tif (newinfo->hook_entry[i])\n\t\t\tif (check_chainloops(newinfo->hook_entry[i],\n\t\t\t   cl_s, udc_cnt, i, newinfo->entries)) {\n\t\t\t\tvfree(cl_s);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t/* we now know the following (along with E=mc\u00b2):\n\t *  - the nr of entries in each chain is right\n\t *  - the size of the allocated space is right\n\t *  - all valid hooks have a corresponding chain\n\t *  - there are no loops\n\t *  - wrong data can still be on the level of a single entry\n\t *  - could be there are jumps to places that are not the\n\t *    beginning of a chain. This can only occur in chains that\n\t *    are not accessible from any base chains, so we don't care.\n\t */\n\n\t/* used to know what we need to clean up if something goes wrong */\n\ti = 0;\n\tret = EBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t   ebt_check_entry, net, newinfo, name, &i, cl_s, udc_cnt);\n\tif (ret != 0) {\n\t\tEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t\t\t\t  ebt_cleanup_entry, net, &i);\n\t}\n\tvfree(cl_s);\n\treturn ret;\n}\n\n/* called under write_lock */\nstatic void get_counters(const struct ebt_counter *oldcounters,\n\t\t\t struct ebt_counter *counters, unsigned int nentries)\n{\n\tint i, cpu;\n\tstruct ebt_counter *counter_base;\n\n\t/* counters of cpu 0 */\n\tmemcpy(counters, oldcounters,\n\t       sizeof(struct ebt_counter) * nentries);\n\n\t/* add other counters to those of cpu 0 */\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == 0)\n\t\t\tcontinue;\n\t\tcounter_base = COUNTER_BASE(oldcounters, nentries, cpu);\n\t\tfor (i = 0; i < nentries; i++) {\n\t\t\tcounters[i].pcnt += counter_base[i].pcnt;\n\t\t\tcounters[i].bcnt += counter_base[i].bcnt;\n\t\t}\n\t}\n}\n\nstatic int do_replace_finish(struct net *net, struct ebt_replace *repl,\n\t\t\t      struct ebt_table_info *newinfo)\n{\n\tint ret, i;\n\tstruct ebt_counter *counterstmp = NULL;\n\t/* used to be able to unlock earlier */\n\tstruct ebt_table_info *table;\n\tstruct ebt_table *t;\n\n\t/* the user wants counters back\n\t * the check on the size is done later, when we have the lock\n\t */\n\tif (repl->num_counters) {\n\t\tunsigned long size = repl->num_counters * sizeof(*counterstmp);\n\t\tcounterstmp = vmalloc(size);\n\t\tif (!counterstmp)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tnewinfo->chainstack = NULL;\n\tret = ebt_verify_pointers(repl, newinfo);\n\tif (ret != 0)\n\t\tgoto free_counterstmp;\n\n\tret = translate_table(net, repl->name, newinfo);\n\n\tif (ret != 0)\n\t\tgoto free_counterstmp;\n\n\tt = find_table_lock(net, repl->name, &ret, &ebt_mutex);\n\tif (!t) {\n\t\tret = -ENOENT;\n\t\tgoto free_iterate;\n\t}\n\n\t/* the table doesn't like it */\n\tif (t->check && (ret = t->check(newinfo, repl->valid_hooks)))\n\t\tgoto free_unlock;\n\n\tif (repl->num_counters && repl->num_counters != t->private->nentries) {\n\t\tBUGPRINT(\"Wrong nr. of counters requested\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_unlock;\n\t}\n\n\t/* we have the mutex lock, so no danger in reading this pointer */\n\ttable = t->private;\n\t/* make sure the table can only be rmmod'ed if it contains no rules */\n\tif (!table->nentries && newinfo->nentries && !try_module_get(t->me)) {\n\t\tret = -ENOENT;\n\t\tgoto free_unlock;\n\t} else if (table->nentries && !newinfo->nentries)\n\t\tmodule_put(t->me);\n\t/* we need an atomic snapshot of the counters */\n\twrite_lock_bh(&t->lock);\n\tif (repl->num_counters)\n\t\tget_counters(t->private->counters, counterstmp,\n\t\t   t->private->nentries);\n\n\tt->private = newinfo;\n\twrite_unlock_bh(&t->lock);\n\tmutex_unlock(&ebt_mutex);\n\t/* so, a user can change the chains while having messed up her counter\n\t * allocation. Only reason why this is done is because this way the lock\n\t * is held only once, while this doesn't bring the kernel into a\n\t * dangerous state.\n\t */\n\tif (repl->num_counters &&\n\t   copy_to_user(repl->counters, counterstmp,\n\t   repl->num_counters * sizeof(struct ebt_counter))) {\n\t\t/* Silent error, can't fail, new table is already in place */\n\t\tnet_warn_ratelimited(\"ebtables: counters copy to user failed while replacing table\\n\");\n\t}\n\n\t/* decrease module count and free resources */\n\tEBT_ENTRY_ITERATE(table->entries, table->entries_size,\n\t\t\t  ebt_cleanup_entry, net, NULL);\n\n\tvfree(table->entries);\n\tif (table->chainstack) {\n\t\tfor_each_possible_cpu(i)\n\t\t\tvfree(table->chainstack[i]);\n\t\tvfree(table->chainstack);\n\t}\n\tvfree(table);\n\n\tvfree(counterstmp);\n\n#ifdef CONFIG_AUDIT\n\tif (audit_enabled) {\n\t\taudit_log(current->audit_context, GFP_KERNEL,\n\t\t\t  AUDIT_NETFILTER_CFG,\n\t\t\t  \"table=%s family=%u entries=%u\",\n\t\t\t  repl->name, AF_BRIDGE, repl->nentries);\n\t}\n#endif\n\treturn ret;\n\nfree_unlock:\n\tmutex_unlock(&ebt_mutex);\nfree_iterate:\n\tEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t\t\t  ebt_cleanup_entry, net, NULL);\nfree_counterstmp:\n\tvfree(counterstmp);\n\t/* can be initialized in translate_table() */\n\tif (newinfo->chainstack) {\n\t\tfor_each_possible_cpu(i)\n\t\t\tvfree(newinfo->chainstack[i]);\n\t\tvfree(newinfo->chainstack);\n\t}\n\treturn ret;\n}\n\n/* replace the table */\nstatic int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* overflow check */\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\n\ttmp.name[sizeof(tmp.name) - 1] = 0;\n\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}\n\nstatic void __ebt_unregister_table(struct net *net, struct ebt_table *table)\n{\n\tint i;\n\n\tmutex_lock(&ebt_mutex);\n\tlist_del(&table->list);\n\tmutex_unlock(&ebt_mutex);\n\tEBT_ENTRY_ITERATE(table->private->entries, table->private->entries_size,\n\t\t\t  ebt_cleanup_entry, net, NULL);\n\tif (table->private->nentries)\n\t\tmodule_put(table->me);\n\tvfree(table->private->entries);\n\tif (table->private->chainstack) {\n\t\tfor_each_possible_cpu(i)\n\t\t\tvfree(table->private->chainstack[i]);\n\t\tvfree(table->private->chainstack);\n\t}\n\tvfree(table->private);\n\tkfree(table);\n}\n\nint ebt_register_table(struct net *net, const struct ebt_table *input_table,\n\t\t       const struct nf_hook_ops *ops, struct ebt_table **res)\n{\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_table *t, *table;\n\tstruct ebt_replace_kernel *repl;\n\tint ret, i, countersize;\n\tvoid *p;\n\n\tif (input_table == NULL || (repl = input_table->table) == NULL ||\n\t    repl->entries == NULL || repl->entries_size == 0 ||\n\t    repl->counters != NULL || input_table->private != NULL) {\n\t\tBUGPRINT(\"Bad table data for ebt_register_table!!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Don't add one table to multiple lists. */\n\ttable = kmemdup(input_table, sizeof(struct ebt_table), GFP_KERNEL);\n\tif (!table) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcountersize = COUNTER_OFFSET(repl->nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tret = -ENOMEM;\n\tif (!newinfo)\n\t\tgoto free_table;\n\n\tp = vmalloc(repl->entries_size);\n\tif (!p)\n\t\tgoto free_newinfo;\n\n\tmemcpy(p, repl->entries, repl->entries_size);\n\tnewinfo->entries = p;\n\n\tnewinfo->entries_size = repl->entries_size;\n\tnewinfo->nentries = repl->nentries;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\t/* fill in newinfo and parse the entries */\n\tnewinfo->chainstack = NULL;\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif ((repl->valid_hooks & (1 << i)) == 0)\n\t\t\tnewinfo->hook_entry[i] = NULL;\n\t\telse\n\t\t\tnewinfo->hook_entry[i] = p +\n\t\t\t\t((char *)repl->hook_entry[i] - repl->entries);\n\t}\n\tret = translate_table(net, repl->name, newinfo);\n\tif (ret != 0) {\n\t\tBUGPRINT(\"Translate_table failed\\n\");\n\t\tgoto free_chainstack;\n\t}\n\n\tif (table->check && table->check(newinfo, table->valid_hooks)) {\n\t\tBUGPRINT(\"The table doesn't like its own initial data, lol\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_chainstack;\n\t}\n\n\ttable->private = newinfo;\n\trwlock_init(&table->lock);\n\tmutex_lock(&ebt_mutex);\n\tlist_for_each_entry(t, &net->xt.tables[NFPROTO_BRIDGE], list) {\n\t\tif (strcmp(t->name, table->name) == 0) {\n\t\t\tret = -EEXIST;\n\t\t\tBUGPRINT(\"Table name already exists\\n\");\n\t\t\tgoto free_unlock;\n\t\t}\n\t}\n\n\t/* Hold a reference count if the chains aren't empty */\n\tif (newinfo->nentries && !try_module_get(table->me)) {\n\t\tret = -ENOENT;\n\t\tgoto free_unlock;\n\t}\n\tlist_add(&table->list, &net->xt.tables[NFPROTO_BRIDGE]);\n\tmutex_unlock(&ebt_mutex);\n\n\tWRITE_ONCE(*res, table);\n\n\tif (!ops)\n\t\treturn 0;\n\n\tret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));\n\tif (ret) {\n\t\t__ebt_unregister_table(net, table);\n\t\t*res = NULL;\n\t}\n\n\treturn ret;\nfree_unlock:\n\tmutex_unlock(&ebt_mutex);\nfree_chainstack:\n\tif (newinfo->chainstack) {\n\t\tfor_each_possible_cpu(i)\n\t\t\tvfree(newinfo->chainstack[i]);\n\t\tvfree(newinfo->chainstack);\n\t}\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\nfree_table:\n\tkfree(table);\nout:\n\treturn ret;\n}\n\nvoid ebt_unregister_table(struct net *net, struct ebt_table *table,\n\t\t\t  const struct nf_hook_ops *ops)\n{\n\tif (ops)\n\t\tnf_unregister_net_hooks(net, ops, hweight32(table->valid_hooks));\n\t__ebt_unregister_table(net, table);\n}\n\n/* userspace just supplied us with counters */\nstatic int do_update_counters(struct net *net, const char *name,\n\t\t\t\tstruct ebt_counter __user *counters,\n\t\t\t\tunsigned int num_counters,\n\t\t\t\tconst void __user *user, unsigned int len)\n{\n\tint i, ret;\n\tstruct ebt_counter *tmp;\n\tstruct ebt_table *t;\n\n\tif (num_counters == 0)\n\t\treturn -EINVAL;\n\n\ttmp = vmalloc(num_counters * sizeof(*tmp));\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tt = find_table_lock(net, name, &ret, &ebt_mutex);\n\tif (!t)\n\t\tgoto free_tmp;\n\n\tif (num_counters != t->private->nentries) {\n\t\tBUGPRINT(\"Wrong nr of counters\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unlock_mutex;\n\t}\n\n\tif (copy_from_user(tmp, counters, num_counters * sizeof(*counters))) {\n\t\tret = -EFAULT;\n\t\tgoto unlock_mutex;\n\t}\n\n\t/* we want an atomic add of the counters */\n\twrite_lock_bh(&t->lock);\n\n\t/* we add to the counters of the first cpu */\n\tfor (i = 0; i < num_counters; i++) {\n\t\tt->private->counters[i].pcnt += tmp[i].pcnt;\n\t\tt->private->counters[i].bcnt += tmp[i].bcnt;\n\t}\n\n\twrite_unlock_bh(&t->lock);\n\tret = 0;\nunlock_mutex:\n\tmutex_unlock(&ebt_mutex);\nfree_tmp:\n\tvfree(tmp);\n\treturn ret;\n}\n\nstatic int update_counters(struct net *net, const void __user *user,\n\t\t\t    unsigned int len)\n{\n\tstruct ebt_replace hlp;\n\n\tif (copy_from_user(&hlp, user, sizeof(hlp)))\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(hlp) + hlp.num_counters * sizeof(struct ebt_counter))\n\t\treturn -EINVAL;\n\n\treturn do_update_counters(net, hlp.name, hlp.counters,\n\t\t\t\thlp.num_counters, user, len);\n}\n\nstatic inline int ebt_obj_to_user(char __user *um, const char *_name,\n\t\t\t\t  const char *data, int entrysize,\n\t\t\t\t  int usersize, int datasize)\n{\n\tchar name[EBT_FUNCTION_MAXNAMELEN] = {0};\n\n\t/* ebtables expects 32 bytes long names but xt_match names are 29 bytes\n\t * long. Copy 29 bytes and fill remaining bytes with zeroes.\n\t */\n\tstrlcpy(name, _name, sizeof(name));\n\tif (copy_to_user(um, name, EBT_FUNCTION_MAXNAMELEN) ||\n\t    put_user(datasize, (int __user *)(um + EBT_FUNCTION_MAXNAMELEN)) ||\n\t    xt_data_to_user(um + entrysize, data, usersize, datasize,\n\t\t\t    XT_ALIGN(datasize)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic inline int ebt_match_to_user(const struct ebt_entry_match *m,\n\t\t\t\t    const char *base, char __user *ubase)\n{\n\treturn ebt_obj_to_user(ubase + ((char *)m - base),\n\t\t\t       m->u.match->name, m->data, sizeof(*m),\n\t\t\t       m->u.match->usersize, m->match_size);\n}\n\nstatic inline int ebt_watcher_to_user(const struct ebt_entry_watcher *w,\n\t\t\t\t      const char *base, char __user *ubase)\n{\n\treturn ebt_obj_to_user(ubase + ((char *)w - base),\n\t\t\t       w->u.watcher->name, w->data, sizeof(*w),\n\t\t\t       w->u.watcher->usersize, w->watcher_size);\n}\n\nstatic inline int ebt_entry_to_user(struct ebt_entry *e, const char *base,\n\t\t\t\t    char __user *ubase)\n{\n\tint ret;\n\tchar __user *hlp;\n\tconst struct ebt_entry_target *t;\n\n\tif (e->bitmask == 0) {\n\t\t/* special case !EBT_ENTRY_OR_ENTRIES */\n\t\tif (copy_to_user(ubase + ((char *)e - base), e,\n\t\t\t\t sizeof(struct ebt_entries)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tif (copy_to_user(ubase + ((char *)e - base), e, sizeof(*e)))\n\t\treturn -EFAULT;\n\n\thlp = ubase + (((char *)e + e->target_offset) - base);\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\n\tret = EBT_MATCH_ITERATE(e, ebt_match_to_user, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = EBT_WATCHER_ITERATE(e, ebt_watcher_to_user, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = ebt_obj_to_user(hlp, t->u.target->name, t->data, sizeof(*t),\n\t\t\t      t->u.target->usersize, t->target_size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int copy_counters_to_user(struct ebt_table *t,\n\t\t\t\t const struct ebt_counter *oldcounters,\n\t\t\t\t void __user *user, unsigned int num_counters,\n\t\t\t\t unsigned int nentries)\n{\n\tstruct ebt_counter *counterstmp;\n\tint ret = 0;\n\n\t/* userspace might not need the counters */\n\tif (num_counters == 0)\n\t\treturn 0;\n\n\tif (num_counters != nentries) {\n\t\tBUGPRINT(\"Num_counters wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcounterstmp = vmalloc(nentries * sizeof(*counterstmp));\n\tif (!counterstmp)\n\t\treturn -ENOMEM;\n\n\twrite_lock_bh(&t->lock);\n\tget_counters(oldcounters, counterstmp, nentries);\n\twrite_unlock_bh(&t->lock);\n\n\tif (copy_to_user(user, counterstmp,\n\t   nentries * sizeof(struct ebt_counter)))\n\t\tret = -EFAULT;\n\tvfree(counterstmp);\n\treturn ret;\n}\n\n/* called with ebt_mutex locked */\nstatic int copy_everything_to_user(struct ebt_table *t, void __user *user,\n\t\t\t\t   const int *len, int cmd)\n{\n\tstruct ebt_replace tmp;\n\tconst struct ebt_counter *oldcounters;\n\tunsigned int entries_size, nentries;\n\tint ret;\n\tchar *entries;\n\n\tif (cmd == EBT_SO_GET_ENTRIES) {\n\t\tentries_size = t->private->entries_size;\n\t\tnentries = t->private->nentries;\n\t\tentries = t->private->entries;\n\t\toldcounters = t->private->counters;\n\t} else {\n\t\tentries_size = t->table->entries_size;\n\t\tnentries = t->table->nentries;\n\t\tentries = t->table->entries;\n\t\toldcounters = t->table->counters;\n\t}\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (*len != sizeof(struct ebt_replace) + entries_size +\n\t   (tmp.num_counters ? nentries * sizeof(struct ebt_counter) : 0))\n\t\treturn -EINVAL;\n\n\tif (tmp.nentries != nentries) {\n\t\tBUGPRINT(\"Nentries wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size != entries_size) {\n\t\tBUGPRINT(\"Wrong size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = copy_counters_to_user(t, oldcounters, tmp.counters,\n\t\t\t\t\ttmp.num_counters, nentries);\n\tif (ret)\n\t\treturn ret;\n\n\t/* set the match/watcher/target names right */\n\treturn EBT_ENTRY_ITERATE(entries, entries_size,\n\t   ebt_entry_to_user, entries, tmp.entries);\n}\n\nstatic int do_ebt_set_ctl(struct sock *sk,\n\tint cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase EBT_SO_SET_ENTRIES:\n\t\tret = do_replace(net, user, len);\n\t\tbreak;\n\tcase EBT_SO_SET_COUNTERS:\n\t\tret = update_counters(net, user, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int do_ebt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\tstruct ebt_replace tmp;\n\tstruct ebt_table *t;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\ttmp.name[sizeof(tmp.name) - 1] = '\\0';\n\n\tt = find_table_lock(net, tmp.name, &ret, &ebt_mutex);\n\tif (!t)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase EBT_SO_GET_INFO:\n\tcase EBT_SO_GET_INIT_INFO:\n\t\tif (*len != sizeof(struct ebt_replace)) {\n\t\t\tret = -EINVAL;\n\t\t\tmutex_unlock(&ebt_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tif (cmd == EBT_SO_GET_INFO) {\n\t\t\ttmp.nentries = t->private->nentries;\n\t\t\ttmp.entries_size = t->private->entries_size;\n\t\t\ttmp.valid_hooks = t->valid_hooks;\n\t\t} else {\n\t\t\ttmp.nentries = t->table->nentries;\n\t\t\ttmp.entries_size = t->table->entries_size;\n\t\t\ttmp.valid_hooks = t->table->valid_hooks;\n\t\t}\n\t\tmutex_unlock(&ebt_mutex);\n\t\tif (copy_to_user(user, &tmp, *len) != 0) {\n\t\t\tBUGPRINT(\"c2u Didn't work\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\n\tcase EBT_SO_GET_ENTRIES:\n\tcase EBT_SO_GET_INIT_ENTRIES:\n\t\tret = copy_everything_to_user(t, user, len, cmd);\n\t\tmutex_unlock(&ebt_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&ebt_mutex);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n/* 32 bit-userspace compatibility definitions. */\nstruct compat_ebt_replace {\n\tchar name[EBT_TABLE_MAXNAMELEN];\n\tcompat_uint_t valid_hooks;\n\tcompat_uint_t nentries;\n\tcompat_uint_t entries_size;\n\t/* start of the chains */\n\tcompat_uptr_t hook_entry[NF_BR_NUMHOOKS];\n\t/* nr of counters userspace expects back */\n\tcompat_uint_t num_counters;\n\t/* where the kernel will put the old counters. */\n\tcompat_uptr_t counters;\n\tcompat_uptr_t entries;\n};\n\n/* struct ebt_entry_match, _target and _watcher have same layout */\nstruct compat_ebt_entry_mwt {\n\tunion {\n\t\tchar name[EBT_FUNCTION_MAXNAMELEN];\n\t\tcompat_uptr_t ptr;\n\t} u;\n\tcompat_uint_t match_size;\n\tcompat_uint_t data[0];\n};\n\n/* account for possible padding between match_size and ->data */\nstatic int ebt_compat_entry_padsize(void)\n{\n\tBUILD_BUG_ON(XT_ALIGN(sizeof(struct ebt_entry_match)) <\n\t\t\tCOMPAT_XT_ALIGN(sizeof(struct compat_ebt_entry_mwt)));\n\treturn (int) XT_ALIGN(sizeof(struct ebt_entry_match)) -\n\t\t\tCOMPAT_XT_ALIGN(sizeof(struct compat_ebt_entry_mwt));\n}\n\nstatic int ebt_compat_match_offset(const struct xt_match *match,\n\t\t\t\t   unsigned int userlen)\n{\n\t/* ebt_among needs special handling. The kernel .matchsize is\n\t * set to -1 at registration time; at runtime an EBT_ALIGN()ed\n\t * value is expected.\n\t * Example: userspace sends 4500, ebt_among.c wants 4504.\n\t */\n\tif (unlikely(match->matchsize == -1))\n\t\treturn XT_ALIGN(userlen) - COMPAT_XT_ALIGN(userlen);\n\treturn xt_compat_match_offset(match);\n}\n\nstatic int compat_match_to_user(struct ebt_entry_match *m, void __user **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tconst struct xt_match *match = m->u.match;\n\tstruct compat_ebt_entry_mwt __user *cm = *dstptr;\n\tint off = ebt_compat_match_offset(match, m->match_size);\n\tcompat_uint_t msize = m->match_size - off;\n\n\tif (WARN_ON(off >= m->match_size))\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(cm->u.name, match->name,\n\t    strlen(match->name) + 1) || put_user(msize, &cm->match_size))\n\t\treturn -EFAULT;\n\n\tif (match->compat_to_user) {\n\t\tif (match->compat_to_user(cm->data, m->data))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (xt_data_to_user(cm->data, m->data, match->usersize, msize,\n\t\t\t\t    COMPAT_XT_ALIGN(msize)))\n\t\t\treturn -EFAULT;\n\t}\n\n\t*size -= ebt_compat_entry_padsize() + off;\n\t*dstptr = cm->data;\n\t*dstptr += msize;\n\treturn 0;\n}\n\nstatic int compat_target_to_user(struct ebt_entry_target *t,\n\t\t\t\t void __user **dstptr,\n\t\t\t\t unsigned int *size)\n{\n\tconst struct xt_target *target = t->u.target;\n\tstruct compat_ebt_entry_mwt __user *cm = *dstptr;\n\tint off = xt_compat_target_offset(target);\n\tcompat_uint_t tsize = t->target_size - off;\n\n\tif (WARN_ON(off >= t->target_size))\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(cm->u.name, target->name,\n\t    strlen(target->name) + 1) || put_user(tsize, &cm->match_size))\n\t\treturn -EFAULT;\n\n\tif (target->compat_to_user) {\n\t\tif (target->compat_to_user(cm->data, t->data))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (xt_data_to_user(cm->data, t->data, target->usersize, tsize,\n\t\t\t\t    COMPAT_XT_ALIGN(tsize)))\n\t\t\treturn -EFAULT;\n\t}\n\n\t*size -= ebt_compat_entry_padsize() + off;\n\t*dstptr = cm->data;\n\t*dstptr += tsize;\n\treturn 0;\n}\n\nstatic int compat_watcher_to_user(struct ebt_entry_watcher *w,\n\t\t\t\t  void __user **dstptr,\n\t\t\t\t  unsigned int *size)\n{\n\treturn compat_target_to_user((struct ebt_entry_target *)w,\n\t\t\t\t\t\t\tdstptr, size);\n}\n\nstatic int compat_copy_entry_to_user(struct ebt_entry *e, void __user **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tstruct ebt_entry_target *t;\n\tstruct ebt_entry __user *ce;\n\tu32 watchers_offset, target_offset, next_offset;\n\tcompat_uint_t origsize;\n\tint ret;\n\n\tif (e->bitmask == 0) {\n\t\tif (*size < sizeof(struct ebt_entries))\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(*dstptr, e, sizeof(struct ebt_entries)))\n\t\t\treturn -EFAULT;\n\n\t\t*dstptr += sizeof(struct ebt_entries);\n\t\t*size -= sizeof(struct ebt_entries);\n\t\treturn 0;\n\t}\n\n\tif (*size < sizeof(*ce))\n\t\treturn -EINVAL;\n\n\tce = *dstptr;\n\tif (copy_to_user(ce, e, sizeof(*ce)))\n\t\treturn -EFAULT;\n\n\torigsize = *size;\n\t*dstptr += sizeof(*ce);\n\n\tret = EBT_MATCH_ITERATE(e, compat_match_to_user, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\twatchers_offset = e->watchers_offset - (origsize - *size);\n\n\tret = EBT_WATCHER_ITERATE(e, compat_watcher_to_user, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\ttarget_offset = e->target_offset - (origsize - *size);\n\n\tt = (struct ebt_entry_target *) ((char *) e + e->target_offset);\n\n\tret = compat_target_to_user(t, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\tnext_offset = e->next_offset - (origsize - *size);\n\n\tif (put_user(watchers_offset, &ce->watchers_offset) ||\n\t    put_user(target_offset, &ce->target_offset) ||\n\t    put_user(next_offset, &ce->next_offset))\n\t\treturn -EFAULT;\n\n\t*size -= sizeof(*ce);\n\treturn 0;\n}\n\nstatic int compat_calc_match(struct ebt_entry_match *m, int *off)\n{\n\t*off += ebt_compat_match_offset(m->u.match, m->match_size);\n\t*off += ebt_compat_entry_padsize();\n\treturn 0;\n}\n\nstatic int compat_calc_watcher(struct ebt_entry_watcher *w, int *off)\n{\n\t*off += xt_compat_target_offset(w->u.watcher);\n\t*off += ebt_compat_entry_padsize();\n\treturn 0;\n}\n\nstatic int compat_calc_entry(const struct ebt_entry *e,\n\t\t\t     const struct ebt_table_info *info,\n\t\t\t     const void *base,\n\t\t\t     struct compat_ebt_replace *newinfo)\n{\n\tconst struct ebt_entry_target *t;\n\tunsigned int entry_offset;\n\tint off, ret, i;\n\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\n\toff = 0;\n\tentry_offset = (void *)e - base;\n\n\tEBT_MATCH_ITERATE(e, compat_calc_match, &off);\n\tEBT_WATCHER_ITERATE(e, compat_calc_watcher, &off);\n\n\tt = (const struct ebt_entry_target *) ((char *) e + e->target_offset);\n\n\toff += xt_compat_target_offset(t->u.target);\n\toff += ebt_compat_entry_padsize();\n\n\tnewinfo->entries_size -= off;\n\n\tret = xt_compat_add_offset(NFPROTO_BRIDGE, entry_offset, off);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tconst void *hookptr = info->hook_entry[i];\n\t\tif (info->hook_entry[i] &&\n\t\t    (e < (struct ebt_entry *)(base - hookptr))) {\n\t\t\tnewinfo->hook_entry[i] -= off;\n\t\t\tpr_debug(\"0x%08X -> 0x%08X\\n\",\n\t\t\t\t\tnewinfo->hook_entry[i] + off,\n\t\t\t\t\tnewinfo->hook_entry[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int compat_table_info(const struct ebt_table_info *info,\n\t\t\t     struct compat_ebt_replace *newinfo)\n{\n\tunsigned int size = info->entries_size;\n\tconst void *entries = info->entries;\n\n\tnewinfo->entries_size = size;\n\n\txt_compat_init_offsets(NFPROTO_BRIDGE, info->nentries);\n\treturn EBT_ENTRY_ITERATE(entries, size, compat_calc_entry, info,\n\t\t\t\t\t\t\tentries, newinfo);\n}\n\nstatic int compat_copy_everything_to_user(struct ebt_table *t,\n\t\t\t\t\t  void __user *user, int *len, int cmd)\n{\n\tstruct compat_ebt_replace repl, tmp;\n\tstruct ebt_counter *oldcounters;\n\tstruct ebt_table_info tinfo;\n\tint ret;\n\tvoid __user *pos;\n\n\tmemset(&tinfo, 0, sizeof(tinfo));\n\n\tif (cmd == EBT_SO_GET_ENTRIES) {\n\t\ttinfo.entries_size = t->private->entries_size;\n\t\ttinfo.nentries = t->private->nentries;\n\t\ttinfo.entries = t->private->entries;\n\t\toldcounters = t->private->counters;\n\t} else {\n\t\ttinfo.entries_size = t->table->entries_size;\n\t\ttinfo.nentries = t->table->nentries;\n\t\ttinfo.entries = t->table->entries;\n\t\toldcounters = t->table->counters;\n\t}\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (tmp.nentries != tinfo.nentries ||\n\t   (tmp.num_counters && tmp.num_counters != tinfo.nentries))\n\t\treturn -EINVAL;\n\n\tmemcpy(&repl, &tmp, sizeof(repl));\n\tif (cmd == EBT_SO_GET_ENTRIES)\n\t\tret = compat_table_info(t->private, &repl);\n\telse\n\t\tret = compat_table_info(&tinfo, &repl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*len != sizeof(tmp) + repl.entries_size +\n\t   (tmp.num_counters? tinfo.nentries * sizeof(struct ebt_counter): 0)) {\n\t\tpr_err(\"wrong size: *len %d, entries_size %u, replsz %d\\n\",\n\t\t\t\t*len, tinfo.entries_size, repl.entries_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* userspace might not need the counters */\n\tret = copy_counters_to_user(t, oldcounters, compat_ptr(tmp.counters),\n\t\t\t\t\ttmp.num_counters, tinfo.nentries);\n\tif (ret)\n\t\treturn ret;\n\n\tpos = compat_ptr(tmp.entries);\n\treturn EBT_ENTRY_ITERATE(tinfo.entries, tinfo.entries_size,\n\t\t\tcompat_copy_entry_to_user, &pos, &tmp.entries_size);\n}\n\nstruct ebt_entries_buf_state {\n\tchar *buf_kern_start;\t/* kernel buffer to copy (translated) data to */\n\tu32 buf_kern_len;\t/* total size of kernel buffer */\n\tu32 buf_kern_offset;\t/* amount of data copied so far */\n\tu32 buf_user_offset;\t/* read position in userspace buffer */\n};\n\nstatic int ebt_buf_count(struct ebt_entries_buf_state *state, unsigned int sz)\n{\n\tstate->buf_kern_offset += sz;\n\treturn state->buf_kern_offset >= sz ? 0 : -EINVAL;\n}\n\nstatic int ebt_buf_add(struct ebt_entries_buf_state *state,\n\t\t       void *data, unsigned int sz)\n{\n\tif (state->buf_kern_start == NULL)\n\t\tgoto count_only;\n\n\tif (WARN_ON(state->buf_kern_offset + sz > state->buf_kern_len))\n\t\treturn -EINVAL;\n\n\tmemcpy(state->buf_kern_start + state->buf_kern_offset, data, sz);\n\n count_only:\n\tstate->buf_user_offset += sz;\n\treturn ebt_buf_count(state, sz);\n}\n\nstatic int ebt_buf_add_pad(struct ebt_entries_buf_state *state, unsigned int sz)\n{\n\tchar *b = state->buf_kern_start;\n\n\tif (WARN_ON(b && state->buf_kern_offset > state->buf_kern_len))\n\t\treturn -EINVAL;\n\n\tif (b != NULL && sz > 0)\n\t\tmemset(b + state->buf_kern_offset, 0, sz);\n\t/* do not adjust ->buf_user_offset here, we added kernel-side padding */\n\treturn ebt_buf_count(state, sz);\n}\n\nenum compat_mwt {\n\tEBT_COMPAT_MATCH,\n\tEBT_COMPAT_WATCHER,\n\tEBT_COMPAT_TARGET,\n};\n\nstatic int compat_mtw_from_user(struct compat_ebt_entry_mwt *mwt,\n\t\t\t\tenum compat_mwt compat_mwt,\n\t\t\t\tstruct ebt_entries_buf_state *state,\n\t\t\t\tconst unsigned char *base)\n{\n\tchar name[EBT_FUNCTION_MAXNAMELEN];\n\tstruct xt_match *match;\n\tstruct xt_target *wt;\n\tvoid *dst = NULL;\n\tint off, pad = 0;\n\tunsigned int size_kern, match_size = mwt->match_size;\n\n\tstrlcpy(name, mwt->u.name, sizeof(name));\n\n\tif (state->buf_kern_start)\n\t\tdst = state->buf_kern_start + state->buf_kern_offset;\n\n\tswitch (compat_mwt) {\n\tcase EBT_COMPAT_MATCH:\n\t\tmatch = xt_request_find_match(NFPROTO_BRIDGE, name, 0);\n\t\tif (IS_ERR(match))\n\t\t\treturn PTR_ERR(match);\n\n\t\toff = ebt_compat_match_offset(match, match_size);\n\t\tif (dst) {\n\t\t\tif (match->compat_from_user)\n\t\t\t\tmatch->compat_from_user(dst, mwt->data);\n\t\t\telse\n\t\t\t\tmemcpy(dst, mwt->data, match_size);\n\t\t}\n\n\t\tsize_kern = match->matchsize;\n\t\tif (unlikely(size_kern == -1))\n\t\t\tsize_kern = match_size;\n\t\tmodule_put(match->me);\n\t\tbreak;\n\tcase EBT_COMPAT_WATCHER: /* fallthrough */\n\tcase EBT_COMPAT_TARGET:\n\t\twt = xt_request_find_target(NFPROTO_BRIDGE, name, 0);\n\t\tif (IS_ERR(wt))\n\t\t\treturn PTR_ERR(wt);\n\t\toff = xt_compat_target_offset(wt);\n\n\t\tif (dst) {\n\t\t\tif (wt->compat_from_user)\n\t\t\t\twt->compat_from_user(dst, mwt->data);\n\t\t\telse\n\t\t\t\tmemcpy(dst, mwt->data, match_size);\n\t\t}\n\n\t\tsize_kern = wt->targetsize;\n\t\tmodule_put(wt->me);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstate->buf_kern_offset += match_size + off;\n\tstate->buf_user_offset += match_size;\n\tpad = XT_ALIGN(size_kern) - size_kern;\n\n\tif (pad > 0 && dst) {\n\t\tif (WARN_ON(state->buf_kern_len <= pad))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(state->buf_kern_offset - (match_size + off) + size_kern > state->buf_kern_len - pad))\n\t\t\treturn -EINVAL;\n\t\tmemset(dst + size_kern, 0, pad);\n\t}\n\treturn off + match_size;\n}\n\n/* return size of all matches, watchers or target, including necessary\n * alignment and padding.\n */\nstatic int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\n\tif (size_left == 0)\n\t\treturn 0;\n\n\tbuf = (char *) match32;\n\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\n\t\t/* add padding before match->data (if any) */\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\n\t\tsize_left -= match32->match_size;\n\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\n\t\tif (WARN_ON(type == EBT_COMPAT_TARGET && size_left))\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\n\treturn growth;\n}\n\n/* called for all ebt_entry structures. */\nstatic int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,\n\t\t\t  unsigned int *total,\n\t\t\t  struct ebt_entries_buf_state *state)\n{\n\tunsigned int i, j, startoff, new_offset = 0;\n\t/* stores match/watchers/targets & offset of next struct ebt_entry: */\n\tunsigned int offsets[4];\n\tunsigned int *offsets_update = NULL;\n\tint ret;\n\tchar *buf_start;\n\n\tif (*total < sizeof(struct ebt_entries))\n\t\treturn -EINVAL;\n\n\tif (!entry->bitmask) {\n\t\t*total -= sizeof(struct ebt_entries);\n\t\treturn ebt_buf_add(state, entry, sizeof(struct ebt_entries));\n\t}\n\tif (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))\n\t\treturn -EINVAL;\n\n\tstartoff = state->buf_user_offset;\n\t/* pull in most part of ebt_entry, it does not need to be changed. */\n\tret = ebt_buf_add(state, entry,\n\t\t\toffsetof(struct ebt_entry, watchers_offset));\n\tif (ret < 0)\n\t\treturn ret;\n\n\toffsets[0] = sizeof(struct ebt_entry); /* matches come first */\n\tmemcpy(&offsets[1], &entry->watchers_offset,\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\n\tif (state->buf_kern_start) {\n\t\tbuf_start = state->buf_kern_start + state->buf_kern_offset;\n\t\toffsets_update = (unsigned int *) buf_start;\n\t}\n\tret = ebt_buf_add(state, &offsets[1],\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf_start = (char *) entry;\n\t/* 0: matches offset, always follows ebt_entry.\n\t * 1: watchers offset, from ebt_entry structure\n\t * 2: target offset, from ebt_entry structure\n\t * 3: next ebt_entry offset, from ebt_entry structure\n\t *\n\t * offsets are relative to beginning of struct ebt_entry (i.e., 0).\n\t */\n\tfor (i = 0; i < 4 ; ++i) {\n\t\tif (offsets[i] >= *total)\n\t\t\treturn -EINVAL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (offsets[i-1] > offsets[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\n\t\tstruct compat_ebt_entry_mwt *match32;\n\t\tunsigned int size;\n\t\tchar *buf = buf_start + offsets[i];\n\n\t\tif (offsets[i] > offsets[j])\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t\tsize = offsets[j] - offsets[i];\n\t\tret = ebt_size_mwt(match32, size, i, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_offset += ret;\n\t\tif (offsets_update && new_offset) {\n\t\t\tpr_debug(\"change offset %d to %d\\n\",\n\t\t\t\toffsets_update[i], offsets[j] + new_offset);\n\t\t\toffsets_update[i] = offsets[j] + new_offset;\n\t\t}\n\t}\n\n\tif (state->buf_kern_start == NULL) {\n\t\tunsigned int offset = buf_start - (char *) base;\n\n\t\tret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstartoff = state->buf_user_offset - startoff;\n\n\tif (WARN_ON(*total < startoff))\n\t\treturn -EINVAL;\n\t*total -= startoff;\n\treturn 0;\n}\n\n/* repl->entries_size is the size of the ebt_entry blob in userspace.\n * It might need more memory when copied to a 64 bit kernel in case\n * userspace is 32-bit. So, first task: find out how much memory is needed.\n *\n * Called before validation is performed.\n */\nstatic int compat_copy_entries(unsigned char *data, unsigned int size_user,\n\t\t\t\tstruct ebt_entries_buf_state *state)\n{\n\tunsigned int size_remaining = size_user;\n\tint ret;\n\n\tret = EBT_ENTRY_ITERATE(data, size_user, size_entry_mwt, data,\n\t\t\t\t\t&size_remaining, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tWARN_ON(size_remaining);\n\treturn state->buf_kern_offset;\n}\n\n\nstatic int compat_copy_ebt_replace_from_user(struct ebt_replace *repl,\n\t\t\t\t\t    void __user *user, unsigned int len)\n{\n\tstruct compat_ebt_replace tmp;\n\tint i;\n\n\tif (len < sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size)\n\t\treturn -EINVAL;\n\n\tif (tmp.entries_size == 0)\n\t\treturn -EINVAL;\n\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\n\tmemcpy(repl, &tmp, offsetof(struct ebt_replace, hook_entry));\n\n\t/* starting with hook_entry, 32 vs. 64 bit structures are different */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++)\n\t\trepl->hook_entry[i] = compat_ptr(tmp.hook_entry[i]);\n\n\trepl->num_counters = tmp.num_counters;\n\trepl->counters = compat_ptr(tmp.counters);\n\trepl->entries = compat_ptr(tmp.entries);\n\treturn 0;\n}\n\nstatic int compat_do_replace(struct net *net, void __user *user,\n\t\t\t     unsigned int len)\n{\n\tint ret, i, countersize, size64;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\tstruct ebt_entries_buf_state state;\n\tvoid *entries_tmp;\n\n\tret = compat_copy_ebt_replace_from_user(&tmp, user, len);\n\tif (ret) {\n\t\t/* try real handler in case userland supplied needed padding */\n\t\tif (ret == -EINVAL && do_replace(net, user, len) == 0)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tmemset(&state, 0, sizeof(state));\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tentries_tmp = newinfo->entries;\n\n\txt_compat_lock(NFPROTO_BRIDGE);\n\n\txt_compat_init_offsets(NFPROTO_BRIDGE, tmp.nentries);\n\tret = compat_copy_entries(entries_tmp, tmp.entries_size, &state);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tpr_debug(\"tmp.entries_size %d, kern off %d, user off %d delta %d\\n\",\n\t\ttmp.entries_size, state.buf_kern_offset, state.buf_user_offset,\n\t\txt_compat_calc_jump(NFPROTO_BRIDGE, tmp.entries_size));\n\n\tsize64 = ret;\n\tnewinfo->entries = vmalloc(size64);\n\tif (!newinfo->entries) {\n\t\tvfree(entries_tmp);\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.buf_kern_start = newinfo->entries;\n\tstate.buf_kern_len = size64;\n\n\tret = compat_copy_entries(entries_tmp, tmp.entries_size, &state);\n\tif (WARN_ON(ret < 0))\n\t\tgoto out_unlock;\n\n\tvfree(entries_tmp);\n\ttmp.entries_size = size64;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tchar __user *usrptr;\n\t\tif (tmp.hook_entry[i]) {\n\t\t\tunsigned int delta;\n\t\t\tusrptr = (char __user *) tmp.hook_entry[i];\n\t\t\tdelta = usrptr - tmp.entries;\n\t\t\tusrptr += xt_compat_calc_jump(NFPROTO_BRIDGE, delta);\n\t\t\ttmp.hook_entry[i] = (struct ebt_entries __user *)usrptr;\n\t\t}\n\t}\n\n\txt_compat_flush_offsets(NFPROTO_BRIDGE);\n\txt_compat_unlock(NFPROTO_BRIDGE);\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(NFPROTO_BRIDGE);\n\txt_compat_unlock(NFPROTO_BRIDGE);\n\tgoto free_entries;\n}\n\nstatic int compat_update_counters(struct net *net, void __user *user,\n\t\t\t\t  unsigned int len)\n{\n\tstruct compat_ebt_replace hlp;\n\n\tif (copy_from_user(&hlp, user, sizeof(hlp)))\n\t\treturn -EFAULT;\n\n\t/* try real handler in case userland supplied needed padding */\n\tif (len != sizeof(hlp) + hlp.num_counters * sizeof(struct ebt_counter))\n\t\treturn update_counters(net, user, len);\n\n\treturn do_update_counters(net, hlp.name, compat_ptr(hlp.counters),\n\t\t\t\t\thlp.num_counters, user, len);\n}\n\nstatic int compat_do_ebt_set_ctl(struct sock *sk,\n\t\tint cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase EBT_SO_SET_ENTRIES:\n\t\tret = compat_do_replace(net, user, len);\n\t\tbreak;\n\tcase EBT_SO_SET_COUNTERS:\n\t\tret = compat_update_counters(net, user, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int compat_do_ebt_get_ctl(struct sock *sk, int cmd,\n\t\tvoid __user *user, int *len)\n{\n\tint ret;\n\tstruct compat_ebt_replace tmp;\n\tstruct ebt_table *t;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\t/* try real handler in case userland supplied needed padding */\n\tif ((cmd == EBT_SO_GET_INFO ||\n\t     cmd == EBT_SO_GET_INIT_INFO) && *len != sizeof(tmp))\n\t\t\treturn do_ebt_get_ctl(sk, cmd, user, len);\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\ttmp.name[sizeof(tmp.name) - 1] = '\\0';\n\n\tt = find_table_lock(net, tmp.name, &ret, &ebt_mutex);\n\tif (!t)\n\t\treturn ret;\n\n\txt_compat_lock(NFPROTO_BRIDGE);\n\tswitch (cmd) {\n\tcase EBT_SO_GET_INFO:\n\t\ttmp.nentries = t->private->nentries;\n\t\tret = compat_table_info(t->private, &tmp);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\ttmp.valid_hooks = t->valid_hooks;\n\n\t\tif (copy_to_user(user, &tmp, *len) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase EBT_SO_GET_INIT_INFO:\n\t\ttmp.nentries = t->table->nentries;\n\t\ttmp.entries_size = t->table->entries_size;\n\t\ttmp.valid_hooks = t->table->valid_hooks;\n\n\t\tif (copy_to_user(user, &tmp, *len) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase EBT_SO_GET_ENTRIES:\n\tcase EBT_SO_GET_INIT_ENTRIES:\n\t\t/* try real handler first in case of userland-side padding.\n\t\t * in case we are dealing with an 'ordinary' 32 bit binary\n\t\t * without 64bit compatibility padding, this will fail right\n\t\t * after copy_from_user when the *len argument is validated.\n\t\t *\n\t\t * the compat_ variant needs to do one pass over the kernel\n\t\t * data set to adjust for size differences before it the check.\n\t\t */\n\t\tif (copy_everything_to_user(t, user, len, cmd) == 0)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = compat_copy_everything_to_user(t, user, len, cmd);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n out:\n\txt_compat_flush_offsets(NFPROTO_BRIDGE);\n\txt_compat_unlock(NFPROTO_BRIDGE);\n\tmutex_unlock(&ebt_mutex);\n\treturn ret;\n}\n#endif\n\nstatic struct nf_sockopt_ops ebt_sockopts = {\n\t.pf\t\t= PF_INET,\n\t.set_optmin\t= EBT_BASE_CTL,\n\t.set_optmax\t= EBT_SO_SET_MAX + 1,\n\t.set\t\t= do_ebt_set_ctl,\n#ifdef CONFIG_COMPAT\n\t.compat_set\t= compat_do_ebt_set_ctl,\n#endif\n\t.get_optmin\t= EBT_BASE_CTL,\n\t.get_optmax\t= EBT_SO_GET_MAX + 1,\n\t.get\t\t= do_ebt_get_ctl,\n#ifdef CONFIG_COMPAT\n\t.compat_get\t= compat_do_ebt_get_ctl,\n#endif\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init ebtables_init(void)\n{\n\tint ret;\n\n\tret = xt_register_target(&ebt_standard_target);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = nf_register_sockopt(&ebt_sockopts);\n\tif (ret < 0) {\n\t\txt_unregister_target(&ebt_standard_target);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit ebtables_fini(void)\n{\n\tnf_unregister_sockopt(&ebt_sockopts);\n\txt_unregister_target(&ebt_standard_target);\n}\n\nEXPORT_SYMBOL(ebt_register_table);\nEXPORT_SYMBOL(ebt_unregister_table);\nEXPORT_SYMBOL(ebt_do_table);\nmodule_init(ebtables_init);\nmodule_exit(ebtables_fini);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["net/bridge/netfilter/ebtables.c"], "buggy_code_start_loc": [2063], "buggy_code_end_loc": [2118], "fixing_code_start_loc": [2063], "fixing_code_end_loc": [2130], "type": "CWE-787", "message": "A flaw was found in the Linux 4.x kernel's implementation of 32-bit syscall interface for bridging. This allowed a privileged user to arbitrarily write to a limited range of kernel memory.", "other": {"cve": {"id": "CVE-2018-1068", "sourceIdentifier": "secalert@redhat.com", "published": "2018-03-16T16:29:00.207", "lastModified": "2019-05-14T23:29:04.857", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in the Linux 4.x kernel's implementation of 32-bit syscall interface for bridging. This allowed a privileged user to arbitrarily write to a limited range of kernel memory."}, {"lang": "es", "value": "Se ha encontrado un error en la implementaci\u00f3n de la interfaz syscall de 32 bits para puentes de red (bridging) en el kernel de las versiones 4.x de Linux. Esto permit\u00eda que un usuario privilegiado escribiese de forma arbitraria en un rango limitado de memoria del kernel."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndIncluding": "4.16", "matchCriteriaId": "3A19DAE3-65E5-44AB-ACA6-A347E14EADAC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization_host:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB28F9AF-3D06-4532-B397-96D7E4792503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/103459", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1318", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1355", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2948", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1170", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1190", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4159", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1552048", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b71812168571fa55e44cdd0254471331b9c4c4c6", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b71812168571fa55e44cdd0254471331b9c4c4c6", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/05/msg00000.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://marc.info/?l=linux-netdev&m=152023808817590&w=2", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://marc.info/?l=linux-netdev&m=152025888924151&w=2", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3654-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3654-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3656-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3674-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3674-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3677-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3677-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4187", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4188", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b71812168571fa55e44cdd0254471331b9c4c4c6"}}