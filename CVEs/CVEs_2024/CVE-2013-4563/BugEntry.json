{"buggy_code": ["/*\n *\tIPV6 GSO/GRO offload support\n *\tLinux INET6 implementation\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *      UDPv6 GSO support\n */\n#include <linux/skbuff.h>\n#include <net/protocol.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <net/ip6_checksum.h>\n#include \"ip6_offload.h\"\n\nstatic int udp6_ufo_send_check(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *ipv6h;\n\tstruct udphdr *uh;\n\n\tif (!pskb_may_pull(skb, sizeof(*uh)))\n\t\treturn -EINVAL;\n\n\tif (likely(!skb->encapsulation)) {\n\t\tipv6h = ipv6_hdr(skb);\n\t\tuh = udp_hdr(skb);\n\n\t\tuh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,\n\t\t\t\t\t     IPPROTO_UDP, 0);\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tint tnl_hlen;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP |\n\t\t\t\t      SKB_GSO_DODGY |\n\t\t\t\t      SKB_GSO_UDP_TUNNEL |\n\t\t\t\t      SKB_GSO_GRE |\n\t\t\t\t      SKB_GSO_IPIP |\n\t\t\t\t      SKB_GSO_SIT |\n\t\t\t\t      SKB_GSO_MPLS) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\n\t\tsegs = skb_udp_tunnel_segment(skb, features);\n\telse {\n\t\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t\t * do checksum of UDP packets sent as multiple IP fragments.\n\t\t */\n\t\toffset = skb_checksum_start_offset(skb);\n\t\tcsum = skb_checksum(skb, offset, skb->len - offset, 0);\n\t\toffset += skb->csum_offset;\n\t\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\t/* Check if there is enough headroom to insert fragment header. */\n\t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {\n\t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t\t * bytes to insert fragment header.\n\t\t */\n\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));\n\n\t\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t\t * fragment header are updated in ipv6_gso_segment()\n\t\t */\n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}\nstatic const struct net_offload udpv6_offload = {\n\t.callbacks = {\n\t\t.gso_send_check =\tudp6_ufo_send_check,\n\t\t.gso_segment\t=\tudp6_ufo_fragment,\n\t},\n};\n\nint __init udp_offload_init(void)\n{\n\treturn inet6_add_offload(&udpv6_offload, IPPROTO_UDP);\n}\n"], "fixing_code": ["/*\n *\tIPV6 GSO/GRO offload support\n *\tLinux INET6 implementation\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *      UDPv6 GSO support\n */\n#include <linux/skbuff.h>\n#include <net/protocol.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <net/ip6_checksum.h>\n#include \"ip6_offload.h\"\n\nstatic int udp6_ufo_send_check(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *ipv6h;\n\tstruct udphdr *uh;\n\n\tif (!pskb_may_pull(skb, sizeof(*uh)))\n\t\treturn -EINVAL;\n\n\tif (likely(!skb->encapsulation)) {\n\t\tipv6h = ipv6_hdr(skb);\n\t\tuh = udp_hdr(skb);\n\n\t\tuh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,\n\t\t\t\t\t     IPPROTO_UDP, 0);\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tint tnl_hlen;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP |\n\t\t\t\t      SKB_GSO_DODGY |\n\t\t\t\t      SKB_GSO_UDP_TUNNEL |\n\t\t\t\t      SKB_GSO_GRE |\n\t\t\t\t      SKB_GSO_IPIP |\n\t\t\t\t      SKB_GSO_SIT |\n\t\t\t\t      SKB_GSO_MPLS) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\n\t\tsegs = skb_udp_tunnel_segment(skb, features);\n\telse {\n\t\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t\t * do checksum of UDP packets sent as multiple IP fragments.\n\t\t */\n\t\toffset = skb_checksum_start_offset(skb);\n\t\tcsum = skb_checksum(skb, offset, skb->len - offset, 0);\n\t\toffset += skb->csum_offset;\n\t\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\t/* Check if there is enough headroom to insert fragment header. */\n\t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\n\t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t\t * bytes to insert fragment header.\n\t\t */\n\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));\n\n\t\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t\t * fragment header are updated in ipv6_gso_segment()\n\t\t */\n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}\nstatic const struct net_offload udpv6_offload = {\n\t.callbacks = {\n\t\t.gso_send_check =\tudp6_ufo_send_check,\n\t\t.gso_segment\t=\tudp6_ufo_fragment,\n\t},\n};\n\nint __init udp_offload_init(void)\n{\n\treturn inet6_add_offload(&udpv6_offload, IPPROTO_UDP);\n}\n"], "filenames": ["net/ipv6/udp_offload.c"], "buggy_code_start_loc": [93], "buggy_code_end_loc": [94], "fixing_code_start_loc": [93], "fixing_code_end_loc": [94], "type": "CWE-189", "message": "The udp6_ufo_fragment function in net/ipv6/udp_offload.c in the Linux kernel through 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly perform a certain size comparison before inserting a fragment header, which allows remote attackers to cause a denial of service (panic) via a large IPv6 UDP packet, as demonstrated by use of the Token Bucket Filter (TBF) queueing discipline.", "other": {"cve": {"id": "CVE-2013-4563", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-20T13:19:41.697", "lastModified": "2023-05-19T16:50:53.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The udp6_ufo_fragment function in net/ipv6/udp_offload.c in the Linux kernel through 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly perform a certain size comparison before inserting a fragment header, which allows remote attackers to cause a denial of service (panic) via a large IPv6 UDP packet, as demonstrated by use of the Token Bucket Filter (TBF) queueing discipline."}, {"lang": "es", "value": "La funci\u00f3n udp6_ufo_fragment en net/ipv6/udp_offload.c del kernel de Linux hasta la versi\u00f3n 3.12, cuando est\u00e1 activado UDP Fragmentation Offload (UFO), no realiza adecuadamente comparaciones de cierto tama\u00f1o antes de insertar una cabecera fragmentada, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (panic) a trav\u00e9s de un paquete IPv6 UDP grande, tal y como se demostr\u00f3 mediante el uso de Token Bucket Filter (TBF)."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.9.8", "versionEndIncluding": "3.10.23", "matchCriteriaId": "0E06431E-08C2-49B3-9479-9E506C545BD5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.4", "matchCriteriaId": "98872EEB-8D10-4CF6-9592-F9CE1090365D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:13.10:*:*:*:*:*:*:*", "matchCriteriaId": "7F61F047-129C-41A6-8A27-FFCBB8563E91"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=0e033e04c2678dbbe74a46b23fffb7bb918c288e", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-02/msg00003.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2013/11/13/9", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.ubuntu.com/usn/USN-2113-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2117-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1030015", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e"}}