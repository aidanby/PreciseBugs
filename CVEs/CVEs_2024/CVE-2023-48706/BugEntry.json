{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_cmds.c: some functions for command line commands\n */\n\n#include \"vim.h\"\n#include \"version.h\"\n\n#include <float.h>\n\nstatic int linelen(int *has_tab);\nstatic void do_filter(linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out);\nstatic int not_writing(void);\nstatic int check_readonly(int *forceit, buf_T *buf);\nstatic void delbuf_msg(char_u *name);\n\n/*\n * \":ascii\" and \"ga\".\n */\n    void\ndo_ascii(exarg_T *eap UNUSED)\n{\n    int\t\tc;\n    int\t\tcval;\n    char\tbuf1[20];\n    char\tbuf2[20];\n    char_u\tbuf3[7];\n#ifdef FEAT_DIGRAPHS\n    char_u      *dig;\n#endif\n    int\t\tcc[MAX_MCO];\n    int\t\tci = 0;\n    int\t\tlen;\n\n    if (enc_utf8)\n\tc = utfc_ptr2char(ml_get_cursor(), cc);\n    else\n\tc = gchar_cursor();\n    if (c == NUL)\n    {\n\tmsg(\"NUL\");\n\treturn;\n    }\n\n    IObuff[0] = NUL;\n    if (!has_mbyte || (enc_dbcs != 0 && c < 0x100) || c < 0x80)\n    {\n\tif (c == NL)\t    // NUL is stored as NL\n\t    c = NUL;\n\tif (c == CAR && get_fileformat(curbuf) == EOL_MAC)\n\t    cval = NL;\t    // NL is stored as CR\n\telse\n\t    cval = c;\n\tif (vim_isprintc_strict(c) && (c < ' ' || c > '~'))\n\t{\n\t    transchar_nonprint(curbuf, buf3, c);\n\t    vim_snprintf(buf1, sizeof(buf1), \"  <%s>\", (char *)buf3);\n\t}\n\telse\n\t    buf1[0] = NUL;\n\tif (c >= 0x80)\n\t    vim_snprintf(buf2, sizeof(buf2), \"  <M-%s>\",\n\t\t\t\t\t\t (char *)transchar(c & 0x7f));\n\telse\n\t    buf2[0] = NUL;\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(cval);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Oct %03o, Digr %s\"),\n\t\t\t      transchar(c), buf1, buf2, cval, cval, cval, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Octal %03o\"),\n\t\t\t\t  transchar(c), buf1, buf2, cval, cval, cval);\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    // Repeat for combining characters.\n    while (has_mbyte && (c >= 0x100 || (enc_utf8 && c >= 0x80)))\n    {\n\tlen = (int)STRLEN(IObuff);\n\t// This assumes every multi-byte char is printable...\n\tif (len > 0)\n\t    IObuff[len++] = ' ';\n\tIObuff[len++] = '<';\n\tif (enc_utf8 && utf_iscomposing(c)\n#ifdef USE_GUI\n\t\t&& !gui.in_use\n#endif\n\t\t)\n\t    IObuff[len++] = ' '; // draw composing char on top of a space\n\tlen += (*mb_char2bytes)(c, IObuff + len);\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(c);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\tc < 0x10000 ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")\n\t\t\t\t    : _(\"> %d, Hex %08x, Oct %o, Digr %s\"),\n\t\t\t\t\tc, c, c, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\t c < 0x10000 ? _(\"> %d, Hex %04x, Octal %o\")\n\t\t\t\t     : _(\"> %d, Hex %08x, Octal %o\"),\n\t\t\t\t     c, c, c);\n\tif (ci == MAX_MCO)\n\t    break;\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    msg((char *)IObuff);\n}\n\n/*\n * \":left\", \":center\" and \":right\": align text.\n */\n    void\nex_align(exarg_T *eap)\n{\n    pos_T\tsave_curpos;\n    int\t\tlen;\n    int\t\tindent = 0;\n    int\t\tnew_indent;\n    int\t\thas_tab;\n    int\t\twidth;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl)\n    {\n\t// switch left and right aligning\n\tif (eap->cmdidx == CMD_right)\n\t    eap->cmdidx = CMD_left;\n\telse if (eap->cmdidx == CMD_left)\n\t    eap->cmdidx = CMD_right;\n    }\n#endif\n\n    width = atoi((char *)eap->arg);\n    save_curpos = curwin->w_cursor;\n    if (eap->cmdidx == CMD_left)    // width is used for new indent\n    {\n\tif (width >= 0)\n\t    indent = width;\n    }\n    else\n    {\n\t/*\n\t * if 'textwidth' set, use it\n\t * else if 'wrapmargin' set, use it\n\t * if invalid value, use 80\n\t */\n\tif (width <= 0)\n\t    width = curbuf->b_p_tw;\n\tif (width == 0 && curbuf->b_p_wm > 0)\n\t    width = curwin->w_width - curbuf->b_p_wm;\n\tif (width <= 0)\n\t    width = 80;\n    }\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n\n    for (curwin->w_cursor.lnum = eap->line1;\n\t\t curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum)\n    {\n\tif (eap->cmdidx == CMD_left)\t\t// left align\n\t    new_indent = indent;\n\telse\n\t{\n\t    has_tab = FALSE;\t// avoid uninit warnings\n\t    len = linelen(eap->cmdidx == CMD_right ? &has_tab\n\t\t\t\t\t\t   : NULL) - get_indent();\n\n\t    if (len <= 0)\t\t\t// skip blank lines\n\t\tcontinue;\n\n\t    if (eap->cmdidx == CMD_center)\n\t\tnew_indent = (width - len) / 2;\n\t    else\n\t    {\n\t\tnew_indent = width - len;\t// right align\n\n\t\t/*\n\t\t * Make sure that embedded TABs don't make the text go too far\n\t\t * to the right.\n\t\t */\n\t\tif (has_tab)\n\t\t    while (new_indent > 0)\n\t\t    {\n\t\t\t(void)set_indent(new_indent, 0);\n\t\t\tif (linelen(NULL) <= width)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Now try to move the line as much as possible to\n\t\t\t     * the right.  Stop when it moves too far.\n\t\t\t     */\n\t\t\t    do\n\t\t\t\t(void)set_indent(++new_indent, 0);\n\t\t\t    while (linelen(NULL) <= width);\n\t\t\t    --new_indent;\n\t\t\t    break;\n\t\t\t}\n\t\t\t--new_indent;\n\t\t    }\n\t    }\n\t}\n\tif (new_indent < 0)\n\t    new_indent = 0;\n\t(void)set_indent(new_indent, 0);\t\t// set indent\n    }\n    changed_lines(eap->line1, 0, eap->line2 + 1, 0L);\n    curwin->w_cursor = save_curpos;\n    beginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * Get the length of the current line, excluding trailing white space.\n */\n    static int\nlinelen(int *has_tab)\n{\n    char_u  *line;\n    char_u  *first;\n    char_u  *last;\n    int\t    save;\n    int\t    len;\n\n    // Get the line.  If it's empty bail out early (could be the empty string\n    // for an unloaded buffer).\n    line = ml_get_curline();\n    if (*line == NUL)\n\treturn 0;\n\n    // find the first non-blank character\n    first = skipwhite(line);\n\n    // find the character after the last non-blank character\n    for (last = first + STRLEN(first);\n\t\t\t\tlast > first && VIM_ISWHITE(last[-1]); --last)\n\t;\n    save = *last;\n    *last = NUL;\n    len = linetabsize_str(line);\t// get line length on screen\n    if (has_tab != NULL)\t\t// check for embedded TAB\n\t*has_tab = (vim_strchr(first, TAB) != NULL);\n    *last = save;\n\n    return len;\n}\n\n// Buffer for two lines used during sorting.  They are allocated to\n// contain the longest line being sorted.\nstatic char_u\t*sortbuf1;\nstatic char_u\t*sortbuf2;\n\nstatic int\tsort_lc;\t// sort using locale\nstatic int\tsort_ic;\t// ignore case\nstatic int\tsort_nr;\t// sort on number\nstatic int\tsort_rx;\t// sort on regex instead of skipping it\nstatic int\tsort_flt;\t// sort on floating number\n\nstatic int\tsort_abort;\t// flag to indicate if sorting has been interrupted\n\n// Struct to store info to be sorted.\ntypedef struct\n{\n    linenr_T\tlnum;\t\t\t// line number\n    union {\n\tstruct\n\t{\n\t    varnumber_T\tstart_col_nr;\t// starting column number\n\t    varnumber_T\tend_col_nr;\t// ending column number\n\t} line;\n\tstruct\n\t{\n\t    varnumber_T\tvalue;\t\t// value if sorting by integer\n\t    int is_number;\t\t// TRUE when line contains a number\n\t} num;\n\tfloat_T value_flt;\t\t// value if sorting by float\n    } st_u;\n} sorti_T;\n\n    static int\nstring_compare(const void *s1, const void *s2)\n{\n    if (sort_lc)\n\treturn strcoll((char *)s1, (char *)s2);\n    return sort_ic ? STRICMP(s1, s2) : STRCMP(s1, s2);\n}\n\n    static int\nsort_compare(const void *s1, const void *s2)\n{\n    sorti_T\tl1 = *(sorti_T *)s1;\n    sorti_T\tl2 = *(sorti_T *)s2;\n    int\t\tresult = 0;\n\n    // If the user interrupts, there's no way to stop qsort() immediately, but\n    // if we return 0 every time, qsort will assume it's done sorting and\n    // exit.\n    if (sort_abort)\n\treturn 0;\n    fast_breakcheck();\n    if (got_int)\n\tsort_abort = TRUE;\n\n    if (sort_nr)\n    {\n\tif (l1.st_u.num.is_number != l2.st_u.num.is_number)\n\t    result = l1.st_u.num.is_number - l2.st_u.num.is_number;\n\telse\n\t    result = l1.st_u.num.value == l2.st_u.num.value ? 0\n\t\t\t     : l1.st_u.num.value > l2.st_u.num.value ? 1 : -1;\n    }\n    else if (sort_flt)\n\tresult = l1.st_u.value_flt == l2.st_u.value_flt ? 0\n\t\t\t     : l1.st_u.value_flt > l2.st_u.value_flt ? 1 : -1;\n    else\n    {\n\t// We need to copy one line into \"sortbuf1\", because there is no\n\t// guarantee that the first pointer becomes invalid when obtaining the\n\t// second one.\n\tSTRNCPY(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,\n\t\t     l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1);\n\tsortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = 0;\n\tSTRNCPY(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,\n\t\t     l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1);\n\tsortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = 0;\n\n\tresult = string_compare(sortbuf1, sortbuf2);\n    }\n\n    // If two lines have the same value, preserve the original line order.\n    if (result == 0)\n\treturn (int)(l1.lnum - l2.lnum);\n    return result;\n}\n\n/*\n * \":sort\".\n */\n    void\nex_sort(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    int\t\tlen;\n    linenr_T\tlnum;\n    long\tmaxlen = 0;\n    sorti_T\t*nrs;\n    size_t\tcount = (size_t)(eap->line2 - eap->line1 + 1);\n    size_t\ti;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*s2;\n    char_u\tc;\t\t\t// temporary character storage\n    int\t\tunique = FALSE;\n    long\tdeleted;\n    colnr_T\tstart_col;\n    colnr_T\tend_col;\n    int\t\tsort_what = 0;\n    int\t\tformat_found = 0;\n    int\t\tchange_occurred = FALSE; // Buffer contents changed.\n\n    // Sorting one line is really quick!\n    if (count <= 1)\n\treturn;\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n    sortbuf1 = NULL;\n    sortbuf2 = NULL;\n    regmatch.regprog = NULL;\n    nrs = ALLOC_MULT(sorti_T, count);\n    if (nrs == NULL)\n\tgoto sortend;\n\n    sort_abort = sort_ic = sort_lc = sort_rx = sort_nr = 0;\n    sort_flt = 0;\n\n    for (p = eap->arg; *p != NUL; ++p)\n    {\n\tif (VIM_ISWHITE(*p))\n\t    ;\n\telse if (*p == 'i')\n\t    sort_ic = TRUE;\n\telse if (*p == 'l')\n\t    sort_lc = TRUE;\n\telse if (*p == 'r')\n\t    sort_rx = TRUE;\n\telse if (*p == 'n')\n\t{\n\t    sort_nr = 1;\n\t    ++format_found;\n\t}\n\telse if (*p == 'f')\n\t{\n\t    sort_flt = 1;\n\t    ++format_found;\n\t}\n\telse if (*p == 'b')\n\t{\n\t    sort_what = STR2NR_BIN + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'o')\n\t{\n\t    sort_what = STR2NR_OCT + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'x')\n\t{\n\t    sort_what = STR2NR_HEX + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'u')\n\t    unique = TRUE;\n\telse if (*p == '\"')\t// comment start\n\t    break;\n\telse if (eap->nextcmd == NULL && check_nextcmd(p) != NULL)\n\t{\n\t    eap->nextcmd = check_nextcmd(p);\n\t    break;\n\t}\n\telse if (!ASCII_ISALPHA(*p) && regmatch.regprog == NULL)\n\t{\n\t    s = skip_regexp_err(p + 1, *p, TRUE);\n\t    if (s == NULL)\n\t\tgoto sortend;\n\t    *s = NUL;\n\t    // Use last search pattern if sort pattern is empty.\n\t    if (s == p + 1)\n\t    {\n\t\tif (last_search_pat() == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_regular_expression));\n\t\t    goto sortend;\n\t\t}\n\t\tregmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n\t    }\n\t    else\n\t\tregmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t\tgoto sortend;\n\t    p = s;\t\t// continue after the regexp\n\t    regmatch.rm_ic = p_ic;\n\t}\n\telse\n\t{\n\t    semsg(_(e_invalid_argument_str), p);\n\t    goto sortend;\n\t}\n    }\n\n    // Can only have one of 'n', 'b', 'o' and 'x'.\n    if (format_found > 1)\n    {\n\temsg(_(e_invalid_argument));\n\tgoto sortend;\n    }\n\n    // From here on \"sort_nr\" is used as a flag for any integer number\n    // sorting.\n    sort_nr += sort_what;\n\n    /*\n     * Make an array with all line numbers.  This avoids having to copy all\n     * the lines into allocated memory.\n     * When sorting on strings \"start_col_nr\" is the offset in the line, for\n     * numbers sorting it's the number to sort on.  This means the pattern\n     * matching and number conversion only has to be done once per line.\n     * Also get the longest line length for allocating \"sortbuf\".\n     */\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n    {\n\ts = ml_get(lnum);\n\tlen = (int)STRLEN(s);\n\tif (maxlen < len)\n\t    maxlen = len;\n\n\tstart_col = 0;\n\tend_col = len;\n\tif (regmatch.regprog != NULL && vim_regexec(&regmatch, s, 0))\n\t{\n\t    if (sort_rx)\n\t    {\n\t\tstart_col = (colnr_T)(regmatch.startp[0] - s);\n\t\tend_col = (colnr_T)(regmatch.endp[0] - s);\n\t    }\n\t    else\n\t\tstart_col = (colnr_T)(regmatch.endp[0] - s);\n\t}\n\telse\n\t    if (regmatch.regprog != NULL)\n\t\tend_col = 0;\n\n\tif (sort_nr || sort_flt)\n\t{\n\t    // Make sure vim_str2nr() doesn't read any digits past the end\n\t    // of the match, by temporarily terminating the string there\n\t    s2 = s + end_col;\n\t    c = *s2;\n\t    *s2 = NUL;\n\t    // Sorting on number: Store the number itself.\n\t    p = s + start_col;\n\t    if (sort_nr)\n\t    {\n\t\tif (sort_what & STR2NR_HEX)\n\t\t    s = skiptohex(p);\n\t\telse if (sort_what & STR2NR_BIN)\n\t\t    s = skiptobin(p);\n\t\telse\n\t\t    s = skiptodigit(p);\n\t\tif (s > p && s[-1] == '-')\n\t\t    --s;  // include preceding negative sign\n\t\tif (*s == NUL)\n\t\t{\n\t\t    // line without number should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = FALSE;\n\t\t    nrs[lnum - eap->line1].st_u.num.value = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = TRUE;\n\t\t    vim_str2nr(s, NULL, NULL, sort_what,\n\t\t\t&nrs[lnum - eap->line1].st_u.num.value,\n\t\t\tNULL, 0, FALSE, NULL);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = skipwhite(p);\n\t\tif (*s == '+')\n\t\t    s = skipwhite(s + 1);\n\n\t\tif (*s == NUL)\n\t\t    // empty line should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.value_flt = -DBL_MAX;\n\t\telse\n\t\t    nrs[lnum - eap->line1].st_u.value_flt =\n\t\t\t\t\t\t      strtod((char *)s, NULL);\n\t    }\n\t    *s2 = c;\n\t}\n\telse\n\t{\n\t    // Store the column to sort at.\n\t    nrs[lnum - eap->line1].st_u.line.start_col_nr = start_col;\n\t    nrs[lnum - eap->line1].st_u.line.end_col_nr = end_col;\n\t}\n\n\tnrs[lnum - eap->line1].lnum = lnum;\n\n\tif (regmatch.regprog != NULL)\n\t    fast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // Allocate a buffer that can hold the longest line.\n    sortbuf1 = alloc(maxlen + 1);\n    if (sortbuf1 == NULL)\n\tgoto sortend;\n    sortbuf2 = alloc(maxlen + 1);\n    if (sortbuf2 == NULL)\n\tgoto sortend;\n\n    // Sort the array of line numbers.  Note: can't be interrupted!\n    qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);\n\n    if (sort_abort)\n\tgoto sortend;\n\n    // Insert the lines in the sorted order below the last one.\n    lnum = eap->line2;\n    for (i = 0; i < count; ++i)\n    {\n\tlinenr_T get_lnum = nrs[eap->forceit ? count - i - 1 : i].lnum;\n\n\t// If the original line number of the line being placed is not the same\n\t// as \"lnum\" (accounting for offset), we know that the buffer changed.\n\tif (get_lnum + ((linenr_T)count - 1) != lnum)\n\t    change_occurred = TRUE;\n\n\ts = ml_get(get_lnum);\n\tif (!unique || i == 0 || string_compare(s, sortbuf1) != 0)\n\t{\n\t    // Copy the line into a buffer, it may become invalid in\n\t    // ml_append(). And it's needed for \"unique\".\n\t    STRCPY(sortbuf1, s);\n\t    if (ml_append(lnum++, sortbuf1, (colnr_T)0, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\tfast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // delete the original lines if appending worked\n    if (i == count)\n\tfor (i = 0; i < count; ++i)\n\t    ml_delete(eap->line1);\n    else\n\tcount = 0;\n\n    // Adjust marks for deleted (or added) lines and prepare for displaying.\n    deleted = (long)(count - (lnum - eap->line2));\n    if (deleted > 0)\n    {\n\tmark_adjust(eap->line2 - deleted, eap->line2, (long)MAXLNUM, -deleted);\n\tmsgmore(-deleted);\n    }\n    else if (deleted < 0)\n\tmark_adjust(eap->line2, MAXLNUM, -deleted, 0L);\n\n    if (change_occurred || deleted != 0)\n\tchanged_lines(eap->line1, 0, eap->line2 + 1, -deleted);\n\n    curwin->w_cursor.lnum = eap->line1;\n    beginline(BL_WHITE | BL_FIX);\n\nsortend:\n    vim_free(nrs);\n    vim_free(sortbuf1);\n    vim_free(sortbuf2);\n    vim_regfree(regmatch.regprog);\n    if (got_int)\n\temsg(_(e_interrupted));\n}\n\n/*\n * :move command - move lines line1-line2 to line dest\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_move(linenr_T line1, linenr_T line2, linenr_T dest)\n{\n    char_u\t*str;\n    linenr_T\tl;\n    linenr_T\textra;\t    // Num lines added before line1\n    linenr_T\tnum_lines;  // Num lines moved\n    linenr_T\tlast_line;  // Last line in file after adding new text\n#ifdef FEAT_FOLDING\n    win_T\t*win;\n    tabpage_T\t*tp;\n#endif\n\n    if (dest >= line1 && dest < line2)\n    {\n\temsg(_(e_cannot_move_range_of_lines_into_itself));\n\treturn FAIL;\n    }\n\n    // Do nothing if we are not actually moving any lines.  This will prevent\n    // the 'modified' flag from being set without cause.\n    if (dest == line1 - 1 || dest == line2)\n    {\n\t// Move the cursor as if lines were moved (see below) to be backwards\n\t// compatible.\n\tif (dest >= line1)\n\t    curwin->w_cursor.lnum = dest;\n\telse\n\t    curwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n\treturn OK;\n    }\n\n    num_lines = line2 - line1 + 1;\n\n    /*\n     * First we copy the old text to its new location -- webb\n     * Also copy the flag that \":global\" command uses.\n     */\n    if (u_save(dest, dest + 1) == FAIL)\n\treturn FAIL;\n    for (extra = 0, l = line1; l <= line2; l++)\n    {\n\tstr = vim_strsave(ml_get(l + extra));\n\tif (str != NULL)\n\t{\n\t    ml_append(dest + l - line1, str, (colnr_T)0, FALSE);\n\t    vim_free(str);\n\t    if (dest < line1)\n\t\textra++;\n\t}\n    }\n\n    /*\n     * Now we must be careful adjusting our marks so that we don't overlap our\n     * mark_adjust() calls.\n     *\n     * We adjust the marks within the old text so that they refer to the\n     * last lines of the file (temporarily), because we know no other marks\n     * will be set there since these line numbers did not exist until we added\n     * our new lines.\n     *\n     * Then we adjust the marks on lines between the old and new text positions\n     * (either forwards or backwards).\n     *\n     * And Finally we adjust the marks we put at the end of the file back to\n     * their final destination at the new text position -- webb\n     */\n    last_line = curbuf->b_ml.ml_line_count;\n    mark_adjust_nofold(line1, line2, last_line - line2, 0L);\n    if (dest >= line2)\n    {\n\tmark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t{\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, line1, line2, dest);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest - num_lines + 1;\n\t    curbuf->b_op_end.lnum = dest;\n\t}\n    }\n    else\n    {\n\tmark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t{\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, dest + 1, line1 - 1, line2);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest + 1;\n\t    curbuf->b_op_end.lnum = dest + num_lines;\n\t}\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    mark_adjust_nofold(last_line - num_lines + 1, last_line,\n\t\t\t\t\t     -(last_line - dest - extra), 0L);\n\n    /*\n     * Now we delete the original text -- webb\n     */\n    if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)\n\treturn FAIL;\n\n    for (l = line1; l <= line2; l++)\n\tml_delete_flags(line1 + extra, ML_DEL_MESSAGE);\n\n    if (!global_busy && num_lines > p_report)\n\tsmsg(NGETTEXT(\"%ld line moved\", \"%ld lines moved\", num_lines),\n\t\t\t(long)num_lines);\n\n    /*\n     * Leave the cursor on the last of the moved lines.\n     */\n    if (dest >= line1)\n\tcurwin->w_cursor.lnum = dest;\n    else\n\tcurwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n    if (line1 < dest)\n    {\n\tdest += num_lines + 1;\n\tlast_line = curbuf->b_ml.ml_line_count;\n\tif (dest > last_line + 1)\n\t    dest = last_line + 1;\n\tchanged_lines(line1, 0, dest, 0L);\n    }\n    else\n\tchanged_lines(dest + 1, 0, line1 + num_lines, 0L);\n\n    return OK;\n}\n\n/*\n * \":copy\"\n */\n    void\nex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    msgmore((long)count);\n}\n\nstatic char_u\t*prevcmd = NULL;\t// the previous command\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_prev_shellcmd(void)\n{\n    vim_free(prevcmd);\n}\n#endif\n\n/*\n * Check that \"prevcmd\" is not NULL.  If it is NULL then give an error message\n * and return FALSE.\n */\n    static int\nprevcmd_is_set(void)\n{\n    if (prevcmd == NULL)\n    {\n\temsg(_(e_no_previous_command));\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Handle the \":!cmd\" command.\tAlso for \":r !cmd\" and \":w !cmd\"\n * Bangs in the argument are replaced with the previously entered command.\n * Remember the argument.\n */\n    void\ndo_bang(\n    int\t\taddr_count,\n    exarg_T\t*eap,\n    int\t\tforceit,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t\t*arg = eap->arg;\t// command\n    linenr_T\t\tline1 = eap->line1;\t// start of range\n    linenr_T\t\tline2 = eap->line2;\t// end of range\n    char_u\t\t*newcmd = NULL;\t\t// the new command\n    int\t\t\tfree_newcmd = FALSE;    // need to free() newcmd\n    int\t\t\tins_prevcmd;\n    char_u\t\t*t;\n    char_u\t\t*p;\n    char_u\t\t*trailarg;\n    int\t\t\tlen;\n    int\t\t\tscroll_save = msg_scroll;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (addr_count == 0)\t\t// :!\n    {\n\tmsg_scroll = FALSE;\t    // don't scroll here\n\tautowrite_all();\n\tmsg_scroll = scroll_save;\n    }\n\n    /*\n     * Try to find an embedded bang, like in \":!<cmd> ! [args]\"\n     * \":!!\" is indicated by the 'forceit' variable.\n     */\n    ins_prevcmd = forceit;\n\n    // Skip leading white space to avoid a strange error with some shells.\n    trailarg = skipwhite(arg);\n    do\n    {\n\tlen = (int)STRLEN(trailarg) + 1;\n\tif (newcmd != NULL)\n\t    len += (int)STRLEN(newcmd);\n\tif (ins_prevcmd)\n\t{\n\t    if (!prevcmd_is_set())\n\t    {\n\t\tvim_free(newcmd);\n\t\treturn;\n\t    }\n\t    len += (int)STRLEN(prevcmd);\n\t}\n\tif ((t = alloc(len)) == NULL)\n\t{\n\t    vim_free(newcmd);\n\t    return;\n\t}\n\t*t = NUL;\n\tif (newcmd != NULL)\n\t    STRCAT(t, newcmd);\n\tif (ins_prevcmd)\n\t    STRCAT(t, prevcmd);\n\tp = t + STRLEN(t);\n\tSTRCAT(t, trailarg);\n\tvim_free(newcmd);\n\tnewcmd = t;\n\n\t/*\n\t * Scan the rest of the argument for '!', which is replaced by the\n\t * previous command.  \"\\!\" is replaced by \"!\" (this is vi compatible).\n\t */\n\ttrailarg = NULL;\n\twhile (*p)\n\t{\n\t    if (*p == '!')\n\t    {\n\t\tif (p > newcmd && p[-1] == '\\\\')\n\t\t    STRMOVE(p - 1, p);\n\t\telse\n\t\t{\n\t\t    trailarg = p;\n\t\t    *trailarg++ = NUL;\n\t\t    ins_prevcmd = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t    ++p;\n\t}\n    } while (trailarg != NULL);\n\n    // Only set \"prevcmd\" if there is a command to run, otherwise keep te one\n    // we have.\n    if (STRLEN(newcmd) > 0)\n    {\n\tvim_free(prevcmd);\n\tprevcmd = newcmd;\n    }\n    else\n\tfree_newcmd = TRUE;\n\n    if (bangredo)\t    // put cmd in redo buffer for ! command\n    {\n\tif (!prevcmd_is_set())\n\t    goto theend;\n\n\t// If % or # appears in the command, it must have been escaped.\n\t// Reescape them, so that redoing them does not substitute them by the\n\t// buffername.\n\tchar_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)\"%#\");\n\n\tif (cmd != NULL)\n\t{\n\t    AppendToRedobuffLit(cmd, -1);\n\t    vim_free(cmd);\n\t}\n\telse\n\t    AppendToRedobuffLit(prevcmd, -1);\n\tAppendToRedobuff((char_u *)\"\\n\");\n\tbangredo = FALSE;\n    }\n    /*\n     * Add quotes around the command, for shells that need them.\n     */\n    if (*p_shq != NUL)\n    {\n\tif (free_newcmd)\n\t    vim_free(newcmd);\n\tnewcmd = alloc(STRLEN(prevcmd) + 2 * STRLEN(p_shq) + 1);\n\tif (newcmd == NULL)\n\t    return;\n\tSTRCPY(newcmd, p_shq);\n\tSTRCAT(newcmd, prevcmd);\n\tSTRCAT(newcmd, p_shq);\n\tfree_newcmd = TRUE;\n    }\n    if (addr_count == 0)\t\t// :!\n    {\n\t// echo the command\n\tmsg_start();\n\tmsg_putchar(':');\n\tmsg_putchar('!');\n\tmsg_outtrans(newcmd);\n\tmsg_clr_eos();\n\twindgoto(msg_row, msg_col);\n\n\tdo_shell(newcmd, 0);\n    }\n    else\t\t\t\t// :range!\n    {\n\t// Careful: This may recursively call do_bang() again! (because of\n\t// autocommands)\n\tdo_filter(line1, line2, eap, newcmd, do_in, do_out);\n\tapply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);\n    }\n\ntheend:\n    if (free_newcmd)\n\tvim_free(newcmd);\n}\n\n/*\n * do_filter: filter lines through a command given by the user\n *\n * We mostly use temp files and the call_shell() routine here. This would\n * normally be done using pipes on a UNIX machine, but this is more portable\n * to non-unix machines. The call_shell() routine needs to be able\n * to deal with redirection somehow, and should handle things like looking\n * at the PATH env. variable, and adding reasonable extensions to the\n * command name given by the user. All reasonable versions of call_shell()\n * do this.\n * Alternatively, if on Unix and redirecting input or output, but not both,\n * and the 'shelltemp' option isn't set, use pipes.\n * We use input redirection if do_in is TRUE.\n * We use output redirection if do_out is TRUE.\n */\n    static void\ndo_filter(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    exarg_T\t*eap,\t\t// for forced 'ff' and 'fenc'\n    char_u\t*cmd,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t*itmp = NULL;\n    char_u\t*otmp = NULL;\n    linenr_T\tlinecount;\n    linenr_T\tread_linecount;\n    pos_T\tcursor_save;\n    char_u\t*cmd_buf;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\tshell_flags = 0;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#ifdef FEAT_FILTERPIPE\n    int\t\tstmp = p_stmp;\n#endif\n\n    if (*cmd == NUL)\t    // no filter command\n\treturn;\n\n    // Temporarily disable lockmarks since that's needed to propagate changed\n    // regions of the buffer for foldUpdate(), linecount, etc.\n    cmdmod.cmod_flags &= ~CMOD_LOCKMARKS;\n\n    cursor_save = curwin->w_cursor;\n    linecount = line2 - line1 + 1;\n    curwin->w_cursor.lnum = line1;\n    curwin->w_cursor.col = 0;\n    changed_line_abv_curs();\n    invalidate_botline();\n\n    /*\n     * When using temp files:\n     * 1. * Form temp file names\n     * 2. * Write the lines to a temp file\n     * 3.   Run the filter command on the temp file\n     * 4. * Read the output of the command into the buffer\n     * 5. * Delete the original lines to be filtered\n     * 6. * Remove the temp files\n     *\n     * When writing the input with a pipe or when catching the output with a\n     * pipe only need to do 3.\n     */\n\n    if (do_out)\n\tshell_flags |= SHELL_DOOUT;\n\n#ifdef FEAT_FILTERPIPE\n# ifdef VIMDLL\n    if (!gui.in_use && !gui.starting)\n\tstmp = 1;   // Console mode doesn't support filterpipe.\n# endif\n\n    if (!do_in && do_out && !stmp)\n    {\n\t// Use a pipe to fetch stdout of the command, do not use a temp file.\n\tshell_flags |= SHELL_READ;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else if (do_in && !do_out && !stmp)\n    {\n\t// Use a pipe to write stdin of the command, do not use a temp file.\n\tshell_flags |= SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n    }\n    else if (do_in && do_out && !stmp)\n    {\n\t// Use a pipe to write stdin and fetch stdout of the command, do not\n\t// use a temp file.\n\tshell_flags |= SHELL_READ|SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else\n#endif\n\tif ((do_in && (itmp = vim_tempname('i', FALSE)) == NULL)\n\t\t|| (do_out && (otmp = vim_tempname('o', FALSE)) == NULL))\n\t{\n\t    emsg(_(e_cant_get_temp_file_name));\n\t    goto filterend;\n\t}\n\n/*\n * The writing and reading of temp files will not be shown.\n * Vi also doesn't do this and the messages are not very informative.\n */\n    ++no_wait_return;\t\t// don't call wait_return() while busy\n    if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,\n\t\t\t\t\t   FALSE, FALSE, FALSE, TRUE) == FAIL)\n    {\n\tmsg_putchar('\\n');\t\t// keep message from buf_write()\n\t--no_wait_return;\n#if defined(FEAT_EVAL)\n\tif (!aborting())\n#endif\n\t    // will call wait_return()\n\t    (void)semsg(_(e_cant_create_file_str), itmp);\n\tgoto filterend;\n    }\n    if (curbuf != old_curbuf)\n\tgoto filterend;\n\n    if (!do_out)\n\tmsg_putchar('\\n');\n\n    // Create the shell command in allocated memory.\n    cmd_buf = make_filter_cmd(cmd, itmp, otmp);\n    if (cmd_buf == NULL)\n\tgoto filterend;\n\n    windgoto((int)Rows - 1, 0);\n    cursor_on();\n\n    /*\n     * When not redirecting the output the command can write anything to the\n     * screen. If 'shellredir' is equal to \">\", screen may be messed up by\n     * stderr output of external command. Clear the screen later.\n     * If do_in is FALSE, this could be something like \":r !cat\", which may\n     * also mess up the screen, clear it later.\n     */\n    if (!do_out || STRCMP(p_srr, \">\") == 0 || !do_in)\n\tredraw_later_clear();\n\n    if (do_out)\n    {\n\tif (u_save(line2, (linenr_T)(line2 + 1)) == FAIL)\n\t{\n\t    vim_free(cmd_buf);\n\t    goto error;\n\t}\n\tredraw_curbuf_later(UPD_VALID);\n    }\n    read_linecount = curbuf->b_ml.ml_line_count;\n\n    /*\n     * When call_shell() fails wait_return() is called to give the user a\n     * chance to read the error messages. Otherwise errors are ignored, so you\n     * can see the error messages from the command that appear on stdout; use\n     * 'u' to fix the text\n     * Switch to cooked mode when not redirecting stdin, avoids that something\n     * like \":r !cat\" hangs.\n     * Pass on the SHELL_DOOUT flag when the output is being redirected.\n     */\n    if (call_shell(cmd_buf, SHELL_FILTER | SHELL_COOKED | shell_flags))\n    {\n\tredraw_later_clear();\n\twait_return(FALSE);\n    }\n    vim_free(cmd_buf);\n\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    // When interrupting the shell command, it may still have produced some\n    // useful output.  Reset got_int here, so that readfile() won't cancel\n    // reading.\n    ui_breakcheck();\n    got_int = FALSE;\n\n    if (do_out)\n    {\n\tif (otmp != NULL)\n\t{\n\t    if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t\t    eap, READ_FILTER) != OK)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tif (!aborting())\n#endif\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    semsg(_(e_cant_read_file_str), otmp);\n\t\t}\n\t\tgoto error;\n\t    }\n\t    if (curbuf != old_curbuf)\n\t\tgoto filterend;\n\t}\n\n\tread_linecount = curbuf->b_ml.ml_line_count - read_linecount;\n\n\tif (shell_flags & SHELL_READ)\n\t{\n\t    curbuf->b_op_start.lnum = line2 + 1;\n\t    curbuf->b_op_end.lnum = curwin->w_cursor.lnum;\n\t    appended_lines_mark(line2, read_linecount);\n\t}\n\n\tif (do_in)\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPMARKS)\n\t\t\t\t     || vim_strchr(p_cpo, CPO_REMMARK) == NULL)\n\t    {\n\t\tif (read_linecount >= linecount)\n\t\t    // move all marks from old lines to new lines\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\telse if (save_cmod_flags & CMOD_LOCKMARKS)\n\t\t{\n\t\t    // Move marks from the lines below the new lines down by\n\t\t    // the number of lines lost.\n\t\t    // Move marks from the lines that will be deleted to the\n\t\t    // new lines and below.\n\t\t    mark_adjust(line2 + 1, (linenr_T)MAXLNUM,\n\t\t\t\t\t       linecount - read_linecount, 0L);\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // move marks from old lines to new lines, delete marks\n\t\t    // that are in deleted lines\n\t\t    mark_adjust(line1, line1 + read_linecount - 1,\n\t\t\t\t\t\t\t\tlinecount, 0L);\n\t\t    mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Put cursor on first filtered line for \":range!cmd\".\n\t     * Adjust '[ and '] (set by buf_write()).\n\t     */\n\t    curwin->w_cursor.lnum = line1;\n\t    del_lines(linecount, TRUE);\n\t    curbuf->b_op_start.lnum -= linecount;\t// adjust '[\n\t    curbuf->b_op_end.lnum -= linecount;\t\t// adjust ']\n\t    write_lnum_adjust(-linecount);\t\t// adjust last line\n\t\t\t\t\t\t\t// for next write\n#ifdef FEAT_FOLDING\n\t    foldUpdate(curwin, curbuf->b_op_start.lnum, curbuf->b_op_end.lnum);\n#endif\n\t}\n\telse\n\t{\n\t    /*\n\t     * Put cursor on last new line for \":r !cmd\".\n\t     */\n\t    linecount = curbuf->b_op_end.lnum - curbuf->b_op_start.lnum + 1;\n\t    curwin->w_cursor.lnum = curbuf->b_op_end.lnum;\n\t}\n\n\tbeginline(BL_WHITE | BL_FIX);\t    // cursor on first non-blank\n\t--no_wait_return;\n\n\tif (linecount > p_report)\n\t{\n\t    if (do_in)\n\t    {\n\t\tvim_snprintf(msg_buf, sizeof(msg_buf),\n\t\t\t\t    _(\"%ld lines filtered\"), (long)linecount);\n\t\tif (msg(msg_buf) && !msg_scroll)\n\t\t    // save message to display it after redraw\n\t\t    set_keep_msg((char_u *)msg_buf, 0);\n\t    }\n\t    else\n\t\tmsgmore((long)linecount);\n\t}\n    }\n    else\n    {\nerror:\n\t// put cursor back in same position for \":w !cmd\"\n\tcurwin->w_cursor = cursor_save;\n\t--no_wait_return;\n\twait_return(FALSE);\n    }\n\nfilterend:\n\n    cmdmod.cmod_flags = save_cmod_flags;\n    if (curbuf != old_curbuf)\n    {\n\t--no_wait_return;\n\temsg(_(e_filter_autocommands_must_not_change_current_buffer));\n    }\n    else if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n\n    if (itmp != NULL)\n\tmch_remove(itmp);\n    if (otmp != NULL)\n\tmch_remove(otmp);\n    vim_free(itmp);\n    vim_free(otmp);\n}\n\n/*\n * Call a shell to execute a command.\n * When \"cmd\" is NULL start an interactive shell.\n */\n    void\ndo_shell(\n    char_u\t*cmd,\n    int\t\tflags)\t// may be SHELL_DOOUT when output is redirected\n{\n    buf_T\t*buf;\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n    int\t\tsave_nwr;\n#endif\n#ifdef MSWIN\n    int\t\twinstart = FALSE;\n#endif\n    int\t\tkeep_termcap = !termcap_active;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n    {\n\tmsg_end();\n\treturn;\n    }\n\n#ifdef MSWIN\n    /*\n     * Check if \":!start\" is used.  This implies not stopping termcap mode.\n     */\n    if (cmd != NULL)\n\tkeep_termcap = winstart = (STRNICMP(cmd, \"start \", 6) == 0);\n\n# if defined(FEAT_GUI) && defined(FEAT_TERMINAL)\n    // Don't stop termcap mode when using a terminal window for the shell.\n    if (gui.in_use && vim_strchr(p_go, GO_TERMINAL) != NULL)\n\tkeep_termcap = TRUE;\n# endif\n#endif\n\n    /*\n     * For autocommands we want to get the output on the current screen, to\n     * avoid having to type return below.\n     */\n    msg_putchar('\\r');\t\t\t// put cursor at start of line\n    if (!autocmd_busy)\n    {\n\tif (!keep_termcap)\n\t    stoptermcap();\n    }\n#ifdef MSWIN\n    if (!winstart)\n#endif\n\tmsg_putchar('\\n');\t\t// may shift screen one line up\n\n    // warning message before calling the shell\n    if (p_warn && !autocmd_busy && msg_silent == 0)\n\tFOR_ALL_BUFFERS(buf)\n\t    if (bufIsChangedNotTerm(buf))\n\t    {\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    starttermcap();\t// don't want a message box here\n#endif\n\t\tmsg_puts(_(\"[No write since last change]\\n\"));\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    stoptermcap();\n#endif\n\t\tbreak;\n\t    }\n\n    // This windgoto is required for when the '\\n' resulted in a \"delete line\n    // 1\" command to the terminal.\n    if (!swapping_screen())\n\twindgoto(msg_row, msg_col);\n    cursor_on();\n    (void)call_shell(cmd, SHELL_COOKED | flags);\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    /*\n     * put the message cursor at the end of the screen, avoids wait_return()\n     * to overwrite the text that the external command showed\n     */\n    if (!swapping_screen())\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n\n    if (autocmd_busy)\n    {\n\tif (msg_silent == 0)\n\t    redraw_later_clear();\n    }\n    else\n    {\n\t/*\n\t * For \":sh\" there is no need to call wait_return(), just redraw.\n\t * Also for the Win32 GUI (the output is in a console window).\n\t * Otherwise there is probably text on the screen that the user wants\n\t * to read before redrawing, so call wait_return().\n\t */\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t{\n\t    if (cmd == NULL\n# ifdef MSWIN\n\t\t    || (keep_termcap && !need_wait_return)\n# endif\n\t       )\n\t    {\n\t\tif (msg_silent == 0)\n\t\t    redraw_later_clear();\n\t\tneed_wait_return = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * If we switch screens when starttermcap() is called, we\n\t\t * really want to wait for \"hit return to continue\".\n\t\t */\n\t\tsave_nwr = no_wait_return;\n\t\tif (swapping_screen())\n\t\t    no_wait_return = FALSE;\n# ifdef AMIGA\n\t\twait_return(term_console ? -1 : msg_silent == 0); // see below\n# else\n\t\twait_return(msg_silent == 0);\n# endif\n\t\tno_wait_return = save_nwr;\n\t    }\n\t}\n#endif // FEAT_GUI_MSWIN\n\n\tif (!keep_termcap)\t// if keep_termcap is TRUE didn't stop termcap\n\t    starttermcap();\t// start termcap if not done by wait_return()\n\n\t/*\n\t * In an Amiga window redrawing is caused by asking the window size.\n\t * If we got an interrupt this will not work. The chance that the\n\t * window size is wrong is very small, but we need to redraw the\n\t * screen.  Don't do this if ':' hit in wait_return().\tTHIS IS UGLY\n\t * but it saves an extra redraw.\n\t */\n#ifdef AMIGA\n\tif (skip_redraw)\t\t// ':' hit in wait_return()\n\t{\n\t    if (msg_silent == 0)\n\t\tredraw_later_clear();\n\t}\n\telse if (term_console)\n\t{\n\t    OUT_STR(\"\\033[0 q\");\t// get window size\n\t    if (got_int && msg_silent == 0)\n\t\tredraw_later_clear();\t// if got_int is TRUE, redraw needed\n\t    else\n\t\tmust_redraw = 0;\t// no extra redraw needed\n\t}\n#endif\n    }\n\n    // display any error messages now\n    display_errors();\n\n    apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);\n}\n\n#if !defined(UNIX)\n    static char_u *\nfind_pipe(char_u *cmd)\n{\n    char_u  *p;\n    int\t    inquote = FALSE;\n\n    for (p = cmd; *p != NUL; ++p)\n    {\n\tif (!inquote && *p == '|')\n\t    return p;\n\tif (*p == '\"')\n\t    inquote = !inquote;\n\telse if (rem_backslash(p))\n\t    ++p;\n    }\n    return NULL;\n}\n#endif\n\n/*\n * Create a shell command from a command string, input redirection file and\n * output redirection file.\n * Returns an allocated string with the shell command, or NULL for failure.\n */\n    char_u *\nmake_filter_cmd(\n    char_u\t*cmd,\t\t// command\n    char_u\t*itmp,\t\t// NULL or name of input file\n    char_u\t*otmp)\t\t// NULL or name of output file\n{\n    char_u\t*buf;\n    long_u\tlen;\n    int\t\tis_powershell = FALSE;\n#ifdef UNIX\n    int\t\tis_fish_shell;\n#endif\n\n    char_u *shell_name = get_isolated_shell_name();\n    if (shell_name == NULL)\n\treturn NULL;\n\n#if defined(UNIX)\n    // Account for fish's different syntax for subshells\n    is_fish_shell = fnamecmp(shell_name, \"fish\") == 0;\n    if (is_fish_shell)\n\tlen = (long_u)STRLEN(cmd) + 13;\t\t// \"begin; \" + \"; end\" + NUL\n    else\n#endif\n    {\n\tis_powershell = (shell_name[0] == 'p')\n\t\t\t&& (fnamecmp(shell_name, \"powershell\") == 0\n\t\t\t\t|| fnamecmp(shell_name, \"powershell.exe\") == 0\n\t\t\t\t|| fnamecmp(shell_name, \"pwsh\") == 0\n\t\t\t\t|| fnamecmp(shell_name, \"pwsh.exe\") == 0);\n\tlen = (long_u)STRLEN(cmd) + 3;\t\t// \"()\" + NUL\n    }\n\n    if (itmp != NULL)\n    {\n\tif (is_powershell)\n\t    // \"& { Get-Content \" + \" | & \" + \" }\"\n\t    len += (long_u)STRLEN(itmp) + 24;\n\telse\n\t    len += (long_u)STRLEN(itmp) + 9;\t// \" { < \" + \" } \"\n    }\n    if (otmp != NULL)\n\tlen += (long_u)STRLEN(otmp) + (long_u)STRLEN(p_srr) + 2; // \"  \"\n\n    vim_free(shell_name);\n\n    buf = alloc(len);\n    if (buf == NULL)\n\treturn NULL;\n\n    if (is_powershell)\n    {\n\tif (itmp != NULL)\n\t    vim_snprintf((char *)buf, len, \"& { Get-Content %s | & %s }\",\n\t\t\t\t\t\t\t\titmp, cmd);\n\telse\n\t    vim_snprintf((char *)buf, len, \"(%s)\", cmd);\n    }\n    else\n    {\n#if defined(UNIX)\n\t// Put braces around the command (for concatenated commands) when\n\t// redirecting input and/or output.\n\tif (itmp != NULL || otmp != NULL)\n\t{\n\t    if (is_fish_shell)\n\t\tvim_snprintf((char *)buf, len, \"begin; %s; end\", (char *)cmd);\n\t    else\n\t\tvim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n\t}\n\telse\n\t    STRCPY(buf, cmd);\n\tif (itmp != NULL)\n\t{\n\t    STRCAT(buf, \" < \");\n\t    STRCAT(buf, itmp);\n\t}\n#else\n\t// For shells that don't understand braces around commands, at least\n\t// allow the use of commands in a pipe.\n\tif (*p_sxe != NUL && *p_sxq == '(')\n\t{\n\t    if (itmp != NULL || otmp != NULL)\n\t\tvim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n\t    else\n\t\tSTRCPY(buf, cmd);\n\t    if (itmp != NULL)\n\t    {\n\t\tSTRCAT(buf, \" < \");\n\t\tSTRCAT(buf, itmp);\n\t    }\n\t}\n\telse\n\t{\n\t    STRCPY(buf, cmd);\n\t    if (itmp != NULL)\n\t    {\n\t\tchar_u\t*p;\n\n\t\t// If there is a pipe, we have to put the '<' in front of it.\n\t\t// Don't do this when 'shellquote' is not empty, otherwise the\n\t\t// redirection would be inside the quotes.\n\t\tif (*p_shq == NUL)\n\t\t{\n\t\t    p = find_pipe(buf);\n\t\t    if (p != NULL)\n\t\t\t*p = NUL;\n\t\t}\n\t\tSTRCAT(buf, \" <\");\t// \" < \" causes problems on Amiga\n\t\tSTRCAT(buf, itmp);\n\t\tif (*p_shq == NUL)\n\t\t{\n\t\t    p = find_pipe(cmd);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\t// insert a space before the '|' for DOS\n\t\t\tSTRCAT(buf, \" \");\n\t\t\tSTRCAT(buf, p);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif\n    }\n    if (otmp != NULL)\n\tappend_redir(buf, (int)len, p_srr, otmp);\n\n    return buf;\n}\n\n/*\n * Append output redirection for file \"fname\" to the end of string buffer\n * \"buf[buflen]\"\n * Works with the 'shellredir' and 'shellpipe' options.\n * The caller should make sure that there is enough room:\n *\tSTRLEN(opt) + STRLEN(fname) + 3\n */\n    void\nappend_redir(\n    char_u\t*buf,\n    int\t\tbuflen,\n    char_u\t*opt,\n    char_u\t*fname)\n{\n    char_u\t*p;\n    char_u\t*end;\n\n    end = buf + STRLEN(buf);\n    // find \"%s\"\n    for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)\n    {\n\tif (p[1] == 's') // found %s\n\t    break;\n\tif (p[1] == '%') // skip %%\n\t    ++p;\n    }\n    if (p != NULL)\n    {\n#ifdef MSWIN\n\t*end++ = ' '; // not really needed? Not with sh, ksh or bash\n#endif\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)),\n\t\t\t\t\t\t  (char *)opt, (char *)fname);\n    }\n    else\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)), \" %s %s\",\n\t\t(char *)opt, (char *)fname);\n}\n\n/*\n * Implementation of \":fixdel\", also used by get_stty().\n *  <BS>    resulting <Del>\n *   ^?\t\t^H\n * not ^?\t^?\n */\n    void\ndo_fixdel(exarg_T *eap UNUSED)\n{\n    char_u  *p;\n\n    p = find_termcode((char_u *)\"kb\");\n    add_termcode((char_u *)\"kD\", p != NULL\n\t    && *p == DEL ? (char_u *)CTRL_H_STR : DEL_STR, FALSE);\n}\n\n    void\nprint_line_no_prefix(\n    linenr_T\tlnum,\n    int\t\tuse_number,\n    int\t\tlist)\n{\n    char\tnumbuf[30];\n\n    if (curwin->w_p_nu || use_number)\n    {\n\tvim_snprintf(numbuf, sizeof(numbuf),\n\t\t\t\t   \"%*ld \", number_width(curwin), (long)lnum);\n\tmsg_puts_attr(numbuf, HL_ATTR(HLF_N));\t// Highlight line nrs\n    }\n    msg_prt_line(ml_get(lnum), list);\n}\n\n/*\n * Print a text line.  Also in silent mode (\"ex -s\").\n */\n    void\nprint_line(linenr_T lnum, int use_number, int list)\n{\n    int\t\tsave_silent = silent_mode;\n\n    // apply :filter /pat/\n    if (message_filtered(ml_get(lnum)))\n\treturn;\n\n    msg_start();\n    silent_mode = FALSE;\n    info_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n    print_line_no_prefix(lnum, use_number, list);\n    if (save_silent)\n    {\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = save_silent;\n    }\n    info_message = FALSE;\n}\n\n    int\nrename_buffer(char_u *new_fname)\n{\n    char_u\t*fname, *sfname, *xfname;\n    buf_T\t*buf;\n\n    buf = curbuf;\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    // buffer changed, don't change name now\n    if (buf != curbuf)\n\treturn FAIL;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n    /*\n     * The name of the current buffer will be changed.\n     * A new (unlisted) buffer entry needs to be made to hold the old file\n     * name, which will become the alternate file name.\n     * But don't set the alternate file name if the buffer didn't have a\n     * name.\n     */\n    fname = curbuf->b_ffname;\n    sfname = curbuf->b_sfname;\n    xfname = curbuf->b_fname;\n    curbuf->b_ffname = NULL;\n    curbuf->b_sfname = NULL;\n    if (setfname(curbuf, new_fname, NULL, TRUE) == FAIL)\n    {\n\tcurbuf->b_ffname = fname;\n\tcurbuf->b_sfname = sfname;\n\treturn FAIL;\n    }\n    curbuf->b_flags |= BF_NOTEDITED;\n    if (xfname != NULL && *xfname != NUL)\n    {\n\tbuf = buflist_new(fname, xfname, curwin->w_cursor.lnum, 0);\n\tif (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t    curwin->w_alt_fnum = buf->b_fnum;\n    }\n    vim_free(fname);\n    vim_free(sfname);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n    return OK;\n}\n\n/*\n * \":file[!] [fname]\".\n */\n    void\nex_file(exarg_T *eap)\n{\n    // \":0file\" removes the file name.  Check for illegal uses \":3file\",\n    // \"0file name\", etc.\n    if (eap->addr_count > 0\n\t    && (*eap->arg != NUL\n\t\t|| eap->line2 > 0\n\t\t|| eap->addr_count > 1))\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    if (*eap->arg != NUL || eap->addr_count == 1)\n    {\n\tif (rename_buffer(eap->arg) == FAIL)\n\t    return;\n\tredraw_tabline = TRUE;\n    }\n\n    // print file name if no argument or 'F' is not in 'shortmess'\n    if (*eap->arg == NUL || !shortmess(SHM_FILEINFO))\n\tfileinfo(FALSE, FALSE, eap->forceit);\n}\n\n/*\n * \":update\".\n */\n    void\nex_update(exarg_T *eap)\n{\n    if (curbufIsChanged())\n\t(void)do_write(eap);\n}\n\n/*\n * \":write\" and \":saveas\".\n */\n    void\nex_write(exarg_T *eap)\n{\n    if (eap->cmdidx == CMD_saveas)\n    {\n\t// :saveas does not take a range, uses all lines.\n\teap->line1 = 1;\n\teap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    if (eap->usefilter)\t\t// input lines to shell command\n\tdo_bang(1, eap, FALSE, TRUE, FALSE);\n    else\n\t(void)do_write(eap);\n}\n\n#ifdef UNIX\n    static int\ncheck_writable(char_u *fname)\n{\n    if (mch_nodetype(fname) == NODE_OTHER)\n    {\n\tsemsg(_(e_str_is_not_file_or_writable_device), fname);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Write the current buffer to file \"eap->arg\".\n * If \"eap->append\" is TRUE, append to the file.\n *\n * If \"*eap->arg == NUL\" write to current file.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_write(exarg_T *eap)\n{\n    int\t\tother;\n    char_u\t*fname = NULL;\t\t// init to shut up gcc\n    char_u\t*ffname;\n    int\t\tretval = FAIL;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\t*browse_file = NULL;\n#endif\n    buf_T\t*alt_buf = NULL;\n    int\t\tname_was_missing;\n\n    if (not_writing())\t\t// check 'write' option\n\treturn FAIL;\n\n    ffname = eap->arg;\n#ifdef FEAT_BROWSE\n    if ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n    {\n\tbrowse_file = do_browse(BROWSE_SAVE, (char_u *)_(\"Save As\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\tif (browse_file == NULL)\n\t    goto theend;\n\tffname = browse_file;\n    }\n#endif\n    if (*ffname == NUL)\n    {\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    emsg(_(e_argument_required));\n\t    goto theend;\n\t}\n\tother = FALSE;\n    }\n    else\n    {\n\tfname = ffname;\n\tfree_fname = fix_fname(ffname);\n\t/*\n\t * When out-of-memory, keep unexpanded file name, because we MUST be\n\t * able to write the file in this situation.\n\t */\n\tif (free_fname != NULL)\n\t    ffname = free_fname;\n\tother = otherfile(ffname);\n    }\n\n    /*\n     * If we have a new file, put its name in the list of alternate file names.\n     */\n    if (other)\n    {\n\tif (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL\n\t\t\t\t\t\t || eap->cmdidx == CMD_saveas)\n\t    alt_buf = setaltfname(ffname, fname, (linenr_T)1);\n\telse\n\t    alt_buf = buflist_findname(ffname);\n\tif (alt_buf != NULL && alt_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    // Overwriting a file that is loaded in another buffer is not a\n\t    // good idea.\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    goto theend;\n\t}\n    }\n\n    /*\n     * Writing to the current file is not allowed in readonly mode\n     * and a file name is required.\n     * \"nofile\" and \"nowrite\" buffers cannot be written implicitly either.\n     */\n    if (!other && (bt_dontwrite_msg(curbuf) || check_fname() == FAIL\n#ifdef UNIX\n\t\t|| check_writable(curbuf->b_ffname) == FAIL\n#endif\n\t\t|| check_readonly(&eap->forceit, curbuf)))\n\tgoto theend;\n\n    if (!other)\n    {\n\tffname = curbuf->b_ffname;\n\tfname = curbuf->b_fname;\n\t/*\n\t * Not writing the whole file is only allowed with '!'.\n\t */\n\tif (\t   (eap->line1 != 1\n\t\t    || eap->line2 != curbuf->b_ml.ml_line_count)\n\t\t&& !eap->forceit\n\t\t&& !eap->append\n\t\t&& !p_wa)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL,\n\t\t\t       (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)\n\t\t    goto theend;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_use_bang_to_write_partial_buffer));\n\t\tgoto theend;\n\t    }\n\t}\n    }\n\n    if (check_overwrite(eap, curbuf, fname, ffname, other) == OK)\n    {\n\tif (eap->cmdidx == CMD_saveas && alt_buf != NULL)\n\t{\n\t    buf_T\t*was_curbuf = curbuf;\n\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't change name now\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\t    // Exchange the file names for the current and the alternate\n\t    // buffer.  This makes it look like we are now editing the buffer\n\t    // under the new name.  Must be done before buf_write(), because\n\t    // if there is no file name and 'cpo' contains 'F', it will set\n\t    // the file name.\n\t    fname = alt_buf->b_fname;\n\t    alt_buf->b_fname = curbuf->b_fname;\n\t    curbuf->b_fname = fname;\n\t    fname = alt_buf->b_ffname;\n\t    alt_buf->b_ffname = curbuf->b_ffname;\n\t    curbuf->b_ffname = fname;\n\t    fname = alt_buf->b_sfname;\n\t    alt_buf->b_sfname = curbuf->b_sfname;\n\t    curbuf->b_sfname = fname;\n\t    buf_name_changed(curbuf);\n\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);\n\t    if (!alt_buf->b_p_bl)\n\t    {\n\t\talt_buf->b_p_bl = TRUE;\n\t\tapply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);\n\t    }\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't write the file\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\n\t    // If 'filetype' was empty try detecting it now.\n\t    if (*curbuf->b_p_ft == NUL)\n\t    {\n\t\tif (au_has_group((char_u *)\"filetypedetect\"))\n\t\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\",\n\t\t\t\t\t\t\t\t  TRUE, NULL);\n\t\tdo_modelines(0);\n\t    }\n\n\t    // Autocommands may have changed buffer names, esp. when\n\t    // 'autochdir' is set.\n\t    fname = curbuf->b_sfname;\n\t}\n\n\tname_was_missing = curbuf->b_ffname == NULL;\n\n\tretval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,\n\t\t\t\t eap, eap->append, eap->forceit, TRUE, FALSE);\n\n\t// After \":saveas fname\" reset 'readonly'.\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    if (retval == OK)\n\t    {\n\t\tcurbuf->b_p_ro = FALSE;\n\t\tredraw_tabline = TRUE;\n\t    }\n\t}\n\n\t// Change directories when the 'acd' option is set and the file name\n\t// got changed or set.\n\tif (eap->cmdidx == CMD_saveas || name_was_missing)\n\t    DO_AUTOCHDIR;\n    }\n\ntheend:\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n/*\n * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,\n * BF_NEW or BF_READERR, check for overwriting current file.\n * May set eap->forceit if a dialog says it's OK to overwrite.\n * Return OK if it's OK, FAIL if it is not.\n */\n    int\ncheck_overwrite(\n    exarg_T\t*eap,\n    buf_T\t*buf,\n    char_u\t*fname,\t    // file name to be used (can differ from\n\t\t\t    // buf->ffname)\n    char_u\t*ffname,    // full path version of fname\n    int\t\tother)\t    // writing under other name\n{\n    /*\n     * Write to another file or b_flags set or not writing the whole file:\n     * overwriting only allowed with '!'.\n     * If \"other\" is FALSE and bt_nofilename(buf) is TRUE, this must be\n     * writing an \"acwrite\" buffer to the same file as its b_ffname, and\n     * buf_write() will only allow writing with BufWriteCmd autocommands,\n     * so there is no need for an overwrite check.\n     */\n    if (       (other\n\t\t|| (!bt_nofilename(buf)\n\t\t    && ((buf->b_flags & BF_NOTEDITED)\n\t\t\t|| ((buf->b_flags & BF_NEW)\n\t\t\t    && vim_strchr(p_cpo, CPO_OVERNEW) == NULL)\n\t\t\t|| (buf->b_flags & BF_READERR))))\n\t    && !p_wa\n\t    && vim_fexists(ffname))\n    {\n\tif (!eap->forceit && !eap->append)\n\t{\n#ifdef UNIX\n\t    // with UNIX it is possible to open a directory\n\t    if (mch_isdir(ffname))\n\t    {\n\t\tsemsg(_(e_str_is_directory), ffname);\n\t\treturn FAIL;\n\t    }\n#endif\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tdialog_msg(buff, _(\"Overwrite existing file \\\"%s\\\"?\"), fname);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)\n\t\t    return FAIL;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_file_exists));\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// For \":w! filename\" check that no swap file exists for \"filename\".\n\tif (other && !emsg_silent)\n\t{\n\t    char_u\t*dir;\n\t    char_u\t*p;\n\t    int\t\tr;\n\t    char_u\t*swapname;\n\n\t    // We only try the first entry in 'directory', without checking if\n\t    // it's writable.  If the \".\" directory is not writable the write\n\t    // will probably fail anyway.\n\t    // Use 'shortname' of the current buffer, since there is no buffer\n\t    // for the written file.\n\t    if (*p_dir == NUL)\n\t    {\n\t\tdir = alloc(5);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tSTRCPY(dir, \".\");\n\t    }\n\t    else\n\t    {\n\t\tdir = alloc(MAXPATHL);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tp = p_dir;\n\t\tcopy_option_part(&p, dir, MAXPATHL, \",\");\n\t    }\n\t    swapname = makeswapname(fname, ffname, curbuf, dir);\n\t    vim_free(dir);\n\t    r = vim_fexists(swapname);\n\t    if (r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t{\n\t\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\t    dialog_msg(buff,\n\t\t\t    _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),\n\t\t\t\t\t\t\t\t    swapname);\n\t\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)\n\t\t\t\t\t\t\t\t   != VIM_YES)\n\t\t    {\n\t\t\tvim_free(swapname);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    eap->forceit = TRUE;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    semsg(_(e_swap_file_exists_str_silent_overrides), swapname);\n\t\t    vim_free(swapname);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    vim_free(swapname);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle \":wnext\", \":wNext\" and \":wprevious\" commands.\n */\n    void\nex_wnext(exarg_T *eap)\n{\n    int\t\ti;\n\n    if (eap->cmd[1] == 'n')\n\ti = curwin->w_arg_idx + (int)eap->line2;\n    else\n\ti = curwin->w_arg_idx - (int)eap->line2;\n    eap->line1 = 1;\n    eap->line2 = curbuf->b_ml.ml_line_count;\n    if (do_write(eap) != FAIL)\n\tdo_argfile(eap, i);\n}\n\n/*\n * \":wall\", \":wqall\" and \":xall\": Write all changed files (and exit).\n */\n    void\ndo_wqall(exarg_T *eap)\n{\n    buf_T\t*buf;\n    int\t\terror = 0;\n    int\t\tsave_forceit = eap->forceit;\n\n    if (eap->cmdidx == CMD_xall || eap->cmdidx == CMD_wqall)\n    {\n\tif (before_quit_all(eap) == FAIL)\n\t    return;\n\texiting = TRUE;\n    }\n\n    FOR_ALL_BUFFERS(buf)\n    {\n#ifdef FEAT_TERMINAL\n\tif (exiting && term_job_running(buf->b_term))\n\t{\n\t    no_write_message_nobang(buf);\n\t    ++error;\n\t}\n\telse\n#endif\n\tif (bufIsChanged(buf) && !bt_dontwrite(buf))\n\t{\n\t    /*\n\t     * Check if there is a reason the buffer cannot be written:\n\t     * 1. if the 'write' option is set\n\t     * 2. if there is no file name (even after browsing)\n\t     * 3. if the 'readonly' is set (even after a dialog)\n\t     * 4. if overwriting is allowed (even after a dialog)\n\t     */\n\t    if (not_writing())\n\t    {\n\t\t++error;\n\t\tbreak;\n\t    }\n#ifdef FEAT_BROWSE\n\t    // \":browse wall\": ask for file name if there isn't one\n\t    if (buf->b_ffname == NULL && (cmdmod.cmod_flags & CMOD_BROWSE))\n\t\tbrowse_save_fname(buf);\n#endif\n\t    if (buf->b_ffname == NULL)\n\t    {\n\t\tsemsg(_(e_no_file_name_for_buffer_nr), (long)buf->b_fnum);\n\t\t++error;\n\t    }\n\t    else if (check_readonly(&eap->forceit, buf)\n\t\t    || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,\n\t\t\t\t\t\t\t       FALSE) == FAIL)\n\t    {\n\t\t++error;\n\t    }\n\t    else\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tif (buf_write_all(buf, eap->forceit) == FAIL)\n\t\t    ++error;\n\t\t// an autocommand may have deleted the buffer\n\t\tif (!bufref_valid(&bufref))\n\t\t    buf = firstbuf;\n\t    }\n\t    eap->forceit = save_forceit;    // check_overwrite() may set it\n\t}\n    }\n    if (exiting)\n    {\n\tif (!error)\n\t    getout(0);\t\t// exit Vim\n\tnot_exiting();\n    }\n}\n\n/*\n * Check the 'write' option.\n * Return TRUE and give a message when it's not set.\n */\n    static int\nnot_writing(void)\n{\n    if (p_write)\n\treturn FALSE;\n    emsg(_(e_file_not_written_writing_is_disabled_by_write_option));\n    return TRUE;\n}\n\n/*\n * Check if a buffer is read-only (either 'readonly' option is set or file is\n * read-only). Ask for overruling in a dialog. Return TRUE and give an error\n * message when the buffer is readonly.\n */\n    static int\ncheck_readonly(int *forceit, buf_T *buf)\n{\n    stat_T\tst;\n\n    // Handle a file being readonly when the 'readonly' option is set or when\n    // the file exists and permissions are read-only.\n    // We will send 0777 to check_file_readonly(), as the \"perm\" variable is\n    // important for device checks but not here.\n    if (!*forceit && (buf->b_p_ro\n\t\t|| (mch_stat((char *)buf->b_ffname, &st) >= 0\n\t\t    && check_file_readonly(buf->b_ffname, 0777))))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t       && buf->b_fname != NULL)\n\t{\n\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t    if (buf->b_p_ro)\n\t\tdialog_msg(buff, _(\"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),\n\t\t    buf->b_fname);\n\t    else\n\t\tdialog_msg(buff, _(\"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),\n\t\t    buf->b_fname);\n\n\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)\n\t    {\n\t\t// Set forceit, to force the writing of a readonly file\n\t\t*forceit = TRUE;\n\t\treturn FALSE;\n\t    }\n\t    else\n\t\treturn TRUE;\n\t}\n\telse\n#endif\n\tif (buf->b_p_ro)\n\t    emsg(_(e_readonly_option_is_set_add_bang_to_override));\n\telse\n\t    semsg(_(e_str_is_read_only_add_bang_to_override), buf->b_fname);\n\treturn TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Try to abandon the current file and edit a new or existing file.\n * \"fnum\" is the number of the file, if zero use \"ffname_arg\"/\"sfname_arg\".\n * \"lnum\" is the line number for the cursor in the new file (if non-zero).\n *\n * Return:\n * GETFILE_ERROR for \"normal\" error,\n * GETFILE_NOT_WRITTEN for \"not written\" error,\n * GETFILE_SAME_FILE for success\n * GETFILE_OPEN_OTHER for successfully opening another file.\n */\n    int\ngetfile(\n    int\t\tfnum,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tsetpm,\n    linenr_T\tlnum,\n    int\t\tforceit)\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    int\t\tother;\n    int\t\tretval;\n    char_u\t*free_me = NULL;\n\n    if (text_locked())\n\treturn GETFILE_ERROR;\n    if (curbuf_locked())\n\treturn GETFILE_ERROR;\n\n    if (fnum == 0)\n    {\n\t\t\t\t\t// make ffname full path, set sfname\n\tfname_expand(curbuf, &ffname, &sfname);\n\tother = otherfile(ffname);\n\tfree_me = ffname;\t\t// has been allocated, free() later\n    }\n    else\n\tother = (fnum != curbuf->b_fnum);\n\n    if (other)\n\t++no_wait_return;\t    // don't wait for autowrite message\n    if (other && !forceit && curbuf->b_nwindows == 1 && !buf_hide(curbuf)\n\t\t   && curbufIsChanged() && autowrite(curbuf, forceit) == FAIL)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif (p_confirm && p_write)\n\t    dialog_changed(curbuf, FALSE);\n\tif (curbufIsChanged())\n#endif\n\t{\n\t    --no_wait_return;\n\t    no_write_message();\n\t    retval = GETFILE_NOT_WRITTEN;\t// file has been changed\n\t    goto theend;\n\t}\n    }\n    if (other)\n\t--no_wait_return;\n    if (setpm)\n\tsetpcmark();\n    if (!other)\n    {\n\tif (lnum != 0)\n\t    curwin->w_cursor.lnum = lnum;\n\tcheck_cursor_lnum();\n\tbeginline(BL_SOL | BL_FIX);\n\tretval = GETFILE_SAME_FILE;\t// it's in the same file\n    }\n    else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,\n\t     (buf_hide(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),\n\t\tcurwin) == OK)\n\tretval = GETFILE_OPEN_OTHER;\t// opened another file\n    else\n\tretval = GETFILE_ERROR;\t\t// error encountered\n\ntheend:\n    vim_free(free_me);\n    return retval;\n}\n\n/*\n * start editing a new file\n *\n *     fnum: file number; if zero use ffname/sfname\n *   ffname: the file name\n *\t\t- full path if sfname used,\n *\t\t- any file name if sfname is NULL\n *\t\t- empty string to re-edit with the same file name (but may be\n *\t\t    in a different directory)\n *\t\t- NULL to start an empty buffer\n *   sfname: the short file name (or NULL)\n *\teap: contains the command to be executed after loading the file and\n *\t     forced 'ff' and 'fenc'\n *  newlnum: if > 0: put cursor on this line number (if possible)\n *\t     if ECMD_LASTL: use last position in loaded file\n *\t     if ECMD_LAST: use last position in all files\n *\t     if ECMD_ONE: use first line\n *    flags:\n *\t   ECMD_HIDE: if TRUE don't free the current buffer\n *     ECMD_SET_HELP: set b_help flag of (new) buffer before opening file\n *\t ECMD_OLDBUF: use existing buffer if it exists\n *\tECMD_FORCEIT: ! used for Ex command\n *\t ECMD_ADDBUF: don't edit, just add to buffer list\n *\t ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate file\n *   ECMD_NOWINENTER: Do not trigger BufWinEnter\n *   oldwin: Should be \"curwin\" when editing a new buffer in the current\n *\t     window, NULL when splitting the window first.  When not NULL info\n *\t     of the previous buffer for \"oldwin\" is stored.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_ecmd(\n    int\t\tfnum,\n    char_u\t*ffname,\n    char_u\t*sfname,\n    exarg_T\t*eap,\t\t\t// can be NULL!\n    linenr_T\tnewlnum,\n    int\t\tflags,\n    win_T\t*oldwin)\n{\n    int\t\tother_file;\t\t// TRUE if editing another file\n    int\t\toldbuf;\t\t\t// TRUE if using existing buffer\n    int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us\n\t\t\t\t\t// into the buffer unexpectedly\n    char_u\t*new_name = NULL;\n#if defined(FEAT_EVAL)\n    int\t\tdid_set_swapcommand = FALSE;\n#endif\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    bufref_T\told_curbuf;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    char_u\t*browse_file = NULL;\n#endif\n    int\t\tretval = FAIL;\n    long\tn;\n    pos_T\torig_pos;\n    linenr_T\ttopline = 0;\n    int\t\tnewcol = -1;\n    int\t\tsolcol = -1;\n    pos_T\t*pos;\n    char_u\t*command = NULL;\n#ifdef FEAT_SPELL\n    int\t\tdid_get_winopts = FALSE;\n#endif\n    int\t\treadfile_flags = 0;\n    int\t\tdid_inc_redrawing_disabled = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn FAIL;\n#endif\n\n    if (eap != NULL)\n\tcommand = eap->do_ecmd_cmd;\n    set_bufref(&old_curbuf, curbuf);\n\n    if (fnum != 0)\n    {\n\tif (fnum == curbuf->b_fnum)\t// file is already being edited\n\t    return OK;\t\t\t// nothing to do\n\tother_file = TRUE;\n    }\n    else\n    {\n#ifdef FEAT_BROWSE\n\tif ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n\t{\n\t    if (\n# ifdef FEAT_GUI\n\t\t!gui.in_use &&\n# endif\n\t\t    au_has_group((char_u *)\"FileExplorer\"))\n\t    {\n\t\t// No browsing supported but we do have the file explorer:\n\t\t// Edit the directory.\n\t\tif (ffname == NULL || !mch_isdir(ffname))\n\t\t    ffname = dot_path;\n\t    }\n\t    else\n\t    {\n\t\tbrowse_file = do_browse(0, (char_u *)_(\"Edit File\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t\tif (browse_file == NULL)\n\t\t    goto theend;\n\t\tffname = browse_file;\n\t    }\n\t}\n#endif\n\t// if no short name given, use ffname for short name\n\tif (sfname == NULL)\n\t    sfname = ffname;\n#ifdef USE_FNAME_CASE\n\tif (sfname != NULL)\n\t    fname_case(sfname, 0);   // set correct case for sfname\n#endif\n\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t\t\t\t\t && (ffname == NULL || *ffname == NUL))\n\t    goto theend;\n\n\tif (ffname == NULL)\n\t    other_file = TRUE;\n\t\t\t\t\t    // there is no file name\n\telse if (*ffname == NUL && curbuf->b_ffname == NULL)\n\t    other_file = FALSE;\n\telse\n\t{\n\t    if (*ffname == NUL)\t\t    // re-edit with same file name\n\t    {\n\t\tffname = curbuf->b_ffname;\n\t\tsfname = curbuf->b_fname;\n\t    }\n\t    free_fname = fix_fname(ffname); // may expand to full path name\n\t    if (free_fname != NULL)\n\t\tffname = free_fname;\n\t    other_file = otherfile(ffname);\n\t}\n    }\n\n    /*\n     * If the file was changed we may not be allowed to abandon it:\n     * - if we are going to re-edit the same file\n     * - or if we are the only window on this file and if ECMD_HIDE is FALSE\n     */\n    if (  ((!other_file && !(flags & ECMD_OLDBUF))\n\t    || (curbuf->b_nwindows == 1\n\t\t&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))\n\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n\n    // End Visual mode before switching to another buffer, so the text can be\n    // copied into the GUI selection buffer.\n    // Careful: may trigger ModeChanged() autocommand\n\n    // Should we block autocommands here?\n    reset_VIsual();\n\n    // autocommands freed window :(\n    if (oldwin != NULL && !win_valid(oldwin))\n\toldwin = NULL;\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t// Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)\n\t    len = (int)STRLEN(command) + 3;\n\telse\n\t    len = 30;\n\tp = alloc(len);\n\tif (p != NULL)\n\t{\n\t    if (command != NULL)\n\t\tvim_snprintf((char *)p, len, \":%s\\r\", command);\n\t    else\n\t\tvim_snprintf((char *)p, len, \"%ldG\", (long)newlnum);\n\t    set_vim_var_string(VV_SWAPCOMMAND, p, -1);\n\t    did_set_swapcommand = TRUE;\n\t    vim_free(p);\n\t}\n    }\n#endif\n\n    /*\n     * If we are starting to edit another file, open a (new) buffer.\n     * Otherwise we re-use the current buffer.\n     */\n    if (other_file)\n    {\n\tint prev_alt_fnum = curwin->w_alt_fnum;\n\n\tif (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\tcurwin->w_alt_fnum = curbuf->b_fnum;\n\t    if (oldwin != NULL)\n\t\tbuflist_altfpos(oldwin);\n\t}\n\n\tif (fnum)\n\t    buf = buflist_findnr(fnum);\n\telse\n\t{\n\t    if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t    {\n\t\t// Default the line number to zero to avoid that a wininfo item\n\t\t// is added for the current window.\n\t\tlinenr_T\ttlnum = 0;\n\t\tbuf_T\t\t*newbuf;\n\n\t\tif (command != NULL)\n\t\t{\n\t\t    tlnum = atol((char *)command);\n\t\t    if (tlnum <= 0)\n\t\t\ttlnum = 1L;\n\t\t}\n\t\t// Add BLN_NOCURWIN to avoid a new wininfo items are associated\n\t\t// with the current window.\n\t\tnewbuf = buflist_new(ffname, sfname, tlnum,\n\t\t\t\t\t\t    BLN_LISTED | BLN_NOCURWIN);\n\t\tif (newbuf != NULL)\n\t\t{\n\t\t    if (flags & ECMD_ALTBUF)\n\t\t\tcurwin->w_alt_fnum = newbuf->b_fnum;\n\t\t    if (tlnum > 0)\n\t\t\tnewbuf->b_last_cursor.lnum = tlnum;\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    buf = buflist_new(ffname, sfname, 0L,\n\t\t    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));\n\n\t    // autocommands may change curwin and curbuf\n\t    if (oldwin != NULL)\n\t\toldwin = curwin;\n\t    set_bufref(&old_curbuf, curbuf);\n\t}\n\tif (buf == NULL)\n\t    goto theend;\n\tif (curwin->w_alt_fnum == buf->b_fnum && prev_alt_fnum != 0)\n\t    // reusing the buffer, keep the old alternate file\n\t    curwin->w_alt_fnum = prev_alt_fnum;\n\n\tif (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet\n\t{\n\t    oldbuf = FALSE;\n\t}\n\telse\t\t\t\t\t// existing memfile\n\t{\n\t    oldbuf = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    (void)buf_check_timestamp(buf, FALSE);\n\t    // Check if autocommands made the buffer invalid or changed the\n\t    // current buffer.\n\t    if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)\n\t\tgoto theend;\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t\tgoto theend;\n#endif\n\t}\n\n\t// May jump to last used line number for a loaded buffer or when asked\n\t// for explicitly\n\tif ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)\n\t{\n\t    pos = buflist_findfpos(buf);\n\t    newlnum = pos->lnum;\n\t    solcol = pos->col;\n\t}\n\n\t/*\n\t * Make the (new) buffer the one used by the current window.\n\t * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.\n\t * If the current buffer was empty and has no file name, curbuf\n\t * is returned by buflist_new(), nothing to do here.\n\t */\n\tif (buf != curbuf)\n\t{\n\t    bufref_T\tsave_au_new_curbuf;\n\t    int\t\tsave_cmdwin_type = cmdwin_type;\n\n\t    // BufLeave applies to the old buffer.\n\t    cmdwin_type = 0;\n\n\t    /*\n\t     * Be careful: The autocommands may delete any buffer and change\n\t     * the current buffer.\n\t     * - If the buffer we are going to edit is deleted, give up.\n\t     * - If the current buffer is deleted, prefer to load the new\n\t     *   buffer when loading a buffer is required.  This avoids\n\t     *   loading another buffer which then must be closed again.\n\t     * - If we ended up in the new buffer already, need to skip a few\n\t     *\t things, set auto_buf.\n\t     */\n\t    if (buf->b_fname != NULL)\n\t\tnew_name = vim_strsave(buf->b_fname);\n\t    save_au_new_curbuf = au_new_curbuf;\n\t    set_bufref(&au_new_curbuf, buf);\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    cmdwin_type = save_cmdwin_type;\n\t    if (!bufref_valid(&au_new_curbuf))\n\t    {\n\t\t// new buffer has been deleted\n\t\tdelbuf_msg(new_name);\t// frees new_name\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t    {\n\t\tvim_free(new_name);\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#endif\n\t    if (buf == curbuf)\t\t// already in new buffer\n\t\tauto_buf = TRUE;\n\t    else\n\t    {\n\t\twin_T\t    *the_curwin = curwin;\n\t\tint\t    did_decrement;\n\t\tbuf_T\t    *was_curbuf = curbuf;\n\n\t\t// Set the w_closing flag to avoid that autocommands close the\n\t\t// window.  And set b_locked for the same reason.\n\t\tthe_curwin->w_closing = TRUE;\n\t\t++buf->b_locked;\n\n\t\tif (curbuf == old_curbuf.br_buf)\n\t\t    buf_copy_options(buf, BCO_ENTER);\n\n\t\t// Close the link to the current buffer. This will set\n\t\t// oldwin->w_buffer to NULL.\n\t\tu_sync(FALSE);\n\t\tdid_decrement = close_buffer(oldwin, curbuf,\n\t\t\t (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);\n\n\t\t// Autocommands may have closed the window.\n\t\tif (win_valid(the_curwin))\n\t\t    the_curwin->w_closing = FALSE;\n\t\t--buf->b_locked;\n\n#ifdef FEAT_EVAL\n\t\t// autocmds may abort script processing\n\t\tif (aborting() && curwin->w_buffer != NULL)\n\t\t{\n\t\t    vim_free(new_name);\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n#endif\n\t\t// Be careful again, like above.\n\t\tif (!bufref_valid(&au_new_curbuf))\n\t\t{\n\t\t    // new buffer has been deleted\n\t\t    delbuf_msg(new_name);\t// frees new_name\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n\t\tif (buf == curbuf)\t\t// already in new buffer\n\t\t{\n\t\t    // close_buffer() has decremented the window count,\n\t\t    // increment it again here and restore w_buffer.\n\t\t    if (did_decrement && buf_valid(was_curbuf))\n\t\t\t++was_curbuf->b_nwindows;\n\t\t    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)\n\t\t\toldwin->w_buffer = was_curbuf;\n\t\t    auto_buf = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_SYN_HL\n\t\t    /*\n\t\t     * <VN> We could instead free the synblock\n\t\t     * and re-attach to buffer, perhaps.\n\t\t     */\n\t\t    if (curwin->w_buffer == NULL\n\t\t\t    || curwin->w_s == &(curwin->w_buffer->b_s))\n\t\t\tcurwin->w_s = &(buf->b_s);\n#endif\n\t\t    curwin->w_buffer = buf;\n\t\t    curbuf = buf;\n\t\t    ++curbuf->b_nwindows;\n\n\t\t    // Set 'fileformat', 'binary' and 'fenc' when forced.\n\t\t    if (!oldbuf && eap != NULL)\n\t\t    {\n\t\t\tset_file_options(TRUE, eap);\n\t\t\tset_forced_fenc(eap);\n\t\t    }\n\t\t}\n\n\t\t// May get the window options from the last time this buffer\n\t\t// was in this window (or another window).  If not used\n\t\t// before, reset the local window options to the global\n\t\t// values.  Also restores old folding stuff.\n\t\tget_winopts(curbuf);\n#ifdef FEAT_SPELL\n\t\tdid_get_winopts = TRUE;\n#endif\n\t    }\n\t    vim_free(new_name);\n\t    au_new_curbuf = save_au_new_curbuf;\n\t}\n\n\tcurwin->w_pcmark.lnum = 1;\n\tcurwin->w_pcmark.col = 0;\n    }\n    else // !other_file\n    {\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)\n\t    goto theend;\n\n\toldbuf = (flags & ECMD_OLDBUF);\n    }\n\n    // Don't redraw until the cursor is in the right line, otherwise\n    // autocommands may cause ml_get errors.\n    ++RedrawingDisabled;\n    did_inc_redrawing_disabled = TRUE;\n\n    buf = curbuf;\n    if ((flags & ECMD_SET_HELP) || keep_help_flag)\n    {\n\tprepare_help_buffer();\n    }\n    else\n    {\n\t// Don't make a buffer listed if it's a help buffer.  Useful when\n\t// using CTRL-O to go back to a help file.\n\tif (!curbuf->b_help)\n\t    set_buflisted(TRUE);\n    }\n\n    // If autocommands change buffers under our fingers, forget about\n    // editing the file.\n    if (buf != curbuf)\n\tgoto theend;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\tgoto theend;\n#endif\n\n    // Since we are starting to edit a file, consider the filetype to be\n    // unset.  Helps for when an autocommand changes files and expects syntax\n    // highlighting to work in the other file.\n    did_filetype = FALSE;\n\n/*\n * other_file\toldbuf\n *  FALSE\tFALSE\t    re-edit same file, buffer is re-used\n *  FALSE\tTRUE\t    re-edit same file, nothing changes\n *  TRUE\tFALSE\t    start editing new file, new buffer\n *  TRUE\tTRUE\t    start editing in existing buffer (nothing to do)\n */\n    if (!other_file && !oldbuf)\t\t// re-use the buffer\n    {\n\tset_last_cursor(curwin);\t// may set b_last_cursor\n\tif (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)\n\t{\n\t    newlnum = curwin->w_cursor.lnum;\n\t    solcol = curwin->w_cursor.col;\n\t}\n\tbuf = curbuf;\n\tif (buf->b_fname != NULL)\n\t    new_name = vim_strsave(buf->b_fname);\n\telse\n\t    new_name = NULL;\n\tset_bufref(&bufref, buf);\n\n\t// If the buffer was used before, store the current contents so that\n\t// the reload can be undone.  Do not do this if the (empty) buffer is\n\t// being re-used for another file.\n\tif (!(curbuf->b_flags & BF_NEVERLOADED)\n\t\t&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))\n\t{\n\t    // Sync first so that this is a separate undo-able action.\n\t    u_sync(FALSE);\n\t    if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)\n\t\t\t\t\t\t\t\t     == FAIL)\n\t    {\n\t\tvim_free(new_name);\n\t\tgoto theend;\n\t    }\n\t    u_unchanged(curbuf);\n\t    buf_freeall(curbuf, BFA_KEEP_UNDO);\n\n\t    // tell readfile() not to clear or reload undo info\n\t    readfile_flags = READ_KEEP_UNDO;\n\t}\n\telse\n\t    buf_freeall(curbuf, 0);   // free all things for buffer\n\n\t// If autocommands deleted the buffer we were going to re-edit, give\n\t// up and jump to the end.\n\tif (!bufref_valid(&bufref))\n\t{\n\t    delbuf_msg(new_name);\t// frees new_name\n\t    goto theend;\n\t}\n\tvim_free(new_name);\n\n\t// If autocommands change buffers under our fingers, forget about\n\t// re-editing the file.  Should do the buf_clear_file(), but perhaps\n\t// the autocommands changed the buffer...\n\tif (buf != curbuf)\n\t    goto theend;\n#ifdef FEAT_EVAL\n\tif (aborting())\t    // autocmds may abort script processing\n\t    goto theend;\n#endif\n\tbuf_clear_file(curbuf);\n\tcurbuf->b_op_start.lnum = 0;\t// clear '[ and '] marks\n\tcurbuf->b_op_end.lnum = 0;\n    }\n\n/*\n * If we get here we are sure to start editing\n */\n    // Assume success now\n    retval = OK;\n\n    // If the file name was changed, reset the not-edit flag so that \":write\"\n    // works.\n    if (!other_file)\n\tcurbuf->b_flags &= ~BF_NOTEDITED;\n\n    /*\n     * Check if we are editing the w_arg_idx file in the argument list.\n     */\n    check_arg_idx(curwin);\n\n    if (!auto_buf)\n    {\n\t/*\n\t * Set cursor and init window before reading the file and executing\n\t * autocommands.  This allows for the autocommands to position the\n\t * cursor.\n\t */\n\tcurwin_init();\n\n#ifdef FEAT_FOLDING\n\t// It's possible that all lines in the buffer changed.  Need to update\n\t// automatic folding for all windows where it's used.\n\t{\n\t    win_T\t    *win;\n\t    tabpage_T\t    *tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, win)\n\t\tif (win->w_buffer == curbuf)\n\t\t    foldUpdateAll(win);\n\t}\n#endif\n\n\t// Change directories when the 'acd' option is set.\n\tDO_AUTOCHDIR;\n\n\t/*\n\t * Careful: open_buffer() and apply_autocmds() may change the current\n\t * buffer and window.\n\t */\n\torig_pos = curwin->w_cursor;\n\ttopline = curwin->w_topline;\n\tif (!oldbuf)\t\t\t    // need to read the file\n\t{\n#ifdef FEAT_PROP_POPUP\n\t    // Don't use the swap-exists dialog for a popup window, can't edit\n\t    // the buffer.\n\t    if (WIN_IS_POPUP(curwin))\n\t\tcurbuf->b_flags |= BF_NO_SEA;\n#endif\n\t    swap_exists_action = SEA_DIALOG;\n\t    curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag\n\n\t    /*\n\t     * Open the buffer and read the file.\n\t     */\n\t    if (flags & ECMD_NOWINENTER)\n\t\treadfile_flags |= READ_NOWINENTER;\n#if defined(FEAT_EVAL)\n\t    if (should_abort(open_buffer(FALSE, eap, readfile_flags)))\n\t\tretval = FAIL;\n#else\n\t    (void)open_buffer(FALSE, eap, readfile_flags);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n\t    curbuf->b_flags &= ~BF_NO_SEA;\n#endif\n\t    if (swap_exists_action == SEA_QUIT)\n\t\tretval = FAIL;\n\t    handle_swap_exists(&old_curbuf);\n\t}\n\telse\n\t{\n\t    // Read the modelines, but only to set window-local options.  Any\n\t    // buffer-local options have already been set and may have been\n\t    // changed by the user.\n\t    do_modelines(OPT_WINONLY);\n\n\t    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t    if ((flags & ECMD_NOWINENTER) == 0)\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t}\n\tcheck_arg_idx(curwin);\n\n\t// If autocommands change the cursor position or topline, we should\n\t// keep it.  Also when it moves within a line. But not when it moves\n\t// to the first non-blank.\n\tif (!EQUAL_POS(curwin->w_cursor, orig_pos))\n\t{\n\t    char_u *text = ml_get_curline();\n\n\t    if (curwin->w_cursor.lnum != orig_pos.lnum\n\t\t    || curwin->w_cursor.col != (int)(skipwhite(text) - text))\n\t    {\n\t\tnewlnum = curwin->w_cursor.lnum;\n\t\tnewcol = curwin->w_cursor.col;\n\t    }\n\t}\n\tif (curwin->w_topline == topline)\n\t    topline = 0;\n\n\t// Even when cursor didn't move we need to recompute topline.\n\tchanged_line_abv_curs();\n\n\tmaketitle();\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\tif (WIN_IS_POPUP(curwin) && curwin->w_p_pvw && retval != FAIL)\n\t    popup_set_title(curwin);\n#endif\n    }\n\n#ifdef FEAT_DIFF\n    // Tell the diff stuff that this buffer is new and/or needs updating.\n    // Also needed when re-editing the same buffer, because unloading will\n    // have removed it as a diff buffer.\n    if (curwin->w_p_diff)\n    {\n\tdiff_buf_add(curbuf);\n\tdiff_invalidate(curbuf);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // If the window options were changed may need to set the spell language.\n    // Can only do this after the buffer has been properly setup.\n    if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)parse_spelllang(curwin);\n#endif\n\n    if (command == NULL)\n    {\n\tif (newcol >= 0)\t// position set by autocommands\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    curwin->w_cursor.col = newcol;\n\t    check_cursor();\n\t}\n\telse if (newlnum > 0)\t// line number from caller or old position\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    check_cursor_lnum();\n\t    if (solcol >= 0 && !p_sol)\n\t    {\n\t\t// 'sol' is off: Use last known column.\n\t\tcurwin->w_cursor.col = solcol;\n\t\tcheck_cursor_col();\n\t\tcurwin->w_cursor.coladd = 0;\n\t\tcurwin->w_set_curswant = TRUE;\n\t    }\n\t    else\n\t\tbeginline(BL_SOL | BL_FIX);\n\t}\n\telse\t\t\t// no line number, go to last line in Ex mode\n\t{\n\t    if (exmode_active)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n    }\n\n    // Check if cursors in other windows on the same buffer are still valid\n    check_lnums(FALSE);\n\n    /*\n     * Did not read the file, need to show some info about the file.\n     * Do this after setting the cursor.\n     */\n    if (oldbuf && !auto_buf)\n    {\n\tint\tmsg_scroll_save = msg_scroll;\n\n\t// Obey the 'O' flag in 'cpoptions': overwrite any previous file\n\t// message.\n\tif (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n\t    msg_scroll = FALSE;\n\tif (!msg_scroll)\t// wait a bit when overwriting an error msg\n\t    check_for_delay(FALSE);\n\tmsg_start();\n\tmsg_scroll = msg_scroll_save;\n\tmsg_scrolled_ign = TRUE;\n\n\tif (!shortmess(SHM_FILEINFO))\n\t    fileinfo(FALSE, TRUE, FALSE);\n\n\tmsg_scrolled_ign = FALSE;\n    }\n\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    if (command != NULL)\n\tdo_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n\n    if (RedrawingDisabled > 0)\n\t--RedrawingDisabled;\n    did_inc_redrawing_disabled = FALSE;\n    if (!skip_redraw)\n    {\n\tn = *so_ptr;\n\tif (topline == 0 && command == NULL)\n\t    *so_ptr = 9999;\t\t// force cursor halfway the window\n\tupdate_topline();\n\tcurwin->w_scbind_pos = curwin->w_topline;\n\t*so_ptr = n;\n\tredraw_curbuf_later(UPD_NOT_VALID);\t// redraw this buffer later\n    }\n\n    if (p_im && (State & MODE_INSERT) == 0)\n\tneed_start_insertmode = TRUE;\n\n#ifdef FEAT_AUTOCHDIR\n    // Change directories when the 'acd' option is set and we aren't already in\n    // that directory (should already be done above). Expect getcwd() to be\n    // faster than calling shorten_fnames() unnecessarily.\n    if (p_acd && curbuf->b_ffname != NULL)\n    {\n\tchar_u\tcurdir[MAXPATHL];\n\tchar_u\tfiledir[MAXPATHL];\n\n\tvim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);\n\t*gettail_sep(filedir) = NUL;\n\tif (mch_dirname(curdir, MAXPATHL) != FAIL\n\t\t&& vim_fnamecmp(curdir, filedir) != 0)\n\t    do_autochdir();\n    }\n#endif\n\n#if defined(FEAT_NETBEANS_INTG)\n    if (curbuf->b_ffname != NULL)\n    {\n# ifdef FEAT_NETBEANS_INTG\n\tif ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)\n\t    netbeans_file_opened(curbuf);\n# endif\n    }\n#endif\n\ntheend:\n    if (did_inc_redrawing_disabled && RedrawingDisabled > 0)\n\t--RedrawingDisabled;\n#if defined(FEAT_EVAL)\n    if (did_set_swapcommand)\n\tset_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n    static void\ndelbuf_msg(char_u *name)\n{\n    semsg(_(e_autocommands_unexpectedly_deleted_new_buffer_str),\n\t\t\t\t\t   name == NULL ? (char_u *)\"\" : name);\n    vim_free(name);\n    au_new_curbuf.br_buf = NULL;\n    au_new_curbuf.br_buf_free_count = 0;\n}\n\nstatic int append_indent = 0;\t    // autoindent for first line\n\n/*\n * \":insert\" and \":append\", also used by \":change\"\n */\n    void\nex_append(exarg_T *eap)\n{\n    char_u\t*theline;\n    int\t\tdid_undo = FALSE;\n    linenr_T\tlnum = eap->line2;\n    int\t\tindent = 0;\n    char_u\t*p;\n    int\t\tvcol;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    // the ! flag toggles autoindent\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // First autoindent comes from the line we start on\n    if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)\n\tappend_indent = get_indent_lnum(lnum);\n\n    if (eap->cmdidx != CMD_append)\n\t--lnum;\n\n    // when the buffer is empty need to delete the dummy line\n    if (empty && lnum == 1)\n\tlnum = 0;\n\n    State = MODE_INSERT;\t\t    // behave like in Insert mode\n    if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\tState |= MODE_LANGMAP;\n\n    for (;;)\n    {\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tif (curbuf->b_p_ai)\n\t{\n\t    if (append_indent >= 0)\n\t    {\n\t\tindent = append_indent;\n\t\tappend_indent = -1;\n\t    }\n\t    else if (lnum > 0)\n\t\tindent = get_indent_lnum(lnum);\n\t}\n\tex_keep_indent = FALSE;\n\tif (eap->getline == NULL)\n\t{\n\t    // No getline() function, use the lines that follow. This ends\n\t    // when there is no more.\n\t    if (eap->nextcmd == NULL || *eap->nextcmd == NUL)\n\t\tbreak;\n\t    p = vim_strchr(eap->nextcmd, NL);\n\t    if (p == NULL)\n\t\tp = eap->nextcmd + STRLEN(eap->nextcmd);\n\t    theline = vim_strnsave(eap->nextcmd, p - eap->nextcmd);\n\t    if (*p != NUL)\n\t\t++p;\n\t    eap->nextcmd = p;\n\t}\n\telse\n\t{\n\t    int save_State = State;\n\n\t    // Set State to avoid the cursor shape to be set to MODE_INSERT\n\t    // state when getline() returns.\n\t    State = MODE_CMDLINE;\n\t    theline = eap->getline(\n#ifdef FEAT_EVAL\n\t\t    eap->cstack->cs_looplevel > 0 ? -1 :\n#endif\n\t\t    NUL, eap->cookie, indent, TRUE);\n\t    State = save_State;\n\t}\n\tlines_left = Rows - 1;\n\tif (theline == NULL)\n\t    break;\n\n\t// Using ^ CTRL-D in getexmodeline() makes us repeat the indent.\n\tif (ex_keep_indent)\n\t    append_indent = indent;\n\n\t// Look for the \".\" after automatic indent.\n\tvcol = 0;\n\tfor (p = theline; indent > vcol; ++p)\n\t{\n\t    if (*p == ' ')\n\t\t++vcol;\n\t    else if (*p == TAB)\n\t\tvcol += 8 - vcol % 8;\n\t    else\n\t\tbreak;\n\t}\n\tif ((p[0] == '.' && p[1] == NUL)\n\t\t|| (!did_undo && u_save(lnum, lnum + 1 + (empty ? 1 : 0))\n\t\t\t\t\t\t\t\t     == FAIL))\n\t{\n\t    vim_free(theline);\n\t    break;\n\t}\n\n\t// don't use autoindent if nothing was typed.\n\tif (p[0] == NUL)\n\t    theline[0] = NUL;\n\n\tdid_undo = TRUE;\n\tml_append(lnum, theline, (colnr_T)0, FALSE);\n\tif (empty)\n\t    // there are no marks below the inserted lines\n\t    appended_lines(lnum, 1L);\n\telse\n\t    appended_lines_mark(lnum, 1L);\n\n\tvim_free(theline);\n\t++lnum;\n\n\tif (empty)\n\t{\n\t    ml_delete(2L);\n\t    empty = FALSE;\n\t}\n    }\n    State = MODE_NORMAL;\n\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // \"start\" is set to eap->line2+1 unless that position is invalid (when\n    // eap->line2 pointed to the end of the buffer and nothing was appended)\n    // \"end\" is set to lnum when something has been appended, otherwise\n    // it is the same as \"start\"  -- Acevedo\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = (eap->line2 < curbuf->b_ml.ml_line_count) ?\n\t    eap->line2 + 1 : curbuf->b_ml.ml_line_count;\n\tif (eap->cmdidx != CMD_append)\n\t    --curbuf->b_op_start.lnum;\n\tcurbuf->b_op_end.lnum = (eap->line2 < lnum)\n\t\t\t\t\t      ? lnum : curbuf->b_op_start.lnum;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n    curwin->w_cursor.lnum = lnum;\n    check_cursor_lnum();\n    beginline(BL_SOL | BL_FIX);\n\n    need_wait_return = FALSE;\t// don't use wait_return() now\n    ex_no_reprint = TRUE;\n}\n\n/*\n * \":change\"\n */\n    void\nex_change(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (eap->line2 >= eap->line1\n\t    && u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)\n\treturn;\n\n    // the ! flag toggles autoindent\n    if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)\n\tappend_indent = get_indent_lnum(eap->line1);\n\n    for (lnum = eap->line2; lnum >= eap->line1; --lnum)\n    {\n\tif (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to delete\n\t    break;\n\tml_delete(eap->line1);\n    }\n\n    // make sure the cursor is not beyond the end of the file now\n    check_cursor_lnum();\n    deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));\n\n    // \":append\" on the line above the deleted lines.\n    eap->line2 = eap->line1;\n    ex_append(eap);\n}\n\n    void\nex_z(exarg_T *eap)\n{\n    char_u\t*x;\n    long\tbigness;\n    char_u\t*kind;\n    int\t\tminus = 0;\n    linenr_T\tstart, end, curs, i;\n    int\t\tj;\n    linenr_T\tlnum = eap->line2;\n\n    // Vi compatible: \":z!\" uses display height, without a count uses\n    // 'scroll'\n    if (eap->forceit)\n\tbigness = Rows - 1;\n    else if (!ONE_WINDOW)\n\tbigness = curwin->w_height - 3;\n    else\n\tbigness = curwin->w_p_scr * 2;\n    if (bigness < 1)\n\tbigness = 1;\n\n    x = eap->arg;\n    kind = x;\n    if (*kind == '-' || *kind == '+' || *kind == '='\n\t\t\t\t\t      || *kind == '^' || *kind == '.')\n\t++x;\n    while (*x == '-' || *x == '+')\n\t++x;\n\n    if (*x != 0)\n    {\n\tif (!VIM_ISDIGIT(*x))\n\t{\n\t    emsg(_(e_non_numeric_argument_to_z));\n\t    return;\n\t}\n\telse\n\t{\n\t    bigness = atol((char *)x);\n\n\t    // bigness could be < 0 if atol(x) overflows.\n\t    if (bigness > 2 * curbuf->b_ml.ml_line_count || bigness < 0)\n\t\tbigness = 2 * curbuf->b_ml.ml_line_count;\n\n\t    p_window = bigness;\n\t    if (*kind == '=')\n\t\tbigness += 2;\n\t}\n    }\n\n    // the number of '-' and '+' multiplies the distance\n    if (*kind == '-' || *kind == '+')\n\tfor (x = kind + 1; *x == *kind; ++x)\n\t    ;\n\n    switch (*kind)\n    {\n\tcase '-':\n\t    start = lnum - bigness * (linenr_T)(x - kind) + 1;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n\n\tcase '=':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = lnum;\n\t    minus = 1;\n\t    break;\n\n\tcase '^':\n\t    start = lnum - bigness * 2;\n\t    end = lnum - bigness;\n\t    curs = lnum - bigness;\n\t    break;\n\n\tcase '.':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = end;\n\t    break;\n\n\tdefault:  // '+'\n\t    start = lnum;\n\t    if (*kind == '+')\n\t\tstart += bigness * (linenr_T)(x - kind - 1) + 1;\n\t    else if (eap->addr_count == 0)\n\t\t++start;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n    }\n\n    if (start < 1)\n\tstart = 1;\n\n    if (end > curbuf->b_ml.ml_line_count)\n\tend = curbuf->b_ml.ml_line_count;\n\n    if (curs > curbuf->b_ml.ml_line_count)\n\tcurs = curbuf->b_ml.ml_line_count;\n    else if (curs < 1)\n\tcurs = 1;\n\n    for (i = start; i <= end; i++)\n    {\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n\n\tprint_line(i, eap->flags & EXFLAG_NR, eap->flags & EXFLAG_LIST);\n\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n    }\n\n    if (curwin->w_cursor.lnum != curs)\n    {\n\tcurwin->w_cursor.lnum = curs;\n\tcurwin->w_cursor.col = 0;\n    }\n    ex_no_reprint = TRUE;\n}\n\n/*\n * Check if the restricted flag is set.\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(e_shell_commands_and_some_functionality_not_allowed_in_rvim));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check if the secure flag is set (.exrc or .vimrc in current directory).\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_secure(void)\n{\n    if (secure)\n    {\n\tsecure = 2;\n\temsg(_(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search));\n\treturn TRUE;\n    }\n#ifdef HAVE_SANDBOX\n    /*\n     * In the sandbox more things are not allowed, including the things\n     * disallowed in secure mode.\n     */\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn TRUE;\n    }\n#endif\n    return FALSE;\n}\n\nstatic char_u\t*old_sub = NULL;\t// previous substitute pattern\nstatic int\tglobal_need_beginline;\t// call beginline() after \":g\"\n\n/*\n * Flags that are kept between calls to :substitute.\n */\ntypedef struct {\n    int\tdo_all;\t\t// do multiple substitutions per line\n    int\tdo_ask;\t\t// ask for confirmation\n    int\tdo_count;\t// count only\n    int\tdo_error;\t// if false, ignore errors\n    int\tdo_print;\t// print last line with subs.\n    int\tdo_list;\t// list last line with subs.\n    int\tdo_number;\t// list last line with line nr\n    int\tdo_ic;\t\t// ignore case flag\n} subflags_T;\n\n/*\n * Skip over the \"sub\" part in :s/pat/sub/ where \"delimiter\" is the separating\n * character.\n */\n    char_u *\nskip_substitute(char_u *start, int delimiter)\n{\n    char_u *p = start;\n\n    while (p[0])\n    {\n\tif (p[0] == delimiter)\t\t// end delimiter found\n\t{\n\t    *p++ = NUL;\t\t\t// replace it with a NUL\n\t    break;\n\t}\n\tif (p[0] == '\\\\' && p[1] != 0)\t// skip escaped characters\n\t    ++p;\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    static int\ncheck_regexp_delim(int c)\n{\n    if (isalpha(c))\n    {\n\temsg(_(e_regular_expressions_cant_be_delimited_by_letters));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Perform a substitution from line eap->line1 to line eap->line2 using the\n * command pointed to by eap->arg which should be of the form:\n *\n * /pattern/substitution/{flags}\n *\n * The usual escapes are supported as described in the regexp docs.\n */\n    void\nex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    char_u\t*sub_copy = NULL;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n    int\t\tsave_sandbox = 0;\n#endif\n#ifdef FEAT_PROP_POPUP\n    textprop_T\t*text_props = NULL;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    if (in_vim9script())\n\t    {\n\t\temsg(_(e_cannot_use_s_backslash_in_vim9_script));\n\t\treturn;\n\t    }\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\telse if (i >= INT_MAX)\n\t{\n\t    char\tbuf[20];\n\t    vim_snprintf(buf, sizeof(buf), \"%ld\", i);\n\t    semsg(_(e_val_too_large), buf);\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, NULL, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n    {\n\tchar_u *newsub = regtilde(sub, magic_isset());\n\n\tif (newsub != sub)\n\t{\n\t    // newsub was allocated, free it later.\n\t    sub_copy = newsub;\n\t    sub = newsub;\n\t}\n    }\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n\t    int\t\ttext_prop_count = 0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to MODE_CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = MODE_CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t\t// When \":normal\" runs out of characters we get\n\t\t\t\t// an empty line.  Use \"q\" to get out of the\n\t\t\t\t// loop.\n\t\t\t\tif (ex_normal_busy && typed == NUL)\n\t\t\t\t    typed = 'q';\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    int save_RedrawingDisabled = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    if (search_match_lines == 0\n\t\t\t\t\t\t   && search_match_endcol == 0)\n\t\t\t\t// highlight at least one character for /^/\n\t\t\t\tsearch_match_endcol = 1;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(UPD_SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(UPD_SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return()\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = save_RedrawingDisabled;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tsave_sandbox = sandbox;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n\n\t\t// Disallow changing text or switching window in an expression.\n\t\t++textlock;\n#endif\n\t\t// Get length of substitution part, including the NUL.\n\t\t// When it fails sublen is zero.\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, 0,\n\t\t\t       REGSUB_BACKSLASH\n\t\t\t\t    | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (sublen == 0 || aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    sandbox = save_sandbox;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t    // safety check\n\t\t    if (nmatch < 0)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    linenr_T\tlastlnum = sub_firstlnum + nmatch - 1;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tchar_u\t*prop_start;\n\n\t\t\t// Props in the first line may be shortened or deleted\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       -MAXCOL, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\ttotal_added -= (colnr_T)STRLEN(\n\t\t\t\t     sub_firstline + regmatch.startpos[0].col);\n\n\t\t\t// Props in the last line may be moved or deleted\n\t\t\tif (adjust_prop_columns(lastlnum,\n\t\t\t\t\t0, -regmatch.endpos[0].col, apc_flags))\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\n\t\t\t// Copy the text props of the last line, they will be\n\t\t\t// later appended to the changed line.\n\t\t\ttext_prop_count = get_text_props(curbuf, lastlnum,\n\t\t\t\t\t\t\t   &prop_start, FALSE);\n\t\t\tif (text_prop_count > 0)\n\t\t\t{\n\t\t\t    // TODO: what when we already did this?\n\t\t\t    vim_free(text_props);\n\t\t\t    text_props = ALLOC_MULT(textprop_T,\n\t\t\t\t\t\t\t      text_prop_count);\n\t\t\t    if (text_props != NULL)\n\t\t\t    {\n\t\t\t\tint pi;\n\n\t\t\t\tmch_memmove(text_props, prop_start,\n\t\t\t\t\t text_prop_count * sizeof(textprop_T));\n\t\t\t\t// After joining the text prop columns will\n\t\t\t\t// increase.\n\t\t\t\tfor (pi = 0; pi < text_prop_count; ++pi)\n\t\t\t\t    text_props[pi].tp_col +=\n\t\t\t\t\t regmatch.startpos[0].col + sublen - 1;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n#endif\n\t\t    p1 = ml_get(lastlnum);\n\t\t    nmatch_tl += nmatch - 1;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t\ttotal_added += (colnr_T)STRLEN(\n\t\t\t\t\t\t  p1 + regmatch.endpos[0].col);\n#endif\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\tif ((int)new_start_len - copy_len < sublen)\n\t\t    sublen = new_start_len - copy_len - 1;\n\n#ifdef FEAT_EVAL\n\t\t++textlock;\n#endif\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, sublen,\n\t\t\t\t      REGSUB_COPY | REGSUB_BACKSLASH\n\t\t\t\t\t | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n#endif\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum,\n\t\t\t\t\t\t\t       plen, 1, FALSE);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (text_props != NULL)\n\t\t\t    add_text_props(lnum, text_props, text_prop_count);\n#endif\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n#ifdef FEAT_PROP_POPUP\n    vim_free(text_props);\n#endif\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub_copy);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}\n\n/*\n * Give message for number of substitutions.\n * Can also be used after a \":global\" command.\n * Return TRUE if a message was given.\n */\n    int\ndo_sub_msg(\n    int\t    count_only)\t\t// used 'n' flag for \":s\"\n{\n    /*\n     * Only report substitutions when:\n     * - more than 'report' substitutions\n     * - command was typed by user, or number of changed lines > 'report'\n     * - giving messages is not disabled by 'lazyredraw'\n     */\n    if (((sub_nsubs > p_report && (KeyTyped || sub_nlines > 1 || p_report < 1))\n\t\t|| count_only)\n\t    && messaging())\n    {\n\tchar\t*msg_single;\n\tchar\t*msg_plural;\n\n\tif (got_int)\n\t    STRCPY(msg_buf, _(\"(Interrupted) \"));\n\telse\n\t    *msg_buf = NUL;\n\n\tmsg_single = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld line\",\n\t\t\t\t\t  \"%ld matches on %ld line\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld line\",\n\t\t\t\t   \"%ld substitutions on %ld line\", sub_nsubs);\n\tmsg_plural = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld lines\",\n\t\t\t\t\t \"%ld matches on %ld lines\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld lines\",\n\t\t\t\t  \"%ld substitutions on %ld lines\", sub_nsubs);\n\n\tvim_snprintf_add(msg_buf, sizeof(msg_buf),\n\t\t\t\t NGETTEXT(msg_single, msg_plural, sub_nlines),\n\t\t\t\t sub_nsubs, (long)sub_nlines);\n\n\tif (msg(msg_buf))\n\t    // save message to display it after redraw\n\t    set_keep_msg((char_u *)msg_buf, 0);\n\treturn TRUE;\n    }\n    if (got_int)\n    {\n\temsg(_(e_interrupted));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nglobal_exe_one(char_u *cmd, linenr_T lnum)\n{\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    if (*cmd == NUL || *cmd == '\\n')\n\tdo_cmdline((char_u *)\"p\", NULL, NULL, DOCMD_NOWAIT);\n    else\n\tdo_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);\n}\n\n/*\n * Execute a global command of the form:\n *\n * g/pattern/X : execute X on all lines where pattern matches\n * v/pattern/X : execute X on all lines where pattern does not match\n *\n * where 'X' is an EX command\n *\n * The command character (as well as the trailing slash) is optional, and\n * is assumed to be 'p' if missing.\n *\n * This is implemented in two passes: first we scan the file for the pattern and\n * set a mark for each line that (not) matches. Secondly we execute the command\n * for each line that has a mark. This is required because after deleting\n * lines we do not know where to search for the next match.\n */\n    void\nex_global(exarg_T *eap)\n{\n    linenr_T\tlnum;\t\t// line number according to old situation\n    int\t\tndone = 0;\n    int\t\ttype;\t\t// first char of cmd: 'v' or 'g'\n    char_u\t*cmd;\t\t// command argument\n\n    char_u\tdelim;\t\t// delimiter, normally '/'\n    char_u\t*pat;\n    char_u\t*used_pat;\n    regmmatch_T\tregmatch;\n    int\t\tmatch;\n    int\t\twhich_pat;\n\n    // When nesting the command works on one line.  This allows for\n    // \":g/found/v/notfound/command\".\n    if (global_busy && (eap->line1 != 1\n\t\t\t\t  || eap->line2 != curbuf->b_ml.ml_line_count))\n    {\n\t// will increment global_busy to break out of the loop\n\temsg(_(e_cannot_do_global_recursive_with_range));\n\treturn;\n    }\n\n    if (eap->forceit)\t\t    // \":global!\" is like \":vglobal\"\n\ttype = 'v';\n    else\n\ttype = *eap->cmd;\n    cmd = eap->arg;\n    which_pat = RE_LAST;\t    // default: use last used regexp\n\n#ifdef FEAT_EVAL\n    if (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg) == FAIL)\n\treturn;\n#endif\n\n    /*\n     * undocumented vi feature:\n     *\t\"\\/\" and \"\\?\": use previous search pattern.\n     *\t\t \"\\&\": use previous substitute pattern.\n     */\n    if (*cmd == '\\\\')\n    {\n\t++cmd;\n\tif (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t{\n\t    emsg(_(e_backslash_should_be_followed_by));\n\t    return;\n\t}\n\tif (*cmd == '&')\n\t    which_pat = RE_SUBST;\t// use previous substitute pattern\n\telse\n\t    which_pat = RE_SEARCH;\t// use previous search pattern\n\t++cmd;\n\tpat = (char_u *)\"\";\n    }\n    else if (*cmd == NUL)\n    {\n\temsg(_(e_regular_expression_missing_from_global));\n\treturn;\n    }\n    else if (check_regexp_delim(*cmd) == FAIL)\n    {\n\treturn;\n    }\n    else\n    {\n\tdelim = *cmd;\t\t// get the delimiter\n\t++cmd;\t\t\t// skip delimiter if there is one\n\tpat = cmd;\t\t// remember start of pattern\n\tcmd = skip_regexp_ex(cmd, delim, magic_isset(), &eap->arg, NULL, NULL);\n\tif (cmd[0] == delim)\t\t    // end delimiter found\n\t    *cmd++ = NUL;\t\t    // replace it with a NUL\n    }\n\n    if (search_regcomp(pat, &used_pat, RE_BOTH, which_pat, SEARCH_HIS,\n\t\t\t\t\t\t\t    &regmatch) == FAIL)\n    {\n\temsg(_(e_invalid_command));\n\treturn;\n    }\n\n    if (global_busy)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif ((type == 'g' && match) || (type == 'v' && !match))\n\t    global_exe_one(cmd, lnum);\n    }\n    else\n    {\n\t/*\n\t * pass 1: set marks for each (not) matching line\n\t */\n\tfor (lnum = eap->line1; lnum <= eap->line2 && !got_int; ++lnum)\n\t{\n\t    // a match on this line?\n\t    match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\t    if (regmatch.regprog == NULL)\n\t\tbreak;  // re-compiling regprog failed\n\t    if ((type == 'g' && match) || (type == 'v' && !match))\n\t    {\n\t\tml_setmarked(lnum);\n\t\tndone++;\n\t    }\n\t    line_breakcheck();\n\t}\n\n\t/*\n\t * pass 2: execute the command for each line that has been marked\n\t */\n\tif (got_int)\n\t    msg(_(e_interrupted));\n\telse if (ndone == 0)\n\t{\n\t    if (type == 'v')\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_found_in_every_line_str), used_pat);\n\t\telse\n\t\t    smsg(_(\"Pattern found in every line: %s\"), used_pat);\n\t    }\n\t    else\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_not_found_str), used_pat);\n\t\telse\n\t\t    smsg(_(\"Pattern not found: %s\"), used_pat);\n\t    }\n\t}\n\telse\n\t{\n#ifdef FEAT_CLIPBOARD\n\t    start_global_changes();\n#endif\n\t    global_exe(cmd);\n#ifdef FEAT_CLIPBOARD\n\t    end_global_changes();\n#endif\n\t}\n\n\tml_clearmarked();\t   // clear rest of the marks\n    }\n\n    vim_regfree(regmatch.regprog);\n}\n\n/*\n * Execute \"cmd\" on lines marked with ml_setmarked().\n */\n    void\nglobal_exe(char_u *cmd)\n{\n    linenr_T old_lcount;\t// b_ml.ml_line_count before the command\n    buf_T    *old_buf = curbuf;\t// remember what buffer we started in\n    linenr_T lnum;\t\t// line number according to old situation\n\n    /*\n     * Set current position only once for a global command.\n     * If global_busy is set, setpcmark() will not do anything.\n     * If there is an error, global_busy will be incremented.\n     */\n    setpcmark();\n\n    // When the command writes a message, don't overwrite the command.\n    msg_didout = TRUE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    global_need_beginline = FALSE;\n    global_busy = 1;\n    old_lcount = curbuf->b_ml.ml_line_count;\n    while (!got_int && (lnum = ml_firstmarked()) != 0 && global_busy == 1)\n    {\n\tglobal_exe_one(cmd, lnum);\n\tui_breakcheck();\n    }\n\n    global_busy = 0;\n    if (global_need_beginline)\n\tbeginline(BL_WHITE | BL_FIX);\n    else\n\tcheck_cursor();\t// cursor may be beyond the end of the line\n\n    // the cursor may not have moved in the text but a change in a previous\n    // line may move it on the screen\n    changed_line_abv_curs();\n\n    // If it looks like no message was written, allow overwriting the\n    // command with the report for number of changes.\n    if (msg_col == 0 && msg_scrolled == 0)\n\tmsg_didout = FALSE;\n\n    // If substitutes done, report number of substitutes, otherwise report\n    // number of extra or deleted lines.\n    // Don't report extra or deleted lines in the edge case where the buffer\n    // we are in after execution is different from the buffer we started in.\n    if (!do_sub_msg(FALSE) && curbuf == old_buf)\n\tmsgmore(curbuf->b_ml.ml_line_count - old_lcount);\n}\n\n#ifdef FEAT_VIMINFO\n/*\n * Get the previous substitute pattern.\n */\n    char_u *\nget_old_sub(void)\n{\n    return old_sub;\n}\n\n/*\n * Set the previous substitute pattern.  \"val\" must be allocated.\n */\n    void\nset_old_sub(char_u *val)\n{\n    vim_free(old_sub);\n    old_sub = val;\n}\n#endif // FEAT_VIMINFO\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_old_sub(void)\n{\n    vim_free(old_sub);\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Set up for a tagpreview.\n * Makes the preview window the current window.\n * Return TRUE when it was created.\n */\n    int\nprepare_tagpreview(\n    int\t\tundo_sync,\t    // sync undo when leaving the window\n    int\t\tuse_previewpopup,   // use popup if 'previewpopup' set\n    use_popup_T\tuse_popup)\t    // use other popup window\n{\n    win_T\t*wp;\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n\n    if (curwin->w_p_pvw)\n\treturn FALSE;\n\n    /*\n     * If there is already a preview window open, use that one.\n     */\n# ifdef FEAT_PROP_POPUP\n    if (use_previewpopup && *p_pvp != NUL)\n    {\n\twp = popup_find_preview_window();\n\tif (wp != NULL)\n\t    popup_set_wantpos_cursor(wp, wp->w_minwidth, NULL);\n    }\n    else if (use_popup != USEPOPUP_NONE)\n    {\n\twp = popup_find_info_window();\n\tif (wp != NULL)\n\t{\n\t    if (use_popup == USEPOPUP_NORMAL)\n\t\tpopup_show(wp);\n\t    else\n\t\tpopup_hide(wp);\n\t    // When the popup moves or resizes it may reveal part of\n\t    // another window.  TODO: can this be done more efficiently?\n\t    redraw_all_later(UPD_NOT_VALID);\n\t}\n    }\n    else\n# endif\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_p_pvw)\n\t\tbreak;\n    }\n    if (wp != NULL)\n    {\n\twin_enter(wp, undo_sync);\n\treturn FALSE;\n    }\n\n    /*\n     * There is no preview window open yet.  Create one.\n     */\n# ifdef FEAT_PROP_POPUP\n    if ((use_previewpopup && *p_pvp != NUL)\n\t    || use_popup != USEPOPUP_NONE)\n\treturn popup_create_preview_window(use_popup != USEPOPUP_NONE);\n# endif\n    if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0) == FAIL)\n\treturn FALSE;\n    curwin->w_p_pvw = TRUE;\n    curwin->w_p_wfh = TRUE;\n    RESET_BINDING(curwin);\t    // don't take over 'scrollbind'\n\t\t\t\t    // and 'cursorbind'\n# ifdef FEAT_DIFF\n    curwin->w_p_diff = FALSE;\t    // no 'diff'\n# endif\n# ifdef FEAT_FOLDING\n    curwin->w_p_fdc = 0;\t    // no 'foldcolumn'\n# endif\n    return TRUE;\n}\n\n#endif\n\n/*\n * Make the user happy.\n */\n    void\nex_smile(exarg_T *eap UNUSED)\n{\n    static char *code[] = {\n\t\"\\34 \\4o\\14$\\4ox\\30 \\2o\\30$\\1ox\\25 \\2o\\36$\\1o\\11 \\1o\\1$\\3 \\2$\\1 \\1o\\1$x\\5 \\1o\\1 \\1$\\1 \\2o\\10 \\1o\\44$\\1o\\7 \\2$\\1 \\2$\\1 \\2$\\1o\\1$x\\2 \\2o\\1 \\1$\\1 \\1$\\1 \\1\\\"\\1$\\6 \\1o\\11$\\4 \\15$\\4 \\11$\\1o\\7 \\3$\\1o\\2$\\1o\\1$x\\2 \\1\\\"\\6$\\1o\\1$\\5 \\1o\\11$\\6 \\13$\\6 \\12$\\1o\\4 \\10$x\\4 \\7$\\4 \\13$\\6 \\13$\\6 \\27$x\\4 \\27$\\4 \\15$\\4 \\16$\\2 \\3\\\"\\3$x\\5 \\1\\\"\\3$\\4\\\"\\61$\\5 \\1\\\"\\3$x\\6 \\3$\\3 \\1o\\62$\\5 \\1\\\"\\3$\\1ox\\5 \\1o\\2$\\1\\\"\\3 \\63$\\7 \\3$\\1ox\\5 \\3$\\4 \\55$\\1\\\"\\1 \\1\\\"\\6$\",\n\t\"\\5o\\4$\\1ox\\4 \\1o\\3$\\4o\\5$\\2 \\45$\\3 \\1o\\21$x\\4 \\10$\\1\\\"\\4$\\3 \\42$\\5 \\4$\\10\\\"x\\3 \\4\\\"\\7 \\4$\\4 \\1\\\"\\34$\\1\\\"\\6 \\1o\\3$x\\16 \\1\\\"\\3$\\1o\\5 \\3\\\"\\22$\\1\\\"\\2$\\1\\\"\\11 \\3$x\\20 \\3$\\1o\\12 \\1\\\"\\2$\\2\\\"\\6$\\4\\\"\\13 \\1o\\3$x\\21 \\4$\\1o\\40 \\1o\\3$\\1\\\"x\\22 \\1\\\"\\4$\\1o\\6 \\1o\\6$\\1o\\1\\\"\\4$\\1o\\10 \\1o\\4$x\\24 \\1\\\"\\5$\\2o\\5 \\2\\\"\\4$\\1o\\5$\\1o\\3 \\1o\\4$\\2\\\"x\\27 \\2\\\"\\5$\\4o\\2 \\1\\\"\\3$\\1o\\11$\\3\\\"x\\32 \\2\\\"\\7$\\2o\\1 \\12$x\\42 \\4\\\"\\13$x\\46 \\14$x\\47 \\12$\\1\\\"x\\50 \\1\\\"\\3$\\4\\\"x\"\n    };\n    char *p;\n    int n;\n    int i;\n\n    msg_start();\n    msg_putchar('\\n');\n    for (i = 0; i < 2; ++i)\n\tfor (p = code[i]; *p != NUL; ++p)\n\t    if (*p == 'x')\n\t\tmsg_putchar('\\n');\n\t    else\n\t\tfor (n = *p++; n > 0; --n)\n\t\t    if (*p == 'o' || *p == '$')\n\t\t\tmsg_putchar_attr(*p, HL_ATTR(HLF_L));\n\t\t    else\n\t\t\tmsg_putchar(*p);\n    msg_clr_eos();\n}\n\n/*\n * \":drop\"\n * Opens the first argument in a window.  When there are two or more arguments\n * the argument list is redefined.\n */\n    void\nex_drop(exarg_T *eap)\n{\n    int\t\tsplit = FALSE;\n    win_T\t*wp;\n    buf_T\t*buf;\n    tabpage_T\t*tp;\n\n    if (ERROR_IF_POPUP_WINDOW || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n\n    /*\n     * Check if the first argument is already being edited in a window.  If\n     * so, jump to that window.\n     * We would actually need to check all arguments, but that's complicated\n     * and mostly only one file is dropped.\n     * This also ignores wildcards, since it is very unlikely the user is\n     * editing a file name with a wildcard character.\n     */\n    set_arglist(eap->arg);\n\n    /*\n     * Expanding wildcards may result in an empty argument list.  E.g. when\n     * editing \"foo.pyc\" and \".pyc\" is in 'wildignore'.  Assume that we\n     * already did an error message for this.\n     */\n    if (ARGCOUNT == 0)\n\treturn;\n\n    if (cmdmod.cmod_tab)\n    {\n\t// \":tab drop file ...\": open a tab for each argument that isn't\n\t// edited in a window yet.  It's like \":tab all\" but without closing\n\t// windows or tabs.\n\tex_all(eap);\n\treturn;\n    }\n\n    // \":drop file ...\": Edit the first argument.  Jump to an existing\n    // window if possible, edit in current window if the current buffer\n    // can be abandoned, otherwise open a new window.\n    buf = buflist_findnr(ARGLIST[0].ae_fnum);\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == buf)\n\t{\n\t    goto_tabpage_win(tp, wp);\n\t    curwin->w_arg_idx = 0;\n\t    if (!bufIsChanged(curbuf))\n\t    {\n\t\tint save_ar = curbuf->b_p_ar;\n\n\t\t// reload the file if it is newer\n\t\tcurbuf->b_p_ar = TRUE;\n\t\tbuf_check_timestamp(curbuf, FALSE);\n\t\tcurbuf->b_p_ar = save_ar;\n\t    }\n\t    return;\n\t}\n    }\n\n    /*\n     * Check whether the current buffer is changed. If so, we will need\n     * to split the current window or data could be lost.\n     * Skip the check if the 'hidden' option is set, as in this case the\n     * buffer won't be lost.\n     */\n    if (!buf_hide(curbuf))\n    {\n\t++emsg_off;\n\tsplit = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);\n\t--emsg_off;\n    }\n\n    // Fake a \":sfirst\" or \":first\" command edit the first argument.\n    if (split)\n    {\n\teap->cmdidx = CMD_sfirst;\n\teap->cmd[0] = 's';\n    }\n    else\n\teap->cmdidx = CMD_first;\n    ex_rewind(eap);\n}\n\n/*\n * Skip over the pattern argument of \":vimgrep /pat/[g][j]\".\n * Put the start of the pattern in \"*s\", unless \"s\" is NULL.\n * If \"flags\" is not NULL put the flags in it: VGR_GLOBAL, VGR_NOJUMP.\n * If \"s\" is not NULL terminate the pattern with a NUL.\n * Return a pointer to the char just past the pattern plus flags.\n */\n    char_u *\nskip_vimgrep_pat(char_u *p, char_u **s, int *flags)\n{\n    return skip_vimgrep_pat_ext(p, s, flags, NULL, NULL);\n}\n\n/*\n * As skip_vimgrep_pat() and store the character overwritten by NUL in \"cp\"\n * and the pointer to it in \"nulp\".\n */\n    char_u *\nskip_vimgrep_pat_ext(char_u *p, char_u **s, int *flags, char_u **nulp, int *cp)\n{\n    int\t\tc;\n\n    if (vim_isIDc(*p))\n    {\n\t// \":vimgrep pattern fname\"\n\tif (s != NULL)\n\t    *s = p;\n\tp = skiptowhite(p);\n\tif (s != NULL && *p != NUL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p++ = NUL;\n\t}\n    }\n    else\n    {\n\t// \":vimgrep /pattern/[g][j] fname\"\n\tif (s != NULL)\n\t    *s = p + 1;\n\tc = *p;\n\tp = skip_regexp(p + 1, c, TRUE);\n\tif (*p != c)\n\t    return NULL;\n\n\t// Truncate the pattern.\n\tif (s != NULL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p = NUL;\n\t}\n\t++p;\n\n\t// Find the flags\n\twhile (*p == 'g' || *p == 'j' || *p == 'f')\n\t{\n\t    if (flags != NULL)\n\t    {\n\t\tif (*p == 'g')\n\t\t    *flags |= VGR_GLOBAL;\n\t\telse if (*p == 'j')\n\t\t    *flags |= VGR_NOJUMP;\n\t\telse\n\t\t    *flags |= VGR_FUZZY;\n\t    }\n\t    ++p;\n\t}\n    }\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * List v:oldfiles in a nice way.\n */\n    void\nex_oldfiles(exarg_T *eap UNUSED)\n{\n    list_T\t*l = get_vim_var_list(VV_OLDFILES);\n    listitem_T\t*li;\n    int\t\tnr = 0;\n    char_u\t*fname;\n\n    if (l == NULL)\n    {\n\tmsg(_(\"No old files\"));\n\treturn;\n    }\n\n    msg_start();\n    msg_scroll = TRUE;\n    for (li = l->lv_first; li != NULL && !got_int; li = li->li_next)\n    {\n\t++nr;\n\tfname = tv_get_string(&li->li_tv);\n\tif (!message_filtered(fname))\n\t{\n\t    msg_outnum((long)nr);\n\t    msg_puts(\": \");\n\t    msg_outtrans(fname);\n\t    msg_clr_eos();\n\t    msg_putchar('\\n');\n\t    out_flush();\t    // output one line at a time\n\t    ui_breakcheck();\n\t}\n    }\n\n    // Assume \"got_int\" was set to truncate the listing.\n    got_int = FALSE;\n\n# ifdef FEAT_BROWSE_CMD\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tquit_more = FALSE;\n\tnr = prompt_for_number(FALSE);\n\tmsg_starthere();\n\tif (nr > 0)\n\t{\n\t    char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t    (long)nr);\n\n\t    if (p != NULL)\n\t    {\n\t\tp = expand_env_save(p);\n\t\teap->arg = p;\n\t\teap->cmdidx = CMD_edit;\n\t\tcmdmod.cmod_flags &= ~CMOD_BROWSE;\n\t\tdo_exedit(eap, NULL);\n\t\tvim_free(p);\n\t    }\n\t}\n    }\n# endif\n}\n#endif\n", "\" Tests for the substitute (:s) command\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_multiline_subst()\n  enew!\n  call append(0, [\"1 aa\",\n\t      \\ \"bb\",\n\t      \\ \"cc\",\n\t      \\ \"2 dd\",\n\t      \\ \"ee\",\n\t      \\ \"3 ef\",\n\t      \\ \"gh\",\n\t      \\ \"4 ij\",\n\t      \\ \"5 a8\",\n\t      \\ \"8b c9\",\n\t      \\ \"9d\",\n\t      \\ \"6 e7\",\n\t      \\ \"77f\",\n\t      \\ \"xxxxx\"])\n\n  1\n  \" test if replacing a line break works with a back reference\n  /^1/,/^2/s/\\n\\(.\\)/ \\1/\n  \" test if inserting a line break works with a back reference\n  /^3/,/^4/s/\\(.\\)$/\\r\\1/\n  \" test if replacing a line break with another line break works\n  /^5/,/^6/s/\\(\\_d\\{3}\\)/x\\1x/\n  call assert_equal('1 aa bb cc 2 dd ee', getline(1))\n  call assert_equal('3 e', getline(2))\n  call assert_equal('f', getline(3))\n  call assert_equal('g', getline(4))\n  call assert_equal('h', getline(5))\n  call assert_equal('4 i', getline(6))\n  call assert_equal('j', getline(7))\n  call assert_equal('5 ax8', getline(8))\n  call assert_equal('8xb cx9', getline(9))\n  call assert_equal('9xd', getline(10))\n  call assert_equal('6 ex7', getline(11))\n  call assert_equal('7x7f', getline(12))\n  call assert_equal('xxxxx', getline(13))\n  enew!\nendfunc\n\nfunc Test_substitute_variants()\n  \" Validate that all the 2-/3-letter variants which embed the flags into the\n  \" command name actually work.\n  enew!\n  let ln = 'Testing string'\n  let variants = [\n\t\\ { 'cmd': ':s/Test/test/c', 'exp': 'testing string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ce', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cg', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/t/r/ci', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cI', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/c', 'exp': 'Testing string', 'prompt': 'n' },\n\t\\ { 'cmd': ':s/t/r/cn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cp', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cl', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/gc', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'TestIng string', 'prompt': 'l' },\n\t\\ { 'cmd': ':s/foo/bar/ge', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/g', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gi', 'exp': 'resring srring' },\n\t\\ { 'cmd': ':s/t/r/gI', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/gp', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gl', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s//r/gr', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s/t/r/ic', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/i', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/iI', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/in', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/ip', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s//r/ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/t/r/Ic', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/Ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/Ig', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/Ii', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/I', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Ip', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Il', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s//r/Ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rc', 'exp': 'Testr string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s//r/rg', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s//r/ri', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rI', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rn', 'exp': 'Testing string' },\n\t\\ { 'cmd': ':s//r/rp', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rl', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/r', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'Testing string', 'prompt': 'q' },\n\t\\]\n\n  for var in variants\n    for run in [1, 2]\n      let cmd = var.cmd\n      if run == 2 && cmd =~ \"/.*/.*/.\"\n\t\" Change  :s/from/to/{flags}  to  :s{flags}\n\tlet cmd = substitute(cmd, '/.*/', '', '')\n      endif\n      call setline(1, [ln])\n      let msg = printf('using \"%s\"', cmd)\n      let @/='ing'\n      let v:errmsg = ''\n      call feedkeys(cmd . \"\\<CR>\" . get(var, 'prompt', ''), 'ntx')\n      \" No error should exist (matters for testing e flag)\n      call assert_equal('', v:errmsg, msg)\n      call assert_equal(var.exp, getline('.'), msg)\n    endfor\n  endfor\nendfunc\n\n\" Test the l, p, # flags.\nfunc Test_substitute_flags_lp()\n  new\n  call setline(1, \"abc\\tdef\\<C-h>ghi\")\n\n  let a = execute('s/a/a/p')\n  call assert_equal(\"\\nabc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l')\n  call assert_equal(\"\\nabc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/p#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l#')\n  call assert_equal(\"\\n  1 abc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/')\n  call assert_equal(\"\", a)\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_repeat()\n  \" This caused an invalid memory access.\n  split Xsubfile\n  s/^/x\n  call feedkeys(\"Qsc\\<CR>y\", 'tx')\n  bwipe!\nendfunc\n\n\" Test %s/\\n// which is implemented as a special case to use a\n\" more efficient join rather than doing a regular substitution.\nfunc Test_substitute_join()\n  new\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//g')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//p')\n  call assert_equal(\"\\nfoo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//l')\n  call assert_equal(\"\\nfoo^Ibarbar^Hfoo$\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//#')\n  call assert_equal(\"\\n  1 foo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  call execute('1,2s/\\n//')\n  call assert_equal(['foobarbaz', 'qux'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_count()\n  new\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2\n\n  s/foo/bar/3\n  call assert_equal(['foo foo', 'bar foo', 'bar foo', 'bar foo', 'foo foo'],\n  \\                 getline(1, '$'))\n\n  call assert_fails('s/foo/bar/0', 'E939:')\n\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2,4s/foo/bar/ 10\n  call assert_equal(['foo foo', 'foo foo', 'foo foo', 'bar foo', 'bar foo'],\n        \\           getline(1, '$'))\n\n  call assert_fails('s/./b/2147483647', 'E1510:')\n  bwipe!\nendfunc\n\n\" Test substitute 'n' flag (report number of matches, do not substitute).\nfunc Test_substitute_flag_n()\n  new\n  let lines = ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo']\n  call setline(1, lines)\n\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/n'))\n  call assert_equal(\"\\n6 matches on 3 lines\", execute('2,4s/foo/bar/gn'))\n\n  \" c flag (confirm) should be ignored when using n flag.\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/nc'))\n\n  \" No substitution should have been done.\n  call assert_equal(lines, getline(1, '$'))\n\n  %delete _\n  call setline(1, ['A', 'Bar', 'Baz'])\n  call assert_equal(\"\\n1 match on 1 line\", execute('s/\\nB\\@=//gn'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_errors()\n  new\n  call setline(1, 'foobar')\n\n  call assert_fails('s/FOO/bar/', 'E486:')\n  call assert_fails('s/foo/bar/@', 'E488:')\n  call assert_fails('s/\\(/bar/', 'E54:')\n  call assert_fails('s afooabara', 'E146:')\n  call assert_fails('s\\\\a', 'E10:')\n\n  setl nomodifiable\n  call assert_fails('s/foo/bar/', 'E21:')\n\n  call assert_fails(\"let s=substitute([], 'a', 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', [], 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', [], 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', 'A', [])\", 'E730:')\n  call assert_fails(\"let s=substitute('abc', '\\\\%(', 'A', 'g')\", 'E53:')\n\n  bwipe!\nendfunc\n\n\" Test for *sub-replace-special* and *sub-replace-expression* on substitute().\nfunc Test_sub_replace_1()\n  \" Run the tests with 'magic' on\n  set magic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal(\"w\\\\w\", substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal(\"x\\<C-M>x\", substitute('xXx', 'X', \"\\r\", ''))\n  call assert_equal(\"YyyY\", substitute('Y', 'Y', '\\L\\uyYy\\l\\EY', ''))\n  call assert_equal(\"zZZz\", substitute('Z', 'Z', '\\U\\lZzZ\\u\\Ez', ''))\n  \" \\v or \\V after $\n  call assert_equal('abxx', substitute('abcd', 'xy$\\v|cd$', 'xx', ''))\n  call assert_equal('abxx', substitute('abcd', 'xy$\\V\\|cd\\$', 'xx', ''))\nendfunc\n\nfunc Test_sub_replace_2()\n  \" Run the tests with 'magic' off\n  set nomagic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"t\\<C-M>t\", substitute('tTt', 'T', \"\\r\", ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal('w\\w', substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal('XxxX', substitute('X', 'X', '\\L\\uxXx\\l\\EX', ''))\n  call assert_equal('yYYy', substitute('Y', 'Y', '\\U\\lYyY\\u\\Ey', ''))\nendfunc\n\nfunc Test_sub_replace_3()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A', '\\=\"\\\\\"', ''))\n  call assert_equal('b\\\\b', substitute('bBb', 'B', '\\=\"\\\\\\\\\"', ''))\n  call assert_equal(\"c\\rc\", substitute('cCc', 'C', \"\\\\=\\\"\\r\\\"\", ''))\n  call assert_equal(\"d\\\\\\rd\", substitute('dDd', 'D', \"\\\\=\\\"\\\\\\\\\\r\\\"\", ''))\n  call assert_equal(\"e\\\\\\\\\\re\", substitute('eEe', 'E', \"\\\\=\\\"\\\\\\\\\\\\\\\\\\r\\\"\", ''))\n  call assert_equal('f\\rf', substitute('fFf', 'F', '\\=\"\\\\r\"', ''))\n  call assert_equal('j\\nj', substitute('jJj', 'J', '\\=\"\\\\n\"', ''))\n  call assert_equal(\"k\\<C-M>k\", substitute('kKk', 'K', '\\=\"\\r\"', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=\"\\n\"', ''))\nendfunc\n\n\" Test for submatch() on substitute().\nfunc Test_sub_replace_4()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\", \"\")', ''))\n  call assert_equal('b\\b', substitute('bBb', 'B',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\\\\\", \"\")', ''))\n  call assert_equal(\"c\\<C-V>\\<C-M>c\", substitute('cCc', 'C', '\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"d\\<C-V>\\<C-M>d\", substitute('dDd', 'D', '\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"e\\\\\\<C-V>\\<C-M>e\", substitute('eEe', 'E', '\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"f\\<C-M>f\", substitute('fFf', 'F', '\\=substitute(submatch(0), \".\", \"\\\\r\", \"\")', ''))\n  call assert_equal(\"j\\nj\", substitute('jJj', 'J', '\\=substitute(submatch(0), \".\", \"\\\\n\", \"\")', ''))\n  call assert_equal(\"k\\rk\", substitute('kKk', 'K', '\\=substitute(submatch(0), \".\", \"\\r\", \"\")', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=substitute(submatch(0), \".\", \"\\n\", \"\")', ''))\nendfunc\n\nfunc Test_sub_replace_5()\n  set magic&\n  set cpo&\n  call assert_equal('A123456789987654321', substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=submatch(0) . submatch(9) . submatch(8) . ' .\n\t\t\\ 'submatch(7) . submatch(6) . submatch(5) . ' .\n\t\t\\ 'submatch(4) . submatch(3) . submatch(2) . submatch(1)',\n\t\t\\ ''))\n   call assert_equal(\"[['A123456789'], ['9'], ['8'], ['7'], ['6'], \" .\n\t\t\\ \"['5'], ['4'], ['3'], ['2'], ['1']]\",\n\t\t\\ substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=string([submatch(0, 1), submatch(9, 1), ' .\n\t\t\\ 'submatch(8, 1), 7->submatch(1), submatch(6, 1), ' .\n\t\t\\ 'submatch(5, 1), submatch(4, 1), submatch(3, 1), ' .\n\t\t\\ 'submatch(2, 1), submatch(1, 1)])',\n\t\t\\ ''))\nendfunc\n\nfunc Test_sub_replace_6()\n  set magic&\n  set cpo+=/\n  call assert_equal('a', substitute('A', 'A', 'a', ''))\n  call assert_equal('%', substitute('B', 'B', '%', ''))\n  set cpo-=/\n  call assert_equal('c', substitute('C', 'C', 'c', ''))\n  call assert_equal('%', substitute('D', 'D', '%', ''))\nendfunc\n\nfunc Test_sub_replace_7()\n  set magic&\n  set cpo&\n  call assert_equal('A\u0016A', substitute('A\u0016A', 'A.', '\\=submatch(0)', ''))\n  call assert_equal(\"B\\nB\", substitute(\"B\\nB\", 'B.', '\\=submatch(0)', ''))\n  call assert_equal(\"['B\\n']B\", substitute(\"B\\nB\", 'B.', '\\=string(submatch(0, 1))', ''))\n  call assert_equal('-abab', substitute('-bb', '\\zeb', 'a', 'g'))\n  call assert_equal('c-cbcbc', substitute('-bb', '\\ze', 'c', 'g'))\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_replace_8()\n  new\n  set magic&\n  set cpo&\n  $put =',,X'\n  s/\\(^\\|,\\)\\ze\\(,\\|X\\)/\\1N/g\n  call assert_equal('N,,NX', getline(\"$\"))\n  $put =',,Y'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Y\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>a\", \"xt\")\n  call assert_equal('N,,NY', getline(\"$\"))\n  :$put =',,Z'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Z\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>yy\", \"xt\")\n  call assert_equal('N,,NZ', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_9()\n  new\n  set magic&\n  set cpo&\n  $put ='xxx'\n  call feedkeys(\":s/x/X/gc\\<CR>yyq\", \"xt\")\n  call assert_equal('XXx', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_10()\n   set magic&\n   set cpo&\n   call assert_equal('a1a2a3a', substitute('123', '\\zs', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '\\zs.', 'a', 'g'))\n   call assert_equal('1a2a3a', substitute('123', '.\\zs', 'a', 'g'))\n   call assert_equal('a1a2a3a', substitute('123', '\\ze', 'a', 'g'))\n   call assert_equal('a1a2a3', substitute('123', '\\ze.', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '.\\ze', 'a', 'g'))\n   call assert_equal('aa2a3a', substitute('123', '1\\|\\ze', 'a', 'g'))\n   call assert_equal('1aaa', substitute('123', '1\\zs\\|[23]', 'a', 'g'))\nendfunc\n\nfunc SubReplacer(text, submatches)\n  return a:text .. a:submatches[0] .. a:text\nendfunc\nfunc SubReplacerVar(text, ...)\n  return a:text .. a:1[0] .. a:text\nendfunc\ndef SubReplacerVar9(text: string, ...args: list<list<string>>): string\n  return text .. args[0][0] .. text\nenddef\nfunc SubReplacer20(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, submatches)\n  return a:t3 .. a:submatches[0] .. a:t11\nendfunc\n\nfunc Test_substitute_partial()\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacer', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar9', ['foo']), 'g'))\n\n  \" 19 arguments plus one is just OK\n  let Replacer = function('SubReplacer20', repeat(['foo'], 19))\n  call assert_equal('1foo2foo3', substitute('123', '2', Replacer, 'g'))\n\n  \" 20 arguments plus one is too many\n  let Replacer = function('SubReplacer20', repeat(['foo'], 20))\n  call assert_fails(\"call substitute('123', '2', Replacer, 'g')\", 'E118:')\nendfunc\n\nfunc Test_substitute_float()\n  call assert_equal('number 1.23', substitute('number ', '$', { -> 1.23 }, ''))\n  vim9 assert_equal('number 1.23', substitute('number ', '$', () => 1.23, ''))\nendfunc\n\n\" Tests for *sub-replace-special* and *sub-replace-expression* on :substitute.\n\n\" Execute a list of :substitute command tests\nfunc Run_SubCmd_Tests(tests)\n  enew!\n  for t in a:tests\n    let start = line('.') + 1\n    let end = start + len(t[2]) - 1\n    exe \"normal o\" . t[0]\n    call cursor(start, 1)\n    exe t[1]\n    call assert_equal(t[2], getline(start, end), t[1])\n  endfor\n  enew!\nendfunc\n\nfunc Test_sub_cmd_1()\n  set magic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['AA']],\n\t      \\ ['B', 's/B/\\&/', ['&']],\n\t      \\ ['C123456789', 's/C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['d']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_2()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['&&']],\n\t      \\ ['B', 's/B/\\&/', ['B']],\n\t      \\ ['C123456789', 's/\\mC\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['~']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_3()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['aAa', \"s/A/\\\\='\\\\'/\", ['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\='\\\\\\\\'/\", ['b\\\\b']],\n\t      \\ ['cCc', \"s/C/\\\\='\\<C-V>\\<C-M>'/\", [\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\='\\\\\\<C-V>\\<C-M>'/\", [\"d\\\\\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\='\\\\\\\\\\<C-V>\\<C-M>'/\", [\"e\\\\\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\='\\r'/\", ['f', 'f']],\n\t      \\ ['gGg', \"s/G/\\\\='\\<C-V>\\<C-J>'/\", [\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', \"s/H/\\\\='\\\\\\<C-V>\\<C-J>'/\", [\"h\\\\\\<C-V>\", 'h']],\n\t      \\ ['iIi', \"s/I/\\\\='\\\\\\\\\\<C-V>\\<C-J>'/\", [\"i\\\\\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\='\\n'/\", ['j', 'j']],\n\t      \\ ['kKk', 's/K/\\=\"\\r\"/', ['k', 'k']],\n\t      \\ ['lLl', 's/L/\\=\"\\n\"/', ['l', 'l']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for submatch() on :substitute.\nfunc Test_sub_cmd_4()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['aAa', \"s/A/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['b\\b']],\n\t      \\ ['cCc', \"s/C/\\\\=substitute(submatch(0), '.', '\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\=substitute(submatch(0), '.', '\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"d\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\=substitute(submatch(0), '.', '\\\\\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"e\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['f', 'f']],\n\t      \\ ['gGg', 's/G/\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', 's/H/\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"h\\<C-V>\", 'h']],\n\t      \\ ['iIi', 's/I/\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"i\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['j', 'j']],\n\t      \\ ['kKk', \"s/K/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['k', 'k']],\n\t      \\ ['lLl', \"s/L/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['l', 'l']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_5()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A123456789', 's/A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)/', ['A123456789987654321']],\n\t      \\ ['B123456789', 's/B\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])/', [\"[['B123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]\"]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_cmd_6()\n  set magic&\n  set cpo+=/\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A', 's/A/a/', ['a']],\n\t      \\ ['B', 's/B/%/', ['a']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo-=/\n  let tests = [ ['C', 's/C/c/', ['c']],\n\t      \\ ['D', 's/D/%/', ['%']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo&\nendfunc\n\n\" Test for :s replacing \\n with  line break.\nfunc Test_sub_cmd_7()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ [\"A\\<C-V>\\<C-M>A\", 's/A./\\=submatch(0)/', ['A', 'A']],\n\t      \\ [\"B\\<C-V>\\<C-J>B\", 's/B./\\=submatch(0)/', ['B', 'B']],\n\t      \\ [\"C\\<C-V>\\<C-J>C\", 's/C./\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['C\\<C-J>']C\")]],\n\t      \\ [\"D\\<C-V>\\<C-J>\\nD\", 's/D.\\nD/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['D\\<C-J>', 'D']\")]],\n\t      \\ [\"E\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>E\", 's/E\\_.\\{-}E/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['E\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>E']\")]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  exe \"normal oQ\\nQ\\<Esc>k\"\n  call assert_fails('s/Q[^\\n]Q/\\=submatch(0).\"foobar\"/', 'E486:')\n  enew!\nendfunc\n\nfunc TitleString()\n  let check = 'foo' =~ 'bar'\n  return \"\"\nendfunc\n\nfunc Test_sub_cmd_8()\n  set titlestring=%{TitleString()}\n\n  enew!\n  call append(0, ['', 'test_one', 'test_two'])\n  call cursor(1,1)\n  /^test_one/s/.*/\\=\"foo\\nbar\"/\n  call assert_equal('foo', getline(2))\n  call assert_equal('bar', getline(3))\n  call feedkeys(':/^test_two/s/.*/\\=\"foo\\nbar\"/c', \"t\")\n  call feedkeys(\"\\<CR>y\", \"xt\")\n  call assert_equal('foo', getline(4))\n  call assert_equal('bar', getline(5))\n\n  enew!\n  set titlestring&\nendfunc\n\nfunc Test_sub_cmd_9()\n  new\n  let input = ['1 aaa', '2 aaa', '3 aaa']\n  call setline(1, input)\n  func Foo()\n    return submatch(0)\n  endfunc\n  %s/aaa/\\=Foo()/gn\n  call assert_equal(input, getline(1, '$'))\n  call assert_equal(1, &modifiable)\n\n  delfunc Foo\n  bw!\nendfunc\n\nfunc Test_sub_highlight_zero_match()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    call setline(1, ['one', 'two', 'three'])\n  END\n  call writefile(lines, 'XscriptSubHighlight', 'D')\n  let buf = RunVimInTerminal('-S XscriptSubHighlight', #{rows: 8, cols: 60})\n  call term_sendkeys(buf, \":%s/^/   /c\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_sub_highlight_zer_match_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_nocatch_sub_failure_handling()\n  \" normal error results in all replacements\n  func Foo()\n    foobar\n  endfunc\n  new\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  \" need silent! to avoid a delay when entering Insert mode\n  silent! %s/aaa/\\=Foo()/g\n  call assert_equal(['1 0', '2 0', '3 0'], getline(1, 3))\n\n  \" Throw without try-catch causes abort after the first line.\n  \" We cannot test this, since it would stop executing the test script.\n\n  \" try/catch does not result in any changes\n  func! Foo()\n    throw 'error'\n  endfunc\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/g\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  \" Same, but using \"n\" flag so that \"sandbox\" gets set\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/gn\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  delfunc Foo\n  bwipe!\nendfunc\n\n\" Test \":s/pat/sub/\" with different ~s in sub.\nfunc Test_replace_with_tilde()\n  new\n  \" Set the last replace string to empty\n  s/^$//\n  call append(0, ['- Bug in \"vPPPP\" on this text:'])\n  normal gg\n  s/u/~u~/\n  call assert_equal('- Bug in \"vPPPP\" on this text:', getline(1))\n  s/i/~u~/\n  call assert_equal('- Bug uuun \"vPPPP\" on this text:', getline(1))\n  s/o/~~~/\n  call assert_equal('- Bug uuun \"vPPPP\" uuuuuuuuun this text:', getline(1))\n  close!\nendfunc\n\nfunc Test_replace_keeppatterns()\n  new\n  a\nfoobar\n\nsubstitute foo asdf\n\none two\n.\n\n  normal gg\n  /^substitute\n  s/foo/bar/\n  call assert_equal('foo', @/)\n  call assert_equal('substitute bar asdf', getline('.'))\n\n  /^substitute\n  keeppatterns s/asdf/xyz/\n  call assert_equal('^substitute', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n\n  exe \"normal /bar /e\\<CR>\"\n  call assert_equal(15, col('.'))\n  normal -\n  keeppatterns /xyz\n  call assert_equal('bar ', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n  exe \"normal 0dn\"\n  call assert_equal('xyz', getline('.'))\n\n  close!\nendfunc\n\nfunc Test_sub_beyond_end()\n  new\n  call setline(1, '#')\n  let @/ = '^#\\n\\zs'\n  s///e\n  call assert_equal('#', getline(1))\n  bwipe!\nendfunc\n\n\" Test for repeating last substitution using :~ and :&r\nfunc Test_repeat_last_sub()\n  new\n  call setline(1, ['blue green yellow orange white'])\n  s/blue/red/\n  let @/ = 'yellow'\n  ~\n  let @/ = 'white'\n  :&r\n  let @/ = 'green'\n  s//gray\n  call assert_equal('red gray red orange red', getline(1))\n  close!\nendfunc\n\n\" Test for Vi compatible substitution:\n\"     \\/{string}/, \\?{string}? and \\&{string}&\nfunc Test_sub_vi_compatibility()\n  new\n  call setline(1, ['blue green yellow orange blue'])\n  let @/ = 'orange'\n  s\\/white/\n  let @/ = 'blue'\n  s\\?amber?\n  let @/ = 'white'\n  s\\&green&\n  call assert_equal('amber green yellow white green', getline(1))\n  close!\n\n  call assert_fails('vim9cmd s\\/white/', 'E1270:')\n  call assert_fails('vim9cmd s\\?white?', 'E1270:')\n  call assert_fails('vim9cmd s\\&white&', 'E1270:')\nendfunc\n\n\" Test for substitute with the new text longer than the original text\nfunc Test_sub_expand_text()\n  new\n  call setline(1, 'abcabcabcabcabcabcabcabc')\n  s/b/\\=repeat('B', 10)/g\n  call assert_equal(repeat('aBBBBBBBBBBc', 8), getline(1))\n  close!\nendfunc\n\n\" Test for command failures when the last substitute pattern is not set.\nfunc Test_sub_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('~', 'E33:')\n    call assert_fails('s//abc/g', 'E35:')\n    call assert_fails('s\\/bar', 'E35:')\n    call assert_fails('s\\&bar&', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  let lines =<< trim [SCRIPT]\n    set cpo+=/\n    call assert_fails('s/abc/%/', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\nfunc Test_substitute()\n  call assert_equal('a\uff11a\uff12a\uff13a', substitute('\uff11\uff12\uff13', '\\zs', 'a', 'g'))\n  \" Substitute with special keys\n  call assert_equal(\"a\\<End>c\", substitute('abc', \"a.c\", \"a\\<End>c\", ''))\nendfunc\n\nfunc Test_substitute_expr()\n  let g:val = 'XXX'\n  call assert_equal('XXX', substitute('yyy', 'y*', '\\=g:val', ''))\n  call assert_equal('XXX', substitute('yyy', 'y*', {-> g:val}, ''))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ '\\=nr2char(\"0x\" . submatch(1))', 'g'))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ {-> nr2char(\"0x\" . submatch(1))}, 'g'))\n\n  call assert_equal('231', substitute('123', '\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))\n\n  func Recurse()\n    return substitute('yyy', 'y\\(.\\)y', {-> submatch(1)}, '')\n  endfunc\n  \" recursive call works\n  call assert_equal('-y-x-', substitute('xxx', 'x\\(.\\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))\n\n  call assert_fails(\"let s=submatch([])\", 'E745:')\n  call assert_fails(\"let s=submatch(2, [])\", 'E745:')\nendfunc\n\nfunc Test_invalid_submatch()\n  \" This was causing invalid memory access in Vim-7.4.2232 and older\n  call assert_fails(\"call substitute('x', '.', {-> submatch(10)}, '')\", 'E935:')\n  call assert_fails('eval submatch(-1)', 'E935:')\n  call assert_equal('', submatch(0))\n  call assert_equal('', submatch(1))\n  call assert_equal([], submatch(0, 1))\n  call assert_equal([], submatch(1, 1))\nendfunc\n\nfunc Test_submatch_list_concatenate()\n  let pat = 'A\\(.\\)'\n  let Rep = {-> string([submatch(0, 1)] + [[submatch(1)]])}\n  call substitute('A1', pat, Rep, '')->assert_equal(\"[['A1'], ['1']]\")\nendfunc\n\nfunc Test_substitute_expr_arg()\n  call assert_equal('123456789-123456789=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456-123456=789', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(a*\\)\\(n*\\)\\(.\\)\\(.\\)\\(.\\)\\(x*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456789-123456789x=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . 'x' . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(add(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(insert(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(extend(m, ['x']))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(remove(m, 1))}, '')\", 'E742:')\nendfunc\n\n\" Test for using a function to supply the substitute string\nfunc Test_substitute_using_func()\n  func Xfunc()\n    return '1234'\n  endfunc\n  call assert_equal('a1234f', substitute('abcdef', 'b..e',\n        \\ function(\"Xfunc\"), ''))\n  delfunc Xfunc\nendfunc\n\n\" Test for using submatch() with a multiline match\nfunc Test_substitute_multiline_submatch()\n  new\n  call setline(1, ['line1', 'line2', 'line3', 'line4'])\n  %s/^line1\\(\\_.\\+\\)line4$/\\=submatch(1)/\n  call assert_equal(['', 'line2', 'line3', ''], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_substitute_skipped_range()\n  new\n  if 0\n    /1/5/2/2/\\n\n  endif\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  bwipe!\nendfunc\n\n\" Test using the 'gdefault' option (when on, flag 'g' is default on).\nfunc Test_substitute_gdefault()\n  new\n\n  \" First check without 'gdefault'\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar foo', getline(1))\n\n  \" Then check with 'gdefault'\n  set gdefault\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar FOO', getline(1))\n\n  \" Setting 'compatible' should reset 'gdefault'\n  call assert_equal(1, &gdefault)\n  set compatible\n  call assert_equal(0, &gdefault)\n  set nocompatible\n  call assert_equal(0, &gdefault)\n\n  bw!\nendfunc\n\n\" This was using \"old_sub\" after it was freed.\nfunc Test_using_old_sub()\n  set compatible maxfuncdepth=10\n  new\n  call setline(1, 'some text.')\n  func Repl()\n    ~\n    s/\n  endfunc\n  silent! s/\\%')/\\=Repl()\n\n  delfunc Repl\n  bwipe!\n  set nocompatible\nendfunc\n\n\" This was switching windows in between computing the length and using it.\nfunc Test_sub_change_window()\n  silent! lfile\n  sil! norm o0000000000000000000000000000000000000000000000000000\n  func Repl()\n    lopen\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n  bwipe!\n  bwipe!\n  delfunc Repl\nendfunc\n\n\" This was undoign a change in between computing the length and using it.\nfunc Do_Test_sub_undo_change()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  silent! s/\\%')/\\=Repl()\n  bwipe!\nendfunc\n\nfunc Test_sub_undo_change()\n  func Repl()\n    silent! norm g-\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  func! Repl()\n    silent earlier\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  delfunc Repl\nendfunc\n\n\" This was opening a command line window from the expression\nfunc Test_sub_open_cmdline_win()\n  \" the error only happens in a very specific setup, run a new Vim instance to\n  \" get a clean starting point.\n  let lines =<< trim [SCRIPT]\n    set vb t_vb=\n    norm o0000000000000000000000000000000000000000000000000000\n    func Replace()\n      norm q/\n    endfunc\n    s/\\%')/\\=Replace()\n    redir >Xresult\n    messages\n    redir END\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '-u NONE -S Xscript')\n    call assert_match('E565: Not allowed to change text or change window',\n          \\ readfile('Xresult')->join('XX'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\n\" This was editing a script file from the expression\nfunc Test_sub_edit_scriptfile()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  func EditScript()\n    silent! scr! Xsedfile\n  endfunc\n  s/\\%')/\\=EditScript()\n\n  delfunc EditScript\n  bwipe!\nendfunc\n\n\" This was editing another file from the expression.\nfunc Test_sub_expr_goto_other_file()\n  call writefile([''], 'Xfileone', 'D')\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd',\n\t\\ 'Xfileone zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'])\n\n  func g:SplitGotoFile()\n    exe \"sil! norm 0\\<C-W>gf\"\n    return ''\n  endfunc\n\n  $\n  s/\\%')/\\=g:SplitGotoFile()\n\n  delfunc g:SplitGotoFile\n  bwipe!\nendfunc\n\nfunc Test_recursive_expr_substitute()\n  \" this was reading invalid memory\n  let lines =<< trim END\n      func Repl(g, n)\n        s\n        r%:s000\n      endfunc\n      next 0\n      let caught = 0\n      s/\\%')/\\=Repl(0, 0)\n      qall!\n  END\n  call writefile(lines, 'XexprSubst', 'D')\n  call RunVim([], [], '--clean -S XexprSubst')\nendfunc\n\n\" Test for the 2-letter and 3-letter :substitute commands\nfunc Test_substitute_short_cmd()\n  new\n  call setline(1, ['one', 'one one one'])\n  s/one/two\n  call cursor(2, 1)\n\n  \" :sc\n  call feedkeys(\":sc\\<CR>y\", 'xt')\n  call assert_equal('two one one', getline(2))\n\n  \" :scg\n  call setline(2, 'one one one')\n  call feedkeys(\":scg\\<CR>nyq\", 'xt')\n  call assert_equal('one two one', getline(2))\n\n  \" :sci\n  call setline(2, 'ONE One onE')\n  call feedkeys(\":sci\\<CR>y\", 'xt')\n  call assert_equal('two One onE', getline(2))\n\n  \" :scI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  call feedkeys(\":scI\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :scn\n  call setline(2, 'one one one')\n  let t = execute('scn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :scp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scp\\<CR>y\", 'xt')\n  redir END\n  call assert_equal('        two one one', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :scl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scl\\<CR>y\", 'xt')\n  redir END\n  call assert_equal(\"^Itwo one one$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :sgc\n  call setline(2, 'one one one one one')\n  call feedkeys(\":sgc\\<CR>nyyq\", 'xt')\n  call assert_equal('one two two one one', getline(2))\n\n  \" :sg\n  call setline(2, 'one one one')\n  sg\n  call assert_equal('two two two', getline(2))\n\n  \" :sgi\n  call setline(2, 'ONE One onE')\n  sgi\n  call assert_equal('two two two', getline(2))\n\n  \" :sgI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  sgI\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :sgn\n  call setline(2, 'one one one')\n  let t = execute('sgn')->split(\"\\n\")\n  call assert_equal(['3 matches on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :sgp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgp\n  redir END\n  call assert_equal('        two two two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgl\n  redir END\n  call assert_equal(\"^Itwo two two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgr\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sgr\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sic\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sic\\<CR>y\", 'xt')\n  call assert_equal('two One one', getline(2))\n\n  \" :si\n  call setline(2, \"ONE One one\")\n  si\n  call assert_equal('two One one', getline(2))\n\n  \" :siI\n  call setline(2, \"ONE One one\")\n  siI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sin\n  call setline(2, 'ONE One onE')\n  let t = execute('sin')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One onE', getline(2))\n\n  \" :sip\n  call setline(2, \"\\tONE One onE\")\n  redir => output\n  sip\n  redir END\n  call assert_equal('        two One onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo One onE\", getline(2))\n\n  \" :sir\n  call setline(2, \"ONE One onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sir\n  call assert_equal('xyz One onE', getline(2))\n\n  \" :sIc\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sIc\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIg\n  call setline(2, \"ONE one onE one\")\n  sIg\n  call assert_equal('ONE two onE two', getline(2))\n\n  \" :sIi\n  call setline(2, \"ONE One one\")\n  sIi\n  call assert_equal('two One one', getline(2))\n\n  \" :sI\n  call setline(2, \"ONE One one\")\n  sI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIn\n  call setline(2, 'ONE One one')\n  let t = execute('sIn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One one', getline(2))\n\n  \" :sIp\n  call setline(2, \"\\tONE One one\")\n  redir => output\n  sIp\n  redir END\n  call assert_equal('        ONE One two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE One two\", getline(2))\n\n  \" :sIl\n  call setline(2, \"\\tONE onE one\")\n  redir => output\n  sIl\n  redir END\n  call assert_equal(\"^IONE onE two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE onE two\", getline(2))\n\n  \" :sIr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sIr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :src\n  call setline(2, \"ONE one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  call feedkeys(\":src\\<CR>y\", 'xt')\n  call assert_equal('ONE xyz one', getline(2))\n\n  \" :srg\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srg\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sri\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sri\n  call assert_equal('xyz one onE', getline(2))\n\n  \" :srI\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srI\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :srn\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  let t = execute('srn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE one onE', getline(2))\n\n  \" :srp\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srp\n  redir END\n  call assert_equal('        ONE xyz onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :srl\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srl\n  redir END\n  call assert_equal(\"^IONE xyz onE$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :sr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :sce\n  s/abc/xyz/e\n  call assert_fails(\"sc\", 'E486:')\n  sce\n  \" :sge\n  call assert_fails(\"sg\", 'E486:')\n  sge\n  \" :sie\n  call assert_fails(\"si\", 'E486:')\n  sie\n  \" :sIe\n  call assert_fails(\"sI\", 'E486:')\n  sIe\n\n  bw!\nendfunc\n\n\" Check handling expanding \"~\" resulting in extremely long text.\n\" FIXME: disabled, it takes too long to run on CI\n\"func Test_substitute_tilde_too_long()\n\"  enew!\n\"\n\"  s/.*/ixxx\n\"  s//~~~~~~~~~AAAAAAA@(\n\"\n\"  \" Either fails with \"out of memory\" or \"text too long\".\n\"  \" This can take a long time.\n\"  call assert_fails('sil! norm &&&&&&&&&', ['E1240:\\|E342:'])\n\"\n\"  bwipe!\n\"endfunc\n\n\" This should be done last to reveal a memory leak when vim_regsub_both() is\n\" called to evaluate an expression but it is not used in a second call.\nfunc Test_z_substitute_expr_leak()\n  func SubExpr()\n    ~n\n  endfunc\n  silent! s/\\%')/\\=SubExpr()\n  delfunc SubExpr\nendfunc\n\nfunc Test_substitute_expr_switch_win()\n  func R()\n    wincmd x\n    return 'XXXX'\n  endfunc\n  new Xfoobar\n  let bufnr = bufnr('%')\n  put =\"abcdef\"\n  silent! s/\\%')/\\=R()\n  call assert_fails(':%s/./\\=R()/g', 'E565:')\n  delfunc R\n  exe bufnr .. \"bw!\"\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_cmds.c: some functions for command line commands\n */\n\n#include \"vim.h\"\n#include \"version.h\"\n\n#include <float.h>\n\nstatic int linelen(int *has_tab);\nstatic void do_filter(linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out);\nstatic int not_writing(void);\nstatic int check_readonly(int *forceit, buf_T *buf);\nstatic void delbuf_msg(char_u *name);\n\n/*\n * \":ascii\" and \"ga\".\n */\n    void\ndo_ascii(exarg_T *eap UNUSED)\n{\n    int\t\tc;\n    int\t\tcval;\n    char\tbuf1[20];\n    char\tbuf2[20];\n    char_u\tbuf3[7];\n#ifdef FEAT_DIGRAPHS\n    char_u      *dig;\n#endif\n    int\t\tcc[MAX_MCO];\n    int\t\tci = 0;\n    int\t\tlen;\n\n    if (enc_utf8)\n\tc = utfc_ptr2char(ml_get_cursor(), cc);\n    else\n\tc = gchar_cursor();\n    if (c == NUL)\n    {\n\tmsg(\"NUL\");\n\treturn;\n    }\n\n    IObuff[0] = NUL;\n    if (!has_mbyte || (enc_dbcs != 0 && c < 0x100) || c < 0x80)\n    {\n\tif (c == NL)\t    // NUL is stored as NL\n\t    c = NUL;\n\tif (c == CAR && get_fileformat(curbuf) == EOL_MAC)\n\t    cval = NL;\t    // NL is stored as CR\n\telse\n\t    cval = c;\n\tif (vim_isprintc_strict(c) && (c < ' ' || c > '~'))\n\t{\n\t    transchar_nonprint(curbuf, buf3, c);\n\t    vim_snprintf(buf1, sizeof(buf1), \"  <%s>\", (char *)buf3);\n\t}\n\telse\n\t    buf1[0] = NUL;\n\tif (c >= 0x80)\n\t    vim_snprintf(buf2, sizeof(buf2), \"  <M-%s>\",\n\t\t\t\t\t\t (char *)transchar(c & 0x7f));\n\telse\n\t    buf2[0] = NUL;\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(cval);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Oct %03o, Digr %s\"),\n\t\t\t      transchar(c), buf1, buf2, cval, cval, cval, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Octal %03o\"),\n\t\t\t\t  transchar(c), buf1, buf2, cval, cval, cval);\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    // Repeat for combining characters.\n    while (has_mbyte && (c >= 0x100 || (enc_utf8 && c >= 0x80)))\n    {\n\tlen = (int)STRLEN(IObuff);\n\t// This assumes every multi-byte char is printable...\n\tif (len > 0)\n\t    IObuff[len++] = ' ';\n\tIObuff[len++] = '<';\n\tif (enc_utf8 && utf_iscomposing(c)\n#ifdef USE_GUI\n\t\t&& !gui.in_use\n#endif\n\t\t)\n\t    IObuff[len++] = ' '; // draw composing char on top of a space\n\tlen += (*mb_char2bytes)(c, IObuff + len);\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(c);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\tc < 0x10000 ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")\n\t\t\t\t    : _(\"> %d, Hex %08x, Oct %o, Digr %s\"),\n\t\t\t\t\tc, c, c, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\t c < 0x10000 ? _(\"> %d, Hex %04x, Octal %o\")\n\t\t\t\t     : _(\"> %d, Hex %08x, Octal %o\"),\n\t\t\t\t     c, c, c);\n\tif (ci == MAX_MCO)\n\t    break;\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    msg((char *)IObuff);\n}\n\n/*\n * \":left\", \":center\" and \":right\": align text.\n */\n    void\nex_align(exarg_T *eap)\n{\n    pos_T\tsave_curpos;\n    int\t\tlen;\n    int\t\tindent = 0;\n    int\t\tnew_indent;\n    int\t\thas_tab;\n    int\t\twidth;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl)\n    {\n\t// switch left and right aligning\n\tif (eap->cmdidx == CMD_right)\n\t    eap->cmdidx = CMD_left;\n\telse if (eap->cmdidx == CMD_left)\n\t    eap->cmdidx = CMD_right;\n    }\n#endif\n\n    width = atoi((char *)eap->arg);\n    save_curpos = curwin->w_cursor;\n    if (eap->cmdidx == CMD_left)    // width is used for new indent\n    {\n\tif (width >= 0)\n\t    indent = width;\n    }\n    else\n    {\n\t/*\n\t * if 'textwidth' set, use it\n\t * else if 'wrapmargin' set, use it\n\t * if invalid value, use 80\n\t */\n\tif (width <= 0)\n\t    width = curbuf->b_p_tw;\n\tif (width == 0 && curbuf->b_p_wm > 0)\n\t    width = curwin->w_width - curbuf->b_p_wm;\n\tif (width <= 0)\n\t    width = 80;\n    }\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n\n    for (curwin->w_cursor.lnum = eap->line1;\n\t\t curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum)\n    {\n\tif (eap->cmdidx == CMD_left)\t\t// left align\n\t    new_indent = indent;\n\telse\n\t{\n\t    has_tab = FALSE;\t// avoid uninit warnings\n\t    len = linelen(eap->cmdidx == CMD_right ? &has_tab\n\t\t\t\t\t\t   : NULL) - get_indent();\n\n\t    if (len <= 0)\t\t\t// skip blank lines\n\t\tcontinue;\n\n\t    if (eap->cmdidx == CMD_center)\n\t\tnew_indent = (width - len) / 2;\n\t    else\n\t    {\n\t\tnew_indent = width - len;\t// right align\n\n\t\t/*\n\t\t * Make sure that embedded TABs don't make the text go too far\n\t\t * to the right.\n\t\t */\n\t\tif (has_tab)\n\t\t    while (new_indent > 0)\n\t\t    {\n\t\t\t(void)set_indent(new_indent, 0);\n\t\t\tif (linelen(NULL) <= width)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Now try to move the line as much as possible to\n\t\t\t     * the right.  Stop when it moves too far.\n\t\t\t     */\n\t\t\t    do\n\t\t\t\t(void)set_indent(++new_indent, 0);\n\t\t\t    while (linelen(NULL) <= width);\n\t\t\t    --new_indent;\n\t\t\t    break;\n\t\t\t}\n\t\t\t--new_indent;\n\t\t    }\n\t    }\n\t}\n\tif (new_indent < 0)\n\t    new_indent = 0;\n\t(void)set_indent(new_indent, 0);\t\t// set indent\n    }\n    changed_lines(eap->line1, 0, eap->line2 + 1, 0L);\n    curwin->w_cursor = save_curpos;\n    beginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * Get the length of the current line, excluding trailing white space.\n */\n    static int\nlinelen(int *has_tab)\n{\n    char_u  *line;\n    char_u  *first;\n    char_u  *last;\n    int\t    save;\n    int\t    len;\n\n    // Get the line.  If it's empty bail out early (could be the empty string\n    // for an unloaded buffer).\n    line = ml_get_curline();\n    if (*line == NUL)\n\treturn 0;\n\n    // find the first non-blank character\n    first = skipwhite(line);\n\n    // find the character after the last non-blank character\n    for (last = first + STRLEN(first);\n\t\t\t\tlast > first && VIM_ISWHITE(last[-1]); --last)\n\t;\n    save = *last;\n    *last = NUL;\n    len = linetabsize_str(line);\t// get line length on screen\n    if (has_tab != NULL)\t\t// check for embedded TAB\n\t*has_tab = (vim_strchr(first, TAB) != NULL);\n    *last = save;\n\n    return len;\n}\n\n// Buffer for two lines used during sorting.  They are allocated to\n// contain the longest line being sorted.\nstatic char_u\t*sortbuf1;\nstatic char_u\t*sortbuf2;\n\nstatic int\tsort_lc;\t// sort using locale\nstatic int\tsort_ic;\t// ignore case\nstatic int\tsort_nr;\t// sort on number\nstatic int\tsort_rx;\t// sort on regex instead of skipping it\nstatic int\tsort_flt;\t// sort on floating number\n\nstatic int\tsort_abort;\t// flag to indicate if sorting has been interrupted\n\n// Struct to store info to be sorted.\ntypedef struct\n{\n    linenr_T\tlnum;\t\t\t// line number\n    union {\n\tstruct\n\t{\n\t    varnumber_T\tstart_col_nr;\t// starting column number\n\t    varnumber_T\tend_col_nr;\t// ending column number\n\t} line;\n\tstruct\n\t{\n\t    varnumber_T\tvalue;\t\t// value if sorting by integer\n\t    int is_number;\t\t// TRUE when line contains a number\n\t} num;\n\tfloat_T value_flt;\t\t// value if sorting by float\n    } st_u;\n} sorti_T;\n\n    static int\nstring_compare(const void *s1, const void *s2)\n{\n    if (sort_lc)\n\treturn strcoll((char *)s1, (char *)s2);\n    return sort_ic ? STRICMP(s1, s2) : STRCMP(s1, s2);\n}\n\n    static int\nsort_compare(const void *s1, const void *s2)\n{\n    sorti_T\tl1 = *(sorti_T *)s1;\n    sorti_T\tl2 = *(sorti_T *)s2;\n    int\t\tresult = 0;\n\n    // If the user interrupts, there's no way to stop qsort() immediately, but\n    // if we return 0 every time, qsort will assume it's done sorting and\n    // exit.\n    if (sort_abort)\n\treturn 0;\n    fast_breakcheck();\n    if (got_int)\n\tsort_abort = TRUE;\n\n    if (sort_nr)\n    {\n\tif (l1.st_u.num.is_number != l2.st_u.num.is_number)\n\t    result = l1.st_u.num.is_number - l2.st_u.num.is_number;\n\telse\n\t    result = l1.st_u.num.value == l2.st_u.num.value ? 0\n\t\t\t     : l1.st_u.num.value > l2.st_u.num.value ? 1 : -1;\n    }\n    else if (sort_flt)\n\tresult = l1.st_u.value_flt == l2.st_u.value_flt ? 0\n\t\t\t     : l1.st_u.value_flt > l2.st_u.value_flt ? 1 : -1;\n    else\n    {\n\t// We need to copy one line into \"sortbuf1\", because there is no\n\t// guarantee that the first pointer becomes invalid when obtaining the\n\t// second one.\n\tSTRNCPY(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,\n\t\t     l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1);\n\tsortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = 0;\n\tSTRNCPY(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,\n\t\t     l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1);\n\tsortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = 0;\n\n\tresult = string_compare(sortbuf1, sortbuf2);\n    }\n\n    // If two lines have the same value, preserve the original line order.\n    if (result == 0)\n\treturn (int)(l1.lnum - l2.lnum);\n    return result;\n}\n\n/*\n * \":sort\".\n */\n    void\nex_sort(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    int\t\tlen;\n    linenr_T\tlnum;\n    long\tmaxlen = 0;\n    sorti_T\t*nrs;\n    size_t\tcount = (size_t)(eap->line2 - eap->line1 + 1);\n    size_t\ti;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*s2;\n    char_u\tc;\t\t\t// temporary character storage\n    int\t\tunique = FALSE;\n    long\tdeleted;\n    colnr_T\tstart_col;\n    colnr_T\tend_col;\n    int\t\tsort_what = 0;\n    int\t\tformat_found = 0;\n    int\t\tchange_occurred = FALSE; // Buffer contents changed.\n\n    // Sorting one line is really quick!\n    if (count <= 1)\n\treturn;\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n    sortbuf1 = NULL;\n    sortbuf2 = NULL;\n    regmatch.regprog = NULL;\n    nrs = ALLOC_MULT(sorti_T, count);\n    if (nrs == NULL)\n\tgoto sortend;\n\n    sort_abort = sort_ic = sort_lc = sort_rx = sort_nr = 0;\n    sort_flt = 0;\n\n    for (p = eap->arg; *p != NUL; ++p)\n    {\n\tif (VIM_ISWHITE(*p))\n\t    ;\n\telse if (*p == 'i')\n\t    sort_ic = TRUE;\n\telse if (*p == 'l')\n\t    sort_lc = TRUE;\n\telse if (*p == 'r')\n\t    sort_rx = TRUE;\n\telse if (*p == 'n')\n\t{\n\t    sort_nr = 1;\n\t    ++format_found;\n\t}\n\telse if (*p == 'f')\n\t{\n\t    sort_flt = 1;\n\t    ++format_found;\n\t}\n\telse if (*p == 'b')\n\t{\n\t    sort_what = STR2NR_BIN + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'o')\n\t{\n\t    sort_what = STR2NR_OCT + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'x')\n\t{\n\t    sort_what = STR2NR_HEX + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'u')\n\t    unique = TRUE;\n\telse if (*p == '\"')\t// comment start\n\t    break;\n\telse if (eap->nextcmd == NULL && check_nextcmd(p) != NULL)\n\t{\n\t    eap->nextcmd = check_nextcmd(p);\n\t    break;\n\t}\n\telse if (!ASCII_ISALPHA(*p) && regmatch.regprog == NULL)\n\t{\n\t    s = skip_regexp_err(p + 1, *p, TRUE);\n\t    if (s == NULL)\n\t\tgoto sortend;\n\t    *s = NUL;\n\t    // Use last search pattern if sort pattern is empty.\n\t    if (s == p + 1)\n\t    {\n\t\tif (last_search_pat() == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_regular_expression));\n\t\t    goto sortend;\n\t\t}\n\t\tregmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n\t    }\n\t    else\n\t\tregmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t\tgoto sortend;\n\t    p = s;\t\t// continue after the regexp\n\t    regmatch.rm_ic = p_ic;\n\t}\n\telse\n\t{\n\t    semsg(_(e_invalid_argument_str), p);\n\t    goto sortend;\n\t}\n    }\n\n    // Can only have one of 'n', 'b', 'o' and 'x'.\n    if (format_found > 1)\n    {\n\temsg(_(e_invalid_argument));\n\tgoto sortend;\n    }\n\n    // From here on \"sort_nr\" is used as a flag for any integer number\n    // sorting.\n    sort_nr += sort_what;\n\n    /*\n     * Make an array with all line numbers.  This avoids having to copy all\n     * the lines into allocated memory.\n     * When sorting on strings \"start_col_nr\" is the offset in the line, for\n     * numbers sorting it's the number to sort on.  This means the pattern\n     * matching and number conversion only has to be done once per line.\n     * Also get the longest line length for allocating \"sortbuf\".\n     */\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n    {\n\ts = ml_get(lnum);\n\tlen = (int)STRLEN(s);\n\tif (maxlen < len)\n\t    maxlen = len;\n\n\tstart_col = 0;\n\tend_col = len;\n\tif (regmatch.regprog != NULL && vim_regexec(&regmatch, s, 0))\n\t{\n\t    if (sort_rx)\n\t    {\n\t\tstart_col = (colnr_T)(regmatch.startp[0] - s);\n\t\tend_col = (colnr_T)(regmatch.endp[0] - s);\n\t    }\n\t    else\n\t\tstart_col = (colnr_T)(regmatch.endp[0] - s);\n\t}\n\telse\n\t    if (regmatch.regprog != NULL)\n\t\tend_col = 0;\n\n\tif (sort_nr || sort_flt)\n\t{\n\t    // Make sure vim_str2nr() doesn't read any digits past the end\n\t    // of the match, by temporarily terminating the string there\n\t    s2 = s + end_col;\n\t    c = *s2;\n\t    *s2 = NUL;\n\t    // Sorting on number: Store the number itself.\n\t    p = s + start_col;\n\t    if (sort_nr)\n\t    {\n\t\tif (sort_what & STR2NR_HEX)\n\t\t    s = skiptohex(p);\n\t\telse if (sort_what & STR2NR_BIN)\n\t\t    s = skiptobin(p);\n\t\telse\n\t\t    s = skiptodigit(p);\n\t\tif (s > p && s[-1] == '-')\n\t\t    --s;  // include preceding negative sign\n\t\tif (*s == NUL)\n\t\t{\n\t\t    // line without number should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = FALSE;\n\t\t    nrs[lnum - eap->line1].st_u.num.value = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = TRUE;\n\t\t    vim_str2nr(s, NULL, NULL, sort_what,\n\t\t\t&nrs[lnum - eap->line1].st_u.num.value,\n\t\t\tNULL, 0, FALSE, NULL);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = skipwhite(p);\n\t\tif (*s == '+')\n\t\t    s = skipwhite(s + 1);\n\n\t\tif (*s == NUL)\n\t\t    // empty line should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.value_flt = -DBL_MAX;\n\t\telse\n\t\t    nrs[lnum - eap->line1].st_u.value_flt =\n\t\t\t\t\t\t      strtod((char *)s, NULL);\n\t    }\n\t    *s2 = c;\n\t}\n\telse\n\t{\n\t    // Store the column to sort at.\n\t    nrs[lnum - eap->line1].st_u.line.start_col_nr = start_col;\n\t    nrs[lnum - eap->line1].st_u.line.end_col_nr = end_col;\n\t}\n\n\tnrs[lnum - eap->line1].lnum = lnum;\n\n\tif (regmatch.regprog != NULL)\n\t    fast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // Allocate a buffer that can hold the longest line.\n    sortbuf1 = alloc(maxlen + 1);\n    if (sortbuf1 == NULL)\n\tgoto sortend;\n    sortbuf2 = alloc(maxlen + 1);\n    if (sortbuf2 == NULL)\n\tgoto sortend;\n\n    // Sort the array of line numbers.  Note: can't be interrupted!\n    qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);\n\n    if (sort_abort)\n\tgoto sortend;\n\n    // Insert the lines in the sorted order below the last one.\n    lnum = eap->line2;\n    for (i = 0; i < count; ++i)\n    {\n\tlinenr_T get_lnum = nrs[eap->forceit ? count - i - 1 : i].lnum;\n\n\t// If the original line number of the line being placed is not the same\n\t// as \"lnum\" (accounting for offset), we know that the buffer changed.\n\tif (get_lnum + ((linenr_T)count - 1) != lnum)\n\t    change_occurred = TRUE;\n\n\ts = ml_get(get_lnum);\n\tif (!unique || i == 0 || string_compare(s, sortbuf1) != 0)\n\t{\n\t    // Copy the line into a buffer, it may become invalid in\n\t    // ml_append(). And it's needed for \"unique\".\n\t    STRCPY(sortbuf1, s);\n\t    if (ml_append(lnum++, sortbuf1, (colnr_T)0, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\tfast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // delete the original lines if appending worked\n    if (i == count)\n\tfor (i = 0; i < count; ++i)\n\t    ml_delete(eap->line1);\n    else\n\tcount = 0;\n\n    // Adjust marks for deleted (or added) lines and prepare for displaying.\n    deleted = (long)(count - (lnum - eap->line2));\n    if (deleted > 0)\n    {\n\tmark_adjust(eap->line2 - deleted, eap->line2, (long)MAXLNUM, -deleted);\n\tmsgmore(-deleted);\n    }\n    else if (deleted < 0)\n\tmark_adjust(eap->line2, MAXLNUM, -deleted, 0L);\n\n    if (change_occurred || deleted != 0)\n\tchanged_lines(eap->line1, 0, eap->line2 + 1, -deleted);\n\n    curwin->w_cursor.lnum = eap->line1;\n    beginline(BL_WHITE | BL_FIX);\n\nsortend:\n    vim_free(nrs);\n    vim_free(sortbuf1);\n    vim_free(sortbuf2);\n    vim_regfree(regmatch.regprog);\n    if (got_int)\n\temsg(_(e_interrupted));\n}\n\n/*\n * :move command - move lines line1-line2 to line dest\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_move(linenr_T line1, linenr_T line2, linenr_T dest)\n{\n    char_u\t*str;\n    linenr_T\tl;\n    linenr_T\textra;\t    // Num lines added before line1\n    linenr_T\tnum_lines;  // Num lines moved\n    linenr_T\tlast_line;  // Last line in file after adding new text\n#ifdef FEAT_FOLDING\n    win_T\t*win;\n    tabpage_T\t*tp;\n#endif\n\n    if (dest >= line1 && dest < line2)\n    {\n\temsg(_(e_cannot_move_range_of_lines_into_itself));\n\treturn FAIL;\n    }\n\n    // Do nothing if we are not actually moving any lines.  This will prevent\n    // the 'modified' flag from being set without cause.\n    if (dest == line1 - 1 || dest == line2)\n    {\n\t// Move the cursor as if lines were moved (see below) to be backwards\n\t// compatible.\n\tif (dest >= line1)\n\t    curwin->w_cursor.lnum = dest;\n\telse\n\t    curwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n\treturn OK;\n    }\n\n    num_lines = line2 - line1 + 1;\n\n    /*\n     * First we copy the old text to its new location -- webb\n     * Also copy the flag that \":global\" command uses.\n     */\n    if (u_save(dest, dest + 1) == FAIL)\n\treturn FAIL;\n    for (extra = 0, l = line1; l <= line2; l++)\n    {\n\tstr = vim_strsave(ml_get(l + extra));\n\tif (str != NULL)\n\t{\n\t    ml_append(dest + l - line1, str, (colnr_T)0, FALSE);\n\t    vim_free(str);\n\t    if (dest < line1)\n\t\textra++;\n\t}\n    }\n\n    /*\n     * Now we must be careful adjusting our marks so that we don't overlap our\n     * mark_adjust() calls.\n     *\n     * We adjust the marks within the old text so that they refer to the\n     * last lines of the file (temporarily), because we know no other marks\n     * will be set there since these line numbers did not exist until we added\n     * our new lines.\n     *\n     * Then we adjust the marks on lines between the old and new text positions\n     * (either forwards or backwards).\n     *\n     * And Finally we adjust the marks we put at the end of the file back to\n     * their final destination at the new text position -- webb\n     */\n    last_line = curbuf->b_ml.ml_line_count;\n    mark_adjust_nofold(line1, line2, last_line - line2, 0L);\n    if (dest >= line2)\n    {\n\tmark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t{\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, line1, line2, dest);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest - num_lines + 1;\n\t    curbuf->b_op_end.lnum = dest;\n\t}\n    }\n    else\n    {\n\tmark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t{\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, dest + 1, line1 - 1, line2);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest + 1;\n\t    curbuf->b_op_end.lnum = dest + num_lines;\n\t}\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    mark_adjust_nofold(last_line - num_lines + 1, last_line,\n\t\t\t\t\t     -(last_line - dest - extra), 0L);\n\n    /*\n     * Now we delete the original text -- webb\n     */\n    if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)\n\treturn FAIL;\n\n    for (l = line1; l <= line2; l++)\n\tml_delete_flags(line1 + extra, ML_DEL_MESSAGE);\n\n    if (!global_busy && num_lines > p_report)\n\tsmsg(NGETTEXT(\"%ld line moved\", \"%ld lines moved\", num_lines),\n\t\t\t(long)num_lines);\n\n    /*\n     * Leave the cursor on the last of the moved lines.\n     */\n    if (dest >= line1)\n\tcurwin->w_cursor.lnum = dest;\n    else\n\tcurwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n    if (line1 < dest)\n    {\n\tdest += num_lines + 1;\n\tlast_line = curbuf->b_ml.ml_line_count;\n\tif (dest > last_line + 1)\n\t    dest = last_line + 1;\n\tchanged_lines(line1, 0, dest, 0L);\n    }\n    else\n\tchanged_lines(dest + 1, 0, line1 + num_lines, 0L);\n\n    return OK;\n}\n\n/*\n * \":copy\"\n */\n    void\nex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    msgmore((long)count);\n}\n\nstatic char_u\t*prevcmd = NULL;\t// the previous command\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_prev_shellcmd(void)\n{\n    vim_free(prevcmd);\n}\n#endif\n\n/*\n * Check that \"prevcmd\" is not NULL.  If it is NULL then give an error message\n * and return FALSE.\n */\n    static int\nprevcmd_is_set(void)\n{\n    if (prevcmd == NULL)\n    {\n\temsg(_(e_no_previous_command));\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Handle the \":!cmd\" command.\tAlso for \":r !cmd\" and \":w !cmd\"\n * Bangs in the argument are replaced with the previously entered command.\n * Remember the argument.\n */\n    void\ndo_bang(\n    int\t\taddr_count,\n    exarg_T\t*eap,\n    int\t\tforceit,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t\t*arg = eap->arg;\t// command\n    linenr_T\t\tline1 = eap->line1;\t// start of range\n    linenr_T\t\tline2 = eap->line2;\t// end of range\n    char_u\t\t*newcmd = NULL;\t\t// the new command\n    int\t\t\tfree_newcmd = FALSE;    // need to free() newcmd\n    int\t\t\tins_prevcmd;\n    char_u\t\t*t;\n    char_u\t\t*p;\n    char_u\t\t*trailarg;\n    int\t\t\tlen;\n    int\t\t\tscroll_save = msg_scroll;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (addr_count == 0)\t\t// :!\n    {\n\tmsg_scroll = FALSE;\t    // don't scroll here\n\tautowrite_all();\n\tmsg_scroll = scroll_save;\n    }\n\n    /*\n     * Try to find an embedded bang, like in \":!<cmd> ! [args]\"\n     * \":!!\" is indicated by the 'forceit' variable.\n     */\n    ins_prevcmd = forceit;\n\n    // Skip leading white space to avoid a strange error with some shells.\n    trailarg = skipwhite(arg);\n    do\n    {\n\tlen = (int)STRLEN(trailarg) + 1;\n\tif (newcmd != NULL)\n\t    len += (int)STRLEN(newcmd);\n\tif (ins_prevcmd)\n\t{\n\t    if (!prevcmd_is_set())\n\t    {\n\t\tvim_free(newcmd);\n\t\treturn;\n\t    }\n\t    len += (int)STRLEN(prevcmd);\n\t}\n\tif ((t = alloc(len)) == NULL)\n\t{\n\t    vim_free(newcmd);\n\t    return;\n\t}\n\t*t = NUL;\n\tif (newcmd != NULL)\n\t    STRCAT(t, newcmd);\n\tif (ins_prevcmd)\n\t    STRCAT(t, prevcmd);\n\tp = t + STRLEN(t);\n\tSTRCAT(t, trailarg);\n\tvim_free(newcmd);\n\tnewcmd = t;\n\n\t/*\n\t * Scan the rest of the argument for '!', which is replaced by the\n\t * previous command.  \"\\!\" is replaced by \"!\" (this is vi compatible).\n\t */\n\ttrailarg = NULL;\n\twhile (*p)\n\t{\n\t    if (*p == '!')\n\t    {\n\t\tif (p > newcmd && p[-1] == '\\\\')\n\t\t    STRMOVE(p - 1, p);\n\t\telse\n\t\t{\n\t\t    trailarg = p;\n\t\t    *trailarg++ = NUL;\n\t\t    ins_prevcmd = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t    ++p;\n\t}\n    } while (trailarg != NULL);\n\n    // Only set \"prevcmd\" if there is a command to run, otherwise keep te one\n    // we have.\n    if (STRLEN(newcmd) > 0)\n    {\n\tvim_free(prevcmd);\n\tprevcmd = newcmd;\n    }\n    else\n\tfree_newcmd = TRUE;\n\n    if (bangredo)\t    // put cmd in redo buffer for ! command\n    {\n\tif (!prevcmd_is_set())\n\t    goto theend;\n\n\t// If % or # appears in the command, it must have been escaped.\n\t// Reescape them, so that redoing them does not substitute them by the\n\t// buffername.\n\tchar_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)\"%#\");\n\n\tif (cmd != NULL)\n\t{\n\t    AppendToRedobuffLit(cmd, -1);\n\t    vim_free(cmd);\n\t}\n\telse\n\t    AppendToRedobuffLit(prevcmd, -1);\n\tAppendToRedobuff((char_u *)\"\\n\");\n\tbangredo = FALSE;\n    }\n    /*\n     * Add quotes around the command, for shells that need them.\n     */\n    if (*p_shq != NUL)\n    {\n\tif (free_newcmd)\n\t    vim_free(newcmd);\n\tnewcmd = alloc(STRLEN(prevcmd) + 2 * STRLEN(p_shq) + 1);\n\tif (newcmd == NULL)\n\t    return;\n\tSTRCPY(newcmd, p_shq);\n\tSTRCAT(newcmd, prevcmd);\n\tSTRCAT(newcmd, p_shq);\n\tfree_newcmd = TRUE;\n    }\n    if (addr_count == 0)\t\t// :!\n    {\n\t// echo the command\n\tmsg_start();\n\tmsg_putchar(':');\n\tmsg_putchar('!');\n\tmsg_outtrans(newcmd);\n\tmsg_clr_eos();\n\twindgoto(msg_row, msg_col);\n\n\tdo_shell(newcmd, 0);\n    }\n    else\t\t\t\t// :range!\n    {\n\t// Careful: This may recursively call do_bang() again! (because of\n\t// autocommands)\n\tdo_filter(line1, line2, eap, newcmd, do_in, do_out);\n\tapply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);\n    }\n\ntheend:\n    if (free_newcmd)\n\tvim_free(newcmd);\n}\n\n/*\n * do_filter: filter lines through a command given by the user\n *\n * We mostly use temp files and the call_shell() routine here. This would\n * normally be done using pipes on a UNIX machine, but this is more portable\n * to non-unix machines. The call_shell() routine needs to be able\n * to deal with redirection somehow, and should handle things like looking\n * at the PATH env. variable, and adding reasonable extensions to the\n * command name given by the user. All reasonable versions of call_shell()\n * do this.\n * Alternatively, if on Unix and redirecting input or output, but not both,\n * and the 'shelltemp' option isn't set, use pipes.\n * We use input redirection if do_in is TRUE.\n * We use output redirection if do_out is TRUE.\n */\n    static void\ndo_filter(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    exarg_T\t*eap,\t\t// for forced 'ff' and 'fenc'\n    char_u\t*cmd,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t*itmp = NULL;\n    char_u\t*otmp = NULL;\n    linenr_T\tlinecount;\n    linenr_T\tread_linecount;\n    pos_T\tcursor_save;\n    char_u\t*cmd_buf;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\tshell_flags = 0;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#ifdef FEAT_FILTERPIPE\n    int\t\tstmp = p_stmp;\n#endif\n\n    if (*cmd == NUL)\t    // no filter command\n\treturn;\n\n    // Temporarily disable lockmarks since that's needed to propagate changed\n    // regions of the buffer for foldUpdate(), linecount, etc.\n    cmdmod.cmod_flags &= ~CMOD_LOCKMARKS;\n\n    cursor_save = curwin->w_cursor;\n    linecount = line2 - line1 + 1;\n    curwin->w_cursor.lnum = line1;\n    curwin->w_cursor.col = 0;\n    changed_line_abv_curs();\n    invalidate_botline();\n\n    /*\n     * When using temp files:\n     * 1. * Form temp file names\n     * 2. * Write the lines to a temp file\n     * 3.   Run the filter command on the temp file\n     * 4. * Read the output of the command into the buffer\n     * 5. * Delete the original lines to be filtered\n     * 6. * Remove the temp files\n     *\n     * When writing the input with a pipe or when catching the output with a\n     * pipe only need to do 3.\n     */\n\n    if (do_out)\n\tshell_flags |= SHELL_DOOUT;\n\n#ifdef FEAT_FILTERPIPE\n# ifdef VIMDLL\n    if (!gui.in_use && !gui.starting)\n\tstmp = 1;   // Console mode doesn't support filterpipe.\n# endif\n\n    if (!do_in && do_out && !stmp)\n    {\n\t// Use a pipe to fetch stdout of the command, do not use a temp file.\n\tshell_flags |= SHELL_READ;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else if (do_in && !do_out && !stmp)\n    {\n\t// Use a pipe to write stdin of the command, do not use a temp file.\n\tshell_flags |= SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n    }\n    else if (do_in && do_out && !stmp)\n    {\n\t// Use a pipe to write stdin and fetch stdout of the command, do not\n\t// use a temp file.\n\tshell_flags |= SHELL_READ|SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else\n#endif\n\tif ((do_in && (itmp = vim_tempname('i', FALSE)) == NULL)\n\t\t|| (do_out && (otmp = vim_tempname('o', FALSE)) == NULL))\n\t{\n\t    emsg(_(e_cant_get_temp_file_name));\n\t    goto filterend;\n\t}\n\n/*\n * The writing and reading of temp files will not be shown.\n * Vi also doesn't do this and the messages are not very informative.\n */\n    ++no_wait_return;\t\t// don't call wait_return() while busy\n    if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,\n\t\t\t\t\t   FALSE, FALSE, FALSE, TRUE) == FAIL)\n    {\n\tmsg_putchar('\\n');\t\t// keep message from buf_write()\n\t--no_wait_return;\n#if defined(FEAT_EVAL)\n\tif (!aborting())\n#endif\n\t    // will call wait_return()\n\t    (void)semsg(_(e_cant_create_file_str), itmp);\n\tgoto filterend;\n    }\n    if (curbuf != old_curbuf)\n\tgoto filterend;\n\n    if (!do_out)\n\tmsg_putchar('\\n');\n\n    // Create the shell command in allocated memory.\n    cmd_buf = make_filter_cmd(cmd, itmp, otmp);\n    if (cmd_buf == NULL)\n\tgoto filterend;\n\n    windgoto((int)Rows - 1, 0);\n    cursor_on();\n\n    /*\n     * When not redirecting the output the command can write anything to the\n     * screen. If 'shellredir' is equal to \">\", screen may be messed up by\n     * stderr output of external command. Clear the screen later.\n     * If do_in is FALSE, this could be something like \":r !cat\", which may\n     * also mess up the screen, clear it later.\n     */\n    if (!do_out || STRCMP(p_srr, \">\") == 0 || !do_in)\n\tredraw_later_clear();\n\n    if (do_out)\n    {\n\tif (u_save(line2, (linenr_T)(line2 + 1)) == FAIL)\n\t{\n\t    vim_free(cmd_buf);\n\t    goto error;\n\t}\n\tredraw_curbuf_later(UPD_VALID);\n    }\n    read_linecount = curbuf->b_ml.ml_line_count;\n\n    /*\n     * When call_shell() fails wait_return() is called to give the user a\n     * chance to read the error messages. Otherwise errors are ignored, so you\n     * can see the error messages from the command that appear on stdout; use\n     * 'u' to fix the text\n     * Switch to cooked mode when not redirecting stdin, avoids that something\n     * like \":r !cat\" hangs.\n     * Pass on the SHELL_DOOUT flag when the output is being redirected.\n     */\n    if (call_shell(cmd_buf, SHELL_FILTER | SHELL_COOKED | shell_flags))\n    {\n\tredraw_later_clear();\n\twait_return(FALSE);\n    }\n    vim_free(cmd_buf);\n\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    // When interrupting the shell command, it may still have produced some\n    // useful output.  Reset got_int here, so that readfile() won't cancel\n    // reading.\n    ui_breakcheck();\n    got_int = FALSE;\n\n    if (do_out)\n    {\n\tif (otmp != NULL)\n\t{\n\t    if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t\t    eap, READ_FILTER) != OK)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tif (!aborting())\n#endif\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    semsg(_(e_cant_read_file_str), otmp);\n\t\t}\n\t\tgoto error;\n\t    }\n\t    if (curbuf != old_curbuf)\n\t\tgoto filterend;\n\t}\n\n\tread_linecount = curbuf->b_ml.ml_line_count - read_linecount;\n\n\tif (shell_flags & SHELL_READ)\n\t{\n\t    curbuf->b_op_start.lnum = line2 + 1;\n\t    curbuf->b_op_end.lnum = curwin->w_cursor.lnum;\n\t    appended_lines_mark(line2, read_linecount);\n\t}\n\n\tif (do_in)\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPMARKS)\n\t\t\t\t     || vim_strchr(p_cpo, CPO_REMMARK) == NULL)\n\t    {\n\t\tif (read_linecount >= linecount)\n\t\t    // move all marks from old lines to new lines\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\telse if (save_cmod_flags & CMOD_LOCKMARKS)\n\t\t{\n\t\t    // Move marks from the lines below the new lines down by\n\t\t    // the number of lines lost.\n\t\t    // Move marks from the lines that will be deleted to the\n\t\t    // new lines and below.\n\t\t    mark_adjust(line2 + 1, (linenr_T)MAXLNUM,\n\t\t\t\t\t       linecount - read_linecount, 0L);\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // move marks from old lines to new lines, delete marks\n\t\t    // that are in deleted lines\n\t\t    mark_adjust(line1, line1 + read_linecount - 1,\n\t\t\t\t\t\t\t\tlinecount, 0L);\n\t\t    mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Put cursor on first filtered line for \":range!cmd\".\n\t     * Adjust '[ and '] (set by buf_write()).\n\t     */\n\t    curwin->w_cursor.lnum = line1;\n\t    del_lines(linecount, TRUE);\n\t    curbuf->b_op_start.lnum -= linecount;\t// adjust '[\n\t    curbuf->b_op_end.lnum -= linecount;\t\t// adjust ']\n\t    write_lnum_adjust(-linecount);\t\t// adjust last line\n\t\t\t\t\t\t\t// for next write\n#ifdef FEAT_FOLDING\n\t    foldUpdate(curwin, curbuf->b_op_start.lnum, curbuf->b_op_end.lnum);\n#endif\n\t}\n\telse\n\t{\n\t    /*\n\t     * Put cursor on last new line for \":r !cmd\".\n\t     */\n\t    linecount = curbuf->b_op_end.lnum - curbuf->b_op_start.lnum + 1;\n\t    curwin->w_cursor.lnum = curbuf->b_op_end.lnum;\n\t}\n\n\tbeginline(BL_WHITE | BL_FIX);\t    // cursor on first non-blank\n\t--no_wait_return;\n\n\tif (linecount > p_report)\n\t{\n\t    if (do_in)\n\t    {\n\t\tvim_snprintf(msg_buf, sizeof(msg_buf),\n\t\t\t\t    _(\"%ld lines filtered\"), (long)linecount);\n\t\tif (msg(msg_buf) && !msg_scroll)\n\t\t    // save message to display it after redraw\n\t\t    set_keep_msg((char_u *)msg_buf, 0);\n\t    }\n\t    else\n\t\tmsgmore((long)linecount);\n\t}\n    }\n    else\n    {\nerror:\n\t// put cursor back in same position for \":w !cmd\"\n\tcurwin->w_cursor = cursor_save;\n\t--no_wait_return;\n\twait_return(FALSE);\n    }\n\nfilterend:\n\n    cmdmod.cmod_flags = save_cmod_flags;\n    if (curbuf != old_curbuf)\n    {\n\t--no_wait_return;\n\temsg(_(e_filter_autocommands_must_not_change_current_buffer));\n    }\n    else if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n\n    if (itmp != NULL)\n\tmch_remove(itmp);\n    if (otmp != NULL)\n\tmch_remove(otmp);\n    vim_free(itmp);\n    vim_free(otmp);\n}\n\n/*\n * Call a shell to execute a command.\n * When \"cmd\" is NULL start an interactive shell.\n */\n    void\ndo_shell(\n    char_u\t*cmd,\n    int\t\tflags)\t// may be SHELL_DOOUT when output is redirected\n{\n    buf_T\t*buf;\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n    int\t\tsave_nwr;\n#endif\n#ifdef MSWIN\n    int\t\twinstart = FALSE;\n#endif\n    int\t\tkeep_termcap = !termcap_active;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n    {\n\tmsg_end();\n\treturn;\n    }\n\n#ifdef MSWIN\n    /*\n     * Check if \":!start\" is used.  This implies not stopping termcap mode.\n     */\n    if (cmd != NULL)\n\tkeep_termcap = winstart = (STRNICMP(cmd, \"start \", 6) == 0);\n\n# if defined(FEAT_GUI) && defined(FEAT_TERMINAL)\n    // Don't stop termcap mode when using a terminal window for the shell.\n    if (gui.in_use && vim_strchr(p_go, GO_TERMINAL) != NULL)\n\tkeep_termcap = TRUE;\n# endif\n#endif\n\n    /*\n     * For autocommands we want to get the output on the current screen, to\n     * avoid having to type return below.\n     */\n    msg_putchar('\\r');\t\t\t// put cursor at start of line\n    if (!autocmd_busy)\n    {\n\tif (!keep_termcap)\n\t    stoptermcap();\n    }\n#ifdef MSWIN\n    if (!winstart)\n#endif\n\tmsg_putchar('\\n');\t\t// may shift screen one line up\n\n    // warning message before calling the shell\n    if (p_warn && !autocmd_busy && msg_silent == 0)\n\tFOR_ALL_BUFFERS(buf)\n\t    if (bufIsChangedNotTerm(buf))\n\t    {\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    starttermcap();\t// don't want a message box here\n#endif\n\t\tmsg_puts(_(\"[No write since last change]\\n\"));\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    stoptermcap();\n#endif\n\t\tbreak;\n\t    }\n\n    // This windgoto is required for when the '\\n' resulted in a \"delete line\n    // 1\" command to the terminal.\n    if (!swapping_screen())\n\twindgoto(msg_row, msg_col);\n    cursor_on();\n    (void)call_shell(cmd, SHELL_COOKED | flags);\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    /*\n     * put the message cursor at the end of the screen, avoids wait_return()\n     * to overwrite the text that the external command showed\n     */\n    if (!swapping_screen())\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n\n    if (autocmd_busy)\n    {\n\tif (msg_silent == 0)\n\t    redraw_later_clear();\n    }\n    else\n    {\n\t/*\n\t * For \":sh\" there is no need to call wait_return(), just redraw.\n\t * Also for the Win32 GUI (the output is in a console window).\n\t * Otherwise there is probably text on the screen that the user wants\n\t * to read before redrawing, so call wait_return().\n\t */\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t{\n\t    if (cmd == NULL\n# ifdef MSWIN\n\t\t    || (keep_termcap && !need_wait_return)\n# endif\n\t       )\n\t    {\n\t\tif (msg_silent == 0)\n\t\t    redraw_later_clear();\n\t\tneed_wait_return = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * If we switch screens when starttermcap() is called, we\n\t\t * really want to wait for \"hit return to continue\".\n\t\t */\n\t\tsave_nwr = no_wait_return;\n\t\tif (swapping_screen())\n\t\t    no_wait_return = FALSE;\n# ifdef AMIGA\n\t\twait_return(term_console ? -1 : msg_silent == 0); // see below\n# else\n\t\twait_return(msg_silent == 0);\n# endif\n\t\tno_wait_return = save_nwr;\n\t    }\n\t}\n#endif // FEAT_GUI_MSWIN\n\n\tif (!keep_termcap)\t// if keep_termcap is TRUE didn't stop termcap\n\t    starttermcap();\t// start termcap if not done by wait_return()\n\n\t/*\n\t * In an Amiga window redrawing is caused by asking the window size.\n\t * If we got an interrupt this will not work. The chance that the\n\t * window size is wrong is very small, but we need to redraw the\n\t * screen.  Don't do this if ':' hit in wait_return().\tTHIS IS UGLY\n\t * but it saves an extra redraw.\n\t */\n#ifdef AMIGA\n\tif (skip_redraw)\t\t// ':' hit in wait_return()\n\t{\n\t    if (msg_silent == 0)\n\t\tredraw_later_clear();\n\t}\n\telse if (term_console)\n\t{\n\t    OUT_STR(\"\\033[0 q\");\t// get window size\n\t    if (got_int && msg_silent == 0)\n\t\tredraw_later_clear();\t// if got_int is TRUE, redraw needed\n\t    else\n\t\tmust_redraw = 0;\t// no extra redraw needed\n\t}\n#endif\n    }\n\n    // display any error messages now\n    display_errors();\n\n    apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);\n}\n\n#if !defined(UNIX)\n    static char_u *\nfind_pipe(char_u *cmd)\n{\n    char_u  *p;\n    int\t    inquote = FALSE;\n\n    for (p = cmd; *p != NUL; ++p)\n    {\n\tif (!inquote && *p == '|')\n\t    return p;\n\tif (*p == '\"')\n\t    inquote = !inquote;\n\telse if (rem_backslash(p))\n\t    ++p;\n    }\n    return NULL;\n}\n#endif\n\n/*\n * Create a shell command from a command string, input redirection file and\n * output redirection file.\n * Returns an allocated string with the shell command, or NULL for failure.\n */\n    char_u *\nmake_filter_cmd(\n    char_u\t*cmd,\t\t// command\n    char_u\t*itmp,\t\t// NULL or name of input file\n    char_u\t*otmp)\t\t// NULL or name of output file\n{\n    char_u\t*buf;\n    long_u\tlen;\n    int\t\tis_powershell = FALSE;\n#ifdef UNIX\n    int\t\tis_fish_shell;\n#endif\n\n    char_u *shell_name = get_isolated_shell_name();\n    if (shell_name == NULL)\n\treturn NULL;\n\n#if defined(UNIX)\n    // Account for fish's different syntax for subshells\n    is_fish_shell = fnamecmp(shell_name, \"fish\") == 0;\n    if (is_fish_shell)\n\tlen = (long_u)STRLEN(cmd) + 13;\t\t// \"begin; \" + \"; end\" + NUL\n    else\n#endif\n    {\n\tis_powershell = (shell_name[0] == 'p')\n\t\t\t&& (fnamecmp(shell_name, \"powershell\") == 0\n\t\t\t\t|| fnamecmp(shell_name, \"powershell.exe\") == 0\n\t\t\t\t|| fnamecmp(shell_name, \"pwsh\") == 0\n\t\t\t\t|| fnamecmp(shell_name, \"pwsh.exe\") == 0);\n\tlen = (long_u)STRLEN(cmd) + 3;\t\t// \"()\" + NUL\n    }\n\n    if (itmp != NULL)\n    {\n\tif (is_powershell)\n\t    // \"& { Get-Content \" + \" | & \" + \" }\"\n\t    len += (long_u)STRLEN(itmp) + 24;\n\telse\n\t    len += (long_u)STRLEN(itmp) + 9;\t// \" { < \" + \" } \"\n    }\n    if (otmp != NULL)\n\tlen += (long_u)STRLEN(otmp) + (long_u)STRLEN(p_srr) + 2; // \"  \"\n\n    vim_free(shell_name);\n\n    buf = alloc(len);\n    if (buf == NULL)\n\treturn NULL;\n\n    if (is_powershell)\n    {\n\tif (itmp != NULL)\n\t    vim_snprintf((char *)buf, len, \"& { Get-Content %s | & %s }\",\n\t\t\t\t\t\t\t\titmp, cmd);\n\telse\n\t    vim_snprintf((char *)buf, len, \"(%s)\", cmd);\n    }\n    else\n    {\n#if defined(UNIX)\n\t// Put braces around the command (for concatenated commands) when\n\t// redirecting input and/or output.\n\tif (itmp != NULL || otmp != NULL)\n\t{\n\t    if (is_fish_shell)\n\t\tvim_snprintf((char *)buf, len, \"begin; %s; end\", (char *)cmd);\n\t    else\n\t\tvim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n\t}\n\telse\n\t    STRCPY(buf, cmd);\n\tif (itmp != NULL)\n\t{\n\t    STRCAT(buf, \" < \");\n\t    STRCAT(buf, itmp);\n\t}\n#else\n\t// For shells that don't understand braces around commands, at least\n\t// allow the use of commands in a pipe.\n\tif (*p_sxe != NUL && *p_sxq == '(')\n\t{\n\t    if (itmp != NULL || otmp != NULL)\n\t\tvim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n\t    else\n\t\tSTRCPY(buf, cmd);\n\t    if (itmp != NULL)\n\t    {\n\t\tSTRCAT(buf, \" < \");\n\t\tSTRCAT(buf, itmp);\n\t    }\n\t}\n\telse\n\t{\n\t    STRCPY(buf, cmd);\n\t    if (itmp != NULL)\n\t    {\n\t\tchar_u\t*p;\n\n\t\t// If there is a pipe, we have to put the '<' in front of it.\n\t\t// Don't do this when 'shellquote' is not empty, otherwise the\n\t\t// redirection would be inside the quotes.\n\t\tif (*p_shq == NUL)\n\t\t{\n\t\t    p = find_pipe(buf);\n\t\t    if (p != NULL)\n\t\t\t*p = NUL;\n\t\t}\n\t\tSTRCAT(buf, \" <\");\t// \" < \" causes problems on Amiga\n\t\tSTRCAT(buf, itmp);\n\t\tif (*p_shq == NUL)\n\t\t{\n\t\t    p = find_pipe(cmd);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\t// insert a space before the '|' for DOS\n\t\t\tSTRCAT(buf, \" \");\n\t\t\tSTRCAT(buf, p);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif\n    }\n    if (otmp != NULL)\n\tappend_redir(buf, (int)len, p_srr, otmp);\n\n    return buf;\n}\n\n/*\n * Append output redirection for file \"fname\" to the end of string buffer\n * \"buf[buflen]\"\n * Works with the 'shellredir' and 'shellpipe' options.\n * The caller should make sure that there is enough room:\n *\tSTRLEN(opt) + STRLEN(fname) + 3\n */\n    void\nappend_redir(\n    char_u\t*buf,\n    int\t\tbuflen,\n    char_u\t*opt,\n    char_u\t*fname)\n{\n    char_u\t*p;\n    char_u\t*end;\n\n    end = buf + STRLEN(buf);\n    // find \"%s\"\n    for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)\n    {\n\tif (p[1] == 's') // found %s\n\t    break;\n\tif (p[1] == '%') // skip %%\n\t    ++p;\n    }\n    if (p != NULL)\n    {\n#ifdef MSWIN\n\t*end++ = ' '; // not really needed? Not with sh, ksh or bash\n#endif\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)),\n\t\t\t\t\t\t  (char *)opt, (char *)fname);\n    }\n    else\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)), \" %s %s\",\n\t\t(char *)opt, (char *)fname);\n}\n\n/*\n * Implementation of \":fixdel\", also used by get_stty().\n *  <BS>    resulting <Del>\n *   ^?\t\t^H\n * not ^?\t^?\n */\n    void\ndo_fixdel(exarg_T *eap UNUSED)\n{\n    char_u  *p;\n\n    p = find_termcode((char_u *)\"kb\");\n    add_termcode((char_u *)\"kD\", p != NULL\n\t    && *p == DEL ? (char_u *)CTRL_H_STR : DEL_STR, FALSE);\n}\n\n    void\nprint_line_no_prefix(\n    linenr_T\tlnum,\n    int\t\tuse_number,\n    int\t\tlist)\n{\n    char\tnumbuf[30];\n\n    if (curwin->w_p_nu || use_number)\n    {\n\tvim_snprintf(numbuf, sizeof(numbuf),\n\t\t\t\t   \"%*ld \", number_width(curwin), (long)lnum);\n\tmsg_puts_attr(numbuf, HL_ATTR(HLF_N));\t// Highlight line nrs\n    }\n    msg_prt_line(ml_get(lnum), list);\n}\n\n/*\n * Print a text line.  Also in silent mode (\"ex -s\").\n */\n    void\nprint_line(linenr_T lnum, int use_number, int list)\n{\n    int\t\tsave_silent = silent_mode;\n\n    // apply :filter /pat/\n    if (message_filtered(ml_get(lnum)))\n\treturn;\n\n    msg_start();\n    silent_mode = FALSE;\n    info_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n    print_line_no_prefix(lnum, use_number, list);\n    if (save_silent)\n    {\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = save_silent;\n    }\n    info_message = FALSE;\n}\n\n    int\nrename_buffer(char_u *new_fname)\n{\n    char_u\t*fname, *sfname, *xfname;\n    buf_T\t*buf;\n\n    buf = curbuf;\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    // buffer changed, don't change name now\n    if (buf != curbuf)\n\treturn FAIL;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n    /*\n     * The name of the current buffer will be changed.\n     * A new (unlisted) buffer entry needs to be made to hold the old file\n     * name, which will become the alternate file name.\n     * But don't set the alternate file name if the buffer didn't have a\n     * name.\n     */\n    fname = curbuf->b_ffname;\n    sfname = curbuf->b_sfname;\n    xfname = curbuf->b_fname;\n    curbuf->b_ffname = NULL;\n    curbuf->b_sfname = NULL;\n    if (setfname(curbuf, new_fname, NULL, TRUE) == FAIL)\n    {\n\tcurbuf->b_ffname = fname;\n\tcurbuf->b_sfname = sfname;\n\treturn FAIL;\n    }\n    curbuf->b_flags |= BF_NOTEDITED;\n    if (xfname != NULL && *xfname != NUL)\n    {\n\tbuf = buflist_new(fname, xfname, curwin->w_cursor.lnum, 0);\n\tif (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t    curwin->w_alt_fnum = buf->b_fnum;\n    }\n    vim_free(fname);\n    vim_free(sfname);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n    return OK;\n}\n\n/*\n * \":file[!] [fname]\".\n */\n    void\nex_file(exarg_T *eap)\n{\n    // \":0file\" removes the file name.  Check for illegal uses \":3file\",\n    // \"0file name\", etc.\n    if (eap->addr_count > 0\n\t    && (*eap->arg != NUL\n\t\t|| eap->line2 > 0\n\t\t|| eap->addr_count > 1))\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    if (*eap->arg != NUL || eap->addr_count == 1)\n    {\n\tif (rename_buffer(eap->arg) == FAIL)\n\t    return;\n\tredraw_tabline = TRUE;\n    }\n\n    // print file name if no argument or 'F' is not in 'shortmess'\n    if (*eap->arg == NUL || !shortmess(SHM_FILEINFO))\n\tfileinfo(FALSE, FALSE, eap->forceit);\n}\n\n/*\n * \":update\".\n */\n    void\nex_update(exarg_T *eap)\n{\n    if (curbufIsChanged())\n\t(void)do_write(eap);\n}\n\n/*\n * \":write\" and \":saveas\".\n */\n    void\nex_write(exarg_T *eap)\n{\n    if (eap->cmdidx == CMD_saveas)\n    {\n\t// :saveas does not take a range, uses all lines.\n\teap->line1 = 1;\n\teap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    if (eap->usefilter)\t\t// input lines to shell command\n\tdo_bang(1, eap, FALSE, TRUE, FALSE);\n    else\n\t(void)do_write(eap);\n}\n\n#ifdef UNIX\n    static int\ncheck_writable(char_u *fname)\n{\n    if (mch_nodetype(fname) == NODE_OTHER)\n    {\n\tsemsg(_(e_str_is_not_file_or_writable_device), fname);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Write the current buffer to file \"eap->arg\".\n * If \"eap->append\" is TRUE, append to the file.\n *\n * If \"*eap->arg == NUL\" write to current file.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_write(exarg_T *eap)\n{\n    int\t\tother;\n    char_u\t*fname = NULL;\t\t// init to shut up gcc\n    char_u\t*ffname;\n    int\t\tretval = FAIL;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\t*browse_file = NULL;\n#endif\n    buf_T\t*alt_buf = NULL;\n    int\t\tname_was_missing;\n\n    if (not_writing())\t\t// check 'write' option\n\treturn FAIL;\n\n    ffname = eap->arg;\n#ifdef FEAT_BROWSE\n    if ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n    {\n\tbrowse_file = do_browse(BROWSE_SAVE, (char_u *)_(\"Save As\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\tif (browse_file == NULL)\n\t    goto theend;\n\tffname = browse_file;\n    }\n#endif\n    if (*ffname == NUL)\n    {\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    emsg(_(e_argument_required));\n\t    goto theend;\n\t}\n\tother = FALSE;\n    }\n    else\n    {\n\tfname = ffname;\n\tfree_fname = fix_fname(ffname);\n\t/*\n\t * When out-of-memory, keep unexpanded file name, because we MUST be\n\t * able to write the file in this situation.\n\t */\n\tif (free_fname != NULL)\n\t    ffname = free_fname;\n\tother = otherfile(ffname);\n    }\n\n    /*\n     * If we have a new file, put its name in the list of alternate file names.\n     */\n    if (other)\n    {\n\tif (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL\n\t\t\t\t\t\t || eap->cmdidx == CMD_saveas)\n\t    alt_buf = setaltfname(ffname, fname, (linenr_T)1);\n\telse\n\t    alt_buf = buflist_findname(ffname);\n\tif (alt_buf != NULL && alt_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    // Overwriting a file that is loaded in another buffer is not a\n\t    // good idea.\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    goto theend;\n\t}\n    }\n\n    /*\n     * Writing to the current file is not allowed in readonly mode\n     * and a file name is required.\n     * \"nofile\" and \"nowrite\" buffers cannot be written implicitly either.\n     */\n    if (!other && (bt_dontwrite_msg(curbuf) || check_fname() == FAIL\n#ifdef UNIX\n\t\t|| check_writable(curbuf->b_ffname) == FAIL\n#endif\n\t\t|| check_readonly(&eap->forceit, curbuf)))\n\tgoto theend;\n\n    if (!other)\n    {\n\tffname = curbuf->b_ffname;\n\tfname = curbuf->b_fname;\n\t/*\n\t * Not writing the whole file is only allowed with '!'.\n\t */\n\tif (\t   (eap->line1 != 1\n\t\t    || eap->line2 != curbuf->b_ml.ml_line_count)\n\t\t&& !eap->forceit\n\t\t&& !eap->append\n\t\t&& !p_wa)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL,\n\t\t\t       (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)\n\t\t    goto theend;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_use_bang_to_write_partial_buffer));\n\t\tgoto theend;\n\t    }\n\t}\n    }\n\n    if (check_overwrite(eap, curbuf, fname, ffname, other) == OK)\n    {\n\tif (eap->cmdidx == CMD_saveas && alt_buf != NULL)\n\t{\n\t    buf_T\t*was_curbuf = curbuf;\n\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't change name now\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\t    // Exchange the file names for the current and the alternate\n\t    // buffer.  This makes it look like we are now editing the buffer\n\t    // under the new name.  Must be done before buf_write(), because\n\t    // if there is no file name and 'cpo' contains 'F', it will set\n\t    // the file name.\n\t    fname = alt_buf->b_fname;\n\t    alt_buf->b_fname = curbuf->b_fname;\n\t    curbuf->b_fname = fname;\n\t    fname = alt_buf->b_ffname;\n\t    alt_buf->b_ffname = curbuf->b_ffname;\n\t    curbuf->b_ffname = fname;\n\t    fname = alt_buf->b_sfname;\n\t    alt_buf->b_sfname = curbuf->b_sfname;\n\t    curbuf->b_sfname = fname;\n\t    buf_name_changed(curbuf);\n\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);\n\t    if (!alt_buf->b_p_bl)\n\t    {\n\t\talt_buf->b_p_bl = TRUE;\n\t\tapply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);\n\t    }\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't write the file\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\n\t    // If 'filetype' was empty try detecting it now.\n\t    if (*curbuf->b_p_ft == NUL)\n\t    {\n\t\tif (au_has_group((char_u *)\"filetypedetect\"))\n\t\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\",\n\t\t\t\t\t\t\t\t  TRUE, NULL);\n\t\tdo_modelines(0);\n\t    }\n\n\t    // Autocommands may have changed buffer names, esp. when\n\t    // 'autochdir' is set.\n\t    fname = curbuf->b_sfname;\n\t}\n\n\tname_was_missing = curbuf->b_ffname == NULL;\n\n\tretval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,\n\t\t\t\t eap, eap->append, eap->forceit, TRUE, FALSE);\n\n\t// After \":saveas fname\" reset 'readonly'.\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    if (retval == OK)\n\t    {\n\t\tcurbuf->b_p_ro = FALSE;\n\t\tredraw_tabline = TRUE;\n\t    }\n\t}\n\n\t// Change directories when the 'acd' option is set and the file name\n\t// got changed or set.\n\tif (eap->cmdidx == CMD_saveas || name_was_missing)\n\t    DO_AUTOCHDIR;\n    }\n\ntheend:\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n/*\n * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,\n * BF_NEW or BF_READERR, check for overwriting current file.\n * May set eap->forceit if a dialog says it's OK to overwrite.\n * Return OK if it's OK, FAIL if it is not.\n */\n    int\ncheck_overwrite(\n    exarg_T\t*eap,\n    buf_T\t*buf,\n    char_u\t*fname,\t    // file name to be used (can differ from\n\t\t\t    // buf->ffname)\n    char_u\t*ffname,    // full path version of fname\n    int\t\tother)\t    // writing under other name\n{\n    /*\n     * Write to another file or b_flags set or not writing the whole file:\n     * overwriting only allowed with '!'.\n     * If \"other\" is FALSE and bt_nofilename(buf) is TRUE, this must be\n     * writing an \"acwrite\" buffer to the same file as its b_ffname, and\n     * buf_write() will only allow writing with BufWriteCmd autocommands,\n     * so there is no need for an overwrite check.\n     */\n    if (       (other\n\t\t|| (!bt_nofilename(buf)\n\t\t    && ((buf->b_flags & BF_NOTEDITED)\n\t\t\t|| ((buf->b_flags & BF_NEW)\n\t\t\t    && vim_strchr(p_cpo, CPO_OVERNEW) == NULL)\n\t\t\t|| (buf->b_flags & BF_READERR))))\n\t    && !p_wa\n\t    && vim_fexists(ffname))\n    {\n\tif (!eap->forceit && !eap->append)\n\t{\n#ifdef UNIX\n\t    // with UNIX it is possible to open a directory\n\t    if (mch_isdir(ffname))\n\t    {\n\t\tsemsg(_(e_str_is_directory), ffname);\n\t\treturn FAIL;\n\t    }\n#endif\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tdialog_msg(buff, _(\"Overwrite existing file \\\"%s\\\"?\"), fname);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)\n\t\t    return FAIL;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_file_exists));\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// For \":w! filename\" check that no swap file exists for \"filename\".\n\tif (other && !emsg_silent)\n\t{\n\t    char_u\t*dir;\n\t    char_u\t*p;\n\t    int\t\tr;\n\t    char_u\t*swapname;\n\n\t    // We only try the first entry in 'directory', without checking if\n\t    // it's writable.  If the \".\" directory is not writable the write\n\t    // will probably fail anyway.\n\t    // Use 'shortname' of the current buffer, since there is no buffer\n\t    // for the written file.\n\t    if (*p_dir == NUL)\n\t    {\n\t\tdir = alloc(5);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tSTRCPY(dir, \".\");\n\t    }\n\t    else\n\t    {\n\t\tdir = alloc(MAXPATHL);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tp = p_dir;\n\t\tcopy_option_part(&p, dir, MAXPATHL, \",\");\n\t    }\n\t    swapname = makeswapname(fname, ffname, curbuf, dir);\n\t    vim_free(dir);\n\t    r = vim_fexists(swapname);\n\t    if (r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t{\n\t\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\t    dialog_msg(buff,\n\t\t\t    _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),\n\t\t\t\t\t\t\t\t    swapname);\n\t\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)\n\t\t\t\t\t\t\t\t   != VIM_YES)\n\t\t    {\n\t\t\tvim_free(swapname);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    eap->forceit = TRUE;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    semsg(_(e_swap_file_exists_str_silent_overrides), swapname);\n\t\t    vim_free(swapname);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    vim_free(swapname);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle \":wnext\", \":wNext\" and \":wprevious\" commands.\n */\n    void\nex_wnext(exarg_T *eap)\n{\n    int\t\ti;\n\n    if (eap->cmd[1] == 'n')\n\ti = curwin->w_arg_idx + (int)eap->line2;\n    else\n\ti = curwin->w_arg_idx - (int)eap->line2;\n    eap->line1 = 1;\n    eap->line2 = curbuf->b_ml.ml_line_count;\n    if (do_write(eap) != FAIL)\n\tdo_argfile(eap, i);\n}\n\n/*\n * \":wall\", \":wqall\" and \":xall\": Write all changed files (and exit).\n */\n    void\ndo_wqall(exarg_T *eap)\n{\n    buf_T\t*buf;\n    int\t\terror = 0;\n    int\t\tsave_forceit = eap->forceit;\n\n    if (eap->cmdidx == CMD_xall || eap->cmdidx == CMD_wqall)\n    {\n\tif (before_quit_all(eap) == FAIL)\n\t    return;\n\texiting = TRUE;\n    }\n\n    FOR_ALL_BUFFERS(buf)\n    {\n#ifdef FEAT_TERMINAL\n\tif (exiting && term_job_running(buf->b_term))\n\t{\n\t    no_write_message_nobang(buf);\n\t    ++error;\n\t}\n\telse\n#endif\n\tif (bufIsChanged(buf) && !bt_dontwrite(buf))\n\t{\n\t    /*\n\t     * Check if there is a reason the buffer cannot be written:\n\t     * 1. if the 'write' option is set\n\t     * 2. if there is no file name (even after browsing)\n\t     * 3. if the 'readonly' is set (even after a dialog)\n\t     * 4. if overwriting is allowed (even after a dialog)\n\t     */\n\t    if (not_writing())\n\t    {\n\t\t++error;\n\t\tbreak;\n\t    }\n#ifdef FEAT_BROWSE\n\t    // \":browse wall\": ask for file name if there isn't one\n\t    if (buf->b_ffname == NULL && (cmdmod.cmod_flags & CMOD_BROWSE))\n\t\tbrowse_save_fname(buf);\n#endif\n\t    if (buf->b_ffname == NULL)\n\t    {\n\t\tsemsg(_(e_no_file_name_for_buffer_nr), (long)buf->b_fnum);\n\t\t++error;\n\t    }\n\t    else if (check_readonly(&eap->forceit, buf)\n\t\t    || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,\n\t\t\t\t\t\t\t       FALSE) == FAIL)\n\t    {\n\t\t++error;\n\t    }\n\t    else\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tif (buf_write_all(buf, eap->forceit) == FAIL)\n\t\t    ++error;\n\t\t// an autocommand may have deleted the buffer\n\t\tif (!bufref_valid(&bufref))\n\t\t    buf = firstbuf;\n\t    }\n\t    eap->forceit = save_forceit;    // check_overwrite() may set it\n\t}\n    }\n    if (exiting)\n    {\n\tif (!error)\n\t    getout(0);\t\t// exit Vim\n\tnot_exiting();\n    }\n}\n\n/*\n * Check the 'write' option.\n * Return TRUE and give a message when it's not set.\n */\n    static int\nnot_writing(void)\n{\n    if (p_write)\n\treturn FALSE;\n    emsg(_(e_file_not_written_writing_is_disabled_by_write_option));\n    return TRUE;\n}\n\n/*\n * Check if a buffer is read-only (either 'readonly' option is set or file is\n * read-only). Ask for overruling in a dialog. Return TRUE and give an error\n * message when the buffer is readonly.\n */\n    static int\ncheck_readonly(int *forceit, buf_T *buf)\n{\n    stat_T\tst;\n\n    // Handle a file being readonly when the 'readonly' option is set or when\n    // the file exists and permissions are read-only.\n    // We will send 0777 to check_file_readonly(), as the \"perm\" variable is\n    // important for device checks but not here.\n    if (!*forceit && (buf->b_p_ro\n\t\t|| (mch_stat((char *)buf->b_ffname, &st) >= 0\n\t\t    && check_file_readonly(buf->b_ffname, 0777))))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t       && buf->b_fname != NULL)\n\t{\n\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t    if (buf->b_p_ro)\n\t\tdialog_msg(buff, _(\"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),\n\t\t    buf->b_fname);\n\t    else\n\t\tdialog_msg(buff, _(\"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),\n\t\t    buf->b_fname);\n\n\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)\n\t    {\n\t\t// Set forceit, to force the writing of a readonly file\n\t\t*forceit = TRUE;\n\t\treturn FALSE;\n\t    }\n\t    else\n\t\treturn TRUE;\n\t}\n\telse\n#endif\n\tif (buf->b_p_ro)\n\t    emsg(_(e_readonly_option_is_set_add_bang_to_override));\n\telse\n\t    semsg(_(e_str_is_read_only_add_bang_to_override), buf->b_fname);\n\treturn TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Try to abandon the current file and edit a new or existing file.\n * \"fnum\" is the number of the file, if zero use \"ffname_arg\"/\"sfname_arg\".\n * \"lnum\" is the line number for the cursor in the new file (if non-zero).\n *\n * Return:\n * GETFILE_ERROR for \"normal\" error,\n * GETFILE_NOT_WRITTEN for \"not written\" error,\n * GETFILE_SAME_FILE for success\n * GETFILE_OPEN_OTHER for successfully opening another file.\n */\n    int\ngetfile(\n    int\t\tfnum,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tsetpm,\n    linenr_T\tlnum,\n    int\t\tforceit)\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    int\t\tother;\n    int\t\tretval;\n    char_u\t*free_me = NULL;\n\n    if (text_locked())\n\treturn GETFILE_ERROR;\n    if (curbuf_locked())\n\treturn GETFILE_ERROR;\n\n    if (fnum == 0)\n    {\n\t\t\t\t\t// make ffname full path, set sfname\n\tfname_expand(curbuf, &ffname, &sfname);\n\tother = otherfile(ffname);\n\tfree_me = ffname;\t\t// has been allocated, free() later\n    }\n    else\n\tother = (fnum != curbuf->b_fnum);\n\n    if (other)\n\t++no_wait_return;\t    // don't wait for autowrite message\n    if (other && !forceit && curbuf->b_nwindows == 1 && !buf_hide(curbuf)\n\t\t   && curbufIsChanged() && autowrite(curbuf, forceit) == FAIL)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif (p_confirm && p_write)\n\t    dialog_changed(curbuf, FALSE);\n\tif (curbufIsChanged())\n#endif\n\t{\n\t    --no_wait_return;\n\t    no_write_message();\n\t    retval = GETFILE_NOT_WRITTEN;\t// file has been changed\n\t    goto theend;\n\t}\n    }\n    if (other)\n\t--no_wait_return;\n    if (setpm)\n\tsetpcmark();\n    if (!other)\n    {\n\tif (lnum != 0)\n\t    curwin->w_cursor.lnum = lnum;\n\tcheck_cursor_lnum();\n\tbeginline(BL_SOL | BL_FIX);\n\tretval = GETFILE_SAME_FILE;\t// it's in the same file\n    }\n    else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,\n\t     (buf_hide(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),\n\t\tcurwin) == OK)\n\tretval = GETFILE_OPEN_OTHER;\t// opened another file\n    else\n\tretval = GETFILE_ERROR;\t\t// error encountered\n\ntheend:\n    vim_free(free_me);\n    return retval;\n}\n\n/*\n * start editing a new file\n *\n *     fnum: file number; if zero use ffname/sfname\n *   ffname: the file name\n *\t\t- full path if sfname used,\n *\t\t- any file name if sfname is NULL\n *\t\t- empty string to re-edit with the same file name (but may be\n *\t\t    in a different directory)\n *\t\t- NULL to start an empty buffer\n *   sfname: the short file name (or NULL)\n *\teap: contains the command to be executed after loading the file and\n *\t     forced 'ff' and 'fenc'\n *  newlnum: if > 0: put cursor on this line number (if possible)\n *\t     if ECMD_LASTL: use last position in loaded file\n *\t     if ECMD_LAST: use last position in all files\n *\t     if ECMD_ONE: use first line\n *    flags:\n *\t   ECMD_HIDE: if TRUE don't free the current buffer\n *     ECMD_SET_HELP: set b_help flag of (new) buffer before opening file\n *\t ECMD_OLDBUF: use existing buffer if it exists\n *\tECMD_FORCEIT: ! used for Ex command\n *\t ECMD_ADDBUF: don't edit, just add to buffer list\n *\t ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate file\n *   ECMD_NOWINENTER: Do not trigger BufWinEnter\n *   oldwin: Should be \"curwin\" when editing a new buffer in the current\n *\t     window, NULL when splitting the window first.  When not NULL info\n *\t     of the previous buffer for \"oldwin\" is stored.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_ecmd(\n    int\t\tfnum,\n    char_u\t*ffname,\n    char_u\t*sfname,\n    exarg_T\t*eap,\t\t\t// can be NULL!\n    linenr_T\tnewlnum,\n    int\t\tflags,\n    win_T\t*oldwin)\n{\n    int\t\tother_file;\t\t// TRUE if editing another file\n    int\t\toldbuf;\t\t\t// TRUE if using existing buffer\n    int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us\n\t\t\t\t\t// into the buffer unexpectedly\n    char_u\t*new_name = NULL;\n#if defined(FEAT_EVAL)\n    int\t\tdid_set_swapcommand = FALSE;\n#endif\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    bufref_T\told_curbuf;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    char_u\t*browse_file = NULL;\n#endif\n    int\t\tretval = FAIL;\n    long\tn;\n    pos_T\torig_pos;\n    linenr_T\ttopline = 0;\n    int\t\tnewcol = -1;\n    int\t\tsolcol = -1;\n    pos_T\t*pos;\n    char_u\t*command = NULL;\n#ifdef FEAT_SPELL\n    int\t\tdid_get_winopts = FALSE;\n#endif\n    int\t\treadfile_flags = 0;\n    int\t\tdid_inc_redrawing_disabled = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn FAIL;\n#endif\n\n    if (eap != NULL)\n\tcommand = eap->do_ecmd_cmd;\n    set_bufref(&old_curbuf, curbuf);\n\n    if (fnum != 0)\n    {\n\tif (fnum == curbuf->b_fnum)\t// file is already being edited\n\t    return OK;\t\t\t// nothing to do\n\tother_file = TRUE;\n    }\n    else\n    {\n#ifdef FEAT_BROWSE\n\tif ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n\t{\n\t    if (\n# ifdef FEAT_GUI\n\t\t!gui.in_use &&\n# endif\n\t\t    au_has_group((char_u *)\"FileExplorer\"))\n\t    {\n\t\t// No browsing supported but we do have the file explorer:\n\t\t// Edit the directory.\n\t\tif (ffname == NULL || !mch_isdir(ffname))\n\t\t    ffname = dot_path;\n\t    }\n\t    else\n\t    {\n\t\tbrowse_file = do_browse(0, (char_u *)_(\"Edit File\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t\tif (browse_file == NULL)\n\t\t    goto theend;\n\t\tffname = browse_file;\n\t    }\n\t}\n#endif\n\t// if no short name given, use ffname for short name\n\tif (sfname == NULL)\n\t    sfname = ffname;\n#ifdef USE_FNAME_CASE\n\tif (sfname != NULL)\n\t    fname_case(sfname, 0);   // set correct case for sfname\n#endif\n\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t\t\t\t\t && (ffname == NULL || *ffname == NUL))\n\t    goto theend;\n\n\tif (ffname == NULL)\n\t    other_file = TRUE;\n\t\t\t\t\t    // there is no file name\n\telse if (*ffname == NUL && curbuf->b_ffname == NULL)\n\t    other_file = FALSE;\n\telse\n\t{\n\t    if (*ffname == NUL)\t\t    // re-edit with same file name\n\t    {\n\t\tffname = curbuf->b_ffname;\n\t\tsfname = curbuf->b_fname;\n\t    }\n\t    free_fname = fix_fname(ffname); // may expand to full path name\n\t    if (free_fname != NULL)\n\t\tffname = free_fname;\n\t    other_file = otherfile(ffname);\n\t}\n    }\n\n    /*\n     * If the file was changed we may not be allowed to abandon it:\n     * - if we are going to re-edit the same file\n     * - or if we are the only window on this file and if ECMD_HIDE is FALSE\n     */\n    if (  ((!other_file && !(flags & ECMD_OLDBUF))\n\t    || (curbuf->b_nwindows == 1\n\t\t&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))\n\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n\n    // End Visual mode before switching to another buffer, so the text can be\n    // copied into the GUI selection buffer.\n    // Careful: may trigger ModeChanged() autocommand\n\n    // Should we block autocommands here?\n    reset_VIsual();\n\n    // autocommands freed window :(\n    if (oldwin != NULL && !win_valid(oldwin))\n\toldwin = NULL;\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t// Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)\n\t    len = (int)STRLEN(command) + 3;\n\telse\n\t    len = 30;\n\tp = alloc(len);\n\tif (p != NULL)\n\t{\n\t    if (command != NULL)\n\t\tvim_snprintf((char *)p, len, \":%s\\r\", command);\n\t    else\n\t\tvim_snprintf((char *)p, len, \"%ldG\", (long)newlnum);\n\t    set_vim_var_string(VV_SWAPCOMMAND, p, -1);\n\t    did_set_swapcommand = TRUE;\n\t    vim_free(p);\n\t}\n    }\n#endif\n\n    /*\n     * If we are starting to edit another file, open a (new) buffer.\n     * Otherwise we re-use the current buffer.\n     */\n    if (other_file)\n    {\n\tint prev_alt_fnum = curwin->w_alt_fnum;\n\n\tif (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\tcurwin->w_alt_fnum = curbuf->b_fnum;\n\t    if (oldwin != NULL)\n\t\tbuflist_altfpos(oldwin);\n\t}\n\n\tif (fnum)\n\t    buf = buflist_findnr(fnum);\n\telse\n\t{\n\t    if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t    {\n\t\t// Default the line number to zero to avoid that a wininfo item\n\t\t// is added for the current window.\n\t\tlinenr_T\ttlnum = 0;\n\t\tbuf_T\t\t*newbuf;\n\n\t\tif (command != NULL)\n\t\t{\n\t\t    tlnum = atol((char *)command);\n\t\t    if (tlnum <= 0)\n\t\t\ttlnum = 1L;\n\t\t}\n\t\t// Add BLN_NOCURWIN to avoid a new wininfo items are associated\n\t\t// with the current window.\n\t\tnewbuf = buflist_new(ffname, sfname, tlnum,\n\t\t\t\t\t\t    BLN_LISTED | BLN_NOCURWIN);\n\t\tif (newbuf != NULL)\n\t\t{\n\t\t    if (flags & ECMD_ALTBUF)\n\t\t\tcurwin->w_alt_fnum = newbuf->b_fnum;\n\t\t    if (tlnum > 0)\n\t\t\tnewbuf->b_last_cursor.lnum = tlnum;\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    buf = buflist_new(ffname, sfname, 0L,\n\t\t    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));\n\n\t    // autocommands may change curwin and curbuf\n\t    if (oldwin != NULL)\n\t\toldwin = curwin;\n\t    set_bufref(&old_curbuf, curbuf);\n\t}\n\tif (buf == NULL)\n\t    goto theend;\n\tif (curwin->w_alt_fnum == buf->b_fnum && prev_alt_fnum != 0)\n\t    // reusing the buffer, keep the old alternate file\n\t    curwin->w_alt_fnum = prev_alt_fnum;\n\n\tif (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet\n\t{\n\t    oldbuf = FALSE;\n\t}\n\telse\t\t\t\t\t// existing memfile\n\t{\n\t    oldbuf = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    (void)buf_check_timestamp(buf, FALSE);\n\t    // Check if autocommands made the buffer invalid or changed the\n\t    // current buffer.\n\t    if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)\n\t\tgoto theend;\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t\tgoto theend;\n#endif\n\t}\n\n\t// May jump to last used line number for a loaded buffer or when asked\n\t// for explicitly\n\tif ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)\n\t{\n\t    pos = buflist_findfpos(buf);\n\t    newlnum = pos->lnum;\n\t    solcol = pos->col;\n\t}\n\n\t/*\n\t * Make the (new) buffer the one used by the current window.\n\t * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.\n\t * If the current buffer was empty and has no file name, curbuf\n\t * is returned by buflist_new(), nothing to do here.\n\t */\n\tif (buf != curbuf)\n\t{\n\t    bufref_T\tsave_au_new_curbuf;\n\t    int\t\tsave_cmdwin_type = cmdwin_type;\n\n\t    // BufLeave applies to the old buffer.\n\t    cmdwin_type = 0;\n\n\t    /*\n\t     * Be careful: The autocommands may delete any buffer and change\n\t     * the current buffer.\n\t     * - If the buffer we are going to edit is deleted, give up.\n\t     * - If the current buffer is deleted, prefer to load the new\n\t     *   buffer when loading a buffer is required.  This avoids\n\t     *   loading another buffer which then must be closed again.\n\t     * - If we ended up in the new buffer already, need to skip a few\n\t     *\t things, set auto_buf.\n\t     */\n\t    if (buf->b_fname != NULL)\n\t\tnew_name = vim_strsave(buf->b_fname);\n\t    save_au_new_curbuf = au_new_curbuf;\n\t    set_bufref(&au_new_curbuf, buf);\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    cmdwin_type = save_cmdwin_type;\n\t    if (!bufref_valid(&au_new_curbuf))\n\t    {\n\t\t// new buffer has been deleted\n\t\tdelbuf_msg(new_name);\t// frees new_name\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t    {\n\t\tvim_free(new_name);\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#endif\n\t    if (buf == curbuf)\t\t// already in new buffer\n\t\tauto_buf = TRUE;\n\t    else\n\t    {\n\t\twin_T\t    *the_curwin = curwin;\n\t\tint\t    did_decrement;\n\t\tbuf_T\t    *was_curbuf = curbuf;\n\n\t\t// Set the w_closing flag to avoid that autocommands close the\n\t\t// window.  And set b_locked for the same reason.\n\t\tthe_curwin->w_closing = TRUE;\n\t\t++buf->b_locked;\n\n\t\tif (curbuf == old_curbuf.br_buf)\n\t\t    buf_copy_options(buf, BCO_ENTER);\n\n\t\t// Close the link to the current buffer. This will set\n\t\t// oldwin->w_buffer to NULL.\n\t\tu_sync(FALSE);\n\t\tdid_decrement = close_buffer(oldwin, curbuf,\n\t\t\t (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);\n\n\t\t// Autocommands may have closed the window.\n\t\tif (win_valid(the_curwin))\n\t\t    the_curwin->w_closing = FALSE;\n\t\t--buf->b_locked;\n\n#ifdef FEAT_EVAL\n\t\t// autocmds may abort script processing\n\t\tif (aborting() && curwin->w_buffer != NULL)\n\t\t{\n\t\t    vim_free(new_name);\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n#endif\n\t\t// Be careful again, like above.\n\t\tif (!bufref_valid(&au_new_curbuf))\n\t\t{\n\t\t    // new buffer has been deleted\n\t\t    delbuf_msg(new_name);\t// frees new_name\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n\t\tif (buf == curbuf)\t\t// already in new buffer\n\t\t{\n\t\t    // close_buffer() has decremented the window count,\n\t\t    // increment it again here and restore w_buffer.\n\t\t    if (did_decrement && buf_valid(was_curbuf))\n\t\t\t++was_curbuf->b_nwindows;\n\t\t    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)\n\t\t\toldwin->w_buffer = was_curbuf;\n\t\t    auto_buf = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_SYN_HL\n\t\t    /*\n\t\t     * <VN> We could instead free the synblock\n\t\t     * and re-attach to buffer, perhaps.\n\t\t     */\n\t\t    if (curwin->w_buffer == NULL\n\t\t\t    || curwin->w_s == &(curwin->w_buffer->b_s))\n\t\t\tcurwin->w_s = &(buf->b_s);\n#endif\n\t\t    curwin->w_buffer = buf;\n\t\t    curbuf = buf;\n\t\t    ++curbuf->b_nwindows;\n\n\t\t    // Set 'fileformat', 'binary' and 'fenc' when forced.\n\t\t    if (!oldbuf && eap != NULL)\n\t\t    {\n\t\t\tset_file_options(TRUE, eap);\n\t\t\tset_forced_fenc(eap);\n\t\t    }\n\t\t}\n\n\t\t// May get the window options from the last time this buffer\n\t\t// was in this window (or another window).  If not used\n\t\t// before, reset the local window options to the global\n\t\t// values.  Also restores old folding stuff.\n\t\tget_winopts(curbuf);\n#ifdef FEAT_SPELL\n\t\tdid_get_winopts = TRUE;\n#endif\n\t    }\n\t    vim_free(new_name);\n\t    au_new_curbuf = save_au_new_curbuf;\n\t}\n\n\tcurwin->w_pcmark.lnum = 1;\n\tcurwin->w_pcmark.col = 0;\n    }\n    else // !other_file\n    {\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)\n\t    goto theend;\n\n\toldbuf = (flags & ECMD_OLDBUF);\n    }\n\n    // Don't redraw until the cursor is in the right line, otherwise\n    // autocommands may cause ml_get errors.\n    ++RedrawingDisabled;\n    did_inc_redrawing_disabled = TRUE;\n\n    buf = curbuf;\n    if ((flags & ECMD_SET_HELP) || keep_help_flag)\n    {\n\tprepare_help_buffer();\n    }\n    else\n    {\n\t// Don't make a buffer listed if it's a help buffer.  Useful when\n\t// using CTRL-O to go back to a help file.\n\tif (!curbuf->b_help)\n\t    set_buflisted(TRUE);\n    }\n\n    // If autocommands change buffers under our fingers, forget about\n    // editing the file.\n    if (buf != curbuf)\n\tgoto theend;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\tgoto theend;\n#endif\n\n    // Since we are starting to edit a file, consider the filetype to be\n    // unset.  Helps for when an autocommand changes files and expects syntax\n    // highlighting to work in the other file.\n    did_filetype = FALSE;\n\n/*\n * other_file\toldbuf\n *  FALSE\tFALSE\t    re-edit same file, buffer is re-used\n *  FALSE\tTRUE\t    re-edit same file, nothing changes\n *  TRUE\tFALSE\t    start editing new file, new buffer\n *  TRUE\tTRUE\t    start editing in existing buffer (nothing to do)\n */\n    if (!other_file && !oldbuf)\t\t// re-use the buffer\n    {\n\tset_last_cursor(curwin);\t// may set b_last_cursor\n\tif (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)\n\t{\n\t    newlnum = curwin->w_cursor.lnum;\n\t    solcol = curwin->w_cursor.col;\n\t}\n\tbuf = curbuf;\n\tif (buf->b_fname != NULL)\n\t    new_name = vim_strsave(buf->b_fname);\n\telse\n\t    new_name = NULL;\n\tset_bufref(&bufref, buf);\n\n\t// If the buffer was used before, store the current contents so that\n\t// the reload can be undone.  Do not do this if the (empty) buffer is\n\t// being re-used for another file.\n\tif (!(curbuf->b_flags & BF_NEVERLOADED)\n\t\t&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))\n\t{\n\t    // Sync first so that this is a separate undo-able action.\n\t    u_sync(FALSE);\n\t    if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)\n\t\t\t\t\t\t\t\t     == FAIL)\n\t    {\n\t\tvim_free(new_name);\n\t\tgoto theend;\n\t    }\n\t    u_unchanged(curbuf);\n\t    buf_freeall(curbuf, BFA_KEEP_UNDO);\n\n\t    // tell readfile() not to clear or reload undo info\n\t    readfile_flags = READ_KEEP_UNDO;\n\t}\n\telse\n\t    buf_freeall(curbuf, 0);   // free all things for buffer\n\n\t// If autocommands deleted the buffer we were going to re-edit, give\n\t// up and jump to the end.\n\tif (!bufref_valid(&bufref))\n\t{\n\t    delbuf_msg(new_name);\t// frees new_name\n\t    goto theend;\n\t}\n\tvim_free(new_name);\n\n\t// If autocommands change buffers under our fingers, forget about\n\t// re-editing the file.  Should do the buf_clear_file(), but perhaps\n\t// the autocommands changed the buffer...\n\tif (buf != curbuf)\n\t    goto theend;\n#ifdef FEAT_EVAL\n\tif (aborting())\t    // autocmds may abort script processing\n\t    goto theend;\n#endif\n\tbuf_clear_file(curbuf);\n\tcurbuf->b_op_start.lnum = 0;\t// clear '[ and '] marks\n\tcurbuf->b_op_end.lnum = 0;\n    }\n\n/*\n * If we get here we are sure to start editing\n */\n    // Assume success now\n    retval = OK;\n\n    // If the file name was changed, reset the not-edit flag so that \":write\"\n    // works.\n    if (!other_file)\n\tcurbuf->b_flags &= ~BF_NOTEDITED;\n\n    /*\n     * Check if we are editing the w_arg_idx file in the argument list.\n     */\n    check_arg_idx(curwin);\n\n    if (!auto_buf)\n    {\n\t/*\n\t * Set cursor and init window before reading the file and executing\n\t * autocommands.  This allows for the autocommands to position the\n\t * cursor.\n\t */\n\tcurwin_init();\n\n#ifdef FEAT_FOLDING\n\t// It's possible that all lines in the buffer changed.  Need to update\n\t// automatic folding for all windows where it's used.\n\t{\n\t    win_T\t    *win;\n\t    tabpage_T\t    *tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, win)\n\t\tif (win->w_buffer == curbuf)\n\t\t    foldUpdateAll(win);\n\t}\n#endif\n\n\t// Change directories when the 'acd' option is set.\n\tDO_AUTOCHDIR;\n\n\t/*\n\t * Careful: open_buffer() and apply_autocmds() may change the current\n\t * buffer and window.\n\t */\n\torig_pos = curwin->w_cursor;\n\ttopline = curwin->w_topline;\n\tif (!oldbuf)\t\t\t    // need to read the file\n\t{\n#ifdef FEAT_PROP_POPUP\n\t    // Don't use the swap-exists dialog for a popup window, can't edit\n\t    // the buffer.\n\t    if (WIN_IS_POPUP(curwin))\n\t\tcurbuf->b_flags |= BF_NO_SEA;\n#endif\n\t    swap_exists_action = SEA_DIALOG;\n\t    curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag\n\n\t    /*\n\t     * Open the buffer and read the file.\n\t     */\n\t    if (flags & ECMD_NOWINENTER)\n\t\treadfile_flags |= READ_NOWINENTER;\n#if defined(FEAT_EVAL)\n\t    if (should_abort(open_buffer(FALSE, eap, readfile_flags)))\n\t\tretval = FAIL;\n#else\n\t    (void)open_buffer(FALSE, eap, readfile_flags);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n\t    curbuf->b_flags &= ~BF_NO_SEA;\n#endif\n\t    if (swap_exists_action == SEA_QUIT)\n\t\tretval = FAIL;\n\t    handle_swap_exists(&old_curbuf);\n\t}\n\telse\n\t{\n\t    // Read the modelines, but only to set window-local options.  Any\n\t    // buffer-local options have already been set and may have been\n\t    // changed by the user.\n\t    do_modelines(OPT_WINONLY);\n\n\t    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t    if ((flags & ECMD_NOWINENTER) == 0)\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t}\n\tcheck_arg_idx(curwin);\n\n\t// If autocommands change the cursor position or topline, we should\n\t// keep it.  Also when it moves within a line. But not when it moves\n\t// to the first non-blank.\n\tif (!EQUAL_POS(curwin->w_cursor, orig_pos))\n\t{\n\t    char_u *text = ml_get_curline();\n\n\t    if (curwin->w_cursor.lnum != orig_pos.lnum\n\t\t    || curwin->w_cursor.col != (int)(skipwhite(text) - text))\n\t    {\n\t\tnewlnum = curwin->w_cursor.lnum;\n\t\tnewcol = curwin->w_cursor.col;\n\t    }\n\t}\n\tif (curwin->w_topline == topline)\n\t    topline = 0;\n\n\t// Even when cursor didn't move we need to recompute topline.\n\tchanged_line_abv_curs();\n\n\tmaketitle();\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\tif (WIN_IS_POPUP(curwin) && curwin->w_p_pvw && retval != FAIL)\n\t    popup_set_title(curwin);\n#endif\n    }\n\n#ifdef FEAT_DIFF\n    // Tell the diff stuff that this buffer is new and/or needs updating.\n    // Also needed when re-editing the same buffer, because unloading will\n    // have removed it as a diff buffer.\n    if (curwin->w_p_diff)\n    {\n\tdiff_buf_add(curbuf);\n\tdiff_invalidate(curbuf);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // If the window options were changed may need to set the spell language.\n    // Can only do this after the buffer has been properly setup.\n    if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)parse_spelllang(curwin);\n#endif\n\n    if (command == NULL)\n    {\n\tif (newcol >= 0)\t// position set by autocommands\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    curwin->w_cursor.col = newcol;\n\t    check_cursor();\n\t}\n\telse if (newlnum > 0)\t// line number from caller or old position\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    check_cursor_lnum();\n\t    if (solcol >= 0 && !p_sol)\n\t    {\n\t\t// 'sol' is off: Use last known column.\n\t\tcurwin->w_cursor.col = solcol;\n\t\tcheck_cursor_col();\n\t\tcurwin->w_cursor.coladd = 0;\n\t\tcurwin->w_set_curswant = TRUE;\n\t    }\n\t    else\n\t\tbeginline(BL_SOL | BL_FIX);\n\t}\n\telse\t\t\t// no line number, go to last line in Ex mode\n\t{\n\t    if (exmode_active)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n    }\n\n    // Check if cursors in other windows on the same buffer are still valid\n    check_lnums(FALSE);\n\n    /*\n     * Did not read the file, need to show some info about the file.\n     * Do this after setting the cursor.\n     */\n    if (oldbuf && !auto_buf)\n    {\n\tint\tmsg_scroll_save = msg_scroll;\n\n\t// Obey the 'O' flag in 'cpoptions': overwrite any previous file\n\t// message.\n\tif (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n\t    msg_scroll = FALSE;\n\tif (!msg_scroll)\t// wait a bit when overwriting an error msg\n\t    check_for_delay(FALSE);\n\tmsg_start();\n\tmsg_scroll = msg_scroll_save;\n\tmsg_scrolled_ign = TRUE;\n\n\tif (!shortmess(SHM_FILEINFO))\n\t    fileinfo(FALSE, TRUE, FALSE);\n\n\tmsg_scrolled_ign = FALSE;\n    }\n\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    if (command != NULL)\n\tdo_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n\n    if (RedrawingDisabled > 0)\n\t--RedrawingDisabled;\n    did_inc_redrawing_disabled = FALSE;\n    if (!skip_redraw)\n    {\n\tn = *so_ptr;\n\tif (topline == 0 && command == NULL)\n\t    *so_ptr = 9999;\t\t// force cursor halfway the window\n\tupdate_topline();\n\tcurwin->w_scbind_pos = curwin->w_topline;\n\t*so_ptr = n;\n\tredraw_curbuf_later(UPD_NOT_VALID);\t// redraw this buffer later\n    }\n\n    if (p_im && (State & MODE_INSERT) == 0)\n\tneed_start_insertmode = TRUE;\n\n#ifdef FEAT_AUTOCHDIR\n    // Change directories when the 'acd' option is set and we aren't already in\n    // that directory (should already be done above). Expect getcwd() to be\n    // faster than calling shorten_fnames() unnecessarily.\n    if (p_acd && curbuf->b_ffname != NULL)\n    {\n\tchar_u\tcurdir[MAXPATHL];\n\tchar_u\tfiledir[MAXPATHL];\n\n\tvim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);\n\t*gettail_sep(filedir) = NUL;\n\tif (mch_dirname(curdir, MAXPATHL) != FAIL\n\t\t&& vim_fnamecmp(curdir, filedir) != 0)\n\t    do_autochdir();\n    }\n#endif\n\n#if defined(FEAT_NETBEANS_INTG)\n    if (curbuf->b_ffname != NULL)\n    {\n# ifdef FEAT_NETBEANS_INTG\n\tif ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)\n\t    netbeans_file_opened(curbuf);\n# endif\n    }\n#endif\n\ntheend:\n    if (did_inc_redrawing_disabled && RedrawingDisabled > 0)\n\t--RedrawingDisabled;\n#if defined(FEAT_EVAL)\n    if (did_set_swapcommand)\n\tset_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n    static void\ndelbuf_msg(char_u *name)\n{\n    semsg(_(e_autocommands_unexpectedly_deleted_new_buffer_str),\n\t\t\t\t\t   name == NULL ? (char_u *)\"\" : name);\n    vim_free(name);\n    au_new_curbuf.br_buf = NULL;\n    au_new_curbuf.br_buf_free_count = 0;\n}\n\nstatic int append_indent = 0;\t    // autoindent for first line\n\n/*\n * \":insert\" and \":append\", also used by \":change\"\n */\n    void\nex_append(exarg_T *eap)\n{\n    char_u\t*theline;\n    int\t\tdid_undo = FALSE;\n    linenr_T\tlnum = eap->line2;\n    int\t\tindent = 0;\n    char_u\t*p;\n    int\t\tvcol;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    // the ! flag toggles autoindent\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // First autoindent comes from the line we start on\n    if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)\n\tappend_indent = get_indent_lnum(lnum);\n\n    if (eap->cmdidx != CMD_append)\n\t--lnum;\n\n    // when the buffer is empty need to delete the dummy line\n    if (empty && lnum == 1)\n\tlnum = 0;\n\n    State = MODE_INSERT;\t\t    // behave like in Insert mode\n    if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\tState |= MODE_LANGMAP;\n\n    for (;;)\n    {\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tif (curbuf->b_p_ai)\n\t{\n\t    if (append_indent >= 0)\n\t    {\n\t\tindent = append_indent;\n\t\tappend_indent = -1;\n\t    }\n\t    else if (lnum > 0)\n\t\tindent = get_indent_lnum(lnum);\n\t}\n\tex_keep_indent = FALSE;\n\tif (eap->getline == NULL)\n\t{\n\t    // No getline() function, use the lines that follow. This ends\n\t    // when there is no more.\n\t    if (eap->nextcmd == NULL || *eap->nextcmd == NUL)\n\t\tbreak;\n\t    p = vim_strchr(eap->nextcmd, NL);\n\t    if (p == NULL)\n\t\tp = eap->nextcmd + STRLEN(eap->nextcmd);\n\t    theline = vim_strnsave(eap->nextcmd, p - eap->nextcmd);\n\t    if (*p != NUL)\n\t\t++p;\n\t    eap->nextcmd = p;\n\t}\n\telse\n\t{\n\t    int save_State = State;\n\n\t    // Set State to avoid the cursor shape to be set to MODE_INSERT\n\t    // state when getline() returns.\n\t    State = MODE_CMDLINE;\n\t    theline = eap->getline(\n#ifdef FEAT_EVAL\n\t\t    eap->cstack->cs_looplevel > 0 ? -1 :\n#endif\n\t\t    NUL, eap->cookie, indent, TRUE);\n\t    State = save_State;\n\t}\n\tlines_left = Rows - 1;\n\tif (theline == NULL)\n\t    break;\n\n\t// Using ^ CTRL-D in getexmodeline() makes us repeat the indent.\n\tif (ex_keep_indent)\n\t    append_indent = indent;\n\n\t// Look for the \".\" after automatic indent.\n\tvcol = 0;\n\tfor (p = theline; indent > vcol; ++p)\n\t{\n\t    if (*p == ' ')\n\t\t++vcol;\n\t    else if (*p == TAB)\n\t\tvcol += 8 - vcol % 8;\n\t    else\n\t\tbreak;\n\t}\n\tif ((p[0] == '.' && p[1] == NUL)\n\t\t|| (!did_undo && u_save(lnum, lnum + 1 + (empty ? 1 : 0))\n\t\t\t\t\t\t\t\t     == FAIL))\n\t{\n\t    vim_free(theline);\n\t    break;\n\t}\n\n\t// don't use autoindent if nothing was typed.\n\tif (p[0] == NUL)\n\t    theline[0] = NUL;\n\n\tdid_undo = TRUE;\n\tml_append(lnum, theline, (colnr_T)0, FALSE);\n\tif (empty)\n\t    // there are no marks below the inserted lines\n\t    appended_lines(lnum, 1L);\n\telse\n\t    appended_lines_mark(lnum, 1L);\n\n\tvim_free(theline);\n\t++lnum;\n\n\tif (empty)\n\t{\n\t    ml_delete(2L);\n\t    empty = FALSE;\n\t}\n    }\n    State = MODE_NORMAL;\n\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // \"start\" is set to eap->line2+1 unless that position is invalid (when\n    // eap->line2 pointed to the end of the buffer and nothing was appended)\n    // \"end\" is set to lnum when something has been appended, otherwise\n    // it is the same as \"start\"  -- Acevedo\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = (eap->line2 < curbuf->b_ml.ml_line_count) ?\n\t    eap->line2 + 1 : curbuf->b_ml.ml_line_count;\n\tif (eap->cmdidx != CMD_append)\n\t    --curbuf->b_op_start.lnum;\n\tcurbuf->b_op_end.lnum = (eap->line2 < lnum)\n\t\t\t\t\t      ? lnum : curbuf->b_op_start.lnum;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n    curwin->w_cursor.lnum = lnum;\n    check_cursor_lnum();\n    beginline(BL_SOL | BL_FIX);\n\n    need_wait_return = FALSE;\t// don't use wait_return() now\n    ex_no_reprint = TRUE;\n}\n\n/*\n * \":change\"\n */\n    void\nex_change(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (eap->line2 >= eap->line1\n\t    && u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)\n\treturn;\n\n    // the ! flag toggles autoindent\n    if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)\n\tappend_indent = get_indent_lnum(eap->line1);\n\n    for (lnum = eap->line2; lnum >= eap->line1; --lnum)\n    {\n\tif (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to delete\n\t    break;\n\tml_delete(eap->line1);\n    }\n\n    // make sure the cursor is not beyond the end of the file now\n    check_cursor_lnum();\n    deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));\n\n    // \":append\" on the line above the deleted lines.\n    eap->line2 = eap->line1;\n    ex_append(eap);\n}\n\n    void\nex_z(exarg_T *eap)\n{\n    char_u\t*x;\n    long\tbigness;\n    char_u\t*kind;\n    int\t\tminus = 0;\n    linenr_T\tstart, end, curs, i;\n    int\t\tj;\n    linenr_T\tlnum = eap->line2;\n\n    // Vi compatible: \":z!\" uses display height, without a count uses\n    // 'scroll'\n    if (eap->forceit)\n\tbigness = Rows - 1;\n    else if (!ONE_WINDOW)\n\tbigness = curwin->w_height - 3;\n    else\n\tbigness = curwin->w_p_scr * 2;\n    if (bigness < 1)\n\tbigness = 1;\n\n    x = eap->arg;\n    kind = x;\n    if (*kind == '-' || *kind == '+' || *kind == '='\n\t\t\t\t\t      || *kind == '^' || *kind == '.')\n\t++x;\n    while (*x == '-' || *x == '+')\n\t++x;\n\n    if (*x != 0)\n    {\n\tif (!VIM_ISDIGIT(*x))\n\t{\n\t    emsg(_(e_non_numeric_argument_to_z));\n\t    return;\n\t}\n\telse\n\t{\n\t    bigness = atol((char *)x);\n\n\t    // bigness could be < 0 if atol(x) overflows.\n\t    if (bigness > 2 * curbuf->b_ml.ml_line_count || bigness < 0)\n\t\tbigness = 2 * curbuf->b_ml.ml_line_count;\n\n\t    p_window = bigness;\n\t    if (*kind == '=')\n\t\tbigness += 2;\n\t}\n    }\n\n    // the number of '-' and '+' multiplies the distance\n    if (*kind == '-' || *kind == '+')\n\tfor (x = kind + 1; *x == *kind; ++x)\n\t    ;\n\n    switch (*kind)\n    {\n\tcase '-':\n\t    start = lnum - bigness * (linenr_T)(x - kind) + 1;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n\n\tcase '=':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = lnum;\n\t    minus = 1;\n\t    break;\n\n\tcase '^':\n\t    start = lnum - bigness * 2;\n\t    end = lnum - bigness;\n\t    curs = lnum - bigness;\n\t    break;\n\n\tcase '.':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = end;\n\t    break;\n\n\tdefault:  // '+'\n\t    start = lnum;\n\t    if (*kind == '+')\n\t\tstart += bigness * (linenr_T)(x - kind - 1) + 1;\n\t    else if (eap->addr_count == 0)\n\t\t++start;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n    }\n\n    if (start < 1)\n\tstart = 1;\n\n    if (end > curbuf->b_ml.ml_line_count)\n\tend = curbuf->b_ml.ml_line_count;\n\n    if (curs > curbuf->b_ml.ml_line_count)\n\tcurs = curbuf->b_ml.ml_line_count;\n    else if (curs < 1)\n\tcurs = 1;\n\n    for (i = start; i <= end; i++)\n    {\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n\n\tprint_line(i, eap->flags & EXFLAG_NR, eap->flags & EXFLAG_LIST);\n\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n    }\n\n    if (curwin->w_cursor.lnum != curs)\n    {\n\tcurwin->w_cursor.lnum = curs;\n\tcurwin->w_cursor.col = 0;\n    }\n    ex_no_reprint = TRUE;\n}\n\n/*\n * Check if the restricted flag is set.\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(e_shell_commands_and_some_functionality_not_allowed_in_rvim));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check if the secure flag is set (.exrc or .vimrc in current directory).\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_secure(void)\n{\n    if (secure)\n    {\n\tsecure = 2;\n\temsg(_(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search));\n\treturn TRUE;\n    }\n#ifdef HAVE_SANDBOX\n    /*\n     * In the sandbox more things are not allowed, including the things\n     * disallowed in secure mode.\n     */\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn TRUE;\n    }\n#endif\n    return FALSE;\n}\n\nstatic char_u\t*old_sub = NULL;\t// previous substitute pattern\nstatic int\tglobal_need_beginline;\t// call beginline() after \":g\"\n\n/*\n * Flags that are kept between calls to :substitute.\n */\ntypedef struct {\n    int\tdo_all;\t\t// do multiple substitutions per line\n    int\tdo_ask;\t\t// ask for confirmation\n    int\tdo_count;\t// count only\n    int\tdo_error;\t// if false, ignore errors\n    int\tdo_print;\t// print last line with subs.\n    int\tdo_list;\t// list last line with subs.\n    int\tdo_number;\t// list last line with line nr\n    int\tdo_ic;\t\t// ignore case flag\n} subflags_T;\n\n/*\n * Skip over the \"sub\" part in :s/pat/sub/ where \"delimiter\" is the separating\n * character.\n */\n    char_u *\nskip_substitute(char_u *start, int delimiter)\n{\n    char_u *p = start;\n\n    while (p[0])\n    {\n\tif (p[0] == delimiter)\t\t// end delimiter found\n\t{\n\t    *p++ = NUL;\t\t\t// replace it with a NUL\n\t    break;\n\t}\n\tif (p[0] == '\\\\' && p[1] != 0)\t// skip escaped characters\n\t    ++p;\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    static int\ncheck_regexp_delim(int c)\n{\n    if (isalpha(c))\n    {\n\temsg(_(e_regular_expressions_cant_be_delimited_by_letters));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Perform a substitution from line eap->line1 to line eap->line2 using the\n * command pointed to by eap->arg which should be of the form:\n *\n * /pattern/substitution/{flags}\n *\n * The usual escapes are supported as described in the regexp docs.\n */\n    void\nex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    char_u\t*p;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n    int\t\tsave_sandbox = 0;\n#endif\n#ifdef FEAT_PROP_POPUP\n    textprop_T\t*text_props = NULL;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    if (in_vim9script())\n\t    {\n\t\temsg(_(e_cannot_use_s_backslash_in_vim9_script));\n\t\treturn;\n\t    }\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tp = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\tsub = vim_strsave(p);\n\tif (sub == NULL)\n\t    // out of memory\n\t    return;\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    vim_free(sub);\n\t\t    return;\n\t\t}\n\t\tvim_free(sub);\n\t\tsub = vim_strsave(old_sub);\n\t\tif (sub == NULL)\n\t\t    // out of memory\n\t\t    return;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t\tif (old_sub == NULL)\n\t\t    // out of memory\n\t\t    return;\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = vim_strsave(old_sub);\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t{\n\t    vim_free(sub);\n\t    return;\n\t}\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\tvim_free(sub);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    vim_free(sub);\n\t    return;\n\t}\n\telse if (i >= INT_MAX)\n\t{\n\t    char\tbuf[20];\n\t    vim_snprintf(buf, sizeof(buf), \"%ld\", i);\n\t    semsg(_(e_val_too_large), buf);\n\t    vim_free(sub);\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    vim_free(sub);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n    {\n\tvim_free(sub);\n\treturn;\n    }\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tvim_free(sub);\n\treturn;\n    }\n\n    if (search_regcomp(pat, NULL, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\tvim_free(sub);\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tp = vim_strsave(sub);\n\tvim_free(sub);\n\tif (p == NULL)\n\t    return;\n\tsub = p;\n    }\n    else\n    {\n\tp = regtilde(sub, magic_isset());\n\n\tif (p != sub)\n\t{\n\t    vim_free(sub);\n\t    sub = p;\n\t}\n    }\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n\t    int\t\ttext_prop_count = 0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to MODE_CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = MODE_CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t\t// When \":normal\" runs out of characters we get\n\t\t\t\t// an empty line.  Use \"q\" to get out of the\n\t\t\t\t// loop.\n\t\t\t\tif (ex_normal_busy && typed == NUL)\n\t\t\t\t    typed = 'q';\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    int save_RedrawingDisabled = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    if (search_match_lines == 0\n\t\t\t\t\t\t   && search_match_endcol == 0)\n\t\t\t\t// highlight at least one character for /^/\n\t\t\t\tsearch_match_endcol = 1;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(UPD_SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(UPD_SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return()\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = save_RedrawingDisabled;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tsave_sandbox = sandbox;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n\n\t\t// Disallow changing text or switching window in an expression.\n\t\t++textlock;\n#endif\n\t\t// Get length of substitution part, including the NUL.\n\t\t// When it fails sublen is zero.\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, 0,\n\t\t\t       REGSUB_BACKSLASH\n\t\t\t\t    | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (sublen == 0 || aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    sandbox = save_sandbox;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t    // safety check\n\t\t    if (nmatch < 0)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    linenr_T\tlastlnum = sub_firstlnum + nmatch - 1;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tchar_u\t*prop_start;\n\n\t\t\t// Props in the first line may be shortened or deleted\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       -MAXCOL, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\ttotal_added -= (colnr_T)STRLEN(\n\t\t\t\t     sub_firstline + regmatch.startpos[0].col);\n\n\t\t\t// Props in the last line may be moved or deleted\n\t\t\tif (adjust_prop_columns(lastlnum,\n\t\t\t\t\t0, -regmatch.endpos[0].col, apc_flags))\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\n\t\t\t// Copy the text props of the last line, they will be\n\t\t\t// later appended to the changed line.\n\t\t\ttext_prop_count = get_text_props(curbuf, lastlnum,\n\t\t\t\t\t\t\t   &prop_start, FALSE);\n\t\t\tif (text_prop_count > 0)\n\t\t\t{\n\t\t\t    // TODO: what when we already did this?\n\t\t\t    vim_free(text_props);\n\t\t\t    text_props = ALLOC_MULT(textprop_T,\n\t\t\t\t\t\t\t      text_prop_count);\n\t\t\t    if (text_props != NULL)\n\t\t\t    {\n\t\t\t\tint pi;\n\n\t\t\t\tmch_memmove(text_props, prop_start,\n\t\t\t\t\t text_prop_count * sizeof(textprop_T));\n\t\t\t\t// After joining the text prop columns will\n\t\t\t\t// increase.\n\t\t\t\tfor (pi = 0; pi < text_prop_count; ++pi)\n\t\t\t\t    text_props[pi].tp_col +=\n\t\t\t\t\t regmatch.startpos[0].col + sublen - 1;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n#endif\n\t\t    p1 = ml_get(lastlnum);\n\t\t    nmatch_tl += nmatch - 1;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t\ttotal_added += (colnr_T)STRLEN(\n\t\t\t\t\t\t  p1 + regmatch.endpos[0].col);\n#endif\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\tif ((int)new_start_len - copy_len < sublen)\n\t\t    sublen = new_start_len - copy_len - 1;\n\n#ifdef FEAT_EVAL\n\t\t++textlock;\n#endif\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, sublen,\n\t\t\t\t      REGSUB_COPY | REGSUB_BACKSLASH\n\t\t\t\t\t | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n#endif\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum,\n\t\t\t\t\t\t\t       plen, 1, FALSE);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (text_props != NULL)\n\t\t\t    add_text_props(lnum, text_props, text_prop_count);\n#endif\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n#ifdef FEAT_PROP_POPUP\n    vim_free(text_props);\n#endif\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}\n\n/*\n * Give message for number of substitutions.\n * Can also be used after a \":global\" command.\n * Return TRUE if a message was given.\n */\n    int\ndo_sub_msg(\n    int\t    count_only)\t\t// used 'n' flag for \":s\"\n{\n    /*\n     * Only report substitutions when:\n     * - more than 'report' substitutions\n     * - command was typed by user, or number of changed lines > 'report'\n     * - giving messages is not disabled by 'lazyredraw'\n     */\n    if (((sub_nsubs > p_report && (KeyTyped || sub_nlines > 1 || p_report < 1))\n\t\t|| count_only)\n\t    && messaging())\n    {\n\tchar\t*msg_single;\n\tchar\t*msg_plural;\n\n\tif (got_int)\n\t    STRCPY(msg_buf, _(\"(Interrupted) \"));\n\telse\n\t    *msg_buf = NUL;\n\n\tmsg_single = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld line\",\n\t\t\t\t\t  \"%ld matches on %ld line\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld line\",\n\t\t\t\t   \"%ld substitutions on %ld line\", sub_nsubs);\n\tmsg_plural = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld lines\",\n\t\t\t\t\t \"%ld matches on %ld lines\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld lines\",\n\t\t\t\t  \"%ld substitutions on %ld lines\", sub_nsubs);\n\n\tvim_snprintf_add(msg_buf, sizeof(msg_buf),\n\t\t\t\t NGETTEXT(msg_single, msg_plural, sub_nlines),\n\t\t\t\t sub_nsubs, (long)sub_nlines);\n\n\tif (msg(msg_buf))\n\t    // save message to display it after redraw\n\t    set_keep_msg((char_u *)msg_buf, 0);\n\treturn TRUE;\n    }\n    if (got_int)\n    {\n\temsg(_(e_interrupted));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nglobal_exe_one(char_u *cmd, linenr_T lnum)\n{\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    if (*cmd == NUL || *cmd == '\\n')\n\tdo_cmdline((char_u *)\"p\", NULL, NULL, DOCMD_NOWAIT);\n    else\n\tdo_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);\n}\n\n/*\n * Execute a global command of the form:\n *\n * g/pattern/X : execute X on all lines where pattern matches\n * v/pattern/X : execute X on all lines where pattern does not match\n *\n * where 'X' is an EX command\n *\n * The command character (as well as the trailing slash) is optional, and\n * is assumed to be 'p' if missing.\n *\n * This is implemented in two passes: first we scan the file for the pattern and\n * set a mark for each line that (not) matches. Secondly we execute the command\n * for each line that has a mark. This is required because after deleting\n * lines we do not know where to search for the next match.\n */\n    void\nex_global(exarg_T *eap)\n{\n    linenr_T\tlnum;\t\t// line number according to old situation\n    int\t\tndone = 0;\n    int\t\ttype;\t\t// first char of cmd: 'v' or 'g'\n    char_u\t*cmd;\t\t// command argument\n\n    char_u\tdelim;\t\t// delimiter, normally '/'\n    char_u\t*pat;\n    char_u\t*used_pat;\n    regmmatch_T\tregmatch;\n    int\t\tmatch;\n    int\t\twhich_pat;\n\n    // When nesting the command works on one line.  This allows for\n    // \":g/found/v/notfound/command\".\n    if (global_busy && (eap->line1 != 1\n\t\t\t\t  || eap->line2 != curbuf->b_ml.ml_line_count))\n    {\n\t// will increment global_busy to break out of the loop\n\temsg(_(e_cannot_do_global_recursive_with_range));\n\treturn;\n    }\n\n    if (eap->forceit)\t\t    // \":global!\" is like \":vglobal\"\n\ttype = 'v';\n    else\n\ttype = *eap->cmd;\n    cmd = eap->arg;\n    which_pat = RE_LAST;\t    // default: use last used regexp\n\n#ifdef FEAT_EVAL\n    if (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg) == FAIL)\n\treturn;\n#endif\n\n    /*\n     * undocumented vi feature:\n     *\t\"\\/\" and \"\\?\": use previous search pattern.\n     *\t\t \"\\&\": use previous substitute pattern.\n     */\n    if (*cmd == '\\\\')\n    {\n\t++cmd;\n\tif (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t{\n\t    emsg(_(e_backslash_should_be_followed_by));\n\t    return;\n\t}\n\tif (*cmd == '&')\n\t    which_pat = RE_SUBST;\t// use previous substitute pattern\n\telse\n\t    which_pat = RE_SEARCH;\t// use previous search pattern\n\t++cmd;\n\tpat = (char_u *)\"\";\n    }\n    else if (*cmd == NUL)\n    {\n\temsg(_(e_regular_expression_missing_from_global));\n\treturn;\n    }\n    else if (check_regexp_delim(*cmd) == FAIL)\n    {\n\treturn;\n    }\n    else\n    {\n\tdelim = *cmd;\t\t// get the delimiter\n\t++cmd;\t\t\t// skip delimiter if there is one\n\tpat = cmd;\t\t// remember start of pattern\n\tcmd = skip_regexp_ex(cmd, delim, magic_isset(), &eap->arg, NULL, NULL);\n\tif (cmd[0] == delim)\t\t    // end delimiter found\n\t    *cmd++ = NUL;\t\t    // replace it with a NUL\n    }\n\n    if (search_regcomp(pat, &used_pat, RE_BOTH, which_pat, SEARCH_HIS,\n\t\t\t\t\t\t\t    &regmatch) == FAIL)\n    {\n\temsg(_(e_invalid_command));\n\treturn;\n    }\n\n    if (global_busy)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif ((type == 'g' && match) || (type == 'v' && !match))\n\t    global_exe_one(cmd, lnum);\n    }\n    else\n    {\n\t/*\n\t * pass 1: set marks for each (not) matching line\n\t */\n\tfor (lnum = eap->line1; lnum <= eap->line2 && !got_int; ++lnum)\n\t{\n\t    // a match on this line?\n\t    match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\t    if (regmatch.regprog == NULL)\n\t\tbreak;  // re-compiling regprog failed\n\t    if ((type == 'g' && match) || (type == 'v' && !match))\n\t    {\n\t\tml_setmarked(lnum);\n\t\tndone++;\n\t    }\n\t    line_breakcheck();\n\t}\n\n\t/*\n\t * pass 2: execute the command for each line that has been marked\n\t */\n\tif (got_int)\n\t    msg(_(e_interrupted));\n\telse if (ndone == 0)\n\t{\n\t    if (type == 'v')\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_found_in_every_line_str), used_pat);\n\t\telse\n\t\t    smsg(_(\"Pattern found in every line: %s\"), used_pat);\n\t    }\n\t    else\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_not_found_str), used_pat);\n\t\telse\n\t\t    smsg(_(\"Pattern not found: %s\"), used_pat);\n\t    }\n\t}\n\telse\n\t{\n#ifdef FEAT_CLIPBOARD\n\t    start_global_changes();\n#endif\n\t    global_exe(cmd);\n#ifdef FEAT_CLIPBOARD\n\t    end_global_changes();\n#endif\n\t}\n\n\tml_clearmarked();\t   // clear rest of the marks\n    }\n\n    vim_regfree(regmatch.regprog);\n}\n\n/*\n * Execute \"cmd\" on lines marked with ml_setmarked().\n */\n    void\nglobal_exe(char_u *cmd)\n{\n    linenr_T old_lcount;\t// b_ml.ml_line_count before the command\n    buf_T    *old_buf = curbuf;\t// remember what buffer we started in\n    linenr_T lnum;\t\t// line number according to old situation\n\n    /*\n     * Set current position only once for a global command.\n     * If global_busy is set, setpcmark() will not do anything.\n     * If there is an error, global_busy will be incremented.\n     */\n    setpcmark();\n\n    // When the command writes a message, don't overwrite the command.\n    msg_didout = TRUE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    global_need_beginline = FALSE;\n    global_busy = 1;\n    old_lcount = curbuf->b_ml.ml_line_count;\n    while (!got_int && (lnum = ml_firstmarked()) != 0 && global_busy == 1)\n    {\n\tglobal_exe_one(cmd, lnum);\n\tui_breakcheck();\n    }\n\n    global_busy = 0;\n    if (global_need_beginline)\n\tbeginline(BL_WHITE | BL_FIX);\n    else\n\tcheck_cursor();\t// cursor may be beyond the end of the line\n\n    // the cursor may not have moved in the text but a change in a previous\n    // line may move it on the screen\n    changed_line_abv_curs();\n\n    // If it looks like no message was written, allow overwriting the\n    // command with the report for number of changes.\n    if (msg_col == 0 && msg_scrolled == 0)\n\tmsg_didout = FALSE;\n\n    // If substitutes done, report number of substitutes, otherwise report\n    // number of extra or deleted lines.\n    // Don't report extra or deleted lines in the edge case where the buffer\n    // we are in after execution is different from the buffer we started in.\n    if (!do_sub_msg(FALSE) && curbuf == old_buf)\n\tmsgmore(curbuf->b_ml.ml_line_count - old_lcount);\n}\n\n#ifdef FEAT_VIMINFO\n/*\n * Get the previous substitute pattern.\n */\n    char_u *\nget_old_sub(void)\n{\n    return old_sub;\n}\n\n/*\n * Set the previous substitute pattern.  \"val\" must be allocated.\n */\n    void\nset_old_sub(char_u *val)\n{\n    vim_free(old_sub);\n    old_sub = val;\n}\n#endif // FEAT_VIMINFO\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_old_sub(void)\n{\n    vim_free(old_sub);\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Set up for a tagpreview.\n * Makes the preview window the current window.\n * Return TRUE when it was created.\n */\n    int\nprepare_tagpreview(\n    int\t\tundo_sync,\t    // sync undo when leaving the window\n    int\t\tuse_previewpopup,   // use popup if 'previewpopup' set\n    use_popup_T\tuse_popup)\t    // use other popup window\n{\n    win_T\t*wp;\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n\n    if (curwin->w_p_pvw)\n\treturn FALSE;\n\n    /*\n     * If there is already a preview window open, use that one.\n     */\n# ifdef FEAT_PROP_POPUP\n    if (use_previewpopup && *p_pvp != NUL)\n    {\n\twp = popup_find_preview_window();\n\tif (wp != NULL)\n\t    popup_set_wantpos_cursor(wp, wp->w_minwidth, NULL);\n    }\n    else if (use_popup != USEPOPUP_NONE)\n    {\n\twp = popup_find_info_window();\n\tif (wp != NULL)\n\t{\n\t    if (use_popup == USEPOPUP_NORMAL)\n\t\tpopup_show(wp);\n\t    else\n\t\tpopup_hide(wp);\n\t    // When the popup moves or resizes it may reveal part of\n\t    // another window.  TODO: can this be done more efficiently?\n\t    redraw_all_later(UPD_NOT_VALID);\n\t}\n    }\n    else\n# endif\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_p_pvw)\n\t\tbreak;\n    }\n    if (wp != NULL)\n    {\n\twin_enter(wp, undo_sync);\n\treturn FALSE;\n    }\n\n    /*\n     * There is no preview window open yet.  Create one.\n     */\n# ifdef FEAT_PROP_POPUP\n    if ((use_previewpopup && *p_pvp != NUL)\n\t    || use_popup != USEPOPUP_NONE)\n\treturn popup_create_preview_window(use_popup != USEPOPUP_NONE);\n# endif\n    if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0) == FAIL)\n\treturn FALSE;\n    curwin->w_p_pvw = TRUE;\n    curwin->w_p_wfh = TRUE;\n    RESET_BINDING(curwin);\t    // don't take over 'scrollbind'\n\t\t\t\t    // and 'cursorbind'\n# ifdef FEAT_DIFF\n    curwin->w_p_diff = FALSE;\t    // no 'diff'\n# endif\n# ifdef FEAT_FOLDING\n    curwin->w_p_fdc = 0;\t    // no 'foldcolumn'\n# endif\n    return TRUE;\n}\n\n#endif\n\n/*\n * Make the user happy.\n */\n    void\nex_smile(exarg_T *eap UNUSED)\n{\n    static char *code[] = {\n\t\"\\34 \\4o\\14$\\4ox\\30 \\2o\\30$\\1ox\\25 \\2o\\36$\\1o\\11 \\1o\\1$\\3 \\2$\\1 \\1o\\1$x\\5 \\1o\\1 \\1$\\1 \\2o\\10 \\1o\\44$\\1o\\7 \\2$\\1 \\2$\\1 \\2$\\1o\\1$x\\2 \\2o\\1 \\1$\\1 \\1$\\1 \\1\\\"\\1$\\6 \\1o\\11$\\4 \\15$\\4 \\11$\\1o\\7 \\3$\\1o\\2$\\1o\\1$x\\2 \\1\\\"\\6$\\1o\\1$\\5 \\1o\\11$\\6 \\13$\\6 \\12$\\1o\\4 \\10$x\\4 \\7$\\4 \\13$\\6 \\13$\\6 \\27$x\\4 \\27$\\4 \\15$\\4 \\16$\\2 \\3\\\"\\3$x\\5 \\1\\\"\\3$\\4\\\"\\61$\\5 \\1\\\"\\3$x\\6 \\3$\\3 \\1o\\62$\\5 \\1\\\"\\3$\\1ox\\5 \\1o\\2$\\1\\\"\\3 \\63$\\7 \\3$\\1ox\\5 \\3$\\4 \\55$\\1\\\"\\1 \\1\\\"\\6$\",\n\t\"\\5o\\4$\\1ox\\4 \\1o\\3$\\4o\\5$\\2 \\45$\\3 \\1o\\21$x\\4 \\10$\\1\\\"\\4$\\3 \\42$\\5 \\4$\\10\\\"x\\3 \\4\\\"\\7 \\4$\\4 \\1\\\"\\34$\\1\\\"\\6 \\1o\\3$x\\16 \\1\\\"\\3$\\1o\\5 \\3\\\"\\22$\\1\\\"\\2$\\1\\\"\\11 \\3$x\\20 \\3$\\1o\\12 \\1\\\"\\2$\\2\\\"\\6$\\4\\\"\\13 \\1o\\3$x\\21 \\4$\\1o\\40 \\1o\\3$\\1\\\"x\\22 \\1\\\"\\4$\\1o\\6 \\1o\\6$\\1o\\1\\\"\\4$\\1o\\10 \\1o\\4$x\\24 \\1\\\"\\5$\\2o\\5 \\2\\\"\\4$\\1o\\5$\\1o\\3 \\1o\\4$\\2\\\"x\\27 \\2\\\"\\5$\\4o\\2 \\1\\\"\\3$\\1o\\11$\\3\\\"x\\32 \\2\\\"\\7$\\2o\\1 \\12$x\\42 \\4\\\"\\13$x\\46 \\14$x\\47 \\12$\\1\\\"x\\50 \\1\\\"\\3$\\4\\\"x\"\n    };\n    char *p;\n    int n;\n    int i;\n\n    msg_start();\n    msg_putchar('\\n');\n    for (i = 0; i < 2; ++i)\n\tfor (p = code[i]; *p != NUL; ++p)\n\t    if (*p == 'x')\n\t\tmsg_putchar('\\n');\n\t    else\n\t\tfor (n = *p++; n > 0; --n)\n\t\t    if (*p == 'o' || *p == '$')\n\t\t\tmsg_putchar_attr(*p, HL_ATTR(HLF_L));\n\t\t    else\n\t\t\tmsg_putchar(*p);\n    msg_clr_eos();\n}\n\n/*\n * \":drop\"\n * Opens the first argument in a window.  When there are two or more arguments\n * the argument list is redefined.\n */\n    void\nex_drop(exarg_T *eap)\n{\n    int\t\tsplit = FALSE;\n    win_T\t*wp;\n    buf_T\t*buf;\n    tabpage_T\t*tp;\n\n    if (ERROR_IF_POPUP_WINDOW || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n\n    /*\n     * Check if the first argument is already being edited in a window.  If\n     * so, jump to that window.\n     * We would actually need to check all arguments, but that's complicated\n     * and mostly only one file is dropped.\n     * This also ignores wildcards, since it is very unlikely the user is\n     * editing a file name with a wildcard character.\n     */\n    set_arglist(eap->arg);\n\n    /*\n     * Expanding wildcards may result in an empty argument list.  E.g. when\n     * editing \"foo.pyc\" and \".pyc\" is in 'wildignore'.  Assume that we\n     * already did an error message for this.\n     */\n    if (ARGCOUNT == 0)\n\treturn;\n\n    if (cmdmod.cmod_tab)\n    {\n\t// \":tab drop file ...\": open a tab for each argument that isn't\n\t// edited in a window yet.  It's like \":tab all\" but without closing\n\t// windows or tabs.\n\tex_all(eap);\n\treturn;\n    }\n\n    // \":drop file ...\": Edit the first argument.  Jump to an existing\n    // window if possible, edit in current window if the current buffer\n    // can be abandoned, otherwise open a new window.\n    buf = buflist_findnr(ARGLIST[0].ae_fnum);\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == buf)\n\t{\n\t    goto_tabpage_win(tp, wp);\n\t    curwin->w_arg_idx = 0;\n\t    if (!bufIsChanged(curbuf))\n\t    {\n\t\tint save_ar = curbuf->b_p_ar;\n\n\t\t// reload the file if it is newer\n\t\tcurbuf->b_p_ar = TRUE;\n\t\tbuf_check_timestamp(curbuf, FALSE);\n\t\tcurbuf->b_p_ar = save_ar;\n\t    }\n\t    return;\n\t}\n    }\n\n    /*\n     * Check whether the current buffer is changed. If so, we will need\n     * to split the current window or data could be lost.\n     * Skip the check if the 'hidden' option is set, as in this case the\n     * buffer won't be lost.\n     */\n    if (!buf_hide(curbuf))\n    {\n\t++emsg_off;\n\tsplit = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);\n\t--emsg_off;\n    }\n\n    // Fake a \":sfirst\" or \":first\" command edit the first argument.\n    if (split)\n    {\n\teap->cmdidx = CMD_sfirst;\n\teap->cmd[0] = 's';\n    }\n    else\n\teap->cmdidx = CMD_first;\n    ex_rewind(eap);\n}\n\n/*\n * Skip over the pattern argument of \":vimgrep /pat/[g][j]\".\n * Put the start of the pattern in \"*s\", unless \"s\" is NULL.\n * If \"flags\" is not NULL put the flags in it: VGR_GLOBAL, VGR_NOJUMP.\n * If \"s\" is not NULL terminate the pattern with a NUL.\n * Return a pointer to the char just past the pattern plus flags.\n */\n    char_u *\nskip_vimgrep_pat(char_u *p, char_u **s, int *flags)\n{\n    return skip_vimgrep_pat_ext(p, s, flags, NULL, NULL);\n}\n\n/*\n * As skip_vimgrep_pat() and store the character overwritten by NUL in \"cp\"\n * and the pointer to it in \"nulp\".\n */\n    char_u *\nskip_vimgrep_pat_ext(char_u *p, char_u **s, int *flags, char_u **nulp, int *cp)\n{\n    int\t\tc;\n\n    if (vim_isIDc(*p))\n    {\n\t// \":vimgrep pattern fname\"\n\tif (s != NULL)\n\t    *s = p;\n\tp = skiptowhite(p);\n\tif (s != NULL && *p != NUL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p++ = NUL;\n\t}\n    }\n    else\n    {\n\t// \":vimgrep /pattern/[g][j] fname\"\n\tif (s != NULL)\n\t    *s = p + 1;\n\tc = *p;\n\tp = skip_regexp(p + 1, c, TRUE);\n\tif (*p != c)\n\t    return NULL;\n\n\t// Truncate the pattern.\n\tif (s != NULL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p = NUL;\n\t}\n\t++p;\n\n\t// Find the flags\n\twhile (*p == 'g' || *p == 'j' || *p == 'f')\n\t{\n\t    if (flags != NULL)\n\t    {\n\t\tif (*p == 'g')\n\t\t    *flags |= VGR_GLOBAL;\n\t\telse if (*p == 'j')\n\t\t    *flags |= VGR_NOJUMP;\n\t\telse\n\t\t    *flags |= VGR_FUZZY;\n\t    }\n\t    ++p;\n\t}\n    }\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * List v:oldfiles in a nice way.\n */\n    void\nex_oldfiles(exarg_T *eap UNUSED)\n{\n    list_T\t*l = get_vim_var_list(VV_OLDFILES);\n    listitem_T\t*li;\n    int\t\tnr = 0;\n    char_u\t*fname;\n\n    if (l == NULL)\n    {\n\tmsg(_(\"No old files\"));\n\treturn;\n    }\n\n    msg_start();\n    msg_scroll = TRUE;\n    for (li = l->lv_first; li != NULL && !got_int; li = li->li_next)\n    {\n\t++nr;\n\tfname = tv_get_string(&li->li_tv);\n\tif (!message_filtered(fname))\n\t{\n\t    msg_outnum((long)nr);\n\t    msg_puts(\": \");\n\t    msg_outtrans(fname);\n\t    msg_clr_eos();\n\t    msg_putchar('\\n');\n\t    out_flush();\t    // output one line at a time\n\t    ui_breakcheck();\n\t}\n    }\n\n    // Assume \"got_int\" was set to truncate the listing.\n    got_int = FALSE;\n\n# ifdef FEAT_BROWSE_CMD\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tquit_more = FALSE;\n\tnr = prompt_for_number(FALSE);\n\tmsg_starthere();\n\tif (nr > 0)\n\t{\n\t    char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t    (long)nr);\n\n\t    if (p != NULL)\n\t    {\n\t\tp = expand_env_save(p);\n\t\teap->arg = p;\n\t\teap->cmdidx = CMD_edit;\n\t\tcmdmod.cmod_flags &= ~CMOD_BROWSE;\n\t\tdo_exedit(eap, NULL);\n\t\tvim_free(p);\n\t    }\n\t}\n    }\n# endif\n}\n#endif\n", "\" Tests for the substitute (:s) command\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\n\" NOTE: This needs to be the first test to be\n\"       run in the file, since it depends on\n\"       that the previous substitution atom\n\"       was not yet set.\n\"\n\" recursive call of :s and sub-replace special\n\" (did cause heap-use-after free in < v9.0.2121)\nfunc Test_aaaa_substitute_expr_recursive_special()\n  func R()\n    \" FIXME: leaving out the 'n' flag leaks memory, why?\n    %s/./\\='.'/gn\n  endfunc\n  new Xfoobar_UAF\n  put ='abcdef'\n  let bufnr = bufnr('%')\n  try\n    silent! :s/./~\\=R()/0\n    \"call assert_fails(':s/./~\\=R()/0', 'E939:')\n    let @/='.'\n    ~g\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565:/\n  endtry\n  delfunc R\n  exe bufnr .. \"bw!\"\nendfunc\n\nfunc Test_multiline_subst()\n  enew!\n  call append(0, [\"1 aa\",\n\t      \\ \"bb\",\n\t      \\ \"cc\",\n\t      \\ \"2 dd\",\n\t      \\ \"ee\",\n\t      \\ \"3 ef\",\n\t      \\ \"gh\",\n\t      \\ \"4 ij\",\n\t      \\ \"5 a8\",\n\t      \\ \"8b c9\",\n\t      \\ \"9d\",\n\t      \\ \"6 e7\",\n\t      \\ \"77f\",\n\t      \\ \"xxxxx\"])\n\n  1\n  \" test if replacing a line break works with a back reference\n  /^1/,/^2/s/\\n\\(.\\)/ \\1/\n  \" test if inserting a line break works with a back reference\n  /^3/,/^4/s/\\(.\\)$/\\r\\1/\n  \" test if replacing a line break with another line break works\n  /^5/,/^6/s/\\(\\_d\\{3}\\)/x\\1x/\n  call assert_equal('1 aa bb cc 2 dd ee', getline(1))\n  call assert_equal('3 e', getline(2))\n  call assert_equal('f', getline(3))\n  call assert_equal('g', getline(4))\n  call assert_equal('h', getline(5))\n  call assert_equal('4 i', getline(6))\n  call assert_equal('j', getline(7))\n  call assert_equal('5 ax8', getline(8))\n  call assert_equal('8xb cx9', getline(9))\n  call assert_equal('9xd', getline(10))\n  call assert_equal('6 ex7', getline(11))\n  call assert_equal('7x7f', getline(12))\n  call assert_equal('xxxxx', getline(13))\n  enew!\nendfunc\n\nfunc Test_substitute_variants()\n  \" Validate that all the 2-/3-letter variants which embed the flags into the\n  \" command name actually work.\n  enew!\n  let ln = 'Testing string'\n  let variants = [\n\t\\ { 'cmd': ':s/Test/test/c', 'exp': 'testing string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ce', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cg', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/t/r/ci', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cI', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/c', 'exp': 'Testing string', 'prompt': 'n' },\n\t\\ { 'cmd': ':s/t/r/cn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cp', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cl', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/gc', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'TestIng string', 'prompt': 'l' },\n\t\\ { 'cmd': ':s/foo/bar/ge', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/g', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gi', 'exp': 'resring srring' },\n\t\\ { 'cmd': ':s/t/r/gI', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/gp', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gl', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s//r/gr', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s/t/r/ic', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/i', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/iI', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/in', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/ip', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s//r/ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/t/r/Ic', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/Ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/Ig', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/Ii', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/I', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Ip', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Il', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s//r/Ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rc', 'exp': 'Testr string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s//r/rg', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s//r/ri', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rI', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rn', 'exp': 'Testing string' },\n\t\\ { 'cmd': ':s//r/rp', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rl', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/r', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'Testing string', 'prompt': 'q' },\n\t\\]\n\n  for var in variants\n    for run in [1, 2]\n      let cmd = var.cmd\n      if run == 2 && cmd =~ \"/.*/.*/.\"\n\t\" Change  :s/from/to/{flags}  to  :s{flags}\n\tlet cmd = substitute(cmd, '/.*/', '', '')\n      endif\n      call setline(1, [ln])\n      let msg = printf('using \"%s\"', cmd)\n      let @/='ing'\n      let v:errmsg = ''\n      call feedkeys(cmd . \"\\<CR>\" . get(var, 'prompt', ''), 'ntx')\n      \" No error should exist (matters for testing e flag)\n      call assert_equal('', v:errmsg, msg)\n      call assert_equal(var.exp, getline('.'), msg)\n    endfor\n  endfor\nendfunc\n\n\" Test the l, p, # flags.\nfunc Test_substitute_flags_lp()\n  new\n  call setline(1, \"abc\\tdef\\<C-h>ghi\")\n\n  let a = execute('s/a/a/p')\n  call assert_equal(\"\\nabc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l')\n  call assert_equal(\"\\nabc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/p#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l#')\n  call assert_equal(\"\\n  1 abc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/')\n  call assert_equal(\"\", a)\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_repeat()\n  \" This caused an invalid memory access.\n  split Xsubfile\n  s/^/x\n  call feedkeys(\"Qsc\\<CR>y\", 'tx')\n  bwipe!\nendfunc\n\" Test %s/\\n// which is implemented as a special case to use a\n\" more efficient join rather than doing a regular substitution.\nfunc Test_substitute_join()\n  new\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//g')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//p')\n  call assert_equal(\"\\nfoo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//l')\n  call assert_equal(\"\\nfoo^Ibarbar^Hfoo$\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//#')\n  call assert_equal(\"\\n  1 foo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  call execute('1,2s/\\n//')\n  call assert_equal(['foobarbaz', 'qux'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_count()\n  new\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2\n\n  s/foo/bar/3\n  call assert_equal(['foo foo', 'bar foo', 'bar foo', 'bar foo', 'foo foo'],\n  \\                 getline(1, '$'))\n\n  call assert_fails('s/foo/bar/0', 'E939:')\n\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2,4s/foo/bar/ 10\n  call assert_equal(['foo foo', 'foo foo', 'foo foo', 'bar foo', 'bar foo'],\n        \\           getline(1, '$'))\n\n  call assert_fails('s/./b/2147483647', 'E1510:')\n  bwipe!\nendfunc\n\n\" Test substitute 'n' flag (report number of matches, do not substitute).\nfunc Test_substitute_flag_n()\n  new\n  let lines = ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo']\n  call setline(1, lines)\n\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/n'))\n  call assert_equal(\"\\n6 matches on 3 lines\", execute('2,4s/foo/bar/gn'))\n\n  \" c flag (confirm) should be ignored when using n flag.\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/nc'))\n\n  \" No substitution should have been done.\n  call assert_equal(lines, getline(1, '$'))\n\n  %delete _\n  call setline(1, ['A', 'Bar', 'Baz'])\n  call assert_equal(\"\\n1 match on 1 line\", execute('s/\\nB\\@=//gn'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_errors()\n  new\n  call setline(1, 'foobar')\n\n  call assert_fails('s/FOO/bar/', 'E486:')\n  call assert_fails('s/foo/bar/@', 'E488:')\n  call assert_fails('s/\\(/bar/', 'E54:')\n  call assert_fails('s afooabara', 'E146:')\n  call assert_fails('s\\\\a', 'E10:')\n\n  setl nomodifiable\n  call assert_fails('s/foo/bar/', 'E21:')\n\n  call assert_fails(\"let s=substitute([], 'a', 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', [], 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', [], 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', 'A', [])\", 'E730:')\n  call assert_fails(\"let s=substitute('abc', '\\\\%(', 'A', 'g')\", 'E53:')\n\n  bwipe!\nendfunc\n\n\" Test for *sub-replace-special* and *sub-replace-expression* on substitute().\nfunc Test_sub_replace_1()\n  \" Run the tests with 'magic' on\n  set magic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal(\"w\\\\w\", substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal(\"x\\<C-M>x\", substitute('xXx', 'X', \"\\r\", ''))\n  call assert_equal(\"YyyY\", substitute('Y', 'Y', '\\L\\uyYy\\l\\EY', ''))\n  call assert_equal(\"zZZz\", substitute('Z', 'Z', '\\U\\lZzZ\\u\\Ez', ''))\n  \" \\v or \\V after $\n  call assert_equal('abxx', substitute('abcd', 'xy$\\v|cd$', 'xx', ''))\n  call assert_equal('abxx', substitute('abcd', 'xy$\\V\\|cd\\$', 'xx', ''))\nendfunc\n\nfunc Test_sub_replace_2()\n  \" Run the tests with 'magic' off\n  set nomagic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"t\\<C-M>t\", substitute('tTt', 'T', \"\\r\", ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal('w\\w', substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal('XxxX', substitute('X', 'X', '\\L\\uxXx\\l\\EX', ''))\n  call assert_equal('yYYy', substitute('Y', 'Y', '\\U\\lYyY\\u\\Ey', ''))\nendfunc\n\nfunc Test_sub_replace_3()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A', '\\=\"\\\\\"', ''))\n  call assert_equal('b\\\\b', substitute('bBb', 'B', '\\=\"\\\\\\\\\"', ''))\n  call assert_equal(\"c\\rc\", substitute('cCc', 'C', \"\\\\=\\\"\\r\\\"\", ''))\n  call assert_equal(\"d\\\\\\rd\", substitute('dDd', 'D', \"\\\\=\\\"\\\\\\\\\\r\\\"\", ''))\n  call assert_equal(\"e\\\\\\\\\\re\", substitute('eEe', 'E', \"\\\\=\\\"\\\\\\\\\\\\\\\\\\r\\\"\", ''))\n  call assert_equal('f\\rf', substitute('fFf', 'F', '\\=\"\\\\r\"', ''))\n  call assert_equal('j\\nj', substitute('jJj', 'J', '\\=\"\\\\n\"', ''))\n  call assert_equal(\"k\\<C-M>k\", substitute('kKk', 'K', '\\=\"\\r\"', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=\"\\n\"', ''))\nendfunc\n\n\" Test for submatch() on substitute().\nfunc Test_sub_replace_4()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\", \"\")', ''))\n  call assert_equal('b\\b', substitute('bBb', 'B',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\\\\\", \"\")', ''))\n  call assert_equal(\"c\\<C-V>\\<C-M>c\", substitute('cCc', 'C', '\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"d\\<C-V>\\<C-M>d\", substitute('dDd', 'D', '\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"e\\\\\\<C-V>\\<C-M>e\", substitute('eEe', 'E', '\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"f\\<C-M>f\", substitute('fFf', 'F', '\\=substitute(submatch(0), \".\", \"\\\\r\", \"\")', ''))\n  call assert_equal(\"j\\nj\", substitute('jJj', 'J', '\\=substitute(submatch(0), \".\", \"\\\\n\", \"\")', ''))\n  call assert_equal(\"k\\rk\", substitute('kKk', 'K', '\\=substitute(submatch(0), \".\", \"\\r\", \"\")', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=substitute(submatch(0), \".\", \"\\n\", \"\")', ''))\nendfunc\n\nfunc Test_sub_replace_5()\n  set magic&\n  set cpo&\n  call assert_equal('A123456789987654321', substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=submatch(0) . submatch(9) . submatch(8) . ' .\n\t\t\\ 'submatch(7) . submatch(6) . submatch(5) . ' .\n\t\t\\ 'submatch(4) . submatch(3) . submatch(2) . submatch(1)',\n\t\t\\ ''))\n   call assert_equal(\"[['A123456789'], ['9'], ['8'], ['7'], ['6'], \" .\n\t\t\\ \"['5'], ['4'], ['3'], ['2'], ['1']]\",\n\t\t\\ substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=string([submatch(0, 1), submatch(9, 1), ' .\n\t\t\\ 'submatch(8, 1), 7->submatch(1), submatch(6, 1), ' .\n\t\t\\ 'submatch(5, 1), submatch(4, 1), submatch(3, 1), ' .\n\t\t\\ 'submatch(2, 1), submatch(1, 1)])',\n\t\t\\ ''))\nendfunc\n\nfunc Test_sub_replace_6()\n  set magic&\n  set cpo+=/\n  call assert_equal('a', substitute('A', 'A', 'a', ''))\n  call assert_equal('%', substitute('B', 'B', '%', ''))\n  set cpo-=/\n  call assert_equal('c', substitute('C', 'C', 'c', ''))\n  call assert_equal('%', substitute('D', 'D', '%', ''))\nendfunc\n\nfunc Test_sub_replace_7()\n  set magic&\n  set cpo&\n  call assert_equal('A\u0016A', substitute('A\u0016A', 'A.', '\\=submatch(0)', ''))\n  call assert_equal(\"B\\nB\", substitute(\"B\\nB\", 'B.', '\\=submatch(0)', ''))\n  call assert_equal(\"['B\\n']B\", substitute(\"B\\nB\", 'B.', '\\=string(submatch(0, 1))', ''))\n  call assert_equal('-abab', substitute('-bb', '\\zeb', 'a', 'g'))\n  call assert_equal('c-cbcbc', substitute('-bb', '\\ze', 'c', 'g'))\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_replace_8()\n  new\n  set magic&\n  set cpo&\n  $put =',,X'\n  s/\\(^\\|,\\)\\ze\\(,\\|X\\)/\\1N/g\n  call assert_equal('N,,NX', getline(\"$\"))\n  $put =',,Y'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Y\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>a\", \"xt\")\n  call assert_equal('N,,NY', getline(\"$\"))\n  :$put =',,Z'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Z\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>yy\", \"xt\")\n  call assert_equal('N,,NZ', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_9()\n  new\n  set magic&\n  set cpo&\n  $put ='xxx'\n  call feedkeys(\":s/x/X/gc\\<CR>yyq\", \"xt\")\n  call assert_equal('XXx', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_10()\n   set magic&\n   set cpo&\n   call assert_equal('a1a2a3a', substitute('123', '\\zs', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '\\zs.', 'a', 'g'))\n   call assert_equal('1a2a3a', substitute('123', '.\\zs', 'a', 'g'))\n   call assert_equal('a1a2a3a', substitute('123', '\\ze', 'a', 'g'))\n   call assert_equal('a1a2a3', substitute('123', '\\ze.', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '.\\ze', 'a', 'g'))\n   call assert_equal('aa2a3a', substitute('123', '1\\|\\ze', 'a', 'g'))\n   call assert_equal('1aaa', substitute('123', '1\\zs\\|[23]', 'a', 'g'))\nendfunc\n\nfunc SubReplacer(text, submatches)\n  return a:text .. a:submatches[0] .. a:text\nendfunc\nfunc SubReplacerVar(text, ...)\n  return a:text .. a:1[0] .. a:text\nendfunc\ndef SubReplacerVar9(text: string, ...args: list<list<string>>): string\n  return text .. args[0][0] .. text\nenddef\nfunc SubReplacer20(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, submatches)\n  return a:t3 .. a:submatches[0] .. a:t11\nendfunc\n\nfunc Test_substitute_partial()\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacer', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar9', ['foo']), 'g'))\n\n  \" 19 arguments plus one is just OK\n  let Replacer = function('SubReplacer20', repeat(['foo'], 19))\n  call assert_equal('1foo2foo3', substitute('123', '2', Replacer, 'g'))\n\n  \" 20 arguments plus one is too many\n  let Replacer = function('SubReplacer20', repeat(['foo'], 20))\n  call assert_fails(\"call substitute('123', '2', Replacer, 'g')\", 'E118:')\nendfunc\n\nfunc Test_substitute_float()\n  call assert_equal('number 1.23', substitute('number ', '$', { -> 1.23 }, ''))\n  vim9 assert_equal('number 1.23', substitute('number ', '$', () => 1.23, ''))\nendfunc\n\n\" Tests for *sub-replace-special* and *sub-replace-expression* on :substitute.\n\n\" Execute a list of :substitute command tests\nfunc Run_SubCmd_Tests(tests)\n  enew!\n  for t in a:tests\n    let start = line('.') + 1\n    let end = start + len(t[2]) - 1\n    exe \"normal o\" . t[0]\n    call cursor(start, 1)\n    exe t[1]\n    call assert_equal(t[2], getline(start, end), t[1])\n  endfor\n  enew!\nendfunc\n\nfunc Test_sub_cmd_1()\n  set magic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['AA']],\n\t      \\ ['B', 's/B/\\&/', ['&']],\n\t      \\ ['C123456789', 's/C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['d']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_2()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['&&']],\n\t      \\ ['B', 's/B/\\&/', ['B']],\n\t      \\ ['C123456789', 's/\\mC\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['~']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_3()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['aAa', \"s/A/\\\\='\\\\'/\", ['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\='\\\\\\\\'/\", ['b\\\\b']],\n\t      \\ ['cCc', \"s/C/\\\\='\\<C-V>\\<C-M>'/\", [\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\='\\\\\\<C-V>\\<C-M>'/\", [\"d\\\\\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\='\\\\\\\\\\<C-V>\\<C-M>'/\", [\"e\\\\\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\='\\r'/\", ['f', 'f']],\n\t      \\ ['gGg', \"s/G/\\\\='\\<C-V>\\<C-J>'/\", [\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', \"s/H/\\\\='\\\\\\<C-V>\\<C-J>'/\", [\"h\\\\\\<C-V>\", 'h']],\n\t      \\ ['iIi', \"s/I/\\\\='\\\\\\\\\\<C-V>\\<C-J>'/\", [\"i\\\\\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\='\\n'/\", ['j', 'j']],\n\t      \\ ['kKk', 's/K/\\=\"\\r\"/', ['k', 'k']],\n\t      \\ ['lLl', 's/L/\\=\"\\n\"/', ['l', 'l']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for submatch() on :substitute.\nfunc Test_sub_cmd_4()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['aAa', \"s/A/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['b\\b']],\n\t      \\ ['cCc', \"s/C/\\\\=substitute(submatch(0), '.', '\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\=substitute(submatch(0), '.', '\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"d\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\=substitute(submatch(0), '.', '\\\\\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"e\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['f', 'f']],\n\t      \\ ['gGg', 's/G/\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', 's/H/\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"h\\<C-V>\", 'h']],\n\t      \\ ['iIi', 's/I/\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"i\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['j', 'j']],\n\t      \\ ['kKk', \"s/K/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['k', 'k']],\n\t      \\ ['lLl', \"s/L/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['l', 'l']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_5()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A123456789', 's/A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)/', ['A123456789987654321']],\n\t      \\ ['B123456789', 's/B\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])/', [\"[['B123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]\"]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_cmd_6()\n  set magic&\n  set cpo+=/\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A', 's/A/a/', ['a']],\n\t      \\ ['B', 's/B/%/', ['a']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo-=/\n  let tests = [ ['C', 's/C/c/', ['c']],\n\t      \\ ['D', 's/D/%/', ['%']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo&\nendfunc\n\n\" Test for :s replacing \\n with  line break.\nfunc Test_sub_cmd_7()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ [\"A\\<C-V>\\<C-M>A\", 's/A./\\=submatch(0)/', ['A', 'A']],\n\t      \\ [\"B\\<C-V>\\<C-J>B\", 's/B./\\=submatch(0)/', ['B', 'B']],\n\t      \\ [\"C\\<C-V>\\<C-J>C\", 's/C./\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['C\\<C-J>']C\")]],\n\t      \\ [\"D\\<C-V>\\<C-J>\\nD\", 's/D.\\nD/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['D\\<C-J>', 'D']\")]],\n\t      \\ [\"E\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>E\", 's/E\\_.\\{-}E/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['E\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>E']\")]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  exe \"normal oQ\\nQ\\<Esc>k\"\n  call assert_fails('s/Q[^\\n]Q/\\=submatch(0).\"foobar\"/', 'E486:')\n  enew!\nendfunc\n\nfunc TitleString()\n  let check = 'foo' =~ 'bar'\n  return \"\"\nendfunc\n\nfunc Test_sub_cmd_8()\n  set titlestring=%{TitleString()}\n\n  enew!\n  call append(0, ['', 'test_one', 'test_two'])\n  call cursor(1,1)\n  /^test_one/s/.*/\\=\"foo\\nbar\"/\n  call assert_equal('foo', getline(2))\n  call assert_equal('bar', getline(3))\n  call feedkeys(':/^test_two/s/.*/\\=\"foo\\nbar\"/c', \"t\")\n  call feedkeys(\"\\<CR>y\", \"xt\")\n  call assert_equal('foo', getline(4))\n  call assert_equal('bar', getline(5))\n\n  enew!\n  set titlestring&\nendfunc\n\nfunc Test_sub_cmd_9()\n  new\n  let input = ['1 aaa', '2 aaa', '3 aaa']\n  call setline(1, input)\n  func Foo()\n    return submatch(0)\n  endfunc\n  %s/aaa/\\=Foo()/gn\n  call assert_equal(input, getline(1, '$'))\n  call assert_equal(1, &modifiable)\n\n  delfunc Foo\n  bw!\nendfunc\n\nfunc Test_sub_highlight_zero_match()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    call setline(1, ['one', 'two', 'three'])\n  END\n  call writefile(lines, 'XscriptSubHighlight', 'D')\n  let buf = RunVimInTerminal('-S XscriptSubHighlight', #{rows: 8, cols: 60})\n  call term_sendkeys(buf, \":%s/^/   /c\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_sub_highlight_zer_match_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_nocatch_sub_failure_handling()\n  \" normal error results in all replacements\n  func Foo()\n    foobar\n  endfunc\n  new\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  \" need silent! to avoid a delay when entering Insert mode\n  silent! %s/aaa/\\=Foo()/g\n  call assert_equal(['1 0', '2 0', '3 0'], getline(1, 3))\n\n  \" Throw without try-catch causes abort after the first line.\n  \" We cannot test this, since it would stop executing the test script.\n\n  \" try/catch does not result in any changes\n  func! Foo()\n    throw 'error'\n  endfunc\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/g\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  \" Same, but using \"n\" flag so that \"sandbox\" gets set\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/gn\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  delfunc Foo\n  bwipe!\nendfunc\n\n\" Test \":s/pat/sub/\" with different ~s in sub.\nfunc Test_replace_with_tilde()\n  new\n  \" Set the last replace string to empty\n  s/^$//\n  call append(0, ['- Bug in \"vPPPP\" on this text:'])\n  normal gg\n  s/u/~u~/\n  call assert_equal('- Bug in \"vPPPP\" on this text:', getline(1))\n  s/i/~u~/\n  call assert_equal('- Bug uuun \"vPPPP\" on this text:', getline(1))\n  s/o/~~~/\n  call assert_equal('- Bug uuun \"vPPPP\" uuuuuuuuun this text:', getline(1))\n  close!\nendfunc\n\nfunc Test_replace_keeppatterns()\n  new\n  a\nfoobar\n\nsubstitute foo asdf\n\none two\n.\n\n  normal gg\n  /^substitute\n  s/foo/bar/\n  call assert_equal('foo', @/)\n  call assert_equal('substitute bar asdf', getline('.'))\n\n  /^substitute\n  keeppatterns s/asdf/xyz/\n  call assert_equal('^substitute', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n\n  exe \"normal /bar /e\\<CR>\"\n  call assert_equal(15, col('.'))\n  normal -\n  keeppatterns /xyz\n  call assert_equal('bar ', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n  exe \"normal 0dn\"\n  call assert_equal('xyz', getline('.'))\n\n  close!\nendfunc\n\nfunc Test_sub_beyond_end()\n  new\n  call setline(1, '#')\n  let @/ = '^#\\n\\zs'\n  s///e\n  call assert_equal('#', getline(1))\n  bwipe!\nendfunc\n\n\" Test for repeating last substitution using :~ and :&r\nfunc Test_repeat_last_sub()\n  new\n  call setline(1, ['blue green yellow orange white'])\n  s/blue/red/\n  let @/ = 'yellow'\n  ~\n  let @/ = 'white'\n  :&r\n  let @/ = 'green'\n  s//gray\n  call assert_equal('red gray red orange red', getline(1))\n  close!\nendfunc\n\n\" Test for Vi compatible substitution:\n\"     \\/{string}/, \\?{string}? and \\&{string}&\nfunc Test_sub_vi_compatibility()\n  new\n  call setline(1, ['blue green yellow orange blue'])\n  let @/ = 'orange'\n  s\\/white/\n  let @/ = 'blue'\n  s\\?amber?\n  let @/ = 'white'\n  s\\&green&\n  call assert_equal('amber green yellow white green', getline(1))\n  close!\n\n  call assert_fails('vim9cmd s\\/white/', 'E1270:')\n  call assert_fails('vim9cmd s\\?white?', 'E1270:')\n  call assert_fails('vim9cmd s\\&white&', 'E1270:')\nendfunc\n\n\" Test for substitute with the new text longer than the original text\nfunc Test_sub_expand_text()\n  new\n  call setline(1, 'abcabcabcabcabcabcabcabc')\n  s/b/\\=repeat('B', 10)/g\n  call assert_equal(repeat('aBBBBBBBBBBc', 8), getline(1))\n  close!\nendfunc\n\n\" Test for command failures when the last substitute pattern is not set.\nfunc Test_sub_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('~', 'E33:')\n    call assert_fails('s//abc/g', 'E35:')\n    call assert_fails('s\\/bar', 'E35:')\n    call assert_fails('s\\&bar&', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  let lines =<< trim [SCRIPT]\n    set cpo+=/\n    call assert_fails('s/abc/%/', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\nfunc Test_substitute()\n  call assert_equal('a\uff11a\uff12a\uff13a', substitute('\uff11\uff12\uff13', '\\zs', 'a', 'g'))\n  \" Substitute with special keys\n  call assert_equal(\"a\\<End>c\", substitute('abc', \"a.c\", \"a\\<End>c\", ''))\nendfunc\n\nfunc Test_substitute_expr()\n  let g:val = 'XXX'\n  call assert_equal('XXX', substitute('yyy', 'y*', '\\=g:val', ''))\n  call assert_equal('XXX', substitute('yyy', 'y*', {-> g:val}, ''))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ '\\=nr2char(\"0x\" . submatch(1))', 'g'))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ {-> nr2char(\"0x\" . submatch(1))}, 'g'))\n\n  call assert_equal('231', substitute('123', '\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))\n\n  func Recurse()\n    return substitute('yyy', 'y\\(.\\)y', {-> submatch(1)}, '')\n  endfunc\n  \" recursive call works\n  call assert_equal('-y-x-', substitute('xxx', 'x\\(.\\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))\n\n  call assert_fails(\"let s=submatch([])\", 'E745:')\n  call assert_fails(\"let s=submatch(2, [])\", 'E745:')\nendfunc\n\nfunc Test_invalid_submatch()\n  \" This was causing invalid memory access in Vim-7.4.2232 and older\n  call assert_fails(\"call substitute('x', '.', {-> submatch(10)}, '')\", 'E935:')\n  call assert_fails('eval submatch(-1)', 'E935:')\n  call assert_equal('', submatch(0))\n  call assert_equal('', submatch(1))\n  call assert_equal([], submatch(0, 1))\n  call assert_equal([], submatch(1, 1))\nendfunc\n\nfunc Test_submatch_list_concatenate()\n  let pat = 'A\\(.\\)'\n  let Rep = {-> string([submatch(0, 1)] + [[submatch(1)]])}\n  call substitute('A1', pat, Rep, '')->assert_equal(\"[['A1'], ['1']]\")\nendfunc\n\nfunc Test_substitute_expr_arg()\n  call assert_equal('123456789-123456789=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456-123456=789', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(a*\\)\\(n*\\)\\(.\\)\\(.\\)\\(.\\)\\(x*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456789-123456789x=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . 'x' . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(add(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(insert(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(extend(m, ['x']))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(remove(m, 1))}, '')\", 'E742:')\nendfunc\n\n\" Test for using a function to supply the substitute string\nfunc Test_substitute_using_func()\n  func Xfunc()\n    return '1234'\n  endfunc\n  call assert_equal('a1234f', substitute('abcdef', 'b..e',\n        \\ function(\"Xfunc\"), ''))\n  delfunc Xfunc\nendfunc\n\n\" Test for using submatch() with a multiline match\nfunc Test_substitute_multiline_submatch()\n  new\n  call setline(1, ['line1', 'line2', 'line3', 'line4'])\n  %s/^line1\\(\\_.\\+\\)line4$/\\=submatch(1)/\n  call assert_equal(['', 'line2', 'line3', ''], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_substitute_skipped_range()\n  new\n  if 0\n    /1/5/2/2/\\n\n  endif\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  bwipe!\nendfunc\n\n\" Test using the 'gdefault' option (when on, flag 'g' is default on).\nfunc Test_substitute_gdefault()\n  new\n\n  \" First check without 'gdefault'\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar foo', getline(1))\n\n  \" Then check with 'gdefault'\n  set gdefault\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar FOO', getline(1))\n\n  \" Setting 'compatible' should reset 'gdefault'\n  call assert_equal(1, &gdefault)\n  set compatible\n  call assert_equal(0, &gdefault)\n  set nocompatible\n  call assert_equal(0, &gdefault)\n\n  bw!\nendfunc\n\n\" This was using \"old_sub\" after it was freed.\nfunc Test_using_old_sub()\n  set compatible maxfuncdepth=10\n  new\n  call setline(1, 'some text.')\n  func Repl()\n    ~\n    s/\n  endfunc\n  silent! s/\\%')/\\=Repl()\n\n  delfunc Repl\n  bwipe!\n  set nocompatible\nendfunc\n\n\" This was switching windows in between computing the length and using it.\nfunc Test_sub_change_window()\n  silent! lfile\n  sil! norm o0000000000000000000000000000000000000000000000000000\n  func Repl()\n    lopen\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n  bwipe!\n  bwipe!\n  delfunc Repl\nendfunc\n\n\" This was undoign a change in between computing the length and using it.\nfunc Do_Test_sub_undo_change()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  silent! s/\\%')/\\=Repl()\n  bwipe!\nendfunc\n\nfunc Test_sub_undo_change()\n  func Repl()\n    silent! norm g-\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  func! Repl()\n    silent earlier\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  delfunc Repl\nendfunc\n\n\" This was opening a command line window from the expression\nfunc Test_sub_open_cmdline_win()\n  \" the error only happens in a very specific setup, run a new Vim instance to\n  \" get a clean starting point.\n  let lines =<< trim [SCRIPT]\n    set vb t_vb=\n    norm o0000000000000000000000000000000000000000000000000000\n    func Replace()\n      norm q/\n    endfunc\n    s/\\%')/\\=Replace()\n    redir >Xresult\n    messages\n    redir END\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '-u NONE -S Xscript')\n    call assert_match('E565: Not allowed to change text or change window',\n          \\ readfile('Xresult')->join('XX'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\n\" This was editing a script file from the expression\nfunc Test_sub_edit_scriptfile()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  func EditScript()\n    silent! scr! Xsedfile\n  endfunc\n  s/\\%')/\\=EditScript()\n\n  delfunc EditScript\n  bwipe!\nendfunc\n\n\" This was editing another file from the expression.\nfunc Test_sub_expr_goto_other_file()\n  call writefile([''], 'Xfileone', 'D')\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd',\n\t\\ 'Xfileone zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'])\n\n  func g:SplitGotoFile()\n    exe \"sil! norm 0\\<C-W>gf\"\n    return ''\n  endfunc\n\n  $\n  s/\\%')/\\=g:SplitGotoFile()\n\n  delfunc g:SplitGotoFile\n  bwipe!\nendfunc\n\nfunc Test_recursive_expr_substitute()\n  \" this was reading invalid memory\n  let lines =<< trim END\n      func Repl(g, n)\n        s\n        r%:s000\n      endfunc\n      next 0\n      let caught = 0\n      s/\\%')/\\=Repl(0, 0)\n      qall!\n  END\n  call writefile(lines, 'XexprSubst', 'D')\n  call RunVim([], [], '--clean -S XexprSubst')\nendfunc\n\n\" Test for the 2-letter and 3-letter :substitute commands\nfunc Test_substitute_short_cmd()\n  new\n  call setline(1, ['one', 'one one one'])\n  s/one/two\n  call cursor(2, 1)\n\n  \" :sc\n  call feedkeys(\":sc\\<CR>y\", 'xt')\n  call assert_equal('two one one', getline(2))\n\n  \" :scg\n  call setline(2, 'one one one')\n  call feedkeys(\":scg\\<CR>nyq\", 'xt')\n  call assert_equal('one two one', getline(2))\n\n  \" :sci\n  call setline(2, 'ONE One onE')\n  call feedkeys(\":sci\\<CR>y\", 'xt')\n  call assert_equal('two One onE', getline(2))\n\n  \" :scI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  call feedkeys(\":scI\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :scn\n  call setline(2, 'one one one')\n  let t = execute('scn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :scp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scp\\<CR>y\", 'xt')\n  redir END\n  call assert_equal('        two one one', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :scl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scl\\<CR>y\", 'xt')\n  redir END\n  call assert_equal(\"^Itwo one one$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :sgc\n  call setline(2, 'one one one one one')\n  call feedkeys(\":sgc\\<CR>nyyq\", 'xt')\n  call assert_equal('one two two one one', getline(2))\n\n  \" :sg\n  call setline(2, 'one one one')\n  sg\n  call assert_equal('two two two', getline(2))\n\n  \" :sgi\n  call setline(2, 'ONE One onE')\n  sgi\n  call assert_equal('two two two', getline(2))\n\n  \" :sgI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  sgI\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :sgn\n  call setline(2, 'one one one')\n  let t = execute('sgn')->split(\"\\n\")\n  call assert_equal(['3 matches on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :sgp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgp\n  redir END\n  call assert_equal('        two two two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgl\n  redir END\n  call assert_equal(\"^Itwo two two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgr\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sgr\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sic\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sic\\<CR>y\", 'xt')\n  call assert_equal('two One one', getline(2))\n\n  \" :si\n  call setline(2, \"ONE One one\")\n  si\n  call assert_equal('two One one', getline(2))\n\n  \" :siI\n  call setline(2, \"ONE One one\")\n  siI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sin\n  call setline(2, 'ONE One onE')\n  let t = execute('sin')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One onE', getline(2))\n\n  \" :sip\n  call setline(2, \"\\tONE One onE\")\n  redir => output\n  sip\n  redir END\n  call assert_equal('        two One onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo One onE\", getline(2))\n\n  \" :sir\n  call setline(2, \"ONE One onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sir\n  call assert_equal('xyz One onE', getline(2))\n\n  \" :sIc\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sIc\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIg\n  call setline(2, \"ONE one onE one\")\n  sIg\n  call assert_equal('ONE two onE two', getline(2))\n\n  \" :sIi\n  call setline(2, \"ONE One one\")\n  sIi\n  call assert_equal('two One one', getline(2))\n\n  \" :sI\n  call setline(2, \"ONE One one\")\n  sI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIn\n  call setline(2, 'ONE One one')\n  let t = execute('sIn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One one', getline(2))\n\n  \" :sIp\n  call setline(2, \"\\tONE One one\")\n  redir => output\n  sIp\n  redir END\n  call assert_equal('        ONE One two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE One two\", getline(2))\n\n  \" :sIl\n  call setline(2, \"\\tONE onE one\")\n  redir => output\n  sIl\n  redir END\n  call assert_equal(\"^IONE onE two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE onE two\", getline(2))\n\n  \" :sIr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sIr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :src\n  call setline(2, \"ONE one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  call feedkeys(\":src\\<CR>y\", 'xt')\n  call assert_equal('ONE xyz one', getline(2))\n\n  \" :srg\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srg\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sri\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sri\n  call assert_equal('xyz one onE', getline(2))\n\n  \" :srI\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srI\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :srn\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  let t = execute('srn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE one onE', getline(2))\n\n  \" :srp\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srp\n  redir END\n  call assert_equal('        ONE xyz onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :srl\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srl\n  redir END\n  call assert_equal(\"^IONE xyz onE$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :sr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :sce\n  s/abc/xyz/e\n  call assert_fails(\"sc\", 'E486:')\n  sce\n  \" :sge\n  call assert_fails(\"sg\", 'E486:')\n  sge\n  \" :sie\n  call assert_fails(\"si\", 'E486:')\n  sie\n  \" :sIe\n  call assert_fails(\"sI\", 'E486:')\n  sIe\n\n  bw!\nendfunc\n\n\" Check handling expanding \"~\" resulting in extremely long text.\n\" FIXME: disabled, it takes too long to run on CI\n\"func Test_substitute_tilde_too_long()\n\"  enew!\n\"\n\"  s/.*/ixxx\n\"  s//~~~~~~~~~AAAAAAA@(\n\"\n\"  \" Either fails with \"out of memory\" or \"text too long\".\n\"  \" This can take a long time.\n\"  call assert_fails('sil! norm &&&&&&&&&', ['E1240:\\|E342:'])\n\"\n\"  bwipe!\n\"endfunc\n\n\" This should be done last to reveal a memory leak when vim_regsub_both() is\n\" called to evaluate an expression but it is not used in a second call.\nfunc Test_z_substitute_expr_leak()\n  func SubExpr()\n    ~n\n  endfunc\n  silent! s/\\%')/\\=SubExpr()\n  delfunc SubExpr\nendfunc\n\nfunc Test_substitute_expr_switch_win()\n  func R()\n    wincmd x\n    return 'XXXX'\n  endfunc\n  new Xfoobar\n  let bufnr = bufnr('%')\n  put ='abcdef'\n  silent! s/\\%')/\\=R()\n  call assert_fails(':%s/./\\=R()/g', 'E565:')\n  delfunc R\n  exe bufnr .. \"bw!\"\nendfunc\n\n\" recursive call of :s using test-replace special\nfunc Test_substitute_expr_recursive()\n  func Q()\n    %s/./\\='foobar'/gn\n    return \"foobar\"\n  endfunc\n  func R()\n    %s/./\\=Q()/g\n  endfunc\n  new Xfoobar_UAF\n  let bufnr = bufnr('%')\n  put ='abcdef'\n  silent! s/./\\=R()/g\n  call assert_fails(':%s/./\\=R()/g', 'E565:')\n  delfunc R\n  delfunc Q\n  exe bufnr .. \"bw!\"\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/ex_cmds.c", "src/testdir/test_substitute.vim", "src/version.c"], "buggy_code_start_loc": [3740, 5, 706], "buggy_code_end_loc": [4969, 1456, 706], "fixing_code_start_loc": [3739, 6, 707], "fixing_code_end_loc": [4993, 1501, 709], "type": "CWE-416", "message": "Vim is a UNIX editor that, prior to version 9.0.2121, has a heap-use-after-free vulnerability. When executing a `:s` command for the very first time and using a sub-replace-special atom inside the substitution part, it is possible that the recursive `:s` call causes free-ing of memory which may later then be accessed by the initial `:s` command. The user must intentionally execute the payload and the whole process is a bit tricky to do since it seems to work only reliably for the very first :s command. It may also cause a crash of Vim. Version 9.0.2121 contains a fix for this issue.", "other": {"cve": {"id": "CVE-2023-48706", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-22T22:15:08.673", "lastModified": "2024-01-05T18:15:29.133", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Vim is a UNIX editor that, prior to version 9.0.2121, has a heap-use-after-free vulnerability. When executing a `:s` command for the very first time and using a sub-replace-special atom inside the substitution part, it is possible that the recursive `:s` call causes free-ing of memory which may later then be accessed by the initial `:s` command. The user must intentionally execute the payload and the whole process is a bit tricky to do since it seems to work only reliably for the very first :s command. It may also cause a crash of Vim. Version 9.0.2121 contains a fix for this issue."}, {"lang": "es", "value": "Vim es un editor UNIX que, antes de la versi\u00f3n 9.0.2121, tiene una vulnerabilidad de heap-use-after-free. Al ejecutar un comando `:s` por primera vez y utilizar un \u00e1tomo subreemplazante especial dentro de la parte de sustituci\u00f3n, es posible que la llamada recursiva `:s` provoque la liberaci\u00f3n de memoria a la que luego se podr\u00e1 acceder por el comando inicial `:s`. El usuario debe ejecutar intencionalmente el payload y todo el proceso es un poco complicado de realizar ya que parece funcionar solo de manera confiable para el primer comando :s. Tambi\u00e9n puede provocar un bloqueo de Vim. La versi\u00f3n 9.0.2121 contiene una soluci\u00f3n para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 3.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.2121", "matchCriteriaId": "F978DA02-FB07-40A0-BD9E-CAC3945B4E2D"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/11/22/3", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/gandalf4a/crash_report/blob/main/vim/vim_huaf", "source": "security-advisories@github.com", "tags": ["Exploit"]}, {"url": "https://github.com/vim/vim/commit/26c11c56888d01e298cd8044caf860f3c26f57bb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vim/vim/pull/13552", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/vim/vim/security/advisories/GHSA-c8qm-x72m-q53q", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DNMFS3IH74KEMMESOA3EOB6MZ56TWGFF/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IVA7K73WHQH4KVFDJQ7ELIUD2WK5ZT5E/", "source": "security-advisories@github.com"}, {"url": "https://security.netapp.com/advisory/ntap-20240105-0001/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/vim/vim/commit/26c11c56888d01e298cd8044caf860f3c26f57bb"}}