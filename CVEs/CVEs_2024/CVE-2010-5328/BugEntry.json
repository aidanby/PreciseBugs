{"buggy_code": ["/*\n *  linux/kernel/fork.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also entry.S and others).\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'\n */\n\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/tracehook.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/ftrace.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/random.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/blkdev.h>\n#include <linux/fs_struct.h>\n#include <linux/magic.h>\n#include <linux/perf_event.h>\n#include <linux/posix-timers.h>\n#include <linux/user-return-notifier.h>\n\n#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n#include <trace/events/sched.h>\n\n/*\n * Protected counters by write_lock_irq(&tasklist_lock)\n */\nunsigned long total_forks;\t/* Handle normal Linux uptimes. */\nint nr_threads; \t\t/* The idle threads do not count.. */\n\nint max_threads;\t\t/* tunable limit on nr_threads */\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */\n\n#ifdef CONFIG_PROVE_RCU\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}\nEXPORT_SYMBOL_GPL(lockdep_tasklist_lock_is_held);\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\nint nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n# define alloc_task_struct()\tkmem_cache_alloc(task_struct_cachep, GFP_KERNEL)\n# define free_task_struct(tsk)\tkmem_cache_free(task_struct_cachep, (tsk))\nstatic struct kmem_cache *task_struct_cachep;\n#endif\n\n#ifndef __HAVE_ARCH_THREAD_INFO_ALLOCATOR\nstatic inline struct thread_info *alloc_thread_info(struct task_struct *tsk)\n{\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tgfp_t mask = GFP_KERNEL | __GFP_ZERO;\n#else\n\tgfp_t mask = GFP_KERNEL;\n#endif\n\treturn (struct thread_info *)__get_free_pages(mask, THREAD_SIZE_ORDER);\n}\n\nstatic inline void free_thread_info(struct thread_info *ti)\n{\n\tfree_pages((unsigned long)ti, THREAD_SIZE_ORDER);\n}\n#endif\n\n/* SLAB cache for signal_struct structures (tsk->signal) */\nstatic struct kmem_cache *signal_cachep;\n\n/* SLAB cache for sighand_struct structures (tsk->sighand) */\nstruct kmem_cache *sighand_cachep;\n\n/* SLAB cache for files_struct structures (tsk->files) */\nstruct kmem_cache *files_cachep;\n\n/* SLAB cache for fs_struct structures (tsk->fs) */\nstruct kmem_cache *fs_cachep;\n\n/* SLAB cache for vm_area_struct structures */\nstruct kmem_cache *vm_area_cachep;\n\n/* SLAB cache for mm_struct structures (tsk->mm) */\nstatic struct kmem_cache *mm_cachep;\n\nstatic void account_kernel_stack(struct thread_info *ti, int account)\n{\n\tstruct zone *zone = page_zone(virt_to_page(ti));\n\n\tmod_zone_page_state(zone, NR_KERNEL_STACK, account);\n}\n\nvoid free_task(struct task_struct *tsk)\n{\n\tprop_local_destroy_single(&tsk->dirties);\n\taccount_kernel_stack(tsk->stack, -1);\n\tfree_thread_info(tsk->stack);\n\trt_mutex_debug_task_free(tsk);\n\tftrace_graph_exit_task(tsk);\n\tfree_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\nstatic inline void free_signal_struct(struct signal_struct *sig)\n{\n\ttaskstats_tgid_free(sig);\n\tkmem_cache_free(signal_cachep, sig);\n}\n\nstatic inline void put_signal_struct(struct signal_struct *sig)\n{\n\tif (atomic_dec_and_test(&sig->sigcnt))\n\t\tfree_signal_struct(sig);\n}\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}\n\n/*\n * macro override instead of weak attribute alias, to workaround\n * gcc 4.1.0 and 4.1.1 bugs with weak attribute and empty functions.\n */\n#ifndef arch_task_cache_init\n#define arch_task_cache_init()\n#endif\n\nvoid __init fork_init(unsigned long mempages)\n{\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN\tL1_CACHE_BYTES\n#endif\n\t/* create a slab on which task_structs can be allocated */\n\ttask_struct_cachep =\n\t\tkmem_cache_create(\"task_struct\", sizeof(struct task_struct),\n\t\t\tARCH_MIN_TASKALIGN, SLAB_PANIC | SLAB_NOTRACK, NULL);\n#endif\n\n\t/* do the arch specific task caches init */\n\tarch_task_cache_init();\n\n\t/*\n\t * The default maximum number of threads is set to a safe\n\t * value: the thread structures can take up at most half\n\t * of memory.\n\t */\n\tmax_threads = mempages / (8 * THREAD_SIZE / PAGE_SIZE);\n\n\t/*\n\t * we need to allow at least 20 threads to boot a system\n\t */\n\tif(max_threads < 20)\n\t\tmax_threads = 20;\n\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =\n\t\tinit_task.signal->rlim[RLIMIT_NPROC];\n}\n\nint __attribute__((weak)) arch_dup_task_struct(struct task_struct *dst,\n\t\t\t\t\t       struct task_struct *src)\n{\n\t*dst = *src;\n\treturn 0;\n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\n\tint err;\n\n\tprepare_to_copy(orig);\n\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\n\ttsk->stack = ti;\n\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\n\t/* One for us, one for whoever does the \"release_task()\" (usually parent) */\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\n\taccount_kernel_stack(ti, 1);\n\n\treturn tsk;\n\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}\n\n#ifdef CONFIG_MMU\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tstruct mempolicy *pol;\n\n\tdown_write(&oldmm->mmap_sem);\n\tflush_cache_dup_mm(oldmm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tdown_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);\n\n\tmm->locked_vm = 0;\n\tmm->mmap = NULL;\n\tmm->mmap_cache = NULL;\n\tmm->free_area_cache = oldmm->mmap_base;\n\tmm->cached_hole_size = ~0UL;\n\tmm->map_count = 0;\n\tcpumask_clear(mm_cpumask(mm));\n\tmm->mm_rb = RB_ROOT;\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\tretval = ksm_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tlong pages = vma_pages(mpnt);\n\t\t\tmm->total_vm -= pages;\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, mpnt->vm_file,\n\t\t\t\t\t\t\t\t-pages);\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned int len = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;\n\t\t\tif (security_vm_enough_memory(len))\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\t*tmp = *mpnt;\n\t\tINIT_LIST_HEAD(&tmp->anon_vma_chain);\n\t\tpol = mpol_dup(vma_policy(mpnt));\n\t\tretval = PTR_ERR(pol);\n\t\tif (IS_ERR(pol))\n\t\t\tgoto fail_nomem_policy;\n\t\tvma_set_policy(tmp, pol);\n\t\tif (anon_vma_fork(tmp, mpnt))\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\ttmp->vm_flags &= ~VM_LOCKED;\n\t\ttmp->vm_mm = mm;\n\t\ttmp->vm_next = NULL;\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file->f_path.dentry->d_inode;\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tatomic_dec(&inode->i_writecount);\n\t\t\tspin_lock(&mapping->i_mmap_lock);\n\t\t\tif (tmp->vm_flags & VM_SHARED)\n\t\t\t\tmapping->i_mmap_writable++;\n\t\t\ttmp->vm_truncate_count = mpnt->vm_truncate_count;\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tvma_prio_tree_add(tmp, mpnt);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\tspin_unlock(&mapping->i_mmap_lock);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tretval = copy_page_range(mm, oldmm, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tarch_dup_mmap(oldmm, mm);\n\tretval = 0;\nout:\n\tup_write(&mm->mmap_sem);\n\tflush_tlb_mm(oldmm);\n\tup_write(&oldmm->mmap_sem);\n\treturn retval;\nfail_nomem_anon_vma_fork:\n\tmpol_put(pol);\nfail_nomem_policy:\n\tkmem_cache_free(vm_area_cachep, tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct * mm)\n{\n\tmm->pgd = pgd_alloc(mm);\n\tif (unlikely(!mm->pgd))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct * mm)\n{\n\tpgd_free(mm, mm->pgd);\n}\n#else\n#define dup_mmap(mm, oldmm)\t(0)\n#define mm_alloc_pgd(mm)\t(0)\n#define mm_free_pgd(mm)\n#endif /* CONFIG_MMU */\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\n#define allocate_mm()\t(kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)\t(kmem_cache_free(mm_cachep, (mm)))\n\nstatic unsigned long default_dump_filter = MMF_DUMP_FILTER_DEFAULT;\n\nstatic int __init coredump_filter_setup(char *s)\n{\n\tdefault_dump_filter =\n\t\t(simple_strtoul(s, NULL, 0) << MMF_DUMP_FILTER_SHIFT) &\n\t\tMMF_DUMP_FILTER_MASK;\n\treturn 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>\n\nstatic void mm_init_aio(struct mm_struct *mm)\n{\n#ifdef CONFIG_AIO\n\tspin_lock_init(&mm->ioctx_lock);\n\tINIT_HLIST_HEAD(&mm->ioctx_list);\n#endif\n}\n\nstatic struct mm_struct * mm_init(struct mm_struct * mm, struct task_struct *p)\n{\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->flags = (current->mm) ?\n\t\t(current->mm->flags & MMF_INIT_MASK) : default_dump_filter;\n\tmm->core_state = NULL;\n\tmm->nr_ptes = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm->free_area_cache = TASK_UNMAPPED_BASE;\n\tmm->cached_hole_size = ~0UL;\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\n\tif (likely(!mm_alloc_pgd(mm))) {\n\t\tmm->def_flags = 0;\n\t\tmmu_notifier_mm_init(mm);\n\t\treturn mm;\n\t}\n\n\tfree_mm(mm);\n\treturn NULL;\n}\n\n/*\n * Allocate and initialize an mm_struct.\n */\nstruct mm_struct * mm_alloc(void)\n{\n\tstruct mm_struct * mm;\n\n\tmm = allocate_mm();\n\tif (mm) {\n\t\tmemset(mm, 0, sizeof(*mm));\n\t\tmm = mm_init(mm, current);\n\t}\n\treturn mm;\n}\n\n/*\n * Called when the last reference to the mm\n * is dropped: either by a lazy thread or by\n * mmput. Free the page directory and the mm.\n */\nvoid __mmdrop(struct mm_struct *mm)\n{\n\tBUG_ON(mm == &init_mm);\n\tmm_free_pgd(mm);\n\tdestroy_context(mm);\n\tmmu_notifier_mm_destroy(mm);\n\tfree_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\n/*\n * Decrement the use count and release all resources for an mm.\n */\nvoid mmput(struct mm_struct *mm)\n{\n\tmight_sleep();\n\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\texit_aio(mm);\n\t\tksm_exit(mm);\n\t\texit_mmap(mm);\n\t\tset_mm_exe_file(mm, NULL);\n\t\tif (!list_empty(&mm->mmlist)) {\n\t\t\tspin_lock(&mmlist_lock);\n\t\t\tlist_del(&mm->mmlist);\n\t\t\tspin_unlock(&mmlist_lock);\n\t\t}\n\t\tput_swap_token(mm);\n\t\tif (mm->binfmt)\n\t\t\tmodule_put(mm->binfmt->module);\n\t\tmmdrop(mm);\n\t}\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n/**\n * get_task_mm - acquire a reference to the task's mm\n *\n * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning\n * this kernel workthread has transiently adopted a user mm with use_mm,\n * to do its AIO) is not set and if so returns a reference to it, after\n * bumping up the use count.  User must release the mm via mmput()\n * after use.  Typically used by /proc and ptrace.\n */\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tatomic_inc(&mm->mm_users);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\n/* Please note the differences between mmput and mm_release.\n * mmput is called whenever we stop holding onto a mm_struct,\n * error success whatever.\n *\n * mm_release is called after a mm_struct has been removed\n * from the current process.\n *\n * This difference is important for error handling, when we\n * only half set up a mm_struct for a new process and need to restore\n * the old one.  Because we mmput the new mm_struct before\n * restoring the old one. . .\n * Eric Biederman 10 January 1998\n */\nvoid mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct completion *vfork_done = tsk->vfork_done;\n\n\t/* Get rid of any futexes when releasing the mm */\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list)) {\n\t\texit_robust_list(tsk);\n\t\ttsk->robust_list = NULL;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list)) {\n\t\tcompat_exit_robust_list(tsk);\n\t\ttsk->compat_robust_list = NULL;\n\t}\n#endif\n\tif (unlikely(!list_empty(&tsk->pi_state_list)))\n\t\texit_pi_state_list(tsk);\n#endif\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/* notify parent sleeping on vfork() */\n\tif (vfork_done) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork_done);\n\t}\n\n\t/*\n\t * If we're exiting normally, clear a user-space tid field if\n\t * requested.  We leave this alone when dying by signal, to leave\n\t * the value intact in a core dump, and to save the unnecessary\n\t * trouble otherwise.  Userland only wants this done for a sys_exit.\n\t */\n\tif (tsk->clear_child_tid) {\n\t\tif (!(tsk->flags & PF_SIGNALED) &&\n\t\t    atomic_read(&mm->mm_users) > 1) {\n\t\t\t/*\n\t\t\t * We don't check the error code - if userspace has\n\t\t\t * not set up a proper pointer then tough luck.\n\t\t\t */\n\t\t\tput_user(0, tsk->clear_child_tid);\n\t\t\tsys_futex(tsk->clear_child_tid, FUTEX_WAKE,\n\t\t\t\t\t1, NULL, NULL, 0);\n\t\t}\n\t\ttsk->clear_child_tid = NULL;\n\t}\n}\n\n/*\n * Allocate a new mm structure and copy contents from the\n * mm structure of the passed in task structure.\n */\nstruct mm_struct *dup_mm(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm = current->mm;\n\tint err;\n\n\tif (!oldmm)\n\t\treturn NULL;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\t/* Initializing for Swap token stuff */\n\tmm->token_priority = 0;\n\tmm->last_interval = 0;\n\n\tif (!mm_init(mm, tsk))\n\t\tgoto fail_nomem;\n\n\tif (init_new_context(tsk, mm))\n\t\tgoto fail_nocontext;\n\n\tdup_mm_exe_file(oldmm, mm);\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\tif (mm->binfmt && !try_module_get(mm->binfmt->module))\n\t\tgoto free_pt;\n\n\treturn mm;\n\nfree_pt:\n\t/* don't put binfmt in mmput, we haven't got module yet */\n\tmm->binfmt = NULL;\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n\nfail_nocontext:\n\t/*\n\t * If init_new_context() failed, we cannot use mmput() to free the mm\n\t * because it calls destroy_context()\n\t */\n\tmm_free_pgd(mm);\n\tfree_mm(mm);\n\treturn NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct * tsk)\n{\n\tstruct mm_struct * mm, *oldmm;\n\tint retval;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n#endif\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\tif (clone_flags & CLONE_VM) {\n\t\tatomic_inc(&oldmm->mm_users);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\n\tretval = -ENOMEM;\n\tmm = dup_mm(tsk);\n\tif (!mm)\n\t\tgoto fail_nomem;\n\ngood_mm:\n\t/* Initializing for Swap token stuff */\n\tmm->token_priority = 0;\n\tmm->last_interval = 0;\n\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\treturn 0;\n\nfail_nomem:\n\treturn retval;\n}\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct fs_struct *fs = current->fs;\n\tif (clone_flags & CLONE_FS) {\n\t\t/* tsk->fs is already what we want */\n\t\twrite_lock(&fs->lock);\n\t\tif (fs->in_exec) {\n\t\t\twrite_unlock(&fs->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tfs->users++;\n\t\twrite_unlock(&fs->lock);\n\t\treturn 0;\n\t}\n\ttsk->fs = copy_fs_struct(fs);\n\tif (!tsk->fs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct * tsk)\n{\n\tstruct files_struct *oldf, *newf;\n\tint error = 0;\n\n\t/*\n\t * A background process may not have any files ...\n\t */\n\toldf = current->files;\n\tif (!oldf)\n\t\tgoto out;\n\n\tif (clone_flags & CLONE_FILES) {\n\t\tatomic_inc(&oldf->count);\n\t\tgoto out;\n\t}\n\n\tnewf = dup_fd(oldf, &error);\n\tif (!newf)\n\t\tgoto out;\n\n\ttsk->files = newf;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int copy_io(unsigned long clone_flags, struct task_struct *tsk)\n{\n#ifdef CONFIG_BLOCK\n\tstruct io_context *ioc = current->io_context;\n\n\tif (!ioc)\n\t\treturn 0;\n\t/*\n\t * Share io context with parent, if CLONE_IO is set\n\t */\n\tif (clone_flags & CLONE_IO) {\n\t\ttsk->io_context = ioc_task_link(ioc);\n\t\tif (unlikely(!tsk->io_context))\n\t\t\treturn -ENOMEM;\n\t} else if (ioprio_valid(ioc->ioprio)) {\n\t\ttsk->io_context = alloc_io_context(GFP_KERNEL, -1);\n\t\tif (unlikely(!tsk->io_context))\n\t\t\treturn -ENOMEM;\n\n\t\ttsk->io_context->ioprio = ioc->ioprio;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\tif (clone_flags & CLONE_SIGHAND) {\n\t\tatomic_inc(&current->sighand->count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\trcu_assign_pointer(tsk->sighand, sig);\n\tif (!sig)\n\t\treturn -ENOMEM;\n\tatomic_set(&sig->count, 1);\n\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));\n\treturn 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (atomic_dec_and_test(&sighand->count))\n\t\tkmem_cache_free(sighand_cachep, sighand);\n}\n\n\n/*\n * Initialize POSIX timer handling for a thread group.\n */\nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\tunsigned long cpu_limit;\n\n\t/* Thread group counters. */\n\tthread_group_cputime_init(sig);\n\n\tcpu_limit = ACCESS_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);\n\tif (cpu_limit != RLIM_INFINITY) {\n\t\tsig->cputime_expires.prof_exp = secs_to_cputime(cpu_limit);\n\t\tsig->cputimer.running = 1;\n\t}\n\n\t/* The timer lists. */\n\tINIT_LIST_HEAD(&sig->cpu_timers[0]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[1]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[2]);\n}\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (clone_flags & CLONE_THREAD)\n\t\treturn 0;\n\n\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tsig->nr_threads = 1;\n\tatomic_set(&sig->live, 1);\n\tatomic_set(&sig->sigcnt, 1);\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tif (clone_flags & CLONE_NEWPID)\n\t\tsig->flags |= SIGNAL_UNKILLABLE;\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->real_timer.function = it_real_fn;\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\ttty_audit_fork(sig);\n\n\tsig->oom_adj = current->signal->oom_adj;\n\n\treturn 0;\n}\n\nstatic void copy_flags(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long new_flags = p->flags;\n\n\tnew_flags &= ~PF_SUPERPRIV;\n\tnew_flags |= PF_FORKNOEXEC;\n\tnew_flags |= PF_STARTING;\n\tp->flags = new_flags;\n\tclear_freeze_flag(p);\n}\n\nSYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tplist_head_init_raw(&p->pi_waiters, &p->pi_lock);\n\tp->pi_blocked_on = NULL;\n#endif\n}\n\n#ifdef CONFIG_MM_OWNER\nvoid mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n\tmm->owner = p;\n}\n#endif /* CONFIG_MM_OWNER */\n\n/*\n * Initialize POSIX timer handling for a single task.\n */\nstatic void posix_cpu_timers_init(struct task_struct *tsk)\n{\n\ttsk->cputime_expires.prof_exp = cputime_zero;\n\ttsk->cputime_expires.virt_exp = cputime_zero;\n\ttsk->cputime_expires.sched_exp = 0;\n\tINIT_LIST_HEAD(&tsk->cpu_timers[0]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[1]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[2]);\n}\n\n/*\n * This creates a new process as a copy of the old one,\n * but does not actually start it yet.\n *\n * It copies the registers, and all the appropriate\n * parts of the process environment (as per the clone\n * flags). The actual kick-off is left to the caller.\n */\nstatic struct task_struct *copy_process(unsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace)\n{\n\tint retval;\n\tstruct task_struct *p;\n\tint cgroup_callbacks_done = 0;\n\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tretval = security_task_create(clone_flags);\n\tif (retval)\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current);\n\tif (!p)\n\t\tgoto fork_out;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&\n\t\t    p->real_cred->user != INIT_USER)\n\t\t\tgoto bad_fork_free;\n\t}\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (nr_threads >= max_threads)\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (!try_module_get(task_thread_info(p)->exec_domain->module))\n\t\tgoto bad_fork_cleanup_count;\n\n\tp->did_exec = 0;\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tcopy_flags(clone_flags, p);\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = cputime_zero;\n\tp->stime = cputime_zero;\n\tp->gtime = cputime_zero;\n\tp->utimescaled = cputime_zero;\n\tp->stimescaled = cputime_zero;\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING\n\tp->prev_utime = cputime_zero;\n\tp->prev_stime = cputime_zero;\n#endif\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cpu_timers_init(p);\n\n\tp->lock_depth = -1;\t\t/* -1 = no lock */\n\tdo_posix_clock_monotonic_gettime(&p->start_time);\n\tp->real_start_time = p->start_time;\n\tmonotonic_to_bootbased(&p->real_start_time);\n\tp->io_context = NULL;\n\tp->audit_context = NULL;\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n \tif (IS_ERR(p->mempolicy)) {\n \t\tretval = PTR_ERR(p->mempolicy);\n \t\tp->mempolicy = NULL;\n \t\tgoto bad_fork_cleanup_cgroup;\n \t}\n\tmpol_fix_fork_child_flag(p);\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = node_random(p->mems_allowed);\n\tp->cpuset_slab_spread_rotor = node_random(p->mems_allowed);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tp->irq_events = 0;\n#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW\n\tp->hardirqs_enabled = 1;\n#else\n\tp->hardirqs_enabled = 0;\n#endif\n\tp->hardirq_enable_ip = 0;\n\tp->hardirq_enable_event = 0;\n\tp->hardirq_disable_ip = _THIS_IP_;\n\tp->hardirq_disable_event = 0;\n\tp->softirqs_enabled = 1;\n\tp->softirq_enable_ip = _THIS_IP_;\n\tp->softirq_enable_event = 0;\n\tp->softirq_disable_ip = 0;\n\tp->softirq_disable_event = 0;\n\tp->hardirq_context = 0;\n\tp->softirq_context = 0;\n#endif\n#ifdef CONFIG_LOCKDEP\n\tp->lockdep_depth = 0; /* no locks held yet */\n\tp->curr_chain_key = 0;\n\tp->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR\n\tp->memcg_batch.do_batch = 0;\n\tp->memcg_batch.memcg = NULL;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tsched_fork(p, clone_flags);\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tif ((retval = audit_alloc(p)))\n\t\tgoto bad_fork_cleanup_policy;\n\t/* copy all the process information */\n\tif ((retval = copy_semundo(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_audit;\n\tif ((retval = copy_files(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_semundo;\n\tif ((retval = copy_fs(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_files;\n\tif ((retval = copy_sighand(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_fs;\n\tif ((retval = copy_signal(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_sighand;\n\tif ((retval = copy_mm(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_signal;\n\tif ((retval = copy_namespaces(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_mm;\n\tif ((retval = copy_io(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(clone_flags, stack_start, stack_size, p, regs);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tif (pid != &init_struct_pid) {\n\t\tretval = -ENOMEM;\n\t\tpid = alloc_pid(p->nsproxy->pid_ns);\n\t\tif (!pid)\n\t\t\tgoto bad_fork_cleanup_io;\n\n\t\tif (clone_flags & CLONE_NEWPID) {\n\t\t\tretval = pid_ns_prepare_proc(p->nsproxy->pid_ns);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t}\n\n\tp->pid = pid_nr(pid);\n\tp->tgid = p->pid;\n\tif (clone_flags & CLONE_THREAD)\n\t\tp->tgid = current->tgid;\n\n\tif (current->nsproxy != p->nsproxy) {\n\t\tretval = ns_cgroup_clone(p, pid);\n\t\tif (retval)\n\t\t\tgoto bad_fork_free_pid;\n\t}\n\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n#ifdef CONFIG_FUTEX\n\tp->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n\tp->compat_robust_list = NULL;\n#endif\n\tINIT_LIST_HEAD(&p->pi_state_list);\n\tp->pi_state_cache = NULL;\n#endif\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tp->sas_ss_sp = p->sas_ss_size = 0;\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_all_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);\n\tp->pdeath_signal = 0;\n\tp->exit_state = 0;\n\n\t/*\n\t * Ok, make it visible to the rest of the system.\n\t * We dont wake it up yet.\n\t */\n\tp->group_leader = p;\n\tINIT_LIST_HEAD(&p->thread_group);\n\n\t/* Now that the task is set up, run cgroup callbacks if\n\t * necessary. We need to run them before the task is visible\n\t * on the tasklist. */\n\tcgroup_fork_callbacks(p);\n\tcgroup_callbacks_done = 1;\n\n\t/* Need tasklist lock for parent etc handling! */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t}\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Process group and session signals need to be delivered to just the\n\t * parent before the fork or both the parent and the child after the\n\t * fork. Restart if a signal comes in before we add the new process to\n\t * it's process group.\n\t * A fatal signal pending means that current will exit, so the new\n\t * thread can't slip out of an OOM kill (or normal SIGKILL).\n \t */\n\trecalc_sigpending();\n\tif (signal_pending(current)) {\n\t\tspin_unlock(&current->sighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tretval = -ERESTARTNOINTR;\n\t\tgoto bad_fork_free_pid;\n\t}\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tcurrent->signal->nr_threads++;\n\t\tatomic_inc(&current->signal->live);\n\t\tatomic_inc(&current->signal->sigcnt);\n\t\tp->group_leader = current->group_leader;\n\t\tlist_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);\n\t}\n\n\tif (likely(p->pid)) {\n\t\ttracehook_finish_clone(p, clone_flags, trace);\n\n\t\tif (thread_group_leader(p)) {\n\t\t\tif (clone_flags & CLONE_NEWPID)\n\t\t\t\tp->nsproxy->pid_ns->child_reaper = p;\n\n\t\t\tp->signal->leader_pid = pid;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\tattach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tattach_pid(p, PIDTYPE_SID, task_session(current));\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\t__get_cpu_var(process_counts)++;\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID, pid);\n\t\tnr_threads++;\n\t}\n\n\ttotal_forks++;\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tproc_fork_connector(p);\n\tcgroup_post_fork(p);\n\tperf_event_fork(p);\n\treturn p;\n\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm)\n\t\tmmput(p->mm);\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_policy:\n\tperf_event_free_task(p);\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_cgroup:\n#endif\n\tcgroup_exit(p, cgroup_callbacks_done);\n\tdelayacct_tsk_free(p);\n\tmodule_put(task_thread_info(p)->exec_domain->module);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\texit_creds(p);\nbad_fork_free:\n\tfree_task(p);\nfork_out:\n\treturn ERR_PTR(retval);\n}\n\nnoinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_regs *regs)\n{\n\tmemset(regs, 0, sizeof(struct pt_regs));\n\treturn regs;\n}\n\nstruct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\n\treturn task;\n}\n\n/*\n *  Ok, this is the main fork-routine.\n *\n * It copies the process, and if successful kick-starts\n * it and waits for it to finish using the VM if required.\n */\nlong do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      struct pt_regs *regs,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr)\n{\n\tstruct task_struct *p;\n\tint trace = 0;\n\tlong nr;\n\n\t/*\n\t * Do some preliminary argument and permissions checking before we\n\t * actually start allocating stuff\n\t */\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\treturn -EINVAL;\n\t\t/* hopefully this check will go away when userns support is\n\t\t * complete\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SETUID) ||\n\t\t\t\t!capable(CAP_SETGID))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We hope to recycle these flags after 2.6.26\n\t */\n\tif (unlikely(clone_flags & CLONE_STOPPED)) {\n\t\tstatic int __read_mostly count = 100;\n\n\t\tif (count > 0 && printk_ratelimit()) {\n\t\t\tchar comm[TASK_COMM_LEN];\n\n\t\t\tcount--;\n\t\t\tprintk(KERN_INFO \"fork(): process `%s' used deprecated \"\n\t\t\t\t\t\"clone flags 0x%lx\\n\",\n\t\t\t\tget_task_comm(comm, current),\n\t\t\t\tclone_flags & CLONE_STOPPED);\n\t\t}\n\t}\n\n\t/*\n\t * When called from kernel_thread, don't do user tracing stuff.\n\t */\n\tif (likely(user_mode(regs)))\n\t\ttrace = tracehook_prepare_clone(clone_flags);\n\n\tp = copy_process(clone_flags, stack_start, regs, stack_size,\n\t\t\t child_tidptr, NULL, trace);\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\tif (!IS_ERR(p)) {\n\t\tstruct completion vfork;\n\n\t\ttrace_sched_process_fork(current, p);\n\n\t\tnr = task_pid_vnr(p);\n\n\t\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\t\tput_user(nr, parent_tidptr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tp->vfork_done = &vfork;\n\t\t\tinit_completion(&vfork);\n\t\t}\n\n\t\taudit_finish_fork(p);\n\t\ttracehook_report_clone(regs, clone_flags, nr, p);\n\n\t\t/*\n\t\t * We set PF_STARTING at creation in case tracing wants to\n\t\t * use this to distinguish a fully live task from one that\n\t\t * hasn't gotten to tracehook_report_clone() yet.  Now we\n\t\t * clear it and set the child going.\n\t\t */\n\t\tp->flags &= ~PF_STARTING;\n\n\t\tif (unlikely(clone_flags & CLONE_STOPPED)) {\n\t\t\t/*\n\t\t\t * We'll start up with an immediate SIGSTOP.\n\t\t\t */\n\t\t\tsigaddset(&p->pending.signal, SIGSTOP);\n\t\t\tset_tsk_thread_flag(p, TIF_SIGPENDING);\n\t\t\t__set_task_state(p, TASK_STOPPED);\n\t\t} else {\n\t\t\twake_up_new_task(p, clone_flags);\n\t\t}\n\n\t\ttracehook_report_clone_complete(trace, regs,\n\t\t\t\t\t\tclone_flags, nr, p);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tfreezer_do_not_count();\n\t\t\twait_for_completion(&vfork);\n\t\t\tfreezer_count();\n\t\t\ttracehook_report_vfork_done(p, nr);\n\t\t}\n\t} else {\n\t\tnr = PTR_ERR(p);\n\t}\n\treturn nr;\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n\tstruct sighand_struct *sighand = data;\n\n\tspin_lock_init(&sighand->siglock);\n\tinit_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|\n\t\t\tSLAB_NOTRACK, sighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);\n\tmmap_init();\n}\n\n/*\n * Check constraints on flags passed to the unshare system call and\n * force unsharing of additional process context as appropriate.\n */\nstatic void check_unshare_flags(unsigned long *flags_ptr)\n{\n\t/*\n\t * If unsharing a thread from a thread group, must also\n\t * unshare vm.\n\t */\n\tif (*flags_ptr & CLONE_THREAD)\n\t\t*flags_ptr |= CLONE_VM;\n\n\t/*\n\t * If unsharing vm, must also unshare signal handlers.\n\t */\n\tif (*flags_ptr & CLONE_VM)\n\t\t*flags_ptr |= CLONE_SIGHAND;\n\n\t/*\n\t * If unsharing namespace, must also unshare filesystem information.\n\t */\n\tif (*flags_ptr & CLONE_NEWNS)\n\t\t*flags_ptr |= CLONE_FS;\n}\n\n/*\n * Unsharing of tasks created with CLONE_THREAD is not supported yet\n */\nstatic int unshare_thread(unsigned long unshare_flags)\n{\n\tif (unshare_flags & CLONE_THREAD)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * Unshare the filesystem structure if it is being shared\n */\nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif (!(unshare_flags & CLONE_FS) || !fs)\n\t\treturn 0;\n\n\t/* don't need lock here; in the worst case we'll do useless copy */\n\tif (fs->users == 1)\n\t\treturn 0;\n\n\t*new_fsp = copy_fs_struct(fs);\n\tif (!*new_fsp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/*\n * Unsharing of sighand is not supported yet\n */\nstatic int unshare_sighand(unsigned long unshare_flags, struct sighand_struct **new_sighp)\n{\n\tstruct sighand_struct *sigh = current->sighand;\n\n\tif ((unshare_flags & CLONE_SIGHAND) && atomic_read(&sigh->count) > 1)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}\n\n/*\n * Unshare vm if it is being shared\n */\nstatic int unshare_vm(unsigned long unshare_flags, struct mm_struct **new_mmp)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif ((unshare_flags & CLONE_VM) &&\n\t    (mm && atomic_read(&mm->mm_users) > 1)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unshare file descriptor table if it is being shared\n */\nstatic int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)\n{\n\tstruct files_struct *fd = current->files;\n\tint error = 0;\n\n\tif ((unshare_flags & CLONE_FILES) &&\n\t    (fd && atomic_read(&fd->count) > 1)) {\n\t\t*new_fdp = dup_fd(fd, &error);\n\t\tif (!*new_fdp)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * unshare allows a process to 'unshare' part of the process\n * context which was originally shared using clone.  copy_*\n * functions used by do_fork() cannot be used here directly\n * because they modify an inactive task_struct that is being\n * constructed. Here we are modifying the current, active,\n * task_struct.\n */\nSYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)\n{\n\tint err = 0;\n\tstruct fs_struct *fs, *new_fs = NULL;\n\tstruct sighand_struct *new_sigh = NULL;\n\tstruct mm_struct *mm, *new_mm = NULL, *active_mm = NULL;\n\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\n\tcheck_unshare_flags(&unshare_flags);\n\n\t/* Return -EINVAL for all unsupported flags */\n\terr = -EINVAL;\n\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET))\n\t\tgoto bad_unshare_out;\n\n\t/*\n\t * CLONE_NEWIPC must also detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.\n\t */\n\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n\t\tdo_sysvsem = 1;\n\tif ((err = unshare_thread(unshare_flags)))\n\t\tgoto bad_unshare_out;\n\tif ((err = unshare_fs(unshare_flags, &new_fs)))\n\t\tgoto bad_unshare_cleanup_thread;\n\tif ((err = unshare_sighand(unshare_flags, &new_sigh)))\n\t\tgoto bad_unshare_cleanup_fs;\n\tif ((err = unshare_vm(unshare_flags, &new_mm)))\n\t\tgoto bad_unshare_cleanup_sigh;\n\tif ((err = unshare_fd(unshare_flags, &new_fd)))\n\t\tgoto bad_unshare_cleanup_vm;\n\tif ((err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,\n\t\t\tnew_fs)))\n\t\tgoto bad_unshare_cleanup_fd;\n\n\tif (new_fs ||  new_mm || new_fd || do_sysvsem || new_nsproxy) {\n\t\tif (do_sysvsem) {\n\t\t\t/*\n\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().\n\t\t\t */\n\t\t\texit_sem(current);\n\t\t}\n\n\t\tif (new_nsproxy) {\n\t\t\tswitch_task_namespaces(current, new_nsproxy);\n\t\t\tnew_nsproxy = NULL;\n\t\t}\n\n\t\ttask_lock(current);\n\n\t\tif (new_fs) {\n\t\t\tfs = current->fs;\n\t\t\twrite_lock(&fs->lock);\n\t\t\tcurrent->fs = new_fs;\n\t\t\tif (--fs->users)\n\t\t\t\tnew_fs = NULL;\n\t\t\telse\n\t\t\t\tnew_fs = fs;\n\t\t\twrite_unlock(&fs->lock);\n\t\t}\n\n\t\tif (new_mm) {\n\t\t\tmm = current->mm;\n\t\t\tactive_mm = current->active_mm;\n\t\t\tcurrent->mm = new_mm;\n\t\t\tcurrent->active_mm = new_mm;\n\t\t\tactivate_mm(active_mm, new_mm);\n\t\t\tnew_mm = mm;\n\t\t}\n\n\t\tif (new_fd) {\n\t\t\tfd = current->files;\n\t\t\tcurrent->files = new_fd;\n\t\t\tnew_fd = fd;\n\t\t}\n\n\t\ttask_unlock(current);\n\t}\n\n\tif (new_nsproxy)\n\t\tput_nsproxy(new_nsproxy);\n\nbad_unshare_cleanup_fd:\n\tif (new_fd)\n\t\tput_files_struct(new_fd);\n\nbad_unshare_cleanup_vm:\n\tif (new_mm)\n\t\tmmput(new_mm);\n\nbad_unshare_cleanup_sigh:\n\tif (new_sigh)\n\t\tif (atomic_dec_and_test(&new_sigh->count))\n\t\t\tkmem_cache_free(sighand_cachep, new_sigh);\n\nbad_unshare_cleanup_fs:\n\tif (new_fs)\n\t\tfree_fs_struct(new_fs);\n\nbad_unshare_cleanup_thread:\nbad_unshare_out:\n\treturn err;\n}\n\n/*\n *\tHelper to unshare the files of the current task.\n *\tWe don't want to expose copy_files internals to\n *\tthe exec layer of the kernel.\n */\n\nint unshare_files(struct files_struct **displaced)\n{\n\tstruct task_struct *task = current;\n\tstruct files_struct *copy = NULL;\n\tint error;\n\n\terror = unshare_fd(CLONE_FILES, &copy);\n\tif (error || !copy) {\n\t\t*displaced = NULL;\n\t\treturn error;\n\t}\n\t*displaced = task->files;\n\ttask_lock(task);\n\ttask->files = copy;\n\ttask_unlock(task);\n\treturn 0;\n}\n"], "fixing_code": ["/*\n *  linux/kernel/fork.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also entry.S and others).\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'\n */\n\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/tracehook.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/ftrace.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/random.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/blkdev.h>\n#include <linux/fs_struct.h>\n#include <linux/magic.h>\n#include <linux/perf_event.h>\n#include <linux/posix-timers.h>\n#include <linux/user-return-notifier.h>\n\n#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n#include <trace/events/sched.h>\n\n/*\n * Protected counters by write_lock_irq(&tasklist_lock)\n */\nunsigned long total_forks;\t/* Handle normal Linux uptimes. */\nint nr_threads; \t\t/* The idle threads do not count.. */\n\nint max_threads;\t\t/* tunable limit on nr_threads */\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */\n\n#ifdef CONFIG_PROVE_RCU\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}\nEXPORT_SYMBOL_GPL(lockdep_tasklist_lock_is_held);\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\nint nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n# define alloc_task_struct()\tkmem_cache_alloc(task_struct_cachep, GFP_KERNEL)\n# define free_task_struct(tsk)\tkmem_cache_free(task_struct_cachep, (tsk))\nstatic struct kmem_cache *task_struct_cachep;\n#endif\n\n#ifndef __HAVE_ARCH_THREAD_INFO_ALLOCATOR\nstatic inline struct thread_info *alloc_thread_info(struct task_struct *tsk)\n{\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tgfp_t mask = GFP_KERNEL | __GFP_ZERO;\n#else\n\tgfp_t mask = GFP_KERNEL;\n#endif\n\treturn (struct thread_info *)__get_free_pages(mask, THREAD_SIZE_ORDER);\n}\n\nstatic inline void free_thread_info(struct thread_info *ti)\n{\n\tfree_pages((unsigned long)ti, THREAD_SIZE_ORDER);\n}\n#endif\n\n/* SLAB cache for signal_struct structures (tsk->signal) */\nstatic struct kmem_cache *signal_cachep;\n\n/* SLAB cache for sighand_struct structures (tsk->sighand) */\nstruct kmem_cache *sighand_cachep;\n\n/* SLAB cache for files_struct structures (tsk->files) */\nstruct kmem_cache *files_cachep;\n\n/* SLAB cache for fs_struct structures (tsk->fs) */\nstruct kmem_cache *fs_cachep;\n\n/* SLAB cache for vm_area_struct structures */\nstruct kmem_cache *vm_area_cachep;\n\n/* SLAB cache for mm_struct structures (tsk->mm) */\nstatic struct kmem_cache *mm_cachep;\n\nstatic void account_kernel_stack(struct thread_info *ti, int account)\n{\n\tstruct zone *zone = page_zone(virt_to_page(ti));\n\n\tmod_zone_page_state(zone, NR_KERNEL_STACK, account);\n}\n\nvoid free_task(struct task_struct *tsk)\n{\n\tprop_local_destroy_single(&tsk->dirties);\n\taccount_kernel_stack(tsk->stack, -1);\n\tfree_thread_info(tsk->stack);\n\trt_mutex_debug_task_free(tsk);\n\tftrace_graph_exit_task(tsk);\n\tfree_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\nstatic inline void free_signal_struct(struct signal_struct *sig)\n{\n\ttaskstats_tgid_free(sig);\n\tkmem_cache_free(signal_cachep, sig);\n}\n\nstatic inline void put_signal_struct(struct signal_struct *sig)\n{\n\tif (atomic_dec_and_test(&sig->sigcnt))\n\t\tfree_signal_struct(sig);\n}\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}\n\n/*\n * macro override instead of weak attribute alias, to workaround\n * gcc 4.1.0 and 4.1.1 bugs with weak attribute and empty functions.\n */\n#ifndef arch_task_cache_init\n#define arch_task_cache_init()\n#endif\n\nvoid __init fork_init(unsigned long mempages)\n{\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN\tL1_CACHE_BYTES\n#endif\n\t/* create a slab on which task_structs can be allocated */\n\ttask_struct_cachep =\n\t\tkmem_cache_create(\"task_struct\", sizeof(struct task_struct),\n\t\t\tARCH_MIN_TASKALIGN, SLAB_PANIC | SLAB_NOTRACK, NULL);\n#endif\n\n\t/* do the arch specific task caches init */\n\tarch_task_cache_init();\n\n\t/*\n\t * The default maximum number of threads is set to a safe\n\t * value: the thread structures can take up at most half\n\t * of memory.\n\t */\n\tmax_threads = mempages / (8 * THREAD_SIZE / PAGE_SIZE);\n\n\t/*\n\t * we need to allow at least 20 threads to boot a system\n\t */\n\tif(max_threads < 20)\n\t\tmax_threads = 20;\n\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =\n\t\tinit_task.signal->rlim[RLIMIT_NPROC];\n}\n\nint __attribute__((weak)) arch_dup_task_struct(struct task_struct *dst,\n\t\t\t\t\t       struct task_struct *src)\n{\n\t*dst = *src;\n\treturn 0;\n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\n\tint err;\n\n\tprepare_to_copy(orig);\n\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\n\ttsk->stack = ti;\n\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\n\t/* One for us, one for whoever does the \"release_task()\" (usually parent) */\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\n\taccount_kernel_stack(ti, 1);\n\n\treturn tsk;\n\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}\n\n#ifdef CONFIG_MMU\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tstruct mempolicy *pol;\n\n\tdown_write(&oldmm->mmap_sem);\n\tflush_cache_dup_mm(oldmm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tdown_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);\n\n\tmm->locked_vm = 0;\n\tmm->mmap = NULL;\n\tmm->mmap_cache = NULL;\n\tmm->free_area_cache = oldmm->mmap_base;\n\tmm->cached_hole_size = ~0UL;\n\tmm->map_count = 0;\n\tcpumask_clear(mm_cpumask(mm));\n\tmm->mm_rb = RB_ROOT;\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\tretval = ksm_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tlong pages = vma_pages(mpnt);\n\t\t\tmm->total_vm -= pages;\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, mpnt->vm_file,\n\t\t\t\t\t\t\t\t-pages);\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned int len = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;\n\t\t\tif (security_vm_enough_memory(len))\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\t*tmp = *mpnt;\n\t\tINIT_LIST_HEAD(&tmp->anon_vma_chain);\n\t\tpol = mpol_dup(vma_policy(mpnt));\n\t\tretval = PTR_ERR(pol);\n\t\tif (IS_ERR(pol))\n\t\t\tgoto fail_nomem_policy;\n\t\tvma_set_policy(tmp, pol);\n\t\tif (anon_vma_fork(tmp, mpnt))\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\ttmp->vm_flags &= ~VM_LOCKED;\n\t\ttmp->vm_mm = mm;\n\t\ttmp->vm_next = NULL;\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file->f_path.dentry->d_inode;\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tatomic_dec(&inode->i_writecount);\n\t\t\tspin_lock(&mapping->i_mmap_lock);\n\t\t\tif (tmp->vm_flags & VM_SHARED)\n\t\t\t\tmapping->i_mmap_writable++;\n\t\t\ttmp->vm_truncate_count = mpnt->vm_truncate_count;\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tvma_prio_tree_add(tmp, mpnt);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\tspin_unlock(&mapping->i_mmap_lock);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tretval = copy_page_range(mm, oldmm, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tarch_dup_mmap(oldmm, mm);\n\tretval = 0;\nout:\n\tup_write(&mm->mmap_sem);\n\tflush_tlb_mm(oldmm);\n\tup_write(&oldmm->mmap_sem);\n\treturn retval;\nfail_nomem_anon_vma_fork:\n\tmpol_put(pol);\nfail_nomem_policy:\n\tkmem_cache_free(vm_area_cachep, tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct * mm)\n{\n\tmm->pgd = pgd_alloc(mm);\n\tif (unlikely(!mm->pgd))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct * mm)\n{\n\tpgd_free(mm, mm->pgd);\n}\n#else\n#define dup_mmap(mm, oldmm)\t(0)\n#define mm_alloc_pgd(mm)\t(0)\n#define mm_free_pgd(mm)\n#endif /* CONFIG_MMU */\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\n#define allocate_mm()\t(kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)\t(kmem_cache_free(mm_cachep, (mm)))\n\nstatic unsigned long default_dump_filter = MMF_DUMP_FILTER_DEFAULT;\n\nstatic int __init coredump_filter_setup(char *s)\n{\n\tdefault_dump_filter =\n\t\t(simple_strtoul(s, NULL, 0) << MMF_DUMP_FILTER_SHIFT) &\n\t\tMMF_DUMP_FILTER_MASK;\n\treturn 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>\n\nstatic void mm_init_aio(struct mm_struct *mm)\n{\n#ifdef CONFIG_AIO\n\tspin_lock_init(&mm->ioctx_lock);\n\tINIT_HLIST_HEAD(&mm->ioctx_list);\n#endif\n}\n\nstatic struct mm_struct * mm_init(struct mm_struct * mm, struct task_struct *p)\n{\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->flags = (current->mm) ?\n\t\t(current->mm->flags & MMF_INIT_MASK) : default_dump_filter;\n\tmm->core_state = NULL;\n\tmm->nr_ptes = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm->free_area_cache = TASK_UNMAPPED_BASE;\n\tmm->cached_hole_size = ~0UL;\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\n\tif (likely(!mm_alloc_pgd(mm))) {\n\t\tmm->def_flags = 0;\n\t\tmmu_notifier_mm_init(mm);\n\t\treturn mm;\n\t}\n\n\tfree_mm(mm);\n\treturn NULL;\n}\n\n/*\n * Allocate and initialize an mm_struct.\n */\nstruct mm_struct * mm_alloc(void)\n{\n\tstruct mm_struct * mm;\n\n\tmm = allocate_mm();\n\tif (mm) {\n\t\tmemset(mm, 0, sizeof(*mm));\n\t\tmm = mm_init(mm, current);\n\t}\n\treturn mm;\n}\n\n/*\n * Called when the last reference to the mm\n * is dropped: either by a lazy thread or by\n * mmput. Free the page directory and the mm.\n */\nvoid __mmdrop(struct mm_struct *mm)\n{\n\tBUG_ON(mm == &init_mm);\n\tmm_free_pgd(mm);\n\tdestroy_context(mm);\n\tmmu_notifier_mm_destroy(mm);\n\tfree_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\n/*\n * Decrement the use count and release all resources for an mm.\n */\nvoid mmput(struct mm_struct *mm)\n{\n\tmight_sleep();\n\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\texit_aio(mm);\n\t\tksm_exit(mm);\n\t\texit_mmap(mm);\n\t\tset_mm_exe_file(mm, NULL);\n\t\tif (!list_empty(&mm->mmlist)) {\n\t\t\tspin_lock(&mmlist_lock);\n\t\t\tlist_del(&mm->mmlist);\n\t\t\tspin_unlock(&mmlist_lock);\n\t\t}\n\t\tput_swap_token(mm);\n\t\tif (mm->binfmt)\n\t\t\tmodule_put(mm->binfmt->module);\n\t\tmmdrop(mm);\n\t}\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n/**\n * get_task_mm - acquire a reference to the task's mm\n *\n * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning\n * this kernel workthread has transiently adopted a user mm with use_mm,\n * to do its AIO) is not set and if so returns a reference to it, after\n * bumping up the use count.  User must release the mm via mmput()\n * after use.  Typically used by /proc and ptrace.\n */\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tatomic_inc(&mm->mm_users);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\n/* Please note the differences between mmput and mm_release.\n * mmput is called whenever we stop holding onto a mm_struct,\n * error success whatever.\n *\n * mm_release is called after a mm_struct has been removed\n * from the current process.\n *\n * This difference is important for error handling, when we\n * only half set up a mm_struct for a new process and need to restore\n * the old one.  Because we mmput the new mm_struct before\n * restoring the old one. . .\n * Eric Biederman 10 January 1998\n */\nvoid mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct completion *vfork_done = tsk->vfork_done;\n\n\t/* Get rid of any futexes when releasing the mm */\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list)) {\n\t\texit_robust_list(tsk);\n\t\ttsk->robust_list = NULL;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list)) {\n\t\tcompat_exit_robust_list(tsk);\n\t\ttsk->compat_robust_list = NULL;\n\t}\n#endif\n\tif (unlikely(!list_empty(&tsk->pi_state_list)))\n\t\texit_pi_state_list(tsk);\n#endif\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/* notify parent sleeping on vfork() */\n\tif (vfork_done) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork_done);\n\t}\n\n\t/*\n\t * If we're exiting normally, clear a user-space tid field if\n\t * requested.  We leave this alone when dying by signal, to leave\n\t * the value intact in a core dump, and to save the unnecessary\n\t * trouble otherwise.  Userland only wants this done for a sys_exit.\n\t */\n\tif (tsk->clear_child_tid) {\n\t\tif (!(tsk->flags & PF_SIGNALED) &&\n\t\t    atomic_read(&mm->mm_users) > 1) {\n\t\t\t/*\n\t\t\t * We don't check the error code - if userspace has\n\t\t\t * not set up a proper pointer then tough luck.\n\t\t\t */\n\t\t\tput_user(0, tsk->clear_child_tid);\n\t\t\tsys_futex(tsk->clear_child_tid, FUTEX_WAKE,\n\t\t\t\t\t1, NULL, NULL, 0);\n\t\t}\n\t\ttsk->clear_child_tid = NULL;\n\t}\n}\n\n/*\n * Allocate a new mm structure and copy contents from the\n * mm structure of the passed in task structure.\n */\nstruct mm_struct *dup_mm(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm = current->mm;\n\tint err;\n\n\tif (!oldmm)\n\t\treturn NULL;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\t/* Initializing for Swap token stuff */\n\tmm->token_priority = 0;\n\tmm->last_interval = 0;\n\n\tif (!mm_init(mm, tsk))\n\t\tgoto fail_nomem;\n\n\tif (init_new_context(tsk, mm))\n\t\tgoto fail_nocontext;\n\n\tdup_mm_exe_file(oldmm, mm);\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\tif (mm->binfmt && !try_module_get(mm->binfmt->module))\n\t\tgoto free_pt;\n\n\treturn mm;\n\nfree_pt:\n\t/* don't put binfmt in mmput, we haven't got module yet */\n\tmm->binfmt = NULL;\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n\nfail_nocontext:\n\t/*\n\t * If init_new_context() failed, we cannot use mmput() to free the mm\n\t * because it calls destroy_context()\n\t */\n\tmm_free_pgd(mm);\n\tfree_mm(mm);\n\treturn NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct * tsk)\n{\n\tstruct mm_struct * mm, *oldmm;\n\tint retval;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n#endif\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\tif (clone_flags & CLONE_VM) {\n\t\tatomic_inc(&oldmm->mm_users);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\n\tretval = -ENOMEM;\n\tmm = dup_mm(tsk);\n\tif (!mm)\n\t\tgoto fail_nomem;\n\ngood_mm:\n\t/* Initializing for Swap token stuff */\n\tmm->token_priority = 0;\n\tmm->last_interval = 0;\n\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\treturn 0;\n\nfail_nomem:\n\treturn retval;\n}\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct fs_struct *fs = current->fs;\n\tif (clone_flags & CLONE_FS) {\n\t\t/* tsk->fs is already what we want */\n\t\twrite_lock(&fs->lock);\n\t\tif (fs->in_exec) {\n\t\t\twrite_unlock(&fs->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tfs->users++;\n\t\twrite_unlock(&fs->lock);\n\t\treturn 0;\n\t}\n\ttsk->fs = copy_fs_struct(fs);\n\tif (!tsk->fs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct * tsk)\n{\n\tstruct files_struct *oldf, *newf;\n\tint error = 0;\n\n\t/*\n\t * A background process may not have any files ...\n\t */\n\toldf = current->files;\n\tif (!oldf)\n\t\tgoto out;\n\n\tif (clone_flags & CLONE_FILES) {\n\t\tatomic_inc(&oldf->count);\n\t\tgoto out;\n\t}\n\n\tnewf = dup_fd(oldf, &error);\n\tif (!newf)\n\t\tgoto out;\n\n\ttsk->files = newf;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int copy_io(unsigned long clone_flags, struct task_struct *tsk)\n{\n#ifdef CONFIG_BLOCK\n\tstruct io_context *ioc = current->io_context;\n\n\tif (!ioc)\n\t\treturn 0;\n\t/*\n\t * Share io context with parent, if CLONE_IO is set\n\t */\n\tif (clone_flags & CLONE_IO) {\n\t\ttsk->io_context = ioc_task_link(ioc);\n\t\tif (unlikely(!tsk->io_context))\n\t\t\treturn -ENOMEM;\n\t} else if (ioprio_valid(ioc->ioprio)) {\n\t\ttsk->io_context = alloc_io_context(GFP_KERNEL, -1);\n\t\tif (unlikely(!tsk->io_context))\n\t\t\treturn -ENOMEM;\n\n\t\ttsk->io_context->ioprio = ioc->ioprio;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\tif (clone_flags & CLONE_SIGHAND) {\n\t\tatomic_inc(&current->sighand->count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\trcu_assign_pointer(tsk->sighand, sig);\n\tif (!sig)\n\t\treturn -ENOMEM;\n\tatomic_set(&sig->count, 1);\n\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));\n\treturn 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (atomic_dec_and_test(&sighand->count))\n\t\tkmem_cache_free(sighand_cachep, sighand);\n}\n\n\n/*\n * Initialize POSIX timer handling for a thread group.\n */\nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\tunsigned long cpu_limit;\n\n\t/* Thread group counters. */\n\tthread_group_cputime_init(sig);\n\n\tcpu_limit = ACCESS_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);\n\tif (cpu_limit != RLIM_INFINITY) {\n\t\tsig->cputime_expires.prof_exp = secs_to_cputime(cpu_limit);\n\t\tsig->cputimer.running = 1;\n\t}\n\n\t/* The timer lists. */\n\tINIT_LIST_HEAD(&sig->cpu_timers[0]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[1]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[2]);\n}\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (clone_flags & CLONE_THREAD)\n\t\treturn 0;\n\n\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tsig->nr_threads = 1;\n\tatomic_set(&sig->live, 1);\n\tatomic_set(&sig->sigcnt, 1);\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tif (clone_flags & CLONE_NEWPID)\n\t\tsig->flags |= SIGNAL_UNKILLABLE;\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->real_timer.function = it_real_fn;\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\ttty_audit_fork(sig);\n\n\tsig->oom_adj = current->signal->oom_adj;\n\n\treturn 0;\n}\n\nstatic void copy_flags(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long new_flags = p->flags;\n\n\tnew_flags &= ~PF_SUPERPRIV;\n\tnew_flags |= PF_FORKNOEXEC;\n\tnew_flags |= PF_STARTING;\n\tp->flags = new_flags;\n\tclear_freeze_flag(p);\n}\n\nSYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tplist_head_init_raw(&p->pi_waiters, &p->pi_lock);\n\tp->pi_blocked_on = NULL;\n#endif\n}\n\n#ifdef CONFIG_MM_OWNER\nvoid mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n\tmm->owner = p;\n}\n#endif /* CONFIG_MM_OWNER */\n\n/*\n * Initialize POSIX timer handling for a single task.\n */\nstatic void posix_cpu_timers_init(struct task_struct *tsk)\n{\n\ttsk->cputime_expires.prof_exp = cputime_zero;\n\ttsk->cputime_expires.virt_exp = cputime_zero;\n\ttsk->cputime_expires.sched_exp = 0;\n\tINIT_LIST_HEAD(&tsk->cpu_timers[0]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[1]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[2]);\n}\n\n/*\n * This creates a new process as a copy of the old one,\n * but does not actually start it yet.\n *\n * It copies the registers, and all the appropriate\n * parts of the process environment (as per the clone\n * flags). The actual kick-off is left to the caller.\n */\nstatic struct task_struct *copy_process(unsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace)\n{\n\tint retval;\n\tstruct task_struct *p;\n\tint cgroup_callbacks_done = 0;\n\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tretval = security_task_create(clone_flags);\n\tif (retval)\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current);\n\tif (!p)\n\t\tgoto fork_out;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&\n\t\t    p->real_cred->user != INIT_USER)\n\t\t\tgoto bad_fork_free;\n\t}\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (nr_threads >= max_threads)\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (!try_module_get(task_thread_info(p)->exec_domain->module))\n\t\tgoto bad_fork_cleanup_count;\n\n\tp->did_exec = 0;\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tcopy_flags(clone_flags, p);\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = cputime_zero;\n\tp->stime = cputime_zero;\n\tp->gtime = cputime_zero;\n\tp->utimescaled = cputime_zero;\n\tp->stimescaled = cputime_zero;\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING\n\tp->prev_utime = cputime_zero;\n\tp->prev_stime = cputime_zero;\n#endif\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cpu_timers_init(p);\n\n\tp->lock_depth = -1;\t\t/* -1 = no lock */\n\tdo_posix_clock_monotonic_gettime(&p->start_time);\n\tp->real_start_time = p->start_time;\n\tmonotonic_to_bootbased(&p->real_start_time);\n\tp->io_context = NULL;\n\tp->audit_context = NULL;\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n \tif (IS_ERR(p->mempolicy)) {\n \t\tretval = PTR_ERR(p->mempolicy);\n \t\tp->mempolicy = NULL;\n \t\tgoto bad_fork_cleanup_cgroup;\n \t}\n\tmpol_fix_fork_child_flag(p);\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = node_random(p->mems_allowed);\n\tp->cpuset_slab_spread_rotor = node_random(p->mems_allowed);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tp->irq_events = 0;\n#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW\n\tp->hardirqs_enabled = 1;\n#else\n\tp->hardirqs_enabled = 0;\n#endif\n\tp->hardirq_enable_ip = 0;\n\tp->hardirq_enable_event = 0;\n\tp->hardirq_disable_ip = _THIS_IP_;\n\tp->hardirq_disable_event = 0;\n\tp->softirqs_enabled = 1;\n\tp->softirq_enable_ip = _THIS_IP_;\n\tp->softirq_enable_event = 0;\n\tp->softirq_disable_ip = 0;\n\tp->softirq_disable_event = 0;\n\tp->hardirq_context = 0;\n\tp->softirq_context = 0;\n#endif\n#ifdef CONFIG_LOCKDEP\n\tp->lockdep_depth = 0; /* no locks held yet */\n\tp->curr_chain_key = 0;\n\tp->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR\n\tp->memcg_batch.do_batch = 0;\n\tp->memcg_batch.memcg = NULL;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tsched_fork(p, clone_flags);\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tif ((retval = audit_alloc(p)))\n\t\tgoto bad_fork_cleanup_policy;\n\t/* copy all the process information */\n\tif ((retval = copy_semundo(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_audit;\n\tif ((retval = copy_files(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_semundo;\n\tif ((retval = copy_fs(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_files;\n\tif ((retval = copy_sighand(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_fs;\n\tif ((retval = copy_signal(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_sighand;\n\tif ((retval = copy_mm(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_signal;\n\tif ((retval = copy_namespaces(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_mm;\n\tif ((retval = copy_io(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(clone_flags, stack_start, stack_size, p, regs);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tif (pid != &init_struct_pid) {\n\t\tretval = -ENOMEM;\n\t\tpid = alloc_pid(p->nsproxy->pid_ns);\n\t\tif (!pid)\n\t\t\tgoto bad_fork_cleanup_io;\n\n\t\tif (clone_flags & CLONE_NEWPID) {\n\t\t\tretval = pid_ns_prepare_proc(p->nsproxy->pid_ns);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t}\n\n\tp->pid = pid_nr(pid);\n\tp->tgid = p->pid;\n\tif (clone_flags & CLONE_THREAD)\n\t\tp->tgid = current->tgid;\n\n\tif (current->nsproxy != p->nsproxy) {\n\t\tretval = ns_cgroup_clone(p, pid);\n\t\tif (retval)\n\t\t\tgoto bad_fork_free_pid;\n\t}\n\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n#ifdef CONFIG_FUTEX\n\tp->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n\tp->compat_robust_list = NULL;\n#endif\n\tINIT_LIST_HEAD(&p->pi_state_list);\n\tp->pi_state_cache = NULL;\n#endif\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tp->sas_ss_sp = p->sas_ss_size = 0;\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_all_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);\n\tp->pdeath_signal = 0;\n\tp->exit_state = 0;\n\n\t/*\n\t * Ok, make it visible to the rest of the system.\n\t * We dont wake it up yet.\n\t */\n\tp->group_leader = p;\n\tINIT_LIST_HEAD(&p->thread_group);\n\n\t/* Now that the task is set up, run cgroup callbacks if\n\t * necessary. We need to run them before the task is visible\n\t * on the tasklist. */\n\tcgroup_fork_callbacks(p);\n\tcgroup_callbacks_done = 1;\n\n\t/* Need tasklist lock for parent etc handling! */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t}\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Process group and session signals need to be delivered to just the\n\t * parent before the fork or both the parent and the child after the\n\t * fork. Restart if a signal comes in before we add the new process to\n\t * it's process group.\n\t * A fatal signal pending means that current will exit, so the new\n\t * thread can't slip out of an OOM kill (or normal SIGKILL).\n \t */\n\trecalc_sigpending();\n\tif (signal_pending(current)) {\n\t\tspin_unlock(&current->sighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tretval = -ERESTARTNOINTR;\n\t\tgoto bad_fork_free_pid;\n\t}\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tcurrent->signal->nr_threads++;\n\t\tatomic_inc(&current->signal->live);\n\t\tatomic_inc(&current->signal->sigcnt);\n\t\tp->group_leader = current->group_leader;\n\t\tlist_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);\n\t}\n\n\tif (likely(p->pid)) {\n\t\ttracehook_finish_clone(p, clone_flags, trace);\n\n\t\tif (thread_group_leader(p)) {\n\t\t\tif (clone_flags & CLONE_NEWPID)\n\t\t\t\tp->nsproxy->pid_ns->child_reaper = p;\n\n\t\t\tp->signal->leader_pid = pid;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\tattach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tattach_pid(p, PIDTYPE_SID, task_session(current));\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\t__get_cpu_var(process_counts)++;\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID, pid);\n\t\tnr_threads++;\n\t}\n\n\ttotal_forks++;\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tproc_fork_connector(p);\n\tcgroup_post_fork(p);\n\tperf_event_fork(p);\n\treturn p;\n\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm)\n\t\tmmput(p->mm);\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_policy:\n\tperf_event_free_task(p);\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_cgroup:\n#endif\n\tcgroup_exit(p, cgroup_callbacks_done);\n\tdelayacct_tsk_free(p);\n\tmodule_put(task_thread_info(p)->exec_domain->module);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\texit_creds(p);\nbad_fork_free:\n\tfree_task(p);\nfork_out:\n\treturn ERR_PTR(retval);\n}\n\nnoinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_regs *regs)\n{\n\tmemset(regs, 0, sizeof(struct pt_regs));\n\treturn regs;\n}\n\nstatic inline void init_idle_pids(struct pid_link *links)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&links[type].node); /* not really needed */\n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}\n\nstruct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task->pids);\n\t\tinit_idle(task, cpu);\n\t}\n\n\treturn task;\n}\n\n/*\n *  Ok, this is the main fork-routine.\n *\n * It copies the process, and if successful kick-starts\n * it and waits for it to finish using the VM if required.\n */\nlong do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      struct pt_regs *regs,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr)\n{\n\tstruct task_struct *p;\n\tint trace = 0;\n\tlong nr;\n\n\t/*\n\t * Do some preliminary argument and permissions checking before we\n\t * actually start allocating stuff\n\t */\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\treturn -EINVAL;\n\t\t/* hopefully this check will go away when userns support is\n\t\t * complete\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SETUID) ||\n\t\t\t\t!capable(CAP_SETGID))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We hope to recycle these flags after 2.6.26\n\t */\n\tif (unlikely(clone_flags & CLONE_STOPPED)) {\n\t\tstatic int __read_mostly count = 100;\n\n\t\tif (count > 0 && printk_ratelimit()) {\n\t\t\tchar comm[TASK_COMM_LEN];\n\n\t\t\tcount--;\n\t\t\tprintk(KERN_INFO \"fork(): process `%s' used deprecated \"\n\t\t\t\t\t\"clone flags 0x%lx\\n\",\n\t\t\t\tget_task_comm(comm, current),\n\t\t\t\tclone_flags & CLONE_STOPPED);\n\t\t}\n\t}\n\n\t/*\n\t * When called from kernel_thread, don't do user tracing stuff.\n\t */\n\tif (likely(user_mode(regs)))\n\t\ttrace = tracehook_prepare_clone(clone_flags);\n\n\tp = copy_process(clone_flags, stack_start, regs, stack_size,\n\t\t\t child_tidptr, NULL, trace);\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\tif (!IS_ERR(p)) {\n\t\tstruct completion vfork;\n\n\t\ttrace_sched_process_fork(current, p);\n\n\t\tnr = task_pid_vnr(p);\n\n\t\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\t\tput_user(nr, parent_tidptr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tp->vfork_done = &vfork;\n\t\t\tinit_completion(&vfork);\n\t\t}\n\n\t\taudit_finish_fork(p);\n\t\ttracehook_report_clone(regs, clone_flags, nr, p);\n\n\t\t/*\n\t\t * We set PF_STARTING at creation in case tracing wants to\n\t\t * use this to distinguish a fully live task from one that\n\t\t * hasn't gotten to tracehook_report_clone() yet.  Now we\n\t\t * clear it and set the child going.\n\t\t */\n\t\tp->flags &= ~PF_STARTING;\n\n\t\tif (unlikely(clone_flags & CLONE_STOPPED)) {\n\t\t\t/*\n\t\t\t * We'll start up with an immediate SIGSTOP.\n\t\t\t */\n\t\t\tsigaddset(&p->pending.signal, SIGSTOP);\n\t\t\tset_tsk_thread_flag(p, TIF_SIGPENDING);\n\t\t\t__set_task_state(p, TASK_STOPPED);\n\t\t} else {\n\t\t\twake_up_new_task(p, clone_flags);\n\t\t}\n\n\t\ttracehook_report_clone_complete(trace, regs,\n\t\t\t\t\t\tclone_flags, nr, p);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tfreezer_do_not_count();\n\t\t\twait_for_completion(&vfork);\n\t\t\tfreezer_count();\n\t\t\ttracehook_report_vfork_done(p, nr);\n\t\t}\n\t} else {\n\t\tnr = PTR_ERR(p);\n\t}\n\treturn nr;\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n\tstruct sighand_struct *sighand = data;\n\n\tspin_lock_init(&sighand->siglock);\n\tinit_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|\n\t\t\tSLAB_NOTRACK, sighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);\n\tmmap_init();\n}\n\n/*\n * Check constraints on flags passed to the unshare system call and\n * force unsharing of additional process context as appropriate.\n */\nstatic void check_unshare_flags(unsigned long *flags_ptr)\n{\n\t/*\n\t * If unsharing a thread from a thread group, must also\n\t * unshare vm.\n\t */\n\tif (*flags_ptr & CLONE_THREAD)\n\t\t*flags_ptr |= CLONE_VM;\n\n\t/*\n\t * If unsharing vm, must also unshare signal handlers.\n\t */\n\tif (*flags_ptr & CLONE_VM)\n\t\t*flags_ptr |= CLONE_SIGHAND;\n\n\t/*\n\t * If unsharing namespace, must also unshare filesystem information.\n\t */\n\tif (*flags_ptr & CLONE_NEWNS)\n\t\t*flags_ptr |= CLONE_FS;\n}\n\n/*\n * Unsharing of tasks created with CLONE_THREAD is not supported yet\n */\nstatic int unshare_thread(unsigned long unshare_flags)\n{\n\tif (unshare_flags & CLONE_THREAD)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * Unshare the filesystem structure if it is being shared\n */\nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif (!(unshare_flags & CLONE_FS) || !fs)\n\t\treturn 0;\n\n\t/* don't need lock here; in the worst case we'll do useless copy */\n\tif (fs->users == 1)\n\t\treturn 0;\n\n\t*new_fsp = copy_fs_struct(fs);\n\tif (!*new_fsp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/*\n * Unsharing of sighand is not supported yet\n */\nstatic int unshare_sighand(unsigned long unshare_flags, struct sighand_struct **new_sighp)\n{\n\tstruct sighand_struct *sigh = current->sighand;\n\n\tif ((unshare_flags & CLONE_SIGHAND) && atomic_read(&sigh->count) > 1)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}\n\n/*\n * Unshare vm if it is being shared\n */\nstatic int unshare_vm(unsigned long unshare_flags, struct mm_struct **new_mmp)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif ((unshare_flags & CLONE_VM) &&\n\t    (mm && atomic_read(&mm->mm_users) > 1)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unshare file descriptor table if it is being shared\n */\nstatic int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)\n{\n\tstruct files_struct *fd = current->files;\n\tint error = 0;\n\n\tif ((unshare_flags & CLONE_FILES) &&\n\t    (fd && atomic_read(&fd->count) > 1)) {\n\t\t*new_fdp = dup_fd(fd, &error);\n\t\tif (!*new_fdp)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * unshare allows a process to 'unshare' part of the process\n * context which was originally shared using clone.  copy_*\n * functions used by do_fork() cannot be used here directly\n * because they modify an inactive task_struct that is being\n * constructed. Here we are modifying the current, active,\n * task_struct.\n */\nSYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)\n{\n\tint err = 0;\n\tstruct fs_struct *fs, *new_fs = NULL;\n\tstruct sighand_struct *new_sigh = NULL;\n\tstruct mm_struct *mm, *new_mm = NULL, *active_mm = NULL;\n\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\n\tcheck_unshare_flags(&unshare_flags);\n\n\t/* Return -EINVAL for all unsupported flags */\n\terr = -EINVAL;\n\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET))\n\t\tgoto bad_unshare_out;\n\n\t/*\n\t * CLONE_NEWIPC must also detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.\n\t */\n\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n\t\tdo_sysvsem = 1;\n\tif ((err = unshare_thread(unshare_flags)))\n\t\tgoto bad_unshare_out;\n\tif ((err = unshare_fs(unshare_flags, &new_fs)))\n\t\tgoto bad_unshare_cleanup_thread;\n\tif ((err = unshare_sighand(unshare_flags, &new_sigh)))\n\t\tgoto bad_unshare_cleanup_fs;\n\tif ((err = unshare_vm(unshare_flags, &new_mm)))\n\t\tgoto bad_unshare_cleanup_sigh;\n\tif ((err = unshare_fd(unshare_flags, &new_fd)))\n\t\tgoto bad_unshare_cleanup_vm;\n\tif ((err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,\n\t\t\tnew_fs)))\n\t\tgoto bad_unshare_cleanup_fd;\n\n\tif (new_fs ||  new_mm || new_fd || do_sysvsem || new_nsproxy) {\n\t\tif (do_sysvsem) {\n\t\t\t/*\n\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().\n\t\t\t */\n\t\t\texit_sem(current);\n\t\t}\n\n\t\tif (new_nsproxy) {\n\t\t\tswitch_task_namespaces(current, new_nsproxy);\n\t\t\tnew_nsproxy = NULL;\n\t\t}\n\n\t\ttask_lock(current);\n\n\t\tif (new_fs) {\n\t\t\tfs = current->fs;\n\t\t\twrite_lock(&fs->lock);\n\t\t\tcurrent->fs = new_fs;\n\t\t\tif (--fs->users)\n\t\t\t\tnew_fs = NULL;\n\t\t\telse\n\t\t\t\tnew_fs = fs;\n\t\t\twrite_unlock(&fs->lock);\n\t\t}\n\n\t\tif (new_mm) {\n\t\t\tmm = current->mm;\n\t\t\tactive_mm = current->active_mm;\n\t\t\tcurrent->mm = new_mm;\n\t\t\tcurrent->active_mm = new_mm;\n\t\t\tactivate_mm(active_mm, new_mm);\n\t\t\tnew_mm = mm;\n\t\t}\n\n\t\tif (new_fd) {\n\t\t\tfd = current->files;\n\t\t\tcurrent->files = new_fd;\n\t\t\tnew_fd = fd;\n\t\t}\n\n\t\ttask_unlock(current);\n\t}\n\n\tif (new_nsproxy)\n\t\tput_nsproxy(new_nsproxy);\n\nbad_unshare_cleanup_fd:\n\tif (new_fd)\n\t\tput_files_struct(new_fd);\n\nbad_unshare_cleanup_vm:\n\tif (new_mm)\n\t\tmmput(new_mm);\n\nbad_unshare_cleanup_sigh:\n\tif (new_sigh)\n\t\tif (atomic_dec_and_test(&new_sigh->count))\n\t\t\tkmem_cache_free(sighand_cachep, new_sigh);\n\nbad_unshare_cleanup_fs:\n\tif (new_fs)\n\t\tfree_fs_struct(new_fs);\n\nbad_unshare_cleanup_thread:\nbad_unshare_out:\n\treturn err;\n}\n\n/*\n *\tHelper to unshare the files of the current task.\n *\tWe don't want to expose copy_files internals to\n *\tthe exec layer of the kernel.\n */\n\nint unshare_files(struct files_struct **displaced)\n{\n\tstruct task_struct *task = current;\n\tstruct files_struct *copy = NULL;\n\tint error;\n\n\terror = unshare_fd(CLONE_FILES, &copy);\n\tif (error || !copy) {\n\t\t*displaced = NULL;\n\t\treturn error;\n\t}\n\t*displaced = task->files;\n\ttask_lock(task);\n\ttask->files = copy;\n\ttask_unlock(task);\n\treturn 0;\n}\n"], "filenames": ["kernel/fork.c"], "buggy_code_start_loc": [1340], "buggy_code_end_loc": [1349], "fixing_code_start_loc": [1341], "fixing_code_end_loc": [1362], "type": "CWE-20", "message": "include/linux/init_task.h in the Linux kernel before 2.6.35 does not prevent signals with a process group ID of zero from reaching the swapper process, which allows local users to cause a denial of service (system crash) by leveraging access to this process group.", "other": {"cve": {"id": "CVE-2010-5328", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-06T06:59:00.137", "lastModified": "2017-03-29T01:59:00.203", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "include/linux/init_task.h in the Linux kernel before 2.6.35 does not prevent signals with a process group ID of zero from reaching the swapper process, which allows local users to cause a denial of service (system crash) by leveraging access to this process group."}, {"lang": "es", "value": "include/linux/init_task.h en el kernel de Linux en versiones anteriores a 2.6.35 no impide que las se\u00f1ales con un ID de grupo de proceso de cero alcancen el proceso swapper, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (ca\u00edda del sistema) aprovechando el acceso a este grupo de procesos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.34.7", "matchCriteriaId": "9A17F021-CEC3-4408-ACD2-EE71A3BC67F7"}]}]}], "references": [{"url": "http://ftp.naist.jp/pub/linux/kernel/v2.6/ChangeLog-2.6.35", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f106eee10038c2ee5b6056aaf3f6d5229be6dcdd", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f20011457f41c11edb5ea5038ad0c8ea9f392023", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=fa2755e20ab0c7215d99c2dc7c262e98a09b01df", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/21/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97103", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1358840", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/f106eee10038c2ee5b6056aaf3f6d5229be6dcdd", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/f20011457f41c11edb5ea5038ad0c8ea9f392023", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/fa2755e20ab0c7215d99c2dc7c262e98a09b01df", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f106eee10038c2ee5b6056aaf3f6d5229be6dcdd"}}