{"buggy_code": ["module Spree\n  module Api\n    module V2\n      class BaseController < ActionController::API\n        include CanCan::ControllerAdditions\n        include Spree::Core::ControllerHelpers::StrongParameters\n        include Spree::Core::ControllerHelpers::Store\n        rescue_from ActiveRecord::RecordNotFound, with: :record_not_found\n        rescue_from CanCan::AccessDenied, with: :access_denied\n        rescue_from Spree::Core::GatewayError, with: :gateway_error\n\n        def content_type\n          Spree::Api::Config[:api_v2_content_type]\n        end\n\n        private\n\n        def serialize_collection(collection)\n          collection_serializer.new(\n            collection,\n            collection_options(collection)\n          ).serializable_hash\n        end\n\n        def serialize_resource(resource)\n          resource_serializer.new(\n            resource,\n            include: resource_includes,\n            fields: sparse_fields\n          ).serializable_hash\n        end\n\n        def paginated_collection\n          collection_paginator.new(sorted_collection, params).call\n        end\n\n        def collection_paginator\n          Spree::Api::Dependencies.storefront_collection_paginator.constantize\n        end\n\n        def render_serialized_payload(status = 200)\n          render json: yield, status: status, content_type: content_type\n        rescue ArgumentError => exception\n          render_error_payload(exception.message, 400)\n        end\n\n        def render_error_payload(error, status = 422)\n          if error.is_a?(Struct)\n            render json: { error: error.to_s, errors: error.to_h }, status: status, content_type: content_type\n          elsif error.is_a?(String)\n            render json: { error: error }, status: status, content_type: content_type\n          end\n        end\n\n        def spree_current_user\n          @spree_current_user ||= Spree.user_class.find_by(id: doorkeeper_token.resource_owner_id) if doorkeeper_token\n        end\n\n        def spree_authorize!(action, subject, *args)\n          authorize!(action, subject, *args)\n        end\n\n        def require_spree_current_user\n          raise CanCan::AccessDenied if spree_current_user.nil?\n        end\n\n        # Needs to be overriden so that we use Spree's Ability rather than anyone else's.\n        def current_ability\n          @current_ability ||= Spree::Dependencies.ability_class.constantize.new(spree_current_user)\n        end\n\n        def request_includes\n          # if API user want's to receive only the bare-minimum\n          # the API will return only the main resource without any included\n          if params[:include]&.blank?\n            []\n          elsif params[:include].present?\n            params[:include].split(',')\n          end\n        end\n\n        def resource_includes\n          (request_includes || default_resource_includes).map(&:intern)\n        end\n\n        # overwrite this method in your controllers to set JSON API default include value\n        # https://jsonapi.org/format/#fetching-includes\n        # eg.:\n        # %w[images variants]\n        # ['variant.images', 'line_items']\n        def default_resource_includes\n          []\n        end\n\n        def sparse_fields\n          return unless params[:fields]&.respond_to?(:each)\n\n          fields = {}\n          params[:fields].\n            select { |_, v| v.is_a?(String) }.\n            each { |type, values| fields[type.intern] = values.split(',').map(&:intern) }\n          fields.presence\n        end\n\n        def record_not_found\n          render_error_payload(I18n.t(:resource_not_found, scope: 'spree.api'), 404)\n        end\n\n        def access_denied(exception)\n          render_error_payload(exception.message, 403)\n        end\n\n        def gateway_error(exception)\n          render_error_payload(exception.message)\n        end\n      end\n    end\n  end\nend\n", "shared_context 'API v2 tokens' do\n  let(:token) { Doorkeeper::AccessToken.create!(resource_owner_id: user.id, expires_in: nil) }\n  let(:headers_bearer) { { 'Authorization' => \"Bearer #{token.token}\" } }\n  let(:headers_order_token) { { 'X-Spree-Order-Token' => order.token } }\nend\n\n[200, 201, 400, 404, 403, 422].each do |status_code|\n  shared_examples \"returns #{status_code} HTTP status\" do\n    it \"returns #{status_code}\" do\n      expect(response.status).to eq(status_code)\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe 'API v2 Errors spec', type: :request do\n  context 'record not found' do\n    before { get '/api/v2/storefront/products/product-that-doesn-t-exist' }\n\n    it_behaves_like 'returns 404 HTTP status'\n\n    it 'returns proper error message' do\n      expect(json_response['error']).to eq('The resource you were looking for could not be found.')\n    end\n  end\n\n  context 'authorization failure' do\n    let(:user) { create(:user) }\n    let(:another_user) { create(:user) }\n    let!(:order) { create(:order, user: another_user) }\n\n    include_context 'API v2 tokens'\n\n    before do\n      allow_any_instance_of(Spree::Api::V2::Storefront::CartController).to receive(:spree_current_order).and_return(order)\n      patch '/api/v2/storefront/cart/empty', headers: headers_bearer\n    end\n\n    it_behaves_like 'returns 403 HTTP status'\n\n    it 'returns proper error message' do\n      expect(json_response['error']).to eq('You are not authorized to access this page.')\n    end\n  end\nend\n"], "fixing_code": ["module Spree\n  module Api\n    module V2\n      class BaseController < ActionController::API\n        include CanCan::ControllerAdditions\n        include Spree::Core::ControllerHelpers::StrongParameters\n        include Spree::Core::ControllerHelpers::Store\n        rescue_from ActiveRecord::RecordNotFound, with: :record_not_found\n        rescue_from CanCan::AccessDenied, with: :access_denied\n        rescue_from Spree::Core::GatewayError, with: :gateway_error\n\n        def content_type\n          Spree::Api::Config[:api_v2_content_type]\n        end\n\n        private\n\n        def serialize_collection(collection)\n          collection_serializer.new(\n            collection,\n            collection_options(collection)\n          ).serializable_hash\n        end\n\n        def serialize_resource(resource)\n          resource_serializer.new(\n            resource,\n            include: resource_includes,\n            fields: sparse_fields\n          ).serializable_hash\n        end\n\n        def paginated_collection\n          collection_paginator.new(sorted_collection, params).call\n        end\n\n        def collection_paginator\n          Spree::Api::Dependencies.storefront_collection_paginator.constantize\n        end\n\n        def render_serialized_payload(status = 200)\n          render json: yield, status: status, content_type: content_type\n        rescue ArgumentError => exception\n          render_error_payload(exception.message, 400)\n        end\n\n        def render_error_payload(error, status = 422)\n          if error.is_a?(Struct)\n            render json: { error: error.to_s, errors: error.to_h }, status: status, content_type: content_type\n          elsif error.is_a?(String)\n            render json: { error: error }, status: status, content_type: content_type\n          end\n        end\n\n        def spree_current_user\n          return nil unless doorkeeper_token\n          return @spree_current_user if @spree_current_user\n\n          doorkeeper_authorize!\n\n          @spree_current_user ||= Spree.user_class.find_by(id: doorkeeper_token.resource_owner_id)\n        end\n\n        def spree_authorize!(action, subject, *args)\n          authorize!(action, subject, *args)\n        end\n\n        def require_spree_current_user\n          raise CanCan::AccessDenied if spree_current_user.nil?\n        end\n\n        # Needs to be overriden so that we use Spree's Ability rather than anyone else's.\n        def current_ability\n          @current_ability ||= Spree::Dependencies.ability_class.constantize.new(spree_current_user)\n        end\n\n        def request_includes\n          # if API user want's to receive only the bare-minimum\n          # the API will return only the main resource without any included\n          if params[:include]&.blank?\n            []\n          elsif params[:include].present?\n            params[:include].split(',')\n          end\n        end\n\n        def resource_includes\n          (request_includes || default_resource_includes).map(&:intern)\n        end\n\n        # overwrite this method in your controllers to set JSON API default include value\n        # https://jsonapi.org/format/#fetching-includes\n        # eg.:\n        # %w[images variants]\n        # ['variant.images', 'line_items']\n        def default_resource_includes\n          []\n        end\n\n        def sparse_fields\n          return unless params[:fields]&.respond_to?(:each)\n\n          fields = {}\n          params[:fields].\n            select { |_, v| v.is_a?(String) }.\n            each { |type, values| fields[type.intern] = values.split(',').map(&:intern) }\n          fields.presence\n        end\n\n        def record_not_found\n          render_error_payload(I18n.t(:resource_not_found, scope: 'spree.api'), 404)\n        end\n\n        def access_denied(exception)\n          render_error_payload(exception.message, 403)\n        end\n\n        def gateway_error(exception)\n          render_error_payload(exception.message)\n        end\n      end\n    end\n  end\nend\n", "shared_context 'API v2 tokens' do\n  let(:token) { Doorkeeper::AccessToken.create!(resource_owner_id: user.id, expires_in: nil) }\n  let(:headers_bearer) { { 'Authorization' => \"Bearer #{token.token}\" } }\n  let(:headers_order_token) { { 'X-Spree-Order-Token' => order.token } }\nend\n\n[200, 201, 400, 401, 404, 403, 422].each do |status_code|\n  shared_examples \"returns #{status_code} HTTP status\" do\n    it \"returns #{status_code}\" do\n      expect(response.status).to eq(status_code)\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe 'API v2 Errors spec', type: :request do\n  context 'record not found' do\n    before { get '/api/v2/storefront/products/product-that-doesn-t-exist' }\n\n    it_behaves_like 'returns 404 HTTP status'\n\n    it 'returns proper error message' do\n      expect(json_response['error']).to eq('The resource you were looking for could not be found.')\n    end\n  end\n\n  context 'authorization failure' do\n    let(:user) { create(:user) }\n    let(:another_user) { create(:user) }\n    let!(:order) { create(:order, user: another_user) }\n\n    include_context 'API v2 tokens'\n\n    before do\n      allow_any_instance_of(Spree::Api::V2::Storefront::CartController).to receive(:spree_current_order).and_return(order)\n      patch '/api/v2/storefront/cart/empty', headers: headers_bearer\n    end\n\n    it_behaves_like 'returns 403 HTTP status'\n\n    it 'returns proper error message' do\n      expect(json_response['error']).to eq('You are not authorized to access this page.')\n    end\n  end\n\n  context 'expired token failure' do\n    let(:user) { create(:user) }\n    let(:headers) { headers_bearer }\n\n    include_context 'API v2 tokens'\n\n    before do\n      token.expires_in = -1\n      token.save\n      get '/api/v2/storefront/account', headers: headers\n    end\n\n    it_behaves_like 'returns 401 HTTP status'\n  end\nend\n"], "filenames": ["api/app/controllers/spree/api/v2/base_controller.rb", "api/lib/spree/api/testing_support/v2/base.rb", "api/spec/requests/spree/api/v2/errors_spec.rb"], "buggy_code_start_loc": [56, 7, 31], "buggy_code_end_loc": [57, 8, 31], "fixing_code_start_loc": [56, 7, 32], "fixing_code_end_loc": [62, 8, 47], "type": "CWE-613", "message": "In Spree before versions 3.7.11, 4.0.4, or 4.1.11, expired user tokens could be used to access Storefront API v2 endpoints. The issue is patched in versions 3.7.11, 4.0.4 and 4.1.11. A workaround without upgrading is described in the linked advisory.", "other": {"cve": {"id": "CVE-2020-15269", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-20T21:15:12.743", "lastModified": "2021-11-18T16:21:15.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Spree before versions 3.7.11, 4.0.4, or 4.1.11, expired user tokens could be used to access Storefront API v2 endpoints. The issue is patched in versions 3.7.11, 4.0.4 and 4.1.11. A workaround without upgrading is described in the linked advisory."}, {"lang": "es", "value": "En Spree versiones anteriores a 3.7.11, 4.0.4 o 4.1.11, los tokens de usuario vencidos podr\u00edan ser usados para acceder a los endpoints de Storefront API versi\u00f3n v2.&#xa0;El problema est\u00e1 parcheado en las versiones 3.7.11, 4.0.4 y 4.1.11.&#xa0;Una soluci\u00f3n alternativa sin actualizar es descrita en el aviso vinculado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sparksolutions:spree:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.7.11", "matchCriteriaId": "E26F2607-9260-4AA3-A636-3D5EB219CB3A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sparksolutions:spree:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.0.4", "matchCriteriaId": "A7B96C57-83B7-4975-A978-64488EC00415"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sparksolutions:spree:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.11", "matchCriteriaId": "1636D8F5-D862-4F97-B6E8-28D1874A4826"}]}]}], "references": [{"url": "https://github.com/spree/spree/commit/e43643abfe51f54bd9208dd02298b366e9b9a847", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/spree/spree/security/advisories/GHSA-f8cm-364f-q9qh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/spree/spree/commit/e43643abfe51f54bd9208dd02298b366e9b9a847"}}