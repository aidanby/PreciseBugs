{"buggy_code": ["<?php\n\nnamespace Pterodactyl\\Http\\Controllers\\Auth;\n\nuse Illuminate\\Http\\Request;\nuse Pterodactyl\\Models\\User;\nuse Illuminate\\Auth\\AuthManager;\nuse Illuminate\\Http\\JsonResponse;\nuse Illuminate\\Auth\\Events\\Failed;\nuse Illuminate\\Contracts\\Config\\Repository;\nuse Pterodactyl\\Exceptions\\DisplayException;\nuse Pterodactyl\\Http\\Controllers\\Controller;\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\nuse Illuminate\\Foundation\\Auth\\AuthenticatesUsers;\n\nabstract class AbstractLoginController extends Controller\n{\n    use AuthenticatesUsers;\n\n    /**\n     * Lockout time for failed login requests.\n     *\n     * @var int\n     */\n    protected $lockoutTime;\n\n    /**\n     * After how many attempts should logins be throttled and locked.\n     *\n     * @var int\n     */\n    protected $maxLoginAttempts;\n\n    /**\n     * Where to redirect users after login / registration.\n     *\n     * @var string\n     */\n    protected $redirectTo = '/';\n\n    /**\n     * @var \\Illuminate\\Auth\\AuthManager\n     */\n    protected $auth;\n\n    /**\n     * @var \\Illuminate\\Contracts\\Config\\Repository\n     */\n    protected $config;\n\n    /**\n     * LoginController constructor.\n     */\n    public function __construct(AuthManager $auth, Repository $config)\n    {\n        $this->lockoutTime = $config->get('auth.lockout.time');\n        $this->maxLoginAttempts = $config->get('auth.lockout.attempts');\n\n        $this->auth = $auth;\n        $this->config = $config;\n    }\n\n    /**\n     * Get the failed login response instance.\n     *\n     * @throws \\Pterodactyl\\Exceptions\\DisplayException\n     */\n    protected function sendFailedLoginResponse(Request $request, Authenticatable $user = null, string $message = null)\n    {\n        $this->incrementLoginAttempts($request);\n        $this->fireFailedLoginEvent($user, [\n            $this->getField($request->input('user')) => $request->input('user'),\n        ]);\n\n        if ($request->route()->named('auth.login-checkpoint')) {\n            throw new DisplayException($message ?? trans('auth.two_factor.checkpoint_failed'));\n        }\n\n        throw new DisplayException(trans('auth.failed'));\n    }\n\n    /**\n     * Send the response after the user was authenticated.\n     */\n    protected function sendLoginResponse(User $user, Request $request): JsonResponse\n    {\n        $request->session()->regenerate();\n        $this->clearLoginAttempts($request);\n\n        $this->auth->guard()->login($user, true);\n\n        return JsonResponse::create([\n            'data' => [\n                'complete' => true,\n                'intended' => $this->redirectPath(),\n                'user' => $user->toVueObject(),\n            ],\n        ]);\n    }\n\n    /**\n     * Determine if the user is logging in using an email or username,.\n     *\n     * @param string $input\n     */\n    protected function getField(string $input = null): string\n    {\n        return ($input && str_contains($input, '@')) ? 'email' : 'username';\n    }\n\n    /**\n     * Fire a failed login event.\n     */\n    protected function fireFailedLoginEvent(Authenticatable $user = null, array $credentials = [])\n    {\n        event(new Failed('auth', $user, $credentials));\n    }\n}\n", "<?php\n\nnamespace Pterodactyl\\Http\\Controllers\\Auth;\n\nuse Pterodactyl\\Models\\User;\nuse Illuminate\\Auth\\AuthManager;\nuse Illuminate\\Http\\JsonResponse;\nuse PragmaRX\\Google2FA\\Google2FA;\nuse Illuminate\\Contracts\\Config\\Repository;\nuse Illuminate\\Contracts\\Encryption\\Encrypter;\nuse Illuminate\\Database\\Eloquent\\ModelNotFoundException;\nuse Pterodactyl\\Http\\Requests\\Auth\\LoginCheckpointRequest;\nuse Illuminate\\Contracts\\Cache\\Repository as CacheRepository;\nuse Pterodactyl\\Contracts\\Repository\\UserRepositoryInterface;\nuse Pterodactyl\\Repositories\\Eloquent\\RecoveryTokenRepository;\n\nclass LoginCheckpointController extends AbstractLoginController\n{\n    /**\n     * @var \\Illuminate\\Contracts\\Cache\\Repository\n     */\n    private $cache;\n\n    /**\n     * @var \\Pterodactyl\\Contracts\\Repository\\UserRepositoryInterface\n     */\n    private $repository;\n\n    /**\n     * @var \\PragmaRX\\Google2FA\\Google2FA\n     */\n    private $google2FA;\n\n    /**\n     * @var \\Illuminate\\Contracts\\Encryption\\Encrypter\n     */\n    private $encrypter;\n\n    /**\n     * @var \\Pterodactyl\\Repositories\\Eloquent\\RecoveryTokenRepository\n     */\n    private $recoveryTokenRepository;\n\n    /**\n     * LoginCheckpointController constructor.\n     */\n    public function __construct(\n        AuthManager $auth,\n        Encrypter $encrypter,\n        Google2FA $google2FA,\n        Repository $config,\n        CacheRepository $cache,\n        RecoveryTokenRepository $recoveryTokenRepository,\n        UserRepositoryInterface $repository\n    ) {\n        parent::__construct($auth, $config);\n\n        $this->google2FA = $google2FA;\n        $this->cache = $cache;\n        $this->repository = $repository;\n        $this->encrypter = $encrypter;\n        $this->recoveryTokenRepository = $recoveryTokenRepository;\n    }\n\n    /**\n     * Handle a login where the user is required to provide a TOTP authentication\n     * token. Once a user has reached this stage it is assumed that they have already\n     * provided a valid username and password.\n     *\n     * @return \\Illuminate\\Http\\JsonResponse|void\n     *\n     * @throws \\PragmaRX\\Google2FA\\Exceptions\\IncompatibleWithGoogleAuthenticatorException\n     * @throws \\PragmaRX\\Google2FA\\Exceptions\\InvalidCharactersException\n     * @throws \\PragmaRX\\Google2FA\\Exceptions\\SecretKeyTooShortException\n     * @throws \\Exception\n     * @throws \\Illuminate\\Validation\\ValidationException\n     */\n    public function __invoke(LoginCheckpointRequest $request): JsonResponse\n    {\n        if ($this->hasTooManyLoginAttempts($request)) {\n            $this->sendLockoutResponse($request);\n        }\n\n        $token = $request->input('confirmation_token');\n        try {\n            /** @var \\Pterodactyl\\Models\\User $user */\n            $user = User::query()->findOrFail($this->cache->get($token, 0));\n        } catch (ModelNotFoundException $exception) {\n            $this->incrementLoginAttempts($request);\n\n            return $this->sendFailedLoginResponse(\n                $request,\n                null,\n                'The authentication token provided has expired, please refresh the page and try again.'\n            );\n        }\n\n        // Recovery tokens go through a slightly different pathway for usage.\n        if (!is_null($recoveryToken = $request->input('recovery_token'))) {\n            if ($this->isValidRecoveryToken($user, $recoveryToken)) {\n                return $this->sendLoginResponse($user, $request);\n            }\n        } else {\n            $decrypted = $this->encrypter->decrypt($user->totp_secret);\n\n            if ($this->google2FA->verifyKey($decrypted, (string) $request->input('authentication_code') ?? '', config('pterodactyl.auth.2fa.window'))) {\n                $this->cache->delete($token);\n\n                return $this->sendLoginResponse($user, $request);\n            }\n        }\n\n        $this->incrementLoginAttempts($request);\n\n        return $this->sendFailedLoginResponse($request, $user, !empty($recoveryToken) ? 'The recovery token provided is not valid.' : null);\n    }\n\n    /**\n     * Determines if a given recovery token is valid for the user account. If we find a matching token\n     * it will be deleted from the database.\n     *\n     * @return bool\n     *\n     * @throws \\Exception\n     */\n    protected function isValidRecoveryToken(User $user, string $value)\n    {\n        foreach ($user->recoveryTokens as $token) {\n            if (password_verify($value, $token->token)) {\n                $token->delete();\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n", "<?php\n\nnamespace Pterodactyl\\Http\\Controllers\\Auth;\n\nuse Carbon\\CarbonImmutable;\nuse Illuminate\\Support\\Str;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Auth\\AuthManager;\nuse Illuminate\\Http\\JsonResponse;\nuse Illuminate\\Contracts\\View\\View;\nuse Illuminate\\Contracts\\Config\\Repository;\nuse Illuminate\\Contracts\\View\\Factory as ViewFactory;\nuse Illuminate\\Contracts\\Cache\\Repository as CacheRepository;\nuse Pterodactyl\\Contracts\\Repository\\UserRepositoryInterface;\nuse Pterodactyl\\Exceptions\\Repository\\RecordNotFoundException;\n\nclass LoginController extends AbstractLoginController\n{\n    /**\n     * @var \\Illuminate\\Contracts\\View\\Factory\n     */\n    private $view;\n\n    /**\n     * @var \\Illuminate\\Contracts\\Cache\\Repository\n     */\n    private $cache;\n\n    /**\n     * @var \\Pterodactyl\\Contracts\\Repository\\UserRepositoryInterface\n     */\n    private $repository;\n\n    /**\n     * LoginController constructor.\n     */\n    public function __construct(\n        AuthManager $auth,\n        Repository $config,\n        CacheRepository $cache,\n        UserRepositoryInterface $repository,\n        ViewFactory $view\n    ) {\n        parent::__construct($auth, $config);\n\n        $this->view = $view;\n        $this->cache = $cache;\n        $this->repository = $repository;\n    }\n\n    /**\n     * Handle all incoming requests for the authentication routes and render the\n     * base authentication view component. Vuejs will take over at this point and\n     * turn the login area into a SPA.\n     */\n    public function index(): View\n    {\n        return $this->view->make('templates/auth.core');\n    }\n\n    /**\n     * Handle a login request to the application.\n     *\n     * @return \\Illuminate\\Http\\JsonResponse|void\n     *\n     * @throws \\Pterodactyl\\Exceptions\\DisplayException\n     * @throws \\Illuminate\\Validation\\ValidationException\n     */\n    public function login(Request $request): JsonResponse\n    {\n        $username = $request->input('user');\n        $useColumn = $this->getField($username);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            $this->fireLockoutEvent($request);\n            $this->sendLockoutResponse($request);\n        }\n\n        try {\n            $user = $this->repository->findFirstWhere([[$useColumn, '=', $username]]);\n        } catch (RecordNotFoundException $exception) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // Ensure that the account is using a valid username and password before trying to\n        // continue. Previously this was handled in the 2FA checkpoint, however that has\n        // a flaw in which you can discover if an account exists simply by seeing if you\n        // can proceede to the next step in the login process.\n        if (!password_verify($request->input('password'), $user->password)) {\n            return $this->sendFailedLoginResponse($request, $user);\n        }\n\n        if ($user->use_totp) {\n            $token = Str::random(64);\n            $this->cache->put($token, $user->id, CarbonImmutable::now()->addMinutes(5));\n\n            return new JsonResponse([\n                'data' => [\n                    'complete' => false,\n                    'confirmation_token' => $token,\n                ],\n            ]);\n        }\n\n        $this->auth->guard()->login($user, true);\n\n        return $this->sendLoginResponse($user, $request);\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Pterodactyl\\Http\\Controllers\\Auth;\n\nuse Illuminate\\Http\\Request;\nuse Pterodactyl\\Models\\User;\nuse Illuminate\\Auth\\AuthManager;\nuse Illuminate\\Http\\JsonResponse;\nuse Illuminate\\Auth\\Events\\Failed;\nuse Illuminate\\Container\\Container;\nuse Pterodactyl\\Exceptions\\DisplayException;\nuse Pterodactyl\\Http\\Controllers\\Controller;\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\nuse Illuminate\\Foundation\\Auth\\AuthenticatesUsers;\n\nabstract class AbstractLoginController extends Controller\n{\n    use AuthenticatesUsers;\n\n    protected AuthManager $auth;\n\n    /**\n     * Lockout time for failed login requests.\n     *\n     * @var int\n     */\n    protected $lockoutTime;\n\n    /**\n     * After how many attempts should logins be throttled and locked.\n     *\n     * @var int\n     */\n    protected $maxLoginAttempts;\n\n    /**\n     * Where to redirect users after login / registration.\n     *\n     * @var string\n     */\n    protected $redirectTo = '/';\n\n    /**\n     * LoginController constructor.\n     */\n    public function __construct()\n    {\n        $this->lockoutTime = config('auth.lockout.time');\n        $this->maxLoginAttempts = config('auth.lockout.attempts');\n        $this->auth = Container::getInstance()->make(AuthManager::class);\n    }\n\n    /**\n     * Get the failed login response instance.\n     *\n     * @throws \\Pterodactyl\\Exceptions\\DisplayException\n     */\n    protected function sendFailedLoginResponse(Request $request, Authenticatable $user = null, string $message = null)\n    {\n        $this->incrementLoginAttempts($request);\n        $this->fireFailedLoginEvent($user, [\n            $this->getField($request->input('user')) => $request->input('user'),\n        ]);\n\n        if ($request->route()->named('auth.login-checkpoint')) {\n            throw new DisplayException($message ?? trans('auth.two_factor.checkpoint_failed'));\n        }\n\n        throw new DisplayException(trans('auth.failed'));\n    }\n\n    /**\n     * Send the response after the user was authenticated.\n     */\n    protected function sendLoginResponse(User $user, Request $request): JsonResponse\n    {\n        $request->session()->remove('auth_confirmation_token');\n        $request->session()->regenerate();\n\n        $this->clearLoginAttempts($request);\n\n        $this->auth->guard()->login($user, true);\n\n        return new JsonResponse([\n            'data' => [\n                'complete' => true,\n                'intended' => $this->redirectPath(),\n                'user' => $user->toVueObject(),\n            ],\n        ]);\n    }\n\n    /**\n     * Determine if the user is logging in using an email or username,.\n     *\n     * @param string|null $input\n     * @return string\n     */\n    protected function getField(string $input = null): string\n    {\n        return ($input && str_contains($input, '@')) ? 'email' : 'username';\n    }\n\n    /**\n     * Fire a failed login event.\n     */\n    protected function fireFailedLoginEvent(Authenticatable $user = null, array $credentials = [])\n    {\n        event(new Failed('auth', $user, $credentials));\n    }\n}\n", "<?php\n\nnamespace Pterodactyl\\Http\\Controllers\\Auth;\n\nuse Carbon\\CarbonInterface;\nuse Carbon\\CarbonImmutable;\nuse Pterodactyl\\Models\\User;\nuse Illuminate\\Http\\JsonResponse;\nuse PragmaRX\\Google2FA\\Google2FA;\nuse Illuminate\\Contracts\\Encryption\\Encrypter;\nuse Illuminate\\Database\\Eloquent\\ModelNotFoundException;\nuse Pterodactyl\\Http\\Requests\\Auth\\LoginCheckpointRequest;\nuse Illuminate\\Contracts\\Validation\\Factory as ValidationFactory;\n\nclass LoginCheckpointController extends AbstractLoginController\n{\n    private const TOKEN_EXPIRED_MESSAGE = 'The authentication token provided has expired, please refresh the page and try again.';\n\n    private ValidationFactory $validation;\n\n    private Google2FA $google2FA;\n\n    private Encrypter $encrypter;\n\n    /**\n     * LoginCheckpointController constructor.\n     */\n    public function __construct(Encrypter $encrypter, Google2FA $google2FA, ValidationFactory $validation)\n    {\n        parent::__construct();\n\n        $this->google2FA = $google2FA;\n        $this->encrypter = $encrypter;\n        $this->validation = $validation;\n    }\n\n    /**\n     * Handle a login where the user is required to provide a TOTP authentication\n     * token. Once a user has reached this stage it is assumed that they have already\n     * provided a valid username and password.\n     *\n     * @return \\Illuminate\\Http\\JsonResponse|void\n     *\n     * @throws \\PragmaRX\\Google2FA\\Exceptions\\IncompatibleWithGoogleAuthenticatorException\n     * @throws \\PragmaRX\\Google2FA\\Exceptions\\InvalidCharactersException\n     * @throws \\PragmaRX\\Google2FA\\Exceptions\\SecretKeyTooShortException\n     * @throws \\Exception\n     * @throws \\Illuminate\\Validation\\ValidationException\n     */\n    public function __invoke(LoginCheckpointRequest $request): JsonResponse\n    {\n        if ($this->hasTooManyLoginAttempts($request)) {\n            $this->sendLockoutResponse($request);\n        }\n\n        $details = $request->session()->get('auth_confirmation_token');\n        if (!$this->hasValidSessionData($details)) {\n            $this->sendFailedLoginResponse($request, null, self::TOKEN_EXPIRED_MESSAGE);\n        }\n\n        if (!hash_equals($request->input('confirmation_token') ?? '', $details['token_value'])) {\n            $this->sendFailedLoginResponse($request);\n        }\n\n        try {\n            /** @var \\Pterodactyl\\Models\\User $user */\n            $user = User::query()->findOrFail($details['user_id']);\n        } catch (ModelNotFoundException $exception) {\n            $this->sendFailedLoginResponse($request, null, self::TOKEN_EXPIRED_MESSAGE);\n        }\n\n        // Recovery tokens go through a slightly different pathway for usage.\n        if (!is_null($recoveryToken = $request->input('recovery_token'))) {\n            if ($this->isValidRecoveryToken($user, $recoveryToken)) {\n                return $this->sendLoginResponse($user, $request);\n            }\n        } else {\n            $decrypted = $this->encrypter->decrypt($user->totp_secret);\n\n            if ($this->google2FA->verifyKey($decrypted, (string) $request->input('authentication_code') ?? '', config('pterodactyl.auth.2fa.window'))) {\n                return $this->sendLoginResponse($user, $request);\n            }\n        }\n\n        $this->sendFailedLoginResponse($request, $user, !empty($recoveryToken) ? 'The recovery token provided is not valid.' : null);\n    }\n\n    /**\n     * Determines if a given recovery token is valid for the user account. If we find a matching token\n     * it will be deleted from the database.\n     *\n     * @return bool\n     *\n     * @throws \\Exception\n     */\n    protected function isValidRecoveryToken(User $user, string $value)\n    {\n        foreach ($user->recoveryTokens as $token) {\n            if (password_verify($value, $token->token)) {\n                $token->delete();\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Determines if the data provided from the session is valid or not. This\n     * will return false if the data is invalid, or if more time has passed than\n     * was configured when the session was written.\n     *\n     * @param array $data\n     * @return bool\n     */\n    protected function hasValidSessionData(array $data): bool\n    {\n        $validator = $this->validation->make($data, [\n            'user_id' => 'required|integer|min:1',\n            'token_value' => 'required|string',\n            'expires_at' => 'required',\n        ]);\n\n        if ($validator->fails()) {\n            return false;\n        }\n\n        if (!$data['expires_at'] instanceof CarbonInterface) {\n            return false;\n        }\n\n        if ($data['expires_at']->isBefore(CarbonImmutable::now())) {\n            return false;\n        }\n\n        return true;\n    }\n}\n", "<?php\n\nnamespace Pterodactyl\\Http\\Controllers\\Auth;\n\nuse Carbon\\CarbonImmutable;\nuse Illuminate\\Support\\Str;\nuse Illuminate\\Http\\Request;\nuse Pterodactyl\\Models\\User;\nuse Illuminate\\Http\\JsonResponse;\nuse Illuminate\\Contracts\\View\\View;\nuse Illuminate\\Contracts\\View\\Factory as ViewFactory;\nuse Illuminate\\Database\\Eloquent\\ModelNotFoundException;\n\nclass LoginController extends AbstractLoginController\n{\n    private ViewFactory $view;\n\n    /**\n     * LoginController constructor.\n     */\n    public function __construct(ViewFactory $view)\n    {\n        parent::__construct();\n\n        $this->view = $view;\n    }\n\n    /**\n     * Handle all incoming requests for the authentication routes and render the\n     * base authentication view component. Vuejs will take over at this point and\n     * turn the login area into a SPA.\n     */\n    public function index(): View\n    {\n        return $this->view->make('templates/auth.core');\n    }\n\n    /**\n     * Handle a login request to the application.\n     *\n     * @return \\Illuminate\\Http\\JsonResponse|void\n     *\n     * @throws \\Pterodactyl\\Exceptions\\DisplayException\n     * @throws \\Illuminate\\Validation\\ValidationException\n     */\n    public function login(Request $request): JsonResponse\n    {\n        if ($this->hasTooManyLoginAttempts($request)) {\n            $this->fireLockoutEvent($request);\n            $this->sendLockoutResponse($request);\n        }\n\n        try {\n            $username = $request->input('user');\n\n            /** @var \\Pterodactyl\\Models\\User $user */\n            $user = User::query()->where($this->getField($username), $username)->firstOrFail();\n        } catch (ModelNotFoundException $exception) {\n            $this->sendFailedLoginResponse($request);\n        }\n\n        // Ensure that the account is using a valid username and password before trying to\n        // continue. Previously this was handled in the 2FA checkpoint, however that has\n        // a flaw in which you can discover if an account exists simply by seeing if you\n        // can proceede to the next step in the login process.\n        if (!password_verify($request->input('password'), $user->password)) {\n            $this->sendFailedLoginResponse($request, $user);\n        }\n\n        if ($user->use_totp) {\n            $token = Str::random(64);\n\n            $request->session()->put('auth_confirmation_token', [\n                'user_id' => $user->id,\n                'token_value' => $token,\n                'expires_at' => CarbonImmutable::now()->addMinutes(5),\n            ]);\n\n            return new JsonResponse([\n                'data' => [\n                    'complete' => false,\n                    'confirmation_token' => $token,\n                ],\n            ]);\n        }\n\n        $this->auth->guard()->login($user, true);\n\n        return $this->sendLoginResponse($user, $request);\n    }\n}\n"], "filenames": ["app/Http/Controllers/Auth/AbstractLoginController.php", "app/Http/Controllers/Auth/LoginCheckpointController.php", "app/Http/Controllers/Auth/LoginController.php"], "buggy_code_start_loc": [10, 4, 8], "buggy_code_end_loc": [105, 137, 96], "fixing_code_start_loc": [10, 5, 8], "fixing_code_end_loc": [98, 139, 78], "type": "CWE-287", "message": "Pterodactyl is an open-source game server management panel built with PHP 7, React, and Go. A malicious user can modify the contents of a `confirmation_token` input during the two-factor authentication process to reference a cache value not associated with the login attempt. In rare cases this can allow a malicious actor to authenticate as a random user in the Panel. The malicious user must target an account with two-factor authentication enabled, and then must provide a correct two-factor authentication token before being authenticated as that user. Due to a validation flaw in the logic handling user authentication during the two-factor authentication process a malicious user can trick the system into loading credentials for an arbitrary user by modifying the token sent to the server. This authentication flaw is present in the `LoginCheckpointController@__invoke` method which handles two-factor authentication for a user. This controller looks for a request input parameter called `confirmation_token` which is expected to be a 64 character random alpha-numeric string that references a value within the Panel's cache containing a `user_id` value. This value is then used to fetch the user that attempted to login, and lookup their two-factor authentication token. Due to the design of this system, any element in the cache that contains only digits could be referenced by a malicious user, and whatever value is stored at that position would be used as the `user_id`. There are a few different areas of the Panel that store values into the cache that are integers, and a user who determines what those cache keys are could pass one of those keys which would cause this code pathway to reference an arbitrary user. At its heart this is a high-risk login bypass vulnerability. However, there are a few additional conditions that must be met in order for this to be successfully executed, notably: 1.) The account referenced by the malicious cache key must have two-factor authentication enabled. An account without two-factor authentication would cause an exception to be triggered by the authentication logic, thusly exiting this authentication flow. 2.) Even if the malicious user is able to reference a valid cache key that references a valid user account with two-factor authentication, they must provide a valid two-factor authentication token. However, due to the design of this endpoint once a valid user account is found with two-factor authentication enabled there is no rate-limiting present, thusly allowing an attacker to brute force combinations until successful. This leads to a third condition that must be met: 3.) For the duration of this attack sequence the cache key being referenced must continue to exist with a valid `user_id` value. Depending on the specific key being used for this attack, this value may disappear quickly, or be changed by other random user interactions on the Panel, outside the control of the attacker. In order to mitigate this vulnerability the underlying authentication logic was changed to use an encrypted session store that the user is therefore unable to control the value of. This completely removed the use of a user-controlled value being used. In addition, the code was audited to ensure this type of vulnerability is not present elsewhere.", "other": {"cve": {"id": "CVE-2021-41129", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-06T20:15:19.897", "lastModified": "2022-08-12T16:48:54.220", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pterodactyl is an open-source game server management panel built with PHP 7, React, and Go. A malicious user can modify the contents of a `confirmation_token` input during the two-factor authentication process to reference a cache value not associated with the login attempt. In rare cases this can allow a malicious actor to authenticate as a random user in the Panel. The malicious user must target an account with two-factor authentication enabled, and then must provide a correct two-factor authentication token before being authenticated as that user. Due to a validation flaw in the logic handling user authentication during the two-factor authentication process a malicious user can trick the system into loading credentials for an arbitrary user by modifying the token sent to the server. This authentication flaw is present in the `LoginCheckpointController@__invoke` method which handles two-factor authentication for a user. This controller looks for a request input parameter called `confirmation_token` which is expected to be a 64 character random alpha-numeric string that references a value within the Panel's cache containing a `user_id` value. This value is then used to fetch the user that attempted to login, and lookup their two-factor authentication token. Due to the design of this system, any element in the cache that contains only digits could be referenced by a malicious user, and whatever value is stored at that position would be used as the `user_id`. There are a few different areas of the Panel that store values into the cache that are integers, and a user who determines what those cache keys are could pass one of those keys which would cause this code pathway to reference an arbitrary user. At its heart this is a high-risk login bypass vulnerability. However, there are a few additional conditions that must be met in order for this to be successfully executed, notably: 1.) The account referenced by the malicious cache key must have two-factor authentication enabled. An account without two-factor authentication would cause an exception to be triggered by the authentication logic, thusly exiting this authentication flow. 2.) Even if the malicious user is able to reference a valid cache key that references a valid user account with two-factor authentication, they must provide a valid two-factor authentication token. However, due to the design of this endpoint once a valid user account is found with two-factor authentication enabled there is no rate-limiting present, thusly allowing an attacker to brute force combinations until successful. This leads to a third condition that must be met: 3.) For the duration of this attack sequence the cache key being referenced must continue to exist with a valid `user_id` value. Depending on the specific key being used for this attack, this value may disappear quickly, or be changed by other random user interactions on the Panel, outside the control of the attacker. In order to mitigate this vulnerability the underlying authentication logic was changed to use an encrypted session store that the user is therefore unable to control the value of. This completely removed the use of a user-controlled value being used. In addition, the code was audited to ensure this type of vulnerability is not present elsewhere."}, {"lang": "es", "value": "Pterodactyl es un panel de administraci\u00f3n de servidores de juegos de c\u00f3digo abierto construido con PHP 7, React y Go. Un usuario malicioso puede modificar el contenido de una entrada \"confirmation_token\" durante el proceso de autenticaci\u00f3n de dos factores para hacer referencia a un valor de cach\u00e9 no asociado con el intento de inicio de sesi\u00f3n. En casos excepcionales, esto puede permitir a un actor malicioso autenticarse como un usuario aleatorio en el Panel. El usuario malicioso debe dirigirse a una cuenta con la autenticaci\u00f3n de dos factores habilitada y luego debe proporcionar un token de autenticaci\u00f3n de dos factores correcto antes de ser autenticado como dicho usuario. Debido a un fallo de comprobaci\u00f3n en la l\u00f3gica que administra la autenticaci\u00f3n de usuario durante el proceso de autenticaci\u00f3n de dos factores, un usuario malicioso puede enga\u00f1ar al sistema para que cargue las credenciales de un usuario arbitrario modificando el token enviado al servidor. Este fallo de autenticaci\u00f3n est\u00e1 presente en el m\u00e9todo \"LoginCheckpointController@__invoke\" que maneja la autenticaci\u00f3n de dos factores para un usuario. Este controlador busca un par\u00e1metro de entrada de la petici\u00f3n llamado \"confirmation_token\" que se espera que sea una cadena alfanum\u00e9rica aleatoria de 64 caracteres que hace referencia a un valor dentro de la cach\u00e9 del Panel que contiene un valor \"user_id\". Este valor es usado para recuperar el usuario que ha intentado iniciar sesi\u00f3n y buscar su token de autenticaci\u00f3n de dos factores. Debido al dise\u00f1o de este sistema, cualquier elemento de la cach\u00e9 que contenga s\u00f3lo d\u00edgitos podr\u00eda ser referenciado por un usuario malicioso, y cualquier valor almacenado en esa posici\u00f3n ser\u00eda usado como el \"user_id\". Se presentan algunas \u00e1reas diferentes del Panel que almacenan valores en la cach\u00e9 que son enteros, y un usuario que determine cu\u00e1les son esas claves de la cach\u00e9 podr\u00eda pasar una de esas claves que causar\u00eda que esta v\u00eda de c\u00f3digo hiciera referencia a un usuario arbitrario. En el fondo, se trata de una vulnerabilidad de alto riesgo para omitir el inicio de sesi\u00f3n. Sin embargo, hay algunas condiciones adicionales que deben cumplirse para que esto se ejecute con \u00e9xito, en particular 1.) La cuenta a la que hace referencia la clave de cach\u00e9 maliciosa debe tener habilitada la autenticaci\u00f3n de dos factores. Una cuenta sin la autenticaci\u00f3n de dos factores causar\u00eda una excepci\u00f3n en la l\u00f3gica de autenticaci\u00f3n, saliendo as\u00ed de este flujo de autenticaci\u00f3n. 2.) Incluso si el usuario malicioso es capaz de hacer referencia a una clave de cach\u00e9 v\u00e1lida que hace referencia a una cuenta de usuario v\u00e1lida con autenticaci\u00f3n de dos factores, debe proporcionar un token de autenticaci\u00f3n de dos factores v\u00e1lido. Sin embargo, debido al dise\u00f1o de este endpoint, una vez que se encuentra una cuenta de usuario v\u00e1lida con la autenticaci\u00f3n de dos factores habilitada, no hay l\u00edmite de velocidad presente, permitiendo as\u00ed a un atacante hacer combinaciones de fuerza bruta hasta tener \u00e9xito. Esto conlleva a una tercera condici\u00f3n que debe cumplirse: 3.) Durante la duraci\u00f3n de esta secuencia de ataque, la clave de cach\u00e9 a la que se hace referencia debe seguir existiendo con un valor v\u00e1lido de \"user_id\". Dependiendo de la llave espec\u00edfica que se est\u00e9 usando para este ataque, este valor puede desaparecer r\u00e1pidamente, o ser cambiado por otras interacciones aleatorias del usuario en el Panel, fuera del control del atacante. Para mitigar esta vulnerabilidad, se modific\u00f3 la l\u00f3gica de autenticaci\u00f3n subyacente para utilizar un almac\u00e9n de sesi\u00f3n cifrado, cuyo valor no puede ser controlado por el usuario. Esto elimin\u00f3 por completo el uso de un valor controlado por el usuario. Adem\u00e1s, se audit\u00f3 el c\u00f3digo para asegurar que este tipo de vulnerabilidad no est\u00e1 presente en otros lugares"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-502"}, {"lang": "en", "value": "CWE-639"}, {"lang": "en", "value": "CWE-807"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:panel:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "1.6.2", "matchCriteriaId": "39D8D800-578B-42AB-BFCA-6FA76ABDDAE7"}]}]}], "references": [{"url": "https://github.com/pterodactyl/panel/blob/v1.6.2/CHANGELOG.md#v162", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/pterodactyl/panel/commit/4a84c36009be10dbd83051ac1771662c056e4977", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pterodactyl/panel/releases/tag/v1.6.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/pterodactyl/panel/security/advisories/GHSA-5vfx-8w6m-h3v4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pterodactyl/panel/commit/4a84c36009be10dbd83051ac1771662c056e4977"}}