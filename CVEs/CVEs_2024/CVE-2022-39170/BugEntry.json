{"buggy_code": ["\nid: DW202207-001\ncve:\nfuzzer: ossfuzz\ndatereported: 2022-05-01\nreportedby: David Korczynski\nvulnerability: buffer overflow in dwarf_form.c\nproduct: libdwarf\ndescription: A carefully corrupted string\n  would cause libdwarf to read outside of a buffer containing\n  the string (one past the end) when checking the string\n  to determine if it is a full path in processing \n  a .gnu.debuglink section.\n  That could cause a segmentation violation or other\n  major error, terminating the calling application and\n  resulting in Denial Of Service.\ndatefixed: 2022-07-23\nreferences: regressiontests/ossfuzz47150/clusterfuzz-testcase-minimized-fuzz_init_path-6727387238236160.fuzz\ngitfixid:  24dff940cc4c71a9c3cb5475aee231b19163a12c\ntarrelease: \nendrec: DW202207-001\n\nid: DW202206-001\ncve:\nfuzzer: \ndatereported: 2022-06-15\nreportedby: Casper Sun\nvulnerability: buffer overflow in dwarf_form.c\nproduct: libdwarf\ndescription: A carefully corrupted .debug_info section\n  would cause libdwarf to read outside of a buffer containing\n  a Dwarf_Sig8 symbolic reference.\n  That could cause a segmentation violation or other\n  major error, terminating the calling application and\n  resulting in Denial Of Service.\n  This failure to check for buffer overflow has been present\n  since DWARF4 when DW_FORM_ref_sig8 was added to libdwarf.\ndatefixed: 2022-06-15\nreferences: regressiontests/sleicasper2/buffer-overflow-dwarf-form\ngitfixid: 7ef09e1fc9ba07653dd078edb2408631c7969162\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202206-001\n\nid: DW202205-001\ncve:\nfuzzer: \ndatereported: 2022-05-26\nreportedby: Casper Sun\nvulnerability: buffer overflow in dwarf_globals.c\nproduct: libdwarf\ndescription: A carefully corrupted .debug_pubnames section\n  would cause libdwarf to read outside of a buffer containing\n  the section contents.\n  That could cause a segmentation violation or other\n  major error, terminating the calling application and\n  resulting in Denial Of Service.\n  The bug has been present for many years.\ndatefixed: 2022-05-29\nreferences: regressiontests/sleicasper/bufferoverflow\ngitfixid: 8151575a6ace77d005ca5bb5d71c1bfdba3f7069\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202205-001\n\nid: DW202111-016\ncve:\nfuzzer: oss-fuzz-41240\ndatereported: 2021-11-20\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_path\nproduct: libdwarf\ndescription: A corrupted object.\n  The PE object section header for\n  section .gnu_debuglink is corrupted. A very\n  large number is in the VirtualSize field.\n  Attempting a malloc for the section could\n  succeed or might fail, resulting in\n  Denial Of Service.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=41240\n  </pre>\ndatefixed: 2021-11-21\nreferences: regressiontests/ ossfuzz41240/clusterfuzz-testcase-minimized-fuzz_init_path-5929343686148096\ngitfixid: a120c808234060c3c9b1872ab9a059aa1ac70b1d \ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-016\n\nid: DW202111-015\ncve:\nfuzzer: oss-fuzz-40896\ndatereported: 2021-11-10\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_path\nproduct: libdwarf\ndescription: A corrupted object.\n  Several Elf section sizes and section offsets are larger than\n  the file size.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40896\n  </pre>\ndatefixed: 2021-11-12\nreferences: regressiontests/ossfuzz40896/clusterfuzz-testcase-fuzz_init_path-5337872492789760\n  regressiontests/ossfuzz40896/clusterfuzz-testcase-minimized-fuzz_init_path-5337872492789760\ngitfixid: b7a119dc07c502c1334bcbf8dd04ca0e4d5f6ab6\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-015\n\nid: DW202111-014\ncve:\nfuzzer: oss-fuzz-40895\ndatereported: 2021-11-10\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_binary\nproduct: libdwarf\ndescription: A corrupted object.\n  Some Elf section sizes are larger than the file size.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40895\n  </pre>\ndatefixed: 2021-11-12\nreferences: regressiontests/ossfuzz40895/clusterfuzz-testcase-fuzz_init_binary-4805508242997248\n  regressiontests/ossfuzz40895/clusterfuzz-testcase-minimized-fuzz_init_binary-4805508242997248\ngitfixid: b7a119dc07c502c1334bcbf8dd04ca0e4d5f6ab6\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-014\n\n\nid: DW201907-001\ncve: CVE-2019-14249\nfuzzer:\ndatereported: 2019-07-23\nreportedby: unknown\nvulnerability: Denial of service with zero size section group\nproduct: libdwarf\ndescription: dwarf_elf_load_headers.c in libdwarf before 2019-07-05 allows attackers to cause a denial of service (division by zero) via an ELF file with a zero-size section group (SHT_GROUP), as demonstrated by dwarfdump. \ndatefixed: 2019-07-05\nreferences: \ngitfixid: cb7198abde46c2ae29957ad460da6886eaa606ba\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW201907-001\n\nid: DW202111-013\ncve:\nfuzzer: oss-fuzz-40802\ndatereported: 2021-11-07\nreportedby: David Korczynski\nvulnerability: Null-dereference READ in dwarf_object_init_b\nproduct: libdwarf\ndescription: A corrupted object. \n  The error handling code in  dwarf_object_init_b\n  was not properly dealing with a NULL pointer\n  Dwarf_Error *errp in the test code.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40802\n  </pre>\ndatefixed: 2021-11-19\nreferences: regressiontests/ossfuzz40802/ clusterfuzz-testcase-fuzz_init_binary-5538015955517440.fuzz\n  regressiontests/ossfuzz40802/clusterfuzz-testcase-minimized-fuzz_init_binary-5538015955517440.fuzz\n\ngitfixid: adf4dae25b39039f1821b095688c00f3010e1d37\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-013\n\n\n\nid: DW202111-012\ncve:\nfuzzer: oss-fuzz-40801\ndatereported: 2021-11-07\nreportedby: David Korczynski\nvulnerability:  Timeout in fuzz_init_path\nproduct: libdwarf\ndescription: A corrupted object. libdwarf detects it quickly now.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40801\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz801/clusterfuzz-testcase-fuzz_init_path-5443517279764480\n  regressiontests/ossfuzz40801/clusterfuzz-testcase-minimized-fuzz_init_path-5443517279764480\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-012\n\n\nid: DW202111-011\ncve:\nfuzzer: oss-fuzz-40799\ndatereported: 2021-11-02\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_path\nproduct: libdwarf\ndescription: A corrupted object.\n  Gigantic section sizes or offsets were provoking\n  a large malloc.  Now these are detected and\n  no malloc is attempted (an error is returned).\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40799\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40799/clusterfuzz-testcase-fuzz_init_path-5245778948390912\n  regressiontests/ossfuzz40799/clusterfuzz-testcase-minimized-fuzz_init_path-5245778948390912\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-011\n\n\n\nid: DW202111-010\ncve:\nfuzzer: oss-fuzz-40627\ndatereported: 2021-11-02\nreportedby: David Korczynski\nvulnerability: Abrt in _dwarf_error_string\nproduct: libdwarf\ndescription: The Elf object file has some corruption. The\n  read now stops with an error.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40627\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40627/clusterfuzz-testcase-fuzz_init_path-5186858573758464\n  regressiontests/ossfuzz40627/clusterfuzz-testcase-minimized-fuzz_init_path-5186858573758464\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-010\n\nid: DW202111-009\ncve:\nfuzzer: oss-fuzz-40729\ndatereported: 2021-11-05\nreportedby: David Korczynski\nvulnerability: Timeout - fuzz_init_binary\nproduct: libdwarf\ndescription: The object file (macho 64 bit) has some\n  header fuzzing that was not caught reading\n  the object until the macho reader\n  tried a gigantic malloc..\n  Now the library code catches the error before malloc and\n  returns an error code.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40729\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40729/clusterfuzz-testcase-minimized-fuzz_init_binary-4791627277795328\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-009\n\nid: DW202111-008\ncve:\nfuzzer: oss-fuzz-40731\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_binary\nproduct: libdwarf\ndescription: The fuzzed macho64 object has corrupted\n  headers. The library notices and reports an error.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40731\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40731/clusterfuzz-testcase-fuzz_init_binary-5983147574034432\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-008\n\n\nid: DW202111-005\ncve: \nfuzzer: oss-fuzz-40674\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Heap-buffer-overflow in _dwarf_elf_setup_all_section_groups\nproduct: libdwarf\ndescription:  Object file has corrupt section group information.\n  Results in buffer overflow.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40674#c6\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40674/clusterfuzz-testcase-minimized-fuzz_init_path-6557751518560256\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-005\n\nid: DW202111-004\ncve: \nfuzzer: oss-fuzz-40673\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Null-dereference READ in dwarf_object_init_b \nproduct: libdwarf\ndescription: The macho object has corrupted headers\n  and now mentions that and stops.\n  Verified as fixed by oss-fuzz 2021-11-03\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40673\n  </pre>\ndatefixed: 2021-11-05\nreferences: regressiontests/ossfuzz40673/clusterfuzz-testcase-minimized-fuzz_init_path-6240961391362048.fuzz \ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-004\n\nid: DW202111-003\ncve: \nfuzzer: oss-fuzz-40671\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Direct-leak in _dwarf_get_debug\nproduct: libdwarf\ndescription: The test code is calling a libdwarf-internal\n  function (which is against the rules, only libdwarf\n  function names beginning with dwarf_ are callable.\n  When building libdwarf as an archive there is no\n  means to enforce this rule)\n  doc/libdwarf.mm/pdf now documents this rule.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40671\n  </pre>\ndatefixed: 2021-11-05\nreferences: regressiontests/oss40671/clusterfuzz-testcase-fuzz_init_path-5455557297831936\n  regressiontests/oss40671/clusterfuzz-testcase-minimized-fuzz_init_path-5455557297831936\ngitfixid: b40f7e291216e771185f62292dd6304b5a662926\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-003\n\n\nid: DW202111-002\ncve: \nfuzzer: oss-fuzz-40669\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_path\nproduct: libdwarf\ndescription:  Corrupted MachO object can crash caller.b\n  Two fields in the MachO file header\n  were not checked for sanity so nonsense large values\n  could lead to excessive malloc and or a caller\n  segmentation violation. Fixed by DW202111-001.\n  Verified as fixed by oss-fuzz\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40669\n  </pre>\ndatefixed: 2021-11-04\nreferences: regressiontests/ossfuzz40669/clusterfuzz-testcase-minimized-fuzz_init_path-5399726397194240\n  regressiontests/clusterfuzz-testcase-fuzz_init_path-5399726397194240\ngitfixid: b40f7e291216e771185f62292dd6304b5a662926\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-002\n\n\n\nid: DW202111-001\ncve: \nfuzzer: oss-fuzz-40663\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Timeout in fuzz_init_path\nproduct: libdwarf\ndescription:  Corrupted MachO object can crash caller\n  Two fields in the MachO file header\n  were not checked for sanity so nonsense large values\n  could lead to excessive malloc and or a caller\n  segmentation violation.\n  Verified by oss-fuzz as fixed.\n  The testcase has illegal libdwarf call\n  and improper include statements.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40663\n  </pre>\ndatefixed: 2021-11-04\nreferences: regressiontests/ossfuzz40663/clusterfuzz-testcase-minimized-fuzz_init_path-6122542432124928\ngitfixid: b40f7e291216e771185f62292dd6304b5a662926 \ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-001\n\n\nid: DW202010-003\ncve: CVE-2020-28163\ndatereported: 2020-10-27\nreportedby: Casper Sun\nvulnerability: Passing null to %s due to corrupt line table header.\nproduct: libdwarf\ndescription: If a DWARF5 line table header has an invalid\n  FORM for a pathname, the fi_file_name field may be null\n  and printing it via %s can result in referencing memory\n  at address 0, possibly generating segmentation\n  violation or application crash.  Now in case of null\n  we provide a fixed string of <no file name>\n  and for the form code we print the value and <unknown form>\n  so there are no unpredictable effects.\n  <pre>\n  \n  This should be visible after redhat makes it public.\n  Filed on bugzilla.redhat 23 November 2021.\n  bugzilla.redhat.com/show_bug.cgi?id=2026000\n  </pre>\ndatefixed: 2020-10-28\nreferences: regressiontests/c-sun2/nullpointer\ngitfixid: faf99408e3f9f706fc3809dd400e831f989778d3 \ntarrelease:\nendrec: DW202010-003\n\n\nid: DW202010-002\ncve: CVE-2020-28162\ndatereported: 2020-10-27\nreportedby: Casper Sun\nvulnerability: dwarfdump crashes if the nest of C scopes is too deep\nproduct: dwarfdump\ndescription: An object file where the DIEs depth of\n  nesting exceeds the limit of 800 levels\n  due to corruption or a compiler bug \n  can result in exhausting the die stack array and\n  writing past its end.\n  A segmentation fault is possible.\n  The code at the point of error was not adjusting\n  the array index properly\n  so an invalid dereference could occur.\n  Now the test code is correct and the array overflow\n  is detected resulting in a normal error return.\n  Additional places where this could occur were\n  identified and the proper test added.\n  <pre>\n  Unable to enter in bugzilla.redhat.com\n  so CVE can be completed by Fedora (as CNA)\n  as dwarfdump is not part of Fedora\n  </pre>\ndatefixed: 2020-10-28\nreferences: regressiontests/c-sun2/globaloverflow\ngitfixid: a7fa8edd640b74daf8e7a442dcec96640875b4fb \ntarrelease:\nendrec: DW202010-002\n\nid: DW202010-001\ncve: CVE-2020-27545\ndatereported: 2020-10-10\nreportedby: Casper Sun\nvulnerability: A carefully corrupted line table can crash calling app\nproduct: libdwarf\ndescription: A carefully crafted object with an\n  invalid line table could cause libdwarf\n  to dereference a pointer reading a single byte outside of\n  the intended .debug_line section and potentially\n  outside of memory visible to the library.  \n  A segmentation fault is possible.\n  The code testing for the error was coded incorrectly\n  so an invalid dereference could occur.\n  Now the test code is correct and the error\n  is detected resulting in a normal error return.\n  <pre>\n  This should be visible after redhat makes it public.\n  Filed on bugzilla.redhat 22 November 2021.\n  bugzilla.redhat.com/show_bug.cgi?id=2025694\n  </pre>\ndatefixed: 2020-10-17\nreferences: regressiontests/c-sun/poc\ngitfixid:  95f634808c01f1c61bbec56ed2395af997f397ea\ntarrelease: \nendrec: DW202010-001\n\nid: DW201801-001\ncve:\ndatereported: 2018-01-28\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect frame section can crash dwarfdump\nproduct: dwarfdump\ndescription: A carefully crafted object with an\n  invalid frame section set of initial-instructions\n  can crash the frame-instructions decode in\n  dwarfdump. In addition, a couple places in libdwarf\n  are not as careful in checking frame data as\n  they should be.\n  A segmentation-fault/core-dump is possible.\ndatefixed: 2018-01-29\nreferences: sarubbo-11/testcase{1,2,3,4,5}.bin\ngitfixid:  7af0ecddfafed88446969cbf8c888356ad485d99\ntarrelease: libdwarf-20180129.tar.gz\nendrec: DW201801-001\n\n\nid: DW201712-001\ncve:\ndatereported: 2017-12-01\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect frame section could let caller crash\nproduct: libdwarf\ndescription: A carefully crafted object with an\n  invalid frame section\n  can result in passing back data to a caller of \n  dwarf_get_fde_augmentation_data()\n  is erroneous and will result in the \n  caller reference off the end of the frame \n  section.  \n  A segmentation-fault/core-dump is possible.\ndatefixed: 2017-12-01\nreferences: sarubbo-10/1.crashes.bin\ngitfixid: 329ea8e56bc9550260cae6e2e9756bfbe7e2ff6d \ntarrelease:\nendrec: DW201712-001\n\n\n\nid: DW201711-002\ncve:\ndatereported: 2017-11-08\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect line table section could crash caller\nproduct: libdwarf\ndescription: An carefully crafted object with a\n  invalid line table section crafted to\n  end early at a particular point resulted in\n  dereferencing outside the line table from\n  libdwarf/dwarf_line_table_reader_common.c . \n  A segmentation-fault/core-dump is possible.\ndatefixed: 2017-11-08\nreferences: regressiontests/sarubbo-9/3.crashes.bin\ngitfixid: a1644f4dde7dd5990537ff7ad22a9e94b8723186\ntarrelease:\nendrec: DW201711-002\n\nid: DW201711-001\ncve:\ndatereported: 2017-11-01\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect frame section could crash caller\nproduct: libdwarf\ndescription: A carefully crafted object with a\n  resulting invalid frame section\n  with DW_CFA_advance_loc1 implying\n  data off-the-end-of-section\n  will dereference an invalid pointer.\n  A segmentation fault and core dump is possible.\n  Corrected code checks now.\ndatefixed: 2017-11-02\nreferences: regressiontests/sarubbo-8/1.crashes.bin\ngitfixid: 44349d7991e44dd3751794f76537cabcf65ee28d\ntarrelease:\nendrec: DW201711-001\n\n\n\n\nid: DW201709-001\ncve: \ndatereported: 2017-09-19\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect abbrev section could crash caller.\nproduct: libdwarf\ndescription: A fuzzed object with a\n  resulting invalid abbrev section where\n  the end of section follows an abbrev tag\n  would dereference a non-existent has-child byte.\n\ndatefixed: 2017-09-26\nreferences: regressiontests/sarubbo-3/1.crashes.bin\ngitfixid: bcc2e33908e669bacd397e3c941ffd1db3005d17\ntarrelease:\nendrec: DW201709-001\n\n\nid: DW201706-001\ncve: CVE-2017-9998\ndatereported: 2017-06-28\nreportedby: team OWL337\nvulnerability: Addition overflow in libdwarf leads to segmentation violation \nproduct: libdwarf\ndescription: A fuzzed object with a \n  resulting invalid value can overflow\n  when added to a valid pointer\n  (depending on how the runtime memory is laid out) \n  and thereafter a dereference results in a \n  segmentation violation).\n\n <pre> see\n  https://bugzilla.redhat.com/show_bug.cgi?id=1465756\n  for contact information of those finding the bug.\n  Fabian Wolff sent email and provided\n  the link to the web page.\n </pre>\ndatefixed: 2017-07-06\nreferences: regressiontests/wolff/POC1 \ngitfixid: e91681e8841291f57386f26a90897fd1dcf92a6e\ntarrelease: \nendrec: DW201706-001\n\n\n\nid: DW201703-007\ncve:\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in strncmp (libelf bug)\nproduct: libdwarf (libelf)\ndescription:  7/7. A heap overflow in\n  strncmp() is due to libelf failing to check arguments\n  to elf_ strptr.\n  This is not a bug in libdwarf, it is a libelf bug.\n  A  pointer for being in bounds (in a few places in this\n  function) and a failure in a check in dwarf_attr_list().\n  The test object is intentionally corrupted (fuzzed).\n\n <pre>\n A portion of sanitizer output with Ubuntu 14.04:\n ==180133==ERROR: AddressSanitizer: heap-buffer-overflow \n   on address 0x60d00000cff1 at pc 0x0000004476f4 \n   bp 0x7fff87dd7dd0 sp 0x7fff87dd7590\n READ of size 8 at 0x60d00000cff1 thread T0\n    #0 0x4476f3 in __interceptor_strncmp (/home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/dwarfdump+0x4476f3)\n    #1 0x7992ae in this_section_dwarf_relevant /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_init_finish.c:608:13\n    #2 0x781064 in _dwarf_setup /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_init_finish.c:722:14\n    #3 0x77d59c in dwarf_object_init /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_init_finish.c:922:20\n\n With Ubuntu 16.04 libelf dwarfdump gets:\n ERROR:  dwarf_elf_init:  DW_DLE_ELF_STRPTR_ERROR (30) \n a call to elf_strptr() failed trying to get a section name\n </pre>\n Fix date is irrelevant, libdwarf no longer uses libelf.\ndatefixed: \nreferences: regressiontests/marcel/crash7\ngitfixid: \ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-007\n\n\nid: DW201703-006\ncve: CVE-2017-9052\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in dwarf_formsdata \nproduct: libdwarf\ndescription:  6/7. A heap overflow in\n  dwarf_formsdata() is due to a failure to check\n  a  pointer for being in bounds (in a few places in this\n  function) and a failure in a check in dwarf_attr_list().\n  The test object is intentionally corrupted (fuzzed).\n\n <pre>\n A portion of sanitizer output with Ubuntu 14.04:\n ==180130==ERROR: AddressSanitizer: heap-buffer-overflow \n  on address 0x61100000589c at pc 0x0000006cab95 \n  bp 0x7fff749aab10 sp 0x7fff749aab08\n READ of size 1 at 0x61100000589c thread T0\n    #0 0x6cab94 in dwarf_formsdata /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_form.c:937:9\n    #1 0x567daf in get_small_encoding_integer_and_name /home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/print_die.c:1533:16\n    #2 0x562f28 in get_attr_value /home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/print_die.c:5030:24\n    #3 0x555f86 in print_attribute /home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/print_die.c:3357:13\n\n After fixes applied dwarfdump says:\n ERROR:  dwarf_attrlist:  DW_DLE_DW_DLE_ATTR_OUTSIDE_SECTION(281)\n </pre>\n\ndatefixed: 2017-03-21\nreferences: regressiontests/marcel/crash6\ngitfixid: cc37d6917011733d776ae228af4e5d6abe9613c1\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-006\n\n\n\nid: DW201703-005\ncve: CVE-2017-9053\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in _dwarf_read_loc_expr_op()\nproduct: libdwarf\ndescription:  5/7. A heap overflow in \n  _dwarf_read_loc_expr_op() is due to a failure to check\n  a  pointer for being in bounds (in a few places in this\n  function).\n  The test object is intentionally corrupted (fuzzed).\n\n <pre>\n A portion of sanitizer output with Ubuntu 14.04:\n ==180112==ERROR: AddressSanitizer: heap-buffer-overflow \n  on address 0x60800000bf72 at pc 0x00000084dd52 \n  bp 0x7ffc12136fd0 sp 0x7ffc12136fc8\n READ of size 1 at 0x60800000bf72 thread T0\n    #0 0x84dd51 in _dwarf_read_loc_expr_op /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/./dwarf_loc.c:250:9\n    #1 0x841f16 in _dwarf_get_locdesc_c /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/./dwarf_loc2.c:109:15\n    #2 0x837d08 in dwarf_get_loclist_c /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/./dwarf_loc2.c:685:18\n    #3 0x57dff2 in get_location_list /home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/print_die.c:3812:16\n\n After fixes applied dwarfdump says:\n ERROR:  dwarf_get_loclist_c:  DW_DLE_LOCEXPR_OFF_SECTION_END \n (343) Corrupt dwarf\n </pre>\n\ndatefixed: 2017-03-21\nreferences: regressiontests/marcel/crash5\ngitfixid: cc37d6917011733d776ae228af4e5d6abe9613c1\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-005\n\nid: DW201703-004\ncve:\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in set_up_section strlen\nproduct: libdwarf (libelf)\ndescription:  4/7. An apparent heap overflow that\n  gives the appearance of being in libdwarf is due to\n  libelf call elf_strptr() failing to fully check\n  that its arguments make sense.\n  This is not a bug in libdwarf, it is a libelf bug.\n  The test object is intentionally corrupted (fuzzed).\n  The submission was with Ubuntu 14.04. With Ubuntu\n  16.04 there is no sanitizer error report.\n <pre>\n\n A portion of sanitizer output with Ubuntu 14.04:\n ==180109==ERROR: AddressSanitizer: heap-buffer-overflow \n   on address 0x60b00000b000 at pc 0x00000048fd12 \n   bp 0x7fff4ad31ef0 sp 0x7fff4ad316b0\n READ of size 16 at 0x60b00000b000 thread T0\n    #0 0x48fd11 in __interceptor_strlen (/home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/dwarfdump+0x48fd11)\n    #1 0x7a84a4 in set_up_section /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:285:27\n    #2 0x79aaa5 in enter_section_in_de_debug_sections_array /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:355:5\n    #3 0x78170b in _dwarf_setup /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:746:19\n\n With Ubuntu 16.04 libelf one gets:\n ERROR:  dwarf_elf_init:  DW_DLE_ELF_STRPTR_ERROR (30) \n a call to elf_strptr() failed trying to get a section name\n </pre>\ndatefixed:\nreferences: regressiontests/marcel/crash4\ngitfixid:\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-004\n\n\n\nid: DW201703-003\ncve:\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in strcmp \nproduct: libdwarf (libelf)\ndescription:  3/7. An apparent heap overflow that\n  gives the appearance of being in libdwarf is due to\n  libelf call elf_strptr() failing to fully check \n  that its arguments make sense.\n  This is not a bug in libdwarf, it is a libelf bug.\n  The test object is intentionally corrupted (fuzzed).\n  The submission was with Ubuntu 14.04. With Ubuntu\n  16.04 there is no sanitizer error report.\n <pre>\n\n A portion of sanitizer output with Ubuntu 14.04:\n  ==180106==ERROR: AddressSanitizer: heap-buffer-overflow \n    on address 0x60f00000ef09 at pc 0x000000447300 \n    bp 0x7ffc667dce10 sp 0x7ffc667dc5d0\n  READ of size 4 at 0x60f00000ef09 thread T0\n    #0 0x4472ff in __interceptor_strcmp (/home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/dwarfdump+0x4472ff)\n    #1 0x79938f in this_section_dwarf_relevant /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:612:12\n    #2 0x781064 in _dwarf_setup /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:722:14\n    #3 0x77d59c in dwarf_object_init /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:922:20\n    #4 0x899d4f in dwarf_elf_init_file_ownership /\n\n  With Ubuntu 16.04 libelf one gets:\n  ERROR:  dwarf_elf_init:  DW_DLE_ELF_STRPTR_ERROR (30) \n  a call to elf_strptr() failed trying to get a section name\n  </pre>\n  Fix date is irrelevant, libdwarf no longer uses libelf.\ndatefixed: \nreferences: regressiontests/marcel/crash3\ngitfixid:\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-003\n\n\nid: DW201703-002\ncve: CVE-2017-9054\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in _dwarf_decode_s_leb128_chk()\nproduct: libdwarf\ndescription:  2/7. In _dwarf_decode_s_leb128_chk()\n  a byte pointer was dereferenced just before was checked\n  as being in bounds.\n  The test object is intentionally corrupted (fuzzed).\n <pre>\n\n A portion of sanitizer output:\n  .debug_line: line number info for a single cu\n  ==180103==ERROR: AddressSanitizer: heap-buffer-overflow \n    on address 0x610000007ffc at pc 0x0000007b0f5b \n    bp 0x7ffe06bbf510 sp 0x7ffe06bbf508\n  READ of size 1 at 0x610000007ffc thread T0\n    #0 0x7b0f5a in _dwarf_decode_s_leb128_chk /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_leb.c:304:9\n    #1 0x7e753e in read_line_table_program /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/./\n       dwarf_line_table_reader_common.c:1167:17\n    #2 0x7d7fe3 in _dwarf_internal_srclines /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/./dwarf_line.c:690:15\n    #3 0x7f9dbb in dwarf_srclines_b /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/./dwarf_line.c:944:12\n    #4 0x5caaa5 in print_line_numbers_this_cu /home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/print_lines.c:762:16\n\n  After fix applied one gets:\n  ERROR:  dwarf_srclines:  DW_DLE_LEB_IMPROPER (329) \n  Runs off end of section or CU\n </pre>\n\ndatefixed: 2017-03-21\nreferences: regressiontests/marcel/crash2\ngitfixid: cc37d6917011733d776ae228af4e5d6abe9613c1\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-002\n\n\nid: DW201703-001\ncve: CVE-2017-9055\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in dwarf_formsdata\nproduct: libdwarf\ndescription:  1/7. In dwarf_formsdata() a few\n  data types were not checked as being in bounds.\n  The test object is intentionally corrupted (fuzzed).\n <pre>\n\n A portion of sanitizer output:\n LOCAL_SYMBOLS:\n < 1><0x0000002f>    DW_TAG_subprogram\n\n ==180088==ERROR: AddressSanitizer: heap-buffer-overflow on \n  address 0x60800000bf72 at pc 0x0000006cab95 bp \n  0x7fff31425830 sp 0x7fff31425828\n  READ of size 1 at 0x60800000bf72 thread T0\n    #0 0x6cab94 in dwarf_formsdata /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_form.c:937:9\n    #1 0x567daf in get_small_encoding_integer_and_name /home/\n       ubuntu/subjects/build-asan/libdwarf/dwarfdump/print_die.c:1533:16\n    #2 0x576f38 in check_for_type_unsigned /home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/print_die.c:4301:11\n    #3 0x56ad8c in formxdata_print_value /home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/print_die.c:4374:39\n    #4 0x5643be in get_attr_value /home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/print_die.c:5140:24\n    #5 0x555f86 in print_attribute /home/ubuntu/subjects/build\n  ...\n\n  After fixes applied dwarfdump gets:\n  ERROR:  dwarf_attrlist:  DW_DLE_DW_DLE_ATTR_OUTSIDE_SECTION(281)\n </pre>\ndatefixed: 2017-03-21\nreferences: regressiontests/marcel/crash1 \ngitfixid: cc37d6917011733d776ae228af4e5d6abe9613c1\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-001\n\nid: DW201611-008\ncve: CVE-2016-10254\ndatereported: 2016-11-04\nreportedby: Agostino Sarubbo\nvulnerability: Crash libelf reading fuzzed object.\nproduct: libdwarf\ndescription: This is a weakness in libelf checking.\n  Testing that current libdwarf deals with it properly,\n  though it was never a bug in libdwarf.\n  The CVE mentions libdwarf.\n  <pre>\n  blogs.gentoo.org/ago/2016/11/04/elfutils-memory-allocation-failure-in-allocate_elf-common-h/\n  www.openwall.com/lists/oss-security/2017/03/22/2 \n  </pre>\n  Fixed in gentoo libelf by Agostino Sarubbo.\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-b/00011-elfutils-memalloc-allocate_elf \ngitfixid:\ntarrelease:\nendrec: DW201611-008\n\nid: DW201611-007\ncve: CVE-2016-10255\ndatereported: 2016-11-04\nreportedby: Agostino Sarubbo\nvulnerability: Crash libelf reading fuzzed object.\nproduct: libdwarf\ndescription: This is a weakness in libelf checking.\n  Testing that current libdwarf deals with it properly,\n  though it was never a bug in libdwarf.\n  The CVE mentions libdwarf.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1387584 \n  www.openwall.com/lists/oss-security/2017/03/22/1 \n  blogs.gentoo.org/ago/2016/11/04/elfutils-memory-allocation-failure-in-__libelf_set_rawdata_wrlock-elf_getdata-c/ \n  </pre>\n  Fixed in gentoo libelf by Agostino Sarubbo.\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-a/00031-elfutils-memalloc-__libelf_set_rawdata_wrlock\ngitfixid:\ntarrelease:\nendrec: DW201611-007\n\n  \n\nid: DW201611-006\ncve: CVE-2016-9480\ndatereported: 2016-11-14\nreportedby: Puzzor (Shi Ji)\nvulnerability: Heap buffer overflow\nproduct: libdwarf\ndescription: An object with corrupt contents causes a memory reference\n out of bounds, a heap buffer overflow reference.\n <pre>\n heap-buffer-overflow in dwarf_util.c:208 for val_ptr\n\n # Version\n bb9a3492ac5713bed9cf3ae58ddb7afa6e9e98f8\n (in regression tests here named  heap_buf_overflow.o)\n\n\n # ASAN Output\n <0> tag: 17 DW_TAG_compile_unit  name: \"strstrnocase.c\" FORM 0xe \"DW_FORM_strp\"\n <1> tag: 46 DW_TAG_subprogram  name: \"is_strstrnocase\" FORM 0xe \"DW_FORM_strp\"\n =================\n ==1666==ERROR: AddressSanitizer: heap-buffer-overflow on address \n   0xb5846db9 at p\n c 0x080b3a1b bp 0xbfa75d18 sp 0xbfa75d08\n READ of size 1 at 0xb5846db9 thread T0\n    #0 0x80b3a1a in _dwarf_get_size_of_val /home/puzzor/libdwarf-code/\n        libdwarf/dwarf_util.c:208\n    #1 0x8056602 in _dwarf_next_die_info_ptr /home/puzzor/libdwarf-code/\n        libdwarf/dwarf_die_deliv.c:1353\n    #2 0x8057f4b in dwarf_child /home/puzzor/libdwarf-code/libdwarf/\n       dwarf_die_de liv.c:1688\n    #3 0x804b5fa in get_die_and_siblings simplereader.c:637\n    #4 0x804b65c in get_die_and_siblings simplereader.c:643\n    #5 0x804b3f3 in read_cu_list simplereader.c:611\n    #6 0x804aeae in main simplereader.c:533\n    #7 0xb6ffe275 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18275)\n    #8 0x80491c0  (/home/puzzor/libdwarf-code/dwarfexample/simplereader+\n         0x80491c 0)\n\n 0xb5846db9 is located 0 bytes to the right of 249-byte region \n    [0xb5846cc0,0xb5846db9)\n allocated by thread T0 here:\n    #0 0xb727fae4 in __interceptor_malloc (/usr/lib/i386-linux-gnu/libasan.so.\n       3+ 0xc3ae4)\n    #1 0xb71a9b98  (/usr/lib/i386-linux-gnu/libelf.so.1+0x9b98)\n </pre>\n For the orignal bug report see\n <pre>\n https://sourceforge.net/p/libdwarf/bugs/5/\n </pre>\ndatefixed: 2016-11-16\nreferences: regressiontests/puzzor/heap_buf_overflow.o\ngitfixid: 5dd64de047cd5ec479fb11fe7ff2692fd819e5e5\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\n\nid: DW201611-005\ncve: CVE-2016-9558\ndatereported: 2016-11-11\nreportedby: Agostino Sarubbo\nvulnerability: negation of -9223372036854775808 cannot be represented in type \nproduct: libdwarf\ndescription: With the right bit pattern in a signed leb number\n the signed leb decode would execute an unary minus with undefined\n effect. This is not known to generate an incorrect value,\n but it could, one supposes.\ndatefixed: 2016-11-11\nreferences: regressiontests/sarubbo-2/00050-libdwarf-negate-itself\ngitfixid: 4f19e1050cd8e9ddf2cb6caa061ff2fec4c9b5f9\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201611-004\ncve: CVE-2016-9275\ndatereported: 2016-11-02\nreportedby: Agostino Sarubbo\nvulnerability: Heap overflow in dwarf_skim_forms()\nproduct: libdwarf\ndescription: If a non-terminated string \n  in a DWARF5 macro section \n  ends a section it can result in accessing memory not\n  in the application (out of bounds read).\n  dwarf_macro5.c(in _dwarf_skim_forms()).\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-2/00027-libdwarf-heapoverflow-_dwarf_skim_forms\ngitfixid:  583f8834083b5ef834c497f5b47797e16101a9a6\nendrec:\n\nid: DW201611-003\ncve: CVE-2016-9276\ndatereported: 2016-11-02\nreportedby: Agostino Sarubbo\nvulnerability: Bad aranges length leads to overflow and bad pointer\nproduct: libdwarf\ndescription:  in dwarf_arange.c(dwarf_get_aranges_list) an aranges\n header with corrupt data could, with an overflowing calculation,\n result in pointers to invalid or inappropriate memory being\n dereferenced.\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-2/00026-libdwarf-heapoverflow-dwarf_get_aranges_list\ngitfixid:  583f8834083b5ef834c497f5b47797e16101a9a6\ntarrelease: libdwarf-20170416.tar.gz\nendrec:\n\n\nid: DW201611-002\ncve:\ndatereported: 2016-11-02\nreportedby: Agostino Sarubbo\nvulnerability: heap overflow in get_attr_value\nproduct: libdwarf\ndescription: Libdwarf failed to check for a bogus\n length in dwarf_form.c (dwarf_formblock()) resulting\n in a pointer pointing outside of the intended memory\n region.  Anything could happen in the subsequent\n use of the bogus pointer.\n <pre>\n 0x61300000de1c is located 0 bytes to the right of 348-byte region \n [0x61300000dcc0,0x61300000de1c) \n allocated by thread T0 here: \n   #0 0x4c0ad8 in malloc /var/tmp/portage/sys-devel/llvm-3.8.1-\n r2/work/llvm-3.8.1.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52 \n   #1 0x7f883cfc6206 in __libelf_set_rawdata_wrlock /tmp/portage/dev-\n libs/elfutils-0.166/work/elfutils-0.166/libelf/elf_getdata.c:318\n </pre>\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-2/00025-libdwarf-heapoverflow-get_attr_value\ngitfixid:  583f8834083b5ef834c497f5b47797e16101a9a6\ntarrelease: libdwarf-20170416.tar.gz \nendrec:\n\nid: DW201611-001\ncve:\ndatereported: 2016-11-02\nreportedby: Agostino Sarubbo\nvulnerability: Memory allocation failure in do_decompress_zlib\nproduct: libdwarf\ndescription: In decompressing a zlib compressed section if\n the decompressed section size is nonsense (too large)\n an attempted malloc will fail and could let an exception\n propagate to callers.\n <pre>\n  ==27994==WARNING: AddressSanitizer failed to allocate 0x62696c2f7273752f\n  bytes ==27994==AddressSanitizer's allocator is terminating the process\n  instead of returning 0\n  ...\n   #6 0x4c0ab1 in malloc /var/tmp/portage/sys-devel/llvm-3.8.1-\nr2/work/llvm-3.8.1.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:53\n#7 0x5b582e in do_decompress_zlib\n/tmp/dwarf-20161021/libdwarf/dwarf_init_finish.c:1085:12\n   #8 0x5b582e in _dwarf_load_section\n/tmp/dwarf-20161021/libdwarf/dwarf_init_finish.c:1159\n   #9 0x5bb479 in dwarf_srcfiles\n/tmp/dwarf-20161021/libdwarf/./dwarf_line.c:336:11\n   #10 0x5145cd in print_one_die_section\n </pre>\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-2/00024-libdwarf-memalloc-do_decompress_zlib\ngitfixid:  583f8834083b5ef834c497f5b47797e16101a9a6\ntarrelease: libdwarf-20170416.tar.gz \nendrec: DW201611-001\n\nid: DW201610-003\ncve: CVE-2016-8679\ndatereported: 2016-10-02\nreportedby: agostino\nvulnerability: dwarf_get_size_of_val out of bounds read\nproduct: libdwarf\ndescription: The _dwarf_get_size_of_val function in \n  libdwarf/dwarf_util.c in Libdwarf before 20161124 \n  allows remote attackers to cause a denial of service \n  (out-of-bounds read) by calling the dwarfdump command \n  on a crafted file. \n  <pre>\n  www.securityfocus.com/bid/93601\n  blogs.gentoo.org/ago/2016/10/06/libdwarf-heap-based-\n  buffer-overflow-in-_dwarf_get_size_of_val-dwarf_util-c/\n  </pre>\ndatefixed: 2016-10-04\nreferences:\ngitfixid: efe48cad0693d6994d9a7b561e1c3833b073a624\nendrec: DW201610-003\n\nid: DW201610-002\ncve: CVE-2016-8680\ndatereported: 2016-10-02\nreportedby: agostino\nvulnerability: Out of bounds read\nproduct: libdwarf\ndescription: The _dwarf_get_abbrev_for_code function in\n  dwarf_util.c in libdwarf 20161001 and earlier allows remote \n  attackers to cause a denial of service (out-of-bounds read) \n  by calling the dwarfdump command on a crafted file. \n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1385690\n  www.securityfocus.com/bid/93592\n  Duplicate of CVE-2016-8681\n  </pre>\ndatefixed: 2016-10-04\nreferences: \ngitfixid: efe48cad0693d6994d9a7b561e1c3833b073a624\nendrec: DW201610-002\n\n\n\n\nid: DW201610-001\ncve: CVE-2016-8681\ndatereported: 2016-10-02\nreportedby: agostino\nvulnerability: Out of bounds read\nproduct: libdwarf\ndescription: The _dwarf_get_abbrev_for_code function in\n  dwarf_util.c in libdwarf 20161001 and earlier allows remote \n  attackers to cause a denial of service (out-of-bounds read) \n  by calling the dwarfdump command on a crafted file. \n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1385690\n  www.securityfocus.com/bid/93592\n  Duplicate of CVE-2016-8680\n  </pre>\ndatefixed: 2016-10-04\nreferences: \ngitfixid: efe48cad0693d6994d9a7b561e1c3833b073a624\nendrec: DW201610-001\n\n\nid: DW201609-004\ncve: CVE-2016-7510 \ndatereported: 2016-09-17\nreportedby: Puzzor\nvulnerability: libdwarf 20160613 Out-of-Bounds read\nproduct: libdwarf\ndescription:  read line table program Out-of-Bounds read\n line_ptr in dwarf_line_table_reader_common.c:1433 Out-of-Bounds read\n See:\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1377015\n https://sourceforge.net/p/libdwarf/bugs/4/\n </pre>\n <pre>\n # Address Sanitizer Output\n ==27763==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4603f84 at pc 0x8408ede bp 0xffff6518 sp 0xffff6510\n READ of size 1 at 0xf4603f84 thread T0\n #0 0x8408edd in read_line_table_program /home/puzzor/test-fuzzing/code/libdwarf/./dwarf_line_table_reader_common.c:1433\n #1 0x83f716c in _dwarf_internal_srclines /home/puzzor/test-fuzzing/code/libdwarf/./dwarf_line.c:690\n #2 0x841436c in dwarf_srclines_b /home/puzzor/test-fuzzing/code/libdwarf/./dwarf_line.c:944\n #3 0x81fbc28 in print_line_numbers_this_cu /home/puzzor/test-fuzzing/code/dwarfdump/print_lines.c:763\n #4 0x815c191 in print_one_die_section /home/puzzor/test-fuzzing/code/dwarfdump/print_die.c:850\n #5 0x81565c1 in print_infos /home/puzzor/test-fuzzing/code/dwarfdump\n </pre>\ndatefixed: 2016-09-23\nreferences: regressiontests/DW201609-004/poc\ngitfixid:  3767305debcba8bd7e1c483ae48c509d25399252\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\n\nid: DW201609-003\ncve: CVE-2016-7410\ndatereported: 2016-09-13\nreportedby: https://marc.info/?l=oss-security&m=147391785920048&w=2\nvulnerability: libdwarf 20160613 heap-buffer-overflow\nproduct: libdwarf\ndescription: With AddressSanitizer, \n  we found a Heap-Buffer-overflow in the latest\n  release version of dwarfdump. The crash output is as follows:\n  <pre>\n  See also:\n  https://marc.info/?l=oss-security&m=147378394815872&w=2\n  The testcase poc is from this web page.\n  </pre>\n  <pre>\n  ==17411==ERROR: AddressSanitizer: heap-buffer-overflow on address\n  0xf3808904 at pc 0x80a6f76 bp 0xffb95e78 sp 0xffb95a5c\n  READ of size 4 at 0xf3808904 thread T0\n  ==17411==WARNING: Trying to symbolize code, but external symbolizer is\n  not initialized!\n    #0 0x80a6f75 in __interceptor_memcpy ??:?\n    #1 0x8426c3b in _dwarf_read_loc_section\n  /home/starlab/fuzzing/dwarf-20160613/libdwarf/./dwarf_loc.c:919\n    #2 0x84250e2 in _dwarf_get_loclist_count\n  /home/starlab/fuzzing/dwarf-20160613/libdwarf/./dwarf_loc.c:970\n    #3 0x8438826 in dwarf_get_loclist_c\n  /home/starlab/fuzzing/dwarf-20160613/libdwarf/./dwarf_loc2.c:551\n    #4 0x81a1be8 in get_location_list\n  /home/starlab/fuzzing/dwarf-20160613/dwarfdump/print_die.c:3523\n    #5 0x816e1a2 in print_attribute\n  </pre>\n  _dwarf_get_loclist_header_start() is not cautious about values\n  in the header being absurdly large.\n  Unclear as yet if this is the problem\n  but it is a potential problem (fixed for next release).\n  <pre>\n  Address Sanitizer in gcc reproduces the report.\n  In _dwarf_read_loc_section() the simple calculation of\n  loc_section_end was wrong, so end-of section was\n  incorrect for the local reads.\n  With that fixed we get DW_DLE_READ_LITTLEENDIAN_ERROR when\n  libdwarf attempts to read off end of section.\n  </pre>\ndatefixed: 2016-09-23\nreferences: regressiontests/DW201609-003/poc\ngitfixid:  3767305debcba8bd7e1c483ae48c509d25399252\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201609-002\ncve: CVE-2016-7511\ndatereported: 2016-09-18\nreportedby: Shi Ji (@Puzzor)\nvulnerability: libdwarf 20160613 Integer Overflow\nproduct: libdwarf\ndescription: In dwarf_get_size_of_val() with\n  fuzzed DWARF data we get a SEGV. \n  <pre>\n  See\n  https://sourceforge.net/p/libdwarf/bugs/3/\n  </pre>\n  <pre>\n  ==6825== ERROR: AddressSanitizer: SEGV on unknown address 0x0583903c (pc 0xb61f1a98 sp 0xbfa388b4 bp 0xbfa38d08 T0)\n  AddressSanitizer can not provide additional info.\n  #1 0xb61e3c0b (/usr/lib/i386-linux-gnu/libasan.so.0+0xdc0b)\n  #2 0x80a21b1 in _dwarf_get_size_of_val /home/fuzzing/fuzzing/dwarf-20160613/libdwarf/dwarf_util.c:210\n  #3 0x8054214 in _dwarf_next_die_info_ptr /home/fuzzing/fuzzing/dwarf-20160613/libdwarf/dwarf_die_deliv.c:1340\n  #4 0x80557a5 in dwarf_child /home/fuzzing/fuzzing/dwarf-20160613/libdwarf/dwarf_die_deliv.c:1640\n  #5 0x804b23f in get_die_and_siblings /home/fuzzing/fuzzing/dwarf-20160613/dwarfexample/./simplereader.c:573\n  </pre>\n  _dwarf_make_CU_Context() is insufficiently cautious about\n  the length of a CU being absurd. \n  Unclear as yet if this is the problem\n  but it is a problem and is fixed for next release.\ndatefixed: 2016-09-23\nreferences: regressiontests/DW201609-002/DW201609-002-poc\ngitfixid:   3767305debcba8bd7e1c483ae48c509d25399252\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\nid: DW201609-001\ncve: \ndatereported: 2016-09-16\nreportedby: STARLAB\n   https://sourceforge.net/p/libdwarf/bugs/2/\nvulnerability: libdwarf 20160613 die_info_ptr in dwarf_die_deliv.c: 1533 Out-Of_bounds\nproduct: libdwarf\ndescription: At line 1533 of dwarf_die_deliv.c a\n pointer dereference is done with a pointer pointing\n past the end of the CU data.\n <pre>\n see\n https://sourceforge.net/p/libdwarf/bugs/2/\n </pre>\n <pre>\n ==8054==ERROR: AddressSanitizer: heap-buffer-overflow on \n    address 0xf4c027ab at pc 0x819e4a4 bp 0xff88eb38 sp 0xff88eb30\n READ of size 1 at 0xf4c027ab thread T0\n #0 0x819e4a3 in dwarf_siblingof_b /home/starlab/fuzzing/dwarf-20160613/libdwarf/dwarf_die_deliv.c:1533\n #1 0x8116201 in print_die_and_children_internal /home/starlab/fuzzing/dwarf-20160613/dwarfdump/print_die.c:1157\n Bug report on sourceforge.net bug list for libdwarf.\n The bad pointer dereference is due to libdwarf \n not noticing that the DWARF in that file is corrupt.\n In addtion\n The code was not noticing that it could dereference\n a pointer that pointed out of bounds in the end-sibling-list\n loop. \n </pre>\n <pre>\n The example from the bug report (DW201609-001-poc) has\n the same problem.\n dwarfdump now reports DW_DLE_SIBLING_LIST_IMPROPER\n on both test2.o and DW201609-001-poc.\n </pre>\ndatefixed: 2016-09-17\nreferences: regressiontests/DW201609-001/test2.o \n  regressiontests/DW201609-001/DW201609-001-poc\ngitfixid:  3767305debcba8bd7e1c483ae48c509d25399252\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-019\ncve: CVE-2016-5028\ndatereported: 2016-05-23\nreportedby: Yue Liu\nvulnerability: Null dereference in print_frame_inst_bytes (dwarfdump)\nproduct: libdwarf\ndescription: The null dereference is due to a corrupted\n object file. Libdwarf was not dealing with empty (bss-like)\n sections since it really did not expect to see such in\n sections it reads!  Now libdwarf catches the object error\n so dwarfdump sees the section as empty (as indeed it is!).\ndatefixed: 2016-05-23\nreferences: regressiontests/liu/NULLdeference0522c.elf\ngitfixid: a55b958926cc67f89a512ed30bb5a22b0adb10f4\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-018\ncve: CVE-2016-5029\ndatereported: 2016-05-22\nreportedby: Yue Liu\nvulnerability: Null dereference in create_fullest_file_path().\nproduct: libdwarf\ndescription: The null dereference in create_fullest_file_path()\n causes a crash. This is due to corrupted dwarf and the fix\n detects this corruption and if that null string pointer\n happens undetected a static string is substituted so\n readers can notice the situation.\n <pre>\n  202             }\n 203             if (dirno > 0 && fe->fi_dir_index > 0) {\n 204                 inc_dir_name = (char *) \n                         line_context->lc_include_directories[\n 205                     fe->fi_dir_index - 1];\n 206                 incdirnamelen = strlen(inc_dir_name);  <- $pc\n 207             }\n 208             full_name = (char *) _dwarf_get_alloc(dbg, \n\n #0  create_fullest_file_path (dbg=<optimized out>,\n fe=0x68d510, line_context=0x68c4f0, name_ptr_out=<optimized\n out>, error=0x7fffffffe2b8) at ./dwarf_line.c:206\n\n #1  0x00007ffff7b6d3f9 in dwarf_filename (context=<optimized\n out>, fileno_in=<optimized out>, ret_filename=0x7fffffffe280,\n error=0x7fffffffe2b8) at ./dwarf_line.c:1418\n\n #2  dwarf_linesrc (line=<optimized out>,\n ret_linesrc=<optimized out>, error=<optimized out>) at\n ./dwarf_line.c:1436\n </pre>\ndatefixed: 2016-05-22\nreferences: regressiontests/liu/NULLdereference0522.elf\ngitfixid: acae971371daa23a19358bc62204007d258fbc5e\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\n\nid: DW201605-017\ncve: CVE-2016-5030\ndatereported: 2016-05-19\nreportedby: Yue Liu\nvulnerability: Null dereference bug in  _dwarf_calculate_info_section_end_ptr().\nproduct: libdwarf\ndescription: \n NULL dereference bug in _dwarf_calculate_info_section_end_ptr().\n <pre>\n 1742         Dwarf_Off off2 = 0;\n 1743         Dwarf_Small *dataptr = 0;\n 1744     \n 1745         dbg = context->cc_dbg;\n 1746         dataptr = context->cc_is_info? dbg->de_debug_info.dss_data:                 <- $pc\n 1747             dbg->de_debug_types.dss_data;\n 1748         off2 = context->cc_debug_offset;\n 1749         info_start = dataptr + off2;\n 1750         info_end = info_start + context->cc_length +\n \n #0  _dwarf_calculate_info_section_end_ptr\n (context=context@entry=0x0) at dwarf_query.c:1746\n \n #1  0x00002aaaaace307d in\n _dwarf_extract_string_offset_via_str_offsets\n (dbg=dbg@entry=0x655a70, info_data_ptr=0x6629f0\n \"\", attrnum=attrnum@entry=121,\n attrform=attrform@entry=26, cu_context=0x0,\n str_sect_offset_out=str_sect_offset_out@entry=0x7fffffffd718,\n error=error@entry=0x7fffffffd878) at dwarf_form.c:1099\n \n #2  0x00002aaaaacf4ed7 in dwarf_get_macro_defundef\n (macro_context=macro_context@entry=0x65b790,\n op_number=op_number@entry=1,\n line_number=line_number@entry=0x7fffffffd858,\n index=index@entry=0x7fffffffd860,\n offset=offset@entry=0x7fffffffd868,\n forms_count=forms_count@entry=0x7fffffffd7ce,\n macro_string=macro_string@entry=0x7fffffffd870,\n error=error@entry=0x7fffffffd878) at dwarf_macro5.c:557\n \n ------\n \n _dwarf_calculate_info_section_end_ptr (context=context@entry=0x0) at \n   dwarf_query.c:1746\n 1746        dataptr = context->cc_is_info? dbg->de_debug_info.dss_data:\n gef> p/x $rdi\n $4 = 0x0\n </pre>\ndatefixed: 2016-05-22\nreferences: regressiontests/liu/NULLdereference0519.elf\ngitfixid: 6fa3f710ee6f21bba7966b963033a91d77c952bd\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\nid: DW201605-016\ncve:\ndatereported: 2016-05-19\nreportedby: Yue Liu\nvulnerability: Invalid dwarf leads to \n dwarfdump crash in print_frame_inst_bytes.\nproduct: dwarfdump\ndescription: Corrupted dwarf crashes dwarfdump\n <pre>\n 1297         }\n 1298         len = len_in;\n 1299         endpoint = instp + len;\n 1300         for (; len > 0;) {\n 1301             unsigned char ibyte = *instp;           <- $pc\n 1302             int top = ibyte & 0xc0;\n 1303             int bottom = ibyte & 0x3f;\n 1304             int delta = 0;\n 1305             int reg = 0;\n\n #0  print_frame_inst_bytes (dbg=dbg@entry=0x655ca0,\n cie_init_inst=<optimized out>, len_in=<optimized out>,\n data_alignment_factor=-4, code_alignment_factor=4,\n addr_size=addr_size@entry=4, offset_size=4, version=3,\n config_data=config_data@entry=0x63cda0 <g_config_file_data>)\n at print_frames.c:1301\n\n #1  0x000000000041b70c in print_one_cie\n (dbg=dbg@entry=0x655ca0, cie=<optimized out>,\n cie_index=cie_index@entry=2, address_size=<optimized out>,\n config_data=config_data@entry=0x63cda0 <g_config_file_data>)\n at print_frames.c:1161\n\n #2  0x000000000041cf52 in print_frames (dbg=0x655ca0,\n print_debug_frame=print_debug_frame@entry=1, print_eh_frame=0,\n config_data=config_data@entry=0x63cda0 <g_config_file_data>)\n at print_frames.c:2229\n\n gef> p/x $r13\n $1 = 0x4bcad8\n gef> p/x *$r13\n Cannot access memory at address 0x4bcad8\n </pre>\ndatefixed: 2016-05-22\nreferences: regressiontests/liu/OOB_READ0519.elf\ngitfixid: 6fa3f710ee6f21bba7966b963033a91d77c952bd\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-015\ncve: CVE-2016-5031\ndatereported: 2016-05-17\nreportedby: Yue Liu\nvulnerability: OOB read bug in print_frame_inst_bytes()\nproduct: libdwarf\ndescription: Test object shows\n an invalid read in  print_frame_inst_bytes().\n <pre>\n 1294         for (; len > 0;) {\n 1295             unsigned char ibyte = *instp;           <- $pc\n 1296             int top = ibyte & 0xc0;\n\n #0  print_frame_inst_bytes (dbg=dbg@entry=0x654c80, \n    cie_init_inst=<optimized out>, len=503715, data_alignment_factor=-4, \n    code_alignment_factor=1, addr_size=addr_size@entry=4, offset_size=4, \n    version=3, config_data=config_data@entry=0x63bda0 \n    <g_config_file_data>) at print_frames.c:1295\n #1  0x000000000041b64c in print_one_cie (dbg=dbg@entry=0x654c80, \n    cie=<optimized out>, cie_index=cie_index@entry=1, \n    address_size=<optimized out>, config_data=\n    config_data@entry=0x63bda0 <g_config_file_data>) at print_frames.c:1161\n #2  0x000000000041ce92 in print_frames (dbg=0x654c80, \n    print_debug_frame=print_debug_frame@entry=1, print_eh_frame=0, \n    config_data=config_data@entry=0x63bda0 <g_config_file_data>) \n    at print_frames.c:2209\n\n gef> x/10x $r13\n 0x5e7981:       Cannot access memory at address 0x5e7981\n gef> p/x $r13\n $14 = 0x5e7981\n </pre>\ndatefixed: 2015-05-18\nreferences: regressiontests/liu/OOB0517_03.elf\ngitfixid: ac6673e32f3443a5d36c2217cb814000930b2c54\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\n\nid: DW201605-014\ncve: CVE-2016-5032\ndatereported: 2016-05-17\nreportedby: Yue Liu\nvulnerability: OOB read bug in dwarf_get_xu_hash_entry()\nproduct: libdwarf\ndescription: Test object shows\n an invalid read in dwarf_get _xu_hash_entry, lin 211.\n <pre>\n #0  dwarf_get_xu_hash_entry (xuhdr=xuhdr@entry=0x657360, \n    index=index@entry=2897626028, hash_value=\n    hash_value@entry=0x7fffffffd5b0, \n    index_to_sections=index_to_sections@entry=0x7fffffffd5a8, \n    err=err@entry=0x7fffffffdb08) at dwarf_xu_index.c:211\n #1  0x00002aaaaacfd05e in _dwarf_search_fission_for_key (\n    dbg=0x654a50, error=0x7fffffffdb08, percu_index_out=<synthetic pointer>,\n    key_in=0x7fffffffd670, xuhdr=0x657360) at dwarf_xu_index.c:363\n #2  dwarf_get_debugfission_for_key (dbg=dbg@entry=0x654a50, \n    key=key@entry=0x7fffffffd670, key_type=key_type@entry=0x2aaaaad15e2a \n    \"tu\", percu_out=percu_out@entry=0x65a830, \n    error=error@entry=0x7fffffffdb08) at dwarf_xu_index.c:577\n </pre>\ndatefixed: 2015-05-18\nreferences: regressiontests/liu/OOB0517_02.elf\ngitfixid: ac6673e32f3443a5d36c2217cb814000930b2c54\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\n\nid: DW201605-013\ncve: CVE-2016-5033\ndatereported: 2016-05-17\nreportedby: Yue Liu\nvulnerability: OOB read bug in print_exprloc_content\nproduct: libdwarf\ndescription: Test object shows\n an invalid write in print_exprloc_content.\n <pre>\n #0  print_exprloc_content (dbg=dbg@entry=0x654ea0, \n    die=die@entry=0x65b110, attrib=attrib@entry=0x65b590, \n    esbp=esbp@entry=0x7fffffffcef0, showhextoo=1) at print_die.c:4182\n #1  0x0000000000412fb1 in get_attr_value (dbg=dbg@entry=0x654ea0, \n    tag=<optimized out>, die=die@entry=0x65b110, \n    dieprint_cu_goffset=dieprint_cu_goffset@entry=11, \n    attrib=attrib@entry=0x65b590, srcfiles=srcfiles@entry=0x0, \n    cnt=cnt@entry=0, esbp=esbp@entry=0x7fffffffcef0, show_form=0, \n    local_verbose=0) at print_die.c:4972\n </pre>\ndatefixed: 2015-05-18\nreferences: regressiontests/liu/OOB0517_01.elf\ngitfixid: ac6673e32f3443a5d36c2217cb814000930b2c54\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-012\ncve: CVE-2016-5034\ndatereported: 2016-05-13\nreportedby: Yue Liu\nvulnerability: OOB write. From relocation records\nproduct: libdwarf\ndescription: Test object shows\n an invalid write in dwarf_elf_access.c\n (when doing the relocations).\n Adding the relocation value to anything overflowed\n and disguised the bad relocation record.\n With a 32bit kernel build the test could show\n a double-free and coredump due to the unchecked invalid\n writes from relocations.\ndatefixed: 2016-05-17 \nreferences: regressiontests/liu/HeapOverflow0513.elf\ngitfixid: 10ca310f64368dc083efacac87732c02ef560a92\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\nid: DW201605-011\ncve: CVE-2016-5035\ndatereported: 2016-05-06\nreportedby: Yue Liu\nvulnerability: OOB read bug in _dwarf_read_line_table_header\nproduct: libdwarf\ndescription: Test object shows\n null dereference at line 62\n of dwarf_line_table_reader.c.\n Frame code and linetable code was not noticing data corruption.\ndatefixed: 2016-05-12\nreferences: regressiontests/liu/OOB_read4.elf\ngitfixid: 82d8e007851805af0dcaaff41f49a2d48473334b\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-010\ncve: CVE-2016-5036\ndatereported: 2016-05-06\nreportedby: Yue Liu\nvulnerability: OOB read bug in dump_block\nproduct: libdwarf\ndescription: Test object shows\n null dereverence at line 186\n of dump_block() in print_sections.c\n Frame code was not noticing frame data corruption.\ndatefixed: 2016-05-12\nreferences: regressiontests/liu/OOB_read3.elf\n regressiontests/liu/OOB_read3_02.elf\ngitfixid: 82d8e007851805af0dcaaff41f49a2d48473334b\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\nid: DW201605-009\ncve: CVE-2016-5037\ndatereported: 2016-05-05\nreportedby: Yue Liu\nvulnerability: NULL dereference in _dwarf_load_section\nproduct: libdwarf\ndescription: Test object shows\n null dereverence at line 1010\n if(!strncmp(\"ZLIB\",(const char *)src,4)) {\n in dwarf_init_finish.c\n The zlib code was not checking for\n a corrupted length-value.\ndatefixed: 2016-05-06\nreferences: regressiontests/liu/NULLderefer0505_01.elf\ngitfixid: b6ec2dfd850929821626ea63fb0a752076a3c08a\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-008\ncve: CVE-2016-5038\ndatereported: 2016-05-05\nreportedby: Yue Liu\nvulnerability: OOB read in dwarf_get_macro_startend_file()\nproduct: libdwarf\ndescription: Test object shows\n out of bound read.\n OOB at:\n line 772  *src_file_name = macro_context->mc_srcfiles[trueindex];\n in dwarf_macro5.c\n A string offset into .debug_str is outside the bounds\n of the .debug_str section.\ndatefixed: 2016-05-12\nreferences: regressiontests/liu/OOB0505_02.elf\n regressiontests/liu/OOB0505_02_02.elf\ngitfixid: 82d8e007851805af0dcaaff41f49a2d48473334b\ntarrelease: libdwarf-20160923.tar.gz \nendrec:\n\nid: DW201605-007\ncve: CVE-2016-5039\ndatereported: 2016-05-05\nreportedby: Yue Liu\nvulnerability: OOB read bug in get_attr_value()\nproduct: libdwarf\ndescription: Test object shows\n out of bound read.\n Object had data all-bits-on so\n the existing length check did not work\n due to wraparound. Added a check\n not susceptible to that error (DW_DLE_FORM_BLOCK_LENGTH_ERROR).\ndatefixed: 2016-05-06\nreferences: regressiontests/liu/OOB0505_01.elf\ngitfixid: eb1472afac95031d0c9dd8c11d527b865fe7deb8\ngittag: 20160507\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-006\ncve:\ndatereported: 2016-05-05\nreportedby: Yue Liu\nvulnerability: Two Heap-Overflow bug\nproduct: libdwarf\ndescription: Two test objects showing\n a heap overflow in libdwarf when\n using dwarfdump.\n It seems that these were fixed\n by the previous git update.\n Neither gdb nor valgrind find any errors\n when building with yesterday's commit.\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/free_invalid_address.elf\n regressiontests/liu/heapoverflow01b.elf\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-001\ncve: CVE-2016-5044\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in a duplicate free() in libdwarf and\n the calling application will crash. \nproduct:  libdwarf\ndescription:\n In file dwarf_elf_access.c:1071\n <pre>\n WRITE_UNALIGNED(dbg,target_section + offset,\n     &outval,sizeof(outval),reloc_size);\n </pre>\n A crafted ELF file may lead to a large offset value, which\n bigger than the size of target_section heap chunk, then this\n WRITE_UNALIGNED() function will write the value of &outval\n out of the heap chunk.\n offset is a 64bit unsigned int value, so this is more than\n a heap overflow bug, but also a Out-of-Bound write bug.\n So WRITE_UNALIGNED() need more strictly checking to prevent\n this.\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/heapoverflow01.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332141\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ngittag: 2016-05-07\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\n\n\nid: DW201605-002\ncve: CVE-2016-5043\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in a read outside the bounds of in memory\n data so the calling application can crash.\nproduct:  libdwarf\ndescription: Out of bound read bug in libdwarf git code.\n\n dwarf_dealloc() did not check the Dwarf_Ptr space argument\n before using it. This will lead to a out-of-bound read bug.\n <pre>\n backtrace:\n #0  dwarf_dealloc (dbg=dbg@entry=0x655f30, space=0xa0,\n alloc_type=alloc_type@entry=1) at dwarf_alloc.c:477\n #1  0x00002aaaaacf3296 in dealloc_srcfiles\n (dbg=0x655f30, srcfiles=0x66b8f0, srcfiles_count=17) at\n dwarf_macro5.c:1025 #2  0x00002aaaaacf50e6 in dealloc_srcfiles\n (srcfiles_count=<optimized out>, srcfiles=<optimized out>,\n dbg=<optimized out>) at dwarf_macro5.c:1021 -----\n\n gef> p &r->rd_dbg\n $14 = (void **) 0x90\n </pre>\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/outofbound01.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332144\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-003\ncve: CVE-2016-5042\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in an infinite loop that eventually\n crashes the application.\nproduct:  libdwarf\ndescription:\n In dwarf_get_aranges_list()\n an invalid count will iterate, reading from memory\n addresses that increase till it all fails.\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/infiniteloop.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332145\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-004\ncve: CVE-2016-5041\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in a null dereference reading debugging\n information entries  which\n crashes the application.\nproduct:  libdwarf\ndescription:\n If no DW_AT_name is present in a debugging\n information entry  using DWARF5 macros\n a null dereference in dwarf_macro5.c will\n crash the application.\n \ndatefixed: 2016-05-04\nreferences: regressiontests/liu/null01.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332148\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-005\ncve: CVE-2016-5040\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in  reading a compilation unit header\n that crashes the application.\nproduct:  libdwarf\ndescription:\n If the data read for a compilation unit header\n contains a too large length value the library\n will read outside of its bounds and crash the application.\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/null02.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332149\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-020\ncve: CVE-2016-5027\ndatereported: 2016-04-25\nreportedby: Yue Liu,lieanu\nvulnerability: NULL dereference in  _dwarf_decode_s_leb128\nproduct: libdwarf\ndescription: dwarf_form.c in libdwarf 20160115 allows\n  remote attackers to cause a denial of service (crash) \n  via a crafted elf file\n  Apparently no crafted object file presented.\n  However the code fix is presented in the report\n  at openwall.com.\n  Discovered the CVE November 2021\n  To attack the code just pass the argument\n  Dwarf_Word * leb128_length as a NULL pointer (that is allowed). \n  The code was fixed in dwarf_leb.c on 2016-04-27 20:00:06.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1330237\n  www.openwall.com/lists/oss-security/2016/05/24/1\n  www.openwall.com/lists/oss-security/2016/05/25/1\n  </pre>\ndatefixed: 2016-05-27 \nreferences:\ngitfixid: \ntarrelease: \nendrec: DW201605-020\n\nid: DW201601-001\ncve: CVE-2016-2091\ndatereported: 2016-01-12\nreportedby: Qixue Xiao\nvulnerability: Out of bound read in  dwarf_read_cie_fde_prefix()\nproduct: libdwarf\ndescription: Crashes the calling program. Requires\n  a crafted object file.  \n  <pre>\n  *** DWARF CHECK: DW_DLE_DEBUG_FRAME_LENGTH_NOT_MULTIPLE\n  len=0x00000010, len size=0x00000004, extn size=0x00000000, totl\n  length=0x00000014, addr size=0x00000008, mod=0x00000004 must be zero\n  in cie, offset 0x00000000. ***\n  7   ==53495== Invalid read of size 2\n  1 ==53495==    at 0x4C2F7E0: memcpy@@GLIBC_2.14 (in\n  /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n  2 ==53495==    by 0x43287F: dwarf_read_cie_fde_prefix (dwarf_frame2.c:934)\n  3 ==53495==    by 0x431305: _dwarf_get_fde_list_internal (dwarf_frame2.c:268)\n  4 ==53495==    by 0x42EB5F: dwarf_get_fde_list_eh (dwarf_frame.c:1101)\n  5 ==53495==    by 0x41BABE: print_frames (print_frames.c:1835)\n  6 ==53495==    by 0x40485B: process_one_file (dwarfdump.c:1323)\n  7 ==53495==    by 0x403529: main (dwarfdump.c:630)\n  www.openwall.com/lists/oss-security/2016/01/19/3\n  www.openwall.com/lists/oss-security/2016/05/28/8\n  </pre>\ndatefixed: 2016-01-21\nreferences: regressiontests/xqx-b/awbug5.elf\ngitfixid: d9d40e4d802e626065ce37ff384dd69c43bc499\ntarrelease:\nendrec: DW201601-001\n\nid: DW201601-002\ncve: CVE-2016-2050\ndatereported: 2016-01-19\nreportedby: Qixue Xiao\nvulnerability: Out of bound write in get_abbrev_array_info\nproduct: libdwarf\ndescription: Crashes the calling program. Requires\n  a crafted object file.\n  <pre>\n  valgrind ./dwarfdump -ka aw.elf\n  ==5358== Memcheck, a memory error detector\n  ==5358== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\n  ==5358== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info\n  ==5358== Command: ../../llvm-codes/dwarf-20151114/dwarfdump/dwarfdump -ka aw.elf\n  ==5358==\n  ==5358== Invalid write of size 8\n  ==5358==    at 0x40DA25: get_abbrev_array_info (in\n  /home/xqx/test/libdwarf-test/llvm-codes/dwarf-20151114/dwarfdump/dwarfdump)\n  ==5358==    by 0x40FD92: print_one_die_section (in\n  /home/xqx/test/libdwarf-test/llvm-codes/dwarf-20151114/dwarfdump/dwarfdump)\n  www.openwall.com/lists/oss-security/2016/01/19/9 \n  www.openwall.com/lists/oss-security/2016/01/25/3\n  </pre>\ndatefixed: 2016-01-21\nreferences: regressiontests/xqx-b/aw.elf\ngitfixid: d9d40e4d802e626065ce37ff384dd69c43bc499\ntarrelease:\nendrec: DW201601-002\n\nid: DW201512-001\ncve: CVE-2015-8750\ndatereported: 2015-12-26\nreportedby: Qixue Xiao (xqx)\nvulnerability:  Null pointer dereference in libdwarf\nproduct: libdwarf\ndescription: libdwarf 20151114 and earlier allows remote\n  attackers to cause a denial of service (NULL pointer \n  dereference and crash) via a debug_abbrev \n  section marked NOBITS in an ELF file.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1294264\n  www.openwall.com/lists/oss-security/2016/01/07/11\n  </pre>\ndatefixed: 2015-12-31 \nreferences: regressiontests/xqx-c/awbug6.elf\ngitfixid: \ntarrelease: \nendrec: DW201512-001\n\nid: DW201512-002\ncve: CVE-2015-8538\ndatereported: 2015-12-14\nreportedby: Adam Maris\nvulnerability:  Out-of-bounds read in dwarf_leb.c\nproduct: libdwarf\ndescription: libdwarf 20151114 and earlier allows remote\n  attackers to cause a denial of service (NULL pointer \n  dereference and crash) via a debug_abbrev \n  section marked NOBITS in an ELF file.\n  The CVE report mentions a reproducer object file\n  but such is not present.\n  Due to recent tool advances (like\n  coverity scan) we are confident this was fixed long ago.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1291299 \n  www.openwall.com/lists/oss-security/2015/12/10/3 \n  </pre>\ndatefixed: 2018-01-01\nreferences:\ngitfixid: \ntarrelease:\nendrec: DW201512-002\n\n\nid: DW201412-001\ncve: CVE-2014-9482\ndatereported: 2014-12-31\nreportedby: Adam Maris\nvulnerability: Use after free vulnerability in Dwarfdump\nproduct: dwarfdump\ndescription: The use-after-free has no attached testcase\n  anywhere.  Due to recent tool advances (like\n  coverity scan) we are confident this was fixed long ago.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1177758\n  www.openwall.com/lists/oss-security/2014/12/31/3 \n  www.openwall.com/lists/oss-security/2015/01/03/14\n  </pre>\ndatefixed: 2018-01-01\nreferences: \ngitfixid:\ntarrelease:\nendrec: DW201412-001\n\n\n\n"], "fixing_code": ["\n\n\nid: DW202208-001\ncve:\nfuzzer: unspecified\ndatereported: 2022-08-27\nreportedby: Han Zheng\nvulnerability: Double free in dwarfdump\nproduct: dwarfdump\ndescription: A carefully corrupted object file\n  would cause dwarfdump -vv -a \n  to do a double free in handling an error condition.\n  That could cause a segmentation violation or other\n  major error, terminating the calling application and\n  resulting in Denial Of Service.\ndatefixed: \nreferences: regressiontests/hanzheng/fuzzedobject\ngitfixid: \ntarrelease:\nendrec: DW202208-001\n\n\n\n\n\nid: DW202207-001\ncve:\nfuzzer: ossfuzz\ndatereported: 2022-05-01\nreportedby: David Korczynski\nvulnerability: buffer overflow in dwarf_form.c\nproduct: libdwarf\ndescription: A carefully corrupted string\n  would cause libdwarf to read outside of a buffer containing\n  the string (one past the end) when checking the string\n  to determine if it is a full path in processing \n  a .gnu.debuglink section.\n  That could cause a segmentation violation or other\n  major error, terminating the calling application and\n  resulting in Denial Of Service.\ndatefixed: 2022-07-23\nreferences: regressiontests/ossfuzz47150/clusterfuzz-testcase-minimized-fuzz_init_path-6727387238236160.fuzz\ngitfixid:  24dff940cc4c71a9c3cb5475aee231b19163a12c\ntarrelease: \nendrec: DW202207-001\n\nid: DW202206-001\ncve:\nfuzzer: \ndatereported: 2022-06-15\nreportedby: Casper Sun\nvulnerability: buffer overflow in dwarf_form.c\nproduct: libdwarf\ndescription: A carefully corrupted .debug_info section\n  would cause libdwarf to read outside of a buffer containing\n  a Dwarf_Sig8 symbolic reference.\n  That could cause a segmentation violation or other\n  major error, terminating the calling application and\n  resulting in Denial Of Service.\n  This failure to check for buffer overflow has been present\n  since DWARF4 when DW_FORM_ref_sig8 was added to libdwarf.\ndatefixed: 2022-06-15\nreferences: regressiontests/sleicasper2/buffer-overflow-dwarf-form\ngitfixid: 7ef09e1fc9ba07653dd078edb2408631c7969162\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202206-001\n\nid: DW202205-001\ncve:\nfuzzer: \ndatereported: 2022-05-26\nreportedby: Casper Sun\nvulnerability: buffer overflow in dwarf_globals.c\nproduct: libdwarf\ndescription: A carefully corrupted .debug_pubnames section\n  would cause libdwarf to read outside of a buffer containing\n  the section contents.\n  That could cause a segmentation violation or other\n  major error, terminating the calling application and\n  resulting in Denial Of Service.\n  The bug has been present for many years.\ndatefixed: 2022-05-29\nreferences: regressiontests/sleicasper/bufferoverflow\ngitfixid: 8151575a6ace77d005ca5bb5d71c1bfdba3f7069\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202205-001\n\nid: DW202111-016\ncve:\nfuzzer: oss-fuzz-41240\ndatereported: 2021-11-20\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_path\nproduct: libdwarf\ndescription: A corrupted object.\n  The PE object section header for\n  section .gnu_debuglink is corrupted. A very\n  large number is in the VirtualSize field.\n  Attempting a malloc for the section could\n  succeed or might fail, resulting in\n  Denial Of Service.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=41240\n  </pre>\ndatefixed: 2021-11-21\nreferences: regressiontests/ ossfuzz41240/clusterfuzz-testcase-minimized-fuzz_init_path-5929343686148096\ngitfixid: a120c808234060c3c9b1872ab9a059aa1ac70b1d \ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-016\n\nid: DW202111-015\ncve:\nfuzzer: oss-fuzz-40896\ndatereported: 2021-11-10\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_path\nproduct: libdwarf\ndescription: A corrupted object.\n  Several Elf section sizes and section offsets are larger than\n  the file size.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40896\n  </pre>\ndatefixed: 2021-11-12\nreferences: regressiontests/ossfuzz40896/clusterfuzz-testcase-fuzz_init_path-5337872492789760\n  regressiontests/ossfuzz40896/clusterfuzz-testcase-minimized-fuzz_init_path-5337872492789760\ngitfixid: b7a119dc07c502c1334bcbf8dd04ca0e4d5f6ab6\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-015\n\nid: DW202111-014\ncve:\nfuzzer: oss-fuzz-40895\ndatereported: 2021-11-10\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_binary\nproduct: libdwarf\ndescription: A corrupted object.\n  Some Elf section sizes are larger than the file size.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40895\n  </pre>\ndatefixed: 2021-11-12\nreferences: regressiontests/ossfuzz40895/clusterfuzz-testcase-fuzz_init_binary-4805508242997248\n  regressiontests/ossfuzz40895/clusterfuzz-testcase-minimized-fuzz_init_binary-4805508242997248\ngitfixid: b7a119dc07c502c1334bcbf8dd04ca0e4d5f6ab6\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-014\n\n\nid: DW201907-001\ncve: CVE-2019-14249\nfuzzer:\ndatereported: 2019-07-23\nreportedby: unknown\nvulnerability: Denial of service with zero size section group\nproduct: libdwarf\ndescription: dwarf_elf_load_headers.c in libdwarf before 2019-07-05 allows attackers to cause a denial of service (division by zero) via an ELF file with a zero-size section group (SHT_GROUP), as demonstrated by dwarfdump. \ndatefixed: 2019-07-05\nreferences: \ngitfixid: cb7198abde46c2ae29957ad460da6886eaa606ba\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW201907-001\n\nid: DW202111-013\ncve:\nfuzzer: oss-fuzz-40802\ndatereported: 2021-11-07\nreportedby: David Korczynski\nvulnerability: Null-dereference READ in dwarf_object_init_b\nproduct: libdwarf\ndescription: A corrupted object. \n  The error handling code in  dwarf_object_init_b\n  was not properly dealing with a NULL pointer\n  Dwarf_Error *errp in the test code.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40802\n  </pre>\ndatefixed: 2021-11-19\nreferences: regressiontests/ossfuzz40802/ clusterfuzz-testcase-fuzz_init_binary-5538015955517440.fuzz\n  regressiontests/ossfuzz40802/clusterfuzz-testcase-minimized-fuzz_init_binary-5538015955517440.fuzz\n\ngitfixid: adf4dae25b39039f1821b095688c00f3010e1d37\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-013\n\n\n\nid: DW202111-012\ncve:\nfuzzer: oss-fuzz-40801\ndatereported: 2021-11-07\nreportedby: David Korczynski\nvulnerability:  Timeout in fuzz_init_path\nproduct: libdwarf\ndescription: A corrupted object. libdwarf detects it quickly now.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40801\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz801/clusterfuzz-testcase-fuzz_init_path-5443517279764480\n  regressiontests/ossfuzz40801/clusterfuzz-testcase-minimized-fuzz_init_path-5443517279764480\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-012\n\n\nid: DW202111-011\ncve:\nfuzzer: oss-fuzz-40799\ndatereported: 2021-11-02\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_path\nproduct: libdwarf\ndescription: A corrupted object.\n  Gigantic section sizes or offsets were provoking\n  a large malloc.  Now these are detected and\n  no malloc is attempted (an error is returned).\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40799\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40799/clusterfuzz-testcase-fuzz_init_path-5245778948390912\n  regressiontests/ossfuzz40799/clusterfuzz-testcase-minimized-fuzz_init_path-5245778948390912\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-011\n\n\n\nid: DW202111-010\ncve:\nfuzzer: oss-fuzz-40627\ndatereported: 2021-11-02\nreportedby: David Korczynski\nvulnerability: Abrt in _dwarf_error_string\nproduct: libdwarf\ndescription: The Elf object file has some corruption. The\n  read now stops with an error.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40627\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40627/clusterfuzz-testcase-fuzz_init_path-5186858573758464\n  regressiontests/ossfuzz40627/clusterfuzz-testcase-minimized-fuzz_init_path-5186858573758464\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-010\n\nid: DW202111-009\ncve:\nfuzzer: oss-fuzz-40729\ndatereported: 2021-11-05\nreportedby: David Korczynski\nvulnerability: Timeout - fuzz_init_binary\nproduct: libdwarf\ndescription: The object file (macho 64 bit) has some\n  header fuzzing that was not caught reading\n  the object until the macho reader\n  tried a gigantic malloc..\n  Now the library code catches the error before malloc and\n  returns an error code.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40729\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40729/clusterfuzz-testcase-minimized-fuzz_init_binary-4791627277795328\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-009\n\nid: DW202111-008\ncve:\nfuzzer: oss-fuzz-40731\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_binary\nproduct: libdwarf\ndescription: The fuzzed macho64 object has corrupted\n  headers. The library notices and reports an error.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40731\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40731/clusterfuzz-testcase-fuzz_init_binary-5983147574034432\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-008\n\n\nid: DW202111-005\ncve: \nfuzzer: oss-fuzz-40674\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Heap-buffer-overflow in _dwarf_elf_setup_all_section_groups\nproduct: libdwarf\ndescription:  Object file has corrupt section group information.\n  Results in buffer overflow.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40674#c6\n  </pre>\ndatefixed: 2021-11-07\nreferences: regressiontests/ossfuzz40674/clusterfuzz-testcase-minimized-fuzz_init_path-6557751518560256\ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-005\n\nid: DW202111-004\ncve: \nfuzzer: oss-fuzz-40673\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Null-dereference READ in dwarf_object_init_b \nproduct: libdwarf\ndescription: The macho object has corrupted headers\n  and now mentions that and stops.\n  Verified as fixed by oss-fuzz 2021-11-03\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40673\n  </pre>\ndatefixed: 2021-11-05\nreferences: regressiontests/ossfuzz40673/clusterfuzz-testcase-minimized-fuzz_init_path-6240961391362048.fuzz \ngitfixid: 94dece3ce0f030d06da442a103bd6a5301410b25\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-004\n\nid: DW202111-003\ncve: \nfuzzer: oss-fuzz-40671\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Direct-leak in _dwarf_get_debug\nproduct: libdwarf\ndescription: The test code is calling a libdwarf-internal\n  function (which is against the rules, only libdwarf\n  function names beginning with dwarf_ are callable.\n  When building libdwarf as an archive there is no\n  means to enforce this rule)\n  doc/libdwarf.mm/pdf now documents this rule.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40671\n  </pre>\ndatefixed: 2021-11-05\nreferences: regressiontests/oss40671/clusterfuzz-testcase-fuzz_init_path-5455557297831936\n  regressiontests/oss40671/clusterfuzz-testcase-minimized-fuzz_init_path-5455557297831936\ngitfixid: b40f7e291216e771185f62292dd6304b5a662926\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-003\n\n\nid: DW202111-002\ncve: \nfuzzer: oss-fuzz-40669\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Out-of-memory in fuzz_init_path\nproduct: libdwarf\ndescription:  Corrupted MachO object can crash caller.b\n  Two fields in the MachO file header\n  were not checked for sanity so nonsense large values\n  could lead to excessive malloc and or a caller\n  segmentation violation. Fixed by DW202111-001.\n  Verified as fixed by oss-fuzz\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40669\n  </pre>\ndatefixed: 2021-11-04\nreferences: regressiontests/ossfuzz40669/clusterfuzz-testcase-minimized-fuzz_init_path-5399726397194240\n  regressiontests/clusterfuzz-testcase-fuzz_init_path-5399726397194240\ngitfixid: b40f7e291216e771185f62292dd6304b5a662926\ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-002\n\n\n\nid: DW202111-001\ncve: \nfuzzer: oss-fuzz-40663\ndatereported: 2021-11-03\nreportedby: David Korczynski\nvulnerability: Timeout in fuzz_init_path\nproduct: libdwarf\ndescription:  Corrupted MachO object can crash caller\n  Two fields in the MachO file header\n  were not checked for sanity so nonsense large values\n  could lead to excessive malloc and or a caller\n  segmentation violation.\n  Verified by oss-fuzz as fixed.\n  The testcase has illegal libdwarf call\n  and improper include statements.\n  <pre>\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40663\n  </pre>\ndatefixed: 2021-11-04\nreferences: regressiontests/ossfuzz40663/clusterfuzz-testcase-minimized-fuzz_init_path-6122542432124928\ngitfixid: b40f7e291216e771185f62292dd6304b5a662926 \ntarrelease: libdwarf-0.4.1.tar.xz\nendrec: DW202111-001\n\n\nid: DW202010-003\ncve: CVE-2020-28163\ndatereported: 2020-10-27\nreportedby: Casper Sun\nvulnerability: Passing null to %s due to corrupt line table header.\nproduct: libdwarf\ndescription: If a DWARF5 line table header has an invalid\n  FORM for a pathname, the fi_file_name field may be null\n  and printing it via %s can result in referencing memory\n  at address 0, possibly generating segmentation\n  violation or application crash.  Now in case of null\n  we provide a fixed string of <no file name>\n  and for the form code we print the value and <unknown form>\n  so there are no unpredictable effects.\n  <pre>\n  \n  This should be visible after redhat makes it public.\n  Filed on bugzilla.redhat 23 November 2021.\n  bugzilla.redhat.com/show_bug.cgi?id=2026000\n  </pre>\ndatefixed: 2020-10-28\nreferences: regressiontests/c-sun2/nullpointer\ngitfixid: faf99408e3f9f706fc3809dd400e831f989778d3 \ntarrelease:\nendrec: DW202010-003\n\n\nid: DW202010-002\ncve: CVE-2020-28162\ndatereported: 2020-10-27\nreportedby: Casper Sun\nvulnerability: dwarfdump crashes if the nest of C scopes is too deep\nproduct: dwarfdump\ndescription: An object file where the DIEs depth of\n  nesting exceeds the limit of 800 levels\n  due to corruption or a compiler bug \n  can result in exhausting the die stack array and\n  writing past its end.\n  A segmentation fault is possible.\n  The code at the point of error was not adjusting\n  the array index properly\n  so an invalid dereference could occur.\n  Now the test code is correct and the array overflow\n  is detected resulting in a normal error return.\n  Additional places where this could occur were\n  identified and the proper test added.\n  <pre>\n  Unable to enter in bugzilla.redhat.com\n  so CVE can be completed by Fedora (as CNA)\n  as dwarfdump is not part of Fedora\n  </pre>\ndatefixed: 2020-10-28\nreferences: regressiontests/c-sun2/globaloverflow\ngitfixid: a7fa8edd640b74daf8e7a442dcec96640875b4fb \ntarrelease:\nendrec: DW202010-002\n\nid: DW202010-001\ncve: CVE-2020-27545\ndatereported: 2020-10-10\nreportedby: Casper Sun\nvulnerability: A carefully corrupted line table can crash calling app\nproduct: libdwarf\ndescription: A carefully crafted object with an\n  invalid line table could cause libdwarf\n  to dereference a pointer reading a single byte outside of\n  the intended .debug_line section and potentially\n  outside of memory visible to the library.  \n  A segmentation fault is possible.\n  The code testing for the error was coded incorrectly\n  so an invalid dereference could occur.\n  Now the test code is correct and the error\n  is detected resulting in a normal error return.\n  <pre>\n  This should be visible after redhat makes it public.\n  Filed on bugzilla.redhat 22 November 2021.\n  bugzilla.redhat.com/show_bug.cgi?id=2025694\n  </pre>\ndatefixed: 2020-10-17\nreferences: regressiontests/c-sun/poc\ngitfixid:  95f634808c01f1c61bbec56ed2395af997f397ea\ntarrelease: \nendrec: DW202010-001\n\nid: DW201801-001\ncve:\ndatereported: 2018-01-28\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect frame section can crash dwarfdump\nproduct: dwarfdump\ndescription: A carefully crafted object with an\n  invalid frame section set of initial-instructions\n  can crash the frame-instructions decode in\n  dwarfdump. In addition, a couple places in libdwarf\n  are not as careful in checking frame data as\n  they should be.\n  A segmentation-fault/core-dump is possible.\ndatefixed: 2018-01-29\nreferences: sarubbo-11/testcase{1,2,3,4,5}.bin\ngitfixid:  7af0ecddfafed88446969cbf8c888356ad485d99\ntarrelease: libdwarf-20180129.tar.gz\nendrec: DW201801-001\n\n\nid: DW201712-001\ncve:\ndatereported: 2017-12-01\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect frame section could let caller crash\nproduct: libdwarf\ndescription: A carefully crafted object with an\n  invalid frame section\n  can result in passing back data to a caller of \n  dwarf_get_fde_augmentation_data()\n  is erroneous and will result in the \n  caller reference off the end of the frame \n  section.  \n  A segmentation-fault/core-dump is possible.\ndatefixed: 2017-12-01\nreferences: sarubbo-10/1.crashes.bin\ngitfixid: 329ea8e56bc9550260cae6e2e9756bfbe7e2ff6d \ntarrelease:\nendrec: DW201712-001\n\n\n\nid: DW201711-002\ncve:\ndatereported: 2017-11-08\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect line table section could crash caller\nproduct: libdwarf\ndescription: An carefully crafted object with a\n  invalid line table section crafted to\n  end early at a particular point resulted in\n  dereferencing outside the line table from\n  libdwarf/dwarf_line_table_reader_common.c . \n  A segmentation-fault/core-dump is possible.\ndatefixed: 2017-11-08\nreferences: regressiontests/sarubbo-9/3.crashes.bin\ngitfixid: a1644f4dde7dd5990537ff7ad22a9e94b8723186\ntarrelease:\nendrec: DW201711-002\n\nid: DW201711-001\ncve:\ndatereported: 2017-11-01\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect frame section could crash caller\nproduct: libdwarf\ndescription: A carefully crafted object with a\n  resulting invalid frame section\n  with DW_CFA_advance_loc1 implying\n  data off-the-end-of-section\n  will dereference an invalid pointer.\n  A segmentation fault and core dump is possible.\n  Corrected code checks now.\ndatefixed: 2017-11-02\nreferences: regressiontests/sarubbo-8/1.crashes.bin\ngitfixid: 44349d7991e44dd3751794f76537cabcf65ee28d\ntarrelease:\nendrec: DW201711-001\n\n\n\n\nid: DW201709-001\ncve: \ndatereported: 2017-09-19\nreportedby: Agostino Sarubbo\nvulnerability: Incorrect abbrev section could crash caller.\nproduct: libdwarf\ndescription: A fuzzed object with a\n  resulting invalid abbrev section where\n  the end of section follows an abbrev tag\n  would dereference a non-existent has-child byte.\n\ndatefixed: 2017-09-26\nreferences: regressiontests/sarubbo-3/1.crashes.bin\ngitfixid: bcc2e33908e669bacd397e3c941ffd1db3005d17\ntarrelease:\nendrec: DW201709-001\n\n\nid: DW201706-001\ncve: CVE-2017-9998\ndatereported: 2017-06-28\nreportedby: team OWL337\nvulnerability: Addition overflow in libdwarf leads to segmentation violation \nproduct: libdwarf\ndescription: A fuzzed object with a \n  resulting invalid value can overflow\n  when added to a valid pointer\n  (depending on how the runtime memory is laid out) \n  and thereafter a dereference results in a \n  segmentation violation).\n\n <pre> see\n  https://bugzilla.redhat.com/show_bug.cgi?id=1465756\n  for contact information of those finding the bug.\n  Fabian Wolff sent email and provided\n  the link to the web page.\n </pre>\ndatefixed: 2017-07-06\nreferences: regressiontests/wolff/POC1 \ngitfixid: e91681e8841291f57386f26a90897fd1dcf92a6e\ntarrelease: \nendrec: DW201706-001\n\n\n\nid: DW201703-007\ncve:\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in strncmp (libelf bug)\nproduct: libdwarf (libelf)\ndescription:  7/7. A heap overflow in\n  strncmp() is due to libelf failing to check arguments\n  to elf_ strptr.\n  This is not a bug in libdwarf, it is a libelf bug.\n  A  pointer for being in bounds (in a few places in this\n  function) and a failure in a check in dwarf_attr_list().\n  The test object is intentionally corrupted (fuzzed).\n\n <pre>\n A portion of sanitizer output with Ubuntu 14.04:\n ==180133==ERROR: AddressSanitizer: heap-buffer-overflow \n   on address 0x60d00000cff1 at pc 0x0000004476f4 \n   bp 0x7fff87dd7dd0 sp 0x7fff87dd7590\n READ of size 8 at 0x60d00000cff1 thread T0\n    #0 0x4476f3 in __interceptor_strncmp (/home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/dwarfdump+0x4476f3)\n    #1 0x7992ae in this_section_dwarf_relevant /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_init_finish.c:608:13\n    #2 0x781064 in _dwarf_setup /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_init_finish.c:722:14\n    #3 0x77d59c in dwarf_object_init /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_init_finish.c:922:20\n\n With Ubuntu 16.04 libelf dwarfdump gets:\n ERROR:  dwarf_elf_init:  DW_DLE_ELF_STRPTR_ERROR (30) \n a call to elf_strptr() failed trying to get a section name\n </pre>\n Fix date is irrelevant, libdwarf no longer uses libelf.\ndatefixed: \nreferences: regressiontests/marcel/crash7\ngitfixid: \ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-007\n\n\nid: DW201703-006\ncve: CVE-2017-9052\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in dwarf_formsdata \nproduct: libdwarf\ndescription:  6/7. A heap overflow in\n  dwarf_formsdata() is due to a failure to check\n  a  pointer for being in bounds (in a few places in this\n  function) and a failure in a check in dwarf_attr_list().\n  The test object is intentionally corrupted (fuzzed).\n\n <pre>\n A portion of sanitizer output with Ubuntu 14.04:\n ==180130==ERROR: AddressSanitizer: heap-buffer-overflow \n  on address 0x61100000589c at pc 0x0000006cab95 \n  bp 0x7fff749aab10 sp 0x7fff749aab08\n READ of size 1 at 0x61100000589c thread T0\n    #0 0x6cab94 in dwarf_formsdata /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_form.c:937:9\n    #1 0x567daf in get_small_encoding_integer_and_name /home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/print_die.c:1533:16\n    #2 0x562f28 in get_attr_value /home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/print_die.c:5030:24\n    #3 0x555f86 in print_attribute /home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/print_die.c:3357:13\n\n After fixes applied dwarfdump says:\n ERROR:  dwarf_attrlist:  DW_DLE_DW_DLE_ATTR_OUTSIDE_SECTION(281)\n </pre>\n\ndatefixed: 2017-03-21\nreferences: regressiontests/marcel/crash6\ngitfixid: cc37d6917011733d776ae228af4e5d6abe9613c1\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-006\n\n\n\nid: DW201703-005\ncve: CVE-2017-9053\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in _dwarf_read_loc_expr_op()\nproduct: libdwarf\ndescription:  5/7. A heap overflow in \n  _dwarf_read_loc_expr_op() is due to a failure to check\n  a  pointer for being in bounds (in a few places in this\n  function).\n  The test object is intentionally corrupted (fuzzed).\n\n <pre>\n A portion of sanitizer output with Ubuntu 14.04:\n ==180112==ERROR: AddressSanitizer: heap-buffer-overflow \n  on address 0x60800000bf72 at pc 0x00000084dd52 \n  bp 0x7ffc12136fd0 sp 0x7ffc12136fc8\n READ of size 1 at 0x60800000bf72 thread T0\n    #0 0x84dd51 in _dwarf_read_loc_expr_op /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/./dwarf_loc.c:250:9\n    #1 0x841f16 in _dwarf_get_locdesc_c /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/./dwarf_loc2.c:109:15\n    #2 0x837d08 in dwarf_get_loclist_c /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/./dwarf_loc2.c:685:18\n    #3 0x57dff2 in get_location_list /home/ubuntu/subjects/\n       build-asan/libdwarf/dwarfdump/print_die.c:3812:16\n\n After fixes applied dwarfdump says:\n ERROR:  dwarf_get_loclist_c:  DW_DLE_LOCEXPR_OFF_SECTION_END \n (343) Corrupt dwarf\n </pre>\n\ndatefixed: 2017-03-21\nreferences: regressiontests/marcel/crash5\ngitfixid: cc37d6917011733d776ae228af4e5d6abe9613c1\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-005\n\nid: DW201703-004\ncve:\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in set_up_section strlen\nproduct: libdwarf (libelf)\ndescription:  4/7. An apparent heap overflow that\n  gives the appearance of being in libdwarf is due to\n  libelf call elf_strptr() failing to fully check\n  that its arguments make sense.\n  This is not a bug in libdwarf, it is a libelf bug.\n  The test object is intentionally corrupted (fuzzed).\n  The submission was with Ubuntu 14.04. With Ubuntu\n  16.04 there is no sanitizer error report.\n <pre>\n\n A portion of sanitizer output with Ubuntu 14.04:\n ==180109==ERROR: AddressSanitizer: heap-buffer-overflow \n   on address 0x60b00000b000 at pc 0x00000048fd12 \n   bp 0x7fff4ad31ef0 sp 0x7fff4ad316b0\n READ of size 16 at 0x60b00000b000 thread T0\n    #0 0x48fd11 in __interceptor_strlen (/home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/dwarfdump+0x48fd11)\n    #1 0x7a84a4 in set_up_section /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:285:27\n    #2 0x79aaa5 in enter_section_in_de_debug_sections_array /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:355:5\n    #3 0x78170b in _dwarf_setup /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:746:19\n\n With Ubuntu 16.04 libelf one gets:\n ERROR:  dwarf_elf_init:  DW_DLE_ELF_STRPTR_ERROR (30) \n a call to elf_strptr() failed trying to get a section name\n </pre>\ndatefixed:\nreferences: regressiontests/marcel/crash4\ngitfixid:\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-004\n\n\n\nid: DW201703-003\ncve:\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in strcmp \nproduct: libdwarf (libelf)\ndescription:  3/7. An apparent heap overflow that\n  gives the appearance of being in libdwarf is due to\n  libelf call elf_strptr() failing to fully check \n  that its arguments make sense.\n  This is not a bug in libdwarf, it is a libelf bug.\n  The test object is intentionally corrupted (fuzzed).\n  The submission was with Ubuntu 14.04. With Ubuntu\n  16.04 there is no sanitizer error report.\n <pre>\n\n A portion of sanitizer output with Ubuntu 14.04:\n  ==180106==ERROR: AddressSanitizer: heap-buffer-overflow \n    on address 0x60f00000ef09 at pc 0x000000447300 \n    bp 0x7ffc667dce10 sp 0x7ffc667dc5d0\n  READ of size 4 at 0x60f00000ef09 thread T0\n    #0 0x4472ff in __interceptor_strcmp (/home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/dwarfdump+0x4472ff)\n    #1 0x79938f in this_section_dwarf_relevant /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:612:12\n    #2 0x781064 in _dwarf_setup /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:722:14\n    #3 0x77d59c in dwarf_object_init /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:922:20\n    #4 0x899d4f in dwarf_elf_init_file_ownership /\n\n  With Ubuntu 16.04 libelf one gets:\n  ERROR:  dwarf_elf_init:  DW_DLE_ELF_STRPTR_ERROR (30) \n  a call to elf_strptr() failed trying to get a section name\n  </pre>\n  Fix date is irrelevant, libdwarf no longer uses libelf.\ndatefixed: \nreferences: regressiontests/marcel/crash3\ngitfixid:\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-003\n\n\nid: DW201703-002\ncve: CVE-2017-9054\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in _dwarf_decode_s_leb128_chk()\nproduct: libdwarf\ndescription:  2/7. In _dwarf_decode_s_leb128_chk()\n  a byte pointer was dereferenced just before was checked\n  as being in bounds.\n  The test object is intentionally corrupted (fuzzed).\n <pre>\n\n A portion of sanitizer output:\n  .debug_line: line number info for a single cu\n  ==180103==ERROR: AddressSanitizer: heap-buffer-overflow \n    on address 0x610000007ffc at pc 0x0000007b0f5b \n    bp 0x7ffe06bbf510 sp 0x7ffe06bbf508\n  READ of size 1 at 0x610000007ffc thread T0\n    #0 0x7b0f5a in _dwarf_decode_s_leb128_chk /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/dwarf_leb.c:304:9\n    #1 0x7e753e in read_line_table_program /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/./\n       dwarf_line_table_reader_common.c:1167:17\n    #2 0x7d7fe3 in _dwarf_internal_srclines /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/./dwarf_line.c:690:15\n    #3 0x7f9dbb in dwarf_srclines_b /home/ubuntu/\n       subjects/build-asan/libdwarf/libdwarf/./dwarf_line.c:944:12\n    #4 0x5caaa5 in print_line_numbers_this_cu /home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/print_lines.c:762:16\n\n  After fix applied one gets:\n  ERROR:  dwarf_srclines:  DW_DLE_LEB_IMPROPER (329) \n  Runs off end of section or CU\n </pre>\n\ndatefixed: 2017-03-21\nreferences: regressiontests/marcel/crash2\ngitfixid: cc37d6917011733d776ae228af4e5d6abe9613c1\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-002\n\n\nid: DW201703-001\ncve: CVE-2017-9055\ndatereported: 2017-03-21\nreportedby: Marcel Bohme and Van-Thuan Pham\nvulnerability: Heap overflow in dwarf_formsdata\nproduct: libdwarf\ndescription:  1/7. In dwarf_formsdata() a few\n  data types were not checked as being in bounds.\n  The test object is intentionally corrupted (fuzzed).\n <pre>\n\n A portion of sanitizer output:\n LOCAL_SYMBOLS:\n < 1><0x0000002f>    DW_TAG_subprogram\n\n ==180088==ERROR: AddressSanitizer: heap-buffer-overflow on \n  address 0x60800000bf72 at pc 0x0000006cab95 bp \n  0x7fff31425830 sp 0x7fff31425828\n  READ of size 1 at 0x60800000bf72 thread T0\n    #0 0x6cab94 in dwarf_formsdata /home/ubuntu/subjects/\n       build-asan/libdwarf/libdwarf/dwarf_form.c:937:9\n    #1 0x567daf in get_small_encoding_integer_and_name /home/\n       ubuntu/subjects/build-asan/libdwarf/dwarfdump/print_die.c:1533:16\n    #2 0x576f38 in check_for_type_unsigned /home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/print_die.c:4301:11\n    #3 0x56ad8c in formxdata_print_value /home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/print_die.c:4374:39\n    #4 0x5643be in get_attr_value /home/ubuntu/\n       subjects/build-asan/libdwarf/dwarfdump/print_die.c:5140:24\n    #5 0x555f86 in print_attribute /home/ubuntu/subjects/build\n  ...\n\n  After fixes applied dwarfdump gets:\n  ERROR:  dwarf_attrlist:  DW_DLE_DW_DLE_ATTR_OUTSIDE_SECTION(281)\n </pre>\ndatefixed: 2017-03-21\nreferences: regressiontests/marcel/crash1 \ngitfixid: cc37d6917011733d776ae228af4e5d6abe9613c1\ntarrelease: libdwarf-20160507.tar.gz\nendrec: DW201703-001\n\nid: DW201611-008\ncve: CVE-2016-10254\ndatereported: 2016-11-04\nreportedby: Agostino Sarubbo\nvulnerability: Crash libelf reading fuzzed object.\nproduct: libdwarf\ndescription: This is a weakness in libelf checking.\n  Testing that current libdwarf deals with it properly,\n  though it was never a bug in libdwarf.\n  The CVE mentions libdwarf.\n  <pre>\n  blogs.gentoo.org/ago/2016/11/04/elfutils-memory-allocation-failure-in-allocate_elf-common-h/\n  www.openwall.com/lists/oss-security/2017/03/22/2 \n  </pre>\n  Fixed in gentoo libelf by Agostino Sarubbo.\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-b/00011-elfutils-memalloc-allocate_elf \ngitfixid:\ntarrelease:\nendrec: DW201611-008\n\nid: DW201611-007\ncve: CVE-2016-10255\ndatereported: 2016-11-04\nreportedby: Agostino Sarubbo\nvulnerability: Crash libelf reading fuzzed object.\nproduct: libdwarf\ndescription: This is a weakness in libelf checking.\n  Testing that current libdwarf deals with it properly,\n  though it was never a bug in libdwarf.\n  The CVE mentions libdwarf.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1387584 \n  www.openwall.com/lists/oss-security/2017/03/22/1 \n  blogs.gentoo.org/ago/2016/11/04/elfutils-memory-allocation-failure-in-__libelf_set_rawdata_wrlock-elf_getdata-c/ \n  </pre>\n  Fixed in gentoo libelf by Agostino Sarubbo.\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-a/00031-elfutils-memalloc-__libelf_set_rawdata_wrlock\ngitfixid:\ntarrelease:\nendrec: DW201611-007\n\n  \n\nid: DW201611-006\ncve: CVE-2016-9480\ndatereported: 2016-11-14\nreportedby: Puzzor (Shi Ji)\nvulnerability: Heap buffer overflow\nproduct: libdwarf\ndescription: An object with corrupt contents causes a memory reference\n out of bounds, a heap buffer overflow reference.\n <pre>\n heap-buffer-overflow in dwarf_util.c:208 for val_ptr\n\n # Version\n bb9a3492ac5713bed9cf3ae58ddb7afa6e9e98f8\n (in regression tests here named  heap_buf_overflow.o)\n\n\n # ASAN Output\n <0> tag: 17 DW_TAG_compile_unit  name: \"strstrnocase.c\" FORM 0xe \"DW_FORM_strp\"\n <1> tag: 46 DW_TAG_subprogram  name: \"is_strstrnocase\" FORM 0xe \"DW_FORM_strp\"\n =================\n ==1666==ERROR: AddressSanitizer: heap-buffer-overflow on address \n   0xb5846db9 at p\n c 0x080b3a1b bp 0xbfa75d18 sp 0xbfa75d08\n READ of size 1 at 0xb5846db9 thread T0\n    #0 0x80b3a1a in _dwarf_get_size_of_val /home/puzzor/libdwarf-code/\n        libdwarf/dwarf_util.c:208\n    #1 0x8056602 in _dwarf_next_die_info_ptr /home/puzzor/libdwarf-code/\n        libdwarf/dwarf_die_deliv.c:1353\n    #2 0x8057f4b in dwarf_child /home/puzzor/libdwarf-code/libdwarf/\n       dwarf_die_de liv.c:1688\n    #3 0x804b5fa in get_die_and_siblings simplereader.c:637\n    #4 0x804b65c in get_die_and_siblings simplereader.c:643\n    #5 0x804b3f3 in read_cu_list simplereader.c:611\n    #6 0x804aeae in main simplereader.c:533\n    #7 0xb6ffe275 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18275)\n    #8 0x80491c0  (/home/puzzor/libdwarf-code/dwarfexample/simplereader+\n         0x80491c 0)\n\n 0xb5846db9 is located 0 bytes to the right of 249-byte region \n    [0xb5846cc0,0xb5846db9)\n allocated by thread T0 here:\n    #0 0xb727fae4 in __interceptor_malloc (/usr/lib/i386-linux-gnu/libasan.so.\n       3+ 0xc3ae4)\n    #1 0xb71a9b98  (/usr/lib/i386-linux-gnu/libelf.so.1+0x9b98)\n </pre>\n For the orignal bug report see\n <pre>\n https://sourceforge.net/p/libdwarf/bugs/5/\n </pre>\ndatefixed: 2016-11-16\nreferences: regressiontests/puzzor/heap_buf_overflow.o\ngitfixid: 5dd64de047cd5ec479fb11fe7ff2692fd819e5e5\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\n\nid: DW201611-005\ncve: CVE-2016-9558\ndatereported: 2016-11-11\nreportedby: Agostino Sarubbo\nvulnerability: negation of -9223372036854775808 cannot be represented in type \nproduct: libdwarf\ndescription: With the right bit pattern in a signed leb number\n the signed leb decode would execute an unary minus with undefined\n effect. This is not known to generate an incorrect value,\n but it could, one supposes.\ndatefixed: 2016-11-11\nreferences: regressiontests/sarubbo-2/00050-libdwarf-negate-itself\ngitfixid: 4f19e1050cd8e9ddf2cb6caa061ff2fec4c9b5f9\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201611-004\ncve: CVE-2016-9275\ndatereported: 2016-11-02\nreportedby: Agostino Sarubbo\nvulnerability: Heap overflow in dwarf_skim_forms()\nproduct: libdwarf\ndescription: If a non-terminated string \n  in a DWARF5 macro section \n  ends a section it can result in accessing memory not\n  in the application (out of bounds read).\n  dwarf_macro5.c(in _dwarf_skim_forms()).\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-2/00027-libdwarf-heapoverflow-_dwarf_skim_forms\ngitfixid:  583f8834083b5ef834c497f5b47797e16101a9a6\nendrec:\n\nid: DW201611-003\ncve: CVE-2016-9276\ndatereported: 2016-11-02\nreportedby: Agostino Sarubbo\nvulnerability: Bad aranges length leads to overflow and bad pointer\nproduct: libdwarf\ndescription:  in dwarf_arange.c(dwarf_get_aranges_list) an aranges\n header with corrupt data could, with an overflowing calculation,\n result in pointers to invalid or inappropriate memory being\n dereferenced.\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-2/00026-libdwarf-heapoverflow-dwarf_get_aranges_list\ngitfixid:  583f8834083b5ef834c497f5b47797e16101a9a6\ntarrelease: libdwarf-20170416.tar.gz\nendrec:\n\n\nid: DW201611-002\ncve:\ndatereported: 2016-11-02\nreportedby: Agostino Sarubbo\nvulnerability: heap overflow in get_attr_value\nproduct: libdwarf\ndescription: Libdwarf failed to check for a bogus\n length in dwarf_form.c (dwarf_formblock()) resulting\n in a pointer pointing outside of the intended memory\n region.  Anything could happen in the subsequent\n use of the bogus pointer.\n <pre>\n 0x61300000de1c is located 0 bytes to the right of 348-byte region \n [0x61300000dcc0,0x61300000de1c) \n allocated by thread T0 here: \n   #0 0x4c0ad8 in malloc /var/tmp/portage/sys-devel/llvm-3.8.1-\n r2/work/llvm-3.8.1.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52 \n   #1 0x7f883cfc6206 in __libelf_set_rawdata_wrlock /tmp/portage/dev-\n libs/elfutils-0.166/work/elfutils-0.166/libelf/elf_getdata.c:318\n </pre>\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-2/00025-libdwarf-heapoverflow-get_attr_value\ngitfixid:  583f8834083b5ef834c497f5b47797e16101a9a6\ntarrelease: libdwarf-20170416.tar.gz \nendrec:\n\nid: DW201611-001\ncve:\ndatereported: 2016-11-02\nreportedby: Agostino Sarubbo\nvulnerability: Memory allocation failure in do_decompress_zlib\nproduct: libdwarf\ndescription: In decompressing a zlib compressed section if\n the decompressed section size is nonsense (too large)\n an attempted malloc will fail and could let an exception\n propagate to callers.\n <pre>\n  ==27994==WARNING: AddressSanitizer failed to allocate 0x62696c2f7273752f\n  bytes ==27994==AddressSanitizer's allocator is terminating the process\n  instead of returning 0\n  ...\n   #6 0x4c0ab1 in malloc /var/tmp/portage/sys-devel/llvm-3.8.1-\nr2/work/llvm-3.8.1.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:53\n#7 0x5b582e in do_decompress_zlib\n/tmp/dwarf-20161021/libdwarf/dwarf_init_finish.c:1085:12\n   #8 0x5b582e in _dwarf_load_section\n/tmp/dwarf-20161021/libdwarf/dwarf_init_finish.c:1159\n   #9 0x5bb479 in dwarf_srcfiles\n/tmp/dwarf-20161021/libdwarf/./dwarf_line.c:336:11\n   #10 0x5145cd in print_one_die_section\n </pre>\ndatefixed: 2016-11-04\nreferences: regressiontests/sarubbo-2/00024-libdwarf-memalloc-do_decompress_zlib\ngitfixid:  583f8834083b5ef834c497f5b47797e16101a9a6\ntarrelease: libdwarf-20170416.tar.gz \nendrec: DW201611-001\n\nid: DW201610-003\ncve: CVE-2016-8679\ndatereported: 2016-10-02\nreportedby: agostino\nvulnerability: dwarf_get_size_of_val out of bounds read\nproduct: libdwarf\ndescription: The _dwarf_get_size_of_val function in \n  libdwarf/dwarf_util.c in Libdwarf before 20161124 \n  allows remote attackers to cause a denial of service \n  (out-of-bounds read) by calling the dwarfdump command \n  on a crafted file. \n  <pre>\n  www.securityfocus.com/bid/93601\n  blogs.gentoo.org/ago/2016/10/06/libdwarf-heap-based-\n  buffer-overflow-in-_dwarf_get_size_of_val-dwarf_util-c/\n  </pre>\ndatefixed: 2016-10-04\nreferences:\ngitfixid: efe48cad0693d6994d9a7b561e1c3833b073a624\nendrec: DW201610-003\n\nid: DW201610-002\ncve: CVE-2016-8680\ndatereported: 2016-10-02\nreportedby: agostino\nvulnerability: Out of bounds read\nproduct: libdwarf\ndescription: The _dwarf_get_abbrev_for_code function in\n  dwarf_util.c in libdwarf 20161001 and earlier allows remote \n  attackers to cause a denial of service (out-of-bounds read) \n  by calling the dwarfdump command on a crafted file. \n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1385690\n  www.securityfocus.com/bid/93592\n  Duplicate of CVE-2016-8681\n  </pre>\ndatefixed: 2016-10-04\nreferences: \ngitfixid: efe48cad0693d6994d9a7b561e1c3833b073a624\nendrec: DW201610-002\n\n\n\n\nid: DW201610-001\ncve: CVE-2016-8681\ndatereported: 2016-10-02\nreportedby: agostino\nvulnerability: Out of bounds read\nproduct: libdwarf\ndescription: The _dwarf_get_abbrev_for_code function in\n  dwarf_util.c in libdwarf 20161001 and earlier allows remote \n  attackers to cause a denial of service (out-of-bounds read) \n  by calling the dwarfdump command on a crafted file. \n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1385690\n  www.securityfocus.com/bid/93592\n  Duplicate of CVE-2016-8680\n  </pre>\ndatefixed: 2016-10-04\nreferences: \ngitfixid: efe48cad0693d6994d9a7b561e1c3833b073a624\nendrec: DW201610-001\n\n\nid: DW201609-004\ncve: CVE-2016-7510 \ndatereported: 2016-09-17\nreportedby: Puzzor\nvulnerability: libdwarf 20160613 Out-of-Bounds read\nproduct: libdwarf\ndescription:  read line table program Out-of-Bounds read\n line_ptr in dwarf_line_table_reader_common.c:1433 Out-of-Bounds read\n See:\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1377015\n https://sourceforge.net/p/libdwarf/bugs/4/\n </pre>\n <pre>\n # Address Sanitizer Output\n ==27763==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4603f84 at pc 0x8408ede bp 0xffff6518 sp 0xffff6510\n READ of size 1 at 0xf4603f84 thread T0\n #0 0x8408edd in read_line_table_program /home/puzzor/test-fuzzing/code/libdwarf/./dwarf_line_table_reader_common.c:1433\n #1 0x83f716c in _dwarf_internal_srclines /home/puzzor/test-fuzzing/code/libdwarf/./dwarf_line.c:690\n #2 0x841436c in dwarf_srclines_b /home/puzzor/test-fuzzing/code/libdwarf/./dwarf_line.c:944\n #3 0x81fbc28 in print_line_numbers_this_cu /home/puzzor/test-fuzzing/code/dwarfdump/print_lines.c:763\n #4 0x815c191 in print_one_die_section /home/puzzor/test-fuzzing/code/dwarfdump/print_die.c:850\n #5 0x81565c1 in print_infos /home/puzzor/test-fuzzing/code/dwarfdump\n </pre>\ndatefixed: 2016-09-23\nreferences: regressiontests/DW201609-004/poc\ngitfixid:  3767305debcba8bd7e1c483ae48c509d25399252\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\n\nid: DW201609-003\ncve: CVE-2016-7410\ndatereported: 2016-09-13\nreportedby: https://marc.info/?l=oss-security&m=147391785920048&w=2\nvulnerability: libdwarf 20160613 heap-buffer-overflow\nproduct: libdwarf\ndescription: With AddressSanitizer, \n  we found a Heap-Buffer-overflow in the latest\n  release version of dwarfdump. The crash output is as follows:\n  <pre>\n  See also:\n  https://marc.info/?l=oss-security&m=147378394815872&w=2\n  The testcase poc is from this web page.\n  </pre>\n  <pre>\n  ==17411==ERROR: AddressSanitizer: heap-buffer-overflow on address\n  0xf3808904 at pc 0x80a6f76 bp 0xffb95e78 sp 0xffb95a5c\n  READ of size 4 at 0xf3808904 thread T0\n  ==17411==WARNING: Trying to symbolize code, but external symbolizer is\n  not initialized!\n    #0 0x80a6f75 in __interceptor_memcpy ??:?\n    #1 0x8426c3b in _dwarf_read_loc_section\n  /home/starlab/fuzzing/dwarf-20160613/libdwarf/./dwarf_loc.c:919\n    #2 0x84250e2 in _dwarf_get_loclist_count\n  /home/starlab/fuzzing/dwarf-20160613/libdwarf/./dwarf_loc.c:970\n    #3 0x8438826 in dwarf_get_loclist_c\n  /home/starlab/fuzzing/dwarf-20160613/libdwarf/./dwarf_loc2.c:551\n    #4 0x81a1be8 in get_location_list\n  /home/starlab/fuzzing/dwarf-20160613/dwarfdump/print_die.c:3523\n    #5 0x816e1a2 in print_attribute\n  </pre>\n  _dwarf_get_loclist_header_start() is not cautious about values\n  in the header being absurdly large.\n  Unclear as yet if this is the problem\n  but it is a potential problem (fixed for next release).\n  <pre>\n  Address Sanitizer in gcc reproduces the report.\n  In _dwarf_read_loc_section() the simple calculation of\n  loc_section_end was wrong, so end-of section was\n  incorrect for the local reads.\n  With that fixed we get DW_DLE_READ_LITTLEENDIAN_ERROR when\n  libdwarf attempts to read off end of section.\n  </pre>\ndatefixed: 2016-09-23\nreferences: regressiontests/DW201609-003/poc\ngitfixid:  3767305debcba8bd7e1c483ae48c509d25399252\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201609-002\ncve: CVE-2016-7511\ndatereported: 2016-09-18\nreportedby: Shi Ji (@Puzzor)\nvulnerability: libdwarf 20160613 Integer Overflow\nproduct: libdwarf\ndescription: In dwarf_get_size_of_val() with\n  fuzzed DWARF data we get a SEGV. \n  <pre>\n  See\n  https://sourceforge.net/p/libdwarf/bugs/3/\n  </pre>\n  <pre>\n  ==6825== ERROR: AddressSanitizer: SEGV on unknown address 0x0583903c (pc 0xb61f1a98 sp 0xbfa388b4 bp 0xbfa38d08 T0)\n  AddressSanitizer can not provide additional info.\n  #1 0xb61e3c0b (/usr/lib/i386-linux-gnu/libasan.so.0+0xdc0b)\n  #2 0x80a21b1 in _dwarf_get_size_of_val /home/fuzzing/fuzzing/dwarf-20160613/libdwarf/dwarf_util.c:210\n  #3 0x8054214 in _dwarf_next_die_info_ptr /home/fuzzing/fuzzing/dwarf-20160613/libdwarf/dwarf_die_deliv.c:1340\n  #4 0x80557a5 in dwarf_child /home/fuzzing/fuzzing/dwarf-20160613/libdwarf/dwarf_die_deliv.c:1640\n  #5 0x804b23f in get_die_and_siblings /home/fuzzing/fuzzing/dwarf-20160613/dwarfexample/./simplereader.c:573\n  </pre>\n  _dwarf_make_CU_Context() is insufficiently cautious about\n  the length of a CU being absurd. \n  Unclear as yet if this is the problem\n  but it is a problem and is fixed for next release.\ndatefixed: 2016-09-23\nreferences: regressiontests/DW201609-002/DW201609-002-poc\ngitfixid:   3767305debcba8bd7e1c483ae48c509d25399252\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\nid: DW201609-001\ncve: \ndatereported: 2016-09-16\nreportedby: STARLAB\n   https://sourceforge.net/p/libdwarf/bugs/2/\nvulnerability: libdwarf 20160613 die_info_ptr in dwarf_die_deliv.c: 1533 Out-Of_bounds\nproduct: libdwarf\ndescription: At line 1533 of dwarf_die_deliv.c a\n pointer dereference is done with a pointer pointing\n past the end of the CU data.\n <pre>\n see\n https://sourceforge.net/p/libdwarf/bugs/2/\n </pre>\n <pre>\n ==8054==ERROR: AddressSanitizer: heap-buffer-overflow on \n    address 0xf4c027ab at pc 0x819e4a4 bp 0xff88eb38 sp 0xff88eb30\n READ of size 1 at 0xf4c027ab thread T0\n #0 0x819e4a3 in dwarf_siblingof_b /home/starlab/fuzzing/dwarf-20160613/libdwarf/dwarf_die_deliv.c:1533\n #1 0x8116201 in print_die_and_children_internal /home/starlab/fuzzing/dwarf-20160613/dwarfdump/print_die.c:1157\n Bug report on sourceforge.net bug list for libdwarf.\n The bad pointer dereference is due to libdwarf \n not noticing that the DWARF in that file is corrupt.\n In addtion\n The code was not noticing that it could dereference\n a pointer that pointed out of bounds in the end-sibling-list\n loop. \n </pre>\n <pre>\n The example from the bug report (DW201609-001-poc) has\n the same problem.\n dwarfdump now reports DW_DLE_SIBLING_LIST_IMPROPER\n on both test2.o and DW201609-001-poc.\n </pre>\ndatefixed: 2016-09-17\nreferences: regressiontests/DW201609-001/test2.o \n  regressiontests/DW201609-001/DW201609-001-poc\ngitfixid:  3767305debcba8bd7e1c483ae48c509d25399252\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-019\ncve: CVE-2016-5028\ndatereported: 2016-05-23\nreportedby: Yue Liu\nvulnerability: Null dereference in print_frame_inst_bytes (dwarfdump)\nproduct: libdwarf\ndescription: The null dereference is due to a corrupted\n object file. Libdwarf was not dealing with empty (bss-like)\n sections since it really did not expect to see such in\n sections it reads!  Now libdwarf catches the object error\n so dwarfdump sees the section as empty (as indeed it is!).\ndatefixed: 2016-05-23\nreferences: regressiontests/liu/NULLdeference0522c.elf\ngitfixid: a55b958926cc67f89a512ed30bb5a22b0adb10f4\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-018\ncve: CVE-2016-5029\ndatereported: 2016-05-22\nreportedby: Yue Liu\nvulnerability: Null dereference in create_fullest_file_path().\nproduct: libdwarf\ndescription: The null dereference in create_fullest_file_path()\n causes a crash. This is due to corrupted dwarf and the fix\n detects this corruption and if that null string pointer\n happens undetected a static string is substituted so\n readers can notice the situation.\n <pre>\n  202             }\n 203             if (dirno > 0 && fe->fi_dir_index > 0) {\n 204                 inc_dir_name = (char *) \n                         line_context->lc_include_directories[\n 205                     fe->fi_dir_index - 1];\n 206                 incdirnamelen = strlen(inc_dir_name);  <- $pc\n 207             }\n 208             full_name = (char *) _dwarf_get_alloc(dbg, \n\n #0  create_fullest_file_path (dbg=<optimized out>,\n fe=0x68d510, line_context=0x68c4f0, name_ptr_out=<optimized\n out>, error=0x7fffffffe2b8) at ./dwarf_line.c:206\n\n #1  0x00007ffff7b6d3f9 in dwarf_filename (context=<optimized\n out>, fileno_in=<optimized out>, ret_filename=0x7fffffffe280,\n error=0x7fffffffe2b8) at ./dwarf_line.c:1418\n\n #2  dwarf_linesrc (line=<optimized out>,\n ret_linesrc=<optimized out>, error=<optimized out>) at\n ./dwarf_line.c:1436\n </pre>\ndatefixed: 2016-05-22\nreferences: regressiontests/liu/NULLdereference0522.elf\ngitfixid: acae971371daa23a19358bc62204007d258fbc5e\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\n\nid: DW201605-017\ncve: CVE-2016-5030\ndatereported: 2016-05-19\nreportedby: Yue Liu\nvulnerability: Null dereference bug in  _dwarf_calculate_info_section_end_ptr().\nproduct: libdwarf\ndescription: \n NULL dereference bug in _dwarf_calculate_info_section_end_ptr().\n <pre>\n 1742         Dwarf_Off off2 = 0;\n 1743         Dwarf_Small *dataptr = 0;\n 1744     \n 1745         dbg = context->cc_dbg;\n 1746         dataptr = context->cc_is_info? dbg->de_debug_info.dss_data:                 <- $pc\n 1747             dbg->de_debug_types.dss_data;\n 1748         off2 = context->cc_debug_offset;\n 1749         info_start = dataptr + off2;\n 1750         info_end = info_start + context->cc_length +\n \n #0  _dwarf_calculate_info_section_end_ptr\n (context=context@entry=0x0) at dwarf_query.c:1746\n \n #1  0x00002aaaaace307d in\n _dwarf_extract_string_offset_via_str_offsets\n (dbg=dbg@entry=0x655a70, info_data_ptr=0x6629f0\n \"\", attrnum=attrnum@entry=121,\n attrform=attrform@entry=26, cu_context=0x0,\n str_sect_offset_out=str_sect_offset_out@entry=0x7fffffffd718,\n error=error@entry=0x7fffffffd878) at dwarf_form.c:1099\n \n #2  0x00002aaaaacf4ed7 in dwarf_get_macro_defundef\n (macro_context=macro_context@entry=0x65b790,\n op_number=op_number@entry=1,\n line_number=line_number@entry=0x7fffffffd858,\n index=index@entry=0x7fffffffd860,\n offset=offset@entry=0x7fffffffd868,\n forms_count=forms_count@entry=0x7fffffffd7ce,\n macro_string=macro_string@entry=0x7fffffffd870,\n error=error@entry=0x7fffffffd878) at dwarf_macro5.c:557\n \n ------\n \n _dwarf_calculate_info_section_end_ptr (context=context@entry=0x0) at \n   dwarf_query.c:1746\n 1746        dataptr = context->cc_is_info? dbg->de_debug_info.dss_data:\n gef> p/x $rdi\n $4 = 0x0\n </pre>\ndatefixed: 2016-05-22\nreferences: regressiontests/liu/NULLdereference0519.elf\ngitfixid: 6fa3f710ee6f21bba7966b963033a91d77c952bd\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\nid: DW201605-016\ncve:\ndatereported: 2016-05-19\nreportedby: Yue Liu\nvulnerability: Invalid dwarf leads to \n dwarfdump crash in print_frame_inst_bytes.\nproduct: dwarfdump\ndescription: Corrupted dwarf crashes dwarfdump\n <pre>\n 1297         }\n 1298         len = len_in;\n 1299         endpoint = instp + len;\n 1300         for (; len > 0;) {\n 1301             unsigned char ibyte = *instp;           <- $pc\n 1302             int top = ibyte & 0xc0;\n 1303             int bottom = ibyte & 0x3f;\n 1304             int delta = 0;\n 1305             int reg = 0;\n\n #0  print_frame_inst_bytes (dbg=dbg@entry=0x655ca0,\n cie_init_inst=<optimized out>, len_in=<optimized out>,\n data_alignment_factor=-4, code_alignment_factor=4,\n addr_size=addr_size@entry=4, offset_size=4, version=3,\n config_data=config_data@entry=0x63cda0 <g_config_file_data>)\n at print_frames.c:1301\n\n #1  0x000000000041b70c in print_one_cie\n (dbg=dbg@entry=0x655ca0, cie=<optimized out>,\n cie_index=cie_index@entry=2, address_size=<optimized out>,\n config_data=config_data@entry=0x63cda0 <g_config_file_data>)\n at print_frames.c:1161\n\n #2  0x000000000041cf52 in print_frames (dbg=0x655ca0,\n print_debug_frame=print_debug_frame@entry=1, print_eh_frame=0,\n config_data=config_data@entry=0x63cda0 <g_config_file_data>)\n at print_frames.c:2229\n\n gef> p/x $r13\n $1 = 0x4bcad8\n gef> p/x *$r13\n Cannot access memory at address 0x4bcad8\n </pre>\ndatefixed: 2016-05-22\nreferences: regressiontests/liu/OOB_READ0519.elf\ngitfixid: 6fa3f710ee6f21bba7966b963033a91d77c952bd\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-015\ncve: CVE-2016-5031\ndatereported: 2016-05-17\nreportedby: Yue Liu\nvulnerability: OOB read bug in print_frame_inst_bytes()\nproduct: libdwarf\ndescription: Test object shows\n an invalid read in  print_frame_inst_bytes().\n <pre>\n 1294         for (; len > 0;) {\n 1295             unsigned char ibyte = *instp;           <- $pc\n 1296             int top = ibyte & 0xc0;\n\n #0  print_frame_inst_bytes (dbg=dbg@entry=0x654c80, \n    cie_init_inst=<optimized out>, len=503715, data_alignment_factor=-4, \n    code_alignment_factor=1, addr_size=addr_size@entry=4, offset_size=4, \n    version=3, config_data=config_data@entry=0x63bda0 \n    <g_config_file_data>) at print_frames.c:1295\n #1  0x000000000041b64c in print_one_cie (dbg=dbg@entry=0x654c80, \n    cie=<optimized out>, cie_index=cie_index@entry=1, \n    address_size=<optimized out>, config_data=\n    config_data@entry=0x63bda0 <g_config_file_data>) at print_frames.c:1161\n #2  0x000000000041ce92 in print_frames (dbg=0x654c80, \n    print_debug_frame=print_debug_frame@entry=1, print_eh_frame=0, \n    config_data=config_data@entry=0x63bda0 <g_config_file_data>) \n    at print_frames.c:2209\n\n gef> x/10x $r13\n 0x5e7981:       Cannot access memory at address 0x5e7981\n gef> p/x $r13\n $14 = 0x5e7981\n </pre>\ndatefixed: 2015-05-18\nreferences: regressiontests/liu/OOB0517_03.elf\ngitfixid: ac6673e32f3443a5d36c2217cb814000930b2c54\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\n\nid: DW201605-014\ncve: CVE-2016-5032\ndatereported: 2016-05-17\nreportedby: Yue Liu\nvulnerability: OOB read bug in dwarf_get_xu_hash_entry()\nproduct: libdwarf\ndescription: Test object shows\n an invalid read in dwarf_get _xu_hash_entry, lin 211.\n <pre>\n #0  dwarf_get_xu_hash_entry (xuhdr=xuhdr@entry=0x657360, \n    index=index@entry=2897626028, hash_value=\n    hash_value@entry=0x7fffffffd5b0, \n    index_to_sections=index_to_sections@entry=0x7fffffffd5a8, \n    err=err@entry=0x7fffffffdb08) at dwarf_xu_index.c:211\n #1  0x00002aaaaacfd05e in _dwarf_search_fission_for_key (\n    dbg=0x654a50, error=0x7fffffffdb08, percu_index_out=<synthetic pointer>,\n    key_in=0x7fffffffd670, xuhdr=0x657360) at dwarf_xu_index.c:363\n #2  dwarf_get_debugfission_for_key (dbg=dbg@entry=0x654a50, \n    key=key@entry=0x7fffffffd670, key_type=key_type@entry=0x2aaaaad15e2a \n    \"tu\", percu_out=percu_out@entry=0x65a830, \n    error=error@entry=0x7fffffffdb08) at dwarf_xu_index.c:577\n </pre>\ndatefixed: 2015-05-18\nreferences: regressiontests/liu/OOB0517_02.elf\ngitfixid: ac6673e32f3443a5d36c2217cb814000930b2c54\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\n\nid: DW201605-013\ncve: CVE-2016-5033\ndatereported: 2016-05-17\nreportedby: Yue Liu\nvulnerability: OOB read bug in print_exprloc_content\nproduct: libdwarf\ndescription: Test object shows\n an invalid write in print_exprloc_content.\n <pre>\n #0  print_exprloc_content (dbg=dbg@entry=0x654ea0, \n    die=die@entry=0x65b110, attrib=attrib@entry=0x65b590, \n    esbp=esbp@entry=0x7fffffffcef0, showhextoo=1) at print_die.c:4182\n #1  0x0000000000412fb1 in get_attr_value (dbg=dbg@entry=0x654ea0, \n    tag=<optimized out>, die=die@entry=0x65b110, \n    dieprint_cu_goffset=dieprint_cu_goffset@entry=11, \n    attrib=attrib@entry=0x65b590, srcfiles=srcfiles@entry=0x0, \n    cnt=cnt@entry=0, esbp=esbp@entry=0x7fffffffcef0, show_form=0, \n    local_verbose=0) at print_die.c:4972\n </pre>\ndatefixed: 2015-05-18\nreferences: regressiontests/liu/OOB0517_01.elf\ngitfixid: ac6673e32f3443a5d36c2217cb814000930b2c54\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-012\ncve: CVE-2016-5034\ndatereported: 2016-05-13\nreportedby: Yue Liu\nvulnerability: OOB write. From relocation records\nproduct: libdwarf\ndescription: Test object shows\n an invalid write in dwarf_elf_access.c\n (when doing the relocations).\n Adding the relocation value to anything overflowed\n and disguised the bad relocation record.\n With a 32bit kernel build the test could show\n a double-free and coredump due to the unchecked invalid\n writes from relocations.\ndatefixed: 2016-05-17 \nreferences: regressiontests/liu/HeapOverflow0513.elf\ngitfixid: 10ca310f64368dc083efacac87732c02ef560a92\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\n\nid: DW201605-011\ncve: CVE-2016-5035\ndatereported: 2016-05-06\nreportedby: Yue Liu\nvulnerability: OOB read bug in _dwarf_read_line_table_header\nproduct: libdwarf\ndescription: Test object shows\n null dereference at line 62\n of dwarf_line_table_reader.c.\n Frame code and linetable code was not noticing data corruption.\ndatefixed: 2016-05-12\nreferences: regressiontests/liu/OOB_read4.elf\ngitfixid: 82d8e007851805af0dcaaff41f49a2d48473334b\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\n\nid: DW201605-010\ncve: CVE-2016-5036\ndatereported: 2016-05-06\nreportedby: Yue Liu\nvulnerability: OOB read bug in dump_block\nproduct: libdwarf\ndescription: Test object shows\n null dereverence at line 186\n of dump_block() in print_sections.c\n Frame code was not noticing frame data corruption.\ndatefixed: 2016-05-12\nreferences: regressiontests/liu/OOB_read3.elf\n regressiontests/liu/OOB_read3_02.elf\ngitfixid: 82d8e007851805af0dcaaff41f49a2d48473334b\ntarrelease: libdwarf-20160923.tar.gz\nendrec:\n\nid: DW201605-009\ncve: CVE-2016-5037\ndatereported: 2016-05-05\nreportedby: Yue Liu\nvulnerability: NULL dereference in _dwarf_load_section\nproduct: libdwarf\ndescription: Test object shows\n null dereverence at line 1010\n if(!strncmp(\"ZLIB\",(const char *)src,4)) {\n in dwarf_init_finish.c\n The zlib code was not checking for\n a corrupted length-value.\ndatefixed: 2016-05-06\nreferences: regressiontests/liu/NULLderefer0505_01.elf\ngitfixid: b6ec2dfd850929821626ea63fb0a752076a3c08a\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-008\ncve: CVE-2016-5038\ndatereported: 2016-05-05\nreportedby: Yue Liu\nvulnerability: OOB read in dwarf_get_macro_startend_file()\nproduct: libdwarf\ndescription: Test object shows\n out of bound read.\n OOB at:\n line 772  *src_file_name = macro_context->mc_srcfiles[trueindex];\n in dwarf_macro5.c\n A string offset into .debug_str is outside the bounds\n of the .debug_str section.\ndatefixed: 2016-05-12\nreferences: regressiontests/liu/OOB0505_02.elf\n regressiontests/liu/OOB0505_02_02.elf\ngitfixid: 82d8e007851805af0dcaaff41f49a2d48473334b\ntarrelease: libdwarf-20160923.tar.gz \nendrec:\n\nid: DW201605-007\ncve: CVE-2016-5039\ndatereported: 2016-05-05\nreportedby: Yue Liu\nvulnerability: OOB read bug in get_attr_value()\nproduct: libdwarf\ndescription: Test object shows\n out of bound read.\n Object had data all-bits-on so\n the existing length check did not work\n due to wraparound. Added a check\n not susceptible to that error (DW_DLE_FORM_BLOCK_LENGTH_ERROR).\ndatefixed: 2016-05-06\nreferences: regressiontests/liu/OOB0505_01.elf\ngitfixid: eb1472afac95031d0c9dd8c11d527b865fe7deb8\ngittag: 20160507\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-006\ncve:\ndatereported: 2016-05-05\nreportedby: Yue Liu\nvulnerability: Two Heap-Overflow bug\nproduct: libdwarf\ndescription: Two test objects showing\n a heap overflow in libdwarf when\n using dwarfdump.\n It seems that these were fixed\n by the previous git update.\n Neither gdb nor valgrind find any errors\n when building with yesterday's commit.\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/free_invalid_address.elf\n regressiontests/liu/heapoverflow01b.elf\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-001\ncve: CVE-2016-5044\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in a duplicate free() in libdwarf and\n the calling application will crash. \nproduct:  libdwarf\ndescription:\n In file dwarf_elf_access.c:1071\n <pre>\n WRITE_UNALIGNED(dbg,target_section + offset,\n     &outval,sizeof(outval),reloc_size);\n </pre>\n A crafted ELF file may lead to a large offset value, which\n bigger than the size of target_section heap chunk, then this\n WRITE_UNALIGNED() function will write the value of &outval\n out of the heap chunk.\n offset is a 64bit unsigned int value, so this is more than\n a heap overflow bug, but also a Out-of-Bound write bug.\n So WRITE_UNALIGNED() need more strictly checking to prevent\n this.\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/heapoverflow01.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332141\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ngittag: 2016-05-07\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\n\n\nid: DW201605-002\ncve: CVE-2016-5043\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in a read outside the bounds of in memory\n data so the calling application can crash.\nproduct:  libdwarf\ndescription: Out of bound read bug in libdwarf git code.\n\n dwarf_dealloc() did not check the Dwarf_Ptr space argument\n before using it. This will lead to a out-of-bound read bug.\n <pre>\n backtrace:\n #0  dwarf_dealloc (dbg=dbg@entry=0x655f30, space=0xa0,\n alloc_type=alloc_type@entry=1) at dwarf_alloc.c:477\n #1  0x00002aaaaacf3296 in dealloc_srcfiles\n (dbg=0x655f30, srcfiles=0x66b8f0, srcfiles_count=17) at\n dwarf_macro5.c:1025 #2  0x00002aaaaacf50e6 in dealloc_srcfiles\n (srcfiles_count=<optimized out>, srcfiles=<optimized out>,\n dbg=<optimized out>) at dwarf_macro5.c:1021 -----\n\n gef> p &r->rd_dbg\n $14 = (void **) 0x90\n </pre>\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/outofbound01.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332144\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-003\ncve: CVE-2016-5042\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in an infinite loop that eventually\n crashes the application.\nproduct:  libdwarf\ndescription:\n In dwarf_get_aranges_list()\n an invalid count will iterate, reading from memory\n addresses that increase till it all fails.\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/infiniteloop.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332145\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-004\ncve: CVE-2016-5041\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in a null dereference reading debugging\n information entries  which\n crashes the application.\nproduct:  libdwarf\ndescription:\n If no DW_AT_name is present in a debugging\n information entry  using DWARF5 macros\n a null dereference in dwarf_macro5.c will\n crash the application.\n \ndatefixed: 2016-05-04\nreferences: regressiontests/liu/null01.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332148\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-005\ncve: CVE-2016-5040\ndatereported: 2016-05-02\nreportedby: Yue Liu\nvulnerability: A specially crafted DWARF section\n results in  reading a compilation unit header\n that crashes the application.\nproduct:  libdwarf\ndescription:\n If the data read for a compilation unit header\n contains a too large length value the library\n will read outside of its bounds and crash the application.\ndatefixed: 2016-05-04\nreferences: regressiontests/liu/null02.elf\n <pre>\n https://bugzilla.redhat.com/show_bug.cgi?id=1332149\n </pre>\ngitfixid: 98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f\ntarrelease: libdwarf-20160507.tar.gz\nendrec:\n\nid: DW201605-020\ncve: CVE-2016-5027\ndatereported: 2016-04-25\nreportedby: Yue Liu,lieanu\nvulnerability: NULL dereference in  _dwarf_decode_s_leb128\nproduct: libdwarf\ndescription: dwarf_form.c in libdwarf 20160115 allows\n  remote attackers to cause a denial of service (crash) \n  via a crafted elf file\n  Apparently no crafted object file presented.\n  However the code fix is presented in the report\n  at openwall.com.\n  Discovered the CVE November 2021\n  To attack the code just pass the argument\n  Dwarf_Word * leb128_length as a NULL pointer (that is allowed). \n  The code was fixed in dwarf_leb.c on 2016-04-27 20:00:06.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1330237\n  www.openwall.com/lists/oss-security/2016/05/24/1\n  www.openwall.com/lists/oss-security/2016/05/25/1\n  </pre>\ndatefixed: 2016-05-27 \nreferences:\ngitfixid: \ntarrelease: \nendrec: DW201605-020\n\nid: DW201601-001\ncve: CVE-2016-2091\ndatereported: 2016-01-12\nreportedby: Qixue Xiao\nvulnerability: Out of bound read in  dwarf_read_cie_fde_prefix()\nproduct: libdwarf\ndescription: Crashes the calling program. Requires\n  a crafted object file.  \n  <pre>\n  *** DWARF CHECK: DW_DLE_DEBUG_FRAME_LENGTH_NOT_MULTIPLE\n  len=0x00000010, len size=0x00000004, extn size=0x00000000, totl\n  length=0x00000014, addr size=0x00000008, mod=0x00000004 must be zero\n  in cie, offset 0x00000000. ***\n  7   ==53495== Invalid read of size 2\n  1 ==53495==    at 0x4C2F7E0: memcpy@@GLIBC_2.14 (in\n  /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n  2 ==53495==    by 0x43287F: dwarf_read_cie_fde_prefix (dwarf_frame2.c:934)\n  3 ==53495==    by 0x431305: _dwarf_get_fde_list_internal (dwarf_frame2.c:268)\n  4 ==53495==    by 0x42EB5F: dwarf_get_fde_list_eh (dwarf_frame.c:1101)\n  5 ==53495==    by 0x41BABE: print_frames (print_frames.c:1835)\n  6 ==53495==    by 0x40485B: process_one_file (dwarfdump.c:1323)\n  7 ==53495==    by 0x403529: main (dwarfdump.c:630)\n  www.openwall.com/lists/oss-security/2016/01/19/3\n  www.openwall.com/lists/oss-security/2016/05/28/8\n  </pre>\ndatefixed: 2016-01-21\nreferences: regressiontests/xqx-b/awbug5.elf\ngitfixid: d9d40e4d802e626065ce37ff384dd69c43bc499\ntarrelease:\nendrec: DW201601-001\n\nid: DW201601-002\ncve: CVE-2016-2050\ndatereported: 2016-01-19\nreportedby: Qixue Xiao\nvulnerability: Out of bound write in get_abbrev_array_info\nproduct: libdwarf\ndescription: Crashes the calling program. Requires\n  a crafted object file.\n  <pre>\n  valgrind ./dwarfdump -ka aw.elf\n  ==5358== Memcheck, a memory error detector\n  ==5358== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\n  ==5358== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info\n  ==5358== Command: ../../llvm-codes/dwarf-20151114/dwarfdump/dwarfdump -ka aw.elf\n  ==5358==\n  ==5358== Invalid write of size 8\n  ==5358==    at 0x40DA25: get_abbrev_array_info (in\n  /home/xqx/test/libdwarf-test/llvm-codes/dwarf-20151114/dwarfdump/dwarfdump)\n  ==5358==    by 0x40FD92: print_one_die_section (in\n  /home/xqx/test/libdwarf-test/llvm-codes/dwarf-20151114/dwarfdump/dwarfdump)\n  www.openwall.com/lists/oss-security/2016/01/19/9 \n  www.openwall.com/lists/oss-security/2016/01/25/3\n  </pre>\ndatefixed: 2016-01-21\nreferences: regressiontests/xqx-b/aw.elf\ngitfixid: d9d40e4d802e626065ce37ff384dd69c43bc499\ntarrelease:\nendrec: DW201601-002\n\nid: DW201512-001\ncve: CVE-2015-8750\ndatereported: 2015-12-26\nreportedby: Qixue Xiao (xqx)\nvulnerability:  Null pointer dereference in libdwarf\nproduct: libdwarf\ndescription: libdwarf 20151114 and earlier allows remote\n  attackers to cause a denial of service (NULL pointer \n  dereference and crash) via a debug_abbrev \n  section marked NOBITS in an ELF file.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1294264\n  www.openwall.com/lists/oss-security/2016/01/07/11\n  </pre>\ndatefixed: 2015-12-31 \nreferences: regressiontests/xqx-c/awbug6.elf\ngitfixid: \ntarrelease: \nendrec: DW201512-001\n\nid: DW201512-002\ncve: CVE-2015-8538\ndatereported: 2015-12-14\nreportedby: Adam Maris\nvulnerability:  Out-of-bounds read in dwarf_leb.c\nproduct: libdwarf\ndescription: libdwarf 20151114 and earlier allows remote\n  attackers to cause a denial of service (NULL pointer \n  dereference and crash) via a debug_abbrev \n  section marked NOBITS in an ELF file.\n  The CVE report mentions a reproducer object file\n  but such is not present.\n  Due to recent tool advances (like\n  coverity scan) we are confident this was fixed long ago.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1291299 \n  www.openwall.com/lists/oss-security/2015/12/10/3 \n  </pre>\ndatefixed: 2018-01-01\nreferences:\ngitfixid: \ntarrelease:\nendrec: DW201512-002\n\n\nid: DW201412-001\ncve: CVE-2014-9482\ndatereported: 2014-12-31\nreportedby: Adam Maris\nvulnerability: Use after free vulnerability in Dwarfdump\nproduct: dwarfdump\ndescription: The use-after-free has no attached testcase\n  anywhere.  Due to recent tool advances (like\n  coverity scan) we are confident this was fixed long ago.\n  <pre>\n  bugzilla.redhat.com/show_bug.cgi?id=1177758\n  www.openwall.com/lists/oss-security/2014/12/31/3 \n  www.openwall.com/lists/oss-security/2015/01/03/14\n  </pre>\ndatefixed: 2018-01-01\nreferences: \ngitfixid:\ntarrelease:\nendrec: DW201412-001\n\n\n\n"], "filenames": ["bugxml/data.txt"], "buggy_code_start_loc": [0], "buggy_code_end_loc": [0], "fixing_code_start_loc": [1], "fixing_code_end_loc": [26], "type": "CWE-415", "message": "libdwarf 0.4.1 has a double free in _dwarf_exec_frame_instr in dwarf_frame.c.", "other": {"cve": {"id": "CVE-2022-39170", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-02T03:15:07.527", "lastModified": "2022-09-29T15:50:28.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libdwarf 0.4.1 has a double free in _dwarf_exec_frame_instr in dwarf_frame.c."}, {"lang": "es", "value": "libdwarf versi\u00f3n 0.4.1, presenta una doble liberaci\u00f3n en la funci\u00f3n _dwarf_exec_frame_instr en el archivo dwarf_frame.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libdwarf_project:libdwarf:0.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "DE7E818D-510D-47B1-8DB9-299F4344D6D8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/davea42/libdwarf-code/commit/60303eb80ecc7747bf29776d545e2a5c5a76f6f8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/davea42/libdwarf-code/issues/132", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IKUE4XT62AEZ3H5D6GMREYOSCMMRFXBH/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/davea42/libdwarf-code/commit/60303eb80ecc7747bf29776d545e2a5c5a76f6f8"}}