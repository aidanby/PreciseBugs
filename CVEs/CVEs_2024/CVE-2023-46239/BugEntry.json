{"buggy_code": ["package quic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/logutils\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n)\n\ntype unpacker interface {\n\tUnpackLongHeader(hdr *wire.Header, rcvTime time.Time, data []byte, v protocol.VersionNumber) (*unpackedPacket, error)\n\tUnpackShortHeader(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error)\n}\n\ntype streamGetter interface {\n\tGetOrOpenReceiveStream(protocol.StreamID) (receiveStreamI, error)\n\tGetOrOpenSendStream(protocol.StreamID) (sendStreamI, error)\n}\n\ntype streamManager interface {\n\tGetOrOpenSendStream(protocol.StreamID) (sendStreamI, error)\n\tGetOrOpenReceiveStream(protocol.StreamID) (receiveStreamI, error)\n\tOpenStream() (Stream, error)\n\tOpenUniStream() (SendStream, error)\n\tOpenStreamSync(context.Context) (Stream, error)\n\tOpenUniStreamSync(context.Context) (SendStream, error)\n\tAcceptStream(context.Context) (Stream, error)\n\tAcceptUniStream(context.Context) (ReceiveStream, error)\n\tDeleteStream(protocol.StreamID) error\n\tUpdateLimits(*wire.TransportParameters)\n\tHandleMaxStreamsFrame(*wire.MaxStreamsFrame)\n\tCloseWithError(error)\n\tResetFor0RTT()\n\tUseResetMaps()\n}\n\ntype cryptoStreamHandler interface {\n\tStartHandshake() error\n\tChangeConnectionID(protocol.ConnectionID)\n\tSetLargest1RTTAcked(protocol.PacketNumber) error\n\tSetHandshakeConfirmed()\n\tGetSessionTicket() ([]byte, error)\n\tNextEvent() handshake.Event\n\tDiscardInitialKeys()\n\tio.Closer\n\tConnectionState() handshake.ConnectionState\n}\n\ntype receivedPacket struct {\n\tbuffer *packetBuffer\n\n\tremoteAddr net.Addr\n\trcvTime    time.Time\n\tdata       []byte\n\n\tecn protocol.ECN\n\n\tinfo packetInfo // only valid if the contained IP address is valid\n}\n\nfunc (p *receivedPacket) Size() protocol.ByteCount { return protocol.ByteCount(len(p.data)) }\n\nfunc (p *receivedPacket) Clone() *receivedPacket {\n\treturn &receivedPacket{\n\t\tremoteAddr: p.remoteAddr,\n\t\trcvTime:    p.rcvTime,\n\t\tdata:       p.data,\n\t\tbuffer:     p.buffer,\n\t\tecn:        p.ecn,\n\t\tinfo:       p.info,\n\t}\n}\n\ntype connRunner interface {\n\tAdd(protocol.ConnectionID, packetHandler) bool\n\tGetStatelessResetToken(protocol.ConnectionID) protocol.StatelessResetToken\n\tRetire(protocol.ConnectionID)\n\tRemove(protocol.ConnectionID)\n\tReplaceWithClosed([]protocol.ConnectionID, protocol.Perspective, []byte)\n\tAddResetToken(protocol.StatelessResetToken, packetHandler)\n\tRemoveResetToken(protocol.StatelessResetToken)\n}\n\ntype closeError struct {\n\terr       error\n\tremote    bool\n\timmediate bool\n}\n\ntype errCloseForRecreating struct {\n\tnextPacketNumber protocol.PacketNumber\n\tnextVersion      protocol.VersionNumber\n}\n\nfunc (e *errCloseForRecreating) Error() string {\n\treturn \"closing connection in order to recreate it\"\n}\n\nvar connTracingID uint64        // to be accessed atomically\nfunc nextConnTracingID() uint64 { return atomic.AddUint64(&connTracingID, 1) }\n\n// A Connection is a QUIC connection\ntype connection struct {\n\t// Destination connection ID used during the handshake.\n\t// Used to check source connection ID on incoming packets.\n\thandshakeDestConnID protocol.ConnectionID\n\t// Set for the client. Destination connection ID used on the first Initial sent.\n\torigDestConnID protocol.ConnectionID\n\tretrySrcConnID *protocol.ConnectionID // only set for the client (and if a Retry was performed)\n\n\tsrcConnIDLen int\n\n\tperspective protocol.Perspective\n\tversion     protocol.VersionNumber\n\tconfig      *Config\n\n\tconn      sendConn\n\tsendQueue sender\n\n\tstreamsMap      streamManager\n\tconnIDManager   *connIDManager\n\tconnIDGenerator *connIDGenerator\n\n\trttStats *utils.RTTStats\n\n\tcryptoStreamManager   *cryptoStreamManager\n\tsentPacketHandler     ackhandler.SentPacketHandler\n\treceivedPacketHandler ackhandler.ReceivedPacketHandler\n\tretransmissionQueue   *retransmissionQueue\n\tframer                framer\n\twindowUpdateQueue     *windowUpdateQueue\n\tconnFlowController    flowcontrol.ConnectionFlowController\n\ttokenStoreKey         string                    // only set for the client\n\ttokenGenerator        *handshake.TokenGenerator // only set for the server\n\n\tunpacker      unpacker\n\tframeParser   wire.FrameParser\n\tpacker        packer\n\tmtuDiscoverer mtuDiscoverer // initialized when the handshake completes\n\n\tinitialStream       cryptoStream\n\thandshakeStream     cryptoStream\n\toneRTTStream        cryptoStream // only set for the server\n\tcryptoStreamHandler cryptoStreamHandler\n\n\treceivedPackets  chan receivedPacket\n\tsendingScheduled chan struct{}\n\n\tcloseOnce sync.Once\n\t// closeChan is used to notify the run loop that it should terminate\n\tcloseChan chan closeError\n\n\tctx                context.Context\n\tctxCancel          context.CancelCauseFunc\n\thandshakeCtx       context.Context\n\thandshakeCtxCancel context.CancelFunc\n\n\tundecryptablePackets          []receivedPacket // undecryptable packets, waiting for a change in encryption level\n\tundecryptablePacketsToProcess []receivedPacket\n\n\tearlyConnReadyChan chan struct{}\n\tsentFirstPacket    bool\n\thandshakeComplete  bool\n\thandshakeConfirmed bool\n\n\treceivedRetry       bool\n\tversionNegotiated   bool\n\treceivedFirstPacket bool\n\n\t// the minimum of the max_idle_timeout values advertised by both endpoints\n\tidleTimeout  time.Duration\n\tcreationTime time.Time\n\t// The idle timeout is set based on the max of the time we received the last packet...\n\tlastPacketReceivedTime time.Time\n\t// ... and the time we sent a new ack-eliciting packet after receiving a packet.\n\tfirstAckElicitingPacketAfterIdleSentTime time.Time\n\t// pacingDeadline is the time when the next packet should be sent\n\tpacingDeadline time.Time\n\n\tpeerParams *wire.TransportParameters\n\n\ttimer connectionTimer\n\t// keepAlivePingSent stores whether a keep alive PING is in flight.\n\t// It is reset as soon as we receive a packet from the peer.\n\tkeepAlivePingSent bool\n\tkeepAliveInterval time.Duration\n\n\tdatagramQueue *datagramQueue\n\n\tconnStateMutex sync.Mutex\n\tconnState      ConnectionState\n\n\tlogID  string\n\ttracer logging.ConnectionTracer\n\tlogger utils.Logger\n}\n\nvar (\n\t_ Connection      = &connection{}\n\t_ EarlyConnection = &connection{}\n\t_ streamSender    = &connection{}\n)\n\nvar newConnection = func(\n\tconn sendConn,\n\trunner connRunner,\n\torigDestConnID protocol.ConnectionID,\n\tretrySrcConnID *protocol.ConnectionID,\n\tclientDestConnID protocol.ConnectionID,\n\tdestConnID protocol.ConnectionID,\n\tsrcConnID protocol.ConnectionID,\n\tconnIDGenerator ConnectionIDGenerator,\n\tstatelessResetToken protocol.StatelessResetToken,\n\tconf *Config,\n\ttlsConf *tls.Config,\n\ttokenGenerator *handshake.TokenGenerator,\n\tclientAddressValidated bool,\n\ttracer logging.ConnectionTracer,\n\ttracingID uint64,\n\tlogger utils.Logger,\n\tv protocol.VersionNumber,\n) quicConn {\n\ts := &connection{\n\t\tconn:                conn,\n\t\tconfig:              conf,\n\t\thandshakeDestConnID: destConnID,\n\t\tsrcConnIDLen:        srcConnID.Len(),\n\t\ttokenGenerator:      tokenGenerator,\n\t\toneRTTStream:        newCryptoStream(),\n\t\tperspective:         protocol.PerspectiveServer,\n\t\ttracer:              tracer,\n\t\tlogger:              logger,\n\t\tversion:             v,\n\t}\n\tif origDestConnID.Len() > 0 {\n\t\ts.logID = origDestConnID.String()\n\t} else {\n\t\ts.logID = destConnID.String()\n\t}\n\ts.connIDManager = newConnIDManager(\n\t\tdestConnID,\n\t\tfunc(token protocol.StatelessResetToken) { runner.AddResetToken(token, s) },\n\t\trunner.RemoveResetToken,\n\t\ts.queueControlFrame,\n\t)\n\ts.connIDGenerator = newConnIDGenerator(\n\t\tsrcConnID,\n\t\t&clientDestConnID,\n\t\tfunc(connID protocol.ConnectionID) { runner.Add(connID, s) },\n\t\trunner.GetStatelessResetToken,\n\t\trunner.Remove,\n\t\trunner.Retire,\n\t\trunner.ReplaceWithClosed,\n\t\ts.queueControlFrame,\n\t\tconnIDGenerator,\n\t)\n\ts.preSetup()\n\ts.ctx, s.ctxCancel = context.WithCancelCause(context.WithValue(context.Background(), ConnectionTracingKey, tracingID))\n\ts.sentPacketHandler, s.receivedPacketHandler = ackhandler.NewAckHandler(\n\t\t0,\n\t\tgetMaxPacketSize(s.conn.RemoteAddr()),\n\t\ts.rttStats,\n\t\tclientAddressValidated,\n\t\ts.perspective,\n\t\ts.tracer,\n\t\ts.logger,\n\t)\n\ts.mtuDiscoverer = newMTUDiscoverer(s.rttStats, getMaxPacketSize(s.conn.RemoteAddr()), s.sentPacketHandler.SetMaxDatagramSize)\n\tparams := &wire.TransportParameters{\n\t\tInitialMaxStreamDataBidiLocal:   protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataBidiRemote:  protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataUni:         protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxData:                  protocol.ByteCount(s.config.InitialConnectionReceiveWindow),\n\t\tMaxIdleTimeout:                  s.config.MaxIdleTimeout,\n\t\tMaxBidiStreamNum:                protocol.StreamNum(s.config.MaxIncomingStreams),\n\t\tMaxUniStreamNum:                 protocol.StreamNum(s.config.MaxIncomingUniStreams),\n\t\tMaxAckDelay:                     protocol.MaxAckDelayInclGranularity,\n\t\tAckDelayExponent:                protocol.AckDelayExponent,\n\t\tDisableActiveMigration:          true,\n\t\tStatelessResetToken:             &statelessResetToken,\n\t\tOriginalDestinationConnectionID: origDestConnID,\n\t\t// For interoperability with quic-go versions before May 2023, this value must be set to a value\n\t\t// different from protocol.DefaultActiveConnectionIDLimit.\n\t\t// If set to the default value, it will be omitted from the transport parameters, which will make\n\t\t// old quic-go versions interpret it as 0, instead of the default value of 2.\n\t\t// See https://github.com/quic-go/quic-go/pull/3806.\n\t\tActiveConnectionIDLimit:   protocol.MaxActiveConnectionIDs,\n\t\tInitialSourceConnectionID: srcConnID,\n\t\tRetrySourceConnectionID:   retrySrcConnID,\n\t}\n\tif s.config.EnableDatagrams {\n\t\tparams.MaxDatagramFrameSize = protocol.MaxDatagramFrameSize\n\t} else {\n\t\tparams.MaxDatagramFrameSize = protocol.InvalidByteCount\n\t}\n\tif s.tracer != nil {\n\t\ts.tracer.SentTransportParameters(params)\n\t}\n\tcs := handshake.NewCryptoSetupServer(\n\t\tclientDestConnID,\n\t\tconn.LocalAddr(),\n\t\tconn.RemoteAddr(),\n\t\tparams,\n\t\ttlsConf,\n\t\tconf.Allow0RTT,\n\t\ts.rttStats,\n\t\ttracer,\n\t\tlogger,\n\t\ts.version,\n\t)\n\ts.cryptoStreamHandler = cs\n\ts.packer = newPacketPacker(srcConnID, s.connIDManager.Get, s.initialStream, s.handshakeStream, s.sentPacketHandler, s.retransmissionQueue, cs, s.framer, s.receivedPacketHandler, s.datagramQueue, s.perspective)\n\ts.unpacker = newPacketUnpacker(cs, s.srcConnIDLen)\n\ts.cryptoStreamManager = newCryptoStreamManager(cs, s.initialStream, s.handshakeStream, s.oneRTTStream)\n\treturn s\n}\n\n// declare this as a variable, such that we can it mock it in the tests\nvar newClientConnection = func(\n\tconn sendConn,\n\trunner connRunner,\n\tdestConnID protocol.ConnectionID,\n\tsrcConnID protocol.ConnectionID,\n\tconnIDGenerator ConnectionIDGenerator,\n\tconf *Config,\n\ttlsConf *tls.Config,\n\tinitialPacketNumber protocol.PacketNumber,\n\tenable0RTT bool,\n\thasNegotiatedVersion bool,\n\ttracer logging.ConnectionTracer,\n\ttracingID uint64,\n\tlogger utils.Logger,\n\tv protocol.VersionNumber,\n) quicConn {\n\ts := &connection{\n\t\tconn:                conn,\n\t\tconfig:              conf,\n\t\torigDestConnID:      destConnID,\n\t\thandshakeDestConnID: destConnID,\n\t\tsrcConnIDLen:        srcConnID.Len(),\n\t\tperspective:         protocol.PerspectiveClient,\n\t\tlogID:               destConnID.String(),\n\t\tlogger:              logger,\n\t\ttracer:              tracer,\n\t\tversionNegotiated:   hasNegotiatedVersion,\n\t\tversion:             v,\n\t}\n\ts.connIDManager = newConnIDManager(\n\t\tdestConnID,\n\t\tfunc(token protocol.StatelessResetToken) { runner.AddResetToken(token, s) },\n\t\trunner.RemoveResetToken,\n\t\ts.queueControlFrame,\n\t)\n\ts.connIDGenerator = newConnIDGenerator(\n\t\tsrcConnID,\n\t\tnil,\n\t\tfunc(connID protocol.ConnectionID) { runner.Add(connID, s) },\n\t\trunner.GetStatelessResetToken,\n\t\trunner.Remove,\n\t\trunner.Retire,\n\t\trunner.ReplaceWithClosed,\n\t\ts.queueControlFrame,\n\t\tconnIDGenerator,\n\t)\n\ts.preSetup()\n\ts.ctx, s.ctxCancel = context.WithCancelCause(context.WithValue(context.Background(), ConnectionTracingKey, tracingID))\n\ts.sentPacketHandler, s.receivedPacketHandler = ackhandler.NewAckHandler(\n\t\tinitialPacketNumber,\n\t\tgetMaxPacketSize(s.conn.RemoteAddr()),\n\t\ts.rttStats,\n\t\tfalse, /* has no effect */\n\t\ts.perspective,\n\t\ts.tracer,\n\t\ts.logger,\n\t)\n\ts.mtuDiscoverer = newMTUDiscoverer(s.rttStats, getMaxPacketSize(s.conn.RemoteAddr()), s.sentPacketHandler.SetMaxDatagramSize)\n\toneRTTStream := newCryptoStream()\n\tparams := &wire.TransportParameters{\n\t\tInitialMaxStreamDataBidiRemote: protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataBidiLocal:  protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataUni:        protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxData:                 protocol.ByteCount(s.config.InitialConnectionReceiveWindow),\n\t\tMaxIdleTimeout:                 s.config.MaxIdleTimeout,\n\t\tMaxBidiStreamNum:               protocol.StreamNum(s.config.MaxIncomingStreams),\n\t\tMaxUniStreamNum:                protocol.StreamNum(s.config.MaxIncomingUniStreams),\n\t\tMaxAckDelay:                    protocol.MaxAckDelayInclGranularity,\n\t\tAckDelayExponent:               protocol.AckDelayExponent,\n\t\tDisableActiveMigration:         true,\n\t\t// For interoperability with quic-go versions before May 2023, this value must be set to a value\n\t\t// different from protocol.DefaultActiveConnectionIDLimit.\n\t\t// If set to the default value, it will be omitted from the transport parameters, which will make\n\t\t// old quic-go versions interpret it as 0, instead of the default value of 2.\n\t\t// See https://github.com/quic-go/quic-go/pull/3806.\n\t\tActiveConnectionIDLimit:   protocol.MaxActiveConnectionIDs,\n\t\tInitialSourceConnectionID: srcConnID,\n\t}\n\tif s.config.EnableDatagrams {\n\t\tparams.MaxDatagramFrameSize = protocol.MaxDatagramFrameSize\n\t} else {\n\t\tparams.MaxDatagramFrameSize = protocol.InvalidByteCount\n\t}\n\tif s.tracer != nil {\n\t\ts.tracer.SentTransportParameters(params)\n\t}\n\tcs := handshake.NewCryptoSetupClient(\n\t\tdestConnID,\n\t\tparams,\n\t\ttlsConf,\n\t\tenable0RTT,\n\t\ts.rttStats,\n\t\ttracer,\n\t\tlogger,\n\t\ts.version,\n\t)\n\ts.cryptoStreamHandler = cs\n\ts.cryptoStreamManager = newCryptoStreamManager(cs, s.initialStream, s.handshakeStream, oneRTTStream)\n\ts.unpacker = newPacketUnpacker(cs, s.srcConnIDLen)\n\ts.packer = newPacketPacker(srcConnID, s.connIDManager.Get, s.initialStream, s.handshakeStream, s.sentPacketHandler, s.retransmissionQueue, cs, s.framer, s.receivedPacketHandler, s.datagramQueue, s.perspective)\n\tif len(tlsConf.ServerName) > 0 {\n\t\ts.tokenStoreKey = tlsConf.ServerName\n\t} else {\n\t\ts.tokenStoreKey = conn.RemoteAddr().String()\n\t}\n\tif s.config.TokenStore != nil {\n\t\tif token := s.config.TokenStore.Pop(s.tokenStoreKey); token != nil {\n\t\t\ts.packer.SetToken(token.data)\n\t\t}\n\t}\n\treturn s\n}\n\nfunc (s *connection) preSetup() {\n\ts.initialStream = newCryptoStream()\n\ts.handshakeStream = newCryptoStream()\n\ts.sendQueue = newSendQueue(s.conn)\n\ts.retransmissionQueue = newRetransmissionQueue()\n\ts.frameParser = wire.NewFrameParser(s.config.EnableDatagrams)\n\ts.rttStats = &utils.RTTStats{}\n\ts.connFlowController = flowcontrol.NewConnectionFlowController(\n\t\tprotocol.ByteCount(s.config.InitialConnectionReceiveWindow),\n\t\tprotocol.ByteCount(s.config.MaxConnectionReceiveWindow),\n\t\ts.onHasConnectionWindowUpdate,\n\t\tfunc(size protocol.ByteCount) bool {\n\t\t\tif s.config.AllowConnectionWindowIncrease == nil {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn s.config.AllowConnectionWindowIncrease(s, uint64(size))\n\t\t},\n\t\ts.rttStats,\n\t\ts.logger,\n\t)\n\ts.earlyConnReadyChan = make(chan struct{})\n\ts.streamsMap = newStreamsMap(\n\t\ts,\n\t\ts.newFlowController,\n\t\tuint64(s.config.MaxIncomingStreams),\n\t\tuint64(s.config.MaxIncomingUniStreams),\n\t\ts.perspective,\n\t)\n\ts.framer = newFramer(s.streamsMap)\n\ts.receivedPackets = make(chan receivedPacket, protocol.MaxConnUnprocessedPackets)\n\ts.closeChan = make(chan closeError, 1)\n\ts.sendingScheduled = make(chan struct{}, 1)\n\ts.handshakeCtx, s.handshakeCtxCancel = context.WithCancel(context.Background())\n\n\tnow := time.Now()\n\ts.lastPacketReceivedTime = now\n\ts.creationTime = now\n\n\ts.windowUpdateQueue = newWindowUpdateQueue(s.streamsMap, s.connFlowController, s.framer.QueueControlFrame)\n\ts.datagramQueue = newDatagramQueue(s.scheduleSending, s.logger)\n\ts.connState.Version = s.version\n}\n\n// run the connection main loop\nfunc (s *connection) run() error {\n\tvar closeErr closeError\n\tdefer func() {\n\t\ts.ctxCancel(closeErr.err)\n\t}()\n\n\ts.timer = *newTimer()\n\n\tif err := s.cryptoStreamHandler.StartHandshake(); err != nil {\n\t\treturn err\n\t}\n\tif err := s.handleHandshakeEvents(); err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\tif err := s.sendQueue.Run(); err != nil {\n\t\t\ts.destroyImpl(err)\n\t\t}\n\t}()\n\n\tif s.perspective == protocol.PerspectiveClient {\n\t\ts.scheduleSending() // so the ClientHello actually gets sent\n\t}\n\n\tvar sendQueueAvailable <-chan struct{}\n\nrunLoop:\n\tfor {\n\t\t// Close immediately if requested\n\t\tselect {\n\t\tcase closeErr = <-s.closeChan:\n\t\t\tbreak runLoop\n\t\tdefault:\n\t\t}\n\n\t\ts.maybeResetTimer()\n\n\t\tvar processedUndecryptablePacket bool\n\t\tif len(s.undecryptablePacketsToProcess) > 0 {\n\t\t\tqueue := s.undecryptablePacketsToProcess\n\t\t\ts.undecryptablePacketsToProcess = nil\n\t\t\tfor _, p := range queue {\n\t\t\t\tif processed := s.handlePacketImpl(p); processed {\n\t\t\t\t\tprocessedUndecryptablePacket = true\n\t\t\t\t}\n\t\t\t\t// Don't set timers and send packets if the packet made us close the connection.\n\t\t\t\tselect {\n\t\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\t\tbreak runLoop\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If we processed any undecryptable packets, jump to the resetting of the timers directly.\n\t\tif !processedUndecryptablePacket {\n\t\t\tselect {\n\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\tbreak runLoop\n\t\t\tcase <-s.timer.Chan():\n\t\t\t\ts.timer.SetRead()\n\t\t\t\t// We do all the interesting stuff after the switch statement, so\n\t\t\t\t// nothing to see here.\n\t\t\tcase <-s.sendingScheduled:\n\t\t\t\t// We do all the interesting stuff after the switch statement, so\n\t\t\t\t// nothing to see here.\n\t\t\tcase <-sendQueueAvailable:\n\t\t\tcase firstPacket := <-s.receivedPackets:\n\t\t\t\twasProcessed := s.handlePacketImpl(firstPacket)\n\t\t\t\t// Don't set timers and send packets if the packet made us close the connection.\n\t\t\t\tselect {\n\t\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\t\tbreak runLoop\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t\tif s.handshakeComplete {\n\t\t\t\t\t// Now process all packets in the receivedPackets channel.\n\t\t\t\t\t// Limit the number of packets to the length of the receivedPackets channel,\n\t\t\t\t\t// so we eventually get a chance to send out an ACK when receiving a lot of packets.\n\t\t\t\t\tnumPackets := len(s.receivedPackets)\n\t\t\t\treceiveLoop:\n\t\t\t\t\tfor i := 0; i < numPackets; i++ {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase p := <-s.receivedPackets:\n\t\t\t\t\t\t\tif processed := s.handlePacketImpl(p); processed {\n\t\t\t\t\t\t\t\twasProcessed = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tselect {\n\t\t\t\t\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\t\t\t\t\tbreak runLoop\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak receiveLoop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Only reset the timers if this packet was actually processed.\n\t\t\t\t// This avoids modifying any state when handling undecryptable packets,\n\t\t\t\t// which could be injected by an attacker.\n\t\t\t\tif !wasProcessed {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnow := time.Now()\n\t\tif timeout := s.sentPacketHandler.GetLossDetectionTimeout(); !timeout.IsZero() && timeout.Before(now) {\n\t\t\t// This could cause packets to be retransmitted.\n\t\t\t// Check it before trying to send packets.\n\t\t\tif err := s.sentPacketHandler.OnLossDetectionTimeout(); err != nil {\n\t\t\t\ts.closeLocal(err)\n\t\t\t}\n\t\t}\n\n\t\tif keepAliveTime := s.nextKeepAliveTime(); !keepAliveTime.IsZero() && !now.Before(keepAliveTime) {\n\t\t\t// send a PING frame since there is no activity in the connection\n\t\t\ts.logger.Debugf(\"Sending a keep-alive PING to keep the connection alive.\")\n\t\t\ts.framer.QueueControlFrame(&wire.PingFrame{})\n\t\t\ts.keepAlivePingSent = true\n\t\t} else if !s.handshakeComplete && now.Sub(s.creationTime) >= s.config.handshakeTimeout() {\n\t\t\ts.destroyImpl(qerr.ErrHandshakeTimeout)\n\t\t\tcontinue\n\t\t} else {\n\t\t\tidleTimeoutStartTime := s.idleTimeoutStartTime()\n\t\t\tif (!s.handshakeComplete && now.Sub(idleTimeoutStartTime) >= s.config.HandshakeIdleTimeout) ||\n\t\t\t\t(s.handshakeComplete && now.After(s.nextIdleTimeoutTime())) {\n\t\t\t\ts.destroyImpl(qerr.ErrIdleTimeout)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\t// The send queue is still busy sending out packets.\n\t\t\t// Wait until there's space to enqueue new packets.\n\t\t\tsendQueueAvailable = s.sendQueue.Available()\n\t\t\tcontinue\n\t\t}\n\t\tif err := s.triggerSending(); err != nil {\n\t\t\ts.closeLocal(err)\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\tsendQueueAvailable = s.sendQueue.Available()\n\t\t} else {\n\t\t\tsendQueueAvailable = nil\n\t\t}\n\t}\n\n\ts.cryptoStreamHandler.Close()\n\ts.sendQueue.Close() // close the send queue before sending the CONNECTION_CLOSE\n\ts.handleCloseError(&closeErr)\n\tif e := (&errCloseForRecreating{}); !errors.As(closeErr.err, &e) && s.tracer != nil {\n\t\ts.tracer.Close()\n\t}\n\ts.logger.Infof(\"Connection %s closed.\", s.logID)\n\ts.timer.Stop()\n\treturn closeErr.err\n}\n\n// blocks until the early connection can be used\nfunc (s *connection) earlyConnReady() <-chan struct{} {\n\treturn s.earlyConnReadyChan\n}\n\nfunc (s *connection) HandshakeComplete() <-chan struct{} {\n\treturn s.handshakeCtx.Done()\n}\n\nfunc (s *connection) Context() context.Context {\n\treturn s.ctx\n}\n\nfunc (s *connection) supportsDatagrams() bool {\n\treturn s.peerParams.MaxDatagramFrameSize > 0\n}\n\nfunc (s *connection) ConnectionState() ConnectionState {\n\ts.connStateMutex.Lock()\n\tdefer s.connStateMutex.Unlock()\n\tcs := s.cryptoStreamHandler.ConnectionState()\n\ts.connState.TLS = cs.ConnectionState\n\ts.connState.Used0RTT = cs.Used0RTT\n\treturn s.connState\n}\n\n// Time when the connection should time out\nfunc (s *connection) nextIdleTimeoutTime() time.Time {\n\tidleTimeout := utils.Max(s.idleTimeout, s.rttStats.PTO(true)*3)\n\treturn s.idleTimeoutStartTime().Add(idleTimeout)\n}\n\n// Time when the next keep-alive packet should be sent.\n// It returns a zero time if no keep-alive should be sent.\nfunc (s *connection) nextKeepAliveTime() time.Time {\n\tif s.config.KeepAlivePeriod == 0 || s.keepAlivePingSent || !s.firstAckElicitingPacketAfterIdleSentTime.IsZero() {\n\t\treturn time.Time{}\n\t}\n\tkeepAliveInterval := utils.Max(s.keepAliveInterval, s.rttStats.PTO(true)*3/2)\n\treturn s.lastPacketReceivedTime.Add(keepAliveInterval)\n}\n\nfunc (s *connection) maybeResetTimer() {\n\tvar deadline time.Time\n\tif !s.handshakeComplete {\n\t\tdeadline = utils.MinTime(\n\t\t\ts.creationTime.Add(s.config.handshakeTimeout()),\n\t\t\ts.idleTimeoutStartTime().Add(s.config.HandshakeIdleTimeout),\n\t\t)\n\t} else {\n\t\tif keepAliveTime := s.nextKeepAliveTime(); !keepAliveTime.IsZero() {\n\t\t\tdeadline = keepAliveTime\n\t\t} else {\n\t\t\tdeadline = s.nextIdleTimeoutTime()\n\t\t}\n\t}\n\n\ts.timer.SetTimer(\n\t\tdeadline,\n\t\ts.receivedPacketHandler.GetAlarmTimeout(),\n\t\ts.sentPacketHandler.GetLossDetectionTimeout(),\n\t\ts.pacingDeadline,\n\t)\n}\n\nfunc (s *connection) idleTimeoutStartTime() time.Time {\n\treturn utils.MaxTime(s.lastPacketReceivedTime, s.firstAckElicitingPacketAfterIdleSentTime)\n}\n\nfunc (s *connection) handleHandshakeComplete() error {\n\ts.handshakeComplete = true\n\tdefer s.handshakeCtxCancel()\n\t// Once the handshake completes, we have derived 1-RTT keys.\n\t// There's no point in queueing undecryptable packets for later decryption any more.\n\ts.undecryptablePackets = nil\n\n\ts.connIDManager.SetHandshakeComplete()\n\ts.connIDGenerator.SetHandshakeComplete()\n\n\tif s.perspective == protocol.PerspectiveClient {\n\t\ts.applyTransportParameters()\n\t\treturn nil\n\t}\n\n\tif err := s.handleHandshakeConfirmed(); err != nil {\n\t\treturn err\n\t}\n\n\tticket, err := s.cryptoStreamHandler.GetSessionTicket()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ticket != nil { // may be nil if session tickets are disabled via tls.Config.SessionTicketsDisabled\n\t\ts.oneRTTStream.Write(ticket)\n\t\tfor s.oneRTTStream.HasData() {\n\t\t\ts.queueControlFrame(s.oneRTTStream.PopCryptoFrame(protocol.MaxPostHandshakeCryptoFrameSize))\n\t\t}\n\t}\n\ttoken, err := s.tokenGenerator.NewToken(s.conn.RemoteAddr())\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.queueControlFrame(&wire.NewTokenFrame{Token: token})\n\ts.queueControlFrame(&wire.HandshakeDoneFrame{})\n\treturn nil\n}\n\nfunc (s *connection) handleHandshakeConfirmed() error {\n\tif err := s.dropEncryptionLevel(protocol.EncryptionHandshake); err != nil {\n\t\treturn err\n\t}\n\n\ts.handshakeConfirmed = true\n\ts.sentPacketHandler.SetHandshakeConfirmed()\n\ts.cryptoStreamHandler.SetHandshakeConfirmed()\n\n\tif !s.config.DisablePathMTUDiscovery && s.conn.capabilities().DF {\n\t\tmaxPacketSize := s.peerParams.MaxUDPPayloadSize\n\t\tif maxPacketSize == 0 {\n\t\t\tmaxPacketSize = protocol.MaxByteCount\n\t\t}\n\t\ts.mtuDiscoverer.Start(utils.Min(maxPacketSize, protocol.MaxPacketBufferSize))\n\t}\n\treturn nil\n}\n\nfunc (s *connection) handlePacketImpl(rp receivedPacket) bool {\n\ts.sentPacketHandler.ReceivedBytes(rp.Size())\n\n\tif wire.IsVersionNegotiationPacket(rp.data) {\n\t\ts.handleVersionNegotiationPacket(rp)\n\t\treturn false\n\t}\n\n\tvar counter uint8\n\tvar lastConnID protocol.ConnectionID\n\tvar processed bool\n\tdata := rp.data\n\tp := rp\n\tfor len(data) > 0 {\n\t\tvar destConnID protocol.ConnectionID\n\t\tif counter > 0 {\n\t\t\tp = *(p.Clone())\n\t\t\tp.data = data\n\n\t\t\tvar err error\n\t\t\tdestConnID, err = wire.ParseConnectionID(p.data, s.srcConnIDLen)\n\t\t\tif err != nil {\n\t\t\t\tif s.tracer != nil {\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.ByteCount(len(data)), logging.PacketDropHeaderParseError)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"error parsing packet, couldn't parse connection ID: %s\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif destConnID != lastConnID {\n\t\t\t\tif s.tracer != nil {\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.ByteCount(len(data)), logging.PacketDropUnknownConnectionID)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"coalesced packet has different destination connection ID: %s, expected %s\", destConnID, lastConnID)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif wire.IsLongHeaderPacket(p.data[0]) {\n\t\t\thdr, packetData, rest, err := wire.ParsePacket(p.data)\n\t\t\tif err != nil {\n\t\t\t\tif s.tracer != nil {\n\t\t\t\t\tdropReason := logging.PacketDropHeaderParseError\n\t\t\t\t\tif err == wire.ErrUnsupportedVersion {\n\t\t\t\t\t\tdropReason = logging.PacketDropUnsupportedVersion\n\t\t\t\t\t}\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.ByteCount(len(data)), dropReason)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"error parsing packet: %s\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlastConnID = hdr.DestConnectionID\n\n\t\t\tif hdr.Version != s.version {\n\t\t\t\tif s.tracer != nil {\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeFromHeader(hdr), protocol.ByteCount(len(data)), logging.PacketDropUnexpectedVersion)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"Dropping packet with version %x. Expected %x.\", hdr.Version, s.version)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif counter > 0 {\n\t\t\t\tp.buffer.Split()\n\t\t\t}\n\t\t\tcounter++\n\n\t\t\t// only log if this actually a coalesced packet\n\t\t\tif s.logger.Debug() && (counter > 1 || len(rest) > 0) {\n\t\t\t\ts.logger.Debugf(\"Parsed a coalesced packet. Part %d: %d bytes. Remaining: %d bytes.\", counter, len(packetData), len(rest))\n\t\t\t}\n\n\t\t\tp.data = packetData\n\n\t\t\tif wasProcessed := s.handleLongHeaderPacket(p, hdr); wasProcessed {\n\t\t\t\tprocessed = true\n\t\t\t}\n\t\t\tdata = rest\n\t\t} else {\n\t\t\tif counter > 0 {\n\t\t\t\tp.buffer.Split()\n\t\t\t}\n\t\t\tprocessed = s.handleShortHeaderPacket(p, destConnID)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tp.buffer.MaybeRelease()\n\treturn processed\n}\n\nfunc (s *connection) handleShortHeaderPacket(p receivedPacket, destConnID protocol.ConnectionID) bool {\n\tvar wasQueued bool\n\n\tdefer func() {\n\t\t// Put back the packet buffer if the packet wasn't queued for later decryption.\n\t\tif !wasQueued {\n\t\t\tp.buffer.Decrement()\n\t\t}\n\t}()\n\n\tpn, pnLen, keyPhase, data, err := s.unpacker.UnpackShortHeader(p.rcvTime, p.data)\n\tif err != nil {\n\t\twasQueued = s.handleUnpackError(err, p, logging.PacketType1RTT)\n\t\treturn false\n\t}\n\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"<- Reading packet %d (%d bytes) for connection %s, 1-RTT\", pn, p.Size(), destConnID)\n\t\twire.LogShortHeader(s.logger, destConnID, pn, pnLen, keyPhase)\n\t}\n\n\tif s.receivedPacketHandler.IsPotentiallyDuplicate(pn, protocol.Encryption1RTT) {\n\t\ts.logger.Debugf(\"Dropping (potentially) duplicate packet.\")\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketType1RTT, p.Size(), logging.PacketDropDuplicate)\n\t\t}\n\t\treturn false\n\t}\n\n\tvar log func([]logging.Frame)\n\tif s.tracer != nil {\n\t\tlog = func(frames []logging.Frame) {\n\t\t\ts.tracer.ReceivedShortHeaderPacket(\n\t\t\t\t&logging.ShortHeader{\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tPacketNumber:     pn,\n\t\t\t\t\tPacketNumberLen:  pnLen,\n\t\t\t\t\tKeyPhase:         keyPhase,\n\t\t\t\t},\n\t\t\t\tp.Size(),\n\t\t\t\tframes,\n\t\t\t)\n\t\t}\n\t}\n\tif err := s.handleUnpackedShortHeaderPacket(destConnID, pn, data, p.ecn, p.rcvTime, log); err != nil {\n\t\ts.closeLocal(err)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (s *connection) handleLongHeaderPacket(p receivedPacket, hdr *wire.Header) bool /* was the packet successfully processed */ {\n\tvar wasQueued bool\n\n\tdefer func() {\n\t\t// Put back the packet buffer if the packet wasn't queued for later decryption.\n\t\tif !wasQueued {\n\t\t\tp.buffer.Decrement()\n\t\t}\n\t}()\n\n\tif hdr.Type == protocol.PacketTypeRetry {\n\t\treturn s.handleRetryPacket(hdr, p.data)\n\t}\n\n\t// The server can change the source connection ID with the first Handshake packet.\n\t// After this, all packets with a different source connection have to be ignored.\n\tif s.receivedFirstPacket && hdr.Type == protocol.PacketTypeInitial && hdr.SrcConnectionID != s.handshakeDestConnID {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeInitial, p.Size(), logging.PacketDropUnknownConnectionID)\n\t\t}\n\t\ts.logger.Debugf(\"Dropping Initial packet (%d bytes) with unexpected source connection ID: %s (expected %s)\", p.Size(), hdr.SrcConnectionID, s.handshakeDestConnID)\n\t\treturn false\n\t}\n\t// drop 0-RTT packets, if we are a client\n\tif s.perspective == protocol.PerspectiveClient && hdr.Type == protocol.PacketType0RTT {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketType0RTT, p.Size(), logging.PacketDropKeyUnavailable)\n\t\t}\n\t\treturn false\n\t}\n\n\tpacket, err := s.unpacker.UnpackLongHeader(hdr, p.rcvTime, p.data, s.version)\n\tif err != nil {\n\t\twasQueued = s.handleUnpackError(err, p, logging.PacketTypeFromHeader(hdr))\n\t\treturn false\n\t}\n\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"<- Reading packet %d (%d bytes) for connection %s, %s\", packet.hdr.PacketNumber, p.Size(), hdr.DestConnectionID, packet.encryptionLevel)\n\t\tpacket.hdr.Log(s.logger)\n\t}\n\n\tif s.receivedPacketHandler.IsPotentiallyDuplicate(packet.hdr.PacketNumber, packet.encryptionLevel) {\n\t\ts.logger.Debugf(\"Dropping (potentially) duplicate packet.\")\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeFromHeader(hdr), p.Size(), logging.PacketDropDuplicate)\n\t\t}\n\t\treturn false\n\t}\n\n\tif err := s.handleUnpackedLongHeaderPacket(packet, p.ecn, p.rcvTime, p.Size()); err != nil {\n\t\ts.closeLocal(err)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (s *connection) handleUnpackError(err error, p receivedPacket, pt logging.PacketType) (wasQueued bool) {\n\tswitch err {\n\tcase handshake.ErrKeysDropped:\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(pt, p.Size(), logging.PacketDropKeyUnavailable)\n\t\t}\n\t\ts.logger.Debugf(\"Dropping %s packet (%d bytes) because we already dropped the keys.\", pt, p.Size())\n\tcase handshake.ErrKeysNotYetAvailable:\n\t\t// Sealer for this encryption level not yet available.\n\t\t// Try again later.\n\t\ts.tryQueueingUndecryptablePacket(p, pt)\n\t\treturn true\n\tcase wire.ErrInvalidReservedBits:\n\t\ts.closeLocal(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: err.Error(),\n\t\t})\n\tcase handshake.ErrDecryptionFailed:\n\t\t// This might be a packet injected by an attacker. Drop it.\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(pt, p.Size(), logging.PacketDropPayloadDecryptError)\n\t\t}\n\t\ts.logger.Debugf(\"Dropping %s packet (%d bytes) that could not be unpacked. Error: %s\", pt, p.Size(), err)\n\tdefault:\n\t\tvar headerErr *headerParseError\n\t\tif errors.As(err, &headerErr) {\n\t\t\t// This might be a packet injected by an attacker. Drop it.\n\t\t\tif s.tracer != nil {\n\t\t\t\ts.tracer.DroppedPacket(pt, p.Size(), logging.PacketDropHeaderParseError)\n\t\t\t}\n\t\t\ts.logger.Debugf(\"Dropping %s packet (%d bytes) for which we couldn't unpack the header. Error: %s\", pt, p.Size(), err)\n\t\t} else {\n\t\t\t// This is an error returned by the AEAD (other than ErrDecryptionFailed).\n\t\t\t// For example, a PROTOCOL_VIOLATION due to key updates.\n\t\t\ts.closeLocal(err)\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *connection) handleRetryPacket(hdr *wire.Header, data []byte) bool /* was this a valid Retry */ {\n\tif s.perspective == protocol.PerspectiveServer {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring Retry.\")\n\t\treturn false\n\t}\n\tif s.receivedFirstPacket {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring Retry, since we already received a packet.\")\n\t\treturn false\n\t}\n\tdestConnID := s.connIDManager.Get()\n\tif hdr.SrcConnectionID == destConnID {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring Retry, since the server didn't change the Source Connection ID.\")\n\t\treturn false\n\t}\n\t// If a token is already set, this means that we already received a Retry from the server.\n\t// Ignore this Retry packet.\n\tif s.receivedRetry {\n\t\ts.logger.Debugf(\"Ignoring Retry, since a Retry was already received.\")\n\t\treturn false\n\t}\n\n\ttag := handshake.GetRetryIntegrityTag(data[:len(data)-16], destConnID, hdr.Version)\n\tif !bytes.Equal(data[len(data)-16:], tag[:]) {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.ByteCount(len(data)), logging.PacketDropPayloadDecryptError)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring spoofed Retry. Integrity Tag doesn't match.\")\n\t\treturn false\n\t}\n\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"<- Received Retry:\")\n\t\t(&wire.ExtendedHeader{Header: *hdr}).Log(s.logger)\n\t\ts.logger.Debugf(\"Switching destination connection ID to: %s\", hdr.SrcConnectionID)\n\t}\n\tif s.tracer != nil {\n\t\ts.tracer.ReceivedRetry(hdr)\n\t}\n\tnewDestConnID := hdr.SrcConnectionID\n\ts.receivedRetry = true\n\tif err := s.sentPacketHandler.ResetForRetry(); err != nil {\n\t\ts.closeLocal(err)\n\t\treturn false\n\t}\n\ts.handshakeDestConnID = newDestConnID\n\ts.retrySrcConnID = &newDestConnID\n\ts.cryptoStreamHandler.ChangeConnectionID(newDestConnID)\n\ts.packer.SetToken(hdr.Token)\n\ts.connIDManager.ChangeInitialConnID(newDestConnID)\n\ts.scheduleSending()\n\treturn true\n}\n\nfunc (s *connection) handleVersionNegotiationPacket(p receivedPacket) {\n\tif s.perspective == protocol.PerspectiveServer || // servers never receive version negotiation packets\n\t\ts.receivedFirstPacket || s.versionNegotiated { // ignore delayed / duplicated version negotiation packets\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\treturn\n\t}\n\n\tsrc, dest, supportedVersions, err := wire.ParseVersionNegotiationPacket(p.data)\n\tif err != nil {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropHeaderParseError)\n\t\t}\n\t\ts.logger.Debugf(\"Error parsing Version Negotiation packet: %s\", err)\n\t\treturn\n\t}\n\n\tfor _, v := range supportedVersions {\n\t\tif v == s.version {\n\t\t\tif s.tracer != nil {\n\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropUnexpectedVersion)\n\t\t\t}\n\t\t\t// The Version Negotiation packet contains the version that we offered.\n\t\t\t// This might be a packet sent by an attacker, or it was corrupted.\n\t\t\treturn\n\t\t}\n\t}\n\n\ts.logger.Infof(\"Received a Version Negotiation packet. Supported Versions: %s\", supportedVersions)\n\tif s.tracer != nil {\n\t\ts.tracer.ReceivedVersionNegotiationPacket(dest, src, supportedVersions)\n\t}\n\tnewVersion, ok := protocol.ChooseSupportedVersion(s.config.Versions, supportedVersions)\n\tif !ok {\n\t\ts.destroyImpl(&VersionNegotiationError{\n\t\t\tOurs:   s.config.Versions,\n\t\t\tTheirs: supportedVersions,\n\t\t})\n\t\ts.logger.Infof(\"No compatible QUIC version found.\")\n\t\treturn\n\t}\n\tif s.tracer != nil {\n\t\ts.tracer.NegotiatedVersion(newVersion, s.config.Versions, supportedVersions)\n\t}\n\n\ts.logger.Infof(\"Switching to QUIC version %s.\", newVersion)\n\tnextPN, _ := s.sentPacketHandler.PeekPacketNumber(protocol.EncryptionInitial)\n\ts.destroyImpl(&errCloseForRecreating{\n\t\tnextPacketNumber: nextPN,\n\t\tnextVersion:      newVersion,\n\t})\n}\n\nfunc (s *connection) handleUnpackedLongHeaderPacket(\n\tpacket *unpackedPacket,\n\tecn protocol.ECN,\n\trcvTime time.Time,\n\tpacketSize protocol.ByteCount, // only for logging\n) error {\n\tif !s.receivedFirstPacket {\n\t\ts.receivedFirstPacket = true\n\t\tif !s.versionNegotiated && s.tracer != nil {\n\t\t\tvar clientVersions, serverVersions []protocol.VersionNumber\n\t\t\tswitch s.perspective {\n\t\t\tcase protocol.PerspectiveClient:\n\t\t\t\tclientVersions = s.config.Versions\n\t\t\tcase protocol.PerspectiveServer:\n\t\t\t\tserverVersions = s.config.Versions\n\t\t\t}\n\t\t\ts.tracer.NegotiatedVersion(s.version, clientVersions, serverVersions)\n\t\t}\n\t\t// The server can change the source connection ID with the first Handshake packet.\n\t\tif s.perspective == protocol.PerspectiveClient && packet.hdr.SrcConnectionID != s.handshakeDestConnID {\n\t\t\tcid := packet.hdr.SrcConnectionID\n\t\t\ts.logger.Debugf(\"Received first packet. Switching destination connection ID to: %s\", cid)\n\t\t\ts.handshakeDestConnID = cid\n\t\t\ts.connIDManager.ChangeInitialConnID(cid)\n\t\t}\n\t\t// We create the connection as soon as we receive the first packet from the client.\n\t\t// We do that before authenticating the packet.\n\t\t// That means that if the source connection ID was corrupted,\n\t\t// we might have created a connection with an incorrect source connection ID.\n\t\t// Once we authenticate the first packet, we need to update it.\n\t\tif s.perspective == protocol.PerspectiveServer {\n\t\t\tif packet.hdr.SrcConnectionID != s.handshakeDestConnID {\n\t\t\t\ts.handshakeDestConnID = packet.hdr.SrcConnectionID\n\t\t\t\ts.connIDManager.ChangeInitialConnID(packet.hdr.SrcConnectionID)\n\t\t\t}\n\t\t\tif s.tracer != nil {\n\t\t\t\ts.tracer.StartedConnection(\n\t\t\t\t\ts.conn.LocalAddr(),\n\t\t\t\t\ts.conn.RemoteAddr(),\n\t\t\t\t\tpacket.hdr.SrcConnectionID,\n\t\t\t\t\tpacket.hdr.DestConnectionID,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tif s.perspective == protocol.PerspectiveServer && packet.encryptionLevel == protocol.EncryptionHandshake {\n\t\t// On the server side, Initial keys are dropped as soon as the first Handshake packet is received.\n\t\t// See Section 4.9.1 of RFC 9001.\n\t\tif err := s.dropEncryptionLevel(protocol.EncryptionInitial); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ts.lastPacketReceivedTime = rcvTime\n\ts.firstAckElicitingPacketAfterIdleSentTime = time.Time{}\n\ts.keepAlivePingSent = false\n\n\tvar log func([]logging.Frame)\n\tif s.tracer != nil {\n\t\tlog = func(frames []logging.Frame) {\n\t\t\ts.tracer.ReceivedLongHeaderPacket(packet.hdr, packetSize, frames)\n\t\t}\n\t}\n\tisAckEliciting, err := s.handleFrames(packet.data, packet.hdr.DestConnectionID, packet.encryptionLevel, log)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.receivedPacketHandler.ReceivedPacket(packet.hdr.PacketNumber, ecn, packet.encryptionLevel, rcvTime, isAckEliciting)\n}\n\nfunc (s *connection) handleUnpackedShortHeaderPacket(\n\tdestConnID protocol.ConnectionID,\n\tpn protocol.PacketNumber,\n\tdata []byte,\n\tecn protocol.ECN,\n\trcvTime time.Time,\n\tlog func([]logging.Frame),\n) error {\n\ts.lastPacketReceivedTime = rcvTime\n\ts.firstAckElicitingPacketAfterIdleSentTime = time.Time{}\n\ts.keepAlivePingSent = false\n\n\tisAckEliciting, err := s.handleFrames(data, destConnID, protocol.Encryption1RTT, log)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.receivedPacketHandler.ReceivedPacket(pn, ecn, protocol.Encryption1RTT, rcvTime, isAckEliciting)\n}\n\nfunc (s *connection) handleFrames(\n\tdata []byte,\n\tdestConnID protocol.ConnectionID,\n\tencLevel protocol.EncryptionLevel,\n\tlog func([]logging.Frame),\n) (isAckEliciting bool, _ error) {\n\t// Only used for tracing.\n\t// If we're not tracing, this slice will always remain empty.\n\tvar frames []logging.Frame\n\tif log != nil {\n\t\tframes = make([]logging.Frame, 0, 4)\n\t}\n\tvar handleErr error\n\tfor len(data) > 0 {\n\t\tl, frame, err := s.frameParser.ParseNext(data, encLevel, s.version)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tdata = data[l:]\n\t\tif frame == nil {\n\t\t\tbreak\n\t\t}\n\t\tif ackhandler.IsFrameAckEliciting(frame) {\n\t\t\tisAckEliciting = true\n\t\t}\n\t\tif log != nil {\n\t\t\tframes = append(frames, logutils.ConvertFrame(frame))\n\t\t}\n\t\t// An error occurred handling a previous frame.\n\t\t// Don't handle the current frame.\n\t\tif handleErr != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := s.handleFrame(frame, encLevel, destConnID); err != nil {\n\t\t\tif log == nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t\t// If we're logging, we need to keep parsing (but not handling) all frames.\n\t\t\thandleErr = err\n\t\t}\n\t}\n\n\tif log != nil {\n\t\tlog(frames)\n\t\tif handleErr != nil {\n\t\t\treturn false, handleErr\n\t\t}\n\t}\n\treturn\n}\n\nfunc (s *connection) handleFrame(f wire.Frame, encLevel protocol.EncryptionLevel, destConnID protocol.ConnectionID) error {\n\tvar err error\n\twire.LogFrame(s.logger, f, false)\n\tswitch frame := f.(type) {\n\tcase *wire.CryptoFrame:\n\t\terr = s.handleCryptoFrame(frame, encLevel)\n\tcase *wire.StreamFrame:\n\t\terr = s.handleStreamFrame(frame)\n\tcase *wire.AckFrame:\n\t\terr = s.handleAckFrame(frame, encLevel)\n\tcase *wire.ConnectionCloseFrame:\n\t\ts.handleConnectionCloseFrame(frame)\n\tcase *wire.ResetStreamFrame:\n\t\terr = s.handleResetStreamFrame(frame)\n\tcase *wire.MaxDataFrame:\n\t\ts.handleMaxDataFrame(frame)\n\tcase *wire.MaxStreamDataFrame:\n\t\terr = s.handleMaxStreamDataFrame(frame)\n\tcase *wire.MaxStreamsFrame:\n\t\ts.handleMaxStreamsFrame(frame)\n\tcase *wire.DataBlockedFrame:\n\tcase *wire.StreamDataBlockedFrame:\n\tcase *wire.StreamsBlockedFrame:\n\tcase *wire.StopSendingFrame:\n\t\terr = s.handleStopSendingFrame(frame)\n\tcase *wire.PingFrame:\n\tcase *wire.PathChallengeFrame:\n\t\ts.handlePathChallengeFrame(frame)\n\tcase *wire.PathResponseFrame:\n\t\t// since we don't send PATH_CHALLENGEs, we don't expect PATH_RESPONSEs\n\t\terr = errors.New(\"unexpected PATH_RESPONSE frame\")\n\tcase *wire.NewTokenFrame:\n\t\terr = s.handleNewTokenFrame(frame)\n\tcase *wire.NewConnectionIDFrame:\n\t\terr = s.handleNewConnectionIDFrame(frame)\n\tcase *wire.RetireConnectionIDFrame:\n\t\terr = s.handleRetireConnectionIDFrame(frame, destConnID)\n\tcase *wire.HandshakeDoneFrame:\n\t\terr = s.handleHandshakeDoneFrame()\n\tcase *wire.DatagramFrame:\n\t\terr = s.handleDatagramFrame(frame)\n\tdefault:\n\t\terr = fmt.Errorf(\"unexpected frame type: %s\", reflect.ValueOf(&frame).Elem().Type().Name())\n\t}\n\treturn err\n}\n\n// handlePacket is called by the server with a new packet\nfunc (s *connection) handlePacket(p receivedPacket) {\n\t// Discard packets once the amount of queued packets is larger than\n\t// the channel size, protocol.MaxConnUnprocessedPackets\n\tselect {\n\tcase s.receivedPackets <- p:\n\tdefault:\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropDOSPrevention)\n\t\t}\n\t}\n}\n\nfunc (s *connection) handleConnectionCloseFrame(frame *wire.ConnectionCloseFrame) {\n\tif frame.IsApplicationError {\n\t\ts.closeRemote(&qerr.ApplicationError{\n\t\t\tRemote:       true,\n\t\t\tErrorCode:    qerr.ApplicationErrorCode(frame.ErrorCode),\n\t\t\tErrorMessage: frame.ReasonPhrase,\n\t\t})\n\t\treturn\n\t}\n\ts.closeRemote(&qerr.TransportError{\n\t\tRemote:       true,\n\t\tErrorCode:    qerr.TransportErrorCode(frame.ErrorCode),\n\t\tFrameType:    frame.FrameType,\n\t\tErrorMessage: frame.ReasonPhrase,\n\t})\n}\n\nfunc (s *connection) handleCryptoFrame(frame *wire.CryptoFrame, encLevel protocol.EncryptionLevel) error {\n\tif err := s.cryptoStreamManager.HandleCryptoFrame(frame, encLevel); err != nil {\n\t\treturn err\n\t}\n\treturn s.handleHandshakeEvents()\n}\n\nfunc (s *connection) handleHandshakeEvents() error {\n\tfor {\n\t\tev := s.cryptoStreamHandler.NextEvent()\n\t\tvar err error\n\t\tswitch ev.Kind {\n\t\tcase handshake.EventNoEvent:\n\t\t\treturn nil\n\t\tcase handshake.EventHandshakeComplete:\n\t\t\terr = s.handleHandshakeComplete()\n\t\tcase handshake.EventReceivedTransportParameters:\n\t\t\terr = s.handleTransportParameters(ev.TransportParameters)\n\t\tcase handshake.EventRestoredTransportParameters:\n\t\t\ts.restoreTransportParameters(ev.TransportParameters)\n\t\t\tclose(s.earlyConnReadyChan)\n\t\tcase handshake.EventReceivedReadKeys:\n\t\t\t// Queue all packets for decryption that have been undecryptable so far.\n\t\t\ts.undecryptablePacketsToProcess = s.undecryptablePackets\n\t\t\ts.undecryptablePackets = nil\n\t\tcase handshake.EventDiscard0RTTKeys:\n\t\t\terr = s.dropEncryptionLevel(protocol.Encryption0RTT)\n\t\tcase handshake.EventWriteInitialData:\n\t\t\t_, err = s.initialStream.Write(ev.Data)\n\t\tcase handshake.EventWriteHandshakeData:\n\t\t\t_, err = s.handshakeStream.Write(ev.Data)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *connection) handleStreamFrame(frame *wire.StreamFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenReceiveStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// Stream is closed and already garbage collected\n\t\t// ignore this StreamFrame\n\t\treturn nil\n\t}\n\treturn str.handleStreamFrame(frame)\n}\n\nfunc (s *connection) handleMaxDataFrame(frame *wire.MaxDataFrame) {\n\ts.connFlowController.UpdateSendWindow(frame.MaximumData)\n}\n\nfunc (s *connection) handleMaxStreamDataFrame(frame *wire.MaxStreamDataFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenSendStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// stream is closed and already garbage collected\n\t\treturn nil\n\t}\n\tstr.updateSendWindow(frame.MaximumStreamData)\n\treturn nil\n}\n\nfunc (s *connection) handleMaxStreamsFrame(frame *wire.MaxStreamsFrame) {\n\ts.streamsMap.HandleMaxStreamsFrame(frame)\n}\n\nfunc (s *connection) handleResetStreamFrame(frame *wire.ResetStreamFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenReceiveStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// stream is closed and already garbage collected\n\t\treturn nil\n\t}\n\treturn str.handleResetStreamFrame(frame)\n}\n\nfunc (s *connection) handleStopSendingFrame(frame *wire.StopSendingFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenSendStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// stream is closed and already garbage collected\n\t\treturn nil\n\t}\n\tstr.handleStopSendingFrame(frame)\n\treturn nil\n}\n\nfunc (s *connection) handlePathChallengeFrame(frame *wire.PathChallengeFrame) {\n\ts.queueControlFrame(&wire.PathResponseFrame{Data: frame.Data})\n}\n\nfunc (s *connection) handleNewTokenFrame(frame *wire.NewTokenFrame) error {\n\tif s.perspective == protocol.PerspectiveServer {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"received NEW_TOKEN frame from the client\",\n\t\t}\n\t}\n\tif s.config.TokenStore != nil {\n\t\ts.config.TokenStore.Put(s.tokenStoreKey, &ClientToken{data: frame.Token})\n\t}\n\treturn nil\n}\n\nfunc (s *connection) handleNewConnectionIDFrame(f *wire.NewConnectionIDFrame) error {\n\treturn s.connIDManager.Add(f)\n}\n\nfunc (s *connection) handleRetireConnectionIDFrame(f *wire.RetireConnectionIDFrame, destConnID protocol.ConnectionID) error {\n\treturn s.connIDGenerator.Retire(f.SequenceNumber, destConnID)\n}\n\nfunc (s *connection) handleHandshakeDoneFrame() error {\n\tif s.perspective == protocol.PerspectiveServer {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"received a HANDSHAKE_DONE frame\",\n\t\t}\n\t}\n\tif !s.handshakeConfirmed {\n\t\treturn s.handleHandshakeConfirmed()\n\t}\n\treturn nil\n}\n\nfunc (s *connection) handleAckFrame(frame *wire.AckFrame, encLevel protocol.EncryptionLevel) error {\n\tacked1RTTPacket, err := s.sentPacketHandler.ReceivedAck(frame, encLevel, s.lastPacketReceivedTime)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !acked1RTTPacket {\n\t\treturn nil\n\t}\n\tif s.perspective == protocol.PerspectiveClient && !s.handshakeConfirmed {\n\t\tif err := s.handleHandshakeConfirmed(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn s.cryptoStreamHandler.SetLargest1RTTAcked(frame.LargestAcked())\n}\n\nfunc (s *connection) handleDatagramFrame(f *wire.DatagramFrame) error {\n\tif f.Length(s.version) > protocol.MaxDatagramFrameSize {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"DATAGRAM frame too large\",\n\t\t}\n\t}\n\ts.datagramQueue.HandleDatagramFrame(f)\n\treturn nil\n}\n\n// closeLocal closes the connection and send a CONNECTION_CLOSE containing the error\nfunc (s *connection) closeLocal(e error) {\n\ts.closeOnce.Do(func() {\n\t\tif e == nil {\n\t\t\ts.logger.Infof(\"Closing connection.\")\n\t\t} else {\n\t\t\ts.logger.Errorf(\"Closing connection with error: %s\", e)\n\t\t}\n\t\ts.closeChan <- closeError{err: e, immediate: false, remote: false}\n\t})\n}\n\n// destroy closes the connection without sending the error on the wire\nfunc (s *connection) destroy(e error) {\n\ts.destroyImpl(e)\n\t<-s.ctx.Done()\n}\n\nfunc (s *connection) destroyImpl(e error) {\n\ts.closeOnce.Do(func() {\n\t\tif nerr, ok := e.(net.Error); ok && nerr.Timeout() {\n\t\t\ts.logger.Errorf(\"Destroying connection: %s\", e)\n\t\t} else {\n\t\t\ts.logger.Errorf(\"Destroying connection with error: %s\", e)\n\t\t}\n\t\ts.closeChan <- closeError{err: e, immediate: true, remote: false}\n\t})\n}\n\nfunc (s *connection) closeRemote(e error) {\n\ts.closeOnce.Do(func() {\n\t\ts.logger.Errorf(\"Peer closed connection with error: %s\", e)\n\t\ts.closeChan <- closeError{err: e, immediate: true, remote: true}\n\t})\n}\n\n// Close the connection. It sends a NO_ERROR application error.\n// It waits until the run loop has stopped before returning\nfunc (s *connection) shutdown() {\n\ts.closeLocal(nil)\n\t<-s.ctx.Done()\n}\n\nfunc (s *connection) CloseWithError(code ApplicationErrorCode, desc string) error {\n\ts.closeLocal(&qerr.ApplicationError{\n\t\tErrorCode:    code,\n\t\tErrorMessage: desc,\n\t})\n\t<-s.ctx.Done()\n\treturn nil\n}\n\nfunc (s *connection) handleCloseError(closeErr *closeError) {\n\te := closeErr.err\n\tif e == nil {\n\t\te = &qerr.ApplicationError{}\n\t} else {\n\t\tdefer func() {\n\t\t\tcloseErr.err = e\n\t\t}()\n\t}\n\n\tvar (\n\t\tstatelessResetErr     *StatelessResetError\n\t\tversionNegotiationErr *VersionNegotiationError\n\t\trecreateErr           *errCloseForRecreating\n\t\tapplicationErr        *ApplicationError\n\t\ttransportErr          *TransportError\n\t)\n\tswitch {\n\tcase errors.Is(e, qerr.ErrIdleTimeout),\n\t\terrors.Is(e, qerr.ErrHandshakeTimeout),\n\t\terrors.As(e, &statelessResetErr),\n\t\terrors.As(e, &versionNegotiationErr),\n\t\terrors.As(e, &recreateErr),\n\t\terrors.As(e, &applicationErr),\n\t\terrors.As(e, &transportErr):\n\tdefault:\n\t\te = &qerr.TransportError{\n\t\t\tErrorCode:    qerr.InternalError,\n\t\t\tErrorMessage: e.Error(),\n\t\t}\n\t}\n\n\ts.streamsMap.CloseWithError(e)\n\ts.connIDManager.Close()\n\tif s.datagramQueue != nil {\n\t\ts.datagramQueue.CloseWithError(e)\n\t}\n\n\tif s.tracer != nil && !errors.As(e, &recreateErr) {\n\t\ts.tracer.ClosedConnection(e)\n\t}\n\n\t// If this is a remote close we're done here\n\tif closeErr.remote {\n\t\ts.connIDGenerator.ReplaceWithClosed(s.perspective, nil)\n\t\treturn\n\t}\n\tif closeErr.immediate {\n\t\ts.connIDGenerator.RemoveAll()\n\t\treturn\n\t}\n\t// Don't send out any CONNECTION_CLOSE if this is an error that occurred\n\t// before we even sent out the first packet.\n\tif s.perspective == protocol.PerspectiveClient && !s.sentFirstPacket {\n\t\ts.connIDGenerator.RemoveAll()\n\t\treturn\n\t}\n\tconnClosePacket, err := s.sendConnectionClose(e)\n\tif err != nil {\n\t\ts.logger.Debugf(\"Error sending CONNECTION_CLOSE: %s\", err)\n\t}\n\ts.connIDGenerator.ReplaceWithClosed(s.perspective, connClosePacket)\n}\n\nfunc (s *connection) dropEncryptionLevel(encLevel protocol.EncryptionLevel) error {\n\tif s.tracer != nil {\n\t\ts.tracer.DroppedEncryptionLevel(encLevel)\n\t}\n\ts.sentPacketHandler.DropPackets(encLevel)\n\ts.receivedPacketHandler.DropPackets(encLevel)\n\t//nolint:exhaustive // only Initial and 0-RTT need special treatment\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\ts.cryptoStreamHandler.DiscardInitialKeys()\n\tcase protocol.Encryption0RTT:\n\t\ts.streamsMap.ResetFor0RTT()\n\t\tif err := s.connFlowController.Reset(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn s.framer.Handle0RTTRejection()\n\t}\n\treturn s.cryptoStreamManager.Drop(encLevel)\n}\n\n// is called for the client, when restoring transport parameters saved for 0-RTT\nfunc (s *connection) restoreTransportParameters(params *wire.TransportParameters) {\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"Restoring Transport Parameters: %s\", params)\n\t}\n\n\ts.peerParams = params\n\ts.connIDGenerator.SetMaxActiveConnIDs(params.ActiveConnectionIDLimit)\n\ts.connFlowController.UpdateSendWindow(params.InitialMaxData)\n\ts.streamsMap.UpdateLimits(params)\n\ts.connStateMutex.Lock()\n\ts.connState.SupportsDatagrams = s.supportsDatagrams()\n\ts.connStateMutex.Unlock()\n}\n\nfunc (s *connection) handleTransportParameters(params *wire.TransportParameters) error {\n\tif err := s.checkTransportParameters(params); err != nil {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\tErrorMessage: err.Error(),\n\t\t}\n\t}\n\ts.peerParams = params\n\t// On the client side we have to wait for handshake completion.\n\t// During a 0-RTT connection, we are only allowed to use the new transport parameters for 1-RTT packets.\n\tif s.perspective == protocol.PerspectiveServer {\n\t\ts.applyTransportParameters()\n\t\t// On the server side, the early connection is ready as soon as we processed\n\t\t// the client's transport parameters.\n\t\tclose(s.earlyConnReadyChan)\n\t}\n\n\ts.connStateMutex.Lock()\n\ts.connState.SupportsDatagrams = s.supportsDatagrams()\n\ts.connStateMutex.Unlock()\n\treturn nil\n}\n\nfunc (s *connection) checkTransportParameters(params *wire.TransportParameters) error {\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"Processed Transport Parameters: %s\", params)\n\t}\n\tif s.tracer != nil {\n\t\ts.tracer.ReceivedTransportParameters(params)\n\t}\n\n\t// check the initial_source_connection_id\n\tif params.InitialSourceConnectionID != s.handshakeDestConnID {\n\t\treturn fmt.Errorf(\"expected initial_source_connection_id to equal %s, is %s\", s.handshakeDestConnID, params.InitialSourceConnectionID)\n\t}\n\n\tif s.perspective == protocol.PerspectiveServer {\n\t\treturn nil\n\t}\n\t// check the original_destination_connection_id\n\tif params.OriginalDestinationConnectionID != s.origDestConnID {\n\t\treturn fmt.Errorf(\"expected original_destination_connection_id to equal %s, is %s\", s.origDestConnID, params.OriginalDestinationConnectionID)\n\t}\n\tif s.retrySrcConnID != nil { // a Retry was performed\n\t\tif params.RetrySourceConnectionID == nil {\n\t\t\treturn errors.New(\"missing retry_source_connection_id\")\n\t\t}\n\t\tif *params.RetrySourceConnectionID != *s.retrySrcConnID {\n\t\t\treturn fmt.Errorf(\"expected retry_source_connection_id to equal %s, is %s\", s.retrySrcConnID, *params.RetrySourceConnectionID)\n\t\t}\n\t} else if params.RetrySourceConnectionID != nil {\n\t\treturn errors.New(\"received retry_source_connection_id, although no Retry was performed\")\n\t}\n\treturn nil\n}\n\nfunc (s *connection) applyTransportParameters() {\n\tparams := s.peerParams\n\t// Our local idle timeout will always be > 0.\n\ts.idleTimeout = utils.MinNonZeroDuration(s.config.MaxIdleTimeout, params.MaxIdleTimeout)\n\ts.keepAliveInterval = utils.Min(s.config.KeepAlivePeriod, utils.Min(s.idleTimeout/2, protocol.MaxKeepAliveInterval))\n\ts.streamsMap.UpdateLimits(params)\n\ts.frameParser.SetAckDelayExponent(params.AckDelayExponent)\n\ts.connFlowController.UpdateSendWindow(params.InitialMaxData)\n\ts.rttStats.SetMaxAckDelay(params.MaxAckDelay)\n\ts.connIDGenerator.SetMaxActiveConnIDs(params.ActiveConnectionIDLimit)\n\tif params.StatelessResetToken != nil {\n\t\ts.connIDManager.SetStatelessResetToken(*params.StatelessResetToken)\n\t}\n\t// We don't support connection migration yet, so we don't have any use for the preferred_address.\n\tif params.PreferredAddress != nil {\n\t\t// Retire the connection ID.\n\t\ts.connIDManager.AddFromPreferredAddress(params.PreferredAddress.ConnectionID, params.PreferredAddress.StatelessResetToken)\n\t}\n}\n\nfunc (s *connection) triggerSending() error {\n\ts.pacingDeadline = time.Time{}\n\tnow := time.Now()\n\n\tsendMode := s.sentPacketHandler.SendMode(now)\n\t//nolint:exhaustive // No need to handle pacing limited here.\n\tswitch sendMode {\n\tcase ackhandler.SendAny:\n\t\treturn s.sendPackets(now)\n\tcase ackhandler.SendNone:\n\t\treturn nil\n\tcase ackhandler.SendPacingLimited:\n\t\tdeadline := s.sentPacketHandler.TimeUntilSend()\n\t\tif deadline.IsZero() {\n\t\t\tdeadline = deadlineSendImmediately\n\t\t}\n\t\ts.pacingDeadline = deadline\n\t\t// Allow sending of an ACK if we're pacing limit.\n\t\t// This makes sure that a peer that is mostly receiving data (and thus has an inaccurate cwnd estimate)\n\t\t// sends enough ACKs to allow its peer to utilize the bandwidth.\n\t\tfallthrough\n\tcase ackhandler.SendAck:\n\t\t// We can at most send a single ACK only packet.\n\t\t// There will only be a new ACK after receiving new packets.\n\t\t// SendAck is only returned when we're congestion limited, so we don't need to set the pacinggs timer.\n\t\treturn s.maybeSendAckOnlyPacket(now)\n\tcase ackhandler.SendPTOInitial:\n\t\tif err := s.sendProbePacket(protocol.EncryptionInitial, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\ts.scheduleSending()\n\t\t\treturn nil\n\t\t}\n\t\treturn s.triggerSending()\n\tcase ackhandler.SendPTOHandshake:\n\t\tif err := s.sendProbePacket(protocol.EncryptionHandshake, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\ts.scheduleSending()\n\t\t\treturn nil\n\t\t}\n\t\treturn s.triggerSending()\n\tcase ackhandler.SendPTOAppData:\n\t\tif err := s.sendProbePacket(protocol.Encryption1RTT, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\ts.scheduleSending()\n\t\t\treturn nil\n\t\t}\n\t\treturn s.triggerSending()\n\tdefault:\n\t\treturn fmt.Errorf(\"BUG: invalid send mode %d\", sendMode)\n\t}\n}\n\nfunc (s *connection) sendPackets(now time.Time) error {\n\t// Path MTU Discovery\n\t// Can't use GSO, since we need to send a single packet that's larger than our current maximum size.\n\t// Performance-wise, this doesn't matter, since we only send a very small (<10) number of\n\t// MTU probe packets per connection.\n\tif s.handshakeConfirmed && s.mtuDiscoverer != nil && s.mtuDiscoverer.ShouldSendProbe(now) {\n\t\tping, size := s.mtuDiscoverer.GetPing()\n\t\tp, buf, err := s.packer.PackMTUProbePacket(ping, size, s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, buf.Len(), false)\n\t\ts.registerPackedShortHeaderPacket(p, now)\n\t\ts.sendQueue.Send(buf, buf.Len())\n\t\t// This is kind of a hack. We need to trigger sending again somehow.\n\t\ts.pacingDeadline = deadlineSendImmediately\n\t\treturn nil\n\t}\n\n\tif isBlocked, offset := s.connFlowController.IsNewlyBlocked(); isBlocked {\n\t\ts.framer.QueueControlFrame(&wire.DataBlockedFrame{MaximumData: offset})\n\t}\n\ts.windowUpdateQueue.QueueAll()\n\tif cf := s.cryptoStreamManager.GetPostHandshakeData(protocol.MaxPostHandshakeCryptoFrameSize); cf != nil {\n\t\ts.queueControlFrame(cf)\n\t}\n\n\tif !s.handshakeConfirmed {\n\t\tpacket, err := s.packer.PackCoalescedPacket(false, s.mtuDiscoverer.CurrentSize(), s.version)\n\t\tif err != nil || packet == nil {\n\t\t\treturn err\n\t\t}\n\t\ts.sentFirstPacket = true\n\t\tif err := s.sendPackedCoalescedPacket(packet, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsendMode := s.sentPacketHandler.SendMode(now)\n\t\tif sendMode == ackhandler.SendPacingLimited {\n\t\t\ts.resetPacingDeadline()\n\t\t} else if sendMode == ackhandler.SendAny {\n\t\t\ts.pacingDeadline = deadlineSendImmediately\n\t\t}\n\t\treturn nil\n\t}\n\n\tif s.conn.capabilities().GSO {\n\t\treturn s.sendPacketsWithGSO(now)\n\t}\n\treturn s.sendPacketsWithoutGSO(now)\n}\n\nfunc (s *connection) sendPacketsWithoutGSO(now time.Time) error {\n\tfor {\n\t\tbuf := getPacketBuffer()\n\t\tif _, err := s.appendPacket(buf, s.mtuDiscoverer.CurrentSize(), now); err != nil {\n\t\t\tif err == errNothingToPack {\n\t\t\t\tbuf.Release()\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\ts.sendQueue.Send(buf, buf.Len())\n\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\treturn nil\n\t\t}\n\t\tsendMode := s.sentPacketHandler.SendMode(now)\n\t\tif sendMode == ackhandler.SendPacingLimited {\n\t\t\ts.resetPacingDeadline()\n\t\t\treturn nil\n\t\t}\n\t\tif sendMode != ackhandler.SendAny {\n\t\t\treturn nil\n\t\t}\n\t\t// Prioritize receiving of packets over sending out more packets.\n\t\tif len(s.receivedPackets) > 0 {\n\t\t\ts.pacingDeadline = deadlineSendImmediately\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (s *connection) sendPacketsWithGSO(now time.Time) error {\n\tbuf := getLargePacketBuffer()\n\tmaxSize := s.mtuDiscoverer.CurrentSize()\n\n\tfor {\n\t\tvar dontSendMore bool\n\t\tsize, err := s.appendPacket(buf, maxSize, now)\n\t\tif err != nil {\n\t\t\tif err != errNothingToPack {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif buf.Len() == 0 {\n\t\t\t\tbuf.Release()\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tdontSendMore = true\n\t\t}\n\n\t\tif !dontSendMore {\n\t\t\tsendMode := s.sentPacketHandler.SendMode(now)\n\t\t\tif sendMode == ackhandler.SendPacingLimited {\n\t\t\t\ts.resetPacingDeadline()\n\t\t\t}\n\t\t\tif sendMode != ackhandler.SendAny {\n\t\t\t\tdontSendMore = true\n\t\t\t}\n\t\t}\n\n\t\t// Append another packet if\n\t\t// 1. The congestion controller and pacer allow sending more\n\t\t// 2. The last packet appended was a full-size packet\n\t\t// 3. We still have enough space for another full-size packet in the buffer\n\t\tif !dontSendMore && size == maxSize && buf.Len()+maxSize <= buf.Cap() {\n\t\t\tcontinue\n\t\t}\n\n\t\ts.sendQueue.Send(buf, maxSize)\n\n\t\tif dontSendMore {\n\t\t\treturn nil\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Prioritize receiving of packets over sending out more packets.\n\t\tif len(s.receivedPackets) > 0 {\n\t\t\ts.pacingDeadline = deadlineSendImmediately\n\t\t\treturn nil\n\t\t}\n\n\t\tbuf = getLargePacketBuffer()\n\t}\n}\n\nfunc (s *connection) resetPacingDeadline() {\n\tdeadline := s.sentPacketHandler.TimeUntilSend()\n\tif deadline.IsZero() {\n\t\tdeadline = deadlineSendImmediately\n\t}\n\ts.pacingDeadline = deadline\n}\n\nfunc (s *connection) maybeSendAckOnlyPacket(now time.Time) error {\n\tif !s.handshakeConfirmed {\n\t\tpacket, err := s.packer.PackCoalescedPacket(true, s.mtuDiscoverer.CurrentSize(), s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif packet == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn s.sendPackedCoalescedPacket(packet, time.Now())\n\t}\n\n\tp, buf, err := s.packer.PackAckOnlyPacket(s.mtuDiscoverer.CurrentSize(), s.version)\n\tif err != nil {\n\t\tif err == errNothingToPack {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, buf.Len(), false)\n\ts.registerPackedShortHeaderPacket(p, now)\n\ts.sendQueue.Send(buf, buf.Len())\n\treturn nil\n}\n\nfunc (s *connection) sendProbePacket(encLevel protocol.EncryptionLevel, now time.Time) error {\n\t// Queue probe packets until we actually send out a packet,\n\t// or until there are no more packets to queue.\n\tvar packet *coalescedPacket\n\tfor {\n\t\tif wasQueued := s.sentPacketHandler.QueueProbePacket(encLevel); !wasQueued {\n\t\t\tbreak\n\t\t}\n\t\tvar err error\n\t\tpacket, err = s.packer.MaybePackProbePacket(encLevel, s.mtuDiscoverer.CurrentSize(), s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif packet != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tif packet == nil {\n\t\ts.retransmissionQueue.AddPing(encLevel)\n\t\tvar err error\n\t\tpacket, err = s.packer.MaybePackProbePacket(encLevel, s.mtuDiscoverer.CurrentSize(), s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif packet == nil || (len(packet.longHdrPackets) == 0 && packet.shortHdrPacket == nil) {\n\t\treturn fmt.Errorf(\"connection BUG: couldn't pack %s probe packet\", encLevel)\n\t}\n\treturn s.sendPackedCoalescedPacket(packet, now)\n}\n\n// appendPacket appends a new packet to the given packetBuffer.\n// If there was nothing to pack, the returned size is 0.\nfunc (s *connection) appendPacket(buf *packetBuffer, maxSize protocol.ByteCount, now time.Time) (protocol.ByteCount, error) {\n\tstartLen := buf.Len()\n\tp, err := s.packer.AppendPacket(buf, maxSize, s.version)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tsize := buf.Len() - startLen\n\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, size, false)\n\ts.registerPackedShortHeaderPacket(p, now)\n\treturn size, nil\n}\n\nfunc (s *connection) registerPackedShortHeaderPacket(p shortHeaderPacket, now time.Time) {\n\tif s.firstAckElicitingPacketAfterIdleSentTime.IsZero() && (len(p.StreamFrames) > 0 || ackhandler.HasAckElicitingFrames(p.Frames)) {\n\t\ts.firstAckElicitingPacketAfterIdleSentTime = now\n\t}\n\n\tlargestAcked := protocol.InvalidPacketNumber\n\tif p.Ack != nil {\n\t\tlargestAcked = p.Ack.LargestAcked()\n\t}\n\ts.sentPacketHandler.SentPacket(now, p.PacketNumber, largestAcked, p.StreamFrames, p.Frames, protocol.Encryption1RTT, p.Length, p.IsPathMTUProbePacket)\n\ts.connIDManager.SentPacket()\n}\n\nfunc (s *connection) sendPackedCoalescedPacket(packet *coalescedPacket, now time.Time) error {\n\ts.logCoalescedPacket(packet)\n\tfor _, p := range packet.longHdrPackets {\n\t\tif s.firstAckElicitingPacketAfterIdleSentTime.IsZero() && p.IsAckEliciting() {\n\t\t\ts.firstAckElicitingPacketAfterIdleSentTime = now\n\t\t}\n\t\tlargestAcked := protocol.InvalidPacketNumber\n\t\tif p.ack != nil {\n\t\t\tlargestAcked = p.ack.LargestAcked()\n\t\t}\n\t\ts.sentPacketHandler.SentPacket(now, p.header.PacketNumber, largestAcked, p.streamFrames, p.frames, p.EncryptionLevel(), p.length, false)\n\t\tif s.perspective == protocol.PerspectiveClient && p.EncryptionLevel() == protocol.EncryptionHandshake {\n\t\t\t// On the client side, Initial keys are dropped as soon as the first Handshake packet is sent.\n\t\t\t// See Section 4.9.1 of RFC 9001.\n\t\t\tif err := s.dropEncryptionLevel(protocol.EncryptionInitial); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif p := packet.shortHdrPacket; p != nil {\n\t\tif s.firstAckElicitingPacketAfterIdleSentTime.IsZero() && p.IsAckEliciting() {\n\t\t\ts.firstAckElicitingPacketAfterIdleSentTime = now\n\t\t}\n\t\tlargestAcked := protocol.InvalidPacketNumber\n\t\tif p.Ack != nil {\n\t\t\tlargestAcked = p.Ack.LargestAcked()\n\t\t}\n\t\ts.sentPacketHandler.SentPacket(now, p.PacketNumber, largestAcked, p.StreamFrames, p.Frames, protocol.Encryption1RTT, p.Length, p.IsPathMTUProbePacket)\n\t}\n\ts.connIDManager.SentPacket()\n\ts.sendQueue.Send(packet.buffer, packet.buffer.Len())\n\treturn nil\n}\n\nfunc (s *connection) sendConnectionClose(e error) ([]byte, error) {\n\tvar packet *coalescedPacket\n\tvar err error\n\tvar transportErr *qerr.TransportError\n\tvar applicationErr *qerr.ApplicationError\n\tif errors.As(e, &transportErr) {\n\t\tpacket, err = s.packer.PackConnectionClose(transportErr, s.mtuDiscoverer.CurrentSize(), s.version)\n\t} else if errors.As(e, &applicationErr) {\n\t\tpacket, err = s.packer.PackApplicationClose(applicationErr, s.mtuDiscoverer.CurrentSize(), s.version)\n\t} else {\n\t\tpacket, err = s.packer.PackConnectionClose(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.InternalError,\n\t\t\tErrorMessage: fmt.Sprintf(\"connection BUG: unspecified error type (msg: %s)\", e.Error()),\n\t\t}, s.mtuDiscoverer.CurrentSize(), s.version)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.logCoalescedPacket(packet)\n\treturn packet.buffer.Data, s.conn.Write(packet.buffer.Data, packet.buffer.Len())\n}\n\nfunc (s *connection) logLongHeaderPacket(p *longHeaderPacket) {\n\t// quic-go logging\n\tif s.logger.Debug() {\n\t\tp.header.Log(s.logger)\n\t\tif p.ack != nil {\n\t\t\twire.LogFrame(s.logger, p.ack, true)\n\t\t}\n\t\tfor _, frame := range p.frames {\n\t\t\twire.LogFrame(s.logger, frame.Frame, true)\n\t\t}\n\t\tfor _, frame := range p.streamFrames {\n\t\t\twire.LogFrame(s.logger, frame.Frame, true)\n\t\t}\n\t}\n\n\t// tracing\n\tif s.tracer != nil {\n\t\tframes := make([]logging.Frame, 0, len(p.frames))\n\t\tfor _, f := range p.frames {\n\t\t\tframes = append(frames, logutils.ConvertFrame(f.Frame))\n\t\t}\n\t\tfor _, f := range p.streamFrames {\n\t\t\tframes = append(frames, logutils.ConvertFrame(f.Frame))\n\t\t}\n\t\tvar ack *logging.AckFrame\n\t\tif p.ack != nil {\n\t\t\tack = logutils.ConvertAckFrame(p.ack)\n\t\t}\n\t\ts.tracer.SentLongHeaderPacket(p.header, p.length, ack, frames)\n\t}\n}\n\nfunc (s *connection) logShortHeaderPacket(\n\tdestConnID protocol.ConnectionID,\n\tackFrame *wire.AckFrame,\n\tframes []ackhandler.Frame,\n\tstreamFrames []ackhandler.StreamFrame,\n\tpn protocol.PacketNumber,\n\tpnLen protocol.PacketNumberLen,\n\tkp protocol.KeyPhaseBit,\n\tsize protocol.ByteCount,\n\tisCoalesced bool,\n) {\n\tif s.logger.Debug() && !isCoalesced {\n\t\ts.logger.Debugf(\"-> Sending packet %d (%d bytes) for connection %s, 1-RTT\", pn, size, s.logID)\n\t}\n\t// quic-go logging\n\tif s.logger.Debug() {\n\t\twire.LogShortHeader(s.logger, destConnID, pn, pnLen, kp)\n\t\tif ackFrame != nil {\n\t\t\twire.LogFrame(s.logger, ackFrame, true)\n\t\t}\n\t\tfor _, f := range frames {\n\t\t\twire.LogFrame(s.logger, f.Frame, true)\n\t\t}\n\t\tfor _, f := range streamFrames {\n\t\t\twire.LogFrame(s.logger, f.Frame, true)\n\t\t}\n\t}\n\n\t// tracing\n\tif s.tracer != nil {\n\t\tfs := make([]logging.Frame, 0, len(frames)+len(streamFrames))\n\t\tfor _, f := range frames {\n\t\t\tfs = append(fs, logutils.ConvertFrame(f.Frame))\n\t\t}\n\t\tfor _, f := range streamFrames {\n\t\t\tfs = append(fs, logutils.ConvertFrame(f.Frame))\n\t\t}\n\t\tvar ack *logging.AckFrame\n\t\tif ackFrame != nil {\n\t\t\tack = logutils.ConvertAckFrame(ackFrame)\n\t\t}\n\t\ts.tracer.SentShortHeaderPacket(\n\t\t\t&logging.ShortHeader{\n\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\tPacketNumber:     pn,\n\t\t\t\tPacketNumberLen:  pnLen,\n\t\t\t\tKeyPhase:         kp,\n\t\t\t},\n\t\t\tsize,\n\t\t\tack,\n\t\t\tfs,\n\t\t)\n\t}\n}\n\nfunc (s *connection) logCoalescedPacket(packet *coalescedPacket) {\n\tif s.logger.Debug() {\n\t\t// There's a short period between dropping both Initial and Handshake keys and completion of the handshake,\n\t\t// during which we might call PackCoalescedPacket but just pack a short header packet.\n\t\tif len(packet.longHdrPackets) == 0 && packet.shortHdrPacket != nil {\n\t\t\ts.logShortHeaderPacket(\n\t\t\t\tpacket.shortHdrPacket.DestConnID,\n\t\t\t\tpacket.shortHdrPacket.Ack,\n\t\t\t\tpacket.shortHdrPacket.Frames,\n\t\t\t\tpacket.shortHdrPacket.StreamFrames,\n\t\t\t\tpacket.shortHdrPacket.PacketNumber,\n\t\t\t\tpacket.shortHdrPacket.PacketNumberLen,\n\t\t\t\tpacket.shortHdrPacket.KeyPhase,\n\t\t\t\tpacket.shortHdrPacket.Length,\n\t\t\t\tfalse,\n\t\t\t)\n\t\t\treturn\n\t\t}\n\t\tif len(packet.longHdrPackets) > 1 {\n\t\t\ts.logger.Debugf(\"-> Sending coalesced packet (%d parts, %d bytes) for connection %s\", len(packet.longHdrPackets), packet.buffer.Len(), s.logID)\n\t\t} else {\n\t\t\ts.logger.Debugf(\"-> Sending packet %d (%d bytes) for connection %s, %s\", packet.longHdrPackets[0].header.PacketNumber, packet.buffer.Len(), s.logID, packet.longHdrPackets[0].EncryptionLevel())\n\t\t}\n\t}\n\tfor _, p := range packet.longHdrPackets {\n\t\ts.logLongHeaderPacket(p)\n\t}\n\tif p := packet.shortHdrPacket; p != nil {\n\t\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, p.Length, true)\n\t}\n}\n\n// AcceptStream returns the next stream openend by the peer\nfunc (s *connection) AcceptStream(ctx context.Context) (Stream, error) {\n\treturn s.streamsMap.AcceptStream(ctx)\n}\n\nfunc (s *connection) AcceptUniStream(ctx context.Context) (ReceiveStream, error) {\n\treturn s.streamsMap.AcceptUniStream(ctx)\n}\n\n// OpenStream opens a stream\nfunc (s *connection) OpenStream() (Stream, error) {\n\treturn s.streamsMap.OpenStream()\n}\n\nfunc (s *connection) OpenStreamSync(ctx context.Context) (Stream, error) {\n\treturn s.streamsMap.OpenStreamSync(ctx)\n}\n\nfunc (s *connection) OpenUniStream() (SendStream, error) {\n\treturn s.streamsMap.OpenUniStream()\n}\n\nfunc (s *connection) OpenUniStreamSync(ctx context.Context) (SendStream, error) {\n\treturn s.streamsMap.OpenUniStreamSync(ctx)\n}\n\nfunc (s *connection) newFlowController(id protocol.StreamID) flowcontrol.StreamFlowController {\n\tinitialSendWindow := s.peerParams.InitialMaxStreamDataUni\n\tif id.Type() == protocol.StreamTypeBidi {\n\t\tif id.InitiatedBy() == s.perspective {\n\t\t\tinitialSendWindow = s.peerParams.InitialMaxStreamDataBidiRemote\n\t\t} else {\n\t\t\tinitialSendWindow = s.peerParams.InitialMaxStreamDataBidiLocal\n\t\t}\n\t}\n\treturn flowcontrol.NewStreamFlowController(\n\t\tid,\n\t\ts.connFlowController,\n\t\tprotocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tprotocol.ByteCount(s.config.MaxStreamReceiveWindow),\n\t\tinitialSendWindow,\n\t\ts.onHasStreamWindowUpdate,\n\t\ts.rttStats,\n\t\ts.logger,\n\t)\n}\n\n// scheduleSending signals that we have data for sending\nfunc (s *connection) scheduleSending() {\n\tselect {\n\tcase s.sendingScheduled <- struct{}{}:\n\tdefault:\n\t}\n}\n\n// tryQueueingUndecryptablePacket queues a packet for which we're missing the decryption keys.\n// The logging.PacketType is only used for logging purposes.\nfunc (s *connection) tryQueueingUndecryptablePacket(p receivedPacket, pt logging.PacketType) {\n\tif s.handshakeComplete {\n\t\tpanic(\"shouldn't queue undecryptable packets after handshake completion\")\n\t}\n\tif len(s.undecryptablePackets)+1 > protocol.MaxUndecryptablePackets {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(pt, p.Size(), logging.PacketDropDOSPrevention)\n\t\t}\n\t\ts.logger.Infof(\"Dropping undecryptable packet (%d bytes). Undecryptable packet queue full.\", p.Size())\n\t\treturn\n\t}\n\ts.logger.Infof(\"Queueing packet (%d bytes) for later decryption\", p.Size())\n\tif s.tracer != nil {\n\t\ts.tracer.BufferedPacket(pt, p.Size())\n\t}\n\ts.undecryptablePackets = append(s.undecryptablePackets, p)\n}\n\nfunc (s *connection) queueControlFrame(f wire.Frame) {\n\ts.framer.QueueControlFrame(f)\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onHasStreamWindowUpdate(id protocol.StreamID) {\n\ts.windowUpdateQueue.AddStream(id)\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onHasConnectionWindowUpdate() {\n\ts.windowUpdateQueue.AddConnection()\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onHasStreamData(id protocol.StreamID) {\n\ts.framer.AddActiveStream(id)\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onStreamCompleted(id protocol.StreamID) {\n\tif err := s.streamsMap.DeleteStream(id); err != nil {\n\t\ts.closeLocal(err)\n\t}\n}\n\nfunc (s *connection) SendMessage(p []byte) error {\n\tif !s.supportsDatagrams() {\n\t\treturn errors.New(\"datagram support disabled\")\n\t}\n\n\tf := &wire.DatagramFrame{DataLenPresent: true}\n\tif protocol.ByteCount(len(p)) > f.MaxDataLen(s.peerParams.MaxDatagramFrameSize, s.version) {\n\t\treturn errors.New(\"message too large\")\n\t}\n\tf.Data = make([]byte, len(p))\n\tcopy(f.Data, p)\n\treturn s.datagramQueue.AddAndWait(f)\n}\n\nfunc (s *connection) ReceiveMessage(ctx context.Context) ([]byte, error) {\n\tif !s.config.EnableDatagrams {\n\t\treturn nil, errors.New(\"datagram support disabled\")\n\t}\n\treturn s.datagramQueue.Receive(ctx)\n}\n\nfunc (s *connection) LocalAddr() net.Addr {\n\treturn s.conn.LocalAddr()\n}\n\nfunc (s *connection) RemoteAddr() net.Addr {\n\treturn s.conn.RemoteAddr()\n}\n\nfunc (s *connection) getPerspective() protocol.Perspective {\n\treturn s.perspective\n}\n\nfunc (s *connection) GetVersion() protocol.VersionNumber {\n\treturn s.version\n}\n\nfunc (s *connection) NextConnection() Connection {\n\t<-s.HandshakeComplete()\n\ts.streamsMap.UseResetMaps()\n\treturn s\n}\n", "package quic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"runtime/pprof\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/mocks\"\n\tmockackhandler \"github.com/quic-go/quic-go/internal/mocks/ackhandler\"\n\tmocklogging \"github.com/quic-go/quic-go/internal/mocks/logging\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/testutils\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n\n\t\"github.com/golang/mock/gomock\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc areConnsRunning() bool {\n\tvar b bytes.Buffer\n\tpprof.Lookup(\"goroutine\").WriteTo(&b, 1)\n\treturn strings.Contains(b.String(), \"quic-go.(*connection).run\")\n}\n\nvar _ = Describe(\"Connection\", func() {\n\tvar (\n\t\tconn          *connection\n\t\tconnRunner    *MockConnRunner\n\t\tmconn         *MockSendConn\n\t\tstreamManager *MockStreamManager\n\t\tpacker        *MockPacker\n\t\tcryptoSetup   *mocks.MockCryptoSetup\n\t\ttracer        *mocklogging.MockConnectionTracer\n\t\tcapabilities  connCapabilities\n\t)\n\tremoteAddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\tlocalAddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 7331}\n\tsrcConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\tdestConnID := protocol.ParseConnectionID([]byte{8, 7, 6, 5, 4, 3, 2, 1})\n\tclientDestConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n\n\tgetCoalescedPacket := func(pn protocol.PacketNumber, isLongHeader bool) *coalescedPacket {\n\t\tbuffer := getPacketBuffer()\n\t\tbuffer.Data = append(buffer.Data, []byte(\"foobar\")...)\n\t\tpacket := &coalescedPacket{buffer: buffer}\n\t\tif isLongHeader {\n\t\t\tpacket.longHdrPackets = []*longHeaderPacket{{\n\t\t\t\theader: &wire.ExtendedHeader{\n\t\t\t\t\tHeader:       wire.Header{},\n\t\t\t\t\tPacketNumber: pn,\n\t\t\t\t},\n\t\t\t\tlength: 6, // foobar\n\t\t\t}}\n\t\t} else {\n\t\t\tpacket.shortHdrPacket = &shortHeaderPacket{\n\t\t\t\tPacketNumber: pn,\n\t\t\t\tLength:       6,\n\t\t\t}\n\t\t}\n\t\treturn packet\n\t}\n\n\texpectReplaceWithClosed := func() {\n\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(connIDs []protocol.ConnectionID, _ protocol.Perspective, _ []byte) {\n\t\t\tExpect(connIDs).To(ContainElement(srcConnID))\n\t\t\tif len(connIDs) > 1 {\n\t\t\t\tExpect(connIDs).To(ContainElement(clientDestConnID))\n\t\t\t}\n\t\t})\n\t}\n\n\texpectAppendPacket := func(packer *MockPacker, p shortHeaderPacket, b []byte) *gomock.Call {\n\t\treturn packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), Version1).DoAndReturn(func(buf *packetBuffer, _ protocol.ByteCount, _ protocol.VersionNumber) (shortHeaderPacket, error) {\n\t\t\tbuf.Data = append(buf.Data, b...)\n\t\t\treturn p, nil\n\t\t})\n\t}\n\n\tenableGSO := func() { capabilities = connCapabilities{GSO: true} }\n\n\tBeforeEach(func() {\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\n\t\tconnRunner = NewMockConnRunner(mockCtrl)\n\t\tmconn = NewMockSendConn(mockCtrl)\n\t\tmconn.EXPECT().capabilities().DoAndReturn(func() connCapabilities { return capabilities }).AnyTimes()\n\t\tmconn.EXPECT().RemoteAddr().Return(remoteAddr).AnyTimes()\n\t\tmconn.EXPECT().LocalAddr().Return(localAddr).AnyTimes()\n\t\ttokenGenerator, err := handshake.NewTokenGenerator(rand.Reader)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\ttracer = mocklogging.NewMockConnectionTracer(mockCtrl)\n\t\ttracer.EXPECT().NegotiatedVersion(gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\ttracer.EXPECT().SentTransportParameters(gomock.Any())\n\t\ttracer.EXPECT().UpdatedKeyFromTLS(gomock.Any(), gomock.Any()).AnyTimes()\n\t\ttracer.EXPECT().UpdatedCongestionState(gomock.Any())\n\t\tconn = newConnection(\n\t\t\tmconn,\n\t\t\tconnRunner,\n\t\t\tprotocol.ConnectionID{},\n\t\t\tnil,\n\t\t\tclientDestConnID,\n\t\t\tdestConnID,\n\t\t\tsrcConnID,\n\t\t\t&protocol.DefaultConnectionIDGenerator{},\n\t\t\tprotocol.StatelessResetToken{},\n\t\t\tpopulateServerConfig(&Config{DisablePathMTUDiscovery: true}),\n\t\t\t&tls.Config{},\n\t\t\ttokenGenerator,\n\t\t\tfalse,\n\t\t\ttracer,\n\t\t\t1234,\n\t\t\tutils.DefaultLogger,\n\t\t\tprotocol.Version1,\n\t\t).(*connection)\n\t\tstreamManager = NewMockStreamManager(mockCtrl)\n\t\tconn.streamsMap = streamManager\n\t\tpacker = NewMockPacker(mockCtrl)\n\t\tconn.packer = packer\n\t\tcryptoSetup = mocks.NewMockCryptoSetup(mockCtrl)\n\t\tconn.cryptoStreamHandler = cryptoSetup\n\t\tconn.handshakeComplete = true\n\t\tconn.idleTimeout = time.Hour\n\t})\n\n\tAfterEach(func() {\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\tcapabilities = connCapabilities{}\n\t})\n\n\tContext(\"frame handling\", func() {\n\t\tContext(\"handling STREAM frames\", func() {\n\t\t\tIt(\"passes STREAM frames to the stream\", func() {\n\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\tStreamID: 5,\n\t\t\t\t\tData:     []byte{0xde, 0xca, 0xfb, 0xad},\n\t\t\t\t}\n\t\t\t\tstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\t\tstr.EXPECT().handleStreamFrame(f)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(5)).Return(str, nil)\n\t\t\t\tExpect(conn.handleStreamFrame(f)).To(Succeed())\n\t\t\t})\n\n\t\t\tIt(\"returns errors\", func() {\n\t\t\t\ttestErr := errors.New(\"test err\")\n\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\tStreamID: 5,\n\t\t\t\t\tData:     []byte{0xde, 0xca, 0xfb, 0xad},\n\t\t\t\t}\n\t\t\t\tstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\t\tstr.EXPECT().handleStreamFrame(f).Return(testErr)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(5)).Return(str, nil)\n\t\t\t\tExpect(conn.handleStreamFrame(f)).To(MatchError(testErr))\n\t\t\t})\n\n\t\t\tIt(\"ignores STREAM frames for closed streams\", func() {\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(5)).Return(nil, nil) // for closed streams, the streamManager returns nil\n\t\t\t\tExpect(conn.handleStreamFrame(&wire.StreamFrame{\n\t\t\t\t\tStreamID: 5,\n\t\t\t\t\tData:     []byte(\"foobar\"),\n\t\t\t\t})).To(Succeed())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling ACK frames\", func() {\n\t\t\tIt(\"informs the SentPacketHandler about ACKs\", func() {\n\t\t\t\tf := &wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 2, Largest: 3}}}\n\t\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\t\tsph.EXPECT().ReceivedAck(f, protocol.EncryptionHandshake, gomock.Any())\n\t\t\t\tconn.sentPacketHandler = sph\n\t\t\t\terr := conn.handleAckFrame(f, protocol.EncryptionHandshake)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling RESET_STREAM frames\", func() {\n\t\t\tIt(\"closes the streams for writing\", func() {\n\t\t\t\tf := &wire.ResetStreamFrame{\n\t\t\t\t\tStreamID:  555,\n\t\t\t\t\tErrorCode: 42,\n\t\t\t\t\tFinalSize: 0x1337,\n\t\t\t\t}\n\t\t\t\tstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(555)).Return(str, nil)\n\t\t\t\tstr.EXPECT().handleResetStreamFrame(f)\n\t\t\t\terr := conn.handleResetStreamFrame(f)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t})\n\n\t\t\tIt(\"returns errors\", func() {\n\t\t\t\tf := &wire.ResetStreamFrame{\n\t\t\t\t\tStreamID:  7,\n\t\t\t\t\tFinalSize: 0x1337,\n\t\t\t\t}\n\t\t\t\ttestErr := errors.New(\"flow control violation\")\n\t\t\t\tstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(7)).Return(str, nil)\n\t\t\t\tstr.EXPECT().handleResetStreamFrame(f).Return(testErr)\n\t\t\t\terr := conn.handleResetStreamFrame(f)\n\t\t\t\tExpect(err).To(MatchError(testErr))\n\t\t\t})\n\n\t\t\tIt(\"ignores RESET_STREAM frames for closed streams\", func() {\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(3)).Return(nil, nil)\n\t\t\t\tExpect(conn.handleFrame(&wire.ResetStreamFrame{\n\t\t\t\t\tStreamID:  3,\n\t\t\t\t\tErrorCode: 42,\n\t\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling MAX_DATA and MAX_STREAM_DATA frames\", func() {\n\t\t\tvar connFC *mocks.MockConnectionFlowController\n\n\t\t\tBeforeEach(func() {\n\t\t\t\tconnFC = mocks.NewMockConnectionFlowController(mockCtrl)\n\t\t\t\tconn.connFlowController = connFC\n\t\t\t})\n\n\t\t\tIt(\"updates the flow control window of a stream\", func() {\n\t\t\t\tf := &wire.MaxStreamDataFrame{\n\t\t\t\t\tStreamID:          12345,\n\t\t\t\t\tMaximumStreamData: 0x1337,\n\t\t\t\t}\n\t\t\t\tstr := NewMockSendStreamI(mockCtrl)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenSendStream(protocol.StreamID(12345)).Return(str, nil)\n\t\t\t\tstr.EXPECT().updateSendWindow(protocol.ByteCount(0x1337))\n\t\t\t\tExpect(conn.handleMaxStreamDataFrame(f)).To(Succeed())\n\t\t\t})\n\n\t\t\tIt(\"updates the flow control window of the connection\", func() {\n\t\t\t\toffset := protocol.ByteCount(0x800000)\n\t\t\t\tconnFC.EXPECT().UpdateSendWindow(offset)\n\t\t\t\tconn.handleMaxDataFrame(&wire.MaxDataFrame{MaximumData: offset})\n\t\t\t})\n\n\t\t\tIt(\"ignores MAX_STREAM_DATA frames for a closed stream\", func() {\n\t\t\t\tstreamManager.EXPECT().GetOrOpenSendStream(protocol.StreamID(10)).Return(nil, nil)\n\t\t\t\tExpect(conn.handleFrame(&wire.MaxStreamDataFrame{\n\t\t\t\t\tStreamID:          10,\n\t\t\t\t\tMaximumStreamData: 1337,\n\t\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling MAX_STREAM_ID frames\", func() {\n\t\t\tIt(\"passes the frame to the streamsMap\", func() {\n\t\t\t\tf := &wire.MaxStreamsFrame{\n\t\t\t\t\tType:         protocol.StreamTypeUni,\n\t\t\t\t\tMaxStreamNum: 10,\n\t\t\t\t}\n\t\t\t\tstreamManager.EXPECT().HandleMaxStreamsFrame(f)\n\t\t\t\tconn.handleMaxStreamsFrame(f)\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling STOP_SENDING frames\", func() {\n\t\t\tIt(\"passes the frame to the stream\", func() {\n\t\t\t\tf := &wire.StopSendingFrame{\n\t\t\t\t\tStreamID:  5,\n\t\t\t\t\tErrorCode: 10,\n\t\t\t\t}\n\t\t\t\tstr := NewMockSendStreamI(mockCtrl)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenSendStream(protocol.StreamID(5)).Return(str, nil)\n\t\t\t\tstr.EXPECT().handleStopSendingFrame(f)\n\t\t\t\terr := conn.handleStopSendingFrame(f)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t})\n\n\t\t\tIt(\"ignores STOP_SENDING frames for a closed stream\", func() {\n\t\t\t\tstreamManager.EXPECT().GetOrOpenSendStream(protocol.StreamID(3)).Return(nil, nil)\n\t\t\t\tExpect(conn.handleFrame(&wire.StopSendingFrame{\n\t\t\t\t\tStreamID:  3,\n\t\t\t\t\tErrorCode: 1337,\n\t\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\t})\n\t\t})\n\n\t\tIt(\"handles NEW_CONNECTION_ID frames\", func() {\n\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4})\n\t\t\tExpect(conn.handleFrame(&wire.NewConnectionIDFrame{\n\t\t\t\tSequenceNumber: 10,\n\t\t\t\tConnectionID:   connID,\n\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\tExpect(conn.connIDManager.queue.Back().Value.ConnectionID).To(Equal(connID))\n\t\t})\n\n\t\tIt(\"handles PING frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.PingFrame{}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"rejects PATH_RESPONSE frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.PathResponseFrame{Data: [8]byte{1, 2, 3, 4, 5, 6, 7, 8}}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).To(MatchError(\"unexpected PATH_RESPONSE frame\"))\n\t\t})\n\n\t\tIt(\"handles PATH_CHALLENGE frames\", func() {\n\t\t\tdata := [8]byte{1, 2, 3, 4, 5, 6, 7, 8}\n\t\t\terr := conn.handleFrame(&wire.PathChallengeFrame{Data: data}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tframes, _ := conn.framer.AppendControlFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(Equal([]ackhandler.Frame{{Frame: &wire.PathResponseFrame{Data: data}}}))\n\t\t})\n\n\t\tIt(\"rejects NEW_TOKEN frames\", func() {\n\t\t\terr := conn.handleNewTokenFrame(&wire.NewTokenFrame{})\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err).To(BeAssignableToTypeOf(&qerr.TransportError{}))\n\t\t\tExpect(err.(*qerr.TransportError).ErrorCode).To(Equal(qerr.ProtocolViolation))\n\t\t})\n\n\t\tIt(\"handles BLOCKED frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.DataBlockedFrame{}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"handles STREAM_BLOCKED frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.StreamDataBlockedFrame{}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"handles STREAMS_BLOCKED frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.StreamsBlockedFrame{}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"handles CONNECTION_CLOSE frames, with a transport error code\", func() {\n\t\t\texpectedErr := &qerr.TransportError{\n\t\t\t\tRemote:       true,\n\t\t\t\tErrorCode:    qerr.StreamLimitError,\n\t\t\t\tErrorMessage: \"foobar\",\n\t\t\t}\n\t\t\tstreamManager.EXPECT().CloseWithError(expectedErr)\n\t\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(connIDs []protocol.ConnectionID, _ protocol.Perspective, _ []byte) {\n\t\t\t\tExpect(connIDs).To(ConsistOf(clientDestConnID, srcConnID))\n\t\t\t})\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(expectedErr),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tExpect(conn.run()).To(MatchError(expectedErr))\n\t\t\t}()\n\t\t\tExpect(conn.handleFrame(&wire.ConnectionCloseFrame{\n\t\t\t\tErrorCode:    uint64(qerr.StreamLimitError),\n\t\t\t\tReasonPhrase: \"foobar\",\n\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"handles CONNECTION_CLOSE frames, with an application error code\", func() {\n\t\t\ttestErr := &qerr.ApplicationError{\n\t\t\t\tRemote:       true,\n\t\t\t\tErrorCode:    0x1337,\n\t\t\t\tErrorMessage: \"foobar\",\n\t\t\t}\n\t\t\tstreamManager.EXPECT().CloseWithError(testErr)\n\t\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(connIDs []protocol.ConnectionID, _ protocol.Perspective, _ []byte) {\n\t\t\t\tExpect(connIDs).To(ConsistOf(clientDestConnID, srcConnID))\n\t\t\t})\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(testErr),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tExpect(conn.run()).To(MatchError(testErr))\n\t\t\t}()\n\t\t\tccf := &wire.ConnectionCloseFrame{\n\t\t\t\tErrorCode:          0x1337,\n\t\t\t\tReasonPhrase:       \"foobar\",\n\t\t\t\tIsApplicationError: true,\n\t\t\t}\n\t\t\tExpect(conn.handleFrame(ccf, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t\tExpect(context.Cause(conn.Context())).To(MatchError(testErr))\n\t\t})\n\n\t\tIt(\"errors on HANDSHAKE_DONE frames\", func() {\n\t\t\tExpect(conn.handleHandshakeDoneFrame()).To(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\t\tErrorMessage: \"received a HANDSHAKE_DONE frame\",\n\t\t\t}))\n\t\t})\n\t})\n\n\tIt(\"tells its versions\", func() {\n\t\tconn.version = 4242\n\t\tExpect(conn.GetVersion()).To(Equal(protocol.VersionNumber(4242)))\n\t})\n\n\tContext(\"closing\", func() {\n\t\tvar (\n\t\t\trunErr         chan error\n\t\t\texpectedRunErr error\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\trunErr = make(chan error, 1)\n\t\t\texpectedRunErr = nil\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\tif expectedRunErr != nil {\n\t\t\t\tEventually(runErr).Should(Receive(MatchError(expectedRunErr)))\n\t\t\t} else {\n\t\t\t\tEventually(runErr).Should(Receive())\n\t\t\t}\n\t\t})\n\n\t\trunConn := func() {\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\trunErr <- conn.run()\n\t\t\t}()\n\t\t\tEventually(areConnsRunning).Should(BeTrue())\n\t\t}\n\n\t\tIt(\"shuts down without error\", func() {\n\t\t\tconn.handshakeComplete = true\n\t\t\trunConn()\n\t\t\tstreamManager.EXPECT().CloseWithError(&qerr.ApplicationError{})\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tbuffer := getPacketBuffer()\n\t\t\tbuffer.Data = append(buffer.Data, []byte(\"connection close\")...)\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(e *qerr.ApplicationError, _ protocol.ByteCount, _ protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tExpect(e.ErrorCode).To(BeEquivalentTo(qerr.NoError))\n\t\t\t\tExpect(e.ErrorMessage).To(BeEmpty())\n\t\t\t\treturn &coalescedPacket{buffer: buffer}, nil\n\t\t\t})\n\t\t\tmconn.EXPECT().Write([]byte(\"connection close\"), gomock.Any())\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tvar appErr *ApplicationError\n\t\t\t\t\tExpect(errors.As(e, &appErr)).To(BeTrue())\n\t\t\t\t\tExpect(appErr.Remote).To(BeFalse())\n\t\t\t\t\tExpect(appErr.ErrorCode).To(BeZero())\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.shutdown()\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\tExpect(conn.Context().Done()).To(BeClosed())\n\t\t})\n\n\t\tIt(\"only closes once\", func() {\n\t\t\trunConn()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tconn.shutdown()\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\tExpect(conn.Context().Done()).To(BeClosed())\n\t\t})\n\n\t\tIt(\"closes with an error\", func() {\n\t\t\trunConn()\n\t\t\texpectedErr := &qerr.ApplicationError{\n\t\t\t\tErrorCode:    0x1337,\n\t\t\t\tErrorMessage: \"test error\",\n\t\t\t}\n\t\t\tstreamManager.EXPECT().CloseWithError(expectedErr)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackApplicationClose(expectedErr, gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(expectedErr),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.CloseWithError(0x1337, \"test error\")\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\tExpect(conn.Context().Done()).To(BeClosed())\n\t\t\tExpect(context.Cause(conn.Context())).To(MatchError(expectedErr))\n\t\t})\n\n\t\tIt(\"includes the frame type in transport-level close frames\", func() {\n\t\t\trunConn()\n\t\t\texpectedErr := &qerr.TransportError{\n\t\t\t\tErrorCode:    0x1337,\n\t\t\t\tFrameType:    0x42,\n\t\t\t\tErrorMessage: \"test error\",\n\t\t\t}\n\t\t\tstreamManager.EXPECT().CloseWithError(expectedErr)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(expectedErr, gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(expectedErr),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.closeLocal(expectedErr)\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\tExpect(conn.Context().Done()).To(BeClosed())\n\t\t})\n\n\t\tIt(\"destroys the connection\", func() {\n\t\t\trunConn()\n\t\t\ttestErr := errors.New(\"close\")\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\t// don't EXPECT any calls to mconn.Write()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tvar transportErr *TransportError\n\t\t\t\t\tExpect(errors.As(e, &transportErr)).To(BeTrue())\n\t\t\t\t\tExpect(transportErr.Remote).To(BeFalse())\n\t\t\t\t\tExpect(transportErr.ErrorCode).To(Equal(qerr.InternalError))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.destroy(testErr)\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\texpectedRunErr = &qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.InternalError,\n\t\t\t\tErrorMessage: testErr.Error(),\n\t\t\t}\n\t\t})\n\n\t\tIt(\"cancels the context when the run loop exists\", func() {\n\t\t\trunConn()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\treturned := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tctx := conn.Context()\n\t\t\t\t<-ctx.Done()\n\t\t\t\tExpect(ctx.Err()).To(MatchError(context.Canceled))\n\t\t\t\tclose(returned)\n\t\t\t}()\n\t\t\tConsistently(returned).ShouldNot(BeClosed())\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(returned).Should(BeClosed())\n\t\t\tExpect(context.Cause(conn.Context())).To(MatchError(context.Canceled))\n\t\t})\n\n\t\tIt(\"doesn't send any more packets after receiving a CONNECTION_CLOSE\", func() {\n\t\t\tunpacker := NewMockUnpacker(mockCtrl)\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tconn.unpacker = unpacker\n\t\t\trunConn()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tb, err := wire.AppendShortHeader(nil, srcConnID, 42, protocol.PacketNumberLen2, protocol.KeyPhaseOne)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).DoAndReturn(func(time.Time, []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\t\t\t\tb, err := (&wire.ConnectionCloseFrame{ErrorCode: uint64(qerr.StreamLimitError)}).Append(nil, conn.version)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\treturn 3, protocol.PacketNumberLen2, protocol.KeyPhaseOne, b, nil\n\t\t\t})\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\t// don't EXPECT any calls to packer.PackPacket()\n\t\t\tconn.handlePacket(receivedPacket{\n\t\t\t\trcvTime:    time.Now(),\n\t\t\t\tremoteAddr: &net.UDPAddr{},\n\t\t\t\tbuffer:     getPacketBuffer(),\n\t\t\t\tdata:       b,\n\t\t\t})\n\t\t\t// Consistently(pack).ShouldNot(Receive())\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes when the sendQueue encounters an error\", func() {\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tsconn := NewMockSendConn(mockCtrl)\n\t\t\tsconn.EXPECT().capabilities().AnyTimes()\n\t\t\tsconn.EXPECT().Write(gomock.Any(), gomock.Any()).Return(io.ErrClosedPipe).AnyTimes()\n\t\t\tconn.sendQueue = newSendQueue(sconn)\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().Return(time.Now().Add(time.Hour)).AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\t// only expect a single SentPacket() call\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tconn.sentPacketHandler = sph\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1}, []byte(\"foobar\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\t\trunConn()\n\t\t\tconn.queueControlFrame(&wire.PingFrame{})\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes due to a stateless reset\", func() {\n\t\t\ttoken := protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\t\t\trunConn()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tvar srErr *StatelessResetError\n\t\t\t\t\tExpect(errors.As(e, &srErr)).To(BeTrue())\n\t\t\t\t\tExpect(srErr.Token).To(Equal(token))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tconn.destroy(&StatelessResetError{Token: token})\n\t\t})\n\t})\n\n\tContext(\"receiving packets\", func() {\n\t\tvar unpacker *MockUnpacker\n\n\t\tBeforeEach(func() {\n\t\t\tunpacker = NewMockUnpacker(mockCtrl)\n\t\t\tconn.unpacker = unpacker\n\t\t})\n\n\t\tgetShortHeaderPacket := func(connID protocol.ConnectionID, pn protocol.PacketNumber, data []byte) receivedPacket {\n\t\t\tb, err := wire.AppendShortHeader(nil, connID, pn, protocol.PacketNumberLen2, protocol.KeyPhaseOne)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\treturn receivedPacket{\n\t\t\t\tdata:    append(b, data...),\n\t\t\t\tbuffer:  getPacketBuffer(),\n\t\t\t\trcvTime: time.Now(),\n\t\t\t}\n\t\t}\n\n\t\tgetLongHeaderPacket := func(extHdr *wire.ExtendedHeader, data []byte) receivedPacket {\n\t\t\tb, err := extHdr.Append(nil, conn.version)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\treturn receivedPacket{\n\t\t\t\tdata:    append(b, data...),\n\t\t\t\tbuffer:  getPacketBuffer(),\n\t\t\t\trcvTime: time.Now(),\n\t\t\t}\n\t\t}\n\n\t\tIt(\"drops Retry packets\", func() {\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{Header: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeRetry,\n\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\tVersion:          conn.version,\n\t\t\t\tToken:            []byte(\"foobar\"),\n\t\t\t}}, make([]byte, 16) /* Retry integrity tag */)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops Version Negotiation packets\", func() {\n\t\t\tb := wire.ComposeVersionNegotiation(\n\t\t\t\tprotocol.ArbitraryLenConnectionID(srcConnID.Bytes()),\n\t\t\t\tprotocol.ArbitraryLenConnectionID(destConnID.Bytes()),\n\t\t\t\tconn.config.Versions,\n\t\t\t)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeVersionNegotiation, protocol.ByteCount(len(b)), logging.PacketDropUnexpectedPacket)\n\t\t\tExpect(conn.handlePacketImpl(receivedPacket{\n\t\t\t\tdata:   b,\n\t\t\t\tbuffer: getPacketBuffer(),\n\t\t\t})).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops packets for which header decryption fails\", func() {\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:    protocol.PacketTypeHandshake,\n\t\t\t\t\tVersion: conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, nil)\n\t\t\tp.data[0] ^= 0x40 // unset the QUIC bit\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropHeaderParseError)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops packets for which the version is unsupported\", func() {\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:    protocol.PacketTypeHandshake,\n\t\t\t\t\tVersion: conn.version + 1,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, nil)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropUnsupportedVersion)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops packets with an unsupported version\", func() {\n\t\t\torigSupportedVersions := make([]protocol.VersionNumber, len(protocol.SupportedVersions))\n\t\t\tcopy(origSupportedVersions, protocol.SupportedVersions)\n\t\t\tdefer func() {\n\t\t\t\tprotocol.SupportedVersions = origSupportedVersions\n\t\t\t}()\n\n\t\t\tprotocol.SupportedVersions = append(protocol.SupportedVersions, conn.version+1)\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tVersion:          conn.version + 1,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, nil)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeHandshake, p.Size(), logging.PacketDropUnexpectedVersion)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"informs the ReceivedPacketHandler about non-ack-eliciting packets\", func() {\n\t\t\thdr := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: srcConnID,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t\tLength:           1,\n\t\t\t\t},\n\t\t\t\tPacketNumber:    0x37,\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t}\n\t\t\tunpackedHdr := *hdr\n\t\t\tunpackedHdr.PacketNumber = 0x1337\n\t\t\tpacket := getLongHeaderPacket(hdr, nil)\n\t\t\tpacket.ecn = protocol.ECNCE\n\t\t\trcvTime := time.Now().Add(-10 * time.Second)\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), rcvTime, gomock.Any(), conn.version).Return(&unpackedPacket{\n\t\t\t\tencryptionLevel: protocol.EncryptionInitial,\n\t\t\t\thdr:             &unpackedHdr,\n\t\t\t\tdata:            []byte{0}, // one PADDING frame\n\t\t\t}, nil)\n\t\t\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\t\t\tgomock.InOrder(\n\t\t\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(0x1337), protocol.EncryptionInitial),\n\t\t\t\trph.EXPECT().ReceivedPacket(protocol.PacketNumber(0x1337), protocol.ECNCE, protocol.EncryptionInitial, rcvTime, false),\n\t\t\t)\n\t\t\tconn.receivedPacketHandler = rph\n\t\t\tpacket.rcvTime = rcvTime\n\t\t\ttracer.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), []logging.Frame{})\n\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeTrue())\n\t\t})\n\n\t\tIt(\"informs the ReceivedPacketHandler about ack-eliciting packets\", func() {\n\t\t\trcvTime := time.Now().Add(-10 * time.Second)\n\t\t\tb, err := (&wire.PingFrame{}).Append(nil, conn.version)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tpacket := getShortHeaderPacket(srcConnID, 0x37, nil)\n\t\t\tpacket.ecn = protocol.ECT1\n\t\t\tunpacker.EXPECT().UnpackShortHeader(rcvTime, gomock.Any()).Return(protocol.PacketNumber(0x1337), protocol.PacketNumberLen2, protocol.KeyPhaseZero, b, nil)\n\t\t\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\t\t\tgomock.InOrder(\n\t\t\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(0x1337), protocol.Encryption1RTT),\n\t\t\t\trph.EXPECT().ReceivedPacket(protocol.PacketNumber(0x1337), protocol.ECT1, protocol.Encryption1RTT, rcvTime, true),\n\t\t\t)\n\t\t\tconn.receivedPacketHandler = rph\n\t\t\tpacket.rcvTime = rcvTime\n\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(&logging.ShortHeader{PacketNumber: 0x1337, PacketNumberLen: 2, KeyPhase: protocol.KeyPhaseZero}, protocol.ByteCount(len(packet.data)), []logging.Frame{&logging.PingFrame{}})\n\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeTrue())\n\t\t})\n\n\t\tIt(\"drops duplicate packets\", func() {\n\t\t\tpacket := getShortHeaderPacket(srcConnID, 0x37, nil)\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0x1337), protocol.PacketNumberLen2, protocol.KeyPhaseOne, []byte(\"foobar\"), nil)\n\t\t\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\t\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(0x1337), protocol.Encryption1RTT).Return(true)\n\t\t\tconn.receivedPacketHandler = rph\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketType1RTT, protocol.ByteCount(len(packet.data)), logging.PacketDropDuplicate)\n\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops a packet when unpacking fails\", func() {\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(nil, handshake.ErrDecryptionFailed)\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\texpectReplaceWithClosed()\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\tDestConnectionID: srcConnID,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t\tLength:           2 + 6,\n\t\t\t\t},\n\t\t\t\tPacketNumber:    0x1337,\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, []byte(\"foobar\"))\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeHandshake, p.Size(), logging.PacketDropPayloadDecryptError)\n\t\t\tconn.handlePacket(p)\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\t\t\t// make the go routine return\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.closeLocal(errors.New(\"close\"))\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"processes multiple received packets before sending one\", func() {\n\t\t\tconn.creationTime = time.Now()\n\t\t\tvar pn protocol.PacketNumber\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).DoAndReturn(func(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\t\t\t\tpn++\n\t\t\t\treturn pn, protocol.PacketNumberLen2, protocol.KeyPhaseZero, []byte{0} /* PADDING frame */, nil\n\t\t\t}).Times(3)\n\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(hdr *logging.ShortHeader, _ protocol.ByteCount, _ []logging.Frame) {\n\t\t\t}).Times(3)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version) // only expect a single call\n\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\tconn.handlePacket(getShortHeaderPacket(srcConnID, 0x1337+protocol.PacketNumber(i), []byte(\"foobar\")))\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\n\t\t\t// make the go routine return\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.closeLocal(errors.New(\"close\"))\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't processes multiple received packets before sending one before handshake completion\", func() {\n\t\t\tconn.handshakeComplete = false\n\t\t\tconn.creationTime = time.Now()\n\t\t\tvar pn protocol.PacketNumber\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).DoAndReturn(func(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\t\t\t\tpn++\n\t\t\t\treturn pn, protocol.PacketNumberLen4, protocol.KeyPhaseZero, []byte{0} /* PADDING frame */, nil\n\t\t\t}).Times(3)\n\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(hdr *logging.ShortHeader, _ protocol.ByteCount, _ []logging.Frame) {\n\t\t\t}).Times(3)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Times(3)\n\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\tconn.handlePacket(getShortHeaderPacket(srcConnID, 0x1337+protocol.PacketNumber(i), []byte(\"foobar\")))\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\n\t\t\t// make the go routine return\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.closeLocal(errors.New(\"close\"))\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes the connection when unpacking fails because the reserved bits were incorrect\", func() {\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0), protocol.PacketNumberLen(0), protocol.KeyPhaseBit(0), nil, wire.ErrInvalidReservedBits)\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terr := conn.run()\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\tExpect(err).To(BeAssignableToTypeOf(&qerr.TransportError{}))\n\t\t\t\tExpect(err.(*qerr.TransportError).ErrorCode).To(Equal(qerr.ProtocolViolation))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\texpectReplaceWithClosed()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tpacket := getShortHeaderPacket(srcConnID, 0x42, nil)\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.handlePacket(packet)\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"ignores packets when unpacking the header fails\", func() {\n\t\t\ttestErr := &headerParseError{errors.New(\"test error\")}\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0), protocol.PacketNumberLen(0), protocol.KeyPhaseBit(0), nil, testErr)\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\trunErr := make(chan error)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\trunErr <- conn.run()\n\t\t\t}()\n\t\t\texpectReplaceWithClosed()\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketType1RTT, gomock.Any(), logging.PacketDropHeaderParseError)\n\t\t\tconn.handlePacket(getShortHeaderPacket(srcConnID, 0x42, nil))\n\t\t\tConsistently(runErr).ShouldNot(Receive())\n\t\t\t// make the go routine return\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes the connection when unpacking fails because of an error other than a decryption error\", func() {\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0), protocol.PacketNumberLen(0), protocol.KeyPhaseBit(0), nil, &qerr.TransportError{ErrorCode: qerr.ConnectionIDLimitError})\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terr := conn.run()\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\tExpect(err).To(BeAssignableToTypeOf(&qerr.TransportError{}))\n\t\t\t\tExpect(err.(*qerr.TransportError).ErrorCode).To(Equal(qerr.ConnectionIDLimitError))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\texpectReplaceWithClosed()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.handlePacket(getShortHeaderPacket(srcConnID, 0x42, nil))\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"ignores packets with a different source connection ID\", func() {\n\t\t\thdr1 := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    1,\n\t\t\t}\n\t\t\thdr2 := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    2,\n\t\t\t}\n\t\t\tExpect(srcConnID).ToNot(Equal(hdr2.SrcConnectionID))\n\t\t\t// Send one packet, which might change the connection ID.\n\t\t\t// only EXPECT one call to the unpacker\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(&unpackedPacket{\n\t\t\t\tencryptionLevel: protocol.Encryption1RTT,\n\t\t\t\thdr:             hdr1,\n\t\t\t\tdata:            []byte{0}, // one PADDING frame\n\t\t\t}, nil)\n\t\t\tp1 := getLongHeaderPacket(hdr1, nil)\n\t\t\ttracer.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(p1.data)), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(p1)).To(BeTrue())\n\t\t\t// The next packet has to be ignored, since the source connection ID doesn't match.\n\t\t\tp2 := getLongHeaderPacket(hdr2, nil)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeInitial, protocol.ByteCount(len(p2.data)), logging.PacketDropUnknownConnectionID)\n\t\t\tExpect(conn.handlePacketImpl(p2)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"queues undecryptable packets\", func() {\n\t\t\tconn.handshakeComplete = false\n\t\t\thdr := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    1,\n\t\t\t}\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(nil, handshake.ErrKeysNotYetAvailable)\n\t\t\tpacket := getLongHeaderPacket(hdr, nil)\n\t\t\ttracer.EXPECT().BufferedPacket(logging.PacketTypeHandshake, packet.Size())\n\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeFalse())\n\t\t\tExpect(conn.undecryptablePackets).To(Equal([]receivedPacket{packet}))\n\t\t})\n\n\t\tContext(\"updating the remote address\", func() {\n\t\t\tIt(\"doesn't support connection migration\", func() {\n\t\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(10), protocol.PacketNumberLen2, protocol.KeyPhaseZero, []byte{0} /* one PADDING frame */, nil)\n\t\t\t\tpacket := getShortHeaderPacket(srcConnID, 0x42, nil)\n\t\t\t\tpacket.remoteAddr = &net.IPAddr{IP: net.IPv4(192, 168, 0, 100)}\n\t\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet.data)), gomock.Any())\n\t\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeTrue())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"coalesced packets\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\ttracer.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\t\t})\n\n\t\t\tgetPacketWithLength := func(connID protocol.ConnectionID, length protocol.ByteCount) (int /* header length */, receivedPacket) {\n\t\t\t\thdr := &wire.ExtendedHeader{\n\t\t\t\t\tHeader: wire.Header{\n\t\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\t\tDestConnectionID: connID,\n\t\t\t\t\t\tSrcConnectionID:  destConnID,\n\t\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t\t\tLength:           length,\n\t\t\t\t\t},\n\t\t\t\t\tPacketNumberLen: protocol.PacketNumberLen3,\n\t\t\t\t}\n\t\t\t\thdrLen := hdr.GetLength(conn.version)\n\t\t\t\tb := make([]byte, 1)\n\t\t\t\trand.Read(b)\n\t\t\t\tpacket := getLongHeaderPacket(hdr, bytes.Repeat(b, int(length)-3))\n\t\t\t\treturn int(hdrLen), packet\n\t\t\t}\n\n\t\t\tIt(\"cuts packets to the right length\", func() {\n\t\t\t\thdrLen, packet := getPacketWithLength(srcConnID, 456)\n\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\tExpect(data).To(HaveLen(hdrLen + 456 - 3))\n\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\thdr:             &wire.ExtendedHeader{Header: wire.Header{}},\n\t\t\t\t\t}, nil\n\t\t\t\t})\n\t\t\t\tcryptoSetup.EXPECT().DiscardInitialKeys()\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionInitial)\n\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet.data)), gomock.Any())\n\t\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeTrue())\n\t\t\t})\n\n\t\t\tIt(\"handles coalesced packets\", func() {\n\t\t\t\thdrLen1, packet1 := getPacketWithLength(srcConnID, 456)\n\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\tExpect(data).To(HaveLen(hdrLen1 + 456 - 3))\n\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\thdr: &wire.ExtendedHeader{\n\t\t\t\t\t\t\tPacketNumber: 1,\n\t\t\t\t\t\t\tHeader:       wire.Header{SrcConnectionID: destConnID},\n\t\t\t\t\t\t},\n\t\t\t\t\t}, nil\n\t\t\t\t})\n\t\t\t\thdrLen2, packet2 := getPacketWithLength(srcConnID, 123)\n\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\tExpect(data).To(HaveLen(hdrLen2 + 123 - 3))\n\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\thdr: &wire.ExtendedHeader{\n\t\t\t\t\t\t\tPacketNumber: 2,\n\t\t\t\t\t\t\tHeader:       wire.Header{SrcConnectionID: destConnID},\n\t\t\t\t\t\t},\n\t\t\t\t\t}, nil\n\t\t\t\t})\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionInitial).AnyTimes()\n\t\t\t\tcryptoSetup.EXPECT().DiscardInitialKeys().AnyTimes()\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet1.data)), gomock.Any()),\n\t\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet2.data)), gomock.Any()),\n\t\t\t\t)\n\t\t\t\tpacket1.data = append(packet1.data, packet2.data...)\n\t\t\t\tExpect(conn.handlePacketImpl(packet1)).To(BeTrue())\n\t\t\t})\n\n\t\t\tIt(\"works with undecryptable packets\", func() {\n\t\t\t\tconn.handshakeComplete = false\n\t\t\t\thdrLen1, packet1 := getPacketWithLength(srcConnID, 456)\n\t\t\t\thdrLen2, packet2 := getPacketWithLength(srcConnID, 123)\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(nil, handshake.ErrKeysNotYetAvailable),\n\t\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\t\tExpect(data).To(HaveLen(hdrLen2 + 123 - 3))\n\t\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\t\thdr:             &wire.ExtendedHeader{Header: wire.Header{}},\n\t\t\t\t\t\t}, nil\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionInitial).AnyTimes()\n\t\t\t\tcryptoSetup.EXPECT().DiscardInitialKeys().AnyTimes()\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\ttracer.EXPECT().BufferedPacket(gomock.Any(), protocol.ByteCount(len(packet1.data))),\n\t\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet2.data)), gomock.Any()),\n\t\t\t\t)\n\t\t\t\tpacket1.data = append(packet1.data, packet2.data...)\n\t\t\t\tExpect(conn.handlePacketImpl(packet1)).To(BeTrue())\n\n\t\t\t\tExpect(conn.undecryptablePackets).To(HaveLen(1))\n\t\t\t\tExpect(conn.undecryptablePackets[0].data).To(HaveLen(hdrLen1 + 456 - 3))\n\t\t\t})\n\n\t\t\tIt(\"ignores coalesced packet parts if the destination connection IDs don't match\", func() {\n\t\t\t\twrongConnID := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\t\tExpect(srcConnID).ToNot(Equal(wrongConnID))\n\t\t\t\thdrLen1, packet1 := getPacketWithLength(srcConnID, 456)\n\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\tExpect(data).To(HaveLen(hdrLen1 + 456 - 3))\n\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\thdr:             &wire.ExtendedHeader{Header: wire.Header{}},\n\t\t\t\t\t}, nil\n\t\t\t\t})\n\t\t\t\t_, packet2 := getPacketWithLength(wrongConnID, 123)\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionInitial).AnyTimes()\n\t\t\t\tcryptoSetup.EXPECT().DiscardInitialKeys().AnyTimes()\n\t\t\t\t// don't EXPECT any more calls to unpacker.UnpackLongHeader()\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet1.data)), gomock.Any()),\n\t\t\t\t\ttracer.EXPECT().DroppedPacket(gomock.Any(), protocol.ByteCount(len(packet2.data)), logging.PacketDropUnknownConnectionID),\n\t\t\t\t)\n\t\t\t\tpacket1.data = append(packet1.data, packet2.data...)\n\t\t\t\tExpect(conn.handlePacketImpl(packet1)).To(BeTrue())\n\t\t\t})\n\t\t})\n\t})\n\n\tContext(\"sending packets\", func() {\n\t\tvar (\n\t\t\tconnDone chan struct{}\n\t\t\tsender   *MockSender\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\tsender = NewMockSender(mockCtrl)\n\t\t\tsender.EXPECT().Run()\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tconn.sendQueue = sender\n\t\t\tconnDone = make(chan struct{})\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tsender.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t\tEventually(connDone).Should(BeClosed())\n\t\t})\n\n\t\trunConn := func() {\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t\tclose(connDone)\n\t\t\t}()\n\t\t}\n\n\t\tIt(\"sends packets\", func() {\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tconn.sentPacketHandler = sph\n\t\t\trunConn()\n\t\t\tp := shortHeaderPacket{\n\t\t\t\tDestConnID:      protocol.ParseConnectionID([]byte{1, 2, 3}),\n\t\t\t\tPacketNumber:    1337,\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen3,\n\t\t\t\tKeyPhase:        protocol.KeyPhaseOne,\n\t\t\t}\n\t\t\texpectAppendPacket(packer, p, []byte(\"foobar\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\t\tsent := make(chan struct{})\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(sent) })\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(&logging.ShortHeader{\n\t\t\t\tDestConnectionID: p.DestConnID,\n\t\t\t\tPacketNumber:     p.PacketNumber,\n\t\t\t\tPacketNumberLen:  p.PacketNumberLen,\n\t\t\t\tKeyPhase:         p.KeyPhase,\n\t\t\t}, gomock.Any(), nil, []logging.Frame{})\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(sent).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't send packets if there's nothing to send\", func() {\n\t\t\tconn.handshakeConfirmed = true\n\t\t\trunConn()\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\t\tconn.receivedPacketHandler.ReceivedPacket(0x035e, protocol.ECNNon, protocol.Encryption1RTT, time.Now(), true)\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure there are no calls to mconn.Write()\n\t\t})\n\n\t\tIt(\"sends ACK only packets\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAck)\n\t\t\tdone := make(chan struct{})\n\t\t\tpacker.EXPECT().PackCoalescedPacket(true, gomock.Any(), conn.version).Do(func(bool, protocol.ByteCount, protocol.VersionNumber) { close(done) })\n\t\t\tconn.sentPacketHandler = sph\n\t\t\trunConn()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"adds a BLOCKED frame when it is connection-level flow control blocked\", func() {\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tfc := mocks.NewMockConnectionFlowController(mockCtrl)\n\t\t\tfc.EXPECT().IsNewlyBlocked().Return(true, protocol.ByteCount(1337))\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 13}, []byte(\"foobar\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\t\tconn.connFlowController = fc\n\t\t\trunConn()\n\t\t\tsent := make(chan struct{})\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(sent) })\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), nil, []logging.Frame{})\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(sent).Should(BeClosed())\n\t\t\tframes, _ := conn.framer.AppendControlFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(Equal([]ackhandler.Frame{{Frame: &logging.DataBlockedFrame{MaximumData: 1337}}}))\n\t\t})\n\n\t\tIt(\"doesn't send when the SentPacketHandler doesn't allow it\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone).AnyTimes()\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tconn.sentPacketHandler = sph\n\t\t\trunConn()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t})\n\n\t\tfor _, enc := range []protocol.EncryptionLevel{protocol.EncryptionInitial, protocol.EncryptionHandshake, protocol.Encryption1RTT} {\n\t\t\tencLevel := enc\n\n\t\t\tContext(fmt.Sprintf(\"sending %s probe packets\", encLevel), func() {\n\t\t\t\tvar sendMode ackhandler.SendMode\n\t\t\t\tvar getFrame func(protocol.ByteCount, protocol.VersionNumber) wire.Frame\n\n\t\t\t\tBeforeEach(func() {\n\t\t\t\t\t//nolint:exhaustive\n\t\t\t\t\tswitch encLevel {\n\t\t\t\t\tcase protocol.EncryptionInitial:\n\t\t\t\t\t\tsendMode = ackhandler.SendPTOInitial\n\t\t\t\t\t\tgetFrame = conn.retransmissionQueue.GetInitialFrame\n\t\t\t\t\tcase protocol.EncryptionHandshake:\n\t\t\t\t\t\tsendMode = ackhandler.SendPTOHandshake\n\t\t\t\t\t\tgetFrame = conn.retransmissionQueue.GetHandshakeFrame\n\t\t\t\t\tcase protocol.Encryption1RTT:\n\t\t\t\t\t\tsendMode = ackhandler.SendPTOAppData\n\t\t\t\t\t\tgetFrame = conn.retransmissionQueue.GetAppDataFrame\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tIt(\"sends a probe packet\", func() {\n\t\t\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(sendMode)\n\t\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\t\t\t\t\tsph.EXPECT().QueueProbePacket(encLevel)\n\t\t\t\t\tp := getCoalescedPacket(123, enc != protocol.Encryption1RTT)\n\t\t\t\t\tpacker.EXPECT().MaybePackProbePacket(encLevel, gomock.Any(), conn.version).Return(p, nil)\n\t\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, _ protocol.EncryptionLevel, _ protocol.ByteCount, _ bool) {\n\t\t\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(123)))\n\t\t\t\t\t})\n\t\t\t\t\tconn.sentPacketHandler = sph\n\t\t\t\t\trunConn()\n\t\t\t\t\tsent := make(chan struct{})\n\t\t\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(sent) })\n\t\t\t\t\tif enc == protocol.Encryption1RTT {\n\t\t\t\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), p.shortHdrPacket.Length, gomock.Any(), gomock.Any())\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttracer.EXPECT().SentLongHeaderPacket(gomock.Any(), p.longHdrPackets[0].length, gomock.Any(), gomock.Any())\n\t\t\t\t\t}\n\t\t\t\t\tconn.scheduleSending()\n\t\t\t\t\tEventually(sent).Should(BeClosed())\n\t\t\t\t})\n\n\t\t\t\tIt(\"sends a PING as a probe packet\", func() {\n\t\t\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(sendMode)\n\t\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\t\t\t\t\tsph.EXPECT().QueueProbePacket(encLevel).Return(false)\n\t\t\t\t\tp := getCoalescedPacket(123, enc != protocol.Encryption1RTT)\n\t\t\t\t\tpacker.EXPECT().MaybePackProbePacket(encLevel, gomock.Any(), conn.version).Return(p, nil)\n\t\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, _ protocol.EncryptionLevel, _ protocol.ByteCount, _ bool) {\n\t\t\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(123)))\n\t\t\t\t\t})\n\t\t\t\t\tconn.sentPacketHandler = sph\n\t\t\t\t\trunConn()\n\t\t\t\t\tsent := make(chan struct{})\n\t\t\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(sent) })\n\t\t\t\t\tif enc == protocol.Encryption1RTT {\n\t\t\t\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), p.shortHdrPacket.Length, gomock.Any(), gomock.Any())\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttracer.EXPECT().SentLongHeaderPacket(gomock.Any(), p.longHdrPackets[0].length, gomock.Any(), gomock.Any())\n\t\t\t\t\t}\n\t\t\t\t\tconn.scheduleSending()\n\t\t\t\t\tEventually(sent).Should(BeClosed())\n\t\t\t\t\t// We're using a mock packet packer in this test.\n\t\t\t\t\t// We therefore need to test separately that the PING was actually queued.\n\t\t\t\t\tExpect(getFrame(1000, protocol.Version1)).To(BeAssignableToTypeOf(&wire.PingFrame{}))\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t})\n\n\tContext(\"packet pacing\", func() {\n\t\tvar (\n\t\t\tsph    *mockackhandler.MockSentPacketHandler\n\t\t\tsender *MockSender\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tsph = mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tconn.handshakeComplete = true\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tsender = NewMockSender(mockCtrl)\n\t\t\tsender.EXPECT().Run()\n\t\t\tconn.sendQueue = sender\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t// make the go routine return\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tsender.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sends multiple packets one by one immediately\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited)\n\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(time.Hour))\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, []byte(\"packet10\"))\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 11}, []byte(\"packet11\"))\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(b *packetBuffer, _ protocol.ByteCount) {\n\t\t\t\tExpect(b.Data).To(Equal([]byte(\"packet10\")))\n\t\t\t})\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(b *packetBuffer, _ protocol.ByteCount) {\n\t\t\t\tExpect(b.Data).To(Equal([]byte(\"packet11\")))\n\t\t\t})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 2 packets are sent\n\t\t})\n\n\t\tIt(\"sends multiple packets one by one immediately, with GSO\", func() {\n\t\t\tenableGSO()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(3)\n\t\t\tpayload1 := make([]byte, conn.mtuDiscoverer.CurrentSize())\n\t\t\trand.Read(payload1)\n\t\t\tpayload2 := make([]byte, conn.mtuDiscoverer.CurrentSize())\n\t\t\trand.Read(payload2)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, payload1)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 11}, payload2)\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any()).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), conn.mtuDiscoverer.CurrentSize()).Do(func(b *packetBuffer, l protocol.ByteCount) {\n\t\t\t\tExpect(b.Data).To(Equal(append(payload1, payload2...)))\n\t\t\t})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 2 packets are sent\n\t\t})\n\n\t\tIt(\"stops appending packets when a smaller packet is packed, with GSO\", func() {\n\t\t\tenableGSO()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\t\t\tpayload1 := make([]byte, conn.mtuDiscoverer.CurrentSize())\n\t\t\trand.Read(payload1)\n\t\t\tpayload2 := make([]byte, conn.mtuDiscoverer.CurrentSize()-1)\n\t\t\trand.Read(payload2)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, payload1)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 11}, payload2)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), conn.mtuDiscoverer.CurrentSize()).Do(func(b *packetBuffer, l protocol.ByteCount) {\n\t\t\t\tExpect(b.Data).To(Equal(append(payload1, payload2...)))\n\t\t\t})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 2 packets are sent\n\t\t})\n\n\t\tIt(\"sends multiple packets, when the pacer allows immediate sending\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(2)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, []byte(\"packet10\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any())\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 1 packet is sent\n\t\t})\n\n\t\tIt(\"allows an ACK to be sent when pacing limited\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(time.Hour))\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited)\n\t\t\tpacker.EXPECT().PackAckOnlyPacket(gomock.Any(), conn.version).Return(shortHeaderPacket{PacketNumber: 123}, getPacketBuffer(), nil)\n\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any())\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 1 packet is sent\n\t\t})\n\n\t\t// when becoming congestion limited, at some point the SendMode will change from SendAny to SendAck\n\t\t// we shouldn't send the ACK in the same run\n\t\tIt(\"doesn't send an ACK right after becoming congestion limited\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAck)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 100}, []byte(\"packet100\"))\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any())\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 1 packet is sent\n\t\t})\n\n\t\tIt(\"paces packets\", func() {\n\t\t\tpacingDelay := scaleDuration(100 * time.Millisecond)\n\t\t\tgomock.InOrder(\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny),\n\t\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 100}, []byte(\"packet100\")),\n\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited),\n\t\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(pacingDelay)),\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny),\n\t\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 101}, []byte(\"packet101\")),\n\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited),\n\t\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(time.Hour)),\n\t\t\t)\n\t\t\twritten := make(chan struct{}, 2)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} }).Times(2)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(HaveLen(1))\n\t\t\tConsistently(written, pacingDelay/2).Should(HaveLen(1))\n\t\t\tEventually(written, 2*pacingDelay).Should(HaveLen(2))\n\t\t})\n\n\t\tIt(\"sends multiple packets at once\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Times(3)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(3)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited)\n\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(time.Hour))\n\t\t\tfor pn := protocol.PacketNumber(1000); pn < 1003; pn++ {\n\t\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: pn}, []byte(\"packet\"))\n\t\t\t}\n\t\t\twritten := make(chan struct{}, 3)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} }).Times(3)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(HaveLen(3))\n\t\t})\n\n\t\tfor _, withGSO := range []bool{false, true} {\n\t\t\twithGSO := withGSO\n\t\t\tIt(fmt.Sprintf(\"doesn't try to send if the send queue is full: %t\", withGSO), func() {\n\t\t\t\tif withGSO {\n\t\t\t\t\tenableGSO()\n\t\t\t\t}\n\t\t\t\tavailable := make(chan struct{}, 1)\n\t\t\t\tsender.EXPECT().WouldBlock().Return(true)\n\t\t\t\tsender.EXPECT().Available().Return(available)\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\t\tconn.run()\n\t\t\t\t}()\n\t\t\t\tconn.scheduleSending()\n\t\t\t\ttime.Sleep(scaleDuration(50 * time.Millisecond))\n\n\t\t\t\twritten := make(chan struct{})\n\t\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1000}, []byte(\"packet1000\"))\n\t\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { close(written) })\n\t\t\t\tavailable <- struct{}{}\n\t\t\t\tEventually(written).Should(BeClosed())\n\t\t\t})\n\t\t}\n\n\t\tIt(\"stops sending when there are new packets to receive\", func() {\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\n\t\t\twritten := make(chan struct{})\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(time.Time, protocol.PacketNumber, protocol.PacketNumber, []ackhandler.StreamFrame, []ackhandler.Frame, protocol.EncryptionLevel, protocol.ByteCount, bool) {\n\t\t\t\tsph.EXPECT().ReceivedBytes(gomock.Any())\n\t\t\t\tconn.handlePacket(receivedPacket{buffer: getPacketBuffer()})\n\t\t\t})\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, []byte(\"packet10\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { close(written) })\n\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(scaleDuration(50 * time.Millisecond))\n\n\t\t\tEventually(written).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"stops sending when the send queue is full\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1000}, []byte(\"packet1000\"))\n\t\t\twritten := make(chan struct{}, 1)\n\t\t\tsender.EXPECT().WouldBlock()\n\t\t\tsender.EXPECT().WouldBlock().Return(true).Times(2)\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} })\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tavailable := make(chan struct{}, 1)\n\t\t\tsender.EXPECT().Available().Return(available)\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(Receive())\n\t\t\ttime.Sleep(scaleDuration(50 * time.Millisecond))\n\n\t\t\t// now make room in the send queue\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1001}, []byte(\"packet1001\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} })\n\t\t\tavailable <- struct{}{}\n\t\t\tEventually(written).Should(Receive())\n\n\t\t\t// The send queue is not full any more. Sending on the available channel should have no effect.\n\t\t\tavailable <- struct{}{}\n\t\t\ttime.Sleep(scaleDuration(50 * time.Millisecond))\n\t\t})\n\n\t\tIt(\"doesn't set a pacing timer when there is no data to send\", func() {\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\t// don't EXPECT any calls to mconn.Write()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending() // no packet will get sent\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t})\n\n\t\tIt(\"sends a Path MTU probe packet\", func() {\n\t\t\tmtuDiscoverer := NewMockMTUDiscoverer(mockCtrl)\n\t\t\tconn.mtuDiscoverer = mtuDiscoverer\n\t\t\tconn.config.DisablePathMTUDiscovery = false\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\t\t\twritten := make(chan struct{}, 1)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} })\n\t\t\tmtuDiscoverer.EXPECT().ShouldSendProbe(gomock.Any()).Return(true)\n\t\t\tping := ackhandler.Frame{Frame: &wire.PingFrame{}}\n\t\t\tmtuDiscoverer.EXPECT().GetPing().Return(ping, protocol.ByteCount(1234))\n\t\t\tpacker.EXPECT().PackMTUProbePacket(ping, protocol.ByteCount(1234), conn.version).Return(shortHeaderPacket{PacketNumber: 1}, getPacketBuffer(), nil)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(Receive())\n\t\t\tmtuDiscoverer.EXPECT().CurrentSize().Return(protocol.ByteCount(1234))\n\t\t})\n\t})\n\n\tContext(\"scheduling sending\", func() {\n\t\tvar sender *MockSender\n\n\t\tBeforeEach(func() {\n\t\t\tsender = NewMockSender(mockCtrl)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Run()\n\t\t\tconn.sendQueue = sender\n\t\t\tconn.handshakeConfirmed = true\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t// make the go routine return\n\t\t\texpectReplaceWithClosed()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tsender.EXPECT().Close()\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sends when scheduleSending is called\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tconn.sentPacketHandler = sph\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1}, []byte(\"packet1\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\t// don't EXPECT any calls to mconn.Write()\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t// only EXPECT calls after scheduleSending is called\n\t\t\twritten := make(chan struct{})\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(written) })\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sets the timer to the ack timer\", func() {\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1234}, []byte(\"packet1234\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, _ protocol.EncryptionLevel, _ protocol.ByteCount, _ bool) {\n\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(1234)))\n\t\t\t})\n\t\t\tconn.sentPacketHandler = sph\n\t\t\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\t\t\trph.EXPECT().GetAlarmTimeout().Return(time.Now().Add(10 * time.Millisecond))\n\t\t\t// make the run loop wait\n\t\t\trph.EXPECT().GetAlarmTimeout().Return(time.Now().Add(time.Hour)).MaxTimes(1)\n\t\t\tconn.receivedPacketHandler = rph\n\n\t\t\twritten := make(chan struct{})\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(written) })\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tEventually(written).Should(BeClosed())\n\t\t})\n\t})\n\n\tIt(\"sends coalesced packets before the handshake is confirmed\", func() {\n\t\tconn.handshakeComplete = false\n\t\tconn.handshakeConfirmed = false\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tconn.sentPacketHandler = sph\n\t\tbuffer := getPacketBuffer()\n\t\tbuffer.Data = append(buffer.Data, []byte(\"foobar\")...)\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Return(&coalescedPacket{\n\t\t\tbuffer: buffer,\n\t\t\tlongHdrPackets: []*longHeaderPacket{\n\t\t\t\t{\n\t\t\t\t\theader: &wire.ExtendedHeader{\n\t\t\t\t\t\tHeader:       wire.Header{Type: protocol.PacketTypeInitial},\n\t\t\t\t\t\tPacketNumber: 13,\n\t\t\t\t\t},\n\t\t\t\t\tlength: 123,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\theader: &wire.ExtendedHeader{\n\t\t\t\t\t\tHeader:       wire.Header{Type: protocol.PacketTypeHandshake},\n\t\t\t\t\t\tPacketNumber: 37,\n\t\t\t\t\t},\n\t\t\t\t\tlength: 1234,\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\n\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\tsph.EXPECT().TimeUntilSend().Return(time.Now()).AnyTimes()\n\t\tgomock.InOrder(\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, encLevel protocol.EncryptionLevel, size protocol.ByteCount, _ bool) {\n\t\t\t\tExpect(encLevel).To(Equal(protocol.EncryptionInitial))\n\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(13)))\n\t\t\t\tExpect(size).To(BeEquivalentTo(123))\n\t\t\t}),\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, encLevel protocol.EncryptionLevel, size protocol.ByteCount, _ bool) {\n\t\t\t\tExpect(encLevel).To(Equal(protocol.EncryptionHandshake))\n\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(37)))\n\t\t\t\tExpect(size).To(BeEquivalentTo(1234))\n\t\t\t}),\n\t\t)\n\t\tgomock.InOrder(\n\t\t\ttracer.EXPECT().SentLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(hdr *wire.ExtendedHeader, _ protocol.ByteCount, _ *wire.AckFrame, _ []logging.Frame) {\n\t\t\t\tExpect(hdr.Type).To(Equal(protocol.PacketTypeInitial))\n\t\t\t}),\n\t\t\ttracer.EXPECT().SentLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(hdr *wire.ExtendedHeader, _ protocol.ByteCount, _ *wire.AckFrame, _ []logging.Frame) {\n\t\t\t\tExpect(hdr.Type).To(Equal(protocol.PacketTypeHandshake))\n\t\t\t}),\n\t\t)\n\n\t\tsent := make(chan struct{})\n\t\tmconn.EXPECT().Write([]byte(\"foobar\"), protocol.ByteCount(6)).Do(func([]byte, protocol.ByteCount) { close(sent) })\n\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tconn.run()\n\t\t}()\n\n\t\tconn.scheduleSending()\n\t\tEventually(sent).Should(BeClosed())\n\n\t\t// make sure the go routine returns\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t})\n\n\tIt(\"cancels the HandshakeComplete context when the handshake completes\", func() {\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\tfinishHandshake := make(chan struct{})\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tconn.sentPacketHandler = sph\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\tsph.EXPECT().SendMode(gomock.Any()).AnyTimes()\n\t\tsph.EXPECT().DropPackets(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().SetHandshakeConfirmed()\n\t\tconnRunner.EXPECT().Retire(clientDestConnID)\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\t<-finishHandshake\n\t\t\tcryptoSetup.EXPECT().StartHandshake()\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete})\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\t\tcryptoSetup.EXPECT().GetSessionTicket()\n\t\t\tconn.run()\n\t\t}()\n\t\thandshakeCtx := conn.HandshakeComplete()\n\t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n\t\tclose(finishHandshake)\n\t\tEventually(handshakeCtx).Should(BeClosed())\n\t\t// make sure the go routine returns\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t})\n\n\tIt(\"sends a session ticket when the handshake completes\", func() {\n\t\tconst size = protocol.MaxPostHandshakeCryptoFrameSize * 3 / 2\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\tfinishHandshake := make(chan struct{})\n\t\tconnRunner.EXPECT().Retire(clientDestConnID)\n\t\tconn.sentPacketHandler.DropPackets(protocol.EncryptionInitial)\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\t<-finishHandshake\n\t\t\tcryptoSetup.EXPECT().StartHandshake()\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete})\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\t\tcryptoSetup.EXPECT().GetSessionTicket().Return(make([]byte, size), nil)\n\t\t\tconn.run()\n\t\t}()\n\n\t\thandshakeCtx := conn.HandshakeComplete()\n\t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n\t\tclose(finishHandshake)\n\t\tvar frames []ackhandler.Frame\n\t\tEventually(func() []ackhandler.Frame {\n\t\t\tframes, _ = conn.framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\treturn frames\n\t\t}).ShouldNot(BeEmpty())\n\t\tvar count int\n\t\tvar s int\n\t\tfor _, f := range frames {\n\t\t\tif cf, ok := f.Frame.(*wire.CryptoFrame); ok {\n\t\t\t\tcount++\n\t\t\t\ts += len(cf.Data)\n\t\t\t\tExpect(f.Frame.Length(conn.version)).To(BeNumerically(\"<=\", protocol.MaxPostHandshakeCryptoFrameSize))\n\t\t\t}\n\t\t}\n\t\tExpect(size).To(BeEquivalentTo(s))\n\t\t// make sure the go routine returns\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t})\n\n\tIt(\"doesn't cancel the HandshakeComplete context when the handshake fails\", func() {\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake()\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tconn.run()\n\t\t}()\n\t\thandshakeCtx := conn.HandshakeComplete()\n\t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\tconn.closeLocal(errors.New(\"handshake error\"))\n\t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t})\n\n\tIt(\"sends a HANDSHAKE_DONE frame when the handshake completes\", func() {\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\tsph.EXPECT().SetHandshakeConfirmed()\n\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\tconn.sentPacketHandler = sph\n\t\tdone := make(chan struct{})\n\t\tconnRunner.EXPECT().Retire(clientDestConnID)\n\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *packetBuffer, _ protocol.ByteCount, v protocol.VersionNumber) (shortHeaderPacket, error) {\n\t\t\tframes, _ := conn.framer.AppendControlFrames(nil, protocol.MaxByteCount, v)\n\t\t\tExpect(frames).ToNot(BeEmpty())\n\t\t\tExpect(frames[0].Frame).To(BeEquivalentTo(&wire.HandshakeDoneFrame{}))\n\t\t\tdefer close(done)\n\t\t\treturn shortHeaderPacket{}, nil\n\t\t})\n\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().DropPackets(protocol.EncryptionHandshake)\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake()\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete})\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\t\tcryptoSetup.EXPECT().GetSessionTicket()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.run()\n\t\t}()\n\t\tEventually(done).Should(BeClosed())\n\t\t// make sure the go routine returns\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t})\n\n\tIt(\"doesn't return a run error when closing\", func() {\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tExpect(conn.run()).To(Succeed())\n\t\t\tclose(done)\n\t\t}()\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(done).Should(BeClosed())\n\t\tExpect(context.Cause(conn.Context())).To(MatchError(context.Canceled))\n\t})\n\n\tIt(\"passes errors to the connection runner\", func() {\n\t\ttestErr := errors.New(\"handshake error\")\n\t\texpectedErr := &qerr.ApplicationError{\n\t\t\tErrorCode:    0x1337,\n\t\t\tErrorMessage: testErr.Error(),\n\t\t}\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\terr := conn.run()\n\t\t\tExpect(err).To(MatchError(expectedErr))\n\t\t\tclose(done)\n\t\t}()\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tExpect(conn.CloseWithError(0x1337, testErr.Error())).To(Succeed())\n\t\tEventually(done).Should(BeClosed())\n\t\tExpect(context.Cause(conn.Context())).To(MatchError(expectedErr))\n\t})\n\n\tContext(\"transport parameters\", func() {\n\t\tIt(\"processes transport parameters received from the client\", func() {\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tMaxIdleTimeout:                90 * time.Second,\n\t\t\t\tInitialMaxStreamDataBidiLocal: 0x5000,\n\t\t\t\tInitialMaxData:                0x5000,\n\t\t\t\tActiveConnectionIDLimit:       3,\n\t\t\t\t// marshaling always sets it to this value\n\t\t\t\tMaxUDPPayloadSize:         protocol.MaxPacketBufferSize,\n\t\t\t\tInitialSourceConnectionID: destConnID,\n\t\t\t}\n\t\t\tstreamManager.EXPECT().UpdateLimits(params)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).MaxTimes(3)\n\t\t\tExpect(conn.earlyConnReady()).ToNot(BeClosed())\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params)\n\t\t\tconn.handleTransportParameters(params)\n\t\t\tExpect(conn.earlyConnReady()).To(BeClosed())\n\t\t})\n\t})\n\n\tContext(\"keep-alives\", func() {\n\t\tsetRemoteIdleTimeout := func(t time.Duration) {\n\t\t\tstreamManager.EXPECT().UpdateLimits(gomock.Any())\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(gomock.Any())\n\t\t\tconn.handleTransportParameters(&wire.TransportParameters{\n\t\t\t\tMaxIdleTimeout:            t,\n\t\t\t\tInitialSourceConnectionID: destConnID,\n\t\t\t})\n\t\t}\n\n\t\trunConn := func() {\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t}\n\n\t\tBeforeEach(func() {\n\t\t\tconn.config.MaxIdleTimeout = 30 * time.Second\n\t\t\tconn.config.KeepAlivePeriod = 15 * time.Second\n\t\t\tconn.receivedPacketHandler.ReceivedPacket(0, protocol.ECNNon, protocol.EncryptionHandshake, time.Now(), true)\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t// make the go routine return\n\t\t\texpectReplaceWithClosed()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sends a PING as a keep-alive after half the idle timeout\", func() {\n\t\t\tsetRemoteIdleTimeout(5 * time.Second)\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-5 * time.Second / 2)\n\t\t\tsent := make(chan struct{})\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Do(func(bool, protocol.ByteCount, protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tclose(sent)\n\t\t\t\treturn nil, nil\n\t\t\t})\n\t\t\trunConn()\n\t\t\tEventually(sent).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sends a PING after a maximum of protocol.MaxKeepAliveInterval\", func() {\n\t\t\tconn.config.MaxIdleTimeout = time.Hour\n\t\t\tsetRemoteIdleTimeout(time.Hour)\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-protocol.MaxKeepAliveInterval).Add(-time.Millisecond)\n\t\t\tsent := make(chan struct{})\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Do(func(bool, protocol.ByteCount, protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tclose(sent)\n\t\t\t\treturn nil, nil\n\t\t\t})\n\t\t\trunConn()\n\t\t\tEventually(sent).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't send a PING packet if keep-alive is disabled\", func() {\n\t\t\tsetRemoteIdleTimeout(5 * time.Second)\n\t\t\tconn.config.KeepAlivePeriod = 0\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-time.Second * 5 / 2)\n\t\t\trunConn()\n\t\t\t// don't EXPECT() any calls to mconn.Write()\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t})\n\n\t\tIt(\"doesn't send a PING if the handshake isn't completed yet\", func() {\n\t\t\tconn.config.HandshakeIdleTimeout = time.Hour\n\t\t\tconn.handshakeComplete = false\n\t\t\t// Needs to be shorter than our idle timeout.\n\t\t\t// Otherwise we'll try to send a CONNECTION_CLOSE.\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-20 * time.Second)\n\t\t\trunConn()\n\t\t\t// don't EXPECT() any calls to mconn.Write()\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t})\n\n\t\tIt(\"send PING as keep-alive earliest after 1.5 times the PTO\", func() {\n\t\t\tconn.config.KeepAlivePeriod = time.Microsecond\n\t\t\tpto := conn.rttStats.PTO(true)\n\t\t\tconn.lastPacketReceivedTime = time.Now()\n\t\t\tsentPingTimeChan := make(chan time.Time)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Do(func(bool, protocol.ByteCount, protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tsentPingTimeChan <- time.Now()\n\t\t\t\treturn nil, nil\n\t\t\t})\n\t\t\trunConn()\n\t\t\tsentPingTime := <-sentPingTimeChan\n\t\t\tExpect(sentPingTime.Sub(conn.lastPacketReceivedTime)).To(BeNumerically(\">\", pto*3/2))\n\t\t})\n\t})\n\n\tContext(\"timeouts\", func() {\n\t\tBeforeEach(func() {\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t})\n\n\t\tIt(\"times out due to no network activity\", func() {\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).Times(2)\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-time.Hour)\n\t\t\tdone := make(chan struct{})\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tExpect(e).To(MatchError(&qerr.IdleTimeoutError{}))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terr := conn.run()\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tExpect(ok).To(BeTrue())\n\t\t\t\tExpect(nerr.Timeout()).To(BeTrue())\n\t\t\t\tExpect(err).To(MatchError(qerr.ErrIdleTimeout))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"times out due to non-completed handshake\", func() {\n\t\t\tconn.handshakeComplete = false\n\t\t\tconn.creationTime = time.Now().Add(-protocol.DefaultHandshakeTimeout).Add(-time.Second)\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).Times(2)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tExpect(e).To(MatchError(&HandshakeTimeoutError{}))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terr := conn.run()\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tExpect(ok).To(BeTrue())\n\t\t\t\tExpect(nerr.Timeout()).To(BeTrue())\n\t\t\t\tExpect(err).To(MatchError(qerr.ErrHandshakeTimeout))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"does not use the idle timeout before the handshake complete\", func() {\n\t\t\tconn.handshakeComplete = false\n\t\t\tconn.config.HandshakeIdleTimeout = 9999 * time.Second\n\t\t\tconn.config.MaxIdleTimeout = 9999 * time.Second\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-time.Minute)\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(e *qerr.ApplicationError, _ protocol.ByteCount, _ protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tExpect(e.ErrorCode).To(BeZero())\n\t\t\t\treturn &coalescedPacket{buffer: getPacketBuffer()}, nil\n\t\t\t})\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tidleTimeout := &IdleTimeoutError{}\n\t\t\t\t\thandshakeTimeout := &HandshakeTimeoutError{}\n\t\t\t\t\tExpect(errors.As(e, &idleTimeout)).To(BeFalse())\n\t\t\t\t\tExpect(errors.As(e, &handshakeTimeout)).To(BeFalse())\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\t// the handshake timeout is irrelevant here, since it depends on the time the connection was created,\n\t\t\t// and not on the last network activity\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\t\t\t// make the go routine return\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes the connection due to the idle timeout before handshake\", func() {\n\t\t\tconn.config.HandshakeIdleTimeout = 0\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tExpect(e).To(MatchError(&IdleTimeoutError{}))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tdone := make(chan struct{})\n\t\t\tconn.handshakeComplete = false\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tcryptoSetup.EXPECT().GetSessionTicket().MaxTimes(1)\n\t\t\t\terr := conn.run()\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tExpect(ok).To(BeTrue())\n\t\t\t\tExpect(nerr.Timeout()).To(BeTrue())\n\t\t\t\tExpect(err).To(MatchError(qerr.ErrIdleTimeout))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes the connection due to the idle timeout after handshake\", func() {\n\t\t\tconn.sentPacketHandler.DropPackets(protocol.EncryptionInitial)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\t\tgomock.InOrder(\n\t\t\t\tconnRunner.EXPECT().Retire(clientDestConnID),\n\t\t\t\tconnRunner.EXPECT().Remove(gomock.Any()),\n\t\t\t)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake),\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tExpect(e).To(MatchError(&IdleTimeoutError{}))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.idleTimeout = 0\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete})\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tcryptoSetup.EXPECT().GetSessionTicket().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed().MaxTimes(1)\n\t\t\t\terr := conn.run()\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tExpect(ok).To(BeTrue())\n\t\t\t\tExpect(nerr.Timeout()).To(BeTrue())\n\t\t\t\tExpect(err).To(MatchError(qerr.ErrIdleTimeout))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't time out when it just sent a packet\", func() {\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-time.Hour)\n\t\t\tconn.firstAckElicitingPacketAfterIdleSentTime = time.Now().Add(-time.Second)\n\t\t\tconn.idleTimeout = 30 * time.Second\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\t\t\t// make the go routine return\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"times out earliest after 3 times the PTO\", func() {\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\t\tconnRunner.EXPECT().Retire(gomock.Any()).AnyTimes()\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).Times(2)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tcloseTimeChan := make(chan time.Time)\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\tExpect(e).To(MatchError(&IdleTimeoutError{}))\n\t\t\t\tcloseTimeChan <- time.Now()\n\t\t\t})\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.idleTimeout = time.Millisecond\n\t\t\tdone := make(chan struct{})\n\t\t\tpto := conn.rttStats.PTO(true)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tcryptoSetup.EXPECT().GetSessionTicket().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed().MaxTimes(1)\n\t\t\t\tconn.run()\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tcloseTime := <-closeTimeChan\n\t\t\tExpect(closeTime.Sub(conn.lastPacketReceivedTime)).To(BeNumerically(\">\", pto*3))\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\t})\n\n\tIt(\"stores up to MaxConnUnprocessedPackets packets\", func() {\n\t\tdone := make(chan struct{})\n\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, logging.ByteCount(6), logging.PacketDropDOSPrevention).Do(func(logging.PacketType, logging.ByteCount, logging.PacketDropReason) {\n\t\t\tclose(done)\n\t\t})\n\t\t// Nothing here should block\n\t\tfor i := protocol.PacketNumber(0); i < protocol.MaxConnUnprocessedPackets+1; i++ {\n\t\t\tconn.handlePacket(receivedPacket{data: []byte(\"foobar\")})\n\t\t}\n\t\tEventually(done).Should(BeClosed())\n\t})\n\n\tContext(\"getting streams\", func() {\n\t\tIt(\"opens streams\", func() {\n\t\t\tmstr := NewMockStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().OpenStream().Return(mstr, nil)\n\t\t\tstr, err := conn.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"opens streams synchronously\", func() {\n\t\t\tmstr := NewMockStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().OpenStreamSync(context.Background()).Return(mstr, nil)\n\t\t\tstr, err := conn.OpenStreamSync(context.Background())\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"opens unidirectional streams\", func() {\n\t\t\tmstr := NewMockSendStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().OpenUniStream().Return(mstr, nil)\n\t\t\tstr, err := conn.OpenUniStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"opens unidirectional streams synchronously\", func() {\n\t\t\tmstr := NewMockSendStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().OpenUniStreamSync(context.Background()).Return(mstr, nil)\n\t\t\tstr, err := conn.OpenUniStreamSync(context.Background())\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"accepts streams\", func() {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\t\t\tdefer cancel()\n\t\t\tmstr := NewMockStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().AcceptStream(ctx).Return(mstr, nil)\n\t\t\tstr, err := conn.AcceptStream(ctx)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"accepts unidirectional streams\", func() {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\t\tdefer cancel()\n\t\t\tmstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().AcceptUniStream(ctx).Return(mstr, nil)\n\t\t\tstr, err := conn.AcceptUniStream(ctx)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\t})\n\n\tIt(\"returns the local address\", func() {\n\t\tExpect(conn.LocalAddr()).To(Equal(localAddr))\n\t})\n\n\tIt(\"returns the remote address\", func() {\n\t\tExpect(conn.RemoteAddr()).To(Equal(remoteAddr))\n\t})\n})\n\nvar _ = Describe(\"Client Connection\", func() {\n\tvar (\n\t\tconn        *connection\n\t\tconnRunner  *MockConnRunner\n\t\tpacker      *MockPacker\n\t\tmconn       *MockSendConn\n\t\tcryptoSetup *mocks.MockCryptoSetup\n\t\ttracer      *mocklogging.MockConnectionTracer\n\t\ttlsConf     *tls.Config\n\t\tquicConf    *Config\n\t)\n\tsrcConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\tdestConnID := protocol.ParseConnectionID([]byte{8, 7, 6, 5, 4, 3, 2, 1})\n\n\tgetPacket := func(hdr *wire.ExtendedHeader, data []byte) receivedPacket {\n\t\tb, err := hdr.Append(nil, conn.version)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\treturn receivedPacket{\n\t\t\trcvTime: time.Now(),\n\t\t\tdata:    append(b, data...),\n\t\t\tbuffer:  getPacketBuffer(),\n\t\t}\n\t}\n\n\tBeforeEach(func() {\n\t\tquicConf = populateConfig(&Config{})\n\t\ttlsConf = nil\n\t})\n\n\tJustBeforeEach(func() {\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\n\t\tmconn = NewMockSendConn(mockCtrl)\n\t\tmconn.EXPECT().capabilities().AnyTimes()\n\t\tmconn.EXPECT().RemoteAddr().Return(&net.UDPAddr{}).AnyTimes()\n\t\tmconn.EXPECT().LocalAddr().Return(&net.UDPAddr{}).AnyTimes()\n\t\tmconn.EXPECT().capabilities().AnyTimes()\n\t\tif tlsConf == nil {\n\t\t\ttlsConf = &tls.Config{}\n\t\t}\n\t\tconnRunner = NewMockConnRunner(mockCtrl)\n\t\ttracer = mocklogging.NewMockConnectionTracer(mockCtrl)\n\t\ttracer.EXPECT().NegotiatedVersion(gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\ttracer.EXPECT().SentTransportParameters(gomock.Any())\n\t\ttracer.EXPECT().UpdatedKeyFromTLS(gomock.Any(), gomock.Any()).AnyTimes()\n\t\ttracer.EXPECT().UpdatedCongestionState(gomock.Any())\n\t\tconn = newClientConnection(\n\t\t\tmconn,\n\t\t\tconnRunner,\n\t\t\tdestConnID,\n\t\t\tprotocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8}),\n\t\t\t&protocol.DefaultConnectionIDGenerator{},\n\t\t\tquicConf,\n\t\t\ttlsConf,\n\t\t\t42, // initial packet number\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\ttracer,\n\t\t\t1234,\n\t\t\tutils.DefaultLogger,\n\t\t\tprotocol.Version1,\n\t\t).(*connection)\n\t\tpacker = NewMockPacker(mockCtrl)\n\t\tconn.packer = packer\n\t\tcryptoSetup = mocks.NewMockCryptoSetup(mockCtrl)\n\t\tconn.cryptoStreamHandler = cryptoSetup\n\t\tconn.sentFirstPacket = true\n\t})\n\n\tIt(\"changes the connection ID when receiving the first packet from the server\", func() {\n\t\tunpacker := NewMockUnpacker(mockCtrl)\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(hdr *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\treturn &unpackedPacket{\n\t\t\t\tencryptionLevel: protocol.Encryption1RTT,\n\t\t\t\thdr:             &wire.ExtendedHeader{Header: *hdr},\n\t\t\t\tdata:            []byte{0}, // one PADDING frame\n\t\t\t}, nil\n\t\t})\n\t\tconn.unpacker = unpacker\n\t\tdone := make(chan struct{})\n\t\tpacker.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(onlyAck bool, maxPacketSize protocol.ByteCount, v protocol.VersionNumber) { close(done) })\n\t\tnewConnID := protocol.ParseConnectionID([]byte{1, 3, 3, 7, 1, 3, 3, 7})\n\t\tp := getPacket(&wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\tSrcConnectionID:  newConnID,\n\t\t\t\tDestConnectionID: srcConnID,\n\t\t\t\tLength:           2 + 6,\n\t\t\t\tVersion:          conn.version,\n\t\t\t},\n\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t}, []byte(\"foobar\"))\n\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), p.Size(), []logging.Frame{})\n\t\tExpect(conn.handlePacketImpl(p)).To(BeTrue())\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tconn.run()\n\t\t}()\n\t\tEventually(done).Should(BeClosed())\n\t\t// make sure the go routine returns\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tconnRunner.EXPECT().ReplaceWithClosed([]protocol.ConnectionID{srcConnID}, gomock.Any(), gomock.Any())\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\ttime.Sleep(200 * time.Millisecond)\n\t})\n\n\tIt(\"continues accepting Long Header packets after using a new connection ID\", func() {\n\t\tunpacker := NewMockUnpacker(mockCtrl)\n\t\tconn.unpacker = unpacker\n\t\tconnRunner.EXPECT().AddResetToken(gomock.Any(), gomock.Any())\n\t\tconn.connIDManager.SetHandshakeComplete()\n\t\tconn.handleNewConnectionIDFrame(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 1,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5}),\n\t\t})\n\t\tExpect(conn.connIDManager.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5})))\n\t\t// now receive a packet with the original source connection ID\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(hdr *wire.Header, _ time.Time, _ []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\treturn &unpackedPacket{\n\t\t\t\thdr:             &wire.ExtendedHeader{Header: *hdr},\n\t\t\t\tdata:            []byte{0},\n\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t}, nil\n\t\t})\n\t\thdr := &wire.Header{\n\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\tDestConnectionID: srcConnID,\n\t\t\tSrcConnectionID:  destConnID,\n\t\t}\n\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\tExpect(conn.handleLongHeaderPacket(receivedPacket{buffer: getPacketBuffer()}, hdr)).To(BeTrue())\n\t})\n\n\tIt(\"handles HANDSHAKE_DONE frames\", func() {\n\t\tconn.peerParams = &wire.TransportParameters{}\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tconn.sentPacketHandler = sph\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().DropPackets(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().SetHandshakeConfirmed()\n\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\tExpect(conn.handleHandshakeDoneFrame()).To(Succeed())\n\t})\n\n\tIt(\"interprets an ACK for 1-RTT packets as confirmation of the handshake\", func() {\n\t\tconn.peerParams = &wire.TransportParameters{}\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tconn.sentPacketHandler = sph\n\t\tack := &wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 1, Largest: 3}}}\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().ReceivedAck(ack, protocol.Encryption1RTT, gomock.Any()).Return(true, nil)\n\t\tsph.EXPECT().DropPackets(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().SetHandshakeConfirmed()\n\t\tcryptoSetup.EXPECT().SetLargest1RTTAcked(protocol.PacketNumber(3))\n\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\tExpect(conn.handleAckFrame(ack, protocol.Encryption1RTT)).To(Succeed())\n\t})\n\n\tIt(\"doesn't send a CONNECTION_CLOSE when no packet was sent\", func() {\n\t\tconn.sentFirstPacket = false\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\trunning := make(chan struct{})\n\t\tcryptoSetup.EXPECT().StartHandshake().Do(func() {\n\t\t\tclose(running)\n\t\t\tconn.closeLocal(errors.New(\"early error\"))\n\t\t})\n\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\tcryptoSetup.EXPECT().Close()\n\t\tconnRunner.EXPECT().Remove(gomock.Any())\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tconn.run()\n\t\t}()\n\t\tEventually(running).Should(BeClosed())\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\t})\n\n\tContext(\"handling tokens\", func() {\n\t\tvar mockTokenStore *MockTokenStore\n\n\t\tBeforeEach(func() {\n\t\t\tmockTokenStore = NewMockTokenStore(mockCtrl)\n\t\t\ttlsConf = &tls.Config{ServerName: \"server\"}\n\t\t\tquicConf.TokenStore = mockTokenStore\n\t\t\tmockTokenStore.EXPECT().Pop(gomock.Any())\n\t\t\tquicConf.TokenStore = mockTokenStore\n\t\t})\n\n\t\tIt(\"handles NEW_TOKEN frames\", func() {\n\t\t\tmockTokenStore.EXPECT().Put(\"server\", &ClientToken{data: []byte(\"foobar\")})\n\t\t\tExpect(conn.handleNewTokenFrame(&wire.NewTokenFrame{Token: []byte(\"foobar\")})).To(Succeed())\n\t\t})\n\t})\n\n\tContext(\"handling Version Negotiation\", func() {\n\t\tgetVNP := func(versions ...protocol.VersionNumber) receivedPacket {\n\t\t\tb := wire.ComposeVersionNegotiation(\n\t\t\t\tprotocol.ArbitraryLenConnectionID(srcConnID.Bytes()),\n\t\t\t\tprotocol.ArbitraryLenConnectionID(destConnID.Bytes()),\n\t\t\t\tversions,\n\t\t\t)\n\t\t\treturn receivedPacket{\n\t\t\t\trcvTime: time.Now(),\n\t\t\t\tdata:    b,\n\t\t\t\tbuffer:  getPacketBuffer(),\n\t\t\t}\n\t\t}\n\n\t\tIt(\"closes and returns the right error\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tsph.EXPECT().ReceivedBytes(gomock.Any())\n\t\t\tsph.EXPECT().PeekPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(128), protocol.PacketNumberLen4)\n\t\t\tconn.config.Versions = []protocol.VersionNumber{1234, 4321}\n\t\t\terrChan := make(chan error, 1)\n\t\t\tstart := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().DoAndReturn(func() handshake.Event {\n\t\t\t\t\t<-start\n\t\t\t\t\treturn handshake.Event{Kind: handshake.EventNoEvent}\n\t\t\t\t})\n\t\t\t\terrChan <- conn.run()\n\t\t\t}()\n\t\t\tconnRunner.EXPECT().Remove(srcConnID)\n\t\t\ttracer.EXPECT().ReceivedVersionNegotiationPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_, _ protocol.ArbitraryLenConnectionID, versions []logging.VersionNumber) {\n\t\t\t\tExpect(versions).To(And(\n\t\t\t\t\tContainElement(protocol.VersionNumber(4321)),\n\t\t\t\t\tContainElement(protocol.VersionNumber(1337)),\n\t\t\t\t))\n\t\t\t})\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tExpect(conn.handlePacketImpl(getVNP(4321, 1337))).To(BeFalse())\n\t\t\tclose(start)\n\t\t\tvar err error\n\t\t\tEventually(errChan).Should(Receive(&err))\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err).To(BeAssignableToTypeOf(&errCloseForRecreating{}))\n\t\t\trecreateErr := err.(*errCloseForRecreating)\n\t\t\tExpect(recreateErr.nextVersion).To(Equal(protocol.VersionNumber(4321)))\n\t\t\tExpect(recreateErr.nextPacketNumber).To(Equal(protocol.PacketNumber(128)))\n\t\t})\n\n\t\tIt(\"it closes when no matching version is found\", func() {\n\t\t\terrChan := make(chan error, 1)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terrChan <- conn.run()\n\t\t\t}()\n\t\t\tconnRunner.EXPECT().Remove(srcConnID).MaxTimes(1)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ReceivedVersionNegotiationPacket(gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tvar vnErr *VersionNegotiationError\n\t\t\t\t\tExpect(errors.As(e, &vnErr)).To(BeTrue())\n\t\t\t\t\tExpect(vnErr.Theirs).To(ContainElement(logging.VersionNumber(12345678)))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tExpect(conn.handlePacketImpl(getVNP(12345678))).To(BeFalse())\n\t\t\tvar err error\n\t\t\tEventually(errChan).Should(Receive(&err))\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err).ToNot(BeAssignableToTypeOf(errCloseForRecreating{}))\n\t\t\tExpect(err.Error()).To(ContainSubstring(\"no compatible QUIC version found\"))\n\t\t})\n\n\t\tIt(\"ignores Version Negotiation packets that offer the current version\", func() {\n\t\t\tp := getVNP(conn.version)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropUnexpectedVersion)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"ignores unparseable Version Negotiation packets\", func() {\n\t\t\tp := getVNP(conn.version)\n\t\t\tp.data = p.data[:len(p.data)-2]\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropHeaderParseError)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\t})\n\n\tContext(\"handling Retry\", func() {\n\t\torigDestConnID := protocol.ParseConnectionID([]byte{8, 7, 6, 5, 4, 3, 2, 1})\n\n\t\tvar retryHdr *wire.ExtendedHeader\n\n\t\tJustBeforeEach(func() {\n\t\t\tretryHdr = &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeRetry,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t\t\t\t\tDestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8}),\n\t\t\t\t\tToken:            []byte(\"foobar\"),\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t}\n\t\t})\n\n\t\tgetRetryTag := func(hdr *wire.ExtendedHeader) []byte {\n\t\t\tb, err := hdr.Append(nil, conn.version)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\treturn handshake.GetRetryIntegrityTag(b, origDestConnID, hdr.Version)[:]\n\t\t}\n\n\t\tIt(\"handles Retry packets\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tsph.EXPECT().ResetForRetry()\n\t\t\tsph.EXPECT().ReceivedBytes(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().ChangeConnectionID(protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}))\n\t\t\tpacker.EXPECT().SetToken([]byte(\"foobar\"))\n\t\t\ttracer.EXPECT().ReceivedRetry(gomock.Any()).Do(func(hdr *wire.Header) {\n\t\t\t\tExpect(hdr.DestConnectionID).To(Equal(retryHdr.DestConnectionID))\n\t\t\t\tExpect(hdr.SrcConnectionID).To(Equal(retryHdr.SrcConnectionID))\n\t\t\t\tExpect(hdr.Token).To(Equal(retryHdr.Token))\n\t\t\t})\n\t\t\tExpect(conn.handlePacketImpl(getPacket(retryHdr, getRetryTag(retryHdr)))).To(BeTrue())\n\t\t})\n\n\t\tIt(\"ignores Retry packets after receiving a regular packet\", func() {\n\t\t\tconn.receivedFirstPacket = true\n\t\t\tp := getPacket(retryHdr, getRetryTag(retryHdr))\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"ignores Retry packets if the server didn't change the connection ID\", func() {\n\t\t\tretryHdr.SrcConnectionID = destConnID\n\t\t\tp := getPacket(retryHdr, getRetryTag(retryHdr))\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"ignores Retry packets with the a wrong Integrity tag\", func() {\n\t\t\ttag := getRetryTag(retryHdr)\n\t\t\ttag[0]++\n\t\t\tp := getPacket(retryHdr, tag)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, p.Size(), logging.PacketDropPayloadDecryptError)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\t})\n\n\tContext(\"transport parameters\", func() {\n\t\tvar (\n\t\t\tclosed     bool\n\t\t\terrChan    chan error\n\t\t\tparamsChan chan *wire.TransportParameters\n\t\t)\n\n\t\tJustBeforeEach(func() {\n\t\t\terrChan = make(chan error, 1)\n\t\t\tparamsChan = make(chan *wire.TransportParameters, 1)\n\t\t\tclosed = false\n\t\t\tpacker.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\t// This is not 100% what would happen in reality.\n\t\t\t\t// The run loop calls NextEvent once when it starts up (to send out the ClientHello),\n\t\t\t\t// and then again every time a CRYPTO frame is handled.\n\t\t\t\t// Injecting a CRYPTO frame is not straightforward though,\n\t\t\t\t// so we inject the transport parameters on the first call to NextEvent.\n\t\t\t\tparams := <-paramsChan\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{\n\t\t\t\t\tKind:                handshake.EventReceivedTransportParameters,\n\t\t\t\t\tTransportParameters: params,\n\t\t\t\t})\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete}).MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}).MaxTimes(1)\n\t\t\t\terrChan <- conn.run()\n\t\t\t\tclose(errChan)\n\t\t\t}()\n\t\t})\n\n\t\texpectClose := func(applicationClose, errored bool) {\n\t\t\tif !closed && !errored {\n\t\t\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\t\tif applicationClose {\n\t\t\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil).MaxTimes(1)\n\t\t\t\t} else {\n\t\t\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil).MaxTimes(1)\n\t\t\t\t}\n\t\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()),\n\t\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t\t)\n\t\t\t}\n\t\t\tclosed = true\n\t\t}\n\n\t\tAfterEach(func() {\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t\tEventually(errChan).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"uses the preferred_address connection ID\", func() {\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tPreferredAddress: &wire.PreferredAddress{\n\t\t\t\t\tIPv4:                net.IPv4(127, 0, 0, 1),\n\t\t\t\t\tIPv6:                net.IP{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\t\t\tStatelessResetToken: protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\n\t\t\t\t},\n\t\t\t}\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).MaxTimes(1)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\t// make sure the connection ID is not retired\n\t\t\tcf, _ := conn.framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(cf).To(BeEmpty())\n\t\t\tconnRunner.EXPECT().AddResetToken(protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, conn)\n\t\t\tExpect(conn.connIDManager.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4})))\n\t\t\t// shut down\n\t\t\tconnRunner.EXPECT().RemoveResetToken(protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1})\n\t\t\texpectClose(true, false)\n\t\t})\n\n\t\tIt(\"uses the minimum of the peers' idle timeouts\", func() {\n\t\t\tconn.config.MaxIdleTimeout = 19 * time.Second\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tMaxIdleTimeout:                  18 * time.Second,\n\t\t\t}\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\t// close first\n\t\t\texpectClose(true, false)\n\t\t\tconn.shutdown()\n\t\t\t// then check. Avoids race condition when accessing idleTimeout\n\t\t\tExpect(conn.idleTimeout).To(Equal(18 * time.Second))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters contain a wrong initial_source_connection_id\", func() {\n\t\t\tconn.handshakeDestConnID = protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       protocol.ParseConnectionID([]byte{0xde, 0xca, 0xfb, 0xad}),\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"expected initial_source_connection_id to equal deadbeef, is decafbad\",\n\t\t\t})))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters don't contain the retry_source_connection_id, if a Retry was performed\", func() {\n\t\t\trcid := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\tconn.retrySrcConnID = &rcid\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"missing retry_source_connection_id\",\n\t\t\t})))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters contain the wrong retry_source_connection_id, if a Retry was performed\", func() {\n\t\t\trcid := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\trcid2 := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xc0, 0xde})\n\t\t\tconn.retrySrcConnID = &rcid\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tRetrySourceConnectionID:         &rcid2,\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"expected retry_source_connection_id to equal deadbeef, is deadc0de\",\n\t\t\t})))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters contain the retry_source_connection_id, if no Retry was performed\", func() {\n\t\t\trcid := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xc0, 0xde})\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tRetrySourceConnectionID:         &rcid,\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"received retry_source_connection_id, although no Retry was performed\",\n\t\t\t})))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters contain a wrong original_destination_connection_id\", func() {\n\t\t\tconn.origDestConnID = protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: protocol.ParseConnectionID([]byte{0xde, 0xca, 0xfb, 0xad}),\n\t\t\t\tInitialSourceConnectionID:       conn.handshakeDestConnID,\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"expected original_destination_connection_id to equal deadbeef, is decafbad\",\n\t\t\t})))\n\t\t})\n\t})\n\n\tContext(\"handling potentially injected packets\", func() {\n\t\tvar unpacker *MockUnpacker\n\n\t\tgetPacket := func(extHdr *wire.ExtendedHeader, data []byte) receivedPacket {\n\t\t\tb, err := extHdr.Append(nil, conn.version)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\treturn receivedPacket{\n\t\t\t\tdata:   append(b, data...),\n\t\t\t\tbuffer: getPacketBuffer(),\n\t\t\t}\n\t\t}\n\n\t\t// Convert an already packed raw packet into a receivedPacket\n\t\twrapPacket := func(packet []byte) receivedPacket {\n\t\t\treturn receivedPacket{\n\t\t\t\tdata:   packet,\n\t\t\t\tbuffer: getPacketBuffer(),\n\t\t\t}\n\t\t}\n\n\t\t// Illustrates that attacker may inject an Initial packet with a different\n\t\t// source connection ID, causing endpoint to ignore a subsequent real Initial packets.\n\t\tIt(\"ignores Initial packets with a different source connection ID\", func() {\n\t\t\t// Modified from test \"ignores packets with a different source connection ID\"\n\t\t\tunpacker = NewMockUnpacker(mockCtrl)\n\t\t\tconn.unpacker = unpacker\n\n\t\t\thdr1 := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    1,\n\t\t\t}\n\t\t\thdr2 := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    2,\n\t\t\t}\n\t\t\tExpect(hdr2.SrcConnectionID).ToNot(Equal(srcConnID))\n\t\t\t// Send one packet, which might change the connection ID.\n\t\t\t// only EXPECT one call to the unpacker\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(&unpackedPacket{\n\t\t\t\tencryptionLevel: protocol.EncryptionInitial,\n\t\t\t\thdr:             hdr1,\n\t\t\t\tdata:            []byte{0}, // one PADDING frame\n\t\t\t}, nil)\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(getPacket(hdr1, nil))).To(BeTrue())\n\t\t\t// The next packet has to be ignored, since the source connection ID doesn't match.\n\t\t\ttracer.EXPECT().DroppedPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(getPacket(hdr2, nil))).To(BeFalse())\n\t\t})\n\n\t\tIt(\"ignores 0-RTT packets\", func() {\n\t\t\tp := getPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\t\tDestConnectionID: srcConnID,\n\t\t\t\t\tLength:           2 + 6,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumber:    0x42,\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, []byte(\"foobar\"))\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketType0RTT, p.Size(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\t// Illustrates that an injected Initial with an ACK frame for an unsent packet causes\n\t\t// the connection to immediately break down\n\t\tIt(\"fails on Initial-level ACK for unsent packet\", func() {\n\t\t\tack := &wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 2, Largest: 2}}}\n\t\t\tinitialPacket := testutils.ComposeInitialPacket(destConnID, srcConnID, conn.version, destConnID, []wire.Frame{ack})\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(wrapPacket(initialPacket))).To(BeFalse())\n\t\t})\n\n\t\t// Illustrates that an injected Initial with a CONNECTION_CLOSE frame causes\n\t\t// the connection to immediately break down\n\t\tIt(\"fails on Initial-level CONNECTION_CLOSE frame\", func() {\n\t\t\tconnCloseFrame := &wire.ConnectionCloseFrame{\n\t\t\t\tIsApplicationError: true,\n\t\t\t\tReasonPhrase:       \"mitm attacker\",\n\t\t\t}\n\t\t\tinitialPacket := testutils.ComposeInitialPacket(destConnID, srcConnID, conn.version, destConnID, []wire.Frame{connCloseFrame})\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(wrapPacket(initialPacket))).To(BeTrue())\n\t\t})\n\n\t\t// Illustrates that attacker who injects a Retry packet and changes the connection ID\n\t\t// can cause subsequent real Initial packets to be ignored\n\t\tIt(\"ignores Initial packets which use original source id, after accepting a Retry\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tsph.EXPECT().ReceivedBytes(gomock.Any()).Times(2)\n\t\t\tsph.EXPECT().ResetForRetry()\n\t\t\tnewSrcConnID := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\tcryptoSetup.EXPECT().ChangeConnectionID(newSrcConnID)\n\t\t\tpacker.EXPECT().SetToken([]byte(\"foobar\"))\n\n\t\t\ttracer.EXPECT().ReceivedRetry(gomock.Any())\n\t\t\tconn.handlePacketImpl(wrapPacket(testutils.ComposeRetryPacket(newSrcConnID, destConnID, destConnID, []byte(\"foobar\"), conn.version)))\n\t\t\tinitialPacket := testutils.ComposeInitialPacket(conn.connIDManager.Get(), srcConnID, conn.version, conn.connIDManager.Get(), nil)\n\t\t\ttracer.EXPECT().DroppedPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(wrapPacket(initialPacket))).To(BeFalse())\n\t\t})\n\t})\n})\n"], "fixing_code": ["package quic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/logutils\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n)\n\ntype unpacker interface {\n\tUnpackLongHeader(hdr *wire.Header, rcvTime time.Time, data []byte, v protocol.VersionNumber) (*unpackedPacket, error)\n\tUnpackShortHeader(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error)\n}\n\ntype streamGetter interface {\n\tGetOrOpenReceiveStream(protocol.StreamID) (receiveStreamI, error)\n\tGetOrOpenSendStream(protocol.StreamID) (sendStreamI, error)\n}\n\ntype streamManager interface {\n\tGetOrOpenSendStream(protocol.StreamID) (sendStreamI, error)\n\tGetOrOpenReceiveStream(protocol.StreamID) (receiveStreamI, error)\n\tOpenStream() (Stream, error)\n\tOpenUniStream() (SendStream, error)\n\tOpenStreamSync(context.Context) (Stream, error)\n\tOpenUniStreamSync(context.Context) (SendStream, error)\n\tAcceptStream(context.Context) (Stream, error)\n\tAcceptUniStream(context.Context) (ReceiveStream, error)\n\tDeleteStream(protocol.StreamID) error\n\tUpdateLimits(*wire.TransportParameters)\n\tHandleMaxStreamsFrame(*wire.MaxStreamsFrame)\n\tCloseWithError(error)\n\tResetFor0RTT()\n\tUseResetMaps()\n}\n\ntype cryptoStreamHandler interface {\n\tStartHandshake() error\n\tChangeConnectionID(protocol.ConnectionID)\n\tSetLargest1RTTAcked(protocol.PacketNumber) error\n\tSetHandshakeConfirmed()\n\tGetSessionTicket() ([]byte, error)\n\tNextEvent() handshake.Event\n\tDiscardInitialKeys()\n\tio.Closer\n\tConnectionState() handshake.ConnectionState\n}\n\ntype receivedPacket struct {\n\tbuffer *packetBuffer\n\n\tremoteAddr net.Addr\n\trcvTime    time.Time\n\tdata       []byte\n\n\tecn protocol.ECN\n\n\tinfo packetInfo // only valid if the contained IP address is valid\n}\n\nfunc (p *receivedPacket) Size() protocol.ByteCount { return protocol.ByteCount(len(p.data)) }\n\nfunc (p *receivedPacket) Clone() *receivedPacket {\n\treturn &receivedPacket{\n\t\tremoteAddr: p.remoteAddr,\n\t\trcvTime:    p.rcvTime,\n\t\tdata:       p.data,\n\t\tbuffer:     p.buffer,\n\t\tecn:        p.ecn,\n\t\tinfo:       p.info,\n\t}\n}\n\ntype connRunner interface {\n\tAdd(protocol.ConnectionID, packetHandler) bool\n\tGetStatelessResetToken(protocol.ConnectionID) protocol.StatelessResetToken\n\tRetire(protocol.ConnectionID)\n\tRemove(protocol.ConnectionID)\n\tReplaceWithClosed([]protocol.ConnectionID, protocol.Perspective, []byte)\n\tAddResetToken(protocol.StatelessResetToken, packetHandler)\n\tRemoveResetToken(protocol.StatelessResetToken)\n}\n\ntype closeError struct {\n\terr       error\n\tremote    bool\n\timmediate bool\n}\n\ntype errCloseForRecreating struct {\n\tnextPacketNumber protocol.PacketNumber\n\tnextVersion      protocol.VersionNumber\n}\n\nfunc (e *errCloseForRecreating) Error() string {\n\treturn \"closing connection in order to recreate it\"\n}\n\nvar connTracingID uint64        // to be accessed atomically\nfunc nextConnTracingID() uint64 { return atomic.AddUint64(&connTracingID, 1) }\n\n// A Connection is a QUIC connection\ntype connection struct {\n\t// Destination connection ID used during the handshake.\n\t// Used to check source connection ID on incoming packets.\n\thandshakeDestConnID protocol.ConnectionID\n\t// Set for the client. Destination connection ID used on the first Initial sent.\n\torigDestConnID protocol.ConnectionID\n\tretrySrcConnID *protocol.ConnectionID // only set for the client (and if a Retry was performed)\n\n\tsrcConnIDLen int\n\n\tperspective protocol.Perspective\n\tversion     protocol.VersionNumber\n\tconfig      *Config\n\n\tconn      sendConn\n\tsendQueue sender\n\n\tstreamsMap      streamManager\n\tconnIDManager   *connIDManager\n\tconnIDGenerator *connIDGenerator\n\n\trttStats *utils.RTTStats\n\n\tcryptoStreamManager   *cryptoStreamManager\n\tsentPacketHandler     ackhandler.SentPacketHandler\n\treceivedPacketHandler ackhandler.ReceivedPacketHandler\n\tretransmissionQueue   *retransmissionQueue\n\tframer                framer\n\twindowUpdateQueue     *windowUpdateQueue\n\tconnFlowController    flowcontrol.ConnectionFlowController\n\ttokenStoreKey         string                    // only set for the client\n\ttokenGenerator        *handshake.TokenGenerator // only set for the server\n\n\tunpacker      unpacker\n\tframeParser   wire.FrameParser\n\tpacker        packer\n\tmtuDiscoverer mtuDiscoverer // initialized when the handshake completes\n\n\tinitialStream       cryptoStream\n\thandshakeStream     cryptoStream\n\toneRTTStream        cryptoStream // only set for the server\n\tcryptoStreamHandler cryptoStreamHandler\n\n\treceivedPackets  chan receivedPacket\n\tsendingScheduled chan struct{}\n\n\tcloseOnce sync.Once\n\t// closeChan is used to notify the run loop that it should terminate\n\tcloseChan chan closeError\n\n\tctx                context.Context\n\tctxCancel          context.CancelCauseFunc\n\thandshakeCtx       context.Context\n\thandshakeCtxCancel context.CancelFunc\n\n\tundecryptablePackets          []receivedPacket // undecryptable packets, waiting for a change in encryption level\n\tundecryptablePacketsToProcess []receivedPacket\n\n\tearlyConnReadyChan chan struct{}\n\tsentFirstPacket    bool\n\thandshakeComplete  bool\n\thandshakeConfirmed bool\n\n\treceivedRetry       bool\n\tversionNegotiated   bool\n\treceivedFirstPacket bool\n\n\t// the minimum of the max_idle_timeout values advertised by both endpoints\n\tidleTimeout  time.Duration\n\tcreationTime time.Time\n\t// The idle timeout is set based on the max of the time we received the last packet...\n\tlastPacketReceivedTime time.Time\n\t// ... and the time we sent a new ack-eliciting packet after receiving a packet.\n\tfirstAckElicitingPacketAfterIdleSentTime time.Time\n\t// pacingDeadline is the time when the next packet should be sent\n\tpacingDeadline time.Time\n\n\tpeerParams *wire.TransportParameters\n\n\ttimer connectionTimer\n\t// keepAlivePingSent stores whether a keep alive PING is in flight.\n\t// It is reset as soon as we receive a packet from the peer.\n\tkeepAlivePingSent bool\n\tkeepAliveInterval time.Duration\n\n\tdatagramQueue *datagramQueue\n\n\tconnStateMutex sync.Mutex\n\tconnState      ConnectionState\n\n\tlogID  string\n\ttracer logging.ConnectionTracer\n\tlogger utils.Logger\n}\n\nvar (\n\t_ Connection      = &connection{}\n\t_ EarlyConnection = &connection{}\n\t_ streamSender    = &connection{}\n)\n\nvar newConnection = func(\n\tconn sendConn,\n\trunner connRunner,\n\torigDestConnID protocol.ConnectionID,\n\tretrySrcConnID *protocol.ConnectionID,\n\tclientDestConnID protocol.ConnectionID,\n\tdestConnID protocol.ConnectionID,\n\tsrcConnID protocol.ConnectionID,\n\tconnIDGenerator ConnectionIDGenerator,\n\tstatelessResetToken protocol.StatelessResetToken,\n\tconf *Config,\n\ttlsConf *tls.Config,\n\ttokenGenerator *handshake.TokenGenerator,\n\tclientAddressValidated bool,\n\ttracer logging.ConnectionTracer,\n\ttracingID uint64,\n\tlogger utils.Logger,\n\tv protocol.VersionNumber,\n) quicConn {\n\ts := &connection{\n\t\tconn:                conn,\n\t\tconfig:              conf,\n\t\thandshakeDestConnID: destConnID,\n\t\tsrcConnIDLen:        srcConnID.Len(),\n\t\ttokenGenerator:      tokenGenerator,\n\t\toneRTTStream:        newCryptoStream(),\n\t\tperspective:         protocol.PerspectiveServer,\n\t\ttracer:              tracer,\n\t\tlogger:              logger,\n\t\tversion:             v,\n\t}\n\tif origDestConnID.Len() > 0 {\n\t\ts.logID = origDestConnID.String()\n\t} else {\n\t\ts.logID = destConnID.String()\n\t}\n\ts.connIDManager = newConnIDManager(\n\t\tdestConnID,\n\t\tfunc(token protocol.StatelessResetToken) { runner.AddResetToken(token, s) },\n\t\trunner.RemoveResetToken,\n\t\ts.queueControlFrame,\n\t)\n\ts.connIDGenerator = newConnIDGenerator(\n\t\tsrcConnID,\n\t\t&clientDestConnID,\n\t\tfunc(connID protocol.ConnectionID) { runner.Add(connID, s) },\n\t\trunner.GetStatelessResetToken,\n\t\trunner.Remove,\n\t\trunner.Retire,\n\t\trunner.ReplaceWithClosed,\n\t\ts.queueControlFrame,\n\t\tconnIDGenerator,\n\t)\n\ts.preSetup()\n\ts.ctx, s.ctxCancel = context.WithCancelCause(context.WithValue(context.Background(), ConnectionTracingKey, tracingID))\n\ts.sentPacketHandler, s.receivedPacketHandler = ackhandler.NewAckHandler(\n\t\t0,\n\t\tgetMaxPacketSize(s.conn.RemoteAddr()),\n\t\ts.rttStats,\n\t\tclientAddressValidated,\n\t\ts.perspective,\n\t\ts.tracer,\n\t\ts.logger,\n\t)\n\ts.mtuDiscoverer = newMTUDiscoverer(s.rttStats, getMaxPacketSize(s.conn.RemoteAddr()), s.sentPacketHandler.SetMaxDatagramSize)\n\tparams := &wire.TransportParameters{\n\t\tInitialMaxStreamDataBidiLocal:   protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataBidiRemote:  protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataUni:         protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxData:                  protocol.ByteCount(s.config.InitialConnectionReceiveWindow),\n\t\tMaxIdleTimeout:                  s.config.MaxIdleTimeout,\n\t\tMaxBidiStreamNum:                protocol.StreamNum(s.config.MaxIncomingStreams),\n\t\tMaxUniStreamNum:                 protocol.StreamNum(s.config.MaxIncomingUniStreams),\n\t\tMaxAckDelay:                     protocol.MaxAckDelayInclGranularity,\n\t\tAckDelayExponent:                protocol.AckDelayExponent,\n\t\tDisableActiveMigration:          true,\n\t\tStatelessResetToken:             &statelessResetToken,\n\t\tOriginalDestinationConnectionID: origDestConnID,\n\t\t// For interoperability with quic-go versions before May 2023, this value must be set to a value\n\t\t// different from protocol.DefaultActiveConnectionIDLimit.\n\t\t// If set to the default value, it will be omitted from the transport parameters, which will make\n\t\t// old quic-go versions interpret it as 0, instead of the default value of 2.\n\t\t// See https://github.com/quic-go/quic-go/pull/3806.\n\t\tActiveConnectionIDLimit:   protocol.MaxActiveConnectionIDs,\n\t\tInitialSourceConnectionID: srcConnID,\n\t\tRetrySourceConnectionID:   retrySrcConnID,\n\t}\n\tif s.config.EnableDatagrams {\n\t\tparams.MaxDatagramFrameSize = protocol.MaxDatagramFrameSize\n\t} else {\n\t\tparams.MaxDatagramFrameSize = protocol.InvalidByteCount\n\t}\n\tif s.tracer != nil {\n\t\ts.tracer.SentTransportParameters(params)\n\t}\n\tcs := handshake.NewCryptoSetupServer(\n\t\tclientDestConnID,\n\t\tconn.LocalAddr(),\n\t\tconn.RemoteAddr(),\n\t\tparams,\n\t\ttlsConf,\n\t\tconf.Allow0RTT,\n\t\ts.rttStats,\n\t\ttracer,\n\t\tlogger,\n\t\ts.version,\n\t)\n\ts.cryptoStreamHandler = cs\n\ts.packer = newPacketPacker(srcConnID, s.connIDManager.Get, s.initialStream, s.handshakeStream, s.sentPacketHandler, s.retransmissionQueue, cs, s.framer, s.receivedPacketHandler, s.datagramQueue, s.perspective)\n\ts.unpacker = newPacketUnpacker(cs, s.srcConnIDLen)\n\ts.cryptoStreamManager = newCryptoStreamManager(cs, s.initialStream, s.handshakeStream, s.oneRTTStream)\n\treturn s\n}\n\n// declare this as a variable, such that we can it mock it in the tests\nvar newClientConnection = func(\n\tconn sendConn,\n\trunner connRunner,\n\tdestConnID protocol.ConnectionID,\n\tsrcConnID protocol.ConnectionID,\n\tconnIDGenerator ConnectionIDGenerator,\n\tconf *Config,\n\ttlsConf *tls.Config,\n\tinitialPacketNumber protocol.PacketNumber,\n\tenable0RTT bool,\n\thasNegotiatedVersion bool,\n\ttracer logging.ConnectionTracer,\n\ttracingID uint64,\n\tlogger utils.Logger,\n\tv protocol.VersionNumber,\n) quicConn {\n\ts := &connection{\n\t\tconn:                conn,\n\t\tconfig:              conf,\n\t\torigDestConnID:      destConnID,\n\t\thandshakeDestConnID: destConnID,\n\t\tsrcConnIDLen:        srcConnID.Len(),\n\t\tperspective:         protocol.PerspectiveClient,\n\t\tlogID:               destConnID.String(),\n\t\tlogger:              logger,\n\t\ttracer:              tracer,\n\t\tversionNegotiated:   hasNegotiatedVersion,\n\t\tversion:             v,\n\t}\n\ts.connIDManager = newConnIDManager(\n\t\tdestConnID,\n\t\tfunc(token protocol.StatelessResetToken) { runner.AddResetToken(token, s) },\n\t\trunner.RemoveResetToken,\n\t\ts.queueControlFrame,\n\t)\n\ts.connIDGenerator = newConnIDGenerator(\n\t\tsrcConnID,\n\t\tnil,\n\t\tfunc(connID protocol.ConnectionID) { runner.Add(connID, s) },\n\t\trunner.GetStatelessResetToken,\n\t\trunner.Remove,\n\t\trunner.Retire,\n\t\trunner.ReplaceWithClosed,\n\t\ts.queueControlFrame,\n\t\tconnIDGenerator,\n\t)\n\ts.preSetup()\n\ts.ctx, s.ctxCancel = context.WithCancelCause(context.WithValue(context.Background(), ConnectionTracingKey, tracingID))\n\ts.sentPacketHandler, s.receivedPacketHandler = ackhandler.NewAckHandler(\n\t\tinitialPacketNumber,\n\t\tgetMaxPacketSize(s.conn.RemoteAddr()),\n\t\ts.rttStats,\n\t\tfalse, /* has no effect */\n\t\ts.perspective,\n\t\ts.tracer,\n\t\ts.logger,\n\t)\n\ts.mtuDiscoverer = newMTUDiscoverer(s.rttStats, getMaxPacketSize(s.conn.RemoteAddr()), s.sentPacketHandler.SetMaxDatagramSize)\n\toneRTTStream := newCryptoStream()\n\tparams := &wire.TransportParameters{\n\t\tInitialMaxStreamDataBidiRemote: protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataBidiLocal:  protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataUni:        protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxData:                 protocol.ByteCount(s.config.InitialConnectionReceiveWindow),\n\t\tMaxIdleTimeout:                 s.config.MaxIdleTimeout,\n\t\tMaxBidiStreamNum:               protocol.StreamNum(s.config.MaxIncomingStreams),\n\t\tMaxUniStreamNum:                protocol.StreamNum(s.config.MaxIncomingUniStreams),\n\t\tMaxAckDelay:                    protocol.MaxAckDelayInclGranularity,\n\t\tAckDelayExponent:               protocol.AckDelayExponent,\n\t\tDisableActiveMigration:         true,\n\t\t// For interoperability with quic-go versions before May 2023, this value must be set to a value\n\t\t// different from protocol.DefaultActiveConnectionIDLimit.\n\t\t// If set to the default value, it will be omitted from the transport parameters, which will make\n\t\t// old quic-go versions interpret it as 0, instead of the default value of 2.\n\t\t// See https://github.com/quic-go/quic-go/pull/3806.\n\t\tActiveConnectionIDLimit:   protocol.MaxActiveConnectionIDs,\n\t\tInitialSourceConnectionID: srcConnID,\n\t}\n\tif s.config.EnableDatagrams {\n\t\tparams.MaxDatagramFrameSize = protocol.MaxDatagramFrameSize\n\t} else {\n\t\tparams.MaxDatagramFrameSize = protocol.InvalidByteCount\n\t}\n\tif s.tracer != nil {\n\t\ts.tracer.SentTransportParameters(params)\n\t}\n\tcs := handshake.NewCryptoSetupClient(\n\t\tdestConnID,\n\t\tparams,\n\t\ttlsConf,\n\t\tenable0RTT,\n\t\ts.rttStats,\n\t\ttracer,\n\t\tlogger,\n\t\ts.version,\n\t)\n\ts.cryptoStreamHandler = cs\n\ts.cryptoStreamManager = newCryptoStreamManager(cs, s.initialStream, s.handshakeStream, oneRTTStream)\n\ts.unpacker = newPacketUnpacker(cs, s.srcConnIDLen)\n\ts.packer = newPacketPacker(srcConnID, s.connIDManager.Get, s.initialStream, s.handshakeStream, s.sentPacketHandler, s.retransmissionQueue, cs, s.framer, s.receivedPacketHandler, s.datagramQueue, s.perspective)\n\tif len(tlsConf.ServerName) > 0 {\n\t\ts.tokenStoreKey = tlsConf.ServerName\n\t} else {\n\t\ts.tokenStoreKey = conn.RemoteAddr().String()\n\t}\n\tif s.config.TokenStore != nil {\n\t\tif token := s.config.TokenStore.Pop(s.tokenStoreKey); token != nil {\n\t\t\ts.packer.SetToken(token.data)\n\t\t}\n\t}\n\treturn s\n}\n\nfunc (s *connection) preSetup() {\n\ts.initialStream = newCryptoStream()\n\ts.handshakeStream = newCryptoStream()\n\ts.sendQueue = newSendQueue(s.conn)\n\ts.retransmissionQueue = newRetransmissionQueue()\n\ts.frameParser = wire.NewFrameParser(s.config.EnableDatagrams)\n\ts.rttStats = &utils.RTTStats{}\n\ts.connFlowController = flowcontrol.NewConnectionFlowController(\n\t\tprotocol.ByteCount(s.config.InitialConnectionReceiveWindow),\n\t\tprotocol.ByteCount(s.config.MaxConnectionReceiveWindow),\n\t\ts.onHasConnectionWindowUpdate,\n\t\tfunc(size protocol.ByteCount) bool {\n\t\t\tif s.config.AllowConnectionWindowIncrease == nil {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn s.config.AllowConnectionWindowIncrease(s, uint64(size))\n\t\t},\n\t\ts.rttStats,\n\t\ts.logger,\n\t)\n\ts.earlyConnReadyChan = make(chan struct{})\n\ts.streamsMap = newStreamsMap(\n\t\ts,\n\t\ts.newFlowController,\n\t\tuint64(s.config.MaxIncomingStreams),\n\t\tuint64(s.config.MaxIncomingUniStreams),\n\t\ts.perspective,\n\t)\n\ts.framer = newFramer(s.streamsMap)\n\ts.receivedPackets = make(chan receivedPacket, protocol.MaxConnUnprocessedPackets)\n\ts.closeChan = make(chan closeError, 1)\n\ts.sendingScheduled = make(chan struct{}, 1)\n\ts.handshakeCtx, s.handshakeCtxCancel = context.WithCancel(context.Background())\n\n\tnow := time.Now()\n\ts.lastPacketReceivedTime = now\n\ts.creationTime = now\n\n\ts.windowUpdateQueue = newWindowUpdateQueue(s.streamsMap, s.connFlowController, s.framer.QueueControlFrame)\n\ts.datagramQueue = newDatagramQueue(s.scheduleSending, s.logger)\n\ts.connState.Version = s.version\n}\n\n// run the connection main loop\nfunc (s *connection) run() error {\n\tvar closeErr closeError\n\tdefer func() {\n\t\ts.ctxCancel(closeErr.err)\n\t}()\n\n\ts.timer = *newTimer()\n\n\tif err := s.cryptoStreamHandler.StartHandshake(); err != nil {\n\t\treturn err\n\t}\n\tif err := s.handleHandshakeEvents(); err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\tif err := s.sendQueue.Run(); err != nil {\n\t\t\ts.destroyImpl(err)\n\t\t}\n\t}()\n\n\tif s.perspective == protocol.PerspectiveClient {\n\t\ts.scheduleSending() // so the ClientHello actually gets sent\n\t}\n\n\tvar sendQueueAvailable <-chan struct{}\n\nrunLoop:\n\tfor {\n\t\t// Close immediately if requested\n\t\tselect {\n\t\tcase closeErr = <-s.closeChan:\n\t\t\tbreak runLoop\n\t\tdefault:\n\t\t}\n\n\t\ts.maybeResetTimer()\n\n\t\tvar processedUndecryptablePacket bool\n\t\tif len(s.undecryptablePacketsToProcess) > 0 {\n\t\t\tqueue := s.undecryptablePacketsToProcess\n\t\t\ts.undecryptablePacketsToProcess = nil\n\t\t\tfor _, p := range queue {\n\t\t\t\tif processed := s.handlePacketImpl(p); processed {\n\t\t\t\t\tprocessedUndecryptablePacket = true\n\t\t\t\t}\n\t\t\t\t// Don't set timers and send packets if the packet made us close the connection.\n\t\t\t\tselect {\n\t\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\t\tbreak runLoop\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If we processed any undecryptable packets, jump to the resetting of the timers directly.\n\t\tif !processedUndecryptablePacket {\n\t\t\tselect {\n\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\tbreak runLoop\n\t\t\tcase <-s.timer.Chan():\n\t\t\t\ts.timer.SetRead()\n\t\t\t\t// We do all the interesting stuff after the switch statement, so\n\t\t\t\t// nothing to see here.\n\t\t\tcase <-s.sendingScheduled:\n\t\t\t\t// We do all the interesting stuff after the switch statement, so\n\t\t\t\t// nothing to see here.\n\t\t\tcase <-sendQueueAvailable:\n\t\t\tcase firstPacket := <-s.receivedPackets:\n\t\t\t\twasProcessed := s.handlePacketImpl(firstPacket)\n\t\t\t\t// Don't set timers and send packets if the packet made us close the connection.\n\t\t\t\tselect {\n\t\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\t\tbreak runLoop\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t\tif s.handshakeComplete {\n\t\t\t\t\t// Now process all packets in the receivedPackets channel.\n\t\t\t\t\t// Limit the number of packets to the length of the receivedPackets channel,\n\t\t\t\t\t// so we eventually get a chance to send out an ACK when receiving a lot of packets.\n\t\t\t\t\tnumPackets := len(s.receivedPackets)\n\t\t\t\treceiveLoop:\n\t\t\t\t\tfor i := 0; i < numPackets; i++ {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase p := <-s.receivedPackets:\n\t\t\t\t\t\t\tif processed := s.handlePacketImpl(p); processed {\n\t\t\t\t\t\t\t\twasProcessed = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tselect {\n\t\t\t\t\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\t\t\t\t\tbreak runLoop\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak receiveLoop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Only reset the timers if this packet was actually processed.\n\t\t\t\t// This avoids modifying any state when handling undecryptable packets,\n\t\t\t\t// which could be injected by an attacker.\n\t\t\t\tif !wasProcessed {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnow := time.Now()\n\t\tif timeout := s.sentPacketHandler.GetLossDetectionTimeout(); !timeout.IsZero() && timeout.Before(now) {\n\t\t\t// This could cause packets to be retransmitted.\n\t\t\t// Check it before trying to send packets.\n\t\t\tif err := s.sentPacketHandler.OnLossDetectionTimeout(); err != nil {\n\t\t\t\ts.closeLocal(err)\n\t\t\t}\n\t\t}\n\n\t\tif keepAliveTime := s.nextKeepAliveTime(); !keepAliveTime.IsZero() && !now.Before(keepAliveTime) {\n\t\t\t// send a PING frame since there is no activity in the connection\n\t\t\ts.logger.Debugf(\"Sending a keep-alive PING to keep the connection alive.\")\n\t\t\ts.framer.QueueControlFrame(&wire.PingFrame{})\n\t\t\ts.keepAlivePingSent = true\n\t\t} else if !s.handshakeComplete && now.Sub(s.creationTime) >= s.config.handshakeTimeout() {\n\t\t\ts.destroyImpl(qerr.ErrHandshakeTimeout)\n\t\t\tcontinue\n\t\t} else {\n\t\t\tidleTimeoutStartTime := s.idleTimeoutStartTime()\n\t\t\tif (!s.handshakeComplete && now.Sub(idleTimeoutStartTime) >= s.config.HandshakeIdleTimeout) ||\n\t\t\t\t(s.handshakeComplete && now.After(s.nextIdleTimeoutTime())) {\n\t\t\t\ts.destroyImpl(qerr.ErrIdleTimeout)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\t// The send queue is still busy sending out packets.\n\t\t\t// Wait until there's space to enqueue new packets.\n\t\t\tsendQueueAvailable = s.sendQueue.Available()\n\t\t\tcontinue\n\t\t}\n\t\tif err := s.triggerSending(); err != nil {\n\t\t\ts.closeLocal(err)\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\tsendQueueAvailable = s.sendQueue.Available()\n\t\t} else {\n\t\t\tsendQueueAvailable = nil\n\t\t}\n\t}\n\n\ts.cryptoStreamHandler.Close()\n\ts.sendQueue.Close() // close the send queue before sending the CONNECTION_CLOSE\n\ts.handleCloseError(&closeErr)\n\tif e := (&errCloseForRecreating{}); !errors.As(closeErr.err, &e) && s.tracer != nil {\n\t\ts.tracer.Close()\n\t}\n\ts.logger.Infof(\"Connection %s closed.\", s.logID)\n\ts.timer.Stop()\n\treturn closeErr.err\n}\n\n// blocks until the early connection can be used\nfunc (s *connection) earlyConnReady() <-chan struct{} {\n\treturn s.earlyConnReadyChan\n}\n\nfunc (s *connection) HandshakeComplete() <-chan struct{} {\n\treturn s.handshakeCtx.Done()\n}\n\nfunc (s *connection) Context() context.Context {\n\treturn s.ctx\n}\n\nfunc (s *connection) supportsDatagrams() bool {\n\treturn s.peerParams.MaxDatagramFrameSize > 0\n}\n\nfunc (s *connection) ConnectionState() ConnectionState {\n\ts.connStateMutex.Lock()\n\tdefer s.connStateMutex.Unlock()\n\tcs := s.cryptoStreamHandler.ConnectionState()\n\ts.connState.TLS = cs.ConnectionState\n\ts.connState.Used0RTT = cs.Used0RTT\n\treturn s.connState\n}\n\n// Time when the connection should time out\nfunc (s *connection) nextIdleTimeoutTime() time.Time {\n\tidleTimeout := utils.Max(s.idleTimeout, s.rttStats.PTO(true)*3)\n\treturn s.idleTimeoutStartTime().Add(idleTimeout)\n}\n\n// Time when the next keep-alive packet should be sent.\n// It returns a zero time if no keep-alive should be sent.\nfunc (s *connection) nextKeepAliveTime() time.Time {\n\tif s.config.KeepAlivePeriod == 0 || s.keepAlivePingSent || !s.firstAckElicitingPacketAfterIdleSentTime.IsZero() {\n\t\treturn time.Time{}\n\t}\n\tkeepAliveInterval := utils.Max(s.keepAliveInterval, s.rttStats.PTO(true)*3/2)\n\treturn s.lastPacketReceivedTime.Add(keepAliveInterval)\n}\n\nfunc (s *connection) maybeResetTimer() {\n\tvar deadline time.Time\n\tif !s.handshakeComplete {\n\t\tdeadline = utils.MinTime(\n\t\t\ts.creationTime.Add(s.config.handshakeTimeout()),\n\t\t\ts.idleTimeoutStartTime().Add(s.config.HandshakeIdleTimeout),\n\t\t)\n\t} else {\n\t\tif keepAliveTime := s.nextKeepAliveTime(); !keepAliveTime.IsZero() {\n\t\t\tdeadline = keepAliveTime\n\t\t} else {\n\t\t\tdeadline = s.nextIdleTimeoutTime()\n\t\t}\n\t}\n\n\ts.timer.SetTimer(\n\t\tdeadline,\n\t\ts.receivedPacketHandler.GetAlarmTimeout(),\n\t\ts.sentPacketHandler.GetLossDetectionTimeout(),\n\t\ts.pacingDeadline,\n\t)\n}\n\nfunc (s *connection) idleTimeoutStartTime() time.Time {\n\treturn utils.MaxTime(s.lastPacketReceivedTime, s.firstAckElicitingPacketAfterIdleSentTime)\n}\n\nfunc (s *connection) handleHandshakeComplete() error {\n\tdefer s.handshakeCtxCancel()\n\t// Once the handshake completes, we have derived 1-RTT keys.\n\t// There's no point in queueing undecryptable packets for later decryption anymore.\n\ts.undecryptablePackets = nil\n\n\ts.connIDManager.SetHandshakeComplete()\n\ts.connIDGenerator.SetHandshakeComplete()\n\n\t// The server applies transport parameters right away, but the client side has to wait for handshake completion.\n\t// During a 0-RTT connection, the client is only allowed to use the new transport parameters for 1-RTT packets.\n\tif s.perspective == protocol.PerspectiveClient {\n\t\ts.applyTransportParameters()\n\t\treturn nil\n\t}\n\n\t// All these only apply to the server side.\n\tif err := s.handleHandshakeConfirmed(); err != nil {\n\t\treturn err\n\t}\n\n\tticket, err := s.cryptoStreamHandler.GetSessionTicket()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ticket != nil { // may be nil if session tickets are disabled via tls.Config.SessionTicketsDisabled\n\t\ts.oneRTTStream.Write(ticket)\n\t\tfor s.oneRTTStream.HasData() {\n\t\t\ts.queueControlFrame(s.oneRTTStream.PopCryptoFrame(protocol.MaxPostHandshakeCryptoFrameSize))\n\t\t}\n\t}\n\ttoken, err := s.tokenGenerator.NewToken(s.conn.RemoteAddr())\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.queueControlFrame(&wire.NewTokenFrame{Token: token})\n\ts.queueControlFrame(&wire.HandshakeDoneFrame{})\n\treturn nil\n}\n\nfunc (s *connection) handleHandshakeConfirmed() error {\n\tif err := s.dropEncryptionLevel(protocol.EncryptionHandshake); err != nil {\n\t\treturn err\n\t}\n\n\ts.handshakeConfirmed = true\n\ts.sentPacketHandler.SetHandshakeConfirmed()\n\ts.cryptoStreamHandler.SetHandshakeConfirmed()\n\n\tif !s.config.DisablePathMTUDiscovery && s.conn.capabilities().DF {\n\t\tmaxPacketSize := s.peerParams.MaxUDPPayloadSize\n\t\tif maxPacketSize == 0 {\n\t\t\tmaxPacketSize = protocol.MaxByteCount\n\t\t}\n\t\ts.mtuDiscoverer.Start(utils.Min(maxPacketSize, protocol.MaxPacketBufferSize))\n\t}\n\treturn nil\n}\n\nfunc (s *connection) handlePacketImpl(rp receivedPacket) bool {\n\ts.sentPacketHandler.ReceivedBytes(rp.Size())\n\n\tif wire.IsVersionNegotiationPacket(rp.data) {\n\t\ts.handleVersionNegotiationPacket(rp)\n\t\treturn false\n\t}\n\n\tvar counter uint8\n\tvar lastConnID protocol.ConnectionID\n\tvar processed bool\n\tdata := rp.data\n\tp := rp\n\tfor len(data) > 0 {\n\t\tvar destConnID protocol.ConnectionID\n\t\tif counter > 0 {\n\t\t\tp = *(p.Clone())\n\t\t\tp.data = data\n\n\t\t\tvar err error\n\t\t\tdestConnID, err = wire.ParseConnectionID(p.data, s.srcConnIDLen)\n\t\t\tif err != nil {\n\t\t\t\tif s.tracer != nil {\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.ByteCount(len(data)), logging.PacketDropHeaderParseError)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"error parsing packet, couldn't parse connection ID: %s\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif destConnID != lastConnID {\n\t\t\t\tif s.tracer != nil {\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.ByteCount(len(data)), logging.PacketDropUnknownConnectionID)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"coalesced packet has different destination connection ID: %s, expected %s\", destConnID, lastConnID)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif wire.IsLongHeaderPacket(p.data[0]) {\n\t\t\thdr, packetData, rest, err := wire.ParsePacket(p.data)\n\t\t\tif err != nil {\n\t\t\t\tif s.tracer != nil {\n\t\t\t\t\tdropReason := logging.PacketDropHeaderParseError\n\t\t\t\t\tif err == wire.ErrUnsupportedVersion {\n\t\t\t\t\t\tdropReason = logging.PacketDropUnsupportedVersion\n\t\t\t\t\t}\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.ByteCount(len(data)), dropReason)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"error parsing packet: %s\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlastConnID = hdr.DestConnectionID\n\n\t\t\tif hdr.Version != s.version {\n\t\t\t\tif s.tracer != nil {\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeFromHeader(hdr), protocol.ByteCount(len(data)), logging.PacketDropUnexpectedVersion)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"Dropping packet with version %x. Expected %x.\", hdr.Version, s.version)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif counter > 0 {\n\t\t\t\tp.buffer.Split()\n\t\t\t}\n\t\t\tcounter++\n\n\t\t\t// only log if this actually a coalesced packet\n\t\t\tif s.logger.Debug() && (counter > 1 || len(rest) > 0) {\n\t\t\t\ts.logger.Debugf(\"Parsed a coalesced packet. Part %d: %d bytes. Remaining: %d bytes.\", counter, len(packetData), len(rest))\n\t\t\t}\n\n\t\t\tp.data = packetData\n\n\t\t\tif wasProcessed := s.handleLongHeaderPacket(p, hdr); wasProcessed {\n\t\t\t\tprocessed = true\n\t\t\t}\n\t\t\tdata = rest\n\t\t} else {\n\t\t\tif counter > 0 {\n\t\t\t\tp.buffer.Split()\n\t\t\t}\n\t\t\tprocessed = s.handleShortHeaderPacket(p, destConnID)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tp.buffer.MaybeRelease()\n\treturn processed\n}\n\nfunc (s *connection) handleShortHeaderPacket(p receivedPacket, destConnID protocol.ConnectionID) bool {\n\tvar wasQueued bool\n\n\tdefer func() {\n\t\t// Put back the packet buffer if the packet wasn't queued for later decryption.\n\t\tif !wasQueued {\n\t\t\tp.buffer.Decrement()\n\t\t}\n\t}()\n\n\tpn, pnLen, keyPhase, data, err := s.unpacker.UnpackShortHeader(p.rcvTime, p.data)\n\tif err != nil {\n\t\twasQueued = s.handleUnpackError(err, p, logging.PacketType1RTT)\n\t\treturn false\n\t}\n\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"<- Reading packet %d (%d bytes) for connection %s, 1-RTT\", pn, p.Size(), destConnID)\n\t\twire.LogShortHeader(s.logger, destConnID, pn, pnLen, keyPhase)\n\t}\n\n\tif s.receivedPacketHandler.IsPotentiallyDuplicate(pn, protocol.Encryption1RTT) {\n\t\ts.logger.Debugf(\"Dropping (potentially) duplicate packet.\")\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketType1RTT, p.Size(), logging.PacketDropDuplicate)\n\t\t}\n\t\treturn false\n\t}\n\n\tvar log func([]logging.Frame)\n\tif s.tracer != nil {\n\t\tlog = func(frames []logging.Frame) {\n\t\t\ts.tracer.ReceivedShortHeaderPacket(\n\t\t\t\t&logging.ShortHeader{\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tPacketNumber:     pn,\n\t\t\t\t\tPacketNumberLen:  pnLen,\n\t\t\t\t\tKeyPhase:         keyPhase,\n\t\t\t\t},\n\t\t\t\tp.Size(),\n\t\t\t\tframes,\n\t\t\t)\n\t\t}\n\t}\n\tif err := s.handleUnpackedShortHeaderPacket(destConnID, pn, data, p.ecn, p.rcvTime, log); err != nil {\n\t\ts.closeLocal(err)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (s *connection) handleLongHeaderPacket(p receivedPacket, hdr *wire.Header) bool /* was the packet successfully processed */ {\n\tvar wasQueued bool\n\n\tdefer func() {\n\t\t// Put back the packet buffer if the packet wasn't queued for later decryption.\n\t\tif !wasQueued {\n\t\t\tp.buffer.Decrement()\n\t\t}\n\t}()\n\n\tif hdr.Type == protocol.PacketTypeRetry {\n\t\treturn s.handleRetryPacket(hdr, p.data)\n\t}\n\n\t// The server can change the source connection ID with the first Handshake packet.\n\t// After this, all packets with a different source connection have to be ignored.\n\tif s.receivedFirstPacket && hdr.Type == protocol.PacketTypeInitial && hdr.SrcConnectionID != s.handshakeDestConnID {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeInitial, p.Size(), logging.PacketDropUnknownConnectionID)\n\t\t}\n\t\ts.logger.Debugf(\"Dropping Initial packet (%d bytes) with unexpected source connection ID: %s (expected %s)\", p.Size(), hdr.SrcConnectionID, s.handshakeDestConnID)\n\t\treturn false\n\t}\n\t// drop 0-RTT packets, if we are a client\n\tif s.perspective == protocol.PerspectiveClient && hdr.Type == protocol.PacketType0RTT {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketType0RTT, p.Size(), logging.PacketDropKeyUnavailable)\n\t\t}\n\t\treturn false\n\t}\n\n\tpacket, err := s.unpacker.UnpackLongHeader(hdr, p.rcvTime, p.data, s.version)\n\tif err != nil {\n\t\twasQueued = s.handleUnpackError(err, p, logging.PacketTypeFromHeader(hdr))\n\t\treturn false\n\t}\n\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"<- Reading packet %d (%d bytes) for connection %s, %s\", packet.hdr.PacketNumber, p.Size(), hdr.DestConnectionID, packet.encryptionLevel)\n\t\tpacket.hdr.Log(s.logger)\n\t}\n\n\tif s.receivedPacketHandler.IsPotentiallyDuplicate(packet.hdr.PacketNumber, packet.encryptionLevel) {\n\t\ts.logger.Debugf(\"Dropping (potentially) duplicate packet.\")\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeFromHeader(hdr), p.Size(), logging.PacketDropDuplicate)\n\t\t}\n\t\treturn false\n\t}\n\n\tif err := s.handleUnpackedLongHeaderPacket(packet, p.ecn, p.rcvTime, p.Size()); err != nil {\n\t\ts.closeLocal(err)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (s *connection) handleUnpackError(err error, p receivedPacket, pt logging.PacketType) (wasQueued bool) {\n\tswitch err {\n\tcase handshake.ErrKeysDropped:\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(pt, p.Size(), logging.PacketDropKeyUnavailable)\n\t\t}\n\t\ts.logger.Debugf(\"Dropping %s packet (%d bytes) because we already dropped the keys.\", pt, p.Size())\n\tcase handshake.ErrKeysNotYetAvailable:\n\t\t// Sealer for this encryption level not yet available.\n\t\t// Try again later.\n\t\ts.tryQueueingUndecryptablePacket(p, pt)\n\t\treturn true\n\tcase wire.ErrInvalidReservedBits:\n\t\ts.closeLocal(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: err.Error(),\n\t\t})\n\tcase handshake.ErrDecryptionFailed:\n\t\t// This might be a packet injected by an attacker. Drop it.\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(pt, p.Size(), logging.PacketDropPayloadDecryptError)\n\t\t}\n\t\ts.logger.Debugf(\"Dropping %s packet (%d bytes) that could not be unpacked. Error: %s\", pt, p.Size(), err)\n\tdefault:\n\t\tvar headerErr *headerParseError\n\t\tif errors.As(err, &headerErr) {\n\t\t\t// This might be a packet injected by an attacker. Drop it.\n\t\t\tif s.tracer != nil {\n\t\t\t\ts.tracer.DroppedPacket(pt, p.Size(), logging.PacketDropHeaderParseError)\n\t\t\t}\n\t\t\ts.logger.Debugf(\"Dropping %s packet (%d bytes) for which we couldn't unpack the header. Error: %s\", pt, p.Size(), err)\n\t\t} else {\n\t\t\t// This is an error returned by the AEAD (other than ErrDecryptionFailed).\n\t\t\t// For example, a PROTOCOL_VIOLATION due to key updates.\n\t\t\ts.closeLocal(err)\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *connection) handleRetryPacket(hdr *wire.Header, data []byte) bool /* was this a valid Retry */ {\n\tif s.perspective == protocol.PerspectiveServer {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring Retry.\")\n\t\treturn false\n\t}\n\tif s.receivedFirstPacket {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring Retry, since we already received a packet.\")\n\t\treturn false\n\t}\n\tdestConnID := s.connIDManager.Get()\n\tif hdr.SrcConnectionID == destConnID {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring Retry, since the server didn't change the Source Connection ID.\")\n\t\treturn false\n\t}\n\t// If a token is already set, this means that we already received a Retry from the server.\n\t// Ignore this Retry packet.\n\tif s.receivedRetry {\n\t\ts.logger.Debugf(\"Ignoring Retry, since a Retry was already received.\")\n\t\treturn false\n\t}\n\n\ttag := handshake.GetRetryIntegrityTag(data[:len(data)-16], destConnID, hdr.Version)\n\tif !bytes.Equal(data[len(data)-16:], tag[:]) {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.ByteCount(len(data)), logging.PacketDropPayloadDecryptError)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring spoofed Retry. Integrity Tag doesn't match.\")\n\t\treturn false\n\t}\n\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"<- Received Retry:\")\n\t\t(&wire.ExtendedHeader{Header: *hdr}).Log(s.logger)\n\t\ts.logger.Debugf(\"Switching destination connection ID to: %s\", hdr.SrcConnectionID)\n\t}\n\tif s.tracer != nil {\n\t\ts.tracer.ReceivedRetry(hdr)\n\t}\n\tnewDestConnID := hdr.SrcConnectionID\n\ts.receivedRetry = true\n\tif err := s.sentPacketHandler.ResetForRetry(); err != nil {\n\t\ts.closeLocal(err)\n\t\treturn false\n\t}\n\ts.handshakeDestConnID = newDestConnID\n\ts.retrySrcConnID = &newDestConnID\n\ts.cryptoStreamHandler.ChangeConnectionID(newDestConnID)\n\ts.packer.SetToken(hdr.Token)\n\ts.connIDManager.ChangeInitialConnID(newDestConnID)\n\ts.scheduleSending()\n\treturn true\n}\n\nfunc (s *connection) handleVersionNegotiationPacket(p receivedPacket) {\n\tif s.perspective == protocol.PerspectiveServer || // servers never receive version negotiation packets\n\t\ts.receivedFirstPacket || s.versionNegotiated { // ignore delayed / duplicated version negotiation packets\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\treturn\n\t}\n\n\tsrc, dest, supportedVersions, err := wire.ParseVersionNegotiationPacket(p.data)\n\tif err != nil {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropHeaderParseError)\n\t\t}\n\t\ts.logger.Debugf(\"Error parsing Version Negotiation packet: %s\", err)\n\t\treturn\n\t}\n\n\tfor _, v := range supportedVersions {\n\t\tif v == s.version {\n\t\t\tif s.tracer != nil {\n\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropUnexpectedVersion)\n\t\t\t}\n\t\t\t// The Version Negotiation packet contains the version that we offered.\n\t\t\t// This might be a packet sent by an attacker, or it was corrupted.\n\t\t\treturn\n\t\t}\n\t}\n\n\ts.logger.Infof(\"Received a Version Negotiation packet. Supported Versions: %s\", supportedVersions)\n\tif s.tracer != nil {\n\t\ts.tracer.ReceivedVersionNegotiationPacket(dest, src, supportedVersions)\n\t}\n\tnewVersion, ok := protocol.ChooseSupportedVersion(s.config.Versions, supportedVersions)\n\tif !ok {\n\t\ts.destroyImpl(&VersionNegotiationError{\n\t\t\tOurs:   s.config.Versions,\n\t\t\tTheirs: supportedVersions,\n\t\t})\n\t\ts.logger.Infof(\"No compatible QUIC version found.\")\n\t\treturn\n\t}\n\tif s.tracer != nil {\n\t\ts.tracer.NegotiatedVersion(newVersion, s.config.Versions, supportedVersions)\n\t}\n\n\ts.logger.Infof(\"Switching to QUIC version %s.\", newVersion)\n\tnextPN, _ := s.sentPacketHandler.PeekPacketNumber(protocol.EncryptionInitial)\n\ts.destroyImpl(&errCloseForRecreating{\n\t\tnextPacketNumber: nextPN,\n\t\tnextVersion:      newVersion,\n\t})\n}\n\nfunc (s *connection) handleUnpackedLongHeaderPacket(\n\tpacket *unpackedPacket,\n\tecn protocol.ECN,\n\trcvTime time.Time,\n\tpacketSize protocol.ByteCount, // only for logging\n) error {\n\tif !s.receivedFirstPacket {\n\t\ts.receivedFirstPacket = true\n\t\tif !s.versionNegotiated && s.tracer != nil {\n\t\t\tvar clientVersions, serverVersions []protocol.VersionNumber\n\t\t\tswitch s.perspective {\n\t\t\tcase protocol.PerspectiveClient:\n\t\t\t\tclientVersions = s.config.Versions\n\t\t\tcase protocol.PerspectiveServer:\n\t\t\t\tserverVersions = s.config.Versions\n\t\t\t}\n\t\t\ts.tracer.NegotiatedVersion(s.version, clientVersions, serverVersions)\n\t\t}\n\t\t// The server can change the source connection ID with the first Handshake packet.\n\t\tif s.perspective == protocol.PerspectiveClient && packet.hdr.SrcConnectionID != s.handshakeDestConnID {\n\t\t\tcid := packet.hdr.SrcConnectionID\n\t\t\ts.logger.Debugf(\"Received first packet. Switching destination connection ID to: %s\", cid)\n\t\t\ts.handshakeDestConnID = cid\n\t\t\ts.connIDManager.ChangeInitialConnID(cid)\n\t\t}\n\t\t// We create the connection as soon as we receive the first packet from the client.\n\t\t// We do that before authenticating the packet.\n\t\t// That means that if the source connection ID was corrupted,\n\t\t// we might have created a connection with an incorrect source connection ID.\n\t\t// Once we authenticate the first packet, we need to update it.\n\t\tif s.perspective == protocol.PerspectiveServer {\n\t\t\tif packet.hdr.SrcConnectionID != s.handshakeDestConnID {\n\t\t\t\ts.handshakeDestConnID = packet.hdr.SrcConnectionID\n\t\t\t\ts.connIDManager.ChangeInitialConnID(packet.hdr.SrcConnectionID)\n\t\t\t}\n\t\t\tif s.tracer != nil {\n\t\t\t\ts.tracer.StartedConnection(\n\t\t\t\t\ts.conn.LocalAddr(),\n\t\t\t\t\ts.conn.RemoteAddr(),\n\t\t\t\t\tpacket.hdr.SrcConnectionID,\n\t\t\t\t\tpacket.hdr.DestConnectionID,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tif s.perspective == protocol.PerspectiveServer && packet.encryptionLevel == protocol.EncryptionHandshake {\n\t\t// On the server side, Initial keys are dropped as soon as the first Handshake packet is received.\n\t\t// See Section 4.9.1 of RFC 9001.\n\t\tif err := s.dropEncryptionLevel(protocol.EncryptionInitial); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ts.lastPacketReceivedTime = rcvTime\n\ts.firstAckElicitingPacketAfterIdleSentTime = time.Time{}\n\ts.keepAlivePingSent = false\n\n\tvar log func([]logging.Frame)\n\tif s.tracer != nil {\n\t\tlog = func(frames []logging.Frame) {\n\t\t\ts.tracer.ReceivedLongHeaderPacket(packet.hdr, packetSize, frames)\n\t\t}\n\t}\n\tisAckEliciting, err := s.handleFrames(packet.data, packet.hdr.DestConnectionID, packet.encryptionLevel, log)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.receivedPacketHandler.ReceivedPacket(packet.hdr.PacketNumber, ecn, packet.encryptionLevel, rcvTime, isAckEliciting)\n}\n\nfunc (s *connection) handleUnpackedShortHeaderPacket(\n\tdestConnID protocol.ConnectionID,\n\tpn protocol.PacketNumber,\n\tdata []byte,\n\tecn protocol.ECN,\n\trcvTime time.Time,\n\tlog func([]logging.Frame),\n) error {\n\ts.lastPacketReceivedTime = rcvTime\n\ts.firstAckElicitingPacketAfterIdleSentTime = time.Time{}\n\ts.keepAlivePingSent = false\n\n\tisAckEliciting, err := s.handleFrames(data, destConnID, protocol.Encryption1RTT, log)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.receivedPacketHandler.ReceivedPacket(pn, ecn, protocol.Encryption1RTT, rcvTime, isAckEliciting)\n}\n\nfunc (s *connection) handleFrames(\n\tdata []byte,\n\tdestConnID protocol.ConnectionID,\n\tencLevel protocol.EncryptionLevel,\n\tlog func([]logging.Frame),\n) (isAckEliciting bool, _ error) {\n\t// Only used for tracing.\n\t// If we're not tracing, this slice will always remain empty.\n\tvar frames []logging.Frame\n\tif log != nil {\n\t\tframes = make([]logging.Frame, 0, 4)\n\t}\n\thandshakeWasComplete := s.handshakeComplete\n\tvar handleErr error\n\tfor len(data) > 0 {\n\t\tl, frame, err := s.frameParser.ParseNext(data, encLevel, s.version)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tdata = data[l:]\n\t\tif frame == nil {\n\t\t\tbreak\n\t\t}\n\t\tif ackhandler.IsFrameAckEliciting(frame) {\n\t\t\tisAckEliciting = true\n\t\t}\n\t\tif log != nil {\n\t\t\tframes = append(frames, logutils.ConvertFrame(frame))\n\t\t}\n\t\t// An error occurred handling a previous frame.\n\t\t// Don't handle the current frame.\n\t\tif handleErr != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := s.handleFrame(frame, encLevel, destConnID); err != nil {\n\t\t\tif log == nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t\t// If we're logging, we need to keep parsing (but not handling) all frames.\n\t\t\thandleErr = err\n\t\t}\n\t}\n\n\tif log != nil {\n\t\tlog(frames)\n\t\tif handleErr != nil {\n\t\t\treturn false, handleErr\n\t\t}\n\t}\n\n\t// Handle completion of the handshake after processing all the frames.\n\t// This ensures that we correctly handle the following case on the server side:\n\t// We receive a Handshake packet that contains the CRYPTO frame that allows us to complete the handshake,\n\t// and an ACK serialized after that CRYPTO frame. In this case, we still want to process the ACK frame.\n\tif !handshakeWasComplete && s.handshakeComplete {\n\t\tif err := s.handleHandshakeComplete(); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (s *connection) handleFrame(f wire.Frame, encLevel protocol.EncryptionLevel, destConnID protocol.ConnectionID) error {\n\tvar err error\n\twire.LogFrame(s.logger, f, false)\n\tswitch frame := f.(type) {\n\tcase *wire.CryptoFrame:\n\t\terr = s.handleCryptoFrame(frame, encLevel)\n\tcase *wire.StreamFrame:\n\t\terr = s.handleStreamFrame(frame)\n\tcase *wire.AckFrame:\n\t\terr = s.handleAckFrame(frame, encLevel)\n\tcase *wire.ConnectionCloseFrame:\n\t\ts.handleConnectionCloseFrame(frame)\n\tcase *wire.ResetStreamFrame:\n\t\terr = s.handleResetStreamFrame(frame)\n\tcase *wire.MaxDataFrame:\n\t\ts.handleMaxDataFrame(frame)\n\tcase *wire.MaxStreamDataFrame:\n\t\terr = s.handleMaxStreamDataFrame(frame)\n\tcase *wire.MaxStreamsFrame:\n\t\ts.handleMaxStreamsFrame(frame)\n\tcase *wire.DataBlockedFrame:\n\tcase *wire.StreamDataBlockedFrame:\n\tcase *wire.StreamsBlockedFrame:\n\tcase *wire.StopSendingFrame:\n\t\terr = s.handleStopSendingFrame(frame)\n\tcase *wire.PingFrame:\n\tcase *wire.PathChallengeFrame:\n\t\ts.handlePathChallengeFrame(frame)\n\tcase *wire.PathResponseFrame:\n\t\t// since we don't send PATH_CHALLENGEs, we don't expect PATH_RESPONSEs\n\t\terr = errors.New(\"unexpected PATH_RESPONSE frame\")\n\tcase *wire.NewTokenFrame:\n\t\terr = s.handleNewTokenFrame(frame)\n\tcase *wire.NewConnectionIDFrame:\n\t\terr = s.handleNewConnectionIDFrame(frame)\n\tcase *wire.RetireConnectionIDFrame:\n\t\terr = s.handleRetireConnectionIDFrame(frame, destConnID)\n\tcase *wire.HandshakeDoneFrame:\n\t\terr = s.handleHandshakeDoneFrame()\n\tcase *wire.DatagramFrame:\n\t\terr = s.handleDatagramFrame(frame)\n\tdefault:\n\t\terr = fmt.Errorf(\"unexpected frame type: %s\", reflect.ValueOf(&frame).Elem().Type().Name())\n\t}\n\treturn err\n}\n\n// handlePacket is called by the server with a new packet\nfunc (s *connection) handlePacket(p receivedPacket) {\n\t// Discard packets once the amount of queued packets is larger than\n\t// the channel size, protocol.MaxConnUnprocessedPackets\n\tselect {\n\tcase s.receivedPackets <- p:\n\tdefault:\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropDOSPrevention)\n\t\t}\n\t}\n}\n\nfunc (s *connection) handleConnectionCloseFrame(frame *wire.ConnectionCloseFrame) {\n\tif frame.IsApplicationError {\n\t\ts.closeRemote(&qerr.ApplicationError{\n\t\t\tRemote:       true,\n\t\t\tErrorCode:    qerr.ApplicationErrorCode(frame.ErrorCode),\n\t\t\tErrorMessage: frame.ReasonPhrase,\n\t\t})\n\t\treturn\n\t}\n\ts.closeRemote(&qerr.TransportError{\n\t\tRemote:       true,\n\t\tErrorCode:    qerr.TransportErrorCode(frame.ErrorCode),\n\t\tFrameType:    frame.FrameType,\n\t\tErrorMessage: frame.ReasonPhrase,\n\t})\n}\n\nfunc (s *connection) handleCryptoFrame(frame *wire.CryptoFrame, encLevel protocol.EncryptionLevel) error {\n\tif err := s.cryptoStreamManager.HandleCryptoFrame(frame, encLevel); err != nil {\n\t\treturn err\n\t}\n\treturn s.handleHandshakeEvents()\n}\n\nfunc (s *connection) handleHandshakeEvents() error {\n\tfor {\n\t\tev := s.cryptoStreamHandler.NextEvent()\n\t\tvar err error\n\t\tswitch ev.Kind {\n\t\tcase handshake.EventNoEvent:\n\t\t\treturn nil\n\t\tcase handshake.EventHandshakeComplete:\n\t\t\t// Don't call handleHandshakeComplete yet.\n\t\t\t// It's advantageous to process ACK frames that might be serialized after the CRYPTO frame first.\n\t\t\ts.handshakeComplete = true\n\t\tcase handshake.EventReceivedTransportParameters:\n\t\t\terr = s.handleTransportParameters(ev.TransportParameters)\n\t\tcase handshake.EventRestoredTransportParameters:\n\t\t\ts.restoreTransportParameters(ev.TransportParameters)\n\t\t\tclose(s.earlyConnReadyChan)\n\t\tcase handshake.EventReceivedReadKeys:\n\t\t\t// Queue all packets for decryption that have been undecryptable so far.\n\t\t\ts.undecryptablePacketsToProcess = s.undecryptablePackets\n\t\t\ts.undecryptablePackets = nil\n\t\tcase handshake.EventDiscard0RTTKeys:\n\t\t\terr = s.dropEncryptionLevel(protocol.Encryption0RTT)\n\t\tcase handshake.EventWriteInitialData:\n\t\t\t_, err = s.initialStream.Write(ev.Data)\n\t\tcase handshake.EventWriteHandshakeData:\n\t\t\t_, err = s.handshakeStream.Write(ev.Data)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *connection) handleStreamFrame(frame *wire.StreamFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenReceiveStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// Stream is closed and already garbage collected\n\t\t// ignore this StreamFrame\n\t\treturn nil\n\t}\n\treturn str.handleStreamFrame(frame)\n}\n\nfunc (s *connection) handleMaxDataFrame(frame *wire.MaxDataFrame) {\n\ts.connFlowController.UpdateSendWindow(frame.MaximumData)\n}\n\nfunc (s *connection) handleMaxStreamDataFrame(frame *wire.MaxStreamDataFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenSendStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// stream is closed and already garbage collected\n\t\treturn nil\n\t}\n\tstr.updateSendWindow(frame.MaximumStreamData)\n\treturn nil\n}\n\nfunc (s *connection) handleMaxStreamsFrame(frame *wire.MaxStreamsFrame) {\n\ts.streamsMap.HandleMaxStreamsFrame(frame)\n}\n\nfunc (s *connection) handleResetStreamFrame(frame *wire.ResetStreamFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenReceiveStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// stream is closed and already garbage collected\n\t\treturn nil\n\t}\n\treturn str.handleResetStreamFrame(frame)\n}\n\nfunc (s *connection) handleStopSendingFrame(frame *wire.StopSendingFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenSendStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// stream is closed and already garbage collected\n\t\treturn nil\n\t}\n\tstr.handleStopSendingFrame(frame)\n\treturn nil\n}\n\nfunc (s *connection) handlePathChallengeFrame(frame *wire.PathChallengeFrame) {\n\ts.queueControlFrame(&wire.PathResponseFrame{Data: frame.Data})\n}\n\nfunc (s *connection) handleNewTokenFrame(frame *wire.NewTokenFrame) error {\n\tif s.perspective == protocol.PerspectiveServer {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"received NEW_TOKEN frame from the client\",\n\t\t}\n\t}\n\tif s.config.TokenStore != nil {\n\t\ts.config.TokenStore.Put(s.tokenStoreKey, &ClientToken{data: frame.Token})\n\t}\n\treturn nil\n}\n\nfunc (s *connection) handleNewConnectionIDFrame(f *wire.NewConnectionIDFrame) error {\n\treturn s.connIDManager.Add(f)\n}\n\nfunc (s *connection) handleRetireConnectionIDFrame(f *wire.RetireConnectionIDFrame, destConnID protocol.ConnectionID) error {\n\treturn s.connIDGenerator.Retire(f.SequenceNumber, destConnID)\n}\n\nfunc (s *connection) handleHandshakeDoneFrame() error {\n\tif s.perspective == protocol.PerspectiveServer {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"received a HANDSHAKE_DONE frame\",\n\t\t}\n\t}\n\tif !s.handshakeConfirmed {\n\t\treturn s.handleHandshakeConfirmed()\n\t}\n\treturn nil\n}\n\nfunc (s *connection) handleAckFrame(frame *wire.AckFrame, encLevel protocol.EncryptionLevel) error {\n\tacked1RTTPacket, err := s.sentPacketHandler.ReceivedAck(frame, encLevel, s.lastPacketReceivedTime)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !acked1RTTPacket {\n\t\treturn nil\n\t}\n\t// On the client side: If the packet acknowledged a 1-RTT packet, this confirms the handshake.\n\t// This is only possible if the ACK was sent in a 1-RTT packet.\n\t// This is an optimization over simply waiting for a HANDSHAKE_DONE frame, see section 4.1.2 of RFC 9001.\n\tif s.perspective == protocol.PerspectiveClient && !s.handshakeConfirmed {\n\t\tif err := s.handleHandshakeConfirmed(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn s.cryptoStreamHandler.SetLargest1RTTAcked(frame.LargestAcked())\n}\n\nfunc (s *connection) handleDatagramFrame(f *wire.DatagramFrame) error {\n\tif f.Length(s.version) > protocol.MaxDatagramFrameSize {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"DATAGRAM frame too large\",\n\t\t}\n\t}\n\ts.datagramQueue.HandleDatagramFrame(f)\n\treturn nil\n}\n\n// closeLocal closes the connection and send a CONNECTION_CLOSE containing the error\nfunc (s *connection) closeLocal(e error) {\n\ts.closeOnce.Do(func() {\n\t\tif e == nil {\n\t\t\ts.logger.Infof(\"Closing connection.\")\n\t\t} else {\n\t\t\ts.logger.Errorf(\"Closing connection with error: %s\", e)\n\t\t}\n\t\ts.closeChan <- closeError{err: e, immediate: false, remote: false}\n\t})\n}\n\n// destroy closes the connection without sending the error on the wire\nfunc (s *connection) destroy(e error) {\n\ts.destroyImpl(e)\n\t<-s.ctx.Done()\n}\n\nfunc (s *connection) destroyImpl(e error) {\n\ts.closeOnce.Do(func() {\n\t\tif nerr, ok := e.(net.Error); ok && nerr.Timeout() {\n\t\t\ts.logger.Errorf(\"Destroying connection: %s\", e)\n\t\t} else {\n\t\t\ts.logger.Errorf(\"Destroying connection with error: %s\", e)\n\t\t}\n\t\ts.closeChan <- closeError{err: e, immediate: true, remote: false}\n\t})\n}\n\nfunc (s *connection) closeRemote(e error) {\n\ts.closeOnce.Do(func() {\n\t\ts.logger.Errorf(\"Peer closed connection with error: %s\", e)\n\t\ts.closeChan <- closeError{err: e, immediate: true, remote: true}\n\t})\n}\n\n// Close the connection. It sends a NO_ERROR application error.\n// It waits until the run loop has stopped before returning\nfunc (s *connection) shutdown() {\n\ts.closeLocal(nil)\n\t<-s.ctx.Done()\n}\n\nfunc (s *connection) CloseWithError(code ApplicationErrorCode, desc string) error {\n\ts.closeLocal(&qerr.ApplicationError{\n\t\tErrorCode:    code,\n\t\tErrorMessage: desc,\n\t})\n\t<-s.ctx.Done()\n\treturn nil\n}\n\nfunc (s *connection) handleCloseError(closeErr *closeError) {\n\te := closeErr.err\n\tif e == nil {\n\t\te = &qerr.ApplicationError{}\n\t} else {\n\t\tdefer func() {\n\t\t\tcloseErr.err = e\n\t\t}()\n\t}\n\n\tvar (\n\t\tstatelessResetErr     *StatelessResetError\n\t\tversionNegotiationErr *VersionNegotiationError\n\t\trecreateErr           *errCloseForRecreating\n\t\tapplicationErr        *ApplicationError\n\t\ttransportErr          *TransportError\n\t)\n\tswitch {\n\tcase errors.Is(e, qerr.ErrIdleTimeout),\n\t\terrors.Is(e, qerr.ErrHandshakeTimeout),\n\t\terrors.As(e, &statelessResetErr),\n\t\terrors.As(e, &versionNegotiationErr),\n\t\terrors.As(e, &recreateErr),\n\t\terrors.As(e, &applicationErr),\n\t\terrors.As(e, &transportErr):\n\tdefault:\n\t\te = &qerr.TransportError{\n\t\t\tErrorCode:    qerr.InternalError,\n\t\t\tErrorMessage: e.Error(),\n\t\t}\n\t}\n\n\ts.streamsMap.CloseWithError(e)\n\ts.connIDManager.Close()\n\tif s.datagramQueue != nil {\n\t\ts.datagramQueue.CloseWithError(e)\n\t}\n\n\tif s.tracer != nil && !errors.As(e, &recreateErr) {\n\t\ts.tracer.ClosedConnection(e)\n\t}\n\n\t// If this is a remote close we're done here\n\tif closeErr.remote {\n\t\ts.connIDGenerator.ReplaceWithClosed(s.perspective, nil)\n\t\treturn\n\t}\n\tif closeErr.immediate {\n\t\ts.connIDGenerator.RemoveAll()\n\t\treturn\n\t}\n\t// Don't send out any CONNECTION_CLOSE if this is an error that occurred\n\t// before we even sent out the first packet.\n\tif s.perspective == protocol.PerspectiveClient && !s.sentFirstPacket {\n\t\ts.connIDGenerator.RemoveAll()\n\t\treturn\n\t}\n\tconnClosePacket, err := s.sendConnectionClose(e)\n\tif err != nil {\n\t\ts.logger.Debugf(\"Error sending CONNECTION_CLOSE: %s\", err)\n\t}\n\ts.connIDGenerator.ReplaceWithClosed(s.perspective, connClosePacket)\n}\n\nfunc (s *connection) dropEncryptionLevel(encLevel protocol.EncryptionLevel) error {\n\tif s.tracer != nil {\n\t\ts.tracer.DroppedEncryptionLevel(encLevel)\n\t}\n\ts.sentPacketHandler.DropPackets(encLevel)\n\ts.receivedPacketHandler.DropPackets(encLevel)\n\t//nolint:exhaustive // only Initial and 0-RTT need special treatment\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\ts.cryptoStreamHandler.DiscardInitialKeys()\n\tcase protocol.Encryption0RTT:\n\t\ts.streamsMap.ResetFor0RTT()\n\t\tif err := s.connFlowController.Reset(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn s.framer.Handle0RTTRejection()\n\t}\n\treturn s.cryptoStreamManager.Drop(encLevel)\n}\n\n// is called for the client, when restoring transport parameters saved for 0-RTT\nfunc (s *connection) restoreTransportParameters(params *wire.TransportParameters) {\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"Restoring Transport Parameters: %s\", params)\n\t}\n\n\ts.peerParams = params\n\ts.connIDGenerator.SetMaxActiveConnIDs(params.ActiveConnectionIDLimit)\n\ts.connFlowController.UpdateSendWindow(params.InitialMaxData)\n\ts.streamsMap.UpdateLimits(params)\n\ts.connStateMutex.Lock()\n\ts.connState.SupportsDatagrams = s.supportsDatagrams()\n\ts.connStateMutex.Unlock()\n}\n\nfunc (s *connection) handleTransportParameters(params *wire.TransportParameters) error {\n\tif s.tracer != nil {\n\t\ts.tracer.ReceivedTransportParameters(params)\n\t}\n\tif err := s.checkTransportParameters(params); err != nil {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\tErrorMessage: err.Error(),\n\t\t}\n\t}\n\ts.peerParams = params\n\t// On the client side we have to wait for handshake completion.\n\t// During a 0-RTT connection, we are only allowed to use the new transport parameters for 1-RTT packets.\n\tif s.perspective == protocol.PerspectiveServer {\n\t\ts.applyTransportParameters()\n\t\t// On the server side, the early connection is ready as soon as we processed\n\t\t// the client's transport parameters.\n\t\tclose(s.earlyConnReadyChan)\n\t}\n\n\ts.connStateMutex.Lock()\n\ts.connState.SupportsDatagrams = s.supportsDatagrams()\n\ts.connStateMutex.Unlock()\n\treturn nil\n}\n\nfunc (s *connection) checkTransportParameters(params *wire.TransportParameters) error {\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"Processed Transport Parameters: %s\", params)\n\t}\n\n\t// check the initial_source_connection_id\n\tif params.InitialSourceConnectionID != s.handshakeDestConnID {\n\t\treturn fmt.Errorf(\"expected initial_source_connection_id to equal %s, is %s\", s.handshakeDestConnID, params.InitialSourceConnectionID)\n\t}\n\n\tif s.perspective == protocol.PerspectiveServer {\n\t\treturn nil\n\t}\n\t// check the original_destination_connection_id\n\tif params.OriginalDestinationConnectionID != s.origDestConnID {\n\t\treturn fmt.Errorf(\"expected original_destination_connection_id to equal %s, is %s\", s.origDestConnID, params.OriginalDestinationConnectionID)\n\t}\n\tif s.retrySrcConnID != nil { // a Retry was performed\n\t\tif params.RetrySourceConnectionID == nil {\n\t\t\treturn errors.New(\"missing retry_source_connection_id\")\n\t\t}\n\t\tif *params.RetrySourceConnectionID != *s.retrySrcConnID {\n\t\t\treturn fmt.Errorf(\"expected retry_source_connection_id to equal %s, is %s\", s.retrySrcConnID, *params.RetrySourceConnectionID)\n\t\t}\n\t} else if params.RetrySourceConnectionID != nil {\n\t\treturn errors.New(\"received retry_source_connection_id, although no Retry was performed\")\n\t}\n\treturn nil\n}\n\nfunc (s *connection) applyTransportParameters() {\n\tparams := s.peerParams\n\t// Our local idle timeout will always be > 0.\n\ts.idleTimeout = utils.MinNonZeroDuration(s.config.MaxIdleTimeout, params.MaxIdleTimeout)\n\ts.keepAliveInterval = utils.Min(s.config.KeepAlivePeriod, utils.Min(s.idleTimeout/2, protocol.MaxKeepAliveInterval))\n\ts.streamsMap.UpdateLimits(params)\n\ts.frameParser.SetAckDelayExponent(params.AckDelayExponent)\n\ts.connFlowController.UpdateSendWindow(params.InitialMaxData)\n\ts.rttStats.SetMaxAckDelay(params.MaxAckDelay)\n\ts.connIDGenerator.SetMaxActiveConnIDs(params.ActiveConnectionIDLimit)\n\tif params.StatelessResetToken != nil {\n\t\ts.connIDManager.SetStatelessResetToken(*params.StatelessResetToken)\n\t}\n\t// We don't support connection migration yet, so we don't have any use for the preferred_address.\n\tif params.PreferredAddress != nil {\n\t\t// Retire the connection ID.\n\t\ts.connIDManager.AddFromPreferredAddress(params.PreferredAddress.ConnectionID, params.PreferredAddress.StatelessResetToken)\n\t}\n}\n\nfunc (s *connection) triggerSending() error {\n\ts.pacingDeadline = time.Time{}\n\tnow := time.Now()\n\n\tsendMode := s.sentPacketHandler.SendMode(now)\n\t//nolint:exhaustive // No need to handle pacing limited here.\n\tswitch sendMode {\n\tcase ackhandler.SendAny:\n\t\treturn s.sendPackets(now)\n\tcase ackhandler.SendNone:\n\t\treturn nil\n\tcase ackhandler.SendPacingLimited:\n\t\tdeadline := s.sentPacketHandler.TimeUntilSend()\n\t\tif deadline.IsZero() {\n\t\t\tdeadline = deadlineSendImmediately\n\t\t}\n\t\ts.pacingDeadline = deadline\n\t\t// Allow sending of an ACK if we're pacing limit.\n\t\t// This makes sure that a peer that is mostly receiving data (and thus has an inaccurate cwnd estimate)\n\t\t// sends enough ACKs to allow its peer to utilize the bandwidth.\n\t\tfallthrough\n\tcase ackhandler.SendAck:\n\t\t// We can at most send a single ACK only packet.\n\t\t// There will only be a new ACK after receiving new packets.\n\t\t// SendAck is only returned when we're congestion limited, so we don't need to set the pacinggs timer.\n\t\treturn s.maybeSendAckOnlyPacket(now)\n\tcase ackhandler.SendPTOInitial:\n\t\tif err := s.sendProbePacket(protocol.EncryptionInitial, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\ts.scheduleSending()\n\t\t\treturn nil\n\t\t}\n\t\treturn s.triggerSending()\n\tcase ackhandler.SendPTOHandshake:\n\t\tif err := s.sendProbePacket(protocol.EncryptionHandshake, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\ts.scheduleSending()\n\t\t\treturn nil\n\t\t}\n\t\treturn s.triggerSending()\n\tcase ackhandler.SendPTOAppData:\n\t\tif err := s.sendProbePacket(protocol.Encryption1RTT, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\ts.scheduleSending()\n\t\t\treturn nil\n\t\t}\n\t\treturn s.triggerSending()\n\tdefault:\n\t\treturn fmt.Errorf(\"BUG: invalid send mode %d\", sendMode)\n\t}\n}\n\nfunc (s *connection) sendPackets(now time.Time) error {\n\t// Path MTU Discovery\n\t// Can't use GSO, since we need to send a single packet that's larger than our current maximum size.\n\t// Performance-wise, this doesn't matter, since we only send a very small (<10) number of\n\t// MTU probe packets per connection.\n\tif s.handshakeConfirmed && s.mtuDiscoverer != nil && s.mtuDiscoverer.ShouldSendProbe(now) {\n\t\tping, size := s.mtuDiscoverer.GetPing()\n\t\tp, buf, err := s.packer.PackMTUProbePacket(ping, size, s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, buf.Len(), false)\n\t\ts.registerPackedShortHeaderPacket(p, now)\n\t\ts.sendQueue.Send(buf, buf.Len())\n\t\t// This is kind of a hack. We need to trigger sending again somehow.\n\t\ts.pacingDeadline = deadlineSendImmediately\n\t\treturn nil\n\t}\n\n\tif isBlocked, offset := s.connFlowController.IsNewlyBlocked(); isBlocked {\n\t\ts.framer.QueueControlFrame(&wire.DataBlockedFrame{MaximumData: offset})\n\t}\n\ts.windowUpdateQueue.QueueAll()\n\tif cf := s.cryptoStreamManager.GetPostHandshakeData(protocol.MaxPostHandshakeCryptoFrameSize); cf != nil {\n\t\ts.queueControlFrame(cf)\n\t}\n\n\tif !s.handshakeConfirmed {\n\t\tpacket, err := s.packer.PackCoalescedPacket(false, s.mtuDiscoverer.CurrentSize(), s.version)\n\t\tif err != nil || packet == nil {\n\t\t\treturn err\n\t\t}\n\t\ts.sentFirstPacket = true\n\t\tif err := s.sendPackedCoalescedPacket(packet, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsendMode := s.sentPacketHandler.SendMode(now)\n\t\tif sendMode == ackhandler.SendPacingLimited {\n\t\t\ts.resetPacingDeadline()\n\t\t} else if sendMode == ackhandler.SendAny {\n\t\t\ts.pacingDeadline = deadlineSendImmediately\n\t\t}\n\t\treturn nil\n\t}\n\n\tif s.conn.capabilities().GSO {\n\t\treturn s.sendPacketsWithGSO(now)\n\t}\n\treturn s.sendPacketsWithoutGSO(now)\n}\n\nfunc (s *connection) sendPacketsWithoutGSO(now time.Time) error {\n\tfor {\n\t\tbuf := getPacketBuffer()\n\t\tif _, err := s.appendPacket(buf, s.mtuDiscoverer.CurrentSize(), now); err != nil {\n\t\t\tif err == errNothingToPack {\n\t\t\t\tbuf.Release()\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\ts.sendQueue.Send(buf, buf.Len())\n\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\treturn nil\n\t\t}\n\t\tsendMode := s.sentPacketHandler.SendMode(now)\n\t\tif sendMode == ackhandler.SendPacingLimited {\n\t\t\ts.resetPacingDeadline()\n\t\t\treturn nil\n\t\t}\n\t\tif sendMode != ackhandler.SendAny {\n\t\t\treturn nil\n\t\t}\n\t\t// Prioritize receiving of packets over sending out more packets.\n\t\tif len(s.receivedPackets) > 0 {\n\t\t\ts.pacingDeadline = deadlineSendImmediately\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (s *connection) sendPacketsWithGSO(now time.Time) error {\n\tbuf := getLargePacketBuffer()\n\tmaxSize := s.mtuDiscoverer.CurrentSize()\n\n\tfor {\n\t\tvar dontSendMore bool\n\t\tsize, err := s.appendPacket(buf, maxSize, now)\n\t\tif err != nil {\n\t\t\tif err != errNothingToPack {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif buf.Len() == 0 {\n\t\t\t\tbuf.Release()\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tdontSendMore = true\n\t\t}\n\n\t\tif !dontSendMore {\n\t\t\tsendMode := s.sentPacketHandler.SendMode(now)\n\t\t\tif sendMode == ackhandler.SendPacingLimited {\n\t\t\t\ts.resetPacingDeadline()\n\t\t\t}\n\t\t\tif sendMode != ackhandler.SendAny {\n\t\t\t\tdontSendMore = true\n\t\t\t}\n\t\t}\n\n\t\t// Append another packet if\n\t\t// 1. The congestion controller and pacer allow sending more\n\t\t// 2. The last packet appended was a full-size packet\n\t\t// 3. We still have enough space for another full-size packet in the buffer\n\t\tif !dontSendMore && size == maxSize && buf.Len()+maxSize <= buf.Cap() {\n\t\t\tcontinue\n\t\t}\n\n\t\ts.sendQueue.Send(buf, maxSize)\n\n\t\tif dontSendMore {\n\t\t\treturn nil\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Prioritize receiving of packets over sending out more packets.\n\t\tif len(s.receivedPackets) > 0 {\n\t\t\ts.pacingDeadline = deadlineSendImmediately\n\t\t\treturn nil\n\t\t}\n\n\t\tbuf = getLargePacketBuffer()\n\t}\n}\n\nfunc (s *connection) resetPacingDeadline() {\n\tdeadline := s.sentPacketHandler.TimeUntilSend()\n\tif deadline.IsZero() {\n\t\tdeadline = deadlineSendImmediately\n\t}\n\ts.pacingDeadline = deadline\n}\n\nfunc (s *connection) maybeSendAckOnlyPacket(now time.Time) error {\n\tif !s.handshakeConfirmed {\n\t\tpacket, err := s.packer.PackCoalescedPacket(true, s.mtuDiscoverer.CurrentSize(), s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif packet == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn s.sendPackedCoalescedPacket(packet, time.Now())\n\t}\n\n\tp, buf, err := s.packer.PackAckOnlyPacket(s.mtuDiscoverer.CurrentSize(), s.version)\n\tif err != nil {\n\t\tif err == errNothingToPack {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, buf.Len(), false)\n\ts.registerPackedShortHeaderPacket(p, now)\n\ts.sendQueue.Send(buf, buf.Len())\n\treturn nil\n}\n\nfunc (s *connection) sendProbePacket(encLevel protocol.EncryptionLevel, now time.Time) error {\n\t// Queue probe packets until we actually send out a packet,\n\t// or until there are no more packets to queue.\n\tvar packet *coalescedPacket\n\tfor {\n\t\tif wasQueued := s.sentPacketHandler.QueueProbePacket(encLevel); !wasQueued {\n\t\t\tbreak\n\t\t}\n\t\tvar err error\n\t\tpacket, err = s.packer.MaybePackProbePacket(encLevel, s.mtuDiscoverer.CurrentSize(), s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif packet != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tif packet == nil {\n\t\ts.retransmissionQueue.AddPing(encLevel)\n\t\tvar err error\n\t\tpacket, err = s.packer.MaybePackProbePacket(encLevel, s.mtuDiscoverer.CurrentSize(), s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif packet == nil || (len(packet.longHdrPackets) == 0 && packet.shortHdrPacket == nil) {\n\t\treturn fmt.Errorf(\"connection BUG: couldn't pack %s probe packet\", encLevel)\n\t}\n\treturn s.sendPackedCoalescedPacket(packet, now)\n}\n\n// appendPacket appends a new packet to the given packetBuffer.\n// If there was nothing to pack, the returned size is 0.\nfunc (s *connection) appendPacket(buf *packetBuffer, maxSize protocol.ByteCount, now time.Time) (protocol.ByteCount, error) {\n\tstartLen := buf.Len()\n\tp, err := s.packer.AppendPacket(buf, maxSize, s.version)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tsize := buf.Len() - startLen\n\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, size, false)\n\ts.registerPackedShortHeaderPacket(p, now)\n\treturn size, nil\n}\n\nfunc (s *connection) registerPackedShortHeaderPacket(p shortHeaderPacket, now time.Time) {\n\tif s.firstAckElicitingPacketAfterIdleSentTime.IsZero() && (len(p.StreamFrames) > 0 || ackhandler.HasAckElicitingFrames(p.Frames)) {\n\t\ts.firstAckElicitingPacketAfterIdleSentTime = now\n\t}\n\n\tlargestAcked := protocol.InvalidPacketNumber\n\tif p.Ack != nil {\n\t\tlargestAcked = p.Ack.LargestAcked()\n\t}\n\ts.sentPacketHandler.SentPacket(now, p.PacketNumber, largestAcked, p.StreamFrames, p.Frames, protocol.Encryption1RTT, p.Length, p.IsPathMTUProbePacket)\n\ts.connIDManager.SentPacket()\n}\n\nfunc (s *connection) sendPackedCoalescedPacket(packet *coalescedPacket, now time.Time) error {\n\ts.logCoalescedPacket(packet)\n\tfor _, p := range packet.longHdrPackets {\n\t\tif s.firstAckElicitingPacketAfterIdleSentTime.IsZero() && p.IsAckEliciting() {\n\t\t\ts.firstAckElicitingPacketAfterIdleSentTime = now\n\t\t}\n\t\tlargestAcked := protocol.InvalidPacketNumber\n\t\tif p.ack != nil {\n\t\t\tlargestAcked = p.ack.LargestAcked()\n\t\t}\n\t\ts.sentPacketHandler.SentPacket(now, p.header.PacketNumber, largestAcked, p.streamFrames, p.frames, p.EncryptionLevel(), p.length, false)\n\t\tif s.perspective == protocol.PerspectiveClient && p.EncryptionLevel() == protocol.EncryptionHandshake {\n\t\t\t// On the client side, Initial keys are dropped as soon as the first Handshake packet is sent.\n\t\t\t// See Section 4.9.1 of RFC 9001.\n\t\t\tif err := s.dropEncryptionLevel(protocol.EncryptionInitial); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif p := packet.shortHdrPacket; p != nil {\n\t\tif s.firstAckElicitingPacketAfterIdleSentTime.IsZero() && p.IsAckEliciting() {\n\t\t\ts.firstAckElicitingPacketAfterIdleSentTime = now\n\t\t}\n\t\tlargestAcked := protocol.InvalidPacketNumber\n\t\tif p.Ack != nil {\n\t\t\tlargestAcked = p.Ack.LargestAcked()\n\t\t}\n\t\ts.sentPacketHandler.SentPacket(now, p.PacketNumber, largestAcked, p.StreamFrames, p.Frames, protocol.Encryption1RTT, p.Length, p.IsPathMTUProbePacket)\n\t}\n\ts.connIDManager.SentPacket()\n\ts.sendQueue.Send(packet.buffer, packet.buffer.Len())\n\treturn nil\n}\n\nfunc (s *connection) sendConnectionClose(e error) ([]byte, error) {\n\tvar packet *coalescedPacket\n\tvar err error\n\tvar transportErr *qerr.TransportError\n\tvar applicationErr *qerr.ApplicationError\n\tif errors.As(e, &transportErr) {\n\t\tpacket, err = s.packer.PackConnectionClose(transportErr, s.mtuDiscoverer.CurrentSize(), s.version)\n\t} else if errors.As(e, &applicationErr) {\n\t\tpacket, err = s.packer.PackApplicationClose(applicationErr, s.mtuDiscoverer.CurrentSize(), s.version)\n\t} else {\n\t\tpacket, err = s.packer.PackConnectionClose(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.InternalError,\n\t\t\tErrorMessage: fmt.Sprintf(\"connection BUG: unspecified error type (msg: %s)\", e.Error()),\n\t\t}, s.mtuDiscoverer.CurrentSize(), s.version)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.logCoalescedPacket(packet)\n\treturn packet.buffer.Data, s.conn.Write(packet.buffer.Data, packet.buffer.Len())\n}\n\nfunc (s *connection) logLongHeaderPacket(p *longHeaderPacket) {\n\t// quic-go logging\n\tif s.logger.Debug() {\n\t\tp.header.Log(s.logger)\n\t\tif p.ack != nil {\n\t\t\twire.LogFrame(s.logger, p.ack, true)\n\t\t}\n\t\tfor _, frame := range p.frames {\n\t\t\twire.LogFrame(s.logger, frame.Frame, true)\n\t\t}\n\t\tfor _, frame := range p.streamFrames {\n\t\t\twire.LogFrame(s.logger, frame.Frame, true)\n\t\t}\n\t}\n\n\t// tracing\n\tif s.tracer != nil {\n\t\tframes := make([]logging.Frame, 0, len(p.frames))\n\t\tfor _, f := range p.frames {\n\t\t\tframes = append(frames, logutils.ConvertFrame(f.Frame))\n\t\t}\n\t\tfor _, f := range p.streamFrames {\n\t\t\tframes = append(frames, logutils.ConvertFrame(f.Frame))\n\t\t}\n\t\tvar ack *logging.AckFrame\n\t\tif p.ack != nil {\n\t\t\tack = logutils.ConvertAckFrame(p.ack)\n\t\t}\n\t\ts.tracer.SentLongHeaderPacket(p.header, p.length, ack, frames)\n\t}\n}\n\nfunc (s *connection) logShortHeaderPacket(\n\tdestConnID protocol.ConnectionID,\n\tackFrame *wire.AckFrame,\n\tframes []ackhandler.Frame,\n\tstreamFrames []ackhandler.StreamFrame,\n\tpn protocol.PacketNumber,\n\tpnLen protocol.PacketNumberLen,\n\tkp protocol.KeyPhaseBit,\n\tsize protocol.ByteCount,\n\tisCoalesced bool,\n) {\n\tif s.logger.Debug() && !isCoalesced {\n\t\ts.logger.Debugf(\"-> Sending packet %d (%d bytes) for connection %s, 1-RTT\", pn, size, s.logID)\n\t}\n\t// quic-go logging\n\tif s.logger.Debug() {\n\t\twire.LogShortHeader(s.logger, destConnID, pn, pnLen, kp)\n\t\tif ackFrame != nil {\n\t\t\twire.LogFrame(s.logger, ackFrame, true)\n\t\t}\n\t\tfor _, f := range frames {\n\t\t\twire.LogFrame(s.logger, f.Frame, true)\n\t\t}\n\t\tfor _, f := range streamFrames {\n\t\t\twire.LogFrame(s.logger, f.Frame, true)\n\t\t}\n\t}\n\n\t// tracing\n\tif s.tracer != nil {\n\t\tfs := make([]logging.Frame, 0, len(frames)+len(streamFrames))\n\t\tfor _, f := range frames {\n\t\t\tfs = append(fs, logutils.ConvertFrame(f.Frame))\n\t\t}\n\t\tfor _, f := range streamFrames {\n\t\t\tfs = append(fs, logutils.ConvertFrame(f.Frame))\n\t\t}\n\t\tvar ack *logging.AckFrame\n\t\tif ackFrame != nil {\n\t\t\tack = logutils.ConvertAckFrame(ackFrame)\n\t\t}\n\t\ts.tracer.SentShortHeaderPacket(\n\t\t\t&logging.ShortHeader{\n\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\tPacketNumber:     pn,\n\t\t\t\tPacketNumberLen:  pnLen,\n\t\t\t\tKeyPhase:         kp,\n\t\t\t},\n\t\t\tsize,\n\t\t\tack,\n\t\t\tfs,\n\t\t)\n\t}\n}\n\nfunc (s *connection) logCoalescedPacket(packet *coalescedPacket) {\n\tif s.logger.Debug() {\n\t\t// There's a short period between dropping both Initial and Handshake keys and completion of the handshake,\n\t\t// during which we might call PackCoalescedPacket but just pack a short header packet.\n\t\tif len(packet.longHdrPackets) == 0 && packet.shortHdrPacket != nil {\n\t\t\ts.logShortHeaderPacket(\n\t\t\t\tpacket.shortHdrPacket.DestConnID,\n\t\t\t\tpacket.shortHdrPacket.Ack,\n\t\t\t\tpacket.shortHdrPacket.Frames,\n\t\t\t\tpacket.shortHdrPacket.StreamFrames,\n\t\t\t\tpacket.shortHdrPacket.PacketNumber,\n\t\t\t\tpacket.shortHdrPacket.PacketNumberLen,\n\t\t\t\tpacket.shortHdrPacket.KeyPhase,\n\t\t\t\tpacket.shortHdrPacket.Length,\n\t\t\t\tfalse,\n\t\t\t)\n\t\t\treturn\n\t\t}\n\t\tif len(packet.longHdrPackets) > 1 {\n\t\t\ts.logger.Debugf(\"-> Sending coalesced packet (%d parts, %d bytes) for connection %s\", len(packet.longHdrPackets), packet.buffer.Len(), s.logID)\n\t\t} else {\n\t\t\ts.logger.Debugf(\"-> Sending packet %d (%d bytes) for connection %s, %s\", packet.longHdrPackets[0].header.PacketNumber, packet.buffer.Len(), s.logID, packet.longHdrPackets[0].EncryptionLevel())\n\t\t}\n\t}\n\tfor _, p := range packet.longHdrPackets {\n\t\ts.logLongHeaderPacket(p)\n\t}\n\tif p := packet.shortHdrPacket; p != nil {\n\t\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, p.Length, true)\n\t}\n}\n\n// AcceptStream returns the next stream openend by the peer\nfunc (s *connection) AcceptStream(ctx context.Context) (Stream, error) {\n\treturn s.streamsMap.AcceptStream(ctx)\n}\n\nfunc (s *connection) AcceptUniStream(ctx context.Context) (ReceiveStream, error) {\n\treturn s.streamsMap.AcceptUniStream(ctx)\n}\n\n// OpenStream opens a stream\nfunc (s *connection) OpenStream() (Stream, error) {\n\treturn s.streamsMap.OpenStream()\n}\n\nfunc (s *connection) OpenStreamSync(ctx context.Context) (Stream, error) {\n\treturn s.streamsMap.OpenStreamSync(ctx)\n}\n\nfunc (s *connection) OpenUniStream() (SendStream, error) {\n\treturn s.streamsMap.OpenUniStream()\n}\n\nfunc (s *connection) OpenUniStreamSync(ctx context.Context) (SendStream, error) {\n\treturn s.streamsMap.OpenUniStreamSync(ctx)\n}\n\nfunc (s *connection) newFlowController(id protocol.StreamID) flowcontrol.StreamFlowController {\n\tinitialSendWindow := s.peerParams.InitialMaxStreamDataUni\n\tif id.Type() == protocol.StreamTypeBidi {\n\t\tif id.InitiatedBy() == s.perspective {\n\t\t\tinitialSendWindow = s.peerParams.InitialMaxStreamDataBidiRemote\n\t\t} else {\n\t\t\tinitialSendWindow = s.peerParams.InitialMaxStreamDataBidiLocal\n\t\t}\n\t}\n\treturn flowcontrol.NewStreamFlowController(\n\t\tid,\n\t\ts.connFlowController,\n\t\tprotocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tprotocol.ByteCount(s.config.MaxStreamReceiveWindow),\n\t\tinitialSendWindow,\n\t\ts.onHasStreamWindowUpdate,\n\t\ts.rttStats,\n\t\ts.logger,\n\t)\n}\n\n// scheduleSending signals that we have data for sending\nfunc (s *connection) scheduleSending() {\n\tselect {\n\tcase s.sendingScheduled <- struct{}{}:\n\tdefault:\n\t}\n}\n\n// tryQueueingUndecryptablePacket queues a packet for which we're missing the decryption keys.\n// The logging.PacketType is only used for logging purposes.\nfunc (s *connection) tryQueueingUndecryptablePacket(p receivedPacket, pt logging.PacketType) {\n\tif s.handshakeComplete {\n\t\tpanic(\"shouldn't queue undecryptable packets after handshake completion\")\n\t}\n\tif len(s.undecryptablePackets)+1 > protocol.MaxUndecryptablePackets {\n\t\tif s.tracer != nil {\n\t\t\ts.tracer.DroppedPacket(pt, p.Size(), logging.PacketDropDOSPrevention)\n\t\t}\n\t\ts.logger.Infof(\"Dropping undecryptable packet (%d bytes). Undecryptable packet queue full.\", p.Size())\n\t\treturn\n\t}\n\ts.logger.Infof(\"Queueing packet (%d bytes) for later decryption\", p.Size())\n\tif s.tracer != nil {\n\t\ts.tracer.BufferedPacket(pt, p.Size())\n\t}\n\ts.undecryptablePackets = append(s.undecryptablePackets, p)\n}\n\nfunc (s *connection) queueControlFrame(f wire.Frame) {\n\ts.framer.QueueControlFrame(f)\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onHasStreamWindowUpdate(id protocol.StreamID) {\n\ts.windowUpdateQueue.AddStream(id)\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onHasConnectionWindowUpdate() {\n\ts.windowUpdateQueue.AddConnection()\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onHasStreamData(id protocol.StreamID) {\n\ts.framer.AddActiveStream(id)\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onStreamCompleted(id protocol.StreamID) {\n\tif err := s.streamsMap.DeleteStream(id); err != nil {\n\t\ts.closeLocal(err)\n\t}\n}\n\nfunc (s *connection) SendMessage(p []byte) error {\n\tif !s.supportsDatagrams() {\n\t\treturn errors.New(\"datagram support disabled\")\n\t}\n\n\tf := &wire.DatagramFrame{DataLenPresent: true}\n\tif protocol.ByteCount(len(p)) > f.MaxDataLen(s.peerParams.MaxDatagramFrameSize, s.version) {\n\t\treturn errors.New(\"message too large\")\n\t}\n\tf.Data = make([]byte, len(p))\n\tcopy(f.Data, p)\n\treturn s.datagramQueue.AddAndWait(f)\n}\n\nfunc (s *connection) ReceiveMessage(ctx context.Context) ([]byte, error) {\n\tif !s.config.EnableDatagrams {\n\t\treturn nil, errors.New(\"datagram support disabled\")\n\t}\n\treturn s.datagramQueue.Receive(ctx)\n}\n\nfunc (s *connection) LocalAddr() net.Addr {\n\treturn s.conn.LocalAddr()\n}\n\nfunc (s *connection) RemoteAddr() net.Addr {\n\treturn s.conn.RemoteAddr()\n}\n\nfunc (s *connection) getPerspective() protocol.Perspective {\n\treturn s.perspective\n}\n\nfunc (s *connection) GetVersion() protocol.VersionNumber {\n\treturn s.version\n}\n\nfunc (s *connection) NextConnection() Connection {\n\t<-s.HandshakeComplete()\n\ts.streamsMap.UseResetMaps()\n\treturn s\n}\n", "package quic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"runtime/pprof\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/mocks\"\n\tmockackhandler \"github.com/quic-go/quic-go/internal/mocks/ackhandler\"\n\tmocklogging \"github.com/quic-go/quic-go/internal/mocks/logging\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/testutils\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n\n\t\"github.com/golang/mock/gomock\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc areConnsRunning() bool {\n\tvar b bytes.Buffer\n\tpprof.Lookup(\"goroutine\").WriteTo(&b, 1)\n\treturn strings.Contains(b.String(), \"quic-go.(*connection).run\")\n}\n\nvar _ = Describe(\"Connection\", func() {\n\tvar (\n\t\tconn          *connection\n\t\tconnRunner    *MockConnRunner\n\t\tmconn         *MockSendConn\n\t\tstreamManager *MockStreamManager\n\t\tpacker        *MockPacker\n\t\tcryptoSetup   *mocks.MockCryptoSetup\n\t\ttracer        *mocklogging.MockConnectionTracer\n\t\tcapabilities  connCapabilities\n\t)\n\tremoteAddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\tlocalAddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 7331}\n\tsrcConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\tdestConnID := protocol.ParseConnectionID([]byte{8, 7, 6, 5, 4, 3, 2, 1})\n\tclientDestConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n\n\tgetCoalescedPacket := func(pn protocol.PacketNumber, isLongHeader bool) *coalescedPacket {\n\t\tbuffer := getPacketBuffer()\n\t\tbuffer.Data = append(buffer.Data, []byte(\"foobar\")...)\n\t\tpacket := &coalescedPacket{buffer: buffer}\n\t\tif isLongHeader {\n\t\t\tpacket.longHdrPackets = []*longHeaderPacket{{\n\t\t\t\theader: &wire.ExtendedHeader{\n\t\t\t\t\tHeader:       wire.Header{},\n\t\t\t\t\tPacketNumber: pn,\n\t\t\t\t},\n\t\t\t\tlength: 6, // foobar\n\t\t\t}}\n\t\t} else {\n\t\t\tpacket.shortHdrPacket = &shortHeaderPacket{\n\t\t\t\tPacketNumber: pn,\n\t\t\t\tLength:       6,\n\t\t\t}\n\t\t}\n\t\treturn packet\n\t}\n\n\texpectReplaceWithClosed := func() {\n\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(connIDs []protocol.ConnectionID, _ protocol.Perspective, _ []byte) {\n\t\t\tExpect(connIDs).To(ContainElement(srcConnID))\n\t\t\tif len(connIDs) > 1 {\n\t\t\t\tExpect(connIDs).To(ContainElement(clientDestConnID))\n\t\t\t}\n\t\t})\n\t}\n\n\texpectAppendPacket := func(packer *MockPacker, p shortHeaderPacket, b []byte) *gomock.Call {\n\t\treturn packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), Version1).DoAndReturn(func(buf *packetBuffer, _ protocol.ByteCount, _ protocol.VersionNumber) (shortHeaderPacket, error) {\n\t\t\tbuf.Data = append(buf.Data, b...)\n\t\t\treturn p, nil\n\t\t})\n\t}\n\n\tenableGSO := func() { capabilities = connCapabilities{GSO: true} }\n\n\tBeforeEach(func() {\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\n\t\tconnRunner = NewMockConnRunner(mockCtrl)\n\t\tmconn = NewMockSendConn(mockCtrl)\n\t\tmconn.EXPECT().capabilities().DoAndReturn(func() connCapabilities { return capabilities }).AnyTimes()\n\t\tmconn.EXPECT().RemoteAddr().Return(remoteAddr).AnyTimes()\n\t\tmconn.EXPECT().LocalAddr().Return(localAddr).AnyTimes()\n\t\ttokenGenerator, err := handshake.NewTokenGenerator(rand.Reader)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\ttracer = mocklogging.NewMockConnectionTracer(mockCtrl)\n\t\ttracer.EXPECT().NegotiatedVersion(gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\ttracer.EXPECT().SentTransportParameters(gomock.Any())\n\t\ttracer.EXPECT().UpdatedKeyFromTLS(gomock.Any(), gomock.Any()).AnyTimes()\n\t\ttracer.EXPECT().UpdatedCongestionState(gomock.Any())\n\t\tconn = newConnection(\n\t\t\tmconn,\n\t\t\tconnRunner,\n\t\t\tprotocol.ConnectionID{},\n\t\t\tnil,\n\t\t\tclientDestConnID,\n\t\t\tdestConnID,\n\t\t\tsrcConnID,\n\t\t\t&protocol.DefaultConnectionIDGenerator{},\n\t\t\tprotocol.StatelessResetToken{},\n\t\t\tpopulateServerConfig(&Config{DisablePathMTUDiscovery: true}),\n\t\t\t&tls.Config{},\n\t\t\ttokenGenerator,\n\t\t\tfalse,\n\t\t\ttracer,\n\t\t\t1234,\n\t\t\tutils.DefaultLogger,\n\t\t\tprotocol.Version1,\n\t\t).(*connection)\n\t\tstreamManager = NewMockStreamManager(mockCtrl)\n\t\tconn.streamsMap = streamManager\n\t\tpacker = NewMockPacker(mockCtrl)\n\t\tconn.packer = packer\n\t\tcryptoSetup = mocks.NewMockCryptoSetup(mockCtrl)\n\t\tconn.cryptoStreamHandler = cryptoSetup\n\t\tconn.handshakeComplete = true\n\t\tconn.idleTimeout = time.Hour\n\t})\n\n\tAfterEach(func() {\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\tcapabilities = connCapabilities{}\n\t})\n\n\tContext(\"frame handling\", func() {\n\t\tContext(\"handling STREAM frames\", func() {\n\t\t\tIt(\"passes STREAM frames to the stream\", func() {\n\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\tStreamID: 5,\n\t\t\t\t\tData:     []byte{0xde, 0xca, 0xfb, 0xad},\n\t\t\t\t}\n\t\t\t\tstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\t\tstr.EXPECT().handleStreamFrame(f)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(5)).Return(str, nil)\n\t\t\t\tExpect(conn.handleStreamFrame(f)).To(Succeed())\n\t\t\t})\n\n\t\t\tIt(\"returns errors\", func() {\n\t\t\t\ttestErr := errors.New(\"test err\")\n\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\tStreamID: 5,\n\t\t\t\t\tData:     []byte{0xde, 0xca, 0xfb, 0xad},\n\t\t\t\t}\n\t\t\t\tstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\t\tstr.EXPECT().handleStreamFrame(f).Return(testErr)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(5)).Return(str, nil)\n\t\t\t\tExpect(conn.handleStreamFrame(f)).To(MatchError(testErr))\n\t\t\t})\n\n\t\t\tIt(\"ignores STREAM frames for closed streams\", func() {\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(5)).Return(nil, nil) // for closed streams, the streamManager returns nil\n\t\t\t\tExpect(conn.handleStreamFrame(&wire.StreamFrame{\n\t\t\t\t\tStreamID: 5,\n\t\t\t\t\tData:     []byte(\"foobar\"),\n\t\t\t\t})).To(Succeed())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling ACK frames\", func() {\n\t\t\tIt(\"informs the SentPacketHandler about ACKs\", func() {\n\t\t\t\tf := &wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 2, Largest: 3}}}\n\t\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\t\tsph.EXPECT().ReceivedAck(f, protocol.EncryptionHandshake, gomock.Any())\n\t\t\t\tconn.sentPacketHandler = sph\n\t\t\t\terr := conn.handleAckFrame(f, protocol.EncryptionHandshake)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling RESET_STREAM frames\", func() {\n\t\t\tIt(\"closes the streams for writing\", func() {\n\t\t\t\tf := &wire.ResetStreamFrame{\n\t\t\t\t\tStreamID:  555,\n\t\t\t\t\tErrorCode: 42,\n\t\t\t\t\tFinalSize: 0x1337,\n\t\t\t\t}\n\t\t\t\tstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(555)).Return(str, nil)\n\t\t\t\tstr.EXPECT().handleResetStreamFrame(f)\n\t\t\t\terr := conn.handleResetStreamFrame(f)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t})\n\n\t\t\tIt(\"returns errors\", func() {\n\t\t\t\tf := &wire.ResetStreamFrame{\n\t\t\t\t\tStreamID:  7,\n\t\t\t\t\tFinalSize: 0x1337,\n\t\t\t\t}\n\t\t\t\ttestErr := errors.New(\"flow control violation\")\n\t\t\t\tstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(7)).Return(str, nil)\n\t\t\t\tstr.EXPECT().handleResetStreamFrame(f).Return(testErr)\n\t\t\t\terr := conn.handleResetStreamFrame(f)\n\t\t\t\tExpect(err).To(MatchError(testErr))\n\t\t\t})\n\n\t\t\tIt(\"ignores RESET_STREAM frames for closed streams\", func() {\n\t\t\t\tstreamManager.EXPECT().GetOrOpenReceiveStream(protocol.StreamID(3)).Return(nil, nil)\n\t\t\t\tExpect(conn.handleFrame(&wire.ResetStreamFrame{\n\t\t\t\t\tStreamID:  3,\n\t\t\t\t\tErrorCode: 42,\n\t\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling MAX_DATA and MAX_STREAM_DATA frames\", func() {\n\t\t\tvar connFC *mocks.MockConnectionFlowController\n\n\t\t\tBeforeEach(func() {\n\t\t\t\tconnFC = mocks.NewMockConnectionFlowController(mockCtrl)\n\t\t\t\tconn.connFlowController = connFC\n\t\t\t})\n\n\t\t\tIt(\"updates the flow control window of a stream\", func() {\n\t\t\t\tf := &wire.MaxStreamDataFrame{\n\t\t\t\t\tStreamID:          12345,\n\t\t\t\t\tMaximumStreamData: 0x1337,\n\t\t\t\t}\n\t\t\t\tstr := NewMockSendStreamI(mockCtrl)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenSendStream(protocol.StreamID(12345)).Return(str, nil)\n\t\t\t\tstr.EXPECT().updateSendWindow(protocol.ByteCount(0x1337))\n\t\t\t\tExpect(conn.handleMaxStreamDataFrame(f)).To(Succeed())\n\t\t\t})\n\n\t\t\tIt(\"updates the flow control window of the connection\", func() {\n\t\t\t\toffset := protocol.ByteCount(0x800000)\n\t\t\t\tconnFC.EXPECT().UpdateSendWindow(offset)\n\t\t\t\tconn.handleMaxDataFrame(&wire.MaxDataFrame{MaximumData: offset})\n\t\t\t})\n\n\t\t\tIt(\"ignores MAX_STREAM_DATA frames for a closed stream\", func() {\n\t\t\t\tstreamManager.EXPECT().GetOrOpenSendStream(protocol.StreamID(10)).Return(nil, nil)\n\t\t\t\tExpect(conn.handleFrame(&wire.MaxStreamDataFrame{\n\t\t\t\t\tStreamID:          10,\n\t\t\t\t\tMaximumStreamData: 1337,\n\t\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling MAX_STREAM_ID frames\", func() {\n\t\t\tIt(\"passes the frame to the streamsMap\", func() {\n\t\t\t\tf := &wire.MaxStreamsFrame{\n\t\t\t\t\tType:         protocol.StreamTypeUni,\n\t\t\t\t\tMaxStreamNum: 10,\n\t\t\t\t}\n\t\t\t\tstreamManager.EXPECT().HandleMaxStreamsFrame(f)\n\t\t\t\tconn.handleMaxStreamsFrame(f)\n\t\t\t})\n\t\t})\n\n\t\tContext(\"handling STOP_SENDING frames\", func() {\n\t\t\tIt(\"passes the frame to the stream\", func() {\n\t\t\t\tf := &wire.StopSendingFrame{\n\t\t\t\t\tStreamID:  5,\n\t\t\t\t\tErrorCode: 10,\n\t\t\t\t}\n\t\t\t\tstr := NewMockSendStreamI(mockCtrl)\n\t\t\t\tstreamManager.EXPECT().GetOrOpenSendStream(protocol.StreamID(5)).Return(str, nil)\n\t\t\t\tstr.EXPECT().handleStopSendingFrame(f)\n\t\t\t\terr := conn.handleStopSendingFrame(f)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t})\n\n\t\t\tIt(\"ignores STOP_SENDING frames for a closed stream\", func() {\n\t\t\t\tstreamManager.EXPECT().GetOrOpenSendStream(protocol.StreamID(3)).Return(nil, nil)\n\t\t\t\tExpect(conn.handleFrame(&wire.StopSendingFrame{\n\t\t\t\t\tStreamID:  3,\n\t\t\t\t\tErrorCode: 1337,\n\t\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\t})\n\t\t})\n\n\t\tIt(\"handles NEW_CONNECTION_ID frames\", func() {\n\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4})\n\t\t\tExpect(conn.handleFrame(&wire.NewConnectionIDFrame{\n\t\t\t\tSequenceNumber: 10,\n\t\t\t\tConnectionID:   connID,\n\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\tExpect(conn.connIDManager.queue.Back().Value.ConnectionID).To(Equal(connID))\n\t\t})\n\n\t\tIt(\"handles PING frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.PingFrame{}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"rejects PATH_RESPONSE frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.PathResponseFrame{Data: [8]byte{1, 2, 3, 4, 5, 6, 7, 8}}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).To(MatchError(\"unexpected PATH_RESPONSE frame\"))\n\t\t})\n\n\t\tIt(\"handles PATH_CHALLENGE frames\", func() {\n\t\t\tdata := [8]byte{1, 2, 3, 4, 5, 6, 7, 8}\n\t\t\terr := conn.handleFrame(&wire.PathChallengeFrame{Data: data}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tframes, _ := conn.framer.AppendControlFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(Equal([]ackhandler.Frame{{Frame: &wire.PathResponseFrame{Data: data}}}))\n\t\t})\n\n\t\tIt(\"rejects NEW_TOKEN frames\", func() {\n\t\t\terr := conn.handleNewTokenFrame(&wire.NewTokenFrame{})\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err).To(BeAssignableToTypeOf(&qerr.TransportError{}))\n\t\t\tExpect(err.(*qerr.TransportError).ErrorCode).To(Equal(qerr.ProtocolViolation))\n\t\t})\n\n\t\tIt(\"handles BLOCKED frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.DataBlockedFrame{}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"handles STREAM_BLOCKED frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.StreamDataBlockedFrame{}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"handles STREAMS_BLOCKED frames\", func() {\n\t\t\terr := conn.handleFrame(&wire.StreamsBlockedFrame{}, protocol.Encryption1RTT, protocol.ConnectionID{})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"handles CONNECTION_CLOSE frames, with a transport error code\", func() {\n\t\t\texpectedErr := &qerr.TransportError{\n\t\t\t\tRemote:       true,\n\t\t\t\tErrorCode:    qerr.StreamLimitError,\n\t\t\t\tErrorMessage: \"foobar\",\n\t\t\t}\n\t\t\tstreamManager.EXPECT().CloseWithError(expectedErr)\n\t\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(connIDs []protocol.ConnectionID, _ protocol.Perspective, _ []byte) {\n\t\t\t\tExpect(connIDs).To(ConsistOf(clientDestConnID, srcConnID))\n\t\t\t})\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(expectedErr),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tExpect(conn.run()).To(MatchError(expectedErr))\n\t\t\t}()\n\t\t\tExpect(conn.handleFrame(&wire.ConnectionCloseFrame{\n\t\t\t\tErrorCode:    uint64(qerr.StreamLimitError),\n\t\t\t\tReasonPhrase: \"foobar\",\n\t\t\t}, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"handles CONNECTION_CLOSE frames, with an application error code\", func() {\n\t\t\ttestErr := &qerr.ApplicationError{\n\t\t\t\tRemote:       true,\n\t\t\t\tErrorCode:    0x1337,\n\t\t\t\tErrorMessage: \"foobar\",\n\t\t\t}\n\t\t\tstreamManager.EXPECT().CloseWithError(testErr)\n\t\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(connIDs []protocol.ConnectionID, _ protocol.Perspective, _ []byte) {\n\t\t\t\tExpect(connIDs).To(ConsistOf(clientDestConnID, srcConnID))\n\t\t\t})\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(testErr),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tExpect(conn.run()).To(MatchError(testErr))\n\t\t\t}()\n\t\t\tccf := &wire.ConnectionCloseFrame{\n\t\t\t\tErrorCode:          0x1337,\n\t\t\t\tReasonPhrase:       \"foobar\",\n\t\t\t\tIsApplicationError: true,\n\t\t\t}\n\t\t\tExpect(conn.handleFrame(ccf, protocol.Encryption1RTT, protocol.ConnectionID{})).To(Succeed())\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t\tExpect(context.Cause(conn.Context())).To(MatchError(testErr))\n\t\t})\n\n\t\tIt(\"errors on HANDSHAKE_DONE frames\", func() {\n\t\t\tExpect(conn.handleHandshakeDoneFrame()).To(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\t\tErrorMessage: \"received a HANDSHAKE_DONE frame\",\n\t\t\t}))\n\t\t})\n\t})\n\n\tIt(\"tells its versions\", func() {\n\t\tconn.version = 4242\n\t\tExpect(conn.GetVersion()).To(Equal(protocol.VersionNumber(4242)))\n\t})\n\n\tContext(\"closing\", func() {\n\t\tvar (\n\t\t\trunErr         chan error\n\t\t\texpectedRunErr error\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\trunErr = make(chan error, 1)\n\t\t\texpectedRunErr = nil\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\tif expectedRunErr != nil {\n\t\t\t\tEventually(runErr).Should(Receive(MatchError(expectedRunErr)))\n\t\t\t} else {\n\t\t\t\tEventually(runErr).Should(Receive())\n\t\t\t}\n\t\t})\n\n\t\trunConn := func() {\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\trunErr <- conn.run()\n\t\t\t}()\n\t\t\tEventually(areConnsRunning).Should(BeTrue())\n\t\t}\n\n\t\tIt(\"shuts down without error\", func() {\n\t\t\tconn.handshakeComplete = true\n\t\t\trunConn()\n\t\t\tstreamManager.EXPECT().CloseWithError(&qerr.ApplicationError{})\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tbuffer := getPacketBuffer()\n\t\t\tbuffer.Data = append(buffer.Data, []byte(\"connection close\")...)\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(e *qerr.ApplicationError, _ protocol.ByteCount, _ protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tExpect(e.ErrorCode).To(BeEquivalentTo(qerr.NoError))\n\t\t\t\tExpect(e.ErrorMessage).To(BeEmpty())\n\t\t\t\treturn &coalescedPacket{buffer: buffer}, nil\n\t\t\t})\n\t\t\tmconn.EXPECT().Write([]byte(\"connection close\"), gomock.Any())\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tvar appErr *ApplicationError\n\t\t\t\t\tExpect(errors.As(e, &appErr)).To(BeTrue())\n\t\t\t\t\tExpect(appErr.Remote).To(BeFalse())\n\t\t\t\t\tExpect(appErr.ErrorCode).To(BeZero())\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.shutdown()\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\tExpect(conn.Context().Done()).To(BeClosed())\n\t\t})\n\n\t\tIt(\"only closes once\", func() {\n\t\t\trunConn()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tconn.shutdown()\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\tExpect(conn.Context().Done()).To(BeClosed())\n\t\t})\n\n\t\tIt(\"closes with an error\", func() {\n\t\t\trunConn()\n\t\t\texpectedErr := &qerr.ApplicationError{\n\t\t\t\tErrorCode:    0x1337,\n\t\t\t\tErrorMessage: \"test error\",\n\t\t\t}\n\t\t\tstreamManager.EXPECT().CloseWithError(expectedErr)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackApplicationClose(expectedErr, gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(expectedErr),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.CloseWithError(0x1337, \"test error\")\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\tExpect(conn.Context().Done()).To(BeClosed())\n\t\t\tExpect(context.Cause(conn.Context())).To(MatchError(expectedErr))\n\t\t})\n\n\t\tIt(\"includes the frame type in transport-level close frames\", func() {\n\t\t\trunConn()\n\t\t\texpectedErr := &qerr.TransportError{\n\t\t\t\tErrorCode:    0x1337,\n\t\t\t\tFrameType:    0x42,\n\t\t\t\tErrorMessage: \"test error\",\n\t\t\t}\n\t\t\tstreamManager.EXPECT().CloseWithError(expectedErr)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(expectedErr, gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(expectedErr),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.closeLocal(expectedErr)\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\tExpect(conn.Context().Done()).To(BeClosed())\n\t\t})\n\n\t\tIt(\"destroys the connection\", func() {\n\t\t\trunConn()\n\t\t\ttestErr := errors.New(\"close\")\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\t// don't EXPECT any calls to mconn.Write()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tvar transportErr *TransportError\n\t\t\t\t\tExpect(errors.As(e, &transportErr)).To(BeTrue())\n\t\t\t\t\tExpect(transportErr.Remote).To(BeFalse())\n\t\t\t\t\tExpect(transportErr.ErrorCode).To(Equal(qerr.InternalError))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.destroy(testErr)\n\t\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\t\texpectedRunErr = &qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.InternalError,\n\t\t\t\tErrorMessage: testErr.Error(),\n\t\t\t}\n\t\t})\n\n\t\tIt(\"cancels the context when the run loop exists\", func() {\n\t\t\trunConn()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\treturned := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tctx := conn.Context()\n\t\t\t\t<-ctx.Done()\n\t\t\t\tExpect(ctx.Err()).To(MatchError(context.Canceled))\n\t\t\t\tclose(returned)\n\t\t\t}()\n\t\t\tConsistently(returned).ShouldNot(BeClosed())\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(returned).Should(BeClosed())\n\t\t\tExpect(context.Cause(conn.Context())).To(MatchError(context.Canceled))\n\t\t})\n\n\t\tIt(\"doesn't send any more packets after receiving a CONNECTION_CLOSE\", func() {\n\t\t\tunpacker := NewMockUnpacker(mockCtrl)\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tconn.unpacker = unpacker\n\t\t\trunConn()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tb, err := wire.AppendShortHeader(nil, srcConnID, 42, protocol.PacketNumberLen2, protocol.KeyPhaseOne)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).DoAndReturn(func(time.Time, []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\t\t\t\tb, err := (&wire.ConnectionCloseFrame{ErrorCode: uint64(qerr.StreamLimitError)}).Append(nil, conn.version)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\treturn 3, protocol.PacketNumberLen2, protocol.KeyPhaseOne, b, nil\n\t\t\t})\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\t// don't EXPECT any calls to packer.PackPacket()\n\t\t\tconn.handlePacket(receivedPacket{\n\t\t\t\trcvTime:    time.Now(),\n\t\t\t\tremoteAddr: &net.UDPAddr{},\n\t\t\t\tbuffer:     getPacketBuffer(),\n\t\t\t\tdata:       b,\n\t\t\t})\n\t\t\t// Consistently(pack).ShouldNot(Receive())\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes when the sendQueue encounters an error\", func() {\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tsconn := NewMockSendConn(mockCtrl)\n\t\t\tsconn.EXPECT().capabilities().AnyTimes()\n\t\t\tsconn.EXPECT().Write(gomock.Any(), gomock.Any()).Return(io.ErrClosedPipe).AnyTimes()\n\t\t\tconn.sendQueue = newSendQueue(sconn)\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().Return(time.Now().Add(time.Hour)).AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\t// only expect a single SentPacket() call\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tconn.sentPacketHandler = sph\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1}, []byte(\"foobar\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\t\trunConn()\n\t\t\tconn.queueControlFrame(&wire.PingFrame{})\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes due to a stateless reset\", func() {\n\t\t\ttoken := protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\t\t\trunConn()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tvar srErr *StatelessResetError\n\t\t\t\t\tExpect(errors.As(e, &srErr)).To(BeTrue())\n\t\t\t\t\tExpect(srErr.Token).To(Equal(token))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tconn.destroy(&StatelessResetError{Token: token})\n\t\t})\n\t})\n\n\tContext(\"receiving packets\", func() {\n\t\tvar unpacker *MockUnpacker\n\n\t\tBeforeEach(func() {\n\t\t\tunpacker = NewMockUnpacker(mockCtrl)\n\t\t\tconn.unpacker = unpacker\n\t\t})\n\n\t\tgetShortHeaderPacket := func(connID protocol.ConnectionID, pn protocol.PacketNumber, data []byte) receivedPacket {\n\t\t\tb, err := wire.AppendShortHeader(nil, connID, pn, protocol.PacketNumberLen2, protocol.KeyPhaseOne)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\treturn receivedPacket{\n\t\t\t\tdata:    append(b, data...),\n\t\t\t\tbuffer:  getPacketBuffer(),\n\t\t\t\trcvTime: time.Now(),\n\t\t\t}\n\t\t}\n\n\t\tgetLongHeaderPacket := func(extHdr *wire.ExtendedHeader, data []byte) receivedPacket {\n\t\t\tb, err := extHdr.Append(nil, conn.version)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\treturn receivedPacket{\n\t\t\t\tdata:    append(b, data...),\n\t\t\t\tbuffer:  getPacketBuffer(),\n\t\t\t\trcvTime: time.Now(),\n\t\t\t}\n\t\t}\n\n\t\tIt(\"drops Retry packets\", func() {\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{Header: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeRetry,\n\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\tVersion:          conn.version,\n\t\t\t\tToken:            []byte(\"foobar\"),\n\t\t\t}}, make([]byte, 16) /* Retry integrity tag */)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops Version Negotiation packets\", func() {\n\t\t\tb := wire.ComposeVersionNegotiation(\n\t\t\t\tprotocol.ArbitraryLenConnectionID(srcConnID.Bytes()),\n\t\t\t\tprotocol.ArbitraryLenConnectionID(destConnID.Bytes()),\n\t\t\t\tconn.config.Versions,\n\t\t\t)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeVersionNegotiation, protocol.ByteCount(len(b)), logging.PacketDropUnexpectedPacket)\n\t\t\tExpect(conn.handlePacketImpl(receivedPacket{\n\t\t\t\tdata:   b,\n\t\t\t\tbuffer: getPacketBuffer(),\n\t\t\t})).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops packets for which header decryption fails\", func() {\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:    protocol.PacketTypeHandshake,\n\t\t\t\t\tVersion: conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, nil)\n\t\t\tp.data[0] ^= 0x40 // unset the QUIC bit\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropHeaderParseError)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops packets for which the version is unsupported\", func() {\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:    protocol.PacketTypeHandshake,\n\t\t\t\t\tVersion: conn.version + 1,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, nil)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropUnsupportedVersion)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops packets with an unsupported version\", func() {\n\t\t\torigSupportedVersions := make([]protocol.VersionNumber, len(protocol.SupportedVersions))\n\t\t\tcopy(origSupportedVersions, protocol.SupportedVersions)\n\t\t\tdefer func() {\n\t\t\t\tprotocol.SupportedVersions = origSupportedVersions\n\t\t\t}()\n\n\t\t\tprotocol.SupportedVersions = append(protocol.SupportedVersions, conn.version+1)\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tVersion:          conn.version + 1,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, nil)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeHandshake, p.Size(), logging.PacketDropUnexpectedVersion)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"informs the ReceivedPacketHandler about non-ack-eliciting packets\", func() {\n\t\t\thdr := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: srcConnID,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t\tLength:           1,\n\t\t\t\t},\n\t\t\t\tPacketNumber:    0x37,\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t}\n\t\t\tunpackedHdr := *hdr\n\t\t\tunpackedHdr.PacketNumber = 0x1337\n\t\t\tpacket := getLongHeaderPacket(hdr, nil)\n\t\t\tpacket.ecn = protocol.ECNCE\n\t\t\trcvTime := time.Now().Add(-10 * time.Second)\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), rcvTime, gomock.Any(), conn.version).Return(&unpackedPacket{\n\t\t\t\tencryptionLevel: protocol.EncryptionInitial,\n\t\t\t\thdr:             &unpackedHdr,\n\t\t\t\tdata:            []byte{0}, // one PADDING frame\n\t\t\t}, nil)\n\t\t\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\t\t\tgomock.InOrder(\n\t\t\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(0x1337), protocol.EncryptionInitial),\n\t\t\t\trph.EXPECT().ReceivedPacket(protocol.PacketNumber(0x1337), protocol.ECNCE, protocol.EncryptionInitial, rcvTime, false),\n\t\t\t)\n\t\t\tconn.receivedPacketHandler = rph\n\t\t\tpacket.rcvTime = rcvTime\n\t\t\ttracer.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), []logging.Frame{})\n\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeTrue())\n\t\t})\n\n\t\tIt(\"informs the ReceivedPacketHandler about ack-eliciting packets\", func() {\n\t\t\trcvTime := time.Now().Add(-10 * time.Second)\n\t\t\tb, err := (&wire.PingFrame{}).Append(nil, conn.version)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tpacket := getShortHeaderPacket(srcConnID, 0x37, nil)\n\t\t\tpacket.ecn = protocol.ECT1\n\t\t\tunpacker.EXPECT().UnpackShortHeader(rcvTime, gomock.Any()).Return(protocol.PacketNumber(0x1337), protocol.PacketNumberLen2, protocol.KeyPhaseZero, b, nil)\n\t\t\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\t\t\tgomock.InOrder(\n\t\t\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(0x1337), protocol.Encryption1RTT),\n\t\t\t\trph.EXPECT().ReceivedPacket(protocol.PacketNumber(0x1337), protocol.ECT1, protocol.Encryption1RTT, rcvTime, true),\n\t\t\t)\n\t\t\tconn.receivedPacketHandler = rph\n\t\t\tpacket.rcvTime = rcvTime\n\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(&logging.ShortHeader{PacketNumber: 0x1337, PacketNumberLen: 2, KeyPhase: protocol.KeyPhaseZero}, protocol.ByteCount(len(packet.data)), []logging.Frame{&logging.PingFrame{}})\n\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeTrue())\n\t\t})\n\n\t\tIt(\"drops duplicate packets\", func() {\n\t\t\tpacket := getShortHeaderPacket(srcConnID, 0x37, nil)\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0x1337), protocol.PacketNumberLen2, protocol.KeyPhaseOne, []byte(\"foobar\"), nil)\n\t\t\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\t\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(0x1337), protocol.Encryption1RTT).Return(true)\n\t\t\tconn.receivedPacketHandler = rph\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketType1RTT, protocol.ByteCount(len(packet.data)), logging.PacketDropDuplicate)\n\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops a packet when unpacking fails\", func() {\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(nil, handshake.ErrDecryptionFailed)\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\texpectReplaceWithClosed()\n\t\t\tp := getLongHeaderPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\tDestConnectionID: srcConnID,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t\tLength:           2 + 6,\n\t\t\t\t},\n\t\t\t\tPacketNumber:    0x1337,\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, []byte(\"foobar\"))\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeHandshake, p.Size(), logging.PacketDropPayloadDecryptError)\n\t\t\tconn.handlePacket(p)\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\t\t\t// make the go routine return\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.closeLocal(errors.New(\"close\"))\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"processes multiple received packets before sending one\", func() {\n\t\t\tconn.creationTime = time.Now()\n\t\t\tvar pn protocol.PacketNumber\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).DoAndReturn(func(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\t\t\t\tpn++\n\t\t\t\treturn pn, protocol.PacketNumberLen2, protocol.KeyPhaseZero, []byte{0} /* PADDING frame */, nil\n\t\t\t}).Times(3)\n\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(hdr *logging.ShortHeader, _ protocol.ByteCount, _ []logging.Frame) {\n\t\t\t}).Times(3)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version) // only expect a single call\n\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\tconn.handlePacket(getShortHeaderPacket(srcConnID, 0x1337+protocol.PacketNumber(i), []byte(\"foobar\")))\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\n\t\t\t// make the go routine return\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.closeLocal(errors.New(\"close\"))\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't processes multiple received packets before sending one before handshake completion\", func() {\n\t\t\tconn.handshakeComplete = false\n\t\t\tconn.creationTime = time.Now()\n\t\t\tvar pn protocol.PacketNumber\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).DoAndReturn(func(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\t\t\t\tpn++\n\t\t\t\treturn pn, protocol.PacketNumberLen4, protocol.KeyPhaseZero, []byte{0} /* PADDING frame */, nil\n\t\t\t}).Times(3)\n\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(hdr *logging.ShortHeader, _ protocol.ByteCount, _ []logging.Frame) {\n\t\t\t}).Times(3)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Times(3)\n\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\tconn.handlePacket(getShortHeaderPacket(srcConnID, 0x1337+protocol.PacketNumber(i), []byte(\"foobar\")))\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\n\t\t\t// make the go routine return\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.closeLocal(errors.New(\"close\"))\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes the connection when unpacking fails because the reserved bits were incorrect\", func() {\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0), protocol.PacketNumberLen(0), protocol.KeyPhaseBit(0), nil, wire.ErrInvalidReservedBits)\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terr := conn.run()\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\tExpect(err).To(BeAssignableToTypeOf(&qerr.TransportError{}))\n\t\t\t\tExpect(err.(*qerr.TransportError).ErrorCode).To(Equal(qerr.ProtocolViolation))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\texpectReplaceWithClosed()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tpacket := getShortHeaderPacket(srcConnID, 0x42, nil)\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.handlePacket(packet)\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"ignores packets when unpacking the header fails\", func() {\n\t\t\ttestErr := &headerParseError{errors.New(\"test error\")}\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0), protocol.PacketNumberLen(0), protocol.KeyPhaseBit(0), nil, testErr)\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\trunErr := make(chan error)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\trunErr <- conn.run()\n\t\t\t}()\n\t\t\texpectReplaceWithClosed()\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketType1RTT, gomock.Any(), logging.PacketDropHeaderParseError)\n\t\t\tconn.handlePacket(getShortHeaderPacket(srcConnID, 0x42, nil))\n\t\t\tConsistently(runErr).ShouldNot(Receive())\n\t\t\t// make the go routine return\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes the connection when unpacking fails because of an error other than a decryption error\", func() {\n\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0), protocol.PacketNumberLen(0), protocol.KeyPhaseBit(0), nil, &qerr.TransportError{ErrorCode: qerr.ConnectionIDLimitError})\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terr := conn.run()\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\tExpect(err).To(BeAssignableToTypeOf(&qerr.TransportError{}))\n\t\t\t\tExpect(err.(*qerr.TransportError).ErrorCode).To(Equal(qerr.ConnectionIDLimitError))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\texpectReplaceWithClosed()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.handlePacket(getShortHeaderPacket(srcConnID, 0x42, nil))\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"ignores packets with a different source connection ID\", func() {\n\t\t\thdr1 := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    1,\n\t\t\t}\n\t\t\thdr2 := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    2,\n\t\t\t}\n\t\t\tExpect(srcConnID).ToNot(Equal(hdr2.SrcConnectionID))\n\t\t\t// Send one packet, which might change the connection ID.\n\t\t\t// only EXPECT one call to the unpacker\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(&unpackedPacket{\n\t\t\t\tencryptionLevel: protocol.Encryption1RTT,\n\t\t\t\thdr:             hdr1,\n\t\t\t\tdata:            []byte{0}, // one PADDING frame\n\t\t\t}, nil)\n\t\t\tp1 := getLongHeaderPacket(hdr1, nil)\n\t\t\ttracer.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(p1.data)), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(p1)).To(BeTrue())\n\t\t\t// The next packet has to be ignored, since the source connection ID doesn't match.\n\t\t\tp2 := getLongHeaderPacket(hdr2, nil)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeInitial, protocol.ByteCount(len(p2.data)), logging.PacketDropUnknownConnectionID)\n\t\t\tExpect(conn.handlePacketImpl(p2)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"queues undecryptable packets\", func() {\n\t\t\tconn.handshakeComplete = false\n\t\t\thdr := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    1,\n\t\t\t}\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(nil, handshake.ErrKeysNotYetAvailable)\n\t\t\tpacket := getLongHeaderPacket(hdr, nil)\n\t\t\ttracer.EXPECT().BufferedPacket(logging.PacketTypeHandshake, packet.Size())\n\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeFalse())\n\t\t\tExpect(conn.undecryptablePackets).To(Equal([]receivedPacket{packet}))\n\t\t})\n\n\t\tContext(\"updating the remote address\", func() {\n\t\t\tIt(\"doesn't support connection migration\", func() {\n\t\t\t\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(10), protocol.PacketNumberLen2, protocol.KeyPhaseZero, []byte{0} /* one PADDING frame */, nil)\n\t\t\t\tpacket := getShortHeaderPacket(srcConnID, 0x42, nil)\n\t\t\t\tpacket.remoteAddr = &net.IPAddr{IP: net.IPv4(192, 168, 0, 100)}\n\t\t\t\ttracer.EXPECT().ReceivedShortHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet.data)), gomock.Any())\n\t\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeTrue())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"coalesced packets\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\ttracer.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\t\t})\n\n\t\t\tgetPacketWithLength := func(connID protocol.ConnectionID, length protocol.ByteCount) (int /* header length */, receivedPacket) {\n\t\t\t\thdr := &wire.ExtendedHeader{\n\t\t\t\t\tHeader: wire.Header{\n\t\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\t\tDestConnectionID: connID,\n\t\t\t\t\t\tSrcConnectionID:  destConnID,\n\t\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t\t\tLength:           length,\n\t\t\t\t\t},\n\t\t\t\t\tPacketNumberLen: protocol.PacketNumberLen3,\n\t\t\t\t}\n\t\t\t\thdrLen := hdr.GetLength(conn.version)\n\t\t\t\tb := make([]byte, 1)\n\t\t\t\trand.Read(b)\n\t\t\t\tpacket := getLongHeaderPacket(hdr, bytes.Repeat(b, int(length)-3))\n\t\t\t\treturn int(hdrLen), packet\n\t\t\t}\n\n\t\t\tIt(\"cuts packets to the right length\", func() {\n\t\t\t\thdrLen, packet := getPacketWithLength(srcConnID, 456)\n\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\tExpect(data).To(HaveLen(hdrLen + 456 - 3))\n\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\thdr:             &wire.ExtendedHeader{Header: wire.Header{}},\n\t\t\t\t\t}, nil\n\t\t\t\t})\n\t\t\t\tcryptoSetup.EXPECT().DiscardInitialKeys()\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionInitial)\n\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet.data)), gomock.Any())\n\t\t\t\tExpect(conn.handlePacketImpl(packet)).To(BeTrue())\n\t\t\t})\n\n\t\t\tIt(\"handles coalesced packets\", func() {\n\t\t\t\thdrLen1, packet1 := getPacketWithLength(srcConnID, 456)\n\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\tExpect(data).To(HaveLen(hdrLen1 + 456 - 3))\n\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\thdr: &wire.ExtendedHeader{\n\t\t\t\t\t\t\tPacketNumber: 1,\n\t\t\t\t\t\t\tHeader:       wire.Header{SrcConnectionID: destConnID},\n\t\t\t\t\t\t},\n\t\t\t\t\t}, nil\n\t\t\t\t})\n\t\t\t\thdrLen2, packet2 := getPacketWithLength(srcConnID, 123)\n\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\tExpect(data).To(HaveLen(hdrLen2 + 123 - 3))\n\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\thdr: &wire.ExtendedHeader{\n\t\t\t\t\t\t\tPacketNumber: 2,\n\t\t\t\t\t\t\tHeader:       wire.Header{SrcConnectionID: destConnID},\n\t\t\t\t\t\t},\n\t\t\t\t\t}, nil\n\t\t\t\t})\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionInitial).AnyTimes()\n\t\t\t\tcryptoSetup.EXPECT().DiscardInitialKeys().AnyTimes()\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet1.data)), gomock.Any()),\n\t\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet2.data)), gomock.Any()),\n\t\t\t\t)\n\t\t\t\tpacket1.data = append(packet1.data, packet2.data...)\n\t\t\t\tExpect(conn.handlePacketImpl(packet1)).To(BeTrue())\n\t\t\t})\n\n\t\t\tIt(\"works with undecryptable packets\", func() {\n\t\t\t\tconn.handshakeComplete = false\n\t\t\t\thdrLen1, packet1 := getPacketWithLength(srcConnID, 456)\n\t\t\t\thdrLen2, packet2 := getPacketWithLength(srcConnID, 123)\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(nil, handshake.ErrKeysNotYetAvailable),\n\t\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\t\tExpect(data).To(HaveLen(hdrLen2 + 123 - 3))\n\t\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\t\thdr:             &wire.ExtendedHeader{Header: wire.Header{}},\n\t\t\t\t\t\t}, nil\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionInitial).AnyTimes()\n\t\t\t\tcryptoSetup.EXPECT().DiscardInitialKeys().AnyTimes()\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\ttracer.EXPECT().BufferedPacket(gomock.Any(), protocol.ByteCount(len(packet1.data))),\n\t\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet2.data)), gomock.Any()),\n\t\t\t\t)\n\t\t\t\tpacket1.data = append(packet1.data, packet2.data...)\n\t\t\t\tExpect(conn.handlePacketImpl(packet1)).To(BeTrue())\n\n\t\t\t\tExpect(conn.undecryptablePackets).To(HaveLen(1))\n\t\t\t\tExpect(conn.undecryptablePackets[0].data).To(HaveLen(hdrLen1 + 456 - 3))\n\t\t\t})\n\n\t\t\tIt(\"ignores coalesced packet parts if the destination connection IDs don't match\", func() {\n\t\t\t\twrongConnID := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\t\tExpect(srcConnID).ToNot(Equal(wrongConnID))\n\t\t\t\thdrLen1, packet1 := getPacketWithLength(srcConnID, 456)\n\t\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\t\t\tExpect(data).To(HaveLen(hdrLen1 + 456 - 3))\n\t\t\t\t\treturn &unpackedPacket{\n\t\t\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t\t\t\tdata:            []byte{0},\n\t\t\t\t\t\thdr:             &wire.ExtendedHeader{Header: wire.Header{}},\n\t\t\t\t\t}, nil\n\t\t\t\t})\n\t\t\t\t_, packet2 := getPacketWithLength(wrongConnID, 123)\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionInitial).AnyTimes()\n\t\t\t\tcryptoSetup.EXPECT().DiscardInitialKeys().AnyTimes()\n\t\t\t\t// don't EXPECT any more calls to unpacker.UnpackLongHeader()\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), protocol.ByteCount(len(packet1.data)), gomock.Any()),\n\t\t\t\t\ttracer.EXPECT().DroppedPacket(gomock.Any(), protocol.ByteCount(len(packet2.data)), logging.PacketDropUnknownConnectionID),\n\t\t\t\t)\n\t\t\t\tpacket1.data = append(packet1.data, packet2.data...)\n\t\t\t\tExpect(conn.handlePacketImpl(packet1)).To(BeTrue())\n\t\t\t})\n\t\t})\n\t})\n\n\tContext(\"sending packets\", func() {\n\t\tvar (\n\t\t\tconnDone chan struct{}\n\t\t\tsender   *MockSender\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\tsender = NewMockSender(mockCtrl)\n\t\t\tsender.EXPECT().Run()\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tconn.sendQueue = sender\n\t\t\tconnDone = make(chan struct{})\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tsender.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t\tEventually(connDone).Should(BeClosed())\n\t\t})\n\n\t\trunConn := func() {\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t\tclose(connDone)\n\t\t\t}()\n\t\t}\n\n\t\tIt(\"sends packets\", func() {\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tconn.sentPacketHandler = sph\n\t\t\trunConn()\n\t\t\tp := shortHeaderPacket{\n\t\t\t\tDestConnID:      protocol.ParseConnectionID([]byte{1, 2, 3}),\n\t\t\t\tPacketNumber:    1337,\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen3,\n\t\t\t\tKeyPhase:        protocol.KeyPhaseOne,\n\t\t\t}\n\t\t\texpectAppendPacket(packer, p, []byte(\"foobar\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\t\tsent := make(chan struct{})\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(sent) })\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(&logging.ShortHeader{\n\t\t\t\tDestConnectionID: p.DestConnID,\n\t\t\t\tPacketNumber:     p.PacketNumber,\n\t\t\t\tPacketNumberLen:  p.PacketNumberLen,\n\t\t\t\tKeyPhase:         p.KeyPhase,\n\t\t\t}, gomock.Any(), nil, []logging.Frame{})\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(sent).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't send packets if there's nothing to send\", func() {\n\t\t\tconn.handshakeConfirmed = true\n\t\t\trunConn()\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\t\tconn.receivedPacketHandler.ReceivedPacket(0x035e, protocol.ECNNon, protocol.Encryption1RTT, time.Now(), true)\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure there are no calls to mconn.Write()\n\t\t})\n\n\t\tIt(\"sends ACK only packets\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAck)\n\t\t\tdone := make(chan struct{})\n\t\t\tpacker.EXPECT().PackCoalescedPacket(true, gomock.Any(), conn.version).Do(func(bool, protocol.ByteCount, protocol.VersionNumber) { close(done) })\n\t\t\tconn.sentPacketHandler = sph\n\t\t\trunConn()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"adds a BLOCKED frame when it is connection-level flow control blocked\", func() {\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tfc := mocks.NewMockConnectionFlowController(mockCtrl)\n\t\t\tfc.EXPECT().IsNewlyBlocked().Return(true, protocol.ByteCount(1337))\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 13}, []byte(\"foobar\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\t\tconn.connFlowController = fc\n\t\t\trunConn()\n\t\t\tsent := make(chan struct{})\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(sent) })\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), nil, []logging.Frame{})\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(sent).Should(BeClosed())\n\t\t\tframes, _ := conn.framer.AppendControlFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(Equal([]ackhandler.Frame{{Frame: &logging.DataBlockedFrame{MaximumData: 1337}}}))\n\t\t})\n\n\t\tIt(\"doesn't send when the SentPacketHandler doesn't allow it\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone).AnyTimes()\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tconn.sentPacketHandler = sph\n\t\t\trunConn()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t})\n\n\t\tfor _, enc := range []protocol.EncryptionLevel{protocol.EncryptionInitial, protocol.EncryptionHandshake, protocol.Encryption1RTT} {\n\t\t\tencLevel := enc\n\n\t\t\tContext(fmt.Sprintf(\"sending %s probe packets\", encLevel), func() {\n\t\t\t\tvar sendMode ackhandler.SendMode\n\t\t\t\tvar getFrame func(protocol.ByteCount, protocol.VersionNumber) wire.Frame\n\n\t\t\t\tBeforeEach(func() {\n\t\t\t\t\t//nolint:exhaustive\n\t\t\t\t\tswitch encLevel {\n\t\t\t\t\tcase protocol.EncryptionInitial:\n\t\t\t\t\t\tsendMode = ackhandler.SendPTOInitial\n\t\t\t\t\t\tgetFrame = conn.retransmissionQueue.GetInitialFrame\n\t\t\t\t\tcase protocol.EncryptionHandshake:\n\t\t\t\t\t\tsendMode = ackhandler.SendPTOHandshake\n\t\t\t\t\t\tgetFrame = conn.retransmissionQueue.GetHandshakeFrame\n\t\t\t\t\tcase protocol.Encryption1RTT:\n\t\t\t\t\t\tsendMode = ackhandler.SendPTOAppData\n\t\t\t\t\t\tgetFrame = conn.retransmissionQueue.GetAppDataFrame\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tIt(\"sends a probe packet\", func() {\n\t\t\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(sendMode)\n\t\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\t\t\t\t\tsph.EXPECT().QueueProbePacket(encLevel)\n\t\t\t\t\tp := getCoalescedPacket(123, enc != protocol.Encryption1RTT)\n\t\t\t\t\tpacker.EXPECT().MaybePackProbePacket(encLevel, gomock.Any(), conn.version).Return(p, nil)\n\t\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, _ protocol.EncryptionLevel, _ protocol.ByteCount, _ bool) {\n\t\t\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(123)))\n\t\t\t\t\t})\n\t\t\t\t\tconn.sentPacketHandler = sph\n\t\t\t\t\trunConn()\n\t\t\t\t\tsent := make(chan struct{})\n\t\t\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(sent) })\n\t\t\t\t\tif enc == protocol.Encryption1RTT {\n\t\t\t\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), p.shortHdrPacket.Length, gomock.Any(), gomock.Any())\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttracer.EXPECT().SentLongHeaderPacket(gomock.Any(), p.longHdrPackets[0].length, gomock.Any(), gomock.Any())\n\t\t\t\t\t}\n\t\t\t\t\tconn.scheduleSending()\n\t\t\t\t\tEventually(sent).Should(BeClosed())\n\t\t\t\t})\n\n\t\t\t\tIt(\"sends a PING as a probe packet\", func() {\n\t\t\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(sendMode)\n\t\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\t\t\t\t\tsph.EXPECT().QueueProbePacket(encLevel).Return(false)\n\t\t\t\t\tp := getCoalescedPacket(123, enc != protocol.Encryption1RTT)\n\t\t\t\t\tpacker.EXPECT().MaybePackProbePacket(encLevel, gomock.Any(), conn.version).Return(p, nil)\n\t\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, _ protocol.EncryptionLevel, _ protocol.ByteCount, _ bool) {\n\t\t\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(123)))\n\t\t\t\t\t})\n\t\t\t\t\tconn.sentPacketHandler = sph\n\t\t\t\t\trunConn()\n\t\t\t\t\tsent := make(chan struct{})\n\t\t\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(sent) })\n\t\t\t\t\tif enc == protocol.Encryption1RTT {\n\t\t\t\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), p.shortHdrPacket.Length, gomock.Any(), gomock.Any())\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttracer.EXPECT().SentLongHeaderPacket(gomock.Any(), p.longHdrPackets[0].length, gomock.Any(), gomock.Any())\n\t\t\t\t\t}\n\t\t\t\t\tconn.scheduleSending()\n\t\t\t\t\tEventually(sent).Should(BeClosed())\n\t\t\t\t\t// We're using a mock packet packer in this test.\n\t\t\t\t\t// We therefore need to test separately that the PING was actually queued.\n\t\t\t\t\tExpect(getFrame(1000, protocol.Version1)).To(BeAssignableToTypeOf(&wire.PingFrame{}))\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t})\n\n\tContext(\"packet pacing\", func() {\n\t\tvar (\n\t\t\tsph    *mockackhandler.MockSentPacketHandler\n\t\t\tsender *MockSender\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tsph = mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tconn.handshakeConfirmed = true\n\t\t\tconn.handshakeComplete = true\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tsender = NewMockSender(mockCtrl)\n\t\t\tsender.EXPECT().Run()\n\t\t\tconn.sendQueue = sender\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t// make the go routine return\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tsender.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sends multiple packets one by one immediately\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited)\n\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(time.Hour))\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, []byte(\"packet10\"))\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 11}, []byte(\"packet11\"))\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(b *packetBuffer, _ protocol.ByteCount) {\n\t\t\t\tExpect(b.Data).To(Equal([]byte(\"packet10\")))\n\t\t\t})\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(b *packetBuffer, _ protocol.ByteCount) {\n\t\t\t\tExpect(b.Data).To(Equal([]byte(\"packet11\")))\n\t\t\t})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 2 packets are sent\n\t\t})\n\n\t\tIt(\"sends multiple packets one by one immediately, with GSO\", func() {\n\t\t\tenableGSO()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(3)\n\t\t\tpayload1 := make([]byte, conn.mtuDiscoverer.CurrentSize())\n\t\t\trand.Read(payload1)\n\t\t\tpayload2 := make([]byte, conn.mtuDiscoverer.CurrentSize())\n\t\t\trand.Read(payload2)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, payload1)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 11}, payload2)\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any()).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), conn.mtuDiscoverer.CurrentSize()).Do(func(b *packetBuffer, l protocol.ByteCount) {\n\t\t\t\tExpect(b.Data).To(Equal(append(payload1, payload2...)))\n\t\t\t})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 2 packets are sent\n\t\t})\n\n\t\tIt(\"stops appending packets when a smaller packet is packed, with GSO\", func() {\n\t\t\tenableGSO()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(2)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\t\t\tpayload1 := make([]byte, conn.mtuDiscoverer.CurrentSize())\n\t\t\trand.Read(payload1)\n\t\t\tpayload2 := make([]byte, conn.mtuDiscoverer.CurrentSize()-1)\n\t\t\trand.Read(payload2)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, payload1)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 11}, payload2)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), conn.mtuDiscoverer.CurrentSize()).Do(func(b *packetBuffer, l protocol.ByteCount) {\n\t\t\t\tExpect(b.Data).To(Equal(append(payload1, payload2...)))\n\t\t\t})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 2 packets are sent\n\t\t})\n\n\t\tIt(\"sends multiple packets, when the pacer allows immediate sending\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(2)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, []byte(\"packet10\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any())\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 1 packet is sent\n\t\t})\n\n\t\tIt(\"allows an ACK to be sent when pacing limited\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(time.Hour))\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited)\n\t\t\tpacker.EXPECT().PackAckOnlyPacket(gomock.Any(), conn.version).Return(shortHeaderPacket{PacketNumber: 123}, getPacketBuffer(), nil)\n\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any())\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 1 packet is sent\n\t\t})\n\n\t\t// when becoming congestion limited, at some point the SendMode will change from SendAny to SendAck\n\t\t// we shouldn't send the ACK in the same run\n\t\tIt(\"doesn't send an ACK right after becoming congestion limited\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAck)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 100}, []byte(\"packet100\"))\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any())\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(50 * time.Millisecond) // make sure that only 1 packet is sent\n\t\t})\n\n\t\tIt(\"paces packets\", func() {\n\t\t\tpacingDelay := scaleDuration(100 * time.Millisecond)\n\t\t\tgomock.InOrder(\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny),\n\t\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 100}, []byte(\"packet100\")),\n\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited),\n\t\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(pacingDelay)),\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny),\n\t\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 101}, []byte(\"packet101\")),\n\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited),\n\t\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(time.Hour)),\n\t\t\t)\n\t\t\twritten := make(chan struct{}, 2)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} }).Times(2)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(HaveLen(1))\n\t\t\tConsistently(written, pacingDelay/2).Should(HaveLen(1))\n\t\t\tEventually(written, 2*pacingDelay).Should(HaveLen(2))\n\t\t})\n\n\t\tIt(\"sends multiple packets at once\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Times(3)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(3)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited)\n\t\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(time.Hour))\n\t\t\tfor pn := protocol.PacketNumber(1000); pn < 1003; pn++ {\n\t\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: pn}, []byte(\"packet\"))\n\t\t\t}\n\t\t\twritten := make(chan struct{}, 3)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} }).Times(3)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(HaveLen(3))\n\t\t})\n\n\t\tfor _, withGSO := range []bool{false, true} {\n\t\t\twithGSO := withGSO\n\t\t\tIt(fmt.Sprintf(\"doesn't try to send if the send queue is full: %t\", withGSO), func() {\n\t\t\t\tif withGSO {\n\t\t\t\t\tenableGSO()\n\t\t\t\t}\n\t\t\t\tavailable := make(chan struct{}, 1)\n\t\t\t\tsender.EXPECT().WouldBlock().Return(true)\n\t\t\t\tsender.EXPECT().Available().Return(available)\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\t\tconn.run()\n\t\t\t\t}()\n\t\t\t\tconn.scheduleSending()\n\t\t\t\ttime.Sleep(scaleDuration(50 * time.Millisecond))\n\n\t\t\t\twritten := make(chan struct{})\n\t\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1000}, []byte(\"packet1000\"))\n\t\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { close(written) })\n\t\t\t\tavailable <- struct{}{}\n\t\t\t\tEventually(written).Should(BeClosed())\n\t\t\t})\n\t\t}\n\n\t\tIt(\"stops sending when there are new packets to receive\", func() {\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\n\t\t\twritten := make(chan struct{})\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(time.Time, protocol.PacketNumber, protocol.PacketNumber, []ackhandler.StreamFrame, []ackhandler.Frame, protocol.EncryptionLevel, protocol.ByteCount, bool) {\n\t\t\t\tsph.EXPECT().ReceivedBytes(gomock.Any())\n\t\t\t\tconn.handlePacket(receivedPacket{buffer: getPacketBuffer()})\n\t\t\t})\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 10}, []byte(\"packet10\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { close(written) })\n\n\t\t\tconn.scheduleSending()\n\t\t\ttime.Sleep(scaleDuration(50 * time.Millisecond))\n\n\t\t\tEventually(written).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"stops sending when the send queue is full\", func() {\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny)\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1000}, []byte(\"packet1000\"))\n\t\t\twritten := make(chan struct{}, 1)\n\t\t\tsender.EXPECT().WouldBlock()\n\t\t\tsender.EXPECT().WouldBlock().Return(true).Times(2)\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} })\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tavailable := make(chan struct{}, 1)\n\t\t\tsender.EXPECT().Available().Return(available)\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(Receive())\n\t\t\ttime.Sleep(scaleDuration(50 * time.Millisecond))\n\n\t\t\t// now make room in the send queue\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1001}, []byte(\"packet1001\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} })\n\t\t\tavailable <- struct{}{}\n\t\t\tEventually(written).Should(Receive())\n\n\t\t\t// The send queue is not full any more. Sending on the available channel should have no effect.\n\t\t\tavailable <- struct{}{}\n\t\t\ttime.Sleep(scaleDuration(50 * time.Millisecond))\n\t\t})\n\n\t\tIt(\"doesn't set a pacing timer when there is no data to send\", func() {\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\t// don't EXPECT any calls to mconn.Write()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending() // no packet will get sent\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t})\n\n\t\tIt(\"sends a Path MTU probe packet\", func() {\n\t\t\tmtuDiscoverer := NewMockMTUDiscoverer(mockCtrl)\n\t\t\tconn.mtuDiscoverer = mtuDiscoverer\n\t\t\tconn.config.DisablePathMTUDiscovery = false\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny)\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\t\t\twritten := make(chan struct{}, 1)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).DoAndReturn(func(*packetBuffer, protocol.ByteCount) { written <- struct{}{} })\n\t\t\tmtuDiscoverer.EXPECT().ShouldSendProbe(gomock.Any()).Return(true)\n\t\t\tping := ackhandler.Frame{Frame: &wire.PingFrame{}}\n\t\t\tmtuDiscoverer.EXPECT().GetPing().Return(ping, protocol.ByteCount(1234))\n\t\t\tpacker.EXPECT().PackMTUProbePacket(ping, protocol.ByteCount(1234), conn.version).Return(shortHeaderPacket{PacketNumber: 1}, getPacketBuffer(), nil)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(Receive())\n\t\t\tmtuDiscoverer.EXPECT().CurrentSize().Return(protocol.ByteCount(1234))\n\t\t})\n\t})\n\n\tContext(\"scheduling sending\", func() {\n\t\tvar sender *MockSender\n\n\t\tBeforeEach(func() {\n\t\t\tsender = NewMockSender(mockCtrl)\n\t\t\tsender.EXPECT().WouldBlock().AnyTimes()\n\t\t\tsender.EXPECT().Run()\n\t\t\tconn.sendQueue = sender\n\t\t\tconn.handshakeConfirmed = true\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t// make the go routine return\n\t\t\texpectReplaceWithClosed()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tsender.EXPECT().Close()\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sends when scheduleSending is called\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tconn.sentPacketHandler = sph\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1}, []byte(\"packet1\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\t// don't EXPECT any calls to mconn.Write()\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t// only EXPECT calls after scheduleSending is called\n\t\t\twritten := make(chan struct{})\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(written) })\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tconn.scheduleSending()\n\t\t\tEventually(written).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sets the timer to the ack timer\", func() {\n\t\t\texpectAppendPacket(packer, shortHeaderPacket{PacketNumber: 1234}, []byte(\"packet1234\"))\n\t\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack)\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, _ protocol.EncryptionLevel, _ protocol.ByteCount, _ bool) {\n\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(1234)))\n\t\t\t})\n\t\t\tconn.sentPacketHandler = sph\n\t\t\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\t\t\trph.EXPECT().GetAlarmTimeout().Return(time.Now().Add(10 * time.Millisecond))\n\t\t\t// make the run loop wait\n\t\t\trph.EXPECT().GetAlarmTimeout().Return(time.Now().Add(time.Hour)).MaxTimes(1)\n\t\t\tconn.receivedPacketHandler = rph\n\n\t\t\twritten := make(chan struct{})\n\t\t\tsender.EXPECT().Send(gomock.Any(), gomock.Any()).Do(func(*packetBuffer, protocol.ByteCount) { close(written) })\n\t\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tEventually(written).Should(BeClosed())\n\t\t})\n\t})\n\n\tIt(\"sends coalesced packets before the handshake is confirmed\", func() {\n\t\tconn.handshakeComplete = false\n\t\tconn.handshakeConfirmed = false\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tconn.sentPacketHandler = sph\n\t\tbuffer := getPacketBuffer()\n\t\tbuffer.Data = append(buffer.Data, []byte(\"foobar\")...)\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Return(&coalescedPacket{\n\t\t\tbuffer: buffer,\n\t\t\tlongHdrPackets: []*longHeaderPacket{\n\t\t\t\t{\n\t\t\t\t\theader: &wire.ExtendedHeader{\n\t\t\t\t\t\tHeader:       wire.Header{Type: protocol.PacketTypeInitial},\n\t\t\t\t\t\tPacketNumber: 13,\n\t\t\t\t\t},\n\t\t\t\t\tlength: 123,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\theader: &wire.ExtendedHeader{\n\t\t\t\t\t\tHeader:       wire.Header{Type: protocol.PacketTypeHandshake},\n\t\t\t\t\t\tPacketNumber: 37,\n\t\t\t\t\t},\n\t\t\t\t\tlength: 1234,\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\n\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\tsph.EXPECT().TimeUntilSend().Return(time.Now()).AnyTimes()\n\t\tgomock.InOrder(\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, encLevel protocol.EncryptionLevel, size protocol.ByteCount, _ bool) {\n\t\t\t\tExpect(encLevel).To(Equal(protocol.EncryptionInitial))\n\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(13)))\n\t\t\t\tExpect(size).To(BeEquivalentTo(123))\n\t\t\t}),\n\t\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ time.Time, pn, _ protocol.PacketNumber, _ []ackhandler.StreamFrame, _ []ackhandler.Frame, encLevel protocol.EncryptionLevel, size protocol.ByteCount, _ bool) {\n\t\t\t\tExpect(encLevel).To(Equal(protocol.EncryptionHandshake))\n\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(37)))\n\t\t\t\tExpect(size).To(BeEquivalentTo(1234))\n\t\t\t}),\n\t\t)\n\t\tgomock.InOrder(\n\t\t\ttracer.EXPECT().SentLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(hdr *wire.ExtendedHeader, _ protocol.ByteCount, _ *wire.AckFrame, _ []logging.Frame) {\n\t\t\t\tExpect(hdr.Type).To(Equal(protocol.PacketTypeInitial))\n\t\t\t}),\n\t\t\ttracer.EXPECT().SentLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(hdr *wire.ExtendedHeader, _ protocol.ByteCount, _ *wire.AckFrame, _ []logging.Frame) {\n\t\t\t\tExpect(hdr.Type).To(Equal(protocol.PacketTypeHandshake))\n\t\t\t}),\n\t\t)\n\n\t\tsent := make(chan struct{})\n\t\tmconn.EXPECT().Write([]byte(\"foobar\"), protocol.ByteCount(6)).Do(func([]byte, protocol.ByteCount) { close(sent) })\n\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tconn.run()\n\t\t}()\n\n\t\tconn.scheduleSending()\n\t\tEventually(sent).Should(BeClosed())\n\n\t\t// make sure the go routine returns\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t})\n\n\tIt(\"cancels the HandshakeComplete context when the handshake completes\", func() {\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tconn.sentPacketHandler = sph\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\tsph.EXPECT().SendMode(gomock.Any()).AnyTimes()\n\t\tsph.EXPECT().DropPackets(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().SetHandshakeConfirmed()\n\t\tconnRunner.EXPECT().Retire(clientDestConnID)\n\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\tcryptoSetup.EXPECT().GetSessionTicket()\n\t\thandshakeCtx := conn.HandshakeComplete()\n\t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n\t\tEventually(handshakeCtx).Should(BeClosed())\n\t})\n\n\tIt(\"sends a session ticket when the handshake completes\", func() {\n\t\tconst size = protocol.MaxPostHandshakeCryptoFrameSize * 3 / 2\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\tconnRunner.EXPECT().Retire(clientDestConnID)\n\t\tconn.sentPacketHandler.DropPackets(protocol.EncryptionInitial)\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\tcryptoSetup.EXPECT().GetSessionTicket().Return(make([]byte, size), nil)\n\n\t\thandshakeCtx := conn.HandshakeComplete()\n\t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n\t\tvar frames []ackhandler.Frame\n\t\tEventually(func() []ackhandler.Frame {\n\t\t\tframes, _ = conn.framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\treturn frames\n\t\t}).ShouldNot(BeEmpty())\n\t\tvar count int\n\t\tvar s int\n\t\tfor _, f := range frames {\n\t\t\tif cf, ok := f.Frame.(*wire.CryptoFrame); ok {\n\t\t\t\tcount++\n\t\t\t\ts += len(cf.Data)\n\t\t\t\tExpect(f.Frame.Length(conn.version)).To(BeNumerically(\"<=\", protocol.MaxPostHandshakeCryptoFrameSize))\n\t\t\t}\n\t\t}\n\t\tExpect(size).To(BeEquivalentTo(s))\n\t})\n\n\tIt(\"doesn't cancel the HandshakeComplete context when the handshake fails\", func() {\n\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake()\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tconn.run()\n\t\t}()\n\t\thandshakeCtx := conn.HandshakeComplete()\n\t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\tconn.closeLocal(errors.New(\"handshake error\"))\n\t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t})\n\n\tIt(\"sends a HANDSHAKE_DONE frame when the handshake completes\", func() {\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\t\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\t\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\t\tsph.EXPECT().SetHandshakeConfirmed()\n\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().SentShortHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\tconn.sentPacketHandler = sph\n\t\tdone := make(chan struct{})\n\t\tconnRunner.EXPECT().Retire(clientDestConnID)\n\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(_ *packetBuffer, _ protocol.ByteCount, v protocol.VersionNumber) (shortHeaderPacket, error) {\n\t\t\tframes, _ := conn.framer.AppendControlFrames(nil, protocol.MaxByteCount, v)\n\t\t\tExpect(frames).ToNot(BeEmpty())\n\t\t\tExpect(frames[0].Frame).To(BeEquivalentTo(&wire.HandshakeDoneFrame{}))\n\t\t\tdefer close(done)\n\t\t\treturn shortHeaderPacket{}, nil\n\t\t})\n\t\tpacker.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), conn.version).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().DropPackets(protocol.EncryptionHandshake)\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake()\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete})\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\t\tcryptoSetup.EXPECT().GetSessionTicket()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n\t\t\tconn.run()\n\t\t}()\n\t\tEventually(done).Should(BeClosed())\n\t\t// make sure the go routine returns\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t})\n\n\tIt(\"doesn't return a run error when closing\", func() {\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tExpect(conn.run()).To(Succeed())\n\t\t\tclose(done)\n\t\t}()\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(done).Should(BeClosed())\n\t\tExpect(context.Cause(conn.Context())).To(MatchError(context.Canceled))\n\t})\n\n\tIt(\"passes errors to the connection runner\", func() {\n\t\ttestErr := errors.New(\"handshake error\")\n\t\texpectedErr := &qerr.ApplicationError{\n\t\t\tErrorCode:    0x1337,\n\t\t\tErrorMessage: testErr.Error(),\n\t\t}\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\terr := conn.run()\n\t\t\tExpect(err).To(MatchError(expectedErr))\n\t\t\tclose(done)\n\t\t}()\n\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\texpectReplaceWithClosed()\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tExpect(conn.CloseWithError(0x1337, testErr.Error())).To(Succeed())\n\t\tEventually(done).Should(BeClosed())\n\t\tExpect(context.Cause(conn.Context())).To(MatchError(expectedErr))\n\t})\n\n\tContext(\"transport parameters\", func() {\n\t\tIt(\"processes transport parameters received from the client\", func() {\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tMaxIdleTimeout:                90 * time.Second,\n\t\t\t\tInitialMaxStreamDataBidiLocal: 0x5000,\n\t\t\t\tInitialMaxData:                0x5000,\n\t\t\t\tActiveConnectionIDLimit:       3,\n\t\t\t\t// marshaling always sets it to this value\n\t\t\t\tMaxUDPPayloadSize:         protocol.MaxPacketBufferSize,\n\t\t\t\tInitialSourceConnectionID: destConnID,\n\t\t\t}\n\t\t\tstreamManager.EXPECT().UpdateLimits(params)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).MaxTimes(3)\n\t\t\tExpect(conn.earlyConnReady()).ToNot(BeClosed())\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params)\n\t\t\tconn.handleTransportParameters(params)\n\t\t\tExpect(conn.earlyConnReady()).To(BeClosed())\n\t\t})\n\t})\n\n\tContext(\"keep-alives\", func() {\n\t\tsetRemoteIdleTimeout := func(t time.Duration) {\n\t\t\tstreamManager.EXPECT().UpdateLimits(gomock.Any())\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(gomock.Any())\n\t\t\tconn.handleTransportParameters(&wire.TransportParameters{\n\t\t\t\tMaxIdleTimeout:            t,\n\t\t\t\tInitialSourceConnectionID: destConnID,\n\t\t\t})\n\t\t}\n\n\t\trunConn := func() {\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t}\n\n\t\tBeforeEach(func() {\n\t\t\tconn.config.MaxIdleTimeout = 30 * time.Second\n\t\t\tconn.config.KeepAlivePeriod = 15 * time.Second\n\t\t\tconn.receivedPacketHandler.ReceivedPacket(0, protocol.ECNNon, protocol.EncryptionHandshake, time.Now(), true)\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t// make the go routine return\n\t\t\texpectReplaceWithClosed()\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sends a PING as a keep-alive after half the idle timeout\", func() {\n\t\t\tsetRemoteIdleTimeout(5 * time.Second)\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-5 * time.Second / 2)\n\t\t\tsent := make(chan struct{})\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Do(func(bool, protocol.ByteCount, protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tclose(sent)\n\t\t\t\treturn nil, nil\n\t\t\t})\n\t\t\trunConn()\n\t\t\tEventually(sent).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"sends a PING after a maximum of protocol.MaxKeepAliveInterval\", func() {\n\t\t\tconn.config.MaxIdleTimeout = time.Hour\n\t\t\tsetRemoteIdleTimeout(time.Hour)\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-protocol.MaxKeepAliveInterval).Add(-time.Millisecond)\n\t\t\tsent := make(chan struct{})\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Do(func(bool, protocol.ByteCount, protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tclose(sent)\n\t\t\t\treturn nil, nil\n\t\t\t})\n\t\t\trunConn()\n\t\t\tEventually(sent).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't send a PING packet if keep-alive is disabled\", func() {\n\t\t\tsetRemoteIdleTimeout(5 * time.Second)\n\t\t\tconn.config.KeepAlivePeriod = 0\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-time.Second * 5 / 2)\n\t\t\trunConn()\n\t\t\t// don't EXPECT() any calls to mconn.Write()\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t})\n\n\t\tIt(\"doesn't send a PING if the handshake isn't completed yet\", func() {\n\t\t\tconn.config.HandshakeIdleTimeout = time.Hour\n\t\t\tconn.handshakeComplete = false\n\t\t\t// Needs to be shorter than our idle timeout.\n\t\t\t// Otherwise we'll try to send a CONNECTION_CLOSE.\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-20 * time.Second)\n\t\t\trunConn()\n\t\t\t// don't EXPECT() any calls to mconn.Write()\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t})\n\n\t\tIt(\"send PING as keep-alive earliest after 1.5 times the PTO\", func() {\n\t\t\tconn.config.KeepAlivePeriod = time.Microsecond\n\t\t\tpto := conn.rttStats.PTO(true)\n\t\t\tconn.lastPacketReceivedTime = time.Now()\n\t\t\tsentPingTimeChan := make(chan time.Time)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).Do(func(bool, protocol.ByteCount, protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tsentPingTimeChan <- time.Now()\n\t\t\t\treturn nil, nil\n\t\t\t})\n\t\t\trunConn()\n\t\t\tsentPingTime := <-sentPingTimeChan\n\t\t\tExpect(sentPingTime.Sub(conn.lastPacketReceivedTime)).To(BeNumerically(\">\", pto*3/2))\n\t\t})\n\t})\n\n\tContext(\"timeouts\", func() {\n\t\tBeforeEach(func() {\n\t\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n\t\t})\n\n\t\tIt(\"times out due to no network activity\", func() {\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).Times(2)\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-time.Hour)\n\t\t\tdone := make(chan struct{})\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tExpect(e).To(MatchError(&qerr.IdleTimeoutError{}))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terr := conn.run()\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tExpect(ok).To(BeTrue())\n\t\t\t\tExpect(nerr.Timeout()).To(BeTrue())\n\t\t\t\tExpect(err).To(MatchError(qerr.ErrIdleTimeout))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"times out due to non-completed handshake\", func() {\n\t\t\tconn.handshakeComplete = false\n\t\t\tconn.creationTime = time.Now().Add(-protocol.DefaultHandshakeTimeout).Add(-time.Second)\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).Times(2)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tExpect(e).To(MatchError(&HandshakeTimeoutError{}))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terr := conn.run()\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tExpect(ok).To(BeTrue())\n\t\t\t\tExpect(nerr.Timeout()).To(BeTrue())\n\t\t\t\tExpect(err).To(MatchError(qerr.ErrHandshakeTimeout))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"does not use the idle timeout before the handshake complete\", func() {\n\t\t\tconn.handshakeComplete = false\n\t\t\tconn.config.HandshakeIdleTimeout = 9999 * time.Second\n\t\t\tconn.config.MaxIdleTimeout = 9999 * time.Second\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-time.Minute)\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(e *qerr.ApplicationError, _ protocol.ByteCount, _ protocol.VersionNumber) (*coalescedPacket, error) {\n\t\t\t\tExpect(e.ErrorCode).To(BeZero())\n\t\t\t\treturn &coalescedPacket{buffer: getPacketBuffer()}, nil\n\t\t\t})\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tidleTimeout := &IdleTimeoutError{}\n\t\t\t\t\thandshakeTimeout := &HandshakeTimeoutError{}\n\t\t\t\t\tExpect(errors.As(e, &idleTimeout)).To(BeFalse())\n\t\t\t\t\tExpect(errors.As(e, &handshakeTimeout)).To(BeFalse())\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\t// the handshake timeout is irrelevant here, since it depends on the time the connection was created,\n\t\t\t// and not on the last network activity\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\t\t\t// make the go routine return\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes the connection due to the idle timeout before handshake\", func() {\n\t\t\tconn.config.HandshakeIdleTimeout = 0\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tExpect(e).To(MatchError(&IdleTimeoutError{}))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tdone := make(chan struct{})\n\t\t\tconn.handshakeComplete = false\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tcryptoSetup.EXPECT().GetSessionTicket().MaxTimes(1)\n\t\t\t\terr := conn.run()\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tExpect(ok).To(BeTrue())\n\t\t\t\tExpect(nerr.Timeout()).To(BeTrue())\n\t\t\t\tExpect(err).To(MatchError(qerr.ErrIdleTimeout))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"closes the connection due to the idle timeout after handshake\", func() {\n\t\t\tconn.sentPacketHandler.DropPackets(protocol.EncryptionInitial)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\t\tgomock.InOrder(\n\t\t\t\tconnRunner.EXPECT().Retire(clientDestConnID),\n\t\t\t\tconnRunner.EXPECT().Remove(gomock.Any()),\n\t\t\t)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake),\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tExpect(e).To(MatchError(&IdleTimeoutError{}))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tconn.idleTimeout = 0\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete})\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tcryptoSetup.EXPECT().GetSessionTicket().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed().MaxTimes(1)\n\t\t\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n\t\t\t\terr := conn.run()\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tExpect(ok).To(BeTrue())\n\t\t\t\tExpect(nerr.Timeout()).To(BeTrue())\n\t\t\t\tExpect(err).To(MatchError(qerr.ErrIdleTimeout))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't time out when it just sent a packet\", func() {\n\t\t\tconn.lastPacketReceivedTime = time.Now().Add(-time.Hour)\n\t\t\tconn.firstAckElicitingPacketAfterIdleSentTime = time.Now().Add(-time.Second)\n\t\t\tconn.idleTimeout = 30 * time.Second\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tconn.run()\n\t\t\t}()\n\t\t\tConsistently(conn.Context().Done()).ShouldNot(BeClosed())\n\t\t\t// make the go routine return\n\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\t\texpectReplaceWithClosed()\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"times out earliest after 3 times the PTO\", func() {\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n\t\t\tconnRunner.EXPECT().Retire(gomock.Any()).AnyTimes()\n\t\t\tconnRunner.EXPECT().Remove(gomock.Any()).Times(2)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tcloseTimeChan := make(chan time.Time)\n\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\tExpect(e).To(MatchError(&IdleTimeoutError{}))\n\t\t\t\tcloseTimeChan <- time.Now()\n\t\t\t})\n\t\t\ttracer.EXPECT().Close()\n\t\t\tconn.idleTimeout = time.Millisecond\n\t\t\tdone := make(chan struct{})\n\t\t\tpto := conn.rttStats.PTO(true)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\tcryptoSetup.EXPECT().GetSessionTicket().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed().MaxTimes(1)\n\t\t\t\tconn.run()\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tcloseTime := <-closeTimeChan\n\t\t\tExpect(closeTime.Sub(conn.lastPacketReceivedTime)).To(BeNumerically(\">\", pto*3))\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\t})\n\n\tIt(\"stores up to MaxConnUnprocessedPackets packets\", func() {\n\t\tdone := make(chan struct{})\n\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, logging.ByteCount(6), logging.PacketDropDOSPrevention).Do(func(logging.PacketType, logging.ByteCount, logging.PacketDropReason) {\n\t\t\tclose(done)\n\t\t})\n\t\t// Nothing here should block\n\t\tfor i := protocol.PacketNumber(0); i < protocol.MaxConnUnprocessedPackets+1; i++ {\n\t\t\tconn.handlePacket(receivedPacket{data: []byte(\"foobar\")})\n\t\t}\n\t\tEventually(done).Should(BeClosed())\n\t})\n\n\tContext(\"getting streams\", func() {\n\t\tIt(\"opens streams\", func() {\n\t\t\tmstr := NewMockStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().OpenStream().Return(mstr, nil)\n\t\t\tstr, err := conn.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"opens streams synchronously\", func() {\n\t\t\tmstr := NewMockStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().OpenStreamSync(context.Background()).Return(mstr, nil)\n\t\t\tstr, err := conn.OpenStreamSync(context.Background())\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"opens unidirectional streams\", func() {\n\t\t\tmstr := NewMockSendStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().OpenUniStream().Return(mstr, nil)\n\t\t\tstr, err := conn.OpenUniStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"opens unidirectional streams synchronously\", func() {\n\t\t\tmstr := NewMockSendStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().OpenUniStreamSync(context.Background()).Return(mstr, nil)\n\t\t\tstr, err := conn.OpenUniStreamSync(context.Background())\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"accepts streams\", func() {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\t\t\tdefer cancel()\n\t\t\tmstr := NewMockStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().AcceptStream(ctx).Return(mstr, nil)\n\t\t\tstr, err := conn.AcceptStream(ctx)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\n\t\tIt(\"accepts unidirectional streams\", func() {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\t\tdefer cancel()\n\t\t\tmstr := NewMockReceiveStreamI(mockCtrl)\n\t\t\tstreamManager.EXPECT().AcceptUniStream(ctx).Return(mstr, nil)\n\t\t\tstr, err := conn.AcceptUniStream(ctx)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(Equal(mstr))\n\t\t})\n\t})\n\n\tIt(\"returns the local address\", func() {\n\t\tExpect(conn.LocalAddr()).To(Equal(localAddr))\n\t})\n\n\tIt(\"returns the remote address\", func() {\n\t\tExpect(conn.RemoteAddr()).To(Equal(remoteAddr))\n\t})\n})\n\nvar _ = Describe(\"Client Connection\", func() {\n\tvar (\n\t\tconn        *connection\n\t\tconnRunner  *MockConnRunner\n\t\tpacker      *MockPacker\n\t\tmconn       *MockSendConn\n\t\tcryptoSetup *mocks.MockCryptoSetup\n\t\ttracer      *mocklogging.MockConnectionTracer\n\t\ttlsConf     *tls.Config\n\t\tquicConf    *Config\n\t)\n\tsrcConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\tdestConnID := protocol.ParseConnectionID([]byte{8, 7, 6, 5, 4, 3, 2, 1})\n\n\tgetPacket := func(hdr *wire.ExtendedHeader, data []byte) receivedPacket {\n\t\tb, err := hdr.Append(nil, conn.version)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\treturn receivedPacket{\n\t\t\trcvTime: time.Now(),\n\t\t\tdata:    append(b, data...),\n\t\t\tbuffer:  getPacketBuffer(),\n\t\t}\n\t}\n\n\tBeforeEach(func() {\n\t\tquicConf = populateConfig(&Config{})\n\t\ttlsConf = nil\n\t})\n\n\tJustBeforeEach(func() {\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\n\t\tmconn = NewMockSendConn(mockCtrl)\n\t\tmconn.EXPECT().capabilities().AnyTimes()\n\t\tmconn.EXPECT().RemoteAddr().Return(&net.UDPAddr{}).AnyTimes()\n\t\tmconn.EXPECT().LocalAddr().Return(&net.UDPAddr{}).AnyTimes()\n\t\tmconn.EXPECT().capabilities().AnyTimes()\n\t\tif tlsConf == nil {\n\t\t\ttlsConf = &tls.Config{}\n\t\t}\n\t\tconnRunner = NewMockConnRunner(mockCtrl)\n\t\ttracer = mocklogging.NewMockConnectionTracer(mockCtrl)\n\t\ttracer.EXPECT().NegotiatedVersion(gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\ttracer.EXPECT().SentTransportParameters(gomock.Any())\n\t\ttracer.EXPECT().UpdatedKeyFromTLS(gomock.Any(), gomock.Any()).AnyTimes()\n\t\ttracer.EXPECT().UpdatedCongestionState(gomock.Any())\n\t\tconn = newClientConnection(\n\t\t\tmconn,\n\t\t\tconnRunner,\n\t\t\tdestConnID,\n\t\t\tprotocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8}),\n\t\t\t&protocol.DefaultConnectionIDGenerator{},\n\t\t\tquicConf,\n\t\t\ttlsConf,\n\t\t\t42, // initial packet number\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\ttracer,\n\t\t\t1234,\n\t\t\tutils.DefaultLogger,\n\t\t\tprotocol.Version1,\n\t\t).(*connection)\n\t\tpacker = NewMockPacker(mockCtrl)\n\t\tconn.packer = packer\n\t\tcryptoSetup = mocks.NewMockCryptoSetup(mockCtrl)\n\t\tconn.cryptoStreamHandler = cryptoSetup\n\t\tconn.sentFirstPacket = true\n\t})\n\n\tIt(\"changes the connection ID when receiving the first packet from the server\", func() {\n\t\tunpacker := NewMockUnpacker(mockCtrl)\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(hdr *wire.Header, _ time.Time, data []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\treturn &unpackedPacket{\n\t\t\t\tencryptionLevel: protocol.Encryption1RTT,\n\t\t\t\thdr:             &wire.ExtendedHeader{Header: *hdr},\n\t\t\t\tdata:            []byte{0}, // one PADDING frame\n\t\t\t}, nil\n\t\t})\n\t\tconn.unpacker = unpacker\n\t\tdone := make(chan struct{})\n\t\tpacker.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(onlyAck bool, maxPacketSize protocol.ByteCount, v protocol.VersionNumber) { close(done) })\n\t\tnewConnID := protocol.ParseConnectionID([]byte{1, 3, 3, 7, 1, 3, 3, 7})\n\t\tp := getPacket(&wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\tSrcConnectionID:  newConnID,\n\t\t\t\tDestConnectionID: srcConnID,\n\t\t\t\tLength:           2 + 6,\n\t\t\t\tVersion:          conn.version,\n\t\t\t},\n\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t}, []byte(\"foobar\"))\n\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), p.Size(), []logging.Frame{})\n\t\tExpect(conn.handlePacketImpl(p)).To(BeTrue())\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\tconn.run()\n\t\t}()\n\t\tEventually(done).Should(BeClosed())\n\t\t// make sure the go routine returns\n\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\t\tcryptoSetup.EXPECT().Close()\n\t\tconnRunner.EXPECT().ReplaceWithClosed([]protocol.ConnectionID{srcConnID}, gomock.Any(), gomock.Any())\n\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\tconn.shutdown()\n\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\ttime.Sleep(200 * time.Millisecond)\n\t})\n\n\tIt(\"continues accepting Long Header packets after using a new connection ID\", func() {\n\t\tunpacker := NewMockUnpacker(mockCtrl)\n\t\tconn.unpacker = unpacker\n\t\tconnRunner.EXPECT().AddResetToken(gomock.Any(), gomock.Any())\n\t\tconn.connIDManager.SetHandshakeComplete()\n\t\tconn.handleNewConnectionIDFrame(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 1,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5}),\n\t\t})\n\t\tExpect(conn.connIDManager.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5})))\n\t\t// now receive a packet with the original source connection ID\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).DoAndReturn(func(hdr *wire.Header, _ time.Time, _ []byte, _ protocol.VersionNumber) (*unpackedPacket, error) {\n\t\t\treturn &unpackedPacket{\n\t\t\t\thdr:             &wire.ExtendedHeader{Header: *hdr},\n\t\t\t\tdata:            []byte{0},\n\t\t\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\t\t}, nil\n\t\t})\n\t\thdr := &wire.Header{\n\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\tDestConnectionID: srcConnID,\n\t\t\tSrcConnectionID:  destConnID,\n\t\t}\n\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\tExpect(conn.handleLongHeaderPacket(receivedPacket{buffer: getPacketBuffer()}, hdr)).To(BeTrue())\n\t})\n\n\tIt(\"handles HANDSHAKE_DONE frames\", func() {\n\t\tconn.peerParams = &wire.TransportParameters{}\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tconn.sentPacketHandler = sph\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().DropPackets(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().SetHandshakeConfirmed()\n\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\tExpect(conn.handleHandshakeDoneFrame()).To(Succeed())\n\t})\n\n\tIt(\"interprets an ACK for 1-RTT packets as confirmation of the handshake\", func() {\n\t\tconn.peerParams = &wire.TransportParameters{}\n\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\tconn.sentPacketHandler = sph\n\t\tack := &wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 1, Largest: 3}}}\n\t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().ReceivedAck(ack, protocol.Encryption1RTT, gomock.Any()).Return(true, nil)\n\t\tsph.EXPECT().DropPackets(protocol.EncryptionHandshake)\n\t\tsph.EXPECT().SetHandshakeConfirmed()\n\t\tcryptoSetup.EXPECT().SetLargest1RTTAcked(protocol.PacketNumber(3))\n\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n\t\tExpect(conn.handleAckFrame(ack, protocol.Encryption1RTT)).To(Succeed())\n\t})\n\n\tIt(\"doesn't send a CONNECTION_CLOSE when no packet was sent\", func() {\n\t\tconn.sentFirstPacket = false\n\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\t\ttracer.EXPECT().Close()\n\t\trunning := make(chan struct{})\n\t\tcryptoSetup.EXPECT().StartHandshake().Do(func() {\n\t\t\tclose(running)\n\t\t\tconn.closeLocal(errors.New(\"early error\"))\n\t\t})\n\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\tcryptoSetup.EXPECT().Close()\n\t\tconnRunner.EXPECT().Remove(gomock.Any())\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tconn.run()\n\t\t}()\n\t\tEventually(running).Should(BeClosed())\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\t})\n\n\tContext(\"handling tokens\", func() {\n\t\tvar mockTokenStore *MockTokenStore\n\n\t\tBeforeEach(func() {\n\t\t\tmockTokenStore = NewMockTokenStore(mockCtrl)\n\t\t\ttlsConf = &tls.Config{ServerName: \"server\"}\n\t\t\tquicConf.TokenStore = mockTokenStore\n\t\t\tmockTokenStore.EXPECT().Pop(gomock.Any())\n\t\t\tquicConf.TokenStore = mockTokenStore\n\t\t})\n\n\t\tIt(\"handles NEW_TOKEN frames\", func() {\n\t\t\tmockTokenStore.EXPECT().Put(\"server\", &ClientToken{data: []byte(\"foobar\")})\n\t\t\tExpect(conn.handleNewTokenFrame(&wire.NewTokenFrame{Token: []byte(\"foobar\")})).To(Succeed())\n\t\t})\n\t})\n\n\tContext(\"handling Version Negotiation\", func() {\n\t\tgetVNP := func(versions ...protocol.VersionNumber) receivedPacket {\n\t\t\tb := wire.ComposeVersionNegotiation(\n\t\t\t\tprotocol.ArbitraryLenConnectionID(srcConnID.Bytes()),\n\t\t\t\tprotocol.ArbitraryLenConnectionID(destConnID.Bytes()),\n\t\t\t\tversions,\n\t\t\t)\n\t\t\treturn receivedPacket{\n\t\t\t\trcvTime: time.Now(),\n\t\t\t\tdata:    b,\n\t\t\t\tbuffer:  getPacketBuffer(),\n\t\t\t}\n\t\t}\n\n\t\tIt(\"closes and returns the right error\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tsph.EXPECT().ReceivedBytes(gomock.Any())\n\t\t\tsph.EXPECT().PeekPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(128), protocol.PacketNumberLen4)\n\t\t\tconn.config.Versions = []protocol.VersionNumber{1234, 4321}\n\t\t\terrChan := make(chan error, 1)\n\t\t\tstart := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().DoAndReturn(func() handshake.Event {\n\t\t\t\t\t<-start\n\t\t\t\t\treturn handshake.Event{Kind: handshake.EventNoEvent}\n\t\t\t\t})\n\t\t\t\terrChan <- conn.run()\n\t\t\t}()\n\t\t\tconnRunner.EXPECT().Remove(srcConnID)\n\t\t\ttracer.EXPECT().ReceivedVersionNegotiationPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_, _ protocol.ArbitraryLenConnectionID, versions []logging.VersionNumber) {\n\t\t\t\tExpect(versions).To(And(\n\t\t\t\t\tContainElement(protocol.VersionNumber(4321)),\n\t\t\t\t\tContainElement(protocol.VersionNumber(1337)),\n\t\t\t\t))\n\t\t\t})\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tExpect(conn.handlePacketImpl(getVNP(4321, 1337))).To(BeFalse())\n\t\t\tclose(start)\n\t\t\tvar err error\n\t\t\tEventually(errChan).Should(Receive(&err))\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err).To(BeAssignableToTypeOf(&errCloseForRecreating{}))\n\t\t\trecreateErr := err.(*errCloseForRecreating)\n\t\t\tExpect(recreateErr.nextVersion).To(Equal(protocol.VersionNumber(4321)))\n\t\t\tExpect(recreateErr.nextPacketNumber).To(Equal(protocol.PacketNumber(128)))\n\t\t})\n\n\t\tIt(\"it closes when no matching version is found\", func() {\n\t\t\terrChan := make(chan error, 1)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\t\t\t\terrChan <- conn.run()\n\t\t\t}()\n\t\t\tconnRunner.EXPECT().Remove(srcConnID).MaxTimes(1)\n\t\t\tpacker.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().ReceivedVersionNegotiationPacket(gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) {\n\t\t\t\t\tvar vnErr *VersionNegotiationError\n\t\t\t\t\tExpect(errors.As(e, &vnErr)).To(BeTrue())\n\t\t\t\t\tExpect(vnErr.Theirs).To(ContainElement(logging.VersionNumber(12345678)))\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t)\n\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\tExpect(conn.handlePacketImpl(getVNP(12345678))).To(BeFalse())\n\t\t\tvar err error\n\t\t\tEventually(errChan).Should(Receive(&err))\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err).ToNot(BeAssignableToTypeOf(errCloseForRecreating{}))\n\t\t\tExpect(err.Error()).To(ContainSubstring(\"no compatible QUIC version found\"))\n\t\t})\n\n\t\tIt(\"ignores Version Negotiation packets that offer the current version\", func() {\n\t\t\tp := getVNP(conn.version)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropUnexpectedVersion)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"ignores unparseable Version Negotiation packets\", func() {\n\t\t\tp := getVNP(conn.version)\n\t\t\tp.data = p.data[:len(p.data)-2]\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropHeaderParseError)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\t})\n\n\tContext(\"handling Retry\", func() {\n\t\torigDestConnID := protocol.ParseConnectionID([]byte{8, 7, 6, 5, 4, 3, 2, 1})\n\n\t\tvar retryHdr *wire.ExtendedHeader\n\n\t\tJustBeforeEach(func() {\n\t\t\tretryHdr = &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeRetry,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t\t\t\t\tDestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8}),\n\t\t\t\t\tToken:            []byte(\"foobar\"),\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t}\n\t\t})\n\n\t\tgetRetryTag := func(hdr *wire.ExtendedHeader) []byte {\n\t\t\tb, err := hdr.Append(nil, conn.version)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\treturn handshake.GetRetryIntegrityTag(b, origDestConnID, hdr.Version)[:]\n\t\t}\n\n\t\tIt(\"handles Retry packets\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tsph.EXPECT().ResetForRetry()\n\t\t\tsph.EXPECT().ReceivedBytes(gomock.Any())\n\t\t\tcryptoSetup.EXPECT().ChangeConnectionID(protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}))\n\t\t\tpacker.EXPECT().SetToken([]byte(\"foobar\"))\n\t\t\ttracer.EXPECT().ReceivedRetry(gomock.Any()).Do(func(hdr *wire.Header) {\n\t\t\t\tExpect(hdr.DestConnectionID).To(Equal(retryHdr.DestConnectionID))\n\t\t\t\tExpect(hdr.SrcConnectionID).To(Equal(retryHdr.SrcConnectionID))\n\t\t\t\tExpect(hdr.Token).To(Equal(retryHdr.Token))\n\t\t\t})\n\t\t\tExpect(conn.handlePacketImpl(getPacket(retryHdr, getRetryTag(retryHdr)))).To(BeTrue())\n\t\t})\n\n\t\tIt(\"ignores Retry packets after receiving a regular packet\", func() {\n\t\t\tconn.receivedFirstPacket = true\n\t\t\tp := getPacket(retryHdr, getRetryTag(retryHdr))\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"ignores Retry packets if the server didn't change the connection ID\", func() {\n\t\t\tretryHdr.SrcConnectionID = destConnID\n\t\t\tp := getPacket(retryHdr, getRetryTag(retryHdr))\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\tIt(\"ignores Retry packets with the a wrong Integrity tag\", func() {\n\t\t\ttag := getRetryTag(retryHdr)\n\t\t\ttag[0]++\n\t\t\tp := getPacket(retryHdr, tag)\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, p.Size(), logging.PacketDropPayloadDecryptError)\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\t})\n\n\tContext(\"transport parameters\", func() {\n\t\tvar (\n\t\t\tclosed     bool\n\t\t\terrChan    chan error\n\t\t\tparamsChan chan *wire.TransportParameters\n\t\t)\n\n\t\tJustBeforeEach(func() {\n\t\t\terrChan = make(chan error, 1)\n\t\t\tparamsChan = make(chan *wire.TransportParameters, 1)\n\t\t\tclosed = false\n\t\t\tpacker.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tcryptoSetup.EXPECT().StartHandshake().MaxTimes(1)\n\t\t\t\t// This is not 100% what would happen in reality.\n\t\t\t\t// The run loop calls NextEvent once when it starts up (to send out the ClientHello),\n\t\t\t\t// and then again every time a CRYPTO frame is handled.\n\t\t\t\t// Injecting a CRYPTO frame is not straightforward though,\n\t\t\t\t// so we inject the transport parameters on the first call to NextEvent.\n\t\t\t\tparams := <-paramsChan\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{\n\t\t\t\t\tKind:                handshake.EventReceivedTransportParameters,\n\t\t\t\t\tTransportParameters: params,\n\t\t\t\t})\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete}).MaxTimes(1)\n\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}).MaxTimes(1).Do(func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n\t\t\t\t})\n\t\t\t\terrChan <- conn.run()\n\t\t\t\tclose(errChan)\n\t\t\t}()\n\t\t})\n\n\t\texpectClose := func(applicationClose, errored bool) {\n\t\t\tif !closed && !errored {\n\t\t\t\tconnRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\t\tif applicationClose {\n\t\t\t\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil).MaxTimes(1)\n\t\t\t\t} else {\n\t\t\t\t\tpacker.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil).MaxTimes(1)\n\t\t\t\t}\n\t\t\t\tcryptoSetup.EXPECT().Close()\n\t\t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\ttracer.EXPECT().ClosedConnection(gomock.Any()),\n\t\t\t\t\ttracer.EXPECT().Close(),\n\t\t\t\t)\n\t\t\t}\n\t\t\tclosed = true\n\t\t}\n\n\t\tAfterEach(func() {\n\t\t\tconn.shutdown()\n\t\t\tEventually(conn.Context().Done()).Should(BeClosed())\n\t\t\tEventually(errChan).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"uses the preferred_address connection ID\", func() {\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tPreferredAddress: &wire.PreferredAddress{\n\t\t\t\t\tIPv4:                net.IPv4(127, 0, 0, 1),\n\t\t\t\t\tIPv6:                net.IP{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\t\t\tStatelessResetToken: protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\n\t\t\t\t},\n\t\t\t}\n\t\t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).MaxTimes(1)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\t// make sure the connection ID is not retired\n\t\t\tcf, _ := conn.framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(cf).To(BeEmpty())\n\t\t\tconnRunner.EXPECT().AddResetToken(protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, conn)\n\t\t\tExpect(conn.connIDManager.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4})))\n\t\t\t// shut down\n\t\t\tconnRunner.EXPECT().RemoveResetToken(protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1})\n\t\t\texpectClose(true, false)\n\t\t})\n\n\t\tIt(\"uses the minimum of the peers' idle timeouts\", func() {\n\t\t\tconn.config.MaxIdleTimeout = 19 * time.Second\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tMaxIdleTimeout:                  18 * time.Second,\n\t\t\t}\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\t// close first\n\t\t\texpectClose(true, false)\n\t\t\tconn.shutdown()\n\t\t\t// then check. Avoids race condition when accessing idleTimeout\n\t\t\tExpect(conn.idleTimeout).To(Equal(18 * time.Second))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters contain a wrong initial_source_connection_id\", func() {\n\t\t\tconn.handshakeDestConnID = protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       protocol.ParseConnectionID([]byte{0xde, 0xca, 0xfb, 0xad}),\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"expected initial_source_connection_id to equal deadbeef, is decafbad\",\n\t\t\t})))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters don't contain the retry_source_connection_id, if a Retry was performed\", func() {\n\t\t\trcid := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\tconn.retrySrcConnID = &rcid\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"missing retry_source_connection_id\",\n\t\t\t})))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters contain the wrong retry_source_connection_id, if a Retry was performed\", func() {\n\t\t\trcid := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\trcid2 := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xc0, 0xde})\n\t\t\tconn.retrySrcConnID = &rcid\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tRetrySourceConnectionID:         &rcid2,\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"expected retry_source_connection_id to equal deadbeef, is deadc0de\",\n\t\t\t})))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters contain the retry_source_connection_id, if no Retry was performed\", func() {\n\t\t\trcid := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xc0, 0xde})\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: destConnID,\n\t\t\t\tInitialSourceConnectionID:       destConnID,\n\t\t\t\tRetrySourceConnectionID:         &rcid,\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"received retry_source_connection_id, although no Retry was performed\",\n\t\t\t})))\n\t\t})\n\n\t\tIt(\"errors if the transport parameters contain a wrong original_destination_connection_id\", func() {\n\t\t\tconn.origDestConnID = protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\tparams := &wire.TransportParameters{\n\t\t\t\tOriginalDestinationConnectionID: protocol.ParseConnectionID([]byte{0xde, 0xca, 0xfb, 0xad}),\n\t\t\t\tInitialSourceConnectionID:       conn.handshakeDestConnID,\n\t\t\t\tStatelessResetToken:             &protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t\t}\n\t\t\texpectClose(false, true)\n\t\t\tprocessed := make(chan struct{})\n\t\t\ttracer.EXPECT().ReceivedTransportParameters(params).Do(func(*wire.TransportParameters) { close(processed) })\n\t\t\tparamsChan <- params\n\t\t\tEventually(processed).Should(BeClosed())\n\t\t\tEventually(errChan).Should(Receive(MatchError(&qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\t\tErrorMessage: \"expected original_destination_connection_id to equal deadbeef, is decafbad\",\n\t\t\t})))\n\t\t})\n\t})\n\n\tContext(\"handling potentially injected packets\", func() {\n\t\tvar unpacker *MockUnpacker\n\n\t\tgetPacket := func(extHdr *wire.ExtendedHeader, data []byte) receivedPacket {\n\t\t\tb, err := extHdr.Append(nil, conn.version)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\treturn receivedPacket{\n\t\t\t\tdata:   append(b, data...),\n\t\t\t\tbuffer: getPacketBuffer(),\n\t\t\t}\n\t\t}\n\n\t\t// Convert an already packed raw packet into a receivedPacket\n\t\twrapPacket := func(packet []byte) receivedPacket {\n\t\t\treturn receivedPacket{\n\t\t\t\tdata:   packet,\n\t\t\t\tbuffer: getPacketBuffer(),\n\t\t\t}\n\t\t}\n\n\t\t// Illustrates that attacker may inject an Initial packet with a different\n\t\t// source connection ID, causing endpoint to ignore a subsequent real Initial packets.\n\t\tIt(\"ignores Initial packets with a different source connection ID\", func() {\n\t\t\t// Modified from test \"ignores packets with a different source connection ID\"\n\t\t\tunpacker = NewMockUnpacker(mockCtrl)\n\t\t\tconn.unpacker = unpacker\n\n\t\t\thdr1 := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    1,\n\t\t\t}\n\t\t\thdr2 := &wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t\t\t\t\tLength:           1,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\t\t\tPacketNumber:    2,\n\t\t\t}\n\t\t\tExpect(hdr2.SrcConnectionID).ToNot(Equal(srcConnID))\n\t\t\t// Send one packet, which might change the connection ID.\n\t\t\t// only EXPECT one call to the unpacker\n\t\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any(), gomock.Any(), conn.version).Return(&unpackedPacket{\n\t\t\t\tencryptionLevel: protocol.EncryptionInitial,\n\t\t\t\thdr:             hdr1,\n\t\t\t\tdata:            []byte{0}, // one PADDING frame\n\t\t\t}, nil)\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(getPacket(hdr1, nil))).To(BeTrue())\n\t\t\t// The next packet has to be ignored, since the source connection ID doesn't match.\n\t\t\ttracer.EXPECT().DroppedPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(getPacket(hdr2, nil))).To(BeFalse())\n\t\t})\n\n\t\tIt(\"ignores 0-RTT packets\", func() {\n\t\t\tp := getPacket(&wire.ExtendedHeader{\n\t\t\t\tHeader: wire.Header{\n\t\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\t\tDestConnectionID: srcConnID,\n\t\t\t\t\tLength:           2 + 6,\n\t\t\t\t\tVersion:          conn.version,\n\t\t\t\t},\n\t\t\t\tPacketNumber:    0x42,\n\t\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t\t}, []byte(\"foobar\"))\n\t\t\ttracer.EXPECT().DroppedPacket(logging.PacketType0RTT, p.Size(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(p)).To(BeFalse())\n\t\t})\n\n\t\t// Illustrates that an injected Initial with an ACK frame for an unsent packet causes\n\t\t// the connection to immediately break down\n\t\tIt(\"fails on Initial-level ACK for unsent packet\", func() {\n\t\t\tack := &wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 2, Largest: 2}}}\n\t\t\tinitialPacket := testutils.ComposeInitialPacket(destConnID, srcConnID, conn.version, destConnID, []wire.Frame{ack})\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(wrapPacket(initialPacket))).To(BeFalse())\n\t\t})\n\n\t\t// Illustrates that an injected Initial with a CONNECTION_CLOSE frame causes\n\t\t// the connection to immediately break down\n\t\tIt(\"fails on Initial-level CONNECTION_CLOSE frame\", func() {\n\t\t\tconnCloseFrame := &wire.ConnectionCloseFrame{\n\t\t\t\tIsApplicationError: true,\n\t\t\t\tReasonPhrase:       \"mitm attacker\",\n\t\t\t}\n\t\t\tinitialPacket := testutils.ComposeInitialPacket(destConnID, srcConnID, conn.version, destConnID, []wire.Frame{connCloseFrame})\n\t\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(wrapPacket(initialPacket))).To(BeTrue())\n\t\t})\n\n\t\t// Illustrates that attacker who injects a Retry packet and changes the connection ID\n\t\t// can cause subsequent real Initial packets to be ignored\n\t\tIt(\"ignores Initial packets which use original source id, after accepting a Retry\", func() {\n\t\t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\t\t\tconn.sentPacketHandler = sph\n\t\t\tsph.EXPECT().ReceivedBytes(gomock.Any()).Times(2)\n\t\t\tsph.EXPECT().ResetForRetry()\n\t\t\tnewSrcConnID := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\t\tcryptoSetup.EXPECT().ChangeConnectionID(newSrcConnID)\n\t\t\tpacker.EXPECT().SetToken([]byte(\"foobar\"))\n\n\t\t\ttracer.EXPECT().ReceivedRetry(gomock.Any())\n\t\t\tconn.handlePacketImpl(wrapPacket(testutils.ComposeRetryPacket(newSrcConnID, destConnID, destConnID, []byte(\"foobar\"), conn.version)))\n\t\t\tinitialPacket := testutils.ComposeInitialPacket(conn.connIDManager.Get(), srcConnID, conn.version, conn.connIDManager.Get(), nil)\n\t\t\ttracer.EXPECT().DroppedPacket(gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\tExpect(conn.handlePacketImpl(wrapPacket(initialPacket))).To(BeFalse())\n\t\t})\n\t})\n})\n"], "filenames": ["connection.go", "connection_test.go"], "buggy_code_start_loc": [721, 1894], "buggy_code_end_loc": [1690, 2871], "fixing_code_start_loc": [720, 1893], "fixing_code_end_loc": [1708, 2838], "type": "CWE-476", "message": "quic-go is an implementation of the QUIC protocol in Go. Starting in version 0.37.0 and prior to version 0.37.3, by serializing an ACK frame after the CRYTPO that allows a node to complete the handshake, a remote node could trigger a nil pointer dereference (leading to a panic) when the node attempted to drop the Handshake packet number space. An attacker can bring down a quic-go node with very minimal effort. Completing the QUIC handshake only requires sending and receiving a few packets. Version 0.37.3 contains a patch. Versions before 0.37.0 are not affected.", "other": {"cve": {"id": "CVE-2023-46239", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-31T16:15:09.543", "lastModified": "2023-11-09T00:14:04.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "quic-go is an implementation of the QUIC protocol in Go. Starting in version 0.37.0 and prior to version 0.37.3, by serializing an ACK frame after the CRYTPO that allows a node to complete the handshake, a remote node could trigger a nil pointer dereference (leading to a panic) when the node attempted to drop the Handshake packet number space. An attacker can bring down a quic-go node with very minimal effort. Completing the QUIC handshake only requires sending and receiving a few packets. Version 0.37.3 contains a patch. Versions before 0.37.0 are not affected."}, {"lang": "es", "value": "quic-go es una implementaci\u00f3n del protocolo QUIC en Go. A partir de la versi\u00f3n 0.37.0 y antes de la versi\u00f3n 0.37.3, al serializar una trama ACK despu\u00e9s de CRYTPO que permite que un nodo complete el protocolo de enlace, un nodo remoto podr\u00eda desencadenar una desreferencia de puntero nulo (lo que lleva a p\u00e1nico) cuando el nodo intenta para eliminar el espacio del n\u00famero del paquete Handshake. Un atacante puede derribar un nodo r\u00e1pido con un esfuerzo m\u00ednimo. Completar el protocolo de enlace QUIC solo requiere enviar y recibir algunos paquetes. La versi\u00f3n 0.37.3 contiene un parche. Las versiones anteriores a la 0.37.0 no se ven afectadas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-248"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quic-go_project:quic-go:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.37.0", "versionEndExcluding": "0.37.3", "matchCriteriaId": "A4D3D28F-FF90-4B7E-99E8-64325B9B7D08"}]}]}], "references": [{"url": "https://github.com/quic-go/quic-go/commit/b6a4725b60f1fe04e8f1ddcc3114e290fcea1617", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/quic-go/quic-go/releases/tag/v0.37.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/quic-go/quic-go/security/advisories/GHSA-3q6m-v84f-6p9h", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/quic-go/quic-go/commit/b6a4725b60f1fe04e8f1ddcc3114e290fcea1617"}}