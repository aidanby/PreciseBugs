{"buggy_code": ["<?php\n// Copyright (C) 2010-2021 Combodo SARL\n//\n//   This file is part of iTop.\n//\n//   iTop is free software; you can redistribute it and/or modify\t\n//   it under the terms of the GNU Affero General Public License as published by\n//   the Free Software Foundation, either version 3 of the License, or\n//   (at your option) any later version.\n//\n//   iTop is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU Affero General Public License for more details.\n//\n//   You should have received a copy of the GNU Affero General Public License\n//   along with iTop. If not, see <http://www.gnu.org/licenses/>\n\n\n/**\n * Class WizardHelper\n *\n * @copyright   Copyright (C) 2010-2021 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\nrequire_once(APPROOT.'/application/uiwizard.class.inc.php');\n\nclass WizardHelper\n{\n\tprotected $m_aData;\n\t\n\tpublic function __construct()\n\t{\n\t}\n\t/**\n\t * Constructs the PHP target object from the parameters sent to the web page by the wizard\n\t * @param boolean $bReadUploadedFiles True to also read any uploaded file (for blob/document fields)\n\t * @return object\n\t */\t \t \t \t\n\tpublic function GetTargetObject($bReadUploadedFiles = false)\n\t{\n\t\tif (isset($this->m_aData['m_oCurrentValues']['id']))\n\t\t{\n\t\t\t$oObj = MetaModel::GetObject($this->m_aData['m_sClass'], $this->m_aData['m_oCurrentValues']['id']);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$oObj = MetaModel::NewObject($this->m_aData['m_sClass']);\n\t\t}\n\t\tforeach($this->m_aData['m_oCurrentValues'] as $sAttCode => $value)\n\t\t{\n\t\t\t// Because this is stored in a Javascript array, unused indexes\n\t\t\t// are filled with null values and unused keys (stored as strings) contain $$NULL$$\n\t\t\tif ( ($sAttCode !='id') && ($value !== '$$NULL$$'))\n\t\t\t{\n\t\t\t\t$oAttDef = MetaModel::GetAttributeDef($this->m_aData['m_sClass'], $sAttCode);\n\t\t\t\tif (($oAttDef->IsLinkSet()) && ($value != '') )\n\t\t\t\t{\n\t\t\t\t\t// special handling for lists\n\t\t\t\t\t// assumes this is handled as an array of objects\n\t\t\t\t\t// thus encoded in json like: [ { name:'link1', 'id': 123}, { name:'link2', 'id': 124}...]\n\t\t\t\t\t$aData = json_decode($value, true); // true means decode as a hash array (not an object)\n\t\t\t\t\t// Check what are the meaningful attributes\n\t\t\t\t\t$aFields = $this->GetLinkedWizardStructure($oAttDef);\n\t\t\t\t\t$sLinkedClass = $oAttDef->GetLinkedClass();\n\t\t\t\t\t$aLinkedObjectsArray = array();\n\t\t\t\t\tif (!is_array($aData))\n\t\t\t\t\t{\n\t\t\t\t\t\techo (\"aData: '$aData' (value: '$value')\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tforeach($aData as $aLinkedObject)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oLinkedObj = MetaModel::NewObject($sLinkedClass);\n\t\t\t\t\t\tforeach($aFields as $sLinkedAttCode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( isset($aLinkedObject[$sLinkedAttCode]) && ($aLinkedObject[$sLinkedAttCode] !== null) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$sLinkedAttDef = MetaModel::GetAttributeDef($sLinkedClass, $sLinkedAttCode);\n\t\t\t\t\t\t\t\tif (($sLinkedAttDef->IsExternalKey()) && ($aLinkedObject[$sLinkedAttCode] != '') && ($aLinkedObject[$sLinkedAttCode] > 0) )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// For external keys: load the target object so that external fields\n\t\t\t\t\t\t\t\t\t// get filled too\n\t\t\t\t\t\t\t\t\t$oTargetObj = MetaModel::GetObject($sLinkedAttDef->GetTargetClass(), $aLinkedObject[$sLinkedAttCode]);\n\t\t\t\t\t\t\t\t\t$oLinkedObj->Set($sLinkedAttCode, $oTargetObj);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telseif($sLinkedAttDef instanceof AttributeDateTime)\n                                {\n                                    $sDateClass = get_class($sLinkedAttDef);\n                                    $sDate = $aLinkedObject[$sLinkedAttCode];\n                                    if($sDate !== null && $sDate !== '')\n                                    {\n                                        $oDateTimeFormat = $sDateClass::GetFormat();\n                                        $oDate = $oDateTimeFormat->Parse($sDate);\n                                        if ($sDateClass == \"AttributeDate\")\n                                        {\n                                            $sDate = $oDate->format('Y-m-d');\n                                        }\n                                        else\n                                        {\n                                            $sDate = $oDate->format('Y-m-d H:i:s');\n                                        }\n                                    }\n\n                                    $oLinkedObj->Set($sLinkedAttCode, $sDate);\n                                }\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$oLinkedObj->Set($sLinkedAttCode, $aLinkedObject[$sLinkedAttCode]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$aLinkedObjectsArray[] = $oLinkedObj;\n\t\t\t\t\t}\n\t\t\t\t\t$oSet = DBObjectSet::FromArray($sLinkedClass, $aLinkedObjectsArray);\n\t\t\t\t\t$oObj->Set($sAttCode, $oSet);\n\t\t\t\t}\n\t\t\t\telse if ( $oAttDef->GetEditClass() == 'Document' )\n\t\t\t\t{\n\t\t\t\t\tif ($bReadUploadedFiles)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oDocument = utils::ReadPostedDocument('attr_'.$sAttCode, 'fcontents');\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oDocument);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Create a new empty document, just for displaying the file name\n\t\t\t\t\t\t$oDocument = new ormDocument(null, '', $value);\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oDocument);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( $oAttDef->GetEditClass() == 'Image' )\n\t\t\t\t{\n\t\t\t\t\tif ($bReadUploadedFiles)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oDocument = utils::ReadPostedDocument('attr_'.$sAttCode, 'fcontents');\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oDocument);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Create a new empty document, just for displaying the file name\n\t\t\t\t\t\t$oDocument = new ormDocument(null, '', $value);\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oDocument);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (($oAttDef->IsExternalKey()) && (!empty($value)) && ($value > 0) )\n\t\t\t\t{\n\t\t\t\t\t// For external keys: load the target object so that external fields\n\t\t\t\t\t// get filled too\n\t\t\t\t\t$oTargetObj = MetaModel::GetObject($oAttDef->GetTargetClass(), $value, false);\n\t\t\t\t\tif ($oTargetObj)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oTargetObj);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// May happen for security reasons (portal, see ticket N\u00b01074)\n\t\t\t\t\t\t$oObj->Set($sAttCode, $value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ($oAttDef instanceof AttributeDateTime) // AttributeDate is derived from AttributeDateTime\n\t\t\t\t{\n\t\t\t\t\tif ($value != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oDate = $oAttDef->GetFormat()->Parse($value);\n\t\t\t\t\t\tif ($oDate instanceof DateTime)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$value = $oDate->format($oAttDef->GetInternalFormat());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$value = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$oObj->Set($sAttCode, $value);\n\t\t\t\t}\n\t\t\t\telse if ($oAttDef instanceof AttributeTagSet) // AttributeDate is derived from AttributeDateTime\n\t\t\t\t{\n\t\t\t\t\tif (is_null($value))\n\t\t\t\t\t{\n\t\t\t\t\t\t// happens if field is hidden (see N\u00b01827)\n\t\t\t\t\t\t$value = array();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$value = json_decode($value, true);\n\t\t\t\t\t}\n\t\t\t\t\t$oTagSet = new ormTagSet(get_class($oObj), $sAttCode, $oAttDef->GetMaxItems());\n\t\t\t\t\t$oTagSet->SetValues($value['orig_value']);\n\t\t\t\t\t$oTagSet->ApplyDelta($value);\n\t\t\t\t\t$oObj->Set($sAttCode, $oTagSet);\n\t\t\t\t}\n\t\t\t\telse if ($oAttDef instanceof AttributeSet) // AttributeDate is derived from AttributeDateTime\n\t\t\t\t{\n\t\t\t\t\t$value = json_decode($value, true);\n\t\t\t\t\t$oTagSet = new ormSet(get_class($oObj), $sAttCode, $oAttDef->GetMaxItems());\n\t\t\t\t\t$oTagSet->SetValues($value['orig_value']);\n\t\t\t\t\t$oTagSet->ApplyDelta($value);\n\t\t\t\t\t$oObj->Set($sAttCode, $oTagSet);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$oObj->Set($sAttCode, $value);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\tif (isset($this->m_aData['m_sState']) && !empty($this->m_aData['m_sState']))\n\t\t{\n\t\t\t$oObj->Set(MetaModel::GetStateAttributeCode($this->m_aData['m_sClass']), $this->m_aData['m_sState']);\n\t\t}\n\t\t$oObj->DoComputeValues();\n\t\treturn $oObj;\n\t}\n\t\n\tpublic function GetFieldsForDefaultValue()\n\t{\n\t\treturn $this->m_aData['m_aDefaultValueRequested'];\n\t}\n\t\n\tpublic function SetDefaultValue($sAttCode, $value)\n\t{\n\t\t// Protect against a request for a non existing field\n\t\tif (isset($this->m_aData['m_oFieldsMap'][$sAttCode]))\n\t\t{\n\t\t\t$oAttDef = MetaModel::GetAttributeDef($this->m_aData['m_sClass'], $sAttCode);\n\t\t\tif ($oAttDef->GetEditClass() == 'List')\n\t\t\t{\n\t\t\t\t// special handling for lists\n\t\t\t\t// this as to be handled as an array of objects\n\t\t\t\t// thus encoded in json like: [ { name:'link1', 'id': 123}, { name:'link2', 'id': 124}...]\n\t\t\t\t// NOT YET IMPLEMENTED !!\n\t\t\t\t$oSet = $value;\n\t\t\t\t$aData = array();\n\t\t\t\t$aFields = $this->GetLinkedWizardStructure($oAttDef);\n\t\t\t\twhile($oLinkedObj = $oSet->fetch())\n\t\t\t\t{\n\t\t\t\t\tforeach($aFields as $sLinkedAttCode)\n\t\t\t\t\t{\n\t\t\t\t\t\t$aRow[$sAttCode] = $oLinkedObj->Get($sLinkedAttCode);\n\t\t\t\t\t}\n\t\t\t\t\t$aData[] = $aRow;\n\t\t\t\t}\n\t\t\t\t$this->m_aData['m_oDefaultValue'][$sAttCode] = json_encode($aData);\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Normal handling for all other scalar attributes\n\t\t\t\t$this->m_aData['m_oDefaultValue'][$sAttCode] = $value;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic function GetFieldsForAllowedValues()\n\t{\n\t\treturn $this->m_aData['m_aAllowedValuesRequested'];\n\t}\n\t\n\tpublic function SetAllowedValuesHtml($sAttCode, $sHtml)\n\t{\n\t\t// Protect against a request for a non existing field\n\t\tif (isset($this->m_aData['m_oFieldsMap'][$sAttCode]))\n\t\t{\n\t\t\t$this->m_aData['m_oAllowedValues'][$sAttCode] = $sHtml;\n\t\t}\n\t}\n\t\n\tpublic function ToJSON()\n\t{\n\t\treturn json_encode($this->m_aData);\n\t}\n\t\n\tstatic public function FromJSON($sJSON)\n\t{\n\t\t$oWizHelper = new WizardHelper();\n\t\t$aData = json_decode($sJSON, true); // true means hash array instead of object\n\t\t$oWizHelper->m_aData = $aData;\n\t\treturn $oWizHelper;\n\t}\n\t\n\tprotected function GetLinkedWizardStructure($oAttDef)\n\t{\n\t\t$oWizard = new UIWizard(null, $oAttDef->GetLinkedClass());\n\t\t$aWizardSteps = $oWizard->GetWizardStructure();\n\t\t$aFields = array();\n\t\t$sExtKeyToMeCode = $oAttDef->GetExtKeyToMe();\n\t\t// Retrieve as a flat list, all the attributes that are needed to create\n\t\t// an object of the linked class and put them into a flat array, except\n\t\t// the attribute 'ext_key_to_me' which is a constant in our case\n\t\tforeach($aWizardSteps as $sDummy => $aMainSteps)\n\t\t{\n\t\t\t// 2 entries: 'mandatory' and 'optional'\n\t\t\tforeach($aMainSteps as $aSteps)\n\t\t\t{\n\t\t\t\t// One entry for each step of the wizard\n\t\t\t\tforeach($aSteps as $sAttCode)\n\t\t\t\t{\n\t\t\t\t\tif ($sAttCode != $sExtKeyToMeCode)\n\t\t\t\t\t{\n\t\t\t\t\t\t$aFields[] = $sAttCode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $aFields;\n\t}\n\t\n\tpublic function GetTargetClass()\n\t{\n\t\treturn $this->m_aData['m_sClass'];\n\t}\n\n    public function GetFormPrefix()\n    {\n        return $this->m_aData['m_sFormPrefix'];\n    }\n\n    public function GetInitialState()\n    {\n        return isset($this->m_aData['m_sInitialState']) ? $this->m_aData['m_sInitialState'] : null;\n    }\n\n    public function GetStimulus()\n    {\n        return isset($this->m_aData['m_sStimulus']) ? $this->m_aData['m_sStimulus'] : null;\n    }\n\t\n\tpublic function GetIdForField($sFieldName)\n\t{\n\t\t$sResult = '';\n\t\t// It may happen that the field we'd like to update does not\n\t\t// exist in the form. For example, if the field should be hidden/read-only\n\t\t// in the current state of the object\n\t\tif (isset($this->m_aData['m_oFieldsMap'][$sFieldName]))\n\t\t{\n\t\t\t$sResult = $this->m_aData['m_oFieldsMap'][$sFieldName];\n\t\t}\n\n\t\treturn $sResult;\n\t}\n\n\tpublic function GetReturnNotEditableFields()\n\t{\n\t\treturn $this->m_aData['m_bReturnNotEditableFields'] ?? false;\n\t}\n\n\t/**\n\t * @return string JS code to be executed for fields update\n\t * @since 3.0.0 N\u00b03198\n\t */\n\tpublic function GetJsForUpdateFields()\n\t{\n\t\t$sWizardHelperJsVar = (!is_null($this->m_aData['m_sWizHelperJsVarName'])) ? utils::Sanitize($this->m_aData['m_sWizHelperJsVarName'], utils::ENUM_SANITIZATION_FILTER_PARAMETER) : 'oWizardHelper'.$this->GetFormPrefix();\n\t\t//str_replace(['(', ')', ';'], '', $this->m_aData['m_sWizHelperJsVarName']) : 'oWizardHelper'.$this->GetFormPrefix();\n\t\t$sWizardHelperJson = $this->ToJSON();\n\n\t\treturn <<<JS\n{$sWizardHelperJsVar}.m_oData = {$sWizardHelperJson};\n{$sWizardHelperJsVar}.UpdateFields();\nJS;\n\t}\n\n\tstatic function ParseJsonSet($oMe, $sLinkClass, $sExtKeyToMe, $sJsonSet)\n\t{\n\t\t$aSet = json_decode($sJsonSet, true); // true means hash array instead of object\n\t\t$oSet = CMDBObjectSet::FromScratch($sLinkClass);\n\t\tforeach ($aSet as $aLinkObj)\n\t\t{\n\t\t\t$oLink = MetaModel::NewObject($sLinkClass);\n\t\t\tforeach ($aLinkObj as $sAttCode => $value)\n\t\t\t{\n\t\t\t\t$oAttDef = MetaModel::GetAttributeDef($sLinkClass, $sAttCode);\n\t\t\t\tif (($oAttDef->IsExternalKey()) && ($value != '') && ($value > 0))\n\t\t\t\t{\n\t\t\t\t\t// For external keys: load the target object so that external fields\n\t\t\t\t\t// get filled too\n\t\t\t\t\t$oTargetObj = MetaModel::GetObject($oAttDef->GetTargetClass(), $value);\n\t\t\t\t\t$oLink->Set($sAttCode, $oTargetObj);\n\t\t\t\t}\n\t\t\t\t$oLink->Set($sAttCode, $value);\n\t\t\t}\n\t\t\t$oLink->Set($sExtKeyToMe, $oMe->GetKey());\n\t\t\t$oSet->AddObject($oLink);\n\t\t}\n\t\treturn $oSet;\n\t}\n}\n"], "fixing_code": ["<?php\n// Copyright (C) 2010-2021 Combodo SARL\n//\n//   This file is part of iTop.\n//\n//   iTop is free software; you can redistribute it and/or modify\t\n//   it under the terms of the GNU Affero General Public License as published by\n//   the Free Software Foundation, either version 3 of the License, or\n//   (at your option) any later version.\n//\n//   iTop is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU Affero General Public License for more details.\n//\n//   You should have received a copy of the GNU Affero General Public License\n//   along with iTop. If not, see <http://www.gnu.org/licenses/>\n\n\n/**\n * Class WizardHelper\n *\n * @copyright   Copyright (C) 2010-2021 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\nrequire_once(APPROOT.'/application/uiwizard.class.inc.php');\n\nclass WizardHelper\n{\n\tprotected $m_aData;\n\t\n\tpublic function __construct()\n\t{\n\t}\n\t/**\n\t * Constructs the PHP target object from the parameters sent to the web page by the wizard\n\t * @param boolean $bReadUploadedFiles True to also read any uploaded file (for blob/document fields)\n\t * @return object\n\t */\t \t \t \t\n\tpublic function GetTargetObject($bReadUploadedFiles = false)\n\t{\n\t\tif (isset($this->m_aData['m_oCurrentValues']['id']))\n\t\t{\n\t\t\t$oObj = MetaModel::GetObject($this->m_aData['m_sClass'], $this->m_aData['m_oCurrentValues']['id']);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$oObj = MetaModel::NewObject($this->m_aData['m_sClass']);\n\t\t}\n\t\tforeach($this->m_aData['m_oCurrentValues'] as $sAttCode => $value)\n\t\t{\n\t\t\t// Because this is stored in a Javascript array, unused indexes\n\t\t\t// are filled with null values and unused keys (stored as strings) contain $$NULL$$\n\t\t\tif ( ($sAttCode !='id') && ($value !== '$$NULL$$'))\n\t\t\t{\n\t\t\t\t$oAttDef = MetaModel::GetAttributeDef($this->m_aData['m_sClass'], $sAttCode);\n\t\t\t\tif (($oAttDef->IsLinkSet()) && ($value != '') )\n\t\t\t\t{\n\t\t\t\t\t// special handling for lists\n\t\t\t\t\t// assumes this is handled as an array of objects\n\t\t\t\t\t// thus encoded in json like: [ { name:'link1', 'id': 123}, { name:'link2', 'id': 124}...]\n\t\t\t\t\t$aData = json_decode($value, true); // true means decode as a hash array (not an object)\n\t\t\t\t\t// Check what are the meaningful attributes\n\t\t\t\t\t$aFields = $this->GetLinkedWizardStructure($oAttDef);\n\t\t\t\t\t$sLinkedClass = $oAttDef->GetLinkedClass();\n\t\t\t\t\t$aLinkedObjectsArray = array();\n\t\t\t\t\tif (!is_array($aData))\n\t\t\t\t\t{\n\t\t\t\t\t\techo (\"aData: '$aData' (value: '$value')\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tforeach($aData as $aLinkedObject)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oLinkedObj = MetaModel::NewObject($sLinkedClass);\n\t\t\t\t\t\tforeach($aFields as $sLinkedAttCode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( isset($aLinkedObject[$sLinkedAttCode]) && ($aLinkedObject[$sLinkedAttCode] !== null) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$sLinkedAttDef = MetaModel::GetAttributeDef($sLinkedClass, $sLinkedAttCode);\n\t\t\t\t\t\t\t\tif (($sLinkedAttDef->IsExternalKey()) && ($aLinkedObject[$sLinkedAttCode] != '') && ($aLinkedObject[$sLinkedAttCode] > 0) )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// For external keys: load the target object so that external fields\n\t\t\t\t\t\t\t\t\t// get filled too\n\t\t\t\t\t\t\t\t\t$oTargetObj = MetaModel::GetObject($sLinkedAttDef->GetTargetClass(), $aLinkedObject[$sLinkedAttCode]);\n\t\t\t\t\t\t\t\t\t$oLinkedObj->Set($sLinkedAttCode, $oTargetObj);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telseif($sLinkedAttDef instanceof AttributeDateTime)\n                                {\n                                    $sDateClass = get_class($sLinkedAttDef);\n                                    $sDate = $aLinkedObject[$sLinkedAttCode];\n                                    if($sDate !== null && $sDate !== '')\n                                    {\n                                        $oDateTimeFormat = $sDateClass::GetFormat();\n                                        $oDate = $oDateTimeFormat->Parse($sDate);\n                                        if ($sDateClass == \"AttributeDate\")\n                                        {\n                                            $sDate = $oDate->format('Y-m-d');\n                                        }\n                                        else\n                                        {\n                                            $sDate = $oDate->format('Y-m-d H:i:s');\n                                        }\n                                    }\n\n                                    $oLinkedObj->Set($sLinkedAttCode, $sDate);\n                                }\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$oLinkedObj->Set($sLinkedAttCode, $aLinkedObject[$sLinkedAttCode]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$aLinkedObjectsArray[] = $oLinkedObj;\n\t\t\t\t\t}\n\t\t\t\t\t$oSet = DBObjectSet::FromArray($sLinkedClass, $aLinkedObjectsArray);\n\t\t\t\t\t$oObj->Set($sAttCode, $oSet);\n\t\t\t\t}\n\t\t\t\telse if ( $oAttDef->GetEditClass() == 'Document' )\n\t\t\t\t{\n\t\t\t\t\tif ($bReadUploadedFiles)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oDocument = utils::ReadPostedDocument('attr_'.$sAttCode, 'fcontents');\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oDocument);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Create a new empty document, just for displaying the file name\n\t\t\t\t\t\t$oDocument = new ormDocument(null, '', $value);\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oDocument);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( $oAttDef->GetEditClass() == 'Image' )\n\t\t\t\t{\n\t\t\t\t\tif ($bReadUploadedFiles)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oDocument = utils::ReadPostedDocument('attr_'.$sAttCode, 'fcontents');\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oDocument);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Create a new empty document, just for displaying the file name\n\t\t\t\t\t\t$oDocument = new ormDocument(null, '', $value);\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oDocument);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (($oAttDef->IsExternalKey()) && (!empty($value)) && ($value > 0) )\n\t\t\t\t{\n\t\t\t\t\t// For external keys: load the target object so that external fields\n\t\t\t\t\t// get filled too\n\t\t\t\t\t$oTargetObj = MetaModel::GetObject($oAttDef->GetTargetClass(), $value, false);\n\t\t\t\t\tif ($oTargetObj)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oObj->Set($sAttCode, $oTargetObj);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// May happen for security reasons (portal, see ticket N\u00b01074)\n\t\t\t\t\t\t$oObj->Set($sAttCode, $value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ($oAttDef instanceof AttributeDateTime) // AttributeDate is derived from AttributeDateTime\n\t\t\t\t{\n\t\t\t\t\tif ($value != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oDate = $oAttDef->GetFormat()->Parse($value);\n\t\t\t\t\t\tif ($oDate instanceof DateTime)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$value = $oDate->format($oAttDef->GetInternalFormat());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$value = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$oObj->Set($sAttCode, $value);\n\t\t\t\t}\n\t\t\t\telse if ($oAttDef instanceof AttributeTagSet) // AttributeDate is derived from AttributeDateTime\n\t\t\t\t{\n\t\t\t\t\tif (is_null($value))\n\t\t\t\t\t{\n\t\t\t\t\t\t// happens if field is hidden (see N\u00b01827)\n\t\t\t\t\t\t$value = array();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$value = json_decode($value, true);\n\t\t\t\t\t}\n\t\t\t\t\t$oTagSet = new ormTagSet(get_class($oObj), $sAttCode, $oAttDef->GetMaxItems());\n\t\t\t\t\t$oTagSet->SetValues($value['orig_value']);\n\t\t\t\t\t$oTagSet->ApplyDelta($value);\n\t\t\t\t\t$oObj->Set($sAttCode, $oTagSet);\n\t\t\t\t}\n\t\t\t\telse if ($oAttDef instanceof AttributeSet) // AttributeDate is derived from AttributeDateTime\n\t\t\t\t{\n\t\t\t\t\t$value = json_decode($value, true);\n\t\t\t\t\t$oTagSet = new ormSet(get_class($oObj), $sAttCode, $oAttDef->GetMaxItems());\n\t\t\t\t\t$oTagSet->SetValues($value['orig_value']);\n\t\t\t\t\t$oTagSet->ApplyDelta($value);\n\t\t\t\t\t$oObj->Set($sAttCode, $oTagSet);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$oObj->Set($sAttCode, $value);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\tif (isset($this->m_aData['m_sState']) && !empty($this->m_aData['m_sState']))\n\t\t{\n\t\t\t$oObj->Set(MetaModel::GetStateAttributeCode($this->m_aData['m_sClass']), $this->m_aData['m_sState']);\n\t\t}\n\t\t$oObj->DoComputeValues();\n\t\treturn $oObj;\n\t}\n\t\n\tpublic function GetFieldsForDefaultValue()\n\t{\n\t\treturn $this->m_aData['m_aDefaultValueRequested'];\n\t}\n\t\n\tpublic function SetDefaultValue($sAttCode, $value)\n\t{\n\t\t// Protect against a request for a non existing field\n\t\tif (isset($this->m_aData['m_oFieldsMap'][$sAttCode]))\n\t\t{\n\t\t\t$oAttDef = MetaModel::GetAttributeDef($this->m_aData['m_sClass'], $sAttCode);\n\t\t\tif ($oAttDef->GetEditClass() == 'List')\n\t\t\t{\n\t\t\t\t// special handling for lists\n\t\t\t\t// this as to be handled as an array of objects\n\t\t\t\t// thus encoded in json like: [ { name:'link1', 'id': 123}, { name:'link2', 'id': 124}...]\n\t\t\t\t// NOT YET IMPLEMENTED !!\n\t\t\t\t$oSet = $value;\n\t\t\t\t$aData = array();\n\t\t\t\t$aFields = $this->GetLinkedWizardStructure($oAttDef);\n\t\t\t\twhile($oLinkedObj = $oSet->fetch())\n\t\t\t\t{\n\t\t\t\t\tforeach($aFields as $sLinkedAttCode)\n\t\t\t\t\t{\n\t\t\t\t\t\t$aRow[$sAttCode] = $oLinkedObj->Get($sLinkedAttCode);\n\t\t\t\t\t}\n\t\t\t\t\t$aData[] = $aRow;\n\t\t\t\t}\n\t\t\t\t$this->m_aData['m_oDefaultValue'][$sAttCode] = json_encode($aData);\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Normal handling for all other scalar attributes\n\t\t\t\t$this->m_aData['m_oDefaultValue'][$sAttCode] = $value;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic function GetFieldsForAllowedValues()\n\t{\n\t\treturn $this->m_aData['m_aAllowedValuesRequested'];\n\t}\n\t\n\tpublic function SetAllowedValuesHtml($sAttCode, $sHtml)\n\t{\n\t\t// Protect against a request for a non existing field\n\t\tif (isset($this->m_aData['m_oFieldsMap'][$sAttCode]))\n\t\t{\n\t\t\t$this->m_aData['m_oAllowedValues'][$sAttCode] = $sHtml;\n\t\t}\n\t}\n\t\n\tpublic function ToJSON()\n\t{\n\t\treturn json_encode($this->m_aData);\n\t}\n\t\n\tstatic public function FromJSON($sJSON)\n\t{\n\t\t$oWizHelper = new WizardHelper();\n\t\t$aData = json_decode($sJSON, true); // true means hash array instead of object\n\t\t$oWizHelper->m_aData = $aData;\n\t\treturn $oWizHelper;\n\t}\n\t\n\tprotected function GetLinkedWizardStructure($oAttDef)\n\t{\n\t\t$oWizard = new UIWizard(null, $oAttDef->GetLinkedClass());\n\t\t$aWizardSteps = $oWizard->GetWizardStructure();\n\t\t$aFields = array();\n\t\t$sExtKeyToMeCode = $oAttDef->GetExtKeyToMe();\n\t\t// Retrieve as a flat list, all the attributes that are needed to create\n\t\t// an object of the linked class and put them into a flat array, except\n\t\t// the attribute 'ext_key_to_me' which is a constant in our case\n\t\tforeach($aWizardSteps as $sDummy => $aMainSteps)\n\t\t{\n\t\t\t// 2 entries: 'mandatory' and 'optional'\n\t\t\tforeach($aMainSteps as $aSteps)\n\t\t\t{\n\t\t\t\t// One entry for each step of the wizard\n\t\t\t\tforeach($aSteps as $sAttCode)\n\t\t\t\t{\n\t\t\t\t\tif ($sAttCode != $sExtKeyToMeCode)\n\t\t\t\t\t{\n\t\t\t\t\t\t$aFields[] = $sAttCode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $aFields;\n\t}\n\t\n\tpublic function GetTargetClass()\n\t{\n\t\treturn $this->m_aData['m_sClass'];\n\t}\n\n    public function GetFormPrefix()\n    {\n        return $this->m_aData['m_sFormPrefix'];\n    }\n\n    public function GetInitialState()\n    {\n        return isset($this->m_aData['m_sInitialState']) ? $this->m_aData['m_sInitialState'] : null;\n    }\n\n    public function GetStimulus()\n    {\n        return isset($this->m_aData['m_sStimulus']) ? $this->m_aData['m_sStimulus'] : null;\n    }\n\t\n\tpublic function GetIdForField($sFieldName)\n\t{\n\t\t$sResult = '';\n\t\t// It may happen that the field we'd like to update does not\n\t\t// exist in the form. For example, if the field should be hidden/read-only\n\t\t// in the current state of the object\n\t\tif (isset($this->m_aData['m_oFieldsMap'][$sFieldName]))\n\t\t{\n\t\t\t$sResult = $this->m_aData['m_oFieldsMap'][$sFieldName];\n\t\t}\n\n\t\treturn $sResult;\n\t}\n\n\tpublic function GetReturnNotEditableFields()\n\t{\n\t\treturn $this->m_aData['m_bReturnNotEditableFields'] ?? false;\n\t}\n\n\t/**\n\t * @return string JS code to be executed for fields update\n\t * @since 3.0.0 N\u00b03198\n\t */\n\tpublic function GetJsForUpdateFields()\n\t{\n\t\t$sWizardHelperJsVar = (!is_null($this->m_aData['m_sWizHelperJsVarName'])) ? utils::Sanitize($this->m_aData['m_sWizHelperJsVarName'], '', utils::ENUM_SANITIZATION_FILTER_PARAMETER) : 'oWizardHelper'.$this->GetFormPrefix();\n\t\t$sWizardHelperJson = $this->ToJSON();\n\n\t\treturn <<<JS\n{$sWizardHelperJsVar}.m_oData = {$sWizardHelperJson};\n{$sWizardHelperJsVar}.UpdateFields();\nJS;\n\t}\n\n\tstatic function ParseJsonSet($oMe, $sLinkClass, $sExtKeyToMe, $sJsonSet)\n\t{\n\t\t$aSet = json_decode($sJsonSet, true); // true means hash array instead of object\n\t\t$oSet = CMDBObjectSet::FromScratch($sLinkClass);\n\t\tforeach ($aSet as $aLinkObj)\n\t\t{\n\t\t\t$oLink = MetaModel::NewObject($sLinkClass);\n\t\t\tforeach ($aLinkObj as $sAttCode => $value)\n\t\t\t{\n\t\t\t\t$oAttDef = MetaModel::GetAttributeDef($sLinkClass, $sAttCode);\n\t\t\t\tif (($oAttDef->IsExternalKey()) && ($value != '') && ($value > 0))\n\t\t\t\t{\n\t\t\t\t\t// For external keys: load the target object so that external fields\n\t\t\t\t\t// get filled too\n\t\t\t\t\t$oTargetObj = MetaModel::GetObject($oAttDef->GetTargetClass(), $value);\n\t\t\t\t\t$oLink->Set($sAttCode, $oTargetObj);\n\t\t\t\t}\n\t\t\t\t$oLink->Set($sAttCode, $value);\n\t\t\t}\n\t\t\t$oLink->Set($sExtKeyToMe, $oMe->GetKey());\n\t\t\t$oSet->AddObject($oLink);\n\t\t}\n\t\treturn $oSet;\n\t}\n}\n"], "filenames": ["application/wizardhelper.class.inc.php"], "buggy_code_start_loc": [353], "buggy_code_end_loc": [355], "fixing_code_start_loc": [353], "fixing_code_end_loc": [354], "type": "CWE-79", "message": "Combodo iTop is a web based IT Service Management tool. In 3.0.0 beta releases prior to beta6 the `ajax.render.php?operation=wizard_helper` page did not properly escape the user supplied parameters, allowing for a cross site scripting attack vector. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2021-41162", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-21T17:15:07.757", "lastModified": "2022-04-28T19:02:45.663", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Combodo iTop is a web based IT Service Management tool. In 3.0.0 beta releases prior to beta6 the `ajax.render.php?operation=wizard_helper` page did not properly escape the user supplied parameters, allowing for a cross site scripting attack vector. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "Combodo iTop es una herramienta de administraci\u00f3n de servicios de TI basada en la web. En versiones beta 3.0.0 anteriores a beta6, la p\u00e1gina \"ajax.render.php?operation=wizard_helper\" no escapaba correctamente de los par\u00e1metros suministrados por el usuario, permitiendo un vector de ataque de tipo cross site scripting. Es recomendado a usuarios actualizar. No se presentan medidas de mitigaci\u00f3n conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.7.6", "matchCriteriaId": "45BBB537-3E87-4B8F-ABB1-631EA7E76797"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta:*:*:*:*:*:*", "matchCriteriaId": "DD7E6A6A-9B1D-4BA7-9A58-ACEE1ABC46EB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "E0F94E71-E468-4765-9A44-FCD9121DC414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "AF68C176-A8C3-4C88-A344-74CB0E682987"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "997A26DD-11A4-4D9F-8F6C-845068AE605C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "06061D47-3252-4ED4-9423-600027D39551"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "A5DFEEA5-6FB7-4583-A13C-B2EE74502B81"}]}]}], "references": [{"url": "https://github.com/Combodo/iTop/commit/83125d9ae16cfb2527b9d0ab0805a68b863244a0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Combodo/iTop/security/advisories/GHSA-w5jw-hfvp-gx95", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Combodo/iTop/commit/83125d9ae16cfb2527b9d0ab0805a68b863244a0"}}