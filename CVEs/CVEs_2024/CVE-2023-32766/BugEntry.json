{"buggy_code": ["/**\n * Copyright (c) 2021 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport {\n    Emitter,\n    GitpodClient,\n    GitpodServer,\n    GitpodServerPath,\n    GitpodService,\n    GitpodServiceImpl,\n    User,\n    WorkspaceInfo,\n} from \"@gitpod/gitpod-protocol\";\nimport { WebSocketConnectionProvider } from \"@gitpod/gitpod-protocol/lib/messaging/browser/connection\";\nimport { GitpodHostUrl } from \"@gitpod/gitpod-protocol/lib/util/gitpod-host-url\";\nimport { log } from \"@gitpod/gitpod-protocol/lib/util/logging\";\nimport { IDEFrontendDashboardService } from \"@gitpod/gitpod-protocol/lib/frontend-dashboard-service\";\nimport { RemoteTrackMessage } from \"@gitpod/gitpod-protocol/lib/analytics\";\n\nexport const gitpodHostUrl = new GitpodHostUrl(window.location.toString());\n\nfunction createGitpodService<C extends GitpodClient, S extends GitpodServer>() {\n    let host = gitpodHostUrl.asWebsocket().with({ pathname: GitpodServerPath }).withApi();\n\n    const connectionProvider = new WebSocketConnectionProvider();\n    let numberOfErrors = 0;\n    let onReconnect = () => {};\n    const proxy = connectionProvider.createProxy<S>(host.toString(), undefined, {\n        onerror: (event: any) => {\n            log.error(event);\n            // don't show alert if dashboard is inside iframe (workspace origin)\n            if (window.top !== window.self && process.env.NODE_ENV === \"production\") {\n                return;\n            }\n            if (numberOfErrors++ === 5) {\n                alert(\n                    \"We are having trouble connecting to the server.\\nEither you are offline or websocket connections are blocked.\",\n                );\n            }\n        },\n        onListening: (socket) => {\n            onReconnect = () => socket.reconnect();\n        },\n    });\n\n    return new GitpodServiceImpl<C, S>(proxy, { onReconnect });\n}\n\nexport function getGitpodService(): GitpodService {\n    const w = window as any;\n    const _gp = w._gp || (w._gp = {});\n    if (window.location.search.includes(\"service=mock\")) {\n        const service = _gp.gitpodService || (_gp.gitpodService = require(\"./service-mock\").gitpodServiceMock);\n        return service;\n    }\n    const service = _gp.gitpodService || (_gp.gitpodService = createGitpodService());\n    return service;\n}\n\nlet ideFrontendService: IDEFrontendService | undefined;\nexport function getIDEFrontendService(workspaceID: string, sessionId: string, service: GitpodService) {\n    if (!ideFrontendService) {\n        ideFrontendService = new IDEFrontendService(workspaceID, sessionId, service, window.parent);\n    }\n    return ideFrontendService;\n}\n\nexport class IDEFrontendService implements IDEFrontendDashboardService.IServer {\n    private instanceID: string | undefined;\n    private user: User | undefined;\n\n    private latestInfo?: IDEFrontendDashboardService.Info;\n\n    private readonly onDidChangeEmitter = new Emitter<IDEFrontendDashboardService.SetStateData>();\n    readonly onSetState = this.onDidChangeEmitter.event;\n\n    constructor(\n        private workspaceID: string,\n        private sessionId: string,\n        private service: GitpodService,\n        private clientWindow: Window,\n    ) {\n        this.processServerInfo();\n        window.addEventListener(\"message\", (event: MessageEvent) => {\n            if (IDEFrontendDashboardService.isTrackEventData(event.data)) {\n                this.trackEvent(event.data.msg);\n            }\n            if (IDEFrontendDashboardService.isHeartbeatEventData(event.data)) {\n                this.activeHeartbeat();\n            }\n            if (IDEFrontendDashboardService.isSetStateEventData(event.data)) {\n                this.onDidChangeEmitter.fire(event.data.state);\n            }\n            if (IDEFrontendDashboardService.isOpenDesktopIDE(event.data)) {\n                this.openDesktopIDE(event.data.url);\n            }\n        });\n        window.addEventListener(\"unload\", () => {\n            if (!this.instanceID) {\n                return;\n            }\n            // send last heartbeat (wasClosed: true)\n            const data = { sessionId: this.sessionId };\n            const blob = new Blob([JSON.stringify(data)], { type: \"application/json\" });\n            const gitpodHostUrl = new GitpodHostUrl(new URL(window.location.toString()));\n            const url = gitpodHostUrl.withApi({ pathname: `/auth/workspacePageClose/${this.instanceID}` }).toString();\n            navigator.sendBeacon(url, blob);\n        });\n    }\n\n    private async processServerInfo() {\n        const [user, listener] = await Promise.all([\n            this.service.server.getLoggedInUser(),\n            this.service.listenToInstance(this.workspaceID),\n        ]);\n        this.user = user;\n        const reconcile = () => {\n            const info = this.parseInfo(listener.info);\n            this.latestInfo = info;\n            const oldInstanceID = this.instanceID;\n            this.instanceID = info.instanceId;\n            if (info.instanceId && oldInstanceID !== info.instanceId) {\n                this.auth();\n            }\n            this.sendInfoUpdate(this.latestInfo);\n        };\n        reconcile();\n        listener.onDidChange(reconcile);\n    }\n\n    private parseInfo(workspace: WorkspaceInfo): IDEFrontendDashboardService.Info {\n        return {\n            loggedUserId: this.user!.id,\n            workspaceID: this.workspaceID,\n            instanceId: workspace.latestInstance?.id,\n            ideUrl: workspace.latestInstance?.ideUrl,\n            statusPhase: workspace.latestInstance?.status.phase,\n            workspaceDescription: workspace.workspace.description,\n            workspaceType: workspace.workspace.type,\n        };\n    }\n\n    // implements\n\n    private async auth() {\n        if (!this.instanceID) {\n            return;\n        }\n        const url = gitpodHostUrl.asWorkspaceAuth(this.instanceID).toString();\n        await fetch(url, {\n            credentials: \"include\",\n        });\n    }\n\n    private trackEvent(msg: RemoteTrackMessage): void {\n        msg.properties = {\n            ...msg.properties,\n            sessionId: this.sessionId,\n            instanceId: this.latestInfo?.instanceId,\n            workspaceId: this.workspaceID,\n            type: this.latestInfo?.workspaceType,\n        };\n        this.service.server.trackEvent(msg);\n    }\n\n    private activeHeartbeat(): void {\n        if (this.instanceID) {\n            this.service.server.sendHeartBeat({ instanceId: this.instanceID });\n        }\n    }\n\n    openDesktopIDE(url: string): void {\n        let redirect = false;\n        try {\n            const desktopLink = new URL(url);\n            redirect = desktopLink.protocol !== \"http:\" && desktopLink.protocol !== \"https:\";\n        } catch (e) {\n            console.error(\"invalid desktop link:\", e);\n        }\n        // redirect only if points to desktop application\n        // don't navigate browser to another page\n        if (redirect) {\n            window.location.href = url;\n        } else {\n            window.open(url, \"_blank\", \"noopener\");\n        }\n    }\n\n    sendInfoUpdate(info: IDEFrontendDashboardService.Info): void {\n        this.clientWindow.postMessage(\n            {\n                version: 1,\n                type: \"ide-info-update\",\n                info,\n            } as IDEFrontendDashboardService.InfoUpdateEventData,\n            \"*\",\n        );\n    }\n\n    relocate(url: string): void {\n        this.clientWindow.postMessage(\n            { type: \"ide-relocate\", url } as IDEFrontendDashboardService.RelocateEventData,\n            \"*\",\n        );\n    }\n\n    openBrowserIDE(): void {\n        this.clientWindow.postMessage({ type: \"ide-open-browser\" } as IDEFrontendDashboardService.OpenBrowserIDE, \"*\");\n    }\n}\n"], "fixing_code": ["/**\n * Copyright (c) 2021 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport {\n    Emitter,\n    GitpodClient,\n    GitpodServer,\n    GitpodServerPath,\n    GitpodService,\n    GitpodServiceImpl,\n    User,\n    WorkspaceInfo,\n} from \"@gitpod/gitpod-protocol\";\nimport { WebSocketConnectionProvider } from \"@gitpod/gitpod-protocol/lib/messaging/browser/connection\";\nimport { GitpodHostUrl } from \"@gitpod/gitpod-protocol/lib/util/gitpod-host-url\";\nimport { log } from \"@gitpod/gitpod-protocol/lib/util/logging\";\nimport { IDEFrontendDashboardService } from \"@gitpod/gitpod-protocol/lib/frontend-dashboard-service\";\nimport { RemoteTrackMessage } from \"@gitpod/gitpod-protocol/lib/analytics\";\n\nexport const gitpodHostUrl = new GitpodHostUrl(window.location.toString());\n\nfunction createGitpodService<C extends GitpodClient, S extends GitpodServer>() {\n    let host = gitpodHostUrl.asWebsocket().with({ pathname: GitpodServerPath }).withApi();\n\n    const connectionProvider = new WebSocketConnectionProvider();\n    let numberOfErrors = 0;\n    let onReconnect = () => {};\n    const proxy = connectionProvider.createProxy<S>(host.toString(), undefined, {\n        onerror: (event: any) => {\n            log.error(event);\n            // don't show alert if dashboard is inside iframe (workspace origin)\n            if (window.top !== window.self && process.env.NODE_ENV === \"production\") {\n                return;\n            }\n            if (numberOfErrors++ === 5) {\n                alert(\n                    \"We are having trouble connecting to the server.\\nEither you are offline or websocket connections are blocked.\",\n                );\n            }\n        },\n        onListening: (socket) => {\n            onReconnect = () => socket.reconnect();\n        },\n    });\n\n    return new GitpodServiceImpl<C, S>(proxy, { onReconnect });\n}\n\nexport function getGitpodService(): GitpodService {\n    const w = window as any;\n    const _gp = w._gp || (w._gp = {});\n    if (window.location.search.includes(\"service=mock\")) {\n        const service = _gp.gitpodService || (_gp.gitpodService = require(\"./service-mock\").gitpodServiceMock);\n        return service;\n    }\n    const service = _gp.gitpodService || (_gp.gitpodService = createGitpodService());\n    return service;\n}\n\nlet ideFrontendService: IDEFrontendService | undefined;\nexport function getIDEFrontendService(workspaceID: string, sessionId: string, service: GitpodService) {\n    if (!ideFrontendService) {\n        ideFrontendService = new IDEFrontendService(workspaceID, sessionId, service, window.parent);\n    }\n    return ideFrontendService;\n}\n\nexport class IDEFrontendService implements IDEFrontendDashboardService.IServer {\n    private instanceID: string | undefined;\n    private user: User | undefined;\n\n    private latestInfo?: IDEFrontendDashboardService.Info;\n\n    private readonly onDidChangeEmitter = new Emitter<IDEFrontendDashboardService.SetStateData>();\n    readonly onSetState = this.onDidChangeEmitter.event;\n\n    constructor(\n        private workspaceID: string,\n        private sessionId: string,\n        private service: GitpodService,\n        private clientWindow: Window,\n    ) {\n        this.processServerInfo();\n        window.addEventListener(\"message\", (event: MessageEvent) => {\n            if (IDEFrontendDashboardService.isTrackEventData(event.data)) {\n                this.trackEvent(event.data.msg);\n            }\n            if (IDEFrontendDashboardService.isHeartbeatEventData(event.data)) {\n                this.activeHeartbeat();\n            }\n            if (IDEFrontendDashboardService.isSetStateEventData(event.data)) {\n                this.onDidChangeEmitter.fire(event.data.state);\n            }\n            if (IDEFrontendDashboardService.isOpenDesktopIDE(event.data)) {\n                this.openDesktopIDE(event.data.url);\n            }\n        });\n        window.addEventListener(\"unload\", () => {\n            if (!this.instanceID) {\n                return;\n            }\n            // send last heartbeat (wasClosed: true)\n            const data = { sessionId: this.sessionId };\n            const blob = new Blob([JSON.stringify(data)], { type: \"application/json\" });\n            const gitpodHostUrl = new GitpodHostUrl(new URL(window.location.toString()));\n            const url = gitpodHostUrl.withApi({ pathname: `/auth/workspacePageClose/${this.instanceID}` }).toString();\n            navigator.sendBeacon(url, blob);\n        });\n    }\n\n    private async processServerInfo() {\n        const [user, listener] = await Promise.all([\n            this.service.server.getLoggedInUser(),\n            this.service.listenToInstance(this.workspaceID),\n        ]);\n        this.user = user;\n        const reconcile = () => {\n            const info = this.parseInfo(listener.info);\n            this.latestInfo = info;\n            const oldInstanceID = this.instanceID;\n            this.instanceID = info.instanceId;\n            if (info.instanceId && oldInstanceID !== info.instanceId) {\n                this.auth();\n            }\n            this.sendInfoUpdate(this.latestInfo);\n        };\n        reconcile();\n        listener.onDidChange(reconcile);\n    }\n\n    private parseInfo(workspace: WorkspaceInfo): IDEFrontendDashboardService.Info {\n        return {\n            loggedUserId: this.user!.id,\n            workspaceID: this.workspaceID,\n            instanceId: workspace.latestInstance?.id,\n            ideUrl: workspace.latestInstance?.ideUrl,\n            statusPhase: workspace.latestInstance?.status.phase,\n            workspaceDescription: workspace.workspace.description,\n            workspaceType: workspace.workspace.type,\n        };\n    }\n\n    // implements\n\n    private async auth() {\n        if (!this.instanceID) {\n            return;\n        }\n        const url = gitpodHostUrl.asWorkspaceAuth(this.instanceID).toString();\n        await fetch(url, {\n            credentials: \"include\",\n        });\n    }\n\n    private trackEvent(msg: RemoteTrackMessage): void {\n        msg.properties = {\n            ...msg.properties,\n            sessionId: this.sessionId,\n            instanceId: this.latestInfo?.instanceId,\n            workspaceId: this.workspaceID,\n            type: this.latestInfo?.workspaceType,\n        };\n        this.service.server.trackEvent(msg);\n    }\n\n    private activeHeartbeat(): void {\n        if (this.instanceID) {\n            this.service.server.sendHeartBeat({ instanceId: this.instanceID });\n        }\n    }\n\n    openDesktopIDE(url: string): void {\n        let redirect = false;\n        try {\n            const desktopLink = new URL(url);\n            // allow to redirect only for whitelisted trusted protocols\n            // IDE-69\n            const trustedProtocols = [\"vscode:\", \"vscode-insiders:\", \"jetbrains-gateway:\"];\n            redirect = trustedProtocols.includes(desktopLink.protocol);\n        } catch (e) {\n            console.error(\"invalid desktop link:\", e);\n        }\n        // redirect only if points to desktop application\n        // don't navigate browser to another page\n        if (redirect) {\n            window.location.href = url;\n        } else {\n            window.open(url, \"_blank\", \"noopener\");\n        }\n    }\n\n    sendInfoUpdate(info: IDEFrontendDashboardService.Info): void {\n        this.clientWindow.postMessage(\n            {\n                version: 1,\n                type: \"ide-info-update\",\n                info,\n            } as IDEFrontendDashboardService.InfoUpdateEventData,\n            \"*\",\n        );\n    }\n\n    relocate(url: string): void {\n        this.clientWindow.postMessage(\n            { type: \"ide-relocate\", url } as IDEFrontendDashboardService.RelocateEventData,\n            \"*\",\n        );\n    }\n\n    openBrowserIDE(): void {\n        this.clientWindow.postMessage({ type: \"ide-open-browser\" } as IDEFrontendDashboardService.OpenBrowserIDE, \"*\");\n    }\n}\n"], "filenames": ["components/dashboard/src/service/service.tsx"], "buggy_code_start_loc": [179], "buggy_code_end_loc": [180], "fixing_code_start_loc": [179], "fixing_code_end_loc": [183], "type": "CWE-79", "message": "Gitpod before 2022.11.3 allows XSS because redirection can occur for some protocols outside of the trusted set of three (vscode: vscode-insiders: jetbrains-gateway:).", "other": {"cve": {"id": "CVE-2023-32766", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-05T15:15:09.143", "lastModified": "2023-06-09T22:42:16.930", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Gitpod before 2022.11.3 allows XSS because redirection can occur for some protocols outside of the trusted set of three (vscode: vscode-insiders: jetbrains-gateway:)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitpod:gitpod:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022.11.3", "matchCriteriaId": "862828C1-EFDB-4680-A3BA-54F828B08C8A"}]}]}], "references": [{"url": "https://app.safebase.io/portal/71ccd717-aa2d-4a1e-942e-c768d37e9e0c/preview?product=default&tcuUid=1d505bda-9a38-4ca5-8724-052e6337f34d", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/gitpod-io/gitpod/commit/6771283c3406586e352337675b79ff2ca50f191b", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/gitpod-io/gitpod/compare/release-2022.11.2...2022.11.3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/gitpod-io/gitpod/pull/17559", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/gitpod-io/gitpod/releases/tag/2022.11.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.gitpod.io", "source": "cve@mitre.org", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/gitpod-io/gitpod/commit/6771283c3406586e352337675b79ff2ca50f191b"}}