{"buggy_code": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing System.Web;\nusing API.Constants;\nusing API.Data;\nusing API.Data.Repositories;\nusing API.DTOs;\nusing API.DTOs.Account;\nusing API.DTOs.Email;\nusing API.Entities;\nusing API.Entities.Enums;\nusing API.Errors;\nusing API.Extensions;\nusing API.Services;\nusing API.SignalR;\nusing AutoMapper;\nusing Kavita.Common;\nusing Kavita.Common.EnvironmentInfo;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nnamespace API.Controllers;\n\n/// <summary>\n/// All Account matters\n/// </summary>\npublic class AccountController : BaseApiController\n{\n    private readonly UserManager<AppUser> _userManager;\n    private readonly SignInManager<AppUser> _signInManager;\n    private readonly ITokenService _tokenService;\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly ILogger<AccountController> _logger;\n    private readonly IMapper _mapper;\n    private readonly IAccountService _accountService;\n    private readonly IEmailService _emailService;\n    private readonly IHostEnvironment _environment;\n    private readonly IEventHub _eventHub;\n\n    /// <inheritdoc />\n    public AccountController(UserManager<AppUser> userManager,\n        SignInManager<AppUser> signInManager,\n        ITokenService tokenService, IUnitOfWork unitOfWork,\n        ILogger<AccountController> logger,\n        IMapper mapper, IAccountService accountService,\n        IEmailService emailService, IHostEnvironment environment,\n        IEventHub eventHub)\n    {\n        _userManager = userManager;\n        _signInManager = signInManager;\n        _tokenService = tokenService;\n        _unitOfWork = unitOfWork;\n        _logger = logger;\n        _mapper = mapper;\n        _accountService = accountService;\n        _emailService = emailService;\n        _environment = environment;\n        _eventHub = eventHub;\n    }\n\n    /// <summary>\n    /// Update a user's password\n    /// </summary>\n    /// <param name=\"resetPasswordDto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"reset-password\")]\n    public async Task<ActionResult> UpdatePassword(ResetPasswordDto resetPasswordDto)\n    {\n        // TODO: Log this request to Audit Table\n        _logger.LogInformation(\"{UserName} is changing {ResetUser}'s password\", User.GetUsername(), resetPasswordDto.UserName);\n\n        var user = await _userManager.Users.SingleOrDefaultAsync(x => x.UserName == resetPasswordDto.UserName);\n        if (user == null) return Ok(); // Don't report BadRequest as that would allow brute forcing to find accounts on system\n        var isAdmin = User.IsInRole(PolicyConstants.AdminRole);\n\n\n        if (resetPasswordDto.UserName == User.GetUsername() && !(User.IsInRole(PolicyConstants.ChangePasswordRole) || isAdmin))\n            return Unauthorized(\"You are not permitted to this operation.\");\n\n        if (resetPasswordDto.UserName != User.GetUsername() && !isAdmin)\n            return Unauthorized(\"You are not permitted to this operation.\");\n\n        if (string.IsNullOrEmpty(resetPasswordDto.OldPassword) && !isAdmin)\n            return BadRequest(new ApiException(400, \"You must enter your existing password to change your account unless you're an admin\"));\n\n        // If you're an admin and the username isn't yours, you don't need to validate the password\n        var isResettingOtherUser = (resetPasswordDto.UserName != User.GetUsername() && isAdmin);\n        if (!isResettingOtherUser && !await _userManager.CheckPasswordAsync(user, resetPasswordDto.OldPassword))\n        {\n            return BadRequest(\"Invalid Password\");\n        }\n\n        var errors = await _accountService.ChangeUserPassword(user, resetPasswordDto.Password);\n        if (errors.Any())\n        {\n            return BadRequest(errors);\n        }\n\n        _logger.LogInformation(\"{User}'s Password has been reset\", resetPasswordDto.UserName);\n        return Ok();\n    }\n\n    /// <summary>\n    /// Register the first user (admin) on the server. Will not do anything if an admin is already confirmed\n    /// </summary>\n    /// <param name=\"registerDto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"register\")]\n    public async Task<ActionResult<UserDto>> RegisterFirstUser(RegisterDto registerDto)\n    {\n        var admins = await _userManager.GetUsersInRoleAsync(\"Admin\");\n        if (admins.Count > 0) return BadRequest(\"Not allowed\");\n\n        try\n        {\n            var usernameValidation = await _accountService.ValidateUsername(registerDto.Username);\n            if (usernameValidation.Any())\n            {\n                return BadRequest(usernameValidation);\n            }\n\n            var user = new AppUser()\n            {\n                UserName = registerDto.Username,\n                Email = registerDto.Email,\n                UserPreferences = new AppUserPreferences\n                {\n                    Theme = await _unitOfWork.SiteThemeRepository.GetDefaultTheme()\n                },\n                ApiKey = HashUtil.ApiKey()\n            };\n\n            var result = await _userManager.CreateAsync(user, registerDto.Password);\n            if (!result.Succeeded) return BadRequest(result.Errors);\n\n            var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n            if (string.IsNullOrEmpty(token)) return BadRequest(\"There was an issue generating a confirmation token.\");\n            if (!await ConfirmEmailToken(token, user)) return BadRequest($\"There was an issue validating your email: {token}\");\n\n\n            var roleResult = await _userManager.AddToRoleAsync(user, PolicyConstants.AdminRole);\n            if (!roleResult.Succeeded) return BadRequest(result.Errors);\n\n            return new UserDto\n            {\n                Username = user.UserName,\n                Email = user.Email,\n                Token = await _tokenService.CreateToken(user),\n                RefreshToken = await _tokenService.CreateRefreshToken(user),\n                ApiKey = user.ApiKey,\n                Preferences = _mapper.Map<UserPreferencesDto>(user.UserPreferences)\n            };\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Something went wrong when registering user\");\n            // We need to manually delete the User as we've already committed\n            var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(registerDto.Username);\n            _unitOfWork.UserRepository.Delete(user);\n            await _unitOfWork.CommitAsync();\n        }\n\n        return BadRequest(\"Something went wrong when registering user\");\n    }\n\n\n    /// <summary>\n    /// Perform a login. Will send JWT Token of the logged in user back.\n    /// </summary>\n    /// <param name=\"loginDto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"login\")]\n    public async Task<ActionResult<UserDto>> Login(LoginDto loginDto)\n    {\n        var user = await _userManager.Users\n            .Include(u => u.UserPreferences)\n            .SingleOrDefaultAsync(x => x.NormalizedUserName == loginDto.Username.ToUpper());\n\n        if (user == null) return Unauthorized(\"Invalid username\");\n\n        var result = await _signInManager\n            .CheckPasswordSignInAsync(user, loginDto.Password, true);\n\n        if (result.IsLockedOut)\n        {\n            return Unauthorized(\"You've been locked out from too many authorization attempts. Please wait 10 minutes.\");\n        }\n\n        if (!result.Succeeded)\n        {\n            return Unauthorized(result.IsNotAllowed ? \"You must confirm your email first\" : \"Your credentials are not correct.\");\n        }\n\n        // Update LastActive on account\n        user.LastActive = DateTime.Now;\n        user.UserPreferences ??= new AppUserPreferences\n        {\n            Theme = await _unitOfWork.SiteThemeRepository.GetDefaultTheme()\n        };\n\n        _unitOfWork.UserRepository.Update(user);\n        await _unitOfWork.CommitAsync();\n\n        _logger.LogInformation(\"{UserName} logged in at {Time}\", user.UserName, user.LastActive);\n\n        var dto = _mapper.Map<UserDto>(user);\n        dto.Token = await _tokenService.CreateToken(user);\n        dto.RefreshToken = await _tokenService.CreateRefreshToken(user);\n        var pref = await _unitOfWork.UserRepository.GetPreferencesAsync(user.UserName);\n        pref.Theme ??= await _unitOfWork.SiteThemeRepository.GetDefaultTheme();\n        dto.Preferences = _mapper.Map<UserPreferencesDto>(pref);\n        return dto;\n    }\n\n    /// <summary>\n    /// Refreshes the user's JWT token\n    /// </summary>\n    /// <param name=\"tokenRequestDto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"refresh-token\")]\n    public async Task<ActionResult<TokenRequestDto>> RefreshToken([FromBody] TokenRequestDto tokenRequestDto)\n    {\n        var token = await _tokenService.ValidateRefreshToken(tokenRequestDto);\n        if (token == null)\n        {\n            return Unauthorized(new { message = \"Invalid token\" });\n        }\n\n        return Ok(token);\n    }\n\n    /// <summary>\n    /// Get All Roles back. See <see cref=\"PolicyConstants\"/>\n    /// </summary>\n    /// <returns></returns>\n    [HttpGet(\"roles\")]\n    public ActionResult<IList<string>> GetRoles()\n    {\n        // TODO: This should be moved to ServerController\n        return typeof(PolicyConstants)\n            .GetFields(BindingFlags.Public | BindingFlags.Static)\n            .Where(f => f.FieldType == typeof(string))\n            .ToDictionary(f => f.Name,\n                f => (string) f.GetValue(null)).Values.ToList();\n    }\n\n\n    /// <summary>\n    /// Resets the API Key assigned with a user\n    /// </summary>\n    /// <returns></returns>\n    [HttpPost(\"reset-api-key\")]\n    public async Task<ActionResult<string>> ResetApiKey()\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n\n        user.ApiKey = HashUtil.ApiKey();\n\n        if (_unitOfWork.HasChanges() && await _unitOfWork.CommitAsync())\n        {\n            return Ok(user.ApiKey);\n        }\n\n        await _unitOfWork.RollbackAsync();\n        return BadRequest(\"Something went wrong, unable to reset key\");\n\n    }\n\n\n    /// <summary>\n    /// Initiates the flow to update a user's email address. The email address is not changed in this API. A confirmation link is sent/dumped which will\n    /// validate the email. It must be confirmed for the email to update.\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    /// <returns>Returns just if the email was sent or server isn't reachable</returns>\n    [HttpPost(\"update/email\")]\n    public async Task<ActionResult> UpdateEmail(UpdateEmailDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (user == null) return Unauthorized(\"You do not have permission\");\n\n        if (dto == null || string.IsNullOrEmpty(dto.Email)) return BadRequest(\"Invalid payload\");\n\n        // Validate no other users exist with this email\n        if (user.Email.Equals(dto.Email)) return Ok(\"Nothing to do\");\n\n        // Check if email is used by another user\n        var existingUserEmail = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n        if (existingUserEmail != null)\n        {\n            return BadRequest(\"You cannot share emails across multiple accounts\");\n        }\n\n        // All validations complete, generate a new token and email it to the user at the new address. Confirm email link will update the email\n        var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n        if (string.IsNullOrEmpty(token))\n        {\n            _logger.LogError(\"There was an issue generating a token for the email\");\n            return BadRequest(\"There was an issue creating a confirmation email token. See logs.\");\n        }\n\n        user.EmailConfirmed = false;\n        user.ConfirmationToken = token;\n        await _userManager.UpdateAsync(user);\n\n        // Send a confirmation email\n        try\n        {\n            var emailLink = GenerateEmailLink(user.ConfirmationToken, \"confirm-email-update\", dto.Email);\n            _logger.LogCritical(\"[Update Email]: Email Link for {UserName}: {Link}\", user.UserName, emailLink);\n            var host = _environment.IsDevelopment() ? \"localhost:4200\" : Request.Host.ToString();\n            var accessible = await _emailService.CheckIfAccessible(host);\n            if (accessible)\n            {\n                try\n                {\n                    // Email the old address of the update change\n                    await _emailService.SendEmailChangeEmail(new ConfirmationEmailDto()\n                    {\n                        EmailAddress = string.IsNullOrEmpty(user.Email) ? dto.Email : user.Email,\n                        InstallId = BuildInfo.Version.ToString(),\n                        InvitingUser = (await _unitOfWork.UserRepository.GetAdminUsersAsync()).First().UserName,\n                        ServerConfirmationLink = emailLink\n                    });\n                }\n                catch (Exception)\n                {\n                    /* Swallow exception */\n                }\n            }\n\n            return Ok(new InviteUserResponse\n            {\n                EmailLink = string.Empty,\n                EmailSent = accessible\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an error during invite user flow, unable to send an email\");\n        }\n\n\n        await _eventHub.SendMessageToAsync(MessageFactory.UserUpdate, MessageFactory.UserUpdateEvent(user.Id, user.UserName), user.Id);\n\n        return Ok();\n    }\n\n    [HttpPost(\"update/age-restriction\")]\n    public async Task<ActionResult> UpdateAgeRestriction(UpdateAgeRestrictionDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (user == null) return Unauthorized(\"You do not have permission\");\n        if (dto == null) return BadRequest(\"Invalid payload\");\n\n        var isAdmin = await _unitOfWork.UserRepository.IsUserAdminAsync(user);\n\n        user.AgeRestriction = isAdmin ? AgeRating.NotApplicable : dto.AgeRating;\n        user.AgeRestrictionIncludeUnknowns = isAdmin || dto.IncludeUnknowns;\n\n        _unitOfWork.UserRepository.Update(user);\n\n        if (!_unitOfWork.HasChanges()) return Ok();\n        try\n        {\n            await _unitOfWork.CommitAsync();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an error updating the age restriction\");\n            return BadRequest(\"There was an error updating the age restriction\");\n        }\n\n        await _eventHub.SendMessageToAsync(MessageFactory.UserUpdate, MessageFactory.UserUpdateEvent(user.Id, user.UserName), user.Id);\n\n        return Ok();\n    }\n\n    /// <summary>\n    /// Update the user account. This can only affect Username, Email (will require confirming), Roles, and Library access.\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    /// <returns></returns>\n    [Authorize(Policy = \"RequireAdminRole\")]\n    [HttpPost(\"update\")]\n    public async Task<ActionResult> UpdateAccount(UpdateUserDto dto)\n    {\n        var adminUser = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (!await _unitOfWork.UserRepository.IsUserAdminAsync(adminUser)) return Unauthorized(\"You do not have permission\");\n\n        var user = await _unitOfWork.UserRepository.GetUserByIdAsync(dto.UserId);\n        if (user == null) return BadRequest(\"User does not exist\");\n\n        // Check if username is changing\n        if (!user.UserName.Equals(dto.Username))\n        {\n            // Validate username change\n            var errors = await _accountService.ValidateUsername(dto.Username);\n            if (errors.Any()) return BadRequest(\"Username already taken\");\n            user.UserName = dto.Username;\n            _unitOfWork.UserRepository.Update(user);\n        }\n\n        // Update roles\n        var existingRoles = await _userManager.GetRolesAsync(user);\n        var hasAdminRole = dto.Roles.Contains(PolicyConstants.AdminRole);\n        if (!hasAdminRole)\n        {\n            dto.Roles.Add(PolicyConstants.PlebRole);\n        }\n\n        if (existingRoles.Except(dto.Roles).Any() || dto.Roles.Except(existingRoles).Any())\n        {\n            var roles = dto.Roles;\n\n            var roleResult = await _userManager.RemoveFromRolesAsync(user, existingRoles);\n            if (!roleResult.Succeeded) return BadRequest(roleResult.Errors);\n            roleResult = await _userManager.AddToRolesAsync(user, roles);\n            if (!roleResult.Succeeded) return BadRequest(roleResult.Errors);\n        }\n\n\n        var allLibraries = (await _unitOfWork.LibraryRepository.GetLibrariesAsync()).ToList();\n        List<Library> libraries;\n        if (hasAdminRole)\n        {\n            _logger.LogInformation(\"{UserName} is being registered as admin. Granting access to all libraries\",\n                user.UserName);\n            libraries = allLibraries;\n        }\n        else\n        {\n            // Remove user from all libraries\n            foreach (var lib in allLibraries)\n            {\n                lib.AppUsers ??= new List<AppUser>();\n                lib.AppUsers.Remove(user);\n            }\n\n            libraries = (await _unitOfWork.LibraryRepository.GetLibraryForIdsAsync(dto.Libraries, LibraryIncludes.AppUser)).ToList();\n        }\n\n        foreach (var lib in libraries)\n        {\n            lib.AppUsers ??= new List<AppUser>();\n            lib.AppUsers.Add(user);\n        }\n\n        user.AgeRestriction = hasAdminRole ? AgeRating.NotApplicable : dto.AgeRestriction.AgeRating;\n        user.AgeRestrictionIncludeUnknowns = hasAdminRole || dto.AgeRestriction.IncludeUnknowns;\n\n        _unitOfWork.UserRepository.Update(user);\n\n        if (!_unitOfWork.HasChanges() || await _unitOfWork.CommitAsync())\n        {\n            await _eventHub.SendMessageToAsync(MessageFactory.UserUpdate, MessageFactory.UserUpdateEvent(user.Id, user.UserName), user.Id);\n            return Ok();\n        }\n\n        await _unitOfWork.RollbackAsync();\n        return BadRequest(\"There was an exception when updating the user\");\n    }\n\n    /// <summary>\n    /// Requests the Invite Url for the UserId. Will return error if user is already validated.\n    /// </summary>\n    /// <param name=\"userId\"></param>\n    /// <param name=\"withBaseUrl\">Include the \"https://ip:port/\" in the generated link</param>\n    /// <returns></returns>\n    [Authorize(Policy = \"RequireAdminRole\")]\n    [HttpGet(\"invite-url\")]\n    public async Task<ActionResult<string>> GetInviteUrl(int userId, bool withBaseUrl)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByIdAsync(userId);\n        if (user.EmailConfirmed)\n            return BadRequest(\"User is already confirmed\");\n        if (string.IsNullOrEmpty(user.ConfirmationToken))\n            return BadRequest(\"Manual setup is unable to be completed. Please cancel and recreate the invite.\");\n\n        return GenerateEmailLink(user.ConfirmationToken, \"confirm-email\", user.Email, withBaseUrl);\n    }\n\n\n    /// <summary>\n    /// Invites a user to the server. Will generate a setup link for continuing setup. If the server is not accessible, no\n    /// email will be sent.\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    /// <returns></returns>\n    [Authorize(Policy = \"RequireAdminRole\")]\n    [HttpPost(\"invite\")]\n    public async Task<ActionResult<string>> InviteUser(InviteUserDto dto)\n    {\n        var adminUser = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (adminUser == null) return Unauthorized(\"You are not permitted\");\n\n        _logger.LogInformation(\"{User} is inviting {Email} to the server\", adminUser.UserName, dto.Email);\n\n        // Check if there is an existing invite\n        if (!string.IsNullOrEmpty(dto.Email))\n        {\n            dto.Email = dto.Email.Trim();\n            var emailValidationErrors = await _accountService.ValidateEmail(dto.Email);\n            if (emailValidationErrors.Any())\n            {\n                var invitedUser = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n                if (await _userManager.IsEmailConfirmedAsync(invitedUser))\n                    return BadRequest($\"User is already registered as {invitedUser.UserName}\");\n                return BadRequest(\"User is already invited under this email and has yet to accepted invite.\");\n            }\n        }\n\n        // Create a new user\n        var user = new AppUser()\n        {\n            UserName = dto.Email,\n            Email = dto.Email,\n            ApiKey = HashUtil.ApiKey(),\n            UserPreferences = new AppUserPreferences\n            {\n                Theme = await _unitOfWork.SiteThemeRepository.GetDefaultTheme()\n            }\n        };\n\n        try\n        {\n            var result = await _userManager.CreateAsync(user, AccountService.DefaultPassword);\n            if (!result.Succeeded) return BadRequest(result.Errors);\n\n            // Assign Roles\n            var roles = dto.Roles;\n            var hasAdminRole = dto.Roles.Contains(PolicyConstants.AdminRole);\n            if (!hasAdminRole)\n            {\n                roles.Add(PolicyConstants.PlebRole);\n            }\n\n            foreach (var role in roles)\n            {\n                if (!PolicyConstants.ValidRoles.Contains(role)) continue;\n                var roleResult = await _userManager.AddToRoleAsync(user, role);\n                if (!roleResult.Succeeded)\n                    return\n                        BadRequest(roleResult.Errors);\n            }\n\n            // Grant access to libraries\n            List<Library> libraries;\n            if (hasAdminRole)\n            {\n                _logger.LogInformation(\"{UserName} is being registered as admin. Granting access to all libraries\",\n                    user.UserName);\n                libraries = (await _unitOfWork.LibraryRepository.GetLibrariesAsync(LibraryIncludes.AppUser)).ToList();\n            }\n            else\n            {\n                libraries = (await _unitOfWork.LibraryRepository.GetLibraryForIdsAsync(dto.Libraries, LibraryIncludes.AppUser)).ToList();\n            }\n\n            foreach (var lib in libraries)\n            {\n                lib.AppUsers ??= new List<AppUser>();\n                lib.AppUsers.Add(user);\n            }\n\n            user.AgeRestriction = hasAdminRole ? AgeRating.NotApplicable : dto.AgeRestriction.AgeRating;\n            user.AgeRestrictionIncludeUnknowns = hasAdminRole || dto.AgeRestriction.IncludeUnknowns;\n\n            var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n            if (string.IsNullOrEmpty(token))\n            {\n                _logger.LogError(\"There was an issue generating a token for the email\");\n                return BadRequest(\"There was an creating the invite user\");\n            }\n\n            user.ConfirmationToken = token;\n            await _unitOfWork.CommitAsync();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an error during invite user flow, unable to create user. Deleting user for retry\");\n            _unitOfWork.UserRepository.Delete(user);\n            await _unitOfWork.CommitAsync();\n        }\n\n        try\n        {\n            var emailLink = GenerateEmailLink(user.ConfirmationToken, \"confirm-email\", dto.Email);\n            _logger.LogCritical(\"[Invite User]: Email Link for {UserName}: {Link}\", user.UserName, emailLink);\n            _logger.LogCritical(\"[Invite User]: Token {UserName}: {Token}\", user.UserName, user.ConfirmationToken);\n            var host = _environment.IsDevelopment() ? \"localhost:4200\" : Request.Host.ToString();\n            var accessible = await _emailService.CheckIfAccessible(host);\n            if (accessible)\n            {\n                try\n                {\n                    await _emailService.SendConfirmationEmail(new ConfirmationEmailDto()\n                    {\n                        EmailAddress = dto.Email,\n                        InvitingUser = adminUser.UserName,\n                        ServerConfirmationLink = emailLink\n                    });\n                }\n                catch (Exception)\n                {\n                    /* Swallow exception */\n                }\n            }\n\n            return Ok(new InviteUserResponse\n            {\n                EmailLink = emailLink,\n                EmailSent = accessible\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an error during invite user flow, unable to send an email\");\n        }\n\n        return BadRequest(\"There was an error setting up your account. Please check the logs\");\n    }\n\n    [AllowAnonymous]\n    [HttpPost(\"confirm-email\")]\n    public async Task<ActionResult<UserDto>> ConfirmEmail(ConfirmEmailDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n\n        if (user == null)\n        {\n            return BadRequest(\"The email does not match the registered email\");\n        }\n\n        // Validate Password and Username\n        var validationErrors = new List<ApiException>();\n        validationErrors.AddRange(await _accountService.ValidateUsername(dto.Username));\n        validationErrors.AddRange(await _accountService.ValidatePassword(user, dto.Password));\n\n        if (validationErrors.Any())\n        {\n            return BadRequest(validationErrors);\n        }\n\n\n        if (!await ConfirmEmailToken(dto.Token, user)) return BadRequest(\"Invalid Email Token\");\n\n        user.UserName = dto.Username;\n        user.ConfirmationToken = null;\n        var errors = await _accountService.ChangeUserPassword(user, dto.Password);\n        if (errors.Any())\n        {\n            return BadRequest(errors);\n        }\n        await _unitOfWork.CommitAsync();\n\n\n        user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(user.UserName,\n            AppUserIncludes.UserPreferences);\n\n        // Perform Login code\n        return new UserDto\n        {\n            Username = user.UserName,\n            Email = user.Email,\n            Token = await _tokenService.CreateToken(user),\n            RefreshToken = await _tokenService.CreateRefreshToken(user),\n            ApiKey = user.ApiKey,\n            Preferences = _mapper.Map<UserPreferencesDto>(user.UserPreferences)\n        };\n    }\n\n    /// <summary>\n    /// Final step in email update change. Given a confirmation token and the email, this will finish the email change.\n    /// </summary>\n    /// <remarks>This will force connected clients to re-authenticate</remarks>\n    /// <param name=\"dto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"confirm-email-update\")]\n    public async Task<ActionResult> ConfirmEmailUpdate(ConfirmEmailUpdateDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByConfirmationToken(dto.Token);\n        if (user == null)\n        {\n            return BadRequest(\"Invalid Email Token\");\n        }\n\n        if (!await ConfirmEmailToken(dto.Token, user)) return BadRequest(\"Invalid Email Token\");\n\n\n        _logger.LogInformation(\"User is updating email from {OldEmail} to {NewEmail}\", user.Email, dto.Email);\n        var result = await _userManager.SetEmailAsync(user, dto.Email);\n        if (!result.Succeeded)\n        {\n            _logger.LogError(\"Unable to update email for users: {Errors}\", result.Errors.Select(e => e.Description));\n            return BadRequest(\"Unable to update email for user. Check logs\");\n        }\n        user.ConfirmationToken = null;\n        await _unitOfWork.CommitAsync();\n\n\n        // For the user's connected devices to pull the new information in\n        await _eventHub.SendMessageToAsync(MessageFactory.UserUpdate,\n            MessageFactory.UserUpdateEvent(user.Id, user.UserName), user.Id);\n\n        // Perform Login code\n        return Ok();\n    }\n\n    [AllowAnonymous]\n    [HttpPost(\"confirm-password-reset\")]\n    public async Task<ActionResult<string>> ConfirmForgotPassword(ConfirmPasswordResetDto dto)\n    {\n        try\n        {\n            var user = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n            if (user == null)\n            {\n                return BadRequest(\"Invalid Details\");\n            }\n\n            var result = await _userManager.VerifyUserTokenAsync(user, TokenOptions.DefaultProvider,\n                \"ResetPassword\", dto.Token);\n            if (!result) return BadRequest(\"Unable to reset password, your email token is not correct.\");\n\n            var errors = await _accountService.ChangeUserPassword(user, dto.Password);\n            return errors.Any() ? BadRequest(errors) : Ok(\"Password updated\");\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an unexpected error when confirming new password\");\n            return BadRequest(\"There was an unexpected error when confirming new password\");\n        }\n    }\n\n\n    /// <summary>\n    /// Will send user a link to update their password to their email or prompt them if not accessible\n    /// </summary>\n    /// <param name=\"email\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"forgot-password\")]\n    public async Task<ActionResult<string>> ForgotPassword([FromQuery] string email)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByEmailAsync(email);\n        if (user == null)\n        {\n            _logger.LogError(\"There are no users with email: {Email} but user is requesting password reset\", email);\n            return Ok(\"An email will be sent to the email if it exists in our database\");\n        }\n\n        var roles = await _userManager.GetRolesAsync(user);\n        if (!roles.Any(r => r is PolicyConstants.AdminRole or PolicyConstants.ChangePasswordRole))\n            return Unauthorized(\"You are not permitted to this operation.\");\n\n        if (string.IsNullOrEmpty(user.Email) || !user.EmailConfirmed)\n            return BadRequest(\"You do not have an email on account or it has not been confirmed\");\n\n        var token = await _userManager.GeneratePasswordResetTokenAsync(user);\n        var emailLink = GenerateEmailLink(token, \"confirm-reset-password\", user.Email);\n        _logger.LogCritical(\"[Forgot Password]: Email Link for {UserName}: {Link}\", user.UserName, emailLink);\n        var host = _environment.IsDevelopment() ? \"localhost:4200\" : Request.Host.ToString();\n        if (await _emailService.CheckIfAccessible(host))\n        {\n            await _emailService.SendPasswordResetEmail(new PasswordResetEmailDto()\n            {\n                EmailAddress = user.Email,\n                ServerConfirmationLink = emailLink,\n                InstallId = (await _unitOfWork.SettingsRepository.GetSettingAsync(ServerSettingKey.InstallId)).Value\n            });\n            return Ok(\"Email sent\");\n        }\n\n        return Ok(\"Your server is not accessible. The Link to reset your password is in the logs.\");\n    }\n\n    [HttpGet(\"email-confirmed\")]\n    public async Task<ActionResult<bool>> IsEmailConfirmed()\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (user == null) return Unauthorized();\n\n        return Ok(user.EmailConfirmed);\n    }\n\n    [AllowAnonymous]\n    [HttpPost(\"confirm-migration-email\")]\n    public async Task<ActionResult<UserDto>> ConfirmMigrationEmail(ConfirmMigrationEmailDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n        if (user == null) return BadRequest(\"This email is not on system\");\n\n        if (!await ConfirmEmailToken(dto.Token, user)) return BadRequest(\"Invalid Email Token\");\n\n        await _unitOfWork.CommitAsync();\n\n        user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(user.UserName,\n            AppUserIncludes.UserPreferences);\n\n        // Perform Login code\n        return new UserDto\n        {\n            Username = user.UserName,\n            Email = user.Email,\n            Token = await _tokenService.CreateToken(user),\n            RefreshToken = await _tokenService.CreateRefreshToken(user),\n            ApiKey = user.ApiKey,\n            Preferences = _mapper.Map<UserPreferencesDto>(user.UserPreferences)\n        };\n    }\n\n    [HttpPost(\"resend-confirmation-email\")]\n    public async Task<ActionResult<string>> ResendConfirmationSendEmail([FromQuery] int userId)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByIdAsync(userId);\n        if (user == null) return BadRequest(\"User does not exist\");\n\n        if (string.IsNullOrEmpty(user.Email))\n            return BadRequest(\n                \"This user needs to migrate. Have them log out and login to trigger a migration flow\");\n        if (user.EmailConfirmed) return BadRequest(\"User already confirmed\");\n\n        var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n        var emailLink = GenerateEmailLink(token, \"confirm-email\", user.Email);\n        _logger.LogCritical(\"[Email Migration]: Email Link: {Link}\", emailLink);\n        _logger.LogCritical(\"[Email Migration]: Token {UserName}: {Token}\", user.UserName, token);\n        await _emailService.SendMigrationEmail(new EmailMigrationDto()\n        {\n            EmailAddress = user.Email,\n            Username = user.UserName,\n            ServerConfirmationLink = emailLink,\n            InstallId = (await _unitOfWork.SettingsRepository.GetSettingAsync(ServerSettingKey.InstallId)).Value\n        });\n\n\n        return Ok(emailLink);\n    }\n\n    private string GenerateEmailLink(string token, string routePart, string email, bool withHost = true)\n    {\n        var host = _environment.IsDevelopment() ? \"localhost:4200\" : Request.Host.ToString();\n        if (withHost) return $\"{Request.Scheme}://{host}{Request.PathBase}/registration/{routePart}?token={HttpUtility.UrlEncode(token)}&email={HttpUtility.UrlEncode(email)}\";\n        return $\"registration/{routePart}?token={HttpUtility.UrlEncode(token)}&email={HttpUtility.UrlEncode(email)}\";\n    }\n\n    /// <summary>\n    /// This is similar to invite. Essentially we authenticate the user's password then go through invite email flow\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"migrate-email\")]\n    public async Task<ActionResult<string>> MigrateEmail(MigrateUserEmailDto dto)\n    {\n        // Check if there is an existing invite\n        var emailValidationErrors = await _accountService.ValidateEmail(dto.Email);\n        if (emailValidationErrors.Any())\n        {\n            var invitedUser = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n            if (await _userManager.IsEmailConfirmedAsync(invitedUser))\n                return BadRequest($\"User is already registered as {invitedUser.UserName}\");\n\n            _logger.LogInformation(\"A user is attempting to login, but hasn't accepted email invite\");\n            return BadRequest(\"User is already invited under this email and has yet to accepted invite.\");\n        }\n\n\n        var user = await _userManager.Users\n            .Include(u => u.UserPreferences)\n            .SingleOrDefaultAsync(x => x.NormalizedUserName == dto.Username.ToUpper());\n        if (user == null) return BadRequest(\"Invalid username\");\n\n        var validPassword = await _signInManager.UserManager.CheckPasswordAsync(user, dto.Password);\n        if (!validPassword) return BadRequest(\"Your credentials are not correct\");\n\n        try\n        {\n            var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n\n            user.Email = dto.Email;\n            if (!await ConfirmEmailToken(token, user)) return BadRequest(\"There was a critical error during migration\");\n            _unitOfWork.UserRepository.Update(user);\n\n            await _unitOfWork.CommitAsync();\n\n            return Ok();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an issue during email migration. Contact support\");\n            _unitOfWork.UserRepository.Delete(user);\n            await _unitOfWork.CommitAsync();\n        }\n\n        return BadRequest(\"There was an error setting up your account. Please check the logs\");\n    }\n\n    private async Task<bool> ConfirmEmailToken(string token, AppUser user)\n    {\n        var result = await _userManager.ConfirmEmailAsync(user, token);\n        if (result.Succeeded) return true;\n\n\n\n        _logger.LogCritical(\"[Account] Email validation failed\");\n        if (!result.Errors.Any()) return false;\n\n        foreach (var error in result.Errors)\n        {\n            _logger.LogCritical(\"[Account] Email validation error: {Message}\", error.Description);\n        }\n\n        return false;\n\n    }\n}\n"], "fixing_code": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing System.Web;\nusing API.Constants;\nusing API.Data;\nusing API.Data.Repositories;\nusing API.DTOs;\nusing API.DTOs.Account;\nusing API.DTOs.Email;\nusing API.Entities;\nusing API.Entities.Enums;\nusing API.Errors;\nusing API.Extensions;\nusing API.Services;\nusing API.SignalR;\nusing AutoMapper;\nusing Kavita.Common;\nusing Kavita.Common.EnvironmentInfo;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nnamespace API.Controllers;\n\n/// <summary>\n/// All Account matters\n/// </summary>\npublic class AccountController : BaseApiController\n{\n    private readonly UserManager<AppUser> _userManager;\n    private readonly SignInManager<AppUser> _signInManager;\n    private readonly ITokenService _tokenService;\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly ILogger<AccountController> _logger;\n    private readonly IMapper _mapper;\n    private readonly IAccountService _accountService;\n    private readonly IEmailService _emailService;\n    private readonly IHostEnvironment _environment;\n    private readonly IEventHub _eventHub;\n\n    /// <inheritdoc />\n    public AccountController(UserManager<AppUser> userManager,\n        SignInManager<AppUser> signInManager,\n        ITokenService tokenService, IUnitOfWork unitOfWork,\n        ILogger<AccountController> logger,\n        IMapper mapper, IAccountService accountService,\n        IEmailService emailService, IHostEnvironment environment,\n        IEventHub eventHub)\n    {\n        _userManager = userManager;\n        _signInManager = signInManager;\n        _tokenService = tokenService;\n        _unitOfWork = unitOfWork;\n        _logger = logger;\n        _mapper = mapper;\n        _accountService = accountService;\n        _emailService = emailService;\n        _environment = environment;\n        _eventHub = eventHub;\n    }\n\n    /// <summary>\n    /// Update a user's password\n    /// </summary>\n    /// <param name=\"resetPasswordDto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"reset-password\")]\n    public async Task<ActionResult> UpdatePassword(ResetPasswordDto resetPasswordDto)\n    {\n        // TODO: Log this request to Audit Table\n        _logger.LogInformation(\"{UserName} is changing {ResetUser}'s password\", User.GetUsername(), resetPasswordDto.UserName);\n\n        var user = await _userManager.Users.SingleOrDefaultAsync(x => x.UserName == resetPasswordDto.UserName);\n        if (user == null) return Ok(); // Don't report BadRequest as that would allow brute forcing to find accounts on system\n        var isAdmin = User.IsInRole(PolicyConstants.AdminRole);\n\n\n        if (resetPasswordDto.UserName == User.GetUsername() && !(User.IsInRole(PolicyConstants.ChangePasswordRole) || isAdmin))\n            return Unauthorized(\"You are not permitted to this operation.\");\n\n        if (resetPasswordDto.UserName != User.GetUsername() && !isAdmin)\n            return Unauthorized(\"You are not permitted to this operation.\");\n\n        if (string.IsNullOrEmpty(resetPasswordDto.OldPassword) && !isAdmin)\n            return BadRequest(new ApiException(400, \"You must enter your existing password to change your account unless you're an admin\"));\n\n        // If you're an admin and the username isn't yours, you don't need to validate the password\n        var isResettingOtherUser = (resetPasswordDto.UserName != User.GetUsername() && isAdmin);\n        if (!isResettingOtherUser && !await _userManager.CheckPasswordAsync(user, resetPasswordDto.OldPassword))\n        {\n            return BadRequest(\"Invalid Password\");\n        }\n\n        var errors = await _accountService.ChangeUserPassword(user, resetPasswordDto.Password);\n        if (errors.Any())\n        {\n            return BadRequest(errors);\n        }\n\n        _logger.LogInformation(\"{User}'s Password has been reset\", resetPasswordDto.UserName);\n        return Ok();\n    }\n\n    /// <summary>\n    /// Register the first user (admin) on the server. Will not do anything if an admin is already confirmed\n    /// </summary>\n    /// <param name=\"registerDto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"register\")]\n    public async Task<ActionResult<UserDto>> RegisterFirstUser(RegisterDto registerDto)\n    {\n        var admins = await _userManager.GetUsersInRoleAsync(\"Admin\");\n        if (admins.Count > 0) return BadRequest(\"Not allowed\");\n\n        try\n        {\n            var usernameValidation = await _accountService.ValidateUsername(registerDto.Username);\n            if (usernameValidation.Any())\n            {\n                return BadRequest(usernameValidation);\n            }\n\n            var user = new AppUser()\n            {\n                UserName = registerDto.Username,\n                Email = registerDto.Email,\n                UserPreferences = new AppUserPreferences\n                {\n                    Theme = await _unitOfWork.SiteThemeRepository.GetDefaultTheme()\n                },\n                ApiKey = HashUtil.ApiKey()\n            };\n\n            var result = await _userManager.CreateAsync(user, registerDto.Password);\n            if (!result.Succeeded) return BadRequest(result.Errors);\n\n            var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n            if (string.IsNullOrEmpty(token)) return BadRequest(\"There was an issue generating a confirmation token.\");\n            if (!await ConfirmEmailToken(token, user)) return BadRequest($\"There was an issue validating your email: {token}\");\n\n\n            var roleResult = await _userManager.AddToRoleAsync(user, PolicyConstants.AdminRole);\n            if (!roleResult.Succeeded) return BadRequest(result.Errors);\n\n            return new UserDto\n            {\n                Username = user.UserName,\n                Email = user.Email,\n                Token = await _tokenService.CreateToken(user),\n                RefreshToken = await _tokenService.CreateRefreshToken(user),\n                ApiKey = user.ApiKey,\n                Preferences = _mapper.Map<UserPreferencesDto>(user.UserPreferences)\n            };\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Something went wrong when registering user\");\n            // We need to manually delete the User as we've already committed\n            var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(registerDto.Username);\n            _unitOfWork.UserRepository.Delete(user);\n            await _unitOfWork.CommitAsync();\n        }\n\n        return BadRequest(\"Something went wrong when registering user\");\n    }\n\n\n    /// <summary>\n    /// Perform a login. Will send JWT Token of the logged in user back.\n    /// </summary>\n    /// <param name=\"loginDto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"login\")]\n    public async Task<ActionResult<UserDto>> Login(LoginDto loginDto)\n    {\n        var user = await _userManager.Users\n            .Include(u => u.UserPreferences)\n            .SingleOrDefaultAsync(x => x.NormalizedUserName == loginDto.Username.ToUpper());\n\n        if (user == null) return Unauthorized(\"Your credentials are not correct\");\n\n        var result = await _signInManager\n            .CheckPasswordSignInAsync(user, loginDto.Password, true);\n\n        if (result.IsLockedOut)\n        {\n            return Unauthorized(\"You've been locked out from too many authorization attempts. Please wait 10 minutes.\");\n        }\n\n        if (!result.Succeeded)\n        {\n            return Unauthorized(result.IsNotAllowed ? \"You must confirm your email first\" : \"Your credentials are not correct\");\n        }\n\n        // Update LastActive on account\n        user.LastActive = DateTime.Now;\n        user.UserPreferences ??= new AppUserPreferences\n        {\n            Theme = await _unitOfWork.SiteThemeRepository.GetDefaultTheme()\n        };\n\n        _unitOfWork.UserRepository.Update(user);\n        await _unitOfWork.CommitAsync();\n\n        _logger.LogInformation(\"{UserName} logged in at {Time}\", user.UserName, user.LastActive);\n\n        var dto = _mapper.Map<UserDto>(user);\n        dto.Token = await _tokenService.CreateToken(user);\n        dto.RefreshToken = await _tokenService.CreateRefreshToken(user);\n        var pref = await _unitOfWork.UserRepository.GetPreferencesAsync(user.UserName);\n        pref.Theme ??= await _unitOfWork.SiteThemeRepository.GetDefaultTheme();\n        dto.Preferences = _mapper.Map<UserPreferencesDto>(pref);\n        return dto;\n    }\n\n    /// <summary>\n    /// Refreshes the user's JWT token\n    /// </summary>\n    /// <param name=\"tokenRequestDto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"refresh-token\")]\n    public async Task<ActionResult<TokenRequestDto>> RefreshToken([FromBody] TokenRequestDto tokenRequestDto)\n    {\n        var token = await _tokenService.ValidateRefreshToken(tokenRequestDto);\n        if (token == null)\n        {\n            return Unauthorized(new { message = \"Invalid token\" });\n        }\n\n        return Ok(token);\n    }\n\n    /// <summary>\n    /// Get All Roles back. See <see cref=\"PolicyConstants\"/>\n    /// </summary>\n    /// <returns></returns>\n    [HttpGet(\"roles\")]\n    public ActionResult<IList<string>> GetRoles()\n    {\n        // TODO: This should be moved to ServerController\n        return typeof(PolicyConstants)\n            .GetFields(BindingFlags.Public | BindingFlags.Static)\n            .Where(f => f.FieldType == typeof(string))\n            .ToDictionary(f => f.Name,\n                f => (string) f.GetValue(null)).Values.ToList();\n    }\n\n\n    /// <summary>\n    /// Resets the API Key assigned with a user\n    /// </summary>\n    /// <returns></returns>\n    [HttpPost(\"reset-api-key\")]\n    public async Task<ActionResult<string>> ResetApiKey()\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n\n        user.ApiKey = HashUtil.ApiKey();\n\n        if (_unitOfWork.HasChanges() && await _unitOfWork.CommitAsync())\n        {\n            return Ok(user.ApiKey);\n        }\n\n        await _unitOfWork.RollbackAsync();\n        return BadRequest(\"Something went wrong, unable to reset key\");\n\n    }\n\n\n    /// <summary>\n    /// Initiates the flow to update a user's email address. The email address is not changed in this API. A confirmation link is sent/dumped which will\n    /// validate the email. It must be confirmed for the email to update.\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    /// <returns>Returns just if the email was sent or server isn't reachable</returns>\n    [HttpPost(\"update/email\")]\n    public async Task<ActionResult> UpdateEmail(UpdateEmailDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (user == null) return Unauthorized(\"You do not have permission\");\n\n        if (dto == null || string.IsNullOrEmpty(dto.Email)) return BadRequest(\"Invalid payload\");\n\n        // Validate no other users exist with this email\n        if (user.Email.Equals(dto.Email)) return Ok(\"Nothing to do\");\n\n        // Check if email is used by another user\n        var existingUserEmail = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n        if (existingUserEmail != null)\n        {\n            return BadRequest(\"You cannot share emails across multiple accounts\");\n        }\n\n        // All validations complete, generate a new token and email it to the user at the new address. Confirm email link will update the email\n        var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n        if (string.IsNullOrEmpty(token))\n        {\n            _logger.LogError(\"There was an issue generating a token for the email\");\n            return BadRequest(\"There was an issue creating a confirmation email token. See logs.\");\n        }\n\n        user.EmailConfirmed = false;\n        user.ConfirmationToken = token;\n        await _userManager.UpdateAsync(user);\n\n        // Send a confirmation email\n        try\n        {\n            var emailLink = GenerateEmailLink(user.ConfirmationToken, \"confirm-email-update\", dto.Email);\n            _logger.LogCritical(\"[Update Email]: Email Link for {UserName}: {Link}\", user.UserName, emailLink);\n            var host = _environment.IsDevelopment() ? \"localhost:4200\" : Request.Host.ToString();\n            var accessible = await _emailService.CheckIfAccessible(host);\n            if (accessible)\n            {\n                try\n                {\n                    // Email the old address of the update change\n                    await _emailService.SendEmailChangeEmail(new ConfirmationEmailDto()\n                    {\n                        EmailAddress = string.IsNullOrEmpty(user.Email) ? dto.Email : user.Email,\n                        InstallId = BuildInfo.Version.ToString(),\n                        InvitingUser = (await _unitOfWork.UserRepository.GetAdminUsersAsync()).First().UserName,\n                        ServerConfirmationLink = emailLink\n                    });\n                }\n                catch (Exception)\n                {\n                    /* Swallow exception */\n                }\n            }\n\n            return Ok(new InviteUserResponse\n            {\n                EmailLink = string.Empty,\n                EmailSent = accessible\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an error during invite user flow, unable to send an email\");\n        }\n\n\n        await _eventHub.SendMessageToAsync(MessageFactory.UserUpdate, MessageFactory.UserUpdateEvent(user.Id, user.UserName), user.Id);\n\n        return Ok();\n    }\n\n    [HttpPost(\"update/age-restriction\")]\n    public async Task<ActionResult> UpdateAgeRestriction(UpdateAgeRestrictionDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (user == null) return Unauthorized(\"You do not have permission\");\n        if (dto == null) return BadRequest(\"Invalid payload\");\n\n        var isAdmin = await _unitOfWork.UserRepository.IsUserAdminAsync(user);\n\n        user.AgeRestriction = isAdmin ? AgeRating.NotApplicable : dto.AgeRating;\n        user.AgeRestrictionIncludeUnknowns = isAdmin || dto.IncludeUnknowns;\n\n        _unitOfWork.UserRepository.Update(user);\n\n        if (!_unitOfWork.HasChanges()) return Ok();\n        try\n        {\n            await _unitOfWork.CommitAsync();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an error updating the age restriction\");\n            return BadRequest(\"There was an error updating the age restriction\");\n        }\n\n        await _eventHub.SendMessageToAsync(MessageFactory.UserUpdate, MessageFactory.UserUpdateEvent(user.Id, user.UserName), user.Id);\n\n        return Ok();\n    }\n\n    /// <summary>\n    /// Update the user account. This can only affect Username, Email (will require confirming), Roles, and Library access.\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    /// <returns></returns>\n    [Authorize(Policy = \"RequireAdminRole\")]\n    [HttpPost(\"update\")]\n    public async Task<ActionResult> UpdateAccount(UpdateUserDto dto)\n    {\n        var adminUser = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (!await _unitOfWork.UserRepository.IsUserAdminAsync(adminUser)) return Unauthorized(\"You do not have permission\");\n\n        var user = await _unitOfWork.UserRepository.GetUserByIdAsync(dto.UserId);\n        if (user == null) return BadRequest(\"User does not exist\");\n\n        // Check if username is changing\n        if (!user.UserName.Equals(dto.Username))\n        {\n            // Validate username change\n            var errors = await _accountService.ValidateUsername(dto.Username);\n            if (errors.Any()) return BadRequest(\"Username already taken\");\n            user.UserName = dto.Username;\n            _unitOfWork.UserRepository.Update(user);\n        }\n\n        // Update roles\n        var existingRoles = await _userManager.GetRolesAsync(user);\n        var hasAdminRole = dto.Roles.Contains(PolicyConstants.AdminRole);\n        if (!hasAdminRole)\n        {\n            dto.Roles.Add(PolicyConstants.PlebRole);\n        }\n\n        if (existingRoles.Except(dto.Roles).Any() || dto.Roles.Except(existingRoles).Any())\n        {\n            var roles = dto.Roles;\n\n            var roleResult = await _userManager.RemoveFromRolesAsync(user, existingRoles);\n            if (!roleResult.Succeeded) return BadRequest(roleResult.Errors);\n            roleResult = await _userManager.AddToRolesAsync(user, roles);\n            if (!roleResult.Succeeded) return BadRequest(roleResult.Errors);\n        }\n\n\n        var allLibraries = (await _unitOfWork.LibraryRepository.GetLibrariesAsync()).ToList();\n        List<Library> libraries;\n        if (hasAdminRole)\n        {\n            _logger.LogInformation(\"{UserName} is being registered as admin. Granting access to all libraries\",\n                user.UserName);\n            libraries = allLibraries;\n        }\n        else\n        {\n            // Remove user from all libraries\n            foreach (var lib in allLibraries)\n            {\n                lib.AppUsers ??= new List<AppUser>();\n                lib.AppUsers.Remove(user);\n            }\n\n            libraries = (await _unitOfWork.LibraryRepository.GetLibraryForIdsAsync(dto.Libraries, LibraryIncludes.AppUser)).ToList();\n        }\n\n        foreach (var lib in libraries)\n        {\n            lib.AppUsers ??= new List<AppUser>();\n            lib.AppUsers.Add(user);\n        }\n\n        user.AgeRestriction = hasAdminRole ? AgeRating.NotApplicable : dto.AgeRestriction.AgeRating;\n        user.AgeRestrictionIncludeUnknowns = hasAdminRole || dto.AgeRestriction.IncludeUnknowns;\n\n        _unitOfWork.UserRepository.Update(user);\n\n        if (!_unitOfWork.HasChanges() || await _unitOfWork.CommitAsync())\n        {\n            await _eventHub.SendMessageToAsync(MessageFactory.UserUpdate, MessageFactory.UserUpdateEvent(user.Id, user.UserName), user.Id);\n            return Ok();\n        }\n\n        await _unitOfWork.RollbackAsync();\n        return BadRequest(\"There was an exception when updating the user\");\n    }\n\n    /// <summary>\n    /// Requests the Invite Url for the UserId. Will return error if user is already validated.\n    /// </summary>\n    /// <param name=\"userId\"></param>\n    /// <param name=\"withBaseUrl\">Include the \"https://ip:port/\" in the generated link</param>\n    /// <returns></returns>\n    [Authorize(Policy = \"RequireAdminRole\")]\n    [HttpGet(\"invite-url\")]\n    public async Task<ActionResult<string>> GetInviteUrl(int userId, bool withBaseUrl)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByIdAsync(userId);\n        if (user.EmailConfirmed)\n            return BadRequest(\"User is already confirmed\");\n        if (string.IsNullOrEmpty(user.ConfirmationToken))\n            return BadRequest(\"Manual setup is unable to be completed. Please cancel and recreate the invite.\");\n\n        return GenerateEmailLink(user.ConfirmationToken, \"confirm-email\", user.Email, withBaseUrl);\n    }\n\n\n    /// <summary>\n    /// Invites a user to the server. Will generate a setup link for continuing setup. If the server is not accessible, no\n    /// email will be sent.\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    /// <returns></returns>\n    [Authorize(Policy = \"RequireAdminRole\")]\n    [HttpPost(\"invite\")]\n    public async Task<ActionResult<string>> InviteUser(InviteUserDto dto)\n    {\n        var adminUser = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (adminUser == null) return Unauthorized(\"You are not permitted\");\n\n        _logger.LogInformation(\"{User} is inviting {Email} to the server\", adminUser.UserName, dto.Email);\n\n        // Check if there is an existing invite\n        if (!string.IsNullOrEmpty(dto.Email))\n        {\n            dto.Email = dto.Email.Trim();\n            var emailValidationErrors = await _accountService.ValidateEmail(dto.Email);\n            if (emailValidationErrors.Any())\n            {\n                var invitedUser = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n                if (await _userManager.IsEmailConfirmedAsync(invitedUser))\n                    return BadRequest($\"User is already registered as {invitedUser.UserName}\");\n                return BadRequest(\"User is already invited under this email and has yet to accepted invite.\");\n            }\n        }\n\n        // Create a new user\n        var user = new AppUser()\n        {\n            UserName = dto.Email,\n            Email = dto.Email,\n            ApiKey = HashUtil.ApiKey(),\n            UserPreferences = new AppUserPreferences\n            {\n                Theme = await _unitOfWork.SiteThemeRepository.GetDefaultTheme()\n            }\n        };\n\n        try\n        {\n            var result = await _userManager.CreateAsync(user, AccountService.DefaultPassword);\n            if (!result.Succeeded) return BadRequest(result.Errors);\n\n            // Assign Roles\n            var roles = dto.Roles;\n            var hasAdminRole = dto.Roles.Contains(PolicyConstants.AdminRole);\n            if (!hasAdminRole)\n            {\n                roles.Add(PolicyConstants.PlebRole);\n            }\n\n            foreach (var role in roles)\n            {\n                if (!PolicyConstants.ValidRoles.Contains(role)) continue;\n                var roleResult = await _userManager.AddToRoleAsync(user, role);\n                if (!roleResult.Succeeded)\n                    return\n                        BadRequest(roleResult.Errors);\n            }\n\n            // Grant access to libraries\n            List<Library> libraries;\n            if (hasAdminRole)\n            {\n                _logger.LogInformation(\"{UserName} is being registered as admin. Granting access to all libraries\",\n                    user.UserName);\n                libraries = (await _unitOfWork.LibraryRepository.GetLibrariesAsync(LibraryIncludes.AppUser)).ToList();\n            }\n            else\n            {\n                libraries = (await _unitOfWork.LibraryRepository.GetLibraryForIdsAsync(dto.Libraries, LibraryIncludes.AppUser)).ToList();\n            }\n\n            foreach (var lib in libraries)\n            {\n                lib.AppUsers ??= new List<AppUser>();\n                lib.AppUsers.Add(user);\n            }\n\n            user.AgeRestriction = hasAdminRole ? AgeRating.NotApplicable : dto.AgeRestriction.AgeRating;\n            user.AgeRestrictionIncludeUnknowns = hasAdminRole || dto.AgeRestriction.IncludeUnknowns;\n\n            var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n            if (string.IsNullOrEmpty(token))\n            {\n                _logger.LogError(\"There was an issue generating a token for the email\");\n                return BadRequest(\"There was an creating the invite user\");\n            }\n\n            user.ConfirmationToken = token;\n            await _unitOfWork.CommitAsync();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an error during invite user flow, unable to create user. Deleting user for retry\");\n            _unitOfWork.UserRepository.Delete(user);\n            await _unitOfWork.CommitAsync();\n        }\n\n        try\n        {\n            var emailLink = GenerateEmailLink(user.ConfirmationToken, \"confirm-email\", dto.Email);\n            _logger.LogCritical(\"[Invite User]: Email Link for {UserName}: {Link}\", user.UserName, emailLink);\n            _logger.LogCritical(\"[Invite User]: Token {UserName}: {Token}\", user.UserName, user.ConfirmationToken);\n            var host = _environment.IsDevelopment() ? \"localhost:4200\" : Request.Host.ToString();\n            var accessible = await _emailService.CheckIfAccessible(host);\n            if (accessible)\n            {\n                try\n                {\n                    await _emailService.SendConfirmationEmail(new ConfirmationEmailDto()\n                    {\n                        EmailAddress = dto.Email,\n                        InvitingUser = adminUser.UserName,\n                        ServerConfirmationLink = emailLink\n                    });\n                }\n                catch (Exception)\n                {\n                    /* Swallow exception */\n                }\n            }\n\n            return Ok(new InviteUserResponse\n            {\n                EmailLink = emailLink,\n                EmailSent = accessible\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an error during invite user flow, unable to send an email\");\n        }\n\n        return BadRequest(\"There was an error setting up your account. Please check the logs\");\n    }\n\n    /// <summary>\n    /// Last step in authentication flow, confirms the email token for email\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"confirm-email\")]\n    public async Task<ActionResult<UserDto>> ConfirmEmail(ConfirmEmailDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n\n        if (user == null)\n        {\n            _logger.LogInformation(\"confirm-email failed from invalid registered email: {Email}\", dto.Email);\n            return BadRequest(\"Invalid email confirmation\");\n        }\n\n        // Validate Password and Username\n        var validationErrors = new List<ApiException>();\n        validationErrors.AddRange(await _accountService.ValidateUsername(dto.Username));\n        validationErrors.AddRange(await _accountService.ValidatePassword(user, dto.Password));\n\n        if (validationErrors.Any())\n        {\n            return BadRequest(validationErrors);\n        }\n\n\n        if (!await ConfirmEmailToken(dto.Token, user))\n        {\n            _logger.LogInformation(\"confirm-email failed from invalid token: {Token}\", dto.Token);\n            return BadRequest(\"Invalid email confirmation\");\n        }\n\n        user.UserName = dto.Username;\n        user.ConfirmationToken = null;\n        var errors = await _accountService.ChangeUserPassword(user, dto.Password);\n        if (errors.Any())\n        {\n            return BadRequest(errors);\n        }\n        await _unitOfWork.CommitAsync();\n\n\n        user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(user.UserName,\n            AppUserIncludes.UserPreferences);\n\n        // Perform Login code\n        return new UserDto\n        {\n            Username = user.UserName,\n            Email = user.Email,\n            Token = await _tokenService.CreateToken(user),\n            RefreshToken = await _tokenService.CreateRefreshToken(user),\n            ApiKey = user.ApiKey,\n            Preferences = _mapper.Map<UserPreferencesDto>(user.UserPreferences)\n        };\n    }\n\n    /// <summary>\n    /// Final step in email update change. Given a confirmation token and the email, this will finish the email change.\n    /// </summary>\n    /// <remarks>This will force connected clients to re-authenticate</remarks>\n    /// <param name=\"dto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"confirm-email-update\")]\n    public async Task<ActionResult> ConfirmEmailUpdate(ConfirmEmailUpdateDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByConfirmationToken(dto.Token);\n        if (user == null)\n        {\n            _logger.LogInformation(\"confirm-email failed from invalid registered email: {Email}\", dto.Email);\n            return BadRequest(\"Invalid email confirmation\");\n        }\n\n        if (!await ConfirmEmailToken(dto.Token, user))\n        {\n            _logger.LogInformation(\"confirm-email failed from invalid token: {Token}\", dto.Token);\n            return BadRequest(\"Invalid email confirmation\");\n        }\n\n        _logger.LogInformation(\"User is updating email from {OldEmail} to {NewEmail}\", user.Email, dto.Email);\n        var result = await _userManager.SetEmailAsync(user, dto.Email);\n        if (!result.Succeeded)\n        {\n            _logger.LogError(\"Unable to update email for users: {Errors}\", result.Errors.Select(e => e.Description));\n            return BadRequest(\"Unable to update email for user. Check logs\");\n        }\n        user.ConfirmationToken = null;\n        await _unitOfWork.CommitAsync();\n\n\n        // For the user's connected devices to pull the new information in\n        await _eventHub.SendMessageToAsync(MessageFactory.UserUpdate,\n            MessageFactory.UserUpdateEvent(user.Id, user.UserName), user.Id);\n\n        // Perform Login code\n        return Ok();\n    }\n\n    [AllowAnonymous]\n    [HttpPost(\"confirm-password-reset\")]\n    public async Task<ActionResult<string>> ConfirmForgotPassword(ConfirmPasswordResetDto dto)\n    {\n        try\n        {\n            var user = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n            if (user == null)\n            {\n                return BadRequest(\"Invalid credentials\");\n            }\n\n            var result = await _userManager.VerifyUserTokenAsync(user, TokenOptions.DefaultProvider,\n                \"ResetPassword\", dto.Token);\n            if (!result)\n            {\n                _logger.LogInformation(\"Unable to reset password, your email token is not correct: {@Dto}\", dto);\n                return BadRequest(\"Invalid credentials\");\n            }\n\n            var errors = await _accountService.ChangeUserPassword(user, dto.Password);\n            return errors.Any() ? BadRequest(errors) : Ok(\"Password updated\");\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an unexpected error when confirming new password\");\n            return BadRequest(\"There was an unexpected error when confirming new password\");\n        }\n    }\n\n\n    /// <summary>\n    /// Will send user a link to update their password to their email or prompt them if not accessible\n    /// </summary>\n    /// <param name=\"email\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"forgot-password\")]\n    public async Task<ActionResult<string>> ForgotPassword([FromQuery] string email)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByEmailAsync(email);\n        if (user == null)\n        {\n            _logger.LogError(\"There are no users with email: {Email} but user is requesting password reset\", email);\n            return Ok(\"An email will be sent to the email if it exists in our database\");\n        }\n\n        var roles = await _userManager.GetRolesAsync(user);\n        if (!roles.Any(r => r is PolicyConstants.AdminRole or PolicyConstants.ChangePasswordRole))\n            return Unauthorized(\"You are not permitted to this operation.\");\n\n        if (string.IsNullOrEmpty(user.Email) || !user.EmailConfirmed)\n            return BadRequest(\"You do not have an email on account or it has not been confirmed\");\n\n        var token = await _userManager.GeneratePasswordResetTokenAsync(user);\n        var emailLink = GenerateEmailLink(token, \"confirm-reset-password\", user.Email);\n        _logger.LogCritical(\"[Forgot Password]: Email Link for {UserName}: {Link}\", user.UserName, emailLink);\n        var host = _environment.IsDevelopment() ? \"localhost:4200\" : Request.Host.ToString();\n        if (await _emailService.CheckIfAccessible(host))\n        {\n            await _emailService.SendPasswordResetEmail(new PasswordResetEmailDto()\n            {\n                EmailAddress = user.Email,\n                ServerConfirmationLink = emailLink,\n                InstallId = (await _unitOfWork.SettingsRepository.GetSettingAsync(ServerSettingKey.InstallId)).Value\n            });\n            return Ok(\"Email sent\");\n        }\n\n        return Ok(\"Your server is not accessible. The Link to reset your password is in the logs.\");\n    }\n\n    [HttpGet(\"email-confirmed\")]\n    public async Task<ActionResult<bool>> IsEmailConfirmed()\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername());\n        if (user == null) return Unauthorized();\n\n        return Ok(user.EmailConfirmed);\n    }\n\n    [AllowAnonymous]\n    [HttpPost(\"confirm-migration-email\")]\n    public async Task<ActionResult<UserDto>> ConfirmMigrationEmail(ConfirmMigrationEmailDto dto)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n        if (user == null) return BadRequest(\"Invalid credentials\");\n\n        if (!await ConfirmEmailToken(dto.Token, user))\n        {\n            _logger.LogInformation(\"confirm-migration-email email token is invalid\");\n            return BadRequest(\"Invalid credentials\");\n        }\n\n        await _unitOfWork.CommitAsync();\n\n        user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(user.UserName,\n            AppUserIncludes.UserPreferences);\n\n        // Perform Login code\n        return new UserDto\n        {\n            Username = user.UserName,\n            Email = user.Email,\n            Token = await _tokenService.CreateToken(user),\n            RefreshToken = await _tokenService.CreateRefreshToken(user),\n            ApiKey = user.ApiKey,\n            Preferences = _mapper.Map<UserPreferencesDto>(user.UserPreferences)\n        };\n    }\n\n    [HttpPost(\"resend-confirmation-email\")]\n    public async Task<ActionResult<string>> ResendConfirmationSendEmail([FromQuery] int userId)\n    {\n        var user = await _unitOfWork.UserRepository.GetUserByIdAsync(userId);\n        if (user == null) return BadRequest(\"User does not exist\");\n\n        if (string.IsNullOrEmpty(user.Email))\n            return BadRequest(\n                \"This user needs to migrate. Have them log out and login to trigger a migration flow\");\n        if (user.EmailConfirmed) return BadRequest(\"User already confirmed\");\n\n        var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n        var emailLink = GenerateEmailLink(token, \"confirm-email\", user.Email);\n        _logger.LogCritical(\"[Email Migration]: Email Link: {Link}\", emailLink);\n        _logger.LogCritical(\"[Email Migration]: Token {UserName}: {Token}\", user.UserName, token);\n        await _emailService.SendMigrationEmail(new EmailMigrationDto()\n        {\n            EmailAddress = user.Email,\n            Username = user.UserName,\n            ServerConfirmationLink = emailLink,\n            InstallId = (await _unitOfWork.SettingsRepository.GetSettingAsync(ServerSettingKey.InstallId)).Value\n        });\n\n\n        return Ok(emailLink);\n    }\n\n    private string GenerateEmailLink(string token, string routePart, string email, bool withHost = true)\n    {\n        var host = _environment.IsDevelopment() ? \"localhost:4200\" : Request.Host.ToString();\n        if (withHost) return $\"{Request.Scheme}://{host}{Request.PathBase}/registration/{routePart}?token={HttpUtility.UrlEncode(token)}&email={HttpUtility.UrlEncode(email)}\";\n        return $\"registration/{routePart}?token={HttpUtility.UrlEncode(token)}&email={HttpUtility.UrlEncode(email)}\";\n    }\n\n    /// <summary>\n    /// This is similar to invite. Essentially we authenticate the user's password then go through invite email flow\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    /// <returns></returns>\n    [AllowAnonymous]\n    [HttpPost(\"migrate-email\")]\n    public async Task<ActionResult<string>> MigrateEmail(MigrateUserEmailDto dto)\n    {\n        // If there is an admin account already, return\n        var users = await _unitOfWork.UserRepository.GetAdminUsersAsync();\n        if (users.Any()) return BadRequest(\"Admin already exists\");\n\n        // Check if there is an existing invite\n        var emailValidationErrors = await _accountService.ValidateEmail(dto.Email);\n        if (emailValidationErrors.Any())\n        {\n            var invitedUser = await _unitOfWork.UserRepository.GetUserByEmailAsync(dto.Email);\n            if (await _userManager.IsEmailConfirmedAsync(invitedUser))\n                return BadRequest($\"User is already registered as {invitedUser.UserName}\");\n\n            _logger.LogInformation(\"A user is attempting to login, but hasn't accepted email invite\");\n            return BadRequest(\"User is already invited under this email and has yet to accepted invite.\");\n        }\n\n\n        var user = await _userManager.Users\n            .Include(u => u.UserPreferences)\n            .SingleOrDefaultAsync(x => x.NormalizedUserName == dto.Username.ToUpper());\n        if (user == null) return BadRequest(\"Invalid username\");\n\n        var validPassword = await _signInManager.UserManager.CheckPasswordAsync(user, dto.Password);\n        if (!validPassword) return BadRequest(\"Your credentials are not correct\");\n\n        try\n        {\n            var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n\n            user.Email = dto.Email;\n            if (!await ConfirmEmailToken(token, user)) return BadRequest(\"There was a critical error during migration\");\n            _unitOfWork.UserRepository.Update(user);\n\n            await _unitOfWork.CommitAsync();\n\n            return Ok();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"There was an issue during email migration. Contact support\");\n            _unitOfWork.UserRepository.Delete(user);\n            await _unitOfWork.CommitAsync();\n        }\n\n        return BadRequest(\"There was an error setting up your account. Please check the logs\");\n    }\n\n    private async Task<bool> ConfirmEmailToken(string token, AppUser user)\n    {\n        var result = await _userManager.ConfirmEmailAsync(user, token);\n        if (result.Succeeded) return true;\n\n\n\n        _logger.LogCritical(\"[Account] Email validation failed\");\n        if (!result.Errors.Any()) return false;\n\n        foreach (var error in result.Errors)\n        {\n            _logger.LogCritical(\"[Account] Email validation error: {Message}\", error.Description);\n        }\n\n        return false;\n\n    }\n}\n"], "filenames": ["API/Controllers/AccountController.cs"], "buggy_code_start_loc": [189], "buggy_code_end_loc": [867], "fixing_code_start_loc": [189], "fixing_code_end_loc": [894], "type": "CWE-307", "message": "Improper Restriction of Excessive Authentication Attempts in GitHub repository kareadita/kavita prior to 0.6.0.3.", "other": {"cve": {"id": "CVE-2022-3945", "sourceIdentifier": "security@huntr.dev", "published": "2022-11-11T12:15:08.827", "lastModified": "2022-11-16T15:34:39.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Restriction of Excessive Authentication Attempts in GitHub repository kareadita/kavita prior to 0.6.0.3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 9.4, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-307"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-307"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kavitareader:kavita:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.0.3", "matchCriteriaId": "D35423D3-909E-4EB6-B687-300019FCE10B"}]}]}], "references": [{"url": "https://github.com/kareadita/kavita/commit/f8db37d3f9aa42d47e7c4f4ca839e892d3f97afb", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/55cd91b3-1d94-4d34-8d7f-86660b41fd65", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kareadita/kavita/commit/f8db37d3f9aa42d47e7c4f4ca839e892d3f97afb"}}