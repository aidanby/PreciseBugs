{"buggy_code": ["package controller\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\t\"github.com/answerdev/answer/internal/service/uploader\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// UserController user controller\ntype UserController struct {\n\tuserService           *service.UserService\n\tauthService           *auth.AuthService\n\tactionService         *action.CaptchaService\n\tuploaderService       *uploader.UploaderService\n\temailService          *export.EmailService\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService\n}\n\n// NewUserController new controller\nfunc NewUserController(\n\tauthService *auth.AuthService,\n\tuserService *service.UserService,\n\tactionService *action.CaptchaService,\n\temailService *export.EmailService,\n\tuploaderService *uploader.UploaderService,\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService,\n) *UserController {\n\treturn &UserController{\n\t\tauthService:           authService,\n\t\tuserService:           userService,\n\t\tactionService:         actionService,\n\t\tuploaderService:       uploaderService,\n\t\temailService:          emailService,\n\t\tsiteInfoCommonService: siteInfoCommonService,\n\t}\n}\n\n// GetUserInfoByUserID get user info, if user no login response http code is 200, but user info is null\n// @Summary GetUserInfoByUserID\n// @Description get user info, if user no login response http code is 200, but user info is null\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.GetUserToSetShowResp}\n// @Router /answer/api/v1/user/info [get]\nfunc (uc *UserController) GetUserInfoByUserID(ctx *gin.Context) {\n\ttoken := middleware.ExtractToken(ctx)\n\tif len(token) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\t// if user is no login return null in data\n\tuserInfo, _ := uc.authService.GetUserCacheInfo(ctx, token)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetUserInfoByUserID(ctx, token, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// GetOtherUserInfoByUsername godoc\n// @Summary GetOtherUserInfoByUsername\n// @Description GetOtherUserInfoByUsername\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param username query string true \"username\"\n// @Success 200 {object} handler.RespBody{data=schema.GetOtherUserInfoResp}\n// @Router /answer/api/v1/personal/user/info [get]\nfunc (uc *UserController) GetOtherUserInfoByUsername(ctx *gin.Context) {\n\treq := &schema.GetOtherUserInfoByUsernameReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetOtherUserInfoByUsername(ctx, req.Username)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserEmailLogin godoc\n// @Summary UserEmailLogin\n// @Description UserEmailLogin\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserEmailLogin true \"UserEmailLogin\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/login/email [post]\nfunc (uc *UserController) UserEmailLogin(ctx *gin.Context) {\n\treq := &schema.UserEmailLogin{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.EmailLogin(ctx, req)\n\tif err != nil {\n\t\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.EmailOrPasswordWrong),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.EmailOrPasswordWrong), errFields)\n\t\treturn\n\t}\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\thandler.HandleResponse(ctx, nil, resp)\n}\n\n// RetrievePassWord godoc\n// @Summary RetrievePassWord\n// @Description RetrievePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRetrievePassWordRequest  true \"UserRetrievePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/reset [post]\nfunc (uc *UserController) RetrievePassWord(ctx *gin.Context) {\n\treq := &schema.UserRetrievePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\terr := uc.userService.RetrievePassWord(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UseRePassWord godoc\n// @Summary UseRePassWord\n// @Description UseRePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRePassWordRequest  true \"UserRePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/replacement [post]\nfunc (uc *UserController) UseRePassWord(ctx *gin.Context) {\n\treq := &schema.UserRePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UseRePassword(ctx, req)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserLogout user logout\n// @Summary user logout\n// @Description user logout\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/logout [get]\nfunc (uc *UserController) UserLogout(ctx *gin.Context) {\n\taccessToken := middleware.ExtractToken(ctx)\n\tif len(accessToken) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\t_ = uc.authService.RemoveUserCacheInfo(ctx, accessToken)\n\t_ = uc.authService.RemoveAdminUserCacheInfo(ctx, accessToken)\n\thandler.HandleResponse(ctx, nil, nil)\n}\n\n// UserRegisterByEmail godoc\n// @Summary UserRegisterByEmail\n// @Description UserRegisterByEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserRegisterReq true \"UserRegisterReq\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/email [post]\nfunc (uc *UserController) UserRegisterByEmail(ctx *gin.Context) {\n\t// check whether site allow register or not\n\tsiteInfo, err := uc.siteInfoCommonService.GetSiteLogin(ctx)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !siteInfo.AllowNewRegistrations {\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NotAllowedRegistration), nil)\n\t\treturn\n\t}\n\n\treq := &schema.UserRegisterReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\tcaptchaPass := uc.actionService.UserRegisterVerifyCaptcha(ctx, req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, errFields, err := uc.userService.UserRegisterByEmail(ctx, req)\n\tif len(errFields) > 0 {\n\t\tfor _, field := range errFields {\n\t\t\tfield.ErrorMsg = translator.\n\t\t\t\tTr(handler.GetLang(ctx), field.ErrorMsg)\n\t\t}\n\t\thandler.HandleResponse(ctx, err, errFields)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// UserVerifyEmail godoc\n// @Summary UserVerifyEmail\n// @Description UserVerifyEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param code query string true \"code\" default()\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/email/verification [post]\nfunc (uc *UserController) UserVerifyEmail(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UserVerifyEmail(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserVerifyEmailSend godoc\n// @Summary UserVerifyEmailSend\n// @Description UserVerifyEmailSend\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param captcha_id query string false \"captcha_id\"  default()\n// @Param captcha_code query string false \"captcha_code\"  default()\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/email/verification/send [post]\nfunc (uc *UserController) UserVerifyEmailSend(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailSendReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tuserInfo := middleware.GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(),\n\t\treq.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, err := uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\terr = uc.userService.UserVerifyEmailSend(ctx, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserModifyPassWord godoc\n// @Summary UserModifyPassWord\n// @Description UserModifyPassWord\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserModifyPassWordRequest  true \"UserModifyPassWordRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/password [put]\nfunc (uc *UserController) UserModifyPassWord(ctx *gin.Context) {\n\treq := &schema.UserModifyPassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\n\toldPassVerification, err := uc.userService.UserModifyPassWordVerification(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !oldPassVerification {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"old_pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.OldPasswordVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.OldPasswordVerificationFailed), errFields)\n\t\treturn\n\t}\n\tif req.OldPass == req.Pass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.NewPasswordSameAsPreviousSetting),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NewPasswordSameAsPreviousSetting), errFields)\n\t\treturn\n\t}\n\terr = uc.userService.UserModifyPassword(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserUpdateInfo update user info\n// @Summary UserUpdateInfo update user info\n// @Description UserUpdateInfo update user info\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateInfoRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/info [put]\nfunc (uc *UserController) UserUpdateInfo(ctx *gin.Context) {\n\treq := &schema.UpdateInfoRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\terrFields, err := uc.userService.UpdateInfo(ctx, req)\n\tfor _, field := range errFields {\n\t\tfield.ErrorMsg = translator.Tr(handler.GetLang(ctx), field.ErrorMsg)\n\t}\n\thandler.HandleResponse(ctx, err, errFields)\n}\n\n// UserUpdateInterface update user interface config\n// @Summary UserUpdateInterface update user interface config\n// @Description UserUpdateInterface update user interface config\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateUserInterfaceRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/interface [put]\nfunc (uc *UserController) UserUpdateInterface(ctx *gin.Context) {\n\treq := &schema.UpdateUserInterfaceRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserId = middleware.GetLoginUserIDFromContext(ctx)\n\terr := uc.userService.UserUpdateInterface(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// ActionRecord godoc\n// @Summary ActionRecord\n// @Description ActionRecord\n// @Tags User\n// @Param action query string true \"action\" Enums(login, e_mail, find_pass)\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.ActionRecordResp}\n// @Router /answer/api/v1/user/action/record [get]\nfunc (uc *UserController) ActionRecord(ctx *gin.Context) {\n\treq := &schema.ActionRecordReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\n\tresp, err := uc.actionService.ActionRecord(ctx, req)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserRegisterCaptcha godoc\n// @Summary UserRegisterCaptcha\n// @Description UserRegisterCaptcha\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/captcha [get]\nfunc (uc *UserController) UserRegisterCaptcha(ctx *gin.Context) {\n\tresp, err := uc.actionService.UserRegisterCaptcha(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserNoticeSet godoc\n// @Summary UserNoticeSet\n// @Description UserNoticeSet\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserNoticeSetRequest true \"UserNoticeSetRequest\"\n// @Success 200 {object} handler.RespBody{data=schema.UserNoticeSetResp}\n// @Router /answer/api/v1/user/notice/set [post]\nfunc (uc *UserController) UserNoticeSet(ctx *gin.Context) {\n\treq := &schema.UserNoticeSetRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tresp, err := uc.userService.UserNoticeSet(ctx, req.UserID, req.NoticeSwitch)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserChangeEmailSendCode send email to the user email then change their email\n// @Summary send email to the user email then change their email\n// @Description send email to the user email then change their email\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserChangeEmailSendCodeReq true \"UserChangeEmailSendCodeReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/change/code [post]\nfunc (uc *UserController) UserChangeEmailSendCode(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailSendCodeReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\t// If the user is not logged in, the api cannot be used.\n\t// If the user email is not verified, that also can use this api to modify the email.\n\tif len(req.UserID) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tresp, err := uc.userService.UserChangeEmailSendCode(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t\treturn\n\t}\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserChangeEmailVerify user change email verification\n// @Summary user change email verification\n// @Description user change email verification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserChangeEmailVerifyReq true \"UserChangeEmailVerifyReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email [put]\nfunc (uc *UserController) UserChangeEmailVerify(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailVerifyReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UserChangeEmailVerify(ctx, req.Content)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserRanking get user ranking\n// @Summary get user ranking\n// @Description get user ranking\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.UserRankingResp}\n// @Router /answer/api/v1/user/ranking [get]\nfunc (uc *UserController) UserRanking(ctx *gin.Context) {\n\tresp, err := uc.userService.UserRanking(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserUnsubscribeEmailNotification unsubscribe email notification\n// @Summary unsubscribe email notification\n// @Description unsubscribe email notification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/notification [put]\nfunc (uc *UserController) UserUnsubscribeEmailNotification(ctx *gin.Context) {\n\treq := &schema.UserUnsubscribeEmailNotificationReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserUnsubscribeEmailNotification(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n", "package auth\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// authRepo auth repository\ntype authRepo struct {\n\tdata *data.Data\n}\n\n// GetUserCacheInfo get user cache info\nfunc (ar *authRepo) GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {\n\tuserInfoCache, err := ar.data.Cache.GetString(ctx, constant.UserTokenCacheKey+accessToken)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tuserInfo = &entity.UserCacheInfo{}\n\terr = json.Unmarshal([]byte(userInfoCache), userInfo)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn userInfo, nil\n}\n\n// SetUserCacheInfo set user cache info\nfunc (ar *authRepo) SetUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {\n\tuserInfoCache, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = ar.data.Cache.SetString(ctx, constant.UserTokenCacheKey+accessToken,\n\t\tstring(userInfoCache), constant.UserTokenCacheTime)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif err := ar.AddUserTokenMapping(ctx, userInfo.UserID, accessToken); err != nil {\n\t\tlog.Error(err)\n\t}\n\treturn nil\n}\n\n// RemoveUserCacheInfo remove user cache info\nfunc (ar *authRepo) RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error) {\n\terr = ar.data.Cache.Del(ctx, constant.UserTokenCacheKey+accessToken)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// SetUserStatus set user status\nfunc (ar *authRepo) SetUserStatus(ctx context.Context, userID string, userInfo *entity.UserCacheInfo) (err error) {\n\tuserInfoCache, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = ar.data.Cache.SetString(ctx, constant.UserStatusChangedCacheKey+userID,\n\t\tstring(userInfoCache), constant.UserStatusChangedCacheTime)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// GetUserStatus get user status\nfunc (ar *authRepo) GetUserStatus(ctx context.Context, userID string) (userInfo *entity.UserCacheInfo, err error) {\n\tuserInfoCache, err := ar.data.Cache.GetString(ctx, constant.UserStatusChangedCacheKey+userID)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tuserInfo = &entity.UserCacheInfo{}\n\terr = json.Unmarshal([]byte(userInfoCache), userInfo)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn userInfo, nil\n}\n\n// RemoveUserStatus remove user status\nfunc (ar *authRepo) RemoveUserStatus(ctx context.Context, userID string) (err error) {\n\terr = ar.data.Cache.Del(ctx, constant.UserStatusChangedCacheKey+userID)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// GetAdminUserCacheInfo get admin user cache info\nfunc (ar *authRepo) GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {\n\tuserInfoCache, err := ar.data.Cache.GetString(ctx, constant.AdminTokenCacheKey+accessToken)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn\n\t}\n\tuserInfo = &entity.UserCacheInfo{}\n\terr = json.Unmarshal([]byte(userInfoCache), userInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn userInfo, nil\n}\n\n// SetAdminUserCacheInfo set admin user cache info\nfunc (ar *authRepo) SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {\n\tuserInfoCache, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ar.data.Cache.SetString(ctx, constant.AdminTokenCacheKey+accessToken, string(userInfoCache),\n\t\tconstant.AdminTokenCacheTime)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// RemoveAdminUserCacheInfo remove admin user cache info\nfunc (ar *authRepo) RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error) {\n\terr = ar.data.Cache.Del(ctx, constant.AdminTokenCacheKey+accessToken)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// AddUserTokenMapping add user token mapping\nfunc (ar *authRepo) AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error) {\n\tkey := constant.UserTokenMappingCacheKey + userID\n\tresp, _ := ar.data.Cache.GetString(ctx, key)\n\tmapping := make(map[string]bool, 0)\n\tif len(resp) > 0 {\n\t\t_ = json.Unmarshal([]byte(resp), &mapping)\n\t}\n\tmapping[accessToken] = true\n\tcontent, _ := json.Marshal(mapping)\n\treturn ar.data.Cache.SetString(ctx, key, string(content), constant.UserTokenCacheTime)\n}\n\n// RemoveUserTokens Log out all users under this user id\nfunc (ar *authRepo) RemoveUserTokens(ctx context.Context, userID string) {\n\tkey := constant.UserTokenMappingCacheKey + userID\n\tresp, _ := ar.data.Cache.GetString(ctx, key)\n\tmapping := make(map[string]bool, 0)\n\tif len(resp) > 0 {\n\t\t_ = json.Unmarshal([]byte(resp), &mapping)\n\t\tlog.Debugf(\"find %d user tokens by user id %s\", len(mapping), userID)\n\t}\n\n\tfor token := range mapping {\n\t\tif err := ar.RemoveUserCacheInfo(ctx, token); err != nil {\n\t\t\tlog.Error(err)\n\t\t} else {\n\t\t\tlog.Debugf(\"del user %s token success\")\n\t\t}\n\t}\n\tif err := ar.RemoveUserStatus(ctx, userID); err != nil {\n\t\tlog.Error(err)\n\t}\n\tif err := ar.data.Cache.Del(ctx, key); err != nil {\n\t\tlog.Error(err)\n\t}\n}\n\n// NewAuthRepo new repository\nfunc NewAuthRepo(data *data.Data) auth.AuthRepo {\n\treturn &authRepo{\n\t\tdata: data,\n\t}\n}\n", "package schema\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/answerdev/answer/pkg/gravatar\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// UserVerifyEmailReq user verify email request\ntype UserVerifyEmailReq struct {\n\t// code\n\tCode string `validate:\"required,gt=0,lte=500\" form:\"code\"`\n\t// content\n\tContent string `json:\"-\"`\n}\n\n// GetUserResp get user response\ntype GetUserResp struct {\n\t// user id\n\tID string `json:\"id\"`\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// last login date\n\tLastLoginDate int64 `json:\"last_login_date\"`\n\t// username\n\tUsername string `json:\"username\"`\n\t// email\n\tEMail string `json:\"e_mail\"`\n\t// mail status(1 pass 2 to be verified)\n\tMailStatus int `json:\"mail_status\"`\n\t// notice status(1 on 2off)\n\tNoticeStatus int `json:\"notice_status\"`\n\t// follow count\n\tFollowCount int `json:\"follow_count\"`\n\t// answer count\n\tAnswerCount int `json:\"answer_count\"`\n\t// question count\n\tQuestionCount int `json:\"question_count\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// authority group\n\tAuthorityGroup int `json:\"authority_group\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n\t// mobile\n\tMobile string `json:\"mobile\"`\n\t// bio markdown\n\tBio string `json:\"bio\"`\n\t// bio html\n\tBioHTML string `json:\"bio_html\"`\n\t// website\n\tWebsite string `json:\"website\"`\n\t// location\n\tLocation string `json:\"location\"`\n\t// ip info\n\tIPInfo string `json:\"ip_info\"`\n\t// language\n\tLanguage string `json:\"language\"`\n\t// access token\n\tAccessToken string `json:\"access_token\"`\n\t// role id\n\tRoleID int `json:\"role_id\"`\n\t// user status\n\tStatus string `json:\"status\"`\n}\n\nfunc (r *GetUserResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tr.Avatar = FormatAvatarInfo(userInfo.Avatar, userInfo.EMail)\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n}\n\ntype GetUserToSetShowResp struct {\n\t*GetUserResp\n\tAvatar *AvatarInfo `json:\"avatar\"`\n}\n\nfunc (r *GetUserToSetShowResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n\tavatarInfo := &AvatarInfo{}\n\t_ = json.Unmarshal([]byte(userInfo.Avatar), avatarInfo)\n\tif constant.DefaultAvatar == \"gravatar\" && avatarInfo.Type == \"\" {\n\t\tavatarInfo.Type = \"gravatar\"\n\t\tavatarInfo.Gravatar = gravatar.GetAvatarURL(userInfo.EMail)\n\t}\n\t// if json.Unmarshal Error avatarInfo.Type is Empty\n\tr.Avatar = avatarInfo\n}\n\nfunc FormatAvatarInfo(avatarJson, email string) (res string) {\n\tdefer func() {\n\t\tif constant.DefaultAvatar == \"gravatar\" && len(res) == 0 {\n\t\t\tres = gravatar.GetAvatarURL(email)\n\t\t}\n\t}()\n\n\tif avatarJson == \"\" {\n\t\treturn \"\"\n\t}\n\tavatarInfo := &AvatarInfo{}\n\terr := json.Unmarshal([]byte(avatarJson), avatarInfo)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tswitch avatarInfo.Type {\n\tcase \"gravatar\":\n\t\treturn avatarInfo.Gravatar\n\tcase \"custom\":\n\t\treturn avatarInfo.Custom\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\n// GetUserStatusResp get user status info\ntype GetUserStatusResp struct {\n\t// user status\n\tStatus string `json:\"status\"`\n}\n\n// GetOtherUserInfoByUsernameResp get user response\ntype GetOtherUserInfoByUsernameResp struct {\n\t// user id\n\tID string `json:\"id\"`\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// last login date\n\tLastLoginDate int64 `json:\"last_login_date\"`\n\t// username\n\tUsername string `json:\"username\"`\n\t// email\n\t// follow count\n\tFollowCount int `json:\"follow_count\"`\n\t// answer count\n\tAnswerCount int `json:\"answer_count\"`\n\t// question count\n\tQuestionCount int `json:\"question_count\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n\t// mobile\n\tMobile string `json:\"mobile\"`\n\t// bio markdown\n\tBio string `json:\"bio\"`\n\t// bio html\n\tBioHTML string `json:\"bio_html\"`\n\t// website\n\tWebsite string `json:\"website\"`\n\t// location\n\tLocation  string `json:\"location\"`\n\tStatus    string `json:\"status\"`\n\tStatusMsg string `json:\"status_msg,omitempty\"`\n}\n\nfunc (r *GetOtherUserInfoByUsernameResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tAvatar := FormatAvatarInfo(userInfo.Avatar, userInfo.EMail)\n\tr.Avatar = Avatar\n\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n\tif userInfo.MailStatus == entity.EmailStatusToBeVerified {\n\t\tstatusMsgShow, ok := UserStatusShowMsg[11]\n\t\tif ok {\n\t\t\tr.StatusMsg = statusMsgShow\n\t\t}\n\t} else {\n\t\tstatusMsgShow, ok := UserStatusShowMsg[userInfo.Status]\n\t\tif ok {\n\t\t\tr.StatusMsg = statusMsgShow\n\t\t}\n\t}\n}\n\nconst (\n\tMailStatePass   = 1\n\tMailStateVerifi = 2\n\n\tNoticeStatusOn  = 1\n\tNoticeStatusOff = 2\n\n\tActionRecordTypeLogin    = \"login\"\n\tActionRecordTypeEmail    = \"e_mail\"\n\tActionRecordTypeFindPass = \"find_pass\"\n)\n\nvar UserStatusShow = map[int]string{\n\t1:  \"normal\",\n\t9:  \"forbidden\",\n\t10: \"deleted\",\n}\n\nvar UserStatusShowMsg = map[int]string{\n\t1:  \"\",\n\t9:  \"<strong>This user was suspended forever.</strong> This user doesn\u2019t meet a community guideline.\",\n\t10: \"This user was deleted.\",\n\t11: \"This user is inactive.\",\n}\n\n// EmailLogin\ntype UserEmailLogin struct {\n\tEmail       string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\"` // e_mail\n\tPass        string `validate:\"required,gte=8,lte=32\" json:\"pass\"`         // password\n\tCaptchaID   string `json:\"captcha_id\"`                                    // captcha_id\n\tCaptchaCode string `json:\"captcha_code\"`                                  // captcha_code\n}\n\n// UserRegisterReq user register request\ntype UserRegisterReq struct {\n\t// name\n\tName string `validate:\"required,gt=3,lte=30\" json:\"name\"`\n\t// email\n\tEmail string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\" `\n\t// password\n\tPass        string `validate:\"required,gte=8,lte=32\" json:\"pass\"`\n\tIP          string `json:\"-\" `\n\tCaptchaID   string `json:\"captcha_id\"`   // captcha_id\n\tCaptchaCode string `json:\"captcha_code\"` // captcha_code\n}\n\nfunc (u *UserRegisterReq) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\n// UserModifyPassWordRequest\ntype UserModifyPassWordRequest struct {\n\tUserID  string `json:\"-\" `        // user_id\n\tOldPass string `json:\"old_pass\" ` // old password\n\tPass    string `json:\"pass\" `     // password\n}\n\nfunc (u *UserModifyPassWordRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\ntype UpdateInfoRequest struct {\n\t// display_name\n\tDisplayName string `validate:\"required,gt=0,lte=30\" json:\"display_name\"`\n\t// username\n\tUsername string `validate:\"omitempty,gt=3,lte=30\" json:\"username\"`\n\t// avatar\n\tAvatar AvatarInfo `json:\"avatar\"`\n\t// bio\n\tBio string `validate:\"omitempty,gt=0,lte=4096\" json:\"bio\"`\n\t// bio\n\tBioHTML string `json:\"-\"`\n\t// website\n\tWebsite string `validate:\"omitempty,gt=0,lte=500\" json:\"website\"`\n\t// location\n\tLocation string `validate:\"omitempty,gt=0,lte=100\" json:\"location\"`\n\t// user id\n\tUserID string `json:\"-\" `\n}\n\ntype AvatarInfo struct {\n\tType     string `validate:\"omitempty,gt=0,lte=100\"  json:\"type\"`\n\tGravatar string `validate:\"omitempty,gt=0,lte=200\"  json:\"gravatar\"`\n\tCustom   string `validate:\"omitempty,gt=0,lte=200\"  json:\"custom\"`\n}\n\nfunc (req *UpdateInfoRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\tif len(req.Username) > 0 {\n\t\tif checker.IsInvalidUsername(req.Username) {\n\t\t\terrField := &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t\t}\n\t\t\terrFields = append(errFields, errField)\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t\t}\n\t}\n\treq.BioHTML = converter.Markdown2BasicHTML(req.Bio)\n\treturn nil, nil\n}\n\n// UpdateUserInterfaceRequest update user interface request\ntype UpdateUserInterfaceRequest struct {\n\t// language\n\tLanguage string `validate:\"required,gt=1,lte=100\" json:\"language\"`\n\t// user id\n\tUserId string `json:\"-\" `\n}\n\ntype UserRetrievePassWordRequest struct {\n\tEmail       string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\" ` // e_mail\n\tCaptchaID   string `json:\"captcha_id\" `                                    // captcha_id\n\tCaptchaCode string `json:\"captcha_code\" `                                  // captcha_code\n}\n\ntype UserRePassWordRequest struct {\n\tCode    string `validate:\"required,gt=0,lte=100\" json:\"code\" ` // code\n\tPass    string `validate:\"required,gt=0,lte=32\" json:\"pass\" `  // Password\n\tContent string `json:\"-\"`\n}\n\nfunc (u *UserRePassWordRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\ntype UserNoticeSetRequest struct {\n\tNoticeSwitch bool   `json:\"notice_switch\"`\n\tUserID       string `json:\"-\"`\n}\n\ntype UserNoticeSetResp struct {\n\tNoticeSwitch bool `json:\"notice_switch\"`\n}\n\ntype ActionRecordReq struct {\n\t// action\n\tAction string `validate:\"required,oneof=login e_mail find_pass\" form:\"action\"`\n\tIP     string `json:\"-\"`\n}\n\ntype ActionRecordResp struct {\n\tCaptchaID  string `json:\"captcha_id\"`\n\tCaptchaImg string `json:\"captcha_img\"`\n\tVerify     bool   `json:\"verify\"`\n}\n\ntype UserBasicInfo struct {\n\tID          string `json:\"id\"`           // user_id\n\tUsername    string `json:\"username\" `    // name\n\tRank        int    `json:\"rank\" `        // rank\n\tDisplayName string `json:\"display_name\"` // display_name\n\tAvatar      string `json:\"avatar\" `      // avatar\n\tWebsite     string `json:\"website\" `     // website\n\tLocation    string `json:\"location\" `    // location\n\tIPInfo      string `json:\"ip_info\"`      // ip info\n\tStatus      string `json:\"status\"`       // status\n}\n\ntype GetOtherUserInfoByUsernameReq struct {\n\tUsername string `validate:\"required,gt=0,lte=500\" form:\"username\"`\n}\n\ntype GetOtherUserInfoResp struct {\n\tInfo *GetOtherUserInfoByUsernameResp `json:\"info\"`\n}\n\ntype UserChangeEmailSendCodeReq struct {\n\tUserVerifyEmailSendReq\n\tEmail  string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\"`\n\tPass   string `validate:\"omitempty,gte=8,lte=32\" json:\"pass\"`\n\tUserID string `json:\"-\"`\n}\n\ntype UserChangeEmailVerifyReq struct {\n\tCode    string `validate:\"required,gt=0,lte=500\" json:\"code\"`\n\tContent string `json:\"-\"`\n}\n\ntype UserVerifyEmailSendReq struct {\n\tCaptchaID   string `validate:\"omitempty,gt=0,lte=500\" json:\"captcha_id\"`\n\tCaptchaCode string `validate:\"omitempty,gt=0,lte=500\" json:\"captcha_code\"`\n}\n\n// UserRankingResp user ranking response\ntype UserRankingResp struct {\n\tUsersWithTheMostReputation []*UserRankingSimpleInfo `json:\"users_with_the_most_reputation\"`\n\tUsersWithTheMostVote       []*UserRankingSimpleInfo `json:\"users_with_the_most_vote\"`\n\tStaffs                     []*UserRankingSimpleInfo `json:\"staffs\"`\n}\n\n// UserRankingSimpleInfo user ranking simple info\ntype UserRankingSimpleInfo struct {\n\t// username\n\tUsername string `json:\"username\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// vote\n\tVoteCount int `json:\"vote_count\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n}\n\n// UserUnsubscribeEmailNotificationReq user unsubscribe email notification request\ntype UserUnsubscribeEmailNotificationReq struct {\n\tCode    string `validate:\"required,gt=0,lte=500\" json:\"code\"`\n\tContent string `json:\"-\"`\n}\n", "package auth\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/pkg/token\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// AuthRepo auth repository\ntype AuthRepo interface {\n\tGetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error)\n\tSetUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) error\n\tRemoveUserCacheInfo(ctx context.Context, accessToken string) (err error)\n\tSetUserStatus(ctx context.Context, userID string, userInfo *entity.UserCacheInfo) (err error)\n\tGetUserStatus(ctx context.Context, userID string) (userInfo *entity.UserCacheInfo, err error)\n\tRemoveUserStatus(ctx context.Context, userID string) (err error)\n\tGetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error)\n\tSetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) error\n\tRemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error)\n\tAddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error)\n\tRemoveUserTokens(ctx context.Context, userID string)\n}\n\n// AuthService kit service\ntype AuthService struct {\n\tauthRepo AuthRepo\n}\n\n// NewAuthService email service\nfunc NewAuthService(authRepo AuthRepo) *AuthService {\n\treturn &AuthService{\n\t\tauthRepo: authRepo,\n\t}\n}\n\nfunc (as *AuthService) GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {\n\tuserCacheInfo, err := as.authRepo.GetUserCacheInfo(ctx, accessToken)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcacheInfo, _ := as.authRepo.GetUserStatus(ctx, userCacheInfo.UserID)\n\tif cacheInfo != nil {\n\t\tlog.Debugf(\"user status updated: %+v\", cacheInfo)\n\t\tuserCacheInfo.UserStatus = cacheInfo.UserStatus\n\t\tuserCacheInfo.EmailStatus = cacheInfo.EmailStatus\n\t\tuserCacheInfo.RoleID = cacheInfo.RoleID\n\t\t// update current user cache info\n\t\terr := as.authRepo.SetUserCacheInfo(ctx, accessToken, userCacheInfo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn userCacheInfo, nil\n}\n\nfunc (as *AuthService) SetUserCacheInfo(ctx context.Context, userInfo *entity.UserCacheInfo) (accessToken string, err error) {\n\taccessToken = token.GenerateToken()\n\terr = as.authRepo.SetUserCacheInfo(ctx, accessToken, userInfo)\n\treturn accessToken, err\n}\n\nfunc (as *AuthService) SetUserStatus(ctx context.Context, userInfo *entity.UserCacheInfo) (err error) {\n\treturn as.authRepo.SetUserStatus(ctx, userInfo.UserID, userInfo)\n}\n\nfunc (as *AuthService) UpdateUserCacheInfo(ctx context.Context, token string, userInfo *entity.UserCacheInfo) (err error) {\n\terr = as.authRepo.SetUserCacheInfo(ctx, token, userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := as.authRepo.RemoveUserStatus(ctx, userInfo.UserID); err != nil {\n\t\tlog.Error(err)\n\t}\n\treturn\n}\n\nfunc (as *AuthService) RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error) {\n\treturn as.authRepo.RemoveUserCacheInfo(ctx, accessToken)\n}\n\n// AddUserTokenMapping add user token mapping\nfunc (as *AuthService) AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error) {\n\treturn as.authRepo.AddUserTokenMapping(ctx, userID, accessToken)\n}\n\n// RemoveUserTokens Log out all users under this user id\nfunc (as *AuthService) RemoveUserTokens(ctx context.Context, userID string) {\n\tas.authRepo.RemoveUserTokens(ctx, userID)\n}\n\n//Admin\n\nfunc (as *AuthService) GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {\n\treturn as.authRepo.GetAdminUserCacheInfo(ctx, accessToken)\n}\n\nfunc (as *AuthService) SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {\n\terr = as.authRepo.SetAdminUserCacheInfo(ctx, accessToken, userInfo)\n\treturn err\n}\n\nfunc (as *AuthService) RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error) {\n\treturn as.authRepo.RemoveAdminUserCacheInfo(ctx, accessToken)\n}\n", "package user_admin\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/mail\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// UserAdminRepo user repository\ntype UserAdminRepo interface {\n\tUpdateUserStatus(ctx context.Context, userID string, userStatus, mailStatus int, email string) (err error)\n\tGetUserInfo(ctx context.Context, userID string) (user *entity.User, exist bool, err error)\n\tGetUserInfoByEmail(ctx context.Context, email string) (user *entity.User, exist bool, err error)\n\tGetUserPage(ctx context.Context, page, pageSize int, user *entity.User,\n\t\tusernameOrDisplayName string, isStaff bool) (users []*entity.User, total int64, err error)\n\tAddUser(ctx context.Context, user *entity.User) (err error)\n\tUpdateUserPassword(ctx context.Context, userID string, password string) (err error)\n}\n\n// UserAdminService user service\ntype UserAdminService struct {\n\tuserRepo           UserAdminRepo\n\tuserRoleRelService *role.UserRoleRelService\n\tauthService        *auth.AuthService\n\tuserCommonService  *usercommon.UserCommon\n\tuserActivity       activity.UserActiveActivityRepo\n}\n\n// NewUserAdminService new user admin service\nfunc NewUserAdminService(\n\tuserRepo UserAdminRepo,\n\tuserRoleRelService *role.UserRoleRelService,\n\tauthService *auth.AuthService,\n\tuserCommonService *usercommon.UserCommon,\n\tuserActivity activity.UserActiveActivityRepo,\n) *UserAdminService {\n\treturn &UserAdminService{\n\t\tuserRepo:           userRepo,\n\t\tuserRoleRelService: userRoleRelService,\n\t\tauthService:        authService,\n\t\tuserCommonService:  userCommonService,\n\t\tuserActivity:       userActivity,\n\t}\n}\n\n// UpdateUserStatus update user\nfunc (us *UserAdminService) UpdateUserStatus(ctx context.Context, req *schema.UpdateUserStatusReq) (err error) {\n\t// Admin cannot modify their status\n\tif req.UserID == req.LoginUserID {\n\t\treturn errors.BadRequest(reason.AdminCannotModifySelfStatus)\n\t}\n\tuserInfo, exist, err := us.userRepo.GetUserInfo(ctx, req.UserID)\n\tif err != nil {\n\t\treturn\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\t// if user status is deleted\n\tif userInfo.Status == entity.UserStatusDeleted {\n\t\treturn nil\n\t}\n\n\tif req.IsInactive() {\n\t\tuserInfo.MailStatus = entity.EmailStatusToBeVerified\n\t}\n\tif req.IsDeleted() {\n\t\tuserInfo.Status = entity.UserStatusDeleted\n\t\tuserInfo.EMail = fmt.Sprintf(\"%s.%d\", userInfo.EMail, time.Now().UnixNano())\n\t}\n\tif req.IsSuspended() {\n\t\tuserInfo.Status = entity.UserStatusSuspended\n\t}\n\tif req.IsNormal() {\n\t\tuserInfo.Status = entity.UserStatusAvailable\n\t\tuserInfo.MailStatus = entity.EmailStatusAvailable\n\t}\n\n\terr = us.userRepo.UpdateUserStatus(ctx, userInfo.ID, userInfo.Status, userInfo.MailStatus, userInfo.EMail)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// if user reputation is zero means this user is inactive, so try to activate this user.\n\tif req.IsNormal() && userInfo.Rank == 0 {\n\t\treturn us.userActivity.UserActive(ctx, userInfo.ID)\n\t}\n\treturn nil\n}\n\n// UpdateUserRole update user role\nfunc (us *UserAdminService) UpdateUserRole(ctx context.Context, req *schema.UpdateUserRoleReq) (err error) {\n\t// Users cannot modify their roles\n\tif req.UserID == req.LoginUserID {\n\t\treturn errors.BadRequest(reason.UserCannotUpdateYourRole)\n\t}\n\n\terr = us.userRoleRelService.SaveUserRole(ctx, req.UserID, req.RoleID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tus.authService.RemoveUserTokens(ctx, req.UserID)\n\treturn\n}\n\n// AddUser add user\nfunc (us *UserAdminService) AddUser(ctx context.Context, req *schema.AddUserReq) (err error) {\n\t_, has, err := us.userRepo.GetUserInfoByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif has {\n\t\treturn errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\thashPwd, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tuserInfo := &entity.User{}\n\tuserInfo.EMail = req.Email\n\tuserInfo.DisplayName = req.DisplayName\n\tuserInfo.Pass = string(hashPwd)\n\n\tuserInfo.Username, err = us.userCommonService.MakeUsername(ctx, userInfo.DisplayName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tuserInfo.MailStatus = entity.EmailStatusAvailable\n\tuserInfo.Status = entity.UserStatusAvailable\n\tuserInfo.Rank = 1\n\n\terr = us.userRepo.AddUser(ctx, userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn\n}\n\n// UpdateUserPassword update user password\nfunc (us *UserAdminService) UpdateUserPassword(ctx context.Context, req *schema.UpdateUserPasswordReq) (err error) {\n\t// Users cannot modify their password\n\tif req.UserID == req.LoginUserID {\n\t\treturn errors.BadRequest(reason.AdminCannotUpdateTheirPassword)\n\t}\n\tuserInfo, exist, err := us.userRepo.GetUserInfo(ctx, req.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\n\thashPwd, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = us.userRepo.UpdateUserPassword(ctx, userInfo.ID, string(hashPwd))\n\tif err != nil {\n\t\treturn err\n\t}\n\t// logout this user\n\tus.authService.RemoveUserTokens(ctx, req.UserID)\n\treturn\n}\n\n// GetUserInfo get user one\nfunc (us *UserAdminService) GetUserInfo(ctx context.Context, userID string) (resp *schema.GetUserInfoResp, err error) {\n\tuser, exist, err := us.userRepo.GetUserInfo(ctx, userID)\n\tif err != nil {\n\t\treturn\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\n\tresp = &schema.GetUserInfoResp{}\n\t_ = copier.Copy(resp, user)\n\treturn resp, nil\n}\n\n// GetUserPage get user list page\nfunc (us *UserAdminService) GetUserPage(ctx context.Context, req *schema.GetUserPageReq) (pageModel *pager.PageModel, err error) {\n\tuser := &entity.User{}\n\t_ = copier.Copy(user, req)\n\n\tif req.IsInactive() {\n\t\tuser.MailStatus = entity.EmailStatusToBeVerified\n\t\tuser.Status = entity.UserStatusAvailable\n\t} else if req.IsSuspended() {\n\t\tuser.Status = entity.UserStatusSuspended\n\t} else if req.IsDeleted() {\n\t\tuser.Status = entity.UserStatusDeleted\n\t}\n\n\tif len(req.Query) > 0 {\n\t\tif email, e := mail.ParseAddress(req.Query); e == nil {\n\t\t\tuser.EMail = email.Address\n\t\t\treq.Query = \"\"\n\t\t} else if strings.HasPrefix(req.Query, \"user:\") {\n\t\t\tid := strings.TrimSpace(strings.TrimPrefix(req.Query, \"user:\"))\n\t\t\tidSearch := true\n\t\t\tfor _, r := range id {\n\t\t\t\tif !unicode.IsDigit(r) {\n\t\t\t\t\tidSearch = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif idSearch {\n\t\t\t\tuser.ID = id\n\t\t\t\treq.Query = \"\"\n\t\t\t} else {\n\t\t\t\treq.Query = id\n\t\t\t}\n\t\t}\n\t}\n\n\tusers, total, err := us.userRepo.GetUserPage(ctx, req.Page, req.PageSize, user, req.Query, req.Staff)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tresp := make([]*schema.GetUserPageResp, 0)\n\tfor _, u := range users {\n\t\tavatar := schema.FormatAvatarInfo(u.Avatar, u.EMail)\n\t\tt := &schema.GetUserPageResp{\n\t\t\tUserID:      u.ID,\n\t\t\tCreatedAt:   u.CreatedAt.Unix(),\n\t\t\tUsername:    u.Username,\n\t\t\tEMail:       u.EMail,\n\t\t\tRank:        u.Rank,\n\t\t\tDisplayName: u.DisplayName,\n\t\t\tAvatar:      avatar,\n\t\t}\n\t\tif u.Status == entity.UserStatusDeleted {\n\t\t\tt.Status = schema.UserDeleted\n\t\t\tt.DeletedAt = u.DeletedAt.Unix()\n\t\t} else if u.Status == entity.UserStatusSuspended {\n\t\t\tt.Status = schema.UserSuspended\n\t\t\tt.SuspendedAt = u.SuspendedAt.Unix()\n\t\t} else if u.MailStatus == entity.EmailStatusToBeVerified {\n\t\t\tt.Status = schema.UserInactive\n\t\t} else {\n\t\t\tt.Status = schema.UserNormal\n\t\t}\n\t\tresp = append(resp, t)\n\t}\n\tus.setUserRoleInfo(ctx, resp)\n\treturn pager.NewPageModel(total, resp), nil\n}\n\nfunc (us *UserAdminService) setUserRoleInfo(ctx context.Context, resp []*schema.GetUserPageResp) {\n\tvar userIDs []string\n\tfor _, u := range resp {\n\t\tuserIDs = append(userIDs, u.UserID)\n\t}\n\n\tuserRoleMapping, err := us.userRoleRelService.GetUserRoleMapping(ctx, userIDs)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn\n\t}\n\n\tfor _, u := range resp {\n\t\tr := userRoleMapping[u.UserID]\n\t\tif r == nil {\n\t\t\tcontinue\n\t\t}\n\t\tu.RoleID = r.ID\n\t\tu.RoleName = r.Name\n\t}\n}\n", "package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\t\"github.com/answerdev/answer/internal/service/service_config\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/google/uuid\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// UserRepo user repository\n\n// UserService user service\ntype UserService struct {\n\tuserCommonService *usercommon.UserCommon\n\tuserRepo          usercommon.UserRepo\n\tuserActivity      activity.UserActiveActivityRepo\n\tactivityRepo      activity_common.ActivityRepo\n\tserviceConfig     *service_config.ServiceConfig\n\temailService      *export.EmailService\n\tauthService       *auth.AuthService\n\tsiteInfoService   *siteinfo_common.SiteInfoCommonService\n\tuserRoleService   *role.UserRoleRelService\n}\n\nfunc NewUserService(userRepo usercommon.UserRepo,\n\tuserActivity activity.UserActiveActivityRepo,\n\tactivityRepo activity_common.ActivityRepo,\n\temailService *export.EmailService,\n\tauthService *auth.AuthService,\n\tserviceConfig *service_config.ServiceConfig,\n\tsiteInfoService *siteinfo_common.SiteInfoCommonService,\n\tuserRoleService *role.UserRoleRelService,\n\tuserCommonService *usercommon.UserCommon,\n) *UserService {\n\treturn &UserService{\n\t\tuserCommonService: userCommonService,\n\t\tuserRepo:          userRepo,\n\t\tuserActivity:      userActivity,\n\t\tactivityRepo:      activityRepo,\n\t\temailService:      emailService,\n\t\tserviceConfig:     serviceConfig,\n\t\tauthService:       authService,\n\t\tsiteInfoService:   siteInfoService,\n\t\tuserRoleService:   userRoleService,\n\t}\n}\n\n// GetUserInfoByUserID get user info by user id\nfunc (us *UserService) GetUserInfoByUserID(ctx context.Context, token, userID string) (resp *schema.GetUserToSetShowResp, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\tresp = &schema.GetUserToSetShowResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tresp.AccessToken = token\n\tresp.RoleID = roleID\n\treturn resp, nil\n}\n\nfunc (us *UserService) GetOtherUserInfoByUsername(ctx context.Context, username string) (\n\tresp *schema.GetOtherUserInfoByUsernameResp, err error,\n) {\n\tuserInfo, exist, err := us.userRepo.GetByUsername(ctx, username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.NotFound(reason.UserNotFound)\n\t}\n\tresp = &schema.GetOtherUserInfoByUsernameResp{}\n\tresp.GetFromUserEntity(userInfo)\n\treturn resp, nil\n}\n\n// EmailLogin email login\nfunc (us *UserService) EmailLogin(ctx context.Context, req *schema.UserEmailLogin) (resp *schema.GetUserResp, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist || userInfo.Status == entity.UserStatusDeleted {\n\t\treturn nil, errors.BadRequest(reason.EmailOrPasswordWrong)\n\t}\n\tif !us.verifyPassword(ctx, req.Pass, userInfo.Pass) {\n\t\treturn nil, errors.BadRequest(reason.EmailOrPasswordWrong)\n\t}\n\n\terr = us.userRepo.UpdateLastLoginDate(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(\"UpdateLastLoginDate\", err.Error())\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tRoleID:      roleID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp.RoleID = userCacheInfo.RoleID\n\tif resp.RoleID == role.RoleAdminID {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, userCacheInfo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn resp, nil\n}\n\n// RetrievePassWord .\nfunc (us *UserService) RetrievePassWord(ctx context.Context, req *schema.UserRetrievePassWordRequest) error {\n\tuserInfo, has, err := us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn nil\n\t}\n\n\t// send email\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  req.Email,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/password-reset?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.PassResetTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, req.Email, title, body, code, data.ToJSONString())\n\treturn nil\n}\n\n// UseRePassword\nfunc (us *UserService) UseRePassword(ctx context.Context, req *schema.UserRePassWordRequest) (resp *schema.GetUserResp, err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tenpass, err := us.encryptPassword(ctx, req.Pass)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = us.userRepo.UpdatePass(ctx, userInfo.ID, enpass)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp = &schema.GetUserResp{}\n\treturn resp, nil\n}\n\nfunc (us *UserService) UserModifyPassWordVerification(ctx context.Context, request *schema.UserModifyPassWordRequest) (bool, error) {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, request.UserID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !has {\n\t\treturn false, fmt.Errorf(\"user does not exist\")\n\t}\n\tisPass := us.verifyPassword(ctx, request.OldPass, userInfo.Pass)\n\tif !isPass {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}\n\n// UserModifyPassword user modify password\nfunc (us *UserService) UserModifyPassword(ctx context.Context, request *schema.UserModifyPassWordRequest) error {\n\tenpass, err := us.encryptPassword(ctx, request.Pass)\n\tif err != nil {\n\t\treturn err\n\t}\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, request.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn fmt.Errorf(\"user does not exist\")\n\t}\n\tisPass := us.verifyPassword(ctx, request.OldPass, userInfo.Pass)\n\tif !isPass {\n\t\treturn fmt.Errorf(\"the old password verification failed\")\n\t}\n\terr = us.userRepo.UpdatePass(ctx, userInfo.ID, enpass)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// UpdateInfo update user info\nfunc (us *UserService) UpdateInfo(ctx context.Context, req *schema.UpdateInfoRequest) (\n\terrFields []*validator.FormErrorField, err error) {\n\tif len(req.Username) > 0 {\n\t\tuserInfo, exist, err := us.userRepo.GetByUsername(ctx, req.Username)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif exist && userInfo.ID != req.UserID {\n\t\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameDuplicate,\n\t\t\t})\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameDuplicate)\n\t\t}\n\t\tif checker.IsReservedUsername(req.Username) {\n\t\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t\t})\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t\t}\n\t}\n\tavatar, err := json.Marshal(req.Avatar)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.UserSetAvatar).WithError(err).WithStack()\n\t}\n\tuserInfo := entity.User{}\n\tuserInfo.ID = req.UserID\n\tuserInfo.Avatar = string(avatar)\n\tuserInfo.DisplayName = req.DisplayName\n\tuserInfo.Bio = req.Bio\n\tuserInfo.BioHTML = req.BioHTML\n\tuserInfo.Location = req.Location\n\tuserInfo.Website = req.Website\n\tuserInfo.Username = req.Username\n\terr = us.userRepo.UpdateInfo(ctx, &userInfo)\n\treturn nil, err\n}\n\nfunc (us *UserService) UserEmailHas(ctx context.Context, email string) (bool, error) {\n\t_, has, err := us.userRepo.GetByEmail(ctx, email)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn has, nil\n}\n\n// UserUpdateInterface update user interface\nfunc (us *UserService) UserUpdateInterface(ctx context.Context, req *schema.UpdateUserInterfaceRequest) (err error) {\n\tif !translator.CheckLanguageIsValid(req.Language) {\n\t\treturn errors.BadRequest(reason.LangNotFound)\n\t}\n\terr = us.userRepo.UpdateLanguage(ctx, req.UserId, req.Language)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn nil\n}\n\n// UserRegisterByEmail user register\nfunc (us *UserService) UserRegisterByEmail(ctx context.Context, registerUserInfo *schema.UserRegisterReq) (\n\tresp *schema.GetUserResp, errFields []*validator.FormErrorField, err error,\n) {\n\t_, has, err := us.userRepo.GetByEmail(ctx, registerUserInfo.Email)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif has {\n\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   reason.EmailDuplicate,\n\t\t})\n\t\treturn nil, errFields, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tuserInfo := &entity.User{}\n\tuserInfo.EMail = registerUserInfo.Email\n\tuserInfo.DisplayName = registerUserInfo.Name\n\tuserInfo.Pass, err = us.encryptPassword(ctx, registerUserInfo.Pass)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tuserInfo.Username, err = us.userCommonService.MakeUsername(ctx, registerUserInfo.Name)\n\tif err != nil {\n\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\tErrorField: \"name\",\n\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t})\n\t\treturn nil, errFields, err\n\t}\n\tuserInfo.IPInfo = registerUserInfo.IP\n\tuserInfo.MailStatus = entity.EmailStatusToBeVerified\n\tuserInfo.Status = entity.UserStatusAvailable\n\tuserInfo.LastLoginDate = time.Now()\n\terr = us.userRepo.AddUser(ctx, userInfo)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// send email\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  registerUserInfo.Email,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/account-activation?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, userInfo.EMail, title, body, code, data.ToJSONString())\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\t// return user info and token\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tRoleID:      roleID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tresp.RoleID = userCacheInfo.RoleID\n\tif resp.RoleID == role.RoleAdminID {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\treturn resp, nil, nil\n}\n\nfunc (us *UserService) UserVerifyEmailSend(ctx context.Context, userID string) error {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  userInfo.EMail,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/account-activation?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, userInfo.EMail, title, body, code, data.ToJSONString())\n\treturn nil\n}\n\nfunc (us *UserService) UserNoticeSet(ctx context.Context, userID string, noticeSwitch bool) (\n\tresp *schema.UserNoticeSetResp, err error,\n) {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !has {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tif noticeSwitch {\n\t\tuserInfo.NoticeStatus = schema.NoticeStatusOn\n\t} else {\n\t\tuserInfo.NoticeStatus = schema.NoticeStatusOff\n\t}\n\terr = us.userRepo.UpdateNoticeStatus(ctx, userInfo.ID, userInfo.NoticeStatus)\n\treturn &schema.UserNoticeSetResp{NoticeSwitch: noticeSwitch}, err\n}\n\nfunc (us *UserService) UserVerifyEmail(ctx context.Context, req *schema.UserVerifyEmailReq) (resp *schema.GetUserResp, err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, has, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !has {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tuserInfo.MailStatus = entity.EmailStatusAvailable\n\terr = us.userRepo.UpdateEmailStatus(ctx, userInfo.ID, userInfo.MailStatus)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = us.userActivity.UserActive(ctx, userInfo.ID); err != nil {\n\t\tlog.Error(err)\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tRoleID:      roleID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// User verified email will update user email status. So user status cache should be updated.\n\tif err = us.authService.SetUserStatus(ctx, userCacheInfo); err != nil {\n\t\treturn nil, err\n\t}\n\tresp.RoleID = userCacheInfo.RoleID\n\tif resp.RoleID == role.RoleAdminID {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn resp, nil\n}\n\n// verifyPassword\n// Compare whether the password is correct\nfunc (us *UserService) verifyPassword(ctx context.Context, LoginPass, UserPass string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(UserPass), []byte(LoginPass))\n\treturn err == nil\n}\n\n// encryptPassword\n// The password does irreversible encryption.\nfunc (us *UserService) encryptPassword(ctx context.Context, Pass string) (string, error) {\n\thashPwd, err := bcrypt.GenerateFromPassword([]byte(Pass), bcrypt.DefaultCost)\n\t// This encrypted string can be saved to the database and can be used as password matching verification\n\treturn string(hashPwd), err\n}\n\n// UserChangeEmailSendCode user change email verification\nfunc (us *UserService) UserChangeEmailSendCode(ctx context.Context, req *schema.UserChangeEmailSendCodeReq) (\n\tresp []*validator.FormErrorField, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, req.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\n\t// If user's email already verified, then must verify password first.\n\tif userInfo.MailStatus == entity.EmailStatusAvailable && !us.verifyPassword(ctx, req.Pass, userInfo.Pass) {\n\t\tresp = append(resp, &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLangByCtx(ctx), reason.OldPasswordVerificationFailed),\n\t\t})\n\t\treturn resp, errors.BadRequest(reason.OldPasswordVerificationFailed)\n\t}\n\n\t_, exist, err = us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif exist {\n\t\tresp = append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLangByCtx(ctx), reason.EmailDuplicate),\n\t\t})\n\t\treturn resp, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  req.Email,\n\t\tUserID: req.UserID,\n\t}\n\tcode := uuid.NewString()\n\tvar title, body string\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/confirm-new-email?code=%s\", us.getSiteUrl(ctx), code)\n\tif userInfo.MailStatus == entity.EmailStatusToBeVerified {\n\t\ttitle, body, err = us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\t} else {\n\t\ttitle, body, err = us.emailService.ChangeEmailTemplate(ctx, verifyEmailURL)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlog.Infof(\"send email confirmation %s\", verifyEmailURL)\n\n\tgo us.emailService.SendAndSaveCode(context.Background(), req.Email, title, body, code, data.ToJSONString())\n\treturn nil, nil\n}\n\n// UserChangeEmailVerify user change email verify code\nfunc (us *UserService) UserChangeEmailVerify(ctx context.Context, content string) (resp *schema.GetUserResp, err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(content)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\t_, exist, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif exist {\n\t\treturn nil, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, data.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\terr = us.userRepo.UpdateEmail(ctx, data.UserID, data.Email)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\terr = us.userRepo.UpdateEmailStatus(ctx, data.UserID, entity.EmailStatusAvailable)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: entity.EmailStatusAvailable,\n\t\tUserStatus:  userInfo.Status,\n\t\tRoleID:      roleID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// User verified email will update user email status. So user status cache should be updated.\n\tif err = us.authService.SetUserStatus(ctx, userCacheInfo); err != nil {\n\t\treturn nil, err\n\t}\n\tresp.RoleID = userCacheInfo.RoleID\n\tif resp.RoleID == role.RoleAdminID {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn resp, nil\n}\n\n// getSiteUrl get site url\nfunc (us *UserService) getSiteUrl(ctx context.Context) string {\n\tsiteGeneral, err := us.siteInfoService.GetSiteGeneral(ctx)\n\tif err != nil {\n\t\tlog.Errorf(\"get site general failed: %s\", err)\n\t\treturn \"\"\n\t}\n\treturn siteGeneral.SiteUrl\n}\n\n// UserRanking get user ranking\nfunc (us *UserService) UserRanking(ctx context.Context) (resp *schema.UserRankingResp, err error) {\n\tlimit := 20\n\tendTime := time.Now()\n\tstartTime := endTime.AddDate(0, 0, -7)\n\tuserIDs, userIDExist := make([]string, 0), make(map[string]bool, 0)\n\n\t// get most reputation users\n\trankStat, rankStatUserIDs, err := us.getActivityUserRankStat(ctx, startTime, endTime, limit, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, rankStatUserIDs...)\n\n\t// get most vote users\n\tvoteStat, voteStatUserIDs, err := us.getActivityUserVoteStat(ctx, startTime, endTime, limit, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, voteStatUserIDs...)\n\n\t// get all staff members\n\tuserRoleRels, staffUserIDs, err := us.getStaff(ctx, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, staffUserIDs...)\n\n\t// get user information\n\tuserInfoMapping, err := us.getUserInfoMapping(ctx, userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn us.warpStatRankingResp(userInfoMapping, rankStat, voteStat, userRoleRels), nil\n}\n\n// UserUnsubscribeEmailNotification user unsubscribe email notification\nfunc (us *UserService) UserUnsubscribeEmailNotification(\n\tctx context.Context, req *schema.UserUnsubscribeEmailNotificationReq) (err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil || len(data.UserID) == 0 {\n\t\treturn errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, data.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\treturn us.userRepo.UpdateNoticeStatus(ctx, userInfo.ID, schema.NoticeStatusOff)\n}\n\nfunc (us *UserService) getActivityUserRankStat(ctx context.Context, startTime, endTime time.Time, limit int,\n\tuserIDExist map[string]bool) (rankStat []*entity.ActivityUserRankStat, userIDs []string, err error) {\n\trankStat, err = us.activityRepo.GetUsersWhoHasGainedTheMostReputation(ctx, startTime, endTime, limit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, stat := range rankStat {\n\t\tif stat.Rank <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userIDExist[stat.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, stat.UserID)\n\t\tuserIDExist[stat.UserID] = true\n\t}\n\treturn rankStat, userIDs, nil\n}\n\nfunc (us *UserService) getActivityUserVoteStat(ctx context.Context, startTime, endTime time.Time, limit int,\n\tuserIDExist map[string]bool) (voteStat []*entity.ActivityUserVoteStat, userIDs []string, err error) {\n\tvoteStat, err = us.activityRepo.GetUsersWhoHasVoteMost(ctx, startTime, endTime, limit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, stat := range voteStat {\n\t\tif stat.VoteCount <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userIDExist[stat.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, stat.UserID)\n\t\tuserIDExist[stat.UserID] = true\n\t}\n\treturn voteStat, userIDs, nil\n}\n\nfunc (us *UserService) getStaff(ctx context.Context, userIDExist map[string]bool) (\n\tuserRoleRels []*entity.UserRoleRel, userIDs []string, err error) {\n\tuserRoleRels, err = us.userRoleService.GetUserByRoleID(ctx, []int{role.RoleAdminID, role.RoleModeratorID})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, rel := range userRoleRels {\n\t\tif userIDExist[rel.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, rel.UserID)\n\t\tuserIDExist[rel.UserID] = true\n\t}\n\treturn userRoleRels, userIDs, nil\n}\n\nfunc (us *UserService) getUserInfoMapping(ctx context.Context, userIDs []string) (\n\tuserInfoMapping map[string]*entity.User, err error) {\n\tuserInfoMapping = make(map[string]*entity.User, 0)\n\tif len(userIDs) == 0 {\n\t\treturn userInfoMapping, nil\n\t}\n\tuserInfoList, err := us.userRepo.BatchGetByID(ctx, userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, user := range userInfoList {\n\t\tuser.Avatar = schema.FormatAvatarInfo(user.Avatar, user.EMail)\n\t\tuserInfoMapping[user.ID] = user\n\t}\n\treturn userInfoMapping, nil\n}\n\nfunc (us *UserService) warpStatRankingResp(\n\tuserInfoMapping map[string]*entity.User,\n\trankStat []*entity.ActivityUserRankStat,\n\tvoteStat []*entity.ActivityUserVoteStat,\n\tuserRoleRels []*entity.UserRoleRel) (resp *schema.UserRankingResp) {\n\tresp = &schema.UserRankingResp{\n\t\tUsersWithTheMostReputation: make([]*schema.UserRankingSimpleInfo, 0),\n\t\tUsersWithTheMostVote:       make([]*schema.UserRankingSimpleInfo, 0),\n\t\tStaffs:                     make([]*schema.UserRankingSimpleInfo, 0),\n\t}\n\tfor _, stat := range rankStat {\n\t\tif stat.Rank <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userInfo := userInfoMapping[stat.UserID]; userInfo != nil {\n\t\t\tresp.UsersWithTheMostReputation = append(resp.UsersWithTheMostReputation, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tRank:        stat.Rank,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\tfor _, stat := range voteStat {\n\t\tif stat.VoteCount <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userInfo := userInfoMapping[stat.UserID]; userInfo != nil {\n\t\t\tresp.UsersWithTheMostVote = append(resp.UsersWithTheMostVote, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tVoteCount:   stat.VoteCount,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\tfor _, rel := range userRoleRels {\n\t\tif userInfo := userInfoMapping[rel.UserID]; userInfo != nil {\n\t\t\tresp.Staffs = append(resp.Staffs, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tRank:        userInfo.Rank,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\treturn resp\n}\n"], "fixing_code": ["package controller\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\t\"github.com/answerdev/answer/internal/service/uploader\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// UserController user controller\ntype UserController struct {\n\tuserService           *service.UserService\n\tauthService           *auth.AuthService\n\tactionService         *action.CaptchaService\n\tuploaderService       *uploader.UploaderService\n\temailService          *export.EmailService\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService\n}\n\n// NewUserController new controller\nfunc NewUserController(\n\tauthService *auth.AuthService,\n\tuserService *service.UserService,\n\tactionService *action.CaptchaService,\n\temailService *export.EmailService,\n\tuploaderService *uploader.UploaderService,\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService,\n) *UserController {\n\treturn &UserController{\n\t\tauthService:           authService,\n\t\tuserService:           userService,\n\t\tactionService:         actionService,\n\t\tuploaderService:       uploaderService,\n\t\temailService:          emailService,\n\t\tsiteInfoCommonService: siteInfoCommonService,\n\t}\n}\n\n// GetUserInfoByUserID get user info, if user no login response http code is 200, but user info is null\n// @Summary GetUserInfoByUserID\n// @Description get user info, if user no login response http code is 200, but user info is null\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.GetUserToSetShowResp}\n// @Router /answer/api/v1/user/info [get]\nfunc (uc *UserController) GetUserInfoByUserID(ctx *gin.Context) {\n\ttoken := middleware.ExtractToken(ctx)\n\tif len(token) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\t// if user is no login return null in data\n\tuserInfo, _ := uc.authService.GetUserCacheInfo(ctx, token)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetUserInfoByUserID(ctx, token, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// GetOtherUserInfoByUsername godoc\n// @Summary GetOtherUserInfoByUsername\n// @Description GetOtherUserInfoByUsername\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param username query string true \"username\"\n// @Success 200 {object} handler.RespBody{data=schema.GetOtherUserInfoResp}\n// @Router /answer/api/v1/personal/user/info [get]\nfunc (uc *UserController) GetOtherUserInfoByUsername(ctx *gin.Context) {\n\treq := &schema.GetOtherUserInfoByUsernameReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetOtherUserInfoByUsername(ctx, req.Username)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserEmailLogin godoc\n// @Summary UserEmailLogin\n// @Description UserEmailLogin\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserEmailLogin true \"UserEmailLogin\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/login/email [post]\nfunc (uc *UserController) UserEmailLogin(ctx *gin.Context) {\n\treq := &schema.UserEmailLogin{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.EmailLogin(ctx, req)\n\tif err != nil {\n\t\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.EmailOrPasswordWrong),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.EmailOrPasswordWrong), errFields)\n\t\treturn\n\t}\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\thandler.HandleResponse(ctx, nil, resp)\n}\n\n// RetrievePassWord godoc\n// @Summary RetrievePassWord\n// @Description RetrievePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRetrievePassWordRequest  true \"UserRetrievePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/reset [post]\nfunc (uc *UserController) RetrievePassWord(ctx *gin.Context) {\n\treq := &schema.UserRetrievePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\terr := uc.userService.RetrievePassWord(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UseRePassWord godoc\n// @Summary UseRePassWord\n// @Description UseRePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRePassWordRequest  true \"UserRePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/replacement [post]\nfunc (uc *UserController) UseRePassWord(ctx *gin.Context) {\n\treq := &schema.UserRePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UpdatePasswordWhenForgot(ctx, req)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserLogout user logout\n// @Summary user logout\n// @Description user logout\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/logout [get]\nfunc (uc *UserController) UserLogout(ctx *gin.Context) {\n\taccessToken := middleware.ExtractToken(ctx)\n\tif len(accessToken) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\t_ = uc.authService.RemoveUserCacheInfo(ctx, accessToken)\n\t_ = uc.authService.RemoveAdminUserCacheInfo(ctx, accessToken)\n\thandler.HandleResponse(ctx, nil, nil)\n}\n\n// UserRegisterByEmail godoc\n// @Summary UserRegisterByEmail\n// @Description UserRegisterByEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserRegisterReq true \"UserRegisterReq\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/email [post]\nfunc (uc *UserController) UserRegisterByEmail(ctx *gin.Context) {\n\t// check whether site allow register or not\n\tsiteInfo, err := uc.siteInfoCommonService.GetSiteLogin(ctx)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !siteInfo.AllowNewRegistrations {\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NotAllowedRegistration), nil)\n\t\treturn\n\t}\n\n\treq := &schema.UserRegisterReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\tcaptchaPass := uc.actionService.UserRegisterVerifyCaptcha(ctx, req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, errFields, err := uc.userService.UserRegisterByEmail(ctx, req)\n\tif len(errFields) > 0 {\n\t\tfor _, field := range errFields {\n\t\t\tfield.ErrorMsg = translator.\n\t\t\t\tTr(handler.GetLang(ctx), field.ErrorMsg)\n\t\t}\n\t\thandler.HandleResponse(ctx, err, errFields)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// UserVerifyEmail godoc\n// @Summary UserVerifyEmail\n// @Description UserVerifyEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param code query string true \"code\" default()\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/email/verification [post]\nfunc (uc *UserController) UserVerifyEmail(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UserVerifyEmail(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserVerifyEmailSend godoc\n// @Summary UserVerifyEmailSend\n// @Description UserVerifyEmailSend\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param captcha_id query string false \"captcha_id\"  default()\n// @Param captcha_code query string false \"captcha_code\"  default()\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/email/verification/send [post]\nfunc (uc *UserController) UserVerifyEmailSend(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailSendReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tuserInfo := middleware.GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(),\n\t\treq.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, err := uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\terr = uc.userService.UserVerifyEmailSend(ctx, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserModifyPassWord godoc\n// @Summary UserModifyPassWord\n// @Description UserModifyPassWord\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserModifyPasswordReq  true \"UserModifyPasswordReq\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/password [put]\nfunc (uc *UserController) UserModifyPassWord(ctx *gin.Context) {\n\treq := &schema.UserModifyPasswordReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\treq.AccessToken = middleware.ExtractToken(ctx)\n\n\toldPassVerification, err := uc.userService.UserModifyPassWordVerification(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !oldPassVerification {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"old_pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.OldPasswordVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.OldPasswordVerificationFailed), errFields)\n\t\treturn\n\t}\n\tif req.OldPass == req.Pass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.NewPasswordSameAsPreviousSetting),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NewPasswordSameAsPreviousSetting), errFields)\n\t\treturn\n\t}\n\terr = uc.userService.UserModifyPassword(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserUpdateInfo update user info\n// @Summary UserUpdateInfo update user info\n// @Description UserUpdateInfo update user info\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateInfoRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/info [put]\nfunc (uc *UserController) UserUpdateInfo(ctx *gin.Context) {\n\treq := &schema.UpdateInfoRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\terrFields, err := uc.userService.UpdateInfo(ctx, req)\n\tfor _, field := range errFields {\n\t\tfield.ErrorMsg = translator.Tr(handler.GetLang(ctx), field.ErrorMsg)\n\t}\n\thandler.HandleResponse(ctx, err, errFields)\n}\n\n// UserUpdateInterface update user interface config\n// @Summary UserUpdateInterface update user interface config\n// @Description UserUpdateInterface update user interface config\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateUserInterfaceRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/interface [put]\nfunc (uc *UserController) UserUpdateInterface(ctx *gin.Context) {\n\treq := &schema.UpdateUserInterfaceRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserId = middleware.GetLoginUserIDFromContext(ctx)\n\terr := uc.userService.UserUpdateInterface(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// ActionRecord godoc\n// @Summary ActionRecord\n// @Description ActionRecord\n// @Tags User\n// @Param action query string true \"action\" Enums(login, e_mail, find_pass)\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.ActionRecordResp}\n// @Router /answer/api/v1/user/action/record [get]\nfunc (uc *UserController) ActionRecord(ctx *gin.Context) {\n\treq := &schema.ActionRecordReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\n\tresp, err := uc.actionService.ActionRecord(ctx, req)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserRegisterCaptcha godoc\n// @Summary UserRegisterCaptcha\n// @Description UserRegisterCaptcha\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/captcha [get]\nfunc (uc *UserController) UserRegisterCaptcha(ctx *gin.Context) {\n\tresp, err := uc.actionService.UserRegisterCaptcha(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserNoticeSet godoc\n// @Summary UserNoticeSet\n// @Description UserNoticeSet\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserNoticeSetRequest true \"UserNoticeSetRequest\"\n// @Success 200 {object} handler.RespBody{data=schema.UserNoticeSetResp}\n// @Router /answer/api/v1/user/notice/set [post]\nfunc (uc *UserController) UserNoticeSet(ctx *gin.Context) {\n\treq := &schema.UserNoticeSetRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tresp, err := uc.userService.UserNoticeSet(ctx, req.UserID, req.NoticeSwitch)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserChangeEmailSendCode send email to the user email then change their email\n// @Summary send email to the user email then change their email\n// @Description send email to the user email then change their email\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserChangeEmailSendCodeReq true \"UserChangeEmailSendCodeReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/change/code [post]\nfunc (uc *UserController) UserChangeEmailSendCode(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailSendCodeReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\t// If the user is not logged in, the api cannot be used.\n\t// If the user email is not verified, that also can use this api to modify the email.\n\tif len(req.UserID) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tresp, err := uc.userService.UserChangeEmailSendCode(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t\treturn\n\t}\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserChangeEmailVerify user change email verification\n// @Summary user change email verification\n// @Description user change email verification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserChangeEmailVerifyReq true \"UserChangeEmailVerifyReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email [put]\nfunc (uc *UserController) UserChangeEmailVerify(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailVerifyReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UserChangeEmailVerify(ctx, req.Content)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserRanking get user ranking\n// @Summary get user ranking\n// @Description get user ranking\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.UserRankingResp}\n// @Router /answer/api/v1/user/ranking [get]\nfunc (uc *UserController) UserRanking(ctx *gin.Context) {\n\tresp, err := uc.userService.UserRanking(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserUnsubscribeEmailNotification unsubscribe email notification\n// @Summary unsubscribe email notification\n// @Description unsubscribe email notification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/notification [put]\nfunc (uc *UserController) UserUnsubscribeEmailNotification(ctx *gin.Context) {\n\treq := &schema.UserUnsubscribeEmailNotificationReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserUnsubscribeEmailNotification(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n", "package auth\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// authRepo auth repository\ntype authRepo struct {\n\tdata *data.Data\n}\n\n// GetUserCacheInfo get user cache info\nfunc (ar *authRepo) GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {\n\tuserInfoCache, err := ar.data.Cache.GetString(ctx, constant.UserTokenCacheKey+accessToken)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tuserInfo = &entity.UserCacheInfo{}\n\terr = json.Unmarshal([]byte(userInfoCache), userInfo)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn userInfo, nil\n}\n\n// SetUserCacheInfo set user cache info\nfunc (ar *authRepo) SetUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {\n\tuserInfoCache, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = ar.data.Cache.SetString(ctx, constant.UserTokenCacheKey+accessToken,\n\t\tstring(userInfoCache), constant.UserTokenCacheTime)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif err := ar.AddUserTokenMapping(ctx, userInfo.UserID, accessToken); err != nil {\n\t\tlog.Error(err)\n\t}\n\treturn nil\n}\n\n// RemoveUserCacheInfo remove user cache info\nfunc (ar *authRepo) RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error) {\n\terr = ar.data.Cache.Del(ctx, constant.UserTokenCacheKey+accessToken)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// SetUserStatus set user status\nfunc (ar *authRepo) SetUserStatus(ctx context.Context, userID string, userInfo *entity.UserCacheInfo) (err error) {\n\tuserInfoCache, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = ar.data.Cache.SetString(ctx, constant.UserStatusChangedCacheKey+userID,\n\t\tstring(userInfoCache), constant.UserStatusChangedCacheTime)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// GetUserStatus get user status\nfunc (ar *authRepo) GetUserStatus(ctx context.Context, userID string) (userInfo *entity.UserCacheInfo, err error) {\n\tuserInfoCache, err := ar.data.Cache.GetString(ctx, constant.UserStatusChangedCacheKey+userID)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tuserInfo = &entity.UserCacheInfo{}\n\terr = json.Unmarshal([]byte(userInfoCache), userInfo)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn userInfo, nil\n}\n\n// RemoveUserStatus remove user status\nfunc (ar *authRepo) RemoveUserStatus(ctx context.Context, userID string) (err error) {\n\terr = ar.data.Cache.Del(ctx, constant.UserStatusChangedCacheKey+userID)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// GetAdminUserCacheInfo get admin user cache info\nfunc (ar *authRepo) GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {\n\tuserInfoCache, err := ar.data.Cache.GetString(ctx, constant.AdminTokenCacheKey+accessToken)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn\n\t}\n\tuserInfo = &entity.UserCacheInfo{}\n\terr = json.Unmarshal([]byte(userInfoCache), userInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn userInfo, nil\n}\n\n// SetAdminUserCacheInfo set admin user cache info\nfunc (ar *authRepo) SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {\n\tuserInfoCache, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ar.data.Cache.SetString(ctx, constant.AdminTokenCacheKey+accessToken, string(userInfoCache),\n\t\tconstant.AdminTokenCacheTime)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// RemoveAdminUserCacheInfo remove admin user cache info\nfunc (ar *authRepo) RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error) {\n\terr = ar.data.Cache.Del(ctx, constant.AdminTokenCacheKey+accessToken)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// AddUserTokenMapping add user token mapping\nfunc (ar *authRepo) AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error) {\n\tkey := constant.UserTokenMappingCacheKey + userID\n\tresp, _ := ar.data.Cache.GetString(ctx, key)\n\tmapping := make(map[string]bool, 0)\n\tif len(resp) > 0 {\n\t\t_ = json.Unmarshal([]byte(resp), &mapping)\n\t}\n\tmapping[accessToken] = true\n\tcontent, _ := json.Marshal(mapping)\n\treturn ar.data.Cache.SetString(ctx, key, string(content), constant.UserTokenCacheTime)\n}\n\n// RemoveUserTokens Log out all users under this user id\nfunc (ar *authRepo) RemoveUserTokens(ctx context.Context, userID string, remainToken string) {\n\tkey := constant.UserTokenMappingCacheKey + userID\n\tresp, _ := ar.data.Cache.GetString(ctx, key)\n\tmapping := make(map[string]bool, 0)\n\tif len(resp) > 0 {\n\t\t_ = json.Unmarshal([]byte(resp), &mapping)\n\t\tlog.Debugf(\"find %d user tokens by user id %s\", len(mapping), userID)\n\t}\n\n\tfor token := range mapping {\n\t\tif token == remainToken {\n\t\t\tcontinue\n\t\t}\n\t\tif err := ar.RemoveUserCacheInfo(ctx, token); err != nil {\n\t\t\tlog.Error(err)\n\t\t} else {\n\t\t\tlog.Debugf(\"del user %s token success\")\n\t\t}\n\t}\n\tif err := ar.RemoveUserStatus(ctx, userID); err != nil {\n\t\tlog.Error(err)\n\t}\n\tif err := ar.data.Cache.Del(ctx, key); err != nil {\n\t\tlog.Error(err)\n\t}\n}\n\n// NewAuthRepo new repository\nfunc NewAuthRepo(data *data.Data) auth.AuthRepo {\n\treturn &authRepo{\n\t\tdata: data,\n\t}\n}\n", "package schema\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/answerdev/answer/pkg/gravatar\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// UserVerifyEmailReq user verify email request\ntype UserVerifyEmailReq struct {\n\t// code\n\tCode string `validate:\"required,gt=0,lte=500\" form:\"code\"`\n\t// content\n\tContent string `json:\"-\"`\n}\n\n// GetUserResp get user response\ntype GetUserResp struct {\n\t// user id\n\tID string `json:\"id\"`\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// last login date\n\tLastLoginDate int64 `json:\"last_login_date\"`\n\t// username\n\tUsername string `json:\"username\"`\n\t// email\n\tEMail string `json:\"e_mail\"`\n\t// mail status(1 pass 2 to be verified)\n\tMailStatus int `json:\"mail_status\"`\n\t// notice status(1 on 2off)\n\tNoticeStatus int `json:\"notice_status\"`\n\t// follow count\n\tFollowCount int `json:\"follow_count\"`\n\t// answer count\n\tAnswerCount int `json:\"answer_count\"`\n\t// question count\n\tQuestionCount int `json:\"question_count\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// authority group\n\tAuthorityGroup int `json:\"authority_group\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n\t// mobile\n\tMobile string `json:\"mobile\"`\n\t// bio markdown\n\tBio string `json:\"bio\"`\n\t// bio html\n\tBioHTML string `json:\"bio_html\"`\n\t// website\n\tWebsite string `json:\"website\"`\n\t// location\n\tLocation string `json:\"location\"`\n\t// ip info\n\tIPInfo string `json:\"ip_info\"`\n\t// language\n\tLanguage string `json:\"language\"`\n\t// access token\n\tAccessToken string `json:\"access_token\"`\n\t// role id\n\tRoleID int `json:\"role_id\"`\n\t// user status\n\tStatus string `json:\"status\"`\n\t// user have password\n\tHavePassword bool `json:\"have_password\"`\n}\n\nfunc (r *GetUserResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tr.Avatar = FormatAvatarInfo(userInfo.Avatar, userInfo.EMail)\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n\tr.HavePassword = len(userInfo.Pass) > 0\n}\n\ntype GetUserToSetShowResp struct {\n\t*GetUserResp\n\tAvatar       *AvatarInfo `json:\"avatar\"`\n\tHavePassword bool        `json:\"have_password\"`\n}\n\nfunc (r *GetUserToSetShowResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n\tavatarInfo := &AvatarInfo{}\n\t_ = json.Unmarshal([]byte(userInfo.Avatar), avatarInfo)\n\tif constant.DefaultAvatar == \"gravatar\" && avatarInfo.Type == \"\" {\n\t\tavatarInfo.Type = \"gravatar\"\n\t\tavatarInfo.Gravatar = gravatar.GetAvatarURL(userInfo.EMail)\n\t}\n\t// if json.Unmarshal Error avatarInfo.Type is Empty\n\tr.Avatar = avatarInfo\n}\n\nfunc FormatAvatarInfo(avatarJson, email string) (res string) {\n\tdefer func() {\n\t\tif constant.DefaultAvatar == \"gravatar\" && len(res) == 0 {\n\t\t\tres = gravatar.GetAvatarURL(email)\n\t\t}\n\t}()\n\n\tif avatarJson == \"\" {\n\t\treturn \"\"\n\t}\n\tavatarInfo := &AvatarInfo{}\n\terr := json.Unmarshal([]byte(avatarJson), avatarInfo)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tswitch avatarInfo.Type {\n\tcase \"gravatar\":\n\t\treturn avatarInfo.Gravatar\n\tcase \"custom\":\n\t\treturn avatarInfo.Custom\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\n// GetUserStatusResp get user status info\ntype GetUserStatusResp struct {\n\t// user status\n\tStatus string `json:\"status\"`\n}\n\n// GetOtherUserInfoByUsernameResp get user response\ntype GetOtherUserInfoByUsernameResp struct {\n\t// user id\n\tID string `json:\"id\"`\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// last login date\n\tLastLoginDate int64 `json:\"last_login_date\"`\n\t// username\n\tUsername string `json:\"username\"`\n\t// email\n\t// follow count\n\tFollowCount int `json:\"follow_count\"`\n\t// answer count\n\tAnswerCount int `json:\"answer_count\"`\n\t// question count\n\tQuestionCount int `json:\"question_count\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n\t// mobile\n\tMobile string `json:\"mobile\"`\n\t// bio markdown\n\tBio string `json:\"bio\"`\n\t// bio html\n\tBioHTML string `json:\"bio_html\"`\n\t// website\n\tWebsite string `json:\"website\"`\n\t// location\n\tLocation  string `json:\"location\"`\n\tStatus    string `json:\"status\"`\n\tStatusMsg string `json:\"status_msg,omitempty\"`\n}\n\nfunc (r *GetOtherUserInfoByUsernameResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tAvatar := FormatAvatarInfo(userInfo.Avatar, userInfo.EMail)\n\tr.Avatar = Avatar\n\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n\tif userInfo.MailStatus == entity.EmailStatusToBeVerified {\n\t\tstatusMsgShow, ok := UserStatusShowMsg[11]\n\t\tif ok {\n\t\t\tr.StatusMsg = statusMsgShow\n\t\t}\n\t} else {\n\t\tstatusMsgShow, ok := UserStatusShowMsg[userInfo.Status]\n\t\tif ok {\n\t\t\tr.StatusMsg = statusMsgShow\n\t\t}\n\t}\n}\n\nconst (\n\tMailStatePass   = 1\n\tMailStateVerifi = 2\n\n\tNoticeStatusOn  = 1\n\tNoticeStatusOff = 2\n\n\tActionRecordTypeLogin    = \"login\"\n\tActionRecordTypeEmail    = \"e_mail\"\n\tActionRecordTypeFindPass = \"find_pass\"\n)\n\nvar UserStatusShow = map[int]string{\n\t1:  \"normal\",\n\t9:  \"forbidden\",\n\t10: \"deleted\",\n}\n\nvar UserStatusShowMsg = map[int]string{\n\t1:  \"\",\n\t9:  \"<strong>This user was suspended forever.</strong> This user doesn\u2019t meet a community guideline.\",\n\t10: \"This user was deleted.\",\n\t11: \"This user is inactive.\",\n}\n\n// EmailLogin\ntype UserEmailLogin struct {\n\tEmail       string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\"` // e_mail\n\tPass        string `validate:\"required,gte=8,lte=32\" json:\"pass\"`         // password\n\tCaptchaID   string `json:\"captcha_id\"`                                    // captcha_id\n\tCaptchaCode string `json:\"captcha_code\"`                                  // captcha_code\n}\n\n// UserRegisterReq user register request\ntype UserRegisterReq struct {\n\t// name\n\tName string `validate:\"required,gt=3,lte=30\" json:\"name\"`\n\t// email\n\tEmail string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\" `\n\t// password\n\tPass        string `validate:\"required,gte=8,lte=32\" json:\"pass\"`\n\tIP          string `json:\"-\" `\n\tCaptchaID   string `json:\"captcha_id\"`   // captcha_id\n\tCaptchaCode string `json:\"captcha_code\"` // captcha_code\n}\n\nfunc (u *UserRegisterReq) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\ntype UserModifyPasswordReq struct {\n\tOldPass     string `json:\"old_pass\"`\n\tPass        string `json:\"pass\"`\n\tUserID      string `json:\"-\"`\n\tAccessToken string `json:\"-\"`\n}\n\nfunc (u *UserModifyPasswordReq) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\ntype UpdateInfoRequest struct {\n\t// display_name\n\tDisplayName string `validate:\"required,gt=0,lte=30\" json:\"display_name\"`\n\t// username\n\tUsername string `validate:\"omitempty,gt=3,lte=30\" json:\"username\"`\n\t// avatar\n\tAvatar AvatarInfo `json:\"avatar\"`\n\t// bio\n\tBio string `validate:\"omitempty,gt=0,lte=4096\" json:\"bio\"`\n\t// bio\n\tBioHTML string `json:\"-\"`\n\t// website\n\tWebsite string `validate:\"omitempty,gt=0,lte=500\" json:\"website\"`\n\t// location\n\tLocation string `validate:\"omitempty,gt=0,lte=100\" json:\"location\"`\n\t// user id\n\tUserID string `json:\"-\" `\n}\n\ntype AvatarInfo struct {\n\tType     string `validate:\"omitempty,gt=0,lte=100\"  json:\"type\"`\n\tGravatar string `validate:\"omitempty,gt=0,lte=200\"  json:\"gravatar\"`\n\tCustom   string `validate:\"omitempty,gt=0,lte=200\"  json:\"custom\"`\n}\n\nfunc (req *UpdateInfoRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\tif len(req.Username) > 0 {\n\t\tif checker.IsInvalidUsername(req.Username) {\n\t\t\terrField := &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t\t}\n\t\t\terrFields = append(errFields, errField)\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t\t}\n\t}\n\treq.BioHTML = converter.Markdown2BasicHTML(req.Bio)\n\treturn nil, nil\n}\n\n// UpdateUserInterfaceRequest update user interface request\ntype UpdateUserInterfaceRequest struct {\n\t// language\n\tLanguage string `validate:\"required,gt=1,lte=100\" json:\"language\"`\n\t// user id\n\tUserId string `json:\"-\" `\n}\n\ntype UserRetrievePassWordRequest struct {\n\tEmail       string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\" ` // e_mail\n\tCaptchaID   string `json:\"captcha_id\" `                                    // captcha_id\n\tCaptchaCode string `json:\"captcha_code\" `                                  // captcha_code\n}\n\ntype UserRePassWordRequest struct {\n\tCode    string `validate:\"required,gt=0,lte=100\" json:\"code\" ` // code\n\tPass    string `validate:\"required,gt=0,lte=32\" json:\"pass\" `  // Password\n\tContent string `json:\"-\"`\n}\n\nfunc (u *UserRePassWordRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\ntype UserNoticeSetRequest struct {\n\tNoticeSwitch bool   `json:\"notice_switch\"`\n\tUserID       string `json:\"-\"`\n}\n\ntype UserNoticeSetResp struct {\n\tNoticeSwitch bool `json:\"notice_switch\"`\n}\n\ntype ActionRecordReq struct {\n\t// action\n\tAction string `validate:\"required,oneof=login e_mail find_pass\" form:\"action\"`\n\tIP     string `json:\"-\"`\n}\n\ntype ActionRecordResp struct {\n\tCaptchaID  string `json:\"captcha_id\"`\n\tCaptchaImg string `json:\"captcha_img\"`\n\tVerify     bool   `json:\"verify\"`\n}\n\ntype UserBasicInfo struct {\n\tID          string `json:\"id\"`           // user_id\n\tUsername    string `json:\"username\" `    // name\n\tRank        int    `json:\"rank\" `        // rank\n\tDisplayName string `json:\"display_name\"` // display_name\n\tAvatar      string `json:\"avatar\" `      // avatar\n\tWebsite     string `json:\"website\" `     // website\n\tLocation    string `json:\"location\" `    // location\n\tIPInfo      string `json:\"ip_info\"`      // ip info\n\tStatus      string `json:\"status\"`       // status\n}\n\ntype GetOtherUserInfoByUsernameReq struct {\n\tUsername string `validate:\"required,gt=0,lte=500\" form:\"username\"`\n}\n\ntype GetOtherUserInfoResp struct {\n\tInfo *GetOtherUserInfoByUsernameResp `json:\"info\"`\n}\n\ntype UserChangeEmailSendCodeReq struct {\n\tUserVerifyEmailSendReq\n\tEmail  string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\"`\n\tPass   string `validate:\"omitempty,gte=8,lte=32\" json:\"pass\"`\n\tUserID string `json:\"-\"`\n}\n\ntype UserChangeEmailVerifyReq struct {\n\tCode    string `validate:\"required,gt=0,lte=500\" json:\"code\"`\n\tContent string `json:\"-\"`\n}\n\ntype UserVerifyEmailSendReq struct {\n\tCaptchaID   string `validate:\"omitempty,gt=0,lte=500\" json:\"captcha_id\"`\n\tCaptchaCode string `validate:\"omitempty,gt=0,lte=500\" json:\"captcha_code\"`\n}\n\n// UserRankingResp user ranking response\ntype UserRankingResp struct {\n\tUsersWithTheMostReputation []*UserRankingSimpleInfo `json:\"users_with_the_most_reputation\"`\n\tUsersWithTheMostVote       []*UserRankingSimpleInfo `json:\"users_with_the_most_vote\"`\n\tStaffs                     []*UserRankingSimpleInfo `json:\"staffs\"`\n}\n\n// UserRankingSimpleInfo user ranking simple info\ntype UserRankingSimpleInfo struct {\n\t// username\n\tUsername string `json:\"username\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// vote\n\tVoteCount int `json:\"vote_count\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n}\n\n// UserUnsubscribeEmailNotificationReq user unsubscribe email notification request\ntype UserUnsubscribeEmailNotificationReq struct {\n\tCode    string `validate:\"required,gt=0,lte=500\" json:\"code\"`\n\tContent string `json:\"-\"`\n}\n", "package auth\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/pkg/token\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// AuthRepo auth repository\ntype AuthRepo interface {\n\tGetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error)\n\tSetUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) error\n\tRemoveUserCacheInfo(ctx context.Context, accessToken string) (err error)\n\tSetUserStatus(ctx context.Context, userID string, userInfo *entity.UserCacheInfo) (err error)\n\tGetUserStatus(ctx context.Context, userID string) (userInfo *entity.UserCacheInfo, err error)\n\tRemoveUserStatus(ctx context.Context, userID string) (err error)\n\tGetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error)\n\tSetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) error\n\tRemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error)\n\tAddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error)\n\tRemoveUserTokens(ctx context.Context, userID string, remainToken string)\n}\n\n// AuthService kit service\ntype AuthService struct {\n\tauthRepo AuthRepo\n}\n\n// NewAuthService email service\nfunc NewAuthService(authRepo AuthRepo) *AuthService {\n\treturn &AuthService{\n\t\tauthRepo: authRepo,\n\t}\n}\n\nfunc (as *AuthService) GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {\n\tuserCacheInfo, err := as.authRepo.GetUserCacheInfo(ctx, accessToken)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcacheInfo, _ := as.authRepo.GetUserStatus(ctx, userCacheInfo.UserID)\n\tif cacheInfo != nil {\n\t\tlog.Debugf(\"user status updated: %+v\", cacheInfo)\n\t\tuserCacheInfo.UserStatus = cacheInfo.UserStatus\n\t\tuserCacheInfo.EmailStatus = cacheInfo.EmailStatus\n\t\tuserCacheInfo.RoleID = cacheInfo.RoleID\n\t\t// update current user cache info\n\t\terr := as.authRepo.SetUserCacheInfo(ctx, accessToken, userCacheInfo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn userCacheInfo, nil\n}\n\nfunc (as *AuthService) SetUserCacheInfo(ctx context.Context, userInfo *entity.UserCacheInfo) (accessToken string, err error) {\n\taccessToken = token.GenerateToken()\n\terr = as.authRepo.SetUserCacheInfo(ctx, accessToken, userInfo)\n\treturn accessToken, err\n}\n\nfunc (as *AuthService) SetUserStatus(ctx context.Context, userInfo *entity.UserCacheInfo) (err error) {\n\treturn as.authRepo.SetUserStatus(ctx, userInfo.UserID, userInfo)\n}\n\nfunc (as *AuthService) UpdateUserCacheInfo(ctx context.Context, token string, userInfo *entity.UserCacheInfo) (err error) {\n\terr = as.authRepo.SetUserCacheInfo(ctx, token, userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := as.authRepo.RemoveUserStatus(ctx, userInfo.UserID); err != nil {\n\t\tlog.Error(err)\n\t}\n\treturn\n}\n\nfunc (as *AuthService) RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error) {\n\treturn as.authRepo.RemoveUserCacheInfo(ctx, accessToken)\n}\n\n// AddUserTokenMapping add user token mapping\nfunc (as *AuthService) AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error) {\n\treturn as.authRepo.AddUserTokenMapping(ctx, userID, accessToken)\n}\n\n// RemoveUserAllTokens Log out all users under this user id\nfunc (as *AuthService) RemoveUserAllTokens(ctx context.Context, userID string) {\n\tas.authRepo.RemoveUserTokens(ctx, userID, \"\")\n}\n\n// RemoveTokensExceptCurrentUser remove all tokens except the current user\nfunc (as *AuthService) RemoveTokensExceptCurrentUser(ctx context.Context, userID string, accessToken string) {\n\tas.authRepo.RemoveUserTokens(ctx, userID, accessToken)\n}\n\n//Admin\n\nfunc (as *AuthService) GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {\n\treturn as.authRepo.GetAdminUserCacheInfo(ctx, accessToken)\n}\n\nfunc (as *AuthService) SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {\n\terr = as.authRepo.SetAdminUserCacheInfo(ctx, accessToken, userInfo)\n\treturn err\n}\n\nfunc (as *AuthService) RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error) {\n\treturn as.authRepo.RemoveAdminUserCacheInfo(ctx, accessToken)\n}\n", "package user_admin\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/mail\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// UserAdminRepo user repository\ntype UserAdminRepo interface {\n\tUpdateUserStatus(ctx context.Context, userID string, userStatus, mailStatus int, email string) (err error)\n\tGetUserInfo(ctx context.Context, userID string) (user *entity.User, exist bool, err error)\n\tGetUserInfoByEmail(ctx context.Context, email string) (user *entity.User, exist bool, err error)\n\tGetUserPage(ctx context.Context, page, pageSize int, user *entity.User,\n\t\tusernameOrDisplayName string, isStaff bool) (users []*entity.User, total int64, err error)\n\tAddUser(ctx context.Context, user *entity.User) (err error)\n\tUpdateUserPassword(ctx context.Context, userID string, password string) (err error)\n}\n\n// UserAdminService user service\ntype UserAdminService struct {\n\tuserRepo           UserAdminRepo\n\tuserRoleRelService *role.UserRoleRelService\n\tauthService        *auth.AuthService\n\tuserCommonService  *usercommon.UserCommon\n\tuserActivity       activity.UserActiveActivityRepo\n}\n\n// NewUserAdminService new user admin service\nfunc NewUserAdminService(\n\tuserRepo UserAdminRepo,\n\tuserRoleRelService *role.UserRoleRelService,\n\tauthService *auth.AuthService,\n\tuserCommonService *usercommon.UserCommon,\n\tuserActivity activity.UserActiveActivityRepo,\n) *UserAdminService {\n\treturn &UserAdminService{\n\t\tuserRepo:           userRepo,\n\t\tuserRoleRelService: userRoleRelService,\n\t\tauthService:        authService,\n\t\tuserCommonService:  userCommonService,\n\t\tuserActivity:       userActivity,\n\t}\n}\n\n// UpdateUserStatus update user\nfunc (us *UserAdminService) UpdateUserStatus(ctx context.Context, req *schema.UpdateUserStatusReq) (err error) {\n\t// Admin cannot modify their status\n\tif req.UserID == req.LoginUserID {\n\t\treturn errors.BadRequest(reason.AdminCannotModifySelfStatus)\n\t}\n\tuserInfo, exist, err := us.userRepo.GetUserInfo(ctx, req.UserID)\n\tif err != nil {\n\t\treturn\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\t// if user status is deleted\n\tif userInfo.Status == entity.UserStatusDeleted {\n\t\treturn nil\n\t}\n\n\tif req.IsInactive() {\n\t\tuserInfo.MailStatus = entity.EmailStatusToBeVerified\n\t}\n\tif req.IsDeleted() {\n\t\tuserInfo.Status = entity.UserStatusDeleted\n\t\tuserInfo.EMail = fmt.Sprintf(\"%s.%d\", userInfo.EMail, time.Now().UnixNano())\n\t}\n\tif req.IsSuspended() {\n\t\tuserInfo.Status = entity.UserStatusSuspended\n\t}\n\tif req.IsNormal() {\n\t\tuserInfo.Status = entity.UserStatusAvailable\n\t\tuserInfo.MailStatus = entity.EmailStatusAvailable\n\t}\n\n\terr = us.userRepo.UpdateUserStatus(ctx, userInfo.ID, userInfo.Status, userInfo.MailStatus, userInfo.EMail)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// if user reputation is zero means this user is inactive, so try to activate this user.\n\tif req.IsNormal() && userInfo.Rank == 0 {\n\t\treturn us.userActivity.UserActive(ctx, userInfo.ID)\n\t}\n\treturn nil\n}\n\n// UpdateUserRole update user role\nfunc (us *UserAdminService) UpdateUserRole(ctx context.Context, req *schema.UpdateUserRoleReq) (err error) {\n\t// Users cannot modify their roles\n\tif req.UserID == req.LoginUserID {\n\t\treturn errors.BadRequest(reason.UserCannotUpdateYourRole)\n\t}\n\n\terr = us.userRoleRelService.SaveUserRole(ctx, req.UserID, req.RoleID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tus.authService.RemoveUserAllTokens(ctx, req.UserID)\n\treturn\n}\n\n// AddUser add user\nfunc (us *UserAdminService) AddUser(ctx context.Context, req *schema.AddUserReq) (err error) {\n\t_, has, err := us.userRepo.GetUserInfoByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif has {\n\t\treturn errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\thashPwd, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tuserInfo := &entity.User{}\n\tuserInfo.EMail = req.Email\n\tuserInfo.DisplayName = req.DisplayName\n\tuserInfo.Pass = string(hashPwd)\n\n\tuserInfo.Username, err = us.userCommonService.MakeUsername(ctx, userInfo.DisplayName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tuserInfo.MailStatus = entity.EmailStatusAvailable\n\tuserInfo.Status = entity.UserStatusAvailable\n\tuserInfo.Rank = 1\n\n\terr = us.userRepo.AddUser(ctx, userInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn\n}\n\n// UpdateUserPassword update user password\nfunc (us *UserAdminService) UpdateUserPassword(ctx context.Context, req *schema.UpdateUserPasswordReq) (err error) {\n\t// Users cannot modify their password\n\tif req.UserID == req.LoginUserID {\n\t\treturn errors.BadRequest(reason.AdminCannotUpdateTheirPassword)\n\t}\n\tuserInfo, exist, err := us.userRepo.GetUserInfo(ctx, req.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\n\thashPwd, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = us.userRepo.UpdateUserPassword(ctx, userInfo.ID, string(hashPwd))\n\tif err != nil {\n\t\treturn err\n\t}\n\t// logout this user\n\tus.authService.RemoveUserAllTokens(ctx, req.UserID)\n\treturn\n}\n\n// GetUserInfo get user one\nfunc (us *UserAdminService) GetUserInfo(ctx context.Context, userID string) (resp *schema.GetUserInfoResp, err error) {\n\tuser, exist, err := us.userRepo.GetUserInfo(ctx, userID)\n\tif err != nil {\n\t\treturn\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\n\tresp = &schema.GetUserInfoResp{}\n\t_ = copier.Copy(resp, user)\n\treturn resp, nil\n}\n\n// GetUserPage get user list page\nfunc (us *UserAdminService) GetUserPage(ctx context.Context, req *schema.GetUserPageReq) (pageModel *pager.PageModel, err error) {\n\tuser := &entity.User{}\n\t_ = copier.Copy(user, req)\n\n\tif req.IsInactive() {\n\t\tuser.MailStatus = entity.EmailStatusToBeVerified\n\t\tuser.Status = entity.UserStatusAvailable\n\t} else if req.IsSuspended() {\n\t\tuser.Status = entity.UserStatusSuspended\n\t} else if req.IsDeleted() {\n\t\tuser.Status = entity.UserStatusDeleted\n\t}\n\n\tif len(req.Query) > 0 {\n\t\tif email, e := mail.ParseAddress(req.Query); e == nil {\n\t\t\tuser.EMail = email.Address\n\t\t\treq.Query = \"\"\n\t\t} else if strings.HasPrefix(req.Query, \"user:\") {\n\t\t\tid := strings.TrimSpace(strings.TrimPrefix(req.Query, \"user:\"))\n\t\t\tidSearch := true\n\t\t\tfor _, r := range id {\n\t\t\t\tif !unicode.IsDigit(r) {\n\t\t\t\t\tidSearch = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif idSearch {\n\t\t\t\tuser.ID = id\n\t\t\t\treq.Query = \"\"\n\t\t\t} else {\n\t\t\t\treq.Query = id\n\t\t\t}\n\t\t}\n\t}\n\n\tusers, total, err := us.userRepo.GetUserPage(ctx, req.Page, req.PageSize, user, req.Query, req.Staff)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tresp := make([]*schema.GetUserPageResp, 0)\n\tfor _, u := range users {\n\t\tavatar := schema.FormatAvatarInfo(u.Avatar, u.EMail)\n\t\tt := &schema.GetUserPageResp{\n\t\t\tUserID:      u.ID,\n\t\t\tCreatedAt:   u.CreatedAt.Unix(),\n\t\t\tUsername:    u.Username,\n\t\t\tEMail:       u.EMail,\n\t\t\tRank:        u.Rank,\n\t\t\tDisplayName: u.DisplayName,\n\t\t\tAvatar:      avatar,\n\t\t}\n\t\tif u.Status == entity.UserStatusDeleted {\n\t\t\tt.Status = schema.UserDeleted\n\t\t\tt.DeletedAt = u.DeletedAt.Unix()\n\t\t} else if u.Status == entity.UserStatusSuspended {\n\t\t\tt.Status = schema.UserSuspended\n\t\t\tt.SuspendedAt = u.SuspendedAt.Unix()\n\t\t} else if u.MailStatus == entity.EmailStatusToBeVerified {\n\t\t\tt.Status = schema.UserInactive\n\t\t} else {\n\t\t\tt.Status = schema.UserNormal\n\t\t}\n\t\tresp = append(resp, t)\n\t}\n\tus.setUserRoleInfo(ctx, resp)\n\treturn pager.NewPageModel(total, resp), nil\n}\n\nfunc (us *UserAdminService) setUserRoleInfo(ctx context.Context, resp []*schema.GetUserPageResp) {\n\tvar userIDs []string\n\tfor _, u := range resp {\n\t\tuserIDs = append(userIDs, u.UserID)\n\t}\n\n\tuserRoleMapping, err := us.userRoleRelService.GetUserRoleMapping(ctx, userIDs)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn\n\t}\n\n\tfor _, u := range resp {\n\t\tr := userRoleMapping[u.UserID]\n\t\tif r == nil {\n\t\t\tcontinue\n\t\t}\n\t\tu.RoleID = r.ID\n\t\tu.RoleName = r.Name\n\t}\n}\n", "package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\t\"github.com/answerdev/answer/internal/service/service_config\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/google/uuid\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// UserRepo user repository\n\n// UserService user service\ntype UserService struct {\n\tuserCommonService *usercommon.UserCommon\n\tuserRepo          usercommon.UserRepo\n\tuserActivity      activity.UserActiveActivityRepo\n\tactivityRepo      activity_common.ActivityRepo\n\tserviceConfig     *service_config.ServiceConfig\n\temailService      *export.EmailService\n\tauthService       *auth.AuthService\n\tsiteInfoService   *siteinfo_common.SiteInfoCommonService\n\tuserRoleService   *role.UserRoleRelService\n}\n\nfunc NewUserService(userRepo usercommon.UserRepo,\n\tuserActivity activity.UserActiveActivityRepo,\n\tactivityRepo activity_common.ActivityRepo,\n\temailService *export.EmailService,\n\tauthService *auth.AuthService,\n\tserviceConfig *service_config.ServiceConfig,\n\tsiteInfoService *siteinfo_common.SiteInfoCommonService,\n\tuserRoleService *role.UserRoleRelService,\n\tuserCommonService *usercommon.UserCommon,\n) *UserService {\n\treturn &UserService{\n\t\tuserCommonService: userCommonService,\n\t\tuserRepo:          userRepo,\n\t\tuserActivity:      userActivity,\n\t\tactivityRepo:      activityRepo,\n\t\temailService:      emailService,\n\t\tserviceConfig:     serviceConfig,\n\t\tauthService:       authService,\n\t\tsiteInfoService:   siteInfoService,\n\t\tuserRoleService:   userRoleService,\n\t}\n}\n\n// GetUserInfoByUserID get user info by user id\nfunc (us *UserService) GetUserInfoByUserID(ctx context.Context, token, userID string) (resp *schema.GetUserToSetShowResp, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\tresp = &schema.GetUserToSetShowResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tresp.AccessToken = token\n\tresp.RoleID = roleID\n\tresp.HavePassword = len(userInfo.Pass) > 0\n\treturn resp, nil\n}\n\nfunc (us *UserService) GetOtherUserInfoByUsername(ctx context.Context, username string) (\n\tresp *schema.GetOtherUserInfoByUsernameResp, err error,\n) {\n\tuserInfo, exist, err := us.userRepo.GetByUsername(ctx, username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.NotFound(reason.UserNotFound)\n\t}\n\tresp = &schema.GetOtherUserInfoByUsernameResp{}\n\tresp.GetFromUserEntity(userInfo)\n\treturn resp, nil\n}\n\n// EmailLogin email login\nfunc (us *UserService) EmailLogin(ctx context.Context, req *schema.UserEmailLogin) (resp *schema.GetUserResp, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist || userInfo.Status == entity.UserStatusDeleted {\n\t\treturn nil, errors.BadRequest(reason.EmailOrPasswordWrong)\n\t}\n\tif !us.verifyPassword(ctx, req.Pass, userInfo.Pass) {\n\t\treturn nil, errors.BadRequest(reason.EmailOrPasswordWrong)\n\t}\n\n\terr = us.userRepo.UpdateLastLoginDate(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(\"UpdateLastLoginDate\", err.Error())\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tRoleID:      roleID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp.RoleID = userCacheInfo.RoleID\n\tif resp.RoleID == role.RoleAdminID {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, userCacheInfo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn resp, nil\n}\n\n// RetrievePassWord .\nfunc (us *UserService) RetrievePassWord(ctx context.Context, req *schema.UserRetrievePassWordRequest) error {\n\tuserInfo, has, err := us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn nil\n\t}\n\n\t// send email\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  req.Email,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/password-reset?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.PassResetTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, req.Email, title, body, code, data.ToJSONString())\n\treturn nil\n}\n\n// UpdatePasswordWhenForgot update user password when user forgot password\nfunc (us *UserService) UpdatePasswordWhenForgot(ctx context.Context, req *schema.UserRePassWordRequest) (err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil {\n\t\treturn errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\tenpass, err := us.encryptPassword(ctx, req.Pass)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = us.userRepo.UpdatePass(ctx, userInfo.ID, enpass)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// When the user changes the password, all the current user's tokens are invalid.\n\tus.authService.RemoveUserAllTokens(ctx, userInfo.ID)\n\treturn nil\n}\n\nfunc (us *UserService) UserModifyPassWordVerification(ctx context.Context, req *schema.UserModifyPasswordReq) (bool, error) {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, req.UserID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !has {\n\t\treturn false, errors.BadRequest(reason.UserNotFound)\n\t}\n\tisPass := us.verifyPassword(ctx, req.OldPass, userInfo.Pass)\n\tif !isPass {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}\n\n// UserModifyPassword user modify password\nfunc (us *UserService) UserModifyPassword(ctx context.Context, req *schema.UserModifyPasswordReq) error {\n\tenpass, err := us.encryptPassword(ctx, req.Pass)\n\tif err != nil {\n\t\treturn err\n\t}\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, req.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\n\tisPass := us.verifyPassword(ctx, req.OldPass, userInfo.Pass)\n\tif !isPass {\n\t\treturn errors.BadRequest(reason.OldPasswordVerificationFailed)\n\t}\n\terr = us.userRepo.UpdatePass(ctx, userInfo.ID, enpass)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tus.authService.RemoveTokensExceptCurrentUser(ctx, userInfo.ID, req.AccessToken)\n\treturn nil\n}\n\n// UpdateInfo update user info\nfunc (us *UserService) UpdateInfo(ctx context.Context, req *schema.UpdateInfoRequest) (\n\terrFields []*validator.FormErrorField, err error) {\n\tif len(req.Username) > 0 {\n\t\tuserInfo, exist, err := us.userRepo.GetByUsername(ctx, req.Username)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif exist && userInfo.ID != req.UserID {\n\t\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameDuplicate,\n\t\t\t})\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameDuplicate)\n\t\t}\n\t\tif checker.IsReservedUsername(req.Username) {\n\t\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t\t})\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t\t}\n\t}\n\tavatar, err := json.Marshal(req.Avatar)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.UserSetAvatar).WithError(err).WithStack()\n\t}\n\tuserInfo := entity.User{}\n\tuserInfo.ID = req.UserID\n\tuserInfo.Avatar = string(avatar)\n\tuserInfo.DisplayName = req.DisplayName\n\tuserInfo.Bio = req.Bio\n\tuserInfo.BioHTML = req.BioHTML\n\tuserInfo.Location = req.Location\n\tuserInfo.Website = req.Website\n\tuserInfo.Username = req.Username\n\terr = us.userRepo.UpdateInfo(ctx, &userInfo)\n\treturn nil, err\n}\n\nfunc (us *UserService) UserEmailHas(ctx context.Context, email string) (bool, error) {\n\t_, has, err := us.userRepo.GetByEmail(ctx, email)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn has, nil\n}\n\n// UserUpdateInterface update user interface\nfunc (us *UserService) UserUpdateInterface(ctx context.Context, req *schema.UpdateUserInterfaceRequest) (err error) {\n\tif !translator.CheckLanguageIsValid(req.Language) {\n\t\treturn errors.BadRequest(reason.LangNotFound)\n\t}\n\terr = us.userRepo.UpdateLanguage(ctx, req.UserId, req.Language)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn nil\n}\n\n// UserRegisterByEmail user register\nfunc (us *UserService) UserRegisterByEmail(ctx context.Context, registerUserInfo *schema.UserRegisterReq) (\n\tresp *schema.GetUserResp, errFields []*validator.FormErrorField, err error,\n) {\n\t_, has, err := us.userRepo.GetByEmail(ctx, registerUserInfo.Email)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif has {\n\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   reason.EmailDuplicate,\n\t\t})\n\t\treturn nil, errFields, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tuserInfo := &entity.User{}\n\tuserInfo.EMail = registerUserInfo.Email\n\tuserInfo.DisplayName = registerUserInfo.Name\n\tuserInfo.Pass, err = us.encryptPassword(ctx, registerUserInfo.Pass)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tuserInfo.Username, err = us.userCommonService.MakeUsername(ctx, registerUserInfo.Name)\n\tif err != nil {\n\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\tErrorField: \"name\",\n\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t})\n\t\treturn nil, errFields, err\n\t}\n\tuserInfo.IPInfo = registerUserInfo.IP\n\tuserInfo.MailStatus = entity.EmailStatusToBeVerified\n\tuserInfo.Status = entity.UserStatusAvailable\n\tuserInfo.LastLoginDate = time.Now()\n\terr = us.userRepo.AddUser(ctx, userInfo)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// send email\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  registerUserInfo.Email,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/account-activation?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, userInfo.EMail, title, body, code, data.ToJSONString())\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\t// return user info and token\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tRoleID:      roleID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tresp.RoleID = userCacheInfo.RoleID\n\tif resp.RoleID == role.RoleAdminID {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\treturn resp, nil, nil\n}\n\nfunc (us *UserService) UserVerifyEmailSend(ctx context.Context, userID string) error {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  userInfo.EMail,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/account-activation?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, userInfo.EMail, title, body, code, data.ToJSONString())\n\treturn nil\n}\n\nfunc (us *UserService) UserNoticeSet(ctx context.Context, userID string, noticeSwitch bool) (\n\tresp *schema.UserNoticeSetResp, err error,\n) {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !has {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tif noticeSwitch {\n\t\tuserInfo.NoticeStatus = schema.NoticeStatusOn\n\t} else {\n\t\tuserInfo.NoticeStatus = schema.NoticeStatusOff\n\t}\n\terr = us.userRepo.UpdateNoticeStatus(ctx, userInfo.ID, userInfo.NoticeStatus)\n\treturn &schema.UserNoticeSetResp{NoticeSwitch: noticeSwitch}, err\n}\n\nfunc (us *UserService) UserVerifyEmail(ctx context.Context, req *schema.UserVerifyEmailReq) (resp *schema.GetUserResp, err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, has, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !has {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tuserInfo.MailStatus = entity.EmailStatusAvailable\n\terr = us.userRepo.UpdateEmailStatus(ctx, userInfo.ID, userInfo.MailStatus)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = us.userActivity.UserActive(ctx, userInfo.ID); err != nil {\n\t\tlog.Error(err)\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tRoleID:      roleID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// User verified email will update user email status. So user status cache should be updated.\n\tif err = us.authService.SetUserStatus(ctx, userCacheInfo); err != nil {\n\t\treturn nil, err\n\t}\n\tresp.RoleID = userCacheInfo.RoleID\n\tif resp.RoleID == role.RoleAdminID {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn resp, nil\n}\n\n// verifyPassword\n// Compare whether the password is correct\nfunc (us *UserService) verifyPassword(ctx context.Context, loginPass, userPass string) bool {\n\tif len(loginPass) == 0 && len(userPass) == 0 {\n\t\treturn true\n\t}\n\terr := bcrypt.CompareHashAndPassword([]byte(userPass), []byte(loginPass))\n\treturn err == nil\n}\n\n// encryptPassword\n// The password does irreversible encryption.\nfunc (us *UserService) encryptPassword(ctx context.Context, Pass string) (string, error) {\n\thashPwd, err := bcrypt.GenerateFromPassword([]byte(Pass), bcrypt.DefaultCost)\n\t// This encrypted string can be saved to the database and can be used as password matching verification\n\treturn string(hashPwd), err\n}\n\n// UserChangeEmailSendCode user change email verification\nfunc (us *UserService) UserChangeEmailSendCode(ctx context.Context, req *schema.UserChangeEmailSendCodeReq) (\n\tresp []*validator.FormErrorField, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, req.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\n\t// If user's email already verified, then must verify password first.\n\tif userInfo.MailStatus == entity.EmailStatusAvailable && !us.verifyPassword(ctx, req.Pass, userInfo.Pass) {\n\t\tresp = append(resp, &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLangByCtx(ctx), reason.OldPasswordVerificationFailed),\n\t\t})\n\t\treturn resp, errors.BadRequest(reason.OldPasswordVerificationFailed)\n\t}\n\n\t_, exist, err = us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif exist {\n\t\tresp = append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLangByCtx(ctx), reason.EmailDuplicate),\n\t\t})\n\t\treturn resp, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  req.Email,\n\t\tUserID: req.UserID,\n\t}\n\tcode := uuid.NewString()\n\tvar title, body string\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/confirm-new-email?code=%s\", us.getSiteUrl(ctx), code)\n\tif userInfo.MailStatus == entity.EmailStatusToBeVerified {\n\t\ttitle, body, err = us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\t} else {\n\t\ttitle, body, err = us.emailService.ChangeEmailTemplate(ctx, verifyEmailURL)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlog.Infof(\"send email confirmation %s\", verifyEmailURL)\n\n\tgo us.emailService.SendAndSaveCode(context.Background(), req.Email, title, body, code, data.ToJSONString())\n\treturn nil, nil\n}\n\n// UserChangeEmailVerify user change email verify code\nfunc (us *UserService) UserChangeEmailVerify(ctx context.Context, content string) (resp *schema.GetUserResp, err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(content)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\t_, exist, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif exist {\n\t\treturn nil, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, data.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\terr = us.userRepo.UpdateEmail(ctx, data.UserID, data.Email)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\terr = us.userRepo.UpdateEmailStatus(ctx, data.UserID, entity.EmailStatusAvailable)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: entity.EmailStatusAvailable,\n\t\tUserStatus:  userInfo.Status,\n\t\tRoleID:      roleID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// User verified email will update user email status. So user status cache should be updated.\n\tif err = us.authService.SetUserStatus(ctx, userCacheInfo); err != nil {\n\t\treturn nil, err\n\t}\n\tresp.RoleID = userCacheInfo.RoleID\n\tif resp.RoleID == role.RoleAdminID {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn resp, nil\n}\n\n// getSiteUrl get site url\nfunc (us *UserService) getSiteUrl(ctx context.Context) string {\n\tsiteGeneral, err := us.siteInfoService.GetSiteGeneral(ctx)\n\tif err != nil {\n\t\tlog.Errorf(\"get site general failed: %s\", err)\n\t\treturn \"\"\n\t}\n\treturn siteGeneral.SiteUrl\n}\n\n// UserRanking get user ranking\nfunc (us *UserService) UserRanking(ctx context.Context) (resp *schema.UserRankingResp, err error) {\n\tlimit := 20\n\tendTime := time.Now()\n\tstartTime := endTime.AddDate(0, 0, -7)\n\tuserIDs, userIDExist := make([]string, 0), make(map[string]bool, 0)\n\n\t// get most reputation users\n\trankStat, rankStatUserIDs, err := us.getActivityUserRankStat(ctx, startTime, endTime, limit, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, rankStatUserIDs...)\n\n\t// get most vote users\n\tvoteStat, voteStatUserIDs, err := us.getActivityUserVoteStat(ctx, startTime, endTime, limit, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, voteStatUserIDs...)\n\n\t// get all staff members\n\tuserRoleRels, staffUserIDs, err := us.getStaff(ctx, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, staffUserIDs...)\n\n\t// get user information\n\tuserInfoMapping, err := us.getUserInfoMapping(ctx, userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn us.warpStatRankingResp(userInfoMapping, rankStat, voteStat, userRoleRels), nil\n}\n\n// UserUnsubscribeEmailNotification user unsubscribe email notification\nfunc (us *UserService) UserUnsubscribeEmailNotification(\n\tctx context.Context, req *schema.UserUnsubscribeEmailNotificationReq) (err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil || len(data.UserID) == 0 {\n\t\treturn errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, data.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\treturn us.userRepo.UpdateNoticeStatus(ctx, userInfo.ID, schema.NoticeStatusOff)\n}\n\nfunc (us *UserService) getActivityUserRankStat(ctx context.Context, startTime, endTime time.Time, limit int,\n\tuserIDExist map[string]bool) (rankStat []*entity.ActivityUserRankStat, userIDs []string, err error) {\n\trankStat, err = us.activityRepo.GetUsersWhoHasGainedTheMostReputation(ctx, startTime, endTime, limit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, stat := range rankStat {\n\t\tif stat.Rank <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userIDExist[stat.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, stat.UserID)\n\t\tuserIDExist[stat.UserID] = true\n\t}\n\treturn rankStat, userIDs, nil\n}\n\nfunc (us *UserService) getActivityUserVoteStat(ctx context.Context, startTime, endTime time.Time, limit int,\n\tuserIDExist map[string]bool) (voteStat []*entity.ActivityUserVoteStat, userIDs []string, err error) {\n\tvoteStat, err = us.activityRepo.GetUsersWhoHasVoteMost(ctx, startTime, endTime, limit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, stat := range voteStat {\n\t\tif stat.VoteCount <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userIDExist[stat.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, stat.UserID)\n\t\tuserIDExist[stat.UserID] = true\n\t}\n\treturn voteStat, userIDs, nil\n}\n\nfunc (us *UserService) getStaff(ctx context.Context, userIDExist map[string]bool) (\n\tuserRoleRels []*entity.UserRoleRel, userIDs []string, err error) {\n\tuserRoleRels, err = us.userRoleService.GetUserByRoleID(ctx, []int{role.RoleAdminID, role.RoleModeratorID})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, rel := range userRoleRels {\n\t\tif userIDExist[rel.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, rel.UserID)\n\t\tuserIDExist[rel.UserID] = true\n\t}\n\treturn userRoleRels, userIDs, nil\n}\n\nfunc (us *UserService) getUserInfoMapping(ctx context.Context, userIDs []string) (\n\tuserInfoMapping map[string]*entity.User, err error) {\n\tuserInfoMapping = make(map[string]*entity.User, 0)\n\tif len(userIDs) == 0 {\n\t\treturn userInfoMapping, nil\n\t}\n\tuserInfoList, err := us.userRepo.BatchGetByID(ctx, userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, user := range userInfoList {\n\t\tuser.Avatar = schema.FormatAvatarInfo(user.Avatar, user.EMail)\n\t\tuserInfoMapping[user.ID] = user\n\t}\n\treturn userInfoMapping, nil\n}\n\nfunc (us *UserService) warpStatRankingResp(\n\tuserInfoMapping map[string]*entity.User,\n\trankStat []*entity.ActivityUserRankStat,\n\tvoteStat []*entity.ActivityUserVoteStat,\n\tuserRoleRels []*entity.UserRoleRel) (resp *schema.UserRankingResp) {\n\tresp = &schema.UserRankingResp{\n\t\tUsersWithTheMostReputation: make([]*schema.UserRankingSimpleInfo, 0),\n\t\tUsersWithTheMostVote:       make([]*schema.UserRankingSimpleInfo, 0),\n\t\tStaffs:                     make([]*schema.UserRankingSimpleInfo, 0),\n\t}\n\tfor _, stat := range rankStat {\n\t\tif stat.Rank <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userInfo := userInfoMapping[stat.UserID]; userInfo != nil {\n\t\t\tresp.UsersWithTheMostReputation = append(resp.UsersWithTheMostReputation, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tRank:        stat.Rank,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\tfor _, stat := range voteStat {\n\t\tif stat.VoteCount <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userInfo := userInfoMapping[stat.UserID]; userInfo != nil {\n\t\t\tresp.UsersWithTheMostVote = append(resp.UsersWithTheMostVote, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tVoteCount:   stat.VoteCount,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\tfor _, rel := range userRoleRels {\n\t\tif userInfo := userInfoMapping[rel.UserID]; userInfo != nil {\n\t\t\tresp.Staffs = append(resp.Staffs, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tRank:        userInfo.Rank,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\treturn resp\n}\n"], "filenames": ["internal/controller/user_controller.go", "internal/repo/auth/auth.go", "internal/schema/user_schema.go", "internal/service/auth/auth.go", "internal/service/user_admin/user_backyard.go", "internal/service/user_service.go"], "buggy_code_start_loc": [186, 151, 74, 23, 119, 84], "buggy_code_end_loc": [345, 160, 271, 91, 183, 482], "fixing_code_start_loc": [186, 151, 75, 23, 119, 85], "fixing_code_end_loc": [347, 164, 275, 96, 183, 490], "type": "CWE-613", "message": "Insufficient Session Expiration in GitHub repository answerdev/answer prior to v1.1.0.", "other": {"cve": {"id": "CVE-2023-4126", "sourceIdentifier": "security@huntr.dev", "published": "2023-08-03T04:15:11.620", "lastModified": "2023-08-08T16:51:35.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insufficient Session Expiration in GitHub repository answerdev/answer prior to v1.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.0", "matchCriteriaId": "DA293827-A320-409B-9F14-132EB52BA0C8"}]}]}], "references": [{"url": "https://github.com/answerdev/answer/commit/4f468b58d0dea51290bfbdd3e96332b0014c8730", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/7f50bf1c-bcb9-46ca-8cec-211493d280c5", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/4f468b58d0dea51290bfbdd3e96332b0014c8730"}}