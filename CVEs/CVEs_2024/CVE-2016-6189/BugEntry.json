{"buggy_code": ["/* SOGoCalendarComponent.m - this file is part of SOGo\n *\n * Copyright (C) 2006-2014 Inverse inc.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n#import <Foundation/NSAutoreleasePool.h>\n#import <Foundation/NSDictionary.h>\n#import <Foundation/NSEnumerator.h>\n#import <Foundation/NSProcessInfo.h>\n#import <Foundation/NSString.h>\n#import <Foundation/NSValue.h>\n\n#import <NGObjWeb/NSException+HTTP.h>\n#import <NGObjWeb/SoSecurityManager.h>\n#import <NGObjWeb/WOApplication.h>\n#import <NGObjWeb/WOContext+SoObjects.h>\n#import <NGObjWeb/WORequest+So.h>\n#import <NGExtensions/NSObject+Logs.h>\n#import <NGExtensions/NGHashMap.h>\n#import <NGExtensions/NGQuotedPrintableCoding.h>\n#import <NGCards/iCalCalendar.h>\n#import <NGCards/iCalDateTime.h>\n#import <NGCards/iCalEvent.h>\n#import <NGCards/iCalPerson.h>\n#import <NGCards/iCalRepeatableEntityObject.h>\n#import <NGMime/NGMimeBodyPart.h>\n#import <NGMime/NGMimeMultipartBody.h>\n#import <NGMail/NGMimeMessage.h>\n#import <GDLContentStore/GCSFolder.h>\n\n#import <SOGo/NSCalendarDate+SOGo.h>\n#import <SOGo/NSDictionary+Utilities.h>\n#import <SOGo/NSObject+DAV.h>\n#import <SOGo/NSObject+Utilities.h>\n#import <SOGo/NSString+Utilities.h>\n#import <SOGo/SOGoBuild.h>\n#import <SOGo/SOGoDomainDefaults.h>\n#import <SOGo/SOGoMailer.h>\n#import <SOGo/SOGoGroup.h>\n#import <SOGo/SOGoPermissions.h>\n#import <SOGo/SOGoUser.h>\n#import <SOGo/SOGoUserDefaults.h>\n#import <SOGo/SOGoSystemDefaults.h>\n#import <SOGo/SOGoUserManager.h>\n#import <SOGo/SOGoWebDAVAclManager.h>\n#import <SOGo/WORequest+SOGo.h>\n#import <Appointments/SOGoAppointmentFolder.h>\n#import <Mailer/NSString+Mail.h>\n\n#import \"SOGoAptMailICalReply.h\"\n#import \"SOGoAptMailNotification.h\"\n#import \"SOGoAptMailReceipt.h\"\n#import \"SOGoEMailAlarmsManager.h\"\n#import \"iCalEntityObject+SOGo.h\"\n#import \"iCalPerson+SOGo.h\"\n#import \"iCalRepeatableEntityObject+SOGo.h\"\n#import \"SOGoCalendarComponent.h\"\n#import \"SOGoComponentOccurence.h\"\n\n@implementation SOGoCalendarComponent\n\n+ (SOGoWebDAVAclManager *) webdavAclManager\n{\n  static SOGoWebDAVAclManager *aclManager = nil;\n  NSString *nsD, *nsI;\n\n  if (!aclManager)\n    {\n      nsD = @\"DAV:\";\n      nsI = @\"urn:inverse:params:xml:ns:inverse-dav\";\n\n      aclManager = [SOGoWebDAVAclManager new];\n\n      [aclManager registerDAVPermission: davElement (@\"read\", nsD)\n\t\t  abstract: NO\n                  withEquivalent: @\"SOGoDAVReadPermission\" /* hackish */\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"view-whole-component\", nsI)\n\t\t  abstract: NO\n\t\t  withEquivalent: SOGoCalendarPerm_ViewAllComponent\n                  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"view-date-and-time\", nsI)\n\t\t  abstract: NO\n\t\t  withEquivalent: SOGoCalendarPerm_ViewDAndT\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"read-current-user-privilege-set\", nsD)\n\t\t  abstract: NO\n\t\t  withEquivalent: SoPerm_WebDAVAccess\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"write\", nsD)\n\t\t  abstract: NO\n\t\t  withEquivalent: SOGoCalendarPerm_ModifyComponent\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager\n\tregisterDAVPermission: davElement (@\"write-properties\", nsD)\n\tabstract: YES\n\twithEquivalent: SoPerm_ChangePermissions /* hackish */\n\tasChildOf: davElement (@\"write\", nsD)];\n      [aclManager\n\tregisterDAVPermission: davElement (@\"write-content\", nsD)\n\tabstract: YES\n\twithEquivalent: nil\n\tasChildOf: davElement (@\"write\", nsD)];\n      [aclManager\n        registerDAVPermission: davElement (@\"respond-to-component\", nsI)\n                     abstract: NO\n               withEquivalent: SOGoCalendarPerm_RespondToComponent\n                    asChildOf: davElement (@\"write-content\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"admin\", nsI)\n\t\t  abstract: YES\n\t\t  withEquivalent: nil\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager\n\tregisterDAVPermission: davElement (@\"read-acl\", nsD)\n\tabstract: YES\n\twithEquivalent: SOGoPerm_ReadAcls\n\tasChildOf: davElement (@\"admin\", nsI)];\n      [aclManager\n\tregisterDAVPermission: davElement (@\"write-acl\", nsD)\n\tabstract: YES\n\twithEquivalent: nil\n\tasChildOf: davElement (@\"admin\", nsI)];\n    }\n\n  return aclManager;\n}\n\n- (NSException *) changeParticipationStatus: (NSString *) newPartStat\n                               withDelegate: (iCalPerson *) delegate\n                                      alarm: (iCalAlarm *) alarm\n{\n  // Required for protocol <SOGoComponentOccurence>\n  return nil;\n}\n\n- (id) init\n{\n  if ((self = [super init]))\n    {\n      fullCalendar = nil;\n      safeCalendar = nil;\n      originalCalendar = nil;\n      componentTag = nil;\n    }\n\n  return self;\n}\n\n- (void) dealloc\n{\n  [fullCalendar release];\n  [safeCalendar release];\n  [originalCalendar release];\n  [componentTag release];\n  [super dealloc];\n}\n\n- (void) flush\n{\n  DESTROY(fullCalendar);\n  DESTROY(safeCalendar);\n  DESTROY(originalCalendar);\n}\n\n- (Class *) parsingClass\n{\n  return (Class *)[iCalCalendar class];\n}\n\n- (NSString *) davContentType\n{\n  return @\"text/calendar\";\n}\n\n- (NSString *) componentTag\n{\n  if (!componentTag)\n    [self subclassResponsibility: _cmd];\n  \n  return componentTag;\n}\n\n- (void) setComponentTag: (NSString *) theTag\n{\n  ASSIGN(componentTag, theTag);\n}\n\n- (void) _filterComponent: (iCalEntityObject *) component\n{\n  NSString *type, *summary, *tag;\n  NSArray *children;\n\n  int classification, i;\n\n  type = @\"vtodo\";\n  classification = 0;\n\n  if ([component isKindOfClass: [iCalEvent class]])\n    type = @\"vevent\";\n  \n  if ([component symbolicAccessClass] == iCalAccessPrivate)\n    classification = 1;\n  else if ([component symbolicAccessClass] == iCalAccessConfidential)\n    classification = 2;\n\n  summary = [self labelForKey: [NSString stringWithFormat: @\"%@_class%d\",\n                                         type, classification]\n                    inContext: context];\n  [component setSummary: summary];\n  [component setComment: @\"\"];\n  [component setUserComment: @\"\"];\n  [component setLocation: @\"\"];\n  [component setCategories: [NSArray array]];\n  [component setUrl: @\"\"];\n  [component setOrganizer: nil];\n  [component removeAllAttendees];\n  [component removeAllAlarms];\n\n  // We strip all X- tags\n  children = [component children];\n\n  for (i = 0; i < [children count]; i++)\n    {\n      tag = [[children objectAtIndex: i] tag];\n      if ([[tag uppercaseString] hasPrefix: @\"X-\"])\n        [component removeChild: [children objectAtIndex: i]];\n    }\n}\n\n- (NSString *) secureContentAsString\n{\n  iCalRepeatableEntityObject *tmpComponent;\n  iCalCalendar *tmpCalendar;\n  NSArray *allComponents;\n  SoSecurityManager *sm;\n  NSString *iCalString;\n\n  int i;\n\n  sm = [SoSecurityManager sharedSecurityManager];\n  if (activeUserIsOwner\n      || [[self ownerInContext: context] isEqualToString: [[context activeUser] login]]\n      || ![sm validatePermission: SOGoCalendarPerm_ViewAllComponent\n\t      onObject: self inContext: context])\n    iCalString = content;\n  else if (![sm validatePermission: SOGoCalendarPerm_ViewDAndT\n\t\tonObject: self inContext: context])\n    {\n      tmpCalendar = [[self calendar: NO secure: NO] mutableCopy];\n\n      // We filter all components, in case we have RECURRENCE-ID\n      allComponents = [tmpCalendar childrenWithTag: [self componentTag]];\n\n      for (i = 0; i < [allComponents count]; i++)\n        {\n          tmpComponent = (iCalRepeatableEntityObject *)[allComponents objectAtIndex:i];\n          [self _filterComponent: tmpComponent];\n      \n          // We add an additional header here to inform clients (if necessary) that\n          // we churned the content of the calendar.\n          [tmpComponent addChild: [CardElement simpleElementWithTag: @\"X-SOGo-Secure\"\n                                                              value: @\"YES\"]];\n        }\n\n      iCalString = [tmpCalendar versitString];\n      [tmpCalendar release];\n    }\n  else\n    iCalString = nil;\n\n  return iCalString;\n}\n\n- (iCalRepeatableEntityObject *) lookupOccurrence: (NSString *) recID\n{\n  [self subclassResponsibility: _cmd];\n\n  return nil;\n}\n\n- (SOGoComponentOccurence *) occurence: (iCalRepeatableEntityObject *) component\n{\n  [self subclassResponsibility: _cmd];\n\n  return nil;\n}\n\n- (iCalRepeatableEntityObject *) newOccurenceWithID: (NSString *) recID\n{\n  iCalRepeatableEntityObject *masterOccurence, *newOccurence;\n  iCalCalendar *calendar;\n  NSCalendarDate *recDate;\n  NSTimeZone *timeZone;\n  iCalPerson *organizer;\n\n  recDate = [NSCalendarDate dateWithTimeIntervalSince1970: [recID intValue]];\n  masterOccurence = [self component: NO secure: NO];\n  timeZone = [[[context activeUser] userDefaults] timeZone];\n  [recDate setTimeZone: timeZone];\n\n  if ([masterOccurence doesOccurOnDate: recDate])\n    {\n      newOccurence = [masterOccurence mutableCopy];\n      organizer = [masterOccurence organizer];\n      [newOccurence autorelease];\n      [newOccurence removeAllRecurrenceRules];\n      [newOccurence removeAllExceptionRules];\n      [newOccurence removeAllExceptionDates];\n\n      // It is important to set the organizer as some DAV clients (iCal\n      // and Thunderbird 10/Lightning 1.2) will prompt the event \"edition\"\n      // dialog instead of the event \"invitation\" (for accept/decline/tentative)\n      // if the organizer isn't found in a specific recurrence\n      [newOccurence setOrganizer: organizer];\n      [newOccurence setRecurrenceId: recDate];\n\n      calendar = [masterOccurence parent];\n      [calendar addChild: newOccurence];\n    }\n  else\n    newOccurence = nil;\n\n  return newOccurence;\n}\n\n- (id) toManyRelationshipKeys\n{\n  return nil;\n}\n\n- (id) toOneRelationshipKeys\n{\n  NSMutableArray *keys;\n  NSArray *occurences;\n  NSCalendarDate *recID;\n  unsigned int count, max, seconds;\n\n  keys = [NSMutableArray array];\n  [keys addObject: @\"master\"];\n  occurences = [[self calendar: NO secure: NO] allObjects];\n  max = [occurences count];\n  for (count = 1; count < max; count++)\n    {\n      recID = [[occurences objectAtIndex: count] recurrenceId];\n      if (recID)\n\t{\n\t  seconds = [recID timeIntervalSince1970];\n\t  [keys addObject: [NSString stringWithFormat: @\"occurence%d\",\n\t\t\t\t     seconds]];\n\t}\n    }\n\n  return keys;\n}\n\n- (id) lookupName: (NSString *) lookupName\n        inContext: (id) localContext\n          acquire: (BOOL) acquire\n{\n  id obj;\n  iCalRepeatableEntityObject *occurence;\n  NSString *recID;\n  BOOL isNewOccurence;\n\n  obj = [super lookupName: lookupName\n\t       inContext: localContext\n\t       acquire: acquire];\n  if (!obj)\n    {\n      if ([lookupName isEqualToString: @\"master\"])\n\tobj = [self occurence: [self component: NO secure: NO]];\n      else if ([lookupName hasPrefix: @\"occurence\"])\n\t{\n\t  recID = [lookupName substringFromIndex: 9];\n\t  occurence = [self lookupOccurrence: recID];\n\t  if (occurence)\n            isNewOccurence = NO;\n          else\n\t    {\n\t      occurence = [self newOccurenceWithID: recID];\n\t      isNewOccurence = YES;\n\t    }\n\t  if (occurence)\n\t    {\n\t      obj = [self occurence: occurence];\n\t      if (isNewOccurence)\n\t\t[obj setIsNew: isNewOccurence];\n\t    }\n\t}\n    }\n\n  return obj;\n}\n\n- (NSString *) _secureContentWithoutAlarms\n{\n  iCalCalendar *calendar;\n  NSArray *allComponents;\n  iCalEntityObject *currentComponent;\n  NSUInteger count, max;\n\n  calendar = [self calendar: NO secure: YES];\n  allComponents = [calendar childrenWithTag: [self componentTag]];\n  max = [allComponents count];\n  for (count = 0; count < max; count++)\n    {\n      currentComponent = [allComponents objectAtIndex: count];\n      [currentComponent removeAllAlarms];\n    }\n\n  return [calendar versitString];\n}\n\n- (NSString *) contentAsString\n{\n  NSString *secureContent;\n\n  if ([[context request] isSoWebDAVRequest])\n    {\n      if ([container showCalendarAlarms])\n        secureContent = [self secureContentAsString];\n      else\n        secureContent = [self _secureContentWithoutAlarms];\n    }\n  else\n    secureContent = [super contentAsString];\n\n  return secureContent;\n}\n\n- (NSString *) davCalendarData\n{\n  return [self contentAsString];\n}\n\n- (iCalCalendar *) calendar: (BOOL) create secure: (BOOL) secure\n{\n  iCalRepeatableEntityObject *newComponent;\n  iCalCalendar **calendar, *returnedCopy;\n  NSString *iCalString, *tag, *prodID;\n\n  if (secure)\n    calendar = &safeCalendar;\n  else\n    calendar = &fullCalendar;\n\n  if (!*calendar)\n    {\n      if (secure)\n\tiCalString = [self secureContentAsString];\n      else\n\tiCalString = content;\n\n      if ([iCalString length] > 0)\n\t{\n\t  ASSIGN (*calendar, [iCalCalendar parseSingleFromSource: iCalString]);\n\t  if (!secure)\n\t    originalCalendar = [*calendar copy];\n\t}\n      else\n\t{\n\t  if (create)\n\t    {\n\t      ASSIGN (*calendar, [iCalCalendar groupWithTag: @\"vcalendar\"]);\n\t      [*calendar setVersion: @\"2.0\"];\n              prodID = [NSString stringWithFormat:\n                                   @\"-//Inverse inc./SOGo %@//EN\",\n                                 SOGoVersion];\n              [*calendar setProdID: prodID];\n\t      tag = [[self componentTag] uppercaseString];\n\t      newComponent = [[*calendar classForTag: tag]\n\t\t\t       groupWithTag: tag];\n\t      [newComponent setUid: [self globallyUniqueObjectId]];\n\t      [*calendar addChild: newComponent];\n\t    }\n\t}\n    }\n\n  returnedCopy = [*calendar mutableCopy];\n  [returnedCopy autorelease];\n\n  return returnedCopy;\n}\n\n- (id) component: (BOOL) create secure: (BOOL) secure\n{\n  return [[self calendar: create secure: secure]\n\t   firstChildWithTag: [self componentTag]];\n}\n\n//\n// Returs \"YES\" if a a group was decomposed among attendees.\n//\n// It can also return yes if an attendee was found in the list\n// matching the organizer. In which case, it was removed.\n//\n- (BOOL) expandGroupsInEvent: (iCalEvent *) theEvent\n{\n  NSString *organizerEmail, *domain;\n  NSMutableArray *allAttendees;\n  iCalPerson *currentAttendee;\n  NSEnumerator *enumerator;\n  NSAutoreleasePool *pool;\n  SOGoGroup *group;\n\n  BOOL eventWasModified;\n  unsigned int i, j;\n\n\n  domain = [[context activeUser] domain];\n  organizerEmail = [[theEvent organizer] rfc822Email];\n  eventWasModified = NO;\n  allAttendees = [NSMutableArray arrayWithArray: [theEvent attendees]];\n  enumerator = [[theEvent attendees] objectEnumerator];\n\n  j = 0;\n\n  pool = [[NSAutoreleasePool alloc] init];\n\n  while ((currentAttendee = [enumerator nextObject]))\n    {\n      if (j%5 == 0)\n        {\n          RELEASE(pool);\n          pool = [[NSAutoreleasePool alloc] init];\n        }\n\n      group = [SOGoGroup groupWithEmail: [currentAttendee rfc822Email]\n                               inDomain: domain];\n      if (group)\n\t{\n\t  iCalPerson *person;\n\t  NSArray *members;\n\t  SOGoUser *user;\n\t  \n\t  // We did decompose a group...\n\t  [allAttendees removeObject: currentAttendee];\n\n\t  members = [group members];\n\t  for (i = 0; i < [members count]; i++)\n\t    {\n\t      user = [members objectAtIndex: i];\n\t      eventWasModified = YES;\n\n\t      // If the organizer is part of the group, we skip it from\n\t      // the addition to the attendees' list\n\t      if ([user hasEmail: organizerEmail])\n\t\tcontinue;\n\t      \n\t      person = [self iCalPersonWithUID: [user login]];\n\t      [person setTag: @\"ATTENDEE\"];\n\t      [person setParticipationStatus: [currentAttendee participationStatus]];\n\t      [person setRsvp: [currentAttendee rsvp]];\n\t      [person setRole: [currentAttendee role]];\n\t\t\t    \n\t      if (![allAttendees containsObject: person])\n\t\t[allAttendees addObject: person];\n\t    }\n\t}\n      else\n\t{\n\t  // We remove any attendees matching the organizer. Apple iCal will do that when\n\t  // you invite someone. It'll add the organizer in the attendee list, which will\n\t  // confuse itself!\n\t  if ([[currentAttendee rfc822Email] caseInsensitiveCompare: organizerEmail] == NSOrderedSame)\n\t    {\n\t      [allAttendees removeObject: currentAttendee];\n\t      eventWasModified = YES;\n\t    }\n\t}\n      \n      j++;\n    } // while (currentAttendee ...\n\n  if (eventWasModified)\n    [theEvent setAttendees: allAttendees];\n  \n  RELEASE(pool);\n\n  return eventWasModified;\n}\n\n- (void) _updateRecurrenceIDsWithEvent: (iCalRepeatableEntityObject*) newEvent\n{\n  iCalRepeatableEntityObject *oldMaster, *currentComponent;\n  iCalDateTime *currentDate;\n  int deltaSecs;\n  NSArray *components, *dates;\n  NSMutableArray *newDates;\n  unsigned int count, max;\n  NSCalendarDate *recID, *newDate;\n\n  // Compute time interval from previous event definition.\n  if (!originalCalendar)\n    {\n      if (content)\n\tASSIGN (originalCalendar, [iCalCalendar parseSingleFromSource: content]);\n      else\n\t[self warnWithFormat: @\"content not available, we will crash\"];\n    }\n\n  oldMaster = (iCalRepeatableEntityObject *)\n    [originalCalendar firstChildWithTag: [self componentTag]];\n  deltaSecs = [[newEvent startDate]\n\t\ttimeIntervalSinceDate: [oldMaster startDate]];\n\n  components = [[newEvent parent] events];\n  max = [components count];\n\n  if (max > 0)\n    {\n      // Update recurrence-id attribute of occurences.\n      for (count = 1; count < max; count++)\n\t{\n\t  currentComponent = [components objectAtIndex: count];\n\t  recID = [[currentComponent recurrenceId] addTimeInterval: deltaSecs];\n\t  [currentComponent setRecurrenceId: recID];\n\t}\n\n      // Update exception dates in master vEvent.\n      currentComponent = [components objectAtIndex: 0];\n      dates = [currentComponent childrenWithTag: @\"exdate\"];\n      max = [dates count];\n      if (max > 0)\n\t{\n\t  newDates = [NSMutableArray arrayWithCapacity: max];\n\t  for (count = 0; count < max; count++)\n\t    {\n\t      currentDate = [dates objectAtIndex: count];\n\t      newDate = [[currentDate dateTime] addTimeInterval: deltaSecs];\n\t      [newDates addObject: newDate];\n\t    }\n\t  [currentComponent removeAllExceptionDates];\n\t  for (count = 0; count < max; count++)\n\t    [currentComponent addToExceptionDates: [newDates objectAtIndex: count]];\n\t}\n    }\n}\n\n- (void) updateComponent: (iCalRepeatableEntityObject *) newObject\n{\n  NSString *newUid;\n\n  if (!isNew\n      && [newObject isRecurrent])\n    // We update an repeating event -- update exception dates\n    // and recurrence-ids.\n    [self _updateRecurrenceIDsWithEvent: newObject];\n\n  // As much as we can, we try to use c_name == c_uid in order\n  // to avoid tricky scenarios with some CalDAV clients. For example,\n  // if Alice invites Bob (both use SOGo) and Bob accepts the invitation\n  // using Lightning before having refreshed their calendar, they'll end up\n  // with a duplicate of the event in their database tables.\n  if (isNew)\n    {\n      newUid = nameInContainer;\n      \n      if ([newUid hasSuffix: @\".ics\"])\n\tnewUid = [newUid substringToIndex: [newUid length]-4];\n      [newObject setUid: newUid];\n    }\n\n  if ([[SOGoSystemDefaults sharedSystemDefaults] enableEMailAlarms])\n    {\n      SOGoEMailAlarmsManager *eaMgr;\n      \n      eaMgr = [SOGoEMailAlarmsManager sharedEMailAlarmsManager];\n      [eaMgr handleAlarmsInCalendar: [newObject parent]\n\t     fromComponent: self];\n    }\n}\n\n- (NSException *) saveCalendar: (iCalCalendar *) newCalendar\n{\n  [super saveComponent: newCalendar];\n\n  return nil;\n}\n\n- (NSException *) saveComponent: (iCalRepeatableEntityObject *) newObject\n{\n  return [self saveCalendar: [newObject parent]];\n}\n\n/* raw saving */\n\n/* EMail Notifications */\n- (NSString *) homePageURLForPerson: (iCalPerson *) _person\n{\n  NSString *baseURL;\n  NSString *uid;\n  NSArray *traversalObjects;\n\n  /* generate URL from traversal stack */\n  traversalObjects = [context objectTraversalStack];\n  if ([traversalObjects count] > 0)\n    baseURL = [[traversalObjects objectAtIndex:0] baseURLInContext: context];\n  else\n    {\n      baseURL = @\"http://localhost/\";\n      [self warnWithFormat:@\"Unable to create baseURL from context!\"];\n    }\n  uid = [_person uid];\n\n  return ((uid)\n          ? [NSString stringWithFormat:@\"%@%@\", baseURL, uid]\n          : nil);\n}\n\n- (NSTimeZone *) timeZoneForUser: (NSString *) email\n{\n  NSString *uid;\n  SOGoUserDefaults *ud;\n\n  uid = [[SOGoUserManager sharedUserManager] getUIDForEmail: email];\n  ud = [[SOGoUser userWithLogin: uid] userDefaults];\n\n  return [ud timeZone];\n}\n\n- (NGMimeBodyPart *) _bodyPartForICalObject: (iCalRepeatableEntityObject *) object\n{\n  NGMimeBodyPart *bodyPart;\n  NGMutableHashMap *headerMap;\n  NSString *iCalString, *header, *charset;\n  NSData *objectData;\n  iCalCalendar *parent;\n\n  parent = [object parent];\n  iCalString = [NSString stringWithFormat: @\"%@\\r\\n\", [parent versitString]];\n  if ([iCalString canBeConvertedToEncoding: NSISOLatin1StringEncoding])\n    {\n      objectData = [iCalString dataUsingEncoding: NSISOLatin1StringEncoding];\n      charset = @\"ISO-8859-1\";\n    }\n  else\n    {\n      objectData = [iCalString dataUsingEncoding: NSUTF8StringEncoding];\n      charset = @\"UTF-8\";\n    }\n\n  header = [NSString stringWithFormat: @\"text/calendar; method=%@;\"\n                     @\" charset=\\\"%@\\\"\",\n                     [(iCalCalendar *) [object parent] method], charset];\n  headerMap = [NGMutableHashMap hashMapWithCapacity: 3];\n  [headerMap setObject: @\"urn:content-classes:calendarmessage\"  forKey: @\"Content-Class\"];\n  [headerMap setObject: header forKey: @\"content-type\"];\n  [headerMap setObject: @\"quoted-printable\"\n                forKey: @\"content-transfer-encoding\"];\n  bodyPart = [NGMimeBodyPart bodyPartWithHeader: headerMap];\n  [bodyPart setBody: [objectData dataByEncodingQuotedPrintable]];\n\n  return bodyPart;\n}\n\n//\n//\n//\n- (void) sendEMailUsingTemplateNamed: (NSString *) newPageName\n\t\t\t   forObject: (iCalRepeatableEntityObject *) object\n\t\t      previousObject: (iCalRepeatableEntityObject *) previousObject\n                         toAttendees: (NSArray *) attendees\n                            withType: (NSString *) msgType\n{\n  NSString *pageName;\n  NSString *senderEmail, *shortSenderEmail, *email;\n  WOApplication *app;\n  unsigned i, count;\n  iCalPerson *attendee;\n  NSString *recipient;\n  SOGoAptMailNotification *p;\n  NSString *mailDate, *subject, *text;\n  NGMutableHashMap *headerMap;\n  NGMimeMessage *msg;\n  NGMimeBodyPart *bodyPart, *eventBodyPart;\n  NGMimeMultipartBody *body;\n  SOGoUser *ownerUser;\n  SOGoDomainDefaults *dd;\n\n  // If defined, we return immediately. When not defined, we send the notifications correctly\n  if ([object firstChildWithTag: @\"X-SOGo-Send-Appointment-Notifications\"])\n    return;\n\n  ownerUser = [SOGoUser userWithLogin: owner];\n  dd = [ownerUser domainDefaults];\n  if ([dd appointmentSendEMailNotifications] && [object isStillRelevant])\n    {\n      count = [attendees count];\n      if (count)\n\t{\n\t  /* sender */\n\t  shortSenderEmail = [[object organizer] rfc822Email];\n\t  if ([shortSenderEmail length])\n            {\n              senderEmail = [[object organizer] mailAddress];\n            }\n          else\n            {\n              shortSenderEmail = [[previousObject organizer] rfc822Email];\n              senderEmail = [[previousObject organizer] mailAddress];\n            }\n\n          /* calendar part */\n          eventBodyPart = [self _bodyPartForICalObject: object];\n\n\t  /* get WOApplication instance */\n\t  app = [WOApplication application];\n\n\t  /* generate dynamic message content */\n\t  for (i = 0; i < count; i++)\n\t    {\n\t      attendee = [attendees objectAtIndex: i];\n\t      // Don't send a notification to the event organizer nor a deletion\n\t      // notification to an attendee who already declined the invitation.\n\t      if (![[attendee uid] isEqualToString: owner] &&\n\t\t  !([[attendee partStat] compare: @\"DECLINED\"] == NSOrderedSame &&\n\t\t    [newPageName compare: @\"Deletion\"] == NSOrderedSame))\n\t\t{\n\t\t  /* construct recipient */\n\t\t  recipient = [attendee mailAddress];\n\t\t  email = [attendee rfc822Email];\n\n#warning this could be optimized in a class hierarchy common with the\t\\\n  SOGoObject acl notification mechanism\n\t\t  /* create page name */\n\t\t  pageName = [NSString stringWithFormat: @\"SOGoAptMail%@\",\n                                       newPageName];\n\t\t  /* construct message content */\n\t\t  p = [app pageWithName: pageName inContext: context];\n\t\t  [p setApt: (iCalEvent *) object];\n\t\t  [p setPreviousApt: (iCalEvent *) previousObject];\n\t\t  \n\t\t  if ([[object organizer] cn] && [[[object organizer] cn] length])\n\t\t    {\n\t\t      [p setOrganizerName: [[object organizer] cn]];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      [p setOrganizerName: [ownerUser cn]];\n\t\t    }\n\n\t\t  subject = [[p getSubject] asQPSubjectString: @\"UTF-8\"];\n\t\t  text = [p getBody];\n\n\t\t  /* construct message */\n\t\t  headerMap = [NGMutableHashMap hashMapWithCapacity: 5];\n          \n\t\t  /* NOTE: multipart/alternative seems like the correct choice but\n\t\t   * unfortunately Thunderbird doesn't offer the rich content alternative\n\t\t   * at all. Mail.app shows the rich content alternative _only_\n\t\t   * so we'll stick with multipart/mixed for the time being.\n\t\t   */\n#warning SOPE is just plain stupid here - if you change the case of keys, it will break the encoding of fields\n\t\t  [headerMap setObject: @\"multipart/mixed\" forKey: @\"content-type\"];\n\t\t  [headerMap setObject: @\"1.0\" forKey: @\"MIME-Version\"];\n\t\t  [headerMap setObject: senderEmail forKey: @\"from\"];\n\t\t  [headerMap setObject: recipient forKey: @\"to\"];\n\t\t  mailDate = [[NSCalendarDate date] rfc822DateString];\n\t\t  [headerMap setObject: mailDate forKey: @\"date\"];\n\t\t  [headerMap setObject: subject forKey: @\"subject\"];\n                  [headerMap setObject: [NSString generateMessageID] forKey: @\"message-id\"];\n                  if ([msgType length] > 0)\n                    [headerMap setObject: msgType forKey: @\"x-sogo-message-type\"];\n\t\t  msg = [NGMimeMessage messageWithHeader: headerMap];\n\n\t\t  /* multipart body */\n\t\t  body = [[NGMimeMultipartBody alloc] initWithPart: msg];\n\n\t\t  /* text part */\n\t\t  headerMap = [NGMutableHashMap hashMapWithCapacity: 1];\n\t\t  [headerMap setObject: @\"text/html; charset=utf-8\"\n\t\t\t\tforKey: @\"content-type\"];\n\t\t  bodyPart = [NGMimeBodyPart bodyPartWithHeader: headerMap];\n\t\t  [bodyPart setBody: [text dataUsingEncoding: NSUTF8StringEncoding]];\n\n\t\t  /* attach text part to multipart body */\n\t\t  [body addBodyPart: bodyPart];\n    \n\t\t  /* attach calendar part to multipart body */\n\t\t  [body addBodyPart: eventBodyPart];\n    \n\t\t  /* attach multipart body to message */\n\t\t  [msg setBody: body];\n\t\t  [body release];\n\n\t\t  /* send the damn thing */\n\t\t  [[SOGoMailer mailerWithDomainDefaults: dd]\n\t\t           sendMimePart: msg\n                           toRecipients: [NSArray arrayWithObject: email]\n                                 sender: shortSenderEmail\n                      withAuthenticator: [self authenticatorInContext: context]\n                              inContext: context];\n\t\t}\n\t    }\n\t}\n    }\n}\n\n#warning fix this when sendEmailUsing blabla has been cleaned up\n- (void) sendIMIPReplyForEvent: (iCalRepeatableEntityObject *) event\n\t\t\t  from: (SOGoUser *) from\n\t\t\t    to: (iCalPerson *) recipient\n{\n  NSString *pageName, *mailDate, *email;\n  WOApplication *app;\n  iCalPerson *attendee;\n  SOGoAptMailICalReply *p;\n  NGMutableHashMap *headerMap;\n  NGMimeMessage *msg;\n  NGMimeBodyPart *bodyPart;\n  NGMimeMultipartBody *body;\n  NSData *bodyData;\n  SOGoDomainDefaults *dd;\n\n  dd = [from domainDefaults];\n  if ([dd appointmentSendEMailNotifications] && [event isStillRelevant])\n    {\n      /* get WOApplication instance */\n      app = [WOApplication application];\n\n      /* create page name */\n      pageName = @\"SOGoAptMailICalReply\";\n      /* construct message content */\n      p = [app pageWithName: pageName inContext: context];\n      [p setApt: (iCalEvent *) event];\n\n      attendee = [event userAsAttendee: from];\n      [p setAttendee: attendee];\n\n      /* construct message */\n      headerMap = [NGMutableHashMap hashMapWithCapacity: 5];\n\n      /* NOTE: multipart/alternative seems like the correct choice but\n       * unfortunately Thunderbird doesn't offer the rich content alternative\n       * at all. Mail.app shows the rich content alternative _only_\n       * so we'll stick with multipart/mixed for the time being.\n       */\n#warning SOPE is just plain stupid here - if you change the case of keys, it will break the encoding of fields\n      [headerMap setObject: [attendee mailAddress] forKey: @\"from\"];\n      [headerMap setObject: [recipient mailAddress] forKey: @\"to\"];\n      mailDate = [[NSCalendarDate date] rfc822DateString];\n      [headerMap setObject: mailDate forKey: @\"date\"];\n      [headerMap setObject: [[p getSubject] asQPSubjectString: @\"UTF-8\"]\n                    forKey: @\"subject\"];\n      [headerMap setObject: [NSString generateMessageID] forKey: @\"message-id\"];\n      [headerMap setObject: @\"1.0\" forKey: @\"MIME-Version\"];\n      [headerMap setObject: @\"multipart/mixed\" forKey: @\"content-type\"];\n      [headerMap setObject: @\"calendar:invitation-reply\" forKey: @\"x-sogo-message-type\"];\n      msg = [NGMimeMessage messageWithHeader: headerMap];\n\n      /* multipart body */\n      body = [[NGMimeMultipartBody alloc] initWithPart: msg];\n\n      /* text part */\n      headerMap = [NGMutableHashMap hashMapWithCapacity: 1];\n      [headerMap setObject: @\"text/html; charset=utf-8\"\n\t\t    forKey: @\"content-type\"];\n      bodyPart = [NGMimeBodyPart bodyPartWithHeader: headerMap];\n      bodyData = [[p getBody] dataUsingEncoding: NSUTF8StringEncoding];\n      [bodyPart setBody: bodyData];\n\n      /* attach text part to multipart body */\n      [body addBodyPart: bodyPart];\n\n      /* attach calendar part to multipart body */\n      [body addBodyPart: [self _bodyPartForICalObject: event]];\n\n      /* attach multipart body to message */\n      [msg setBody: body];\n      [body release];\n\n      /* send the damn thing */\n      email = [recipient rfc822Email];\n      [[SOGoMailer mailerWithDomainDefaults: dd]\n\t       sendMimePart: msg\n               toRecipients: [NSArray arrayWithObject: email]\n                     sender: [attendee rfc822Email]\n          withAuthenticator: [self authenticatorInContext: context]\n                  inContext: context];\n    }\n}\n\n//\n//\n//\n- (void) sendResponseToOrganizer: (iCalRepeatableEntityObject *) newComponent\n\t\t\t    from: (SOGoUser *) from\n{\n  iCalPerson *organizer, *attendee;\n  iCalEvent *event;\n  SOGoUser *ownerUser;\n\n  event = [newComponent itipEntryWithMethod: @\"reply\"];\n  ownerUser = [SOGoUser userWithLogin: owner];\n  if (![event userIsOrganizer: ownerUser])\n    {\n      organizer = [event organizer];\n      attendee = [event userAsAttendee: ownerUser];\n      [event setAttendees: [NSArray arrayWithObject: attendee]];\n      [self sendIMIPReplyForEvent: event from: from to: organizer];\n    }\n}\n\n//\n//\n//\n- (void) sendReceiptEmailForObject: (iCalRepeatableEntityObject *) object\n\t\t    addedAttendees: (NSArray *) theAddedAttendees\n\t\t  deletedAttendees: (NSArray *) theDeletedAttendees\n\t\t  updatedAttendees: (NSArray *) theUpdatedAttendees\n\t\t\t operation: (SOGoEventOperation) theOperation\n{\n  NSString *calendarName, *mailDate, *mailText, *fullSenderEmail, *senderEmail, *fullRecipientEmail, *recipientEmail;\n  NSDictionary *senderIdentity, *recipientIdentity;\n  id <SOGoAuthenticator> authenticator;\n  SOGoUser *currentUser, *ownerUser;\n  NGMutableHashMap *headerMap;\n  SOGoAptMailReceipt *page;\n  SOGoDomainDefaults *dd;\n  NGMimeMessage *msg;\n\n  calendarName = [[self container] displayName];\n\n  // We must handle three cases here:\n  // - Receive a mail when I modify my calendar\n  // - Receive a mail when someone else modifies my calendar\n  // - When I modify my calendar, send a mail to: <foo@bar.com>\n\n  // We first built the template that we'll slightly adjust for our three use-cases\n  page = [[WOApplication application] pageWithName: @\"SOGoAptMailReceipt\"\n\t\t\t\t\t inContext: context];\n  [page setApt: (iCalEvent *) object];\n  [page setAddedAttendees: theAddedAttendees];\n  [page setDeletedAttendees: theDeletedAttendees];\n  [page setUpdatedAttendees: theUpdatedAttendees];\n  [page setOperation: theOperation];\n  [page setCalendarName: calendarName];\n  \n  currentUser = [context activeUser];\n  senderIdentity = [currentUser primaryIdentity];\n\n  dd = [currentUser domainDefaults];\n\n#warning SOPE is just plain stupid here - if you change the case of keys, it will break the encoding of fields\n  headerMap = [NGMutableHashMap hashMapWithCapacity: 5];\n  \n  // Sender can vary, base on whom modifies the actual event (owner vs. someone else)\n  senderEmail = [senderIdentity objectForKey: @\"email\"];\n  fullSenderEmail = [senderIdentity keysWithFormat: @\"%{fullName} <%{email}>\"];\n  [headerMap setObject: fullSenderEmail forKey: @\"from\"];\n\n  // Recipient is fixed, which is the calendar owner\n  ownerUser = [SOGoUser userWithLogin: self->owner];\n  recipientIdentity = [ownerUser primaryIdentity];\n  \n  // Safety net for broken configurations\n  if (!recipientIdentity)\n    return;\n\n  recipientEmail = [recipientIdentity objectForKey: @\"email\"];\n  fullRecipientEmail = [recipientIdentity keysWithFormat: @\"%{fullName} <%{email}>\"];\n  \n  [headerMap setObject: fullRecipientEmail forKey: @\"to\"];\n\n  mailDate = [[NSCalendarDate date] rfc822DateString];\n  [headerMap setObject: mailDate forKey: @\"date\"];\n  [headerMap setObject: [page getSubject] forKey: @\"subject\"];\n  [headerMap setObject: [NSString generateMessageID] forKey: @\"message-id\"];\n  [headerMap setObject: @\"1.0\" forKey: @\"MIME-Version\"];\n  [headerMap setObject: @\"text/html; charset=utf-8\"\n\t\tforKey: @\"content-type\"];\n  msg = [NGMimeMessage messageWithHeader: headerMap];\n  \n  /* text part */\n  mailText = [page getBody];\n  [msg setBody: [mailText dataUsingEncoding: NSUTF8StringEncoding]];\n\n  authenticator = [self authenticatorInContext: context];\n  \n  if ([self->owner isEqualToString: [currentUser login]])\n    {\n      if ([[self container] notifyOnPersonalModifications])\n\t{\n\t  [[SOGoMailer mailerWithDomainDefaults: dd]\n\t\t    sendMimePart: msg\n\t\t    toRecipients: [NSArray arrayWithObject: recipientEmail]\n                          sender: senderEmail\n               withAuthenticator: authenticator\n                       inContext: context];\n\t}\n      \n      if ([[self container] notifyUserOnPersonalModifications])\n\t{\n\t  id o;\n\n\t  o = [headerMap objectForKey: @\"to\"];\n\t  recipientEmail = [[self container] notifiedUserOnPersonalModifications];\n\t  [headerMap setObject: recipientEmail forKey: @\"to\"];\n\t  \n\t  [[SOGoMailer mailerWithDomainDefaults: dd]\n\t\t    sendMimePart: msg\n\t\t    toRecipients: [NSArray arrayWithObject: recipientEmail]\n                          sender: senderEmail\n               withAuthenticator: authenticator\n                       inContext: context];\n\n\t  [headerMap setObject: o forKey: @\"to\"];\n\t}\n    }\n\n      \n  if ([[self container] notifyOnExternalModifications] &&\n      ![self->owner isEqualToString: [currentUser login]])\n    {\n      [[SOGoMailer mailerWithDomainDefaults: dd]\n\t\t    sendMimePart: msg\n\t\t    toRecipients: [NSArray arrayWithObject: recipientEmail]\n                          sender: senderEmail\n               withAuthenticator: authenticator\n                       inContext: context];\n    }\n\n}\n\n//\n//\n//\n- (iCalPerson *) findParticipantWithUID: (NSString *) uid\n{\n  iCalEntityObject *component;\n  SOGoUser *user;\n\n  user = [SOGoUser userWithLogin: uid];\n  component = [self component: NO secure: NO];\n\n  return [component userAsAttendee: user];\n}\n\n//\n//\n//\n- (iCalPerson *) iCalPersonWithUID: (NSString *) uid\n{\n  iCalPerson *person;\n  SOGoUserManager *um;\n  NSDictionary *contactInfos;\n\n  um = [SOGoUserManager sharedUserManager];\n  contactInfos = [um contactInfosForUserWithUIDorEmail: uid];\n\n  person = [iCalPerson new];\n  [person autorelease];\n  [person setCn: [contactInfos objectForKey: @\"cn\"]];\n  [person setEmail: [contactInfos objectForKey: @\"c_email\"]];\n\n  return person;\n}\n\n//\n//\n//\n- (NSArray *) getUIDsForICalPersons: (NSArray *) iCalPersons\n{\n  iCalPerson *currentPerson;\n  NSEnumerator *persons;\n  NSMutableArray *uids;\n  NSString *uid;\n\n  uids = [NSMutableArray array];\n\n  persons = [iCalPersons objectEnumerator];\n  while ((currentPerson = [persons nextObject]))\n    {\n      uid = [currentPerson uid];\n      if (uid)\n\t[uids addObject: uid];\n    }\n\n  return uids;\n}\n\n- (NSException *) copyToFolder: (SOGoGCSFolder *) newFolder\n{\n  return [self copyComponent: [self calendar: NO secure: NO]\n\t\t    toFolder: newFolder];\n}\n\n- (NSException *) copyComponent: (iCalCalendar *) calendar\n\t\t       toFolder: (SOGoGCSFolder *) newFolder\n{\n  NSArray *elements;\n  NSString *newUID;\n  unsigned int count, max;\n  SOGoCalendarComponent *newComponent;\n\n  newUID = [self globallyUniqueObjectId];\n  elements = [calendar allObjects];\n  max = [elements count];\n  for (count = 0; count < max; count++)\n    [[elements objectAtIndex: count] setUid: newUID];\n\n  newComponent = [[self class] objectWithName:\n\t\t\t\t [NSString stringWithFormat: @\"%@.ics\", newUID]\n\t\t\t       inContainer: newFolder];\n\n  return [newComponent saveCalendar: calendar];\n}\n\n- (NSException *) moveToFolder: (SOGoGCSFolder *) newFolder\n{\n  NSException *ex;\n\n  ex = [self copyToFolder: newFolder];\n\n  if (!ex)\n    ex = [self delete];\n\n  return ex;\n}\n\n#warning Should we not remove the concept of Organizer and Participant roles?\n- (NSString *) _roleOfOwner: (iCalRepeatableEntityObject *) component\n{\n  NSString *role;\n  iCalPerson *organizer;\n  SOGoUser *ownerUser;\n\n  if (isNew)\n    role = SOGoCalendarRole_Organizer;\n  else\n    {\n      organizer = [component organizer];\n      if ([[organizer rfc822Email] length] > 0)\n\t{\n\t  ownerUser = [SOGoUser userWithLogin: owner];\n\t  if ([component userIsOrganizer: ownerUser])\n\t    role = SOGoCalendarRole_Organizer;\n\t  else if ([component userIsAttendee: ownerUser])\n\t    role = SOGoCalendarRole_Participant;\n\t  else\n\t    role = SOGoRole_None;\n\t}\n      else\n\trole = SOGoCalendarRole_Organizer;\n    }\n\n  return role;\n}\n\n- (NSString *) _compiledRoleForOwner: (NSString *) ownerRole\n\t\t\t     andUser: (NSString *) userRole\n{\n  NSString *role;\n\n  if ([userRole isEqualToString: SOGoCalendarRole_ComponentModifier]\n      || ([userRole isEqualToString: SOGoCalendarRole_ComponentResponder]\n\t  && [ownerRole isEqualToString: SOGoCalendarRole_Participant]))\n    role = ownerRole;\n  else\n    role = SOGoRole_None;\n\n  return role;\n}\n\n- (NSArray *) aclsForUser: (NSString *) uid\n{\n  NSMutableArray *roles;\n  NSArray *superAcls;\n  iCalRepeatableEntityObject *component;\n  NSString *accessRole, *ownerRole;\n  SOGoUser *aclUser;\n\n  roles = [NSMutableArray array];\n  superAcls = [super aclsForUser: uid];\n  if ([superAcls count] > 0)\n    [roles addObjectsFromArray: superAcls];\n\n  component = [self component: NO secure: NO];\n  ownerRole = [self _roleOfOwner: component];\n  if ([owner isEqualToString: uid])\n    [roles addObject: ownerRole];\n  else\n    {\n      if (isNew)\n        {\n          if ([roles containsObject: SOGoRole_ObjectCreator])\n            [roles addObject: SOGoCalendarRole_Organizer];\n        }\n      else\n        {\n          if (component)\n            {\n              aclUser = [SOGoUser userWithLogin: uid];\n              if ([component userIsOrganizer: aclUser])\n                [roles addObject: SOGoCalendarRole_Organizer];\n              else if ([component userIsAttendee: aclUser])\n                [roles addObject: SOGoCalendarRole_Participant];\n              accessRole\n                = [container roleForComponentsWithAccessClass: [component symbolicAccessClass]\n                                                      forUser: uid];\n              if ([accessRole length] > 0)\n                {\n                  [roles addObject: accessRole];\n                  [roles addObject: [self _compiledRoleForOwner: ownerRole\n                                                        andUser: accessRole]];\n                }\n            }\n        }\n    }\n\n  return roles;\n}\n\n- (void) snoozeAlarm: (unsigned int) minutes\n{\n  NSDictionary *quickFields;\n  GCSFolder *folder;\n  unsigned int nextAlarm;\n\n  folder = [[self container] ocsFolder];\n  if (!folder)\n    {\n      [self errorWithFormat:@\"(%s): missing folder for update!\",\n            __PRETTY_FUNCTION__];\n      return;\n    }\n\n  nextAlarm = [[NSCalendarDate calendarDate] timeIntervalSince1970]  + minutes * 60;\n  quickFields = [NSDictionary dictionaryWithObject: [NSNumber numberWithInt: nextAlarm]\n                                            forKey: @\"c_nextalarm\"];\n\n  [folder updateQuickFields: quickFields\n                whereColumn: @\"c_name\"\n                  isEqualTo: nameInContainer];\n}\n\n/* SOGoComponentOccurence protocol */\n\n- (iCalRepeatableEntityObject *) occurence\n{\n  return [self component: YES secure: NO];\n}\n\n#warning alarms: we do not handle occurrences\n- (NSException *) prepareDelete\n{\n  if ([[SOGoSystemDefaults sharedSystemDefaults] enableEMailAlarms])\n    {\n      SOGoEMailAlarmsManager *eaMgr;\n      \n      eaMgr = [SOGoEMailAlarmsManager sharedEMailAlarmsManager];\n      [eaMgr deleteAlarmsFromComponent: self];\n    }\n\n  return nil;\n}\n\n- (id) PUTAction: (WOContext *) localContext\n{\n  if ([[SOGoSystemDefaults sharedSystemDefaults] enableEMailAlarms])\n    {\n      SOGoEMailAlarmsManager *eaMgr;\n      iCalCalendar *putCalendar;\n      WORequest *rq;\n\n      rq = [localContext request];\n      putCalendar = [iCalCalendar parseSingleFromSource: [rq contentAsString]];\n      eaMgr = [SOGoEMailAlarmsManager sharedEMailAlarmsManager];\n      [eaMgr handleAlarmsInCalendar: putCalendar\n                      fromComponent: self];\n    }\n\n  return [super PUTAction: localContext];\n}\n\n// /* Overriding this method dramatically speeds up PROPFIND request, but may\n//    otherwise be a bad idea... Wait and see. */\n// - (NSDictionary*) valuesForKeys: (NSArray*)keys\n// {\n//   NSMutableDictionary *values;\n\n//   values = [NSMutableDictionary dictionaryWithCapacity: [keys count]];\n//   [values setObject: [self davCreationDate] forKey: @\"davCreationDate\"];\n//   [values setObject: [self davContentLength] forKey: @\"davContentLength\"];\n//   [values setObject: [self davLastModified] forKey: @\"davLastModified\"];\n//   [values setObject: @\"text/calendar\" forKey: @\"davContentType\"];\n//   [values setObject: [self baseURL] forKey: @\"davURL\"];\n\n//   return values;\n// }\n\n- (void) adjustClassificationInRequestCalendar: (iCalCalendar *) rqCalendar\n{\n  SOGoUserDefaults *userDefaults;\n  NSString *accessClass;\n  NSArray *allObjects;\n  id entity;\n\n  int i;\n\n  userDefaults = [[context activeUser] userDefaults];\n  allObjects = [rqCalendar allObjects];\n\n  for (i = 0; i < [allObjects count]; i++)\n    {\n      entity = [allObjects objectAtIndex: i];\n\n      if ([entity respondsToSelector: @selector(accessClass)])\n        {\n          accessClass = [entity accessClass];\n\n          if (!accessClass || [accessClass length] == 0)\n            {\n              if ([entity isKindOfClass: [iCalEvent class]])\n                [entity setAccessClass: [userDefaults calendarEventsDefaultClassification]];\n              else if ([entity isKindOfClass: [iCalToDo class]])\n                [entity setAccessClass: [userDefaults calendarTasksDefaultClassification]];\n            }\n        }\n    }\n}\n\n\n@end\n", "/* SOGoUserSettings.h - this file is part of SOGo\n *\n * Copyright (C) 2009-2014 Inverse inc.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n#ifndef SOGOUSERSETTINGS_H\n#define SOGOUSERSETTINGS_H\n\n#import \"SOGoDefaultsSource.h\"\n\n@class NSArray;\n@class NSMutableDictionary;\n@class NSString;\n\n@interface SOGoUserSettings : SOGoDefaultsSource\n\n+ (SOGoUserSettings *) settingsForUser: (NSString *) userId;\n\n- (NSArray *) subscribedCalendars;\n- (NSArray *) subscribedAddressBooks;\n\n@end\n\n#endif /* SOGOUSERSETTINGS_H */\n", "/* SOGoUserSettings.m - this file is part of SOGo\n *\n * Copyright (C) 2009-2014 Inverse inc.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n#import <Foundation/NSArray.h>\n#import <Foundation/NSDictionary.h>\n#import <Foundation/NSString.h>\n\n#import \"SOGoUserProfile.h\"\n\n#import \"SOGoUserSettings.h\"\n\nstatic Class SOGoUserProfileKlass = Nil;\n\n@implementation SOGoUserSettings\n\n+ (NSString *) userProfileClassName\n{\n  return @\"SOGoSQLUserProfile\";\n}\n\n+ (void) initialize\n{\n  if (!SOGoUserProfileKlass)\n    SOGoUserProfileKlass = NSClassFromString ([self userProfileClassName]);\n}\n\n+ (SOGoUserSettings *) settingsForUser: (NSString *) userId\n{\n  SOGoUserProfile *up;\n  SOGoUserSettings *ud;\n\n  up = [SOGoUserProfileKlass userProfileWithType: SOGoUserProfileTypeSettings\n                                          forUID: userId];\n  [up fetchProfile];\n  ud = [self defaultsSourceWithSource: up andParentSource: nil];\n\n  return ud;\n}\n\n- (NSArray *) _subscribedFoldersForModule: (NSString *) module\n{\n  return [[self dictionaryForKey: module] objectForKey: @\"SubscribedFolders\"];\n}\n\n- (NSArray *) subscribedCalendars\n{\n  return [self _subscribedFoldersForModule: @\"Calendar\"];\n}\n\n- (NSArray *) subscribedAddressBooks\n{\n  return [self _subscribedFoldersForModule: @\"Contacts\"];\n}\n\n@end\n"], "fixing_code": ["/* SOGoCalendarComponent.m - this file is part of SOGo\n *\n * Copyright (C) 2006-2014 Inverse inc.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n#import <Foundation/NSAutoreleasePool.h>\n#import <Foundation/NSDictionary.h>\n#import <Foundation/NSEnumerator.h>\n#import <Foundation/NSProcessInfo.h>\n#import <Foundation/NSString.h>\n#import <Foundation/NSValue.h>\n\n#import <NGObjWeb/NSException+HTTP.h>\n#import <NGObjWeb/SoSecurityManager.h>\n#import <NGObjWeb/WOApplication.h>\n#import <NGObjWeb/WOContext+SoObjects.h>\n#import <NGObjWeb/WORequest+So.h>\n#import <NGExtensions/NSObject+Logs.h>\n#import <NGExtensions/NGHashMap.h>\n#import <NGExtensions/NGQuotedPrintableCoding.h>\n#import <NGCards/iCalCalendar.h>\n#import <NGCards/iCalDateTime.h>\n#import <NGCards/iCalEvent.h>\n#import <NGCards/iCalPerson.h>\n#import <NGCards/iCalRepeatableEntityObject.h>\n#import <NGMime/NGMimeBodyPart.h>\n#import <NGMime/NGMimeMultipartBody.h>\n#import <NGMail/NGMimeMessage.h>\n#import <GDLContentStore/GCSFolder.h>\n\n#import <SOGo/NSCalendarDate+SOGo.h>\n#import <SOGo/NSDictionary+Utilities.h>\n#import <SOGo/NSObject+DAV.h>\n#import <SOGo/NSObject+Utilities.h>\n#import <SOGo/NSString+Crypto.h>\n#import <SOGo/NSString+Utilities.h>\n#import <SOGo/SOGoBuild.h>\n#import <SOGo/SOGoDomainDefaults.h>\n#import <SOGo/SOGoMailer.h>\n#import <SOGo/SOGoGroup.h>\n#import <SOGo/SOGoPermissions.h>\n#import <SOGo/SOGoUser.h>\n#import <SOGo/SOGoUserDefaults.h>\n#import <SOGo/SOGoUserSettings.h>\n#import <SOGo/SOGoSystemDefaults.h>\n#import <SOGo/SOGoUserManager.h>\n#import <SOGo/SOGoWebDAVAclManager.h>\n#import <SOGo/WORequest+SOGo.h>\n#import <Appointments/SOGoAppointmentFolder.h>\n#import <Mailer/NSString+Mail.h>\n\n#import \"SOGoAptMailICalReply.h\"\n#import \"SOGoAptMailNotification.h\"\n#import \"SOGoAptMailReceipt.h\"\n#import \"SOGoEMailAlarmsManager.h\"\n#import \"iCalEntityObject+SOGo.h\"\n#import \"iCalPerson+SOGo.h\"\n#import \"iCalRepeatableEntityObject+SOGo.h\"\n#import \"SOGoCalendarComponent.h\"\n#import \"SOGoComponentOccurence.h\"\n\n@implementation SOGoCalendarComponent\n\n+ (SOGoWebDAVAclManager *) webdavAclManager\n{\n  static SOGoWebDAVAclManager *aclManager = nil;\n  NSString *nsD, *nsI;\n\n  if (!aclManager)\n    {\n      nsD = @\"DAV:\";\n      nsI = @\"urn:inverse:params:xml:ns:inverse-dav\";\n\n      aclManager = [SOGoWebDAVAclManager new];\n\n      [aclManager registerDAVPermission: davElement (@\"read\", nsD)\n\t\t  abstract: NO\n                  withEquivalent: @\"SOGoDAVReadPermission\" /* hackish */\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"view-whole-component\", nsI)\n\t\t  abstract: NO\n\t\t  withEquivalent: SOGoCalendarPerm_ViewAllComponent\n                  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"view-date-and-time\", nsI)\n\t\t  abstract: NO\n\t\t  withEquivalent: SOGoCalendarPerm_ViewDAndT\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"read-current-user-privilege-set\", nsD)\n\t\t  abstract: NO\n\t\t  withEquivalent: SoPerm_WebDAVAccess\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"write\", nsD)\n\t\t  abstract: NO\n\t\t  withEquivalent: SOGoCalendarPerm_ModifyComponent\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager\n\tregisterDAVPermission: davElement (@\"write-properties\", nsD)\n\tabstract: YES\n\twithEquivalent: SoPerm_ChangePermissions /* hackish */\n\tasChildOf: davElement (@\"write\", nsD)];\n      [aclManager\n\tregisterDAVPermission: davElement (@\"write-content\", nsD)\n\tabstract: YES\n\twithEquivalent: nil\n\tasChildOf: davElement (@\"write\", nsD)];\n      [aclManager\n        registerDAVPermission: davElement (@\"respond-to-component\", nsI)\n                     abstract: NO\n               withEquivalent: SOGoCalendarPerm_RespondToComponent\n                    asChildOf: davElement (@\"write-content\", nsD)];\n      [aclManager registerDAVPermission: davElement (@\"admin\", nsI)\n\t\t  abstract: YES\n\t\t  withEquivalent: nil\n\t\t  asChildOf: davElement (@\"all\", nsD)];\n      [aclManager\n\tregisterDAVPermission: davElement (@\"read-acl\", nsD)\n\tabstract: YES\n\twithEquivalent: SOGoPerm_ReadAcls\n\tasChildOf: davElement (@\"admin\", nsI)];\n      [aclManager\n\tregisterDAVPermission: davElement (@\"write-acl\", nsD)\n\tabstract: YES\n\twithEquivalent: nil\n\tasChildOf: davElement (@\"admin\", nsI)];\n    }\n\n  return aclManager;\n}\n\n- (NSException *) changeParticipationStatus: (NSString *) newPartStat\n                               withDelegate: (iCalPerson *) delegate\n                                      alarm: (iCalAlarm *) alarm\n{\n  // Required for protocol <SOGoComponentOccurence>\n  return nil;\n}\n\n- (id) init\n{\n  if ((self = [super init]))\n    {\n      fullCalendar = nil;\n      safeCalendar = nil;\n      originalCalendar = nil;\n      componentTag = nil;\n    }\n\n  return self;\n}\n\n- (void) dealloc\n{\n  [fullCalendar release];\n  [safeCalendar release];\n  [originalCalendar release];\n  [componentTag release];\n  [super dealloc];\n}\n\n- (void) flush\n{\n  DESTROY(fullCalendar);\n  DESTROY(safeCalendar);\n  DESTROY(originalCalendar);\n}\n\n- (Class *) parsingClass\n{\n  return (Class *)[iCalCalendar class];\n}\n\n- (NSString *) davContentType\n{\n  return @\"text/calendar\";\n}\n\n- (NSString *) componentTag\n{\n  if (!componentTag)\n    [self subclassResponsibility: _cmd];\n  \n  return componentTag;\n}\n\n- (void) setComponentTag: (NSString *) theTag\n{\n  ASSIGN(componentTag, theTag);\n}\n\n- (void) _filterComponent: (iCalEntityObject *) component\n{\n  NSString *type, *summary, *tag, *uid;\n  SOGoUserSettings *settings;\n  SOGoUser *calendarOwner;\n  NSEnumerator *children;\n  CardElement *element;\n  NSArray *tags;\n\n  int classification;\n\n  type = @\"vtodo\";\n  classification = 0;\n\n  calendarOwner = [SOGoUser userWithLogin: [self ownerInContext: context]];\n  settings = [calendarOwner userSettings];\n\n  if ([component isKindOfClass: [iCalEvent class]])\n    type = @\"vevent\";\n  \n  if ([component symbolicAccessClass] == iCalAccessPrivate)\n    classification = 1;\n  else if ([component symbolicAccessClass] == iCalAccessConfidential)\n    classification = 2;\n\n  summary = [self labelForKey: [NSString stringWithFormat: @\"%@_class%d\",\n                                         type, classification]\n                    inContext: context];\n\n  tags = [NSArray arrayWithObjects: @\"DTSTAMP\", @\"DTSTART\", @\"DTEND\", @\"DUE\", @\"EXDATE\", @\"EXRULE\", @\"RRULE\", nil];\n  uid = [[component uid] asCryptedPassUsingScheme: @\"ssha256\"\n                                         withSalt: [[settings userSalt] dataUsingEncoding: NSASCIIStringEncoding]\n                                      andEncoding: encHex];\n\n  children = [[[[component children] copy] autorelease] objectEnumerator];\n\n  while ((element = [children nextObject]))\n    {\n      tag = [element tag];\n      if (![tags containsObject: [tag uppercaseString]])\n        [component removeChild: element];\n    }\n\n  [component setSummary: summary];\n  [component setUid: uid];\n}\n\n- (NSString *) secureContentAsString\n{\n  iCalRepeatableEntityObject *tmpComponent;\n  iCalCalendar *tmpCalendar;\n  NSArray *allComponents;\n  SoSecurityManager *sm;\n  NSString *iCalString;\n\n  int i;\n\n  sm = [SoSecurityManager sharedSecurityManager];\n  if (activeUserIsOwner\n      || [[self ownerInContext: context] isEqualToString: [[context activeUser] login]]\n      || ![sm validatePermission: SOGoCalendarPerm_ViewAllComponent\n\t      onObject: self inContext: context])\n    iCalString = content;\n  else if (![sm validatePermission: SOGoCalendarPerm_ViewDAndT\n\t\tonObject: self inContext: context])\n    {\n      tmpCalendar = [[self calendar: NO secure: NO] mutableCopy];\n\n      // We filter all components, in case we have RECURRENCE-ID\n      allComponents = [tmpCalendar childrenWithTag: [self componentTag]];\n\n      for (i = 0; i < [allComponents count]; i++)\n        {\n          tmpComponent = (iCalRepeatableEntityObject *)[allComponents objectAtIndex:i];\n          [self _filterComponent: tmpComponent];\n      \n          // We add an additional header here to inform clients (if necessary) that\n          // we churned the content of the calendar.\n          [tmpComponent addChild: [CardElement simpleElementWithTag: @\"X-SOGo-Secure\"\n                                                              value: @\"YES\"]];\n        }\n\n      iCalString = [tmpCalendar versitString];\n      [tmpCalendar release];\n    }\n  else\n    iCalString = nil;\n\n  return iCalString;\n}\n\n- (iCalRepeatableEntityObject *) lookupOccurrence: (NSString *) recID\n{\n  [self subclassResponsibility: _cmd];\n\n  return nil;\n}\n\n- (SOGoComponentOccurence *) occurence: (iCalRepeatableEntityObject *) component\n{\n  [self subclassResponsibility: _cmd];\n\n  return nil;\n}\n\n- (iCalRepeatableEntityObject *) newOccurenceWithID: (NSString *) recID\n{\n  iCalRepeatableEntityObject *masterOccurence, *newOccurence;\n  iCalCalendar *calendar;\n  NSCalendarDate *recDate;\n  NSTimeZone *timeZone;\n  iCalPerson *organizer;\n\n  recDate = [NSCalendarDate dateWithTimeIntervalSince1970: [recID intValue]];\n  masterOccurence = [self component: NO secure: NO];\n  timeZone = [[[context activeUser] userDefaults] timeZone];\n  [recDate setTimeZone: timeZone];\n\n  if ([masterOccurence doesOccurOnDate: recDate])\n    {\n      newOccurence = [masterOccurence mutableCopy];\n      organizer = [masterOccurence organizer];\n      [newOccurence autorelease];\n      [newOccurence removeAllRecurrenceRules];\n      [newOccurence removeAllExceptionRules];\n      [newOccurence removeAllExceptionDates];\n\n      // It is important to set the organizer as some DAV clients (iCal\n      // and Thunderbird 10/Lightning 1.2) will prompt the event \"edition\"\n      // dialog instead of the event \"invitation\" (for accept/decline/tentative)\n      // if the organizer isn't found in a specific recurrence\n      [newOccurence setOrganizer: organizer];\n      [newOccurence setRecurrenceId: recDate];\n\n      calendar = [masterOccurence parent];\n      [calendar addChild: newOccurence];\n    }\n  else\n    newOccurence = nil;\n\n  return newOccurence;\n}\n\n- (id) toManyRelationshipKeys\n{\n  return nil;\n}\n\n- (id) toOneRelationshipKeys\n{\n  NSMutableArray *keys;\n  NSArray *occurences;\n  NSCalendarDate *recID;\n  unsigned int count, max, seconds;\n\n  keys = [NSMutableArray array];\n  [keys addObject: @\"master\"];\n  occurences = [[self calendar: NO secure: NO] allObjects];\n  max = [occurences count];\n  for (count = 1; count < max; count++)\n    {\n      recID = [[occurences objectAtIndex: count] recurrenceId];\n      if (recID)\n\t{\n\t  seconds = [recID timeIntervalSince1970];\n\t  [keys addObject: [NSString stringWithFormat: @\"occurence%d\",\n\t\t\t\t     seconds]];\n\t}\n    }\n\n  return keys;\n}\n\n- (id) lookupName: (NSString *) lookupName\n        inContext: (id) localContext\n          acquire: (BOOL) acquire\n{\n  id obj;\n  iCalRepeatableEntityObject *occurence;\n  NSString *recID;\n  BOOL isNewOccurence;\n\n  obj = [super lookupName: lookupName\n\t       inContext: localContext\n\t       acquire: acquire];\n  if (!obj)\n    {\n      if ([lookupName isEqualToString: @\"master\"])\n\tobj = [self occurence: [self component: NO secure: NO]];\n      else if ([lookupName hasPrefix: @\"occurence\"])\n\t{\n\t  recID = [lookupName substringFromIndex: 9];\n\t  occurence = [self lookupOccurrence: recID];\n\t  if (occurence)\n            isNewOccurence = NO;\n          else\n\t    {\n\t      occurence = [self newOccurenceWithID: recID];\n\t      isNewOccurence = YES;\n\t    }\n\t  if (occurence)\n\t    {\n\t      obj = [self occurence: occurence];\n\t      if (isNewOccurence)\n\t\t[obj setIsNew: isNewOccurence];\n\t    }\n\t}\n    }\n\n  return obj;\n}\n\n- (NSString *) _secureContentWithoutAlarms\n{\n  iCalCalendar *calendar;\n  NSArray *allComponents;\n  iCalEntityObject *currentComponent;\n  NSUInteger count, max;\n\n  calendar = [self calendar: NO secure: YES];\n  allComponents = [calendar childrenWithTag: [self componentTag]];\n  max = [allComponents count];\n  for (count = 0; count < max; count++)\n    {\n      currentComponent = [allComponents objectAtIndex: count];\n      [currentComponent removeAllAlarms];\n    }\n\n  return [calendar versitString];\n}\n\n- (NSString *) contentAsString\n{\n  NSString *secureContent;\n\n  if ([[context request] isSoWebDAVRequest])\n    {\n      if ([container showCalendarAlarms])\n        secureContent = [self secureContentAsString];\n      else\n        secureContent = [self _secureContentWithoutAlarms];\n    }\n  else\n    secureContent = [super contentAsString];\n\n  return secureContent;\n}\n\n- (NSString *) davCalendarData\n{\n  return [self contentAsString];\n}\n\n- (iCalCalendar *) calendar: (BOOL) create secure: (BOOL) secure\n{\n  iCalRepeatableEntityObject *newComponent;\n  iCalCalendar **calendar, *returnedCopy;\n  NSString *iCalString, *tag, *prodID;\n\n  if (secure)\n    calendar = &safeCalendar;\n  else\n    calendar = &fullCalendar;\n\n  if (!*calendar)\n    {\n      if (secure)\n\tiCalString = [self secureContentAsString];\n      else\n\tiCalString = content;\n\n      if ([iCalString length] > 0)\n\t{\n\t  ASSIGN (*calendar, [iCalCalendar parseSingleFromSource: iCalString]);\n\t  if (!secure)\n\t    originalCalendar = [*calendar copy];\n\t}\n      else\n\t{\n\t  if (create)\n\t    {\n\t      ASSIGN (*calendar, [iCalCalendar groupWithTag: @\"vcalendar\"]);\n\t      [*calendar setVersion: @\"2.0\"];\n              prodID = [NSString stringWithFormat:\n                                   @\"-//Inverse inc./SOGo %@//EN\",\n                                 SOGoVersion];\n              [*calendar setProdID: prodID];\n\t      tag = [[self componentTag] uppercaseString];\n\t      newComponent = [[*calendar classForTag: tag]\n\t\t\t       groupWithTag: tag];\n\t      [newComponent setUid: [self globallyUniqueObjectId]];\n\t      [*calendar addChild: newComponent];\n\t    }\n\t}\n    }\n\n  returnedCopy = [*calendar mutableCopy];\n  [returnedCopy autorelease];\n\n  return returnedCopy;\n}\n\n- (id) component: (BOOL) create secure: (BOOL) secure\n{\n  return [[self calendar: create secure: secure]\n\t   firstChildWithTag: [self componentTag]];\n}\n\n//\n// Returs \"YES\" if a a group was decomposed among attendees.\n//\n// It can also return yes if an attendee was found in the list\n// matching the organizer. In which case, it was removed.\n//\n- (BOOL) expandGroupsInEvent: (iCalEvent *) theEvent\n{\n  NSString *organizerEmail, *domain;\n  NSMutableArray *allAttendees;\n  iCalPerson *currentAttendee;\n  NSEnumerator *enumerator;\n  NSAutoreleasePool *pool;\n  SOGoGroup *group;\n\n  BOOL eventWasModified;\n  unsigned int i, j;\n\n\n  domain = [[context activeUser] domain];\n  organizerEmail = [[theEvent organizer] rfc822Email];\n  eventWasModified = NO;\n  allAttendees = [NSMutableArray arrayWithArray: [theEvent attendees]];\n  enumerator = [[theEvent attendees] objectEnumerator];\n\n  j = 0;\n\n  pool = [[NSAutoreleasePool alloc] init];\n\n  while ((currentAttendee = [enumerator nextObject]))\n    {\n      if (j%5 == 0)\n        {\n          RELEASE(pool);\n          pool = [[NSAutoreleasePool alloc] init];\n        }\n\n      group = [SOGoGroup groupWithEmail: [currentAttendee rfc822Email]\n                               inDomain: domain];\n      if (group)\n\t{\n\t  iCalPerson *person;\n\t  NSArray *members;\n\t  SOGoUser *user;\n\t  \n\t  // We did decompose a group...\n\t  [allAttendees removeObject: currentAttendee];\n\n\t  members = [group members];\n\t  for (i = 0; i < [members count]; i++)\n\t    {\n\t      user = [members objectAtIndex: i];\n\t      eventWasModified = YES;\n\n\t      // If the organizer is part of the group, we skip it from\n\t      // the addition to the attendees' list\n\t      if ([user hasEmail: organizerEmail])\n\t\tcontinue;\n\t      \n\t      person = [self iCalPersonWithUID: [user login]];\n\t      [person setTag: @\"ATTENDEE\"];\n\t      [person setParticipationStatus: [currentAttendee participationStatus]];\n\t      [person setRsvp: [currentAttendee rsvp]];\n\t      [person setRole: [currentAttendee role]];\n\t\t\t    \n\t      if (![allAttendees containsObject: person])\n\t\t[allAttendees addObject: person];\n\t    }\n\t}\n      else\n\t{\n\t  // We remove any attendees matching the organizer. Apple iCal will do that when\n\t  // you invite someone. It'll add the organizer in the attendee list, which will\n\t  // confuse itself!\n\t  if ([[currentAttendee rfc822Email] caseInsensitiveCompare: organizerEmail] == NSOrderedSame)\n\t    {\n\t      [allAttendees removeObject: currentAttendee];\n\t      eventWasModified = YES;\n\t    }\n\t}\n      \n      j++;\n    } // while (currentAttendee ...\n\n  if (eventWasModified)\n    [theEvent setAttendees: allAttendees];\n  \n  RELEASE(pool);\n\n  return eventWasModified;\n}\n\n- (void) _updateRecurrenceIDsWithEvent: (iCalRepeatableEntityObject*) newEvent\n{\n  iCalRepeatableEntityObject *oldMaster, *currentComponent;\n  iCalDateTime *currentDate;\n  int deltaSecs;\n  NSArray *components, *dates;\n  NSMutableArray *newDates;\n  unsigned int count, max;\n  NSCalendarDate *recID, *newDate;\n\n  // Compute time interval from previous event definition.\n  if (!originalCalendar)\n    {\n      if (content)\n\tASSIGN (originalCalendar, [iCalCalendar parseSingleFromSource: content]);\n      else\n\t[self warnWithFormat: @\"content not available, we will crash\"];\n    }\n\n  oldMaster = (iCalRepeatableEntityObject *)\n    [originalCalendar firstChildWithTag: [self componentTag]];\n  deltaSecs = [[newEvent startDate]\n\t\ttimeIntervalSinceDate: [oldMaster startDate]];\n\n  components = [[newEvent parent] events];\n  max = [components count];\n\n  if (max > 0)\n    {\n      // Update recurrence-id attribute of occurences.\n      for (count = 1; count < max; count++)\n\t{\n\t  currentComponent = [components objectAtIndex: count];\n\t  recID = [[currentComponent recurrenceId] addTimeInterval: deltaSecs];\n\t  [currentComponent setRecurrenceId: recID];\n\t}\n\n      // Update exception dates in master vEvent.\n      currentComponent = [components objectAtIndex: 0];\n      dates = [currentComponent childrenWithTag: @\"exdate\"];\n      max = [dates count];\n      if (max > 0)\n\t{\n\t  newDates = [NSMutableArray arrayWithCapacity: max];\n\t  for (count = 0; count < max; count++)\n\t    {\n\t      currentDate = [dates objectAtIndex: count];\n\t      newDate = [[currentDate dateTime] addTimeInterval: deltaSecs];\n\t      [newDates addObject: newDate];\n\t    }\n\t  [currentComponent removeAllExceptionDates];\n\t  for (count = 0; count < max; count++)\n\t    [currentComponent addToExceptionDates: [newDates objectAtIndex: count]];\n\t}\n    }\n}\n\n- (void) updateComponent: (iCalRepeatableEntityObject *) newObject\n{\n  NSString *newUid;\n\n  if (!isNew\n      && [newObject isRecurrent])\n    // We update an repeating event -- update exception dates\n    // and recurrence-ids.\n    [self _updateRecurrenceIDsWithEvent: newObject];\n\n  // As much as we can, we try to use c_name == c_uid in order\n  // to avoid tricky scenarios with some CalDAV clients. For example,\n  // if Alice invites Bob (both use SOGo) and Bob accepts the invitation\n  // using Lightning before having refreshed their calendar, they'll end up\n  // with a duplicate of the event in their database tables.\n  if (isNew)\n    {\n      newUid = nameInContainer;\n      \n      if ([newUid hasSuffix: @\".ics\"])\n\tnewUid = [newUid substringToIndex: [newUid length]-4];\n      [newObject setUid: newUid];\n    }\n\n  if ([[SOGoSystemDefaults sharedSystemDefaults] enableEMailAlarms])\n    {\n      SOGoEMailAlarmsManager *eaMgr;\n      \n      eaMgr = [SOGoEMailAlarmsManager sharedEMailAlarmsManager];\n      [eaMgr handleAlarmsInCalendar: [newObject parent]\n\t     fromComponent: self];\n    }\n}\n\n- (NSException *) saveCalendar: (iCalCalendar *) newCalendar\n{\n  [super saveComponent: newCalendar];\n\n  return nil;\n}\n\n- (NSException *) saveComponent: (iCalRepeatableEntityObject *) newObject\n{\n  return [self saveCalendar: [newObject parent]];\n}\n\n/* raw saving */\n\n/* EMail Notifications */\n- (NSString *) homePageURLForPerson: (iCalPerson *) _person\n{\n  NSString *baseURL;\n  NSString *uid;\n  NSArray *traversalObjects;\n\n  /* generate URL from traversal stack */\n  traversalObjects = [context objectTraversalStack];\n  if ([traversalObjects count] > 0)\n    baseURL = [[traversalObjects objectAtIndex:0] baseURLInContext: context];\n  else\n    {\n      baseURL = @\"http://localhost/\";\n      [self warnWithFormat:@\"Unable to create baseURL from context!\"];\n    }\n  uid = [_person uid];\n\n  return ((uid)\n          ? [NSString stringWithFormat:@\"%@%@\", baseURL, uid]\n          : nil);\n}\n\n- (NSTimeZone *) timeZoneForUser: (NSString *) email\n{\n  NSString *uid;\n  SOGoUserDefaults *ud;\n\n  uid = [[SOGoUserManager sharedUserManager] getUIDForEmail: email];\n  ud = [[SOGoUser userWithLogin: uid] userDefaults];\n\n  return [ud timeZone];\n}\n\n- (NGMimeBodyPart *) _bodyPartForICalObject: (iCalRepeatableEntityObject *) object\n{\n  NGMimeBodyPart *bodyPart;\n  NGMutableHashMap *headerMap;\n  NSString *iCalString, *header, *charset;\n  NSData *objectData;\n  iCalCalendar *parent;\n\n  parent = [object parent];\n  iCalString = [NSString stringWithFormat: @\"%@\\r\\n\", [parent versitString]];\n  if ([iCalString canBeConvertedToEncoding: NSISOLatin1StringEncoding])\n    {\n      objectData = [iCalString dataUsingEncoding: NSISOLatin1StringEncoding];\n      charset = @\"ISO-8859-1\";\n    }\n  else\n    {\n      objectData = [iCalString dataUsingEncoding: NSUTF8StringEncoding];\n      charset = @\"UTF-8\";\n    }\n\n  header = [NSString stringWithFormat: @\"text/calendar; method=%@;\"\n                     @\" charset=\\\"%@\\\"\",\n                     [(iCalCalendar *) [object parent] method], charset];\n  headerMap = [NGMutableHashMap hashMapWithCapacity: 3];\n  [headerMap setObject: @\"urn:content-classes:calendarmessage\"  forKey: @\"Content-Class\"];\n  [headerMap setObject: header forKey: @\"content-type\"];\n  [headerMap setObject: @\"quoted-printable\"\n                forKey: @\"content-transfer-encoding\"];\n  bodyPart = [NGMimeBodyPart bodyPartWithHeader: headerMap];\n  [bodyPart setBody: [objectData dataByEncodingQuotedPrintable]];\n\n  return bodyPart;\n}\n\n//\n//\n//\n- (void) sendEMailUsingTemplateNamed: (NSString *) newPageName\n\t\t\t   forObject: (iCalRepeatableEntityObject *) object\n\t\t      previousObject: (iCalRepeatableEntityObject *) previousObject\n                         toAttendees: (NSArray *) attendees\n                            withType: (NSString *) msgType\n{\n  NSString *pageName;\n  NSString *senderEmail, *shortSenderEmail, *email;\n  WOApplication *app;\n  unsigned i, count;\n  iCalPerson *attendee;\n  NSString *recipient;\n  SOGoAptMailNotification *p;\n  NSString *mailDate, *subject, *text;\n  NGMutableHashMap *headerMap;\n  NGMimeMessage *msg;\n  NGMimeBodyPart *bodyPart, *eventBodyPart;\n  NGMimeMultipartBody *body;\n  SOGoUser *ownerUser;\n  SOGoDomainDefaults *dd;\n\n  // If defined, we return immediately. When not defined, we send the notifications correctly\n  if ([object firstChildWithTag: @\"X-SOGo-Send-Appointment-Notifications\"])\n    return;\n\n  ownerUser = [SOGoUser userWithLogin: owner];\n  dd = [ownerUser domainDefaults];\n  if ([dd appointmentSendEMailNotifications] && [object isStillRelevant])\n    {\n      count = [attendees count];\n      if (count)\n\t{\n\t  /* sender */\n\t  shortSenderEmail = [[object organizer] rfc822Email];\n\t  if ([shortSenderEmail length])\n            {\n              senderEmail = [[object organizer] mailAddress];\n            }\n          else\n            {\n              shortSenderEmail = [[previousObject organizer] rfc822Email];\n              senderEmail = [[previousObject organizer] mailAddress];\n            }\n\n          /* calendar part */\n          eventBodyPart = [self _bodyPartForICalObject: object];\n\n\t  /* get WOApplication instance */\n\t  app = [WOApplication application];\n\n\t  /* generate dynamic message content */\n\t  for (i = 0; i < count; i++)\n\t    {\n\t      attendee = [attendees objectAtIndex: i];\n\t      // Don't send a notification to the event organizer nor a deletion\n\t      // notification to an attendee who already declined the invitation.\n\t      if (![[attendee uid] isEqualToString: owner] &&\n\t\t  !([[attendee partStat] compare: @\"DECLINED\"] == NSOrderedSame &&\n\t\t    [newPageName compare: @\"Deletion\"] == NSOrderedSame))\n\t\t{\n\t\t  /* construct recipient */\n\t\t  recipient = [attendee mailAddress];\n\t\t  email = [attendee rfc822Email];\n\n#warning this could be optimized in a class hierarchy common with the\t\\\n  SOGoObject acl notification mechanism\n\t\t  /* create page name */\n\t\t  pageName = [NSString stringWithFormat: @\"SOGoAptMail%@\",\n                                       newPageName];\n\t\t  /* construct message content */\n\t\t  p = [app pageWithName: pageName inContext: context];\n\t\t  [p setApt: (iCalEvent *) object];\n\t\t  [p setPreviousApt: (iCalEvent *) previousObject];\n\t\t  \n\t\t  if ([[object organizer] cn] && [[[object organizer] cn] length])\n\t\t    {\n\t\t      [p setOrganizerName: [[object organizer] cn]];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      [p setOrganizerName: [ownerUser cn]];\n\t\t    }\n\n\t\t  subject = [[p getSubject] asQPSubjectString: @\"UTF-8\"];\n\t\t  text = [p getBody];\n\n\t\t  /* construct message */\n\t\t  headerMap = [NGMutableHashMap hashMapWithCapacity: 5];\n          \n\t\t  /* NOTE: multipart/alternative seems like the correct choice but\n\t\t   * unfortunately Thunderbird doesn't offer the rich content alternative\n\t\t   * at all. Mail.app shows the rich content alternative _only_\n\t\t   * so we'll stick with multipart/mixed for the time being.\n\t\t   */\n#warning SOPE is just plain stupid here - if you change the case of keys, it will break the encoding of fields\n\t\t  [headerMap setObject: @\"multipart/mixed\" forKey: @\"content-type\"];\n\t\t  [headerMap setObject: @\"1.0\" forKey: @\"MIME-Version\"];\n\t\t  [headerMap setObject: senderEmail forKey: @\"from\"];\n\t\t  [headerMap setObject: recipient forKey: @\"to\"];\n\t\t  mailDate = [[NSCalendarDate date] rfc822DateString];\n\t\t  [headerMap setObject: mailDate forKey: @\"date\"];\n\t\t  [headerMap setObject: subject forKey: @\"subject\"];\n                  [headerMap setObject: [NSString generateMessageID] forKey: @\"message-id\"];\n                  if ([msgType length] > 0)\n                    [headerMap setObject: msgType forKey: @\"x-sogo-message-type\"];\n\t\t  msg = [NGMimeMessage messageWithHeader: headerMap];\n\n\t\t  /* multipart body */\n\t\t  body = [[NGMimeMultipartBody alloc] initWithPart: msg];\n\n\t\t  /* text part */\n\t\t  headerMap = [NGMutableHashMap hashMapWithCapacity: 1];\n\t\t  [headerMap setObject: @\"text/html; charset=utf-8\"\n\t\t\t\tforKey: @\"content-type\"];\n\t\t  bodyPart = [NGMimeBodyPart bodyPartWithHeader: headerMap];\n\t\t  [bodyPart setBody: [text dataUsingEncoding: NSUTF8StringEncoding]];\n\n\t\t  /* attach text part to multipart body */\n\t\t  [body addBodyPart: bodyPart];\n    \n\t\t  /* attach calendar part to multipart body */\n\t\t  [body addBodyPart: eventBodyPart];\n    \n\t\t  /* attach multipart body to message */\n\t\t  [msg setBody: body];\n\t\t  [body release];\n\n\t\t  /* send the damn thing */\n\t\t  [[SOGoMailer mailerWithDomainDefaults: dd]\n\t\t           sendMimePart: msg\n                           toRecipients: [NSArray arrayWithObject: email]\n                                 sender: shortSenderEmail\n                      withAuthenticator: [self authenticatorInContext: context]\n                              inContext: context];\n\t\t}\n\t    }\n\t}\n    }\n}\n\n#warning fix this when sendEmailUsing blabla has been cleaned up\n- (void) sendIMIPReplyForEvent: (iCalRepeatableEntityObject *) event\n\t\t\t  from: (SOGoUser *) from\n\t\t\t    to: (iCalPerson *) recipient\n{\n  NSString *pageName, *mailDate, *email;\n  WOApplication *app;\n  iCalPerson *attendee;\n  SOGoAptMailICalReply *p;\n  NGMutableHashMap *headerMap;\n  NGMimeMessage *msg;\n  NGMimeBodyPart *bodyPart;\n  NGMimeMultipartBody *body;\n  NSData *bodyData;\n  SOGoDomainDefaults *dd;\n\n  dd = [from domainDefaults];\n  if ([dd appointmentSendEMailNotifications] && [event isStillRelevant])\n    {\n      /* get WOApplication instance */\n      app = [WOApplication application];\n\n      /* create page name */\n      pageName = @\"SOGoAptMailICalReply\";\n      /* construct message content */\n      p = [app pageWithName: pageName inContext: context];\n      [p setApt: (iCalEvent *) event];\n\n      attendee = [event userAsAttendee: from];\n      [p setAttendee: attendee];\n\n      /* construct message */\n      headerMap = [NGMutableHashMap hashMapWithCapacity: 5];\n\n      /* NOTE: multipart/alternative seems like the correct choice but\n       * unfortunately Thunderbird doesn't offer the rich content alternative\n       * at all. Mail.app shows the rich content alternative _only_\n       * so we'll stick with multipart/mixed for the time being.\n       */\n#warning SOPE is just plain stupid here - if you change the case of keys, it will break the encoding of fields\n      [headerMap setObject: [attendee mailAddress] forKey: @\"from\"];\n      [headerMap setObject: [recipient mailAddress] forKey: @\"to\"];\n      mailDate = [[NSCalendarDate date] rfc822DateString];\n      [headerMap setObject: mailDate forKey: @\"date\"];\n      [headerMap setObject: [[p getSubject] asQPSubjectString: @\"UTF-8\"]\n                    forKey: @\"subject\"];\n      [headerMap setObject: [NSString generateMessageID] forKey: @\"message-id\"];\n      [headerMap setObject: @\"1.0\" forKey: @\"MIME-Version\"];\n      [headerMap setObject: @\"multipart/mixed\" forKey: @\"content-type\"];\n      [headerMap setObject: @\"calendar:invitation-reply\" forKey: @\"x-sogo-message-type\"];\n      msg = [NGMimeMessage messageWithHeader: headerMap];\n\n      /* multipart body */\n      body = [[NGMimeMultipartBody alloc] initWithPart: msg];\n\n      /* text part */\n      headerMap = [NGMutableHashMap hashMapWithCapacity: 1];\n      [headerMap setObject: @\"text/html; charset=utf-8\"\n\t\t    forKey: @\"content-type\"];\n      bodyPart = [NGMimeBodyPart bodyPartWithHeader: headerMap];\n      bodyData = [[p getBody] dataUsingEncoding: NSUTF8StringEncoding];\n      [bodyPart setBody: bodyData];\n\n      /* attach text part to multipart body */\n      [body addBodyPart: bodyPart];\n\n      /* attach calendar part to multipart body */\n      [body addBodyPart: [self _bodyPartForICalObject: event]];\n\n      /* attach multipart body to message */\n      [msg setBody: body];\n      [body release];\n\n      /* send the damn thing */\n      email = [recipient rfc822Email];\n      [[SOGoMailer mailerWithDomainDefaults: dd]\n\t       sendMimePart: msg\n               toRecipients: [NSArray arrayWithObject: email]\n                     sender: [attendee rfc822Email]\n          withAuthenticator: [self authenticatorInContext: context]\n                  inContext: context];\n    }\n}\n\n//\n//\n//\n- (void) sendResponseToOrganizer: (iCalRepeatableEntityObject *) newComponent\n\t\t\t    from: (SOGoUser *) from\n{\n  iCalPerson *organizer, *attendee;\n  iCalEvent *event;\n  SOGoUser *ownerUser;\n\n  event = [newComponent itipEntryWithMethod: @\"reply\"];\n  ownerUser = [SOGoUser userWithLogin: owner];\n  if (![event userIsOrganizer: ownerUser])\n    {\n      organizer = [event organizer];\n      attendee = [event userAsAttendee: ownerUser];\n      [event setAttendees: [NSArray arrayWithObject: attendee]];\n      [self sendIMIPReplyForEvent: event from: from to: organizer];\n    }\n}\n\n//\n//\n//\n- (void) sendReceiptEmailForObject: (iCalRepeatableEntityObject *) object\n\t\t    addedAttendees: (NSArray *) theAddedAttendees\n\t\t  deletedAttendees: (NSArray *) theDeletedAttendees\n\t\t  updatedAttendees: (NSArray *) theUpdatedAttendees\n\t\t\t operation: (SOGoEventOperation) theOperation\n{\n  NSString *calendarName, *mailDate, *mailText, *fullSenderEmail, *senderEmail, *fullRecipientEmail, *recipientEmail;\n  NSDictionary *senderIdentity, *recipientIdentity;\n  id <SOGoAuthenticator> authenticator;\n  SOGoUser *currentUser, *ownerUser;\n  NGMutableHashMap *headerMap;\n  SOGoAptMailReceipt *page;\n  SOGoDomainDefaults *dd;\n  NGMimeMessage *msg;\n\n  calendarName = [[self container] displayName];\n\n  // We must handle three cases here:\n  // - Receive a mail when I modify my calendar\n  // - Receive a mail when someone else modifies my calendar\n  // - When I modify my calendar, send a mail to: <foo@bar.com>\n\n  // We first built the template that we'll slightly adjust for our three use-cases\n  page = [[WOApplication application] pageWithName: @\"SOGoAptMailReceipt\"\n\t\t\t\t\t inContext: context];\n  [page setApt: (iCalEvent *) object];\n  [page setAddedAttendees: theAddedAttendees];\n  [page setDeletedAttendees: theDeletedAttendees];\n  [page setUpdatedAttendees: theUpdatedAttendees];\n  [page setOperation: theOperation];\n  [page setCalendarName: calendarName];\n  \n  currentUser = [context activeUser];\n  senderIdentity = [currentUser primaryIdentity];\n\n  dd = [currentUser domainDefaults];\n\n#warning SOPE is just plain stupid here - if you change the case of keys, it will break the encoding of fields\n  headerMap = [NGMutableHashMap hashMapWithCapacity: 5];\n  \n  // Sender can vary, base on whom modifies the actual event (owner vs. someone else)\n  senderEmail = [senderIdentity objectForKey: @\"email\"];\n  fullSenderEmail = [senderIdentity keysWithFormat: @\"%{fullName} <%{email}>\"];\n  [headerMap setObject: fullSenderEmail forKey: @\"from\"];\n\n  // Recipient is fixed, which is the calendar owner\n  ownerUser = [SOGoUser userWithLogin: self->owner];\n  recipientIdentity = [ownerUser primaryIdentity];\n  \n  // Safety net for broken configurations\n  if (!recipientIdentity)\n    return;\n\n  recipientEmail = [recipientIdentity objectForKey: @\"email\"];\n  fullRecipientEmail = [recipientIdentity keysWithFormat: @\"%{fullName} <%{email}>\"];\n  \n  [headerMap setObject: fullRecipientEmail forKey: @\"to\"];\n\n  mailDate = [[NSCalendarDate date] rfc822DateString];\n  [headerMap setObject: mailDate forKey: @\"date\"];\n  [headerMap setObject: [page getSubject] forKey: @\"subject\"];\n  [headerMap setObject: [NSString generateMessageID] forKey: @\"message-id\"];\n  [headerMap setObject: @\"1.0\" forKey: @\"MIME-Version\"];\n  [headerMap setObject: @\"text/html; charset=utf-8\"\n\t\tforKey: @\"content-type\"];\n  msg = [NGMimeMessage messageWithHeader: headerMap];\n  \n  /* text part */\n  mailText = [page getBody];\n  [msg setBody: [mailText dataUsingEncoding: NSUTF8StringEncoding]];\n\n  authenticator = [self authenticatorInContext: context];\n  \n  if ([self->owner isEqualToString: [currentUser login]])\n    {\n      if ([[self container] notifyOnPersonalModifications])\n\t{\n\t  [[SOGoMailer mailerWithDomainDefaults: dd]\n\t\t    sendMimePart: msg\n\t\t    toRecipients: [NSArray arrayWithObject: recipientEmail]\n                          sender: senderEmail\n               withAuthenticator: authenticator\n                       inContext: context];\n\t}\n      \n      if ([[self container] notifyUserOnPersonalModifications])\n\t{\n\t  id o;\n\n\t  o = [headerMap objectForKey: @\"to\"];\n\t  recipientEmail = [[self container] notifiedUserOnPersonalModifications];\n\t  [headerMap setObject: recipientEmail forKey: @\"to\"];\n\t  \n\t  [[SOGoMailer mailerWithDomainDefaults: dd]\n\t\t    sendMimePart: msg\n\t\t    toRecipients: [NSArray arrayWithObject: recipientEmail]\n                          sender: senderEmail\n               withAuthenticator: authenticator\n                       inContext: context];\n\n\t  [headerMap setObject: o forKey: @\"to\"];\n\t}\n    }\n\n      \n  if ([[self container] notifyOnExternalModifications] &&\n      ![self->owner isEqualToString: [currentUser login]])\n    {\n      [[SOGoMailer mailerWithDomainDefaults: dd]\n\t\t    sendMimePart: msg\n\t\t    toRecipients: [NSArray arrayWithObject: recipientEmail]\n                          sender: senderEmail\n               withAuthenticator: authenticator\n                       inContext: context];\n    }\n\n}\n\n//\n//\n//\n- (iCalPerson *) findParticipantWithUID: (NSString *) uid\n{\n  iCalEntityObject *component;\n  SOGoUser *user;\n\n  user = [SOGoUser userWithLogin: uid];\n  component = [self component: NO secure: NO];\n\n  return [component userAsAttendee: user];\n}\n\n//\n//\n//\n- (iCalPerson *) iCalPersonWithUID: (NSString *) uid\n{\n  iCalPerson *person;\n  SOGoUserManager *um;\n  NSDictionary *contactInfos;\n\n  um = [SOGoUserManager sharedUserManager];\n  contactInfos = [um contactInfosForUserWithUIDorEmail: uid];\n\n  person = [iCalPerson new];\n  [person autorelease];\n  [person setCn: [contactInfos objectForKey: @\"cn\"]];\n  [person setEmail: [contactInfos objectForKey: @\"c_email\"]];\n\n  return person;\n}\n\n//\n//\n//\n- (NSArray *) getUIDsForICalPersons: (NSArray *) iCalPersons\n{\n  iCalPerson *currentPerson;\n  NSEnumerator *persons;\n  NSMutableArray *uids;\n  NSString *uid;\n\n  uids = [NSMutableArray array];\n\n  persons = [iCalPersons objectEnumerator];\n  while ((currentPerson = [persons nextObject]))\n    {\n      uid = [currentPerson uid];\n      if (uid)\n\t[uids addObject: uid];\n    }\n\n  return uids;\n}\n\n- (NSException *) copyToFolder: (SOGoGCSFolder *) newFolder\n{\n  return [self copyComponent: [self calendar: NO secure: NO]\n\t\t    toFolder: newFolder];\n}\n\n- (NSException *) copyComponent: (iCalCalendar *) calendar\n\t\t       toFolder: (SOGoGCSFolder *) newFolder\n{\n  NSArray *elements;\n  NSString *newUID;\n  unsigned int count, max;\n  SOGoCalendarComponent *newComponent;\n\n  newUID = [self globallyUniqueObjectId];\n  elements = [calendar allObjects];\n  max = [elements count];\n  for (count = 0; count < max; count++)\n    [[elements objectAtIndex: count] setUid: newUID];\n\n  newComponent = [[self class] objectWithName:\n\t\t\t\t [NSString stringWithFormat: @\"%@.ics\", newUID]\n\t\t\t       inContainer: newFolder];\n\n  return [newComponent saveCalendar: calendar];\n}\n\n- (NSException *) moveToFolder: (SOGoGCSFolder *) newFolder\n{\n  NSException *ex;\n\n  ex = [self copyToFolder: newFolder];\n\n  if (!ex)\n    ex = [self delete];\n\n  return ex;\n}\n\n#warning Should we not remove the concept of Organizer and Participant roles?\n- (NSString *) _roleOfOwner: (iCalRepeatableEntityObject *) component\n{\n  NSString *role;\n  iCalPerson *organizer;\n  SOGoUser *ownerUser;\n\n  if (isNew)\n    role = SOGoCalendarRole_Organizer;\n  else\n    {\n      organizer = [component organizer];\n      if ([[organizer rfc822Email] length] > 0)\n\t{\n\t  ownerUser = [SOGoUser userWithLogin: owner];\n\t  if ([component userIsOrganizer: ownerUser])\n\t    role = SOGoCalendarRole_Organizer;\n\t  else if ([component userIsAttendee: ownerUser])\n\t    role = SOGoCalendarRole_Participant;\n\t  else\n\t    role = SOGoRole_None;\n\t}\n      else\n\trole = SOGoCalendarRole_Organizer;\n    }\n\n  return role;\n}\n\n- (NSString *) _compiledRoleForOwner: (NSString *) ownerRole\n\t\t\t     andUser: (NSString *) userRole\n{\n  NSString *role;\n\n  if ([userRole isEqualToString: SOGoCalendarRole_ComponentModifier]\n      || ([userRole isEqualToString: SOGoCalendarRole_ComponentResponder]\n\t  && [ownerRole isEqualToString: SOGoCalendarRole_Participant]))\n    role = ownerRole;\n  else\n    role = SOGoRole_None;\n\n  return role;\n}\n\n- (NSArray *) aclsForUser: (NSString *) uid\n{\n  NSMutableArray *roles;\n  NSArray *superAcls;\n  iCalRepeatableEntityObject *component;\n  NSString *accessRole, *ownerRole;\n  SOGoUser *aclUser;\n\n  roles = [NSMutableArray array];\n  superAcls = [super aclsForUser: uid];\n  if ([superAcls count] > 0)\n    [roles addObjectsFromArray: superAcls];\n\n  component = [self component: NO secure: NO];\n  ownerRole = [self _roleOfOwner: component];\n  if ([owner isEqualToString: uid])\n    [roles addObject: ownerRole];\n  else\n    {\n      if (isNew)\n        {\n          if ([roles containsObject: SOGoRole_ObjectCreator])\n            [roles addObject: SOGoCalendarRole_Organizer];\n        }\n      else\n        {\n          if (component)\n            {\n              aclUser = [SOGoUser userWithLogin: uid];\n              if ([component userIsOrganizer: aclUser])\n                [roles addObject: SOGoCalendarRole_Organizer];\n              else if ([component userIsAttendee: aclUser])\n                [roles addObject: SOGoCalendarRole_Participant];\n              accessRole\n                = [container roleForComponentsWithAccessClass: [component symbolicAccessClass]\n                                                      forUser: uid];\n              if ([accessRole length] > 0)\n                {\n                  [roles addObject: accessRole];\n                  [roles addObject: [self _compiledRoleForOwner: ownerRole\n                                                        andUser: accessRole]];\n                }\n            }\n        }\n    }\n\n  return roles;\n}\n\n- (void) snoozeAlarm: (unsigned int) minutes\n{\n  NSDictionary *quickFields;\n  GCSFolder *folder;\n  unsigned int nextAlarm;\n\n  folder = [[self container] ocsFolder];\n  if (!folder)\n    {\n      [self errorWithFormat:@\"(%s): missing folder for update!\",\n            __PRETTY_FUNCTION__];\n      return;\n    }\n\n  nextAlarm = [[NSCalendarDate calendarDate] timeIntervalSince1970]  + minutes * 60;\n  quickFields = [NSDictionary dictionaryWithObject: [NSNumber numberWithInt: nextAlarm]\n                                            forKey: @\"c_nextalarm\"];\n\n  [folder updateQuickFields: quickFields\n                whereColumn: @\"c_name\"\n                  isEqualTo: nameInContainer];\n}\n\n/* SOGoComponentOccurence protocol */\n\n- (iCalRepeatableEntityObject *) occurence\n{\n  return [self component: YES secure: NO];\n}\n\n#warning alarms: we do not handle occurrences\n- (NSException *) prepareDelete\n{\n  if ([[SOGoSystemDefaults sharedSystemDefaults] enableEMailAlarms])\n    {\n      SOGoEMailAlarmsManager *eaMgr;\n      \n      eaMgr = [SOGoEMailAlarmsManager sharedEMailAlarmsManager];\n      [eaMgr deleteAlarmsFromComponent: self];\n    }\n\n  return nil;\n}\n\n- (id) PUTAction: (WOContext *) localContext\n{\n  if ([[SOGoSystemDefaults sharedSystemDefaults] enableEMailAlarms])\n    {\n      SOGoEMailAlarmsManager *eaMgr;\n      iCalCalendar *putCalendar;\n      WORequest *rq;\n\n      rq = [localContext request];\n      putCalendar = [iCalCalendar parseSingleFromSource: [rq contentAsString]];\n      eaMgr = [SOGoEMailAlarmsManager sharedEMailAlarmsManager];\n      [eaMgr handleAlarmsInCalendar: putCalendar\n                      fromComponent: self];\n    }\n\n  return [super PUTAction: localContext];\n}\n\n// /* Overriding this method dramatically speeds up PROPFIND request, but may\n//    otherwise be a bad idea... Wait and see. */\n// - (NSDictionary*) valuesForKeys: (NSArray*)keys\n// {\n//   NSMutableDictionary *values;\n\n//   values = [NSMutableDictionary dictionaryWithCapacity: [keys count]];\n//   [values setObject: [self davCreationDate] forKey: @\"davCreationDate\"];\n//   [values setObject: [self davContentLength] forKey: @\"davContentLength\"];\n//   [values setObject: [self davLastModified] forKey: @\"davLastModified\"];\n//   [values setObject: @\"text/calendar\" forKey: @\"davContentType\"];\n//   [values setObject: [self baseURL] forKey: @\"davURL\"];\n\n//   return values;\n// }\n\n- (void) adjustClassificationInRequestCalendar: (iCalCalendar *) rqCalendar\n{\n  SOGoUserDefaults *userDefaults;\n  NSString *accessClass;\n  NSArray *allObjects;\n  id entity;\n\n  int i;\n\n  userDefaults = [[context activeUser] userDefaults];\n  allObjects = [rqCalendar allObjects];\n\n  for (i = 0; i < [allObjects count]; i++)\n    {\n      entity = [allObjects objectAtIndex: i];\n\n      if ([entity respondsToSelector: @selector(accessClass)])\n        {\n          accessClass = [entity accessClass];\n\n          if (!accessClass || [accessClass length] == 0)\n            {\n              if ([entity isKindOfClass: [iCalEvent class]])\n                [entity setAccessClass: [userDefaults calendarEventsDefaultClassification]];\n              else if ([entity isKindOfClass: [iCalToDo class]])\n                [entity setAccessClass: [userDefaults calendarTasksDefaultClassification]];\n            }\n        }\n    }\n}\n\n\n@end\n", "/* SOGoUserSettings.h - this file is part of SOGo\n *\n * Copyright (C) 2009-2016 Inverse inc.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n#ifndef SOGOUSERSETTINGS_H\n#define SOGOUSERSETTINGS_H\n\n#import \"SOGoDefaultsSource.h\"\n\n@class NSArray;\n@class NSMutableDictionary;\n@class NSString;\n\n@interface SOGoUserSettings : SOGoDefaultsSource\n\n+ (SOGoUserSettings *) settingsForUser: (NSString *) userId;\n\n- (NSArray *) subscribedCalendars;\n- (NSArray *) subscribedAddressBooks;\n- (NSString *) userSalt;\n\n@end\n\n#endif /* SOGOUSERSETTINGS_H */\n", "/* SOGoUserSettings.m - this file is part of SOGo\n *\n * Copyright (C) 2009-2016 Inverse inc.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n#import <Foundation/NSArray.h>\n#import <Foundation/NSDictionary.h>\n#import <Foundation/NSProcessInfo.h>\n#import <Foundation/NSString.h>\n\n#import \"SOGoUserProfile.h\"\n#import \"NSString+Crypto.h\"\n\n#import \"SOGoUserSettings.h\"\n\nstatic Class SOGoUserProfileKlass = Nil;\n\n@implementation SOGoUserSettings\n\n+ (NSString *) userProfileClassName\n{\n  return @\"SOGoSQLUserProfile\";\n}\n\n+ (void) initialize\n{\n  if (!SOGoUserProfileKlass)\n    SOGoUserProfileKlass = NSClassFromString ([self userProfileClassName]);\n}\n\n+ (SOGoUserSettings *) settingsForUser: (NSString *) userId\n{\n  SOGoUserProfile *up;\n  SOGoUserSettings *ud;\n\n  up = [SOGoUserProfileKlass userProfileWithType: SOGoUserProfileTypeSettings\n                                          forUID: userId];\n  [up fetchProfile];\n  ud = [self defaultsSourceWithSource: up andParentSource: nil];\n\n  return ud;\n}\n\n- (NSArray *) _subscribedFoldersForModule: (NSString *) module\n{\n  return [[self dictionaryForKey: module] objectForKey: @\"SubscribedFolders\"];\n}\n\n- (NSArray *) subscribedCalendars\n{\n  return [self _subscribedFoldersForModule: @\"Calendar\"];\n}\n\n- (NSArray *) subscribedAddressBooks\n{\n  return [self _subscribedFoldersForModule: @\"Contacts\"];\n}\n\n- (NSString *) userSalt\n{\n  NSMutableDictionary *values;\n  NSString *salt;\n\n  salt = [[self dictionaryForKey: @\"General\"] objectForKey: @\"Salt\"];\n\n  if (!salt)\n    {\n      salt = [[[NSProcessInfo processInfo] globallyUniqueString] asSHA1String];\n      values = [self objectForKey: @\"General\"];\n\n      if (!values)\n        values = [NSMutableDictionary dictionary];\n\n      [values setObject: salt  forKey: @\"Salt\"];\n      [self setObject:  values forKey: @\"General\"];\n      [self synchronize];\n    }\n\n  return salt;\n}\n\n\n@end\n"], "filenames": ["SoObjects/Appointments/SOGoCalendarComponent.m", "SoObjects/SOGo/SOGoUserSettings.h", "SoObjects/SOGo/SOGoUserSettings.m"], "buggy_code_start_loc": [49, 3, 3], "buggy_code_end_loc": [243, 35, 71], "fixing_code_start_loc": [50, 3, 3], "fixing_code_end_loc": [250, 37, 98], "type": "CWE-184", "message": "Incomplete blacklist in SOGo before 2.3.12 and 3.x before 3.1.1 allows remote authenticated users to obtain sensitive information by reading the fields in the (1) ics or (2) XML calendar feeds.", "other": {"cve": {"id": "CVE-2016-6189", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-17T17:59:00.797", "lastModified": "2022-12-20T16:52:37.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Incomplete blacklist in SOGo before 2.3.12 and 3.x before 3.1.1 allows remote authenticated users to obtain sensitive information by reading the fields in the (1) ics or (2) XML calendar feeds."}, {"lang": "es", "value": "Blacklist incompleta en SOGo en versiones anteriores a 2.3.12 y 3.x en versiones anteriores a 3.1.1 permite a usuarios remotos autenticados obtener informaci\u00f3n sensible leyendo los campos en la fuente (1) ics o (2) de calendario XML."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-184"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:alinto:sogo:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.12", "matchCriteriaId": "5D75E49A-4A29-46E4-82AF-2AF4CA019014"}, {"vulnerable": true, "criteria": "cpe:2.3:a:alinto:sogo:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.1.1", "matchCriteriaId": "0C9075E1-13A1-42BC-8141-8981BD1B3640"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/07/09/3", "source": "cve@mitre.org", "tags": ["Mailing List", "VDB Entry"]}, {"url": "https://github.com/inverse-inc/sogo/commit/717f45f640a2866b76a8984139391fae64339225", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/inverse-inc/sogo/commit/875a4aca3218340fd4d3141950c82c2ff45b343d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://sogo.nu/bugs/view.php?id=3695", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/inverse-inc/sogo/commit/717f45f640a2866b76a8984139391fae64339225"}}