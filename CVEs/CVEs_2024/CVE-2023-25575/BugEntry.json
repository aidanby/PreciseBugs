{"buggy_code": ["Feature: Authorization checking\n  In order to use the API\n  As a client software user\n  I need to be authorized to access a given resource.\n\n  @createSchema\n  Scenario: An anonymous user retrieves a secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 401\n\n  Scenario: An authenticated user retrieve a secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should be in JSON\n\n  Scenario: Data provider that's return generator has null previous object\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/custom_data_provider_generator\"\n    Then the response status code should be 200\n\n  Scenario: A standard user cannot create a secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"POST\" request to \"/secured_dummies\" with body:\n    \"\"\"\n    {\n        \"title\": \"Title\",\n        \"description\": \"Description\",\n        \"owner\": \"foo\"\n    }\n    \"\"\"\n    Then the response status code should be 403\n\n  Scenario: An admin can create a secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"POST\" request to \"/secured_dummies\" with body:\n    \"\"\"\n    {\n        \"title\": \"Title\",\n        \"description\": \"Description\",\n        \"owner\": \"someone\"\n    }\n    \"\"\"\n    Then the response status code should be 201\n\n  Scenario: An admin can create another secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"POST\" request to \"/secured_dummies\" with body:\n    \"\"\"\n    {\n        \"title\": \"Special Title\",\n        \"description\": \"Description\",\n        \"owner\": \"dunglas\",\n        \"adminOnlyProperty\": \"secret\"\n    }\n    \"\"\"\n    Then the response status code should be 201\n\n  Scenario: A user cannot retrieve an item they doesn't own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies/1\"\n    Then the response status code should be 403\n    And the response should be in JSON\n\n  Scenario: A user can retrieve an item they owns\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies/2\"\n    Then the response status code should be 200\n\n  Scenario: A user can see a secured owner-only property on an object they own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies/2\"\n    Then the response status code should be 200\n    And the JSON node \"ownerOnlyProperty\" should exist\n    And the JSON node \"ownerOnlyProperty\" should not be null\n\n  Scenario: An admin can't see a secured owner-only property on objects they don't own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should not contain \"ownerOnlyProperty\"\n\n  Scenario: A user can't assign to themself an item they doesn't own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"PUT\" request to \"/secured_dummies/2\" with body:\n    \"\"\"\n    {\n        \"owner\": \"kitten\"\n    }\n    \"\"\"\n    Then the response status code should be 403\n\n  Scenario: A user can update an item they owns and transfer it\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"PUT\" request to \"/secured_dummies/2\" with body:\n    \"\"\"\n    {\n        \"owner\": \"vincent\"\n    }\n    \"\"\"\n    Then the response status code should be 200\n\n  Scenario: An admin retrieves a resource with an admin only viewable property\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should contain \"adminOnlyProperty\"\n\n  Scenario: A user retrieves a resource with an admin only viewable property\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should not contain \"adminOnlyProperty\"\n\n  Scenario: An admin can create a secured resource with a secured Property\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"POST\" request to \"/secured_dummies\" with body:\n    \"\"\"\n    {\n        \"title\": \"Common Title\",\n        \"description\": \"Description\",\n        \"owner\": \"dunglas\",\n        \"adminOnlyProperty\": \"Is it safe?\"\n    }\n    \"\"\"\n    Then the response status code should be 201\n    And the response should contain \"adminOnlyProperty\"\n    And the JSON node \"adminOnlyProperty\" should be equal to the string \"Is it safe?\"\n\n  Scenario: A user cannot update a secured property\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"PUT\" request to \"/secured_dummies/3\" with body:\n    \"\"\"\n    {\n        \"adminOnlyProperty\": \"Yes it is!\"\n    }\n    \"\"\"\n    Then the response status code should be 200\n    And the response should not contain \"adminOnlyProperty\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should contain \"adminOnlyProperty\"\n    And the JSON node \"hydra:member[2].adminOnlyProperty\" should be equal to the string \"Is it safe?\"\n\n  Scenario: An user can update an owner-only secured property on an object they own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"PUT\" request to \"/secured_dummies/3\" with body:\n    \"\"\"\n    {\n        \"ownerOnlyProperty\": \"updated\"\n    }\n    \"\"\"\n    Then the response status code should be 200\n    And the response should contain \"ownerOnlyProperty\"\n    And the JSON node \"ownerOnlyProperty\" should be equal to the string \"updated\"\n", "<?php\n\n/*\n * This file is part of the API Platform project.\n *\n * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ndeclare(strict_types=1);\n\nnamespace ApiPlatform\\Hal\\Serializer;\n\nuse ApiPlatform\\Api\\UrlGeneratorInterface;\nuse ApiPlatform\\Core\\Api\\IriConverterInterface as LegacyIriConverterInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\PropertyMetadata;\nuse ApiPlatform\\Metadata\\ApiProperty;\nuse ApiPlatform\\Serializer\\AbstractItemNormalizer;\nuse ApiPlatform\\Serializer\\CacheKeyTrait;\nuse ApiPlatform\\Serializer\\ContextTrait;\nuse ApiPlatform\\Util\\ClassInfoTrait;\nuse Symfony\\Component\\PropertyInfo\\Type;\nuse Symfony\\Component\\Serializer\\Exception\\LogicException;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\nuse Symfony\\Component\\Serializer\\Mapping\\AttributeMetadataInterface;\n\n/**\n * Converts between objects and array including HAL metadata.\n *\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n */\nfinal class ItemNormalizer extends AbstractItemNormalizer\n{\n    use CacheKeyTrait;\n    use ClassInfoTrait;\n    use ContextTrait;\n\n    public const FORMAT = 'jsonhal';\n\n    private $componentsCache = [];\n    private $attributesMetadataCache = [];\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsNormalization($data, $format = null, array $context = []): bool\n    {\n        return self::FORMAT === $format && parent::supportsNormalization($data, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return array|string|int|float|bool|\\ArrayObject|null\n     */\n    public function normalize($object, $format = null, array $context = [])\n    {\n        $resourceClass = $this->getObjectClass($object);\n        if ($this->getOutputClass($resourceClass, $context)) {\n            return parent::normalize($object, $format, $context);\n        }\n\n        if (!isset($context['cache_key'])) {\n            $context['cache_key'] = $this->getCacheKey($format, $context);\n        }\n\n        if ($this->resourceClassResolver->isResourceClass($resourceClass)) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass($object, $context['resource_class'] ?? null);\n        }\n\n        $context = $this->initContext($resourceClass, $context);\n        $iri = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($object) : $this->iriConverter->getIriFromResource($object, UrlGeneratorInterface::ABS_PATH, $context['operation'] ?? null, $context);\n        $context['iri'] = $iri;\n        $context['api_normalize'] = true;\n\n        $data = parent::normalize($object, $format, $context);\n        if (!\\is_array($data)) {\n            return $data;\n        }\n\n        $metadata = [\n            '_links' => [\n                'self' => [\n                    'href' => $iri,\n                ],\n            ],\n        ];\n        $components = $this->getComponents($object, $format, $context);\n        $metadata = $this->populateRelation($metadata, $object, $format, $context, $components, 'links');\n        $metadata = $this->populateRelation($metadata, $object, $format, $context, $components, 'embedded');\n\n        return $metadata + $data;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsDenormalization($data, $type, $format = null, array $context = []): bool\n    {\n        // prevent the use of lower priority normalizers (e.g. serializer.normalizer.object) for this format\n        return self::FORMAT === $format;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @throws LogicException\n     *\n     * @return mixed\n     */\n    public function denormalize($data, $class, $format = null, array $context = [])\n    {\n        throw new LogicException(sprintf('%s is a read-only format.', self::FORMAT));\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getAttributes($object, $format = null, array $context = []): array\n    {\n        return $this->getComponents($object, $format, $context)['states'];\n    }\n\n    /**\n     * Gets HAL components of the resource: states, links and embedded.\n     *\n     * @param object $object\n     */\n    private function getComponents($object, ?string $format, array $context): array\n    {\n        $cacheKey = $this->getObjectClass($object).'-'.$context['cache_key'];\n\n        if (isset($this->componentsCache[$cacheKey])) {\n            return $this->componentsCache[$cacheKey];\n        }\n\n        $attributes = parent::getAttributes($object, $format, $context);\n        $options = $this->getFactoryOptions($context);\n\n        $components = [\n            'states' => [],\n            'links' => [],\n            'embedded' => [],\n        ];\n\n        foreach ($attributes as $attribute) {\n            /** @var ApiProperty|PropertyMetadata */\n            $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $options);\n\n            // TODO: 3.0 support multiple types, default value of types will be [] instead of null\n            $type = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getType() : ($propertyMetadata->getBuiltinTypes()[0] ?? null);\n            $isOne = $isMany = false;\n\n            if (null !== $type) {\n                if ($type->isCollection()) {\n                    $valueType = method_exists(Type::class, 'getCollectionValueTypes') ? ($type->getCollectionValueTypes()[0] ?? null) : $type->getCollectionValueType();\n                    $isMany = null !== $valueType && ($className = $valueType->getClassName()) && $this->resourceClassResolver->isResourceClass($className);\n                } else {\n                    $className = $type->getClassName();\n                    $isOne = $className && $this->resourceClassResolver->isResourceClass($className);\n                }\n            }\n\n            if (!$isOne && !$isMany) {\n                $components['states'][] = $attribute;\n                continue;\n            }\n\n            $relation = ['name' => $attribute, 'cardinality' => $isOne ? 'one' : 'many'];\n            if ($propertyMetadata->isReadableLink()) {\n                $components['embedded'][] = $relation;\n            }\n\n            $components['links'][] = $relation;\n        }\n\n        if (false !== $context['cache_key']) {\n            $this->componentsCache[$cacheKey] = $components;\n        }\n\n        return $components;\n    }\n\n    /**\n     * Populates _links and _embedded keys.\n     *\n     * @param object $object\n     */\n    private function populateRelation(array $data, $object, ?string $format, array $context, array $components, string $type): array\n    {\n        $class = $this->getObjectClass($object);\n\n        $attributesMetadata = \\array_key_exists($class, $this->attributesMetadataCache) ?\n            $this->attributesMetadataCache[$class] :\n            $this->attributesMetadataCache[$class] = $this->classMetadataFactory ? $this->classMetadataFactory->getMetadataFor($class)->getAttributesMetadata() : null;\n\n        $key = '_'.$type;\n        foreach ($components[$type] as $relation) {\n            if (null !== $attributesMetadata && $this->isMaxDepthReached($attributesMetadata, $class, $relation['name'], $context)) {\n                continue;\n            }\n\n            $attributeValue = $this->getAttributeValue($object, $relation['name'], $format, $context);\n            if (empty($attributeValue)) {\n                continue;\n            }\n\n            $relationName = $relation['name'];\n            if ($this->nameConverter) {\n                $relationName = $this->nameConverter->normalize($relationName, $class, $format, $context);\n            }\n\n            if ('one' === $relation['cardinality']) {\n                if ('links' === $type) {\n                    $data[$key][$relationName]['href'] = $this->getRelationIri($attributeValue);\n                    continue;\n                }\n\n                $data[$key][$relationName] = $attributeValue;\n                continue;\n            }\n\n            // many\n            $data[$key][$relationName] = [];\n            foreach ($attributeValue as $rel) {\n                if ('links' === $type) {\n                    $rel = ['href' => $this->getRelationIri($rel)];\n                }\n\n                $data[$key][$relationName][] = $rel;\n            }\n        }\n\n        return $data;\n    }\n\n    /**\n     * Gets the IRI of the given relation.\n     *\n     * @param mixed $rel\n     *\n     * @throws UnexpectedValueException\n     */\n    private function getRelationIri($rel): string\n    {\n        if (!(\\is_array($rel) || \\is_string($rel))) {\n            throw new UnexpectedValueException('Expected relation to be an IRI or array');\n        }\n\n        return \\is_string($rel) ? $rel : $rel['_links']['self']['href'];\n    }\n\n    /**\n     * Is the max depth reached for the given attribute?\n     *\n     * @param AttributeMetadataInterface[] $attributesMetadata\n     */\n    private function isMaxDepthReached(array $attributesMetadata, string $class, string $attribute, array &$context): bool\n    {\n        if (\n            !($context[self::ENABLE_MAX_DEPTH] ?? false) ||\n            !isset($attributesMetadata[$attribute]) ||\n            null === $maxDepth = $attributesMetadata[$attribute]->getMaxDepth()\n        ) {\n            return false;\n        }\n\n        $key = sprintf(self::DEPTH_KEY_PATTERN, $class, $attribute);\n        if (!isset($context[$key])) {\n            $context[$key] = 1;\n\n            return false;\n        }\n\n        if ($context[$key] === $maxDepth) {\n            return true;\n        }\n\n        ++$context[$key];\n\n        return false;\n    }\n}\n\nclass_alias(ItemNormalizer::class, \\ApiPlatform\\Core\\Hal\\Serializer\\ItemNormalizer::class);\n", "<?php\n\n/*\n * This file is part of the API Platform project.\n *\n * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ndeclare(strict_types=1);\n\nnamespace ApiPlatform\\JsonApi\\Serializer;\n\nuse ApiPlatform\\Api\\ResourceClassResolverInterface;\nuse ApiPlatform\\Api\\UrlGeneratorInterface;\nuse ApiPlatform\\Core\\Api\\IriConverterInterface as LegacyIriConverterInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\Factory\\PropertyNameCollectionFactoryInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\PropertyMetadata;\nuse ApiPlatform\\Core\\Metadata\\Resource\\ResourceMetadata;\nuse ApiPlatform\\Exception\\ItemNotFoundException;\nuse ApiPlatform\\Metadata\\ApiProperty;\nuse ApiPlatform\\Metadata\\Resource\\ResourceMetadataCollection;\nuse ApiPlatform\\Serializer\\AbstractItemNormalizer;\nuse ApiPlatform\\Serializer\\CacheKeyTrait;\nuse ApiPlatform\\Serializer\\ContextTrait;\nuse ApiPlatform\\Symfony\\Security\\ResourceAccessCheckerInterface;\nuse ApiPlatform\\Util\\ClassInfoTrait;\nuse Symfony\\Component\\PropertyAccess\\PropertyAccessorInterface;\nuse Symfony\\Component\\PropertyInfo\\Type;\nuse Symfony\\Component\\Serializer\\Exception\\LogicException;\nuse Symfony\\Component\\Serializer\\Exception\\NotNormalizableValueException;\nuse Symfony\\Component\\Serializer\\Exception\\RuntimeException;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\nuse Symfony\\Component\\Serializer\\NameConverter\\NameConverterInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface;\n\n/**\n * Converts between objects and array.\n *\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n * @author Amrouche Hamza <hamza.simperfit@gmail.com>\n * @author Baptiste Meyer <baptiste.meyer@gmail.com>\n */\nfinal class ItemNormalizer extends AbstractItemNormalizer\n{\n    use CacheKeyTrait;\n    use ClassInfoTrait;\n    use ContextTrait;\n\n    public const FORMAT = 'jsonapi';\n\n    private $componentsCache = [];\n\n    public function __construct(PropertyNameCollectionFactoryInterface $propertyNameCollectionFactory, $propertyMetadataFactory, $iriConverter, ResourceClassResolverInterface $resourceClassResolver, ?PropertyAccessorInterface $propertyAccessor, ?NameConverterInterface $nameConverter, $resourceMetadataFactory, array $defaultContext = [], iterable $dataTransformers = [], ResourceAccessCheckerInterface $resourceAccessChecker = null)\n    {\n        parent::__construct($propertyNameCollectionFactory, $propertyMetadataFactory, $iriConverter, $resourceClassResolver, $propertyAccessor, $nameConverter, null, null, false, $defaultContext, $dataTransformers, $resourceMetadataFactory, $resourceAccessChecker);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsNormalization($data, $format = null, array $context = []): bool\n    {\n        return self::FORMAT === $format && parent::supportsNormalization($data, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return array|string|int|float|bool|\\ArrayObject|null\n     */\n    public function normalize($object, $format = null, array $context = [])\n    {\n        $resourceClass = $this->getObjectClass($object);\n        if ($this->getOutputClass($resourceClass, $context)) {\n            return parent::normalize($object, $format, $context);\n        }\n\n        if (!isset($context['cache_key'])) {\n            $context['cache_key'] = $this->getCacheKey($format, $context);\n        }\n\n        if ($isResourceClass = $this->resourceClassResolver->isResourceClass($resourceClass)) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass($object, $context['resource_class'] ?? null);\n        }\n\n        $context = $this->initContext($resourceClass, $context);\n        $iri = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($object) : $this->iriConverter->getIriFromResource($object, UrlGeneratorInterface::ABS_PATH, $context['operation'] ?? null, $context);\n        $context['iri'] = $iri;\n        $context['api_normalize'] = true;\n\n        $data = parent::normalize($object, $format, $context);\n        if (!\\is_array($data)) {\n            return $data;\n        }\n\n        // Get and populate relations\n        $allRelationshipsData = $this->getComponents($object, $format, $context)['relationships'];\n        $populatedRelationContext = $context;\n        $relationshipsData = $this->getPopulatedRelations($object, $format, $populatedRelationContext, $allRelationshipsData);\n\n        // Do not include primary resources\n        $context['api_included_resources'] = [$context['iri']];\n\n        $includedResourcesData = $this->getRelatedResources($object, $format, $context, $allRelationshipsData);\n\n        $resourceData = [\n            'id' => $context['iri'],\n            'type' => $this->getResourceShortName($resourceClass),\n        ];\n\n        if ($data) {\n            $resourceData['attributes'] = $data;\n        }\n\n        if ($relationshipsData) {\n            $resourceData['relationships'] = $relationshipsData;\n        }\n\n        $document = ['data' => $resourceData];\n\n        if ($includedResourcesData) {\n            $document['included'] = $includedResourcesData;\n        }\n\n        return $document;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsDenormalization($data, $type, $format = null, array $context = []): bool\n    {\n        return self::FORMAT === $format && parent::supportsDenormalization($data, $type, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @throws NotNormalizableValueException\n     *\n     * @return mixed\n     */\n    public function denormalize($data, $class, $format = null, array $context = [])\n    {\n        // Avoid issues with proxies if we populated the object\n        if (!isset($context[self::OBJECT_TO_POPULATE]) && isset($data['data']['id'])) {\n            if (true !== ($context['api_allow_update'] ?? true)) {\n                throw new NotNormalizableValueException('Update is not allowed for this operation.');\n            }\n\n            $context[self::OBJECT_TO_POPULATE] = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getItemFromIri(\n                $data['data']['id'],\n                $context + ['fetch_data' => false]\n            ) : $this->iriConverter->getResourceFromIri(\n                $data['data']['id'],\n                $context + ['fetch_data' => false]\n            );\n        }\n\n        // Merge attributes and relationships, into format expected by the parent normalizer\n        $dataToDenormalize = array_merge(\n            $data['data']['attributes'] ?? [],\n            $data['data']['relationships'] ?? []\n        );\n\n        return parent::denormalize(\n            $dataToDenormalize,\n            $class,\n            $format,\n            $context\n        );\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getAttributes($object, $format = null, array $context = []): array\n    {\n        return $this->getComponents($object, $format, $context)['attributes'];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function setAttributeValue($object, $attribute, $value, $format = null, array $context = []): void\n    {\n        parent::setAttributeValue($object, $attribute, \\is_array($value) && \\array_key_exists('data', $value) ? $value['data'] : $value, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @see http://jsonapi.org/format/#document-resource-object-linkage\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     *\n     * @throws RuntimeException\n     * @throws NotNormalizableValueException\n     */\n    protected function denormalizeRelation(string $attributeName, $propertyMetadata, string $className, $value, ?string $format, array $context)\n    {\n        if (!\\is_array($value) || !isset($value['id'], $value['type'])) {\n            throw new NotNormalizableValueException('Only resource linkage supported currently, see: http://jsonapi.org/format/#document-resource-object-linkage.');\n        }\n\n        try {\n            return $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getItemFromIri($value['id'], $context + ['fetch_data' => true]) : $this->iriConverter->getResourceFromIri($value['id'], $context + ['fetch_data' => true]);\n        } catch (ItemNotFoundException $e) {\n            throw new RuntimeException($e->getMessage(), $e->getCode(), $e);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     *\n     * @see http://jsonapi.org/format/#document-resource-object-linkage\n     */\n    protected function normalizeRelation($propertyMetadata, $relatedObject, string $resourceClass, ?string $format, array $context)\n    {\n        if (null !== $relatedObject) {\n            $iri = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($relatedObject) : $this->iriConverter->getIriFromResource($relatedObject);\n            $context['iri'] = $iri;\n\n            if (isset($context['resources'])) {\n                $context['resources'][$iri] = $iri;\n            }\n        }\n\n        if (null === $relatedObject || isset($context['api_included'])) {\n            if (!$this->serializer instanceof NormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', NormalizerInterface::class));\n            }\n\n            $normalizedRelatedObject = $this->serializer->normalize($relatedObject, $format, $context);\n            // @phpstan-ignore-next-line throwing an explicit exception helps debugging\n            if (!\\is_string($normalizedRelatedObject) && !\\is_array($normalizedRelatedObject) && !$normalizedRelatedObject instanceof \\ArrayObject && null !== $normalizedRelatedObject) {\n                throw new UnexpectedValueException('Expected normalized relation to be an IRI, array, \\ArrayObject or null');\n            }\n\n            return $normalizedRelatedObject;\n        }\n\n        return [\n            'data' => [\n                'type' => $this->getResourceShortName($resourceClass),\n                'id' => $iri,\n            ],\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function isAllowedAttribute($classOrObject, $attribute, $format = null, array $context = []): bool\n    {\n        return preg_match('/^\\\\w[-\\\\w_]*$/', $attribute) && parent::isAllowedAttribute($classOrObject, $attribute, $format, $context);\n    }\n\n    /**\n     * Gets JSON API components of the resource: attributes, relationships, meta and links.\n     *\n     * @param object $object\n     */\n    private function getComponents($object, ?string $format, array $context): array\n    {\n        $cacheKey = $this->getObjectClass($object).'-'.$context['cache_key'];\n\n        if (isset($this->componentsCache[$cacheKey])) {\n            return $this->componentsCache[$cacheKey];\n        }\n\n        $attributes = parent::getAttributes($object, $format, $context);\n\n        $options = $this->getFactoryOptions($context);\n\n        $components = [\n            'links' => [],\n            'relationships' => [],\n            'attributes' => [],\n            'meta' => [],\n        ];\n\n        foreach ($attributes as $attribute) {\n            /** @var ApiProperty|PropertyMetadata */\n            $propertyMetadata = $this\n                ->propertyMetadataFactory\n                ->create($context['resource_class'], $attribute, $options);\n\n            // TODO: 3.0 support multiple types, default value of types will be [] instead of null\n            $type = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getType() : ($propertyMetadata->getBuiltinTypes()[0] ?? null);\n            $isOne = $isMany = false;\n\n            if (null !== $type) {\n                if ($type->isCollection()) {\n                    $collectionValueType = method_exists(Type::class, 'getCollectionValueTypes') ? ($type->getCollectionValueTypes()[0] ?? null) : $type->getCollectionValueType();\n                    $isMany = ($collectionValueType && $className = $collectionValueType->getClassName()) ? $this->resourceClassResolver->isResourceClass($className) : false;\n                } else {\n                    $isOne = ($className = $type->getClassName()) ? $this->resourceClassResolver->isResourceClass($className) : false;\n                }\n            }\n\n            if (!isset($className) || !$isOne && !$isMany) {\n                $components['attributes'][] = $attribute;\n\n                continue;\n            }\n\n            $relation = [\n                'name' => $attribute,\n                'type' => $this->getResourceShortName($className),\n                'cardinality' => $isOne ? 'one' : 'many',\n            ];\n\n            $components['relationships'][] = $relation;\n        }\n\n        if (false !== $context['cache_key']) {\n            $this->componentsCache[$cacheKey] = $components;\n        }\n\n        return $components;\n    }\n\n    /**\n     * Populates relationships keys.\n     *\n     * @param object $object\n     *\n     * @throws UnexpectedValueException\n     */\n    private function getPopulatedRelations($object, ?string $format, array $context, array $relationships): array\n    {\n        $data = [];\n\n        if (!isset($context['resource_class'])) {\n            return $data;\n        }\n\n        unset($context['api_included']);\n        foreach ($relationships as $relationshipDataArray) {\n            $relationshipName = $relationshipDataArray['name'];\n\n            $attributeValue = $this->getAttributeValue($object, $relationshipName, $format, $context);\n\n            if ($this->nameConverter) {\n                $relationshipName = $this->nameConverter->normalize($relationshipName, $context['resource_class'], self::FORMAT, $context);\n            }\n\n            if (!$attributeValue) {\n                continue;\n            }\n\n            $data[$relationshipName] = [\n                'data' => [],\n            ];\n\n            // Many to one relationship\n            if ('one' === $relationshipDataArray['cardinality']) {\n                unset($attributeValue['data']['attributes']);\n                $data[$relationshipName] = $attributeValue;\n\n                continue;\n            }\n\n            // Many to many relationship\n            foreach ($attributeValue as $attributeValueElement) {\n                if (!isset($attributeValueElement['data'])) {\n                    throw new UnexpectedValueException(sprintf('The JSON API attribute \\'%s\\' must contain a \"data\" key.', $relationshipName));\n                }\n                unset($attributeValueElement['data']['attributes']);\n                $data[$relationshipName]['data'][] = $attributeValueElement['data'];\n            }\n        }\n\n        return $data;\n    }\n\n    /**\n     * Populates included keys.\n     *\n     * @param mixed $object\n     */\n    private function getRelatedResources($object, ?string $format, array $context, array $relationships): array\n    {\n        if (!isset($context['api_included'])) {\n            return [];\n        }\n\n        $included = [];\n        foreach ($relationships as $relationshipDataArray) {\n            $relationshipName = $relationshipDataArray['name'];\n\n            if (!$this->shouldIncludeRelation($relationshipName, $context)) {\n                continue;\n            }\n\n            $relationContext = $context;\n            $relationContext['api_included'] = $this->getIncludedNestedResources($relationshipName, $context);\n\n            $attributeValue = $this->getAttributeValue($object, $relationshipName, $format, $relationContext);\n\n            if (!$attributeValue) {\n                continue;\n            }\n\n            // Many to many relationship\n            $attributeValues = $attributeValue;\n            // Many to one relationship\n            if ('one' === $relationshipDataArray['cardinality']) {\n                $attributeValues = [$attributeValue];\n            }\n\n            foreach ($attributeValues as $attributeValueElement) {\n                if (isset($attributeValueElement['data'])) {\n                    $this->addIncluded($attributeValueElement['data'], $included, $context);\n                    if (isset($attributeValueElement['included']) && \\is_array($attributeValueElement['included'])) {\n                        foreach ($attributeValueElement['included'] as $include) {\n                            $this->addIncluded($include, $included, $context);\n                        }\n                    }\n                }\n            }\n        }\n\n        return $included;\n    }\n\n    /**\n     * Add data to included array if it's not already included.\n     */\n    private function addIncluded(array $data, array &$included, array &$context): void\n    {\n        if (isset($data['id']) && !\\in_array($data['id'], $context['api_included_resources'], true)) {\n            $included[] = $data;\n            // Track already included resources\n            $context['api_included_resources'][] = $data['id'];\n        }\n    }\n\n    /**\n     * Figures out if the relationship is in the api_included hash or has included nested resources (path).\n     */\n    private function shouldIncludeRelation(string $relationshipName, array $context): bool\n    {\n        $normalizedName = $this->nameConverter ? $this->nameConverter->normalize($relationshipName, $context['resource_class'], self::FORMAT, $context) : $relationshipName;\n\n        return \\in_array($normalizedName, $context['api_included'], true) || \\count($this->getIncludedNestedResources($relationshipName, $context)) > 0;\n    }\n\n    /**\n     * Returns the names of the nested resources from a path relationship.\n     */\n    private function getIncludedNestedResources(string $relationshipName, array $context): array\n    {\n        $normalizedName = $this->nameConverter ? $this->nameConverter->normalize($relationshipName, $context['resource_class'], self::FORMAT, $context) : $relationshipName;\n\n        $filtered = array_filter($context['api_included'] ?? [], static function (string $included) use ($normalizedName) {\n            return 0 === strpos($included, $normalizedName.'.');\n        });\n\n        return array_map(static function (string $nested) {\n            return substr($nested, strpos($nested, '.') + 1);\n        }, $filtered);\n    }\n\n    // TODO: 3.0 remove\n    private function getResourceShortName(string $resourceClass): string\n    {\n        /** @var ResourceMetadata|ResourceMetadataCollection */\n        $resourceMetadata = $this->resourceMetadataFactory->create($resourceClass);\n\n        if ($resourceMetadata instanceof ResourceMetadata) {\n            return $resourceMetadata->getShortName();\n        }\n\n        return $resourceMetadata->getOperation()->getShortName();\n    }\n}\n\nclass_alias(ItemNormalizer::class, \\ApiPlatform\\Core\\JsonApi\\Serializer\\ItemNormalizer::class);\n", "<?php\n\n/*\n * This file is part of the API Platform project.\n *\n * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ndeclare(strict_types=1);\n\nnamespace ApiPlatform\\Serializer;\n\nuse ApiPlatform\\Api\\IriConverterInterface;\nuse ApiPlatform\\Api\\UrlGeneratorInterface;\nuse ApiPlatform\\Core\\Api\\IriConverterInterface as LegacyIriConverterInterface;\nuse ApiPlatform\\Core\\Bridge\\Symfony\\Messenger\\DataTransformer as MessengerDataTransformer;\nuse ApiPlatform\\Core\\DataProvider\\ItemDataProviderInterface;\nuse ApiPlatform\\Core\\DataTransformer\\DataTransformerInitializerInterface;\nuse ApiPlatform\\Core\\DataTransformer\\DataTransformerInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\Factory\\PropertyMetadataFactoryInterface as LegacyPropertyMetadataFactoryInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\PropertyMetadata;\nuse ApiPlatform\\Core\\Metadata\\Resource\\Factory\\ResourceMetadataFactoryInterface;\nuse ApiPlatform\\Exception\\InvalidArgumentException;\nuse ApiPlatform\\Exception\\InvalidValueException;\nuse ApiPlatform\\Exception\\ItemNotFoundException;\nuse ApiPlatform\\Metadata\\ApiProperty;\nuse ApiPlatform\\Metadata\\Property\\Factory\\PropertyMetadataFactoryInterface;\nuse ApiPlatform\\Metadata\\Property\\Factory\\PropertyNameCollectionFactoryInterface;\nuse ApiPlatform\\Metadata\\Resource\\Factory\\ResourceMetadataCollectionFactoryInterface;\nuse ApiPlatform\\Symfony\\Security\\ResourceAccessCheckerInterface;\nuse ApiPlatform\\Util\\ClassInfoTrait;\nuse Symfony\\Component\\PropertyAccess\\Exception\\NoSuchPropertyException;\nuse Symfony\\Component\\PropertyAccess\\PropertyAccess;\nuse Symfony\\Component\\PropertyAccess\\PropertyAccessorInterface;\nuse Symfony\\Component\\PropertyInfo\\Type;\nuse Symfony\\Component\\Serializer\\Encoder\\CsvEncoder;\nuse Symfony\\Component\\Serializer\\Encoder\\XmlEncoder;\nuse Symfony\\Component\\Serializer\\Exception\\LogicException;\nuse Symfony\\Component\\Serializer\\Exception\\MissingConstructorArgumentsException;\nuse Symfony\\Component\\Serializer\\Exception\\NotNormalizableValueException;\nuse Symfony\\Component\\Serializer\\Exception\\RuntimeException;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\nuse Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactoryInterface;\nuse Symfony\\Component\\Serializer\\NameConverter\\AdvancedNameConverterInterface;\nuse Symfony\\Component\\Serializer\\NameConverter\\NameConverterInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface;\n\n/**\n * Base item normalizer.\n *\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n */\nabstract class AbstractItemNormalizer extends AbstractObjectNormalizer\n{\n    use ClassInfoTrait;\n    use ContextTrait;\n    use InputOutputMetadataTrait;\n\n    public const IS_TRANSFORMED_TO_SAME_CLASS = 'is_transformed_to_same_class';\n\n    /**\n     * @var PropertyNameCollectionFactoryInterface\n     */\n    protected $propertyNameCollectionFactory;\n    /**\n     * @var LegacyPropertyMetadataFactoryInterface|PropertyMetadataFactoryInterface\n     */\n    protected $propertyMetadataFactory;\n    protected $resourceMetadataFactory;\n    /**\n     * @var LegacyIriConverterInterface|IriConverterInterface\n     */\n    protected $iriConverter;\n    protected $resourceClassResolver;\n    protected $resourceAccessChecker;\n    protected $propertyAccessor;\n    protected $itemDataProvider;\n    protected $allowPlainIdentifiers;\n    protected $dataTransformers = [];\n    protected $localCache = [];\n\n    public function __construct(PropertyNameCollectionFactoryInterface $propertyNameCollectionFactory, $propertyMetadataFactory, $iriConverter, $resourceClassResolver, PropertyAccessorInterface $propertyAccessor = null, NameConverterInterface $nameConverter = null, ClassMetadataFactoryInterface $classMetadataFactory = null, ItemDataProviderInterface $itemDataProvider = null, bool $allowPlainIdentifiers = false, array $defaultContext = [], iterable $dataTransformers = [], $resourceMetadataFactory = null, ResourceAccessCheckerInterface $resourceAccessChecker = null)\n    {\n        if (!isset($defaultContext['circular_reference_handler'])) {\n            $defaultContext['circular_reference_handler'] = function ($object) {\n                return $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($object) : $this->iriConverter->getIriFromResource($object);\n            };\n        }\n        if (!interface_exists(AdvancedNameConverterInterface::class) && method_exists($this, 'setCircularReferenceHandler')) {\n            $this->setCircularReferenceHandler($defaultContext['circular_reference_handler']);\n        }\n\n        parent::__construct($classMetadataFactory, $nameConverter, null, null, \\Closure::fromCallable([$this, 'getObjectClass']), $defaultContext);\n\n        $this->propertyNameCollectionFactory = $propertyNameCollectionFactory;\n        $this->propertyMetadataFactory = $propertyMetadataFactory;\n\n        if ($iriConverter instanceof LegacyIriConverterInterface) {\n            trigger_deprecation('api-platform/core', '2.7', sprintf('Use an implementation of \"%s\" instead of \"%s\".', IriConverterInterface::class, LegacyIriConverterInterface::class));\n        }\n\n        $this->iriConverter = $iriConverter;\n        $this->resourceClassResolver = $resourceClassResolver;\n        $this->propertyAccessor = $propertyAccessor ?: PropertyAccess::createPropertyAccessor();\n        $this->itemDataProvider = $itemDataProvider;\n\n        if (true === $allowPlainIdentifiers) {\n            @trigger_error(sprintf('Allowing plain identifiers as argument of \"%s\" is deprecated since API Platform 2.7 and will not be possible anymore in API Platform 3.', self::class), \\E_USER_DEPRECATED);\n        }\n        $this->allowPlainIdentifiers = $allowPlainIdentifiers;\n\n        $this->dataTransformers = $dataTransformers;\n\n        // Just skip our data transformer to trigger a proper deprecation\n        $customDataTransformers = array_filter(\\is_array($dataTransformers) ? $dataTransformers : iterator_to_array($dataTransformers), function ($dataTransformer) {\n            return !$dataTransformer instanceof MessengerDataTransformer;\n        });\n\n        if (\\count($customDataTransformers)) {\n            trigger_deprecation('api-platform/core', '2.7', 'The DataTransformer pattern is deprecated, use a Provider or a Processor and either use your input or return a new output there.');\n        }\n\n        if ($resourceMetadataFactory && !$resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n            trigger_deprecation('api-platform/core', '2.7', sprintf('Use \"%s\" instead of \"%s\".', ResourceMetadataCollectionFactoryInterface::class, ResourceMetadataFactoryInterface::class));\n        }\n\n        $this->resourceMetadataFactory = $resourceMetadataFactory;\n        $this->resourceAccessChecker = $resourceAccessChecker;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsNormalization($data, $format = null, array $context = []): bool\n    {\n        if (!\\is_object($data) || is_iterable($data)) {\n            return false;\n        }\n\n        $class = $this->getObjectClass($data);\n        if (($context['output']['class'] ?? null) === $class) {\n            return true;\n        }\n\n        return $this->resourceClassResolver->isResourceClass($class);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function hasCacheableSupportsMethod(): bool\n    {\n        return true;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @throws LogicException\n     *\n     * @return array|string|int|float|bool|\\ArrayObject|null\n     */\n    public function normalize($object, $format = null, array $context = [])\n    {\n        $resourceClass = $this->getObjectClass($object);\n        if (!($isTransformed = isset($context[self::IS_TRANSFORMED_TO_SAME_CLASS])) && $outputClass = $this->getOutputClass($resourceClass, $context)) {\n            if (!$this->serializer instanceof NormalizerInterface) {\n                throw new LogicException('Cannot normalize the output because the injected serializer is not a normalizer');\n            }\n\n            // Data transformers are deprecated, this is removed from 3.0\n            if ($dataTransformer = $this->getDataTransformer($object, $outputClass, $context)) {\n                $transformed = $dataTransformer->transform($object, $outputClass, $context);\n\n                if ($object === $transformed) {\n                    $context[self::IS_TRANSFORMED_TO_SAME_CLASS] = true;\n                } else {\n                    $context['api_normalize'] = true;\n                    $context['api_resource'] = $object;\n                    unset($context['output'], $context['resource_class']);\n                }\n\n                return $this->serializer->normalize($transformed, $format, $context);\n            }\n\n            unset($context['output'], $context['operation_name']);\n            if ($this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface && !isset($context['operation'])) {\n                $context['operation'] = $this->resourceMetadataFactory->create($context['resource_class'])->getOperation();\n            }\n            $context['resource_class'] = $outputClass;\n            $context['api_sub_level'] = true;\n            $context[self::ALLOW_EXTRA_ATTRIBUTES] = false;\n\n            return $this->serializer->normalize($object, $format, $context);\n        }\n\n        if ($isTransformed) {\n            unset($context[self::IS_TRANSFORMED_TO_SAME_CLASS]);\n        }\n\n        if ($isResourceClass = $this->resourceClassResolver->isResourceClass($resourceClass)) {\n            $context = $this->initContext($resourceClass, $context);\n        }\n\n        $iri = null;\n        if (isset($context['iri'])) {\n            $iri = $context['iri'];\n        } elseif ($this->iriConverter instanceof LegacyIriConverterInterface && $isResourceClass) {\n            $iri = $this->iriConverter->getIriFromItem($object);\n        } elseif ($this->iriConverter instanceof IriConverterInterface) {\n            $iri = $this->iriConverter->getIriFromResource($object, UrlGeneratorInterface::ABS_URL, $context['operation'] ?? null, $context);\n        }\n\n        $context['iri'] = $iri;\n        $context['api_normalize'] = true;\n\n        /*\n         * When true, converts the normalized data array of a resource into an\n         * IRI, if the normalized data array is empty.\n         *\n         * This is useful when traversing from a non-resource towards an attribute\n         * which is a resource, as we do not have the benefit of {@see PropertyMetadata::isReadableLink}.\n         *\n         * It must not be propagated to subresources, as {@see PropertyMetadata::isReadableLink}\n         * should take effect.\n         */\n        $emptyResourceAsIri = $context['api_empty_resource_as_iri'] ?? false;\n        unset($context['api_empty_resource_as_iri']);\n\n        if (isset($context['resources'])) {\n            $context['resources'][$iri] = $iri;\n        }\n\n        $data = parent::normalize($object, $format, $context);\n        if ($emptyResourceAsIri && \\is_array($data) && 0 === \\count($data)) {\n            return $iri;\n        }\n\n        return $data;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return bool\n     */\n    public function supportsDenormalization($data, $type, $format = null, array $context = [])\n    {\n        if (($context['input']['class'] ?? null) === $type) {\n            return true;\n        }\n\n        return $this->localCache[$type] ?? $this->localCache[$type] = $this->resourceClassResolver->isResourceClass($type);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return mixed\n     */\n    public function denormalize($data, $class, $format = null, array $context = [])\n    {\n        $resourceClass = $class;\n\n        if (null !== $inputClass = $this->getInputClass($resourceClass, $context)) {\n            if (null !== $dataTransformer = $this->getDataTransformer($data, $resourceClass, $context)) {\n                $dataTransformerContext = $context;\n\n                unset($context['input']);\n                unset($context['resource_class']);\n\n                if (!$this->serializer instanceof DenormalizerInterface) {\n                    throw new LogicException('Cannot denormalize the input because the injected serializer is not a denormalizer');\n                }\n\n                if ($dataTransformer instanceof DataTransformerInitializerInterface) {\n                    $context[AbstractObjectNormalizer::OBJECT_TO_POPULATE] = $dataTransformer->initialize($inputClass, $context);\n                    $context[AbstractObjectNormalizer::DEEP_OBJECT_TO_POPULATE] = true;\n                }\n\n                try {\n                    $denormalizedInput = $this->serializer->denormalize($data, $inputClass, $format, $context);\n                } catch (NotNormalizableValueException $e) {\n                    throw new UnexpectedValueException('The input data is misformatted.', $e->getCode(), $e);\n                }\n\n                if (!\\is_object($denormalizedInput)) {\n                    throw new UnexpectedValueException('Expected denormalized input to be an object.');\n                }\n\n                return $dataTransformer->transform($denormalizedInput, $resourceClass, $dataTransformerContext);\n            }\n\n            unset($context['input']);\n            unset($context['operation']);\n            unset($context['operation_name']);\n            $context['resource_class'] = $inputClass;\n\n            if (!$this->serializer instanceof DenormalizerInterface) {\n                throw new LogicException('Cannot denormalize the input because the injected serializer is not a denormalizer');\n            }\n\n            try {\n                return $this->serializer->denormalize($data, $inputClass, $format, $context);\n            } catch (NotNormalizableValueException $e) {\n                throw new UnexpectedValueException('The input data is misformatted.', $e->getCode(), $e);\n            }\n        }\n\n        if (null === $objectToPopulate = $this->extractObjectToPopulate($class, $context, static::OBJECT_TO_POPULATE)) {\n            $normalizedData = \\is_scalar($data) ? [$data] : $this->prepareForDenormalization($data);\n            $class = $this->getClassDiscriminatorResolvedClass($normalizedData, $class);\n        }\n\n        $context['api_denormalize'] = true;\n\n        if ($this->resourceClassResolver->isResourceClass($class)) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass($objectToPopulate, $class);\n            $context['resource_class'] = $resourceClass;\n        }\n\n        $supportsPlainIdentifiers = $this->supportsPlainIdentifiers();\n\n        if (\\is_string($data)) {\n            try {\n                return $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getItemFromIri($data, $context + ['fetch_data' => true]) : $this->iriConverter->getResourceFromIri($data, $context + ['fetch_data' => true]);\n            } catch (ItemNotFoundException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw new UnexpectedValueException($e->getMessage(), $e->getCode(), $e);\n                }\n            } catch (InvalidArgumentException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw new UnexpectedValueException(sprintf('Invalid IRI \"%s\".', $data), $e->getCode(), $e);\n                }\n            }\n        }\n\n        if (!\\is_array($data)) {\n            if (!$supportsPlainIdentifiers) {\n                throw new UnexpectedValueException(sprintf('Expected IRI or document for resource \"%s\", \"%s\" given.', $resourceClass, \\gettype($data)));\n            }\n\n            $item = $this->itemDataProvider->getItem($resourceClass, $data, null, $context + ['fetch_data' => true]);\n            if (null === $item) {\n                throw new ItemNotFoundException(sprintf('Item not found for resource \"%s\" with id \"%s\".', $resourceClass, $data));\n            }\n\n            return $item;\n        }\n\n        $previousObject = null !== $objectToPopulate ? clone $objectToPopulate : null;\n        $object = parent::denormalize($data, $resourceClass, $format, $context);\n\n        if (!$this->resourceClassResolver->isResourceClass($context['resource_class'])) {\n            return $object;\n        }\n\n        // Revert attributes that aren't allowed to be changed after a post-denormalize check\n        foreach (array_keys($data) as $attribute) {\n            if (!$this->canAccessAttributePostDenormalize($object, $previousObject, $attribute, $context)) {\n                if (null !== $previousObject) {\n                    $this->setValue($object, $attribute, $this->propertyAccessor->getValue($previousObject, $attribute));\n                } else {\n                    $propertyMetadata = $this->propertyMetadataFactory->create($resourceClass, $attribute, $this->getFactoryOptions($context));\n                    $this->setValue($object, $attribute, $propertyMetadata->getDefault());\n                }\n            }\n        }\n\n        return $object;\n    }\n\n    /**\n     * Method copy-pasted from symfony/serializer.\n     * Remove it after symfony/serializer version update @see https://github.com/symfony/symfony/pull/28263.\n     *\n     * {@inheritdoc}\n     *\n     * @internal\n     *\n     * @return object\n     */\n    protected function instantiateObject(array &$data, $class, array &$context, \\ReflectionClass $reflectionClass, $allowedAttributes, string $format = null)\n    {\n        if (null !== $object = $this->extractObjectToPopulate($class, $context, static::OBJECT_TO_POPULATE)) {\n            unset($context[static::OBJECT_TO_POPULATE]);\n\n            return $object;\n        }\n\n        $class = $this->getClassDiscriminatorResolvedClass($data, $class);\n        $reflectionClass = new \\ReflectionClass($class);\n\n        $constructor = $this->getConstructor($data, $class, $context, $reflectionClass, $allowedAttributes);\n        if ($constructor) {\n            $constructorParameters = $constructor->getParameters();\n\n            $params = [];\n            foreach ($constructorParameters as $constructorParameter) {\n                $paramName = $constructorParameter->name;\n                $key = $this->nameConverter ? $this->nameConverter->normalize($paramName, $class, $format, $context) : $paramName;\n\n                $allowed = false === $allowedAttributes || (\\is_array($allowedAttributes) && \\in_array($paramName, $allowedAttributes, true));\n                $ignored = !$this->isAllowedAttribute($class, $paramName, $format, $context);\n                if ($constructorParameter->isVariadic()) {\n                    if ($allowed && !$ignored && (isset($data[$key]) || \\array_key_exists($key, $data))) {\n                        if (!\\is_array($data[$paramName])) {\n                            throw new RuntimeException(sprintf('Cannot create an instance of %s from serialized data because the variadic parameter %s can only accept an array.', $class, $constructorParameter->name));\n                        }\n\n                        $params = array_merge($params, $data[$paramName]);\n                    }\n                } elseif ($allowed && !$ignored && (isset($data[$key]) || \\array_key_exists($key, $data))) {\n                    $params[] = $this->createConstructorArgument($data[$key], $key, $constructorParameter, $context, $format);\n\n                    // Don't run set for a parameter passed to the constructor\n                    unset($data[$key]);\n                } elseif (isset($context[static::DEFAULT_CONSTRUCTOR_ARGUMENTS][$class][$key])) {\n                    $params[] = $context[static::DEFAULT_CONSTRUCTOR_ARGUMENTS][$class][$key];\n                } elseif ($constructorParameter->isDefaultValueAvailable()) {\n                    $params[] = $constructorParameter->getDefaultValue();\n                } else {\n                    throw new MissingConstructorArgumentsException(sprintf('Cannot create an instance of %s from serialized data because its constructor requires parameter \"%s\" to be present.', $class, $constructorParameter->name));\n                }\n            }\n\n            if ($constructor->isConstructor()) {\n                return $reflectionClass->newInstanceArgs($params);\n            }\n\n            return $constructor->invokeArgs(null, $params);\n        }\n\n        return new $class();\n    }\n\n    protected function getClassDiscriminatorResolvedClass(array &$data, string $class): string\n    {\n        if (null === $this->classDiscriminatorResolver || (null === $mapping = $this->classDiscriminatorResolver->getMappingForClass($class))) {\n            return $class;\n        }\n\n        if (!isset($data[$mapping->getTypeProperty()])) {\n            throw new RuntimeException(sprintf('Type property \"%s\" not found for the abstract object \"%s\"', $mapping->getTypeProperty(), $class));\n        }\n\n        $type = $data[$mapping->getTypeProperty()];\n        if (null === ($mappedClass = $mapping->getClassForType($type))) {\n            throw new RuntimeException(sprintf('The type \"%s\" has no mapped class for the abstract object \"%s\"', $type, $class));\n        }\n\n        return $mappedClass;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function createConstructorArgument($parameterData, string $key, \\ReflectionParameter $constructorParameter, array &$context, string $format = null)\n    {\n        return $this->createAttributeValue($constructorParameter->name, $parameterData, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * Unused in this context.\n     *\n     * @return string[]\n     */\n    protected function extractAttributes($object, $format = null, array $context = [])\n    {\n        return [];\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return array|bool\n     */\n    protected function getAllowedAttributes($classOrObject, array $context, $attributesAsString = false)\n    {\n        if (!$this->resourceClassResolver->isResourceClass($context['resource_class'])) {\n            return parent::getAllowedAttributes($classOrObject, $context, $attributesAsString);\n        }\n\n        $resourceClass = $this->resourceClassResolver->getResourceClass(null, $context['resource_class']); // fix for abstract classes and interfaces\n        $options = $this->getFactoryOptions($context);\n        $propertyNames = $this->propertyNameCollectionFactory->create($resourceClass, $options);\n\n        $allowedAttributes = [];\n        foreach ($propertyNames as $propertyName) {\n            $propertyMetadata = $this->propertyMetadataFactory->create($resourceClass, $propertyName, $options);\n\n            if (\n                $this->isAllowedAttribute($classOrObject, $propertyName, null, $context) &&\n                (\n                    isset($context['api_normalize']) && $propertyMetadata->isReadable() ||\n                    isset($context['api_denormalize']) && ($propertyMetadata->isWritable() || !\\is_object($classOrObject) && $propertyMetadata->isInitializable())\n                )\n            ) {\n                $allowedAttributes[] = $propertyName;\n            }\n        }\n\n        return $allowedAttributes;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return bool\n     */\n    protected function isAllowedAttribute($classOrObject, $attribute, $format = null, array $context = [])\n    {\n        if (!parent::isAllowedAttribute($classOrObject, $attribute, $format, $context)) {\n            return false;\n        }\n\n        return $this->canAccessAttribute(\\is_object($classOrObject) ? $classOrObject : null, $attribute, $context);\n    }\n\n    /**\n     * Check if access to the attribute is granted.\n     *\n     * @param object $object\n     */\n    protected function canAccessAttribute($object, string $attribute, array $context = []): bool\n    {\n        if (!$this->resourceClassResolver->isResourceClass($context['resource_class'])) {\n            return true;\n        }\n\n        $options = $this->getFactoryOptions($context);\n        /** @var PropertyMetadata|ApiProperty */\n        $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $options);\n        $security = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getAttribute('security') : $propertyMetadata->getSecurity();\n        if ($this->resourceAccessChecker && $security) {\n            return $this->resourceAccessChecker->isGranted($context['resource_class'], $security, [\n                'object' => $object,\n            ]);\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if access to the attribute is granted.\n     *\n     * @param object      $object\n     * @param object|null $previousObject\n     */\n    protected function canAccessAttributePostDenormalize($object, $previousObject, string $attribute, array $context = []): bool\n    {\n        $options = $this->getFactoryOptions($context);\n        /** @var PropertyMetadata|ApiProperty */\n        $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $options);\n        $security = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getAttribute('security_post_denormalize') : $propertyMetadata->getSecurityPostDenormalize();\n        if ($this->resourceAccessChecker && $security) {\n            return $this->resourceAccessChecker->isGranted($context['resource_class'], $security, [\n                'object' => $object,\n                'previous_object' => $previousObject,\n            ]);\n        }\n\n        return true;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function setAttributeValue($object, $attribute, $value, $format = null, array $context = [])\n    {\n        $this->setValue($object, $attribute, $this->createAttributeValue($attribute, $value, $format, $context));\n    }\n\n    /**\n     * Validates the type of the value. Allows using integers as floats for JSON formats.\n     *\n     * @param mixed $value\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function validateType(string $attribute, Type $type, $value, string $format = null)\n    {\n        $builtinType = $type->getBuiltinType();\n        if (Type::BUILTIN_TYPE_FLOAT === $builtinType && null !== $format && false !== strpos($format, 'json')) {\n            $isValid = \\is_float($value) || \\is_int($value);\n        } else {\n            $isValid = \\call_user_func('is_'.$builtinType, $value);\n        }\n\n        if (!$isValid) {\n            throw new UnexpectedValueException(sprintf('The type of the \"%s\" attribute must be \"%s\", \"%s\" given.', $attribute, $builtinType, \\gettype($value)));\n        }\n    }\n\n    /**\n     * Denormalizes a collection of objects.\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     * @param mixed                        $value\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function denormalizeCollection(string $attribute, $propertyMetadata, Type $type, string $className, $value, ?string $format, array $context): array\n    {\n        if (!\\is_array($value)) {\n            throw new InvalidArgumentException(sprintf('The type of the \"%s\" attribute must be \"array\", \"%s\" given.', $attribute, \\gettype($value)));\n        }\n\n        $collectionKeyType = method_exists(Type::class, 'getCollectionKeyTypes') ? ($type->getCollectionKeyTypes()[0] ?? null) : $type->getCollectionKeyType();\n        $collectionKeyBuiltinType = null === $collectionKeyType ? null : $collectionKeyType->getBuiltinType();\n\n        $values = [];\n        foreach ($value as $index => $obj) {\n            if (null !== $collectionKeyBuiltinType && !\\call_user_func('is_'.$collectionKeyBuiltinType, $index)) {\n                throw new InvalidArgumentException(sprintf('The type of the key \"%s\" must be \"%s\", \"%s\" given.', $index, $collectionKeyBuiltinType, \\gettype($index)));\n            }\n\n            $values[$index] = $this->denormalizeRelation($attribute, $propertyMetadata, $className, $obj, $format, $this->createChildContext($context, $attribute, $format));\n        }\n\n        return $values;\n    }\n\n    /**\n     * Denormalizes a relation.\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     * @param mixed                        $value\n     *\n     * @throws LogicException\n     * @throws UnexpectedValueException\n     * @throws ItemNotFoundException\n     *\n     * @return object|null\n     */\n    protected function denormalizeRelation(string $attributeName, $propertyMetadata, string $className, $value, ?string $format, array $context)\n    {\n        $supportsPlainIdentifiers = $this->supportsPlainIdentifiers();\n\n        if (\\is_string($value)) {\n            try {\n                return $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getItemFromIri($value, $context + ['fetch_data' => true]) : $this->iriConverter->getResourceFromIri($value, $context + ['fetch_data' => true]);\n            } catch (ItemNotFoundException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw new UnexpectedValueException($e->getMessage(), $e->getCode(), $e);\n                }\n            } catch (InvalidArgumentException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw new UnexpectedValueException(sprintf('Invalid IRI \"%s\".', $value), $e->getCode(), $e);\n                }\n            }\n        }\n\n        if ($propertyMetadata->isWritableLink()) {\n            $context['api_allow_update'] = true;\n\n            if (!$this->serializer instanceof DenormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', DenormalizerInterface::class));\n            }\n\n            try {\n                $item = $this->serializer->denormalize($value, $className, $format, $context);\n                if (!\\is_object($item) && null !== $item) {\n                    throw new \\UnexpectedValueException('Expected item to be an object or null.');\n                }\n\n                return $item;\n            } catch (InvalidValueException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw $e;\n                }\n            }\n        }\n\n        if (!\\is_array($value)) {\n            if (!$supportsPlainIdentifiers) {\n                throw new UnexpectedValueException(sprintf('Expected IRI or nested document for attribute \"%s\", \"%s\" given.', $attributeName, \\gettype($value)));\n            }\n\n            $item = $this->itemDataProvider->getItem($className, $value, null, $context + ['fetch_data' => true]);\n            if (null === $item) {\n                throw new ItemNotFoundException(sprintf('Item not found for resource \"%s\" with id \"%s\".', $className, $value));\n            }\n\n            return $item;\n        }\n\n        throw new UnexpectedValueException(sprintf('Nested documents for attribute \"%s\" are not allowed. Use IRIs instead.', $attributeName));\n    }\n\n    /**\n     * Gets the options for the property name collection / property metadata factories.\n     */\n    protected function getFactoryOptions(array $context): array\n    {\n        $options = [];\n\n        if (isset($context[self::GROUPS])) {\n            /* @see https://github.com/symfony/symfony/blob/v4.2.6/src/Symfony/Component/PropertyInfo/Extractor/SerializerExtractor.php */\n            $options['serializer_groups'] = (array) $context[self::GROUPS];\n        }\n\n        if (isset($context['resource_class']) && $this->resourceClassResolver->isResourceClass($context['resource_class']) && $this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass(null, $context['resource_class']); // fix for abstract classes and interfaces\n            // This is a hot spot, we should avoid calling this here but in many cases we can't\n            $operation = $context['root_operation'] ?? $context['operation'] ?? $this->resourceMetadataFactory->create($resourceClass)->getOperation($context['root_operation_name'] ?? $context['operation_name'] ?? null);\n            $options['normalization_groups'] = $operation->getNormalizationContext()['groups'] ?? null;\n            $options['denormalization_groups'] = $operation->getDenormalizationContext()['groups'] ?? null;\n        }\n\n        if (isset($context['operation_name'])) {\n            $options['operation_name'] = $context['operation_name'];\n        }\n\n        if (isset($context['collection_operation_name'])) {\n            $options['collection_operation_name'] = $context['collection_operation_name'];\n        }\n\n        if (isset($context['item_operation_name'])) {\n            $options['item_operation_name'] = $context['item_operation_name'];\n        }\n\n        return $options;\n    }\n\n    /**\n     * Creates the context to use when serializing a relation.\n     *\n     * @deprecated since version 2.1, to be removed in 3.0.\n     */\n    protected function createRelationSerializationContext(string $resourceClass, array $context): array\n    {\n        @trigger_error(sprintf('The method %s() is deprecated since 2.1 and will be removed in 3.0.', __METHOD__), \\E_USER_DEPRECATED);\n\n        return $context;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @throws UnexpectedValueException\n     * @throws LogicException\n     *\n     * @return mixed\n     */\n    protected function getAttributeValue($object, $attribute, $format = null, array $context = [])\n    {\n        $context['api_attribute'] = $attribute;\n        /** @var ApiProperty|PropertyMetadata */\n        $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $this->getFactoryOptions($context));\n\n        try {\n            $attributeValue = $this->propertyAccessor->getValue($object, $attribute);\n        } catch (NoSuchPropertyException $e) {\n            // BC to be removed in 3.0\n            if ($propertyMetadata instanceof PropertyMetadata && !$propertyMetadata->hasChildInherited()) {\n                throw $e;\n            }\n            if ($propertyMetadata instanceof ApiProperty) {\n                throw $e;\n            }\n\n            $attributeValue = null;\n        }\n\n        if ($context['api_denormalize'] ?? false) {\n            return $attributeValue;\n        }\n\n        $type = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getType() : ($propertyMetadata->getBuiltinTypes()[0] ?? null);\n\n        if (\n            $type &&\n            $type->isCollection() &&\n            ($collectionValueType = method_exists(Type::class, 'getCollectionValueTypes') ? ($type->getCollectionValueTypes()[0] ?? null) : $type->getCollectionValueType()) &&\n            ($className = $collectionValueType->getClassName()) &&\n            $this->resourceClassResolver->isResourceClass($className)\n        ) {\n            if (!is_iterable($attributeValue)) {\n                throw new UnexpectedValueException('Unexpected non-iterable value for to-many relation.');\n            }\n\n            $resourceClass = $this->resourceClassResolver->getResourceClass($attributeValue, $className);\n            $childContext = $this->createChildContext($context, $attribute, $format);\n            $childContext['resource_class'] = $resourceClass;\n            if ($this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n                $childContext['operation'] = $this->resourceMetadataFactory->create($resourceClass)->getOperation();\n            }\n            unset($childContext['iri'], $childContext['uri_variables']);\n\n            return $this->normalizeCollectionOfRelations($propertyMetadata, $attributeValue, $resourceClass, $format, $childContext);\n        }\n\n        if (\n            $type &&\n            ($className = $type->getClassName()) &&\n            $this->resourceClassResolver->isResourceClass($className)\n        ) {\n            if (!\\is_object($attributeValue) && null !== $attributeValue) {\n                throw new UnexpectedValueException('Unexpected non-object value for to-one relation.');\n            }\n\n            $resourceClass = $this->resourceClassResolver->getResourceClass($attributeValue, $className);\n            $childContext = $this->createChildContext($context, $attribute, $format);\n            $childContext['resource_class'] = $resourceClass;\n            if ($this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n                $childContext['operation'] = $this->resourceMetadataFactory->create($resourceClass)->getOperation();\n            }\n            unset($childContext['iri'], $childContext['uri_variables']);\n\n            return $this->normalizeRelation($propertyMetadata, $attributeValue, $resourceClass, $format, $childContext);\n        }\n\n        if (!$this->serializer instanceof NormalizerInterface) {\n            throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', NormalizerInterface::class));\n        }\n\n        unset($context['resource_class']);\n\n        if ($type && $type->getClassName()) {\n            $childContext = $this->createChildContext($context, $attribute, $format);\n            unset($childContext['iri'], $childContext['uri_variables']);\n\n            if ($propertyMetadata instanceof PropertyMetadata) {\n                $childContext['output']['iri'] = $propertyMetadata->getIri() ?? false;\n            } else {\n                $childContext['output']['gen_id'] = $propertyMetadata->getGenId() ?? false;\n            }\n\n            return $this->serializer->normalize($attributeValue, $format, $childContext);\n        }\n\n        return $this->serializer->normalize($attributeValue, $format, $context);\n    }\n\n    /**\n     * Normalizes a collection of relations (to-many).\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     * @param iterable                     $attributeValue\n     *\n     * @throws UnexpectedValueException\n     */\n    protected function normalizeCollectionOfRelations($propertyMetadata, $attributeValue, string $resourceClass, ?string $format, array $context): array\n    {\n        $value = [];\n        foreach ($attributeValue as $index => $obj) {\n            if (!\\is_object($obj) && null !== $obj) {\n                throw new UnexpectedValueException('Unexpected non-object element in to-many relation.');\n            }\n\n            $value[$index] = $this->normalizeRelation($propertyMetadata, $obj, $resourceClass, $format, $context);\n        }\n\n        return $value;\n    }\n\n    /**\n     * Normalizes a relation.\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     * @param object|null                  $relatedObject\n     *\n     * @throws LogicException\n     * @throws UnexpectedValueException\n     *\n     * @return string|array|\\ArrayObject|null IRI or normalized object data\n     */\n    protected function normalizeRelation($propertyMetadata, $relatedObject, string $resourceClass, ?string $format, array $context)\n    {\n        if (null === $relatedObject || !empty($context['attributes']) || $propertyMetadata->isReadableLink()) {\n            if (!$this->serializer instanceof NormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', NormalizerInterface::class));\n            }\n\n            $normalizedRelatedObject = $this->serializer->normalize($relatedObject, $format, $context);\n            // @phpstan-ignore-next-line throwing an explicit exception helps debugging\n            if (!\\is_string($normalizedRelatedObject) && !\\is_array($normalizedRelatedObject) && !$normalizedRelatedObject instanceof \\ArrayObject && null !== $normalizedRelatedObject) {\n                throw new UnexpectedValueException('Expected normalized relation to be an IRI, array, \\ArrayObject or null');\n            }\n\n            return $normalizedRelatedObject;\n        }\n\n        $iri = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($relatedObject) : $this->iriConverter->getIriFromResource($relatedObject);\n\n        if (isset($context['resources'])) {\n            $context['resources'][$iri] = $iri;\n        }\n\n        $push = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getAttribute('push', false) : ($propertyMetadata->getPush() ?? false);\n        if (isset($context['resources_to_push']) && $push) {\n            $context['resources_to_push'][$iri] = $iri;\n        }\n\n        return $iri;\n    }\n\n    /**\n     * Finds the first supported data transformer if any.\n     *\n     * @param object|array $data object on normalize / array on denormalize\n     */\n    protected function getDataTransformer($data, string $to, array $context = []): ?DataTransformerInterface\n    {\n        foreach ($this->dataTransformers as $dataTransformer) {\n            if ($dataTransformer->supportsTransformation($data, $to, $context)) {\n                return $dataTransformer;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * For a given resource, it returns an output representation if any\n     * If not, the resource is returned.\n     *\n     * @param mixed $object\n     */\n    protected function transformOutput($object, array $context = [], string $outputClass = null)\n    {\n    }\n\n    private function createAttributeValue($attribute, $value, $format = null, array $context = [])\n    {\n        if (!$this->resourceClassResolver->isResourceClass($context['resource_class'])) {\n            return $value;\n        }\n\n        /** @var ApiProperty|PropertyMetadata */\n        $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $this->getFactoryOptions($context));\n        $type = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getType() : ($propertyMetadata->getBuiltinTypes()[0] ?? null);\n\n        if (null === $type) {\n            // No type provided, blindly return the value\n            return $value;\n        }\n\n        if (null === $value && $type->isNullable()) {\n            return $value;\n        }\n\n        $collectionValueType = method_exists(Type::class, 'getCollectionValueTypes') ? ($type->getCollectionValueTypes()[0] ?? null) : $type->getCollectionValueType();\n\n        /* From @see AbstractObjectNormalizer::validateAndDenormalize() */\n        // Fix a collection that contains the only one element\n        // This is special to xml format only\n        if ('xml' === $format && null !== $collectionValueType && (!\\is_array($value) || !\\is_int(key($value)))) {\n            $value = [$value];\n        }\n\n        if (\n            $type->isCollection() &&\n            null !== $collectionValueType &&\n            null !== ($className = $collectionValueType->getClassName()) &&\n            $this->resourceClassResolver->isResourceClass($className)\n        ) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass(null, $className);\n            $context['resource_class'] = $resourceClass;\n\n            return $this->denormalizeCollection($attribute, $propertyMetadata, $type, $resourceClass, $value, $format, $context);\n        }\n\n        if (\n            null !== ($className = $type->getClassName()) &&\n            $this->resourceClassResolver->isResourceClass($className)\n        ) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass(null, $className);\n            $childContext = $this->createChildContext($context, $attribute, $format);\n            $childContext['resource_class'] = $resourceClass;\n            if ($this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n                $childContext['operation'] = $this->resourceMetadataFactory->create($resourceClass)->getOperation();\n            }\n\n            return $this->denormalizeRelation($attribute, $propertyMetadata, $resourceClass, $value, $format, $childContext);\n        }\n\n        if (\n            $type->isCollection() &&\n            null !== $collectionValueType &&\n            null !== ($className = $collectionValueType->getClassName())\n        ) {\n            if (!$this->serializer instanceof DenormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', DenormalizerInterface::class));\n            }\n\n            unset($context['resource_class']);\n\n            return $this->serializer->denormalize($value, $className.'[]', $format, $context);\n        }\n\n        if (null !== $className = $type->getClassName()) {\n            if (!$this->serializer instanceof DenormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', DenormalizerInterface::class));\n            }\n\n            unset($context['resource_class']);\n\n            return $this->serializer->denormalize($value, $className, $format, $context);\n        }\n\n        /* From @see AbstractObjectNormalizer::validateAndDenormalize() */\n        // In XML and CSV all basic datatypes are represented as strings, it is e.g. not possible to determine,\n        // if a value is meant to be a string, float, int or a boolean value from the serialized representation.\n        // That's why we have to transform the values, if one of these non-string basic datatypes is expected.\n        if (\\is_string($value) && (XmlEncoder::FORMAT === $format || CsvEncoder::FORMAT === $format)) {\n            if ('' === $value && $type->isNullable() && \\in_array($type->getBuiltinType(), [Type::BUILTIN_TYPE_BOOL, Type::BUILTIN_TYPE_INT, Type::BUILTIN_TYPE_FLOAT], true)) {\n                return null;\n            }\n\n            switch ($type->getBuiltinType()) {\n                case Type::BUILTIN_TYPE_BOOL:\n                    // according to https://www.w3.org/TR/xmlschema-2/#boolean, valid representations are \"false\", \"true\", \"0\" and \"1\"\n                    if ('false' === $value || '0' === $value) {\n                        $value = false;\n                    } elseif ('true' === $value || '1' === $value) {\n                        $value = true;\n                    } else {\n                        throw new NotNormalizableValueException(sprintf('The type of the \"%s\" attribute for class \"%s\" must be bool (\"%s\" given).', $attribute, $className, $value));\n                    }\n                    break;\n                case Type::BUILTIN_TYPE_INT:\n                    if (ctype_digit($value) || ('-' === $value[0] && ctype_digit(substr($value, 1)))) {\n                        $value = (int) $value;\n                    } else {\n                        throw new NotNormalizableValueException(sprintf('The type of the \"%s\" attribute for class \"%s\" must be int (\"%s\" given).', $attribute, $className, $value));\n                    }\n                    break;\n                case Type::BUILTIN_TYPE_FLOAT:\n                    if (is_numeric($value)) {\n                        return (float) $value;\n                    }\n\n                    switch ($value) {\n                        case 'NaN':\n                            return \\NAN;\n                        case 'INF':\n                            return \\INF;\n                        case '-INF':\n                            return -\\INF;\n                        default:\n                            throw new NotNormalizableValueException(sprintf('The type of the \"%s\" attribute for class \"%s\" must be float (\"%s\" given).', $attribute, $className, $value));\n                    }\n            }\n        }\n\n        if ($context[static::DISABLE_TYPE_ENFORCEMENT] ?? false) {\n            return $value;\n        }\n\n        $this->validateType($attribute, $type, $value, $format);\n\n        return $value;\n    }\n\n    /**\n     * Sets a value of the object using the PropertyAccess component.\n     *\n     * @param object $object\n     * @param mixed  $value\n     */\n    private function setValue($object, string $attributeName, $value)\n    {\n        try {\n            $this->propertyAccessor->setValue($object, $attributeName, $value);\n        } catch (NoSuchPropertyException $exception) {\n            // Properties not found are ignored\n        }\n    }\n\n    /**\n     * TODO: to remove in 3.0.\n     *\n     * @deprecated since 2.7\n     */\n    private function supportsPlainIdentifiers(): bool\n    {\n        return $this->allowPlainIdentifiers && null !== $this->itemDataProvider;\n    }\n}\n\nclass_alias(AbstractItemNormalizer::class, \\ApiPlatform\\Core\\Serializer\\AbstractItemNormalizer::class);\n", "<?php\n\n/*\n * This file is part of the API Platform project.\n *\n * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ndeclare(strict_types=1);\n\nnamespace ApiPlatform\\Serializer;\n\ntrait CacheKeyTrait\n{\n    /**\n     * @return string|bool\n     */\n    private function getCacheKey(?string $format, array $context)\n    {\n        foreach ($context[self::EXCLUDE_FROM_CACHE_KEY] ?? $this->defaultContext[self::EXCLUDE_FROM_CACHE_KEY] as $key) {\n            unset($context[$key]);\n        }\n        unset($context[self::EXCLUDE_FROM_CACHE_KEY]);\n        unset($context['cache_key']); // avoid artificially different keys\n\n        try {\n            return md5($format.serialize($context));\n        } catch (\\Exception $exception) {\n            // The context cannot be serialized, skip the cache\n            return false;\n        }\n    }\n}\n\nclass_alias(CacheKeyTrait::class, \\ApiPlatform\\Core\\Serializer\\CacheKeyTrait::class);\n"], "fixing_code": ["Feature: Authorization checking\n  In order to use the API\n  As a client software user\n  I need to be authorized to access a given resource.\n\n  @createSchema\n  Scenario: An anonymous user retrieves a secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 401\n\n  Scenario: An authenticated user retrieve a secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should be in JSON\n\n  Scenario: Data provider that's return generator has null previous object\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/custom_data_provider_generator\"\n    Then the response status code should be 200\n\n  Scenario: A standard user cannot create a secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"POST\" request to \"/secured_dummies\" with body:\n    \"\"\"\n    {\n        \"title\": \"Title\",\n        \"description\": \"Description\",\n        \"owner\": \"foo\"\n    }\n    \"\"\"\n    Then the response status code should be 403\n\n  Scenario: An admin can create a secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"POST\" request to \"/secured_dummies\" with body:\n    \"\"\"\n    {\n        \"title\": \"Title\",\n        \"description\": \"Description\",\n        \"owner\": \"someone\"\n    }\n    \"\"\"\n    Then the response status code should be 201\n\n  Scenario: An admin can create another secured resource\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"POST\" request to \"/secured_dummies\" with body:\n    \"\"\"\n    {\n        \"title\": \"Special Title\",\n        \"description\": \"Description\",\n        \"owner\": \"dunglas\",\n        \"adminOnlyProperty\": \"secret\"\n    }\n    \"\"\"\n    Then the response status code should be 201\n\n  Scenario: A user cannot retrieve an item they doesn't own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies/1\"\n    Then the response status code should be 403\n    And the response should be in JSON\n\n  Scenario: A user can retrieve an item they owns\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies/2\"\n    Then the response status code should be 200\n\n  Scenario: A user can see a secured owner-only property on an object they own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies/2\"\n    Then the response status code should be 200\n    And the JSON node \"ownerOnlyProperty\" should exist\n    And the JSON node \"ownerOnlyProperty\" should not be null\n\n  Scenario: An admin can't see a secured owner-only property on objects they don't own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should not contain \"ownerOnlyProperty\"\n\n  Scenario: A user can't assign to themself an item they doesn't own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"PUT\" request to \"/secured_dummies/2\" with body:\n    \"\"\"\n    {\n        \"owner\": \"kitten\"\n    }\n    \"\"\"\n    Then the response status code should be 403\n\n  Scenario: A user can update an item they owns and transfer it\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"PUT\" request to \"/secured_dummies/2\" with body:\n    \"\"\"\n    {\n        \"owner\": \"vincent\"\n    }\n    \"\"\"\n    Then the response status code should be 200\n\n  Scenario: An admin retrieves a resource with an admin only viewable property\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should contain \"adminOnlyProperty\"\n\n  Scenario: A user retrieves a resource with an admin only viewable property\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should not contain \"adminOnlyProperty\"\n\n  Scenario: An admin can create a secured resource with a secured Property\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"POST\" request to \"/secured_dummies\" with body:\n    \"\"\"\n    {\n        \"title\": \"Common Title\",\n        \"description\": \"Description\",\n        \"owner\": \"dunglas\",\n        \"adminOnlyProperty\": \"Is it safe?\"\n    }\n    \"\"\"\n    Then the response status code should be 201\n    And the response should contain \"adminOnlyProperty\"\n    And the JSON node \"adminOnlyProperty\" should be equal to the string \"Is it safe?\"\n\n  Scenario: A user cannot update a secured property\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"PUT\" request to \"/secured_dummies/3\" with body:\n    \"\"\"\n    {\n        \"adminOnlyProperty\": \"Yes it is!\"\n    }\n    \"\"\"\n    Then the response status code should be 200\n    And the response should not contain \"adminOnlyProperty\"\n    And I add \"Authorization\" header equal to \"Basic YWRtaW46a2l0dGVu\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should contain \"adminOnlyProperty\"\n    And the JSON node \"hydra:member[2].adminOnlyProperty\" should be equal to the string \"Is it safe?\"\n\n  Scenario: An user can update an owner-only secured property on an object they own\n    When I add \"Accept\" header equal to \"application/ld+json\"\n    And I add \"Content-Type\" header equal to \"application/ld+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"PUT\" request to \"/secured_dummies/3\" with body:\n    \"\"\"\n    {\n        \"ownerOnlyProperty\": \"updated\"\n    }\n    \"\"\"\n    Then the response status code should be 200\n    And the response should contain \"ownerOnlyProperty\"\n    And the JSON node \"ownerOnlyProperty\" should be equal to the string \"updated\"\n\n  Scenario: A user retrieves a resource with an admin only viewable property\n    When I add \"Accept\" header equal to \"application/json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should contain \"ownerOnlyProperty\"\n\n  Scenario: A user retrieves a resource with an admin only viewable property\n    When I add \"Accept\" header equal to \"application/hal+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should contain \"ownerOnlyProperty\"\n\n  Scenario: A user retrieves a resource with an admin only viewable property\n    Given I add \"Accept\" header equal to \"application/vnd.api+json\"\n    And I add \"Authorization\" header equal to \"Basic ZHVuZ2xhczprZXZpbg==\"\n    And I send a \"GET\" request to \"/secured_dummies\"\n    Then the response status code should be 200\n    And the response should contain \"ownerOnlyProperty\"\n\n", "<?php\n\n/*\n * This file is part of the API Platform project.\n *\n * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ndeclare(strict_types=1);\n\nnamespace ApiPlatform\\Hal\\Serializer;\n\nuse ApiPlatform\\Api\\UrlGeneratorInterface;\nuse ApiPlatform\\Core\\Api\\IriConverterInterface as LegacyIriConverterInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\PropertyMetadata;\nuse ApiPlatform\\Metadata\\ApiProperty;\nuse ApiPlatform\\Serializer\\AbstractItemNormalizer;\nuse ApiPlatform\\Serializer\\CacheKeyTrait;\nuse ApiPlatform\\Serializer\\ContextTrait;\nuse ApiPlatform\\Util\\ClassInfoTrait;\nuse Symfony\\Component\\PropertyInfo\\Type;\nuse Symfony\\Component\\Serializer\\Exception\\LogicException;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\nuse Symfony\\Component\\Serializer\\Mapping\\AttributeMetadataInterface;\n\n/**\n * Converts between objects and array including HAL metadata.\n *\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n */\nfinal class ItemNormalizer extends AbstractItemNormalizer\n{\n    use CacheKeyTrait;\n    use ClassInfoTrait;\n    use ContextTrait;\n\n    public const FORMAT = 'jsonhal';\n\n    private $componentsCache = [];\n    private $attributesMetadataCache = [];\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsNormalization($data, $format = null, array $context = []): bool\n    {\n        return self::FORMAT === $format && parent::supportsNormalization($data, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return array|string|int|float|bool|\\ArrayObject|null\n     */\n    public function normalize($object, $format = null, array $context = [])\n    {\n        $resourceClass = $this->getObjectClass($object);\n        if ($this->getOutputClass($resourceClass, $context)) {\n            return parent::normalize($object, $format, $context);\n        }\n\n        if ($this->resourceClassResolver->isResourceClass($resourceClass)) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass($object, $context['resource_class'] ?? null);\n        }\n\n        $context = $this->initContext($resourceClass, $context);\n        $iri = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($object) : $this->iriConverter->getIriFromResource($object, UrlGeneratorInterface::ABS_PATH, $context['operation'] ?? null, $context);\n        $context['iri'] = $iri;\n        $context['api_normalize'] = true;\n\n        if (!isset($context['cache_key'])) {\n            $context['cache_key'] = $this->getCacheKey($format, $context);\n        }\n\n        $data = parent::normalize($object, $format, $context);\n        if (!\\is_array($data)) {\n            return $data;\n        }\n\n        $metadata = [\n            '_links' => [\n                'self' => [\n                    'href' => $iri,\n                ],\n            ],\n        ];\n        $components = $this->getComponents($object, $format, $context);\n        $metadata = $this->populateRelation($metadata, $object, $format, $context, $components, 'links');\n        $metadata = $this->populateRelation($metadata, $object, $format, $context, $components, 'embedded');\n\n        return $metadata + $data;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsDenormalization($data, $type, $format = null, array $context = []): bool\n    {\n        // prevent the use of lower priority normalizers (e.g. serializer.normalizer.object) for this format\n        return self::FORMAT === $format;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @throws LogicException\n     *\n     * @return mixed\n     */\n    public function denormalize($data, $class, $format = null, array $context = [])\n    {\n        throw new LogicException(sprintf('%s is a read-only format.', self::FORMAT));\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getAttributes($object, $format = null, array $context = []): array\n    {\n        return $this->getComponents($object, $format, $context)['states'];\n    }\n\n    /**\n     * Gets HAL components of the resource: states, links and embedded.\n     *\n     * @param object $object\n     */\n    private function getComponents($object, ?string $format, array $context): array\n    {\n        $cacheKey = $this->getObjectClass($object).'-'.$context['cache_key'];\n\n        if (isset($this->componentsCache[$cacheKey])) {\n            return $this->componentsCache[$cacheKey];\n        }\n\n        $attributes = parent::getAttributes($object, $format, $context);\n        $options = $this->getFactoryOptions($context);\n\n        $components = [\n            'states' => [],\n            'links' => [],\n            'embedded' => [],\n        ];\n\n        foreach ($attributes as $attribute) {\n            /** @var ApiProperty|PropertyMetadata */\n            $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $options);\n\n            // TODO: 3.0 support multiple types, default value of types will be [] instead of null\n            $type = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getType() : ($propertyMetadata->getBuiltinTypes()[0] ?? null);\n            $isOne = $isMany = false;\n\n            if (null !== $type) {\n                if ($type->isCollection()) {\n                    $valueType = method_exists(Type::class, 'getCollectionValueTypes') ? ($type->getCollectionValueTypes()[0] ?? null) : $type->getCollectionValueType();\n                    $isMany = null !== $valueType && ($className = $valueType->getClassName()) && $this->resourceClassResolver->isResourceClass($className);\n                } else {\n                    $className = $type->getClassName();\n                    $isOne = $className && $this->resourceClassResolver->isResourceClass($className);\n                }\n            }\n\n            if (!$isOne && !$isMany) {\n                $components['states'][] = $attribute;\n                continue;\n            }\n\n            $relation = ['name' => $attribute, 'cardinality' => $isOne ? 'one' : 'many'];\n            if ($propertyMetadata->isReadableLink()) {\n                $components['embedded'][] = $relation;\n            }\n\n            $components['links'][] = $relation;\n        }\n\n        if (false !== $context['cache_key']) {\n            $this->componentsCache[$cacheKey] = $components;\n        }\n\n        return $components;\n    }\n\n    /**\n     * Populates _links and _embedded keys.\n     *\n     * @param object $object\n     */\n    private function populateRelation(array $data, $object, ?string $format, array $context, array $components, string $type): array\n    {\n        $class = $this->getObjectClass($object);\n\n        $attributesMetadata = \\array_key_exists($class, $this->attributesMetadataCache) ?\n            $this->attributesMetadataCache[$class] :\n            $this->attributesMetadataCache[$class] = $this->classMetadataFactory ? $this->classMetadataFactory->getMetadataFor($class)->getAttributesMetadata() : null;\n\n        $key = '_'.$type;\n        foreach ($components[$type] as $relation) {\n            if (null !== $attributesMetadata && $this->isMaxDepthReached($attributesMetadata, $class, $relation['name'], $context)) {\n                continue;\n            }\n\n            $attributeValue = $this->getAttributeValue($object, $relation['name'], $format, $context);\n            if (empty($attributeValue)) {\n                continue;\n            }\n\n            $relationName = $relation['name'];\n            if ($this->nameConverter) {\n                $relationName = $this->nameConverter->normalize($relationName, $class, $format, $context);\n            }\n\n            if ('one' === $relation['cardinality']) {\n                if ('links' === $type) {\n                    $data[$key][$relationName]['href'] = $this->getRelationIri($attributeValue);\n                    continue;\n                }\n\n                $data[$key][$relationName] = $attributeValue;\n                continue;\n            }\n\n            // many\n            $data[$key][$relationName] = [];\n            foreach ($attributeValue as $rel) {\n                if ('links' === $type) {\n                    $rel = ['href' => $this->getRelationIri($rel)];\n                }\n\n                $data[$key][$relationName][] = $rel;\n            }\n        }\n\n        return $data;\n    }\n\n    /**\n     * Gets the IRI of the given relation.\n     *\n     * @param mixed $rel\n     *\n     * @throws UnexpectedValueException\n     */\n    private function getRelationIri($rel): string\n    {\n        if (!(\\is_array($rel) || \\is_string($rel))) {\n            throw new UnexpectedValueException('Expected relation to be an IRI or array');\n        }\n\n        return \\is_string($rel) ? $rel : $rel['_links']['self']['href'];\n    }\n\n    /**\n     * Is the max depth reached for the given attribute?\n     *\n     * @param AttributeMetadataInterface[] $attributesMetadata\n     */\n    private function isMaxDepthReached(array $attributesMetadata, string $class, string $attribute, array &$context): bool\n    {\n        if (\n            !($context[self::ENABLE_MAX_DEPTH] ?? false) ||\n            !isset($attributesMetadata[$attribute]) ||\n            null === $maxDepth = $attributesMetadata[$attribute]->getMaxDepth()\n        ) {\n            return false;\n        }\n\n        $key = sprintf(self::DEPTH_KEY_PATTERN, $class, $attribute);\n        if (!isset($context[$key])) {\n            $context[$key] = 1;\n\n            return false;\n        }\n\n        if ($context[$key] === $maxDepth) {\n            return true;\n        }\n\n        ++$context[$key];\n\n        return false;\n    }\n}\n\nclass_alias(ItemNormalizer::class, \\ApiPlatform\\Core\\Hal\\Serializer\\ItemNormalizer::class);\n", "<?php\n\n/*\n * This file is part of the API Platform project.\n *\n * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ndeclare(strict_types=1);\n\nnamespace ApiPlatform\\JsonApi\\Serializer;\n\nuse ApiPlatform\\Api\\ResourceClassResolverInterface;\nuse ApiPlatform\\Api\\UrlGeneratorInterface;\nuse ApiPlatform\\Core\\Api\\IriConverterInterface as LegacyIriConverterInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\Factory\\PropertyNameCollectionFactoryInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\PropertyMetadata;\nuse ApiPlatform\\Core\\Metadata\\Resource\\ResourceMetadata;\nuse ApiPlatform\\Exception\\ItemNotFoundException;\nuse ApiPlatform\\Metadata\\ApiProperty;\nuse ApiPlatform\\Metadata\\Resource\\ResourceMetadataCollection;\nuse ApiPlatform\\Serializer\\AbstractItemNormalizer;\nuse ApiPlatform\\Serializer\\CacheKeyTrait;\nuse ApiPlatform\\Serializer\\ContextTrait;\nuse ApiPlatform\\Symfony\\Security\\ResourceAccessCheckerInterface;\nuse ApiPlatform\\Util\\ClassInfoTrait;\nuse Symfony\\Component\\PropertyAccess\\PropertyAccessorInterface;\nuse Symfony\\Component\\PropertyInfo\\Type;\nuse Symfony\\Component\\Serializer\\Exception\\LogicException;\nuse Symfony\\Component\\Serializer\\Exception\\NotNormalizableValueException;\nuse Symfony\\Component\\Serializer\\Exception\\RuntimeException;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\nuse Symfony\\Component\\Serializer\\NameConverter\\NameConverterInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface;\n\n/**\n * Converts between objects and array.\n *\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n * @author Amrouche Hamza <hamza.simperfit@gmail.com>\n * @author Baptiste Meyer <baptiste.meyer@gmail.com>\n */\nfinal class ItemNormalizer extends AbstractItemNormalizer\n{\n    use CacheKeyTrait;\n    use ClassInfoTrait;\n    use ContextTrait;\n\n    public const FORMAT = 'jsonapi';\n\n    private $componentsCache = [];\n\n    public function __construct(PropertyNameCollectionFactoryInterface $propertyNameCollectionFactory, $propertyMetadataFactory, $iriConverter, ResourceClassResolverInterface $resourceClassResolver, ?PropertyAccessorInterface $propertyAccessor, ?NameConverterInterface $nameConverter, $resourceMetadataFactory, array $defaultContext = [], iterable $dataTransformers = [], ResourceAccessCheckerInterface $resourceAccessChecker = null)\n    {\n        parent::__construct($propertyNameCollectionFactory, $propertyMetadataFactory, $iriConverter, $resourceClassResolver, $propertyAccessor, $nameConverter, null, null, false, $defaultContext, $dataTransformers, $resourceMetadataFactory, $resourceAccessChecker);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsNormalization($data, $format = null, array $context = []): bool\n    {\n        return self::FORMAT === $format && parent::supportsNormalization($data, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return array|string|int|float|bool|\\ArrayObject|null\n     */\n    public function normalize($object, $format = null, array $context = [])\n    {\n        $resourceClass = $this->getObjectClass($object);\n        if ($this->getOutputClass($resourceClass, $context)) {\n            return parent::normalize($object, $format, $context);\n        }\n\n        if ($this->resourceClassResolver->isResourceClass($resourceClass)) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass($object, $context['resource_class'] ?? null);\n        }\n\n        $context = $this->initContext($resourceClass, $context);\n        $iri = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($object) : $this->iriConverter->getIriFromResource($object, UrlGeneratorInterface::ABS_PATH, $context['operation'] ?? null, $context);\n        $context['iri'] = $iri;\n        $context['api_normalize'] = true;\n\n        if (!isset($context['cache_key'])) {\n            $context['cache_key'] = $this->getCacheKey($format, $context);\n        }\n\n        $data = parent::normalize($object, $format, $context);\n        if (!\\is_array($data)) {\n            return $data;\n        }\n\n        // Get and populate relations\n        $allRelationshipsData = $this->getComponents($object, $format, $context)['relationships'];\n        $populatedRelationContext = $context;\n        $relationshipsData = $this->getPopulatedRelations($object, $format, $populatedRelationContext, $allRelationshipsData);\n\n        // Do not include primary resources\n        $context['api_included_resources'] = [$context['iri']];\n\n        $includedResourcesData = $this->getRelatedResources($object, $format, $context, $allRelationshipsData);\n\n        $resourceData = [\n            'id' => $context['iri'],\n            'type' => $this->getResourceShortName($resourceClass),\n        ];\n\n        if ($data) {\n            $resourceData['attributes'] = $data;\n        }\n\n        if ($relationshipsData) {\n            $resourceData['relationships'] = $relationshipsData;\n        }\n\n        $document = ['data' => $resourceData];\n\n        if ($includedResourcesData) {\n            $document['included'] = $includedResourcesData;\n        }\n\n        return $document;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsDenormalization($data, $type, $format = null, array $context = []): bool\n    {\n        return self::FORMAT === $format && parent::supportsDenormalization($data, $type, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @throws NotNormalizableValueException\n     *\n     * @return mixed\n     */\n    public function denormalize($data, $class, $format = null, array $context = [])\n    {\n        // Avoid issues with proxies if we populated the object\n        if (!isset($context[self::OBJECT_TO_POPULATE]) && isset($data['data']['id'])) {\n            if (true !== ($context['api_allow_update'] ?? true)) {\n                throw new NotNormalizableValueException('Update is not allowed for this operation.');\n            }\n\n            $context[self::OBJECT_TO_POPULATE] = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getItemFromIri(\n                $data['data']['id'],\n                $context + ['fetch_data' => false]\n            ) : $this->iriConverter->getResourceFromIri(\n                $data['data']['id'],\n                $context + ['fetch_data' => false]\n            );\n        }\n\n        // Merge attributes and relationships, into format expected by the parent normalizer\n        $dataToDenormalize = array_merge(\n            $data['data']['attributes'] ?? [],\n            $data['data']['relationships'] ?? []\n        );\n\n        return parent::denormalize(\n            $dataToDenormalize,\n            $class,\n            $format,\n            $context\n        );\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getAttributes($object, $format = null, array $context = []): array\n    {\n        return $this->getComponents($object, $format, $context)['attributes'];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function setAttributeValue($object, $attribute, $value, $format = null, array $context = []): void\n    {\n        parent::setAttributeValue($object, $attribute, \\is_array($value) && \\array_key_exists('data', $value) ? $value['data'] : $value, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @see http://jsonapi.org/format/#document-resource-object-linkage\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     *\n     * @throws RuntimeException\n     * @throws NotNormalizableValueException\n     */\n    protected function denormalizeRelation(string $attributeName, $propertyMetadata, string $className, $value, ?string $format, array $context)\n    {\n        if (!\\is_array($value) || !isset($value['id'], $value['type'])) {\n            throw new NotNormalizableValueException('Only resource linkage supported currently, see: http://jsonapi.org/format/#document-resource-object-linkage.');\n        }\n\n        try {\n            return $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getItemFromIri($value['id'], $context + ['fetch_data' => true]) : $this->iriConverter->getResourceFromIri($value['id'], $context + ['fetch_data' => true]);\n        } catch (ItemNotFoundException $e) {\n            throw new RuntimeException($e->getMessage(), $e->getCode(), $e);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     *\n     * @see http://jsonapi.org/format/#document-resource-object-linkage\n     */\n    protected function normalizeRelation($propertyMetadata, $relatedObject, string $resourceClass, ?string $format, array $context)\n    {\n        if (null !== $relatedObject) {\n            $iri = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($relatedObject) : $this->iriConverter->getIriFromResource($relatedObject);\n            $context['iri'] = $iri;\n\n            if (isset($context['resources'])) {\n                $context['resources'][$iri] = $iri;\n            }\n        }\n\n        if (null === $relatedObject || isset($context['api_included'])) {\n            if (!$this->serializer instanceof NormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', NormalizerInterface::class));\n            }\n\n            $normalizedRelatedObject = $this->serializer->normalize($relatedObject, $format, $context);\n            // @phpstan-ignore-next-line throwing an explicit exception helps debugging\n            if (!\\is_string($normalizedRelatedObject) && !\\is_array($normalizedRelatedObject) && !$normalizedRelatedObject instanceof \\ArrayObject && null !== $normalizedRelatedObject) {\n                throw new UnexpectedValueException('Expected normalized relation to be an IRI, array, \\ArrayObject or null');\n            }\n\n            return $normalizedRelatedObject;\n        }\n\n        return [\n            'data' => [\n                'type' => $this->getResourceShortName($resourceClass),\n                'id' => $iri,\n            ],\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function isAllowedAttribute($classOrObject, $attribute, $format = null, array $context = []): bool\n    {\n        return preg_match('/^\\\\w[-\\\\w_]*$/', $attribute) && parent::isAllowedAttribute($classOrObject, $attribute, $format, $context);\n    }\n\n    /**\n     * Gets JSON API components of the resource: attributes, relationships, meta and links.\n     *\n     * @param object $object\n     */\n    private function getComponents($object, ?string $format, array $context): array\n    {\n        $cacheKey = $this->getObjectClass($object).'-'.$context['cache_key'];\n\n        if (isset($this->componentsCache[$cacheKey])) {\n            return $this->componentsCache[$cacheKey];\n        }\n\n        $attributes = parent::getAttributes($object, $format, $context);\n\n        $options = $this->getFactoryOptions($context);\n\n        $components = [\n            'links' => [],\n            'relationships' => [],\n            'attributes' => [],\n            'meta' => [],\n        ];\n\n        foreach ($attributes as $attribute) {\n            /** @var ApiProperty|PropertyMetadata */\n            $propertyMetadata = $this\n                ->propertyMetadataFactory\n                ->create($context['resource_class'], $attribute, $options);\n\n            // TODO: 3.0 support multiple types, default value of types will be [] instead of null\n            $type = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getType() : ($propertyMetadata->getBuiltinTypes()[0] ?? null);\n            $isOne = $isMany = false;\n\n            if (null !== $type) {\n                if ($type->isCollection()) {\n                    $collectionValueType = method_exists(Type::class, 'getCollectionValueTypes') ? ($type->getCollectionValueTypes()[0] ?? null) : $type->getCollectionValueType();\n                    $isMany = ($collectionValueType && $className = $collectionValueType->getClassName()) ? $this->resourceClassResolver->isResourceClass($className) : false;\n                } else {\n                    $isOne = ($className = $type->getClassName()) ? $this->resourceClassResolver->isResourceClass($className) : false;\n                }\n            }\n\n            if (!isset($className) || !$isOne && !$isMany) {\n                $components['attributes'][] = $attribute;\n\n                continue;\n            }\n\n            $relation = [\n                'name' => $attribute,\n                'type' => $this->getResourceShortName($className),\n                'cardinality' => $isOne ? 'one' : 'many',\n            ];\n\n            $components['relationships'][] = $relation;\n        }\n\n        if (false !== $context['cache_key']) {\n            $this->componentsCache[$cacheKey] = $components;\n        }\n\n        return $components;\n    }\n\n    /**\n     * Populates relationships keys.\n     *\n     * @param object $object\n     *\n     * @throws UnexpectedValueException\n     */\n    private function getPopulatedRelations($object, ?string $format, array $context, array $relationships): array\n    {\n        $data = [];\n\n        if (!isset($context['resource_class'])) {\n            return $data;\n        }\n\n        unset($context['api_included']);\n        foreach ($relationships as $relationshipDataArray) {\n            $relationshipName = $relationshipDataArray['name'];\n\n            $attributeValue = $this->getAttributeValue($object, $relationshipName, $format, $context);\n\n            if ($this->nameConverter) {\n                $relationshipName = $this->nameConverter->normalize($relationshipName, $context['resource_class'], self::FORMAT, $context);\n            }\n\n            if (!$attributeValue) {\n                continue;\n            }\n\n            $data[$relationshipName] = [\n                'data' => [],\n            ];\n\n            // Many to one relationship\n            if ('one' === $relationshipDataArray['cardinality']) {\n                unset($attributeValue['data']['attributes']);\n                $data[$relationshipName] = $attributeValue;\n\n                continue;\n            }\n\n            // Many to many relationship\n            foreach ($attributeValue as $attributeValueElement) {\n                if (!isset($attributeValueElement['data'])) {\n                    throw new UnexpectedValueException(sprintf('The JSON API attribute \\'%s\\' must contain a \"data\" key.', $relationshipName));\n                }\n                unset($attributeValueElement['data']['attributes']);\n                $data[$relationshipName]['data'][] = $attributeValueElement['data'];\n            }\n        }\n\n        return $data;\n    }\n\n    /**\n     * Populates included keys.\n     *\n     * @param mixed $object\n     */\n    private function getRelatedResources($object, ?string $format, array $context, array $relationships): array\n    {\n        if (!isset($context['api_included'])) {\n            return [];\n        }\n\n        $included = [];\n        foreach ($relationships as $relationshipDataArray) {\n            $relationshipName = $relationshipDataArray['name'];\n\n            if (!$this->shouldIncludeRelation($relationshipName, $context)) {\n                continue;\n            }\n\n            $relationContext = $context;\n            $relationContext['api_included'] = $this->getIncludedNestedResources($relationshipName, $context);\n\n            $attributeValue = $this->getAttributeValue($object, $relationshipName, $format, $relationContext);\n\n            if (!$attributeValue) {\n                continue;\n            }\n\n            // Many to many relationship\n            $attributeValues = $attributeValue;\n            // Many to one relationship\n            if ('one' === $relationshipDataArray['cardinality']) {\n                $attributeValues = [$attributeValue];\n            }\n\n            foreach ($attributeValues as $attributeValueElement) {\n                if (isset($attributeValueElement['data'])) {\n                    $this->addIncluded($attributeValueElement['data'], $included, $context);\n                    if (isset($attributeValueElement['included']) && \\is_array($attributeValueElement['included'])) {\n                        foreach ($attributeValueElement['included'] as $include) {\n                            $this->addIncluded($include, $included, $context);\n                        }\n                    }\n                }\n            }\n        }\n\n        return $included;\n    }\n\n    /**\n     * Add data to included array if it's not already included.\n     */\n    private function addIncluded(array $data, array &$included, array &$context): void\n    {\n        if (isset($data['id']) && !\\in_array($data['id'], $context['api_included_resources'], true)) {\n            $included[] = $data;\n            // Track already included resources\n            $context['api_included_resources'][] = $data['id'];\n        }\n    }\n\n    /**\n     * Figures out if the relationship is in the api_included hash or has included nested resources (path).\n     */\n    private function shouldIncludeRelation(string $relationshipName, array $context): bool\n    {\n        $normalizedName = $this->nameConverter ? $this->nameConverter->normalize($relationshipName, $context['resource_class'], self::FORMAT, $context) : $relationshipName;\n\n        return \\in_array($normalizedName, $context['api_included'], true) || \\count($this->getIncludedNestedResources($relationshipName, $context)) > 0;\n    }\n\n    /**\n     * Returns the names of the nested resources from a path relationship.\n     */\n    private function getIncludedNestedResources(string $relationshipName, array $context): array\n    {\n        $normalizedName = $this->nameConverter ? $this->nameConverter->normalize($relationshipName, $context['resource_class'], self::FORMAT, $context) : $relationshipName;\n\n        $filtered = array_filter($context['api_included'] ?? [], static function (string $included) use ($normalizedName) {\n            return 0 === strpos($included, $normalizedName.'.');\n        });\n\n        return array_map(static function (string $nested) {\n            return substr($nested, strpos($nested, '.') + 1);\n        }, $filtered);\n    }\n\n    // TODO: 3.0 remove\n    private function getResourceShortName(string $resourceClass): string\n    {\n        /** @var ResourceMetadata|ResourceMetadataCollection */\n        $resourceMetadata = $this->resourceMetadataFactory->create($resourceClass);\n\n        if ($resourceMetadata instanceof ResourceMetadata) {\n            return $resourceMetadata->getShortName();\n        }\n\n        return $resourceMetadata->getOperation()->getShortName();\n    }\n}\n\nclass_alias(ItemNormalizer::class, \\ApiPlatform\\Core\\JsonApi\\Serializer\\ItemNormalizer::class);\n", "<?php\n\n/*\n * This file is part of the API Platform project.\n *\n * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ndeclare(strict_types=1);\n\nnamespace ApiPlatform\\Serializer;\n\nuse ApiPlatform\\Api\\IriConverterInterface;\nuse ApiPlatform\\Api\\UrlGeneratorInterface;\nuse ApiPlatform\\Core\\Api\\IriConverterInterface as LegacyIriConverterInterface;\nuse ApiPlatform\\Core\\Bridge\\Symfony\\Messenger\\DataTransformer as MessengerDataTransformer;\nuse ApiPlatform\\Core\\DataProvider\\ItemDataProviderInterface;\nuse ApiPlatform\\Core\\DataTransformer\\DataTransformerInitializerInterface;\nuse ApiPlatform\\Core\\DataTransformer\\DataTransformerInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\Factory\\PropertyMetadataFactoryInterface as LegacyPropertyMetadataFactoryInterface;\nuse ApiPlatform\\Core\\Metadata\\Property\\PropertyMetadata;\nuse ApiPlatform\\Core\\Metadata\\Resource\\Factory\\ResourceMetadataFactoryInterface;\nuse ApiPlatform\\Exception\\InvalidArgumentException;\nuse ApiPlatform\\Exception\\InvalidValueException;\nuse ApiPlatform\\Exception\\ItemNotFoundException;\nuse ApiPlatform\\Metadata\\ApiProperty;\nuse ApiPlatform\\Metadata\\CollectionOperationInterface;\nuse ApiPlatform\\Metadata\\Property\\Factory\\PropertyMetadataFactoryInterface;\nuse ApiPlatform\\Metadata\\Property\\Factory\\PropertyNameCollectionFactoryInterface;\nuse ApiPlatform\\Metadata\\Resource\\Factory\\ResourceMetadataCollectionFactoryInterface;\nuse ApiPlatform\\Symfony\\Security\\ResourceAccessCheckerInterface;\nuse ApiPlatform\\Util\\ClassInfoTrait;\nuse Symfony\\Component\\PropertyAccess\\Exception\\NoSuchPropertyException;\nuse Symfony\\Component\\PropertyAccess\\PropertyAccess;\nuse Symfony\\Component\\PropertyAccess\\PropertyAccessorInterface;\nuse Symfony\\Component\\PropertyInfo\\Type;\nuse Symfony\\Component\\Serializer\\Encoder\\CsvEncoder;\nuse Symfony\\Component\\Serializer\\Encoder\\XmlEncoder;\nuse Symfony\\Component\\Serializer\\Exception\\LogicException;\nuse Symfony\\Component\\Serializer\\Exception\\MissingConstructorArgumentsException;\nuse Symfony\\Component\\Serializer\\Exception\\NotNormalizableValueException;\nuse Symfony\\Component\\Serializer\\Exception\\RuntimeException;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\nuse Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactoryInterface;\nuse Symfony\\Component\\Serializer\\NameConverter\\AdvancedNameConverterInterface;\nuse Symfony\\Component\\Serializer\\NameConverter\\NameConverterInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface;\n\n/**\n * Base item normalizer.\n *\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n */\nabstract class AbstractItemNormalizer extends AbstractObjectNormalizer\n{\n    use ClassInfoTrait;\n    use ContextTrait;\n    use InputOutputMetadataTrait;\n\n    public const IS_TRANSFORMED_TO_SAME_CLASS = 'is_transformed_to_same_class';\n\n    /**\n     * @var PropertyNameCollectionFactoryInterface\n     */\n    protected $propertyNameCollectionFactory;\n    /**\n     * @var LegacyPropertyMetadataFactoryInterface|PropertyMetadataFactoryInterface\n     */\n    protected $propertyMetadataFactory;\n    protected $resourceMetadataFactory;\n    /**\n     * @var LegacyIriConverterInterface|IriConverterInterface\n     */\n    protected $iriConverter;\n    protected $resourceClassResolver;\n    protected $resourceAccessChecker;\n    protected $propertyAccessor;\n    protected $itemDataProvider;\n    protected $allowPlainIdentifiers;\n    protected $dataTransformers = [];\n    protected $localCache = [];\n\n    public function __construct(PropertyNameCollectionFactoryInterface $propertyNameCollectionFactory, $propertyMetadataFactory, $iriConverter, $resourceClassResolver, PropertyAccessorInterface $propertyAccessor = null, NameConverterInterface $nameConverter = null, ClassMetadataFactoryInterface $classMetadataFactory = null, ItemDataProviderInterface $itemDataProvider = null, bool $allowPlainIdentifiers = false, array $defaultContext = [], iterable $dataTransformers = [], $resourceMetadataFactory = null, ResourceAccessCheckerInterface $resourceAccessChecker = null)\n    {\n        if (!isset($defaultContext['circular_reference_handler'])) {\n            $defaultContext['circular_reference_handler'] = function ($object) {\n                return $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($object) : $this->iriConverter->getIriFromResource($object);\n            };\n        }\n        if (!interface_exists(AdvancedNameConverterInterface::class) && method_exists($this, 'setCircularReferenceHandler')) {\n            $this->setCircularReferenceHandler($defaultContext['circular_reference_handler']);\n        }\n\n        parent::__construct($classMetadataFactory, $nameConverter, null, null, \\Closure::fromCallable([$this, 'getObjectClass']), $defaultContext);\n\n        $this->propertyNameCollectionFactory = $propertyNameCollectionFactory;\n        $this->propertyMetadataFactory = $propertyMetadataFactory;\n\n        if ($iriConverter instanceof LegacyIriConverterInterface) {\n            trigger_deprecation('api-platform/core', '2.7', sprintf('Use an implementation of \"%s\" instead of \"%s\".', IriConverterInterface::class, LegacyIriConverterInterface::class));\n        }\n\n        $this->iriConverter = $iriConverter;\n        $this->resourceClassResolver = $resourceClassResolver;\n        $this->propertyAccessor = $propertyAccessor ?: PropertyAccess::createPropertyAccessor();\n        $this->itemDataProvider = $itemDataProvider;\n\n        if (true === $allowPlainIdentifiers) {\n            @trigger_error(sprintf('Allowing plain identifiers as argument of \"%s\" is deprecated since API Platform 2.7 and will not be possible anymore in API Platform 3.', self::class), \\E_USER_DEPRECATED);\n        }\n        $this->allowPlainIdentifiers = $allowPlainIdentifiers;\n\n        $this->dataTransformers = $dataTransformers;\n\n        // Just skip our data transformer to trigger a proper deprecation\n        $customDataTransformers = array_filter(\\is_array($dataTransformers) ? $dataTransformers : iterator_to_array($dataTransformers), function ($dataTransformer) {\n            return !$dataTransformer instanceof MessengerDataTransformer;\n        });\n\n        if (\\count($customDataTransformers)) {\n            trigger_deprecation('api-platform/core', '2.7', 'The DataTransformer pattern is deprecated, use a Provider or a Processor and either use your input or return a new output there.');\n        }\n\n        if ($resourceMetadataFactory && !$resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n            trigger_deprecation('api-platform/core', '2.7', sprintf('Use \"%s\" instead of \"%s\".', ResourceMetadataCollectionFactoryInterface::class, ResourceMetadataFactoryInterface::class));\n        }\n\n        $this->resourceMetadataFactory = $resourceMetadataFactory;\n        $this->resourceAccessChecker = $resourceAccessChecker;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsNormalization($data, $format = null, array $context = []): bool\n    {\n        if (!\\is_object($data) || is_iterable($data)) {\n            return false;\n        }\n\n        $class = $this->getObjectClass($data);\n        if (($context['output']['class'] ?? null) === $class) {\n            return true;\n        }\n\n        return $this->resourceClassResolver->isResourceClass($class);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function hasCacheableSupportsMethod(): bool\n    {\n        return true;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @throws LogicException\n     *\n     * @return array|string|int|float|bool|\\ArrayObject|null\n     */\n    public function normalize($object, $format = null, array $context = [])\n    {\n        $resourceClass = $this->getObjectClass($object);\n        if (!($isTransformed = isset($context[self::IS_TRANSFORMED_TO_SAME_CLASS])) && $outputClass = $this->getOutputClass($resourceClass, $context)) {\n            if (!$this->serializer instanceof NormalizerInterface) {\n                throw new LogicException('Cannot normalize the output because the injected serializer is not a normalizer');\n            }\n\n            // Data transformers are deprecated, this is removed from 3.0\n            if ($dataTransformer = $this->getDataTransformer($object, $outputClass, $context)) {\n                $transformed = $dataTransformer->transform($object, $outputClass, $context);\n\n                if ($object === $transformed) {\n                    $context[self::IS_TRANSFORMED_TO_SAME_CLASS] = true;\n                } else {\n                    $context['api_normalize'] = true;\n                    $context['api_resource'] = $object;\n                    unset($context['output'], $context['resource_class']);\n                }\n\n                return $this->serializer->normalize($transformed, $format, $context);\n            }\n\n            unset($context['output'], $context['operation_name']);\n            if ($this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface && !isset($context['operation'])) {\n                $context['operation'] = $this->resourceMetadataFactory->create($context['resource_class'])->getOperation();\n            }\n            $context['resource_class'] = $outputClass;\n            $context['api_sub_level'] = true;\n            $context[self::ALLOW_EXTRA_ATTRIBUTES] = false;\n\n            return $this->serializer->normalize($object, $format, $context);\n        }\n\n        if ($isTransformed) {\n            unset($context[self::IS_TRANSFORMED_TO_SAME_CLASS]);\n        }\n\n        if ($isResourceClass = $this->resourceClassResolver->isResourceClass($resourceClass)) {\n            $context = $this->initContext($resourceClass, $context);\n        }\n\n        if (isset($context['operation']) && $context['operation'] instanceof CollectionOperationInterface) {\n            unset($context['operation']);\n            unset($context['iri']);\n        }\n\n        $iri = null;\n        if (isset($context['iri'])) {\n            $iri = $context['iri'];\n        } elseif ($this->iriConverter instanceof LegacyIriConverterInterface && $isResourceClass) {\n            $iri = $this->iriConverter->getIriFromItem($object);\n        } elseif ($this->iriConverter instanceof IriConverterInterface) {\n            $iri = $this->iriConverter->getIriFromResource($object, UrlGeneratorInterface::ABS_URL, $context['operation'] ?? null, $context);\n        }\n\n        $context['iri'] = $iri;\n        $context['api_normalize'] = true;\n\n        /*\n         * When true, converts the normalized data array of a resource into an\n         * IRI, if the normalized data array is empty.\n         *\n         * This is useful when traversing from a non-resource towards an attribute\n         * which is a resource, as we do not have the benefit of {@see PropertyMetadata::isReadableLink}.\n         *\n         * It must not be propagated to subresources, as {@see PropertyMetadata::isReadableLink}\n         * should take effect.\n         */\n        $emptyResourceAsIri = $context['api_empty_resource_as_iri'] ?? false;\n        unset($context['api_empty_resource_as_iri']);\n\n        if (isset($context['resources'])) {\n            $context['resources'][$iri] = $iri;\n        }\n\n        $data = parent::normalize($object, $format, $context);\n        if ($emptyResourceAsIri && \\is_array($data) && 0 === \\count($data)) {\n            return $iri;\n        }\n\n        return $data;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return bool\n     */\n    public function supportsDenormalization($data, $type, $format = null, array $context = [])\n    {\n        if (($context['input']['class'] ?? null) === $type) {\n            return true;\n        }\n\n        return $this->localCache[$type] ?? $this->localCache[$type] = $this->resourceClassResolver->isResourceClass($type);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return mixed\n     */\n    public function denormalize($data, $class, $format = null, array $context = [])\n    {\n        $resourceClass = $class;\n\n        if (null !== $inputClass = $this->getInputClass($resourceClass, $context)) {\n            if (null !== $dataTransformer = $this->getDataTransformer($data, $resourceClass, $context)) {\n                $dataTransformerContext = $context;\n\n                unset($context['input']);\n                unset($context['resource_class']);\n\n                if (!$this->serializer instanceof DenormalizerInterface) {\n                    throw new LogicException('Cannot denormalize the input because the injected serializer is not a denormalizer');\n                }\n\n                if ($dataTransformer instanceof DataTransformerInitializerInterface) {\n                    $context[AbstractObjectNormalizer::OBJECT_TO_POPULATE] = $dataTransformer->initialize($inputClass, $context);\n                    $context[AbstractObjectNormalizer::DEEP_OBJECT_TO_POPULATE] = true;\n                }\n\n                try {\n                    $denormalizedInput = $this->serializer->denormalize($data, $inputClass, $format, $context);\n                } catch (NotNormalizableValueException $e) {\n                    throw new UnexpectedValueException('The input data is misformatted.', $e->getCode(), $e);\n                }\n\n                if (!\\is_object($denormalizedInput)) {\n                    throw new UnexpectedValueException('Expected denormalized input to be an object.');\n                }\n\n                return $dataTransformer->transform($denormalizedInput, $resourceClass, $dataTransformerContext);\n            }\n\n            unset($context['input']);\n            unset($context['operation']);\n            unset($context['operation_name']);\n            $context['resource_class'] = $inputClass;\n\n            if (!$this->serializer instanceof DenormalizerInterface) {\n                throw new LogicException('Cannot denormalize the input because the injected serializer is not a denormalizer');\n            }\n\n            try {\n                return $this->serializer->denormalize($data, $inputClass, $format, $context);\n            } catch (NotNormalizableValueException $e) {\n                throw new UnexpectedValueException('The input data is misformatted.', $e->getCode(), $e);\n            }\n        }\n\n        if (null === $objectToPopulate = $this->extractObjectToPopulate($class, $context, static::OBJECT_TO_POPULATE)) {\n            $normalizedData = \\is_scalar($data) ? [$data] : $this->prepareForDenormalization($data);\n            $class = $this->getClassDiscriminatorResolvedClass($normalizedData, $class);\n        }\n\n        $context['api_denormalize'] = true;\n\n        if ($this->resourceClassResolver->isResourceClass($class)) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass($objectToPopulate, $class);\n            $context['resource_class'] = $resourceClass;\n        }\n\n        $supportsPlainIdentifiers = $this->supportsPlainIdentifiers();\n\n        if (\\is_string($data)) {\n            try {\n                return $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getItemFromIri($data, $context + ['fetch_data' => true]) : $this->iriConverter->getResourceFromIri($data, $context + ['fetch_data' => true]);\n            } catch (ItemNotFoundException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw new UnexpectedValueException($e->getMessage(), $e->getCode(), $e);\n                }\n            } catch (InvalidArgumentException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw new UnexpectedValueException(sprintf('Invalid IRI \"%s\".', $data), $e->getCode(), $e);\n                }\n            }\n        }\n\n        if (!\\is_array($data)) {\n            if (!$supportsPlainIdentifiers) {\n                throw new UnexpectedValueException(sprintf('Expected IRI or document for resource \"%s\", \"%s\" given.', $resourceClass, \\gettype($data)));\n            }\n\n            $item = $this->itemDataProvider->getItem($resourceClass, $data, null, $context + ['fetch_data' => true]);\n            if (null === $item) {\n                throw new ItemNotFoundException(sprintf('Item not found for resource \"%s\" with id \"%s\".', $resourceClass, $data));\n            }\n\n            return $item;\n        }\n\n        $previousObject = null !== $objectToPopulate ? clone $objectToPopulate : null;\n        $object = parent::denormalize($data, $resourceClass, $format, $context);\n\n        if (!$this->resourceClassResolver->isResourceClass($context['resource_class'])) {\n            return $object;\n        }\n\n        // Revert attributes that aren't allowed to be changed after a post-denormalize check\n        foreach (array_keys($data) as $attribute) {\n            if (!$this->canAccessAttributePostDenormalize($object, $previousObject, $attribute, $context)) {\n                if (null !== $previousObject) {\n                    $this->setValue($object, $attribute, $this->propertyAccessor->getValue($previousObject, $attribute));\n                } else {\n                    $propertyMetadata = $this->propertyMetadataFactory->create($resourceClass, $attribute, $this->getFactoryOptions($context));\n                    $this->setValue($object, $attribute, $propertyMetadata->getDefault());\n                }\n            }\n        }\n\n        return $object;\n    }\n\n    /**\n     * Method copy-pasted from symfony/serializer.\n     * Remove it after symfony/serializer version update @see https://github.com/symfony/symfony/pull/28263.\n     *\n     * {@inheritdoc}\n     *\n     * @internal\n     *\n     * @return object\n     */\n    protected function instantiateObject(array &$data, $class, array &$context, \\ReflectionClass $reflectionClass, $allowedAttributes, string $format = null)\n    {\n        if (null !== $object = $this->extractObjectToPopulate($class, $context, static::OBJECT_TO_POPULATE)) {\n            unset($context[static::OBJECT_TO_POPULATE]);\n\n            return $object;\n        }\n\n        $class = $this->getClassDiscriminatorResolvedClass($data, $class);\n        $reflectionClass = new \\ReflectionClass($class);\n\n        $constructor = $this->getConstructor($data, $class, $context, $reflectionClass, $allowedAttributes);\n        if ($constructor) {\n            $constructorParameters = $constructor->getParameters();\n\n            $params = [];\n            foreach ($constructorParameters as $constructorParameter) {\n                $paramName = $constructorParameter->name;\n                $key = $this->nameConverter ? $this->nameConverter->normalize($paramName, $class, $format, $context) : $paramName;\n\n                $allowed = false === $allowedAttributes || (\\is_array($allowedAttributes) && \\in_array($paramName, $allowedAttributes, true));\n                $ignored = !$this->isAllowedAttribute($class, $paramName, $format, $context);\n                if ($constructorParameter->isVariadic()) {\n                    if ($allowed && !$ignored && (isset($data[$key]) || \\array_key_exists($key, $data))) {\n                        if (!\\is_array($data[$paramName])) {\n                            throw new RuntimeException(sprintf('Cannot create an instance of %s from serialized data because the variadic parameter %s can only accept an array.', $class, $constructorParameter->name));\n                        }\n\n                        $params = array_merge($params, $data[$paramName]);\n                    }\n                } elseif ($allowed && !$ignored && (isset($data[$key]) || \\array_key_exists($key, $data))) {\n                    $params[] = $this->createConstructorArgument($data[$key], $key, $constructorParameter, $context, $format);\n\n                    // Don't run set for a parameter passed to the constructor\n                    unset($data[$key]);\n                } elseif (isset($context[static::DEFAULT_CONSTRUCTOR_ARGUMENTS][$class][$key])) {\n                    $params[] = $context[static::DEFAULT_CONSTRUCTOR_ARGUMENTS][$class][$key];\n                } elseif ($constructorParameter->isDefaultValueAvailable()) {\n                    $params[] = $constructorParameter->getDefaultValue();\n                } else {\n                    throw new MissingConstructorArgumentsException(sprintf('Cannot create an instance of %s from serialized data because its constructor requires parameter \"%s\" to be present.', $class, $constructorParameter->name));\n                }\n            }\n\n            if ($constructor->isConstructor()) {\n                return $reflectionClass->newInstanceArgs($params);\n            }\n\n            return $constructor->invokeArgs(null, $params);\n        }\n\n        return new $class();\n    }\n\n    protected function getClassDiscriminatorResolvedClass(array &$data, string $class): string\n    {\n        if (null === $this->classDiscriminatorResolver || (null === $mapping = $this->classDiscriminatorResolver->getMappingForClass($class))) {\n            return $class;\n        }\n\n        if (!isset($data[$mapping->getTypeProperty()])) {\n            throw new RuntimeException(sprintf('Type property \"%s\" not found for the abstract object \"%s\"', $mapping->getTypeProperty(), $class));\n        }\n\n        $type = $data[$mapping->getTypeProperty()];\n        if (null === ($mappedClass = $mapping->getClassForType($type))) {\n            throw new RuntimeException(sprintf('The type \"%s\" has no mapped class for the abstract object \"%s\"', $type, $class));\n        }\n\n        return $mappedClass;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function createConstructorArgument($parameterData, string $key, \\ReflectionParameter $constructorParameter, array &$context, string $format = null)\n    {\n        return $this->createAttributeValue($constructorParameter->name, $parameterData, $format, $context);\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * Unused in this context.\n     *\n     * @return string[]\n     */\n    protected function extractAttributes($object, $format = null, array $context = [])\n    {\n        return [];\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return array|bool\n     */\n    protected function getAllowedAttributes($classOrObject, array $context, $attributesAsString = false)\n    {\n        if (!$this->resourceClassResolver->isResourceClass($context['resource_class'])) {\n            return parent::getAllowedAttributes($classOrObject, $context, $attributesAsString);\n        }\n\n        $resourceClass = $this->resourceClassResolver->getResourceClass(null, $context['resource_class']); // fix for abstract classes and interfaces\n        $options = $this->getFactoryOptions($context);\n        $propertyNames = $this->propertyNameCollectionFactory->create($resourceClass, $options);\n\n        $allowedAttributes = [];\n        foreach ($propertyNames as $propertyName) {\n            $propertyMetadata = $this->propertyMetadataFactory->create($resourceClass, $propertyName, $options);\n\n            if (\n                $this->isAllowedAttribute($classOrObject, $propertyName, null, $context) &&\n                (\n                    isset($context['api_normalize']) && $propertyMetadata->isReadable() ||\n                    isset($context['api_denormalize']) && ($propertyMetadata->isWritable() || !\\is_object($classOrObject) && $propertyMetadata->isInitializable())\n                )\n            ) {\n                $allowedAttributes[] = $propertyName;\n            }\n        }\n\n        return $allowedAttributes;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @return bool\n     */\n    protected function isAllowedAttribute($classOrObject, $attribute, $format = null, array $context = [])\n    {\n        if (!parent::isAllowedAttribute($classOrObject, $attribute, $format, $context)) {\n            return false;\n        }\n\n        return $this->canAccessAttribute(\\is_object($classOrObject) ? $classOrObject : null, $attribute, $context);\n    }\n\n    /**\n     * Check if access to the attribute is granted.\n     *\n     * @param object $object\n     */\n    protected function canAccessAttribute($object, string $attribute, array $context = []): bool\n    {\n        if (!$this->resourceClassResolver->isResourceClass($context['resource_class'])) {\n            return true;\n        }\n\n        $options = $this->getFactoryOptions($context);\n        /** @var PropertyMetadata|ApiProperty */\n        $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $options);\n        $security = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getAttribute('security') : $propertyMetadata->getSecurity();\n        if ($this->resourceAccessChecker && $security) {\n            return $this->resourceAccessChecker->isGranted($context['resource_class'], $security, [\n                'object' => $object,\n            ]);\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if access to the attribute is granted.\n     *\n     * @param object      $object\n     * @param object|null $previousObject\n     */\n    protected function canAccessAttributePostDenormalize($object, $previousObject, string $attribute, array $context = []): bool\n    {\n        $options = $this->getFactoryOptions($context);\n        /** @var PropertyMetadata|ApiProperty */\n        $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $options);\n        $security = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getAttribute('security_post_denormalize') : $propertyMetadata->getSecurityPostDenormalize();\n        if ($this->resourceAccessChecker && $security) {\n            return $this->resourceAccessChecker->isGranted($context['resource_class'], $security, [\n                'object' => $object,\n                'previous_object' => $previousObject,\n            ]);\n        }\n\n        return true;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function setAttributeValue($object, $attribute, $value, $format = null, array $context = [])\n    {\n        $this->setValue($object, $attribute, $this->createAttributeValue($attribute, $value, $format, $context));\n    }\n\n    /**\n     * Validates the type of the value. Allows using integers as floats for JSON formats.\n     *\n     * @param mixed $value\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function validateType(string $attribute, Type $type, $value, string $format = null)\n    {\n        $builtinType = $type->getBuiltinType();\n        if (Type::BUILTIN_TYPE_FLOAT === $builtinType && null !== $format && false !== strpos($format, 'json')) {\n            $isValid = \\is_float($value) || \\is_int($value);\n        } else {\n            $isValid = \\call_user_func('is_'.$builtinType, $value);\n        }\n\n        if (!$isValid) {\n            throw new UnexpectedValueException(sprintf('The type of the \"%s\" attribute must be \"%s\", \"%s\" given.', $attribute, $builtinType, \\gettype($value)));\n        }\n    }\n\n    /**\n     * Denormalizes a collection of objects.\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     * @param mixed                        $value\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function denormalizeCollection(string $attribute, $propertyMetadata, Type $type, string $className, $value, ?string $format, array $context): array\n    {\n        if (!\\is_array($value)) {\n            throw new InvalidArgumentException(sprintf('The type of the \"%s\" attribute must be \"array\", \"%s\" given.', $attribute, \\gettype($value)));\n        }\n\n        $collectionKeyType = method_exists(Type::class, 'getCollectionKeyTypes') ? ($type->getCollectionKeyTypes()[0] ?? null) : $type->getCollectionKeyType();\n        $collectionKeyBuiltinType = null === $collectionKeyType ? null : $collectionKeyType->getBuiltinType();\n\n        $values = [];\n        foreach ($value as $index => $obj) {\n            if (null !== $collectionKeyBuiltinType && !\\call_user_func('is_'.$collectionKeyBuiltinType, $index)) {\n                throw new InvalidArgumentException(sprintf('The type of the key \"%s\" must be \"%s\", \"%s\" given.', $index, $collectionKeyBuiltinType, \\gettype($index)));\n            }\n\n            $values[$index] = $this->denormalizeRelation($attribute, $propertyMetadata, $className, $obj, $format, $this->createChildContext($context, $attribute, $format));\n        }\n\n        return $values;\n    }\n\n    /**\n     * Denormalizes a relation.\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     * @param mixed                        $value\n     *\n     * @throws LogicException\n     * @throws UnexpectedValueException\n     * @throws ItemNotFoundException\n     *\n     * @return object|null\n     */\n    protected function denormalizeRelation(string $attributeName, $propertyMetadata, string $className, $value, ?string $format, array $context)\n    {\n        $supportsPlainIdentifiers = $this->supportsPlainIdentifiers();\n\n        if (\\is_string($value)) {\n            try {\n                return $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getItemFromIri($value, $context + ['fetch_data' => true]) : $this->iriConverter->getResourceFromIri($value, $context + ['fetch_data' => true]);\n            } catch (ItemNotFoundException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw new UnexpectedValueException($e->getMessage(), $e->getCode(), $e);\n                }\n            } catch (InvalidArgumentException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw new UnexpectedValueException(sprintf('Invalid IRI \"%s\".', $value), $e->getCode(), $e);\n                }\n            }\n        }\n\n        if ($propertyMetadata->isWritableLink()) {\n            $context['api_allow_update'] = true;\n\n            if (!$this->serializer instanceof DenormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', DenormalizerInterface::class));\n            }\n\n            try {\n                $item = $this->serializer->denormalize($value, $className, $format, $context);\n                if (!\\is_object($item) && null !== $item) {\n                    throw new \\UnexpectedValueException('Expected item to be an object or null.');\n                }\n\n                return $item;\n            } catch (InvalidValueException $e) {\n                if (!$supportsPlainIdentifiers) {\n                    throw $e;\n                }\n            }\n        }\n\n        if (!\\is_array($value)) {\n            if (!$supportsPlainIdentifiers) {\n                throw new UnexpectedValueException(sprintf('Expected IRI or nested document for attribute \"%s\", \"%s\" given.', $attributeName, \\gettype($value)));\n            }\n\n            $item = $this->itemDataProvider->getItem($className, $value, null, $context + ['fetch_data' => true]);\n            if (null === $item) {\n                throw new ItemNotFoundException(sprintf('Item not found for resource \"%s\" with id \"%s\".', $className, $value));\n            }\n\n            return $item;\n        }\n\n        throw new UnexpectedValueException(sprintf('Nested documents for attribute \"%s\" are not allowed. Use IRIs instead.', $attributeName));\n    }\n\n    /**\n     * Gets the options for the property name collection / property metadata factories.\n     */\n    protected function getFactoryOptions(array $context): array\n    {\n        $options = [];\n\n        if (isset($context[self::GROUPS])) {\n            /* @see https://github.com/symfony/symfony/blob/v4.2.6/src/Symfony/Component/PropertyInfo/Extractor/SerializerExtractor.php */\n            $options['serializer_groups'] = (array) $context[self::GROUPS];\n        }\n\n        if (isset($context['resource_class']) && $this->resourceClassResolver->isResourceClass($context['resource_class']) && $this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass(null, $context['resource_class']); // fix for abstract classes and interfaces\n            // This is a hot spot, we should avoid calling this here but in many cases we can't\n            $operation = $context['root_operation'] ?? $context['operation'] ?? $this->resourceMetadataFactory->create($resourceClass)->getOperation($context['root_operation_name'] ?? $context['operation_name'] ?? null);\n            $options['normalization_groups'] = $operation->getNormalizationContext()['groups'] ?? null;\n            $options['denormalization_groups'] = $operation->getDenormalizationContext()['groups'] ?? null;\n        }\n\n        if (isset($context['operation_name'])) {\n            $options['operation_name'] = $context['operation_name'];\n        }\n\n        if (isset($context['collection_operation_name'])) {\n            $options['collection_operation_name'] = $context['collection_operation_name'];\n        }\n\n        if (isset($context['item_operation_name'])) {\n            $options['item_operation_name'] = $context['item_operation_name'];\n        }\n\n        return $options;\n    }\n\n    /**\n     * Creates the context to use when serializing a relation.\n     *\n     * @deprecated since version 2.1, to be removed in 3.0.\n     */\n    protected function createRelationSerializationContext(string $resourceClass, array $context): array\n    {\n        @trigger_error(sprintf('The method %s() is deprecated since 2.1 and will be removed in 3.0.', __METHOD__), \\E_USER_DEPRECATED);\n\n        return $context;\n    }\n\n    /**\n     * {@inheritdoc}\n     *\n     * @throws UnexpectedValueException\n     * @throws LogicException\n     *\n     * @return mixed\n     */\n    protected function getAttributeValue($object, $attribute, $format = null, array $context = [])\n    {\n        $context['api_attribute'] = $attribute;\n        /** @var ApiProperty|PropertyMetadata */\n        $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $this->getFactoryOptions($context));\n\n        try {\n            $attributeValue = $this->propertyAccessor->getValue($object, $attribute);\n        } catch (NoSuchPropertyException $e) {\n            // BC to be removed in 3.0\n            if ($propertyMetadata instanceof PropertyMetadata && !$propertyMetadata->hasChildInherited()) {\n                throw $e;\n            }\n            if ($propertyMetadata instanceof ApiProperty) {\n                throw $e;\n            }\n\n            $attributeValue = null;\n        }\n\n        if ($context['api_denormalize'] ?? false) {\n            return $attributeValue;\n        }\n\n        $type = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getType() : ($propertyMetadata->getBuiltinTypes()[0] ?? null);\n\n        if (\n            $type &&\n            $type->isCollection() &&\n            ($collectionValueType = method_exists(Type::class, 'getCollectionValueTypes') ? ($type->getCollectionValueTypes()[0] ?? null) : $type->getCollectionValueType()) &&\n            ($className = $collectionValueType->getClassName()) &&\n            $this->resourceClassResolver->isResourceClass($className)\n        ) {\n            if (!is_iterable($attributeValue)) {\n                throw new UnexpectedValueException('Unexpected non-iterable value for to-many relation.');\n            }\n\n            $resourceClass = $this->resourceClassResolver->getResourceClass($attributeValue, $className);\n            $childContext = $this->createChildContext($context, $attribute, $format);\n            $childContext['resource_class'] = $resourceClass;\n            if ($this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n                $childContext['operation'] = $this->resourceMetadataFactory->create($resourceClass)->getOperation();\n            }\n            unset($childContext['iri'], $childContext['uri_variables']);\n\n            return $this->normalizeCollectionOfRelations($propertyMetadata, $attributeValue, $resourceClass, $format, $childContext);\n        }\n\n        if (\n            $type &&\n            ($className = $type->getClassName()) &&\n            $this->resourceClassResolver->isResourceClass($className)\n        ) {\n            if (!\\is_object($attributeValue) && null !== $attributeValue) {\n                throw new UnexpectedValueException('Unexpected non-object value for to-one relation.');\n            }\n\n            $resourceClass = $this->resourceClassResolver->getResourceClass($attributeValue, $className);\n            $childContext = $this->createChildContext($context, $attribute, $format);\n            $childContext['resource_class'] = $resourceClass;\n            if ($this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n                $childContext['operation'] = $this->resourceMetadataFactory->create($resourceClass)->getOperation();\n            }\n            unset($childContext['iri'], $childContext['uri_variables']);\n\n            return $this->normalizeRelation($propertyMetadata, $attributeValue, $resourceClass, $format, $childContext);\n        }\n\n        if (!$this->serializer instanceof NormalizerInterface) {\n            throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', NormalizerInterface::class));\n        }\n\n        unset($context['resource_class']);\n\n        if ($type && $type->getClassName()) {\n            $childContext = $this->createChildContext($context, $attribute, $format);\n            unset($childContext['iri'], $childContext['uri_variables']);\n\n            if ($propertyMetadata instanceof PropertyMetadata) {\n                $childContext['output']['iri'] = $propertyMetadata->getIri() ?? false;\n            } else {\n                $childContext['output']['gen_id'] = $propertyMetadata->getGenId() ?? false;\n            }\n\n            return $this->serializer->normalize($attributeValue, $format, $childContext);\n        }\n\n        return $this->serializer->normalize($attributeValue, $format, $context);\n    }\n\n    /**\n     * Normalizes a collection of relations (to-many).\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     * @param iterable                     $attributeValue\n     *\n     * @throws UnexpectedValueException\n     */\n    protected function normalizeCollectionOfRelations($propertyMetadata, $attributeValue, string $resourceClass, ?string $format, array $context): array\n    {\n        $value = [];\n        foreach ($attributeValue as $index => $obj) {\n            if (!\\is_object($obj) && null !== $obj) {\n                throw new UnexpectedValueException('Unexpected non-object element in to-many relation.');\n            }\n\n            $value[$index] = $this->normalizeRelation($propertyMetadata, $obj, $resourceClass, $format, $context);\n        }\n\n        return $value;\n    }\n\n    /**\n     * Normalizes a relation.\n     *\n     * @param ApiProperty|PropertyMetadata $propertyMetadata\n     * @param object|null                  $relatedObject\n     *\n     * @throws LogicException\n     * @throws UnexpectedValueException\n     *\n     * @return string|array|\\ArrayObject|null IRI or normalized object data\n     */\n    protected function normalizeRelation($propertyMetadata, $relatedObject, string $resourceClass, ?string $format, array $context)\n    {\n        if (null === $relatedObject || !empty($context['attributes']) || $propertyMetadata->isReadableLink()) {\n            if (!$this->serializer instanceof NormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', NormalizerInterface::class));\n            }\n\n            $normalizedRelatedObject = $this->serializer->normalize($relatedObject, $format, $context);\n            // @phpstan-ignore-next-line throwing an explicit exception helps debugging\n            if (!\\is_string($normalizedRelatedObject) && !\\is_array($normalizedRelatedObject) && !$normalizedRelatedObject instanceof \\ArrayObject && null !== $normalizedRelatedObject) {\n                throw new UnexpectedValueException('Expected normalized relation to be an IRI, array, \\ArrayObject or null');\n            }\n\n            return $normalizedRelatedObject;\n        }\n\n        $iri = $this->iriConverter instanceof LegacyIriConverterInterface ? $this->iriConverter->getIriFromItem($relatedObject) : $this->iriConverter->getIriFromResource($relatedObject);\n\n        if (isset($context['resources'])) {\n            $context['resources'][$iri] = $iri;\n        }\n\n        $push = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getAttribute('push', false) : ($propertyMetadata->getPush() ?? false);\n        if (isset($context['resources_to_push']) && $push) {\n            $context['resources_to_push'][$iri] = $iri;\n        }\n\n        return $iri;\n    }\n\n    /**\n     * Finds the first supported data transformer if any.\n     *\n     * @param object|array $data object on normalize / array on denormalize\n     */\n    protected function getDataTransformer($data, string $to, array $context = []): ?DataTransformerInterface\n    {\n        foreach ($this->dataTransformers as $dataTransformer) {\n            if ($dataTransformer->supportsTransformation($data, $to, $context)) {\n                return $dataTransformer;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * For a given resource, it returns an output representation if any\n     * If not, the resource is returned.\n     *\n     * @param mixed $object\n     */\n    protected function transformOutput($object, array $context = [], string $outputClass = null)\n    {\n    }\n\n    private function createAttributeValue($attribute, $value, $format = null, array $context = [])\n    {\n        if (!$this->resourceClassResolver->isResourceClass($context['resource_class'])) {\n            return $value;\n        }\n\n        /** @var ApiProperty|PropertyMetadata */\n        $propertyMetadata = $this->propertyMetadataFactory->create($context['resource_class'], $attribute, $this->getFactoryOptions($context));\n        $type = $propertyMetadata instanceof PropertyMetadata ? $propertyMetadata->getType() : ($propertyMetadata->getBuiltinTypes()[0] ?? null);\n\n        if (null === $type) {\n            // No type provided, blindly return the value\n            return $value;\n        }\n\n        if (null === $value && $type->isNullable()) {\n            return $value;\n        }\n\n        $collectionValueType = method_exists(Type::class, 'getCollectionValueTypes') ? ($type->getCollectionValueTypes()[0] ?? null) : $type->getCollectionValueType();\n\n        /* From @see AbstractObjectNormalizer::validateAndDenormalize() */\n        // Fix a collection that contains the only one element\n        // This is special to xml format only\n        if ('xml' === $format && null !== $collectionValueType && (!\\is_array($value) || !\\is_int(key($value)))) {\n            $value = [$value];\n        }\n\n        if (\n            $type->isCollection() &&\n            null !== $collectionValueType &&\n            null !== ($className = $collectionValueType->getClassName()) &&\n            $this->resourceClassResolver->isResourceClass($className)\n        ) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass(null, $className);\n            $context['resource_class'] = $resourceClass;\n\n            return $this->denormalizeCollection($attribute, $propertyMetadata, $type, $resourceClass, $value, $format, $context);\n        }\n\n        if (\n            null !== ($className = $type->getClassName()) &&\n            $this->resourceClassResolver->isResourceClass($className)\n        ) {\n            $resourceClass = $this->resourceClassResolver->getResourceClass(null, $className);\n            $childContext = $this->createChildContext($context, $attribute, $format);\n            $childContext['resource_class'] = $resourceClass;\n            if ($this->resourceMetadataFactory instanceof ResourceMetadataCollectionFactoryInterface) {\n                $childContext['operation'] = $this->resourceMetadataFactory->create($resourceClass)->getOperation();\n            }\n\n            return $this->denormalizeRelation($attribute, $propertyMetadata, $resourceClass, $value, $format, $childContext);\n        }\n\n        if (\n            $type->isCollection() &&\n            null !== $collectionValueType &&\n            null !== ($className = $collectionValueType->getClassName())\n        ) {\n            if (!$this->serializer instanceof DenormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', DenormalizerInterface::class));\n            }\n\n            unset($context['resource_class']);\n\n            return $this->serializer->denormalize($value, $className.'[]', $format, $context);\n        }\n\n        if (null !== $className = $type->getClassName()) {\n            if (!$this->serializer instanceof DenormalizerInterface) {\n                throw new LogicException(sprintf('The injected serializer must be an instance of \"%s\".', DenormalizerInterface::class));\n            }\n\n            unset($context['resource_class']);\n\n            return $this->serializer->denormalize($value, $className, $format, $context);\n        }\n\n        /* From @see AbstractObjectNormalizer::validateAndDenormalize() */\n        // In XML and CSV all basic datatypes are represented as strings, it is e.g. not possible to determine,\n        // if a value is meant to be a string, float, int or a boolean value from the serialized representation.\n        // That's why we have to transform the values, if one of these non-string basic datatypes is expected.\n        if (\\is_string($value) && (XmlEncoder::FORMAT === $format || CsvEncoder::FORMAT === $format)) {\n            if ('' === $value && $type->isNullable() && \\in_array($type->getBuiltinType(), [Type::BUILTIN_TYPE_BOOL, Type::BUILTIN_TYPE_INT, Type::BUILTIN_TYPE_FLOAT], true)) {\n                return null;\n            }\n\n            switch ($type->getBuiltinType()) {\n                case Type::BUILTIN_TYPE_BOOL:\n                    // according to https://www.w3.org/TR/xmlschema-2/#boolean, valid representations are \"false\", \"true\", \"0\" and \"1\"\n                    if ('false' === $value || '0' === $value) {\n                        $value = false;\n                    } elseif ('true' === $value || '1' === $value) {\n                        $value = true;\n                    } else {\n                        throw new NotNormalizableValueException(sprintf('The type of the \"%s\" attribute for class \"%s\" must be bool (\"%s\" given).', $attribute, $className, $value));\n                    }\n                    break;\n                case Type::BUILTIN_TYPE_INT:\n                    if (ctype_digit($value) || ('-' === $value[0] && ctype_digit(substr($value, 1)))) {\n                        $value = (int) $value;\n                    } else {\n                        throw new NotNormalizableValueException(sprintf('The type of the \"%s\" attribute for class \"%s\" must be int (\"%s\" given).', $attribute, $className, $value));\n                    }\n                    break;\n                case Type::BUILTIN_TYPE_FLOAT:\n                    if (is_numeric($value)) {\n                        return (float) $value;\n                    }\n\n                    switch ($value) {\n                        case 'NaN':\n                            return \\NAN;\n                        case 'INF':\n                            return \\INF;\n                        case '-INF':\n                            return -\\INF;\n                        default:\n                            throw new NotNormalizableValueException(sprintf('The type of the \"%s\" attribute for class \"%s\" must be float (\"%s\" given).', $attribute, $className, $value));\n                    }\n            }\n        }\n\n        if ($context[static::DISABLE_TYPE_ENFORCEMENT] ?? false) {\n            return $value;\n        }\n\n        $this->validateType($attribute, $type, $value, $format);\n\n        return $value;\n    }\n\n    /**\n     * Sets a value of the object using the PropertyAccess component.\n     *\n     * @param object $object\n     * @param mixed  $value\n     */\n    private function setValue($object, string $attributeName, $value)\n    {\n        try {\n            $this->propertyAccessor->setValue($object, $attributeName, $value);\n        } catch (NoSuchPropertyException $exception) {\n            // Properties not found are ignored\n        }\n    }\n\n    /**\n     * TODO: to remove in 3.0.\n     *\n     * @deprecated since 2.7\n     */\n    private function supportsPlainIdentifiers(): bool\n    {\n        return $this->allowPlainIdentifiers && null !== $this->itemDataProvider;\n    }\n}\n\nclass_alias(AbstractItemNormalizer::class, \\ApiPlatform\\Core\\Serializer\\AbstractItemNormalizer::class);\n", "<?php\n\n/*\n * This file is part of the API Platform project.\n *\n * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ndeclare(strict_types=1);\n\nnamespace ApiPlatform\\Serializer;\n\n/**\n * Used to override Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer::getCacheKey which is private\n * We need the cache_key in JsonApi and Hal before it is computed in Symfony.\n *\n * @see https://github.com/symfony/symfony/blob/49b6ab853d81e941736a1af67845efa3401e7278/src/Symfony/Component/Serializer/Normalizer/AbstractObjectNormalizer.php#L723 which isn't protected\n */\ntrait CacheKeyTrait\n{\n    /**\n     * @return string|bool\n     */\n    private function getCacheKey(?string $format, array $context)\n    {\n        foreach ($context[self::EXCLUDE_FROM_CACHE_KEY] ?? $this->defaultContext[self::EXCLUDE_FROM_CACHE_KEY] as $key) {\n            unset($context[$key]);\n        }\n        unset($context[self::EXCLUDE_FROM_CACHE_KEY]);\n        unset($context[self::OBJECT_TO_POPULATE]);\n        unset($context['cache_key']); // avoid artificially different keys\n\n        try {\n            return hash('xxh128', $format.serialize([\n                'context' => $context,\n                'ignored' => $context[self::IGNORED_ATTRIBUTES] ?? $this->defaultContext[self::IGNORED_ATTRIBUTES],\n            ]));\n        } catch (\\Exception) {\n            // The context cannot be serialized, skip the cache\n            return false;\n        }\n    }\n}\n\nclass_alias(CacheKeyTrait::class, \\ApiPlatform\\Core\\Serializer\\CacheKeyTrait::class);\n"], "filenames": ["features/authorization/deny.feature", "src/Hal/Serializer/ItemNormalizer.php", "src/JsonApi/Serializer/ItemNormalizer.php", "src/Serializer/AbstractItemNormalizer.php", "src/Serializer/CacheKeyTrait.php"], "buggy_code_start_loc": [183, 65, 81, 29, 15], "buggy_code_end_loc": [183, 76, 92, 209, 32], "fixing_code_start_loc": [184, 64, 81, 30, 16], "fixing_code_end_loc": [206, 77, 93, 216, 42], "type": "CWE-863", "message": "API Platform Core is the server component of API Platform: hypermedia and GraphQL APIs. Resource properties secured with the `security` option of the `ApiPlatform\\Metadata\\ApiProperty` attribute can be disclosed to unauthorized users. The problem affects most serialization formats, including raw JSON, which is enabled by default when installing API Platform. Custom serialization formats may also be impacted. Only collection endpoints are affected by the issue, item endpoints are not. The JSON-LD format is not affected by the issue. The result of the security rule is only executed for the first item of the collection. The result of the rule is then cached and reused for the next items. This bug can leak data to unauthorized users when the rule depends on the value of a property of the item. This bug can also hide properties that should be displayed to authorized users. This issue impacts the 2.7, 3.0 and 3.1 branches. Please upgrade to versions 2.7.10, 3.0.12 or 3.1.3. As a workaround, replace the `cache_key` of the context array of the Serializer inside a custom normalizer that works on objects if the security option of the `ApiPlatform\\Metadata\\ApiProperty` attribute is used.", "other": {"cve": {"id": "CVE-2023-25575", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-28T23:15:11.553", "lastModified": "2023-03-13T16:05:57.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "API Platform Core is the server component of API Platform: hypermedia and GraphQL APIs. Resource properties secured with the `security` option of the `ApiPlatform\\Metadata\\ApiProperty` attribute can be disclosed to unauthorized users. The problem affects most serialization formats, including raw JSON, which is enabled by default when installing API Platform. Custom serialization formats may also be impacted. Only collection endpoints are affected by the issue, item endpoints are not. The JSON-LD format is not affected by the issue. The result of the security rule is only executed for the first item of the collection. The result of the rule is then cached and reused for the next items. This bug can leak data to unauthorized users when the rule depends on the value of a property of the item. This bug can also hide properties that should be displayed to authorized users. This issue impacts the 2.7, 3.0 and 3.1 branches. Please upgrade to versions 2.7.10, 3.0.12 or 3.1.3. As a workaround, replace the `cache_key` of the context array of the Serializer inside a custom normalizer that works on objects if the security option of the `ApiPlatform\\Metadata\\ApiProperty` attribute is used."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-842"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:api-platform:core:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndExcluding": "2.7.10", "matchCriteriaId": "024903BC-5E39-4043-9DD1-C5A930CC3DF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:api-platform:core:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.12", "matchCriteriaId": "86D99A32-DD68-4BC9-B204-26371066E5BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:api-platform:core:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1.0", "versionEndExcluding": "3.1.3", "matchCriteriaId": "A5D9B7FE-2AD0-4320-9E65-EDB326BF19F3"}]}]}], "references": [{"url": "https://github.com/api-platform/core/commit/5723d68369722feefeb11e42528d9580db5dd0fb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/api-platform/core/security/advisories/GHSA-vr2x-7687-h6qv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/api-platform/core/commit/5723d68369722feefeb11e42528d9580db5dd0fb"}}