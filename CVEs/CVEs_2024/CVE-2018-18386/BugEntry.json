{"buggy_code": ["// SPDX-License-Identifier: GPL-1.0+\n/*\n * n_tty.c --- implements the N_TTY line discipline.\n *\n * This code used to be in tty_io.c, but things are getting hairy\n * enough that it made sense to split things off.  (The N_TTY\n * processing has changed so much that it's hardly recognizable,\n * anyway...)\n *\n * Note that the open routine for N_TTY is guaranteed never to return\n * an error.  This is because Linux will fall back to setting a line\n * to N_TTY if it can not switch to any other line discipline.\n *\n * Written by Theodore Ts'o, Copyright 1994.\n *\n * This file also contains code originally written by Linus Torvalds,\n * Copyright 1991, 1992, 1993, and by Julian Cowley, Copyright 1994.\n *\n * Reduced memory usage for older ARM systems  - Russell King.\n *\n * 2000/01/20   Fixed SMP locking on put_tty_queue using bits of\n *\t\tthe patch by Andrew J. Kroll <ag784@freenet.buffalo.edu>\n *\t\twho actually finally proved there really was a race.\n *\n * 2002/03/18   Implemented n_tty_wakeup to send SIGIO POLL_OUTs to\n *\t\twaiting writing processes-Sapan Bhatia <sapan@corewars.org>.\n *\t\tAlso fixed a bug in BLOCKING mode where n_tty_write returns\n *\t\tEAGAIN\n */\n\n#include <linux/types.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/fcntl.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/timer.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/bitops.h>\n#include <linux/audit.h>\n#include <linux/file.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ratelimit.h>\n#include <linux/vmalloc.h>\n\n\n/* number of characters left in xmit buffer before select has we have room */\n#define WAKEUP_CHARS 256\n\n/*\n * This defines the low- and high-watermarks for throttling and\n * unthrottling the TTY driver.  These watermarks are used for\n * controlling the space in the read buffer.\n */\n#define TTY_THRESHOLD_THROTTLE\t\t128 /* now based on remaining room */\n#define TTY_THRESHOLD_UNTHROTTLE\t128\n\n/*\n * Special byte codes used in the echo buffer to represent operations\n * or special handling of characters.  Bytes in the echo buffer that\n * are not part of such special blocks are treated as normal character\n * codes.\n */\n#define ECHO_OP_START 0xff\n#define ECHO_OP_MOVE_BACK_COL 0x80\n#define ECHO_OP_SET_CANON_COL 0x81\n#define ECHO_OP_ERASE_TAB 0x82\n\n#define ECHO_COMMIT_WATERMARK\t256\n#define ECHO_BLOCK\t\t256\n#define ECHO_DISCARD_WATERMARK\tN_TTY_BUF_SIZE - (ECHO_BLOCK + 32)\n\n\n#undef N_TTY_TRACE\n#ifdef N_TTY_TRACE\n# define n_tty_trace(f, args...)\ttrace_printk(f, ##args)\n#else\n# define n_tty_trace(f, args...)\n#endif\n\nstruct n_tty_data {\n\t/* producer-published */\n\tsize_t read_head;\n\tsize_t commit_head;\n\tsize_t canon_head;\n\tsize_t echo_head;\n\tsize_t echo_commit;\n\tsize_t echo_mark;\n\tDECLARE_BITMAP(char_map, 256);\n\n\t/* private to n_tty_receive_overrun (single-threaded) */\n\tunsigned long overrun_time;\n\tint num_overrun;\n\n\t/* non-atomic */\n\tbool no_room;\n\n\t/* must hold exclusive termios_rwsem to reset these */\n\tunsigned char lnext:1, erasing:1, raw:1, real_raw:1, icanon:1;\n\tunsigned char push:1;\n\n\t/* shared by producer and consumer */\n\tchar read_buf[N_TTY_BUF_SIZE];\n\tDECLARE_BITMAP(read_flags, N_TTY_BUF_SIZE);\n\tunsigned char echo_buf[N_TTY_BUF_SIZE];\n\n\t/* consumer-published */\n\tsize_t read_tail;\n\tsize_t line_start;\n\n\t/* protected by output lock */\n\tunsigned int column;\n\tunsigned int canon_column;\n\tsize_t echo_tail;\n\n\tstruct mutex atomic_read_lock;\n\tstruct mutex output_lock;\n};\n\nstatic inline size_t read_cnt(struct n_tty_data *ldata)\n{\n\treturn ldata->read_head - ldata->read_tail;\n}\n\nstatic inline unsigned char read_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char *read_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char echo_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char *echo_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic int tty_copy_to_user(struct tty_struct *tty, void __user *to,\n\t\t\t    size_t tail, size_t n)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t size = N_TTY_BUF_SIZE - tail;\n\tconst void *from = read_buf_addr(ldata, tail);\n\tint uncopied;\n\n\tif (n > size) {\n\t\ttty_audit_add_data(tty, from, size);\n\t\tuncopied = copy_to_user(to, from, size);\n\t\tif (uncopied)\n\t\t\treturn uncopied;\n\t\tto += size;\n\t\tn -= size;\n\t\tfrom = ldata->read_buf;\n\t}\n\n\ttty_audit_add_data(tty, from, n);\n\treturn copy_to_user(to, from, n);\n}\n\n/**\n *\tn_tty_kick_worker - start input worker (if required)\n *\t@tty: terminal\n *\n *\tRe-schedules the flip buffer work if it may have stopped\n *\n *\tCaller holds exclusive termios_rwsem\n *\t   or\n *\tn_tty_read()/consumer path:\n *\t\tholds non-exclusive termios_rwsem\n */\n\nstatic void n_tty_kick_worker(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t/* Did the input worker stop? Restart it */\n\tif (unlikely(ldata->no_room)) {\n\t\tldata->no_room = 0;\n\n\t\tWARN_RATELIMIT(tty->port->itty == NULL,\n\t\t\t\t\"scheduling with invalid itty\\n\");\n\t\t/* see if ldisc has been killed - if so, this means that\n\t\t * even though the ldisc has been halted and ->buf.work\n\t\t * cancelled, ->buf.work is about to be rescheduled\n\t\t */\n\t\tWARN_RATELIMIT(test_bit(TTY_LDISC_HALTED, &tty->flags),\n\t\t\t       \"scheduling buffer work for halted ldisc\\n\");\n\t\ttty_buffer_restart_work(tty->port);\n\t}\n}\n\nstatic ssize_t chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tssize_t n = 0;\n\n\tif (!ldata->icanon)\n\t\tn = ldata->commit_head - ldata->read_tail;\n\telse\n\t\tn = ldata->canon_head - ldata->read_tail;\n\treturn n;\n}\n\n/**\n *\tn_tty_write_wakeup\t-\tasynchronous I/O notifier\n *\t@tty: tty device\n *\n *\tRequired for the ptys, serial driver etc. since processes\n *\tthat attach themselves to the master and rely on ASYNC\n *\tIO must be woken up\n */\n\nstatic void n_tty_write_wakeup(struct tty_struct *tty)\n{\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tkill_fasync(&tty->fasync, SIGIO, POLL_OUT);\n}\n\nstatic void n_tty_check_throttle(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t/*\n\t * Check the remaining room for the input canonicalization\n\t * mode.  We don't want to throttle the driver if we're in\n\t * canonical mode and don't have a newline yet!\n\t */\n\tif (ldata->icanon && ldata->canon_head == ldata->read_tail)\n\t\treturn;\n\n\twhile (1) {\n\t\tint throttled;\n\t\ttty_set_flow_change(tty, TTY_THROTTLE_SAFE);\n\t\tif (N_TTY_BUF_SIZE - read_cnt(ldata) >= TTY_THRESHOLD_THROTTLE)\n\t\t\tbreak;\n\t\tthrottled = tty_throttle_safe(tty);\n\t\tif (!throttled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\nstatic void n_tty_check_unthrottle(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\treturn;\n\t\tn_tty_kick_worker(tty);\n\t\ttty_wakeup(tty->link);\n\t\treturn;\n\t}\n\n\t/* If there is enough space in the read buffer now, let the\n\t * low-level driver know. We use chars_in_buffer() to\n\t * check the buffer, as it now knows about canonical mode.\n\t * Otherwise, if the driver is throttled and the line is\n\t * longer than TTY_THRESHOLD_UNTHROTTLE in canonical mode,\n\t * we won't get any more characters.\n\t */\n\n\twhile (1) {\n\t\tint unthrottled;\n\t\ttty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\tbreak;\n\t\tn_tty_kick_worker(tty);\n\t\tunthrottled = tty_unthrottle_safe(tty);\n\t\tif (!unthrottled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\n/**\n *\tput_tty_queue\t\t-\tadd character to tty\n *\t@c: character\n *\t@ldata: n_tty data\n *\n *\tAdd a character to the tty read_buf queue.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n */\n\nstatic inline void put_tty_queue(unsigned char c, struct n_tty_data *ldata)\n{\n\t*read_buf_addr(ldata, ldata->read_head) = c;\n\tldata->read_head++;\n}\n\n/**\n *\treset_buffer_flags\t-\treset buffer state\n *\t@tty: terminal to reset\n *\n *\tReset the read buffer counters and clear the flags.\n *\tCalled from n_tty_open() and n_tty_flush_buffer().\n *\n *\tLocking: caller holds exclusive termios_rwsem\n *\t\t (or locking is not required)\n */\n\nstatic void reset_buffer_flags(struct n_tty_data *ldata)\n{\n\tldata->read_head = ldata->canon_head = ldata->read_tail = 0;\n\tldata->echo_head = ldata->echo_tail = ldata->echo_commit = 0;\n\tldata->commit_head = 0;\n\tldata->echo_mark = 0;\n\tldata->line_start = 0;\n\n\tldata->erasing = 0;\n\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\tldata->push = 0;\n}\n\nstatic void n_tty_packet_mode_flush(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tif (tty->link->packet) {\n\t\tspin_lock_irqsave(&tty->ctrl_lock, flags);\n\t\ttty->ctrl_status |= TIOCPKT_FLUSHREAD;\n\t\tspin_unlock_irqrestore(&tty->ctrl_lock, flags);\n\t\twake_up_interruptible(&tty->link->read_wait);\n\t}\n}\n\n/**\n *\tn_tty_flush_buffer\t-\tclean input queue\n *\t@tty:\tterminal device\n *\n *\tFlush the input buffer. Called when the tty layer wants the\n *\tbuffer flushed (eg at hangup) or when the N_TTY line discipline\n *\tinternally has to clean the pending queue (for example some signals).\n *\n *\tHolds termios_rwsem to exclude producer/consumer while\n *\tbuffer indices are reset.\n *\n *\tLocking: ctrl_lock, exclusive termios_rwsem\n */\n\nstatic void n_tty_flush_buffer(struct tty_struct *tty)\n{\n\tdown_write(&tty->termios_rwsem);\n\treset_buffer_flags(tty->disc_data);\n\tn_tty_kick_worker(tty);\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tup_write(&tty->termios_rwsem);\n}\n\n/**\n *\tis_utf8_continuation\t-\tutf8 multibyte check\n *\t@c: byte to check\n *\n *\tReturns true if the utf8 character 'c' is a multibyte continuation\n *\tcharacter. We use this to correctly compute the on screen size\n *\tof the character when printing\n */\n\nstatic inline int is_utf8_continuation(unsigned char c)\n{\n\treturn (c & 0xc0) == 0x80;\n}\n\n/**\n *\tis_continuation\t\t-\tmultibyte check\n *\t@c: byte to check\n *\n *\tReturns true if the utf8 character 'c' is a multibyte continuation\n *\tcharacter and the terminal is in unicode mode.\n */\n\nstatic inline int is_continuation(unsigned char c, struct tty_struct *tty)\n{\n\treturn I_IUTF8(tty) && is_utf8_continuation(c);\n}\n\n/**\n *\tdo_output_char\t\t\t-\toutput one character\n *\t@c: character (or partial unicode symbol)\n *\t@tty: terminal device\n *\t@space: space available in tty driver write buffer\n *\n *\tThis is a helper function that handles one output character\n *\t(including special characters like TAB, CR, LF, etc.),\n *\tdoing OPOST processing and putting the results in the\n *\ttty driver's write buffer.\n *\n *\tNote that Linux currently ignores TABDLY, CRDLY, VTDLY, FFDLY\n *\tand NLDLY.  They simply aren't relevant in the world today.\n *\tIf you ever need them, add them here.\n *\n *\tReturns the number of bytes of buffer space used or -1 if\n *\tno space left.\n *\n *\tLocking: should be called under the output_lock to protect\n *\t\t the column state and space left in the buffer\n */\n\nstatic int do_output_char(unsigned char c, struct tty_struct *tty, int space)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspaces;\n\n\tif (!space)\n\t\treturn -1;\n\n\tswitch (c) {\n\tcase '\\n':\n\t\tif (O_ONLRET(tty))\n\t\t\tldata->column = 0;\n\t\tif (O_ONLCR(tty)) {\n\t\t\tif (space < 2)\n\t\t\t\treturn -1;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\ttty->ops->write(tty, \"\\r\\n\", 2);\n\t\t\treturn 2;\n\t\t}\n\t\tldata->canon_column = ldata->column;\n\t\tbreak;\n\tcase '\\r':\n\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\treturn 0;\n\t\tif (O_OCRNL(tty)) {\n\t\t\tc = '\\n';\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\t}\n\t\tldata->canon_column = ldata->column = 0;\n\t\tbreak;\n\tcase '\\t':\n\t\tspaces = 8 - (ldata->column & 7);\n\t\tif (O_TABDLY(tty) == XTABS) {\n\t\t\tif (space < spaces)\n\t\t\t\treturn -1;\n\t\t\tldata->column += spaces;\n\t\t\ttty->ops->write(tty, \"        \", spaces);\n\t\t\treturn spaces;\n\t\t}\n\t\tldata->column += spaces;\n\t\tbreak;\n\tcase '\\b':\n\t\tif (ldata->column > 0)\n\t\t\tldata->column--;\n\t\tbreak;\n\tdefault:\n\t\tif (!iscntrl(c)) {\n\t\t\tif (O_OLCUC(tty))\n\t\t\t\tc = toupper(c);\n\t\t\tif (!is_continuation(c, tty))\n\t\t\t\tldata->column++;\n\t\t}\n\t\tbreak;\n\t}\n\n\ttty_put_char(tty, c);\n\treturn 1;\n}\n\n/**\n *\tprocess_output\t\t\t-\toutput post processor\n *\t@c: character (or partial unicode symbol)\n *\t@tty: terminal device\n *\n *\tOutput one character with OPOST processing.\n *\tReturns -1 when the output device is full and the character\n *\tmust be retried.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (also, this is called from n_tty_write under the\n *\t\t  tty layer write lock)\n */\n\nstatic int process_output(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, retval;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tretval = do_output_char(c, tty, space);\n\n\tmutex_unlock(&ldata->output_lock);\n\tif (retval < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\n/**\n *\tprocess_output_block\t\t-\tblock post processor\n *\t@tty: terminal device\n *\t@buf: character buffer\n *\t@nr: number of bytes to output\n *\n *\tOutput a block of characters with OPOST processing.\n *\tReturns the number of characters output.\n *\n *\tThis path is used to speed up block console writes, among other\n *\tthings when processing blocks of output data. It handles only\n *\tthe simple cases normally found and helps to generate blocks of\n *\tsymbols for the console driver and thus improve performance.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (also, this is called from n_tty_write under the\n *\t\t  tty layer write lock)\n */\n\nstatic ssize_t process_output_block(struct tty_struct *tty,\n\t\t\t\t    const unsigned char *buf, unsigned int nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace;\n\tint\ti;\n\tconst unsigned char *cp;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tif (!space) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn 0;\n\t}\n\tif (nr > space)\n\t\tnr = space;\n\n\tfor (i = 0, cp = buf; i < nr; i++, cp++) {\n\t\tunsigned char c = *cp;\n\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->column = 0;\n\t\t\tif (O_ONLCR(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column;\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\t\tgoto break_out;\n\t\t\tif (O_OCRNL(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tgoto break_out;\n\t\tcase '\\b':\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(c)) {\n\t\t\t\tif (O_OLCUC(tty))\n\t\t\t\t\tgoto break_out;\n\t\t\t\tif (!is_continuation(c, tty))\n\t\t\t\t\tldata->column++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nbreak_out:\n\ti = tty->ops->write(tty, buf, i);\n\n\tmutex_unlock(&ldata->output_lock);\n\treturn i;\n}\n\n/**\n *\tprocess_echoes\t-\twrite pending echo characters\n *\t@tty: terminal device\n *\n *\tWrite previously buffered echo (and other ldisc-generated)\n *\tcharacters to the tty.\n *\n *\tCharacters generated by the ldisc (including echoes) need to\n *\tbe buffered because the driver's write buffer can fill during\n *\theavy program output.  Echoing straight to the driver will\n *\toften fail under these conditions, causing lost characters and\n *\tresulting mismatches of ldisc state information.\n *\n *\tSince the ldisc state must represent the characters actually sent\n *\tto the driver at the time of the write, operations like certain\n *\tchanges in column state are also saved in the buffer and executed\n *\there.\n *\n *\tA circular fifo buffer is used so that the most recent characters\n *\tare prioritized.  Also, when control characters are echoed with a\n *\tprefixed \"^\", the pair is treated atomically and thus not separated.\n *\n *\tLocking: callers must hold output_lock\n */\n\nstatic size_t __process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, old_space;\n\tsize_t tail;\n\tunsigned char c;\n\n\told_space = space = tty_write_room(tty);\n\n\ttail = ldata->echo_tail;\n\twhile (ldata->echo_commit != tail) {\n\t\tc = echo_buf(ldata, tail);\n\t\tif (c == ECHO_OP_START) {\n\t\t\tunsigned char op;\n\t\t\tint no_space_left = 0;\n\n\t\t\t/*\n\t\t\t * If the buffer byte is the start of a multi-byte\n\t\t\t * operation, get the next byte, which is either the\n\t\t\t * op code or a control character value.\n\t\t\t */\n\t\t\top = echo_buf(ldata, tail + 1);\n\n\t\t\tswitch (op) {\n\t\t\t\tunsigned int num_chars, num_bs;\n\n\t\t\tcase ECHO_OP_ERASE_TAB:\n\t\t\t\tnum_chars = echo_buf(ldata, tail + 2);\n\n\t\t\t\t/*\n\t\t\t\t * Determine how many columns to go back\n\t\t\t\t * in order to erase the tab.\n\t\t\t\t * This depends on the number of columns\n\t\t\t\t * used by other characters within the tab\n\t\t\t\t * area.  If this (modulo 8) count is from\n\t\t\t\t * the start of input rather than from a\n\t\t\t\t * previous tab, we offset by canon column.\n\t\t\t\t * Otherwise, tab spacing is normal.\n\t\t\t\t */\n\t\t\t\tif (!(num_chars & 0x80))\n\t\t\t\t\tnum_chars += ldata->canon_column;\n\t\t\t\tnum_bs = 8 - (num_chars & 7);\n\n\t\t\t\tif (num_bs > space) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspace -= num_bs;\n\t\t\t\twhile (num_bs--) {\n\t\t\t\t\ttty_put_char(tty, '\\b');\n\t\t\t\t\tif (ldata->column > 0)\n\t\t\t\t\t\tldata->column--;\n\t\t\t\t}\n\t\t\t\ttail += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_SET_CANON_COL:\n\t\t\t\tldata->canon_column = ldata->column;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_MOVE_BACK_COL:\n\t\t\t\tif (ldata->column > 0)\n\t\t\t\t\tldata->column--;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_START:\n\t\t\t\t/* This is an escaped echo op start code */\n\t\t\t\tif (!space) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty_put_char(tty, ECHO_OP_START);\n\t\t\t\tldata->column++;\n\t\t\t\tspace--;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * If the op is not a special byte code,\n\t\t\t\t * it is a ctrl char tagged to be echoed\n\t\t\t\t * as \"^X\" (where X is the letter\n\t\t\t\t * representing the control char).\n\t\t\t\t * Note that we must ensure there is\n\t\t\t\t * enough space for the whole ctrl pair.\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (space < 2) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty_put_char(tty, '^');\n\t\t\t\ttty_put_char(tty, op ^ 0100);\n\t\t\t\tldata->column += 2;\n\t\t\t\tspace -= 2;\n\t\t\t\ttail += 2;\n\t\t\t}\n\n\t\t\tif (no_space_left)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (O_OPOST(tty)) {\n\t\t\t\tint retval = do_output_char(c, tty, space);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tspace -= retval;\n\t\t\t} else {\n\t\t\t\tif (!space)\n\t\t\t\t\tbreak;\n\t\t\t\ttty_put_char(tty, c);\n\t\t\t\tspace -= 1;\n\t\t\t}\n\t\t\ttail += 1;\n\t\t}\n\t}\n\n\t/* If the echo buffer is nearly full (so that the possibility exists\n\t * of echo overrun before the next commit), then discard enough\n\t * data at the tail to prevent a subsequent overrun */\n\twhile (ldata->echo_commit - tail >= ECHO_DISCARD_WATERMARK) {\n\t\tif (echo_buf(ldata, tail) == ECHO_OP_START) {\n\t\t\tif (echo_buf(ldata, tail + 1) == ECHO_OP_ERASE_TAB)\n\t\t\t\ttail += 3;\n\t\t\telse\n\t\t\t\ttail += 2;\n\t\t} else\n\t\t\ttail++;\n\t}\n\n\tldata->echo_tail = tail;\n\treturn old_space - space;\n}\n\nstatic void commit_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t nr, old, echoed;\n\tsize_t head;\n\n\thead = ldata->echo_head;\n\tldata->echo_mark = head;\n\told = ldata->echo_commit - ldata->echo_tail;\n\n\t/* Process committed echoes if the accumulated # of bytes\n\t * is over the threshold (and try again each time another\n\t * block is accumulated) */\n\tnr = head - ldata->echo_tail;\n\tif (nr < ECHO_COMMIT_WATERMARK || (nr % ECHO_BLOCK > old % ECHO_BLOCK))\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = head;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\nstatic void process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t echoed;\n\n\tif (ldata->echo_mark == ldata->echo_tail)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_mark;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\n/* NB: echo_mark and echo_head should be equivalent here */\nstatic void flush_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif ((!L_ECHO(tty) && !L_ECHONL(tty)) ||\n\t    ldata->echo_commit == ldata->echo_head)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_head;\n\t__process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n}\n\n/**\n *\tadd_echo_byte\t-\tadd a byte to the echo buffer\n *\t@c: unicode byte to echo\n *\t@ldata: n_tty data\n *\n *\tAdd a character or operation byte to the echo buffer.\n */\n\nstatic inline void add_echo_byte(unsigned char c, struct n_tty_data *ldata)\n{\n\t*echo_buf_addr(ldata, ldata->echo_head++) = c;\n}\n\n/**\n *\techo_move_back_col\t-\tadd operation to move back a column\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to move back one column.\n */\n\nstatic void echo_move_back_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_MOVE_BACK_COL, ldata);\n}\n\n/**\n *\techo_set_canon_col\t-\tadd operation to set the canon column\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to set the canon column\n *\tto the current column.\n */\n\nstatic void echo_set_canon_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_SET_CANON_COL, ldata);\n}\n\n/**\n *\techo_erase_tab\t-\tadd operation to erase a tab\n *\t@num_chars: number of character columns already used\n *\t@after_tab: true if num_chars starts after a previous tab\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to erase a tab.\n *\n *\tCalled by the eraser function, which knows how many character\n *\tcolumns have been used since either a previous tab or the start\n *\tof input.  This information will be used later, along with\n *\tcanon column (if applicable), to go back the correct number\n *\tof columns.\n */\n\nstatic void echo_erase_tab(unsigned int num_chars, int after_tab,\n\t\t\t   struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_ERASE_TAB, ldata);\n\n\t/* We only need to know this modulo 8 (tab spacing) */\n\tnum_chars &= 7;\n\n\t/* Set the high bit as a flag if num_chars is after a previous tab */\n\tif (after_tab)\n\t\tnum_chars |= 0x80;\n\n\tadd_echo_byte(num_chars, ldata);\n}\n\n/**\n *\techo_char_raw\t-\techo a character raw\n *\t@c: unicode byte to echo\n *\t@tty: terminal device\n *\n *\tEcho user input back onto the screen. This must be called only when\n *\tL_ECHO(tty) is true. Called from the driver receive_buf path.\n *\n *\tThis variant does not treat control characters specially.\n */\n\nstatic void echo_char_raw(unsigned char c, struct n_tty_data *ldata)\n{\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n/**\n *\techo_char\t-\techo a character\n *\t@c: unicode byte to echo\n *\t@tty: terminal device\n *\n *\tEcho user input back onto the screen. This must be called only when\n *\tL_ECHO(tty) is true. Called from the driver receive_buf path.\n *\n *\tThis variant tags control characters to be echoed as \"^X\"\n *\t(where X is the letter representing the control char).\n */\n\nstatic void echo_char(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tif (L_ECHOCTL(tty) && iscntrl(c) && c != '\\t')\n\t\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n/**\n *\tfinish_erasing\t\t-\tcomplete erase\n *\t@ldata: n_tty data\n */\n\nstatic inline void finish_erasing(struct n_tty_data *ldata)\n{\n\tif (ldata->erasing) {\n\t\techo_char_raw('/', ldata);\n\t\tldata->erasing = 0;\n\t}\n}\n\n/**\n *\teraser\t\t-\thandle erase function\n *\t@c: character input\n *\t@tty: terminal device\n *\n *\tPerform erase and necessary output when an erase character is\n *\tpresent in the stream from the driver layer. Handles the complexities\n *\tof UTF-8 multibyte symbols.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n */\n\nstatic void eraser(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tenum { ERASE, WERASE, KILL } kill_type;\n\tsize_t head;\n\tsize_t cnt;\n\tint seen_alnums;\n\n\tif (ldata->read_head == ldata->canon_head) {\n\t\t/* process_output('\\a', tty); */ /* what do you think? */\n\t\treturn;\n\t}\n\tif (c == ERASE_CHAR(tty))\n\t\tkill_type = ERASE;\n\telse if (c == WERASE_CHAR(tty))\n\t\tkill_type = WERASE;\n\telse {\n\t\tif (!L_ECHO(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\treturn;\n\t\t}\n\t\tif (!L_ECHOK(tty) || !L_ECHOKE(tty) || !L_ECHOE(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\tfinish_erasing(ldata);\n\t\t\techo_char(KILL_CHAR(tty), tty);\n\t\t\t/* Add a newline if ECHOK is on and ECHOKE is off. */\n\t\t\tif (L_ECHOK(tty))\n\t\t\t\techo_char_raw('\\n', ldata);\n\t\t\treturn;\n\t\t}\n\t\tkill_type = KILL;\n\t}\n\n\tseen_alnums = 0;\n\twhile (ldata->read_head != ldata->canon_head) {\n\t\thead = ldata->read_head;\n\n\t\t/* erase a single possibly multibyte character */\n\t\tdo {\n\t\t\thead--;\n\t\t\tc = read_buf(ldata, head);\n\t\t} while (is_continuation(c, tty) && head != ldata->canon_head);\n\n\t\t/* do not partially erase */\n\t\tif (is_continuation(c, tty))\n\t\t\tbreak;\n\n\t\tif (kill_type == WERASE) {\n\t\t\t/* Equivalent to BSD's ALTWERASE. */\n\t\t\tif (isalnum(c) || c == '_')\n\t\t\t\tseen_alnums++;\n\t\t\telse if (seen_alnums)\n\t\t\t\tbreak;\n\t\t}\n\t\tcnt = ldata->read_head - head;\n\t\tldata->read_head = head;\n\t\tif (L_ECHO(tty)) {\n\t\t\tif (L_ECHOPRT(tty)) {\n\t\t\t\tif (!ldata->erasing) {\n\t\t\t\t\techo_char_raw('\\\\', ldata);\n\t\t\t\t\tldata->erasing = 1;\n\t\t\t\t}\n\t\t\t\t/* if cnt > 1, output a multi-byte character */\n\t\t\t\techo_char(c, tty);\n\t\t\t\twhile (--cnt > 0) {\n\t\t\t\t\thead++;\n\t\t\t\t\techo_char_raw(read_buf(ldata, head), ldata);\n\t\t\t\t\techo_move_back_col(ldata);\n\t\t\t\t}\n\t\t\t} else if (kill_type == ERASE && !L_ECHOE(tty)) {\n\t\t\t\techo_char(ERASE_CHAR(tty), tty);\n\t\t\t} else if (c == '\\t') {\n\t\t\t\tunsigned int num_chars = 0;\n\t\t\t\tint after_tab = 0;\n\t\t\t\tsize_t tail = ldata->read_head;\n\n\t\t\t\t/*\n\t\t\t\t * Count the columns used for characters\n\t\t\t\t * since the start of input or after a\n\t\t\t\t * previous tab.\n\t\t\t\t * This info is used to go back the correct\n\t\t\t\t * number of columns.\n\t\t\t\t */\n\t\t\t\twhile (tail != ldata->canon_head) {\n\t\t\t\t\ttail--;\n\t\t\t\t\tc = read_buf(ldata, tail);\n\t\t\t\t\tif (c == '\\t') {\n\t\t\t\t\t\tafter_tab = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (iscntrl(c)) {\n\t\t\t\t\t\tif (L_ECHOCTL(tty))\n\t\t\t\t\t\t\tnum_chars += 2;\n\t\t\t\t\t} else if (!is_continuation(c, tty)) {\n\t\t\t\t\t\tnum_chars++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\techo_erase_tab(num_chars, after_tab, ldata);\n\t\t\t} else {\n\t\t\t\tif (iscntrl(c) && L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t\tif (!iscntrl(c) || L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (kill_type == ERASE)\n\t\t\tbreak;\n\t}\n\tif (ldata->read_head == ldata->canon_head && L_ECHO(tty))\n\t\tfinish_erasing(ldata);\n}\n\n/**\n *\tisig\t\t-\thandle the ISIG optio\n *\t@sig: signal\n *\t@tty: terminal\n *\n *\tCalled when a signal is being sent due to terminal input.\n *\tCalled from the driver receive_buf path so serialized.\n *\n *\tPerforms input and output flush if !NOFLSH. In this context, the echo\n *\tbuffer is 'output'. The signal is processed first to alert any current\n *\treaders or writers to discontinue and exit their i/o loops.\n *\n *\tLocking: ctrl_lock\n */\n\nstatic void __isig(int sig, struct tty_struct *tty)\n{\n\tstruct pid *tty_pgrp = tty_get_pgrp(tty);\n\tif (tty_pgrp) {\n\t\tkill_pgrp(tty_pgrp, sig, 1);\n\t\tput_pid(tty_pgrp);\n\t}\n}\n\nstatic void isig(int sig, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (L_NOFLSH(tty)) {\n\t\t/* signal only */\n\t\t__isig(sig, tty);\n\n\t} else { /* signal and flush */\n\t\tup_read(&tty->termios_rwsem);\n\t\tdown_write(&tty->termios_rwsem);\n\n\t\t__isig(sig, tty);\n\n\t\t/* clear echo buffer */\n\t\tmutex_lock(&ldata->output_lock);\n\t\tldata->echo_head = ldata->echo_tail = 0;\n\t\tldata->echo_mark = ldata->echo_commit = 0;\n\t\tmutex_unlock(&ldata->output_lock);\n\n\t\t/* clear output buffer */\n\t\ttty_driver_flush_buffer(tty);\n\n\t\t/* clear input buffer */\n\t\treset_buffer_flags(tty->disc_data);\n\n\t\t/* notify pty master of flush */\n\t\tif (tty->link)\n\t\t\tn_tty_packet_mode_flush(tty);\n\n\t\tup_write(&tty->termios_rwsem);\n\t\tdown_read(&tty->termios_rwsem);\n\t}\n}\n\n/**\n *\tn_tty_receive_break\t-\thandle break\n *\t@tty: terminal\n *\n *\tAn RS232 break event has been hit in the incoming bitstream. This\n *\tcan cause a variety of events depending upon the termios settings.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\n *\tNote: may get exclusive termios_rwsem if flushing input buffer\n */\n\nstatic void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n}\n\n/**\n *\tn_tty_receive_overrun\t-\thandle overrun reporting\n *\t@tty: terminal\n *\n *\tData arrived faster than we could process it. While the tty\n *\tdriver has flagged this the bits that were missed are gone\n *\tforever.\n *\n *\tCalled from the receive_buf path so single threaded. Does not\n *\tneed locking as num_overrun and overrun_time are function\n *\tprivate.\n */\n\nstatic void n_tty_receive_overrun(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tldata->num_overrun++;\n\tif (time_after(jiffies, ldata->overrun_time + HZ) ||\n\t\t\ttime_after(ldata->overrun_time, jiffies)) {\n\t\ttty_warn(tty, \"%d input overrun(s)\\n\", ldata->num_overrun);\n\t\tldata->overrun_time = jiffies;\n\t\tldata->num_overrun = 0;\n\t}\n}\n\n/**\n *\tn_tty_receive_parity_error\t-\terror notifier\n *\t@tty: terminal device\n *\t@c: character\n *\n *\tProcess a parity error and queue the right data to indicate\n *\tthe error case if necessary.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n */\nstatic void n_tty_receive_parity_error(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_INPCK(tty)) {\n\t\tif (I_IGNPAR(tty))\n\t\t\treturn;\n\t\tif (I_PARMRK(tty)) {\n\t\t\tput_tty_queue('\\377', ldata);\n\t\t\tput_tty_queue('\\0', ldata);\n\t\t\tput_tty_queue(c, ldata);\n\t\t} else\n\t\t\tput_tty_queue('\\0', ldata);\n\t} else\n\t\tput_tty_queue(c, ldata);\n}\n\nstatic void\nn_tty_receive_signal_char(struct tty_struct *tty, int signal, unsigned char c)\n{\n\tisig(signal, tty);\n\tif (I_IXON(tty))\n\t\tstart_tty(tty);\n\tif (L_ECHO(tty)) {\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t} else\n\t\tprocess_echoes(tty);\n\treturn;\n}\n\n/**\n *\tn_tty_receive_char\t-\tperform processing\n *\t@tty: terminal device\n *\t@c: character\n *\n *\tProcess an individual character of input received from the driver.\n *\tThis is serialized with respect to itself by the rules for the\n *\tdriver above.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tpublishes canon_head if canonical mode is active\n *\n *\tReturns 1 if LNEXT was received, else returns 0\n */\n\nstatic int\nn_tty_receive_char_special(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IXON(tty)) {\n\t\tif (c == START_CHAR(tty)) {\n\t\t\tstart_tty(tty);\n\t\t\tprocess_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == STOP_CHAR(tty)) {\n\t\t\tstop_tty(tty);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (L_ISIG(tty)) {\n\t\tif (c == INTR_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGINT, c);\n\t\t\treturn 0;\n\t\t} else if (c == QUIT_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGQUIT, c);\n\t\t\treturn 0;\n\t\t} else if (c == SUSP_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGTSTP, c);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\tif (c == '\\r') {\n\t\tif (I_IGNCR(tty))\n\t\t\treturn 0;\n\t\tif (I_ICRNL(tty))\n\t\t\tc = '\\n';\n\t} else if (c == '\\n' && I_INLCR(tty))\n\t\tc = '\\r';\n\n\tif (ldata->icanon) {\n\t\tif (c == ERASE_CHAR(tty) || c == KILL_CHAR(tty) ||\n\t\t    (c == WERASE_CHAR(tty) && L_IEXTEN(tty))) {\n\t\t\teraser(c, tty);\n\t\t\tcommit_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == LNEXT_CHAR(tty) && L_IEXTEN(tty)) {\n\t\t\tldata->lnext = 1;\n\t\t\tif (L_ECHO(tty)) {\n\t\t\t\tfinish_erasing(ldata);\n\t\t\t\tif (L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('^', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\tcommit_echoes(tty);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (c == REPRINT_CHAR(tty) && L_ECHO(tty) && L_IEXTEN(tty)) {\n\t\t\tsize_t tail = ldata->canon_head;\n\n\t\t\tfinish_erasing(ldata);\n\t\t\techo_char(c, tty);\n\t\t\techo_char_raw('\\n', ldata);\n\t\t\twhile (tail != ldata->read_head) {\n\t\t\t\techo_char(read_buf(ldata, tail), tty);\n\t\t\t\ttail++;\n\t\t\t}\n\t\t\tcommit_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\tif (L_ECHO(tty) || L_ECHONL(tty)) {\n\t\t\t\techo_char_raw('\\n', ldata);\n\t\t\t\tcommit_echoes(tty);\n\t\t\t}\n\t\t\tgoto handle_newline;\n\t\t}\n\t\tif (c == EOF_CHAR(tty)) {\n\t\t\tc = __DISABLED_CHAR;\n\t\t\tgoto handle_newline;\n\t\t}\n\t\tif ((c == EOL_CHAR(tty)) ||\n\t\t    (c == EOL2_CHAR(tty) && L_IEXTEN(tty))) {\n\t\t\t/*\n\t\t\t * XXX are EOL_CHAR and EOL2_CHAR echoed?!?\n\t\t\t */\n\t\t\tif (L_ECHO(tty)) {\n\t\t\t\t/* Record the column of first canon char. */\n\t\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\t\techo_set_canon_col(ldata);\n\t\t\t\techo_char(c, tty);\n\t\t\t\tcommit_echoes(tty);\n\t\t\t}\n\t\t\t/*\n\t\t\t * XXX does PARMRK doubling happen for\n\t\t\t * EOL_CHAR and EOL2_CHAR?\n\t\t\t */\n\t\t\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\t\t\tput_tty_queue(c, ldata);\n\nhandle_newline:\n\t\t\tset_bit(ldata->read_head & (N_TTY_BUF_SIZE - 1), ldata->read_flags);\n\t\t\tput_tty_queue(c, ldata);\n\t\t\tsmp_store_release(&ldata->canon_head, ldata->read_head);\n\t\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\t\t\twake_up_interruptible_poll(&tty->read_wait, POLLIN);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\tif (c == '\\n')\n\t\t\techo_char_raw('\\n', ldata);\n\t\telse {\n\t\t\t/* Record the column of first canon char. */\n\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\techo_set_canon_col(ldata);\n\t\t\techo_char(c, tty);\n\t\t}\n\t\tcommit_echoes(tty);\n\t}\n\n\t/* PARMRK doubling check */\n\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\n\tput_tty_queue(c, ldata);\n\treturn 0;\n}\n\nstatic inline void\nn_tty_receive_char_inline(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\t/* Record the column of first canon char. */\n\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\techo_set_canon_col(ldata);\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t}\n\t/* PARMRK doubling check */\n\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\tput_tty_queue(c, ldata);\n}\n\nstatic void n_tty_receive_char(struct tty_struct *tty, unsigned char c)\n{\n\tn_tty_receive_char_inline(tty, c);\n}\n\nstatic inline void\nn_tty_receive_char_fast(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\t/* Record the column of first canon char. */\n\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\techo_set_canon_col(ldata);\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t}\n\tput_tty_queue(c, ldata);\n}\n\nstatic void n_tty_receive_char_closing(struct tty_struct *tty, unsigned char c)\n{\n\tif (I_ISTRIP(tty))\n\t\tc &= 0x7f;\n\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\tc = tolower(c);\n\n\tif (I_IXON(tty)) {\n\t\tif (c == STOP_CHAR(tty))\n\t\t\tstop_tty(tty);\n\t\telse if (c == START_CHAR(tty) ||\n\t\t\t (tty->stopped && !tty->flow_stopped && I_IXANY(tty) &&\n\t\t\t  c != INTR_CHAR(tty) && c != QUIT_CHAR(tty) &&\n\t\t\t  c != SUSP_CHAR(tty))) {\n\t\t\tstart_tty(tty);\n\t\t\tprocess_echoes(tty);\n\t\t}\n\t}\n}\n\nstatic void\nn_tty_receive_char_flagged(struct tty_struct *tty, unsigned char c, char flag)\n{\n\tswitch (flag) {\n\tcase TTY_BREAK:\n\t\tn_tty_receive_break(tty);\n\t\tbreak;\n\tcase TTY_PARITY:\n\tcase TTY_FRAME:\n\t\tn_tty_receive_parity_error(tty, c);\n\t\tbreak;\n\tcase TTY_OVERRUN:\n\t\tn_tty_receive_overrun(tty);\n\t\tbreak;\n\tdefault:\n\t\ttty_err(tty, \"unknown flag %d\\n\", flag);\n\t\tbreak;\n\t}\n}\n\nstatic void\nn_tty_receive_char_lnext(struct tty_struct *tty, unsigned char c, char flag)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tldata->lnext = 0;\n\tif (likely(flag == TTY_NORMAL)) {\n\t\tif (I_ISTRIP(tty))\n\t\t\tc &= 0x7f;\n\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\tc = tolower(c);\n\t\tn_tty_receive_char(tty, c);\n\t} else\n\t\tn_tty_receive_char_flagged(tty, c, flag);\n}\n\nstatic void\nn_tty_receive_buf_real_raw(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t   char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, head;\n\n\thead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\n\tn = min_t(size_t, count, N_TTY_BUF_SIZE - head);\n\tmemcpy(read_buf_addr(ldata, head), cp, n);\n\tldata->read_head += n;\n\tcp += n;\n\tcount -= n;\n\n\thead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\n\tn = min_t(size_t, count, N_TTY_BUF_SIZE - head);\n\tmemcpy(read_buf_addr(ldata, head), cp, n);\n\tldata->read_head += n;\n}\n\nstatic void\nn_tty_receive_buf_raw(struct tty_struct *tty, const unsigned char *cp,\n\t\t      char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tput_tty_queue(*cp++, ldata);\n\t\telse\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tn_tty_receive_char_closing(tty, *cp++);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_standard(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL)) {\n\t\t\tunsigned char c = *cp++;\n\n\t\t\tif (I_ISTRIP(tty))\n\t\t\t\tc &= 0x7f;\n\t\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\t\tc = tolower(c);\n\t\t\tif (L_EXTPROC(tty)) {\n\t\t\t\tput_tty_queue(c, ldata);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!test_bit(c, ldata->char_map))\n\t\t\t\tn_tty_receive_char_inline(tty, c);\n\t\t\telse if (n_tty_receive_char_special(tty, c) && count) {\n\t\t\t\tif (fp)\n\t\t\t\t\tflag = *fp++;\n\t\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t} else\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_fast(struct tty_struct *tty, const unsigned char *cp,\n\t\t       char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL)) {\n\t\t\tunsigned char c = *cp++;\n\n\t\t\tif (!test_bit(c, ldata->char_map))\n\t\t\t\tn_tty_receive_char_fast(tty, c);\n\t\t\telse if (n_tty_receive_char_special(tty, c) && count) {\n\t\t\t\tif (fp)\n\t\t\t\t\tflag = *fp++;\n\t\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t} else\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void __receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tbool preops = I_ISTRIP(tty) || (I_IUCLC(tty) && L_IEXTEN(tty));\n\n\tif (ldata->real_raw)\n\t\tn_tty_receive_buf_real_raw(tty, cp, fp, count);\n\telse if (ldata->raw || (L_EXTPROC(tty) && !preops))\n\t\tn_tty_receive_buf_raw(tty, cp, fp, count);\n\telse if (tty->closing && !L_EXTPROC(tty))\n\t\tn_tty_receive_buf_closing(tty, cp, fp, count);\n\telse {\n\t\tif (ldata->lnext) {\n\t\t\tchar flag = TTY_NORMAL;\n\n\t\t\tif (fp)\n\t\t\t\tflag = *fp++;\n\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\tcount--;\n\t\t}\n\n\t\tif (!preops && !I_PARMRK(tty))\n\t\t\tn_tty_receive_buf_fast(tty, cp, fp, count);\n\t\telse\n\t\t\tn_tty_receive_buf_standard(tty, cp, fp, count);\n\n\t\tflush_echoes(tty);\n\t\tif (tty->ops->flush_chars)\n\t\t\ttty->ops->flush_chars(tty);\n\t}\n\n\tif (ldata->icanon && !L_EXTPROC(tty))\n\t\treturn;\n\n\t/* publish read_head to consumer */\n\tsmp_store_release(&ldata->commit_head, ldata->read_head);\n\n\tif (read_cnt(ldata)) {\n\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\t\twake_up_interruptible_poll(&tty->read_wait, POLLIN);\n\t}\n}\n\n/**\n *\tn_tty_receive_buf_common\t-\tprocess input\n *\t@tty: device to receive input\n *\t@cp: input chars\n *\t@fp: flags for each char (if NULL, all chars are TTY_NORMAL)\n *\t@count: number of input chars in @cp\n *\n *\tCalled by the terminal driver when a block of characters has\n *\tbeen received. This function must be called from soft contexts\n *\tnot from interrupt context. The driver is responsible for making\n *\tcalls one at a time and in order (or using flush_to_ldisc)\n *\n *\tReturns the # of input chars from @cp which were processed.\n *\n *\tIn canonical mode, the maximum line length is 4096 chars (including\n *\tthe line termination char); lines longer than 4096 chars are\n *\ttruncated. After 4095 chars, input data is still processed but\n *\tnot stored. Overflow processing ensures the tty can always\n *\treceive more input until at least one line can be read.\n *\n *\tIn non-canonical mode, the read buffer will only accept 4095 chars;\n *\tthis provides the necessary space for a newline char if the input\n *\tmode is switched to canonical.\n *\n *\tNote it is possible for the read buffer to _contain_ 4096 chars\n *\tin non-canonical mode: the read buffer could already contain the\n *\tmaximum canon line of 4096 chars when the mode is switched to\n *\tnon-canonical.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tclaims non-exclusive termios_rwsem\n *\t\tpublishes commit_head or canon_head\n */\nstatic int\nn_tty_receive_buf_common(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t char *fp, int count, int flow)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint room, n, rcvd = 0, overflow;\n\n\tdown_read(&tty->termios_rwsem);\n\n\twhile (1) {\n\t\t/*\n\t\t * When PARMRK is set, each input char may take up to 3 chars\n\t\t * in the read buf; reduce the buffer space avail by 3x\n\t\t *\n\t\t * If we are doing input canonicalization, and there are no\n\t\t * pending newlines, let characters through without limit, so\n\t\t * that erase characters will be handled.  Other excess\n\t\t * characters will be beeped.\n\t\t *\n\t\t * paired with store in *_copy_from_read_buf() -- guarantees\n\t\t * the consumer has loaded the data in read_buf up to the new\n\t\t * read_tail (so this producer will not overwrite unread data)\n\t\t */\n\t\tsize_t tail = smp_load_acquire(&ldata->read_tail);\n\n\t\troom = N_TTY_BUF_SIZE - (ldata->read_head - tail);\n\t\tif (I_PARMRK(tty))\n\t\t\troom = (room + 2) / 3;\n\t\troom--;\n\t\tif (room <= 0) {\n\t\t\toverflow = ldata->icanon && ldata->canon_head == tail;\n\t\t\tif (overflow && room < 0)\n\t\t\t\tldata->read_head--;\n\t\t\troom = overflow;\n\t\t\tldata->no_room = flow && !room;\n\t\t} else\n\t\t\toverflow = 0;\n\n\t\tn = min(count, room);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\t/* ignore parity errors if handling overflow */\n\t\tif (!overflow || !fp || *fp != TTY_PARITY)\n\t\t\t__receive_buf(tty, cp, fp, n);\n\n\t\tcp += n;\n\t\tif (fp)\n\t\t\tfp += n;\n\t\tcount -= n;\n\t\trcvd += n;\n\t}\n\n\ttty->receive_room = room;\n\n\t/* Unthrottle if handling overflow on pty */\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\n\t\tif (overflow) {\n\t\t\ttty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n\t\t\ttty_unthrottle_safe(tty);\n\t\t\t__tty_set_flow_change(tty, 0);\n\t\t}\n\t} else\n\t\tn_tty_check_throttle(tty);\n\n\tup_read(&tty->termios_rwsem);\n\n\treturn rcvd;\n}\n\nstatic void n_tty_receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\tn_tty_receive_buf_common(tty, cp, fp, count, 0);\n}\n\nstatic int n_tty_receive_buf2(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\treturn n_tty_receive_buf_common(tty, cp, fp, count, 1);\n}\n\n/**\n *\tn_tty_set_termios\t-\ttermios data changed\n *\t@tty: terminal\n *\t@old: previous data\n *\n *\tCalled by the tty layer when the user changes termios flags so\n *\tthat the line discipline can plan ahead. This function cannot sleep\n *\tand is protected from re-entry by the tty layer. The user is\n *\tguaranteed that this function will not be re-entered or in progress\n *\twhen the ldisc is closed.\n *\n *\tLocking: Caller holds tty->termios_rwsem\n */\n\nstatic void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {\n\t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\t\tldata->line_start = ldata->read_tail;\n\t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n\t\t\tldata->canon_head = ldata->read_tail;\n\t\t\tldata->push = 0;\n\t\t} else {\n\t\t\tset_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),\n\t\t\t\tldata->read_flags);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tldata->push = 1;\n\t\t}\n\t\tldata->commit_head = ldata->read_head;\n\t\tldata->erasing = 0;\n\t\tldata->lnext = 0;\n\t}\n\n\tldata->icanon = (L_ICANON(tty) != 0);\n\n\tif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\n\t    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\n\t    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\n\t    I_PARMRK(tty)) {\n\t\tbitmap_zero(ldata->char_map, 256);\n\n\t\tif (I_IGNCR(tty) || I_ICRNL(tty))\n\t\t\tset_bit('\\r', ldata->char_map);\n\t\tif (I_INLCR(tty))\n\t\t\tset_bit('\\n', ldata->char_map);\n\n\t\tif (L_ICANON(tty)) {\n\t\t\tset_bit(ERASE_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(KILL_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(EOF_CHAR(tty), ldata->char_map);\n\t\t\tset_bit('\\n', ldata->char_map);\n\t\t\tset_bit(EOL_CHAR(tty), ldata->char_map);\n\t\t\tif (L_IEXTEN(tty)) {\n\t\t\t\tset_bit(WERASE_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(LNEXT_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(EOL2_CHAR(tty), ldata->char_map);\n\t\t\t\tif (L_ECHO(tty))\n\t\t\t\t\tset_bit(REPRINT_CHAR(tty),\n\t\t\t\t\t\tldata->char_map);\n\t\t\t}\n\t\t}\n\t\tif (I_IXON(tty)) {\n\t\t\tset_bit(START_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(STOP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tif (L_ISIG(tty)) {\n\t\t\tset_bit(INTR_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(QUIT_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(SUSP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tclear_bit(__DISABLED_CHAR, ldata->char_map);\n\t\tldata->raw = 0;\n\t\tldata->real_raw = 0;\n\t} else {\n\t\tldata->raw = 1;\n\t\tif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\n\t\t    (I_IGNPAR(tty) || !I_INPCK(tty)) &&\n\t\t    (tty->driver->flags & TTY_DRIVER_REAL_RAW))\n\t\t\tldata->real_raw = 1;\n\t\telse\n\t\t\tldata->real_raw = 0;\n\t}\n\t/*\n\t * Fix tty hang when I_IXON(tty) is cleared, but the tty\n\t * been stopped by STOP_CHAR(tty) before it.\n\t */\n\tif (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\t/* The termios change make the tty ready for I/O */\n\twake_up_interruptible(&tty->write_wait);\n\twake_up_interruptible(&tty->read_wait);\n}\n\n/**\n *\tn_tty_close\t\t-\tclose the ldisc for this tty\n *\t@tty: device\n *\n *\tCalled from the terminal layer when this line discipline is\n *\tbeing shut down, either because of a close or becsuse of a\n *\tdiscipline change. The function will not be called while other\n *\tldisc methods are in progress.\n */\n\nstatic void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n}\n\n/**\n *\tn_tty_open\t\t-\topen an ldisc\n *\t@tty: terminal to open\n *\n *\tCalled when this line discipline is being attached to the\n *\tterminal device. Can sleep. Called serialized so that no\n *\tother events will occur in parallel. No further open will occur\n *\tuntil a close.\n */\n\nstatic int n_tty_open(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata;\n\n\t/* Currently a malloc failure here can panic */\n\tldata = vmalloc(sizeof(*ldata));\n\tif (!ldata)\n\t\tgoto err;\n\n\tldata->overrun_time = jiffies;\n\tmutex_init(&ldata->atomic_read_lock);\n\tmutex_init(&ldata->output_lock);\n\n\ttty->disc_data = ldata;\n\treset_buffer_flags(tty->disc_data);\n\tldata->column = 0;\n\tldata->canon_column = 0;\n\tldata->num_overrun = 0;\n\tldata->no_room = 0;\n\tldata->lnext = 0;\n\ttty->closing = 0;\n\t/* indicate buffer work may resume */\n\tclear_bit(TTY_LDISC_HALTED, &tty->flags);\n\tn_tty_set_termios(tty, NULL);\n\ttty_unthrottle(tty);\n\n\treturn 0;\nerr:\n\treturn -ENOMEM;\n}\n\nstatic inline int input_available_p(struct tty_struct *tty, int poll)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;\n\n\tif (ldata->icanon && !L_EXTPROC(tty))\n\t\treturn ldata->canon_head != ldata->read_tail;\n\telse\n\t\treturn ldata->commit_head - ldata->read_tail >= amt;\n}\n\n/**\n *\tcopy_from_read_buf\t-\tcopy read data directly\n *\t@tty: terminal device\n *\t@b: user data\n *\t@nr: size of data\n *\n *\tHelper function to speed up n_tty_read.  It is only called when\n *\tICANON is off; it copies characters straight from the tty queue to\n *\tuser space directly.  It can be profitably called twice; once to\n *\tdrain the space from the tail pointer to the (physical) end of the\n *\tbuffer, and once to drain the space from the (physical) beginning of\n *\tthe buffer to head pointer.\n *\n *\tCalled under the ldata->atomic_read_lock sem\n *\n *\tn_tty_read()/consumer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tread_tail published\n */\n\nstatic int copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t      unsigned char __user **b,\n\t\t\t\t      size_t *nr)\n\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\tsize_t n;\n\tbool is_eof;\n\tsize_t head = smp_load_acquire(&ldata->commit_head);\n\tsize_t tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\n\tretval = 0;\n\tn = min(head - ldata->read_tail, N_TTY_BUF_SIZE - tail);\n\tn = min(*nr, n);\n\tif (n) {\n\t\tconst unsigned char *from = read_buf_addr(ldata, tail);\n\t\tretval = copy_to_user(*b, from, n);\n\t\tn -= retval;\n\t\tis_eof = n == 1 && *from == EOF_CHAR(tty);\n\t\ttty_audit_add_data(tty, from, n);\n\t\tsmp_store_release(&ldata->read_tail, ldata->read_tail + n);\n\t\t/* Turn single EOF into zero-length read */\n\t\tif (L_EXTPROC(tty) && ldata->icanon && is_eof &&\n\t\t    (head == ldata->read_tail))\n\t\t\tn = 0;\n\t\t*b += n;\n\t\t*nr -= n;\n\t}\n\treturn retval;\n}\n\n/**\n *\tcanon_copy_from_read_buf\t-\tcopy read data in canonical mode\n *\t@tty: terminal device\n *\t@b: user data\n *\t@nr: size of data\n *\n *\tHelper function for n_tty_read.  It is only called when ICANON is on;\n *\tit copies one line of input up to and including the line-delimiting\n *\tcharacter into the user-space buffer.\n *\n *\tNB: When termios is changed from non-canonical to canonical mode and\n *\tthe read buffer contains data, n_tty_set_termios() simulates an EOF\n *\tpush (as if C-d were input) _without_ the DISABLED_CHAR in the buffer.\n *\tThis causes data already processed as input to be immediately available\n *\tas input although a newline has not been received.\n *\n *\tCalled under the atomic_read_lock mutex\n *\n *\tn_tty_read()/consumer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tread_tail published\n */\n\nstatic int canon_copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t    unsigned char __user **b,\n\t\t\t\t    size_t *nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, size, more, c;\n\tsize_t eol;\n\tsize_t tail;\n\tint ret, found = 0;\n\n\t/* N.B. avoid overrun if nr == 0 */\n\tif (!*nr)\n\t\treturn 0;\n\n\tn = min(*nr + 1, smp_load_acquire(&ldata->canon_head) - ldata->read_tail);\n\n\ttail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\tsize = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\n\n\tn_tty_trace(\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\",\n\t\t    __func__, *nr, tail, n, size);\n\n\teol = find_next_bit(ldata->read_flags, size, tail);\n\tmore = n - (size - tail);\n\tif (eol == N_TTY_BUF_SIZE && more) {\n\t\t/* scan wrapped without finding set bit */\n\t\teol = find_next_bit(ldata->read_flags, more, 0);\n\t\tfound = eol != more;\n\t} else\n\t\tfound = eol != size;\n\n\tn = eol - tail;\n\tif (n > N_TTY_BUF_SIZE)\n\t\tn += N_TTY_BUF_SIZE;\n\tc = n + found;\n\n\tif (!found || read_buf(ldata, eol) != __DISABLED_CHAR) {\n\t\tc = min(*nr, c);\n\t\tn = c;\n\t}\n\n\tn_tty_trace(\"%s: eol:%zu found:%d n:%zu c:%zu tail:%zu more:%zu\\n\",\n\t\t    __func__, eol, found, n, c, tail, more);\n\n\tret = tty_copy_to_user(tty, *b, tail, n);\n\tif (ret)\n\t\treturn -EFAULT;\n\t*b += n;\n\t*nr -= n;\n\n\tif (found)\n\t\tclear_bit(eol, ldata->read_flags);\n\tsmp_store_release(&ldata->read_tail, ldata->read_tail + c);\n\n\tif (found) {\n\t\tif (!ldata->push)\n\t\t\tldata->line_start = ldata->read_tail;\n\t\telse\n\t\t\tldata->push = 0;\n\t\ttty_audit_push();\n\t}\n\treturn 0;\n}\n\nextern ssize_t redirected_tty_write(struct file *, const char __user *,\n\t\t\t\t\t\t\tsize_t, loff_t *);\n\n/**\n *\tjob_control\t\t-\tcheck job control\n *\t@tty: tty\n *\t@file: file handle\n *\n *\tPerform job control management checks on this file/tty descriptor\n *\tand if appropriate send any needed signals and return a negative\n *\terror code if action should be taken.\n *\n *\tLocking: redirected write test is safe\n *\t\t current->signal->tty check is safe\n *\t\t ctrl_lock to safely reference tty->pgrp\n */\n\nstatic int job_control(struct tty_struct *tty, struct file *file)\n{\n\t/* Job control check -- must be done at start and after\n\t   every sleep (POSIX.1 7.1.1.4). */\n\t/* NOTE: not yet done after every sleep pending a thorough\n\t   check of the logic of this change. -- jlc */\n\t/* don't stop on /dev/console */\n\tif (file->f_op->write == redirected_tty_write)\n\t\treturn 0;\n\n\treturn __tty_check_change(tty, SIGTTIN);\n}\n\n\n/**\n *\tn_tty_read\t\t-\tread function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tPerform reads for the line discipline. We are guaranteed that the\n *\tline discipline will not be closed under us but we may get multiple\n *\tparallel readers and must handle this ourselves. We may also get\n *\ta hangup. Always called in user context, may sleep.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\n *\tn_tty_read()/consumer path:\n *\t\tclaims non-exclusive termios_rwsem\n *\t\tpublishes read_tail\n */\n\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\n\t\t\t unsigned char __user *buf, size_t nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tunsigned char __user *b = buf;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint c;\n\tint minimum, time;\n\tssize_t retval = 0;\n\tlong timeout;\n\tint packet;\n\tsize_t tail;\n\n\tc = job_control(tty, file);\n\tif (c < 0)\n\t\treturn c;\n\n\t/*\n\t *\tInternal serialization of reads.\n\t */\n\tif (file->f_flags & O_NONBLOCK) {\n\t\tif (!mutex_trylock(&ldata->atomic_read_lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (mutex_lock_interruptible(&ldata->atomic_read_lock))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\tminimum = time = 0;\n\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\tif (!ldata->icanon) {\n\t\tminimum = MIN_CHAR(tty);\n\t\tif (minimum) {\n\t\t\ttime = (HZ / 10) * TIME_CHAR(tty);\n\t\t} else {\n\t\t\ttimeout = (HZ / 10) * TIME_CHAR(tty);\n\t\t\tminimum = 1;\n\t\t}\n\t}\n\n\tpacket = tty->packet;\n\ttail = ldata->read_tail;\n\n\tadd_wait_queue(&tty->read_wait, &wait);\n\twhile (nr) {\n\t\t/* First test for status change. */\n\t\tif (packet && tty->link->ctrl_status) {\n\t\t\tunsigned char cs;\n\t\t\tif (b != buf)\n\t\t\t\tbreak;\n\t\t\tspin_lock_irq(&tty->link->ctrl_lock);\n\t\t\tcs = tty->link->ctrl_status;\n\t\t\ttty->link->ctrl_status = 0;\n\t\t\tspin_unlock_irq(&tty->link->ctrl_lock);\n\t\t\tif (put_user(cs, b)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tb++;\n\t\t\tnr--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!input_available_p(tty, 0)) {\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\ttty_buffer_flush_work(tty->port);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\tif (!input_available_p(tty, 0)) {\n\t\t\t\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\n\t\t\t\t\tretval = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (tty_hung_up_p(file))\n\t\t\t\t\tbreak;\n\t\t\t\tif (!timeout)\n\t\t\t\t\tbreak;\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tretval = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tup_read(&tty->termios_rwsem);\n\n\t\t\t\ttimeout = wait_woken(&wait, TASK_INTERRUPTIBLE,\n\t\t\t\t\t\ttimeout);\n\n\t\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ldata->icanon && !L_EXTPROC(tty)) {\n\t\t\tretval = canon_copy_from_read_buf(tty, &b, &nr);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tint uncopied;\n\n\t\t\t/* Deal with packet mode. */\n\t\t\tif (packet && b == buf) {\n\t\t\t\tif (put_user(TIOCPKT_DATA, b)) {\n\t\t\t\t\tretval = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t\tnr--;\n\t\t\t}\n\n\t\t\tuncopied = copy_from_read_buf(tty, &b, &nr);\n\t\t\tuncopied += copy_from_read_buf(tty, &b, &nr);\n\t\t\tif (uncopied) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tn_tty_check_unthrottle(tty);\n\n\t\tif (b - buf >= minimum)\n\t\t\tbreak;\n\t\tif (time)\n\t\t\ttimeout = time;\n\t}\n\tif (tail != ldata->read_tail)\n\t\tn_tty_kick_worker(tty);\n\tup_read(&tty->termios_rwsem);\n\n\tremove_wait_queue(&tty->read_wait, &wait);\n\tmutex_unlock(&ldata->atomic_read_lock);\n\n\tif (b - buf)\n\t\tretval = b - buf;\n\n\treturn retval;\n}\n\n/**\n *\tn_tty_write\t\t-\twrite function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tWrite function of the terminal device.  This is serialized with\n *\trespect to other write callers but not to termios changes, reads\n *\tand other such events.  Since the receive code will echo characters,\n *\tthus calling driver write methods, the output_lock is used in\n *\tthe output processing functions called here as well as in the\n *\techo processing function to protect the column state and space\n *\tleft in the buffer.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (note that the process_output*() functions take this\n *\t\t  lock themselves)\n */\n\nstatic ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n\t\t\tif (tty->ops->flush_chars)\n\t\t\t\ttty->ops->flush_chars(tty);\n\t\t} else {\n\t\t\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t\t\twhile (nr > 0) {\n\t\t\t\tmutex_lock(&ldata->output_lock);\n\t\t\t\tc = tty->ops->write(tty, b, nr);\n\t\t\t\tmutex_unlock(&ldata->output_lock);\n\t\t\t\tif (c < 0) {\n\t\t\t\t\tretval = c;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}\n\n/**\n *\tn_tty_poll\t\t-\tpoll method for N_TTY\n *\t@tty: terminal device\n *\t@file: file accessing it\n *\t@wait: poll table\n *\n *\tCalled when the line discipline is asked to poll() for data or\n *\tfor special events. This code is not serialized with respect to\n *\tother events save open/close.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\tCalled without the kernel lock held - fine\n */\n\nstatic unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,\n\t\t\t\t\t\t\tpoll_table *wait)\n{\n\tunsigned int mask = 0;\n\n\tpoll_wait(file, &tty->read_wait, wait);\n\tpoll_wait(file, &tty->write_wait, wait);\n\tif (input_available_p(tty, 1))\n\t\tmask |= POLLIN | POLLRDNORM;\n\telse {\n\t\ttty_buffer_flush_work(tty->port);\n\t\tif (input_available_p(tty, 1))\n\t\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tif (tty->packet && tty->link->ctrl_status)\n\t\tmask |= POLLPRI | POLLIN | POLLRDNORM;\n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tmask |= POLLHUP;\n\tif (tty_hung_up_p(file))\n\t\tmask |= POLLHUP;\n\tif (tty->ops->write && !tty_is_writelocked(tty) &&\n\t\t\ttty_chars_in_buffer(tty) < WAKEUP_CHARS &&\n\t\t\ttty_write_room(tty) > 0)\n\t\tmask |= POLLOUT | POLLWRNORM;\n\treturn mask;\n}\n\nstatic unsigned long inq_canon(struct n_tty_data *ldata)\n{\n\tsize_t nr, head, tail;\n\n\tif (ldata->canon_head == ldata->read_tail)\n\t\treturn 0;\n\thead = ldata->canon_head;\n\ttail = ldata->read_tail;\n\tnr = head - tail;\n\t/* Skip EOF-chars.. */\n\twhile (head != tail) {\n\t\tif (test_bit(tail & (N_TTY_BUF_SIZE - 1), ldata->read_flags) &&\n\t\t    read_buf(ldata, tail) == __DISABLED_CHAR)\n\t\t\tnr--;\n\t\ttail++;\n\t}\n\treturn nr;\n}\n\nstatic int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}\n\nstatic struct tty_ldisc_ops n_tty_ops = {\n\t.magic           = TTY_LDISC_MAGIC,\n\t.name            = \"n_tty\",\n\t.open            = n_tty_open,\n\t.close           = n_tty_close,\n\t.flush_buffer    = n_tty_flush_buffer,\n\t.read            = n_tty_read,\n\t.write           = n_tty_write,\n\t.ioctl           = n_tty_ioctl,\n\t.set_termios     = n_tty_set_termios,\n\t.poll            = n_tty_poll,\n\t.receive_buf     = n_tty_receive_buf,\n\t.write_wakeup    = n_tty_write_wakeup,\n\t.receive_buf2\t = n_tty_receive_buf2,\n};\n\n/**\n *\tn_tty_inherit_ops\t-\tinherit N_TTY methods\n *\t@ops: struct tty_ldisc_ops where to save N_TTY methods\n *\n *\tEnables a 'subclass' line discipline to 'inherit' N_TTY methods.\n */\n\nvoid n_tty_inherit_ops(struct tty_ldisc_ops *ops)\n{\n\t*ops = n_tty_ops;\n\tops->owner = NULL;\n\tops->refcount = ops->flags = 0;\n}\nEXPORT_SYMBOL_GPL(n_tty_inherit_ops);\n\nvoid __init n_tty_init(void)\n{\n\ttty_register_ldisc(N_TTY, &n_tty_ops);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-1.0+\n/*\n * n_tty.c --- implements the N_TTY line discipline.\n *\n * This code used to be in tty_io.c, but things are getting hairy\n * enough that it made sense to split things off.  (The N_TTY\n * processing has changed so much that it's hardly recognizable,\n * anyway...)\n *\n * Note that the open routine for N_TTY is guaranteed never to return\n * an error.  This is because Linux will fall back to setting a line\n * to N_TTY if it can not switch to any other line discipline.\n *\n * Written by Theodore Ts'o, Copyright 1994.\n *\n * This file also contains code originally written by Linus Torvalds,\n * Copyright 1991, 1992, 1993, and by Julian Cowley, Copyright 1994.\n *\n * Reduced memory usage for older ARM systems  - Russell King.\n *\n * 2000/01/20   Fixed SMP locking on put_tty_queue using bits of\n *\t\tthe patch by Andrew J. Kroll <ag784@freenet.buffalo.edu>\n *\t\twho actually finally proved there really was a race.\n *\n * 2002/03/18   Implemented n_tty_wakeup to send SIGIO POLL_OUTs to\n *\t\twaiting writing processes-Sapan Bhatia <sapan@corewars.org>.\n *\t\tAlso fixed a bug in BLOCKING mode where n_tty_write returns\n *\t\tEAGAIN\n */\n\n#include <linux/types.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/fcntl.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/timer.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/bitops.h>\n#include <linux/audit.h>\n#include <linux/file.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ratelimit.h>\n#include <linux/vmalloc.h>\n\n\n/* number of characters left in xmit buffer before select has we have room */\n#define WAKEUP_CHARS 256\n\n/*\n * This defines the low- and high-watermarks for throttling and\n * unthrottling the TTY driver.  These watermarks are used for\n * controlling the space in the read buffer.\n */\n#define TTY_THRESHOLD_THROTTLE\t\t128 /* now based on remaining room */\n#define TTY_THRESHOLD_UNTHROTTLE\t128\n\n/*\n * Special byte codes used in the echo buffer to represent operations\n * or special handling of characters.  Bytes in the echo buffer that\n * are not part of such special blocks are treated as normal character\n * codes.\n */\n#define ECHO_OP_START 0xff\n#define ECHO_OP_MOVE_BACK_COL 0x80\n#define ECHO_OP_SET_CANON_COL 0x81\n#define ECHO_OP_ERASE_TAB 0x82\n\n#define ECHO_COMMIT_WATERMARK\t256\n#define ECHO_BLOCK\t\t256\n#define ECHO_DISCARD_WATERMARK\tN_TTY_BUF_SIZE - (ECHO_BLOCK + 32)\n\n\n#undef N_TTY_TRACE\n#ifdef N_TTY_TRACE\n# define n_tty_trace(f, args...)\ttrace_printk(f, ##args)\n#else\n# define n_tty_trace(f, args...)\n#endif\n\nstruct n_tty_data {\n\t/* producer-published */\n\tsize_t read_head;\n\tsize_t commit_head;\n\tsize_t canon_head;\n\tsize_t echo_head;\n\tsize_t echo_commit;\n\tsize_t echo_mark;\n\tDECLARE_BITMAP(char_map, 256);\n\n\t/* private to n_tty_receive_overrun (single-threaded) */\n\tunsigned long overrun_time;\n\tint num_overrun;\n\n\t/* non-atomic */\n\tbool no_room;\n\n\t/* must hold exclusive termios_rwsem to reset these */\n\tunsigned char lnext:1, erasing:1, raw:1, real_raw:1, icanon:1;\n\tunsigned char push:1;\n\n\t/* shared by producer and consumer */\n\tchar read_buf[N_TTY_BUF_SIZE];\n\tDECLARE_BITMAP(read_flags, N_TTY_BUF_SIZE);\n\tunsigned char echo_buf[N_TTY_BUF_SIZE];\n\n\t/* consumer-published */\n\tsize_t read_tail;\n\tsize_t line_start;\n\n\t/* protected by output lock */\n\tunsigned int column;\n\tunsigned int canon_column;\n\tsize_t echo_tail;\n\n\tstruct mutex atomic_read_lock;\n\tstruct mutex output_lock;\n};\n\nstatic inline size_t read_cnt(struct n_tty_data *ldata)\n{\n\treturn ldata->read_head - ldata->read_tail;\n}\n\nstatic inline unsigned char read_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char *read_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char echo_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char *echo_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic int tty_copy_to_user(struct tty_struct *tty, void __user *to,\n\t\t\t    size_t tail, size_t n)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t size = N_TTY_BUF_SIZE - tail;\n\tconst void *from = read_buf_addr(ldata, tail);\n\tint uncopied;\n\n\tif (n > size) {\n\t\ttty_audit_add_data(tty, from, size);\n\t\tuncopied = copy_to_user(to, from, size);\n\t\tif (uncopied)\n\t\t\treturn uncopied;\n\t\tto += size;\n\t\tn -= size;\n\t\tfrom = ldata->read_buf;\n\t}\n\n\ttty_audit_add_data(tty, from, n);\n\treturn copy_to_user(to, from, n);\n}\n\n/**\n *\tn_tty_kick_worker - start input worker (if required)\n *\t@tty: terminal\n *\n *\tRe-schedules the flip buffer work if it may have stopped\n *\n *\tCaller holds exclusive termios_rwsem\n *\t   or\n *\tn_tty_read()/consumer path:\n *\t\tholds non-exclusive termios_rwsem\n */\n\nstatic void n_tty_kick_worker(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t/* Did the input worker stop? Restart it */\n\tif (unlikely(ldata->no_room)) {\n\t\tldata->no_room = 0;\n\n\t\tWARN_RATELIMIT(tty->port->itty == NULL,\n\t\t\t\t\"scheduling with invalid itty\\n\");\n\t\t/* see if ldisc has been killed - if so, this means that\n\t\t * even though the ldisc has been halted and ->buf.work\n\t\t * cancelled, ->buf.work is about to be rescheduled\n\t\t */\n\t\tWARN_RATELIMIT(test_bit(TTY_LDISC_HALTED, &tty->flags),\n\t\t\t       \"scheduling buffer work for halted ldisc\\n\");\n\t\ttty_buffer_restart_work(tty->port);\n\t}\n}\n\nstatic ssize_t chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tssize_t n = 0;\n\n\tif (!ldata->icanon)\n\t\tn = ldata->commit_head - ldata->read_tail;\n\telse\n\t\tn = ldata->canon_head - ldata->read_tail;\n\treturn n;\n}\n\n/**\n *\tn_tty_write_wakeup\t-\tasynchronous I/O notifier\n *\t@tty: tty device\n *\n *\tRequired for the ptys, serial driver etc. since processes\n *\tthat attach themselves to the master and rely on ASYNC\n *\tIO must be woken up\n */\n\nstatic void n_tty_write_wakeup(struct tty_struct *tty)\n{\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tkill_fasync(&tty->fasync, SIGIO, POLL_OUT);\n}\n\nstatic void n_tty_check_throttle(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t/*\n\t * Check the remaining room for the input canonicalization\n\t * mode.  We don't want to throttle the driver if we're in\n\t * canonical mode and don't have a newline yet!\n\t */\n\tif (ldata->icanon && ldata->canon_head == ldata->read_tail)\n\t\treturn;\n\n\twhile (1) {\n\t\tint throttled;\n\t\ttty_set_flow_change(tty, TTY_THROTTLE_SAFE);\n\t\tif (N_TTY_BUF_SIZE - read_cnt(ldata) >= TTY_THRESHOLD_THROTTLE)\n\t\t\tbreak;\n\t\tthrottled = tty_throttle_safe(tty);\n\t\tif (!throttled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\nstatic void n_tty_check_unthrottle(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\treturn;\n\t\tn_tty_kick_worker(tty);\n\t\ttty_wakeup(tty->link);\n\t\treturn;\n\t}\n\n\t/* If there is enough space in the read buffer now, let the\n\t * low-level driver know. We use chars_in_buffer() to\n\t * check the buffer, as it now knows about canonical mode.\n\t * Otherwise, if the driver is throttled and the line is\n\t * longer than TTY_THRESHOLD_UNTHROTTLE in canonical mode,\n\t * we won't get any more characters.\n\t */\n\n\twhile (1) {\n\t\tint unthrottled;\n\t\ttty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\tbreak;\n\t\tn_tty_kick_worker(tty);\n\t\tunthrottled = tty_unthrottle_safe(tty);\n\t\tif (!unthrottled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\n/**\n *\tput_tty_queue\t\t-\tadd character to tty\n *\t@c: character\n *\t@ldata: n_tty data\n *\n *\tAdd a character to the tty read_buf queue.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n */\n\nstatic inline void put_tty_queue(unsigned char c, struct n_tty_data *ldata)\n{\n\t*read_buf_addr(ldata, ldata->read_head) = c;\n\tldata->read_head++;\n}\n\n/**\n *\treset_buffer_flags\t-\treset buffer state\n *\t@tty: terminal to reset\n *\n *\tReset the read buffer counters and clear the flags.\n *\tCalled from n_tty_open() and n_tty_flush_buffer().\n *\n *\tLocking: caller holds exclusive termios_rwsem\n *\t\t (or locking is not required)\n */\n\nstatic void reset_buffer_flags(struct n_tty_data *ldata)\n{\n\tldata->read_head = ldata->canon_head = ldata->read_tail = 0;\n\tldata->echo_head = ldata->echo_tail = ldata->echo_commit = 0;\n\tldata->commit_head = 0;\n\tldata->echo_mark = 0;\n\tldata->line_start = 0;\n\n\tldata->erasing = 0;\n\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\tldata->push = 0;\n}\n\nstatic void n_tty_packet_mode_flush(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tif (tty->link->packet) {\n\t\tspin_lock_irqsave(&tty->ctrl_lock, flags);\n\t\ttty->ctrl_status |= TIOCPKT_FLUSHREAD;\n\t\tspin_unlock_irqrestore(&tty->ctrl_lock, flags);\n\t\twake_up_interruptible(&tty->link->read_wait);\n\t}\n}\n\n/**\n *\tn_tty_flush_buffer\t-\tclean input queue\n *\t@tty:\tterminal device\n *\n *\tFlush the input buffer. Called when the tty layer wants the\n *\tbuffer flushed (eg at hangup) or when the N_TTY line discipline\n *\tinternally has to clean the pending queue (for example some signals).\n *\n *\tHolds termios_rwsem to exclude producer/consumer while\n *\tbuffer indices are reset.\n *\n *\tLocking: ctrl_lock, exclusive termios_rwsem\n */\n\nstatic void n_tty_flush_buffer(struct tty_struct *tty)\n{\n\tdown_write(&tty->termios_rwsem);\n\treset_buffer_flags(tty->disc_data);\n\tn_tty_kick_worker(tty);\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tup_write(&tty->termios_rwsem);\n}\n\n/**\n *\tis_utf8_continuation\t-\tutf8 multibyte check\n *\t@c: byte to check\n *\n *\tReturns true if the utf8 character 'c' is a multibyte continuation\n *\tcharacter. We use this to correctly compute the on screen size\n *\tof the character when printing\n */\n\nstatic inline int is_utf8_continuation(unsigned char c)\n{\n\treturn (c & 0xc0) == 0x80;\n}\n\n/**\n *\tis_continuation\t\t-\tmultibyte check\n *\t@c: byte to check\n *\n *\tReturns true if the utf8 character 'c' is a multibyte continuation\n *\tcharacter and the terminal is in unicode mode.\n */\n\nstatic inline int is_continuation(unsigned char c, struct tty_struct *tty)\n{\n\treturn I_IUTF8(tty) && is_utf8_continuation(c);\n}\n\n/**\n *\tdo_output_char\t\t\t-\toutput one character\n *\t@c: character (or partial unicode symbol)\n *\t@tty: terminal device\n *\t@space: space available in tty driver write buffer\n *\n *\tThis is a helper function that handles one output character\n *\t(including special characters like TAB, CR, LF, etc.),\n *\tdoing OPOST processing and putting the results in the\n *\ttty driver's write buffer.\n *\n *\tNote that Linux currently ignores TABDLY, CRDLY, VTDLY, FFDLY\n *\tand NLDLY.  They simply aren't relevant in the world today.\n *\tIf you ever need them, add them here.\n *\n *\tReturns the number of bytes of buffer space used or -1 if\n *\tno space left.\n *\n *\tLocking: should be called under the output_lock to protect\n *\t\t the column state and space left in the buffer\n */\n\nstatic int do_output_char(unsigned char c, struct tty_struct *tty, int space)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspaces;\n\n\tif (!space)\n\t\treturn -1;\n\n\tswitch (c) {\n\tcase '\\n':\n\t\tif (O_ONLRET(tty))\n\t\t\tldata->column = 0;\n\t\tif (O_ONLCR(tty)) {\n\t\t\tif (space < 2)\n\t\t\t\treturn -1;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\ttty->ops->write(tty, \"\\r\\n\", 2);\n\t\t\treturn 2;\n\t\t}\n\t\tldata->canon_column = ldata->column;\n\t\tbreak;\n\tcase '\\r':\n\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\treturn 0;\n\t\tif (O_OCRNL(tty)) {\n\t\t\tc = '\\n';\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\t}\n\t\tldata->canon_column = ldata->column = 0;\n\t\tbreak;\n\tcase '\\t':\n\t\tspaces = 8 - (ldata->column & 7);\n\t\tif (O_TABDLY(tty) == XTABS) {\n\t\t\tif (space < spaces)\n\t\t\t\treturn -1;\n\t\t\tldata->column += spaces;\n\t\t\ttty->ops->write(tty, \"        \", spaces);\n\t\t\treturn spaces;\n\t\t}\n\t\tldata->column += spaces;\n\t\tbreak;\n\tcase '\\b':\n\t\tif (ldata->column > 0)\n\t\t\tldata->column--;\n\t\tbreak;\n\tdefault:\n\t\tif (!iscntrl(c)) {\n\t\t\tif (O_OLCUC(tty))\n\t\t\t\tc = toupper(c);\n\t\t\tif (!is_continuation(c, tty))\n\t\t\t\tldata->column++;\n\t\t}\n\t\tbreak;\n\t}\n\n\ttty_put_char(tty, c);\n\treturn 1;\n}\n\n/**\n *\tprocess_output\t\t\t-\toutput post processor\n *\t@c: character (or partial unicode symbol)\n *\t@tty: terminal device\n *\n *\tOutput one character with OPOST processing.\n *\tReturns -1 when the output device is full and the character\n *\tmust be retried.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (also, this is called from n_tty_write under the\n *\t\t  tty layer write lock)\n */\n\nstatic int process_output(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, retval;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tretval = do_output_char(c, tty, space);\n\n\tmutex_unlock(&ldata->output_lock);\n\tif (retval < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\n/**\n *\tprocess_output_block\t\t-\tblock post processor\n *\t@tty: terminal device\n *\t@buf: character buffer\n *\t@nr: number of bytes to output\n *\n *\tOutput a block of characters with OPOST processing.\n *\tReturns the number of characters output.\n *\n *\tThis path is used to speed up block console writes, among other\n *\tthings when processing blocks of output data. It handles only\n *\tthe simple cases normally found and helps to generate blocks of\n *\tsymbols for the console driver and thus improve performance.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (also, this is called from n_tty_write under the\n *\t\t  tty layer write lock)\n */\n\nstatic ssize_t process_output_block(struct tty_struct *tty,\n\t\t\t\t    const unsigned char *buf, unsigned int nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace;\n\tint\ti;\n\tconst unsigned char *cp;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tif (!space) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn 0;\n\t}\n\tif (nr > space)\n\t\tnr = space;\n\n\tfor (i = 0, cp = buf; i < nr; i++, cp++) {\n\t\tunsigned char c = *cp;\n\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->column = 0;\n\t\t\tif (O_ONLCR(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column;\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\t\tgoto break_out;\n\t\t\tif (O_OCRNL(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tgoto break_out;\n\t\tcase '\\b':\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(c)) {\n\t\t\t\tif (O_OLCUC(tty))\n\t\t\t\t\tgoto break_out;\n\t\t\t\tif (!is_continuation(c, tty))\n\t\t\t\t\tldata->column++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nbreak_out:\n\ti = tty->ops->write(tty, buf, i);\n\n\tmutex_unlock(&ldata->output_lock);\n\treturn i;\n}\n\n/**\n *\tprocess_echoes\t-\twrite pending echo characters\n *\t@tty: terminal device\n *\n *\tWrite previously buffered echo (and other ldisc-generated)\n *\tcharacters to the tty.\n *\n *\tCharacters generated by the ldisc (including echoes) need to\n *\tbe buffered because the driver's write buffer can fill during\n *\theavy program output.  Echoing straight to the driver will\n *\toften fail under these conditions, causing lost characters and\n *\tresulting mismatches of ldisc state information.\n *\n *\tSince the ldisc state must represent the characters actually sent\n *\tto the driver at the time of the write, operations like certain\n *\tchanges in column state are also saved in the buffer and executed\n *\there.\n *\n *\tA circular fifo buffer is used so that the most recent characters\n *\tare prioritized.  Also, when control characters are echoed with a\n *\tprefixed \"^\", the pair is treated atomically and thus not separated.\n *\n *\tLocking: callers must hold output_lock\n */\n\nstatic size_t __process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, old_space;\n\tsize_t tail;\n\tunsigned char c;\n\n\told_space = space = tty_write_room(tty);\n\n\ttail = ldata->echo_tail;\n\twhile (ldata->echo_commit != tail) {\n\t\tc = echo_buf(ldata, tail);\n\t\tif (c == ECHO_OP_START) {\n\t\t\tunsigned char op;\n\t\t\tint no_space_left = 0;\n\n\t\t\t/*\n\t\t\t * If the buffer byte is the start of a multi-byte\n\t\t\t * operation, get the next byte, which is either the\n\t\t\t * op code or a control character value.\n\t\t\t */\n\t\t\top = echo_buf(ldata, tail + 1);\n\n\t\t\tswitch (op) {\n\t\t\t\tunsigned int num_chars, num_bs;\n\n\t\t\tcase ECHO_OP_ERASE_TAB:\n\t\t\t\tnum_chars = echo_buf(ldata, tail + 2);\n\n\t\t\t\t/*\n\t\t\t\t * Determine how many columns to go back\n\t\t\t\t * in order to erase the tab.\n\t\t\t\t * This depends on the number of columns\n\t\t\t\t * used by other characters within the tab\n\t\t\t\t * area.  If this (modulo 8) count is from\n\t\t\t\t * the start of input rather than from a\n\t\t\t\t * previous tab, we offset by canon column.\n\t\t\t\t * Otherwise, tab spacing is normal.\n\t\t\t\t */\n\t\t\t\tif (!(num_chars & 0x80))\n\t\t\t\t\tnum_chars += ldata->canon_column;\n\t\t\t\tnum_bs = 8 - (num_chars & 7);\n\n\t\t\t\tif (num_bs > space) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspace -= num_bs;\n\t\t\t\twhile (num_bs--) {\n\t\t\t\t\ttty_put_char(tty, '\\b');\n\t\t\t\t\tif (ldata->column > 0)\n\t\t\t\t\t\tldata->column--;\n\t\t\t\t}\n\t\t\t\ttail += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_SET_CANON_COL:\n\t\t\t\tldata->canon_column = ldata->column;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_MOVE_BACK_COL:\n\t\t\t\tif (ldata->column > 0)\n\t\t\t\t\tldata->column--;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_START:\n\t\t\t\t/* This is an escaped echo op start code */\n\t\t\t\tif (!space) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty_put_char(tty, ECHO_OP_START);\n\t\t\t\tldata->column++;\n\t\t\t\tspace--;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * If the op is not a special byte code,\n\t\t\t\t * it is a ctrl char tagged to be echoed\n\t\t\t\t * as \"^X\" (where X is the letter\n\t\t\t\t * representing the control char).\n\t\t\t\t * Note that we must ensure there is\n\t\t\t\t * enough space for the whole ctrl pair.\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (space < 2) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty_put_char(tty, '^');\n\t\t\t\ttty_put_char(tty, op ^ 0100);\n\t\t\t\tldata->column += 2;\n\t\t\t\tspace -= 2;\n\t\t\t\ttail += 2;\n\t\t\t}\n\n\t\t\tif (no_space_left)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (O_OPOST(tty)) {\n\t\t\t\tint retval = do_output_char(c, tty, space);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tspace -= retval;\n\t\t\t} else {\n\t\t\t\tif (!space)\n\t\t\t\t\tbreak;\n\t\t\t\ttty_put_char(tty, c);\n\t\t\t\tspace -= 1;\n\t\t\t}\n\t\t\ttail += 1;\n\t\t}\n\t}\n\n\t/* If the echo buffer is nearly full (so that the possibility exists\n\t * of echo overrun before the next commit), then discard enough\n\t * data at the tail to prevent a subsequent overrun */\n\twhile (ldata->echo_commit - tail >= ECHO_DISCARD_WATERMARK) {\n\t\tif (echo_buf(ldata, tail) == ECHO_OP_START) {\n\t\t\tif (echo_buf(ldata, tail + 1) == ECHO_OP_ERASE_TAB)\n\t\t\t\ttail += 3;\n\t\t\telse\n\t\t\t\ttail += 2;\n\t\t} else\n\t\t\ttail++;\n\t}\n\n\tldata->echo_tail = tail;\n\treturn old_space - space;\n}\n\nstatic void commit_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t nr, old, echoed;\n\tsize_t head;\n\n\thead = ldata->echo_head;\n\tldata->echo_mark = head;\n\told = ldata->echo_commit - ldata->echo_tail;\n\n\t/* Process committed echoes if the accumulated # of bytes\n\t * is over the threshold (and try again each time another\n\t * block is accumulated) */\n\tnr = head - ldata->echo_tail;\n\tif (nr < ECHO_COMMIT_WATERMARK || (nr % ECHO_BLOCK > old % ECHO_BLOCK))\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = head;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\nstatic void process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t echoed;\n\n\tif (ldata->echo_mark == ldata->echo_tail)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_mark;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\n/* NB: echo_mark and echo_head should be equivalent here */\nstatic void flush_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif ((!L_ECHO(tty) && !L_ECHONL(tty)) ||\n\t    ldata->echo_commit == ldata->echo_head)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_head;\n\t__process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n}\n\n/**\n *\tadd_echo_byte\t-\tadd a byte to the echo buffer\n *\t@c: unicode byte to echo\n *\t@ldata: n_tty data\n *\n *\tAdd a character or operation byte to the echo buffer.\n */\n\nstatic inline void add_echo_byte(unsigned char c, struct n_tty_data *ldata)\n{\n\t*echo_buf_addr(ldata, ldata->echo_head++) = c;\n}\n\n/**\n *\techo_move_back_col\t-\tadd operation to move back a column\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to move back one column.\n */\n\nstatic void echo_move_back_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_MOVE_BACK_COL, ldata);\n}\n\n/**\n *\techo_set_canon_col\t-\tadd operation to set the canon column\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to set the canon column\n *\tto the current column.\n */\n\nstatic void echo_set_canon_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_SET_CANON_COL, ldata);\n}\n\n/**\n *\techo_erase_tab\t-\tadd operation to erase a tab\n *\t@num_chars: number of character columns already used\n *\t@after_tab: true if num_chars starts after a previous tab\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to erase a tab.\n *\n *\tCalled by the eraser function, which knows how many character\n *\tcolumns have been used since either a previous tab or the start\n *\tof input.  This information will be used later, along with\n *\tcanon column (if applicable), to go back the correct number\n *\tof columns.\n */\n\nstatic void echo_erase_tab(unsigned int num_chars, int after_tab,\n\t\t\t   struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_ERASE_TAB, ldata);\n\n\t/* We only need to know this modulo 8 (tab spacing) */\n\tnum_chars &= 7;\n\n\t/* Set the high bit as a flag if num_chars is after a previous tab */\n\tif (after_tab)\n\t\tnum_chars |= 0x80;\n\n\tadd_echo_byte(num_chars, ldata);\n}\n\n/**\n *\techo_char_raw\t-\techo a character raw\n *\t@c: unicode byte to echo\n *\t@tty: terminal device\n *\n *\tEcho user input back onto the screen. This must be called only when\n *\tL_ECHO(tty) is true. Called from the driver receive_buf path.\n *\n *\tThis variant does not treat control characters specially.\n */\n\nstatic void echo_char_raw(unsigned char c, struct n_tty_data *ldata)\n{\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n/**\n *\techo_char\t-\techo a character\n *\t@c: unicode byte to echo\n *\t@tty: terminal device\n *\n *\tEcho user input back onto the screen. This must be called only when\n *\tL_ECHO(tty) is true. Called from the driver receive_buf path.\n *\n *\tThis variant tags control characters to be echoed as \"^X\"\n *\t(where X is the letter representing the control char).\n */\n\nstatic void echo_char(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tif (L_ECHOCTL(tty) && iscntrl(c) && c != '\\t')\n\t\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n/**\n *\tfinish_erasing\t\t-\tcomplete erase\n *\t@ldata: n_tty data\n */\n\nstatic inline void finish_erasing(struct n_tty_data *ldata)\n{\n\tif (ldata->erasing) {\n\t\techo_char_raw('/', ldata);\n\t\tldata->erasing = 0;\n\t}\n}\n\n/**\n *\teraser\t\t-\thandle erase function\n *\t@c: character input\n *\t@tty: terminal device\n *\n *\tPerform erase and necessary output when an erase character is\n *\tpresent in the stream from the driver layer. Handles the complexities\n *\tof UTF-8 multibyte symbols.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n */\n\nstatic void eraser(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tenum { ERASE, WERASE, KILL } kill_type;\n\tsize_t head;\n\tsize_t cnt;\n\tint seen_alnums;\n\n\tif (ldata->read_head == ldata->canon_head) {\n\t\t/* process_output('\\a', tty); */ /* what do you think? */\n\t\treturn;\n\t}\n\tif (c == ERASE_CHAR(tty))\n\t\tkill_type = ERASE;\n\telse if (c == WERASE_CHAR(tty))\n\t\tkill_type = WERASE;\n\telse {\n\t\tif (!L_ECHO(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\treturn;\n\t\t}\n\t\tif (!L_ECHOK(tty) || !L_ECHOKE(tty) || !L_ECHOE(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\tfinish_erasing(ldata);\n\t\t\techo_char(KILL_CHAR(tty), tty);\n\t\t\t/* Add a newline if ECHOK is on and ECHOKE is off. */\n\t\t\tif (L_ECHOK(tty))\n\t\t\t\techo_char_raw('\\n', ldata);\n\t\t\treturn;\n\t\t}\n\t\tkill_type = KILL;\n\t}\n\n\tseen_alnums = 0;\n\twhile (ldata->read_head != ldata->canon_head) {\n\t\thead = ldata->read_head;\n\n\t\t/* erase a single possibly multibyte character */\n\t\tdo {\n\t\t\thead--;\n\t\t\tc = read_buf(ldata, head);\n\t\t} while (is_continuation(c, tty) && head != ldata->canon_head);\n\n\t\t/* do not partially erase */\n\t\tif (is_continuation(c, tty))\n\t\t\tbreak;\n\n\t\tif (kill_type == WERASE) {\n\t\t\t/* Equivalent to BSD's ALTWERASE. */\n\t\t\tif (isalnum(c) || c == '_')\n\t\t\t\tseen_alnums++;\n\t\t\telse if (seen_alnums)\n\t\t\t\tbreak;\n\t\t}\n\t\tcnt = ldata->read_head - head;\n\t\tldata->read_head = head;\n\t\tif (L_ECHO(tty)) {\n\t\t\tif (L_ECHOPRT(tty)) {\n\t\t\t\tif (!ldata->erasing) {\n\t\t\t\t\techo_char_raw('\\\\', ldata);\n\t\t\t\t\tldata->erasing = 1;\n\t\t\t\t}\n\t\t\t\t/* if cnt > 1, output a multi-byte character */\n\t\t\t\techo_char(c, tty);\n\t\t\t\twhile (--cnt > 0) {\n\t\t\t\t\thead++;\n\t\t\t\t\techo_char_raw(read_buf(ldata, head), ldata);\n\t\t\t\t\techo_move_back_col(ldata);\n\t\t\t\t}\n\t\t\t} else if (kill_type == ERASE && !L_ECHOE(tty)) {\n\t\t\t\techo_char(ERASE_CHAR(tty), tty);\n\t\t\t} else if (c == '\\t') {\n\t\t\t\tunsigned int num_chars = 0;\n\t\t\t\tint after_tab = 0;\n\t\t\t\tsize_t tail = ldata->read_head;\n\n\t\t\t\t/*\n\t\t\t\t * Count the columns used for characters\n\t\t\t\t * since the start of input or after a\n\t\t\t\t * previous tab.\n\t\t\t\t * This info is used to go back the correct\n\t\t\t\t * number of columns.\n\t\t\t\t */\n\t\t\t\twhile (tail != ldata->canon_head) {\n\t\t\t\t\ttail--;\n\t\t\t\t\tc = read_buf(ldata, tail);\n\t\t\t\t\tif (c == '\\t') {\n\t\t\t\t\t\tafter_tab = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (iscntrl(c)) {\n\t\t\t\t\t\tif (L_ECHOCTL(tty))\n\t\t\t\t\t\t\tnum_chars += 2;\n\t\t\t\t\t} else if (!is_continuation(c, tty)) {\n\t\t\t\t\t\tnum_chars++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\techo_erase_tab(num_chars, after_tab, ldata);\n\t\t\t} else {\n\t\t\t\tif (iscntrl(c) && L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t\tif (!iscntrl(c) || L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (kill_type == ERASE)\n\t\t\tbreak;\n\t}\n\tif (ldata->read_head == ldata->canon_head && L_ECHO(tty))\n\t\tfinish_erasing(ldata);\n}\n\n/**\n *\tisig\t\t-\thandle the ISIG optio\n *\t@sig: signal\n *\t@tty: terminal\n *\n *\tCalled when a signal is being sent due to terminal input.\n *\tCalled from the driver receive_buf path so serialized.\n *\n *\tPerforms input and output flush if !NOFLSH. In this context, the echo\n *\tbuffer is 'output'. The signal is processed first to alert any current\n *\treaders or writers to discontinue and exit their i/o loops.\n *\n *\tLocking: ctrl_lock\n */\n\nstatic void __isig(int sig, struct tty_struct *tty)\n{\n\tstruct pid *tty_pgrp = tty_get_pgrp(tty);\n\tif (tty_pgrp) {\n\t\tkill_pgrp(tty_pgrp, sig, 1);\n\t\tput_pid(tty_pgrp);\n\t}\n}\n\nstatic void isig(int sig, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (L_NOFLSH(tty)) {\n\t\t/* signal only */\n\t\t__isig(sig, tty);\n\n\t} else { /* signal and flush */\n\t\tup_read(&tty->termios_rwsem);\n\t\tdown_write(&tty->termios_rwsem);\n\n\t\t__isig(sig, tty);\n\n\t\t/* clear echo buffer */\n\t\tmutex_lock(&ldata->output_lock);\n\t\tldata->echo_head = ldata->echo_tail = 0;\n\t\tldata->echo_mark = ldata->echo_commit = 0;\n\t\tmutex_unlock(&ldata->output_lock);\n\n\t\t/* clear output buffer */\n\t\ttty_driver_flush_buffer(tty);\n\n\t\t/* clear input buffer */\n\t\treset_buffer_flags(tty->disc_data);\n\n\t\t/* notify pty master of flush */\n\t\tif (tty->link)\n\t\t\tn_tty_packet_mode_flush(tty);\n\n\t\tup_write(&tty->termios_rwsem);\n\t\tdown_read(&tty->termios_rwsem);\n\t}\n}\n\n/**\n *\tn_tty_receive_break\t-\thandle break\n *\t@tty: terminal\n *\n *\tAn RS232 break event has been hit in the incoming bitstream. This\n *\tcan cause a variety of events depending upon the termios settings.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\n *\tNote: may get exclusive termios_rwsem if flushing input buffer\n */\n\nstatic void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n}\n\n/**\n *\tn_tty_receive_overrun\t-\thandle overrun reporting\n *\t@tty: terminal\n *\n *\tData arrived faster than we could process it. While the tty\n *\tdriver has flagged this the bits that were missed are gone\n *\tforever.\n *\n *\tCalled from the receive_buf path so single threaded. Does not\n *\tneed locking as num_overrun and overrun_time are function\n *\tprivate.\n */\n\nstatic void n_tty_receive_overrun(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tldata->num_overrun++;\n\tif (time_after(jiffies, ldata->overrun_time + HZ) ||\n\t\t\ttime_after(ldata->overrun_time, jiffies)) {\n\t\ttty_warn(tty, \"%d input overrun(s)\\n\", ldata->num_overrun);\n\t\tldata->overrun_time = jiffies;\n\t\tldata->num_overrun = 0;\n\t}\n}\n\n/**\n *\tn_tty_receive_parity_error\t-\terror notifier\n *\t@tty: terminal device\n *\t@c: character\n *\n *\tProcess a parity error and queue the right data to indicate\n *\tthe error case if necessary.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n */\nstatic void n_tty_receive_parity_error(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_INPCK(tty)) {\n\t\tif (I_IGNPAR(tty))\n\t\t\treturn;\n\t\tif (I_PARMRK(tty)) {\n\t\t\tput_tty_queue('\\377', ldata);\n\t\t\tput_tty_queue('\\0', ldata);\n\t\t\tput_tty_queue(c, ldata);\n\t\t} else\n\t\t\tput_tty_queue('\\0', ldata);\n\t} else\n\t\tput_tty_queue(c, ldata);\n}\n\nstatic void\nn_tty_receive_signal_char(struct tty_struct *tty, int signal, unsigned char c)\n{\n\tisig(signal, tty);\n\tif (I_IXON(tty))\n\t\tstart_tty(tty);\n\tif (L_ECHO(tty)) {\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t} else\n\t\tprocess_echoes(tty);\n\treturn;\n}\n\n/**\n *\tn_tty_receive_char\t-\tperform processing\n *\t@tty: terminal device\n *\t@c: character\n *\n *\tProcess an individual character of input received from the driver.\n *\tThis is serialized with respect to itself by the rules for the\n *\tdriver above.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tpublishes canon_head if canonical mode is active\n *\n *\tReturns 1 if LNEXT was received, else returns 0\n */\n\nstatic int\nn_tty_receive_char_special(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IXON(tty)) {\n\t\tif (c == START_CHAR(tty)) {\n\t\t\tstart_tty(tty);\n\t\t\tprocess_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == STOP_CHAR(tty)) {\n\t\t\tstop_tty(tty);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (L_ISIG(tty)) {\n\t\tif (c == INTR_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGINT, c);\n\t\t\treturn 0;\n\t\t} else if (c == QUIT_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGQUIT, c);\n\t\t\treturn 0;\n\t\t} else if (c == SUSP_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGTSTP, c);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\tif (c == '\\r') {\n\t\tif (I_IGNCR(tty))\n\t\t\treturn 0;\n\t\tif (I_ICRNL(tty))\n\t\t\tc = '\\n';\n\t} else if (c == '\\n' && I_INLCR(tty))\n\t\tc = '\\r';\n\n\tif (ldata->icanon) {\n\t\tif (c == ERASE_CHAR(tty) || c == KILL_CHAR(tty) ||\n\t\t    (c == WERASE_CHAR(tty) && L_IEXTEN(tty))) {\n\t\t\teraser(c, tty);\n\t\t\tcommit_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == LNEXT_CHAR(tty) && L_IEXTEN(tty)) {\n\t\t\tldata->lnext = 1;\n\t\t\tif (L_ECHO(tty)) {\n\t\t\t\tfinish_erasing(ldata);\n\t\t\t\tif (L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('^', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\tcommit_echoes(tty);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (c == REPRINT_CHAR(tty) && L_ECHO(tty) && L_IEXTEN(tty)) {\n\t\t\tsize_t tail = ldata->canon_head;\n\n\t\t\tfinish_erasing(ldata);\n\t\t\techo_char(c, tty);\n\t\t\techo_char_raw('\\n', ldata);\n\t\t\twhile (tail != ldata->read_head) {\n\t\t\t\techo_char(read_buf(ldata, tail), tty);\n\t\t\t\ttail++;\n\t\t\t}\n\t\t\tcommit_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\tif (L_ECHO(tty) || L_ECHONL(tty)) {\n\t\t\t\techo_char_raw('\\n', ldata);\n\t\t\t\tcommit_echoes(tty);\n\t\t\t}\n\t\t\tgoto handle_newline;\n\t\t}\n\t\tif (c == EOF_CHAR(tty)) {\n\t\t\tc = __DISABLED_CHAR;\n\t\t\tgoto handle_newline;\n\t\t}\n\t\tif ((c == EOL_CHAR(tty)) ||\n\t\t    (c == EOL2_CHAR(tty) && L_IEXTEN(tty))) {\n\t\t\t/*\n\t\t\t * XXX are EOL_CHAR and EOL2_CHAR echoed?!?\n\t\t\t */\n\t\t\tif (L_ECHO(tty)) {\n\t\t\t\t/* Record the column of first canon char. */\n\t\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\t\techo_set_canon_col(ldata);\n\t\t\t\techo_char(c, tty);\n\t\t\t\tcommit_echoes(tty);\n\t\t\t}\n\t\t\t/*\n\t\t\t * XXX does PARMRK doubling happen for\n\t\t\t * EOL_CHAR and EOL2_CHAR?\n\t\t\t */\n\t\t\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\t\t\tput_tty_queue(c, ldata);\n\nhandle_newline:\n\t\t\tset_bit(ldata->read_head & (N_TTY_BUF_SIZE - 1), ldata->read_flags);\n\t\t\tput_tty_queue(c, ldata);\n\t\t\tsmp_store_release(&ldata->canon_head, ldata->read_head);\n\t\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\t\t\twake_up_interruptible_poll(&tty->read_wait, POLLIN);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\tif (c == '\\n')\n\t\t\techo_char_raw('\\n', ldata);\n\t\telse {\n\t\t\t/* Record the column of first canon char. */\n\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\techo_set_canon_col(ldata);\n\t\t\techo_char(c, tty);\n\t\t}\n\t\tcommit_echoes(tty);\n\t}\n\n\t/* PARMRK doubling check */\n\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\n\tput_tty_queue(c, ldata);\n\treturn 0;\n}\n\nstatic inline void\nn_tty_receive_char_inline(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\t/* Record the column of first canon char. */\n\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\techo_set_canon_col(ldata);\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t}\n\t/* PARMRK doubling check */\n\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\tput_tty_queue(c, ldata);\n}\n\nstatic void n_tty_receive_char(struct tty_struct *tty, unsigned char c)\n{\n\tn_tty_receive_char_inline(tty, c);\n}\n\nstatic inline void\nn_tty_receive_char_fast(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\t/* Record the column of first canon char. */\n\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\techo_set_canon_col(ldata);\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t}\n\tput_tty_queue(c, ldata);\n}\n\nstatic void n_tty_receive_char_closing(struct tty_struct *tty, unsigned char c)\n{\n\tif (I_ISTRIP(tty))\n\t\tc &= 0x7f;\n\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\tc = tolower(c);\n\n\tif (I_IXON(tty)) {\n\t\tif (c == STOP_CHAR(tty))\n\t\t\tstop_tty(tty);\n\t\telse if (c == START_CHAR(tty) ||\n\t\t\t (tty->stopped && !tty->flow_stopped && I_IXANY(tty) &&\n\t\t\t  c != INTR_CHAR(tty) && c != QUIT_CHAR(tty) &&\n\t\t\t  c != SUSP_CHAR(tty))) {\n\t\t\tstart_tty(tty);\n\t\t\tprocess_echoes(tty);\n\t\t}\n\t}\n}\n\nstatic void\nn_tty_receive_char_flagged(struct tty_struct *tty, unsigned char c, char flag)\n{\n\tswitch (flag) {\n\tcase TTY_BREAK:\n\t\tn_tty_receive_break(tty);\n\t\tbreak;\n\tcase TTY_PARITY:\n\tcase TTY_FRAME:\n\t\tn_tty_receive_parity_error(tty, c);\n\t\tbreak;\n\tcase TTY_OVERRUN:\n\t\tn_tty_receive_overrun(tty);\n\t\tbreak;\n\tdefault:\n\t\ttty_err(tty, \"unknown flag %d\\n\", flag);\n\t\tbreak;\n\t}\n}\n\nstatic void\nn_tty_receive_char_lnext(struct tty_struct *tty, unsigned char c, char flag)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tldata->lnext = 0;\n\tif (likely(flag == TTY_NORMAL)) {\n\t\tif (I_ISTRIP(tty))\n\t\t\tc &= 0x7f;\n\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\tc = tolower(c);\n\t\tn_tty_receive_char(tty, c);\n\t} else\n\t\tn_tty_receive_char_flagged(tty, c, flag);\n}\n\nstatic void\nn_tty_receive_buf_real_raw(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t   char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, head;\n\n\thead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\n\tn = min_t(size_t, count, N_TTY_BUF_SIZE - head);\n\tmemcpy(read_buf_addr(ldata, head), cp, n);\n\tldata->read_head += n;\n\tcp += n;\n\tcount -= n;\n\n\thead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\n\tn = min_t(size_t, count, N_TTY_BUF_SIZE - head);\n\tmemcpy(read_buf_addr(ldata, head), cp, n);\n\tldata->read_head += n;\n}\n\nstatic void\nn_tty_receive_buf_raw(struct tty_struct *tty, const unsigned char *cp,\n\t\t      char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tput_tty_queue(*cp++, ldata);\n\t\telse\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tn_tty_receive_char_closing(tty, *cp++);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_standard(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL)) {\n\t\t\tunsigned char c = *cp++;\n\n\t\t\tif (I_ISTRIP(tty))\n\t\t\t\tc &= 0x7f;\n\t\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\t\tc = tolower(c);\n\t\t\tif (L_EXTPROC(tty)) {\n\t\t\t\tput_tty_queue(c, ldata);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!test_bit(c, ldata->char_map))\n\t\t\t\tn_tty_receive_char_inline(tty, c);\n\t\t\telse if (n_tty_receive_char_special(tty, c) && count) {\n\t\t\t\tif (fp)\n\t\t\t\t\tflag = *fp++;\n\t\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t} else\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_fast(struct tty_struct *tty, const unsigned char *cp,\n\t\t       char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL)) {\n\t\t\tunsigned char c = *cp++;\n\n\t\t\tif (!test_bit(c, ldata->char_map))\n\t\t\t\tn_tty_receive_char_fast(tty, c);\n\t\t\telse if (n_tty_receive_char_special(tty, c) && count) {\n\t\t\t\tif (fp)\n\t\t\t\t\tflag = *fp++;\n\t\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t} else\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void __receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tbool preops = I_ISTRIP(tty) || (I_IUCLC(tty) && L_IEXTEN(tty));\n\n\tif (ldata->real_raw)\n\t\tn_tty_receive_buf_real_raw(tty, cp, fp, count);\n\telse if (ldata->raw || (L_EXTPROC(tty) && !preops))\n\t\tn_tty_receive_buf_raw(tty, cp, fp, count);\n\telse if (tty->closing && !L_EXTPROC(tty))\n\t\tn_tty_receive_buf_closing(tty, cp, fp, count);\n\telse {\n\t\tif (ldata->lnext) {\n\t\t\tchar flag = TTY_NORMAL;\n\n\t\t\tif (fp)\n\t\t\t\tflag = *fp++;\n\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\tcount--;\n\t\t}\n\n\t\tif (!preops && !I_PARMRK(tty))\n\t\t\tn_tty_receive_buf_fast(tty, cp, fp, count);\n\t\telse\n\t\t\tn_tty_receive_buf_standard(tty, cp, fp, count);\n\n\t\tflush_echoes(tty);\n\t\tif (tty->ops->flush_chars)\n\t\t\ttty->ops->flush_chars(tty);\n\t}\n\n\tif (ldata->icanon && !L_EXTPROC(tty))\n\t\treturn;\n\n\t/* publish read_head to consumer */\n\tsmp_store_release(&ldata->commit_head, ldata->read_head);\n\n\tif (read_cnt(ldata)) {\n\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\t\twake_up_interruptible_poll(&tty->read_wait, POLLIN);\n\t}\n}\n\n/**\n *\tn_tty_receive_buf_common\t-\tprocess input\n *\t@tty: device to receive input\n *\t@cp: input chars\n *\t@fp: flags for each char (if NULL, all chars are TTY_NORMAL)\n *\t@count: number of input chars in @cp\n *\n *\tCalled by the terminal driver when a block of characters has\n *\tbeen received. This function must be called from soft contexts\n *\tnot from interrupt context. The driver is responsible for making\n *\tcalls one at a time and in order (or using flush_to_ldisc)\n *\n *\tReturns the # of input chars from @cp which were processed.\n *\n *\tIn canonical mode, the maximum line length is 4096 chars (including\n *\tthe line termination char); lines longer than 4096 chars are\n *\ttruncated. After 4095 chars, input data is still processed but\n *\tnot stored. Overflow processing ensures the tty can always\n *\treceive more input until at least one line can be read.\n *\n *\tIn non-canonical mode, the read buffer will only accept 4095 chars;\n *\tthis provides the necessary space for a newline char if the input\n *\tmode is switched to canonical.\n *\n *\tNote it is possible for the read buffer to _contain_ 4096 chars\n *\tin non-canonical mode: the read buffer could already contain the\n *\tmaximum canon line of 4096 chars when the mode is switched to\n *\tnon-canonical.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tclaims non-exclusive termios_rwsem\n *\t\tpublishes commit_head or canon_head\n */\nstatic int\nn_tty_receive_buf_common(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t char *fp, int count, int flow)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint room, n, rcvd = 0, overflow;\n\n\tdown_read(&tty->termios_rwsem);\n\n\twhile (1) {\n\t\t/*\n\t\t * When PARMRK is set, each input char may take up to 3 chars\n\t\t * in the read buf; reduce the buffer space avail by 3x\n\t\t *\n\t\t * If we are doing input canonicalization, and there are no\n\t\t * pending newlines, let characters through without limit, so\n\t\t * that erase characters will be handled.  Other excess\n\t\t * characters will be beeped.\n\t\t *\n\t\t * paired with store in *_copy_from_read_buf() -- guarantees\n\t\t * the consumer has loaded the data in read_buf up to the new\n\t\t * read_tail (so this producer will not overwrite unread data)\n\t\t */\n\t\tsize_t tail = smp_load_acquire(&ldata->read_tail);\n\n\t\troom = N_TTY_BUF_SIZE - (ldata->read_head - tail);\n\t\tif (I_PARMRK(tty))\n\t\t\troom = (room + 2) / 3;\n\t\troom--;\n\t\tif (room <= 0) {\n\t\t\toverflow = ldata->icanon && ldata->canon_head == tail;\n\t\t\tif (overflow && room < 0)\n\t\t\t\tldata->read_head--;\n\t\t\troom = overflow;\n\t\t\tldata->no_room = flow && !room;\n\t\t} else\n\t\t\toverflow = 0;\n\n\t\tn = min(count, room);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\t/* ignore parity errors if handling overflow */\n\t\tif (!overflow || !fp || *fp != TTY_PARITY)\n\t\t\t__receive_buf(tty, cp, fp, n);\n\n\t\tcp += n;\n\t\tif (fp)\n\t\t\tfp += n;\n\t\tcount -= n;\n\t\trcvd += n;\n\t}\n\n\ttty->receive_room = room;\n\n\t/* Unthrottle if handling overflow on pty */\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\n\t\tif (overflow) {\n\t\t\ttty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n\t\t\ttty_unthrottle_safe(tty);\n\t\t\t__tty_set_flow_change(tty, 0);\n\t\t}\n\t} else\n\t\tn_tty_check_throttle(tty);\n\n\tup_read(&tty->termios_rwsem);\n\n\treturn rcvd;\n}\n\nstatic void n_tty_receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\tn_tty_receive_buf_common(tty, cp, fp, count, 0);\n}\n\nstatic int n_tty_receive_buf2(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\treturn n_tty_receive_buf_common(tty, cp, fp, count, 1);\n}\n\n/**\n *\tn_tty_set_termios\t-\ttermios data changed\n *\t@tty: terminal\n *\t@old: previous data\n *\n *\tCalled by the tty layer when the user changes termios flags so\n *\tthat the line discipline can plan ahead. This function cannot sleep\n *\tand is protected from re-entry by the tty layer. The user is\n *\tguaranteed that this function will not be re-entered or in progress\n *\twhen the ldisc is closed.\n *\n *\tLocking: Caller holds tty->termios_rwsem\n */\n\nstatic void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {\n\t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\t\tldata->line_start = ldata->read_tail;\n\t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n\t\t\tldata->canon_head = ldata->read_tail;\n\t\t\tldata->push = 0;\n\t\t} else {\n\t\t\tset_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),\n\t\t\t\tldata->read_flags);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tldata->push = 1;\n\t\t}\n\t\tldata->commit_head = ldata->read_head;\n\t\tldata->erasing = 0;\n\t\tldata->lnext = 0;\n\t}\n\n\tldata->icanon = (L_ICANON(tty) != 0);\n\n\tif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\n\t    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\n\t    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\n\t    I_PARMRK(tty)) {\n\t\tbitmap_zero(ldata->char_map, 256);\n\n\t\tif (I_IGNCR(tty) || I_ICRNL(tty))\n\t\t\tset_bit('\\r', ldata->char_map);\n\t\tif (I_INLCR(tty))\n\t\t\tset_bit('\\n', ldata->char_map);\n\n\t\tif (L_ICANON(tty)) {\n\t\t\tset_bit(ERASE_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(KILL_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(EOF_CHAR(tty), ldata->char_map);\n\t\t\tset_bit('\\n', ldata->char_map);\n\t\t\tset_bit(EOL_CHAR(tty), ldata->char_map);\n\t\t\tif (L_IEXTEN(tty)) {\n\t\t\t\tset_bit(WERASE_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(LNEXT_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(EOL2_CHAR(tty), ldata->char_map);\n\t\t\t\tif (L_ECHO(tty))\n\t\t\t\t\tset_bit(REPRINT_CHAR(tty),\n\t\t\t\t\t\tldata->char_map);\n\t\t\t}\n\t\t}\n\t\tif (I_IXON(tty)) {\n\t\t\tset_bit(START_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(STOP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tif (L_ISIG(tty)) {\n\t\t\tset_bit(INTR_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(QUIT_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(SUSP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tclear_bit(__DISABLED_CHAR, ldata->char_map);\n\t\tldata->raw = 0;\n\t\tldata->real_raw = 0;\n\t} else {\n\t\tldata->raw = 1;\n\t\tif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\n\t\t    (I_IGNPAR(tty) || !I_INPCK(tty)) &&\n\t\t    (tty->driver->flags & TTY_DRIVER_REAL_RAW))\n\t\t\tldata->real_raw = 1;\n\t\telse\n\t\t\tldata->real_raw = 0;\n\t}\n\t/*\n\t * Fix tty hang when I_IXON(tty) is cleared, but the tty\n\t * been stopped by STOP_CHAR(tty) before it.\n\t */\n\tif (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\t/* The termios change make the tty ready for I/O */\n\twake_up_interruptible(&tty->write_wait);\n\twake_up_interruptible(&tty->read_wait);\n}\n\n/**\n *\tn_tty_close\t\t-\tclose the ldisc for this tty\n *\t@tty: device\n *\n *\tCalled from the terminal layer when this line discipline is\n *\tbeing shut down, either because of a close or becsuse of a\n *\tdiscipline change. The function will not be called while other\n *\tldisc methods are in progress.\n */\n\nstatic void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n}\n\n/**\n *\tn_tty_open\t\t-\topen an ldisc\n *\t@tty: terminal to open\n *\n *\tCalled when this line discipline is being attached to the\n *\tterminal device. Can sleep. Called serialized so that no\n *\tother events will occur in parallel. No further open will occur\n *\tuntil a close.\n */\n\nstatic int n_tty_open(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata;\n\n\t/* Currently a malloc failure here can panic */\n\tldata = vmalloc(sizeof(*ldata));\n\tif (!ldata)\n\t\tgoto err;\n\n\tldata->overrun_time = jiffies;\n\tmutex_init(&ldata->atomic_read_lock);\n\tmutex_init(&ldata->output_lock);\n\n\ttty->disc_data = ldata;\n\treset_buffer_flags(tty->disc_data);\n\tldata->column = 0;\n\tldata->canon_column = 0;\n\tldata->num_overrun = 0;\n\tldata->no_room = 0;\n\tldata->lnext = 0;\n\ttty->closing = 0;\n\t/* indicate buffer work may resume */\n\tclear_bit(TTY_LDISC_HALTED, &tty->flags);\n\tn_tty_set_termios(tty, NULL);\n\ttty_unthrottle(tty);\n\n\treturn 0;\nerr:\n\treturn -ENOMEM;\n}\n\nstatic inline int input_available_p(struct tty_struct *tty, int poll)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;\n\n\tif (ldata->icanon && !L_EXTPROC(tty))\n\t\treturn ldata->canon_head != ldata->read_tail;\n\telse\n\t\treturn ldata->commit_head - ldata->read_tail >= amt;\n}\n\n/**\n *\tcopy_from_read_buf\t-\tcopy read data directly\n *\t@tty: terminal device\n *\t@b: user data\n *\t@nr: size of data\n *\n *\tHelper function to speed up n_tty_read.  It is only called when\n *\tICANON is off; it copies characters straight from the tty queue to\n *\tuser space directly.  It can be profitably called twice; once to\n *\tdrain the space from the tail pointer to the (physical) end of the\n *\tbuffer, and once to drain the space from the (physical) beginning of\n *\tthe buffer to head pointer.\n *\n *\tCalled under the ldata->atomic_read_lock sem\n *\n *\tn_tty_read()/consumer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tread_tail published\n */\n\nstatic int copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t      unsigned char __user **b,\n\t\t\t\t      size_t *nr)\n\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\tsize_t n;\n\tbool is_eof;\n\tsize_t head = smp_load_acquire(&ldata->commit_head);\n\tsize_t tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\n\tretval = 0;\n\tn = min(head - ldata->read_tail, N_TTY_BUF_SIZE - tail);\n\tn = min(*nr, n);\n\tif (n) {\n\t\tconst unsigned char *from = read_buf_addr(ldata, tail);\n\t\tretval = copy_to_user(*b, from, n);\n\t\tn -= retval;\n\t\tis_eof = n == 1 && *from == EOF_CHAR(tty);\n\t\ttty_audit_add_data(tty, from, n);\n\t\tsmp_store_release(&ldata->read_tail, ldata->read_tail + n);\n\t\t/* Turn single EOF into zero-length read */\n\t\tif (L_EXTPROC(tty) && ldata->icanon && is_eof &&\n\t\t    (head == ldata->read_tail))\n\t\t\tn = 0;\n\t\t*b += n;\n\t\t*nr -= n;\n\t}\n\treturn retval;\n}\n\n/**\n *\tcanon_copy_from_read_buf\t-\tcopy read data in canonical mode\n *\t@tty: terminal device\n *\t@b: user data\n *\t@nr: size of data\n *\n *\tHelper function for n_tty_read.  It is only called when ICANON is on;\n *\tit copies one line of input up to and including the line-delimiting\n *\tcharacter into the user-space buffer.\n *\n *\tNB: When termios is changed from non-canonical to canonical mode and\n *\tthe read buffer contains data, n_tty_set_termios() simulates an EOF\n *\tpush (as if C-d were input) _without_ the DISABLED_CHAR in the buffer.\n *\tThis causes data already processed as input to be immediately available\n *\tas input although a newline has not been received.\n *\n *\tCalled under the atomic_read_lock mutex\n *\n *\tn_tty_read()/consumer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tread_tail published\n */\n\nstatic int canon_copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t    unsigned char __user **b,\n\t\t\t\t    size_t *nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, size, more, c;\n\tsize_t eol;\n\tsize_t tail;\n\tint ret, found = 0;\n\n\t/* N.B. avoid overrun if nr == 0 */\n\tif (!*nr)\n\t\treturn 0;\n\n\tn = min(*nr + 1, smp_load_acquire(&ldata->canon_head) - ldata->read_tail);\n\n\ttail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\tsize = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\n\n\tn_tty_trace(\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\",\n\t\t    __func__, *nr, tail, n, size);\n\n\teol = find_next_bit(ldata->read_flags, size, tail);\n\tmore = n - (size - tail);\n\tif (eol == N_TTY_BUF_SIZE && more) {\n\t\t/* scan wrapped without finding set bit */\n\t\teol = find_next_bit(ldata->read_flags, more, 0);\n\t\tfound = eol != more;\n\t} else\n\t\tfound = eol != size;\n\n\tn = eol - tail;\n\tif (n > N_TTY_BUF_SIZE)\n\t\tn += N_TTY_BUF_SIZE;\n\tc = n + found;\n\n\tif (!found || read_buf(ldata, eol) != __DISABLED_CHAR) {\n\t\tc = min(*nr, c);\n\t\tn = c;\n\t}\n\n\tn_tty_trace(\"%s: eol:%zu found:%d n:%zu c:%zu tail:%zu more:%zu\\n\",\n\t\t    __func__, eol, found, n, c, tail, more);\n\n\tret = tty_copy_to_user(tty, *b, tail, n);\n\tif (ret)\n\t\treturn -EFAULT;\n\t*b += n;\n\t*nr -= n;\n\n\tif (found)\n\t\tclear_bit(eol, ldata->read_flags);\n\tsmp_store_release(&ldata->read_tail, ldata->read_tail + c);\n\n\tif (found) {\n\t\tif (!ldata->push)\n\t\t\tldata->line_start = ldata->read_tail;\n\t\telse\n\t\t\tldata->push = 0;\n\t\ttty_audit_push();\n\t}\n\treturn 0;\n}\n\nextern ssize_t redirected_tty_write(struct file *, const char __user *,\n\t\t\t\t\t\t\tsize_t, loff_t *);\n\n/**\n *\tjob_control\t\t-\tcheck job control\n *\t@tty: tty\n *\t@file: file handle\n *\n *\tPerform job control management checks on this file/tty descriptor\n *\tand if appropriate send any needed signals and return a negative\n *\terror code if action should be taken.\n *\n *\tLocking: redirected write test is safe\n *\t\t current->signal->tty check is safe\n *\t\t ctrl_lock to safely reference tty->pgrp\n */\n\nstatic int job_control(struct tty_struct *tty, struct file *file)\n{\n\t/* Job control check -- must be done at start and after\n\t   every sleep (POSIX.1 7.1.1.4). */\n\t/* NOTE: not yet done after every sleep pending a thorough\n\t   check of the logic of this change. -- jlc */\n\t/* don't stop on /dev/console */\n\tif (file->f_op->write == redirected_tty_write)\n\t\treturn 0;\n\n\treturn __tty_check_change(tty, SIGTTIN);\n}\n\n\n/**\n *\tn_tty_read\t\t-\tread function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tPerform reads for the line discipline. We are guaranteed that the\n *\tline discipline will not be closed under us but we may get multiple\n *\tparallel readers and must handle this ourselves. We may also get\n *\ta hangup. Always called in user context, may sleep.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\n *\tn_tty_read()/consumer path:\n *\t\tclaims non-exclusive termios_rwsem\n *\t\tpublishes read_tail\n */\n\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\n\t\t\t unsigned char __user *buf, size_t nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tunsigned char __user *b = buf;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint c;\n\tint minimum, time;\n\tssize_t retval = 0;\n\tlong timeout;\n\tint packet;\n\tsize_t tail;\n\n\tc = job_control(tty, file);\n\tif (c < 0)\n\t\treturn c;\n\n\t/*\n\t *\tInternal serialization of reads.\n\t */\n\tif (file->f_flags & O_NONBLOCK) {\n\t\tif (!mutex_trylock(&ldata->atomic_read_lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (mutex_lock_interruptible(&ldata->atomic_read_lock))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\tminimum = time = 0;\n\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\tif (!ldata->icanon) {\n\t\tminimum = MIN_CHAR(tty);\n\t\tif (minimum) {\n\t\t\ttime = (HZ / 10) * TIME_CHAR(tty);\n\t\t} else {\n\t\t\ttimeout = (HZ / 10) * TIME_CHAR(tty);\n\t\t\tminimum = 1;\n\t\t}\n\t}\n\n\tpacket = tty->packet;\n\ttail = ldata->read_tail;\n\n\tadd_wait_queue(&tty->read_wait, &wait);\n\twhile (nr) {\n\t\t/* First test for status change. */\n\t\tif (packet && tty->link->ctrl_status) {\n\t\t\tunsigned char cs;\n\t\t\tif (b != buf)\n\t\t\t\tbreak;\n\t\t\tspin_lock_irq(&tty->link->ctrl_lock);\n\t\t\tcs = tty->link->ctrl_status;\n\t\t\ttty->link->ctrl_status = 0;\n\t\t\tspin_unlock_irq(&tty->link->ctrl_lock);\n\t\t\tif (put_user(cs, b)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tb++;\n\t\t\tnr--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!input_available_p(tty, 0)) {\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\ttty_buffer_flush_work(tty->port);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\tif (!input_available_p(tty, 0)) {\n\t\t\t\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\n\t\t\t\t\tretval = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (tty_hung_up_p(file))\n\t\t\t\t\tbreak;\n\t\t\t\tif (!timeout)\n\t\t\t\t\tbreak;\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tretval = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tup_read(&tty->termios_rwsem);\n\n\t\t\t\ttimeout = wait_woken(&wait, TASK_INTERRUPTIBLE,\n\t\t\t\t\t\ttimeout);\n\n\t\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ldata->icanon && !L_EXTPROC(tty)) {\n\t\t\tretval = canon_copy_from_read_buf(tty, &b, &nr);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tint uncopied;\n\n\t\t\t/* Deal with packet mode. */\n\t\t\tif (packet && b == buf) {\n\t\t\t\tif (put_user(TIOCPKT_DATA, b)) {\n\t\t\t\t\tretval = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t\tnr--;\n\t\t\t}\n\n\t\t\tuncopied = copy_from_read_buf(tty, &b, &nr);\n\t\t\tuncopied += copy_from_read_buf(tty, &b, &nr);\n\t\t\tif (uncopied) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tn_tty_check_unthrottle(tty);\n\n\t\tif (b - buf >= minimum)\n\t\t\tbreak;\n\t\tif (time)\n\t\t\ttimeout = time;\n\t}\n\tif (tail != ldata->read_tail)\n\t\tn_tty_kick_worker(tty);\n\tup_read(&tty->termios_rwsem);\n\n\tremove_wait_queue(&tty->read_wait, &wait);\n\tmutex_unlock(&ldata->atomic_read_lock);\n\n\tif (b - buf)\n\t\tretval = b - buf;\n\n\treturn retval;\n}\n\n/**\n *\tn_tty_write\t\t-\twrite function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tWrite function of the terminal device.  This is serialized with\n *\trespect to other write callers but not to termios changes, reads\n *\tand other such events.  Since the receive code will echo characters,\n *\tthus calling driver write methods, the output_lock is used in\n *\tthe output processing functions called here as well as in the\n *\techo processing function to protect the column state and space\n *\tleft in the buffer.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (note that the process_output*() functions take this\n *\t\t  lock themselves)\n */\n\nstatic ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n\t\t\tif (tty->ops->flush_chars)\n\t\t\t\ttty->ops->flush_chars(tty);\n\t\t} else {\n\t\t\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t\t\twhile (nr > 0) {\n\t\t\t\tmutex_lock(&ldata->output_lock);\n\t\t\t\tc = tty->ops->write(tty, b, nr);\n\t\t\t\tmutex_unlock(&ldata->output_lock);\n\t\t\t\tif (c < 0) {\n\t\t\t\t\tretval = c;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}\n\n/**\n *\tn_tty_poll\t\t-\tpoll method for N_TTY\n *\t@tty: terminal device\n *\t@file: file accessing it\n *\t@wait: poll table\n *\n *\tCalled when the line discipline is asked to poll() for data or\n *\tfor special events. This code is not serialized with respect to\n *\tother events save open/close.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\tCalled without the kernel lock held - fine\n */\n\nstatic unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,\n\t\t\t\t\t\t\tpoll_table *wait)\n{\n\tunsigned int mask = 0;\n\n\tpoll_wait(file, &tty->read_wait, wait);\n\tpoll_wait(file, &tty->write_wait, wait);\n\tif (input_available_p(tty, 1))\n\t\tmask |= POLLIN | POLLRDNORM;\n\telse {\n\t\ttty_buffer_flush_work(tty->port);\n\t\tif (input_available_p(tty, 1))\n\t\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tif (tty->packet && tty->link->ctrl_status)\n\t\tmask |= POLLPRI | POLLIN | POLLRDNORM;\n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tmask |= POLLHUP;\n\tif (tty_hung_up_p(file))\n\t\tmask |= POLLHUP;\n\tif (tty->ops->write && !tty_is_writelocked(tty) &&\n\t\t\ttty_chars_in_buffer(tty) < WAKEUP_CHARS &&\n\t\t\ttty_write_room(tty) > 0)\n\t\tmask |= POLLOUT | POLLWRNORM;\n\treturn mask;\n}\n\nstatic unsigned long inq_canon(struct n_tty_data *ldata)\n{\n\tsize_t nr, head, tail;\n\n\tif (ldata->canon_head == ldata->read_tail)\n\t\treturn 0;\n\thead = ldata->canon_head;\n\ttail = ldata->read_tail;\n\tnr = head - tail;\n\t/* Skip EOF-chars.. */\n\twhile (head != tail) {\n\t\tif (test_bit(tail & (N_TTY_BUF_SIZE - 1), ldata->read_flags) &&\n\t\t    read_buf(ldata, tail) == __DISABLED_CHAR)\n\t\t\tnr--;\n\t\ttail++;\n\t}\n\treturn nr;\n}\n\nstatic int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty) && !L_EXTPROC(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}\n\nstatic struct tty_ldisc_ops n_tty_ops = {\n\t.magic           = TTY_LDISC_MAGIC,\n\t.name            = \"n_tty\",\n\t.open            = n_tty_open,\n\t.close           = n_tty_close,\n\t.flush_buffer    = n_tty_flush_buffer,\n\t.read            = n_tty_read,\n\t.write           = n_tty_write,\n\t.ioctl           = n_tty_ioctl,\n\t.set_termios     = n_tty_set_termios,\n\t.poll            = n_tty_poll,\n\t.receive_buf     = n_tty_receive_buf,\n\t.write_wakeup    = n_tty_write_wakeup,\n\t.receive_buf2\t = n_tty_receive_buf2,\n};\n\n/**\n *\tn_tty_inherit_ops\t-\tinherit N_TTY methods\n *\t@ops: struct tty_ldisc_ops where to save N_TTY methods\n *\n *\tEnables a 'subclass' line discipline to 'inherit' N_TTY methods.\n */\n\nvoid n_tty_inherit_ops(struct tty_ldisc_ops *ops)\n{\n\t*ops = n_tty_ops;\n\tops->owner = NULL;\n\tops->refcount = ops->flags = 0;\n}\nEXPORT_SYMBOL_GPL(n_tty_inherit_ops);\n\nvoid __init n_tty_init(void)\n{\n\ttty_register_ldisc(N_TTY, &n_tty_ops);\n}\n"], "filenames": ["drivers/tty/n_tty.c"], "buggy_code_start_loc": [1765], "buggy_code_end_loc": [2429], "fixing_code_start_loc": [1765], "fixing_code_end_loc": [2429], "type": "CWE-704", "message": "drivers/tty/n_tty.c in the Linux kernel before 4.14.11 allows local attackers (who are able to access pseudo terminals) to hang/block further usage of any pseudo terminal devices due to an EXTPROC versus ICANON confusion in TIOCINQ.", "other": {"cve": {"id": "CVE-2018-18386", "sourceIdentifier": "cve@mitre.org", "published": "2018-10-17T20:29:00.550", "lastModified": "2019-04-23T17:29:05.380", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "drivers/tty/n_tty.c in the Linux kernel before 4.14.11 allows local attackers (who are able to access pseudo terminals) to hang/block further usage of any pseudo terminal devices due to an EXTPROC versus ICANON confusion in TIOCINQ."}, {"lang": "es", "value": "drivers/tty/n_tty.c en el kernel de Linux en versiones anteriores a la 4.14.11 permite que atacantes locales (que pueden acceder a los pseudoterminales) bloqueen el uso de dispositivos pseudoterminal debido a una confusi\u00f3n EXTPROC versus ICANON en TIOCINQ."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-704"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.14.11", "matchCriteriaId": "A84E4D94-A9A4-424C-8262-0B7B89C8CB6D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=966031f340185eddd05affcf72b740549f056348", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0831", "source": "cve@mitre.org"}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1094825", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.14.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3849-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3849-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348"}}