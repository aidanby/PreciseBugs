{"buggy_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/c/c_api_types.h\"\n\n#ifndef TF_LITE_STATIC_MEMORY\n#include <stdlib.h>\n#include <string.h>\n#endif  // TF_LITE_STATIC_MEMORY\n\nint TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n  return sizeof(dummy) + sizeof(dummy.data[0]) * size;\n}\n\nint TfLiteIntArrayEqual(const TfLiteIntArray* a, const TfLiteIntArray* b) {\n  if (a == b) return 1;\n  if (a == NULL || b == NULL) return 0;\n  return TfLiteIntArrayEqualsArray(a, b->size, b->data);\n}\n\nint TfLiteIntArrayEqualsArray(const TfLiteIntArray* a, int b_size,\n                              const int b_data[]) {\n  if (a == NULL) return (b_size == 0);\n  if (a->size != b_size) return 0;\n  int i = 0;\n  for (; i < a->size; i++)\n    if (a->data[i] != b_data[i]) return 0;\n  return 1;\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\n\nTfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  TfLiteIntArray* ret =\n      (TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(size));\n  ret->size = size;\n  return ret;\n}\n\nTfLiteIntArray* TfLiteIntArrayCopy(const TfLiteIntArray* src) {\n  if (!src) return NULL;\n  TfLiteIntArray* ret = TfLiteIntArrayCreate(src->size);\n  if (ret) {\n    memcpy(ret->data, src->data, src->size * sizeof(int));\n  }\n  return ret;\n}\n\nvoid TfLiteIntArrayFree(TfLiteIntArray* a) { free(a); }\n\n#endif  // TF_LITE_STATIC_MEMORY\n\nint TfLiteFloatArrayGetSizeInBytes(int size) {\n  static TfLiteFloatArray dummy;\n  return sizeof(dummy) + sizeof(dummy.data[0]) * size;\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\n\nTfLiteFloatArray* TfLiteFloatArrayCreate(int size) {\n  TfLiteFloatArray* ret =\n      (TfLiteFloatArray*)malloc(TfLiteFloatArrayGetSizeInBytes(size));\n  ret->size = size;\n  return ret;\n}\n\nvoid TfLiteFloatArrayFree(TfLiteFloatArray* a) { free(a); }\n\nvoid TfLiteTensorDataFree(TfLiteTensor* t) {\n  if (t->allocation_type == kTfLiteDynamic ||\n      t->allocation_type == kTfLitePersistentRo) {\n    free(t->data.raw);\n  }\n  t->data.raw = NULL;\n}\n\nvoid TfLiteQuantizationFree(TfLiteQuantization* quantization) {\n  if (quantization->type == kTfLiteAffineQuantization) {\n    TfLiteAffineQuantization* q_params =\n        (TfLiteAffineQuantization*)(quantization->params);\n    if (q_params->scale) {\n      TfLiteFloatArrayFree(q_params->scale);\n      q_params->scale = NULL;\n    }\n    if (q_params->zero_point) {\n      TfLiteIntArrayFree(q_params->zero_point);\n      q_params->zero_point = NULL;\n    }\n    free(q_params);\n  }\n  quantization->params = NULL;\n  quantization->type = kTfLiteNoQuantization;\n}\n\nvoid TfLiteSparsityFree(TfLiteSparsity* sparsity) {\n  if (sparsity == NULL) {\n    return;\n  }\n\n  if (sparsity->traversal_order) {\n    TfLiteIntArrayFree(sparsity->traversal_order);\n    sparsity->traversal_order = NULL;\n  }\n\n  if (sparsity->block_map) {\n    TfLiteIntArrayFree(sparsity->block_map);\n    sparsity->block_map = NULL;\n  }\n\n  if (sparsity->dim_metadata) {\n    int i = 0;\n    for (; i < sparsity->dim_metadata_size; i++) {\n      TfLiteDimensionMetadata metadata = sparsity->dim_metadata[i];\n      if (metadata.format == kTfLiteDimSparseCSR) {\n        TfLiteIntArrayFree(metadata.array_segments);\n        metadata.array_segments = NULL;\n        TfLiteIntArrayFree(metadata.array_indices);\n        metadata.array_indices = NULL;\n      }\n    }\n    free(sparsity->dim_metadata);\n    sparsity->dim_metadata = NULL;\n  }\n\n  free(sparsity);\n}\n\nvoid TfLiteTensorFree(TfLiteTensor* t) {\n  TfLiteTensorDataFree(t);\n  if (t->dims) TfLiteIntArrayFree(t->dims);\n  t->dims = NULL;\n\n  if (t->dims_signature) {\n    TfLiteIntArrayFree((TfLiteIntArray *) t->dims_signature);\n  }\n  t->dims_signature = NULL;\n\n  TfLiteQuantizationFree(&t->quantization);\n  TfLiteSparsityFree(t->sparsity);\n  t->sparsity = NULL;\n}\n\nvoid TfLiteTensorReset(TfLiteType type, const char* name, TfLiteIntArray* dims,\n                       TfLiteQuantizationParams quantization, char* buffer,\n                       size_t size, TfLiteAllocationType allocation_type,\n                       const void* allocation, bool is_variable,\n                       TfLiteTensor* tensor) {\n  TfLiteTensorFree(tensor);\n  tensor->type = type;\n  tensor->name = name;\n  tensor->dims = dims;\n  tensor->params = quantization;\n  tensor->data.raw = buffer;\n  tensor->bytes = size;\n  tensor->allocation_type = allocation_type;\n  tensor->allocation = allocation;\n  tensor->is_variable = is_variable;\n\n  tensor->quantization.type = kTfLiteNoQuantization;\n  tensor->quantization.params = NULL;\n}\n\nvoid TfLiteTensorRealloc(size_t num_bytes, TfLiteTensor* tensor) {\n  if (tensor->allocation_type != kTfLiteDynamic &&\n      tensor->allocation_type != kTfLitePersistentRo) {\n    return;\n  }\n  // TODO(b/145340303): Tensor data should be aligned.\n  if (!tensor->data.raw) {\n    tensor->data.raw = malloc(num_bytes);\n  } else if (num_bytes > tensor->bytes) {\n    tensor->data.raw = realloc(tensor->data.raw, num_bytes);\n  }\n  tensor->bytes = num_bytes;\n}\n#endif  // TF_LITE_STATIC_MEMORY\n\nconst char* TfLiteTypeGetName(TfLiteType type) {\n  switch (type) {\n    case kTfLiteNoType:\n      return \"NOTYPE\";\n    case kTfLiteFloat32:\n      return \"FLOAT32\";\n    case kTfLiteInt16:\n      return \"INT16\";\n    case kTfLiteInt32:\n      return \"INT32\";\n    case kTfLiteUInt32:\n      return \"UINT32\";\n    case kTfLiteUInt8:\n      return \"UINT8\";\n    case kTfLiteInt8:\n      return \"INT8\";\n    case kTfLiteInt64:\n      return \"INT64\";\n    case kTfLiteUInt64:\n      return \"UINT64\";\n    case kTfLiteBool:\n      return \"BOOL\";\n    case kTfLiteComplex64:\n      return \"COMPLEX64\";\n    case kTfLiteComplex128:\n      return \"COMPLEX128\";\n    case kTfLiteString:\n      return \"STRING\";\n    case kTfLiteFloat16:\n      return \"FLOAT16\";\n    case kTfLiteFloat64:\n      return \"FLOAT64\";\n    case kTfLiteResource:\n      return \"RESOURCE\";\n    case kTfLiteVariant:\n      return \"VARIANT\";\n  }\n  return \"Unknown type\";\n}\n\nTfLiteDelegate TfLiteDelegateCreate() {\n  TfLiteDelegate d = {\n      .data_ = NULL,\n      .Prepare = NULL,\n      .CopyFromBufferHandle = NULL,\n      .CopyToBufferHandle = NULL,\n      .FreeBufferHandle = NULL,\n      .flags = kTfLiteDelegateFlagsNone,\n  };\n  return d;\n}\n", "/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Op that looks up items from a sparse tensor in an embedding matrix.\n// The sparse lookup tensor is represented by three individual tensors: lookup,\n// indices, and dense_shape. The representation assume that the corresponding\n// dense tensor would satisfy:\n//   * dense.shape = dense_shape\n//   * dense[tuple(indices[i])] = lookup[i]\n//\n// By convention, indices should be sorted.\n//\n// Options:\n//   combiner: The reduction op (SUM, MEAN, SQRTN).\n//     * SUM computes the weighted sum of the embedding results.\n//     * MEAN is the weighted sum divided by the total weight.\n//     * SQRTN is the weighted sum divided by the square root of the sum of the\n//       squares of the weights.\n//\n// Input:\n//     Tensor[0]: Ids to lookup, dim.size == 1, int32.\n//     Tensor[1]: Indices, int32.\n//     Tensor[2]: Dense shape, int32.\n//     Tensor[3]: Weights to use for aggregation, float.\n//     Tensor[4]: Params, a matrix of multi-dimensional items,\n//                dim.size >= 2, float.\n//\n// Output:\n//   A (dense) tensor representing the combined embeddings for the sparse ids.\n//   For each row in the sparse tensor represented by (lookup, indices, shape)\n//   the op looks up the embeddings for all ids in that row, multiplies them by\n//   the corresponding weight, and combines these embeddings as specified in the\n//   last dimension.\n//\n//   Output.dim = [l0, ... , ln-1, e1, ..., em]\n//   Where dense_shape == [l0, ..., ln] and Tensor[4].dim == [e0, e1, ..., em]\n//\n//   For instance, if params is a 10x20 matrix and ids, weights are:\n//\n//   [0, 0]: id 1, weight 2.0\n//   [0, 1]: id 3, weight 0.5\n//   [1, 0]: id 0, weight 1.0\n//   [2, 3]: id 1, weight 3.0\n//\n//   with combiner=MEAN, then the output will be a (3, 20) tensor where:\n//\n//   output[0, :] = (params[1, :] * 2.0 + params[3, :] * 0.5) / (2.0 + 0.5)\n//   output[1, :] = (params[0, :] * 1.0) / 1.0\n//   output[2, :] = (params[1, :] * 3.0) / 3.0\n//\n//   When indices are out of bound, the op will not succeed.\n\n#include <stdint.h>\n\n#include <algorithm>\n#include <cmath>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_utils.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\n\nnamespace {\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 5);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(ids), 1);\n  TF_LITE_ENSURE_EQ(context, ids->type, kTfLiteInt32);\n\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(indices), 2);\n  TF_LITE_ENSURE_EQ(context, indices->type, kTfLiteInt32);\n\n  const TfLiteTensor* shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &shape));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(shape), 1);\n  TF_LITE_ENSURE_EQ(context, shape->type, kTfLiteInt32);\n\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(weights), 1);\n  TF_LITE_ENSURE_EQ(context, weights->type, kTfLiteFloat32);\n\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(indices, 0),\n                    SizeOfDimension(ids, 0));\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(indices, 0),\n                    SizeOfDimension(weights, 0));\n\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n  TF_LITE_ENSURE(context, NumDimensions(value) >= 2);\n\n  // Mark the output as a dynamic tensor.\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, kTfLiteFloat32);\n  output->allocation_type = kTfLiteDynamic;\n\n  return kTfLiteOk;\n}\n\nvoid FinalizeAggregation(TfLiteCombinerType combiner, int num_elements,\n                         float current_total_weight,\n                         float current_squares_weight, int embedding_size,\n                         float* output) {\n  if (combiner != kTfLiteCombinerTypeSum && num_elements > 0) {\n    float multiplier = 1.0;\n    switch (combiner) {\n      case kTfLiteCombinerTypeMean:\n        multiplier = current_total_weight;\n        break;\n      case kTfLiteCombinerTypeSqrtn:\n        multiplier = std::sqrt(current_squares_weight);\n        break;\n      default:\n        break;\n    }\n    for (int k = 0; k < embedding_size; k++) {\n      output[k] /= multiplier;\n    }\n  }\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  const TfLiteTensor* dense_shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  int k = 0;\n  int embedding_size = 1;\n  int lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const int dim = dense_shape->data.i32[i];\n    lookup_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const int dim = SizeOfDimension(value, i);\n    embedding_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const int output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}\n\n}  // namespace\n\nTfLiteRegistration* Register_EMBEDDING_LOOKUP_SPARSE() {\n  static TfLiteRegistration r = {nullptr, nullptr, Prepare, Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite\n"], "fixing_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/c/c_api_types.h\"\n\n#ifndef TF_LITE_STATIC_MEMORY\n#include <stdlib.h>\n#include <string.h>\n#endif  // TF_LITE_STATIC_MEMORY\n\nint TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n  return sizeof(dummy) + sizeof(dummy.data[0]) * size;\n}\n\nint TfLiteIntArrayEqual(const TfLiteIntArray* a, const TfLiteIntArray* b) {\n  if (a == b) return 1;\n  if (a == NULL || b == NULL) return 0;\n  return TfLiteIntArrayEqualsArray(a, b->size, b->data);\n}\n\nint TfLiteIntArrayEqualsArray(const TfLiteIntArray* a, int b_size,\n                              const int b_data[]) {\n  if (a == NULL) return (b_size == 0);\n  if (a->size != b_size) return 0;\n  int i = 0;\n  for (; i < a->size; i++)\n    if (a->data[i] != b_data[i]) return 0;\n  return 1;\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\n\nTfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}\n\nTfLiteIntArray* TfLiteIntArrayCopy(const TfLiteIntArray* src) {\n  if (!src) return NULL;\n  TfLiteIntArray* ret = TfLiteIntArrayCreate(src->size);\n  if (ret) {\n    memcpy(ret->data, src->data, src->size * sizeof(int));\n  }\n  return ret;\n}\n\nvoid TfLiteIntArrayFree(TfLiteIntArray* a) { free(a); }\n\n#endif  // TF_LITE_STATIC_MEMORY\n\nint TfLiteFloatArrayGetSizeInBytes(int size) {\n  static TfLiteFloatArray dummy;\n  return sizeof(dummy) + sizeof(dummy.data[0]) * size;\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\n\nTfLiteFloatArray* TfLiteFloatArrayCreate(int size) {\n  TfLiteFloatArray* ret =\n      (TfLiteFloatArray*)malloc(TfLiteFloatArrayGetSizeInBytes(size));\n  ret->size = size;\n  return ret;\n}\n\nvoid TfLiteFloatArrayFree(TfLiteFloatArray* a) { free(a); }\n\nvoid TfLiteTensorDataFree(TfLiteTensor* t) {\n  if (t->allocation_type == kTfLiteDynamic ||\n      t->allocation_type == kTfLitePersistentRo) {\n    free(t->data.raw);\n  }\n  t->data.raw = NULL;\n}\n\nvoid TfLiteQuantizationFree(TfLiteQuantization* quantization) {\n  if (quantization->type == kTfLiteAffineQuantization) {\n    TfLiteAffineQuantization* q_params =\n        (TfLiteAffineQuantization*)(quantization->params);\n    if (q_params->scale) {\n      TfLiteFloatArrayFree(q_params->scale);\n      q_params->scale = NULL;\n    }\n    if (q_params->zero_point) {\n      TfLiteIntArrayFree(q_params->zero_point);\n      q_params->zero_point = NULL;\n    }\n    free(q_params);\n  }\n  quantization->params = NULL;\n  quantization->type = kTfLiteNoQuantization;\n}\n\nvoid TfLiteSparsityFree(TfLiteSparsity* sparsity) {\n  if (sparsity == NULL) {\n    return;\n  }\n\n  if (sparsity->traversal_order) {\n    TfLiteIntArrayFree(sparsity->traversal_order);\n    sparsity->traversal_order = NULL;\n  }\n\n  if (sparsity->block_map) {\n    TfLiteIntArrayFree(sparsity->block_map);\n    sparsity->block_map = NULL;\n  }\n\n  if (sparsity->dim_metadata) {\n    int i = 0;\n    for (; i < sparsity->dim_metadata_size; i++) {\n      TfLiteDimensionMetadata metadata = sparsity->dim_metadata[i];\n      if (metadata.format == kTfLiteDimSparseCSR) {\n        TfLiteIntArrayFree(metadata.array_segments);\n        metadata.array_segments = NULL;\n        TfLiteIntArrayFree(metadata.array_indices);\n        metadata.array_indices = NULL;\n      }\n    }\n    free(sparsity->dim_metadata);\n    sparsity->dim_metadata = NULL;\n  }\n\n  free(sparsity);\n}\n\nvoid TfLiteTensorFree(TfLiteTensor* t) {\n  TfLiteTensorDataFree(t);\n  if (t->dims) TfLiteIntArrayFree(t->dims);\n  t->dims = NULL;\n\n  if (t->dims_signature) {\n    TfLiteIntArrayFree((TfLiteIntArray *) t->dims_signature);\n  }\n  t->dims_signature = NULL;\n\n  TfLiteQuantizationFree(&t->quantization);\n  TfLiteSparsityFree(t->sparsity);\n  t->sparsity = NULL;\n}\n\nvoid TfLiteTensorReset(TfLiteType type, const char* name, TfLiteIntArray* dims,\n                       TfLiteQuantizationParams quantization, char* buffer,\n                       size_t size, TfLiteAllocationType allocation_type,\n                       const void* allocation, bool is_variable,\n                       TfLiteTensor* tensor) {\n  TfLiteTensorFree(tensor);\n  tensor->type = type;\n  tensor->name = name;\n  tensor->dims = dims;\n  tensor->params = quantization;\n  tensor->data.raw = buffer;\n  tensor->bytes = size;\n  tensor->allocation_type = allocation_type;\n  tensor->allocation = allocation;\n  tensor->is_variable = is_variable;\n\n  tensor->quantization.type = kTfLiteNoQuantization;\n  tensor->quantization.params = NULL;\n}\n\nvoid TfLiteTensorRealloc(size_t num_bytes, TfLiteTensor* tensor) {\n  if (tensor->allocation_type != kTfLiteDynamic &&\n      tensor->allocation_type != kTfLitePersistentRo) {\n    return;\n  }\n  // TODO(b/145340303): Tensor data should be aligned.\n  if (!tensor->data.raw) {\n    tensor->data.raw = malloc(num_bytes);\n  } else if (num_bytes > tensor->bytes) {\n    tensor->data.raw = realloc(tensor->data.raw, num_bytes);\n  }\n  tensor->bytes = num_bytes;\n}\n#endif  // TF_LITE_STATIC_MEMORY\n\nconst char* TfLiteTypeGetName(TfLiteType type) {\n  switch (type) {\n    case kTfLiteNoType:\n      return \"NOTYPE\";\n    case kTfLiteFloat32:\n      return \"FLOAT32\";\n    case kTfLiteInt16:\n      return \"INT16\";\n    case kTfLiteInt32:\n      return \"INT32\";\n    case kTfLiteUInt32:\n      return \"UINT32\";\n    case kTfLiteUInt8:\n      return \"UINT8\";\n    case kTfLiteInt8:\n      return \"INT8\";\n    case kTfLiteInt64:\n      return \"INT64\";\n    case kTfLiteUInt64:\n      return \"UINT64\";\n    case kTfLiteBool:\n      return \"BOOL\";\n    case kTfLiteComplex64:\n      return \"COMPLEX64\";\n    case kTfLiteComplex128:\n      return \"COMPLEX128\";\n    case kTfLiteString:\n      return \"STRING\";\n    case kTfLiteFloat16:\n      return \"FLOAT16\";\n    case kTfLiteFloat64:\n      return \"FLOAT64\";\n    case kTfLiteResource:\n      return \"RESOURCE\";\n    case kTfLiteVariant:\n      return \"VARIANT\";\n  }\n  return \"Unknown type\";\n}\n\nTfLiteDelegate TfLiteDelegateCreate() {\n  TfLiteDelegate d = {\n      .data_ = NULL,\n      .Prepare = NULL,\n      .CopyFromBufferHandle = NULL,\n      .CopyToBufferHandle = NULL,\n      .FreeBufferHandle = NULL,\n      .flags = kTfLiteDelegateFlagsNone,\n  };\n  return d;\n}\n", "/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Op that looks up items from a sparse tensor in an embedding matrix.\n// The sparse lookup tensor is represented by three individual tensors: lookup,\n// indices, and dense_shape. The representation assume that the corresponding\n// dense tensor would satisfy:\n//   * dense.shape = dense_shape\n//   * dense[tuple(indices[i])] = lookup[i]\n//\n// By convention, indices should be sorted.\n//\n// Options:\n//   combiner: The reduction op (SUM, MEAN, SQRTN).\n//     * SUM computes the weighted sum of the embedding results.\n//     * MEAN is the weighted sum divided by the total weight.\n//     * SQRTN is the weighted sum divided by the square root of the sum of the\n//       squares of the weights.\n//\n// Input:\n//     Tensor[0]: Ids to lookup, dim.size == 1, int32.\n//     Tensor[1]: Indices, int32.\n//     Tensor[2]: Dense shape, int32.\n//     Tensor[3]: Weights to use for aggregation, float.\n//     Tensor[4]: Params, a matrix of multi-dimensional items,\n//                dim.size >= 2, float.\n//\n// Output:\n//   A (dense) tensor representing the combined embeddings for the sparse ids.\n//   For each row in the sparse tensor represented by (lookup, indices, shape)\n//   the op looks up the embeddings for all ids in that row, multiplies them by\n//   the corresponding weight, and combines these embeddings as specified in the\n//   last dimension.\n//\n//   Output.dim = [l0, ... , ln-1, e1, ..., em]\n//   Where dense_shape == [l0, ..., ln] and Tensor[4].dim == [e0, e1, ..., em]\n//\n//   For instance, if params is a 10x20 matrix and ids, weights are:\n//\n//   [0, 0]: id 1, weight 2.0\n//   [0, 1]: id 3, weight 0.5\n//   [1, 0]: id 0, weight 1.0\n//   [2, 3]: id 1, weight 3.0\n//\n//   with combiner=MEAN, then the output will be a (3, 20) tensor where:\n//\n//   output[0, :] = (params[1, :] * 2.0 + params[3, :] * 0.5) / (2.0 + 0.5)\n//   output[1, :] = (params[0, :] * 1.0) / 1.0\n//   output[2, :] = (params[1, :] * 3.0) / 3.0\n//\n//   When indices are out of bound, the op will not succeed.\n\n#include <stdint.h>\n\n#include <algorithm>\n#include <cmath>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_utils.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\n\nnamespace {\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 5);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(ids), 1);\n  TF_LITE_ENSURE_EQ(context, ids->type, kTfLiteInt32);\n\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(indices), 2);\n  TF_LITE_ENSURE_EQ(context, indices->type, kTfLiteInt32);\n\n  const TfLiteTensor* shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &shape));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(shape), 1);\n  TF_LITE_ENSURE_EQ(context, shape->type, kTfLiteInt32);\n\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(weights), 1);\n  TF_LITE_ENSURE_EQ(context, weights->type, kTfLiteFloat32);\n\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(indices, 0),\n                    SizeOfDimension(ids, 0));\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(indices, 0),\n                    SizeOfDimension(weights, 0));\n\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n  TF_LITE_ENSURE(context, NumDimensions(value) >= 2);\n\n  // Mark the output as a dynamic tensor.\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, kTfLiteFloat32);\n  output->allocation_type = kTfLiteDynamic;\n\n  return kTfLiteOk;\n}\n\nvoid FinalizeAggregation(TfLiteCombinerType combiner, int num_elements,\n                         float current_total_weight,\n                         float current_squares_weight, int embedding_size,\n                         float* output) {\n  if (combiner != kTfLiteCombinerTypeSum && num_elements > 0) {\n    float multiplier = 1.0;\n    switch (combiner) {\n      case kTfLiteCombinerTypeMean:\n        multiplier = current_total_weight;\n        break;\n      case kTfLiteCombinerTypeSqrtn:\n        multiplier = std::sqrt(current_squares_weight);\n        break;\n      default:\n        break;\n    }\n    for (int k = 0; k < embedding_size; k++) {\n      output[k] /= multiplier;\n    }\n  }\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  const TfLiteTensor* dense_shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  TF_LITE_ENSURE(context, output_shape != nullptr);\n  int k = 0;\n  int embedding_size = 1;\n  int lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const int dim = dense_shape->data.i32[i];\n    lookup_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const int dim = SizeOfDimension(value, i);\n    embedding_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const int output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}\n\n}  // namespace\n\nTfLiteRegistration* Register_EMBEDDING_LOOKUP_SPARSE() {\n  static TfLiteRegistration r = {nullptr, nullptr, Prepare, Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite\n"], "filenames": ["tensorflow/lite/c/common.c", "tensorflow/lite/kernels/embedding_lookup_sparse.cc"], "buggy_code_start_loc": [48, 175], "buggy_code_end_loc": [50, 175], "fixing_code_start_loc": [48, 176], "fixing_code_end_loc": [52, 177], "type": "CWE-190", "message": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret->size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-29605", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T20:15:15.670", "lastModified": "2021-05-18T15:12:56.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret->size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;El c\u00f3digo TFLite para asignar \"TFLiteIntArray\" es vulnerable a un problema de desbordamiento de enteros (https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27).&#xa0;Un atacante puede dise\u00f1ar un modelo tal que el multiplicador de \"size\" sea tan grande que el valor de retorno desborde el tipo de datos \"int\" y se vuelva negativo.&#xa0;A su vez, esto resulta en que se le d\u00e9 un valor no v\u00e1lido a \"malloc\" (https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52).&#xa0;En este caso, \"ret-)size\" eliminar\u00eda la referencia a un puntero no v\u00e1lido.&#xa0;La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.5.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.4.2, TensorFlow versi\u00f3n 2.3.3, TensorFlow versi\u00f3n 2.2.3 y TensorFlow versi\u00f3n 2.1.4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "323ABCCE-24EB-47CC-87F6-48C101477587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "64ABA90C-0649-4BB0-89C9-83C14BBDCC0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.3", "matchCriteriaId": "0F83E0CF-CBF6-4C24-8683-3E7A5DC95BA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.2", "matchCriteriaId": "8259531B-A8AC-4F8B-B60F-B69DE4767C03"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-jf7h-7m85-w2v2", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5"}}