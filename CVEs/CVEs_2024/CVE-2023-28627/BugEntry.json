{"buggy_code": ["# coding=utf-8\n\nfrom __future__ import unicode_literals\n\nimport logging\nimport platform\nimport re\nimport subprocess\nimport sys\n\nfrom medusa import app, notifiers\nfrom medusa.logger.adapters.style import BraceAdapter\nfrom medusa.updater.update_manager import UpdateManager\n\nfrom six import text_type\n\n\nERROR_MESSAGE = ('Unable to find your git executable. Set git executable path in Advanced Settings '\n                 'OR shutdown application and delete your .git folder and run from source to enable updates.')\n\nlog = BraceAdapter(logging.getLogger(__name__))\nlog.logger.addHandler(logging.NullHandler())\n\n\nclass GitUpdateManager(UpdateManager):\n    def __init__(self):\n        super(GitUpdateManager, self).__init__()\n        self._git_path = self._find_working_git()\n        self.github_org = self.get_github_org()\n        self.github_repo = self.get_github_repo()\n        self.branch = self._find_installed_branch()\n\n        self._cur_commit_hash = None\n        self._newest_commit_hash = None\n        self._num_commits_behind = 0\n        self._num_commits_ahead = 0\n\n    def __str__(self):\n        return 'GitHub Updater'\n\n    @property\n    def current_commit_hash(self):\n        return self._cur_commit_hash\n\n    @property\n    def newest_commit_hash(self):\n        return self._newest_commit_hash\n\n    @property\n    def current_version(self):\n        self.update_commit_hash()\n        cur_version = self._run_git(self._git_path, 'describe --tags --abbrev=0 {0}'.format(\n            self._cur_commit_hash))[0]\n        if cur_version:\n            return cur_version.lstrip('v')\n\n    @property\n    def newest_version(self):\n        self.update_newest_commit_hash()\n        new_version = self._run_git(self._git_path, 'describe --tags --abbrev=0 {0}'.format(\n            self._newest_commit_hash))[0]\n        if new_version:\n            return new_version.lstrip('v')\n\n    @property\n    def commits_behind(self):\n        return self._num_commits_behind\n\n    @property\n    def commits_ahead(self):\n        return self._num_commits_ahead\n\n    def _find_working_git(self):\n        test_cmd = 'version'\n\n        if app.GIT_PATH:\n            main_git = '\"' + app.GIT_PATH + '\"'\n        else:\n            main_git = 'git'\n\n        log.debug(u'Checking if we can use git commands: {0} {1}', main_git, test_cmd)\n        _, _, exit_status = self._run_git(main_git, test_cmd)\n\n        if exit_status == 0:\n            log.debug(u'Using: {0}', main_git)\n            return main_git\n        else:\n            log.debug(u'Not using: {0}', main_git)\n\n        # trying alternatives\n        alternative_git = []\n\n        # osx people who start sr from launchd have a broken path, so try a hail-mary attempt for them\n        if platform.system().lower() == 'darwin':\n            alternative_git.append('/usr/local/git/bin/git')\n\n        if platform.system().lower() == 'windows':\n            if main_git != main_git.lower():\n                alternative_git.append(main_git.lower())\n\n        if alternative_git:\n            log.debug(u'Trying known alternative git locations')\n\n            for cur_git in alternative_git:\n                log.debug(u'Checking if we can use git commands: {0} {1}', cur_git, test_cmd)\n                _, _, exit_status = self._run_git(cur_git, test_cmd)\n\n                if exit_status == 0:\n                    log.debug(u'Using: {0}', cur_git)\n                    return cur_git\n                else:\n                    log.debug(u'Not using: {0}', cur_git)\n\n    def _run_git(self, git_path, args):\n        output = err = exit_status = None\n\n        if not git_path:\n            git_path = self._find_working_git()\n            if git_path:\n                self._git_path = git_path\n            else:\n                # Warn user only if he has version check enabled\n                if app.VERSION_NOTIFY:\n                    log.warning(u\"No git specified, can't use git commands\")\n                    app.NEWEST_VERSION_STRING = ERROR_MESSAGE\n                exit_status = 1\n                return output, err, exit_status\n\n        # If we have a valid git remove the git warning\n        # String will be updated as soon we check github\n        app.NEWEST_VERSION_STRING = None\n        cmd = git_path + ' ' + args\n\n        try:\n            log.debug(u'Executing {cmd} with your shell in {dir}', {'cmd': cmd, 'dir': app.PROG_DIR})\n            p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n                                 shell=True, cwd=app.PROG_DIR)\n            output, err = p.communicate()\n            exit_status = p.returncode\n\n            # Convert bytes to string in python3\n            if isinstance(output, (bytes, bytearray)):\n                output = output.decode('utf-8')\n\n            if output:\n                output = output.strip()\n\n        except OSError:\n            log.info(u\"Command {cmd} didn't work\", {'cmd': cmd})\n            exit_status = 1\n\n        if exit_status == 0:\n            log.debug(u'{cmd} : returned successful', {'cmd': cmd})\n\n        elif exit_status == 1:\n            if output:\n                if 'stash' in output:\n                    log.warning(u\"Enable 'git reset' in settings or stash your changes in local files\")\n                else:\n                    log.warning(u'{cmd} returned : {output}', {'cmd': cmd, 'output': output})\n            else:\n                log.warning(u'{cmd} returned no data', {'cmd': cmd})\n\n        elif exit_status == 128:\n            log.warning('{cmd} returned ({status}) : {output}',\n                        {'cmd': cmd, 'status': exit_status, 'output': output})\n\n        elif exit_status == 129:\n            if 'unknown option' in output and 'set-upstream-to' in output:\n                log.info(\"Can't set upstream to origin/{0} because you're running an old version of git.\"\n                         '\\nPlease upgrade your git installation to its latest version.', app.BRANCH)\n            else:\n                log.warning('{cmd} returned ({status}) : {output}',\n                            {'cmd': cmd, 'status': exit_status, 'output': output})\n\n        else:\n            log.warning(u'{cmd} returned : {output}. Treat as error for now', {'cmd': cmd, 'output': output})\n            exit_status = 1\n\n        return output, err, exit_status\n\n    def update_commit_hash(self):\n        \"\"\"Attempt to set the hash of the currently installed version of the application.\n\n        Uses git to get commit version.\n        \"\"\"\n        output, _, exit_status = self._run_git(self._git_path, 'rev-parse HEAD')\n\n        if exit_status == 0 and output:\n            cur_commit_hash = output.strip()\n            if not re.match('^[a-z0-9]+$', cur_commit_hash):\n                log.warning(u\"Output doesn't look like a hash, not using it\")\n                return False\n\n            self._cur_commit_hash = cur_commit_hash\n            app.CUR_COMMIT_HASH = cur_commit_hash\n            return True\n\n        return False\n\n    def update_newest_commit_hash(self):\n        # update remote origin url\n        self.update_remote_origin()\n\n        # Configure local branch with upstream\n        self.set_upstream_branch()\n\n        # get all new info from github\n        output, _, exit_status = self._run_git(self._git_path, 'fetch --prune {0}'.format(app.GIT_REMOTE))\n        if not exit_status == 0:\n            log.warning(u\"Unable to contact github, can't check for update\")\n            return False\n\n        # get latest commit_hash from remote\n        output, _, exit_status = self._run_git(self._git_path, 'rev-parse --verify --quiet \"@{upstream}\"')\n\n        if exit_status == 0 and output:\n            cur_commit_hash = output.strip()\n            if not re.match('^[a-z0-9]+$', cur_commit_hash):\n                log.debug(u\"Output doesn't look like a hash, not using it\")\n                return False\n            else:\n                self._newest_commit_hash = cur_commit_hash\n                return True\n        else:\n            log.debug(u\"git didn't return newest commit hash\")\n            return False\n\n    def _find_installed_branch(self):\n        branch_info, _, exit_status = self._run_git(self._git_path, 'symbolic-ref -q HEAD')\n        if exit_status == 0 and branch_info:\n            branch = branch_info.strip().replace('refs/heads/', '', 1)\n            if branch:\n                app.BRANCH = branch\n                return branch\n        return ''\n\n    def check_for_update(self):\n        \"\"\"Use git commands to check if there is a newer version that the provided commit hash.\"\"\"\n        self.update_commit_hash()\n        self.update_newest_commit_hash()\n\n        # get number of commits behind and ahead (option --count not supported git < 1.7.2)\n        output, _, exit_status = self._run_git(self._git_path, 'rev-list --left-right \"@{upstream}\"...HEAD')\n        if exit_status == 0 and output:\n            try:\n                self._num_commits_behind = int(output.count('<'))\n                self._num_commits_ahead = int(output.count('>'))\n            except Exception:\n                log.debug(u\"git didn't return numbers for behind and ahead, not using it\")\n                return False\n\n        log.debug(u'cur_commit = {0}, newest_commit = {1}, num_commits_behind = {2}, num_commits_ahead = {3}',\n                  self._cur_commit_hash, self._newest_commit_hash, self._num_commits_behind, self._num_commits_ahead)\n\n    def need_update(self):\n        if self.branch != self._find_installed_branch():\n            log.debug(u'Branch checkout: {0}->{1}', self._find_installed_branch(), self.branch)\n            return True\n\n        try:\n            self.check_for_update()\n        except Exception as e:\n            log.warning(u\"Unable to contact github, can't check for update: {0!r}\", e)\n            return False\n\n        if self._num_commits_behind > 0 or self._num_commits_ahead > 0:\n            self._set_update_text()\n            return True\n\n        return False\n\n    def _set_update_text(self):\n        if self._num_commits_behind > 0 or self._is_hard_reset_allowed():\n            base_url = 'http://github.com/' + self.github_org + '/' + self.github_repo\n            if self._newest_commit_hash:\n                url = base_url + '/compare/' + self._cur_commit_hash + '...' + self._newest_commit_hash\n            else:\n                url = base_url + '/commits/'\n\n            newest_text = 'There is a <a href=\"' + url + '\" onclick=\"window.open(this.href); return false;\">newer version available</a> '\n            newest_text += \" (you're \" + text_type(self._num_commits_behind) + ' commit'\n            if self._num_commits_behind > 1:\n                newest_text += 's'\n            newest_text += ' behind'\n            if self._num_commits_ahead > 0:\n                newest_text += ' and {ahead} commit{s} ahead'.format(ahead=self._num_commits_ahead,\n                                                                     s='s' if self._num_commits_ahead > 1 else '')\n            newest_text += ') &mdash; <a href=\"' + self.get_update_url() + '\">Update Now</a>'\n\n        elif self._num_commits_ahead > 0:\n            newest_text = u'Local branch is ahead of {0}. Automatic update not possible'.format(self.branch)\n            log.warning(newest_text)\n        else:\n            return\n\n        app.NEWEST_VERSION_STRING = newest_text\n\n    def can_update(self):\n        \"\"\"Return whether update can be executed.\n\n        :return:\n        :rtype: bool\n        \"\"\"\n        # Version 0.4.6 is the last version which will run on python 2.7.13.\n        if sys.version_info.major == 2:\n            return False\n\n        return self._num_commits_ahead <= 0 or self._is_hard_reset_allowed()\n\n    def update(self):\n        \"\"\"Call git pull origin <branch> in order to update the application.\n\n        Returns a bool depending on the call's success.\n        \"\"\"\n        # update remote origin url\n        self.update_remote_origin()\n\n        # remove untracked files and performs a hard reset on git branch to avoid update issues\n        if self._is_hard_reset_allowed():\n            self.reset()\n\n        # Executing git clean before updating\n        self.clean()\n\n        current_branch = self._find_installed_branch()\n        if self.branch == current_branch:\n            _, _, exit_status = self._run_git(self._git_path, 'pull -f {0} {1}'.format(app.GIT_REMOTE, self.branch))\n        else:\n            log.warning(\n                u\"Couldn't determine current branch or current branch {current}\"\n                u\" doesn't match desired branch {desired}.\\n\"\n                u'Checkout the desired branch or try again later.', {\n                    'current': current_branch,\n                    'desired': self.branch\n                })\n            return False\n\n        # Executing git clean after updating\n        self.clean()\n\n        if exit_status == 0:\n            self.update_commit_hash()\n            # Notify update successful\n            if app.NOTIFY_ON_UPDATE:\n                try:\n                    notifiers.notify_git_update(app.CUR_COMMIT_HASH or '')\n                except Exception:\n                    log.debug(u'Unable to send update notification. Continuing the update process')\n            return True\n\n        return False\n\n    @staticmethod\n    def _is_hard_reset_allowed():\n        \"\"\"Return whether git hard reset is allowed or not.\n\n        :return:\n        :rtype: bool\n        \"\"\"\n        return app.GIT_RESET and (not app.GIT_RESET_BRANCHES or\n                                  app.BRANCH in app.GIT_RESET_BRANCHES)\n\n    def clean(self):\n        \"\"\"Call git clean to remove all untracked files.\n\n        It only affects source folders and libX and extX folders,\n        to prevent deleting untracked user data not known by .gitignore\n\n        :return:\n        :rtype: int\n        \"\"\"\n        folders = (app.LIB_FOLDER, app.LIB2_FOLDER, app.LIB3_FOLDER, app.EXT_FOLDER,\n                   app.EXT2_FOLDER, app.EXT3_FOLDER, app.SRC_FOLDER, app.STATIC_FOLDER) + app.LEGACY_SRC_FOLDERS\n        _, _, exit_status = self._run_git(self._git_path, 'clean -d -f -x {0}'.format(' '.join(folders)))\n\n        return exit_status\n\n    def reset(self):\n        \"\"\"Call git reset --hard to perform a hard reset.\"\"\"\n        _, _, exit_status = self._run_git(self._git_path, 'reset --hard {0}/{1}'.format(app.GIT_REMOTE, app.BRANCH))\n        if exit_status == 0:\n            return True\n\n    def list_remote_branches(self):\n        # update remote origin url\n        self.update_remote_origin()\n        app.BRANCH = self._find_installed_branch()\n\n        branches, _, exit_status = self._run_git(self._git_path, 'ls-remote --heads {0}'.format(app.GIT_REMOTE))\n        if exit_status == 0 and branches:\n            return re.findall(r'refs/heads/(.*)', branches)\n        return []\n\n    def update_remote_origin(self):\n        self._run_git(self._git_path, 'config remote.{0}.url {1}'.format(app.GIT_REMOTE, app.GIT_REMOTE_URL))\n        self._run_git(self._git_path, 'config remote.{0}.pushurl {1}'.format(app.GIT_REMOTE, app.GIT_REMOTE_URL))\n\n    def set_upstream_branch(self):\n        self._run_git(self._git_path, 'branch {0} --set-upstream-to origin/{1}'.format(app.BRANCH, app.BRANCH))\n"], "fixing_code": ["# coding=utf-8\n\nfrom __future__ import unicode_literals\n\nimport logging\nimport os\nimport platform\nimport re\nimport subprocess\nimport sys\n\nfrom medusa import app, notifiers\nfrom medusa.logger.adapters.style import BraceAdapter\nfrom medusa.updater.update_manager import UpdateManager\n\nfrom six import text_type\n\n\nERROR_MESSAGE = ('Unable to find your git executable. Set git executable path in Advanced Settings '\n                 'OR shutdown application and delete your .git folder and run from source to enable updates.')\n\nlog = BraceAdapter(logging.getLogger(__name__))\nlog.logger.addHandler(logging.NullHandler())\n\n\nclass GitUpdateManager(UpdateManager):\n    def __init__(self):\n        super(GitUpdateManager, self).__init__()\n        self._git_path = self._find_working_git()\n        self.github_org = self.get_github_org()\n        self.github_repo = self.get_github_repo()\n        self.branch = self._find_installed_branch()\n\n        self._cur_commit_hash = None\n        self._newest_commit_hash = None\n        self._num_commits_behind = 0\n        self._num_commits_ahead = 0\n\n    def __str__(self):\n        return 'GitHub Updater'\n\n    @property\n    def current_commit_hash(self):\n        return self._cur_commit_hash\n\n    @property\n    def newest_commit_hash(self):\n        return self._newest_commit_hash\n\n    @property\n    def current_version(self):\n        self.update_commit_hash()\n        cur_version = self._run_git(self._git_path, 'describe --tags --abbrev=0 {0}'.format(\n            self._cur_commit_hash))[0]\n        if cur_version:\n            return cur_version.lstrip('v')\n\n    @property\n    def newest_version(self):\n        self.update_newest_commit_hash()\n        new_version = self._run_git(self._git_path, 'describe --tags --abbrev=0 {0}'.format(\n            self._newest_commit_hash))[0]\n        if new_version:\n            return new_version.lstrip('v')\n\n    @property\n    def commits_behind(self):\n        return self._num_commits_behind\n\n    @property\n    def commits_ahead(self):\n        return self._num_commits_ahead\n\n    def _find_working_git(self):\n        test_cmd = 'version'\n        main_git = app.GIT_PATH or 'git'\n\n        log.debug(u'Checking if we can use git commands: {0} {1}', main_git, test_cmd)\n        _, _, exit_status = self._run_git(main_git, test_cmd)\n\n        if exit_status == 0:\n            log.debug(u'Using: {0}', main_git)\n            return main_git\n        else:\n            log.debug(u'Not using: {0}', main_git)\n\n        # trying alternatives\n        alternative_git = []\n\n        # osx people who start sr from launchd have a broken path, so try a hail-mary attempt for them\n        if platform.system().lower() == 'darwin':\n            alternative_git.append('/usr/local/git/bin/git')\n\n        if platform.system().lower() == 'windows':\n            if main_git != main_git.lower():\n                alternative_git.append(main_git.lower())\n\n        if alternative_git:\n            log.debug(u'Trying known alternative git locations')\n\n            for cur_git in alternative_git:\n                log.debug(u'Checking if we can use git commands: {0} {1}', cur_git, test_cmd)\n                _, _, exit_status = self._run_git(cur_git, test_cmd)\n\n                if exit_status == 0:\n                    log.debug(u'Using: {0}', cur_git)\n                    return cur_git\n                else:\n                    log.debug(u'Not using: {0}', cur_git)\n\n    def _run_git(self, git_path, args):\n        output = err = exit_status = None\n\n        if not git_path:\n            git_path = self._find_working_git()\n            if git_path:\n                self._git_path = git_path\n            else:\n                # Warn user only if he has version check enabled\n                if app.VERSION_NOTIFY:\n                    log.warning(u\"No git specified, can't use git commands\")\n                    app.NEWEST_VERSION_STRING = ERROR_MESSAGE\n                exit_status = 1\n                return output, err, exit_status\n\n        if git_path != 'git' and not os.path.isfile(git_path):\n            log.warning(u\"Invalid git specified, can't use git commands\")\n            exit_status = 1\n            return output, err, exit_status\n\n        # If we have a valid git remove the git warning\n        # String will be updated as soon we check github\n        app.NEWEST_VERSION_STRING = None\n        cmd = git_path + ' ' + args\n\n        try:\n            log.debug(u'Executing {cmd} with your shell in {dir}', {'cmd': cmd, 'dir': app.PROG_DIR})\n            p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n                                 shell=True, cwd=app.PROG_DIR)\n            output, err = p.communicate()\n            exit_status = p.returncode\n\n            # Convert bytes to string in python3\n            if isinstance(output, (bytes, bytearray)):\n                output = output.decode('utf-8')\n\n            if output:\n                output = output.strip()\n\n        except OSError:\n            log.info(u\"Command {cmd} didn't work\", {'cmd': cmd})\n            exit_status = 1\n\n        if exit_status == 0:\n            log.debug(u'{cmd} : returned successful', {'cmd': cmd})\n\n        elif exit_status == 1:\n            if output:\n                if 'stash' in output:\n                    log.warning(u\"Enable 'git reset' in settings or stash your changes in local files\")\n                else:\n                    log.warning(u'{cmd} returned : {output}', {'cmd': cmd, 'output': output})\n            else:\n                log.warning(u'{cmd} returned no data', {'cmd': cmd})\n\n        elif exit_status == 128:\n            log.warning('{cmd} returned ({status}) : {output}',\n                        {'cmd': cmd, 'status': exit_status, 'output': output})\n\n        elif exit_status == 129:\n            if 'unknown option' in output and 'set-upstream-to' in output:\n                log.info(\"Can't set upstream to origin/{0} because you're running an old version of git.\"\n                         '\\nPlease upgrade your git installation to its latest version.', app.BRANCH)\n            else:\n                log.warning('{cmd} returned ({status}) : {output}',\n                            {'cmd': cmd, 'status': exit_status, 'output': output})\n\n        else:\n            log.warning(u'{cmd} returned : {output}. Treat as error for now', {'cmd': cmd, 'output': output})\n            exit_status = 1\n\n        return output, err, exit_status\n\n    def update_commit_hash(self):\n        \"\"\"Attempt to set the hash of the currently installed version of the application.\n\n        Uses git to get commit version.\n        \"\"\"\n        output, _, exit_status = self._run_git(self._git_path, 'rev-parse HEAD')\n\n        if exit_status == 0 and output:\n            cur_commit_hash = output.strip()\n            if not re.match('^[a-z0-9]+$', cur_commit_hash):\n                log.warning(u\"Output doesn't look like a hash, not using it\")\n                return False\n\n            self._cur_commit_hash = cur_commit_hash\n            app.CUR_COMMIT_HASH = cur_commit_hash\n            return True\n\n        return False\n\n    def update_newest_commit_hash(self):\n        # update remote origin url\n        self.update_remote_origin()\n\n        # Configure local branch with upstream\n        self.set_upstream_branch()\n\n        # get all new info from github\n        output, _, exit_status = self._run_git(self._git_path, 'fetch --prune {0}'.format(app.GIT_REMOTE))\n        if not exit_status == 0:\n            log.warning(u\"Unable to contact github, can't check for update\")\n            return False\n\n        # get latest commit_hash from remote\n        output, _, exit_status = self._run_git(self._git_path, 'rev-parse --verify --quiet \"@{upstream}\"')\n\n        if exit_status == 0 and output:\n            cur_commit_hash = output.strip()\n            if not re.match('^[a-z0-9]+$', cur_commit_hash):\n                log.debug(u\"Output doesn't look like a hash, not using it\")\n                return False\n            else:\n                self._newest_commit_hash = cur_commit_hash\n                return True\n        else:\n            log.debug(u\"git didn't return newest commit hash\")\n            return False\n\n    def _find_installed_branch(self):\n        branch_info, _, exit_status = self._run_git(self._git_path, 'symbolic-ref -q HEAD')\n        if exit_status == 0 and branch_info:\n            branch = branch_info.strip().replace('refs/heads/', '', 1)\n            if branch:\n                app.BRANCH = branch\n                return branch\n        return ''\n\n    def check_for_update(self):\n        \"\"\"Use git commands to check if there is a newer version that the provided commit hash.\"\"\"\n        self.update_commit_hash()\n        self.update_newest_commit_hash()\n\n        # get number of commits behind and ahead (option --count not supported git < 1.7.2)\n        output, _, exit_status = self._run_git(self._git_path, 'rev-list --left-right \"@{upstream}\"...HEAD')\n        if exit_status == 0 and output:\n            try:\n                self._num_commits_behind = int(output.count('<'))\n                self._num_commits_ahead = int(output.count('>'))\n            except Exception:\n                log.debug(u\"git didn't return numbers for behind and ahead, not using it\")\n                return False\n\n        log.debug(u'cur_commit = {0}, newest_commit = {1}, num_commits_behind = {2}, num_commits_ahead = {3}',\n                  self._cur_commit_hash, self._newest_commit_hash, self._num_commits_behind, self._num_commits_ahead)\n\n    def need_update(self):\n        if self.branch != self._find_installed_branch():\n            log.debug(u'Branch checkout: {0}->{1}', self._find_installed_branch(), self.branch)\n            return True\n\n        try:\n            self.check_for_update()\n        except Exception as e:\n            log.warning(u\"Unable to contact github, can't check for update: {0!r}\", e)\n            return False\n\n        if self._num_commits_behind > 0 or self._num_commits_ahead > 0:\n            self._set_update_text()\n            return True\n\n        return False\n\n    def _set_update_text(self):\n        if self._num_commits_behind > 0 or self._is_hard_reset_allowed():\n            base_url = 'http://github.com/' + self.github_org + '/' + self.github_repo\n            if self._newest_commit_hash:\n                url = base_url + '/compare/' + self._cur_commit_hash + '...' + self._newest_commit_hash\n            else:\n                url = base_url + '/commits/'\n\n            newest_text = 'There is a <a href=\"' + url + '\" onclick=\"window.open(this.href); return false;\">newer version available</a> '\n            newest_text += \" (you're \" + text_type(self._num_commits_behind) + ' commit'\n            if self._num_commits_behind > 1:\n                newest_text += 's'\n            newest_text += ' behind'\n            if self._num_commits_ahead > 0:\n                newest_text += ' and {ahead} commit{s} ahead'.format(ahead=self._num_commits_ahead,\n                                                                     s='s' if self._num_commits_ahead > 1 else '')\n            newest_text += ') &mdash; <a href=\"' + self.get_update_url() + '\">Update Now</a>'\n\n        elif self._num_commits_ahead > 0:\n            newest_text = u'Local branch is ahead of {0}. Automatic update not possible'.format(self.branch)\n            log.warning(newest_text)\n        else:\n            return\n\n        app.NEWEST_VERSION_STRING = newest_text\n\n    def can_update(self):\n        \"\"\"Return whether update can be executed.\n\n        :return:\n        :rtype: bool\n        \"\"\"\n        # Version 0.4.6 is the last version which will run on python 2.7.13.\n        if sys.version_info.major == 2:\n            return False\n\n        return self._num_commits_ahead <= 0 or self._is_hard_reset_allowed()\n\n    def update(self):\n        \"\"\"Call git pull origin <branch> in order to update the application.\n\n        Returns a bool depending on the call's success.\n        \"\"\"\n        # update remote origin url\n        self.update_remote_origin()\n\n        # remove untracked files and performs a hard reset on git branch to avoid update issues\n        if self._is_hard_reset_allowed():\n            self.reset()\n\n        # Executing git clean before updating\n        self.clean()\n\n        current_branch = self._find_installed_branch()\n        if self.branch == current_branch:\n            _, _, exit_status = self._run_git(self._git_path, 'pull -f {0} {1}'.format(app.GIT_REMOTE, self.branch))\n        else:\n            log.warning(\n                u\"Couldn't determine current branch or current branch {current}\"\n                u\" doesn't match desired branch {desired}.\\n\"\n                u'Checkout the desired branch or try again later.', {\n                    'current': current_branch,\n                    'desired': self.branch\n                })\n            return False\n\n        # Executing git clean after updating\n        self.clean()\n\n        if exit_status == 0:\n            self.update_commit_hash()\n            # Notify update successful\n            if app.NOTIFY_ON_UPDATE:\n                try:\n                    notifiers.notify_git_update(app.CUR_COMMIT_HASH or '')\n                except Exception:\n                    log.debug(u'Unable to send update notification. Continuing the update process')\n            return True\n\n        return False\n\n    @staticmethod\n    def _is_hard_reset_allowed():\n        \"\"\"Return whether git hard reset is allowed or not.\n\n        :return:\n        :rtype: bool\n        \"\"\"\n        return app.GIT_RESET and (not app.GIT_RESET_BRANCHES or\n                                  app.BRANCH in app.GIT_RESET_BRANCHES)\n\n    def clean(self):\n        \"\"\"Call git clean to remove all untracked files.\n\n        It only affects source folders and libX and extX folders,\n        to prevent deleting untracked user data not known by .gitignore\n\n        :return:\n        :rtype: int\n        \"\"\"\n        folders = (app.LIB_FOLDER, app.LIB2_FOLDER, app.LIB3_FOLDER, app.EXT_FOLDER,\n                   app.EXT2_FOLDER, app.EXT3_FOLDER, app.SRC_FOLDER, app.STATIC_FOLDER) + app.LEGACY_SRC_FOLDERS\n        _, _, exit_status = self._run_git(self._git_path, 'clean -d -f -x {0}'.format(' '.join(folders)))\n\n        return exit_status\n\n    def reset(self):\n        \"\"\"Call git reset --hard to perform a hard reset.\"\"\"\n        _, _, exit_status = self._run_git(self._git_path, 'reset --hard {0}/{1}'.format(app.GIT_REMOTE, app.BRANCH))\n        if exit_status == 0:\n            return True\n\n    def list_remote_branches(self):\n        # update remote origin url\n        self.update_remote_origin()\n        app.BRANCH = self._find_installed_branch()\n\n        branches, _, exit_status = self._run_git(self._git_path, 'ls-remote --heads {0}'.format(app.GIT_REMOTE))\n        if exit_status == 0 and branches:\n            return re.findall(r'refs/heads/(.*)', branches)\n        return []\n\n    def update_remote_origin(self):\n        self._run_git(self._git_path, 'config remote.{0}.url {1}'.format(app.GIT_REMOTE, app.GIT_REMOTE_URL))\n        self._run_git(self._git_path, 'config remote.{0}.pushurl {1}'.format(app.GIT_REMOTE, app.GIT_REMOTE_URL))\n\n    def set_upstream_branch(self):\n        self._run_git(self._git_path, 'branch {0} --set-upstream-to origin/{1}'.format(app.BRANCH, app.BRANCH))\n"], "filenames": ["medusa/updater/github_updater.py"], "buggy_code_start_loc": [5], "buggy_code_end_loc": [127], "fixing_code_start_loc": [6], "fixing_code_end_loc": [130], "type": "CWE-78", "message": "pymedusa is an automatic video library manager for TV Shows. In versions prior 1.0.12 an attacker with access to the web interface can update the git executable path in /config/general/ > advanced settings with arbitrary OS commands. An attacker may exploit this vulnerability to take execute arbitrary OS commands as the user running the pymedusa program. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-28627", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-27T21:15:12.310", "lastModified": "2023-04-04T17:02:07.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "pymedusa is an automatic video library manager for TV Shows. In versions prior 1.0.12 an attacker with access to the web interface can update the git executable path in /config/general/ > advanced settings with arbitrary OS commands. An attacker may exploit this vulnerability to take execute arbitrary OS commands as the user running the pymedusa program. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pymedusa:medusa:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.12", "matchCriteriaId": "FECD7ABD-8877-43E8-B1B9-716FF510EABE"}]}]}], "references": [{"url": "https://github.com/pymedusa/Medusa/commit/66d4be8f0872bd5ddcdc5c5a58cb014d22834a45", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pymedusa/Medusa/security/advisories/GHSA-6589-x6f5-cgg9", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pymedusa/Medusa/commit/66d4be8f0872bd5ddcdc5c5a58cb014d22834a45"}}