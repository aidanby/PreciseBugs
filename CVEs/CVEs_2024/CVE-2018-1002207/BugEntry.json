{"buggy_code": ["package archiver\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n)\n\n// Archiver represent a archive format\ntype Archiver interface {\n\t// Match checks supported files\n\tMatch(filename string) bool\n\t// Make makes an archive file on disk.\n\tMake(destination string, sources []string) error\n\t// Open extracts an archive file on disk.\n\tOpen(source, destination string) error\n\t// Write writes an archive to a Writer.\n\tWrite(output io.Writer, sources []string) error\n\t// Read reads an archive from a Reader.\n\tRead(input io.Reader, destination string) error\n}\n\n// SupportedFormats contains all supported archive formats\nvar SupportedFormats = map[string]Archiver{}\n\n// RegisterFormat adds a supported archive format\nfunc RegisterFormat(name string, format Archiver) {\n\tif _, ok := SupportedFormats[name]; ok {\n\t\tlog.Printf(\"Format %s already exists, skip!\\n\", name)\n\t\treturn\n\t}\n\tSupportedFormats[name] = format\n}\n\n// MatchingFormat returns the first archive format that matches\n// the given file, or nil if there is no match\nfunc MatchingFormat(fpath string) Archiver {\n\tfor _, fmt := range SupportedFormats {\n\t\tif fmt.Match(fpath) {\n\t\t\treturn fmt\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc writeNewFile(fpath string, in io.Reader, fm os.FileMode) error {\n\terr := os.MkdirAll(filepath.Dir(fpath), 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making directory for file: %v\", fpath, err)\n\t}\n\n\tout, err := os.Create(fpath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: creating new file: %v\", fpath, err)\n\t}\n\tdefer out.Close()\n\n\terr = out.Chmod(fm)\n\tif err != nil && runtime.GOOS != \"windows\" {\n\t\treturn fmt.Errorf(\"%s: changing file mode: %v\", fpath, err)\n\t}\n\n\t_, err = io.Copy(out, in)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: writing file: %v\", fpath, err)\n\t}\n\treturn nil\n}\n\nfunc writeNewSymbolicLink(fpath string, target string) error {\n\terr := os.MkdirAll(filepath.Dir(fpath), 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making directory for file: %v\", fpath, err)\n\t}\n\n\terr = os.Symlink(target, fpath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making symbolic link for: %v\", fpath, err)\n\t}\n\n\treturn nil\n}\n\nfunc writeNewHardLink(fpath string, target string) error {\n\terr := os.MkdirAll(filepath.Dir(fpath), 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making directory for file: %v\", fpath, err)\n\t}\n\n\terr = os.Link(target, fpath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making hard link for: %v\", fpath, err)\n\t}\n\n\treturn nil\n}\n\nfunc mkdir(dirPath string) error {\n\terr := os.MkdirAll(dirPath, 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making directory: %v\", dirPath, err)\n\t}\n\treturn nil\n}\n", "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/mholt/archiver\"\n)\n\nfunc main() {\n\tif len(os.Args) < 3 {\n\t\tfatal(usage)\n\t}\n\n\tcmd, filename := os.Args[1], os.Args[2]\n\n\tff := archiver.MatchingFormat(filename)\n\tif ff == nil {\n\t\tfatalf(\"%s: Unsupported file extension\", filename)\n\t}\n\n\tvar err error\n\tswitch cmd {\n\tcase \"make\":\n\t\tif len(os.Args) < 4 {\n\t\t\tfatal(usage)\n\t\t}\n\t\terr = ff.Make(filename, os.Args[3:])\n\tcase \"open\":\n\t\tdest := \"\"\n\t\tif len(os.Args) == 4 {\n\t\t\tdest = os.Args[3]\n\t\t} else if len(os.Args) > 4 {\n\t\t\tfatal(usage)\n\t\t}\n\t\terr = ff.Open(filename, dest)\n\tdefault:\n\t\tfatal(usage)\n\t}\n\tif err != nil {\n\t\tfatal(err)\n\t}\n}\n\nfunc fatal(v ...interface{}) {\n\tfmt.Fprintln(os.Stderr, v...)\n\tos.Exit(1)\n}\n\nfunc fatalf(s string, v ...interface{}) {\n\tfmt.Fprintf(os.Stderr, s+\"\\n\", v...)\n\tos.Exit(1)\n}\n\nconst usage = `Usage: archiver {make|open} <archive file> [files...]\n  make\n    Create a new archive file. List the files/folders\n    to include in the archive; at least one required.\n  open\n    Extract an archive file. Give only the archive to\n    open and the destination folder to extract into.\n\n  Specifying archive format:\n    The format of the archive is determined by its\n    file extension. Supported extensions:\n      .zip\n      .tar\n      .tar.gz\n      .tgz\n      .tar.bz2\n      .tbz2\n      .tar.xz\n      .txz\n      .tar.lz4\n      .tlz4\n      .tar.sz\n      .tsz\n      .rar (open only)\n\n  Existing files:\n    When creating an archive file that already exists,\n    archiver will overwrite the existing file. When\n    extracting files, archiver will NOT overwrite files\n    that already exist in the destination path; this\n    is treated as an error and extraction will abort.`\n", "package archiver\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/nwaples/rardecode\"\n)\n\n// Rar is for RAR archive format\nvar Rar rarFormat\n\nfunc init() {\n\tRegisterFormat(\"Rar\", Rar)\n}\n\ntype rarFormat struct{}\n\nfunc (rarFormat) Match(filename string) bool {\n\treturn strings.HasSuffix(strings.ToLower(filename), \".rar\") || isRar(filename)\n}\n\n// isRar checks the file has the RAR 1.5 or 5.0 format signature by reading its\n// beginning bytes and matching it\nfunc isRar(rarPath string) bool {\n\tf, err := os.Open(rarPath)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer f.Close()\n\n\tbuf := make([]byte, 8)\n\tif n, err := f.Read(buf); err != nil || n < 8 {\n\t\treturn false\n\t}\n\n\treturn bytes.Equal(buf[:7], []byte(\"Rar!\\x1a\\x07\\x00\")) || // ver 1.5\n\t\tbytes.Equal(buf, []byte(\"Rar!\\x1a\\x07\\x01\\x00\")) // ver 5.0\n}\n\n// Write outputs a .rar archive, but this is not implemented because\n// RAR is a proprietary format. It is here only for symmetry with\n// the other archive formats in this package.\nfunc (rarFormat) Write(output io.Writer, filePaths []string) error {\n\treturn fmt.Errorf(\"write: RAR not implemented (proprietary format)\")\n}\n\n// Make makes a .rar archive, but this is not implemented because\n// RAR is a proprietary format. It is here only for symmetry with\n// the other archive formats in this package.\nfunc (rarFormat) Make(rarPath string, filePaths []string) error {\n\treturn fmt.Errorf(\"make %s: RAR not implemented (proprietary format)\", rarPath)\n}\n\n// Read extracts the RAR file read from input and puts the contents\n// into destination.\nfunc (rarFormat) Read(input io.Reader, destination string) error {\n\trr, err := rardecode.NewReader(input, \"\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"read: failed to create reader: %v\", err)\n\t}\n\n\tfor {\n\t\theader, err := rr.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif header.IsDir {\n\t\t\terr = mkdir(filepath.Join(destination, header.Name))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// if files come before their containing folders, then we must\n\t\t// create their folders before writing the file\n\t\terr = mkdir(filepath.Dir(filepath.Join(destination, header.Name)))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = writeNewFile(filepath.Join(destination, header.Name), rr, header.Mode())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Open extracts the RAR file at source and puts the contents\n// into destination.\nfunc (rarFormat) Open(source, destination string) error {\n\trf, err := os.Open(source)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: failed to open file: %v\", source, err)\n\t}\n\tdefer rf.Close()\n\n\treturn Rar.Read(rf, destination)\n}\n", "package archiver\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Tar is for Tar format\nvar Tar tarFormat\n\nfunc init() {\n\tRegisterFormat(\"Tar\", Tar)\n}\n\ntype tarFormat struct{}\n\nfunc (tarFormat) Match(filename string) bool {\n\treturn strings.HasSuffix(strings.ToLower(filename), \".tar\") || isTar(filename)\n}\n\nconst tarBlockSize int = 512\n\n// isTar checks the file has the Tar format header by reading its beginning\n// block.\nfunc isTar(tarPath string) bool {\n\tf, err := os.Open(tarPath)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer f.Close()\n\n\tbuf := make([]byte, tarBlockSize)\n\tif _, err = io.ReadFull(f, buf); err != nil {\n\t\treturn false\n\t}\n\n\treturn hasTarHeader(buf)\n}\n\n// hasTarHeader checks passed bytes has a valid tar header or not. buf must\n// contain at least 512 bytes and if not, it always returns false.\nfunc hasTarHeader(buf []byte) bool {\n\tif len(buf) < tarBlockSize {\n\t\treturn false\n\t}\n\n\tb := buf[148:156]\n\tb = bytes.Trim(b, \" \\x00\") // clean up all spaces and null bytes\n\tif len(b) == 0 {\n\t\treturn false // unknown format\n\t}\n\thdrSum, err := strconv.ParseUint(string(b), 8, 64)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// According to the go official archive/tar, Sun tar uses signed byte\n\t// values so this calcs both signed and unsigned\n\tvar usum uint64\n\tvar sum int64\n\tfor i, c := range buf {\n\t\tif 148 <= i && i < 156 {\n\t\t\tc = ' ' // checksum field itself is counted as branks\n\t\t}\n\t\tusum += uint64(uint8(c))\n\t\tsum += int64(int8(c))\n\t}\n\n\tif hdrSum != usum && int64(hdrSum) != sum {\n\t\treturn false // invalid checksum\n\t}\n\n\treturn true\n}\n\n// Write outputs a .tar file to a Writer containing the\n// contents of files listed in filePaths. File paths can\n// be those of regular files or directories. Regular\n// files are stored at the 'root' of the archive, and\n// directories are recursively added.\nfunc (tarFormat) Write(output io.Writer, filePaths []string) error {\n\treturn writeTar(filePaths, output, \"\")\n}\n\n// Make creates a .tar file at tarPath containing the\n// contents of files listed in filePaths. File paths can\n// be those of regular files or directories. Regular\n// files are stored at the 'root' of the archive, and\n// directories are recursively added.\nfunc (tarFormat) Make(tarPath string, filePaths []string) error {\n\tout, err := os.Create(tarPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating %s: %v\", tarPath, err)\n\t}\n\tdefer out.Close()\n\n\treturn writeTar(filePaths, out, tarPath)\n}\n\nfunc writeTar(filePaths []string, output io.Writer, dest string) error {\n\ttarWriter := tar.NewWriter(output)\n\tdefer tarWriter.Close()\n\n\treturn tarball(filePaths, tarWriter, dest)\n}\n\n// tarball writes all files listed in filePaths into tarWriter, which is\n// writing into a file located at dest.\nfunc tarball(filePaths []string, tarWriter *tar.Writer, dest string) error {\n\tfor _, fpath := range filePaths {\n\t\terr := tarFile(tarWriter, fpath, dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// tarFile writes the file at source into tarWriter. It does so\n// recursively for directories.\nfunc tarFile(tarWriter *tar.Writer, source, dest string) error {\n\tsourceInfo, err := os.Stat(source)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: stat: %v\", source, err)\n\t}\n\n\tvar baseDir string\n\tif sourceInfo.IsDir() {\n\t\tbaseDir = filepath.Base(source)\n\t}\n\n\treturn filepath.Walk(source, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error walking to %s: %v\", path, err)\n\t\t}\n\n\t\theader, err := tar.FileInfoHeader(info, path)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: making header: %v\", path, err)\n\t\t}\n\n\t\tif baseDir != \"\" {\n\t\t\theader.Name = filepath.Join(baseDir, strings.TrimPrefix(path, source))\n\t\t}\n\n\t\tif header.Name == dest {\n\t\t\t// our new tar file is inside the directory being archived; skip it\n\t\t\treturn nil\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\theader.Name += \"/\"\n\t\t}\n\n\t\terr = tarWriter.WriteHeader(header)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: writing header: %v\", path, err)\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\n\t\tif header.Typeflag == tar.TypeReg {\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"%s: open: %v\", path, err)\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\t_, err = io.CopyN(tarWriter, file, info.Size())\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn fmt.Errorf(\"%s: copying contents: %v\", path, err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// Read untars a .tar file read from a Reader and puts\n// the contents into destination.\nfunc (tarFormat) Read(input io.Reader, destination string) error {\n\treturn untar(tar.NewReader(input), destination)\n}\n\n// Open untars source and puts the contents into destination.\nfunc (tarFormat) Open(source, destination string) error {\n\tf, err := os.Open(source)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: failed to open archive: %v\", source, err)\n\t}\n\tdefer f.Close()\n\n\treturn Tar.Read(f, destination)\n}\n\n// untar un-tarballs the contents of tr into destination.\nfunc untar(tr *tar.Reader, destination string) error {\n\tfor {\n\t\theader, err := tr.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := untarFile(tr, header, destination); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// untarFile untars a single file from tr with header header into destination.\nfunc untarFile(tr *tar.Reader, header *tar.Header, destination string) error {\n\tswitch header.Typeflag {\n\tcase tar.TypeDir:\n\t\treturn mkdir(filepath.Join(destination, header.Name))\n\tcase tar.TypeReg, tar.TypeRegA, tar.TypeChar, tar.TypeBlock, tar.TypeFifo:\n\t\treturn writeNewFile(filepath.Join(destination, header.Name), tr, header.FileInfo().Mode())\n\tcase tar.TypeSymlink:\n\t\treturn writeNewSymbolicLink(filepath.Join(destination, header.Name), header.Linkname)\n\tcase tar.TypeLink:\n\t\treturn writeNewHardLink(filepath.Join(destination, header.Name), filepath.Join(destination, header.Linkname))\n\tdefault:\n\t\treturn fmt.Errorf(\"%s: unknown type flag: %c\", header.Name, header.Typeflag)\n\t}\n}\n", "// Package archiver makes it super easy to create and open .zip,\n// .tar.gz, and .tar.bz2 files.\npackage archiver\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Zip is for Zip format\nvar Zip zipFormat\n\nfunc init() {\n\tRegisterFormat(\"Zip\", Zip)\n}\n\ntype zipFormat struct{}\n\nfunc (zipFormat) Match(filename string) bool {\n\treturn strings.HasSuffix(strings.ToLower(filename), \".zip\") || isZip(filename)\n}\n\n// isZip checks the file has the Zip format signature by reading its beginning\n// bytes and matching it against \"PK\\x03\\x04\"\nfunc isZip(zipPath string) bool {\n\tf, err := os.Open(zipPath)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer f.Close()\n\n\tbuf := make([]byte, 4)\n\tif n, err := f.Read(buf); err != nil || n < 4 {\n\t\treturn false\n\t}\n\n\treturn bytes.Equal(buf, []byte(\"PK\\x03\\x04\"))\n}\n\n// Write outputs a .zip file to the given writer with\n// the contents of files listed in filePaths. File paths\n// can be those of regular files or directories. Regular\n// files are stored at the 'root' of the archive, and\n// directories are recursively added.\n//\n// Files with an extension for formats that are already\n// compressed will be stored only, not compressed.\nfunc (zipFormat) Write(output io.Writer, filePaths []string) error {\n\tw := zip.NewWriter(output)\n\tfor _, fpath := range filePaths {\n\t\tif err := zipFile(w, fpath); err != nil {\n\t\t\tw.Close()\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn w.Close()\n}\n\n// Make creates a .zip file in the location zipPath containing\n// the contents of files listed in filePaths. File paths\n// can be those of regular files or directories. Regular\n// files are stored at the 'root' of the archive, and\n// directories are recursively added.\n//\n// Files with an extension for formats that are already\n// compressed will be stored only, not compressed.\nfunc (zipFormat) Make(zipPath string, filePaths []string) error {\n\tout, err := os.Create(zipPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating %s: %v\", zipPath, err)\n\t}\n\tdefer out.Close()\n\n\treturn Zip.Write(out, filePaths)\n}\n\nfunc zipFile(w *zip.Writer, source string) error {\n\tsourceInfo, err := os.Stat(source)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: stat: %v\", source, err)\n\t}\n\n\tvar baseDir string\n\tif sourceInfo.IsDir() {\n\t\tbaseDir = filepath.Base(source)\n\t}\n\n\treturn filepath.Walk(source, func(fpath string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"walking to %s: %v\", fpath, err)\n\t\t}\n\n\t\theader, err := zip.FileInfoHeader(info)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: getting header: %v\", fpath, err)\n\t\t}\n\n\t\tif baseDir != \"\" {\n\t\t\tname, err := filepath.Rel(source, fpath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\theader.Name = path.Join(baseDir, filepath.ToSlash(name))\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\theader.Name += \"/\"\n\t\t\theader.Method = zip.Store\n\t\t} else {\n\t\t\text := strings.ToLower(path.Ext(header.Name))\n\t\t\tif _, ok := compressedFormats[ext]; ok {\n\t\t\t\theader.Method = zip.Store\n\t\t\t} else {\n\t\t\t\theader.Method = zip.Deflate\n\t\t\t}\n\t\t}\n\n\t\twriter, err := w.CreateHeader(header)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: making header: %v\", fpath, err)\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\n\t\tif header.Mode().IsRegular() {\n\t\t\tfile, err := os.Open(fpath)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"%s: opening: %v\", fpath, err)\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\t_, err = io.CopyN(writer, file, info.Size())\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn fmt.Errorf(\"%s: copying contents: %v\", fpath, err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n}\n\n// Read unzips the .zip file read from the input Reader into destination.\nfunc (zipFormat) Read(input io.Reader, destination string) error {\n\tbuf, err := ioutil.ReadAll(input)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trdr := bytes.NewReader(buf)\n\tr, err := zip.NewReader(rdr, rdr.Size())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn unzipAll(r, destination)\n}\n\n// Open unzips the .zip file at source into destination.\nfunc (zipFormat) Open(source, destination string) error {\n\tr, err := zip.OpenReader(source)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\n\treturn unzipAll(&r.Reader, destination)\n}\n\nfunc unzipAll(r *zip.Reader, destination string) error {\n\tfor _, zf := range r.File {\n\t\tif err := unzipFile(zf, destination); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc unzipFile(zf *zip.File, destination string) error {\n\tif strings.HasSuffix(zf.Name, \"/\") {\n\t\treturn mkdir(filepath.Join(destination, zf.Name))\n\t}\n\n\trc, err := zf.Open()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: open compressed file: %v\", zf.Name, err)\n\t}\n\tdefer rc.Close()\n\n\treturn writeNewFile(filepath.Join(destination, zf.Name), rc, zf.FileInfo().Mode())\n}\n\n// compressedFormats is a (non-exhaustive) set of lowercased\n// file extensions for formats that are typically already\n// compressed. Compressing already-compressed files often\n// results in a larger file, so when possible, we check this\n// set to avoid that.\nvar compressedFormats = map[string]struct{}{\n\t\".7z\":   {},\n\t\".avi\":  {},\n\t\".bz2\":  {},\n\t\".cab\":  {},\n\t\".gif\":  {},\n\t\".gz\":   {},\n\t\".jar\":  {},\n\t\".jpeg\": {},\n\t\".jpg\":  {},\n\t\".lz\":   {},\n\t\".lzma\": {},\n\t\".mov\":  {},\n\t\".mp3\":  {},\n\t\".mp4\":  {},\n\t\".mpeg\": {},\n\t\".mpg\":  {},\n\t\".png\":  {},\n\t\".rar\":  {},\n\t\".tbz2\": {},\n\t\".tgz\":  {},\n\t\".txz\":  {},\n\t\".xz\":   {},\n\t\".zip\":  {},\n\t\".zipx\": {},\n}\n"], "fixing_code": ["package archiver\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n)\n\n// Archiver represent a archive format\ntype Archiver interface {\n\t// Match checks supported files\n\tMatch(filename string) bool\n\t// Make makes an archive file on disk.\n\tMake(destination string, sources []string) error\n\t// Open extracts an archive file on disk.\n\tOpen(source, destination string) error\n\t// Write writes an archive to a Writer.\n\tWrite(output io.Writer, sources []string) error\n\t// Read reads an archive from a Reader.\n\tRead(input io.Reader, destination string) error\n}\n\n// SupportedFormats contains all supported archive formats\nvar SupportedFormats = map[string]Archiver{}\n\n// RegisterFormat adds a supported archive format\nfunc RegisterFormat(name string, format Archiver) {\n\tif _, ok := SupportedFormats[name]; ok {\n\t\tlog.Printf(\"Format %s already exists, skip!\\n\", name)\n\t\treturn\n\t}\n\tSupportedFormats[name] = format\n}\n\n// MatchingFormat returns the first archive format that matches\n// the given file, or nil if there is no match\nfunc MatchingFormat(fpath string) Archiver {\n\tfor _, fmt := range SupportedFormats {\n\t\tif fmt.Match(fpath) {\n\t\t\treturn fmt\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc writeNewFile(fpath string, in io.Reader, fm os.FileMode) error {\n\terr := os.MkdirAll(filepath.Dir(fpath), 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making directory for file: %v\", fpath, err)\n\t}\n\n\tout, err := os.Create(fpath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: creating new file: %v\", fpath, err)\n\t}\n\tdefer out.Close()\n\n\terr = out.Chmod(fm)\n\tif err != nil && runtime.GOOS != \"windows\" {\n\t\treturn fmt.Errorf(\"%s: changing file mode: %v\", fpath, err)\n\t}\n\n\t_, err = io.Copy(out, in)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: writing file: %v\", fpath, err)\n\t}\n\treturn nil\n}\n\nfunc writeNewSymbolicLink(fpath string, target string) error {\n\terr := os.MkdirAll(filepath.Dir(fpath), 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making directory for file: %v\", fpath, err)\n\t}\n\n\terr = os.Symlink(target, fpath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making symbolic link for: %v\", fpath, err)\n\t}\n\n\treturn nil\n}\n\nfunc writeNewHardLink(fpath string, target string) error {\n\terr := os.MkdirAll(filepath.Dir(fpath), 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making directory for file: %v\", fpath, err)\n\t}\n\n\terr = os.Link(target, fpath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making hard link for: %v\", fpath, err)\n\t}\n\n\treturn nil\n}\n\nfunc mkdir(dirPath string) error {\n\terr := os.MkdirAll(dirPath, 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: making directory: %v\", dirPath, err)\n\t}\n\treturn nil\n}\n\nfunc sanitizeExtractPath(filePath string, destination string) error {\n\t// to avoid zip slip (writing outside of the destination), we resolve\n\t// the target path, and make sure it's nested in the intended\n\t// destination, or bail otherwise.\n\tdestpath := filepath.Join(destination, filePath)\n\tif !strings.HasPrefix(destpath, destination) {\n\t\treturn fmt.Errorf(\"%s: illegal file path\", filePath)\n\t}\n\treturn nil\n}\n", "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/mholt/archiver\"\n)\n\nfunc main() {\n\tif len(os.Args) < 3 {\n\t\tfatal(usage)\n\t}\n\n\tcmd, filename := os.Args[1], os.Args[2]\n\n\tff := archiver.MatchingFormat(filename)\n\tif ff == nil {\n\t\tfatalf(\"%s: Unsupported file extension\", filename)\n\t}\n\n\tvar err error\n\tswitch cmd {\n\tcase \"make\":\n\t\tif len(os.Args) < 4 {\n\t\t\tfatal(usage)\n\t\t}\n\t\terr = ff.Make(filename, os.Args[3:])\n\tcase \"open\":\n\t\tdest, osErr := os.Getwd()\n\t\tif osErr != nil {\n\t\t\tfatal(err)\n\t\t}\n\t\tif len(os.Args) == 4 {\n\t\t\tdest = os.Args[3]\n\t\t} else if len(os.Args) > 4 {\n\t\t\tfatal(usage)\n\t\t}\n\t\terr = ff.Open(filename, dest)\n\tdefault:\n\t\tfatal(usage)\n\t}\n\tif err != nil {\n\t\tfatal(err)\n\t}\n}\n\nfunc fatal(v ...interface{}) {\n\tfmt.Fprintln(os.Stderr, v...)\n\tos.Exit(1)\n}\n\nfunc fatalf(s string, v ...interface{}) {\n\tfmt.Fprintf(os.Stderr, s+\"\\n\", v...)\n\tos.Exit(1)\n}\n\nconst usage = `Usage: archiver {make|open} <archive file> [files...]\n  make\n    Create a new archive file. List the files/folders\n    to include in the archive; at least one required.\n  open\n    Extract an archive file. Give only the archive to\n    open and the destination folder to extract into.\n\n  Specifying archive format:\n    The format of the archive is determined by its\n    file extension. Supported extensions:\n      .zip\n      .tar\n      .tar.gz\n      .tgz\n      .tar.bz2\n      .tbz2\n      .tar.xz\n      .txz\n      .tar.lz4\n      .tlz4\n      .tar.sz\n      .tsz\n      .rar (open only)\n\n  Existing files:\n    When creating an archive file that already exists,\n    archiver will overwrite the existing file. When\n    extracting files, archiver will NOT overwrite files\n    that already exist in the destination path; this\n    is treated as an error and extraction will abort.`\n", "package archiver\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/nwaples/rardecode\"\n)\n\n// Rar is for RAR archive format\nvar Rar rarFormat\n\nfunc init() {\n\tRegisterFormat(\"Rar\", Rar)\n}\n\ntype rarFormat struct{}\n\nfunc (rarFormat) Match(filename string) bool {\n\treturn strings.HasSuffix(strings.ToLower(filename), \".rar\") || isRar(filename)\n}\n\n// isRar checks the file has the RAR 1.5 or 5.0 format signature by reading its\n// beginning bytes and matching it\nfunc isRar(rarPath string) bool {\n\tf, err := os.Open(rarPath)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer f.Close()\n\n\tbuf := make([]byte, 8)\n\tif n, err := f.Read(buf); err != nil || n < 8 {\n\t\treturn false\n\t}\n\n\treturn bytes.Equal(buf[:7], []byte(\"Rar!\\x1a\\x07\\x00\")) || // ver 1.5\n\t\tbytes.Equal(buf, []byte(\"Rar!\\x1a\\x07\\x01\\x00\")) // ver 5.0\n}\n\n// Write outputs a .rar archive, but this is not implemented because\n// RAR is a proprietary format. It is here only for symmetry with\n// the other archive formats in this package.\nfunc (rarFormat) Write(output io.Writer, filePaths []string) error {\n\treturn fmt.Errorf(\"write: RAR not implemented (proprietary format)\")\n}\n\n// Make makes a .rar archive, but this is not implemented because\n// RAR is a proprietary format. It is here only for symmetry with\n// the other archive formats in this package.\nfunc (rarFormat) Make(rarPath string, filePaths []string) error {\n\treturn fmt.Errorf(\"make %s: RAR not implemented (proprietary format)\", rarPath)\n}\n\n// Read extracts the RAR file read from input and puts the contents\n// into destination.\nfunc (rarFormat) Read(input io.Reader, destination string) error {\n\trr, err := rardecode.NewReader(input, \"\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"read: failed to create reader: %v\", err)\n\t}\n\n\tfor {\n\t\theader, err := rr.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = sanitizeExtractPath(header.Name, destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tdestpath := filepath.Join(destination, header.Name)\n\n\t\tif header.IsDir {\n\t\t\terr = mkdir(destpath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// if files come before their containing folders, then we must\n\t\t// create their folders before writing the file\n\t\terr = mkdir(filepath.Dir(destpath))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = writeNewFile(destpath, rr, header.Mode())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Open extracts the RAR file at source and puts the contents\n// into destination.\nfunc (rarFormat) Open(source, destination string) error {\n\trf, err := os.Open(source)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: failed to open file: %v\", source, err)\n\t}\n\tdefer rf.Close()\n\n\treturn Rar.Read(rf, destination)\n}\n", "package archiver\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Tar is for Tar format\nvar Tar tarFormat\n\nfunc init() {\n\tRegisterFormat(\"Tar\", Tar)\n}\n\ntype tarFormat struct{}\n\nfunc (tarFormat) Match(filename string) bool {\n\treturn strings.HasSuffix(strings.ToLower(filename), \".tar\") || isTar(filename)\n}\n\nconst tarBlockSize int = 512\n\n// isTar checks the file has the Tar format header by reading its beginning\n// block.\nfunc isTar(tarPath string) bool {\n\tf, err := os.Open(tarPath)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer f.Close()\n\n\tbuf := make([]byte, tarBlockSize)\n\tif _, err = io.ReadFull(f, buf); err != nil {\n\t\treturn false\n\t}\n\n\treturn hasTarHeader(buf)\n}\n\n// hasTarHeader checks passed bytes has a valid tar header or not. buf must\n// contain at least 512 bytes and if not, it always returns false.\nfunc hasTarHeader(buf []byte) bool {\n\tif len(buf) < tarBlockSize {\n\t\treturn false\n\t}\n\n\tb := buf[148:156]\n\tb = bytes.Trim(b, \" \\x00\") // clean up all spaces and null bytes\n\tif len(b) == 0 {\n\t\treturn false // unknown format\n\t}\n\thdrSum, err := strconv.ParseUint(string(b), 8, 64)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// According to the go official archive/tar, Sun tar uses signed byte\n\t// values so this calcs both signed and unsigned\n\tvar usum uint64\n\tvar sum int64\n\tfor i, c := range buf {\n\t\tif 148 <= i && i < 156 {\n\t\t\tc = ' ' // checksum field itself is counted as branks\n\t\t}\n\t\tusum += uint64(uint8(c))\n\t\tsum += int64(int8(c))\n\t}\n\n\tif hdrSum != usum && int64(hdrSum) != sum {\n\t\treturn false // invalid checksum\n\t}\n\n\treturn true\n}\n\n// Write outputs a .tar file to a Writer containing the\n// contents of files listed in filePaths. File paths can\n// be those of regular files or directories. Regular\n// files are stored at the 'root' of the archive, and\n// directories are recursively added.\nfunc (tarFormat) Write(output io.Writer, filePaths []string) error {\n\treturn writeTar(filePaths, output, \"\")\n}\n\n// Make creates a .tar file at tarPath containing the\n// contents of files listed in filePaths. File paths can\n// be those of regular files or directories. Regular\n// files are stored at the 'root' of the archive, and\n// directories are recursively added.\nfunc (tarFormat) Make(tarPath string, filePaths []string) error {\n\tout, err := os.Create(tarPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating %s: %v\", tarPath, err)\n\t}\n\tdefer out.Close()\n\n\treturn writeTar(filePaths, out, tarPath)\n}\n\nfunc writeTar(filePaths []string, output io.Writer, dest string) error {\n\ttarWriter := tar.NewWriter(output)\n\tdefer tarWriter.Close()\n\n\treturn tarball(filePaths, tarWriter, dest)\n}\n\n// tarball writes all files listed in filePaths into tarWriter, which is\n// writing into a file located at dest.\nfunc tarball(filePaths []string, tarWriter *tar.Writer, dest string) error {\n\tfor _, fpath := range filePaths {\n\t\terr := tarFile(tarWriter, fpath, dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// tarFile writes the file at source into tarWriter. It does so\n// recursively for directories.\nfunc tarFile(tarWriter *tar.Writer, source, dest string) error {\n\tsourceInfo, err := os.Stat(source)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: stat: %v\", source, err)\n\t}\n\n\tvar baseDir string\n\tif sourceInfo.IsDir() {\n\t\tbaseDir = filepath.Base(source)\n\t}\n\n\treturn filepath.Walk(source, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error walking to %s: %v\", path, err)\n\t\t}\n\n\t\theader, err := tar.FileInfoHeader(info, path)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: making header: %v\", path, err)\n\t\t}\n\n\t\tif baseDir != \"\" {\n\t\t\theader.Name = filepath.Join(baseDir, strings.TrimPrefix(path, source))\n\t\t}\n\n\t\tif header.Name == dest {\n\t\t\t// our new tar file is inside the directory being archived; skip it\n\t\t\treturn nil\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\theader.Name += \"/\"\n\t\t}\n\n\t\terr = tarWriter.WriteHeader(header)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: writing header: %v\", path, err)\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\n\t\tif header.Typeflag == tar.TypeReg {\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"%s: open: %v\", path, err)\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\t_, err = io.CopyN(tarWriter, file, info.Size())\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn fmt.Errorf(\"%s: copying contents: %v\", path, err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// Read untars a .tar file read from a Reader and puts\n// the contents into destination.\nfunc (tarFormat) Read(input io.Reader, destination string) error {\n\treturn untar(tar.NewReader(input), destination)\n}\n\n// Open untars source and puts the contents into destination.\nfunc (tarFormat) Open(source, destination string) error {\n\tf, err := os.Open(source)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: failed to open archive: %v\", source, err)\n\t}\n\tdefer f.Close()\n\n\treturn Tar.Read(f, destination)\n}\n\n// untar un-tarballs the contents of tr into destination.\nfunc untar(tr *tar.Reader, destination string) error {\n\tfor {\n\t\theader, err := tr.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := untarFile(tr, header, destination); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// untarFile untars a single file from tr with header header into destination.\nfunc untarFile(tr *tar.Reader, header *tar.Header, destination string) error {\n\terr := sanitizeExtractPath(header.Name, destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdestpath := filepath.Join(destination, header.Name)\n\n\tswitch header.Typeflag {\n\tcase tar.TypeDir:\n\t\treturn mkdir(destpath)\n\tcase tar.TypeReg, tar.TypeRegA, tar.TypeChar, tar.TypeBlock, tar.TypeFifo:\n\t\treturn writeNewFile(destpath, tr, header.FileInfo().Mode())\n\tcase tar.TypeSymlink:\n\t\treturn writeNewSymbolicLink(destpath, header.Linkname)\n\tcase tar.TypeLink:\n\t\treturn writeNewHardLink(destpath, filepath.Join(destination, header.Linkname))\n\tdefault:\n\t\treturn fmt.Errorf(\"%s: unknown type flag: %c\", header.Name, header.Typeflag)\n\t}\n}\n", "// Package archiver makes it super easy to create and open .zip,\n// .tar.gz, and .tar.bz2 files.\npackage archiver\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Zip is for Zip format\nvar Zip zipFormat\n\nfunc init() {\n\tRegisterFormat(\"Zip\", Zip)\n}\n\ntype zipFormat struct{}\n\nfunc (zipFormat) Match(filename string) bool {\n\treturn strings.HasSuffix(strings.ToLower(filename), \".zip\") || isZip(filename)\n}\n\n// isZip checks the file has the Zip format signature by reading its beginning\n// bytes and matching it against \"PK\\x03\\x04\"\nfunc isZip(zipPath string) bool {\n\tf, err := os.Open(zipPath)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer f.Close()\n\n\tbuf := make([]byte, 4)\n\tif n, err := f.Read(buf); err != nil || n < 4 {\n\t\treturn false\n\t}\n\n\treturn bytes.Equal(buf, []byte(\"PK\\x03\\x04\"))\n}\n\n// Write outputs a .zip file to the given writer with\n// the contents of files listed in filePaths. File paths\n// can be those of regular files or directories. Regular\n// files are stored at the 'root' of the archive, and\n// directories are recursively added.\n//\n// Files with an extension for formats that are already\n// compressed will be stored only, not compressed.\nfunc (zipFormat) Write(output io.Writer, filePaths []string) error {\n\tw := zip.NewWriter(output)\n\tfor _, fpath := range filePaths {\n\t\tif err := zipFile(w, fpath); err != nil {\n\t\t\tw.Close()\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn w.Close()\n}\n\n// Make creates a .zip file in the location zipPath containing\n// the contents of files listed in filePaths. File paths\n// can be those of regular files or directories. Regular\n// files are stored at the 'root' of the archive, and\n// directories are recursively added.\n//\n// Files with an extension for formats that are already\n// compressed will be stored only, not compressed.\nfunc (zipFormat) Make(zipPath string, filePaths []string) error {\n\tout, err := os.Create(zipPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating %s: %v\", zipPath, err)\n\t}\n\tdefer out.Close()\n\n\treturn Zip.Write(out, filePaths)\n}\n\nfunc zipFile(w *zip.Writer, source string) error {\n\tsourceInfo, err := os.Stat(source)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: stat: %v\", source, err)\n\t}\n\n\tvar baseDir string\n\tif sourceInfo.IsDir() {\n\t\tbaseDir = filepath.Base(source)\n\t}\n\n\treturn filepath.Walk(source, func(fpath string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"walking to %s: %v\", fpath, err)\n\t\t}\n\n\t\theader, err := zip.FileInfoHeader(info)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: getting header: %v\", fpath, err)\n\t\t}\n\n\t\tif baseDir != \"\" {\n\t\t\tname, err := filepath.Rel(source, fpath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\theader.Name = path.Join(baseDir, filepath.ToSlash(name))\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\theader.Name += \"/\"\n\t\t\theader.Method = zip.Store\n\t\t} else {\n\t\t\text := strings.ToLower(path.Ext(header.Name))\n\t\t\tif _, ok := compressedFormats[ext]; ok {\n\t\t\t\theader.Method = zip.Store\n\t\t\t} else {\n\t\t\t\theader.Method = zip.Deflate\n\t\t\t}\n\t\t}\n\n\t\twriter, err := w.CreateHeader(header)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: making header: %v\", fpath, err)\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\n\t\tif header.Mode().IsRegular() {\n\t\t\tfile, err := os.Open(fpath)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"%s: opening: %v\", fpath, err)\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\t_, err = io.CopyN(writer, file, info.Size())\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn fmt.Errorf(\"%s: copying contents: %v\", fpath, err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n}\n\n// Read unzips the .zip file read from the input Reader into destination.\nfunc (zipFormat) Read(input io.Reader, destination string) error {\n\tbuf, err := ioutil.ReadAll(input)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trdr := bytes.NewReader(buf)\n\tr, err := zip.NewReader(rdr, rdr.Size())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn unzipAll(r, destination)\n}\n\n// Open unzips the .zip file at source into destination.\nfunc (zipFormat) Open(source, destination string) error {\n\tr, err := zip.OpenReader(source)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\n\treturn unzipAll(&r.Reader, destination)\n}\n\nfunc unzipAll(r *zip.Reader, destination string) error {\n\tfor _, zf := range r.File {\n\t\tif err := unzipFile(zf, destination); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc unzipFile(zf *zip.File, destination string) error {\n\terr := sanitizeExtractPath(zf.Name, destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif strings.HasSuffix(zf.Name, \"/\") {\n\t\treturn mkdir(filepath.Join(destination, zf.Name))\n\t}\n\n\trc, err := zf.Open()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: open compressed file: %v\", zf.Name, err)\n\t}\n\tdefer rc.Close()\n\n\treturn writeNewFile(filepath.Join(destination, zf.Name), rc, zf.FileInfo().Mode())\n}\n\n// compressedFormats is a (non-exhaustive) set of lowercased\n// file extensions for formats that are typically already\n// compressed. Compressing already-compressed files often\n// results in a larger file, so when possible, we check this\n// set to avoid that.\nvar compressedFormats = map[string]struct{}{\n\t\".7z\":   {},\n\t\".avi\":  {},\n\t\".bz2\":  {},\n\t\".cab\":  {},\n\t\".gif\":  {},\n\t\".gz\":   {},\n\t\".jar\":  {},\n\t\".jpeg\": {},\n\t\".jpg\":  {},\n\t\".lz\":   {},\n\t\".lzma\": {},\n\t\".mov\":  {},\n\t\".mp3\":  {},\n\t\".mp4\":  {},\n\t\".mpeg\": {},\n\t\".mpg\":  {},\n\t\".png\":  {},\n\t\".rar\":  {},\n\t\".tbz2\": {},\n\t\".tgz\":  {},\n\t\".txz\":  {},\n\t\".xz\":   {},\n\t\".zip\":  {},\n\t\".zipx\": {},\n}\n"], "filenames": ["archiver.go", "cmd/archiver/main.go", "rar.go", "tar.go", "zip.go"], "buggy_code_start_loc": [9, 30, 74, 221, 189], "buggy_code_end_loc": [107, 31, 91, 231, 189], "fixing_code_start_loc": [10, 30, 75, 222, 190], "fixing_code_end_loc": [120, 34, 98, 238, 195], "type": "CWE-22", "message": "mholt/archiver golang package before e4ef56d48eb029648b0e895bb0b6a393ef0829c3 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in an archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'.", "other": {"cve": {"id": "CVE-2018-1002207", "sourceIdentifier": "report@snyk.io", "published": "2018-07-25T17:29:02.047", "lastModified": "2019-10-09T23:32:35.523", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "mholt/archiver golang package before e4ef56d48eb029648b0e895bb0b6a393ef0829c3 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in an archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'."}, {"lang": "es", "value": "El paquete mholt/archiver golang en versiones anteriores a la e4ef56d48eb029648b0e895bb0b6a393ef0829c3 es vulnerable a un salto de directorio, lo que permite que los atacantes escriban en archivos arbitrarios mediante un ../ (punto punto barra) en una entrada de archivo que se gestiona de manera incorrecta durante la extracci\u00f3n. Esta vulnerabilidad tambi\u00e9n se conoce como \"Zip-Slip\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:archiver_project:archiver:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0", "matchCriteriaId": "3DBC181C-4AB6-4FCD-A7FD-193AFAF4E990"}]}]}], "references": [{"url": "https://github.com/mholt/archiver/commit/e4ef56d48eb029648b0e895bb0b6a393ef0829c3", "source": "report@snyk.io", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/mholt/archiver/pull/65", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/snyk/zip-slip-vulnerability", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/research/zip-slip-vulnerability", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMMHOLTARCHIVERCMDARCHIVER-50071", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mholt/archiver/commit/e4ef56d48eb029648b0e895bb0b6a393ef0829c3"}}