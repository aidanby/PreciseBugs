{"buggy_code": ["/*\n *\n * Copyright (C) 2011 Novell Inc.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 as published by\n * the Free Software Foundation.\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/splice.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include \"overlayfs.h\"\n\n#define OVL_COPY_UP_CHUNK_SIZE (1 << 20)\n\nint ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}\n\nstatic int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)\n{\n\tstruct file *old_file;\n\tstruct file *new_file;\n\tloff_t old_pos = 0;\n\tloff_t new_pos = 0;\n\tint error = 0;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\told_file = ovl_path_open(old, O_LARGEFILE | O_RDONLY);\n\tif (IS_ERR(old_file))\n\t\treturn PTR_ERR(old_file);\n\n\tnew_file = ovl_path_open(new, O_LARGEFILE | O_WRONLY);\n\tif (IS_ERR(new_file)) {\n\t\terror = PTR_ERR(new_file);\n\t\tgoto out_fput;\n\t}\n\n\t/* FIXME: copy up sparse files efficiently */\n\twhile (len) {\n\t\tsize_t this_len = OVL_COPY_UP_CHUNK_SIZE;\n\t\tlong bytes;\n\n\t\tif (len < this_len)\n\t\t\tthis_len = len;\n\n\t\tif (signal_pending_state(TASK_KILLABLE, current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes = do_splice_direct(old_file, &old_pos,\n\t\t\t\t\t new_file, &new_pos,\n\t\t\t\t\t this_len, SPLICE_F_MOVE);\n\t\tif (bytes <= 0) {\n\t\t\terror = bytes;\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(old_pos != new_pos);\n\n\t\tlen -= bytes;\n\t}\n\n\tfput(new_file);\nout_fput:\n\tfput(old_file);\n\treturn error;\n}\n\nstatic char *ovl_read_symlink(struct dentry *realdentry)\n{\n\tint res;\n\tchar *buf;\n\tstruct inode *inode = realdentry->d_inode;\n\tmm_segment_t old_fs;\n\n\tres = -EINVAL;\n\tif (!inode->i_op->readlink)\n\t\tgoto err;\n\n\tres = -ENOMEM;\n\tbuf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = inode->i_op->readlink(realdentry,\n\t\t\t\t    (char __user *)buf, PAGE_SIZE - 1);\n\tset_fs(old_fs);\n\tif (res < 0) {\n\t\tfree_page((unsigned long) buf);\n\t\tgoto err;\n\t}\n\tbuf[res] = '\\0';\n\n\treturn buf;\n\nerr:\n\treturn ERR_PTR(res);\n}\n\nstatic int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid =\n\t\t     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,\n\t\t.ia_atime = stat->atime,\n\t\t.ia_mtime = stat->mtime,\n\t};\n\n\treturn notify_change(upperdentry, &attr, NULL);\n}\n\nint ovl_set_attr(struct dentry *upperdentry, struct kstat *stat)\n{\n\tint err = 0;\n\n\tif (!S_ISLNK(stat->mode)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = stat->mode,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_uid = stat->uid,\n\t\t\t.ia_gid = stat->gid,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err)\n\t\tovl_set_timestamps(upperdentry, stat);\n\n\treturn err;\n}\n\nstatic int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\n\t/* Can't properly set mode on creation because of the umask */\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\n\t/*\n\t * Non-directores become opaque when copied up.\n\t */\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}\n\n/*\n * Copy up a single dentry\n *\n * Directory renames only allowed on \"pure upper\" (already created on\n * upper filesystem, never copied up).  Directories which are on lower or\n * are merged may not be renamed.  For these -EXDEV is returned and\n * userspace has to deal with it.  This means, when copying up a\n * directory we can rely on it and ancestors being stable.\n *\n * Non-directory renames start with copy up of source if necessary.  The\n * actual rename will only proceed once the copy up was successful.  Copy\n * up uses upper parent i_mutex for exclusion.  Since rename can change\n * d_parent it is possible that the copy up will lock the old parent.  At\n * that point the file will have already been copied up anyway.\n */\nint ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t    struct path *lowerpath, struct kstat *stat,\n\t\t    struct iattr *attr)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tint err;\n\tstruct kstat pstat;\n\tstruct path parentpath;\n\tstruct dentry *upperdir;\n\tstruct dentry *upperdentry;\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tchar *link = NULL;\n\n\tif (WARN_ON(!workdir))\n\t\treturn -EROFS;\n\n\tovl_path_upper(parent, &parentpath);\n\tupperdir = parentpath.dentry;\n\n\terr = vfs_getattr(&parentpath, &pstat);\n\tif (err)\n\t\treturn err;\n\n\tif (S_ISLNK(stat->mode)) {\n\t\tlink = ovl_read_symlink(lowerpath->dentry);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\n\terr = -ENOMEM;\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\tgoto out_free_link;\n\n\toverride_cred->fsuid = stat->uid;\n\toverride_cred->fsgid = stat->gid;\n\t/*\n\t * CAP_SYS_ADMIN for copying up extended attributes\n\t * CAP_DAC_OVERRIDE for create\n\t * CAP_FOWNER for chmod, timestamp update\n\t * CAP_FSETID for chmod\n\t * CAP_CHOWN for chown\n\t * CAP_MKNOD for mknod\n\t */\n\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\tcap_raise(override_cred->cap_effective, CAP_MKNOD);\n\told_cred = override_creds(override_cred);\n\n\terr = -EIO;\n\tif (lock_rename(workdir, upperdir) != NULL) {\n\t\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\t\tgoto out_unlock;\n\t}\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tunlock_rename(workdir, upperdir);\n\t\terr = 0;\n\t\t/* Raced with another copy-up?  Do the setattr here */\n\t\tif (attr) {\n\t\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\t\terr = notify_change(upperdentry, attr, NULL);\n\t\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t\t}\n\t\tgoto out_put_cred;\n\t}\n\n\terr = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,\n\t\t\t\t stat, attr, link);\n\tif (!err) {\n\t\t/* Restore timestamps on parent (best effort) */\n\t\tovl_set_timestamps(upperdir, &pstat);\n\t}\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_put_cred:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\nout_free_link:\n\tif (link)\n\t\tfree_page((unsigned long) link);\n\n\treturn err;\n}\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}\n"], "fixing_code": ["/*\n *\n * Copyright (C) 2011 Novell Inc.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 as published by\n * the Free Software Foundation.\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/splice.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include \"overlayfs.h\"\n\n#define OVL_COPY_UP_CHUNK_SIZE (1 << 20)\n\nint ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}\n\nstatic int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)\n{\n\tstruct file *old_file;\n\tstruct file *new_file;\n\tloff_t old_pos = 0;\n\tloff_t new_pos = 0;\n\tint error = 0;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\told_file = ovl_path_open(old, O_LARGEFILE | O_RDONLY);\n\tif (IS_ERR(old_file))\n\t\treturn PTR_ERR(old_file);\n\n\tnew_file = ovl_path_open(new, O_LARGEFILE | O_WRONLY);\n\tif (IS_ERR(new_file)) {\n\t\terror = PTR_ERR(new_file);\n\t\tgoto out_fput;\n\t}\n\n\t/* FIXME: copy up sparse files efficiently */\n\twhile (len) {\n\t\tsize_t this_len = OVL_COPY_UP_CHUNK_SIZE;\n\t\tlong bytes;\n\n\t\tif (len < this_len)\n\t\t\tthis_len = len;\n\n\t\tif (signal_pending_state(TASK_KILLABLE, current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes = do_splice_direct(old_file, &old_pos,\n\t\t\t\t\t new_file, &new_pos,\n\t\t\t\t\t this_len, SPLICE_F_MOVE);\n\t\tif (bytes <= 0) {\n\t\t\terror = bytes;\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(old_pos != new_pos);\n\n\t\tlen -= bytes;\n\t}\n\n\tfput(new_file);\nout_fput:\n\tfput(old_file);\n\treturn error;\n}\n\nstatic char *ovl_read_symlink(struct dentry *realdentry)\n{\n\tint res;\n\tchar *buf;\n\tstruct inode *inode = realdentry->d_inode;\n\tmm_segment_t old_fs;\n\n\tres = -EINVAL;\n\tif (!inode->i_op->readlink)\n\t\tgoto err;\n\n\tres = -ENOMEM;\n\tbuf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = inode->i_op->readlink(realdentry,\n\t\t\t\t    (char __user *)buf, PAGE_SIZE - 1);\n\tset_fs(old_fs);\n\tif (res < 0) {\n\t\tfree_page((unsigned long) buf);\n\t\tgoto err;\n\t}\n\tbuf[res] = '\\0';\n\n\treturn buf;\n\nerr:\n\treturn ERR_PTR(res);\n}\n\nstatic int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid =\n\t\t     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,\n\t\t.ia_atime = stat->atime,\n\t\t.ia_mtime = stat->mtime,\n\t};\n\n\treturn notify_change(upperdentry, &attr, NULL);\n}\n\nint ovl_set_attr(struct dentry *upperdentry, struct kstat *stat)\n{\n\tint err = 0;\n\n\tif (!S_ISLNK(stat->mode)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = stat->mode,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_uid = stat->uid,\n\t\t\t.ia_gid = stat->gid,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err)\n\t\tovl_set_timestamps(upperdentry, stat);\n\n\treturn err;\n}\n\nstatic int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\n\t/* Can't properly set mode on creation because of the umask */\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\n\t/*\n\t * Non-directores become opaque when copied up.\n\t */\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out2;\n}\n\n/*\n * Copy up a single dentry\n *\n * Directory renames only allowed on \"pure upper\" (already created on\n * upper filesystem, never copied up).  Directories which are on lower or\n * are merged may not be renamed.  For these -EXDEV is returned and\n * userspace has to deal with it.  This means, when copying up a\n * directory we can rely on it and ancestors being stable.\n *\n * Non-directory renames start with copy up of source if necessary.  The\n * actual rename will only proceed once the copy up was successful.  Copy\n * up uses upper parent i_mutex for exclusion.  Since rename can change\n * d_parent it is possible that the copy up will lock the old parent.  At\n * that point the file will have already been copied up anyway.\n */\nint ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t    struct path *lowerpath, struct kstat *stat,\n\t\t    struct iattr *attr)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tint err;\n\tstruct kstat pstat;\n\tstruct path parentpath;\n\tstruct dentry *upperdir;\n\tstruct dentry *upperdentry;\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tchar *link = NULL;\n\n\tif (WARN_ON(!workdir))\n\t\treturn -EROFS;\n\n\tovl_path_upper(parent, &parentpath);\n\tupperdir = parentpath.dentry;\n\n\terr = vfs_getattr(&parentpath, &pstat);\n\tif (err)\n\t\treturn err;\n\n\tif (S_ISLNK(stat->mode)) {\n\t\tlink = ovl_read_symlink(lowerpath->dentry);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\n\terr = -ENOMEM;\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\tgoto out_free_link;\n\n\toverride_cred->fsuid = stat->uid;\n\toverride_cred->fsgid = stat->gid;\n\t/*\n\t * CAP_SYS_ADMIN for copying up extended attributes\n\t * CAP_DAC_OVERRIDE for create\n\t * CAP_FOWNER for chmod, timestamp update\n\t * CAP_FSETID for chmod\n\t * CAP_CHOWN for chown\n\t * CAP_MKNOD for mknod\n\t */\n\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\tcap_raise(override_cred->cap_effective, CAP_MKNOD);\n\told_cred = override_creds(override_cred);\n\n\terr = -EIO;\n\tif (lock_rename(workdir, upperdir) != NULL) {\n\t\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\t\tgoto out_unlock;\n\t}\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tunlock_rename(workdir, upperdir);\n\t\terr = 0;\n\t\t/* Raced with another copy-up?  Do the setattr here */\n\t\tif (attr) {\n\t\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\t\terr = notify_change(upperdentry, attr, NULL);\n\t\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t\t}\n\t\tgoto out_put_cred;\n\t}\n\n\terr = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,\n\t\t\t\t stat, attr, link);\n\tif (!err) {\n\t\t/* Restore timestamps on parent (best effort) */\n\t\tovl_set_timestamps(upperdir, &pstat);\n\t}\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_put_cred:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\nout_free_link:\n\tif (link)\n\t\tfree_page((unsigned long) link);\n\n\treturn err;\n}\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}\n"], "filenames": ["fs/overlayfs/copy_up.c"], "buggy_code_start_loc": [270], "buggy_code_end_loc": [271], "fixing_code_start_loc": [270], "fixing_code_end_loc": [271], "type": "CWE-399", "message": "fs/overlayfs/copy_up.c in the Linux kernel before 4.2.6 uses an incorrect cleanup code path, which allows local users to cause a denial of service (dentry reference leak) via filesystem operations on a large file in a lower overlayfs layer.", "other": {"cve": {"id": "CVE-2015-8953", "sourceIdentifier": "cve@mitre.org", "published": "2016-10-16T21:59:03.067", "lastModified": "2016-11-28T19:50:48.003", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fs/overlayfs/copy_up.c in the Linux kernel before 4.2.6 uses an incorrect cleanup code path, which allows local users to cause a denial of service (dentry reference leak) via filesystem operations on a large file in a lower overlayfs layer."}, {"lang": "es", "value": "fs/overlayfs/copy_up.c en el kernel de Linux en versiones anteriores a 4.2.6 utiliza una ruta de c\u00f3digo de limpieza incorrecta, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (fuga de referencia dentry) a trav\u00e9s de operaciones de sistema de archivos en un archivo grande en una capa overlayfs inferior."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.2.5", "matchCriteriaId": "EE7F9892-828D-4C99-B78B-2FF1CEF53FA2"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ab79efab0a0ba01a74df782eb7fa44b044dae8b5", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.2.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/23/9", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/92611", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1367814", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/ab79efab0a0ba01a74df782eb7fa44b044dae8b5", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ab79efab0a0ba01a74df782eb7fa44b044dae8b5"}}