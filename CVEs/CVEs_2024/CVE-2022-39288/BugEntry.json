{"buggy_code": ["'use strict'\n\nconst { AsyncResource } = require('async_hooks')\nconst lru = require('tiny-lru').lru\n\nconst secureJson = require('secure-json-parse')\nconst {\n  kDefaultJsonParse,\n  kContentTypeParser,\n  kBodyLimit,\n  kRequestPayloadStream,\n  kState,\n  kTestInternals,\n  kReplyIsError,\n  kRouteContext\n} = require('./symbols')\n\nconst {\n  FST_ERR_CTP_INVALID_TYPE,\n  FST_ERR_CTP_EMPTY_TYPE,\n  FST_ERR_CTP_ALREADY_PRESENT,\n  FST_ERR_CTP_INVALID_HANDLER,\n  FST_ERR_CTP_INVALID_PARSE_TYPE,\n  FST_ERR_CTP_BODY_TOO_LARGE,\n  FST_ERR_CTP_INVALID_MEDIA_TYPE,\n  FST_ERR_CTP_INVALID_CONTENT_LENGTH,\n  FST_ERR_CTP_EMPTY_JSON_BODY\n} = require('./errors')\n\nfunction ContentTypeParser (bodyLimit, onProtoPoisoning, onConstructorPoisoning) {\n  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning)\n  this.customParsers = {}\n  this.customParsers['application/json'] = new Parser(true, false, bodyLimit, this[kDefaultJsonParse])\n  this.customParsers['text/plain'] = new Parser(true, false, bodyLimit, defaultPlainTextParser)\n  this.parserList = ['application/json', 'text/plain']\n  this.parserRegExpList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.add = function (contentType, opts, parserFn) {\n  const contentTypeIsString = typeof contentType === 'string'\n\n  if (!contentTypeIsString && !(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n  if (contentTypeIsString && contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE()\n  if (typeof parserFn !== 'function') throw new FST_ERR_CTP_INVALID_HANDLER()\n\n  if (this.existingParser(contentType)) {\n    throw new FST_ERR_CTP_ALREADY_PRESENT(contentType)\n  }\n\n  if (opts.parseAs !== undefined) {\n    if (opts.parseAs !== 'string' && opts.parseAs !== 'buffer') {\n      throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs)\n    }\n  }\n\n  const parser = new Parser(\n    opts.parseAs === 'string',\n    opts.parseAs === 'buffer',\n    opts.bodyLimit,\n    parserFn\n  )\n\n  if (contentTypeIsString && contentType === '*') {\n    this.customParsers[''] = parser\n  } else {\n    if (contentTypeIsString) {\n      this.parserList.unshift(contentType)\n    } else {\n      this.parserRegExpList.unshift(contentType)\n    }\n    this.customParsers[contentType] = parser\n  }\n}\n\nContentTypeParser.prototype.hasParser = function (contentType) {\n  return contentType in this.customParsers\n}\n\nContentTypeParser.prototype.existingParser = function (contentType) {\n  if (contentType === 'application/json') {\n    return this.customParsers['application/json'] && this.customParsers['application/json'].fn !== this[kDefaultJsonParse]\n  }\n  if (contentType === 'text/plain') {\n    return this.customParsers['text/plain'] && this.customParsers['text/plain'].fn !== defaultPlainTextParser\n  }\n\n  return contentType in this.customParsers\n}\n\nContentTypeParser.prototype.getParser = function (contentType) {\n  if (contentType in this.customParsers) {\n    return this.customParsers[contentType]\n  }\n\n  if (this.cache.has(contentType)) {\n    return this.cache.get(contentType)\n  }\n\n  // eslint-disable-next-line no-var\n  for (var i = 0; i !== this.parserList.length; ++i) {\n    const parserName = this.parserList[i]\n    if (contentType.indexOf(parserName) !== -1) {\n      const parser = this.customParsers[parserName]\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  // eslint-disable-next-line no-var\n  for (var j = 0; j !== this.parserRegExpList.length; ++j) {\n    const parserRegExp = this.parserRegExpList[j]\n    if (parserRegExp.test(contentType)) {\n      const parser = this.customParsers[parserRegExp]\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  return this.customParsers['']\n}\n\nContentTypeParser.prototype.removeAll = function () {\n  this.customParsers = {}\n  this.parserRegExpList = []\n  this.parserList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.remove = function (contentType) {\n  if (!(typeof contentType === 'string' || contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n\n  delete this.customParsers[contentType]\n\n  const parsers = typeof contentType === 'string' ? this.parserList : this.parserRegExpList\n\n  const idx = parsers.findIndex(ct => ct.toString() === contentType.toString())\n\n  if (idx > -1) {\n    parsers.splice(idx, 1)\n  }\n}\n\nContentTypeParser.prototype.run = function (contentType, handler, request, reply) {\n  const parser = this.getParser(contentType)\n  const resource = new AsyncResource('content-type-parser:run', request)\n\n  if (parser === undefined) {\n    if (request.is404) {\n      handler(request, reply)\n    } else {\n      reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || undefined))\n    }\n  } else if (parser.asString === true || parser.asBuffer === true) {\n    rawBody(\n      request,\n      reply,\n      reply[kRouteContext]._parserOptions,\n      parser,\n      done\n    )\n  } else {\n    const result = parser.fn(request, request[kRequestPayloadStream], done)\n\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n\n  function done (error, body) {\n    // We cannot use resource.bind() because it is broken in node v12 and v14\n    resource.runInAsyncScope(() => {\n      if (error) {\n        reply[kReplyIsError] = true\n        reply.send(error)\n      } else {\n        request.body = body\n        handler(request, reply)\n      }\n    })\n  }\n}\n\nfunction rawBody (request, reply, options, parser, done) {\n  const asString = parser.asString\n  const limit = options.limit === null ? parser.bodyLimit : options.limit\n  const contentLength = request.headers['content-length'] === undefined\n    ? NaN\n    : Number(request.headers['content-length'])\n\n  if (contentLength > limit) {\n    reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n    return\n  }\n\n  let receivedLength = 0\n  let body = asString === true ? '' : []\n\n  const payload = request[kRequestPayloadStream] || request.raw\n\n  if (asString === true) {\n    payload.setEncoding('utf8')\n  }\n\n  payload.on('data', onData)\n  payload.on('end', onEnd)\n  payload.on('error', onEnd)\n  payload.resume()\n\n  function onData (chunk) {\n    receivedLength += chunk.length\n\n    if ((payload.receivedEncodedLength || receivedLength) > limit) {\n      payload.removeListener('data', onData)\n      payload.removeListener('end', onEnd)\n      payload.removeListener('error', onEnd)\n      reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n      return\n    }\n\n    if (asString === true) {\n      body += chunk\n    } else {\n      body.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    payload.removeListener('data', onData)\n    payload.removeListener('end', onEnd)\n    payload.removeListener('error', onEnd)\n\n    if (err !== undefined) {\n      err.statusCode = 400\n      reply[kReplyIsError] = true\n      reply.code(err.statusCode).send(err)\n      return\n    }\n\n    if (asString === true) {\n      receivedLength = Buffer.byteLength(body)\n    }\n\n    if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {\n      reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH())\n      return\n    }\n\n    if (asString === false) {\n      body = Buffer.concat(body)\n    }\n\n    const result = parser.fn(request, body, done)\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n}\n\nfunction getDefaultJsonParser (onProtoPoisoning, onConstructorPoisoning) {\n  return defaultJsonParser\n\n  function defaultJsonParser (req, body, done) {\n    if (body === '' || body == null) {\n      return done(new FST_ERR_CTP_EMPTY_JSON_BODY(), undefined)\n    }\n    let json\n    try {\n      json = secureJson.parse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning })\n    } catch (err) {\n      err.statusCode = 400\n      return done(err, undefined)\n    }\n    done(null, json)\n  }\n}\n\nfunction defaultPlainTextParser (req, body, done) {\n  done(null, body)\n}\n\nfunction Parser (asString, asBuffer, bodyLimit, fn) {\n  this.asString = asString\n  this.asBuffer = asBuffer\n  this.bodyLimit = bodyLimit\n  this.fn = fn\n}\n\nfunction buildContentTypeParser (c) {\n  const contentTypeParser = new ContentTypeParser()\n  contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse]\n  Object.assign(contentTypeParser.customParsers, c.customParsers)\n  contentTypeParser.parserList = c.parserList.slice()\n  return contentTypeParser\n}\n\nfunction addContentTypeParser (contentType, opts, parser) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"addContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (typeof opts === 'function') {\n    parser = opts\n    opts = {}\n  }\n\n  if (!opts) opts = {}\n  if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit]\n\n  if (Array.isArray(contentType)) {\n    contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser))\n  } else {\n    this[kContentTypeParser].add(contentType, opts, parser)\n  }\n\n  return this\n}\n\nfunction hasContentTypeParser (contentType) {\n  return this[kContentTypeParser].hasParser(contentType)\n}\n\nfunction removeContentTypeParser (contentType) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (Array.isArray(contentType)) {\n    for (const type of contentType) {\n      this[kContentTypeParser].remove(type)\n    }\n  } else {\n    this[kContentTypeParser].remove(contentType)\n  }\n}\n\nfunction removeAllContentTypeParsers () {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeAllContentTypeParsers\" when fastify instance is already started!')\n  }\n\n  this[kContentTypeParser].removeAll()\n}\n\nmodule.exports = ContentTypeParser\nmodule.exports.helpers = {\n  buildContentTypeParser,\n  addContentTypeParser,\n  hasContentTypeParser,\n  removeContentTypeParser,\n  removeAllContentTypeParsers\n}\nmodule.exports.defaultParsers = {\n  getDefaultJsonParser,\n  defaultTextParser: defaultPlainTextParser\n}\nmodule.exports[kTestInternals] = { rawBody }\n", "'use strict'\n\nconst t = require('tap')\nconst test = t.test\nconst Fastify = require('..')\nconst keys = require('../lib/symbols')\nconst { FST_ERR_CTP_ALREADY_PRESENT, FST_ERR_CTP_INVALID_TYPE, FST_ERR_CTP_INVALID_MEDIA_TYPE } = require('../lib/errors')\n\nconst first = function (req, payload, done) {}\nconst second = function (req, payload, done) {}\nconst third = function (req, payload, done) {}\n\ntest('hasContentTypeParser', t => {\n  test('should know about internal parsers', t => {\n    t.plan(4)\n\n    const fastify = Fastify()\n    fastify.ready(err => {\n      t.error(err)\n      t.ok(fastify.hasContentTypeParser('application/json'))\n      t.ok(fastify.hasContentTypeParser('text/plain'))\n      t.notOk(fastify.hasContentTypeParser('application/jsoff'))\n    })\n  })\n\n  test('should work with string and RegExp', t => {\n    t.plan(7)\n\n    const fastify = Fastify()\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n    fastify.addContentTypeParser('image/gif', first)\n\n    t.ok(fastify.hasContentTypeParser('application/json'))\n    t.ok(fastify.hasContentTypeParser(/^image\\/.*/))\n    t.ok(fastify.hasContentTypeParser(/^application\\/.+\\+xml/))\n    t.ok(fastify.hasContentTypeParser('image/gif'))\n    t.notOk(fastify.hasContentTypeParser(/^image\\/.+\\+xml/))\n    t.notOk(fastify.hasContentTypeParser('image/png'))\n    t.notOk(fastify.hasContentTypeParser('*'))\n  })\n\n  t.end()\n})\n\ntest('getParser', t => {\n  test('should return matching parser', t => {\n    t.plan(3)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, second)\n    fastify.addContentTypeParser('text/html', third)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('application/t+xml').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/png').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, third)\n  })\n\n  test('should return matching parser with caching', t => {\n    t.plan(6)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('text/html', first)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 0)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html ').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 1)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html ').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 1)\n  })\n\n  test('should prefer content type parser with string value', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser('image/gif', second)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/gif').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/png').fn, first)\n  })\n\n  test('should return parser that catches all if no other is set', t => {\n    t.plan(3)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('*', first)\n    fastify.addContentTypeParser(/^text\\/.*/, second)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/gif').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text').fn, first)\n  })\n\n  test('should return undefined if no matching parser exist', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^weirdType\\/.+/, first)\n    fastify.addContentTypeParser('application/javascript', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].getParser('application/xml'))\n    t.notOk(fastify[keys.kContentTypeParser].getParser('weirdType/'))\n  })\n\n  t.end()\n})\n\ntest('existingParser', t => {\n  test('returns always false for \"*\"', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n    fastify.addContentTypeParser('text/html', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].existingParser('*'))\n\n    fastify.addContentTypeParser('*', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].existingParser('*'))\n  })\n\n  test('let you override the default parser once', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('application/json', first)\n    fastify.addContentTypeParser('text/plain', first)\n\n    t.throws(\n      () => fastify.addContentTypeParser('application/json', first),\n      FST_ERR_CTP_ALREADY_PRESENT,\n      \"Content type parser 'application/json' already present\"\n    )\n    t.throws(\n      () => fastify.addContentTypeParser('text/plain', first),\n      FST_ERR_CTP_ALREADY_PRESENT,\n      \"Content type parser 'text/plain' already present\"\n    )\n  })\n\n  const fastify = Fastify()\n  const contentTypeParser = fastify[keys.kContentTypeParser]\n\n  fastify.addContentTypeParser(/^image\\/.*/, first)\n  fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n  fastify.addContentTypeParser('text/html', first)\n\n  t.ok(contentTypeParser.existingParser(/^image\\/.*/))\n  t.ok(contentTypeParser.existingParser('text/html'))\n  t.ok(contentTypeParser.existingParser(/^application\\/.+\\+xml/))\n  t.notOk(contentTypeParser.existingParser('application/json'))\n  t.notOk(contentTypeParser.existingParser('text/plain'))\n  t.notOk(contentTypeParser.existingParser('image/png'))\n  t.notOk(contentTypeParser.existingParser(/^application\\/.+\\+json/))\n\n  t.end()\n})\n\ntest('add', t => {\n  test('should only accept string and RegExp', t => {\n    t.plan(4)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    t.error(contentTypeParser.add('test', {}, first))\n    t.error(contentTypeParser.add(/test/, {}, first))\n    t.throws(\n      () => contentTypeParser.add({}, {}, first),\n      FST_ERR_CTP_INVALID_TYPE,\n      'The content type should be a string or a RegExp'\n    )\n    t.throws(\n      () => contentTypeParser.add(1, {}, first),\n      FST_ERR_CTP_INVALID_TYPE,\n      'The content type should be a string or a RegExp'\n    )\n  })\n\n  test('should set \"*\" as parser that catches all', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.add('*', {}, first)\n    t.equal(contentTypeParser.customParsers[''].fn, first)\n  })\n\n  t.end()\n})\n\ntest('non-Error thrown from content parser is properly handled', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  const throwable = 'test'\n  const payload = 'error'\n\n  fastify.addContentTypeParser('text/test', (request, payload, done) => {\n    done(throwable)\n  })\n\n  fastify.post('/', (req, reply) => {\n  })\n\n  fastify.setErrorHandler((err, req, res) => {\n    t.equal(err, throwable)\n\n    res.send(payload)\n  })\n\n  fastify.inject({\n    method: 'POST',\n    url: '/',\n    headers: { 'Content-Type': 'text/test' },\n    body: 'some text'\n  }, (err, res) => {\n    t.error(err)\n    t.equal(res.payload, payload)\n  })\n})\n\ntest('Error thrown 415 from content type is null and make post request to server', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  const errMsg = new FST_ERR_CTP_INVALID_MEDIA_TYPE(undefined).message\n\n  fastify.post('/', (req, reply) => {\n  })\n\n  fastify.inject({\n    method: 'POST',\n    url: '/',\n    body: 'some text'\n  }, (err, res) => {\n    t.error(err)\n    t.equal(res.statusCode, 415)\n    t.equal(JSON.parse(res.body).message, errMsg)\n  })\n})\n\ntest('remove', t => {\n  test('should remove default parser', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove('application/json')\n\n    t.notOk(contentTypeParser.customParsers['application/json'])\n    t.notOk(contentTypeParser.parserList.find(parser => parser === 'application/json'))\n  })\n\n  test('should remove RegExp parser', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n    fastify.addContentTypeParser(/^text\\/*/, first)\n\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove(/^text\\/*/)\n\n    t.notOk(contentTypeParser.customParsers[/^text\\/*/])\n    t.notOk(contentTypeParser.parserRegExpList.find(parser => parser.toString() === /^text\\/*/.toString()))\n  })\n\n  test('should throw an error if content type is neither string nor RegExp', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    t.throws(() => fastify[keys.kContentTypeParser].remove(12), FST_ERR_CTP_INVALID_TYPE)\n  })\n\n  test('should not throw error if content type does not exist', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    t.doesNotThrow(() => fastify[keys.kContentTypeParser].remove('image/png'))\n  })\n\n  test('should not remove any content type parser if content type does not exist', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove('image/png')\n\n    t.same(Object.keys(contentTypeParser.customParsers).length, 2)\n  })\n\n  t.end()\n})\n\ntest('remove all should remove all existing parsers and reset cache', t => {\n  t.plan(4)\n\n  const fastify = Fastify()\n  fastify.addContentTypeParser('application/xml', first)\n  fastify.addContentTypeParser(/^image\\/.*/, first)\n\n  const contentTypeParser = fastify[keys.kContentTypeParser]\n\n  contentTypeParser.getParser('application/xml') // fill cache with one entry\n  contentTypeParser.removeAll()\n\n  t.same(contentTypeParser.cache.size, 0)\n  t.same(contentTypeParser.parserList.length, 0)\n  t.same(contentTypeParser.parserRegExpList.length, 0)\n  t.same(Object.keys(contentTypeParser.customParsers).length, 0)\n})\n"], "fixing_code": ["'use strict'\n\nconst { AsyncResource } = require('async_hooks')\nconst lru = require('tiny-lru').lru\n\nconst secureJson = require('secure-json-parse')\nconst {\n  kDefaultJsonParse,\n  kContentTypeParser,\n  kBodyLimit,\n  kRequestPayloadStream,\n  kState,\n  kTestInternals,\n  kReplyIsError,\n  kRouteContext\n} = require('./symbols')\n\nconst {\n  FST_ERR_CTP_INVALID_TYPE,\n  FST_ERR_CTP_EMPTY_TYPE,\n  FST_ERR_CTP_ALREADY_PRESENT,\n  FST_ERR_CTP_INVALID_HANDLER,\n  FST_ERR_CTP_INVALID_PARSE_TYPE,\n  FST_ERR_CTP_BODY_TOO_LARGE,\n  FST_ERR_CTP_INVALID_MEDIA_TYPE,\n  FST_ERR_CTP_INVALID_CONTENT_LENGTH,\n  FST_ERR_CTP_EMPTY_JSON_BODY\n} = require('./errors')\n\nfunction ContentTypeParser (bodyLimit, onProtoPoisoning, onConstructorPoisoning) {\n  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning)\n  // using a map instead of a plain object to avoid prototype hijack attacks\n  this.customParsers = new Map()\n  this.customParsers.set('application/json', new Parser(true, false, bodyLimit, this[kDefaultJsonParse]))\n  this.customParsers.set('text/plain', new Parser(true, false, bodyLimit, defaultPlainTextParser))\n  this.parserList = ['application/json', 'text/plain']\n  this.parserRegExpList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.add = function (contentType, opts, parserFn) {\n  const contentTypeIsString = typeof contentType === 'string'\n\n  if (!contentTypeIsString && !(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n  if (contentTypeIsString && contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE()\n  if (typeof parserFn !== 'function') throw new FST_ERR_CTP_INVALID_HANDLER()\n\n  if (this.existingParser(contentType)) {\n    throw new FST_ERR_CTP_ALREADY_PRESENT(contentType)\n  }\n\n  if (opts.parseAs !== undefined) {\n    if (opts.parseAs !== 'string' && opts.parseAs !== 'buffer') {\n      throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs)\n    }\n  }\n\n  const parser = new Parser(\n    opts.parseAs === 'string',\n    opts.parseAs === 'buffer',\n    opts.bodyLimit,\n    parserFn\n  )\n\n  if (contentTypeIsString && contentType === '*') {\n    this.customParsers.set('', parser)\n  } else {\n    if (contentTypeIsString) {\n      this.parserList.unshift(contentType)\n    } else {\n      this.parserRegExpList.unshift(contentType)\n    }\n    this.customParsers.set(contentType.toString(), parser)\n  }\n}\n\nContentTypeParser.prototype.hasParser = function (contentType) {\n  return this.customParsers.has(typeof contentType === 'string' ? contentType : contentType.toString())\n}\n\nContentTypeParser.prototype.existingParser = function (contentType) {\n  if (contentType === 'application/json' && this.customParsers.has(contentType)) {\n    return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse]\n  }\n  if (contentType === 'text/plain' && this.customParsers.has(contentType)) {\n    return this.customParsers.get(contentType).fn !== defaultPlainTextParser\n  }\n\n  return this.hasParser(contentType)\n}\n\nContentTypeParser.prototype.getParser = function (contentType) {\n  if (this.hasParser(contentType)) {\n    return this.customParsers.get(contentType)\n  }\n\n  if (this.cache.has(contentType)) {\n    return this.cache.get(contentType)\n  }\n\n  // eslint-disable-next-line no-var\n  for (var i = 0; i !== this.parserList.length; ++i) {\n    const parserName = this.parserList[i]\n    if (contentType.indexOf(parserName) !== -1) {\n      const parser = this.customParsers.get(parserName)\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  // eslint-disable-next-line no-var\n  for (var j = 0; j !== this.parserRegExpList.length; ++j) {\n    const parserRegExp = this.parserRegExpList[j]\n    if (parserRegExp.test(contentType)) {\n      const parser = this.customParsers.get(parserRegExp.toString())\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  return this.customParsers.get('')\n}\n\nContentTypeParser.prototype.removeAll = function () {\n  this.customParsers = new Map()\n  this.parserRegExpList = []\n  this.parserList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.remove = function (contentType) {\n  if (!(typeof contentType === 'string' || contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n\n  this.customParsers.delete(contentType.toString())\n\n  const parsers = typeof contentType === 'string' ? this.parserList : this.parserRegExpList\n\n  const idx = parsers.findIndex(ct => ct.toString() === contentType.toString())\n\n  if (idx > -1) {\n    parsers.splice(idx, 1)\n  }\n}\n\nContentTypeParser.prototype.run = function (contentType, handler, request, reply) {\n  const parser = this.getParser(contentType)\n  const resource = new AsyncResource('content-type-parser:run', request)\n\n  if (parser === undefined) {\n    if (request.is404) {\n      handler(request, reply)\n    } else {\n      reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || undefined))\n    }\n  } else if (parser.asString === true || parser.asBuffer === true) {\n    rawBody(\n      request,\n      reply,\n      reply[kRouteContext]._parserOptions,\n      parser,\n      done\n    )\n  } else {\n    const result = parser.fn(request, request[kRequestPayloadStream], done)\n\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n\n  function done (error, body) {\n    // We cannot use resource.bind() because it is broken in node v12 and v14\n    resource.runInAsyncScope(() => {\n      if (error) {\n        reply[kReplyIsError] = true\n        reply.send(error)\n      } else {\n        request.body = body\n        handler(request, reply)\n      }\n    })\n  }\n}\n\nfunction rawBody (request, reply, options, parser, done) {\n  const asString = parser.asString\n  const limit = options.limit === null ? parser.bodyLimit : options.limit\n  const contentLength = request.headers['content-length'] === undefined\n    ? NaN\n    : Number(request.headers['content-length'])\n\n  if (contentLength > limit) {\n    reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n    return\n  }\n\n  let receivedLength = 0\n  let body = asString === true ? '' : []\n\n  const payload = request[kRequestPayloadStream] || request.raw\n\n  if (asString === true) {\n    payload.setEncoding('utf8')\n  }\n\n  payload.on('data', onData)\n  payload.on('end', onEnd)\n  payload.on('error', onEnd)\n  payload.resume()\n\n  function onData (chunk) {\n    receivedLength += chunk.length\n\n    if ((payload.receivedEncodedLength || receivedLength) > limit) {\n      payload.removeListener('data', onData)\n      payload.removeListener('end', onEnd)\n      payload.removeListener('error', onEnd)\n      reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n      return\n    }\n\n    if (asString === true) {\n      body += chunk\n    } else {\n      body.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    payload.removeListener('data', onData)\n    payload.removeListener('end', onEnd)\n    payload.removeListener('error', onEnd)\n\n    if (err !== undefined) {\n      err.statusCode = 400\n      reply[kReplyIsError] = true\n      reply.code(err.statusCode).send(err)\n      return\n    }\n\n    if (asString === true) {\n      receivedLength = Buffer.byteLength(body)\n    }\n\n    if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {\n      reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH())\n      return\n    }\n\n    if (asString === false) {\n      body = Buffer.concat(body)\n    }\n\n    const result = parser.fn(request, body, done)\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n}\n\nfunction getDefaultJsonParser (onProtoPoisoning, onConstructorPoisoning) {\n  return defaultJsonParser\n\n  function defaultJsonParser (req, body, done) {\n    if (body === '' || body == null) {\n      return done(new FST_ERR_CTP_EMPTY_JSON_BODY(), undefined)\n    }\n    let json\n    try {\n      json = secureJson.parse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning })\n    } catch (err) {\n      err.statusCode = 400\n      return done(err, undefined)\n    }\n    done(null, json)\n  }\n}\n\nfunction defaultPlainTextParser (req, body, done) {\n  done(null, body)\n}\n\nfunction Parser (asString, asBuffer, bodyLimit, fn) {\n  this.asString = asString\n  this.asBuffer = asBuffer\n  this.bodyLimit = bodyLimit\n  this.fn = fn\n}\n\nfunction buildContentTypeParser (c) {\n  const contentTypeParser = new ContentTypeParser()\n  contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse]\n  contentTypeParser.customParsers = new Map(c.customParsers.entries())\n  contentTypeParser.parserList = c.parserList.slice()\n  return contentTypeParser\n}\n\nfunction addContentTypeParser (contentType, opts, parser) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"addContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (typeof opts === 'function') {\n    parser = opts\n    opts = {}\n  }\n\n  if (!opts) opts = {}\n  if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit]\n\n  if (Array.isArray(contentType)) {\n    contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser))\n  } else {\n    this[kContentTypeParser].add(contentType, opts, parser)\n  }\n\n  return this\n}\n\nfunction hasContentTypeParser (contentType) {\n  return this[kContentTypeParser].hasParser(contentType)\n}\n\nfunction removeContentTypeParser (contentType) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (Array.isArray(contentType)) {\n    for (const type of contentType) {\n      this[kContentTypeParser].remove(type)\n    }\n  } else {\n    this[kContentTypeParser].remove(contentType)\n  }\n}\n\nfunction removeAllContentTypeParsers () {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeAllContentTypeParsers\" when fastify instance is already started!')\n  }\n\n  this[kContentTypeParser].removeAll()\n}\n\nmodule.exports = ContentTypeParser\nmodule.exports.helpers = {\n  buildContentTypeParser,\n  addContentTypeParser,\n  hasContentTypeParser,\n  removeContentTypeParser,\n  removeAllContentTypeParsers\n}\nmodule.exports.defaultParsers = {\n  getDefaultJsonParser,\n  defaultTextParser: defaultPlainTextParser\n}\nmodule.exports[kTestInternals] = { rawBody }\n", "'use strict'\n\nconst t = require('tap')\nconst test = t.test\nconst Fastify = require('..')\nconst keys = require('../lib/symbols')\nconst { FST_ERR_CTP_ALREADY_PRESENT, FST_ERR_CTP_INVALID_TYPE, FST_ERR_CTP_INVALID_MEDIA_TYPE } = require('../lib/errors')\n\nconst first = function (req, payload, done) {}\nconst second = function (req, payload, done) {}\nconst third = function (req, payload, done) {}\n\ntest('hasContentTypeParser', t => {\n  test('should know about internal parsers', t => {\n    t.plan(4)\n\n    const fastify = Fastify()\n    fastify.ready(err => {\n      t.error(err)\n      t.ok(fastify.hasContentTypeParser('application/json'))\n      t.ok(fastify.hasContentTypeParser('text/plain'))\n      t.notOk(fastify.hasContentTypeParser('application/jsoff'))\n    })\n  })\n\n  test('should work with string and RegExp', t => {\n    t.plan(7)\n\n    const fastify = Fastify()\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n    fastify.addContentTypeParser('image/gif', first)\n\n    t.ok(fastify.hasContentTypeParser('application/json'))\n    t.ok(fastify.hasContentTypeParser(/^image\\/.*/))\n    t.ok(fastify.hasContentTypeParser(/^application\\/.+\\+xml/))\n    t.ok(fastify.hasContentTypeParser('image/gif'))\n    t.notOk(fastify.hasContentTypeParser(/^image\\/.+\\+xml/))\n    t.notOk(fastify.hasContentTypeParser('image/png'))\n    t.notOk(fastify.hasContentTypeParser('*'))\n  })\n\n  t.end()\n})\n\ntest('getParser', t => {\n  test('should return matching parser', t => {\n    t.plan(3)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, second)\n    fastify.addContentTypeParser('text/html', third)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('application/t+xml').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/png').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, third)\n  })\n\n  test('should return matching parser with caching', t => {\n    t.plan(6)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('text/html', first)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 0)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html ').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 1)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html ').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 1)\n  })\n\n  test('should prefer content type parser with string value', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser('image/gif', second)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/gif').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/png').fn, first)\n  })\n\n  test('should return parser that catches all if no other is set', t => {\n    t.plan(3)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('*', first)\n    fastify.addContentTypeParser(/^text\\/.*/, second)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/gif').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text').fn, first)\n  })\n\n  test('should return undefined if no matching parser exist', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^weirdType\\/.+/, first)\n    fastify.addContentTypeParser('application/javascript', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].getParser('application/xml'))\n    t.notOk(fastify[keys.kContentTypeParser].getParser('weirdType/'))\n  })\n\n  t.end()\n})\n\ntest('existingParser', t => {\n  test('returns always false for \"*\"', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n    fastify.addContentTypeParser('text/html', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].existingParser('*'))\n\n    fastify.addContentTypeParser('*', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].existingParser('*'))\n  })\n\n  test('let you override the default parser once', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('application/json', first)\n    fastify.addContentTypeParser('text/plain', first)\n\n    t.throws(\n      () => fastify.addContentTypeParser('application/json', first),\n      FST_ERR_CTP_ALREADY_PRESENT,\n      \"Content type parser 'application/json' already present\"\n    )\n    t.throws(\n      () => fastify.addContentTypeParser('text/plain', first),\n      FST_ERR_CTP_ALREADY_PRESENT,\n      \"Content type parser 'text/plain' already present\"\n    )\n  })\n\n  const fastify = Fastify()\n  const contentTypeParser = fastify[keys.kContentTypeParser]\n\n  fastify.addContentTypeParser(/^image\\/.*/, first)\n  fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n  fastify.addContentTypeParser('text/html', first)\n\n  t.ok(contentTypeParser.existingParser(/^image\\/.*/))\n  t.ok(contentTypeParser.existingParser('text/html'))\n  t.ok(contentTypeParser.existingParser(/^application\\/.+\\+xml/))\n  t.notOk(contentTypeParser.existingParser('application/json'))\n  t.notOk(contentTypeParser.existingParser('text/plain'))\n  t.notOk(contentTypeParser.existingParser('image/png'))\n  t.notOk(contentTypeParser.existingParser(/^application\\/.+\\+json/))\n\n  t.end()\n})\n\ntest('add', t => {\n  test('should only accept string and RegExp', t => {\n    t.plan(4)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    t.error(contentTypeParser.add('test', {}, first))\n    t.error(contentTypeParser.add(/test/, {}, first))\n    t.throws(\n      () => contentTypeParser.add({}, {}, first),\n      FST_ERR_CTP_INVALID_TYPE,\n      'The content type should be a string or a RegExp'\n    )\n    t.throws(\n      () => contentTypeParser.add(1, {}, first),\n      FST_ERR_CTP_INVALID_TYPE,\n      'The content type should be a string or a RegExp'\n    )\n  })\n\n  test('should set \"*\" as parser that catches all', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.add('*', {}, first)\n    t.equal(contentTypeParser.customParsers.get('').fn, first)\n  })\n\n  t.end()\n})\n\ntest('non-Error thrown from content parser is properly handled', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  const throwable = 'test'\n  const payload = 'error'\n\n  fastify.addContentTypeParser('text/test', (request, payload, done) => {\n    done(throwable)\n  })\n\n  fastify.post('/', (req, reply) => {\n  })\n\n  fastify.setErrorHandler((err, req, res) => {\n    t.equal(err, throwable)\n\n    res.send(payload)\n  })\n\n  fastify.inject({\n    method: 'POST',\n    url: '/',\n    headers: { 'Content-Type': 'text/test' },\n    body: 'some text'\n  }, (err, res) => {\n    t.error(err)\n    t.equal(res.payload, payload)\n  })\n})\n\ntest('Error thrown 415 from content type is null and make post request to server', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  const errMsg = new FST_ERR_CTP_INVALID_MEDIA_TYPE(undefined).message\n\n  fastify.post('/', (req, reply) => {\n  })\n\n  fastify.inject({\n    method: 'POST',\n    url: '/',\n    body: 'some text'\n  }, (err, res) => {\n    t.error(err)\n    t.equal(res.statusCode, 415)\n    t.equal(JSON.parse(res.body).message, errMsg)\n  })\n})\n\ntest('remove', t => {\n  test('should remove default parser', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove('application/json')\n\n    t.notOk(contentTypeParser.customParsers['application/json'])\n    t.notOk(contentTypeParser.parserList.find(parser => parser === 'application/json'))\n  })\n\n  test('should remove RegExp parser', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n    fastify.addContentTypeParser(/^text\\/*/, first)\n\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove(/^text\\/*/)\n\n    t.notOk(contentTypeParser.customParsers[/^text\\/*/])\n    t.notOk(contentTypeParser.parserRegExpList.find(parser => parser.toString() === /^text\\/*/.toString()))\n  })\n\n  test('should throw an error if content type is neither string nor RegExp', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    t.throws(() => fastify[keys.kContentTypeParser].remove(12), FST_ERR_CTP_INVALID_TYPE)\n  })\n\n  test('should not throw error if content type does not exist', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    t.doesNotThrow(() => fastify[keys.kContentTypeParser].remove('image/png'))\n  })\n\n  test('should not remove any content type parser if content type does not exist', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove('image/png')\n\n    t.same(contentTypeParser.customParsers.size, 2)\n  })\n\n  t.end()\n})\n\ntest('remove all should remove all existing parsers and reset cache', t => {\n  t.plan(4)\n\n  const fastify = Fastify()\n  fastify.addContentTypeParser('application/xml', first)\n  fastify.addContentTypeParser(/^image\\/.*/, first)\n\n  const contentTypeParser = fastify[keys.kContentTypeParser]\n\n  contentTypeParser.getParser('application/xml') // fill cache with one entry\n  contentTypeParser.removeAll()\n\n  t.same(contentTypeParser.cache.size, 0)\n  t.same(contentTypeParser.parserList.length, 0)\n  t.same(contentTypeParser.parserRegExpList.length, 0)\n  t.same(Object.keys(contentTypeParser.customParsers).length, 0)\n})\n\ntest('Safeguard against malicious content-type / 1', async t => {\n  const badNames = Object.getOwnPropertyNames({}.__proto__) // eslint-disable-line\n  t.plan(badNames.length)\n\n  const fastify = Fastify()\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  for (const prop of badNames) {\n    const response = await fastify.inject({\n      method: 'POST',\n      path: '/',\n      headers: {\n        'content-type': prop\n      },\n      body: ''\n    })\n\n    t.same(response.statusCode, 415)\n  }\n})\n\ntest('Safeguard against malicious content-type / 2', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  const response = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': '\\\\u0063\\\\u006fnstructor'\n    },\n    body: ''\n  })\n\n  t.same(response.statusCode, 415)\n})\n\ntest('Safeguard against malicious content-type / 3', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  const response = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'constructor; charset=utf-8'\n    },\n    body: ''\n  })\n\n  t.same(response.statusCode, 415)\n})\n"], "filenames": ["lib/contentTypeParser.js", "test/content-parser.test.js"], "buggy_code_start_loc": [32, 199], "buggy_code_end_loc": [293, 331], "fixing_code_start_loc": [32, 199], "fixing_code_end_loc": [294, 398], "type": "CWE-754", "message": "fastify is a fast and low overhead web framework, for Node.js. Affected versions of fastify are subject to a denial of service via malicious use of the Content-Type header. An attacker can send an invalid Content-Type header that can cause the application to crash. This issue has been addressed in commit `fbb07e8d` and will be included in release version 4.8.1. Users are advised to upgrade. Users unable to upgrade may manually filter out http content with malicious Content-Type headers.", "other": {"cve": {"id": "CVE-2022-39288", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-10T21:15:11.300", "lastModified": "2022-10-12T18:15:46.940", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fastify is a fast and low overhead web framework, for Node.js. Affected versions of fastify are subject to a denial of service via malicious use of the Content-Type header. An attacker can send an invalid Content-Type header that can cause the application to crash. This issue has been addressed in commit `fbb07e8d` and will be included in release version 4.8.1. Users are advised to upgrade. Users unable to upgrade may manually filter out http content with malicious Content-Type headers."}, {"lang": "es", "value": "fastify es un framework web r\u00e1pido y de baja sobrecarga, para Node.js. Las versiones afectadas de fastify est\u00e1n sujetas a una denegaci\u00f3n de servicio por medio del uso malicioso del encabezado Content-Type. Un atacante puede enviar un encabezado Content-Type no v\u00e1lida que puede causar el bloqueo de la aplicaci\u00f3n. Este problema ha sido abordado en el commit \"fbb07e8d\" y ser\u00e1 incluido en versi\u00f3n 4.8.1. Es recomendado a usuarios actualizar. Los usuarios que no puedan actualizar pueden filtrar manualmente el contenido http con encabezados Content-Type maliciosos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fastify:fastify:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.8.1", "matchCriteriaId": "807CA7E6-76C5-4960-A3FE-1D3A9340CABB"}]}]}], "references": [{"url": "https://github.com/fastify/fastify/commit/fbb07e8dfad74c69cd4cd2211aedab87194618e3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fastify/fastify/security/advisories/GHSA-455w-c45v-86rg", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://github.com/fastify/fastify/security/policy", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fastify/fastify/commit/fbb07e8dfad74c69cd4cd2211aedab87194618e3"}}