{"buggy_code": ["/*\n * Copyright 2017-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#pragma once\n\nnamespace wangle {\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::read(\n    Context*,\n    AcceptPipelineType conn) {\n  if (conn.type() != typeid(ConnInfo&)) {\n    return;\n  }\n\n  populateAcceptors();\n\n  const auto& connInfo = boost::get<ConnInfo&>(conn);\n  auto socket = std::shared_ptr<folly::AsyncTransportWrapper>(\n      connInfo.sock, folly::DelayedDestruction::Destructor());\n\n  uint64_t connId = nextConnId_++;\n\n  // Create a new routing pipeline for this connection to read from\n  // the socket until it parses the routing data\n  auto routingPipeline = newRoutingPipeline();\n  routingPipeline->addBack(wangle::AsyncSocketHandler(socket));\n  routingPipeline->addBack(routingHandlerFactory_->newHandler(connId, this));\n  routingPipeline->finalize();\n\n  // Initialize TransportInfo and set it on the routing pipeline\n  auto transportInfo = std::make_shared<TransportInfo>(connInfo.tinfo);\n  folly::SocketAddress localAddr, peerAddr;\n  try {\n    socket->getLocalAddress(&localAddr);\n    socket->getPeerAddress(&peerAddr);\n  } catch (...) {\n    VLOG(2) << \"Socket is no longer valid.\";\n    return;\n  }\n  transportInfo->localAddr = std::make_shared<folly::SocketAddress>(localAddr);\n  transportInfo->remoteAddr = std::make_shared<folly::SocketAddress>(peerAddr);\n  routingPipeline->setTransportInfo(transportInfo);\n\n  routingPipeline->transportActive();\n  routingPipelines_[connId] = std::move(routingPipeline);\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::readEOF(Context*) {\n  // Null implementation to terminate the call in this handler\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::readException(\n    Context*,\n    folly::exception_wrapper) {\n  // Null implementation to terminate the call in this handler\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  // Get the routing pipeline corresponding to this connection\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n\n  // Fetch the socket from the pipeline and pause reading from the\n  // socket\n  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n      routingPipeline->getTransport());\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n\n  // Hash based on routing data to pick a new acceptor\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n\n  // Switch to the new acceptor's thread\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n\n        pipeline->transportActive();\n\n        // Pass in the buffered bytes to the pipeline\n        pipeline->read(routingData.bufQueue);\n      });\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::onError(\n    uint64_t connId,\n    folly::exception_wrapper ex) {\n  VLOG(4) << \"Exception while parsing routing data: \" << ex.what();\n\n  // Notify all handlers of the exception\n  auto ctx = getContext();\n  auto pipeline =\n      CHECK_NOTNULL(dynamic_cast<AcceptPipeline*>(ctx->getPipeline()));\n  pipeline->readException(ex);\n\n  // Delete the routing pipeline. This will close and delete the socket as well.\n  routingPipelines_.erase(connId);\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::populateAcceptors() {\n  if (!acceptors_.empty()) {\n    return;\n  }\n  CHECK(server_);\n  server_->forEachWorker(\n      [&](Acceptor* acceptor) { acceptors_.push_back(acceptor); });\n}\n\n} // namespace wangle\n"], "fixing_code": ["/*\n * Copyright 2017-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#pragma once\n\nnamespace wangle {\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::read(\n    Context*,\n    AcceptPipelineType conn) {\n  if (conn.type() != typeid(ConnInfo&)) {\n    return;\n  }\n\n  populateAcceptors();\n\n  const auto& connInfo = boost::get<ConnInfo&>(conn);\n  auto socket = std::shared_ptr<folly::AsyncTransportWrapper>(\n      connInfo.sock, folly::DelayedDestruction::Destructor());\n\n  uint64_t connId = nextConnId_++;\n\n  // Create a new routing pipeline for this connection to read from\n  // the socket until it parses the routing data\n  auto routingPipeline = newRoutingPipeline();\n  routingPipeline->addBack(wangle::AsyncSocketHandler(socket));\n  routingPipeline->addBack(routingHandlerFactory_->newHandler(connId, this));\n  routingPipeline->finalize();\n\n  // Initialize TransportInfo and set it on the routing pipeline\n  auto transportInfo = std::make_shared<TransportInfo>(connInfo.tinfo);\n  folly::SocketAddress localAddr, peerAddr;\n  try {\n    socket->getLocalAddress(&localAddr);\n    socket->getPeerAddress(&peerAddr);\n  } catch (...) {\n    VLOG(2) << \"Socket is no longer valid.\";\n    return;\n  }\n  transportInfo->localAddr = std::make_shared<folly::SocketAddress>(localAddr);\n  transportInfo->remoteAddr = std::make_shared<folly::SocketAddress>(peerAddr);\n  routingPipeline->setTransportInfo(transportInfo);\n\n  routingPipeline->transportActive();\n  routingPipelines_[connId] = std::move(routingPipeline);\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::readEOF(Context*) {\n  // Null implementation to terminate the call in this handler\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::readException(\n    Context*,\n    folly::exception_wrapper) {\n  // Null implementation to terminate the call in this handler\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  // Get the routing pipeline corresponding to this connection\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n\n  // Fetch the socket from the pipeline and pause reading from the\n  // socket\n  auto socket = std::dynamic_pointer_cast<folly::AsyncTransportWrapper>(\n      routingPipeline->getTransport());\n  CHECK(socket);\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n\n  // Hash based on routing data to pick a new acceptor\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n\n  // Switch to the new acceptor's thread\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n\n        pipeline->transportActive();\n\n        // Pass in the buffered bytes to the pipeline\n        pipeline->read(routingData.bufQueue);\n      });\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::onError(\n    uint64_t connId,\n    folly::exception_wrapper ex) {\n  VLOG(4) << \"Exception while parsing routing data: \" << ex.what();\n\n  // Notify all handlers of the exception\n  auto ctx = getContext();\n  auto pipeline =\n      CHECK_NOTNULL(dynamic_cast<AcceptPipeline*>(ctx->getPipeline()));\n  pipeline->readException(ex);\n\n  // Delete the routing pipeline. This will close and delete the socket as well.\n  routingPipelines_.erase(connId);\n}\n\ntemplate <typename Pipeline, typename R>\nvoid AcceptRoutingHandler<Pipeline, R>::populateAcceptors() {\n  if (!acceptors_.empty()) {\n    return;\n  }\n  CHECK(server_);\n  server_->forEachWorker(\n      [&](Acceptor* acceptor) { acceptors_.push_back(acceptor); });\n}\n\n} // namespace wangle\n"], "filenames": ["wangle/bootstrap/AcceptRoutingHandler-inl.h"], "buggy_code_start_loc": [89], "buggy_code_end_loc": [90], "fixing_code_start_loc": [89], "fixing_code_end_loc": [92], "type": "CWE-19", "message": "Wangle's AcceptRoutingHandler incorrectly casts a socket when accepting a TLS 1.3 connection, leading to a potential denial of service attack against systems accepting such connections. This affects versions of Wangle prior to v2019.01.14.00", "other": {"cve": {"id": "CVE-2019-3554", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-01-15T22:29:00.347", "lastModified": "2019-10-09T23:49:14.553", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Wangle's AcceptRoutingHandler incorrectly casts a socket when accepting a TLS 1.3 connection, leading to a potential denial of service attack against systems accepting such connections. This affects versions of Wangle prior to v2019.01.14.00"}, {"lang": "es", "value": "AcceptRoutingHandler, de Wangle, convierte incorrectamente un socket al aceptar una conexi\u00f3n TLS 1.3, lo que conduce a un potencial ataque de denegaci\u00f3n de servicio (DoS) contra los sistemas que aceptan tales conexiones. Esto afecta a las versiones de Wangle anteriores a la v2019.01.14.00."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-19"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:wangle:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.01.14.00", "matchCriteriaId": "E24C1270-C698-4E93-BCD8-79E2698B8246"}]}]}], "references": [{"url": "https://github.com/facebook/wangle/commit/3b17ba10a82c71e7808760e027ac6af687e06074", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/wangle/commit/3b17ba10a82c71e7808760e027ac6af687e06074"}}