{"buggy_code": ["/*\n * Serial Attached SCSI (SAS) Expander discovery and configuration\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\n#include \"sas_internal.h\"\n\n#include <scsi/sas_ata.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"../scsi_sas_internal.h\"\n\nstatic int sas_discover_expander(struct domain_device *dev);\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr);\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int include);\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr);\n\n/* ---------- SMP task management ---------- */\n\nstatic void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tcomplete(&task->slow_task->completion);\n}\n\nstatic void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}\n\n/* Give it some long enough timeout. In seconds. */\n#define SMP_TIMEOUT 10\n\nstatic int smp_execute_task_sg(struct domain_device *dev,\n\t\tstruct scatterlist *req, struct scatterlist *resp)\n{\n\tint res, retry;\n\tstruct sas_task *task = NULL;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(dev->port->ha->core.shost->transportt);\n\n\tmutex_lock(&dev->ex_dev.cmd_mutex);\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tif (test_bit(SAS_DEV_GONE, &dev->state)) {\n\t\t\tres = -ECOMM;\n\t\t\tbreak;\n\t\t}\n\n\t\ttask = sas_alloc_slow_task(GFP_KERNEL);\n\t\tif (!task) {\n\t\t\tres = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\ttask->dev = dev;\n\t\ttask->task_proto = dev->tproto;\n\t\ttask->smp_task.smp_req = *req;\n\t\ttask->smp_task.smp_resp = *resp;\n\n\t\ttask->task_done = smp_task_done;\n\n\t\ttask->slow_task->timer.function = smp_task_timedout;\n\t\ttask->slow_task->timer.expires = jiffies + SMP_TIMEOUT*HZ;\n\t\tadd_timer(&task->slow_task->timer);\n\n\t\tres = i->dft->lldd_execute_task(task, GFP_KERNEL);\n\n\t\tif (res) {\n\t\t\tdel_timer(&task->slow_task->timer);\n\t\t\tSAS_DPRINTK(\"executing SMP task failed:%d\\n\", res);\n\t\t\tbreak;\n\t\t}\n\n\t\twait_for_completion(&task->slow_task->completion);\n\t\tres = -ECOMM;\n\t\tif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\n\t\t\tSAS_DPRINTK(\"smp task timed out or aborted\\n\");\n\t\t\ti->dft->lldd_abort_task(task);\n\t\t\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\t\t\tSAS_DPRINTK(\"SMP task aborted and not done\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAM_STAT_GOOD) {\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_UNDERRUN) {\n\t\t\t/* no error, but return the number of bytes of\n\t\t\t * underrun */\n\t\t\tres = task->task_status.residual;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_OVERRUN) {\n\t\t\tres = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_UNDELIVERED &&\n\t\t    task->task_status.stat == SAS_DEVICE_UNKNOWN)\n\t\t\tbreak;\n\t\telse {\n\t\t\tSAS_DPRINTK(\"%s: task to dev %016llx response: 0x%x \"\n\t\t\t\t    \"status 0x%x\\n\", __func__,\n\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t    task->task_status.resp,\n\t\t\t\t    task->task_status.stat);\n\t\t\tsas_free_task(task);\n\t\t\ttask = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&dev->ex_dev.cmd_mutex);\n\n\tBUG_ON(retry == 3 && task != NULL);\n\tsas_free_task(task);\n\treturn res;\n}\n\nstatic int smp_execute_task(struct domain_device *dev, void *req, int req_size,\n\t\t\t    void *resp, int resp_size)\n{\n\tstruct scatterlist req_sg;\n\tstruct scatterlist resp_sg;\n\n\tsg_init_one(&req_sg, req, req_size);\n\tsg_init_one(&resp_sg, resp, resp_size);\n\treturn smp_execute_task_sg(dev, &req_sg, &resp_sg);\n}\n\n/* ---------- Allocations ---------- */\n\nstatic inline void *alloc_smp_req(int size)\n{\n\tu8 *p = kzalloc(size, GFP_KERNEL);\n\tif (p)\n\t\tp[0] = SMP_REQUEST;\n\treturn p;\n}\n\nstatic inline void *alloc_smp_resp(int size)\n{\n\treturn kzalloc(size, GFP_KERNEL);\n}\n\nstatic char sas_route_char(struct domain_device *dev, struct ex_phy *phy)\n{\n\tswitch (phy->routing_attr) {\n\tcase TABLE_ROUTING:\n\t\tif (dev->ex_dev.t2t_supp)\n\t\t\treturn 'U';\n\t\telse\n\t\t\treturn 'T';\n\tcase DIRECT_ROUTING:\n\t\treturn 'D';\n\tcase SUBTRACTIVE_ROUTING:\n\t\treturn 'S';\n\tdefault:\n\t\treturn '?';\n\t}\n}\n\nstatic enum sas_device_type to_dev_type(struct discover_resp *dr)\n{\n\t/* This is detecting a failure to transmit initial dev to host\n\t * FIS as described in section J.5 of sas-2 r16\n\t */\n\tif (dr->attached_dev_type == SAS_PHY_UNUSED && dr->attached_sata_dev &&\n\t    dr->linkrate >= SAS_LINK_RATE_1_5_GBPS)\n\t\treturn SAS_SATA_PENDING;\n\telse\n\t\treturn dr->attached_dev_type;\n}\n\nstatic void sas_set_ex_phy(struct domain_device *dev, int phy_id, void *rsp)\n{\n\tenum sas_device_type dev_type;\n\tenum sas_linkrate linkrate;\n\tu8 sas_addr[SAS_ADDR_SIZE];\n\tstruct smp_resp *resp = rsp;\n\tstruct discover_resp *dr = &resp->disc;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tstruct sas_rphy *rphy = dev->rphy;\n\tbool new_phy = !phy->phy;\n\tchar *type;\n\n\tif (new_phy) {\n\t\tif (WARN_ON_ONCE(test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)))\n\t\t\treturn;\n\t\tphy->phy = sas_phy_alloc(&rphy->dev, phy_id);\n\n\t\t/* FIXME: error_handling */\n\t\tBUG_ON(!phy->phy);\n\t}\n\n\tswitch (resp->result) {\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tbreak;\n\tdefault:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tbreak;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tphy->phy_state = PHY_EMPTY; /* do not know yet */\n\t\tbreak;\n\t}\n\n\t/* check if anything important changed to squelch debug */\n\tdev_type = phy->attached_dev_type;\n\tlinkrate  = phy->linkrate;\n\tmemcpy(sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\n\t/* Handle vacant phy - rest of dr data is not valid so skip it */\n\tif (phy->phy_state == PHY_VACANT) {\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tphy->attached_dev_type = SAS_PHY_UNUSED;\n\t\tif (!test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\t\tphy->phy_id = phy_id;\n\t\t\tgoto skip;\n\t\t} else\n\t\t\tgoto out;\n\t}\n\n\tphy->attached_dev_type = to_dev_type(dr);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tgoto out;\n\tphy->phy_id = phy_id;\n\tphy->linkrate = dr->linkrate;\n\tphy->attached_sata_host = dr->attached_sata_host;\n\tphy->attached_sata_dev  = dr->attached_sata_dev;\n\tphy->attached_sata_ps   = dr->attached_sata_ps;\n\tphy->attached_iproto = dr->iproto << 1;\n\tphy->attached_tproto = dr->tproto << 1;\n\t/* help some expanders that fail to zero sas_address in the 'no\n\t * device' case\n\t */\n\tif (phy->attached_dev_type == SAS_PHY_UNUSED ||\n\t    phy->linkrate < SAS_LINK_RATE_1_5_GBPS)\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\telse\n\t\tmemcpy(phy->attached_sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE);\n\tphy->attached_phy_id = dr->attached_phy_id;\n\tphy->phy_change_count = dr->change_count;\n\tphy->routing_attr = dr->routing_attr;\n\tphy->virtual = dr->virtual;\n\tphy->last_da_index = -1;\n\n\tphy->phy->identify.sas_address = SAS_ADDR(phy->attached_sas_addr);\n\tphy->phy->identify.device_type = dr->attached_dev_type;\n\tphy->phy->identify.initiator_port_protocols = phy->attached_iproto;\n\tphy->phy->identify.target_port_protocols = phy->attached_tproto;\n\tif (!phy->attached_tproto && dr->attached_sata_dev)\n\t\tphy->phy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\n\tphy->phy->identify.phy_identifier = phy_id;\n\tphy->phy->minimum_linkrate_hw = dr->hmin_linkrate;\n\tphy->phy->maximum_linkrate_hw = dr->hmax_linkrate;\n\tphy->phy->minimum_linkrate = dr->pmin_linkrate;\n\tphy->phy->maximum_linkrate = dr->pmax_linkrate;\n\tphy->phy->negotiated_linkrate = phy->linkrate;\n\n skip:\n\tif (new_phy)\n\t\tif (sas_phy_add(phy->phy)) {\n\t\t\tsas_phy_free(phy->phy);\n\t\t\treturn;\n\t\t}\n\n out:\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_SATA_PENDING:\n\t\ttype = \"stp pending\";\n\t\tbreak;\n\tcase SAS_PHY_UNUSED:\n\t\ttype = \"no device\";\n\t\tbreak;\n\tcase SAS_END_DEVICE:\n\t\tif (phy->attached_iproto) {\n\t\t\tif (phy->attached_tproto)\n\t\t\t\ttype = \"host+target\";\n\t\t\telse\n\t\t\t\ttype = \"host\";\n\t\t} else {\n\t\t\tif (dr->attached_sata_dev)\n\t\t\t\ttype = \"stp\";\n\t\t\telse\n\t\t\t\ttype = \"ssp\";\n\t\t}\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\ttype = \"smp\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t}\n\n\t/* this routine is polled by libata error recovery so filter\n\t * unimportant messages\n\t */\n\tif (new_phy || phy->attached_dev_type != dev_type ||\n\t    phy->linkrate != linkrate ||\n\t    SAS_ADDR(phy->attached_sas_addr) != SAS_ADDR(sas_addr))\n\t\t/* pass */;\n\telse\n\t\treturn;\n\n\t/* if the attached device type changed and ata_eh is active,\n\t * make sure we run revalidation when eh completes (see:\n\t * sas_enable_revalidation)\n\t */\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tset_bit(DISCE_REVALIDATE_DOMAIN, &dev->port->disc.pending);\n\n\tSAS_DPRINTK(\"%sex %016llx phy%02d:%c:%X attached: %016llx (%s)\\n\",\n\t\t    test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state) ? \"ata: \" : \"\",\n\t\t    SAS_ADDR(dev->sas_addr), phy->phy_id,\n\t\t    sas_route_char(dev, phy), phy->linkrate,\n\t\t    SAS_ADDR(phy->attached_sas_addr), type);\n}\n\n/* check if we have an existing attached ata device on this expander phy */\nstruct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *dev;\n\tstruct sas_rphy *rphy;\n\n\tif (!ex_phy->port)\n\t\treturn NULL;\n\n\trphy = ex_phy->port->rphy;\n\tif (!rphy)\n\t\treturn NULL;\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\n\tif (dev && dev_is_sata(dev))\n\t\treturn dev;\n\n\treturn NULL;\n}\n\n#define DISCOVER_REQ_SIZE  16\n#define DISCOVER_RESP_SIZE 56\n\nstatic int sas_ex_phy_discover_helper(struct domain_device *dev, u8 *disc_req,\n\t\t\t\t      u8 *disc_resp, int single)\n{\n\tstruct discover_resp *dr;\n\tint res;\n\n\tdisc_req[9] = single;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\treturn res;\n\tdr = &((struct smp_resp *)disc_resp)->disc;\n\tif (memcmp(dev->sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE) == 0) {\n\t\tsas_printk(\"Found loopback topology, just ignore it!\\n\");\n\t\treturn 0;\n\t}\n\tsas_set_ex_phy(dev, single, disc_resp);\n\treturn 0;\n}\n\nint sas_ex_phy_discover(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint  res = 0;\n\tu8   *disc_req;\n\tu8   *disc_resp;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp) {\n\t\tkfree(disc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tdisc_req[1] = SMP_DISCOVER;\n\n\tif (0 <= single && single < ex->num_phys) {\n\t\tres = sas_ex_phy_discover_helper(dev, disc_req, disc_resp, single);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tres = sas_ex_phy_discover_helper(dev, disc_req,\n\t\t\t\t\t\t\t disc_resp, i);\n\t\t\tif (res)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\nout_err:\n\tkfree(disc_resp);\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_expander_discover(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res = -ENOMEM;\n\n\tex->ex_phy = kzalloc(sizeof(*ex->ex_phy)*ex->num_phys, GFP_KERNEL);\n\tif (!ex->ex_phy)\n\t\treturn -ENOMEM;\n\n\tres = sas_ex_phy_discover(dev, -1);\n\tif (res)\n\t\tgoto out_err;\n\n\treturn 0;\n out_err:\n\tkfree(ex->ex_phy);\n\tex->ex_phy = NULL;\n\treturn res;\n}\n\n#define MAX_EXPANDER_PHYS 128\n\nstatic void ex_assign_report_general(struct domain_device *dev,\n\t\t\t\t\t    struct smp_resp *resp)\n{\n\tstruct report_general_resp *rg = &resp->rg;\n\n\tdev->ex_dev.ex_change_count = be16_to_cpu(rg->change_count);\n\tdev->ex_dev.max_route_indexes = be16_to_cpu(rg->route_indexes);\n\tdev->ex_dev.num_phys = min(rg->num_phys, (u8)MAX_EXPANDER_PHYS);\n\tdev->ex_dev.t2t_supp = rg->t2t_supp;\n\tdev->ex_dev.conf_route_table = rg->conf_route_table;\n\tdev->ex_dev.configuring = rg->configuring;\n\tmemcpy(dev->ex_dev.enclosure_logical_id, rg->enclosure_logical_id, 8);\n}\n\n#define RG_REQ_SIZE   8\n#define RG_RESP_SIZE 32\n\nstatic int sas_ex_general(struct domain_device *dev)\n{\n\tu8 *rg_req;\n\tstruct smp_resp *rg_resp;\n\tint res;\n\tint i;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t\t       RG_RESP_SIZE);\n\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"RG to ex %016llx failed:0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\t\tgoto out;\n\t\t} else if (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\t\tSAS_DPRINTK(\"RG:ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), rg_resp->result);\n\t\t\tres = rg_resp->result;\n\t\t\tgoto out;\n\t\t}\n\n\t\tex_assign_report_general(dev, rg_resp);\n\n\t\tif (dev->ex_dev.configuring) {\n\t\t\tSAS_DPRINTK(\"RG: ex %llx self-configuring...\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr));\n\t\t\tschedule_timeout_interruptible(5*HZ);\n\t\t} else\n\t\t\tbreak;\n\t}\nout:\n\tkfree(rg_req);\n\tkfree(rg_resp);\n\treturn res;\n}\n\nstatic void ex_assign_manuf_info(struct domain_device *dev, void\n\t\t\t\t\t*_mi_resp)\n{\n\tu8 *mi_resp = _mi_resp;\n\tstruct sas_rphy *rphy = dev->rphy;\n\tstruct sas_expander_device *edev = rphy_to_expander_device(rphy);\n\n\tmemcpy(edev->vendor_id, mi_resp + 12, SAS_EXPANDER_VENDOR_ID_LEN);\n\tmemcpy(edev->product_id, mi_resp + 20, SAS_EXPANDER_PRODUCT_ID_LEN);\n\tmemcpy(edev->product_rev, mi_resp + 36,\n\t       SAS_EXPANDER_PRODUCT_REV_LEN);\n\n\tif (mi_resp[8] & 1) {\n\t\tmemcpy(edev->component_vendor_id, mi_resp + 40,\n\t\t       SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\n\t\tedev->component_id = mi_resp[48] << 8 | mi_resp[49];\n\t\tedev->component_revision_id = mi_resp[50];\n\t}\n}\n\n#define MI_REQ_SIZE   8\n#define MI_RESP_SIZE 64\n\nstatic int sas_ex_manuf_info(struct domain_device *dev)\n{\n\tu8 *mi_req;\n\tu8 *mi_resp;\n\tint res;\n\n\tmi_req = alloc_smp_req(MI_REQ_SIZE);\n\tif (!mi_req)\n\t\treturn -ENOMEM;\n\n\tmi_resp = alloc_smp_resp(MI_RESP_SIZE);\n\tif (!mi_resp) {\n\t\tkfree(mi_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tmi_req[1] = SMP_REPORT_MANUF_INFO;\n\n\tres = smp_execute_task(dev, mi_req, MI_REQ_SIZE, mi_resp,MI_RESP_SIZE);\n\tif (res) {\n\t\tSAS_DPRINTK(\"MI: ex %016llx failed:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out;\n\t} else if (mi_resp[2] != SMP_RESP_FUNC_ACC) {\n\t\tSAS_DPRINTK(\"MI ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), mi_resp[2]);\n\t\tgoto out;\n\t}\n\n\tex_assign_manuf_info(dev, mi_resp);\nout:\n\tkfree(mi_req);\n\tkfree(mi_resp);\n\treturn res;\n}\n\n#define PC_REQ_SIZE  44\n#define PC_RESP_SIZE 8\n\nint sas_smp_phy_control(struct domain_device *dev, int phy_id,\n\t\t\tenum phy_func phy_func,\n\t\t\tstruct sas_phy_linkrates *rates)\n{\n\tu8 *pc_req;\n\tu8 *pc_resp;\n\tint res;\n\n\tpc_req = alloc_smp_req(PC_REQ_SIZE);\n\tif (!pc_req)\n\t\treturn -ENOMEM;\n\n\tpc_resp = alloc_smp_resp(PC_RESP_SIZE);\n\tif (!pc_resp) {\n\t\tkfree(pc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tpc_req[1] = SMP_PHY_CONTROL;\n\tpc_req[9] = phy_id;\n\tpc_req[10]= phy_func;\n\tif (rates) {\n\t\tpc_req[32] = rates->minimum_linkrate << 4;\n\t\tpc_req[33] = rates->maximum_linkrate << 4;\n\t}\n\n\tres = smp_execute_task(dev, pc_req, PC_REQ_SIZE, pc_resp,PC_RESP_SIZE);\n\n\tkfree(pc_resp);\n\tkfree(pc_req);\n\treturn res;\n}\n\nstatic void sas_ex_disable_phy(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\n\tsas_smp_phy_control(dev, phy_id, PHY_FUNC_DISABLE, NULL);\n\tphy->linkrate = SAS_PHY_DISABLED;\n}\n\nstatic void sas_ex_disable_port(struct domain_device *dev, u8 *sas_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) == SAS_ADDR(sas_addr))\n\t\t\tsas_ex_disable_phy(dev, i);\n\t}\n}\n\nstatic int sas_dev_present_in_domain(struct asd_sas_port *port,\n\t\t\t\t\t    u8 *sas_addr)\n{\n\tstruct domain_device *dev;\n\n\tif (SAS_ADDR(port->sas_addr) == SAS_ADDR(sas_addr))\n\t\treturn 1;\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (SAS_ADDR(dev->sas_addr) == SAS_ADDR(sas_addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define RPEL_REQ_SIZE\t16\n#define RPEL_RESP_SIZE\t32\nint sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (!res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(resp);\n\treturn res;\n\n}\n\n#ifdef CONFIG_SCSI_SAS_ATA\n\n#define RPS_REQ_SIZE  16\n#define RPS_RESP_SIZE 60\n\nint sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_resp *rps_resp)\n{\n\tint res;\n\tu8 *rps_req = alloc_smp_req(RPS_REQ_SIZE);\n\tu8 *resp = (u8 *)rps_resp;\n\n\tif (!rps_req)\n\t\treturn -ENOMEM;\n\n\trps_req[1] = SMP_REPORT_PHY_SATA;\n\trps_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, rps_req, RPS_REQ_SIZE,\n\t\t\t            rps_resp, RPS_RESP_SIZE);\n\n\t/* 0x34 is the FIS type for the D2H fis.  There's a potential\n\t * standards cockup here.  sas-2 explicitly specifies the FIS\n\t * should be encoded so that FIS type is in resp[24].\n\t * However, some expanders endian reverse this.  Undo the\n\t * reversal here */\n\tif (!res && resp[27] == 0x34 && resp[24] != 0x34) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tint j = 24 + (i*4);\n\t\t\tu8 a, b;\n\t\t\ta = resp[j + 0];\n\t\t\tb = resp[j + 1];\n\t\t\tresp[j + 0] = resp[j + 3];\n\t\t\tresp[j + 1] = resp[j + 2];\n\t\t\tresp[j + 2] = b;\n\t\t\tresp[j + 3] = a;\n\t\t}\n\t}\n\n\tkfree(rps_req);\n\treturn res;\n}\n#endif\n\nstatic void sas_ex_get_linkrate(struct domain_device *parent,\n\t\t\t\t       struct domain_device *child,\n\t\t\t\t       struct ex_phy *parent_phy)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct sas_port *port;\n\tint i;\n\n\tchild->pathways = 0;\n\n\tport = parent_phy->port;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &parent_ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t    SAS_ADDR(child->sas_addr)) {\n\n\t\t\tchild->min_linkrate = min(parent->min_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->max_linkrate = max(parent->max_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->pathways++;\n\t\t\tsas_port_add_phy(port, phy->phy);\n\t\t}\n\t}\n\tchild->linkrate = min(parent_phy->linkrate, child->max_linkrate);\n\tchild->pathways = min(child->pathways, parent->pathways);\n}\n\nstatic struct domain_device *sas_ex_discover_end_dev(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct ex_phy *phy = &parent_ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tint res;\n\n\tif (phy->attached_sata_host || phy->attached_sata_ps)\n\t\treturn NULL;\n\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port   = parent->port;\n\tchild->iproto = phy->attached_iproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tif (!phy->port) {\n\t\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t\tif (unlikely(!phy->port))\n\t\t\tgoto out_err;\n\t\tif (unlikely(sas_port_add(phy->port) != 0)) {\n\t\t\tsas_port_free(phy->port);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tsas_ex_get_linkrate(parent, child, phy);\n\tsas_device_set_phy(child, phy->port);\n\n#ifdef CONFIG_SCSI_SAS_ATA\n\tif ((phy->attached_tproto & SAS_PROTOCOL_STP) || phy->attached_sata_dev) {\n\t\tres = sas_get_ata_info(child, phy);\n\t\tif (res)\n\t\t\tgoto out_free;\n\n\t\tsas_init_dev(child);\n\t\tres = sas_ata_init(child);\n\t\tif (res)\n\t\t\tgoto out_free;\n\t\trphy = sas_end_device_alloc(phy->port);\n\t\tif (!rphy)\n\t\t\tgoto out_free;\n\n\t\tchild->rphy = rphy;\n\t\tget_device(&rphy->dev);\n\n\t\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\t\tres = sas_discover_sata(child);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"sas_discover_sata() for device %16llx at \"\n\t\t\t\t    \"%016llx:0x%x returned 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t    SAS_ADDR(parent->sas_addr), phy_id, res);\n\t\t\tgoto out_list_del;\n\t\t}\n\t} else\n#endif\n\t  if (phy->attached_tproto & SAS_PROTOCOL_SSP) {\n\t\tchild->dev_type = SAS_END_DEVICE;\n\t\trphy = sas_end_device_alloc(phy->port);\n\t\t/* FIXME: error handling */\n\t\tif (unlikely(!rphy))\n\t\t\tgoto out_free;\n\t\tchild->tproto = phy->attached_tproto;\n\t\tsas_init_dev(child);\n\n\t\tchild->rphy = rphy;\n\t\tget_device(&rphy->dev);\n\t\tsas_fill_in_rphy(child, rphy);\n\n\t\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\t\tres = sas_discover_end_dev(child);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"sas_discover_end_dev() for device %16llx \"\n\t\t\t\t    \"at %016llx:0x%x returned 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t    SAS_ADDR(parent->sas_addr), phy_id, res);\n\t\t\tgoto out_list_del;\n\t\t}\n\t} else {\n\t\tSAS_DPRINTK(\"target proto 0x%x at %016llx:0x%x not handled\\n\",\n\t\t\t    phy->attached_tproto, SAS_ADDR(parent->sas_addr),\n\t\t\t    phy_id);\n\t\tgoto out_free;\n\t}\n\n\tlist_add_tail(&child->siblings, &parent_ex->children);\n\treturn child;\n\n out_list_del:\n\tsas_rphy_free(child->rphy);\n\tlist_del(&child->disco_list_node);\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_del(&child->dev_list_node);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n out_free:\n\tsas_port_delete(phy->port);\n out_err:\n\tphy->port = NULL;\n\tsas_put_device(child);\n\treturn NULL;\n}\n\n/* See if this phy is part of a wide port */\nstatic bool sas_ex_join_wide_port(struct domain_device *parent, int phy_id)\n{\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tint i;\n\n\tfor (i = 0; i < parent->ex_dev.num_phys; i++) {\n\t\tstruct ex_phy *ephy = &parent->ex_dev.ex_phy[i];\n\n\t\tif (ephy == phy)\n\t\t\tcontinue;\n\n\t\tif (!memcmp(phy->attached_sas_addr, ephy->attached_sas_addr,\n\t\t\t    SAS_ADDR_SIZE) && ephy->port) {\n\t\t\tsas_port_add_phy(ephy->port, phy->phy);\n\t\t\tphy->port = ephy->port;\n\t\t\tphy->phy_state = PHY_DEVICE_DISCOVERED;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic struct domain_device *sas_ex_discover_expander(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct sas_expander_device *parent_ex = rphy_to_expander_device(parent->rphy);\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tstruct sas_expander_device *edev;\n\tstruct asd_sas_port *port;\n\tint res;\n\n\tif (phy->routing_attr == DIRECT_ROUTING) {\n\t\tSAS_DPRINTK(\"ex %016llx:0x%x:D <--> ex %016llx:0x%x is not \"\n\t\t\t    \"allowed\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr), phy_id,\n\t\t\t    SAS_ADDR(phy->attached_sas_addr),\n\t\t\t    phy->attached_phy_id);\n\t\treturn NULL;\n\t}\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t/* FIXME: better error handling */\n\tBUG_ON(sas_port_add(phy->port) != 0);\n\n\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\trphy = NULL;\t/* shut gcc up */\n\t\tBUG();\n\t}\n\tport = parent->port;\n\tchild->rphy = rphy;\n\tget_device(&rphy->dev);\n\tedev = rphy_to_expander_device(rphy);\n\tchild->dev_type = phy->attached_dev_type;\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port = port;\n\tchild->iproto = phy->attached_iproto;\n\tchild->tproto = phy->attached_tproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tsas_ex_get_linkrate(parent, child, phy);\n\tedev->level = parent_ex->level + 1;\n\tparent->port->disc.max_level = max(parent->port->disc.max_level,\n\t\t\t\t\t   edev->level);\n\tsas_init_dev(child);\n\tsas_fill_in_rphy(child, rphy);\n\tsas_rphy_add(rphy);\n\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_add_tail(&child->dev_list_node, &parent->port->dev_list);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n\n\tres = sas_discover_expander(child);\n\tif (res) {\n\t\tsas_rphy_delete(rphy);\n\t\tspin_lock_irq(&parent->port->dev_list_lock);\n\t\tlist_del(&child->dev_list_node);\n\t\tspin_unlock_irq(&parent->port->dev_list_lock);\n\t\tsas_put_device(child);\n\t\treturn NULL;\n\t}\n\tlist_add_tail(&child->siblings, &parent->ex_dev.children);\n\treturn child;\n}\n\nstatic int sas_ex_discover_dev(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *ex_phy = &ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tint res = 0;\n\n\t/* Phy state */\n\tif (ex_phy->linkrate == SAS_SATA_SPINUP_HOLD) {\n\t\tif (!sas_smp_phy_control(dev, phy_id, PHY_FUNC_LINK_RESET, NULL))\n\t\t\tres = sas_ex_phy_discover(dev, phy_id);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\t/* Parent and domain coherency */\n\tif (!dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\n\t\t\t     SAS_ADDR(dev->port->sas_addr))) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\treturn 0;\n\t}\n\tif (dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\n\t\t\t    SAS_ADDR(dev->parent->sas_addr))) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\tif (ex_phy->routing_attr == TABLE_ROUTING)\n\t\t\tsas_configure_phy(dev, phy_id, dev->port->sas_addr, 1);\n\t\treturn 0;\n\t}\n\n\tif (sas_dev_present_in_domain(dev->port, ex_phy->attached_sas_addr))\n\t\tsas_ex_disable_port(dev, ex_phy->attached_sas_addr);\n\n\tif (ex_phy->attached_dev_type == SAS_PHY_UNUSED) {\n\t\tif (ex_phy->routing_attr == DIRECT_ROUTING) {\n\t\t\tmemset(ex_phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\t\tsas_configure_routing(dev, ex_phy->attached_sas_addr);\n\t\t}\n\t\treturn 0;\n\t} else if (ex_phy->linkrate == SAS_LINK_RATE_UNKNOWN)\n\t\treturn 0;\n\n\tif (ex_phy->attached_dev_type != SAS_END_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_FANOUT_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_SATA_PENDING) {\n\t\tSAS_DPRINTK(\"unknown device type(0x%x) attached to ex %016llx \"\n\t\t\t    \"phy 0x%x\\n\", ex_phy->attached_dev_type,\n\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t    phy_id);\n\t\treturn 0;\n\t}\n\n\tres = sas_configure_routing(dev, ex_phy->attached_sas_addr);\n\tif (res) {\n\t\tSAS_DPRINTK(\"configure routing for dev %016llx \"\n\t\t\t    \"reported 0x%x. Forgotten\\n\",\n\t\t\t    SAS_ADDR(ex_phy->attached_sas_addr), res);\n\t\tsas_disable_routing(dev, ex_phy->attached_sas_addr);\n\t\treturn res;\n\t}\n\n\tif (sas_ex_join_wide_port(dev, phy_id)) {\n\t\tSAS_DPRINTK(\"Attaching ex phy%d to wide port %016llx\\n\",\n\t\t\t    phy_id, SAS_ADDR(ex_phy->attached_sas_addr));\n\t\treturn res;\n\t}\n\n\tswitch (ex_phy->attached_dev_type) {\n\tcase SAS_END_DEVICE:\n\tcase SAS_SATA_PENDING:\n\t\tchild = sas_ex_discover_end_dev(dev, phy_id);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tif (SAS_ADDR(dev->port->disc.fanout_sas_addr)) {\n\t\t\tSAS_DPRINTK(\"second fanout expander %016llx phy 0x%x \"\n\t\t\t\t    \"attached to ex %016llx phy 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(ex_phy->attached_sas_addr),\n\t\t\t\t    ex_phy->attached_phy_id,\n\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t    phy_id);\n\t\t\tsas_ex_disable_phy(dev, phy_id);\n\t\t\tbreak;\n\t\t} else\n\t\t\tmemcpy(dev->port->disc.fanout_sas_addr,\n\t\t\t       ex_phy->attached_sas_addr, SAS_ADDR_SIZE);\n\t\t/* fallthrough */\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\tchild = sas_ex_discover_expander(dev, phy_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (child) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tif (ex->ex_phy[i].phy_state == PHY_VACANT ||\n\t\t\t    ex->ex_phy[i].phy_state == PHY_NOT_PRESENT)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Due to races, the phy might not get added to the\n\t\t\t * wide port, so we add the phy to the wide port here.\n\t\t\t */\n\t\t\tif (SAS_ADDR(ex->ex_phy[i].attached_sas_addr) ==\n\t\t\t    SAS_ADDR(child->sas_addr)) {\n\t\t\t\tex->ex_phy[i].phy_state= PHY_DEVICE_DISCOVERED;\n\t\t\t\tif (sas_ex_join_wide_port(dev, i))\n\t\t\t\t\tSAS_DPRINTK(\"Attaching ex phy%d to wide port %016llx\\n\",\n\t\t\t\t\t\t    i, SAS_ADDR(ex->ex_phy[i].attached_sas_addr));\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int sas_find_sub_addr(struct domain_device *dev, u8 *sub_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif ((phy->attached_dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t     phy->attached_dev_type == SAS_FANOUT_EXPANDER_DEVICE) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tmemcpy(sub_addr, phy->attached_sas_addr,SAS_ADDR_SIZE);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_check_level_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child;\n\tu8 sub_addr[8] = {0, };\n\n\tlist_for_each_entry(child, &ex->children, siblings) {\n\t\tif (child->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t\t    child->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tcontinue;\n\t\tif (sub_addr[0] == 0) {\n\t\t\tsas_find_sub_addr(child, sub_addr);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tu8 s2[8];\n\n\t\t\tif (sas_find_sub_addr(child, s2) &&\n\t\t\t    (SAS_ADDR(sub_addr) != SAS_ADDR(s2))) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx->%016llx-?->%016llx \"\n\t\t\t\t\t    \"diverges from subtractive \"\n\t\t\t\t\t    \"boundary %016llx\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t\t    SAS_ADDR(s2),\n\t\t\t\t\t    SAS_ADDR(sub_addr));\n\n\t\t\t\tsas_ex_disable_port(child, s2);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/**\n * sas_ex_discover_devices -- discover devices attached to this expander\n * dev: pointer to the expander domain device\n * single: if you want to do a single phy, else set to -1;\n *\n * Configure this expander for use with its devices and register the\n * devices of this expander.\n */\nstatic int sas_ex_discover_devices(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i = 0, end = ex->num_phys;\n\tint res = 0;\n\n\tif (0 <= single && single < end) {\n\t\ti = single;\n\t\tend = i+1;\n\t}\n\n\tfor ( ; i < end; i++) {\n\t\tstruct ex_phy *ex_phy = &ex->ex_phy[i];\n\n\t\tif (ex_phy->phy_state == PHY_VACANT ||\n\t\t    ex_phy->phy_state == PHY_NOT_PRESENT ||\n\t\t    ex_phy->phy_state == PHY_DEVICE_DISCOVERED)\n\t\t\tcontinue;\n\n\t\tswitch (ex_phy->linkrate) {\n\t\tcase SAS_PHY_DISABLED:\n\t\tcase SAS_PHY_RESET_PROBLEM:\n\t\tcase SAS_SATA_PORT_SELECTOR:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tres = sas_ex_discover_dev(dev, i);\n\t\t\tif (res)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!res)\n\t\tsas_check_level_subtractive_boundary(dev);\n\n\treturn res;\n}\n\nstatic int sas_check_ex_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\tu8  *sub_sas_addr = NULL;\n\n\tif (dev->dev_type != SAS_EDGE_EXPANDER_DEVICE)\n\t\treturn 0;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif ((phy->attached_dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     phy->attached_dev_type == SAS_EDGE_EXPANDER_DEVICE) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tif (!sub_sas_addr)\n\t\t\t\tsub_sas_addr = &phy->attached_sas_addr[0];\n\t\t\telse if (SAS_ADDR(sub_sas_addr) !=\n\t\t\t\t SAS_ADDR(phy->attached_sas_addr)) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x \"\n\t\t\t\t\t    \"diverges(%016llx) on subtractive \"\n\t\t\t\t\t    \"boundary(%016llx). Disabled\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr), i,\n\t\t\t\t\t    SAS_ADDR(phy->attached_sas_addr),\n\t\t\t\t\t    SAS_ADDR(sub_sas_addr));\n\t\t\t\tsas_ex_disable_phy(dev, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sas_print_parent_topology_bug(struct domain_device *child,\n\t\t\t\t\t\t struct ex_phy *parent_phy,\n\t\t\t\t\t\t struct ex_phy *child_phy)\n{\n\tstatic const char *ex_type[] = {\n\t\t[SAS_EDGE_EXPANDER_DEVICE] = \"edge\",\n\t\t[SAS_FANOUT_EXPANDER_DEVICE] = \"fanout\",\n\t};\n\tstruct domain_device *parent = child->parent;\n\n\tsas_printk(\"%s ex %016llx phy 0x%x <--> %s ex %016llx \"\n\t\t   \"phy 0x%x has %c:%c routing link!\\n\",\n\n\t\t   ex_type[parent->dev_type],\n\t\t   SAS_ADDR(parent->sas_addr),\n\t\t   parent_phy->phy_id,\n\n\t\t   ex_type[child->dev_type],\n\t\t   SAS_ADDR(child->sas_addr),\n\t\t   child_phy->phy_id,\n\n\t\t   sas_route_char(parent, parent_phy),\n\t\t   sas_route_char(child, child_phy));\n}\n\nstatic int sas_check_eeds(struct domain_device *child,\n\t\t\t\t struct ex_phy *parent_phy,\n\t\t\t\t struct ex_phy *child_phy)\n{\n\tint res = 0;\n\tstruct domain_device *parent = child->parent;\n\n\tif (SAS_ADDR(parent->port->disc.fanout_sas_addr) != 0) {\n\t\tres = -ENODEV;\n\t\tSAS_DPRINTK(\"edge ex %016llx phy S:0x%x <--> edge ex %016llx \"\n\t\t\t    \"phy S:0x%x, while there is a fanout ex %016llx\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr),\n\t\t\t    parent_phy->phy_id,\n\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t    child_phy->phy_id,\n\t\t\t    SAS_ADDR(parent->port->disc.fanout_sas_addr));\n\t} else if (SAS_ADDR(parent->port->disc.eeds_a) == 0) {\n\t\tmemcpy(parent->port->disc.eeds_a, parent->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tmemcpy(parent->port->disc.eeds_b, child->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t} else if (((SAS_ADDR(parent->port->disc.eeds_a) ==\n\t\t    SAS_ADDR(parent->sas_addr)) ||\n\t\t   (SAS_ADDR(parent->port->disc.eeds_a) ==\n\t\t    SAS_ADDR(child->sas_addr)))\n\t\t   &&\n\t\t   ((SAS_ADDR(parent->port->disc.eeds_b) ==\n\t\t     SAS_ADDR(parent->sas_addr)) ||\n\t\t    (SAS_ADDR(parent->port->disc.eeds_b) ==\n\t\t     SAS_ADDR(child->sas_addr))))\n\t\t;\n\telse {\n\t\tres = -ENODEV;\n\t\tSAS_DPRINTK(\"edge ex %016llx phy 0x%x <--> edge ex %016llx \"\n\t\t\t    \"phy 0x%x link forms a third EEDS!\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr),\n\t\t\t    parent_phy->phy_id,\n\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t    child_phy->phy_id);\n\t}\n\n\treturn res;\n}\n\n/* Here we spill over 80 columns.  It is intentional.\n */\nstatic int sas_check_parent_topology(struct domain_device *child)\n{\n\tstruct expander_device *child_ex = &child->ex_dev;\n\tstruct expander_device *parent_ex;\n\tint i;\n\tint res = 0;\n\n\tif (!child->parent)\n\t\treturn 0;\n\n\tif (child->parent->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t    child->parent->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\treturn 0;\n\n\tparent_ex = &child->parent->ex_dev;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *parent_phy = &parent_ex->ex_phy[i];\n\t\tstruct ex_phy *child_phy;\n\n\t\tif (parent_phy->phy_state == PHY_VACANT ||\n\t\t    parent_phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(parent_phy->attached_sas_addr) != SAS_ADDR(child->sas_addr))\n\t\t\tcontinue;\n\n\t\tchild_phy = &child_ex->ex_phy[parent_phy->attached_phy_id];\n\n\t\tswitch (child->parent->dev_type) {\n\t\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\t\tif (child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\t\tif (parent_phy->routing_attr != SUBTRACTIVE_ROUTING ||\n\t\t\t\t    child_phy->routing_attr != TABLE_ROUTING) {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (parent_phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\t\t\t\tif (child_phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\t\t\t\t\tres = sas_check_eeds(child, parent_phy, child_phy);\n\t\t\t\t} else if (child_phy->routing_attr != TABLE_ROUTING) {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (parent_phy->routing_attr == TABLE_ROUTING) {\n\t\t\t\tif (child_phy->routing_attr == SUBTRACTIVE_ROUTING ||\n\t\t\t\t    (child_phy->routing_attr == TABLE_ROUTING &&\n\t\t\t\t     child_ex->t2t_supp && parent_ex->t2t_supp)) {\n\t\t\t\t\t/* All good */;\n\t\t\t\t} else {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\t\tif (parent_phy->routing_attr != TABLE_ROUTING ||\n\t\t\t    child_phy->routing_attr != SUBTRACTIVE_ROUTING) {\n\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\tres = -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n#define RRI_REQ_SIZE  16\n#define RRI_RESP_SIZE 44\n\nstatic int sas_configure_present(struct domain_device *dev, int phy_id,\n\t\t\t\t u8 *sas_addr, int *index, int *present)\n{\n\tint i, res = 0;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tu8 *rri_req;\n\tu8 *rri_resp;\n\n\t*present = 0;\n\t*index = 0;\n\n\trri_req = alloc_smp_req(RRI_REQ_SIZE);\n\tif (!rri_req)\n\t\treturn -ENOMEM;\n\n\trri_resp = alloc_smp_resp(RRI_RESP_SIZE);\n\tif (!rri_resp) {\n\t\tkfree(rri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trri_req[1] = SMP_REPORT_ROUTE_INFO;\n\trri_req[9] = phy_id;\n\n\tfor (i = 0; i < ex->max_route_indexes ; i++) {\n\t\t*(__be16 *)(rri_req+6) = cpu_to_be16(i);\n\t\tres = smp_execute_task(dev, rri_req, RRI_REQ_SIZE, rri_resp,\n\t\t\t\t       RRI_RESP_SIZE);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tres = rri_resp[2];\n\t\tif (res == SMP_RESP_NO_INDEX) {\n\t\t\tSAS_DPRINTK(\"overflow of indexes: dev %016llx \"\n\t\t\t\t    \"phy 0x%x index 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i);\n\t\t\tgoto out;\n\t\t} else if (res != SMP_RESP_FUNC_ACC) {\n\t\t\tSAS_DPRINTK(\"%s: dev %016llx phy 0x%x index 0x%x \"\n\t\t\t\t    \"result 0x%x\\n\", __func__,\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i, res);\n\t\t\tgoto out;\n\t\t}\n\t\tif (SAS_ADDR(sas_addr) != 0) {\n\t\t\tif (SAS_ADDR(rri_resp+16) == SAS_ADDR(sas_addr)) {\n\t\t\t\t*index = i;\n\t\t\t\tif ((rri_resp[12] & 0x80) == 0x80)\n\t\t\t\t\t*present = 0;\n\t\t\t\telse\n\t\t\t\t\t*present = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (SAS_ADDR(rri_resp+16) == 0) {\n\t\t\t\t*index = i;\n\t\t\t\t*present = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (SAS_ADDR(rri_resp+16) == 0 &&\n\t\t\t   phy->last_da_index < i) {\n\t\t\tphy->last_da_index = i;\n\t\t\t*index = i;\n\t\t\t*present = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tres = -1;\nout:\n\tkfree(rri_req);\n\tkfree(rri_resp);\n\treturn res;\n}\n\n#define CRI_REQ_SIZE  44\n#define CRI_RESP_SIZE  8\n\nstatic int sas_configure_set(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int index, int include)\n{\n\tint res;\n\tu8 *cri_req;\n\tu8 *cri_resp;\n\n\tcri_req = alloc_smp_req(CRI_REQ_SIZE);\n\tif (!cri_req)\n\t\treturn -ENOMEM;\n\n\tcri_resp = alloc_smp_resp(CRI_RESP_SIZE);\n\tif (!cri_resp) {\n\t\tkfree(cri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tcri_req[1] = SMP_CONF_ROUTE_INFO;\n\t*(__be16 *)(cri_req+6) = cpu_to_be16(index);\n\tcri_req[9] = phy_id;\n\tif (SAS_ADDR(sas_addr) == 0 || !include)\n\t\tcri_req[12] |= 0x80;\n\tmemcpy(cri_req+16, sas_addr, SAS_ADDR_SIZE);\n\n\tres = smp_execute_task(dev, cri_req, CRI_REQ_SIZE, cri_resp,\n\t\t\t       CRI_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tres = cri_resp[2];\n\tif (res == SMP_RESP_NO_INDEX) {\n\t\tSAS_DPRINTK(\"overflow of indexes: dev %016llx phy 0x%x \"\n\t\t\t    \"index 0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, index);\n\t}\nout:\n\tkfree(cri_req);\n\tkfree(cri_resp);\n\treturn res;\n}\n\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t\t    u8 *sas_addr, int include)\n{\n\tint index;\n\tint present;\n\tint res;\n\n\tres = sas_configure_present(dev, phy_id, sas_addr, &index, &present);\n\tif (res)\n\t\treturn res;\n\tif (include ^ present)\n\t\treturn sas_configure_set(dev, phy_id, sas_addr, index,include);\n\n\treturn res;\n}\n\n/**\n * sas_configure_parent -- configure routing table of parent\n * parent: parent expander\n * child: child expander\n * sas_addr: SAS port identifier of device directly attached to child\n */\nstatic int sas_configure_parent(struct domain_device *parent,\n\t\t\t\tstruct domain_device *child,\n\t\t\t\tu8 *sas_addr, int include)\n{\n\tstruct expander_device *ex_parent = &parent->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tif (parent->parent) {\n\t\tres = sas_configure_parent(parent->parent, parent, sas_addr,\n\t\t\t\t\t   include);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (ex_parent->conf_route_table == 0) {\n\t\tSAS_DPRINTK(\"ex %016llx has self-configuring routing table\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr));\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ex_parent->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex_parent->ex_phy[i];\n\n\t\tif ((phy->routing_attr == TABLE_ROUTING) &&\n\t\t    (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t     SAS_ADDR(child->sas_addr))) {\n\t\t\tres = sas_configure_phy(parent, i, sas_addr, include);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/**\n * sas_configure_routing -- configure routing\n * dev: expander device\n * sas_addr: port identifier of device directly attached to the expander device\n */\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 1);\n\treturn 0;\n}\n\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 0);\n\treturn 0;\n}\n\n/**\n * sas_discover_expander -- expander discovery\n * @ex: pointer to expander domain device\n *\n * See comment in sas_discover_sata().\n */\nstatic int sas_discover_expander(struct domain_device *dev)\n{\n\tint res;\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\tres = sas_ex_general(dev);\n\tif (res)\n\t\tgoto out_err;\n\tres = sas_ex_manuf_info(dev);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = sas_expander_discover(dev);\n\tif (res) {\n\t\tSAS_DPRINTK(\"expander %016llx discovery failed(0x%x)\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out_err;\n\t}\n\n\tsas_check_ex_subtractive_boundary(dev);\n\tres = sas_check_parent_topology(dev);\n\tif (res)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\tsas_notify_lldd_dev_gone(dev);\n\treturn res;\n}\n\nstatic int sas_ex_level_discovery(struct asd_sas_port *port, const int level)\n{\n\tint res = 0;\n\tstruct domain_device *dev;\n\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(dev->rphy);\n\n\t\t\tif (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(dev, -1);\n\t\t\telse if (level > 0)\n\t\t\t\tres = sas_ex_discover_devices(port->port_dev, -1);\n\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int sas_ex_bfs_disc(struct asd_sas_port *port)\n{\n\tint res;\n\tint level;\n\n\tdo {\n\t\tlevel = port->disc.max_level;\n\t\tres = sas_ex_level_discovery(port, level);\n\t\tmb();\n\t} while (level < port->disc.max_level);\n\n\treturn res;\n}\n\nint sas_discover_root_expander(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\n\tres = sas_rphy_add(dev->rphy);\n\tif (res)\n\t\tgoto out_err;\n\n\tex->level = dev->port->disc.max_level; /* 0 */\n\tres = sas_discover_expander(dev);\n\tif (res)\n\t\tgoto out_err2;\n\n\tsas_ex_bfs_disc(dev->port);\n\n\treturn res;\n\nout_err2:\n\tsas_rphy_remove(dev->rphy);\nout_err:\n\treturn res;\n}\n\n/* ---------- Domain revalidation ---------- */\n\nstatic int sas_get_phy_discover(struct domain_device *dev,\n\t\t\t\tint phy_id, struct smp_resp *disc_resp)\n{\n\tint res;\n\tu8 *disc_req;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_req[1] = SMP_DISCOVER;\n\tdisc_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\telse if (disc_resp->result != SMP_RESP_FUNC_ACC) {\n\t\tres = disc_resp->result;\n\t\tgoto out;\n\t}\nout:\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_get_phy_change_count(struct domain_device *dev,\n\t\t\t\t    int phy_id, int *pcc)\n{\n\tint res;\n\tstruct smp_resp *disc_resp;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (!res)\n\t\t*pcc = disc_resp->disc.change_count;\n\n\tkfree(disc_resp);\n\treturn res;\n}\n\nstatic int sas_get_phy_attached_dev(struct domain_device *dev, int phy_id,\n\t\t\t\t    u8 *sas_addr, enum sas_device_type *type)\n{\n\tint res;\n\tstruct smp_resp *disc_resp;\n\tstruct discover_resp *dr;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\tdr = &disc_resp->disc;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (res == 0) {\n\t\tmemcpy(sas_addr, disc_resp->disc.attached_sas_addr, 8);\n\t\t*type = to_dev_type(dr);\n\t\tif (*type == 0)\n\t\t\tmemset(sas_addr, 0, 8);\n\t}\n\tkfree(disc_resp);\n\treturn res;\n}\n\nstatic int sas_find_bcast_phy(struct domain_device *dev, int *phy_id,\n\t\t\t      int from_phy, bool update)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tfor (i = from_phy; i < ex->num_phys; i++) {\n\t\tint phy_change_count = 0;\n\n\t\tres = sas_get_phy_change_count(dev, i, &phy_change_count);\n\t\tswitch (res) {\n\t\tcase SMP_RESP_PHY_VACANT:\n\t\tcase SMP_RESP_NO_PHY:\n\t\t\tcontinue;\n\t\tcase SMP_RESP_FUNC_ACC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\n\t\tif (phy_change_count != ex->ex_phy[i].phy_change_count) {\n\t\t\tif (update)\n\t\t\t\tex->ex_phy[i].phy_change_count =\n\t\t\t\t\tphy_change_count;\n\t\t\t*phy_id = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_get_ex_change_count(struct domain_device *dev, int *ecc)\n{\n\tint res;\n\tu8  *rg_req;\n\tstruct smp_resp  *rg_resp;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t       RG_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tif (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\tres = rg_resp->result;\n\t\tgoto out;\n\t}\n\n\t*ecc = be16_to_cpu(rg_resp->rg.change_count);\nout:\n\tkfree(rg_resp);\n\tkfree(rg_req);\n\treturn res;\n}\n/**\n * sas_find_bcast_dev -  find the device issue BROADCAST(CHANGE).\n * @dev:domain device to be detect.\n * @src_dev: the device which originated BROADCAST(CHANGE).\n *\n * Add self-configuration expander support. Suppose two expander cascading,\n * when the first level expander is self-configuring, hotplug the disks in\n * second level expander, BROADCAST(CHANGE) will not only be originated\n * in the second level expander, but also be originated in the first level\n * expander (see SAS protocol SAS 2r-14, 7.11 for detail), it is to say,\n * expander changed count in two level expanders will all increment at least\n * once, but the phy which chang count has changed is the source device which\n * we concerned.\n */\n\nstatic int sas_find_bcast_dev(struct domain_device *dev,\n\t\t\t      struct domain_device **src_dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint ex_change_count = -1;\n\tint phy_id = -1;\n\tint res;\n\tstruct domain_device *ch;\n\n\tres = sas_get_ex_change_count(dev, &ex_change_count);\n\tif (res)\n\t\tgoto out;\n\tif (ex_change_count != -1 && ex_change_count != ex->ex_change_count) {\n\t\t/* Just detect if this expander phys phy change count changed,\n\t\t* in order to determine if this expander originate BROADCAST,\n\t\t* and do not update phy change count field in our structure.\n\t\t*/\n\t\tres = sas_find_bcast_phy(dev, &phy_id, 0, false);\n\t\tif (phy_id != -1) {\n\t\t\t*src_dev = dev;\n\t\t\tex->ex_change_count = ex_change_count;\n\t\t\tSAS_DPRINTK(\"Expander phy change count has changed\\n\");\n\t\t\treturn res;\n\t\t} else\n\t\t\tSAS_DPRINTK(\"Expander phys DID NOT change\\n\");\n\t}\n\tlist_for_each_entry(ch, &ex->children, siblings) {\n\t\tif (ch->dev_type == SAS_EDGE_EXPANDER_DEVICE || ch->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tres = sas_find_bcast_dev(ch, src_dev);\n\t\t\tif (*src_dev)\n\t\t\t\treturn res;\n\t\t}\n\t}\nout:\n\treturn res;\n}\n\nstatic void sas_unregister_ex_tree(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child, *n;\n\n\tlist_for_each_entry_safe(child, n, &ex->children, siblings) {\n\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tsas_unregister_ex_tree(port, child);\n\t\telse\n\t\t\tsas_unregister_dev(port, child);\n\t}\n\tsas_unregister_dev(port, dev);\n}\n\nstatic void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t\t    SAS_ADDR(phy->attached_sas_addr)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tsas_port_delete(phy->port);\n\t\tphy->port = NULL;\n\t}\n}\n\nstatic int sas_discover_bfs_by_root_level(struct domain_device *root,\n\t\t\t\t\t  const int level)\n{\n\tstruct expander_device *ex_root = &root->ex_dev;\n\tstruct domain_device *child;\n\tint res = 0;\n\n\tlist_for_each_entry(child, &ex_root->children, siblings) {\n\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(child->rphy);\n\n\t\t\tif (level > ex->level)\n\t\t\t\tres = sas_discover_bfs_by_root_level(child,\n\t\t\t\t\t\t\t\t     level);\n\t\t\telse if (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(child, -1);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int sas_discover_bfs_by_root(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\tint level = ex->level+1;\n\n\tres = sas_ex_discover_devices(dev, -1);\n\tif (res)\n\t\tgoto out;\n\tdo {\n\t\tres = sas_discover_bfs_by_root_level(dev, level);\n\t\tmb();\n\t\tlevel += 1;\n\t} while (level <= dev->port->disc.max_level);\nout:\n\treturn res;\n}\n\nstatic int sas_discover_new(struct domain_device *dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child;\n\tint res;\n\n\tSAS_DPRINTK(\"ex %016llx phy%d new device attached\\n\",\n\t\t    SAS_ADDR(dev->sas_addr), phy_id);\n\tres = sas_ex_phy_discover(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\n\tif (sas_ex_join_wide_port(dev, phy_id))\n\t\treturn 0;\n\n\tres = sas_ex_discover_devices(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\tlist_for_each_entry(child, &dev->ex_dev.children, siblings) {\n\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t    SAS_ADDR(ex_phy->attached_sas_addr)) {\n\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\tres = sas_discover_bfs_by_root(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic bool dev_type_flutter(enum sas_device_type new, enum sas_device_type old)\n{\n\tif (old == new)\n\t\treturn true;\n\n\t/* treat device directed resets as flutter, if we went\n\t * SAS_END_DEVICE to SAS_SATA_PENDING the link needs recovery\n\t */\n\tif ((old == SAS_SATA_PENDING && new == SAS_END_DEVICE) ||\n\t    (old == SAS_END_DEVICE && new == SAS_SATA_PENDING))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sas_rediscover_dev(struct domain_device *dev, int phy_id, bool last)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tenum sas_device_type type = SAS_PHY_UNUSED;\n\tu8 sas_addr[8];\n\tint res;\n\n\tmemset(sas_addr, 0, 8);\n\tres = sas_get_phy_attached_dev(dev, phy_id, sas_addr, &type);\n\tswitch (res) {\n\tcase SMP_RESP_NO_PHY:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tbreak;\n\tcase -ECOMM:\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\tif ((SAS_ADDR(sas_addr) == 0) || (res == -ECOMM)) {\n\t\tphy->phy_state = PHY_EMPTY;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\t} else if (SAS_ADDR(sas_addr) == SAS_ADDR(phy->attached_sas_addr) &&\n\t\t   dev_type_flutter(type, phy->attached_dev_type)) {\n\t\tstruct domain_device *ata_dev = sas_ex_to_ata(dev, phy_id);\n\t\tchar *action = \"\";\n\n\t\tsas_ex_phy_discover(dev, phy_id);\n\n\t\tif (ata_dev && phy->attached_dev_type == SAS_SATA_PENDING)\n\t\t\taction = \", needs recovery\";\n\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x broadcast flutter%s\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, action);\n\t\treturn res;\n\t}\n\n\t/* delete the old link */\n\tif (SAS_ADDR(phy->attached_sas_addr) &&\n\t    SAS_ADDR(sas_addr) != SAS_ADDR(phy->attached_sas_addr)) {\n\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x replace %016llx\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id,\n\t\t\t    SAS_ADDR(phy->attached_sas_addr));\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t}\n\n\treturn sas_discover_new(dev, phy_id);\n}\n\n/**\n * sas_rediscover - revalidate the domain.\n * @dev:domain device to be detect.\n * @phy_id: the phy id will be detected.\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.For plugging out, we un-register the device only when it is\n * the last phy in the port, for other phys in this port, we just delete it\n * from the port.For inserting, we do discovery when it is the\n * first phy,for other phys in this port, we add it to the port to\n * forming the wide-port.\n */\nstatic int sas_rediscover(struct domain_device *dev, const int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *changed_phy = &ex->ex_phy[phy_id];\n\tint res = 0;\n\tint i;\n\tbool last = true;\t/* is this the last phy of the port */\n\n\tSAS_DPRINTK(\"ex %016llx phy%d originated BROADCAST(CHANGE)\\n\",\n\t\t    SAS_ADDR(dev->sas_addr), phy_id);\n\n\tif (SAS_ADDR(changed_phy->attached_sas_addr) != 0) {\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\t\tif (i == phy_id)\n\t\t\t\tcontinue;\n\t\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t\t    SAS_ADDR(changed_phy->attached_sas_addr)) {\n\t\t\t\tSAS_DPRINTK(\"phy%d part of wide port with \"\n\t\t\t\t\t    \"phy%d\\n\", phy_id, i);\n\t\t\t\tlast = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = sas_rediscover_dev(dev, phy_id, last);\n\t} else\n\t\tres = sas_discover_new(dev, phy_id);\n\treturn res;\n}\n\n/**\n * sas_revalidate_domain -- revalidate the domain\n * @port: port to the domain of interest\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.\n */\nint sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}\n\nvoid sas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy)\n{\n\tstruct domain_device *dev;\n\tunsigned int reslen = 0;\n\tint ret = -EINVAL;\n\n\t/* no rphy means no smp target support (ie aic94xx host) */\n\tif (!rphy)\n\t\treturn sas_smp_host_handler(job, shost);\n\n\tswitch (rphy->identify.device_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"%s: can we send a smp request to a device?\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\tif (!dev) {\n\t\tprintk(\"%s: fail to find a domain_device?\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t/* do we need to support multiple segments? */\n\tif (job->request_payload.sg_cnt > 1 ||\n\t    job->reply_payload.sg_cnt > 1) {\n\t\tprintk(\"%s: multiple segments req %u, rsp %u\\n\",\n\t\t       __func__, job->request_payload.payload_len,\n\t\t       job->reply_payload.payload_len);\n\t\tgoto out;\n\t}\n\n\tret = smp_execute_task_sg(dev, job->request_payload.sg_list,\n\t\t\tjob->reply_payload.sg_list);\n\tif (ret > 0) {\n\t\t/* positive number is the untransferred residual */\n\t\treslen = ret;\n\t\tret = 0;\n\t}\n\nout:\n\tbsg_job_done(job, ret, reslen);\n}\n"], "fixing_code": ["/*\n * Serial Attached SCSI (SAS) Expander discovery and configuration\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\n#include \"sas_internal.h\"\n\n#include <scsi/sas_ata.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"../scsi_sas_internal.h\"\n\nstatic int sas_discover_expander(struct domain_device *dev);\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr);\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int include);\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr);\n\n/* ---------- SMP task management ---------- */\n\nstatic void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tcomplete(&task->slow_task->completion);\n}\n\nstatic void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}\n\n/* Give it some long enough timeout. In seconds. */\n#define SMP_TIMEOUT 10\n\nstatic int smp_execute_task_sg(struct domain_device *dev,\n\t\tstruct scatterlist *req, struct scatterlist *resp)\n{\n\tint res, retry;\n\tstruct sas_task *task = NULL;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(dev->port->ha->core.shost->transportt);\n\n\tmutex_lock(&dev->ex_dev.cmd_mutex);\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tif (test_bit(SAS_DEV_GONE, &dev->state)) {\n\t\t\tres = -ECOMM;\n\t\t\tbreak;\n\t\t}\n\n\t\ttask = sas_alloc_slow_task(GFP_KERNEL);\n\t\tif (!task) {\n\t\t\tres = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\ttask->dev = dev;\n\t\ttask->task_proto = dev->tproto;\n\t\ttask->smp_task.smp_req = *req;\n\t\ttask->smp_task.smp_resp = *resp;\n\n\t\ttask->task_done = smp_task_done;\n\n\t\ttask->slow_task->timer.function = smp_task_timedout;\n\t\ttask->slow_task->timer.expires = jiffies + SMP_TIMEOUT*HZ;\n\t\tadd_timer(&task->slow_task->timer);\n\n\t\tres = i->dft->lldd_execute_task(task, GFP_KERNEL);\n\n\t\tif (res) {\n\t\t\tdel_timer(&task->slow_task->timer);\n\t\t\tSAS_DPRINTK(\"executing SMP task failed:%d\\n\", res);\n\t\t\tbreak;\n\t\t}\n\n\t\twait_for_completion(&task->slow_task->completion);\n\t\tres = -ECOMM;\n\t\tif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\n\t\t\tSAS_DPRINTK(\"smp task timed out or aborted\\n\");\n\t\t\ti->dft->lldd_abort_task(task);\n\t\t\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\t\t\tSAS_DPRINTK(\"SMP task aborted and not done\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAM_STAT_GOOD) {\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_UNDERRUN) {\n\t\t\t/* no error, but return the number of bytes of\n\t\t\t * underrun */\n\t\t\tres = task->task_status.residual;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_OVERRUN) {\n\t\t\tres = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_UNDELIVERED &&\n\t\t    task->task_status.stat == SAS_DEVICE_UNKNOWN)\n\t\t\tbreak;\n\t\telse {\n\t\t\tSAS_DPRINTK(\"%s: task to dev %016llx response: 0x%x \"\n\t\t\t\t    \"status 0x%x\\n\", __func__,\n\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t    task->task_status.resp,\n\t\t\t\t    task->task_status.stat);\n\t\t\tsas_free_task(task);\n\t\t\ttask = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&dev->ex_dev.cmd_mutex);\n\n\tBUG_ON(retry == 3 && task != NULL);\n\tsas_free_task(task);\n\treturn res;\n}\n\nstatic int smp_execute_task(struct domain_device *dev, void *req, int req_size,\n\t\t\t    void *resp, int resp_size)\n{\n\tstruct scatterlist req_sg;\n\tstruct scatterlist resp_sg;\n\n\tsg_init_one(&req_sg, req, req_size);\n\tsg_init_one(&resp_sg, resp, resp_size);\n\treturn smp_execute_task_sg(dev, &req_sg, &resp_sg);\n}\n\n/* ---------- Allocations ---------- */\n\nstatic inline void *alloc_smp_req(int size)\n{\n\tu8 *p = kzalloc(size, GFP_KERNEL);\n\tif (p)\n\t\tp[0] = SMP_REQUEST;\n\treturn p;\n}\n\nstatic inline void *alloc_smp_resp(int size)\n{\n\treturn kzalloc(size, GFP_KERNEL);\n}\n\nstatic char sas_route_char(struct domain_device *dev, struct ex_phy *phy)\n{\n\tswitch (phy->routing_attr) {\n\tcase TABLE_ROUTING:\n\t\tif (dev->ex_dev.t2t_supp)\n\t\t\treturn 'U';\n\t\telse\n\t\t\treturn 'T';\n\tcase DIRECT_ROUTING:\n\t\treturn 'D';\n\tcase SUBTRACTIVE_ROUTING:\n\t\treturn 'S';\n\tdefault:\n\t\treturn '?';\n\t}\n}\n\nstatic enum sas_device_type to_dev_type(struct discover_resp *dr)\n{\n\t/* This is detecting a failure to transmit initial dev to host\n\t * FIS as described in section J.5 of sas-2 r16\n\t */\n\tif (dr->attached_dev_type == SAS_PHY_UNUSED && dr->attached_sata_dev &&\n\t    dr->linkrate >= SAS_LINK_RATE_1_5_GBPS)\n\t\treturn SAS_SATA_PENDING;\n\telse\n\t\treturn dr->attached_dev_type;\n}\n\nstatic void sas_set_ex_phy(struct domain_device *dev, int phy_id, void *rsp)\n{\n\tenum sas_device_type dev_type;\n\tenum sas_linkrate linkrate;\n\tu8 sas_addr[SAS_ADDR_SIZE];\n\tstruct smp_resp *resp = rsp;\n\tstruct discover_resp *dr = &resp->disc;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tstruct sas_rphy *rphy = dev->rphy;\n\tbool new_phy = !phy->phy;\n\tchar *type;\n\n\tif (new_phy) {\n\t\tif (WARN_ON_ONCE(test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)))\n\t\t\treturn;\n\t\tphy->phy = sas_phy_alloc(&rphy->dev, phy_id);\n\n\t\t/* FIXME: error_handling */\n\t\tBUG_ON(!phy->phy);\n\t}\n\n\tswitch (resp->result) {\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tbreak;\n\tdefault:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tbreak;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tphy->phy_state = PHY_EMPTY; /* do not know yet */\n\t\tbreak;\n\t}\n\n\t/* check if anything important changed to squelch debug */\n\tdev_type = phy->attached_dev_type;\n\tlinkrate  = phy->linkrate;\n\tmemcpy(sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\n\t/* Handle vacant phy - rest of dr data is not valid so skip it */\n\tif (phy->phy_state == PHY_VACANT) {\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tphy->attached_dev_type = SAS_PHY_UNUSED;\n\t\tif (!test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\t\tphy->phy_id = phy_id;\n\t\t\tgoto skip;\n\t\t} else\n\t\t\tgoto out;\n\t}\n\n\tphy->attached_dev_type = to_dev_type(dr);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tgoto out;\n\tphy->phy_id = phy_id;\n\tphy->linkrate = dr->linkrate;\n\tphy->attached_sata_host = dr->attached_sata_host;\n\tphy->attached_sata_dev  = dr->attached_sata_dev;\n\tphy->attached_sata_ps   = dr->attached_sata_ps;\n\tphy->attached_iproto = dr->iproto << 1;\n\tphy->attached_tproto = dr->tproto << 1;\n\t/* help some expanders that fail to zero sas_address in the 'no\n\t * device' case\n\t */\n\tif (phy->attached_dev_type == SAS_PHY_UNUSED ||\n\t    phy->linkrate < SAS_LINK_RATE_1_5_GBPS)\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\telse\n\t\tmemcpy(phy->attached_sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE);\n\tphy->attached_phy_id = dr->attached_phy_id;\n\tphy->phy_change_count = dr->change_count;\n\tphy->routing_attr = dr->routing_attr;\n\tphy->virtual = dr->virtual;\n\tphy->last_da_index = -1;\n\n\tphy->phy->identify.sas_address = SAS_ADDR(phy->attached_sas_addr);\n\tphy->phy->identify.device_type = dr->attached_dev_type;\n\tphy->phy->identify.initiator_port_protocols = phy->attached_iproto;\n\tphy->phy->identify.target_port_protocols = phy->attached_tproto;\n\tif (!phy->attached_tproto && dr->attached_sata_dev)\n\t\tphy->phy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\n\tphy->phy->identify.phy_identifier = phy_id;\n\tphy->phy->minimum_linkrate_hw = dr->hmin_linkrate;\n\tphy->phy->maximum_linkrate_hw = dr->hmax_linkrate;\n\tphy->phy->minimum_linkrate = dr->pmin_linkrate;\n\tphy->phy->maximum_linkrate = dr->pmax_linkrate;\n\tphy->phy->negotiated_linkrate = phy->linkrate;\n\n skip:\n\tif (new_phy)\n\t\tif (sas_phy_add(phy->phy)) {\n\t\t\tsas_phy_free(phy->phy);\n\t\t\treturn;\n\t\t}\n\n out:\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_SATA_PENDING:\n\t\ttype = \"stp pending\";\n\t\tbreak;\n\tcase SAS_PHY_UNUSED:\n\t\ttype = \"no device\";\n\t\tbreak;\n\tcase SAS_END_DEVICE:\n\t\tif (phy->attached_iproto) {\n\t\t\tif (phy->attached_tproto)\n\t\t\t\ttype = \"host+target\";\n\t\t\telse\n\t\t\t\ttype = \"host\";\n\t\t} else {\n\t\t\tif (dr->attached_sata_dev)\n\t\t\t\ttype = \"stp\";\n\t\t\telse\n\t\t\t\ttype = \"ssp\";\n\t\t}\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\ttype = \"smp\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t}\n\n\t/* this routine is polled by libata error recovery so filter\n\t * unimportant messages\n\t */\n\tif (new_phy || phy->attached_dev_type != dev_type ||\n\t    phy->linkrate != linkrate ||\n\t    SAS_ADDR(phy->attached_sas_addr) != SAS_ADDR(sas_addr))\n\t\t/* pass */;\n\telse\n\t\treturn;\n\n\t/* if the attached device type changed and ata_eh is active,\n\t * make sure we run revalidation when eh completes (see:\n\t * sas_enable_revalidation)\n\t */\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tset_bit(DISCE_REVALIDATE_DOMAIN, &dev->port->disc.pending);\n\n\tSAS_DPRINTK(\"%sex %016llx phy%02d:%c:%X attached: %016llx (%s)\\n\",\n\t\t    test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state) ? \"ata: \" : \"\",\n\t\t    SAS_ADDR(dev->sas_addr), phy->phy_id,\n\t\t    sas_route_char(dev, phy), phy->linkrate,\n\t\t    SAS_ADDR(phy->attached_sas_addr), type);\n}\n\n/* check if we have an existing attached ata device on this expander phy */\nstruct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *dev;\n\tstruct sas_rphy *rphy;\n\n\tif (!ex_phy->port)\n\t\treturn NULL;\n\n\trphy = ex_phy->port->rphy;\n\tif (!rphy)\n\t\treturn NULL;\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\n\tif (dev && dev_is_sata(dev))\n\t\treturn dev;\n\n\treturn NULL;\n}\n\n#define DISCOVER_REQ_SIZE  16\n#define DISCOVER_RESP_SIZE 56\n\nstatic int sas_ex_phy_discover_helper(struct domain_device *dev, u8 *disc_req,\n\t\t\t\t      u8 *disc_resp, int single)\n{\n\tstruct discover_resp *dr;\n\tint res;\n\n\tdisc_req[9] = single;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\treturn res;\n\tdr = &((struct smp_resp *)disc_resp)->disc;\n\tif (memcmp(dev->sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE) == 0) {\n\t\tsas_printk(\"Found loopback topology, just ignore it!\\n\");\n\t\treturn 0;\n\t}\n\tsas_set_ex_phy(dev, single, disc_resp);\n\treturn 0;\n}\n\nint sas_ex_phy_discover(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint  res = 0;\n\tu8   *disc_req;\n\tu8   *disc_resp;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp) {\n\t\tkfree(disc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tdisc_req[1] = SMP_DISCOVER;\n\n\tif (0 <= single && single < ex->num_phys) {\n\t\tres = sas_ex_phy_discover_helper(dev, disc_req, disc_resp, single);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tres = sas_ex_phy_discover_helper(dev, disc_req,\n\t\t\t\t\t\t\t disc_resp, i);\n\t\t\tif (res)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\nout_err:\n\tkfree(disc_resp);\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_expander_discover(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res = -ENOMEM;\n\n\tex->ex_phy = kzalloc(sizeof(*ex->ex_phy)*ex->num_phys, GFP_KERNEL);\n\tif (!ex->ex_phy)\n\t\treturn -ENOMEM;\n\n\tres = sas_ex_phy_discover(dev, -1);\n\tif (res)\n\t\tgoto out_err;\n\n\treturn 0;\n out_err:\n\tkfree(ex->ex_phy);\n\tex->ex_phy = NULL;\n\treturn res;\n}\n\n#define MAX_EXPANDER_PHYS 128\n\nstatic void ex_assign_report_general(struct domain_device *dev,\n\t\t\t\t\t    struct smp_resp *resp)\n{\n\tstruct report_general_resp *rg = &resp->rg;\n\n\tdev->ex_dev.ex_change_count = be16_to_cpu(rg->change_count);\n\tdev->ex_dev.max_route_indexes = be16_to_cpu(rg->route_indexes);\n\tdev->ex_dev.num_phys = min(rg->num_phys, (u8)MAX_EXPANDER_PHYS);\n\tdev->ex_dev.t2t_supp = rg->t2t_supp;\n\tdev->ex_dev.conf_route_table = rg->conf_route_table;\n\tdev->ex_dev.configuring = rg->configuring;\n\tmemcpy(dev->ex_dev.enclosure_logical_id, rg->enclosure_logical_id, 8);\n}\n\n#define RG_REQ_SIZE   8\n#define RG_RESP_SIZE 32\n\nstatic int sas_ex_general(struct domain_device *dev)\n{\n\tu8 *rg_req;\n\tstruct smp_resp *rg_resp;\n\tint res;\n\tint i;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t\t       RG_RESP_SIZE);\n\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"RG to ex %016llx failed:0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\t\tgoto out;\n\t\t} else if (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\t\tSAS_DPRINTK(\"RG:ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), rg_resp->result);\n\t\t\tres = rg_resp->result;\n\t\t\tgoto out;\n\t\t}\n\n\t\tex_assign_report_general(dev, rg_resp);\n\n\t\tif (dev->ex_dev.configuring) {\n\t\t\tSAS_DPRINTK(\"RG: ex %llx self-configuring...\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr));\n\t\t\tschedule_timeout_interruptible(5*HZ);\n\t\t} else\n\t\t\tbreak;\n\t}\nout:\n\tkfree(rg_req);\n\tkfree(rg_resp);\n\treturn res;\n}\n\nstatic void ex_assign_manuf_info(struct domain_device *dev, void\n\t\t\t\t\t*_mi_resp)\n{\n\tu8 *mi_resp = _mi_resp;\n\tstruct sas_rphy *rphy = dev->rphy;\n\tstruct sas_expander_device *edev = rphy_to_expander_device(rphy);\n\n\tmemcpy(edev->vendor_id, mi_resp + 12, SAS_EXPANDER_VENDOR_ID_LEN);\n\tmemcpy(edev->product_id, mi_resp + 20, SAS_EXPANDER_PRODUCT_ID_LEN);\n\tmemcpy(edev->product_rev, mi_resp + 36,\n\t       SAS_EXPANDER_PRODUCT_REV_LEN);\n\n\tif (mi_resp[8] & 1) {\n\t\tmemcpy(edev->component_vendor_id, mi_resp + 40,\n\t\t       SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\n\t\tedev->component_id = mi_resp[48] << 8 | mi_resp[49];\n\t\tedev->component_revision_id = mi_resp[50];\n\t}\n}\n\n#define MI_REQ_SIZE   8\n#define MI_RESP_SIZE 64\n\nstatic int sas_ex_manuf_info(struct domain_device *dev)\n{\n\tu8 *mi_req;\n\tu8 *mi_resp;\n\tint res;\n\n\tmi_req = alloc_smp_req(MI_REQ_SIZE);\n\tif (!mi_req)\n\t\treturn -ENOMEM;\n\n\tmi_resp = alloc_smp_resp(MI_RESP_SIZE);\n\tif (!mi_resp) {\n\t\tkfree(mi_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tmi_req[1] = SMP_REPORT_MANUF_INFO;\n\n\tres = smp_execute_task(dev, mi_req, MI_REQ_SIZE, mi_resp,MI_RESP_SIZE);\n\tif (res) {\n\t\tSAS_DPRINTK(\"MI: ex %016llx failed:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out;\n\t} else if (mi_resp[2] != SMP_RESP_FUNC_ACC) {\n\t\tSAS_DPRINTK(\"MI ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), mi_resp[2]);\n\t\tgoto out;\n\t}\n\n\tex_assign_manuf_info(dev, mi_resp);\nout:\n\tkfree(mi_req);\n\tkfree(mi_resp);\n\treturn res;\n}\n\n#define PC_REQ_SIZE  44\n#define PC_RESP_SIZE 8\n\nint sas_smp_phy_control(struct domain_device *dev, int phy_id,\n\t\t\tenum phy_func phy_func,\n\t\t\tstruct sas_phy_linkrates *rates)\n{\n\tu8 *pc_req;\n\tu8 *pc_resp;\n\tint res;\n\n\tpc_req = alloc_smp_req(PC_REQ_SIZE);\n\tif (!pc_req)\n\t\treturn -ENOMEM;\n\n\tpc_resp = alloc_smp_resp(PC_RESP_SIZE);\n\tif (!pc_resp) {\n\t\tkfree(pc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tpc_req[1] = SMP_PHY_CONTROL;\n\tpc_req[9] = phy_id;\n\tpc_req[10]= phy_func;\n\tif (rates) {\n\t\tpc_req[32] = rates->minimum_linkrate << 4;\n\t\tpc_req[33] = rates->maximum_linkrate << 4;\n\t}\n\n\tres = smp_execute_task(dev, pc_req, PC_REQ_SIZE, pc_resp,PC_RESP_SIZE);\n\n\tkfree(pc_resp);\n\tkfree(pc_req);\n\treturn res;\n}\n\nstatic void sas_ex_disable_phy(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\n\tsas_smp_phy_control(dev, phy_id, PHY_FUNC_DISABLE, NULL);\n\tphy->linkrate = SAS_PHY_DISABLED;\n}\n\nstatic void sas_ex_disable_port(struct domain_device *dev, u8 *sas_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) == SAS_ADDR(sas_addr))\n\t\t\tsas_ex_disable_phy(dev, i);\n\t}\n}\n\nstatic int sas_dev_present_in_domain(struct asd_sas_port *port,\n\t\t\t\t\t    u8 *sas_addr)\n{\n\tstruct domain_device *dev;\n\n\tif (SAS_ADDR(port->sas_addr) == SAS_ADDR(sas_addr))\n\t\treturn 1;\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (SAS_ADDR(dev->sas_addr) == SAS_ADDR(sas_addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define RPEL_REQ_SIZE\t16\n#define RPEL_RESP_SIZE\t32\nint sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (!res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n\n}\n\n#ifdef CONFIG_SCSI_SAS_ATA\n\n#define RPS_REQ_SIZE  16\n#define RPS_RESP_SIZE 60\n\nint sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_resp *rps_resp)\n{\n\tint res;\n\tu8 *rps_req = alloc_smp_req(RPS_REQ_SIZE);\n\tu8 *resp = (u8 *)rps_resp;\n\n\tif (!rps_req)\n\t\treturn -ENOMEM;\n\n\trps_req[1] = SMP_REPORT_PHY_SATA;\n\trps_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, rps_req, RPS_REQ_SIZE,\n\t\t\t            rps_resp, RPS_RESP_SIZE);\n\n\t/* 0x34 is the FIS type for the D2H fis.  There's a potential\n\t * standards cockup here.  sas-2 explicitly specifies the FIS\n\t * should be encoded so that FIS type is in resp[24].\n\t * However, some expanders endian reverse this.  Undo the\n\t * reversal here */\n\tif (!res && resp[27] == 0x34 && resp[24] != 0x34) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tint j = 24 + (i*4);\n\t\t\tu8 a, b;\n\t\t\ta = resp[j + 0];\n\t\t\tb = resp[j + 1];\n\t\t\tresp[j + 0] = resp[j + 3];\n\t\t\tresp[j + 1] = resp[j + 2];\n\t\t\tresp[j + 2] = b;\n\t\t\tresp[j + 3] = a;\n\t\t}\n\t}\n\n\tkfree(rps_req);\n\treturn res;\n}\n#endif\n\nstatic void sas_ex_get_linkrate(struct domain_device *parent,\n\t\t\t\t       struct domain_device *child,\n\t\t\t\t       struct ex_phy *parent_phy)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct sas_port *port;\n\tint i;\n\n\tchild->pathways = 0;\n\n\tport = parent_phy->port;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &parent_ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t    SAS_ADDR(child->sas_addr)) {\n\n\t\t\tchild->min_linkrate = min(parent->min_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->max_linkrate = max(parent->max_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->pathways++;\n\t\t\tsas_port_add_phy(port, phy->phy);\n\t\t}\n\t}\n\tchild->linkrate = min(parent_phy->linkrate, child->max_linkrate);\n\tchild->pathways = min(child->pathways, parent->pathways);\n}\n\nstatic struct domain_device *sas_ex_discover_end_dev(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct ex_phy *phy = &parent_ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tint res;\n\n\tif (phy->attached_sata_host || phy->attached_sata_ps)\n\t\treturn NULL;\n\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port   = parent->port;\n\tchild->iproto = phy->attached_iproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tif (!phy->port) {\n\t\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t\tif (unlikely(!phy->port))\n\t\t\tgoto out_err;\n\t\tif (unlikely(sas_port_add(phy->port) != 0)) {\n\t\t\tsas_port_free(phy->port);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tsas_ex_get_linkrate(parent, child, phy);\n\tsas_device_set_phy(child, phy->port);\n\n#ifdef CONFIG_SCSI_SAS_ATA\n\tif ((phy->attached_tproto & SAS_PROTOCOL_STP) || phy->attached_sata_dev) {\n\t\tres = sas_get_ata_info(child, phy);\n\t\tif (res)\n\t\t\tgoto out_free;\n\n\t\tsas_init_dev(child);\n\t\tres = sas_ata_init(child);\n\t\tif (res)\n\t\t\tgoto out_free;\n\t\trphy = sas_end_device_alloc(phy->port);\n\t\tif (!rphy)\n\t\t\tgoto out_free;\n\n\t\tchild->rphy = rphy;\n\t\tget_device(&rphy->dev);\n\n\t\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\t\tres = sas_discover_sata(child);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"sas_discover_sata() for device %16llx at \"\n\t\t\t\t    \"%016llx:0x%x returned 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t    SAS_ADDR(parent->sas_addr), phy_id, res);\n\t\t\tgoto out_list_del;\n\t\t}\n\t} else\n#endif\n\t  if (phy->attached_tproto & SAS_PROTOCOL_SSP) {\n\t\tchild->dev_type = SAS_END_DEVICE;\n\t\trphy = sas_end_device_alloc(phy->port);\n\t\t/* FIXME: error handling */\n\t\tif (unlikely(!rphy))\n\t\t\tgoto out_free;\n\t\tchild->tproto = phy->attached_tproto;\n\t\tsas_init_dev(child);\n\n\t\tchild->rphy = rphy;\n\t\tget_device(&rphy->dev);\n\t\tsas_fill_in_rphy(child, rphy);\n\n\t\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\t\tres = sas_discover_end_dev(child);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"sas_discover_end_dev() for device %16llx \"\n\t\t\t\t    \"at %016llx:0x%x returned 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t    SAS_ADDR(parent->sas_addr), phy_id, res);\n\t\t\tgoto out_list_del;\n\t\t}\n\t} else {\n\t\tSAS_DPRINTK(\"target proto 0x%x at %016llx:0x%x not handled\\n\",\n\t\t\t    phy->attached_tproto, SAS_ADDR(parent->sas_addr),\n\t\t\t    phy_id);\n\t\tgoto out_free;\n\t}\n\n\tlist_add_tail(&child->siblings, &parent_ex->children);\n\treturn child;\n\n out_list_del:\n\tsas_rphy_free(child->rphy);\n\tlist_del(&child->disco_list_node);\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_del(&child->dev_list_node);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n out_free:\n\tsas_port_delete(phy->port);\n out_err:\n\tphy->port = NULL;\n\tsas_put_device(child);\n\treturn NULL;\n}\n\n/* See if this phy is part of a wide port */\nstatic bool sas_ex_join_wide_port(struct domain_device *parent, int phy_id)\n{\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tint i;\n\n\tfor (i = 0; i < parent->ex_dev.num_phys; i++) {\n\t\tstruct ex_phy *ephy = &parent->ex_dev.ex_phy[i];\n\n\t\tif (ephy == phy)\n\t\t\tcontinue;\n\n\t\tif (!memcmp(phy->attached_sas_addr, ephy->attached_sas_addr,\n\t\t\t    SAS_ADDR_SIZE) && ephy->port) {\n\t\t\tsas_port_add_phy(ephy->port, phy->phy);\n\t\t\tphy->port = ephy->port;\n\t\t\tphy->phy_state = PHY_DEVICE_DISCOVERED;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic struct domain_device *sas_ex_discover_expander(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct sas_expander_device *parent_ex = rphy_to_expander_device(parent->rphy);\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tstruct sas_expander_device *edev;\n\tstruct asd_sas_port *port;\n\tint res;\n\n\tif (phy->routing_attr == DIRECT_ROUTING) {\n\t\tSAS_DPRINTK(\"ex %016llx:0x%x:D <--> ex %016llx:0x%x is not \"\n\t\t\t    \"allowed\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr), phy_id,\n\t\t\t    SAS_ADDR(phy->attached_sas_addr),\n\t\t\t    phy->attached_phy_id);\n\t\treturn NULL;\n\t}\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t/* FIXME: better error handling */\n\tBUG_ON(sas_port_add(phy->port) != 0);\n\n\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\trphy = NULL;\t/* shut gcc up */\n\t\tBUG();\n\t}\n\tport = parent->port;\n\tchild->rphy = rphy;\n\tget_device(&rphy->dev);\n\tedev = rphy_to_expander_device(rphy);\n\tchild->dev_type = phy->attached_dev_type;\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port = port;\n\tchild->iproto = phy->attached_iproto;\n\tchild->tproto = phy->attached_tproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tsas_ex_get_linkrate(parent, child, phy);\n\tedev->level = parent_ex->level + 1;\n\tparent->port->disc.max_level = max(parent->port->disc.max_level,\n\t\t\t\t\t   edev->level);\n\tsas_init_dev(child);\n\tsas_fill_in_rphy(child, rphy);\n\tsas_rphy_add(rphy);\n\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_add_tail(&child->dev_list_node, &parent->port->dev_list);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n\n\tres = sas_discover_expander(child);\n\tif (res) {\n\t\tsas_rphy_delete(rphy);\n\t\tspin_lock_irq(&parent->port->dev_list_lock);\n\t\tlist_del(&child->dev_list_node);\n\t\tspin_unlock_irq(&parent->port->dev_list_lock);\n\t\tsas_put_device(child);\n\t\treturn NULL;\n\t}\n\tlist_add_tail(&child->siblings, &parent->ex_dev.children);\n\treturn child;\n}\n\nstatic int sas_ex_discover_dev(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *ex_phy = &ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tint res = 0;\n\n\t/* Phy state */\n\tif (ex_phy->linkrate == SAS_SATA_SPINUP_HOLD) {\n\t\tif (!sas_smp_phy_control(dev, phy_id, PHY_FUNC_LINK_RESET, NULL))\n\t\t\tres = sas_ex_phy_discover(dev, phy_id);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\t/* Parent and domain coherency */\n\tif (!dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\n\t\t\t     SAS_ADDR(dev->port->sas_addr))) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\treturn 0;\n\t}\n\tif (dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\n\t\t\t    SAS_ADDR(dev->parent->sas_addr))) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\tif (ex_phy->routing_attr == TABLE_ROUTING)\n\t\t\tsas_configure_phy(dev, phy_id, dev->port->sas_addr, 1);\n\t\treturn 0;\n\t}\n\n\tif (sas_dev_present_in_domain(dev->port, ex_phy->attached_sas_addr))\n\t\tsas_ex_disable_port(dev, ex_phy->attached_sas_addr);\n\n\tif (ex_phy->attached_dev_type == SAS_PHY_UNUSED) {\n\t\tif (ex_phy->routing_attr == DIRECT_ROUTING) {\n\t\t\tmemset(ex_phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\t\tsas_configure_routing(dev, ex_phy->attached_sas_addr);\n\t\t}\n\t\treturn 0;\n\t} else if (ex_phy->linkrate == SAS_LINK_RATE_UNKNOWN)\n\t\treturn 0;\n\n\tif (ex_phy->attached_dev_type != SAS_END_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_FANOUT_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_SATA_PENDING) {\n\t\tSAS_DPRINTK(\"unknown device type(0x%x) attached to ex %016llx \"\n\t\t\t    \"phy 0x%x\\n\", ex_phy->attached_dev_type,\n\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t    phy_id);\n\t\treturn 0;\n\t}\n\n\tres = sas_configure_routing(dev, ex_phy->attached_sas_addr);\n\tif (res) {\n\t\tSAS_DPRINTK(\"configure routing for dev %016llx \"\n\t\t\t    \"reported 0x%x. Forgotten\\n\",\n\t\t\t    SAS_ADDR(ex_phy->attached_sas_addr), res);\n\t\tsas_disable_routing(dev, ex_phy->attached_sas_addr);\n\t\treturn res;\n\t}\n\n\tif (sas_ex_join_wide_port(dev, phy_id)) {\n\t\tSAS_DPRINTK(\"Attaching ex phy%d to wide port %016llx\\n\",\n\t\t\t    phy_id, SAS_ADDR(ex_phy->attached_sas_addr));\n\t\treturn res;\n\t}\n\n\tswitch (ex_phy->attached_dev_type) {\n\tcase SAS_END_DEVICE:\n\tcase SAS_SATA_PENDING:\n\t\tchild = sas_ex_discover_end_dev(dev, phy_id);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tif (SAS_ADDR(dev->port->disc.fanout_sas_addr)) {\n\t\t\tSAS_DPRINTK(\"second fanout expander %016llx phy 0x%x \"\n\t\t\t\t    \"attached to ex %016llx phy 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(ex_phy->attached_sas_addr),\n\t\t\t\t    ex_phy->attached_phy_id,\n\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t    phy_id);\n\t\t\tsas_ex_disable_phy(dev, phy_id);\n\t\t\tbreak;\n\t\t} else\n\t\t\tmemcpy(dev->port->disc.fanout_sas_addr,\n\t\t\t       ex_phy->attached_sas_addr, SAS_ADDR_SIZE);\n\t\t/* fallthrough */\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\tchild = sas_ex_discover_expander(dev, phy_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (child) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tif (ex->ex_phy[i].phy_state == PHY_VACANT ||\n\t\t\t    ex->ex_phy[i].phy_state == PHY_NOT_PRESENT)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Due to races, the phy might not get added to the\n\t\t\t * wide port, so we add the phy to the wide port here.\n\t\t\t */\n\t\t\tif (SAS_ADDR(ex->ex_phy[i].attached_sas_addr) ==\n\t\t\t    SAS_ADDR(child->sas_addr)) {\n\t\t\t\tex->ex_phy[i].phy_state= PHY_DEVICE_DISCOVERED;\n\t\t\t\tif (sas_ex_join_wide_port(dev, i))\n\t\t\t\t\tSAS_DPRINTK(\"Attaching ex phy%d to wide port %016llx\\n\",\n\t\t\t\t\t\t    i, SAS_ADDR(ex->ex_phy[i].attached_sas_addr));\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int sas_find_sub_addr(struct domain_device *dev, u8 *sub_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif ((phy->attached_dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t     phy->attached_dev_type == SAS_FANOUT_EXPANDER_DEVICE) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tmemcpy(sub_addr, phy->attached_sas_addr,SAS_ADDR_SIZE);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_check_level_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child;\n\tu8 sub_addr[8] = {0, };\n\n\tlist_for_each_entry(child, &ex->children, siblings) {\n\t\tif (child->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t\t    child->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tcontinue;\n\t\tif (sub_addr[0] == 0) {\n\t\t\tsas_find_sub_addr(child, sub_addr);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tu8 s2[8];\n\n\t\t\tif (sas_find_sub_addr(child, s2) &&\n\t\t\t    (SAS_ADDR(sub_addr) != SAS_ADDR(s2))) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx->%016llx-?->%016llx \"\n\t\t\t\t\t    \"diverges from subtractive \"\n\t\t\t\t\t    \"boundary %016llx\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t\t    SAS_ADDR(s2),\n\t\t\t\t\t    SAS_ADDR(sub_addr));\n\n\t\t\t\tsas_ex_disable_port(child, s2);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/**\n * sas_ex_discover_devices -- discover devices attached to this expander\n * dev: pointer to the expander domain device\n * single: if you want to do a single phy, else set to -1;\n *\n * Configure this expander for use with its devices and register the\n * devices of this expander.\n */\nstatic int sas_ex_discover_devices(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i = 0, end = ex->num_phys;\n\tint res = 0;\n\n\tif (0 <= single && single < end) {\n\t\ti = single;\n\t\tend = i+1;\n\t}\n\n\tfor ( ; i < end; i++) {\n\t\tstruct ex_phy *ex_phy = &ex->ex_phy[i];\n\n\t\tif (ex_phy->phy_state == PHY_VACANT ||\n\t\t    ex_phy->phy_state == PHY_NOT_PRESENT ||\n\t\t    ex_phy->phy_state == PHY_DEVICE_DISCOVERED)\n\t\t\tcontinue;\n\n\t\tswitch (ex_phy->linkrate) {\n\t\tcase SAS_PHY_DISABLED:\n\t\tcase SAS_PHY_RESET_PROBLEM:\n\t\tcase SAS_SATA_PORT_SELECTOR:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tres = sas_ex_discover_dev(dev, i);\n\t\t\tif (res)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!res)\n\t\tsas_check_level_subtractive_boundary(dev);\n\n\treturn res;\n}\n\nstatic int sas_check_ex_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\tu8  *sub_sas_addr = NULL;\n\n\tif (dev->dev_type != SAS_EDGE_EXPANDER_DEVICE)\n\t\treturn 0;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif ((phy->attached_dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     phy->attached_dev_type == SAS_EDGE_EXPANDER_DEVICE) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tif (!sub_sas_addr)\n\t\t\t\tsub_sas_addr = &phy->attached_sas_addr[0];\n\t\t\telse if (SAS_ADDR(sub_sas_addr) !=\n\t\t\t\t SAS_ADDR(phy->attached_sas_addr)) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x \"\n\t\t\t\t\t    \"diverges(%016llx) on subtractive \"\n\t\t\t\t\t    \"boundary(%016llx). Disabled\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr), i,\n\t\t\t\t\t    SAS_ADDR(phy->attached_sas_addr),\n\t\t\t\t\t    SAS_ADDR(sub_sas_addr));\n\t\t\t\tsas_ex_disable_phy(dev, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sas_print_parent_topology_bug(struct domain_device *child,\n\t\t\t\t\t\t struct ex_phy *parent_phy,\n\t\t\t\t\t\t struct ex_phy *child_phy)\n{\n\tstatic const char *ex_type[] = {\n\t\t[SAS_EDGE_EXPANDER_DEVICE] = \"edge\",\n\t\t[SAS_FANOUT_EXPANDER_DEVICE] = \"fanout\",\n\t};\n\tstruct domain_device *parent = child->parent;\n\n\tsas_printk(\"%s ex %016llx phy 0x%x <--> %s ex %016llx \"\n\t\t   \"phy 0x%x has %c:%c routing link!\\n\",\n\n\t\t   ex_type[parent->dev_type],\n\t\t   SAS_ADDR(parent->sas_addr),\n\t\t   parent_phy->phy_id,\n\n\t\t   ex_type[child->dev_type],\n\t\t   SAS_ADDR(child->sas_addr),\n\t\t   child_phy->phy_id,\n\n\t\t   sas_route_char(parent, parent_phy),\n\t\t   sas_route_char(child, child_phy));\n}\n\nstatic int sas_check_eeds(struct domain_device *child,\n\t\t\t\t struct ex_phy *parent_phy,\n\t\t\t\t struct ex_phy *child_phy)\n{\n\tint res = 0;\n\tstruct domain_device *parent = child->parent;\n\n\tif (SAS_ADDR(parent->port->disc.fanout_sas_addr) != 0) {\n\t\tres = -ENODEV;\n\t\tSAS_DPRINTK(\"edge ex %016llx phy S:0x%x <--> edge ex %016llx \"\n\t\t\t    \"phy S:0x%x, while there is a fanout ex %016llx\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr),\n\t\t\t    parent_phy->phy_id,\n\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t    child_phy->phy_id,\n\t\t\t    SAS_ADDR(parent->port->disc.fanout_sas_addr));\n\t} else if (SAS_ADDR(parent->port->disc.eeds_a) == 0) {\n\t\tmemcpy(parent->port->disc.eeds_a, parent->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tmemcpy(parent->port->disc.eeds_b, child->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t} else if (((SAS_ADDR(parent->port->disc.eeds_a) ==\n\t\t    SAS_ADDR(parent->sas_addr)) ||\n\t\t   (SAS_ADDR(parent->port->disc.eeds_a) ==\n\t\t    SAS_ADDR(child->sas_addr)))\n\t\t   &&\n\t\t   ((SAS_ADDR(parent->port->disc.eeds_b) ==\n\t\t     SAS_ADDR(parent->sas_addr)) ||\n\t\t    (SAS_ADDR(parent->port->disc.eeds_b) ==\n\t\t     SAS_ADDR(child->sas_addr))))\n\t\t;\n\telse {\n\t\tres = -ENODEV;\n\t\tSAS_DPRINTK(\"edge ex %016llx phy 0x%x <--> edge ex %016llx \"\n\t\t\t    \"phy 0x%x link forms a third EEDS!\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr),\n\t\t\t    parent_phy->phy_id,\n\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t    child_phy->phy_id);\n\t}\n\n\treturn res;\n}\n\n/* Here we spill over 80 columns.  It is intentional.\n */\nstatic int sas_check_parent_topology(struct domain_device *child)\n{\n\tstruct expander_device *child_ex = &child->ex_dev;\n\tstruct expander_device *parent_ex;\n\tint i;\n\tint res = 0;\n\n\tif (!child->parent)\n\t\treturn 0;\n\n\tif (child->parent->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t    child->parent->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\treturn 0;\n\n\tparent_ex = &child->parent->ex_dev;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *parent_phy = &parent_ex->ex_phy[i];\n\t\tstruct ex_phy *child_phy;\n\n\t\tif (parent_phy->phy_state == PHY_VACANT ||\n\t\t    parent_phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(parent_phy->attached_sas_addr) != SAS_ADDR(child->sas_addr))\n\t\t\tcontinue;\n\n\t\tchild_phy = &child_ex->ex_phy[parent_phy->attached_phy_id];\n\n\t\tswitch (child->parent->dev_type) {\n\t\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\t\tif (child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\t\tif (parent_phy->routing_attr != SUBTRACTIVE_ROUTING ||\n\t\t\t\t    child_phy->routing_attr != TABLE_ROUTING) {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (parent_phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\t\t\t\tif (child_phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\t\t\t\t\tres = sas_check_eeds(child, parent_phy, child_phy);\n\t\t\t\t} else if (child_phy->routing_attr != TABLE_ROUTING) {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (parent_phy->routing_attr == TABLE_ROUTING) {\n\t\t\t\tif (child_phy->routing_attr == SUBTRACTIVE_ROUTING ||\n\t\t\t\t    (child_phy->routing_attr == TABLE_ROUTING &&\n\t\t\t\t     child_ex->t2t_supp && parent_ex->t2t_supp)) {\n\t\t\t\t\t/* All good */;\n\t\t\t\t} else {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\t\tif (parent_phy->routing_attr != TABLE_ROUTING ||\n\t\t\t    child_phy->routing_attr != SUBTRACTIVE_ROUTING) {\n\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\tres = -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n#define RRI_REQ_SIZE  16\n#define RRI_RESP_SIZE 44\n\nstatic int sas_configure_present(struct domain_device *dev, int phy_id,\n\t\t\t\t u8 *sas_addr, int *index, int *present)\n{\n\tint i, res = 0;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tu8 *rri_req;\n\tu8 *rri_resp;\n\n\t*present = 0;\n\t*index = 0;\n\n\trri_req = alloc_smp_req(RRI_REQ_SIZE);\n\tif (!rri_req)\n\t\treturn -ENOMEM;\n\n\trri_resp = alloc_smp_resp(RRI_RESP_SIZE);\n\tif (!rri_resp) {\n\t\tkfree(rri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trri_req[1] = SMP_REPORT_ROUTE_INFO;\n\trri_req[9] = phy_id;\n\n\tfor (i = 0; i < ex->max_route_indexes ; i++) {\n\t\t*(__be16 *)(rri_req+6) = cpu_to_be16(i);\n\t\tres = smp_execute_task(dev, rri_req, RRI_REQ_SIZE, rri_resp,\n\t\t\t\t       RRI_RESP_SIZE);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tres = rri_resp[2];\n\t\tif (res == SMP_RESP_NO_INDEX) {\n\t\t\tSAS_DPRINTK(\"overflow of indexes: dev %016llx \"\n\t\t\t\t    \"phy 0x%x index 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i);\n\t\t\tgoto out;\n\t\t} else if (res != SMP_RESP_FUNC_ACC) {\n\t\t\tSAS_DPRINTK(\"%s: dev %016llx phy 0x%x index 0x%x \"\n\t\t\t\t    \"result 0x%x\\n\", __func__,\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i, res);\n\t\t\tgoto out;\n\t\t}\n\t\tif (SAS_ADDR(sas_addr) != 0) {\n\t\t\tif (SAS_ADDR(rri_resp+16) == SAS_ADDR(sas_addr)) {\n\t\t\t\t*index = i;\n\t\t\t\tif ((rri_resp[12] & 0x80) == 0x80)\n\t\t\t\t\t*present = 0;\n\t\t\t\telse\n\t\t\t\t\t*present = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (SAS_ADDR(rri_resp+16) == 0) {\n\t\t\t\t*index = i;\n\t\t\t\t*present = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (SAS_ADDR(rri_resp+16) == 0 &&\n\t\t\t   phy->last_da_index < i) {\n\t\t\tphy->last_da_index = i;\n\t\t\t*index = i;\n\t\t\t*present = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tres = -1;\nout:\n\tkfree(rri_req);\n\tkfree(rri_resp);\n\treturn res;\n}\n\n#define CRI_REQ_SIZE  44\n#define CRI_RESP_SIZE  8\n\nstatic int sas_configure_set(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int index, int include)\n{\n\tint res;\n\tu8 *cri_req;\n\tu8 *cri_resp;\n\n\tcri_req = alloc_smp_req(CRI_REQ_SIZE);\n\tif (!cri_req)\n\t\treturn -ENOMEM;\n\n\tcri_resp = alloc_smp_resp(CRI_RESP_SIZE);\n\tif (!cri_resp) {\n\t\tkfree(cri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tcri_req[1] = SMP_CONF_ROUTE_INFO;\n\t*(__be16 *)(cri_req+6) = cpu_to_be16(index);\n\tcri_req[9] = phy_id;\n\tif (SAS_ADDR(sas_addr) == 0 || !include)\n\t\tcri_req[12] |= 0x80;\n\tmemcpy(cri_req+16, sas_addr, SAS_ADDR_SIZE);\n\n\tres = smp_execute_task(dev, cri_req, CRI_REQ_SIZE, cri_resp,\n\t\t\t       CRI_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tres = cri_resp[2];\n\tif (res == SMP_RESP_NO_INDEX) {\n\t\tSAS_DPRINTK(\"overflow of indexes: dev %016llx phy 0x%x \"\n\t\t\t    \"index 0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, index);\n\t}\nout:\n\tkfree(cri_req);\n\tkfree(cri_resp);\n\treturn res;\n}\n\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t\t    u8 *sas_addr, int include)\n{\n\tint index;\n\tint present;\n\tint res;\n\n\tres = sas_configure_present(dev, phy_id, sas_addr, &index, &present);\n\tif (res)\n\t\treturn res;\n\tif (include ^ present)\n\t\treturn sas_configure_set(dev, phy_id, sas_addr, index,include);\n\n\treturn res;\n}\n\n/**\n * sas_configure_parent -- configure routing table of parent\n * parent: parent expander\n * child: child expander\n * sas_addr: SAS port identifier of device directly attached to child\n */\nstatic int sas_configure_parent(struct domain_device *parent,\n\t\t\t\tstruct domain_device *child,\n\t\t\t\tu8 *sas_addr, int include)\n{\n\tstruct expander_device *ex_parent = &parent->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tif (parent->parent) {\n\t\tres = sas_configure_parent(parent->parent, parent, sas_addr,\n\t\t\t\t\t   include);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (ex_parent->conf_route_table == 0) {\n\t\tSAS_DPRINTK(\"ex %016llx has self-configuring routing table\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr));\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ex_parent->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex_parent->ex_phy[i];\n\n\t\tif ((phy->routing_attr == TABLE_ROUTING) &&\n\t\t    (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t     SAS_ADDR(child->sas_addr))) {\n\t\t\tres = sas_configure_phy(parent, i, sas_addr, include);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/**\n * sas_configure_routing -- configure routing\n * dev: expander device\n * sas_addr: port identifier of device directly attached to the expander device\n */\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 1);\n\treturn 0;\n}\n\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 0);\n\treturn 0;\n}\n\n/**\n * sas_discover_expander -- expander discovery\n * @ex: pointer to expander domain device\n *\n * See comment in sas_discover_sata().\n */\nstatic int sas_discover_expander(struct domain_device *dev)\n{\n\tint res;\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\tres = sas_ex_general(dev);\n\tif (res)\n\t\tgoto out_err;\n\tres = sas_ex_manuf_info(dev);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = sas_expander_discover(dev);\n\tif (res) {\n\t\tSAS_DPRINTK(\"expander %016llx discovery failed(0x%x)\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out_err;\n\t}\n\n\tsas_check_ex_subtractive_boundary(dev);\n\tres = sas_check_parent_topology(dev);\n\tif (res)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\tsas_notify_lldd_dev_gone(dev);\n\treturn res;\n}\n\nstatic int sas_ex_level_discovery(struct asd_sas_port *port, const int level)\n{\n\tint res = 0;\n\tstruct domain_device *dev;\n\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(dev->rphy);\n\n\t\t\tif (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(dev, -1);\n\t\t\telse if (level > 0)\n\t\t\t\tres = sas_ex_discover_devices(port->port_dev, -1);\n\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int sas_ex_bfs_disc(struct asd_sas_port *port)\n{\n\tint res;\n\tint level;\n\n\tdo {\n\t\tlevel = port->disc.max_level;\n\t\tres = sas_ex_level_discovery(port, level);\n\t\tmb();\n\t} while (level < port->disc.max_level);\n\n\treturn res;\n}\n\nint sas_discover_root_expander(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\n\tres = sas_rphy_add(dev->rphy);\n\tif (res)\n\t\tgoto out_err;\n\n\tex->level = dev->port->disc.max_level; /* 0 */\n\tres = sas_discover_expander(dev);\n\tif (res)\n\t\tgoto out_err2;\n\n\tsas_ex_bfs_disc(dev->port);\n\n\treturn res;\n\nout_err2:\n\tsas_rphy_remove(dev->rphy);\nout_err:\n\treturn res;\n}\n\n/* ---------- Domain revalidation ---------- */\n\nstatic int sas_get_phy_discover(struct domain_device *dev,\n\t\t\t\tint phy_id, struct smp_resp *disc_resp)\n{\n\tint res;\n\tu8 *disc_req;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_req[1] = SMP_DISCOVER;\n\tdisc_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\telse if (disc_resp->result != SMP_RESP_FUNC_ACC) {\n\t\tres = disc_resp->result;\n\t\tgoto out;\n\t}\nout:\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_get_phy_change_count(struct domain_device *dev,\n\t\t\t\t    int phy_id, int *pcc)\n{\n\tint res;\n\tstruct smp_resp *disc_resp;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (!res)\n\t\t*pcc = disc_resp->disc.change_count;\n\n\tkfree(disc_resp);\n\treturn res;\n}\n\nstatic int sas_get_phy_attached_dev(struct domain_device *dev, int phy_id,\n\t\t\t\t    u8 *sas_addr, enum sas_device_type *type)\n{\n\tint res;\n\tstruct smp_resp *disc_resp;\n\tstruct discover_resp *dr;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\tdr = &disc_resp->disc;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (res == 0) {\n\t\tmemcpy(sas_addr, disc_resp->disc.attached_sas_addr, 8);\n\t\t*type = to_dev_type(dr);\n\t\tif (*type == 0)\n\t\t\tmemset(sas_addr, 0, 8);\n\t}\n\tkfree(disc_resp);\n\treturn res;\n}\n\nstatic int sas_find_bcast_phy(struct domain_device *dev, int *phy_id,\n\t\t\t      int from_phy, bool update)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tfor (i = from_phy; i < ex->num_phys; i++) {\n\t\tint phy_change_count = 0;\n\n\t\tres = sas_get_phy_change_count(dev, i, &phy_change_count);\n\t\tswitch (res) {\n\t\tcase SMP_RESP_PHY_VACANT:\n\t\tcase SMP_RESP_NO_PHY:\n\t\t\tcontinue;\n\t\tcase SMP_RESP_FUNC_ACC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\n\t\tif (phy_change_count != ex->ex_phy[i].phy_change_count) {\n\t\t\tif (update)\n\t\t\t\tex->ex_phy[i].phy_change_count =\n\t\t\t\t\tphy_change_count;\n\t\t\t*phy_id = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_get_ex_change_count(struct domain_device *dev, int *ecc)\n{\n\tint res;\n\tu8  *rg_req;\n\tstruct smp_resp  *rg_resp;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t       RG_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tif (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\tres = rg_resp->result;\n\t\tgoto out;\n\t}\n\n\t*ecc = be16_to_cpu(rg_resp->rg.change_count);\nout:\n\tkfree(rg_resp);\n\tkfree(rg_req);\n\treturn res;\n}\n/**\n * sas_find_bcast_dev -  find the device issue BROADCAST(CHANGE).\n * @dev:domain device to be detect.\n * @src_dev: the device which originated BROADCAST(CHANGE).\n *\n * Add self-configuration expander support. Suppose two expander cascading,\n * when the first level expander is self-configuring, hotplug the disks in\n * second level expander, BROADCAST(CHANGE) will not only be originated\n * in the second level expander, but also be originated in the first level\n * expander (see SAS protocol SAS 2r-14, 7.11 for detail), it is to say,\n * expander changed count in two level expanders will all increment at least\n * once, but the phy which chang count has changed is the source device which\n * we concerned.\n */\n\nstatic int sas_find_bcast_dev(struct domain_device *dev,\n\t\t\t      struct domain_device **src_dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint ex_change_count = -1;\n\tint phy_id = -1;\n\tint res;\n\tstruct domain_device *ch;\n\n\tres = sas_get_ex_change_count(dev, &ex_change_count);\n\tif (res)\n\t\tgoto out;\n\tif (ex_change_count != -1 && ex_change_count != ex->ex_change_count) {\n\t\t/* Just detect if this expander phys phy change count changed,\n\t\t* in order to determine if this expander originate BROADCAST,\n\t\t* and do not update phy change count field in our structure.\n\t\t*/\n\t\tres = sas_find_bcast_phy(dev, &phy_id, 0, false);\n\t\tif (phy_id != -1) {\n\t\t\t*src_dev = dev;\n\t\t\tex->ex_change_count = ex_change_count;\n\t\t\tSAS_DPRINTK(\"Expander phy change count has changed\\n\");\n\t\t\treturn res;\n\t\t} else\n\t\t\tSAS_DPRINTK(\"Expander phys DID NOT change\\n\");\n\t}\n\tlist_for_each_entry(ch, &ex->children, siblings) {\n\t\tif (ch->dev_type == SAS_EDGE_EXPANDER_DEVICE || ch->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tres = sas_find_bcast_dev(ch, src_dev);\n\t\t\tif (*src_dev)\n\t\t\t\treturn res;\n\t\t}\n\t}\nout:\n\treturn res;\n}\n\nstatic void sas_unregister_ex_tree(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child, *n;\n\n\tlist_for_each_entry_safe(child, n, &ex->children, siblings) {\n\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tsas_unregister_ex_tree(port, child);\n\t\telse\n\t\t\tsas_unregister_dev(port, child);\n\t}\n\tsas_unregister_dev(port, dev);\n}\n\nstatic void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t\t    SAS_ADDR(phy->attached_sas_addr)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tsas_port_delete(phy->port);\n\t\tphy->port = NULL;\n\t}\n}\n\nstatic int sas_discover_bfs_by_root_level(struct domain_device *root,\n\t\t\t\t\t  const int level)\n{\n\tstruct expander_device *ex_root = &root->ex_dev;\n\tstruct domain_device *child;\n\tint res = 0;\n\n\tlist_for_each_entry(child, &ex_root->children, siblings) {\n\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(child->rphy);\n\n\t\t\tif (level > ex->level)\n\t\t\t\tres = sas_discover_bfs_by_root_level(child,\n\t\t\t\t\t\t\t\t     level);\n\t\t\telse if (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(child, -1);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int sas_discover_bfs_by_root(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\tint level = ex->level+1;\n\n\tres = sas_ex_discover_devices(dev, -1);\n\tif (res)\n\t\tgoto out;\n\tdo {\n\t\tres = sas_discover_bfs_by_root_level(dev, level);\n\t\tmb();\n\t\tlevel += 1;\n\t} while (level <= dev->port->disc.max_level);\nout:\n\treturn res;\n}\n\nstatic int sas_discover_new(struct domain_device *dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child;\n\tint res;\n\n\tSAS_DPRINTK(\"ex %016llx phy%d new device attached\\n\",\n\t\t    SAS_ADDR(dev->sas_addr), phy_id);\n\tres = sas_ex_phy_discover(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\n\tif (sas_ex_join_wide_port(dev, phy_id))\n\t\treturn 0;\n\n\tres = sas_ex_discover_devices(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\tlist_for_each_entry(child, &dev->ex_dev.children, siblings) {\n\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t    SAS_ADDR(ex_phy->attached_sas_addr)) {\n\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\tres = sas_discover_bfs_by_root(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic bool dev_type_flutter(enum sas_device_type new, enum sas_device_type old)\n{\n\tif (old == new)\n\t\treturn true;\n\n\t/* treat device directed resets as flutter, if we went\n\t * SAS_END_DEVICE to SAS_SATA_PENDING the link needs recovery\n\t */\n\tif ((old == SAS_SATA_PENDING && new == SAS_END_DEVICE) ||\n\t    (old == SAS_END_DEVICE && new == SAS_SATA_PENDING))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sas_rediscover_dev(struct domain_device *dev, int phy_id, bool last)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tenum sas_device_type type = SAS_PHY_UNUSED;\n\tu8 sas_addr[8];\n\tint res;\n\n\tmemset(sas_addr, 0, 8);\n\tres = sas_get_phy_attached_dev(dev, phy_id, sas_addr, &type);\n\tswitch (res) {\n\tcase SMP_RESP_NO_PHY:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tbreak;\n\tcase -ECOMM:\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\tif ((SAS_ADDR(sas_addr) == 0) || (res == -ECOMM)) {\n\t\tphy->phy_state = PHY_EMPTY;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\t} else if (SAS_ADDR(sas_addr) == SAS_ADDR(phy->attached_sas_addr) &&\n\t\t   dev_type_flutter(type, phy->attached_dev_type)) {\n\t\tstruct domain_device *ata_dev = sas_ex_to_ata(dev, phy_id);\n\t\tchar *action = \"\";\n\n\t\tsas_ex_phy_discover(dev, phy_id);\n\n\t\tif (ata_dev && phy->attached_dev_type == SAS_SATA_PENDING)\n\t\t\taction = \", needs recovery\";\n\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x broadcast flutter%s\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, action);\n\t\treturn res;\n\t}\n\n\t/* delete the old link */\n\tif (SAS_ADDR(phy->attached_sas_addr) &&\n\t    SAS_ADDR(sas_addr) != SAS_ADDR(phy->attached_sas_addr)) {\n\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x replace %016llx\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id,\n\t\t\t    SAS_ADDR(phy->attached_sas_addr));\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t}\n\n\treturn sas_discover_new(dev, phy_id);\n}\n\n/**\n * sas_rediscover - revalidate the domain.\n * @dev:domain device to be detect.\n * @phy_id: the phy id will be detected.\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.For plugging out, we un-register the device only when it is\n * the last phy in the port, for other phys in this port, we just delete it\n * from the port.For inserting, we do discovery when it is the\n * first phy,for other phys in this port, we add it to the port to\n * forming the wide-port.\n */\nstatic int sas_rediscover(struct domain_device *dev, const int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *changed_phy = &ex->ex_phy[phy_id];\n\tint res = 0;\n\tint i;\n\tbool last = true;\t/* is this the last phy of the port */\n\n\tSAS_DPRINTK(\"ex %016llx phy%d originated BROADCAST(CHANGE)\\n\",\n\t\t    SAS_ADDR(dev->sas_addr), phy_id);\n\n\tif (SAS_ADDR(changed_phy->attached_sas_addr) != 0) {\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\t\tif (i == phy_id)\n\t\t\t\tcontinue;\n\t\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t\t    SAS_ADDR(changed_phy->attached_sas_addr)) {\n\t\t\t\tSAS_DPRINTK(\"phy%d part of wide port with \"\n\t\t\t\t\t    \"phy%d\\n\", phy_id, i);\n\t\t\t\tlast = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = sas_rediscover_dev(dev, phy_id, last);\n\t} else\n\t\tres = sas_discover_new(dev, phy_id);\n\treturn res;\n}\n\n/**\n * sas_revalidate_domain -- revalidate the domain\n * @port: port to the domain of interest\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.\n */\nint sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}\n\nvoid sas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy)\n{\n\tstruct domain_device *dev;\n\tunsigned int reslen = 0;\n\tint ret = -EINVAL;\n\n\t/* no rphy means no smp target support (ie aic94xx host) */\n\tif (!rphy)\n\t\treturn sas_smp_host_handler(job, shost);\n\n\tswitch (rphy->identify.device_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"%s: can we send a smp request to a device?\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\tif (!dev) {\n\t\tprintk(\"%s: fail to find a domain_device?\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t/* do we need to support multiple segments? */\n\tif (job->request_payload.sg_cnt > 1 ||\n\t    job->reply_payload.sg_cnt > 1) {\n\t\tprintk(\"%s: multiple segments req %u, rsp %u\\n\",\n\t\t       __func__, job->request_payload.payload_len,\n\t\t       job->reply_payload.payload_len);\n\t\tgoto out;\n\t}\n\n\tret = smp_execute_task_sg(dev, job->request_payload.sg_list,\n\t\t\tjob->reply_payload.sg_list);\n\tif (ret > 0) {\n\t\t/* positive number is the untransferred residual */\n\t\treslen = ret;\n\t\tret = 0;\n\t}\n\nout:\n\tbsg_job_done(job, ret, reslen);\n}\n"], "filenames": ["drivers/scsi/libsas/sas_expander.c"], "buggy_code_start_loc": [697], "buggy_code_end_loc": [697], "fixing_code_start_loc": [698], "fixing_code_end_loc": [699], "type": "CWE-772", "message": "Memory leak in the sas_smp_get_phy_events function in drivers/scsi/libsas/sas_expander.c in the Linux kernel through 4.15.7 allows local users to cause a denial of service (memory consumption) via many read accesses to files in the /sys/class/sas_phy directory, as demonstrated by the /sys/class/sas_phy/phy-1:0:12/invalid_dword_count file.", "other": {"cve": {"id": "CVE-2018-7757", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-08T14:29:00.567", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Memory leak in the sas_smp_get_phy_events function in drivers/scsi/libsas/sas_expander.c in the Linux kernel through 4.15.7 allows local users to cause a denial of service (memory consumption) via many read accesses to files in the /sys/class/sas_phy directory, as demonstrated by the /sys/class/sas_phy/phy-1:0:12/invalid_dword_count file."}, {"lang": "es", "value": "Filtrado de memoria en la funci\u00f3n sas_smp_get_phy_events en drivers/scsi/libsas/sas_expander.c en el kernel de Linux, hasta la versi\u00f3n 4.15.7, permite que usuarios locales provoquen una denegaci\u00f3n de servicio (consumo de memoria) mediante numerosos accesos de lectura a archivos en el directorio /sys/class/sas_phy, tal y como demuestra el archivo /sys/class/sas_phy/phy-1:0:12/invalid_dword_count."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.15.7", "matchCriteriaId": "87875BCC-05C4-4C72-AB6B-5FD9E4E74521"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=4a491b1ab11ca0556d2fda1ff1301e862a2d44c4", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/103348", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2948", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3083", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3096", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/05/msg00000.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3654-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3654-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3656-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3697-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3697-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3698-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3698-2/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4187", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4188", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4"}}