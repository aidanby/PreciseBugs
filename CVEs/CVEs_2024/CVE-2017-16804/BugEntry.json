{"buggy_code": ["# Redmine - project management software\n# Copyright (C) 2006-2016  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire 'roadie'\n\nclass Mailer < ActionMailer::Base\n  layout 'mailer'\n  helper :application\n  helper :issues\n  helper :custom_fields\n\n  include Redmine::I18n\n  include Roadie::Rails::Automatic\n\n  def self.default_url_options\n    options = {:protocol => Setting.protocol}\n    if Setting.host_name.to_s =~ /\\A(https?\\:\\/\\/)?(.+?)(\\:(\\d+))?(\\/.+)?\\z/i\n      host, port, prefix = $2, $4, $5\n      options.merge!({\n        :host => host, :port => port, :script_name => prefix\n      })\n    else\n      options[:host] = Setting.host_name\n    end\n    options\n  end\n\n  # Builds a mail for notifying to_users and cc_users about a new issue\n  def issue_add(issue, to_users, cc_users)\n    redmine_headers 'Project' => issue.project.identifier,\n                    'Issue-Id' => issue.id,\n                    'Issue-Author' => issue.author.login\n    redmine_headers 'Issue-Assignee' => issue.assigned_to.login if issue.assigned_to\n    message_id issue\n    references issue\n    @author = issue.author\n    @issue = issue\n    @users = to_users + cc_users\n    @issue_url = url_for(:controller => 'issues', :action => 'show', :id => issue)\n    mail :to => to_users,\n      :cc => cc_users,\n      :subject => \"[#{issue.project.name} - #{issue.tracker.name} ##{issue.id}] (#{issue.status.name}) #{issue.subject}\"\n  end\n\n  # Notifies users about a new issue\n  def self.deliver_issue_add(issue)\n    to = issue.notified_users\n    cc = issue.notified_watchers - to\n    issue.each_notification(to + cc) do |users|\n      Mailer.issue_add(issue, to & users, cc & users).deliver\n    end\n  end\n\n  # Builds a mail for notifying to_users and cc_users about an issue update\n  def issue_edit(journal, to_users, cc_users)\n    issue = journal.journalized\n    redmine_headers 'Project' => issue.project.identifier,\n                    'Issue-Id' => issue.id,\n                    'Issue-Author' => issue.author.login\n    redmine_headers 'Issue-Assignee' => issue.assigned_to.login if issue.assigned_to\n    message_id journal\n    references issue\n    @author = journal.user\n    s = \"[#{issue.project.name} - #{issue.tracker.name} ##{issue.id}] \"\n    s << \"(#{issue.status.name}) \" if journal.new_value_for('status_id')\n    s << issue.subject\n    @issue = issue\n    @users = to_users + cc_users\n    @journal = journal\n    @journal_details = journal.visible_details(@users.first)\n    @issue_url = url_for(:controller => 'issues', :action => 'show', :id => issue, :anchor => \"change-#{journal.id}\")\n    mail :to => to_users,\n      :cc => cc_users,\n      :subject => s\n  end\n\n  # Notifies users about an issue update\n  def self.deliver_issue_edit(journal)\n    issue = journal.journalized.reload\n    to = journal.notified_users\n    cc = journal.notified_watchers - to\n    journal.each_notification(to + cc) do |users|\n      issue.each_notification(users) do |users2|\n        Mailer.issue_edit(journal, to & users2, cc & users2).deliver\n      end\n    end\n  end\n\n  def reminder(user, issues, days)\n    set_language_if_valid user.language\n    @issues = issues\n    @days = days\n    @issues_url = url_for(:controller => 'issues', :action => 'index',\n                                :set_filter => 1, :assigned_to_id => user.id,\n                                :sort => 'due_date:asc')\n    mail :to => user,\n      :subject => l(:mail_subject_reminder, :count => issues.size, :days => days)\n  end\n\n  # Builds a Mail::Message object used to email users belonging to the added document's project.\n  #\n  # Example:\n  #   document_added(document) => Mail::Message object\n  #   Mailer.document_added(document).deliver => sends an email to the document's project recipients\n  def document_added(document)\n    redmine_headers 'Project' => document.project.identifier\n    @author = User.current\n    @document = document\n    @document_url = url_for(:controller => 'documents', :action => 'show', :id => document)\n    mail :to => document.notified_users,\n      :subject => \"[#{document.project.name}] #{l(:label_document_new)}: #{document.title}\"\n  end\n\n  # Builds a Mail::Message object used to email recipients of a project when an attachements are added.\n  #\n  # Example:\n  #   attachments_added(attachments) => Mail::Message object\n  #   Mailer.attachments_added(attachments).deliver => sends an email to the project's recipients\n  def attachments_added(attachments)\n    container = attachments.first.container\n    added_to = ''\n    added_to_url = ''\n    @author = attachments.first.author\n    case container.class.name\n    when 'Project'\n      added_to_url = url_for(:controller => 'files', :action => 'index', :project_id => container)\n      added_to = \"#{l(:label_project)}: #{container}\"\n      recipients = container.project.notified_users.select {|user| user.allowed_to?(:view_files, container.project)}\n    when 'Version'\n      added_to_url = url_for(:controller => 'files', :action => 'index', :project_id => container.project)\n      added_to = \"#{l(:label_version)}: #{container.name}\"\n      recipients = container.project.notified_users.select {|user| user.allowed_to?(:view_files, container.project)}\n    when 'Document'\n      added_to_url = url_for(:controller => 'documents', :action => 'show', :id => container.id)\n      added_to = \"#{l(:label_document)}: #{container.title}\"\n      recipients = container.notified_users\n    end\n    redmine_headers 'Project' => container.project.identifier\n    @attachments = attachments\n    @added_to = added_to\n    @added_to_url = added_to_url\n    mail :to => recipients,\n      :subject => \"[#{container.project.name}] #{l(:label_attachment_new)}\"\n  end\n\n  # Builds a Mail::Message object used to email recipients of a news' project when a news item is added.\n  #\n  # Example:\n  #   news_added(news) => Mail::Message object\n  #   Mailer.news_added(news).deliver => sends an email to the news' project recipients\n  def news_added(news)\n    redmine_headers 'Project' => news.project.identifier\n    @author = news.author\n    message_id news\n    references news\n    @news = news\n    @news_url = url_for(:controller => 'news', :action => 'show', :id => news)\n    mail :to => news.notified_users,\n      :cc => news.notified_watchers_for_added_news,\n      :subject => \"[#{news.project.name}] #{l(:label_news)}: #{news.title}\"\n  end\n\n  # Builds a Mail::Message object used to email recipients of a news' project when a news comment is added.\n  #\n  # Example:\n  #   news_comment_added(comment) => Mail::Message object\n  #   Mailer.news_comment_added(comment) => sends an email to the news' project recipients\n  def news_comment_added(comment)\n    news = comment.commented\n    redmine_headers 'Project' => news.project.identifier\n    @author = comment.author\n    message_id comment\n    references news\n    @news = news\n    @comment = comment\n    @news_url = url_for(:controller => 'news', :action => 'show', :id => news)\n    mail :to => news.notified_users,\n     :cc => news.notified_watchers,\n     :subject => \"Re: [#{news.project.name}] #{l(:label_news)}: #{news.title}\"\n  end\n\n  # Builds a Mail::Message object used to email the recipients of the specified message that was posted.\n  #\n  # Example:\n  #   message_posted(message) => Mail::Message object\n  #   Mailer.message_posted(message).deliver => sends an email to the recipients\n  def message_posted(message)\n    redmine_headers 'Project' => message.project.identifier,\n                    'Topic-Id' => (message.parent_id || message.id)\n    @author = message.author\n    message_id message\n    references message.root\n    recipients = message.notified_users\n    cc = ((message.root.notified_watchers + message.board.notified_watchers).uniq - recipients)\n    @message = message\n    @message_url = url_for(message.event_url)\n    mail :to => recipients,\n      :cc => cc,\n      :subject => \"[#{message.board.project.name} - #{message.board.name} - msg#{message.root.id}] #{message.subject}\"\n  end\n\n  # Builds a Mail::Message object used to email the recipients of a project of the specified wiki content was added.\n  #\n  # Example:\n  #   wiki_content_added(wiki_content) => Mail::Message object\n  #   Mailer.wiki_content_added(wiki_content).deliver => sends an email to the project's recipients\n  def wiki_content_added(wiki_content)\n    redmine_headers 'Project' => wiki_content.project.identifier,\n                    'Wiki-Page-Id' => wiki_content.page.id\n    @author = wiki_content.author\n    message_id wiki_content\n    recipients = wiki_content.notified_users\n    cc = wiki_content.page.wiki.notified_watchers - recipients\n    @wiki_content = wiki_content\n    @wiki_content_url = url_for(:controller => 'wiki', :action => 'show',\n                                      :project_id => wiki_content.project,\n                                      :id => wiki_content.page.title)\n    mail :to => recipients,\n      :cc => cc,\n      :subject => \"[#{wiki_content.project.name}] #{l(:mail_subject_wiki_content_added, :id => wiki_content.page.pretty_title)}\"\n  end\n\n  # Builds a Mail::Message object used to email the recipients of a project of the specified wiki content was updated.\n  #\n  # Example:\n  #   wiki_content_updated(wiki_content) => Mail::Message object\n  #   Mailer.wiki_content_updated(wiki_content).deliver => sends an email to the project's recipients\n  def wiki_content_updated(wiki_content)\n    redmine_headers 'Project' => wiki_content.project.identifier,\n                    'Wiki-Page-Id' => wiki_content.page.id\n    @author = wiki_content.author\n    message_id wiki_content\n    recipients = wiki_content.notified_users\n    cc = wiki_content.page.wiki.notified_watchers + wiki_content.page.notified_watchers - recipients\n    @wiki_content = wiki_content\n    @wiki_content_url = url_for(:controller => 'wiki', :action => 'show',\n                                      :project_id => wiki_content.project,\n                                      :id => wiki_content.page.title)\n    @wiki_diff_url = url_for(:controller => 'wiki', :action => 'diff',\n                                   :project_id => wiki_content.project, :id => wiki_content.page.title,\n                                   :version => wiki_content.version)\n    mail :to => recipients,\n      :cc => cc,\n      :subject => \"[#{wiki_content.project.name}] #{l(:mail_subject_wiki_content_updated, :id => wiki_content.page.pretty_title)}\"\n  end\n\n  # Builds a Mail::Message object used to email the specified user their account information.\n  #\n  # Example:\n  #   account_information(user, password) => Mail::Message object\n  #   Mailer.account_information(user, password).deliver => sends account information to the user\n  def account_information(user, password)\n    set_language_if_valid user.language\n    @user = user\n    @password = password\n    @login_url = url_for(:controller => 'account', :action => 'login')\n    mail :to => user.mail,\n      :subject => l(:mail_subject_register, Setting.app_title)\n  end\n\n  # Builds a Mail::Message object used to email all active administrators of an account activation request.\n  #\n  # Example:\n  #   account_activation_request(user) => Mail::Message object\n  #   Mailer.account_activation_request(user).deliver => sends an email to all active administrators\n  def account_activation_request(user)\n    # Send the email to all active administrators\n    recipients = User.active.where(:admin => true)\n    @user = user\n    @url = url_for(:controller => 'users', :action => 'index',\n                         :status => User::STATUS_REGISTERED,\n                         :sort_key => 'created_on', :sort_order => 'desc')\n    mail :to => recipients,\n      :subject => l(:mail_subject_account_activation_request, Setting.app_title)\n  end\n\n  # Builds a Mail::Message object used to email the specified user that their account was activated by an administrator.\n  #\n  # Example:\n  #   account_activated(user) => Mail::Message object\n  #   Mailer.account_activated(user).deliver => sends an email to the registered user\n  def account_activated(user)\n    set_language_if_valid user.language\n    @user = user\n    @login_url = url_for(:controller => 'account', :action => 'login')\n    mail :to => user.mail,\n      :subject => l(:mail_subject_register, Setting.app_title)\n  end\n\n  def lost_password(token, recipient=nil)\n    set_language_if_valid(token.user.language)\n    recipient ||= token.user.mail\n    @token = token\n    @url = url_for(:controller => 'account', :action => 'lost_password', :token => token.value)\n    mail :to => recipient,\n      :subject => l(:mail_subject_lost_password, Setting.app_title)\n  end\n\n  # Notifies user that his password was updated\n  def self.password_updated(user)\n    # Don't send a notification to the dummy email address when changing the password\n    # of the default admin account which is required after the first login\n    # TODO: maybe not the best way to handle this\n    return if user.admin? && user.login == 'admin' && user.mail == 'admin@example.net'\n\n    Mailer.security_notification(user,\n      message: :mail_body_password_updated,\n      title: :button_change_password,\n      url: {controller: 'my', action: 'password'}\n    ).deliver\n  end\n\n  def register(token)\n    set_language_if_valid(token.user.language)\n    @token = token\n    @url = url_for(:controller => 'account', :action => 'activate', :token => token.value)\n    mail :to => token.user.mail,\n      :subject => l(:mail_subject_register, Setting.app_title)\n  end\n\n  def security_notification(recipients, options={})\n    redmine_headers 'Sender' => User.current.login\n    @user = Array(recipients).detect{|r| r.is_a? User }\n    set_language_if_valid(@user.try :language)\n    @message = l(options[:message],\n      field: (options[:field] && l(options[:field])),\n      value: options[:value]\n    )\n    @title = options[:title] && l(options[:title])\n    @url = options[:url] && (options[:url].is_a?(Hash) ? url_for(options[:url]) : options[:url])\n    mail :to => recipients,\n      :subject => \"[#{Setting.app_title}] #{l(:mail_subject_security_notification)}\"\n  end\n\n  def settings_updated(recipients, changes)\n    redmine_headers 'Sender' => User.current.login\n    @changes = changes\n    @url = url_for(controller: 'settings', action: 'index')\n    mail :to => recipients,\n      :subject => \"[#{Setting.app_title}] #{l(:mail_subject_security_notification)}\"\n  end\n\n\t# Notifies admins about settings changes\n  def self.security_settings_updated(changes)\n    return unless changes.present?\n\n    users = User.active.where(admin: true).to_a\n    Mailer.settings_updated(users, changes).deliver\n  end\n\n  def test_email(user)\n    set_language_if_valid(user.language)\n    @url = url_for(:controller => 'welcome')\n    mail :to => user.mail,\n      :subject => 'Redmine test'\n  end\n\n  # Sends reminders to issue assignees\n  # Available options:\n  # * :days     => how many days in the future to remind about (defaults to 7)\n  # * :tracker  => id of tracker for filtering issues (defaults to all trackers)\n  # * :project  => id or identifier of project to process (defaults to all projects)\n  # * :users    => array of user/group ids who should be reminded\n  # * :version  => name of target version for filtering issues (defaults to none)\n  def self.reminders(options={})\n    days = options[:days] || 7\n    project = options[:project] ? Project.find(options[:project]) : nil\n    tracker = options[:tracker] ? Tracker.find(options[:tracker]) : nil\n    target_version_id = options[:version] ? Version.named(options[:version]).pluck(:id) : nil\n    if options[:version] && target_version_id.blank?\n      raise ActiveRecord::RecordNotFound.new(\"Couldn't find Version with named #{options[:version]}\")\n    end\n    user_ids = options[:users]\n\n    scope = Issue.open.where(\"#{Issue.table_name}.assigned_to_id IS NOT NULL\" +\n      \" AND #{Project.table_name}.status = #{Project::STATUS_ACTIVE}\" +\n      \" AND #{Issue.table_name}.due_date <= ?\", days.day.from_now.to_date\n    )\n    scope = scope.where(:assigned_to_id => user_ids) if user_ids.present?\n    scope = scope.where(:project_id => project.id) if project\n    scope = scope.where(:fixed_version_id => target_version_id) if target_version_id.present?\n    scope = scope.where(:tracker_id => tracker.id) if tracker\n    issues_by_assignee = scope.includes(:status, :assigned_to, :project, :tracker).\n                              group_by(&:assigned_to)\n    issues_by_assignee.keys.each do |assignee|\n      if assignee.is_a?(Group)\n        assignee.users.each do |user|\n          issues_by_assignee[user] ||= []\n          issues_by_assignee[user] += issues_by_assignee[assignee]\n        end\n      end\n    end\n\n    issues_by_assignee.each do |assignee, issues|\n      reminder(assignee, issues, days).deliver if assignee.is_a?(User) && assignee.active?\n    end\n  end\n\n  # Activates/desactivates email deliveries during +block+\n  def self.with_deliveries(enabled = true, &block)\n    was_enabled = ActionMailer::Base.perform_deliveries\n    ActionMailer::Base.perform_deliveries = !!enabled\n    yield\n  ensure\n    ActionMailer::Base.perform_deliveries = was_enabled\n  end\n\n  # Sends emails synchronously in the given block\n  def self.with_synched_deliveries(&block)\n    saved_method = ActionMailer::Base.delivery_method\n    if m = saved_method.to_s.match(%r{^async_(.+)$})\n      synched_method = m[1]\n      ActionMailer::Base.delivery_method = synched_method.to_sym\n      ActionMailer::Base.send \"#{synched_method}_settings=\", ActionMailer::Base.send(\"async_#{synched_method}_settings\")\n    end\n    yield\n  ensure\n    ActionMailer::Base.delivery_method = saved_method\n  end\n\n  def mail(headers={}, &block)\n    headers.reverse_merge! 'X-Mailer' => 'Redmine',\n            'X-Redmine-Host' => Setting.host_name,\n            'X-Redmine-Site' => Setting.app_title,\n            'X-Auto-Response-Suppress' => 'All',\n            'Auto-Submitted' => 'auto-generated',\n            'From' => Setting.mail_from,\n            'List-Id' => \"<#{Setting.mail_from.to_s.gsub('@', '.')}>\"\n\n    # Replaces users with their email addresses\n    [:to, :cc, :bcc].each do |key|\n      if headers[key].present?\n        headers[key] = self.class.email_addresses(headers[key])\n      end\n    end\n\n    # Removes the author from the recipients and cc\n    # if the author does not want to receive notifications\n    # about what the author do\n    if @author && @author.logged? && @author.pref.no_self_notified\n      addresses = @author.mails\n      headers[:to] -= addresses if headers[:to].is_a?(Array)\n      headers[:cc] -= addresses if headers[:cc].is_a?(Array)\n    end\n\n    if @author && @author.logged?\n      redmine_headers 'Sender' => @author.login\n    end\n\n    # Blind carbon copy recipients\n    if Setting.bcc_recipients?\n      headers[:bcc] = [headers[:to], headers[:cc]].flatten.uniq.reject(&:blank?)\n      headers[:to] = nil\n      headers[:cc] = nil\n    end\n\n    if @message_id_object\n      headers[:message_id] = \"<#{self.class.message_id_for(@message_id_object)}>\"\n    end\n    if @references_objects\n      headers[:references] = @references_objects.collect {|o| \"<#{self.class.references_for(o)}>\"}.join(' ')\n    end\n\n    m = if block_given?\n      super headers, &block\n    else\n      super headers do |format|\n        format.text\n        format.html unless Setting.plain_text_mail?\n      end\n    end\n    set_language_if_valid @initial_language\n\n    m\n  end\n\n  def initialize(*args)\n    @initial_language = current_language\n    set_language_if_valid Setting.default_language\n    super\n  end\n\n  def self.deliver_mail(mail)\n    return false if mail.to.blank? && mail.cc.blank? && mail.bcc.blank?\n    begin\n      # Log errors when raise_delivery_errors is set to false, Rails does not\n      mail.raise_delivery_errors = true\n      super\n    rescue Exception => e\n      if ActionMailer::Base.raise_delivery_errors\n        raise e\n      else\n        Rails.logger.error \"Email delivery error: #{e.message}\"\n      end\n    end\n  end\n\n  def self.method_missing(method, *args, &block)\n    if m = method.to_s.match(%r{^deliver_(.+)$})\n      ActiveSupport::Deprecation.warn \"Mailer.deliver_#{m[1]}(*args) is deprecated. Use Mailer.#{m[1]}(*args).deliver instead.\"\n      send(m[1], *args).deliver\n    else\n      super\n    end\n  end\n\n  # Returns an array of email addresses to notify by\n  # replacing users in arg with their notified email addresses\n  #\n  # Example:\n  #   Mailer.email_addresses(users)\n  #   => [\"foo@example.net\", \"bar@example.net\"]\n  def self.email_addresses(arg)\n    arr = Array.wrap(arg)\n    mails = arr.reject {|a| a.is_a? Principal}\n    users = arr - mails\n    if users.any?\n      mails += EmailAddress.\n        where(:user_id => users.map(&:id)).\n        where(\"is_default = ? OR notify = ?\", true, true).\n        pluck(:address)\n    end\n    mails\n  end\n\n  private\n\n  # Appends a Redmine header field (name is prepended with 'X-Redmine-')\n  def redmine_headers(h)\n    h.each { |k,v| headers[\"X-Redmine-#{k}\"] = v.to_s }\n  end\n\n  def self.token_for(object, rand=true)\n    timestamp = object.send(object.respond_to?(:created_on) ? :created_on : :updated_on)\n    hash = [\n      \"redmine\",\n      \"#{object.class.name.demodulize.underscore}-#{object.id}\",\n      timestamp.strftime(\"%Y%m%d%H%M%S\")\n    ]\n    if rand\n      hash << Redmine::Utils.random_hex(8)\n    end\n    host = Setting.mail_from.to_s.strip.gsub(%r{^.*@|>}, '')\n    host = \"#{::Socket.gethostname}.redmine\" if host.empty?\n    \"#{hash.join('.')}@#{host}\"\n  end\n\n  # Returns a Message-Id for the given object\n  def self.message_id_for(object)\n    token_for(object, true)\n  end\n\n  # Returns a uniq token for a given object referenced by all notifications\n  # related to this object\n  def self.references_for(object)\n    token_for(object, false)\n  end\n\n  def message_id(object)\n    @message_id_object = object\n  end\n\n  def references(object)\n    @references_objects ||= []\n    @references_objects << object\n  end\n\n  def mylogger\n    Rails.logger\n  end\nend\n", "# Redmine - project management software\n# Copyright (C) 2006-2016  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire File.expand_path('../../test_helper', __FILE__)\n\nclass MailerTest < ActiveSupport::TestCase\n  include Redmine::I18n\n  include Rails::Dom::Testing::Assertions\n  fixtures :projects, :enabled_modules, :issues, :users, :email_addresses, :user_preferences, :members,\n           :member_roles, :roles, :documents, :attachments, :news,\n           :tokens, :journals, :journal_details, :changesets,\n           :trackers, :projects_trackers,\n           :issue_statuses, :enumerations, :messages, :boards, :repositories,\n           :wikis, :wiki_pages, :wiki_contents, :wiki_content_versions,\n           :versions,\n           :comments\n\n  def setup\n    ActionMailer::Base.deliveries.clear\n    Setting.plain_text_mail = '0'\n    Setting.default_language = 'en'\n    User.current = nil\n  end\n\n  def test_generated_links_in_emails\n    with_settings :host_name => 'mydomain.foo', :protocol => 'https' do\n      journal = Journal.find(3)\n      assert Mailer.deliver_issue_edit(journal)\n    end\n    mail = last_email\n    assert_not_nil mail\n\n    assert_select_email do\n      # link to the main ticket on issue id\n      assert_select 'a[href=?]',\n                    'https://mydomain.foo/issues/2#change-3',\n                    :text => '#2'\n      # link to the main ticket\n      assert_select 'a[href=?]',\n                    'https://mydomain.foo/issues/2#change-3',\n                    :text => 'Feature request #2: Add ingredients categories'\n      # link to a referenced ticket\n      assert_select 'a[href=?][title=?]',\n                    'https://mydomain.foo/issues/1',\n                    \"Bug: Cannot print recipes (New)\",\n                    :text => '#1'\n      # link to a changeset\n      assert_select 'a[href=?][title=?]',\n                    'https://mydomain.foo/projects/ecookbook/repository/revisions/2',\n                    'This commit fixes #1, #2 and references #1 & #3',\n                    :text => 'r2'\n      # link to a description diff\n      assert_select 'a[href^=?][title=?]',\n                    # should be https://mydomain.foo/journals/diff/3?detail_id=4\n                    # but the Rails 4.2 DOM assertion doesn't handle the ? in the\n                    # attribute value\n                    'https://mydomain.foo/journals/3/diff',\n                    'View differences',\n                    :text => 'diff'\n      # link to an attachment\n      assert_select 'a[href=?]',\n                    'https://mydomain.foo/attachments/download/4/source.rb',\n                    :text => 'source.rb'\n    end\n  end\n\n  def test_generated_links_with_prefix\n    relative_url_root = Redmine::Utils.relative_url_root\n    with_settings :host_name => 'mydomain.foo/rdm', :protocol => 'http' do\n      journal = Journal.find(3)\n      assert Mailer.deliver_issue_edit(journal)\n    end\n\n    mail = last_email\n    assert_not_nil mail\n\n    assert_select_email do\n      # link to the main ticket\n      assert_select 'a[href=?]',\n                    'http://mydomain.foo/rdm/issues/2#change-3',\n                    :text => 'Feature request #2: Add ingredients categories'\n      # link to a referenced ticket\n      assert_select 'a[href=?][title=?]',\n                    'http://mydomain.foo/rdm/issues/1',\n                    \"Bug: Cannot print recipes (New)\",\n                    :text => '#1'\n      # link to a changeset\n      assert_select 'a[href=?][title=?]',\n                    'http://mydomain.foo/rdm/projects/ecookbook/repository/revisions/2',\n                    'This commit fixes #1, #2 and references #1 & #3',\n                    :text => 'r2'\n      # link to a description diff\n      assert_select 'a[href^=?][title=?]',\n                    # should be http://mydomain.foo/rdm/journals/diff/3?detail_id=4\n                    # but the Rails 4.2 DOM assertion doesn't handle the ? in the\n                    # attribute value\n                    'http://mydomain.foo/rdm/journals/3/diff',\n                    'View differences',\n                    :text => 'diff'\n      # link to an attachment\n      assert_select 'a[href=?]',\n                    'http://mydomain.foo/rdm/attachments/download/4/source.rb',\n                    :text => 'source.rb'\n    end\n  end\n\n  def test_generated_links_with_port_and_prefix\n    with_settings :host_name => '10.0.0.1:81/redmine', :protocol => 'http' do\n      Mailer.test_email(User.find(1)).deliver\n      mail = last_email\n      assert_not_nil mail\n      assert_include 'http://10.0.0.1:81/redmine', mail_body(mail)\n    end\n  end\n\n  def test_generated_links_with_port\n    with_settings :host_name => '10.0.0.1:81', :protocol => 'http' do\n      Mailer.test_email(User.find(1)).deliver\n      mail = last_email\n      assert_not_nil mail\n      assert_include 'http://10.0.0.1:81', mail_body(mail)\n    end\n  end\n\n  def test_issue_edit_should_generate_url_with_hostname_for_relations\n    journal = Journal.new(:journalized => Issue.find(1), :user => User.find(1), :created_on => Time.now)\n    journal.details << JournalDetail.new(:property => 'relation', :prop_key => 'label_relates_to', :value => 2)\n    Mailer.deliver_issue_edit(journal)\n    assert_not_nil last_email\n    assert_select_email do\n      assert_select 'a[href=?]', 'http://localhost:3000/issues/2', :text => 'Feature request #2'\n    end\n  end\n\n  def test_generated_links_with_prefix_and_no_relative_url_root\n    relative_url_root = Redmine::Utils.relative_url_root\n    Redmine::Utils.relative_url_root = nil\n\n    with_settings :host_name => 'mydomain.foo/rdm', :protocol => 'http' do\n      journal = Journal.find(3)\n      assert Mailer.deliver_issue_edit(journal)\n    end\n\n    mail = last_email\n    assert_not_nil mail\n\n    assert_select_email do\n      # link to the main ticket\n      assert_select 'a[href=?]',\n                    'http://mydomain.foo/rdm/issues/2#change-3',\n                    :text => 'Feature request #2: Add ingredients categories'\n      # link to a referenced ticket\n      assert_select 'a[href=?][title=?]',\n                    'http://mydomain.foo/rdm/issues/1',\n                    \"Bug: Cannot print recipes (New)\",\n                    :text => '#1'\n      # link to a changeset\n      assert_select 'a[href=?][title=?]',\n                    'http://mydomain.foo/rdm/projects/ecookbook/repository/revisions/2',\n                    'This commit fixes #1, #2 and references #1 & #3',\n                    :text => 'r2'\n      # link to a description diff\n      assert_select 'a[href^=?][title=?]',\n                    # should be http://mydomain.foo/rdm/journals/diff/3?detail_id=4\n                    # but the Rails 4.2 DOM assertion doesn't handle the ? in the\n                    # attribute value\n                    'http://mydomain.foo/rdm/journals/3/diff',\n                    'View differences',\n                    :text => 'diff'\n      # link to an attachment\n      assert_select 'a[href=?]',\n                    'http://mydomain.foo/rdm/attachments/download/4/source.rb',\n                    :text => 'source.rb'\n    end\n  ensure\n    # restore it\n    Redmine::Utils.relative_url_root = relative_url_root\n  end\n\n  def test_email_headers\n    issue = Issue.find(1)\n    Mailer.deliver_issue_add(issue)\n    mail = last_email\n    assert_not_nil mail\n    assert_equal 'All', mail.header['X-Auto-Response-Suppress'].to_s\n    assert_equal 'auto-generated', mail.header['Auto-Submitted'].to_s\n    assert_equal '<redmine.example.net>', mail.header['List-Id'].to_s\n  end\n\n  def test_email_headers_should_include_sender\n    issue = Issue.find(1)\n    Mailer.deliver_issue_add(issue)\n    mail = last_email\n    assert_equal issue.author.login, mail.header['X-Redmine-Sender'].to_s\n  end\n\n  def test_plain_text_mail\n    Setting.plain_text_mail = 1\n    journal = Journal.find(2)\n    Mailer.deliver_issue_edit(journal)\n    mail = last_email\n    assert_equal \"text/plain; charset=UTF-8\", mail.content_type\n    assert_equal 0, mail.parts.size\n    assert !mail.encoded.include?('href')\n  end\n\n  def test_html_mail\n    Setting.plain_text_mail = 0\n    journal = Journal.find(2)\n    Mailer.deliver_issue_edit(journal)\n    mail = last_email\n    assert_equal 2, mail.parts.size\n    assert mail.encoded.include?('href')\n  end\n\n  def test_from_header\n    with_settings :mail_from => 'redmine@example.net' do\n      Mailer.test_email(User.find(1)).deliver\n    end\n    mail = last_email\n    assert_equal 'redmine@example.net', mail.from_addrs.first\n  end\n\n  def test_from_header_with_phrase\n    with_settings :mail_from => 'Redmine app <redmine@example.net>' do\n      Mailer.test_email(User.find(1)).deliver\n    end\n    mail = last_email\n    assert_equal 'redmine@example.net', mail.from_addrs.first\n    assert_equal 'Redmine app <redmine@example.net>', mail.header['From'].to_s\n  end\n\n  def test_should_not_send_email_without_recipient\n    news = News.first\n    user = news.author\n    # Remove members except news author\n    news.project.memberships.each {|m| m.destroy unless m.user == user}\n\n    user.pref.no_self_notified = false\n    user.pref.save\n    User.current = user\n    Mailer.news_added(news.reload).deliver\n    assert_equal 1, last_email.bcc.size\n\n    # nobody to notify\n    user.pref.no_self_notified = true\n    user.pref.save\n    User.current = user\n    ActionMailer::Base.deliveries.clear\n    Mailer.news_added(news.reload).deliver\n    assert ActionMailer::Base.deliveries.empty?\n  end\n\n  def test_issue_add_message_id\n    issue = Issue.find(2)\n    Mailer.deliver_issue_add(issue)\n    mail = last_email\n    assert_match /^redmine\\.issue-2\\.20060719190421\\.[a-f0-9]+@example\\.net/, mail.message_id\n    assert_include \"redmine.issue-2.20060719190421@example.net\", mail.references\n  end\n\n  def test_issue_edit_message_id\n    journal = Journal.find(3)\n    journal.issue = Issue.find(2)\n\n    Mailer.deliver_issue_edit(journal)\n    mail = last_email\n    assert_match /^redmine\\.journal-3\\.\\d+\\.[a-f0-9]+@example\\.net/, mail.message_id\n    assert_include \"redmine.issue-2.20060719190421@example.net\", mail.references\n    assert_select_email do\n      # link to the update\n      assert_select \"a[href=?]\",\n                    \"http://localhost:3000/issues/#{journal.journalized_id}#change-#{journal.id}\"\n    end\n  end\n\n  def test_message_posted_message_id\n    message = Message.find(1)\n    Mailer.message_posted(message).deliver\n    mail = last_email\n    assert_match /^redmine\\.message-1\\.\\d+\\.[a-f0-9]+@example\\.net/, mail.message_id\n    assert_include \"redmine.message-1.20070512151532@example.net\", mail.references\n    assert_select_email do\n      # link to the message\n      assert_select \"a[href=?]\",\n                    \"http://localhost:3000/boards/#{message.board.id}/topics/#{message.id}\",\n                    :text => message.subject\n    end\n  end\n\n  def test_reply_posted_message_id\n    message = Message.find(3)\n    Mailer.message_posted(message).deliver\n    mail = last_email\n    assert_match /^redmine\\.message-3\\.\\d+\\.[a-f0-9]+@example\\.net/, mail.message_id\n    assert_include \"redmine.message-1.20070512151532@example.net\", mail.references\n    assert_select_email do\n      # link to the reply\n      assert_select \"a[href=?]\",\n                    \"http://localhost:3000/boards/#{message.board.id}/topics/#{message.root.id}?r=#{message.id}#message-#{message.id}\",\n                    :text => message.subject\n    end\n  end\n\n  test \"#issue_add should notify project members\" do\n    issue = Issue.find(1)\n    assert Mailer.deliver_issue_add(issue)\n    assert last_email.bcc.include?('dlopper@somenet.foo')\n  end\n\n  def test_issue_add_should_send_mail_to_all_user_email_address\n    EmailAddress.create!(:user_id => 3, :address => 'otheremail@somenet.foo')\n    issue = Issue.find(1)\n    assert Mailer.deliver_issue_add(issue)\n    assert last_email.bcc.include?('dlopper@somenet.foo')\n    assert last_email.bcc.include?('otheremail@somenet.foo')\n  end\n\n  test \"#issue_add should not notify project members that are not allow to view the issue\" do\n    issue = Issue.find(1)\n    Role.find(2).remove_permission!(:view_issues)\n    assert Mailer.deliver_issue_add(issue)\n    assert !last_email.bcc.include?('dlopper@somenet.foo')\n  end\n\n  test \"#issue_add should notify issue watchers\" do\n    issue = Issue.find(1)\n    user = User.find(9)\n    # minimal email notification options\n    user.pref.no_self_notified = '1'\n    user.pref.save\n    user.mail_notification = false\n    user.save\n\n    Watcher.create!(:watchable => issue, :user => user)\n    assert Mailer.deliver_issue_add(issue)\n    assert last_email.bcc.include?(user.mail)\n  end\n\n  test \"#issue_add should not notify watchers not allowed to view the issue\" do\n    issue = Issue.find(1)\n    user = User.find(9)\n    Watcher.create!(:watchable => issue, :user => user)\n    Role.non_member.remove_permission!(:view_issues)\n    assert Mailer.deliver_issue_add(issue)\n    assert !last_email.bcc.include?(user.mail)\n  end\n\n  def test_issue_add_should_include_enabled_fields\n    issue = Issue.find(2)\n    assert Mailer.deliver_issue_add(issue)\n    assert_mail_body_match '* Target version: 1.0', last_email\n    assert_select_email do\n      assert_select 'li', :text => 'Target version: 1.0'\n    end\n  end\n\n  def test_issue_add_should_not_include_disabled_fields\n    issue = Issue.find(2)\n    tracker = issue.tracker\n    tracker.core_fields -= ['fixed_version_id']\n    tracker.save!\n    assert Mailer.deliver_issue_add(issue)\n    assert_mail_body_no_match 'Target version', last_email\n    assert_select_email do\n      assert_select 'li', :text => /Target version/, :count => 0\n    end\n  end\n\n  # test mailer methods for each language\n  def test_issue_add\n    issue = Issue.find(1)\n    with_each_language_as_default do\n      assert Mailer.deliver_issue_add(issue)\n    end\n  end\n\n  def test_issue_edit\n    journal = Journal.find(1)\n    with_each_language_as_default do\n      assert Mailer.deliver_issue_edit(journal)\n    end\n  end\n\n  def test_issue_edit_should_send_private_notes_to_users_with_permission_only\n    journal = Journal.find(1)\n    journal.private_notes = true\n    journal.save!\n\n    Role.find(2).add_permission! :view_private_notes\n    Mailer.deliver_issue_edit(journal)\n    assert_equal %w(dlopper@somenet.foo jsmith@somenet.foo), ActionMailer::Base.deliveries.last.bcc.sort\n\n    Role.find(2).remove_permission! :view_private_notes\n    Mailer.deliver_issue_edit(journal)\n    assert_equal %w(jsmith@somenet.foo), ActionMailer::Base.deliveries.last.bcc.sort\n  end\n\n  def test_issue_edit_should_send_private_notes_to_watchers_with_permission_only\n    Issue.find(1).set_watcher(User.find_by_login('someone'))\n    journal = Journal.find(1)\n    journal.private_notes = true\n    journal.save!\n\n    Role.non_member.add_permission! :view_private_notes\n    Mailer.deliver_issue_edit(journal)\n    assert_include 'someone@foo.bar', ActionMailer::Base.deliveries.last.bcc.sort\n\n    Role.non_member.remove_permission! :view_private_notes\n    Mailer.deliver_issue_edit(journal)\n    assert_not_include 'someone@foo.bar', ActionMailer::Base.deliveries.last.bcc.sort\n  end\n\n  def test_issue_edit_should_mark_private_notes\n    journal = Journal.find(2)\n    journal.private_notes = true\n    journal.save!\n\n    with_settings :default_language => 'en' do\n      Mailer.deliver_issue_edit(journal)\n    end\n    assert_mail_body_match '(Private notes)', last_email\n  end\n\n  def test_issue_edit_with_relation_should_notify_users_who_can_see_the_related_issue\n    issue = Issue.generate!\n    issue.init_journal(User.find(1))\n    private_issue = Issue.generate!(:is_private => true)\n    IssueRelation.create!(:issue_from => issue, :issue_to => private_issue, :relation_type => 'relates')\n    issue.reload\n    assert_equal 1, issue.journals.size\n    journal = issue.journals.first\n    ActionMailer::Base.deliveries.clear\n\n    Mailer.deliver_issue_edit(journal)\n    last_email.bcc.each do |email|\n      user = User.find_by_mail(email)\n      assert private_issue.visible?(user), \"Issue was not visible to #{user}\"\n    end\n  end\n\n  def test_document_added\n    document = Document.find(1)\n    with_each_language_as_default do\n      assert Mailer.document_added(document).deliver\n    end\n  end\n\n  def test_attachments_added\n    attachements = [ Attachment.find_by_container_type('Document') ]\n    with_each_language_as_default do\n      assert Mailer.attachments_added(attachements).deliver\n    end\n  end\n\n  def test_version_file_added\n    attachements = [ Attachment.find_by_container_type('Version') ]\n    assert Mailer.attachments_added(attachements).deliver\n    assert_not_nil last_email.bcc\n    assert last_email.bcc.any?\n    assert_select_email do\n      assert_select \"a[href=?]\", \"http://localhost:3000/projects/ecookbook/files\"\n    end\n  end\n\n  def test_project_file_added\n    attachements = [ Attachment.find_by_container_type('Project') ]\n    assert Mailer.attachments_added(attachements).deliver\n    assert_not_nil last_email.bcc\n    assert last_email.bcc.any?\n    assert_select_email do\n      assert_select \"a[href=?]\", \"http://localhost:3000/projects/ecookbook/files\"\n    end\n  end\n\n  def test_news_added\n    news = News.first\n    with_each_language_as_default do\n      assert Mailer.news_added(news).deliver\n    end\n  end\n\n  def test_news_added_should_notify_project_news_watchers\n    user1 = User.generate!\n    user2 = User.generate!\n    news = News.find(1)\n    news.project.enabled_module('news').add_watcher(user1)\n\n    Mailer.news_added(news).deliver\n    assert_include user1.mail, last_email.bcc\n    assert_not_include user2.mail, last_email.bcc\n  end\n\n  def test_news_comment_added\n    comment = Comment.find(2)\n    with_each_language_as_default do\n      assert Mailer.news_comment_added(comment).deliver\n    end\n  end\n\n  def test_message_posted\n    message = Message.first\n    recipients = ([message.root] + message.root.children).collect {|m| m.author.mail if m.author}\n    recipients = recipients.compact.uniq\n    with_each_language_as_default do\n      assert Mailer.message_posted(message).deliver\n    end\n  end\n\n  def test_wiki_content_added\n    content = WikiContent.find(1)\n    with_each_language_as_default do\n      assert_difference 'ActionMailer::Base.deliveries.size' do\n        assert Mailer.wiki_content_added(content).deliver\n        assert_select_email do\n          assert_select 'a[href=?]',\n            'http://localhost:3000/projects/ecookbook/wiki/CookBook_documentation',\n            :text => 'CookBook documentation'\n        end\n      end\n    end\n  end\n\n  def test_wiki_content_updated\n    content = WikiContent.find(1)\n    with_each_language_as_default do\n      assert_difference 'ActionMailer::Base.deliveries.size' do\n        assert Mailer.wiki_content_updated(content).deliver\n        assert_select_email do\n          assert_select 'a[href=?]',\n            'http://localhost:3000/projects/ecookbook/wiki/CookBook_documentation',\n            :text => 'CookBook documentation'\n        end\n      end\n    end\n  end\n\n  def test_account_information\n    user = User.find(2)\n    valid_languages.each do |lang|\n      user.update_attribute :language, lang.to_s\n      user.reload\n      assert Mailer.account_information(user, 'pAsswORd').deliver\n    end\n  end\n\n  def test_lost_password\n    token = Token.find(2)\n    valid_languages.each do |lang|\n      token.user.update_attribute :language, lang.to_s\n      token.reload\n      assert Mailer.lost_password(token).deliver\n    end\n  end\n\n  def test_register\n    token = Token.find(1)\n    valid_languages.each do |lang|\n      token.user.update_attribute :language, lang.to_s\n      token.reload\n      ActionMailer::Base.deliveries.clear\n      assert Mailer.register(token).deliver\n      mail = last_email\n      assert_select_email do\n        assert_select \"a[href=?]\",\n                      \"http://localhost:3000/account/activate?token=#{token.value}\",\n                      :text => \"http://localhost:3000/account/activate?token=#{token.value}\"\n      end\n    end\n  end\n\n  def test_test\n    user = User.find(1)\n    valid_languages.each do |lang|\n      user.update_attribute :language, lang.to_s\n      assert Mailer.test_email(user).deliver\n    end\n  end\n\n  def test_reminders\n    Mailer.reminders(:days => 42)\n    assert_equal 1, ActionMailer::Base.deliveries.size\n    mail = last_email\n    assert mail.bcc.include?('dlopper@somenet.foo')\n    assert_mail_body_match 'Bug #3: Error 281 when updating a recipe', mail\n    assert_equal '1 issue(s) due in the next 42 days', mail.subject\n  end\n\n  def test_reminders_should_not_include_closed_issues\n    with_settings :default_language => 'en' do\n      Issue.create!(:project_id => 1, :tracker_id => 1, :status_id => 5,\n                      :subject => 'Closed issue', :assigned_to_id => 3,\n                      :due_date => 5.days.from_now,\n                      :author_id => 2)\n      ActionMailer::Base.deliveries.clear\n\n      Mailer.reminders(:days => 42)\n      assert_equal 1, ActionMailer::Base.deliveries.size\n      mail = last_email\n      assert mail.bcc.include?('dlopper@somenet.foo')\n      assert_mail_body_no_match 'Closed issue', mail\n    end\n  end\n\n  def test_reminders_for_users\n    Mailer.reminders(:days => 42, :users => ['5'])\n    assert_equal 0, ActionMailer::Base.deliveries.size # No mail for dlopper\n    Mailer.reminders(:days => 42, :users => ['3'])\n    assert_equal 1, ActionMailer::Base.deliveries.size # No mail for dlopper\n    mail = last_email\n    assert mail.bcc.include?('dlopper@somenet.foo')\n    assert_mail_body_match 'Bug #3: Error 281 when updating a recipe', mail\n  end\n\n  def test_reminder_should_include_issues_assigned_to_groups\n    with_settings :default_language => 'en', :issue_group_assignment => '1' do\n      group = Group.generate!\n      Member.create!(:project_id => 1, :principal => group, :role_ids => [1])\n      group.users << User.find(2)\n      group.users << User.find(3)\n\n      Issue.create!(:project_id => 1, :tracker_id => 1, :status_id => 1,\n                      :subject => 'Assigned to group', :assigned_to => group,\n                      :due_date => 5.days.from_now,\n                      :author_id => 2)\n      ActionMailer::Base.deliveries.clear\n\n      Mailer.reminders(:days => 7)\n      assert_equal 2, ActionMailer::Base.deliveries.size\n      assert_equal %w(dlopper@somenet.foo jsmith@somenet.foo), ActionMailer::Base.deliveries.map(&:bcc).flatten.sort\n      ActionMailer::Base.deliveries.each do |mail|\n        assert_mail_body_match 'Assigned to group', mail\n      end\n    end\n  end\n\n  def test_reminders_with_version_option\n    with_settings :default_language => 'en' do \n      version = Version.generate!(:name => 'Acme', :project_id => 1)\n      Issue.generate!(:assigned_to => User.find(2), :due_date => 5.days.from_now)\n      Issue.generate!(:assigned_to => User.find(3), :due_date => 5.days.from_now, :fixed_version => version)\n      ActionMailer::Base.deliveries.clear\n\n      Mailer.reminders(:days => 42, :version => 'acme')\n      assert_equal 1, ActionMailer::Base.deliveries.size\n\n      mail = last_email\n      assert mail.bcc.include?('dlopper@somenet.foo')\n    end\n  end\n\n  def test_security_notification\n    set_language_if_valid User.find(1).language\n    with_settings :emails_footer => \"footer without link\" do\n      User.current.remote_ip = '192.168.1.1'\n      assert Mailer.security_notification(User.find(1), message: :notice_account_password_updated).deliver\n      mail = last_email\n      assert_not_nil mail\n      assert_mail_body_match '192.168.1.1', mail\n      assert_mail_body_match I18n.t(:notice_account_password_updated), mail\n      assert_select_email do\n        assert_select \"h1\", false\n        assert_select \"a\", false\n      end\n    end\n  end\n\n  def test_security_notification_should_include_title\n    set_language_if_valid User.find(2).language\n    with_settings :emails_footer => \"footer without link\" do\n      assert Mailer.security_notification(User.find(2),\n        message: :notice_account_password_updated,\n        title: :label_my_account\n      ).deliver\n      assert_select_email do\n        assert_select \"a\", false\n        assert_select \"h1\", :text => I18n.t(:label_my_account)\n      end\n    end\n  end\n\n  def test_security_notification_should_include_link\n    set_language_if_valid User.find(3).language\n    with_settings :emails_footer => \"footer without link\" do\n      assert Mailer.security_notification(User.find(3),\n      message: :notice_account_password_updated,\n      title: :label_my_account,\n      url: {controller: 'my', action: 'account'}\n      ).deliver\n      assert_select_email do\n        assert_select \"h1\", false\n        assert_select 'a[href=?]', 'http://localhost:3000/my/account', :text => I18n.t(:label_my_account)\n      end\n    end\n  end\n\n  def test_mailer_should_not_change_locale\n    # Set current language to italian\n    set_language_if_valid 'it'\n    # Send an email to a french user\n    user = User.find(1)\n    user.language = 'fr'\n    Mailer.account_activated(user).deliver\n    mail = last_email\n    assert_mail_body_match 'Votre compte', mail\n\n    assert_equal :it, current_language\n  end\n\n  def test_with_deliveries_off\n    Mailer.with_deliveries false do\n      Mailer.test_email(User.find(1)).deliver\n    end\n    assert ActionMailer::Base.deliveries.empty?\n    # should restore perform_deliveries\n    assert ActionMailer::Base.perform_deliveries\n  end\n\n  def test_token_for_should_strip_trailing_gt_from_address_with_full_name\n    with_settings :mail_from => \"Redmine Mailer<no-reply@redmine.org>\" do\n      assert_match /\\Aredmine.issue-\\d+\\.\\d+\\.[0-9a-f]+@redmine.org\\z/, Mailer.token_for(Issue.generate!)\n    end\n  end\n\n  def test_layout_should_include_the_emails_header\n    with_settings :emails_header => \"*Header content*\" do\n      with_settings :plain_text_mail => 0 do\n        assert Mailer.test_email(User.find(1)).deliver\n        assert_select_email do\n          assert_select \".header\" do\n            assert_select \"strong\", :text => \"Header content\"\n          end\n        end\n      end\n      with_settings :plain_text_mail => 1 do\n        assert Mailer.test_email(User.find(1)).deliver\n        mail = last_email\n        assert_not_nil mail\n        assert_include \"*Header content*\", mail.body.decoded\n      end\n    end\n  end\n\n  def test_layout_should_not_include_empty_emails_header\n    with_settings :emails_header => \"\", :plain_text_mail => 0 do\n      assert Mailer.test_email(User.find(1)).deliver\n      assert_select_email do\n        assert_select \".header\", false\n      end\n    end\n  end\n\n  def test_layout_should_include_the_emails_footer\n    with_settings :emails_footer => \"*Footer content*\" do\n      with_settings :plain_text_mail => 0 do\n        assert Mailer.test_email(User.find(1)).deliver\n        assert_select_email do\n          assert_select \".footer\" do\n            assert_select \"strong\", :text => \"Footer content\"\n          end\n        end\n      end\n      with_settings :plain_text_mail => 1 do\n        assert Mailer.test_email(User.find(1)).deliver\n        mail = last_email\n        assert_not_nil mail\n        assert_include \"\\n-- \\n\", mail.body.decoded\n        assert_include \"*Footer content*\", mail.body.decoded\n      end\n    end\n  end\n\n  def test_layout_should_not_include_empty_emails_footer\n    with_settings :emails_footer => \"\" do\n      with_settings :plain_text_mail => 0 do\n        assert Mailer.test_email(User.find(1)).deliver\n        assert_select_email do\n          assert_select \".footer\", false\n        end\n      end\n      with_settings :plain_text_mail => 1 do\n        assert Mailer.test_email(User.find(1)).deliver\n        mail = last_email\n        assert_not_nil mail\n        assert_not_include \"\\n-- \\n\", mail.body.decoded\n      end\n    end\n  end\n\n  def test_should_escape_html_templates_only\n    Issue.generate!(:project_id => 1, :tracker_id => 1, :subject => 'Subject with a <tag>')\n    mail = last_email\n    assert_equal 2, mail.parts.size\n    assert_include '<tag>', text_part.body.encoded\n    assert_include '&lt;tag&gt;', html_part.body.encoded\n  end\n\n  def test_should_raise_delivery_errors_when_raise_delivery_errors_is_true\n    mail = Mailer.test_email(User.find(1))\n    mail.delivery_method.stubs(:deliver!).raises(Exception.new(\"delivery error\"))\n\n    ActionMailer::Base.raise_delivery_errors = true\n    assert_raise Exception, \"delivery error\" do\n      mail.deliver\n    end\n  ensure\n    ActionMailer::Base.raise_delivery_errors = false\n  end\n\n  def test_should_log_delivery_errors_when_raise_delivery_errors_is_false\n    mail = Mailer.test_email(User.find(1))\n    mail.delivery_method.stubs(:deliver!).raises(Exception.new(\"delivery error\"))\n\n    Rails.logger.expects(:error).with(\"Email delivery error: delivery error\")\n    ActionMailer::Base.raise_delivery_errors = false\n    assert_nothing_raised do\n      mail.deliver\n    end\n  end\n\n  def test_with_synched_deliveries_should_yield_with_synced_deliveries\n    ActionMailer::Base.delivery_method = :async_smtp\n    ActionMailer::Base.async_smtp_settings = {:foo => 'bar'}\n\n    Mailer.with_synched_deliveries do\n      assert_equal :smtp, ActionMailer::Base.delivery_method\n      assert_equal({:foo => 'bar'}, ActionMailer::Base.smtp_settings)\n    end\n    assert_equal :async_smtp, ActionMailer::Base.delivery_method\n  ensure\n    ActionMailer::Base.delivery_method = :test\n  end\n\n  def test_email_addresses_should_keep_addresses\n    assert_equal [\"foo@example.net\"],\n      Mailer.email_addresses(\"foo@example.net\")\n\n    assert_equal [\"foo@example.net\", \"bar@example.net\"],\n      Mailer.email_addresses([\"foo@example.net\", \"bar@example.net\"])\n  end\n\n  def test_email_addresses_should_replace_users_with_their_email_addresses\n    assert_equal [\"admin@somenet.foo\"],\n      Mailer.email_addresses(User.find(1))\n\n    assert_equal [\"admin@somenet.foo\", \"jsmith@somenet.foo\"],\n      Mailer.email_addresses(User.where(:id => [1,2])).sort\n  end\n\n  def test_email_addresses_should_include_notified_emails_addresses_only\n    EmailAddress.create!(:user_id => 2, :address => \"another@somenet.foo\", :notify => false)\n    EmailAddress.create!(:user_id => 2, :address => \"another2@somenet.foo\")\n\n    assert_equal [\"another2@somenet.foo\", \"jsmith@somenet.foo\"],\n      Mailer.email_addresses(User.find(2)).sort\n  end\n\n  private\n\n  def last_email\n    mail = ActionMailer::Base.deliveries.last\n    assert_not_nil mail\n    mail\n  end\n\n  def text_part\n    last_email.parts.detect {|part| part.content_type.include?('text/plain')}\n  end\n\n  def html_part\n    last_email.parts.detect {|part| part.content_type.include?('text/html')}\n  end\n\n  def with_each_language_as_default(&block)\n    valid_languages.each do |lang|\n      with_settings :default_language => lang.to_s do\n        yield lang\n      end\n    end\n  end\nend\n"], "fixing_code": ["# Redmine - project management software\n# Copyright (C) 2006-2016  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire 'roadie'\n\nclass Mailer < ActionMailer::Base\n  layout 'mailer'\n  helper :application\n  helper :issues\n  helper :custom_fields\n\n  include Redmine::I18n\n  include Roadie::Rails::Automatic\n\n  def self.default_url_options\n    options = {:protocol => Setting.protocol}\n    if Setting.host_name.to_s =~ /\\A(https?\\:\\/\\/)?(.+?)(\\:(\\d+))?(\\/.+)?\\z/i\n      host, port, prefix = $2, $4, $5\n      options.merge!({\n        :host => host, :port => port, :script_name => prefix\n      })\n    else\n      options[:host] = Setting.host_name\n    end\n    options\n  end\n\n  # Builds a mail for notifying to_users and cc_users about a new issue\n  def issue_add(issue, to_users, cc_users)\n    redmine_headers 'Project' => issue.project.identifier,\n                    'Issue-Id' => issue.id,\n                    'Issue-Author' => issue.author.login\n    redmine_headers 'Issue-Assignee' => issue.assigned_to.login if issue.assigned_to\n    message_id issue\n    references issue\n    @author = issue.author\n    @issue = issue\n    @users = to_users + cc_users\n    @issue_url = url_for(:controller => 'issues', :action => 'show', :id => issue)\n    mail :to => to_users,\n      :cc => cc_users,\n      :subject => \"[#{issue.project.name} - #{issue.tracker.name} ##{issue.id}] (#{issue.status.name}) #{issue.subject}\"\n  end\n\n  # Notifies users about a new issue\n  def self.deliver_issue_add(issue)\n    to = issue.notified_users\n    cc = issue.notified_watchers - to\n    issue.each_notification(to + cc) do |users|\n      Mailer.issue_add(issue, to & users, cc & users).deliver\n    end\n  end\n\n  # Builds a mail for notifying to_users and cc_users about an issue update\n  def issue_edit(journal, to_users, cc_users)\n    issue = journal.journalized\n    redmine_headers 'Project' => issue.project.identifier,\n                    'Issue-Id' => issue.id,\n                    'Issue-Author' => issue.author.login\n    redmine_headers 'Issue-Assignee' => issue.assigned_to.login if issue.assigned_to\n    message_id journal\n    references issue\n    @author = journal.user\n    s = \"[#{issue.project.name} - #{issue.tracker.name} ##{issue.id}] \"\n    s << \"(#{issue.status.name}) \" if journal.new_value_for('status_id')\n    s << issue.subject\n    @issue = issue\n    @users = to_users + cc_users\n    @journal = journal\n    @journal_details = journal.visible_details(@users.first)\n    @issue_url = url_for(:controller => 'issues', :action => 'show', :id => issue, :anchor => \"change-#{journal.id}\")\n    mail :to => to_users,\n      :cc => cc_users,\n      :subject => s\n  end\n\n  # Notifies users about an issue update\n  def self.deliver_issue_edit(journal)\n    issue = journal.journalized.reload\n    to = journal.notified_users\n    cc = journal.notified_watchers - to\n    journal.each_notification(to + cc) do |users|\n      issue.each_notification(users) do |users2|\n        Mailer.issue_edit(journal, to & users2, cc & users2).deliver\n      end\n    end\n  end\n\n  def reminder(user, issues, days)\n    set_language_if_valid user.language\n    @issues = issues\n    @days = days\n    @issues_url = url_for(:controller => 'issues', :action => 'index',\n                                :set_filter => 1, :assigned_to_id => user.id,\n                                :sort => 'due_date:asc')\n    mail :to => user,\n      :subject => l(:mail_subject_reminder, :count => issues.size, :days => days)\n  end\n\n  # Builds a Mail::Message object used to email users belonging to the added document's project.\n  #\n  # Example:\n  #   document_added(document) => Mail::Message object\n  #   Mailer.document_added(document).deliver => sends an email to the document's project recipients\n  def document_added(document)\n    redmine_headers 'Project' => document.project.identifier\n    @author = User.current\n    @document = document\n    @document_url = url_for(:controller => 'documents', :action => 'show', :id => document)\n    mail :to => document.notified_users,\n      :subject => \"[#{document.project.name}] #{l(:label_document_new)}: #{document.title}\"\n  end\n\n  # Builds a Mail::Message object used to email recipients of a project when an attachements are added.\n  #\n  # Example:\n  #   attachments_added(attachments) => Mail::Message object\n  #   Mailer.attachments_added(attachments).deliver => sends an email to the project's recipients\n  def attachments_added(attachments)\n    container = attachments.first.container\n    added_to = ''\n    added_to_url = ''\n    @author = attachments.first.author\n    case container.class.name\n    when 'Project'\n      added_to_url = url_for(:controller => 'files', :action => 'index', :project_id => container)\n      added_to = \"#{l(:label_project)}: #{container}\"\n      recipients = container.project.notified_users.select {|user| user.allowed_to?(:view_files, container.project)}\n    when 'Version'\n      added_to_url = url_for(:controller => 'files', :action => 'index', :project_id => container.project)\n      added_to = \"#{l(:label_version)}: #{container.name}\"\n      recipients = container.project.notified_users.select {|user| user.allowed_to?(:view_files, container.project)}\n    when 'Document'\n      added_to_url = url_for(:controller => 'documents', :action => 'show', :id => container.id)\n      added_to = \"#{l(:label_document)}: #{container.title}\"\n      recipients = container.notified_users\n    end\n    redmine_headers 'Project' => container.project.identifier\n    @attachments = attachments\n    @added_to = added_to\n    @added_to_url = added_to_url\n    mail :to => recipients,\n      :subject => \"[#{container.project.name}] #{l(:label_attachment_new)}\"\n  end\n\n  # Builds a Mail::Message object used to email recipients of a news' project when a news item is added.\n  #\n  # Example:\n  #   news_added(news) => Mail::Message object\n  #   Mailer.news_added(news).deliver => sends an email to the news' project recipients\n  def news_added(news)\n    redmine_headers 'Project' => news.project.identifier\n    @author = news.author\n    message_id news\n    references news\n    @news = news\n    @news_url = url_for(:controller => 'news', :action => 'show', :id => news)\n    mail :to => news.notified_users,\n      :cc => news.notified_watchers_for_added_news,\n      :subject => \"[#{news.project.name}] #{l(:label_news)}: #{news.title}\"\n  end\n\n  # Builds a Mail::Message object used to email recipients of a news' project when a news comment is added.\n  #\n  # Example:\n  #   news_comment_added(comment) => Mail::Message object\n  #   Mailer.news_comment_added(comment) => sends an email to the news' project recipients\n  def news_comment_added(comment)\n    news = comment.commented\n    redmine_headers 'Project' => news.project.identifier\n    @author = comment.author\n    message_id comment\n    references news\n    @news = news\n    @comment = comment\n    @news_url = url_for(:controller => 'news', :action => 'show', :id => news)\n    mail :to => news.notified_users,\n     :cc => news.notified_watchers,\n     :subject => \"Re: [#{news.project.name}] #{l(:label_news)}: #{news.title}\"\n  end\n\n  # Builds a Mail::Message object used to email the recipients of the specified message that was posted.\n  #\n  # Example:\n  #   message_posted(message) => Mail::Message object\n  #   Mailer.message_posted(message).deliver => sends an email to the recipients\n  def message_posted(message)\n    redmine_headers 'Project' => message.project.identifier,\n                    'Topic-Id' => (message.parent_id || message.id)\n    @author = message.author\n    message_id message\n    references message.root\n    recipients = message.notified_users\n    cc = ((message.root.notified_watchers + message.board.notified_watchers).uniq - recipients)\n    @message = message\n    @message_url = url_for(message.event_url)\n    mail :to => recipients,\n      :cc => cc,\n      :subject => \"[#{message.board.project.name} - #{message.board.name} - msg#{message.root.id}] #{message.subject}\"\n  end\n\n  # Builds a Mail::Message object used to email the recipients of a project of the specified wiki content was added.\n  #\n  # Example:\n  #   wiki_content_added(wiki_content) => Mail::Message object\n  #   Mailer.wiki_content_added(wiki_content).deliver => sends an email to the project's recipients\n  def wiki_content_added(wiki_content)\n    redmine_headers 'Project' => wiki_content.project.identifier,\n                    'Wiki-Page-Id' => wiki_content.page.id\n    @author = wiki_content.author\n    message_id wiki_content\n    recipients = wiki_content.notified_users\n    cc = wiki_content.page.wiki.notified_watchers - recipients\n    @wiki_content = wiki_content\n    @wiki_content_url = url_for(:controller => 'wiki', :action => 'show',\n                                      :project_id => wiki_content.project,\n                                      :id => wiki_content.page.title)\n    mail :to => recipients,\n      :cc => cc,\n      :subject => \"[#{wiki_content.project.name}] #{l(:mail_subject_wiki_content_added, :id => wiki_content.page.pretty_title)}\"\n  end\n\n  # Builds a Mail::Message object used to email the recipients of a project of the specified wiki content was updated.\n  #\n  # Example:\n  #   wiki_content_updated(wiki_content) => Mail::Message object\n  #   Mailer.wiki_content_updated(wiki_content).deliver => sends an email to the project's recipients\n  def wiki_content_updated(wiki_content)\n    redmine_headers 'Project' => wiki_content.project.identifier,\n                    'Wiki-Page-Id' => wiki_content.page.id\n    @author = wiki_content.author\n    message_id wiki_content\n    recipients = wiki_content.notified_users\n    cc = wiki_content.page.wiki.notified_watchers + wiki_content.page.notified_watchers - recipients\n    @wiki_content = wiki_content\n    @wiki_content_url = url_for(:controller => 'wiki', :action => 'show',\n                                      :project_id => wiki_content.project,\n                                      :id => wiki_content.page.title)\n    @wiki_diff_url = url_for(:controller => 'wiki', :action => 'diff',\n                                   :project_id => wiki_content.project, :id => wiki_content.page.title,\n                                   :version => wiki_content.version)\n    mail :to => recipients,\n      :cc => cc,\n      :subject => \"[#{wiki_content.project.name}] #{l(:mail_subject_wiki_content_updated, :id => wiki_content.page.pretty_title)}\"\n  end\n\n  # Builds a Mail::Message object used to email the specified user their account information.\n  #\n  # Example:\n  #   account_information(user, password) => Mail::Message object\n  #   Mailer.account_information(user, password).deliver => sends account information to the user\n  def account_information(user, password)\n    set_language_if_valid user.language\n    @user = user\n    @password = password\n    @login_url = url_for(:controller => 'account', :action => 'login')\n    mail :to => user.mail,\n      :subject => l(:mail_subject_register, Setting.app_title)\n  end\n\n  # Builds a Mail::Message object used to email all active administrators of an account activation request.\n  #\n  # Example:\n  #   account_activation_request(user) => Mail::Message object\n  #   Mailer.account_activation_request(user).deliver => sends an email to all active administrators\n  def account_activation_request(user)\n    # Send the email to all active administrators\n    recipients = User.active.where(:admin => true)\n    @user = user\n    @url = url_for(:controller => 'users', :action => 'index',\n                         :status => User::STATUS_REGISTERED,\n                         :sort_key => 'created_on', :sort_order => 'desc')\n    mail :to => recipients,\n      :subject => l(:mail_subject_account_activation_request, Setting.app_title)\n  end\n\n  # Builds a Mail::Message object used to email the specified user that their account was activated by an administrator.\n  #\n  # Example:\n  #   account_activated(user) => Mail::Message object\n  #   Mailer.account_activated(user).deliver => sends an email to the registered user\n  def account_activated(user)\n    set_language_if_valid user.language\n    @user = user\n    @login_url = url_for(:controller => 'account', :action => 'login')\n    mail :to => user.mail,\n      :subject => l(:mail_subject_register, Setting.app_title)\n  end\n\n  def lost_password(token, recipient=nil)\n    set_language_if_valid(token.user.language)\n    recipient ||= token.user.mail\n    @token = token\n    @url = url_for(:controller => 'account', :action => 'lost_password', :token => token.value)\n    mail :to => recipient,\n      :subject => l(:mail_subject_lost_password, Setting.app_title)\n  end\n\n  # Notifies user that his password was updated\n  def self.password_updated(user)\n    # Don't send a notification to the dummy email address when changing the password\n    # of the default admin account which is required after the first login\n    # TODO: maybe not the best way to handle this\n    return if user.admin? && user.login == 'admin' && user.mail == 'admin@example.net'\n\n    Mailer.security_notification(user,\n      message: :mail_body_password_updated,\n      title: :button_change_password,\n      url: {controller: 'my', action: 'password'}\n    ).deliver\n  end\n\n  def register(token)\n    set_language_if_valid(token.user.language)\n    @token = token\n    @url = url_for(:controller => 'account', :action => 'activate', :token => token.value)\n    mail :to => token.user.mail,\n      :subject => l(:mail_subject_register, Setting.app_title)\n  end\n\n  def security_notification(recipients, options={})\n    redmine_headers 'Sender' => User.current.login\n    @user = Array(recipients).detect{|r| r.is_a? User }\n    set_language_if_valid(@user.try :language)\n    @message = l(options[:message],\n      field: (options[:field] && l(options[:field])),\n      value: options[:value]\n    )\n    @title = options[:title] && l(options[:title])\n    @url = options[:url] && (options[:url].is_a?(Hash) ? url_for(options[:url]) : options[:url])\n    mail :to => recipients,\n      :subject => \"[#{Setting.app_title}] #{l(:mail_subject_security_notification)}\"\n  end\n\n  def settings_updated(recipients, changes)\n    redmine_headers 'Sender' => User.current.login\n    @changes = changes\n    @url = url_for(controller: 'settings', action: 'index')\n    mail :to => recipients,\n      :subject => \"[#{Setting.app_title}] #{l(:mail_subject_security_notification)}\"\n  end\n\n\t# Notifies admins about settings changes\n  def self.security_settings_updated(changes)\n    return unless changes.present?\n\n    users = User.active.where(admin: true).to_a\n    Mailer.settings_updated(users, changes).deliver\n  end\n\n  def test_email(user)\n    set_language_if_valid(user.language)\n    @url = url_for(:controller => 'welcome')\n    mail :to => user.mail,\n      :subject => 'Redmine test'\n  end\n\n  # Sends reminders to issue assignees\n  # Available options:\n  # * :days     => how many days in the future to remind about (defaults to 7)\n  # * :tracker  => id of tracker for filtering issues (defaults to all trackers)\n  # * :project  => id or identifier of project to process (defaults to all projects)\n  # * :users    => array of user/group ids who should be reminded\n  # * :version  => name of target version for filtering issues (defaults to none)\n  def self.reminders(options={})\n    days = options[:days] || 7\n    project = options[:project] ? Project.find(options[:project]) : nil\n    tracker = options[:tracker] ? Tracker.find(options[:tracker]) : nil\n    target_version_id = options[:version] ? Version.named(options[:version]).pluck(:id) : nil\n    if options[:version] && target_version_id.blank?\n      raise ActiveRecord::RecordNotFound.new(\"Couldn't find Version with named #{options[:version]}\")\n    end\n    user_ids = options[:users]\n\n    scope = Issue.open.where(\"#{Issue.table_name}.assigned_to_id IS NOT NULL\" +\n      \" AND #{Project.table_name}.status = #{Project::STATUS_ACTIVE}\" +\n      \" AND #{Issue.table_name}.due_date <= ?\", days.day.from_now.to_date\n    )\n    scope = scope.where(:assigned_to_id => user_ids) if user_ids.present?\n    scope = scope.where(:project_id => project.id) if project\n    scope = scope.where(:fixed_version_id => target_version_id) if target_version_id.present?\n    scope = scope.where(:tracker_id => tracker.id) if tracker\n    issues_by_assignee = scope.includes(:status, :assigned_to, :project, :tracker).\n                              group_by(&:assigned_to)\n    issues_by_assignee.keys.each do |assignee|\n      if assignee.is_a?(Group)\n        assignee.users.each do |user|\n          issues_by_assignee[user] ||= []\n          issues_by_assignee[user] += issues_by_assignee[assignee]\n        end\n      end\n    end\n\n    issues_by_assignee.each do |assignee, issues|\n      if assignee.is_a?(User) && assignee.active? && issues.present?\n        visible_issues = issues.select {|i| i.visible?(assignee)}\n        reminder(assignee, visible_issues, days).deliver if visible_issues.present?\n      end\n    end\n  end\n\n  # Activates/desactivates email deliveries during +block+\n  def self.with_deliveries(enabled = true, &block)\n    was_enabled = ActionMailer::Base.perform_deliveries\n    ActionMailer::Base.perform_deliveries = !!enabled\n    yield\n  ensure\n    ActionMailer::Base.perform_deliveries = was_enabled\n  end\n\n  # Sends emails synchronously in the given block\n  def self.with_synched_deliveries(&block)\n    saved_method = ActionMailer::Base.delivery_method\n    if m = saved_method.to_s.match(%r{^async_(.+)$})\n      synched_method = m[1]\n      ActionMailer::Base.delivery_method = synched_method.to_sym\n      ActionMailer::Base.send \"#{synched_method}_settings=\", ActionMailer::Base.send(\"async_#{synched_method}_settings\")\n    end\n    yield\n  ensure\n    ActionMailer::Base.delivery_method = saved_method\n  end\n\n  def mail(headers={}, &block)\n    headers.reverse_merge! 'X-Mailer' => 'Redmine',\n            'X-Redmine-Host' => Setting.host_name,\n            'X-Redmine-Site' => Setting.app_title,\n            'X-Auto-Response-Suppress' => 'All',\n            'Auto-Submitted' => 'auto-generated',\n            'From' => Setting.mail_from,\n            'List-Id' => \"<#{Setting.mail_from.to_s.gsub('@', '.')}>\"\n\n    # Replaces users with their email addresses\n    [:to, :cc, :bcc].each do |key|\n      if headers[key].present?\n        headers[key] = self.class.email_addresses(headers[key])\n      end\n    end\n\n    # Removes the author from the recipients and cc\n    # if the author does not want to receive notifications\n    # about what the author do\n    if @author && @author.logged? && @author.pref.no_self_notified\n      addresses = @author.mails\n      headers[:to] -= addresses if headers[:to].is_a?(Array)\n      headers[:cc] -= addresses if headers[:cc].is_a?(Array)\n    end\n\n    if @author && @author.logged?\n      redmine_headers 'Sender' => @author.login\n    end\n\n    # Blind carbon copy recipients\n    if Setting.bcc_recipients?\n      headers[:bcc] = [headers[:to], headers[:cc]].flatten.uniq.reject(&:blank?)\n      headers[:to] = nil\n      headers[:cc] = nil\n    end\n\n    if @message_id_object\n      headers[:message_id] = \"<#{self.class.message_id_for(@message_id_object)}>\"\n    end\n    if @references_objects\n      headers[:references] = @references_objects.collect {|o| \"<#{self.class.references_for(o)}>\"}.join(' ')\n    end\n\n    m = if block_given?\n      super headers, &block\n    else\n      super headers do |format|\n        format.text\n        format.html unless Setting.plain_text_mail?\n      end\n    end\n    set_language_if_valid @initial_language\n\n    m\n  end\n\n  def initialize(*args)\n    @initial_language = current_language\n    set_language_if_valid Setting.default_language\n    super\n  end\n\n  def self.deliver_mail(mail)\n    return false if mail.to.blank? && mail.cc.blank? && mail.bcc.blank?\n    begin\n      # Log errors when raise_delivery_errors is set to false, Rails does not\n      mail.raise_delivery_errors = true\n      super\n    rescue Exception => e\n      if ActionMailer::Base.raise_delivery_errors\n        raise e\n      else\n        Rails.logger.error \"Email delivery error: #{e.message}\"\n      end\n    end\n  end\n\n  def self.method_missing(method, *args, &block)\n    if m = method.to_s.match(%r{^deliver_(.+)$})\n      ActiveSupport::Deprecation.warn \"Mailer.deliver_#{m[1]}(*args) is deprecated. Use Mailer.#{m[1]}(*args).deliver instead.\"\n      send(m[1], *args).deliver\n    else\n      super\n    end\n  end\n\n  # Returns an array of email addresses to notify by\n  # replacing users in arg with their notified email addresses\n  #\n  # Example:\n  #   Mailer.email_addresses(users)\n  #   => [\"foo@example.net\", \"bar@example.net\"]\n  def self.email_addresses(arg)\n    arr = Array.wrap(arg)\n    mails = arr.reject {|a| a.is_a? Principal}\n    users = arr - mails\n    if users.any?\n      mails += EmailAddress.\n        where(:user_id => users.map(&:id)).\n        where(\"is_default = ? OR notify = ?\", true, true).\n        pluck(:address)\n    end\n    mails\n  end\n\n  private\n\n  # Appends a Redmine header field (name is prepended with 'X-Redmine-')\n  def redmine_headers(h)\n    h.each { |k,v| headers[\"X-Redmine-#{k}\"] = v.to_s }\n  end\n\n  def self.token_for(object, rand=true)\n    timestamp = object.send(object.respond_to?(:created_on) ? :created_on : :updated_on)\n    hash = [\n      \"redmine\",\n      \"#{object.class.name.demodulize.underscore}-#{object.id}\",\n      timestamp.strftime(\"%Y%m%d%H%M%S\")\n    ]\n    if rand\n      hash << Redmine::Utils.random_hex(8)\n    end\n    host = Setting.mail_from.to_s.strip.gsub(%r{^.*@|>}, '')\n    host = \"#{::Socket.gethostname}.redmine\" if host.empty?\n    \"#{hash.join('.')}@#{host}\"\n  end\n\n  # Returns a Message-Id for the given object\n  def self.message_id_for(object)\n    token_for(object, true)\n  end\n\n  # Returns a uniq token for a given object referenced by all notifications\n  # related to this object\n  def self.references_for(object)\n    token_for(object, false)\n  end\n\n  def message_id(object)\n    @message_id_object = object\n  end\n\n  def references(object)\n    @references_objects ||= []\n    @references_objects << object\n  end\n\n  def mylogger\n    Rails.logger\n  end\nend\n", "# Redmine - project management software\n# Copyright (C) 2006-2016  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire File.expand_path('../../test_helper', __FILE__)\n\nclass MailerTest < ActiveSupport::TestCase\n  include Redmine::I18n\n  include Rails::Dom::Testing::Assertions\n  fixtures :projects, :enabled_modules, :issues, :users, :email_addresses, :user_preferences, :members,\n           :member_roles, :roles, :documents, :attachments, :news,\n           :tokens, :journals, :journal_details, :changesets,\n           :trackers, :projects_trackers,\n           :issue_statuses, :enumerations, :messages, :boards, :repositories,\n           :wikis, :wiki_pages, :wiki_contents, :wiki_content_versions,\n           :versions,\n           :comments\n\n  def setup\n    ActionMailer::Base.deliveries.clear\n    Setting.plain_text_mail = '0'\n    Setting.default_language = 'en'\n    User.current = nil\n  end\n\n  def test_generated_links_in_emails\n    with_settings :host_name => 'mydomain.foo', :protocol => 'https' do\n      journal = Journal.find(3)\n      assert Mailer.deliver_issue_edit(journal)\n    end\n    mail = last_email\n    assert_not_nil mail\n\n    assert_select_email do\n      # link to the main ticket on issue id\n      assert_select 'a[href=?]',\n                    'https://mydomain.foo/issues/2#change-3',\n                    :text => '#2'\n      # link to the main ticket\n      assert_select 'a[href=?]',\n                    'https://mydomain.foo/issues/2#change-3',\n                    :text => 'Feature request #2: Add ingredients categories'\n      # link to a referenced ticket\n      assert_select 'a[href=?][title=?]',\n                    'https://mydomain.foo/issues/1',\n                    \"Bug: Cannot print recipes (New)\",\n                    :text => '#1'\n      # link to a changeset\n      assert_select 'a[href=?][title=?]',\n                    'https://mydomain.foo/projects/ecookbook/repository/revisions/2',\n                    'This commit fixes #1, #2 and references #1 & #3',\n                    :text => 'r2'\n      # link to a description diff\n      assert_select 'a[href^=?][title=?]',\n                    # should be https://mydomain.foo/journals/diff/3?detail_id=4\n                    # but the Rails 4.2 DOM assertion doesn't handle the ? in the\n                    # attribute value\n                    'https://mydomain.foo/journals/3/diff',\n                    'View differences',\n                    :text => 'diff'\n      # link to an attachment\n      assert_select 'a[href=?]',\n                    'https://mydomain.foo/attachments/download/4/source.rb',\n                    :text => 'source.rb'\n    end\n  end\n\n  def test_generated_links_with_prefix\n    relative_url_root = Redmine::Utils.relative_url_root\n    with_settings :host_name => 'mydomain.foo/rdm', :protocol => 'http' do\n      journal = Journal.find(3)\n      assert Mailer.deliver_issue_edit(journal)\n    end\n\n    mail = last_email\n    assert_not_nil mail\n\n    assert_select_email do\n      # link to the main ticket\n      assert_select 'a[href=?]',\n                    'http://mydomain.foo/rdm/issues/2#change-3',\n                    :text => 'Feature request #2: Add ingredients categories'\n      # link to a referenced ticket\n      assert_select 'a[href=?][title=?]',\n                    'http://mydomain.foo/rdm/issues/1',\n                    \"Bug: Cannot print recipes (New)\",\n                    :text => '#1'\n      # link to a changeset\n      assert_select 'a[href=?][title=?]',\n                    'http://mydomain.foo/rdm/projects/ecookbook/repository/revisions/2',\n                    'This commit fixes #1, #2 and references #1 & #3',\n                    :text => 'r2'\n      # link to a description diff\n      assert_select 'a[href^=?][title=?]',\n                    # should be http://mydomain.foo/rdm/journals/diff/3?detail_id=4\n                    # but the Rails 4.2 DOM assertion doesn't handle the ? in the\n                    # attribute value\n                    'http://mydomain.foo/rdm/journals/3/diff',\n                    'View differences',\n                    :text => 'diff'\n      # link to an attachment\n      assert_select 'a[href=?]',\n                    'http://mydomain.foo/rdm/attachments/download/4/source.rb',\n                    :text => 'source.rb'\n    end\n  end\n\n  def test_generated_links_with_port_and_prefix\n    with_settings :host_name => '10.0.0.1:81/redmine', :protocol => 'http' do\n      Mailer.test_email(User.find(1)).deliver\n      mail = last_email\n      assert_not_nil mail\n      assert_include 'http://10.0.0.1:81/redmine', mail_body(mail)\n    end\n  end\n\n  def test_generated_links_with_port\n    with_settings :host_name => '10.0.0.1:81', :protocol => 'http' do\n      Mailer.test_email(User.find(1)).deliver\n      mail = last_email\n      assert_not_nil mail\n      assert_include 'http://10.0.0.1:81', mail_body(mail)\n    end\n  end\n\n  def test_issue_edit_should_generate_url_with_hostname_for_relations\n    journal = Journal.new(:journalized => Issue.find(1), :user => User.find(1), :created_on => Time.now)\n    journal.details << JournalDetail.new(:property => 'relation', :prop_key => 'label_relates_to', :value => 2)\n    Mailer.deliver_issue_edit(journal)\n    assert_not_nil last_email\n    assert_select_email do\n      assert_select 'a[href=?]', 'http://localhost:3000/issues/2', :text => 'Feature request #2'\n    end\n  end\n\n  def test_generated_links_with_prefix_and_no_relative_url_root\n    relative_url_root = Redmine::Utils.relative_url_root\n    Redmine::Utils.relative_url_root = nil\n\n    with_settings :host_name => 'mydomain.foo/rdm', :protocol => 'http' do\n      journal = Journal.find(3)\n      assert Mailer.deliver_issue_edit(journal)\n    end\n\n    mail = last_email\n    assert_not_nil mail\n\n    assert_select_email do\n      # link to the main ticket\n      assert_select 'a[href=?]',\n                    'http://mydomain.foo/rdm/issues/2#change-3',\n                    :text => 'Feature request #2: Add ingredients categories'\n      # link to a referenced ticket\n      assert_select 'a[href=?][title=?]',\n                    'http://mydomain.foo/rdm/issues/1',\n                    \"Bug: Cannot print recipes (New)\",\n                    :text => '#1'\n      # link to a changeset\n      assert_select 'a[href=?][title=?]',\n                    'http://mydomain.foo/rdm/projects/ecookbook/repository/revisions/2',\n                    'This commit fixes #1, #2 and references #1 & #3',\n                    :text => 'r2'\n      # link to a description diff\n      assert_select 'a[href^=?][title=?]',\n                    # should be http://mydomain.foo/rdm/journals/diff/3?detail_id=4\n                    # but the Rails 4.2 DOM assertion doesn't handle the ? in the\n                    # attribute value\n                    'http://mydomain.foo/rdm/journals/3/diff',\n                    'View differences',\n                    :text => 'diff'\n      # link to an attachment\n      assert_select 'a[href=?]',\n                    'http://mydomain.foo/rdm/attachments/download/4/source.rb',\n                    :text => 'source.rb'\n    end\n  ensure\n    # restore it\n    Redmine::Utils.relative_url_root = relative_url_root\n  end\n\n  def test_email_headers\n    issue = Issue.find(1)\n    Mailer.deliver_issue_add(issue)\n    mail = last_email\n    assert_not_nil mail\n    assert_equal 'All', mail.header['X-Auto-Response-Suppress'].to_s\n    assert_equal 'auto-generated', mail.header['Auto-Submitted'].to_s\n    assert_equal '<redmine.example.net>', mail.header['List-Id'].to_s\n  end\n\n  def test_email_headers_should_include_sender\n    issue = Issue.find(1)\n    Mailer.deliver_issue_add(issue)\n    mail = last_email\n    assert_equal issue.author.login, mail.header['X-Redmine-Sender'].to_s\n  end\n\n  def test_plain_text_mail\n    Setting.plain_text_mail = 1\n    journal = Journal.find(2)\n    Mailer.deliver_issue_edit(journal)\n    mail = last_email\n    assert_equal \"text/plain; charset=UTF-8\", mail.content_type\n    assert_equal 0, mail.parts.size\n    assert !mail.encoded.include?('href')\n  end\n\n  def test_html_mail\n    Setting.plain_text_mail = 0\n    journal = Journal.find(2)\n    Mailer.deliver_issue_edit(journal)\n    mail = last_email\n    assert_equal 2, mail.parts.size\n    assert mail.encoded.include?('href')\n  end\n\n  def test_from_header\n    with_settings :mail_from => 'redmine@example.net' do\n      Mailer.test_email(User.find(1)).deliver\n    end\n    mail = last_email\n    assert_equal 'redmine@example.net', mail.from_addrs.first\n  end\n\n  def test_from_header_with_phrase\n    with_settings :mail_from => 'Redmine app <redmine@example.net>' do\n      Mailer.test_email(User.find(1)).deliver\n    end\n    mail = last_email\n    assert_equal 'redmine@example.net', mail.from_addrs.first\n    assert_equal 'Redmine app <redmine@example.net>', mail.header['From'].to_s\n  end\n\n  def test_should_not_send_email_without_recipient\n    news = News.first\n    user = news.author\n    # Remove members except news author\n    news.project.memberships.each {|m| m.destroy unless m.user == user}\n\n    user.pref.no_self_notified = false\n    user.pref.save\n    User.current = user\n    Mailer.news_added(news.reload).deliver\n    assert_equal 1, last_email.bcc.size\n\n    # nobody to notify\n    user.pref.no_self_notified = true\n    user.pref.save\n    User.current = user\n    ActionMailer::Base.deliveries.clear\n    Mailer.news_added(news.reload).deliver\n    assert ActionMailer::Base.deliveries.empty?\n  end\n\n  def test_issue_add_message_id\n    issue = Issue.find(2)\n    Mailer.deliver_issue_add(issue)\n    mail = last_email\n    assert_match /^redmine\\.issue-2\\.20060719190421\\.[a-f0-9]+@example\\.net/, mail.message_id\n    assert_include \"redmine.issue-2.20060719190421@example.net\", mail.references\n  end\n\n  def test_issue_edit_message_id\n    journal = Journal.find(3)\n    journal.issue = Issue.find(2)\n\n    Mailer.deliver_issue_edit(journal)\n    mail = last_email\n    assert_match /^redmine\\.journal-3\\.\\d+\\.[a-f0-9]+@example\\.net/, mail.message_id\n    assert_include \"redmine.issue-2.20060719190421@example.net\", mail.references\n    assert_select_email do\n      # link to the update\n      assert_select \"a[href=?]\",\n                    \"http://localhost:3000/issues/#{journal.journalized_id}#change-#{journal.id}\"\n    end\n  end\n\n  def test_message_posted_message_id\n    message = Message.find(1)\n    Mailer.message_posted(message).deliver\n    mail = last_email\n    assert_match /^redmine\\.message-1\\.\\d+\\.[a-f0-9]+@example\\.net/, mail.message_id\n    assert_include \"redmine.message-1.20070512151532@example.net\", mail.references\n    assert_select_email do\n      # link to the message\n      assert_select \"a[href=?]\",\n                    \"http://localhost:3000/boards/#{message.board.id}/topics/#{message.id}\",\n                    :text => message.subject\n    end\n  end\n\n  def test_reply_posted_message_id\n    message = Message.find(3)\n    Mailer.message_posted(message).deliver\n    mail = last_email\n    assert_match /^redmine\\.message-3\\.\\d+\\.[a-f0-9]+@example\\.net/, mail.message_id\n    assert_include \"redmine.message-1.20070512151532@example.net\", mail.references\n    assert_select_email do\n      # link to the reply\n      assert_select \"a[href=?]\",\n                    \"http://localhost:3000/boards/#{message.board.id}/topics/#{message.root.id}?r=#{message.id}#message-#{message.id}\",\n                    :text => message.subject\n    end\n  end\n\n  test \"#issue_add should notify project members\" do\n    issue = Issue.find(1)\n    assert Mailer.deliver_issue_add(issue)\n    assert last_email.bcc.include?('dlopper@somenet.foo')\n  end\n\n  def test_issue_add_should_send_mail_to_all_user_email_address\n    EmailAddress.create!(:user_id => 3, :address => 'otheremail@somenet.foo')\n    issue = Issue.find(1)\n    assert Mailer.deliver_issue_add(issue)\n    assert last_email.bcc.include?('dlopper@somenet.foo')\n    assert last_email.bcc.include?('otheremail@somenet.foo')\n  end\n\n  test \"#issue_add should not notify project members that are not allow to view the issue\" do\n    issue = Issue.find(1)\n    Role.find(2).remove_permission!(:view_issues)\n    assert Mailer.deliver_issue_add(issue)\n    assert !last_email.bcc.include?('dlopper@somenet.foo')\n  end\n\n  test \"#issue_add should notify issue watchers\" do\n    issue = Issue.find(1)\n    user = User.find(9)\n    # minimal email notification options\n    user.pref.no_self_notified = '1'\n    user.pref.save\n    user.mail_notification = false\n    user.save\n\n    Watcher.create!(:watchable => issue, :user => user)\n    assert Mailer.deliver_issue_add(issue)\n    assert last_email.bcc.include?(user.mail)\n  end\n\n  test \"#issue_add should not notify watchers not allowed to view the issue\" do\n    issue = Issue.find(1)\n    user = User.find(9)\n    Watcher.create!(:watchable => issue, :user => user)\n    Role.non_member.remove_permission!(:view_issues)\n    assert Mailer.deliver_issue_add(issue)\n    assert !last_email.bcc.include?(user.mail)\n  end\n\n  def test_issue_add_should_include_enabled_fields\n    issue = Issue.find(2)\n    assert Mailer.deliver_issue_add(issue)\n    assert_mail_body_match '* Target version: 1.0', last_email\n    assert_select_email do\n      assert_select 'li', :text => 'Target version: 1.0'\n    end\n  end\n\n  def test_issue_add_should_not_include_disabled_fields\n    issue = Issue.find(2)\n    tracker = issue.tracker\n    tracker.core_fields -= ['fixed_version_id']\n    tracker.save!\n    assert Mailer.deliver_issue_add(issue)\n    assert_mail_body_no_match 'Target version', last_email\n    assert_select_email do\n      assert_select 'li', :text => /Target version/, :count => 0\n    end\n  end\n\n  # test mailer methods for each language\n  def test_issue_add\n    issue = Issue.find(1)\n    with_each_language_as_default do\n      assert Mailer.deliver_issue_add(issue)\n    end\n  end\n\n  def test_issue_edit\n    journal = Journal.find(1)\n    with_each_language_as_default do\n      assert Mailer.deliver_issue_edit(journal)\n    end\n  end\n\n  def test_issue_edit_should_send_private_notes_to_users_with_permission_only\n    journal = Journal.find(1)\n    journal.private_notes = true\n    journal.save!\n\n    Role.find(2).add_permission! :view_private_notes\n    Mailer.deliver_issue_edit(journal)\n    assert_equal %w(dlopper@somenet.foo jsmith@somenet.foo), ActionMailer::Base.deliveries.last.bcc.sort\n\n    Role.find(2).remove_permission! :view_private_notes\n    Mailer.deliver_issue_edit(journal)\n    assert_equal %w(jsmith@somenet.foo), ActionMailer::Base.deliveries.last.bcc.sort\n  end\n\n  def test_issue_edit_should_send_private_notes_to_watchers_with_permission_only\n    Issue.find(1).set_watcher(User.find_by_login('someone'))\n    journal = Journal.find(1)\n    journal.private_notes = true\n    journal.save!\n\n    Role.non_member.add_permission! :view_private_notes\n    Mailer.deliver_issue_edit(journal)\n    assert_include 'someone@foo.bar', ActionMailer::Base.deliveries.last.bcc.sort\n\n    Role.non_member.remove_permission! :view_private_notes\n    Mailer.deliver_issue_edit(journal)\n    assert_not_include 'someone@foo.bar', ActionMailer::Base.deliveries.last.bcc.sort\n  end\n\n  def test_issue_edit_should_mark_private_notes\n    journal = Journal.find(2)\n    journal.private_notes = true\n    journal.save!\n\n    with_settings :default_language => 'en' do\n      Mailer.deliver_issue_edit(journal)\n    end\n    assert_mail_body_match '(Private notes)', last_email\n  end\n\n  def test_issue_edit_with_relation_should_notify_users_who_can_see_the_related_issue\n    issue = Issue.generate!\n    issue.init_journal(User.find(1))\n    private_issue = Issue.generate!(:is_private => true)\n    IssueRelation.create!(:issue_from => issue, :issue_to => private_issue, :relation_type => 'relates')\n    issue.reload\n    assert_equal 1, issue.journals.size\n    journal = issue.journals.first\n    ActionMailer::Base.deliveries.clear\n\n    Mailer.deliver_issue_edit(journal)\n    last_email.bcc.each do |email|\n      user = User.find_by_mail(email)\n      assert private_issue.visible?(user), \"Issue was not visible to #{user}\"\n    end\n  end\n\n  def test_document_added\n    document = Document.find(1)\n    with_each_language_as_default do\n      assert Mailer.document_added(document).deliver\n    end\n  end\n\n  def test_attachments_added\n    attachements = [ Attachment.find_by_container_type('Document') ]\n    with_each_language_as_default do\n      assert Mailer.attachments_added(attachements).deliver\n    end\n  end\n\n  def test_version_file_added\n    attachements = [ Attachment.find_by_container_type('Version') ]\n    assert Mailer.attachments_added(attachements).deliver\n    assert_not_nil last_email.bcc\n    assert last_email.bcc.any?\n    assert_select_email do\n      assert_select \"a[href=?]\", \"http://localhost:3000/projects/ecookbook/files\"\n    end\n  end\n\n  def test_project_file_added\n    attachements = [ Attachment.find_by_container_type('Project') ]\n    assert Mailer.attachments_added(attachements).deliver\n    assert_not_nil last_email.bcc\n    assert last_email.bcc.any?\n    assert_select_email do\n      assert_select \"a[href=?]\", \"http://localhost:3000/projects/ecookbook/files\"\n    end\n  end\n\n  def test_news_added\n    news = News.first\n    with_each_language_as_default do\n      assert Mailer.news_added(news).deliver\n    end\n  end\n\n  def test_news_added_should_notify_project_news_watchers\n    user1 = User.generate!\n    user2 = User.generate!\n    news = News.find(1)\n    news.project.enabled_module('news').add_watcher(user1)\n\n    Mailer.news_added(news).deliver\n    assert_include user1.mail, last_email.bcc\n    assert_not_include user2.mail, last_email.bcc\n  end\n\n  def test_news_comment_added\n    comment = Comment.find(2)\n    with_each_language_as_default do\n      assert Mailer.news_comment_added(comment).deliver\n    end\n  end\n\n  def test_message_posted\n    message = Message.first\n    recipients = ([message.root] + message.root.children).collect {|m| m.author.mail if m.author}\n    recipients = recipients.compact.uniq\n    with_each_language_as_default do\n      assert Mailer.message_posted(message).deliver\n    end\n  end\n\n  def test_wiki_content_added\n    content = WikiContent.find(1)\n    with_each_language_as_default do\n      assert_difference 'ActionMailer::Base.deliveries.size' do\n        assert Mailer.wiki_content_added(content).deliver\n        assert_select_email do\n          assert_select 'a[href=?]',\n            'http://localhost:3000/projects/ecookbook/wiki/CookBook_documentation',\n            :text => 'CookBook documentation'\n        end\n      end\n    end\n  end\n\n  def test_wiki_content_updated\n    content = WikiContent.find(1)\n    with_each_language_as_default do\n      assert_difference 'ActionMailer::Base.deliveries.size' do\n        assert Mailer.wiki_content_updated(content).deliver\n        assert_select_email do\n          assert_select 'a[href=?]',\n            'http://localhost:3000/projects/ecookbook/wiki/CookBook_documentation',\n            :text => 'CookBook documentation'\n        end\n      end\n    end\n  end\n\n  def test_account_information\n    user = User.find(2)\n    valid_languages.each do |lang|\n      user.update_attribute :language, lang.to_s\n      user.reload\n      assert Mailer.account_information(user, 'pAsswORd').deliver\n    end\n  end\n\n  def test_lost_password\n    token = Token.find(2)\n    valid_languages.each do |lang|\n      token.user.update_attribute :language, lang.to_s\n      token.reload\n      assert Mailer.lost_password(token).deliver\n    end\n  end\n\n  def test_register\n    token = Token.find(1)\n    valid_languages.each do |lang|\n      token.user.update_attribute :language, lang.to_s\n      token.reload\n      ActionMailer::Base.deliveries.clear\n      assert Mailer.register(token).deliver\n      mail = last_email\n      assert_select_email do\n        assert_select \"a[href=?]\",\n                      \"http://localhost:3000/account/activate?token=#{token.value}\",\n                      :text => \"http://localhost:3000/account/activate?token=#{token.value}\"\n      end\n    end\n  end\n\n  def test_test\n    user = User.find(1)\n    valid_languages.each do |lang|\n      user.update_attribute :language, lang.to_s\n      assert Mailer.test_email(user).deliver\n    end\n  end\n\n  def test_reminders\n    Mailer.reminders(:days => 42)\n    assert_equal 1, ActionMailer::Base.deliveries.size\n    mail = last_email\n    assert mail.bcc.include?('dlopper@somenet.foo')\n    assert_mail_body_match 'Bug #3: Error 281 when updating a recipe', mail\n    assert_equal '1 issue(s) due in the next 42 days', mail.subject\n  end\n\n  def test_reminders_should_not_include_closed_issues\n    with_settings :default_language => 'en' do\n      Issue.create!(:project_id => 1, :tracker_id => 1, :status_id => 5,\n                      :subject => 'Closed issue', :assigned_to_id => 3,\n                      :due_date => 5.days.from_now,\n                      :author_id => 2)\n      ActionMailer::Base.deliveries.clear\n\n      Mailer.reminders(:days => 42)\n      assert_equal 1, ActionMailer::Base.deliveries.size\n      mail = last_email\n      assert mail.bcc.include?('dlopper@somenet.foo')\n      assert_mail_body_no_match 'Closed issue', mail\n    end\n  end\n\n  def test_reminders_for_users\n    Mailer.reminders(:days => 42, :users => ['5'])\n    assert_equal 0, ActionMailer::Base.deliveries.size # No mail for dlopper\n    Mailer.reminders(:days => 42, :users => ['3'])\n    assert_equal 1, ActionMailer::Base.deliveries.size # No mail for dlopper\n    mail = last_email\n    assert mail.bcc.include?('dlopper@somenet.foo')\n    assert_mail_body_match 'Bug #3: Error 281 when updating a recipe', mail\n  end\n\n  def test_reminder_should_include_issues_assigned_to_groups\n    with_settings :default_language => 'en', :issue_group_assignment => '1' do\n      group = Group.generate!\n      Member.create!(:project_id => 1, :principal => group, :role_ids => [1])\n      group.users << User.find(2)\n      group.users << User.find(3)\n\n      Issue.create!(:project_id => 1, :tracker_id => 1, :status_id => 1,\n                      :subject => 'Assigned to group', :assigned_to => group,\n                      :due_date => 5.days.from_now,\n                      :author_id => 2)\n      ActionMailer::Base.deliveries.clear\n\n      Mailer.reminders(:days => 7)\n      assert_equal 2, ActionMailer::Base.deliveries.size\n      assert_equal %w(dlopper@somenet.foo jsmith@somenet.foo), ActionMailer::Base.deliveries.map(&:bcc).flatten.sort\n      ActionMailer::Base.deliveries.each do |mail|\n        assert_mail_body_match 'Assigned to group', mail\n      end\n    end\n  end\n\n  def test_reminders_with_version_option\n    with_settings :default_language => 'en' do \n      version = Version.generate!(:name => 'Acme', :project_id => 1)\n      Issue.generate!(:assigned_to => User.find(2), :due_date => 5.days.from_now)\n      Issue.generate!(:assigned_to => User.find(3), :due_date => 5.days.from_now, :fixed_version => version)\n      ActionMailer::Base.deliveries.clear\n\n      Mailer.reminders(:days => 42, :version => 'acme')\n      assert_equal 1, ActionMailer::Base.deliveries.size\n\n      mail = last_email\n      assert mail.bcc.include?('dlopper@somenet.foo')\n    end\n  end\n\n  def test_reminders_should_only_include_issues_the_user_can_see\n    with_settings :default_language => 'en' do\n      user = User.find(3)\n      member = Member.create!(:project_id => 2, :principal => user, :role_ids => [1])\n      Issue.create!(:project_id => 2, :tracker_id => 1, :status_id => 1,\n                      :subject => 'Issue dlopper should not see', :assigned_to_id => 3,\n                      :due_date => 5.days.from_now,\n                      :author_id => 2)\n      member.destroy\n      ActionMailer::Base.deliveries.clear\n\n      Mailer.reminders(:days => 42)\n      assert_equal 1, ActionMailer::Base.deliveries.size\n      mail = last_email\n      assert mail.bcc.include?('dlopper@somenet.foo')\n      assert_mail_body_no_match 'Issue dlopper should not see', mail\n    end\n  end\n\n  def test_security_notification\n    set_language_if_valid User.find(1).language\n    with_settings :emails_footer => \"footer without link\" do\n      User.current.remote_ip = '192.168.1.1'\n      assert Mailer.security_notification(User.find(1), message: :notice_account_password_updated).deliver\n      mail = last_email\n      assert_not_nil mail\n      assert_mail_body_match '192.168.1.1', mail\n      assert_mail_body_match I18n.t(:notice_account_password_updated), mail\n      assert_select_email do\n        assert_select \"h1\", false\n        assert_select \"a\", false\n      end\n    end\n  end\n\n  def test_security_notification_should_include_title\n    set_language_if_valid User.find(2).language\n    with_settings :emails_footer => \"footer without link\" do\n      assert Mailer.security_notification(User.find(2),\n        message: :notice_account_password_updated,\n        title: :label_my_account\n      ).deliver\n      assert_select_email do\n        assert_select \"a\", false\n        assert_select \"h1\", :text => I18n.t(:label_my_account)\n      end\n    end\n  end\n\n  def test_security_notification_should_include_link\n    set_language_if_valid User.find(3).language\n    with_settings :emails_footer => \"footer without link\" do\n      assert Mailer.security_notification(User.find(3),\n      message: :notice_account_password_updated,\n      title: :label_my_account,\n      url: {controller: 'my', action: 'account'}\n      ).deliver\n      assert_select_email do\n        assert_select \"h1\", false\n        assert_select 'a[href=?]', 'http://localhost:3000/my/account', :text => I18n.t(:label_my_account)\n      end\n    end\n  end\n\n  def test_mailer_should_not_change_locale\n    # Set current language to italian\n    set_language_if_valid 'it'\n    # Send an email to a french user\n    user = User.find(1)\n    user.language = 'fr'\n    Mailer.account_activated(user).deliver\n    mail = last_email\n    assert_mail_body_match 'Votre compte', mail\n\n    assert_equal :it, current_language\n  end\n\n  def test_with_deliveries_off\n    Mailer.with_deliveries false do\n      Mailer.test_email(User.find(1)).deliver\n    end\n    assert ActionMailer::Base.deliveries.empty?\n    # should restore perform_deliveries\n    assert ActionMailer::Base.perform_deliveries\n  end\n\n  def test_token_for_should_strip_trailing_gt_from_address_with_full_name\n    with_settings :mail_from => \"Redmine Mailer<no-reply@redmine.org>\" do\n      assert_match /\\Aredmine.issue-\\d+\\.\\d+\\.[0-9a-f]+@redmine.org\\z/, Mailer.token_for(Issue.generate!)\n    end\n  end\n\n  def test_layout_should_include_the_emails_header\n    with_settings :emails_header => \"*Header content*\" do\n      with_settings :plain_text_mail => 0 do\n        assert Mailer.test_email(User.find(1)).deliver\n        assert_select_email do\n          assert_select \".header\" do\n            assert_select \"strong\", :text => \"Header content\"\n          end\n        end\n      end\n      with_settings :plain_text_mail => 1 do\n        assert Mailer.test_email(User.find(1)).deliver\n        mail = last_email\n        assert_not_nil mail\n        assert_include \"*Header content*\", mail.body.decoded\n      end\n    end\n  end\n\n  def test_layout_should_not_include_empty_emails_header\n    with_settings :emails_header => \"\", :plain_text_mail => 0 do\n      assert Mailer.test_email(User.find(1)).deliver\n      assert_select_email do\n        assert_select \".header\", false\n      end\n    end\n  end\n\n  def test_layout_should_include_the_emails_footer\n    with_settings :emails_footer => \"*Footer content*\" do\n      with_settings :plain_text_mail => 0 do\n        assert Mailer.test_email(User.find(1)).deliver\n        assert_select_email do\n          assert_select \".footer\" do\n            assert_select \"strong\", :text => \"Footer content\"\n          end\n        end\n      end\n      with_settings :plain_text_mail => 1 do\n        assert Mailer.test_email(User.find(1)).deliver\n        mail = last_email\n        assert_not_nil mail\n        assert_include \"\\n-- \\n\", mail.body.decoded\n        assert_include \"*Footer content*\", mail.body.decoded\n      end\n    end\n  end\n\n  def test_layout_should_not_include_empty_emails_footer\n    with_settings :emails_footer => \"\" do\n      with_settings :plain_text_mail => 0 do\n        assert Mailer.test_email(User.find(1)).deliver\n        assert_select_email do\n          assert_select \".footer\", false\n        end\n      end\n      with_settings :plain_text_mail => 1 do\n        assert Mailer.test_email(User.find(1)).deliver\n        mail = last_email\n        assert_not_nil mail\n        assert_not_include \"\\n-- \\n\", mail.body.decoded\n      end\n    end\n  end\n\n  def test_should_escape_html_templates_only\n    Issue.generate!(:project_id => 1, :tracker_id => 1, :subject => 'Subject with a <tag>')\n    mail = last_email\n    assert_equal 2, mail.parts.size\n    assert_include '<tag>', text_part.body.encoded\n    assert_include '&lt;tag&gt;', html_part.body.encoded\n  end\n\n  def test_should_raise_delivery_errors_when_raise_delivery_errors_is_true\n    mail = Mailer.test_email(User.find(1))\n    mail.delivery_method.stubs(:deliver!).raises(Exception.new(\"delivery error\"))\n\n    ActionMailer::Base.raise_delivery_errors = true\n    assert_raise Exception, \"delivery error\" do\n      mail.deliver\n    end\n  ensure\n    ActionMailer::Base.raise_delivery_errors = false\n  end\n\n  def test_should_log_delivery_errors_when_raise_delivery_errors_is_false\n    mail = Mailer.test_email(User.find(1))\n    mail.delivery_method.stubs(:deliver!).raises(Exception.new(\"delivery error\"))\n\n    Rails.logger.expects(:error).with(\"Email delivery error: delivery error\")\n    ActionMailer::Base.raise_delivery_errors = false\n    assert_nothing_raised do\n      mail.deliver\n    end\n  end\n\n  def test_with_synched_deliveries_should_yield_with_synced_deliveries\n    ActionMailer::Base.delivery_method = :async_smtp\n    ActionMailer::Base.async_smtp_settings = {:foo => 'bar'}\n\n    Mailer.with_synched_deliveries do\n      assert_equal :smtp, ActionMailer::Base.delivery_method\n      assert_equal({:foo => 'bar'}, ActionMailer::Base.smtp_settings)\n    end\n    assert_equal :async_smtp, ActionMailer::Base.delivery_method\n  ensure\n    ActionMailer::Base.delivery_method = :test\n  end\n\n  def test_email_addresses_should_keep_addresses\n    assert_equal [\"foo@example.net\"],\n      Mailer.email_addresses(\"foo@example.net\")\n\n    assert_equal [\"foo@example.net\", \"bar@example.net\"],\n      Mailer.email_addresses([\"foo@example.net\", \"bar@example.net\"])\n  end\n\n  def test_email_addresses_should_replace_users_with_their_email_addresses\n    assert_equal [\"admin@somenet.foo\"],\n      Mailer.email_addresses(User.find(1))\n\n    assert_equal [\"admin@somenet.foo\", \"jsmith@somenet.foo\"],\n      Mailer.email_addresses(User.where(:id => [1,2])).sort\n  end\n\n  def test_email_addresses_should_include_notified_emails_addresses_only\n    EmailAddress.create!(:user_id => 2, :address => \"another@somenet.foo\", :notify => false)\n    EmailAddress.create!(:user_id => 2, :address => \"another2@somenet.foo\")\n\n    assert_equal [\"another2@somenet.foo\", \"jsmith@somenet.foo\"],\n      Mailer.email_addresses(User.find(2)).sort\n  end\n\n  private\n\n  def last_email\n    mail = ActionMailer::Base.deliveries.last\n    assert_not_nil mail\n    mail\n  end\n\n  def text_part\n    last_email.parts.detect {|part| part.content_type.include?('text/plain')}\n  end\n\n  def html_part\n    last_email.parts.detect {|part| part.content_type.include?('text/html')}\n  end\n\n  def with_each_language_as_default(&block)\n    valid_languages.each do |lang|\n      with_settings :default_language => lang.to_s do\n        yield lang\n      end\n    end\n  end\nend\n"], "filenames": ["app/models/mailer.rb", "test/unit/mailer_test.rb"], "buggy_code_start_loc": [409, 665], "buggy_code_end_loc": [410, 665], "fixing_code_start_loc": [409, 666], "fixing_code_end_loc": [413, 685], "type": "CWE-200", "message": "In Redmine before 3.2.7 and 3.3.x before 3.3.4, the reminders function in app/models/mailer.rb does not check whether an issue is visible, which allows remote authenticated users to obtain sensitive information by reading e-mail reminder messages.", "other": {"cve": {"id": "CVE-2017-16804", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-13T20:29:00.460", "lastModified": "2019-04-30T15:56:31.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Redmine before 3.2.7 and 3.3.x before 3.3.4, the reminders function in app/models/mailer.rb does not check whether an issue is visible, which allows remote authenticated users to obtain sensitive information by reading e-mail reminder messages."}, {"lang": "es", "value": "En Redmine en versiones anteriores a la 3.2.7 y las versiones 3.3.x anteriores a la 3.3.4, la funci\u00f3n reminders en app/models/mailer.rb no comprueba si un problema es visible, lo que permite que usuarios remotos autenticados obtengan informaci\u00f3n sensible leyendo mensajes de recordatorio de correo electr\u00f3nico."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.7", "matchCriteriaId": "C34F71DA-BA2C-4595-B702-FF2CB4229C4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "196CF994-54D8-4E36-B37E-EAF1CC108F61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "5AE4FC9C-3291-4344-81D5-83BA91D52FA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "67E1F17B-7B25-48B3-8953-18C47D99B443"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "9ADF69D6-449E-4845-811D-D588B4D05665"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/redmine/redmine/commit/0f09f161f64f4190a52166675ff380a15b72a8bc", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4191", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.redmine.org/issues/25713", "source": "cve@mitre.org", "tags": ["Permissions Required"]}, {"url": "https://www.redmine.org/projects/redmine/wiki/Security_Advisories", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/redmine/redmine/commit/0f09f161f64f4190a52166675ff380a15b72a8bc"}}