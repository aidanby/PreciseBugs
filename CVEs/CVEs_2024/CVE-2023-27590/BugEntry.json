{"buggy_code": ["// SPDX-FileCopyrightText: 2009-2018 pancake <pancake@nopcode.org>\n// SPDX-FileCopyrightText: 2009-2018 defragger <rlaemmert@gmail.com>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <rz_core.h>\n#include <rz_debug.h>\n#include <libgdbr.h>\n#include <gdbclient/commands.h>\n\ntypedef struct {\n\tlibgdbr_t desc;\n} RzIOGdb;\n\n#define UNKNOWN     (-1)\n#define UNSUPPORTED 0\n#define SUPPORTED   1\n\ntypedef struct rz_debug_gdb_ctx_t {\n\tRzIOGdb **origrziogdb;\n\tlibgdbr_t *desc;\n\tut8 *reg_buf;\n\tint buf_size;\n\tint support_sw_bp;\n\tint support_hw_bp;\n} RzDebugGdbCtx;\n\nstatic bool rz_debug_gdb_init(RzDebug *dbg, void **user) {\n\tRzDebugGdbCtx *ctx = RZ_NEW0(RzDebugGdbCtx);\n\tif (!ctx) {\n\t\treturn false;\n\t}\n\tctx->support_sw_bp = UNKNOWN;\n\tctx->support_hw_bp = UNKNOWN;\n\t*user = ctx;\n\treturn true;\n}\n\nstatic void rz_debug_gdb_fini(RzDebug *dbg, void *user) {\n\tRzDebugGdbCtx *ctx = user;\n\tfree(ctx);\n}\n\nstatic int rz_debug_gdb_attach(RzDebug *dbg, int pid);\nstatic void check_connection(RzDebug *dbg) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tif (!ctx->desc) {\n\t\trz_debug_gdb_attach(dbg, -1);\n\t}\n}\n\nstatic int rz_debug_gdb_step(RzDebug *dbg) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tgdbr_step(ctx->desc, dbg->tid);\n\treturn true;\n}\n\nstatic RzList /*<RzDebugPid *>*/ *rz_debug_gdb_threads(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tRzList *list;\n\tif ((list = gdbr_threads_list(ctx->desc, pid))) {\n\t\tlist->free = (RzListFree)&rz_debug_pid_free;\n\t}\n\treturn list;\n}\n\nstatic RzList /*<RzDebugPid *>*/ *rz_debug_gdb_pids(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tRzList *list;\n\tif ((list = gdbr_pids_list(ctx->desc, pid))) {\n\t\tlist->free = (RzListFree)&rz_debug_pid_free;\n\t}\n\treturn list;\n}\n\nstatic int rz_debug_gdb_reg_read(RzDebug *dbg, int type, ut8 *buf, int size) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tint copy_size;\n\tint buflen = 0;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tgdbr_read_registers(ctx->desc);\n\tif (!ctx->desc || !ctx->desc->data) {\n\t\treturn -1;\n\t}\n\t// read the len of the current area\n\tfree(rz_reg_get_bytes(dbg->reg, type, &buflen));\n\tif (size < ctx->desc->data_len) {\n\t\teprintf(\"rz_debug_gdb_reg_read: small buffer %d vs %d\\n\",\n\t\t\t(int)size, (int)ctx->desc->data_len);\n\t\t//\treturn -1;\n\t}\n\tcopy_size = RZ_MIN(ctx->desc->data_len, size);\n\tbuflen = RZ_MAX(ctx->desc->data_len, buflen);\n\tif (ctx->reg_buf) {\n\t\t// if (buf_size < copy_size) { //desc->data_len) {\n\t\tif (buflen > ctx->buf_size) { // copy_size) {\n\t\t\tut8 *new_buf = realloc(ctx->reg_buf, buflen);\n\t\t\tif (!new_buf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tctx->reg_buf = new_buf;\n\t\t\tctx->buf_size = buflen;\n\t\t}\n\t} else {\n\t\tctx->reg_buf = calloc(buflen, 1);\n\t\tif (!ctx->reg_buf) {\n\t\t\treturn -1;\n\t\t}\n\t\tctx->buf_size = buflen;\n\t}\n\tmemset((void *)(volatile void *)buf, 0, size);\n\tmemcpy((void *)(volatile void *)buf, ctx->desc->data, RZ_MIN(copy_size, size));\n\tmemset((void *)(volatile void *)ctx->reg_buf, 0, buflen);\n\tmemcpy((void *)(volatile void *)ctx->reg_buf, ctx->desc->data, copy_size);\n#if 0\n\tint i;\n\t//for(i=0;i<168;i++) {\n\tfor(i=0;i<copy_size;i++) {\n\t\tif (!(i%16)) printf (\"\\n0x%08x  \", i);\n\t\tprintf (\"%02x \", buf[i]); //(ut8)desc->data[i]);\n\t}\n\tprintf(\"\\n\");\n#endif\n\treturn ctx->desc->data_len;\n}\n\nstatic RzList /*<RzDebugMap *>*/ *rz_debug_gdb_map_get(RzDebug *dbg) { // TODO\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc || ctx->desc->pid <= 0) {\n\t\treturn NULL;\n\t}\n\tRzList *retlist = NULL;\n\tif (ctx->desc->get_baddr) {\n\t\tctx->desc->get_baddr = false;\n\t\tut64 baddr;\n\t\tif ((baddr = gdbr_get_baddr(ctx->desc)) != UINT64_MAX) {\n\t\t\tif (!(retlist = rz_list_new())) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRzDebugMap *map;\n\t\t\tif (!(map = rz_debug_map_new(\"\", baddr, baddr, RZ_PERM_RX, 0))) {\n\t\t\t\trz_list_free(retlist);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trz_list_append(retlist, map);\n\t\t\treturn retlist;\n\t\t}\n\t}\n\n\t// Get file from GDB\n\tchar path[128];\n\tut8 *buf;\n\tint ret;\n\t// TODO don't hardcode buffer size, get from remote target\n\t// (I think gdb doesn't do that, it just keeps reading till EOF)\n\t// fstat info can get file size, but it doesn't work for /proc/pid/maps\n\tut64 buflen = 16384;\n\t// If /proc/%d/maps is not valid for gdbserver, we return NULL, as of now\n\tsnprintf(path, sizeof(path) - 1, \"/proc/%d/maps\", ctx->desc->pid);\n\n#ifdef _MSC_VER\n#define GDB_FILE_OPEN_MODE (_S_IREAD | _S_IWRITE)\n#else\n#define GDB_FILE_OPEN_MODE (S_IRUSR | S_IWUSR | S_IXUSR)\n#endif\n\n\tif (gdbr_open_file(ctx->desc, path, O_RDONLY, GDB_FILE_OPEN_MODE) < 0) {\n\t\treturn NULL;\n\t}\n\tif (!(buf = malloc(buflen))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\treturn NULL;\n\t}\n\tif ((ret = gdbr_read_file(ctx->desc, buf, buflen - 1)) <= 0) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tbuf[ret] = '\\0';\n\n\t// Get map list\n\tint unk = 0, perm, i;\n\tchar *ptr, *pos_1;\n\tsize_t line_len;\n\tchar name[1024], region1[100], region2[100], perms[5];\n\tRzDebugMap *map = NULL;\n\tregion1[0] = region2[0] = '0';\n\tregion1[1] = region2[1] = 'x';\n\tif (!(ptr = strtok((char *)buf, \"\\n\"))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (!(retlist = rz_list_new())) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\twhile (ptr) {\n\t\tut64 map_start, map_end, offset;\n\t\tbool map_is_shared = false;\n\t\tline_len = strlen(ptr);\n\t\t// maps files should not have empty lines\n\t\tif (line_len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// We assume Linux target, for now, so -\n\t\t// 7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 265428 /usr/lib/ld-2.25.so\n\t\tret = sscanf(ptr, \"%s %s %\" PFMT64x \" %*s %*s %[^\\n]\", &region1[2],\n\t\t\tperms, &offset, name);\n\t\tif (ret == 3) {\n\t\t\tname[0] = '\\0';\n\t\t} else if (ret != 4) {\n\t\t\teprintf(\"%s: Unable to parse \\\"%s\\\"\\nContent:\\n%s\\n\",\n\t\t\t\t__func__, path, buf);\n\t\t\tgdbr_close_file(ctx->desc);\n\t\t\tfree(buf);\n\t\t\trz_list_free(retlist);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(pos_1 = strchr(&region1[2], '-'))) {\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tstrncpy(&region2[2], pos_1 + 1, sizeof(region2) - 2 - 1);\n\t\tif (!*name) {\n\t\t\tsnprintf(name, sizeof(name), \"unk%d\", unk++);\n\t\t}\n\t\tperm = 0;\n\t\tfor (i = 0; i < 5 && perms[i]; i++) {\n\t\t\tswitch (perms[i]) {\n\t\t\tcase 'r': perm |= RZ_PERM_R; break;\n\t\t\tcase 'w': perm |= RZ_PERM_W; break;\n\t\t\tcase 'x': perm |= RZ_PERM_X; break;\n\t\t\tcase 'p': map_is_shared = false; break;\n\t\t\tcase 's': map_is_shared = true; break;\n\t\t\t}\n\t\t}\n\t\tmap_start = rz_num_get(NULL, region1);\n\t\tmap_end = rz_num_get(NULL, region2);\n\t\tif (map_start == map_end || map_end == 0) {\n\t\t\teprintf(\"%s: ignoring invalid map size: %s - %s\\n\",\n\t\t\t\t__func__, region1, region2);\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(map = rz_debug_map_new(name, map_start, map_end, perm, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tmap->offset = offset;\n\t\tmap->shared = map_is_shared;\n\t\tmap->file = strdup(name);\n\t\trz_list_append(retlist, map);\n\t\tptr = strtok(NULL, \"\\n\");\n\t}\n\tgdbr_close_file(ctx->desc);\n\tfree(buf);\n\treturn retlist;\n}\n\nstatic RzList /*<RzDebugMap *>*/ *rz_debug_gdb_modules_get(RzDebug *dbg) {\n\tchar *lastname = NULL;\n\tRzDebugMap *map;\n\tRzListIter *iter, *iter2;\n\tRzList *list, *last;\n\tbool must_delete;\n\tif (!(list = rz_debug_gdb_map_get(dbg))) {\n\t\treturn NULL;\n\t}\n\tif (!(last = rz_list_newf((RzListFree)rz_debug_map_free))) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\trz_list_foreach_safe (list, iter, iter2, map) {\n\t\tconst char *file = map->file;\n\t\tif (!map->file) {\n\t\t\tfile = map->file = strdup(map->name);\n\t\t}\n\t\tmust_delete = true;\n\t\tif (file && *file == '/') {\n\t\t\tif (!lastname || strcmp(lastname, file)) {\n\t\t\t\tmust_delete = false;\n\t\t\t}\n\t\t}\n\t\tif (must_delete) {\n\t\t\trz_list_delete(list, iter);\n\t\t} else {\n\t\t\trz_list_append(last, map);\n\t\t\tfree(lastname);\n\t\t\tlastname = strdup(file);\n\t\t}\n\t}\n\tlist->free = NULL;\n\tfree(lastname);\n\trz_list_free(list);\n\treturn last;\n}\n\nstatic int rz_debug_gdb_reg_write(RzDebug *dbg, int type, const ut8 *buf, int size) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tif (!ctx->reg_buf) {\n\t\t// we cannot write registers before we once read them\n\t\treturn -1;\n\t}\n\tint buflen = 0;\n\tint bits = dbg->analysis->bits;\n\tconst char *pcname = rz_reg_get_name(dbg->analysis->reg, RZ_REG_NAME_PC);\n\tRzRegItem *reg = rz_reg_get(dbg->analysis->reg, pcname, 0);\n\tif (reg) {\n\t\tif (dbg->analysis->bits != reg->size) {\n\t\t\tbits = reg->size;\n\t\t}\n\t}\n\tfree(rz_reg_get_bytes(dbg->reg, type, &buflen));\n\t// some implementations of the gdb protocol are acting weird.\n\t// so winedbg is not able to write registers through the <G> packet\n\t// and also it does not return the whole gdb register profile after\n\t// calling <g>\n\t// so this workaround resizes the small register profile buffer\n\t// to the whole set and fills the rest with 0\n\tif (ctx->buf_size < buflen) {\n\t\tut8 *new_buf = realloc(ctx->reg_buf, buflen * sizeof(ut8));\n\t\tif (!new_buf) {\n\t\t\treturn -1;\n\t\t}\n\t\tctx->reg_buf = new_buf;\n\t\tmemset(new_buf + ctx->buf_size, 0, buflen - ctx->buf_size);\n\t}\n\n\tRzRegItem *current = NULL;\n\t// We default to little endian if there's no way to get the configuration,\n\t// since this was the behaviour prior to the change.\n\tRzRegArena *arena = dbg->reg->regset[type].arena;\n\tfor (;;) {\n\t\tcurrent = rz_reg_next_diff(dbg->reg, type, ctx->reg_buf, buflen, current, bits);\n\t\tif (!current) {\n\t\t\tbreak;\n\t\t}\n\t\tgdbr_write_reg(ctx->desc, current->name, (char *)arena->bytes + (current->offset / 8), current->size / 8);\n\t}\n\treturn true;\n}\n\nstatic int rz_debug_gdb_continue(RzDebug *dbg, int pid, int tid, int sig) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tgdbr_continue(ctx->desc, pid, -1, sig); // Continue all threads\n\tif (ctx->desc->stop_reason.is_valid && ctx->desc->stop_reason.thread.present) {\n\t\t// if (desc->tid != desc->stop_reason.thread.tid) {\n\t\t//\teprintf (\"thread id (%d) in reason differs from current thread id (%d)\\n\", dbg->pid, dbg->tid);\n\t\t// }\n\t\tctx->desc->tid = ctx->desc->stop_reason.thread.tid;\n\t}\n\treturn ctx->desc->tid;\n}\n\nstatic RzDebugReasonType rz_debug_gdb_wait(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tif (!ctx->desc->stop_reason.is_valid) {\n\t\tif (gdbr_stop_reason(ctx->desc) < 0) {\n\t\t\tdbg->reason.type = RZ_DEBUG_REASON_UNKNOWN;\n\t\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t\t}\n\t}\n\tif (ctx->desc->stop_reason.thread.present) {\n\t\tdbg->reason.tid = ctx->desc->stop_reason.thread.tid;\n\t\tdbg->pid = ctx->desc->stop_reason.thread.pid;\n\t\tdbg->tid = ctx->desc->stop_reason.thread.tid;\n\t\tif (dbg->pid != ctx->desc->pid || dbg->tid != ctx->desc->tid) {\n\t\t\t// eprintf (\"= attach %d %d\\n\", dbg->pid, dbg->tid);\n\t\t\tgdbr_select(ctx->desc, dbg->pid, dbg->tid);\n\t\t}\n\t}\n\tdbg->reason.signum = ctx->desc->stop_reason.signum;\n\tdbg->reason.type = ctx->desc->stop_reason.reason;\n\treturn ctx->desc->stop_reason.reason;\n}\n\nstatic int rz_debug_gdb_attach(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tRzIODesc *d = dbg->iob.io->desc;\n\t// TODO: the core must update the dbg.swstep config var when this var is changed\n\tdbg->swstep = false;\n\t// eprintf (\"XWJSTEP TOFALSE\\n\");\n\tif (d && d->plugin && d->plugin->name && d->data) {\n\t\tif (!strcmp(\"gdb\", d->plugin->name)) {\n\t\t\tRzIOGdb *g = d->data;\n\t\t\tctx->origrziogdb = (RzIOGdb **)&d->data; // TODO bit of a hack, please improve\n\t\t\tctx->support_sw_bp = UNKNOWN;\n\t\t\tctx->support_hw_bp = UNKNOWN;\n\t\t\tctx->desc = &g->desc;\n\t\t\tint arch = rz_sys_arch_id(dbg->arch);\n\t\t\tint bits = dbg->analysis->bits;\n\t\t\tgdbr_set_architecture(ctx->desc, arch, bits);\n\t\t} else {\n\t\t\teprintf(\"ERROR: Underlying IO descriptor is not a GDB one..\\n\");\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int rz_debug_gdb_detach(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tint ret = 0;\n\n\tif (pid <= 0 || !ctx->desc->stub_features.multiprocess) {\n\t\tgdbr_detach(ctx->desc);\n\t}\n\tret = gdbr_detach_pid(ctx->desc, pid);\n\n\tif (dbg->pid == pid) {\n\t\tctx->desc = NULL;\n\t}\n\treturn ret;\n}\n\nstatic const char *rz_debug_gdb_reg_profile(RzDebug *dbg) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tint arch = rz_sys_arch_id(dbg->arch);\n\tint bits = dbg->analysis->bits;\n\t// XXX This happens when rizin set dbg.backend before opening io_gdb\n\tif (!ctx->desc) {\n\t\treturn gdbr_get_reg_profile(arch, bits);\n\t}\n\tif (!ctx->desc->target.valid) {\n\t\tgdbr_set_architecture(ctx->desc, arch, bits);\n\t}\n\tif (ctx->desc->target.regprofile) {\n\t\treturn strdup(ctx->desc->target.regprofile);\n\t}\n\treturn NULL;\n}\n\nstatic int rz_debug_gdb_set_reg_profile(RzDebug *dbg, const char *str) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tif (ctx->desc && str) {\n\t\treturn gdbr_set_reg_profile(ctx->desc, str);\n\t}\n\treturn false;\n}\n\nstatic int rz_debug_gdb_breakpoint(RzBreakpoint *bp, RzBreakpointItem *b, bool set) {\n\tRzDebug *dbg = bp->user;\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tint ret = 0, bpsize;\n\tif (!b) {\n\t\treturn false;\n\t}\n\tbpsize = b->size;\n\t// TODO handle conditions\n\tswitch (b->perm) {\n\tcase RZ_PERM_X: {\n\t\tif (set) {\n\t\t\tret = b->hw ? gdbr_set_hwbp(ctx->desc, b->addr, \"\", bpsize) : gdbr_set_bp(ctx->desc, b->addr, \"\", bpsize);\n\t\t} else {\n\t\t\tret = b->hw ? gdbr_remove_hwbp(ctx->desc, b->addr, bpsize) : gdbr_remove_bp(ctx->desc, b->addr, bpsize);\n\t\t}\n\t\tbreak;\n\t}\n\t// TODO handle size (area of watch in upper layer and then bpsize. For the moment watches are set on exact on byte\n\tcase RZ_PERM_W: {\n\t\tif (set) {\n\t\t\tgdbr_set_hww(ctx->desc, b->addr, \"\", 1);\n\t\t} else {\n\t\t\tgdbr_remove_hww(ctx->desc, b->addr, 1);\n\t\t}\n\t\tbreak;\n\t}\n\tcase RZ_PERM_R: {\n\t\tif (set) {\n\t\t\tgdbr_set_hwr(ctx->desc, b->addr, \"\", 1);\n\t\t} else {\n\t\t\tgdbr_remove_hwr(ctx->desc, b->addr, 1);\n\t\t}\n\t\tbreak;\n\t}\n\tcase RZ_PERM_ACCESS: {\n\t\tif (set) {\n\t\t\tgdbr_set_hwa(ctx->desc, b->addr, \"\", 1);\n\t\t} else {\n\t\t\tgdbr_remove_hwa(ctx->desc, b->addr, 1);\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\treturn !ret;\n}\n\nstatic bool rz_debug_gdb_kill(RzDebug *dbg, int pid, int tid, int sig) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\t// TODO kill based on pid and signal\n\tif (sig != 0) {\n\t\tif (gdbr_kill(ctx->desc) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int rz_debug_gdb_select(RzDebug *dbg, int pid, int tid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tif (!ctx->desc || !*ctx->origrziogdb) {\n\t\tctx->desc = NULL; // TODO hacky fix, please improve. I would suggest using a **desc instead of a *desc, so it is automatically updated\n\t\treturn false;\n\t}\n\n\treturn gdbr_select(ctx->desc, pid, tid) >= 0;\n}\n\nstatic RzDebugInfo *rz_debug_gdb_info(RzDebug *dbg, const char *arg) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tRzDebugInfo *rdi;\n\tif (!(rdi = RZ_NEW0(RzDebugInfo))) {\n\t\treturn NULL;\n\t}\n\tRzList *th_list;\n\tbool list_alloc = false;\n\tif (dbg->threads) {\n\t\tth_list = dbg->threads;\n\t} else {\n\t\tth_list = rz_debug_gdb_threads(dbg, dbg->pid);\n\t\tlist_alloc = true;\n\t}\n\tRzDebugPid *th;\n\tRzListIter *it;\n\tbool found = false;\n\trz_list_foreach (th_list, it, th) {\n\t\tif (th->pid == dbg->pid) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trdi->pid = dbg->pid;\n\trdi->tid = dbg->tid;\n\trdi->exe = gdbr_exec_file_read(ctx->desc, dbg->pid);\n\trdi->status = found ? th->status : RZ_DBG_PROC_STOP;\n\trdi->uid = found ? th->uid : -1;\n\trdi->gid = found ? th->gid : -1;\n\tif (gdbr_stop_reason(ctx->desc) >= 0) {\n\t\teprintf(\"signal: %d\\n\", ctx->desc->stop_reason.signum);\n\t\trdi->signum = ctx->desc->stop_reason.signum;\n\t}\n\tif (list_alloc) {\n\t\trz_list_free(th_list);\n\t}\n\treturn rdi;\n}\n\n#include \"native/bt.c\"\n\nstatic RzList /*<RzDebugFrame *>*/ *rz_debug_gdb_frames(RzDebug *dbg, ut64 at) {\n\treturn rz_debug_native_frames(dbg, at);\n}\n\nRzDebugPlugin rz_debug_plugin_gdb = {\n\t.name = \"gdb\",\n\t/* TODO: Add support for more architectures here */\n\t.license = \"LGPL3\",\n\t.arch = \"x86,arm,sh,mips,avr,lm32,v850,ba2\",\n\t.bits = RZ_SYS_BITS_16 | RZ_SYS_BITS_32 | RZ_SYS_BITS_64,\n\t.init = rz_debug_gdb_init,\n\t.fini = rz_debug_gdb_fini,\n\t.step = rz_debug_gdb_step,\n\t.cont = rz_debug_gdb_continue,\n\t.attach = &rz_debug_gdb_attach,\n\t.detach = &rz_debug_gdb_detach,\n\t.threads = &rz_debug_gdb_threads,\n\t.pids = &rz_debug_gdb_pids,\n\t.canstep = 1,\n\t.wait = &rz_debug_gdb_wait,\n\t.map_get = rz_debug_gdb_map_get,\n\t.modules_get = rz_debug_gdb_modules_get,\n\t.breakpoint = &rz_debug_gdb_breakpoint,\n\t.reg_read = &rz_debug_gdb_reg_read,\n\t.reg_write = &rz_debug_gdb_reg_write,\n\t.reg_profile = (void *)rz_debug_gdb_reg_profile,\n\t.set_reg_profile = &rz_debug_gdb_set_reg_profile,\n\t.kill = &rz_debug_gdb_kill,\n\t.info = &rz_debug_gdb_info,\n\t.select = &rz_debug_gdb_select,\n\t.frames = &rz_debug_gdb_frames,\n\t//.bp_write = &rz_debug_gdb_bp_write,\n\t//.bp_read = &rz_debug_gdb_bp_read,\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n\t.type = RZ_LIB_TYPE_DBG,\n\t.data = &rz_debug_plugin_gdb,\n\t.version = RZ_VERSION\n};\n#endif\n", "// SPDX-FileCopyrightText: 2016-2018 pancake <pancake@nopcode.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <rz_io.h>\n#include <rz_debug.h>\n\nstatic int __io_step(RzDebug *dbg) {\n\tfree(dbg->iob.system(dbg->iob.io, \"ds\"));\n\treturn true;\n}\n\nstatic int __io_step_over(RzDebug *dbg) {\n\tfree(dbg->iob.system(dbg->iob.io, \"dso\"));\n\treturn true;\n}\n\nstatic RzList /*<RzDebugMap *>*/ *__io_maps(RzDebug *dbg) {\n\tRzList *list = rz_list_new();\n\tchar *str = dbg->iob.system(dbg->iob.io, \"dm\");\n\tif (!str) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\tchar *ostr = str;\n\tut64 map_start, map_end;\n\tchar perm[32];\n\tchar name[512];\n\tfor (;;) {\n\t\tchar *nl = strchr(str, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\t*name = 0;\n\t\t\t*perm = 0;\n\t\t\tmap_start = map_end = 0LL;\n\t\t\tif (!strncmp(str, \"sys \", 4)) {\n\t\t\t\tchar *sp = strchr(str + 4, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\tstr = sp + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *_s_ = strstr(str, \" s \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\t_s_ = strstr(str, \" ? \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %s %s\",\n\t\t\t\t&map_start, &map_end, perm, name);\n\t\t\tif (map_end != 0LL) {\n\t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0);\n\t\t\t\trz_list_append(list, map);\n\t\t\t}\n\t\t\tstr = nl + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(ostr);\n\trz_cons_reset();\n\treturn list;\n}\n\nstatic RzDebugReasonType __io_wait(RzDebug *dbg, int pid) {\n\t/* do nothing */\n\treturn RZ_DEBUG_REASON_NONE;\n}\n\nstatic int __io_attach(RzDebug *dbg, int pid) {\n\treturn true;\n}\n\n// \"drp\" register profile\nstatic char *__io_reg_profile(RzDebug *dbg) {\n\trz_cons_push();\n\tchar *drp = dbg->iob.system(dbg->iob.io, \"drp\");\n\tif (drp) {\n\t\treturn drp;\n\t}\n\tchar *buf = rz_cons_get_buffer_dup();\n\tif (RZ_STR_ISNOTEMPTY(buf)) {\n\t\trz_cons_pop();\n\t\treturn buf;\n\t}\n\tfree(buf);\n\trz_cons_pop();\n\treturn rz_analysis_get_reg_profile(dbg->analysis);\n}\n\n// \"dr8\" read register state\nstatic int __reg_read(RzDebug *dbg, int type, ut8 *buf, int size) {\n\tchar *dr8 = dbg->iob.system(dbg->iob.io, \"dr8\");\n\tif (!dr8) {\n\t\tchar *fb = rz_cons_get_buffer_dup();\n\t\tif (RZ_STR_ISEMPTY(fb)) {\n\t\t\tfree(fb);\n\t\t\teprintf(\"debug.io: Failed to get dr8 from io\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tdr8 = fb;\n\t\trz_cons_reset();\n\t}\n\tut8 *bregs = calloc(1, strlen(dr8));\n\tif (!bregs) {\n\t\tfree(dr8);\n\t\treturn -1;\n\t}\n\trz_str_trim((char *)bregs);\n\tint sz = rz_hex_str2bin(dr8, bregs);\n\tif (sz > 0) {\n\t\tmemcpy(buf, bregs, RZ_MIN(size, sz));\n\t\tfree(bregs);\n\t\tfree(dr8);\n\t\treturn size;\n\t} else {\n\t\t// eprintf (\"SIZE %d (%s)\\n\", sz, regs);\n\t}\n\tfree(bregs);\n\tfree(dr8);\n\treturn -1;\n}\n\n// \"dc\" continue execution\nstatic int __io_continue(RzDebug *dbg, int pid, int tid, int sig) {\n\tdbg->iob.system(dbg->iob.io, \"dc\");\n\trz_cons_flush();\n\treturn true;\n}\n\n// \"dk\" send kill signal\nstatic bool __io_kill(RzDebug *dbg, int pid, int tid, int sig) {\n\tconst char *cmd = sdb_fmt(\"dk %d\", sig);\n\tdbg->iob.system(dbg->iob.io, cmd);\n\trz_cons_flush();\n\treturn true;\n}\n\nRzDebugPlugin rz_debug_plugin_io = {\n\t.name = \"io\",\n\t.license = \"MIT\",\n\t.arch = \"any\", // TODO: exception!\n\t.bits = RZ_SYS_BITS_32 | RZ_SYS_BITS_64,\n\t.step = __io_step,\n\t.map_get = __io_maps,\n\t.attach = &__io_attach,\n\t.wait = &__io_wait,\n\t.reg_read = __reg_read,\n\t.cont = __io_continue,\n\t.kill = __io_kill,\n\t.reg_profile = __io_reg_profile,\n\t.step_over = __io_step_over,\n\t.canstep = 1,\n#if 0\n\t.init = __esil_init,\n\t.contsc = __esil_continue_syscall,\n\t.detach = &__esil_detach,\n\t.stop = __esil_stop,\n\t.breakpoint = &__esil_breakpoint,\n#endif\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n\t.type = RZ_LIB_TYPE_DBG,\n\t.data = &rz_debug_plugin_io,\n\t.version = RZ_VERSION\n};\n#endif\n", "#ifndef RZ_TYPES_BASE_H\n#define RZ_TYPES_BASE_H\n\n#include <ctype.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <math.h>\n\n#define cut8  const unsigned char\n#define ut64  unsigned long long\n#define st64  long long\n#define ut32  unsigned int\n#define st32  int\n#define ut16  unsigned short\n#define st16  short\n#define ut8   unsigned char\n#define st8   signed char\n#define boolt int\n\n#if defined(_MSC_VER)\ntypedef intptr_t ssize_t;\n#endif\n\n#if defined(_MSC_VER)\n#define RZ_ALIGNED(x) __declspec(align(x))\n#else\n#define RZ_ALIGNED(x) __attribute__((aligned(x)))\n#endif\n\ntypedef struct _ut80 {\n\tut64 Low;\n\tut16 High;\n} ut80;\ntypedef struct _ut96 {\n\tut64 Low;\n\tut32 High;\n} ut96;\ntypedef struct _ut128 {\n\tut64 Low;\n\tst64 High;\n} ut128;\ntypedef struct _ut256 {\n\tut128 Low;\n\tut128 High;\n} ut256;\ntypedef struct _utX {\n\tut80 v80;\n\tut96 v96;\n\tut128 v128;\n\tut256 v256;\n} utX;\n\n#include <stdbool.h>\n\n#define RZ_EMPTY \\\n\t{ 0 }\n#define RZ_EMPTY2 \\\n\t{ \\\n\t\t{ 0 } \\\n\t}\n\n/* limits */\n#undef UT64_MAX\n#undef UT64_GT0\n#undef UT64_LT0\n#undef UT64_MIN\n#undef UT32_MAX\n#undef UT32_MIN\n#undef UT16_MIN\n#undef UT8_MIN\n#define ST64_MAX  ((st64)0x7FFFFFFFFFFFFFFFULL)\n#define ST64_MIN  ((st64)(-ST64_MAX - 1))\n#define UT64_MAX  0xFFFFFFFFFFFFFFFFULL\n#define UT64_GT0  0x8000000000000000ULL\n#define UT64_LT0  0x7FFFFFFFFFFFFFFFULL\n#define UT64_MIN  0ULL\n#define UT64_32U  0xFFFFFFFF00000000ULL\n#define UT64_16U  0xFFFFFFFFFFFF0000ULL\n#define UT64_8U   0xFFFFFFFFFFFFFF00ULL\n#define UT32_MIN  0U\n#define UT16_MIN  0U\n#define UT32_GT0  0x80000000U\n#define UT32_LT0  0x7FFFFFFFU\n#define ST32_MAX  0x7FFFFFFF\n#define ST32_MIN  (-ST32_MAX - 1)\n#define UT32_MAX  0xFFFFFFFFU\n#define ST16_MAX  0x7FFF\n#define ST16_MIN  (-ST16_MAX - 1)\n#define UT16_GT0  0x8000U\n#define UT16_MAX  0xFFFFU\n#define ST8_MAX   0x7F\n#define ST8_MIN   (-ST8_MAX - 1)\n#define UT8_GT0   0x80U\n#define UT8_MAX   0xFFU\n#define UT8_MIN   0x00U\n#define ASCII_MIN 32\n#define ASCII_MAX 127\n\n#if SSIZE_MAX == ST32_MAX\n#define SZT_MAX  UT32_MAX\n#define SZT_MIN  UT32_MIN\n#define SSZT_MAX ST32_MAX\n#define SSZT_MIN ST32_MIN\n#else\n#define SZT_MAX  UT64_MAX\n#define SZT_MIN  UT64_MIN\n#define SSZT_MAX ST64_MAX\n#define SSZT_MIN ST64_MIN\n#endif\n\n#define UT64_ALIGN(x) (x + (x - (x % sizeof(ut64))))\n#define UT32_ALIGN(x) (x + (x - (x % sizeof(ut32))))\n#define UT16_ALIGN(x) (x + (x - (x % sizeof(ut16))))\n\n#define UT32_LO(x) ((ut32)((x)&UT32_MAX))\n#define UT32_HI(x) ((ut32)(((ut64)(x)) >> 32) & UT32_MAX)\n\n#define RZ_BETWEEN(x, y, z) (((y) >= (x)) && ((y) <= (z)))\n#define RZ_ROUND(x, y)      ((x) % (y)) ? (x) + ((y) - ((x) % (y))) : (x)\n#define RZ_DIM(x, y, z)     (((x) < (y)) ? (y) : ((x) > (z)) ? (z) \\\n\t\t\t\t\t\t\t     : (x))\n#ifndef RZ_MAX_DEFINED\n#define RZ_MAX(x, y) (((x) > (y)) ? (x) : (y))\n#define RZ_MAX_DEFINED\n#endif\n#ifndef RZ_MIN_DEFINED\n#define RZ_MIN(x, y) (((x) > (y)) ? (y) : (x))\n#define RZ_MIN_DEFINED\n#endif\n#define RZ_ABS(x)       (((x) < 0) ? -(x) : (x))\n#define RZ_BTW(x, y, z) (((x) >= (y)) && ((y) <= (z))) ? y : x\n\n#include \"rz_types_overflow.h\"\n\n/* copied from bithacks.h */\n#define B_IS_SET(x, n) (((x) & (1ULL << (n))) ? 1 : 0)\n#define B_SET(x, n)    ((x) |= (1ULL << (n)))\n#define B_EVEN(x)      (((x)&1) == 0)\n#define B_ODD(x)       (!B_EVEN((x)))\n#define B_UNSET(x, n)  ((x) &= ~(1ULL << (n)))\n#define B_TOGGLE(x, n) ((x) ^= (1ULL << (n)))\n\n#define B11111 31\n#define B11110 30\n#define B11101 29\n#define B11100 28\n#define B11011 27\n#define B11010 26\n#define B11001 25\n#define B11000 24\n#define B10111 23\n#define B10110 22\n#define B10101 21\n#define B10100 20\n#define B10011 19\n#define B10010 18\n#define B10001 17\n#define B10000 16\n#define B1111  15\n#define B1110  14\n#define B1101  13\n#define B1100  12\n#define B1011  11\n#define B1010  10\n#define B1001  9\n#define B1000  8\n#define B0111  7\n#define B0110  6\n#define B0101  5\n#define B0100  4\n#define B0011  3\n#define B0010  2\n#define B0001  1\n#define B0000  0\n#undef B\n#define B4(a, b, c, d) ((a << 12) | (b << 8) | (c << 4) | (d))\n\n/* portable non-c99 inf/nan types */\n#if !defined(INFINITY)\n#define INFINITY (1.0f / 0.0f)\n#endif\n\n#if !defined(NAN)\n#define NAN (0.0f / 0.0f)\n#endif\n\n/* A workaround against libc headers redefinition of __attribute__:\n * Standard include has lines like\n * #if (GCC_VERSION < 2007)\n * # define __attribute__(x)\n * #endif\n * So we have do remove this define for TinyCC compiler\n */\n#if defined(__TINYC__) && (GCC_VERSION < 2007)\n#undef __attribute__\n#endif\n\n#ifdef _MSC_VER\n#define RZ_PACKED(__Declaration__) __pragma(pack(push, 1)) __Declaration__ __pragma(pack(pop))\n#undef INFINITY\n#undef NAN\n#elif defined(__GNUC__) || defined(__TINYC__)\n#define RZ_PACKED(__Declaration__) __Declaration__ __attribute__((__packed__))\n#endif\n\n#if APPLE_SDK_IPHONESIMULATOR\n#undef DEBUGGER\n#define DEBUGGER 0\n#endif\n\n#define HEAPTYPE(x) \\\n\tstatic x *x##_new(x n) { \\\n\t\tx *m = malloc(sizeof(x)); \\\n\t\treturn m ? *m = n, m : m; \\\n\t}\n\n#endif // RZ_TYPES_BASE_H\n", "// SPDX-FileCopyrightText: 2009-2020 pancake <pancake@nopcode.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <rz_list.h>\n#include <rz_util/rz_log.h>\n#include <rz_util/rz_str.h>\n#include <rz_reg.h>\n#include <rz_util.h>\n#include <rz_util/rz_assert.h>\n#include <rz_lib.h>\n#include <string.h>\n\nstatic void rz_reg_profile_def_free(RzRegProfileDef *def) {\n\tif (!def) {\n\t\treturn;\n\t}\n\tfree(def->name);\n\tfree(def->comment);\n\tfree(def->flags);\n\tfree(def);\n}\n\nstatic void rz_reg_profile_alias_free(RzRegProfileAlias *alias) {\n\tif (!alias) {\n\t\treturn;\n\t}\n\tfree(alias->reg_name);\n\tfree(alias->alias);\n\tfree(alias);\n}\n\n/**\n * Like rz_reg_type_by_name, but warn if non-existent\n */\nstatic int expect_reg_type_by_name(const char *str) {\n\tint r = rz_reg_type_by_name(str);\n\tif (r < 0) {\n\t\tRZ_LOG_WARN(\"No register type for type abbreviation \\\"%s\\\".\\n\", str);\n\t}\n\treturn r;\n}\n\n/**\n * \\brief Parses a register type string.\n *\n * The type string must be of the following form:\n *\n * <sub-type>@<main-type>\n *\n * \"<sub-type>@\" is optional.\n *\n * \\param item Register item whichs types are set.\n * \\param type_str The type string.\n * \\return true On success.\n * \\return false On failure.\n */\nstatic bool parse_type(RZ_OUT RzRegProfileDef *def, const char *type_str) {\n\trz_return_val_if_fail(def && type_str, false);\n\tchar *s = strdup(type_str);\n\tchar *at = strchr(s, '@');\n\tif (at) {\n\t\t// This register has a secondary type e.g. xmm@fpu\n\t\tdef->arena_type = expect_reg_type_by_name(at + 1);\n\t\ts[at - s] = '\\0';\n\t\tdef->type = expect_reg_type_by_name(s);\n\t} else {\n\t\tdef->type = expect_reg_type_by_name(s);\n\t\tdef->arena_type = def->type;\n\t\tif (def->type == RZ_REG_TYPE_FLG) { // Hack to put flgs into gpr arena.\n\t\t\tdef->arena_type = RZ_REG_TYPE_GPR;\n\t\t} else {\n\t\t\tdef->arena_type = def->type;\n\t\t}\n\t}\n\tbool res = true;\n\tif (def->type < 0 || def->arena_type < 0) {\n\t\tRZ_LOG_ERROR(\"Illegal type abbreviation \\\"%s\\\"\\n\", s);\n\t\tres = false;\n\t}\n\tfree(s);\n\treturn res;\n}\n\n/**\n * \\brief Parses the size of a register definition.\n * Sizes with . in front are in bits. Otherwise in bytes.\n *\n * \\param s Size string.\n * \\return ut32 The size as integer or UT64_MAX if it fails.\n */\nstatic ut32 parse_size(char *s) {\n\trz_return_val_if_fail(s, UT32_MAX);\n\tif (s[0] == '.') {\n\t\treturn strtoul(s + 1, NULL, 0);\n\t} else {\n\t\treturn strtoul(s, NULL, 0) * 8;\n\t}\n}\n\n/**\n * \\brief Parses the offset of a register defintion and sets the offset in \\p def->offset.\n *\n * Offset is of the form: <byte>.<bit>\n * .<bit> is optional.\n *\n * \\param s Offset string.\n * \\param def The defintion item to store the offset into \\p def->offset in bits.\n * \\return false On failure (sets def->offset = UT32_MAX).\n * \\return true On success.\n */\nstatic bool parse_offset(const char *s, RZ_OUT RzRegProfileDef *def) {\n\trz_return_val_if_fail(s && def, false);\n\tif (s[0] == '?') {\n\t\tdef->offset = UT32_MAX;\n\t\treturn true;\n\t} else if (s[0] == '.') {\n\t\tdef->offset = strtoul(s + 1, NULL, 0);\n\t\treturn true;\n\t}\n\tdef->offset = strtoul(s, NULL, 0) * 8;\n\n\tconst char *bi = strchr(s, '.');\n\tif (!bi) {\n\t\t// No bit offset given.\n\t\treturn true;\n\t}\n\n\tut8 bit_offset = strtoul(bi + 1, NULL, 0);\n\tdef->offset += bit_offset;\n\treturn true;\n}\n\n/**\n * \\brief Parses a register alias.\n *\n * The alias is of the form:\n * \"=<alias>  <reg name>\"\n *\n * \\param reg The RzReg struct with the register profile.\n * \\param tokens A list with both tokens of the alias string.\n * \\return true On success.\n * \\return false On Failure.\n */\nstatic bool parse_alias(RZ_OUT RzList /*<RzRegProfileAlias *>*/ *alias_list, RZ_BORROW RzList /*<char *>*/ *tokens) {\n\trz_return_val_if_fail(alias_list && tokens, false);\n\tRzRegProfileAlias *pa = RZ_NEW0(RzRegProfileAlias);\n\tif (!pa) {\n\t\tRZ_LOG_WARN(\"Unable to allocate memory.\\n\");\n\t\treturn false;\n\t}\n\n\tconst char *real_name = rz_list_get_n(tokens, 1);\n\tconst char *alias = rz_list_get_n(tokens, 0);\n\tif (!alias) {\n\t\tRZ_LOG_WARN(\"Failed to get alias name from token.\\n\");\n\t\tfree(pa);\n\t\treturn false;\n\t}\n\n\tRzRegisterId role = rz_reg_get_name_idx(alias + 1);\n\tif (!(role >= 0 && role < RZ_REG_NAME_LAST)) {\n\t\tRZ_LOG_WARN(\"Invalid alias\\n\");\n\t\tfree(pa);\n\t\treturn false;\n\t}\n\n\tpa->alias = strdup(alias);\n\tpa->reg_name = strdup(real_name);\n\tpa->role = role;\n\trz_list_append(alias_list, pa);\n\n\treturn true;\n}\n\n/**\n * \\brief Parses a register definition.\n *\n * \\param reg Register struct with the register profile.\n * \\param tokens List of strings of a single register definition.\n * \\return false On failure.\n * \\return true On success.\n */\nstatic bool parse_def(RZ_OUT RzList /*<RzRegProfileDef *>*/ *def_list, RZ_BORROW RzList /*<char *>*/ *tokens) {\n\trz_return_val_if_fail(def_list && tokens, false);\n\n\tRzRegProfileDef *def = RZ_NEW0(RzRegProfileDef);\n\tif (!def) {\n\t\tRZ_LOG_WARN(\"Unable to allocate memory.\\n\");\n\t\treturn false;\n\t}\n\tconst char *name = rz_list_get_n(tokens, 1);\n\tif (!name) {\n\t\tgoto reg_parse_error;\n\t}\n\tdef->name = strdup(name);\n\n\tif (!parse_type(def, rz_list_get_n(tokens, 0))) {\n\t\tRZ_LOG_WARN(\"Invalid register type.\\n\");\n\t\tgoto reg_parse_error;\n\t}\n\n\tdef->size = parse_size(rz_list_get_n(tokens, 2));\n\tif (def->size == UT32_MAX || def->size == 0) {\n\t\tRZ_LOG_WARN(\"Invalid register size.\\n\");\n\t\tgoto reg_parse_error;\n\t}\n\n\tdef->packed = parse_size(rz_list_get_n(tokens, 4));\n\tif (def->packed == UT32_MAX) {\n\t\tRZ_LOG_WARN(\"Invalid register packed size.\\n\");\n\t\tgoto reg_parse_error;\n\t}\n\n\tif (!parse_offset(rz_list_get_n(tokens, 3), def)) {\n\t\tRZ_LOG_WARN(\"Invalid register offset.\\n\");\n\t\tgoto reg_parse_error;\n\t}\n\n\t// Comments and flags are optional\n\tif (rz_list_length(tokens) == 6) {\n\t\tconst char *comment_flag = rz_list_get_n(tokens, 5);\n\t\tif (!comment_flag) {\n\t\t\tgoto reg_parse_error;\n\t\t}\n\t\tif (comment_flag[0] == '#') {\n\t\t\t// Remove # from the comment\n\t\t\tdef->comment = strdup(comment_flag + 1);\n\t\t} else {\n\t\t\tdef->flags = strdup(comment_flag);\n\t\t}\n\t}\n\tRZ_LOG_DEBUG(\"profile: register def: %s %d %d %s\\n\", def->name, def->size, def->offset, def->flags);\n\trz_list_append(def_list, def);\n\n\treturn true;\n\nreg_parse_error:\n\trz_reg_profile_def_free(def);\n\treturn false;\n}\n\n/**\n * \\brief Parses a register profile string. Each line is either a register alias or a register definiton.\n *\n * A register alias string is of the following form:\n * \"=<alias>  <name>\\n\"\n *\n * A register definition string is of the following form:\n * \"(<sub-type>@)main-type  <name>  .<size>  <byte offset>(.<bit offset>)  <packed>  (# <comment> OR <flags>)\\n\"\n *\n * Elements in \"()\" are optional.\n * Each \"<...>\" token is separated by tab or space characters.\n *\n * * alias: Register alias (e.g. PC, A1 etc.)\n * * name: Register name.\n * * size: Register size in bits.\n * * main-type: Register type: gpr, fpr, ctr, flg etc.\n * * sub-type: The second register type (e.g. xmm@fpu : xmm is sub-type of fpu)\n * * byte offset: Offset into register profile in bytes.\n * * bit offset: Offset into the byte offset in bits.\n * * packed: Packed size of the register in bytes.\n * * comment: A comment about the register.\n * * Flags this register holds.\n *\n * \\param reg Register struct which holds all register items.\n * \\param profile Register profile string.\n * \\return false On failure.\n * \\return true On success.\n */\nstatic bool parse_reg_profile_str(RZ_OUT RzList /*<RzRegProfileAlias *>*/ *alias_list, RZ_OUT RzList /*<RzRegProfileDef *>*/ *def_list, const char *profile_str) {\n\trz_return_val_if_fail(alias_list && def_list && profile_str, false);\n\n\tRzList *def_lines = rz_str_split_duplist_n(profile_str, \"\\n\", 0, true);\n\trz_return_val_if_fail(def_lines, false);\n\n\tst32 l = 0; // Line number\n\tconst char *line;\n\tbool is_alias = false;\n\tRzListIter *it;\n\tRzList *toks = NULL;\n\trz_list_foreach (def_lines, it, line) {\n\t\t++l;\n\t\tif (RZ_STR_ISEMPTY(line)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rz_str_strchr(line, \"#\")) {\n\t\t\tRzList *line_and_cmt = rz_str_split_duplist_n_regex(line, \"#\", 0, true);\n\t\t\tchar *raw_comment = strdup(rz_list_get_top(line_and_cmt));\n\t\t\tif (!raw_comment) {\n\t\t\t\tRZ_LOG_WARN(\"Comment could not be split from register definition. Line: \\\"%s\\\"\\n\", line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *tmp = rz_str_prepend(raw_comment, \"#\");\n\t\t\tif (!tmp) {\n\t\t\t\tRZ_LOG_WARN(\"Could not prepend # to comment. Line: \\\"%s\\\".\\n\", line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *comment = strdup(tmp);\n\t\t\ttoks = rz_str_split_duplist_n_regex(rz_list_get_bottom(line_and_cmt), \"[[:blank:]]+\", 0, true);\n\t\t\trz_list_append(toks, comment);\n\t\t\trz_list_free(line_and_cmt);\n\t\t} else {\n\t\t\ttoks = rz_str_split_duplist_n_regex(line, \"[[:blank:]]+\", 0, true);\n\t\t}\n\t\tut32 toks_len = rz_list_length(toks);\n\t\tif (rz_list_empty(toks)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst char *first_tok = rz_list_get_n(toks, 0);\n\t\tif (first_tok[0] == '#') { // Comment line\n\t\t\tcontinue;\n\t\t} else if (first_tok[0] == '=') { // Alias\n\t\t\tif (toks_len != 2) {\n\t\t\t\tRZ_LOG_WARN(\"Invalid number of %d columns in alias \\\"%s\\\" at line %d. 2 needed.\\n\", toks_len, line, l);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tis_alias = true;\n\t\t} else if (isalpha(first_tok[0])) {\n\t\t\tif (toks_len != 5 && toks_len != 6) {\n\t\t\t\tRZ_LOG_WARN(\"Invalid number of %d columns in definition \\\"%s\\\" at line %d. 5 or 6 needed.\\n\", toks_len, line, l);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tRZ_LOG_WARN(\"Invalid line \\\"%s\\\" at register profiles line %d.\\n\", line, l);\n\t\t\tcontinue;\n\t\t}\n\t\tbool success = is_alias\n\t\t\t? parse_alias(alias_list, toks)\n\t\t\t: parse_def(def_list, toks);\n\t\tif (!success) {\n\t\t\tRZ_LOG_WARN(\"Parsing error in \\\"%s\\\" at line %d.\\n\", line, l);\n\t\t\trz_list_free(toks);\n\t\t\trz_list_free(def_lines);\n\t\t\treturn false;\n\t\t}\n\t\tis_alias = false;\n\t\trz_list_free(toks);\n\t}\n\trz_list_free(def_lines);\n\n\treturn true;\n}\n\nstatic void add_item_to_regset(RZ_BORROW RzReg *reg, RZ_BORROW RzRegItem *item) {\n\trz_return_if_fail(reg && item);\n\tRzRegisterType t = item->arena;\n\n\tif (!reg->regset[t].regs) {\n\t\treg->regset[t].regs = rz_list_newf((RzListFree)rz_reg_item_free);\n\t}\n\tif (!reg->regset[t].ht_regs) {\n\t\treg->regset[t].ht_regs = ht_pp_new0();\n\t}\n\n\t// Dynamically update the list of supported bit sizes\n\treg->bits |= item->size;\n\trz_list_append(reg->regset[t].regs, item);\n\tht_pp_insert(reg->regset[t].ht_regs, item->name, item);\n\n\t// Update the overall type of registers into a regset\n\tif (item->type == RZ_REG_TYPE_ANY) {\n\t\treg->regset[t].maskregstype = UT32_MAX;\n\t\treturn;\n\t}\n\treg->regset[t].maskregstype |= ((int)1 << item->type);\n}\n\n/**\n * \\brief Fills \\p reg->regset with the definitions and alias of the register profile.\n *\n * \\param reg The RzReg struct which holds the register profile and an empty \\p reg->regset\n * \\return false On failure.\n * \\return true On success.\n */\nRZ_API bool rz_reg_set_reg_profile(RZ_BORROW RzReg *reg) {\n\trz_return_val_if_fail(reg, false);\n\trz_return_val_if_fail(reg->reg_profile.alias && reg->reg_profile.defs, false);\n\n\tRzListIter *it;\n\tRzRegProfileAlias *alias;\n\trz_list_foreach (reg->reg_profile.alias, it, alias) {\n\t\tif (!rz_reg_set_name(reg, alias->role, alias->reg_name)) {\n\t\t\tRZ_LOG_WARN(\"Invalid alias gviven.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tRzRegProfileDef *def;\n\trz_list_foreach (reg->reg_profile.defs, it, def) {\n\t\tRzRegItem *item = RZ_NEW0(RzRegItem);\n\t\tif (!item) {\n\t\t\tRZ_LOG_WARN(\"Unable to allocate memory.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\titem->name = strdup(def->name);\n\n\t\titem->type = def->type;\n\t\titem->arena = def->arena_type;\n\n\t\titem->size = def->size;\n\t\titem->offset = def->offset;\n\t\t// Update the overall profile size\n\t\tif (item->offset + item->size > reg->size) {\n\t\t\treg->size = item->offset + item->size;\n\t\t}\n\n\t\titem->packed_size = def->packed;\n\n\t\tif (def->comment) {\n\t\t\titem->comment = strdup(def->comment);\n\t\t}\n\t\tif (def->flags) {\n\t\t\titem->flags = strdup(def->flags);\n\t\t}\n\n\t\tadd_item_to_regset(reg, item);\n\t}\n\n\treturn true;\n}\n\n/**\n * \\brief Parses a register profile string and sets up all registers accordingly in \\p reg.\n *\n * \\param reg The RzReg struct which should hold the register data.\n * \\param profile The register profile string.\n * \\return false On failure;\n * \\return true On success.\n */\nRZ_API bool rz_reg_set_profile_string(RZ_NONNULL RzReg *reg, RZ_NONNULL const char *profile_str) {\n\trz_return_val_if_fail(reg && profile_str, false);\n\t// Same profile, no need to change\n\tif (reg->reg_profile_str && !strcmp(reg->reg_profile_str, profile_str)) {\n\t\treturn true;\n\t}\n\n\t// we should reset all the arenas before setting the new reg profile\n\trz_reg_arena_pop(reg);\n\t// Purge the old registers\n\trz_reg_free_internal(reg, true);\n\trz_reg_arena_shrink(reg);\n\n\t// Cache the profile string\n\treg->reg_profile_str = strdup(profile_str);\n\treg->reg_profile.defs = rz_list_newf((RzListFree)rz_reg_profile_def_free);\n\treg->reg_profile.alias = rz_list_newf((RzListFree)rz_reg_profile_alias_free);\n\trz_return_val_if_fail(reg->reg_profile.defs && reg->reg_profile.alias, true);\n\n\tif (!parse_reg_profile_str(reg->reg_profile.alias, reg->reg_profile.defs, profile_str)) {\n\t\tRZ_LOG_WARN(\"Could not parse register profile string.\\n\");\n\t\trz_reg_free_internal(reg, false);\n\t\treturn false;\n\t}\n\n\t// Check for duplicates\n\tRzListIter *it, *tmp;\n\tRzRegProfileDef *def;\n\trz_list_foreach_safe (reg->reg_profile.defs, it, tmp, def) {\n\t\tif (rz_reg_get(reg, def->name, RZ_REG_TYPE_ANY)) {\n\t\t\tRZ_LOG_WARN(\"Ignoring duplicated register definition '%s'.\\n\", def->name);\n\t\t\trz_list_delete(reg->reg_profile.defs, it);\n\t\t}\n\t}\n\n\tif (!rz_reg_set_reg_profile(reg)) {\n\t\tRZ_LOG_WARN(\"Could not set reg profile.\\n\");\n\t\treturn false;\n\t}\n\n\treg->size = 0;\n\tfor (ut32 i = 0; i < RZ_REG_TYPE_LAST; i++) {\n\t\tRzRegSet *rs = &reg->regset[i];\n\t\tif (rs && rs->arena) {\n\t\t\treg->size += rs->arena->size; // Sums minimum arena size.\n\t\t}\n\t}\n\n\trz_reg_fit_arena(reg);\n\t// dup the last arena to allow regdiffing\n\trz_reg_arena_push(reg);\n\trz_reg_reindex(reg);\n\treturn true;\n}\n\nRZ_API bool rz_reg_set_profile(RzReg *reg, const char *profile) {\n\trz_return_val_if_fail(reg && profile, false);\n\tchar *base, *file;\n\tchar *str = rz_file_slurp(profile, NULL);\n\tif (!str) {\n\t\tbase = rz_sys_getenv(RZ_LIB_ENV);\n\t\tif (base) {\n\t\t\tfile = rz_str_append(base, profile);\n\t\t\tstr = rz_file_slurp(file, NULL);\n\t\t\tfree(file);\n\t\t}\n\t}\n\tif (!str) {\n\t\teprintf(\"rz_reg_set_profile: Cannot find '%s'\\n\", profile);\n\t\treturn false;\n\t}\n\tbool ret = rz_reg_set_profile_string(reg, str);\n\tfree(str);\n\treturn ret;\n}\n\nstatic char *gdb_to_rz_profile(const char *gdb) {\n\trz_return_val_if_fail(gdb, NULL);\n\tRzStrBuf *sb = rz_strbuf_new(\"\");\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\tchar *ptr1, *gptr, *gptr1;\n\tchar name[16], groups[128], type[16];\n\tconst int all = 1, gpr = 2, save = 4, restore = 8, float_ = 16,\n\t\t  sse = 32, vector = 64, system = 128, mmx = 256;\n\tint number, rel, offset, size, type_bits, ret;\n\t// Every line is -\n\t// Name Number Rel Offset Size Type Groups\n\tconst char *ptr = rz_str_trim_head_ro(gdb);\n\n\t// It's possible someone includes the heading line too. Skip it\n\tif (rz_str_startswith(ptr, \"Name\")) {\n\t\tif (!(ptr = strchr(ptr, '\\n'))) {\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr++;\n\t}\n\tfor (;;) {\n\t\t// Skip whitespace at beginning of line and empty lines\n\t\twhile (isspace((ut8)*ptr)) {\n\t\t\tptr++;\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ptr1 = strchr(ptr, '\\n'))) {\n\t\t\t*ptr1 = '\\0';\n\t\t} else {\n\t\t\teprintf(\"Could not parse line: %s (missing \\\\n)\\n\", ptr);\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn false;\n\t\t}\n\t\tret = sscanf(ptr, \" %s %d %d %d %d %s %s\", name, &number, &rel,\n\t\t\t&offset, &size, type, groups);\n\t\t// Groups is optional, others not\n\t\tif (ret < 6) {\n\t\t\tif (*ptr != '*') {\n\t\t\t\teprintf(\"Could not parse line: %s\\n\", ptr);\n\t\t\t\trz_strbuf_free(sb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If name is '', then skip\n\t\tif (rz_str_startswith(name, \"''\")) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If size is 0, skip\n\t\tif (size == 0) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\ttype_bits = 0;\n\t\t// Parse group\n\t\tif (ret >= 7) {\n\t\t\tgptr = groups;\n\t\t\twhile (1) {\n\t\t\t\tif ((gptr1 = strchr(gptr, ','))) {\n\t\t\t\t\t*gptr1 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (rz_str_startswith(gptr, \"general\")) {\n\t\t\t\t\ttype_bits |= gpr;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"all\")) {\n\t\t\t\t\ttype_bits |= all;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"save\")) {\n\t\t\t\t\ttype_bits |= save;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"restore\")) {\n\t\t\t\t\ttype_bits |= restore;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"float\")) {\n\t\t\t\t\ttype_bits |= float_;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"sse\")) {\n\t\t\t\t\ttype_bits |= sse;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"mmx\")) {\n\t\t\t\t\ttype_bits |= mmx;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"vector\")) {\n\t\t\t\t\ttype_bits |= vector;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"system\")) {\n\t\t\t\t\ttype_bits |= system;\n\t\t\t\t}\n\t\t\t\tif (!gptr1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgptr = gptr1 + 1;\n\t\t\t}\n\t\t}\n\t\t// If type is not defined, skip\n\t\tif (!*type) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: More mappings between gdb and rizin reg groups. For now, either fpu or gpr\n\t\tif (!(type_bits & sse) && !(type_bits & float_)) {\n\t\t\ttype_bits |= gpr;\n\t\t}\n\t\t// Print line\n\t\trz_strbuf_appendf(sb, \"%s\\t%s\\t.%d\\t%d\\t0\\n\",\n\t\t\t// Ref: Comment above about more register type mappings\n\t\t\t((type_bits & mmx) || (type_bits & float_) || (type_bits & sse)) ? \"fpu\" : \"gpr\",\n\t\t\tname, size * 8, offset);\n\t\t// Go to next line\n\t\tif (!ptr1) {\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr1 + 1;\n\t\tcontinue;\n\t}\n\treturn rz_strbuf_drain(sb);\n}\n\nRZ_API char *rz_reg_parse_gdb_profile(const char *profile_file) {\n\tchar *str = NULL;\n\tif (!(str = rz_file_slurp(profile_file, NULL))) {\n\t\tchar *base = rz_sys_getenv(RZ_LIB_ENV);\n\t\tif (base) {\n\t\t\tchar *file = rz_str_appendf(base, RZ_SYS_DIR \"%s\", profile_file);\n\t\t\tif (file) {\n\t\t\t\tstr = rz_file_slurp(file, NULL);\n\t\t\t\tfree(file);\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tchar *ret = gdb_to_rz_profile(str);\n\t\tfree(str);\n\t\treturn ret;\n\t}\n\teprintf(\"rz_reg_parse_gdb_profile: Cannot find '%s'\\n\", profile_file);\n\treturn NULL;\n}\n\nRZ_API char *rz_reg_profile_to_cc(RzReg *reg) {\n\tconst char *r0 = rz_reg_get_name_by_type(reg, \"R0\");\n\tconst char *a0 = rz_reg_get_name_by_type(reg, \"A0\");\n\tconst char *a1 = rz_reg_get_name_by_type(reg, \"A1\");\n\tconst char *a2 = rz_reg_get_name_by_type(reg, \"A2\");\n\tconst char *a3 = rz_reg_get_name_by_type(reg, \"A3\");\n\n\tif (!a0) {\n\t\tRZ_LOG_WARN(\"It is mandatory to have at least one argument register defined in the register profile.\\n\");\n\t\treturn NULL;\n\t}\n\tif (!r0) {\n\t\tr0 = a0;\n\t}\n\tif (a3 && a2 && a1) {\n\t\treturn rz_str_newf(\"%s reg(%s, %s, %s, %s)\", r0, a0, a1, a2, a3);\n\t}\n\tif (a2 && a1) {\n\t\treturn rz_str_newf(\"%s reg(%s, %s, %s)\", r0, a0, a1, a2);\n\t}\n\tif (a1) {\n\t\treturn rz_str_newf(\"%s reg(%s, %s)\", r0, a0, a1);\n\t}\n\treturn rz_str_newf(\"%s reg(%s)\", r0, a0);\n}\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2009-2018 pancake <pancake@nopcode.org>\n// SPDX-FileCopyrightText: 2009-2018 defragger <rlaemmert@gmail.com>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <rz_core.h>\n#include <rz_debug.h>\n#include <libgdbr.h>\n#include <gdbclient/commands.h>\n\ntypedef struct {\n\tlibgdbr_t desc;\n} RzIOGdb;\n\n#define UNKNOWN     (-1)\n#define UNSUPPORTED 0\n#define SUPPORTED   1\n\n#define PROC_NAME_SZ   1024\n#define PROC_REGION_SZ 100\n// PROC_REGION_SZ - 2 (used for `0x`). Due to how RZ_STR_DEF works this can't be\n// computed.\n#define PROC_REGION_LEFT_SZ 98\n#define PROC_PERM_SZ        5\n\ntypedef struct rz_debug_gdb_ctx_t {\n\tRzIOGdb **origrziogdb;\n\tlibgdbr_t *desc;\n\tut8 *reg_buf;\n\tint buf_size;\n\tint support_sw_bp;\n\tint support_hw_bp;\n} RzDebugGdbCtx;\n\nstatic bool rz_debug_gdb_init(RzDebug *dbg, void **user) {\n\tRzDebugGdbCtx *ctx = RZ_NEW0(RzDebugGdbCtx);\n\tif (!ctx) {\n\t\treturn false;\n\t}\n\tctx->support_sw_bp = UNKNOWN;\n\tctx->support_hw_bp = UNKNOWN;\n\t*user = ctx;\n\treturn true;\n}\n\nstatic void rz_debug_gdb_fini(RzDebug *dbg, void *user) {\n\tRzDebugGdbCtx *ctx = user;\n\tfree(ctx);\n}\n\nstatic int rz_debug_gdb_attach(RzDebug *dbg, int pid);\nstatic void check_connection(RzDebug *dbg) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tif (!ctx->desc) {\n\t\trz_debug_gdb_attach(dbg, -1);\n\t}\n}\n\nstatic int rz_debug_gdb_step(RzDebug *dbg) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tgdbr_step(ctx->desc, dbg->tid);\n\treturn true;\n}\n\nstatic RzList /*<RzDebugPid *>*/ *rz_debug_gdb_threads(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tRzList *list;\n\tif ((list = gdbr_threads_list(ctx->desc, pid))) {\n\t\tlist->free = (RzListFree)&rz_debug_pid_free;\n\t}\n\treturn list;\n}\n\nstatic RzList /*<RzDebugPid *>*/ *rz_debug_gdb_pids(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tRzList *list;\n\tif ((list = gdbr_pids_list(ctx->desc, pid))) {\n\t\tlist->free = (RzListFree)&rz_debug_pid_free;\n\t}\n\treturn list;\n}\n\nstatic int rz_debug_gdb_reg_read(RzDebug *dbg, int type, ut8 *buf, int size) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tint copy_size;\n\tint buflen = 0;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tgdbr_read_registers(ctx->desc);\n\tif (!ctx->desc || !ctx->desc->data) {\n\t\treturn -1;\n\t}\n\t// read the len of the current area\n\tfree(rz_reg_get_bytes(dbg->reg, type, &buflen));\n\tif (size < ctx->desc->data_len) {\n\t\teprintf(\"rz_debug_gdb_reg_read: small buffer %d vs %d\\n\",\n\t\t\t(int)size, (int)ctx->desc->data_len);\n\t\t//\treturn -1;\n\t}\n\tcopy_size = RZ_MIN(ctx->desc->data_len, size);\n\tbuflen = RZ_MAX(ctx->desc->data_len, buflen);\n\tif (ctx->reg_buf) {\n\t\t// if (buf_size < copy_size) { //desc->data_len) {\n\t\tif (buflen > ctx->buf_size) { // copy_size) {\n\t\t\tut8 *new_buf = realloc(ctx->reg_buf, buflen);\n\t\t\tif (!new_buf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tctx->reg_buf = new_buf;\n\t\t\tctx->buf_size = buflen;\n\t\t}\n\t} else {\n\t\tctx->reg_buf = calloc(buflen, 1);\n\t\tif (!ctx->reg_buf) {\n\t\t\treturn -1;\n\t\t}\n\t\tctx->buf_size = buflen;\n\t}\n\tmemset((void *)(volatile void *)buf, 0, size);\n\tmemcpy((void *)(volatile void *)buf, ctx->desc->data, RZ_MIN(copy_size, size));\n\tmemset((void *)(volatile void *)ctx->reg_buf, 0, buflen);\n\tmemcpy((void *)(volatile void *)ctx->reg_buf, ctx->desc->data, copy_size);\n#if 0\n\tint i;\n\t//for(i=0;i<168;i++) {\n\tfor(i=0;i<copy_size;i++) {\n\t\tif (!(i%16)) printf (\"\\n0x%08x  \", i);\n\t\tprintf (\"%02x \", buf[i]); //(ut8)desc->data[i]);\n\t}\n\tprintf(\"\\n\");\n#endif\n\treturn ctx->desc->data_len;\n}\n\nstatic RzList /*<RzDebugMap *>*/ *rz_debug_gdb_map_get(RzDebug *dbg) { // TODO\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc || ctx->desc->pid <= 0) {\n\t\treturn NULL;\n\t}\n\tRzList *retlist = NULL;\n\tif (ctx->desc->get_baddr) {\n\t\tctx->desc->get_baddr = false;\n\t\tut64 baddr;\n\t\tif ((baddr = gdbr_get_baddr(ctx->desc)) != UINT64_MAX) {\n\t\t\tif (!(retlist = rz_list_new())) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRzDebugMap *map;\n\t\t\tif (!(map = rz_debug_map_new(\"\", baddr, baddr, RZ_PERM_RX, 0))) {\n\t\t\t\trz_list_free(retlist);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trz_list_append(retlist, map);\n\t\t\treturn retlist;\n\t\t}\n\t}\n\n\t// Get file from GDB\n\tchar path[128];\n\tut8 *buf;\n\tint ret;\n\t// TODO don't hardcode buffer size, get from remote target\n\t// (I think gdb doesn't do that, it just keeps reading till EOF)\n\t// fstat info can get file size, but it doesn't work for /proc/pid/maps\n\tut64 buflen = 16384;\n\t// If /proc/%d/maps is not valid for gdbserver, we return NULL, as of now\n\tsnprintf(path, sizeof(path) - 1, \"/proc/%d/maps\", ctx->desc->pid);\n\n#ifdef _MSC_VER\n#define GDB_FILE_OPEN_MODE (_S_IREAD | _S_IWRITE)\n#else\n#define GDB_FILE_OPEN_MODE (S_IRUSR | S_IWUSR | S_IXUSR)\n#endif\n\n\tif (gdbr_open_file(ctx->desc, path, O_RDONLY, GDB_FILE_OPEN_MODE) < 0) {\n\t\treturn NULL;\n\t}\n\tif (!(buf = malloc(buflen))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\treturn NULL;\n\t}\n\tif ((ret = gdbr_read_file(ctx->desc, buf, buflen - 1)) <= 0) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tbuf[ret] = '\\0';\n\n\t// Get map list\n\tint unk = 0, perm, i;\n\tchar *ptr, *pos_1;\n\tsize_t line_len;\n\tchar name[PROC_NAME_SZ + 1], region1[PROC_REGION_SZ + 1], region2[PROC_REGION_SZ + 1], perms[PROC_PERM_SZ + 1];\n\tRzDebugMap *map = NULL;\n\tregion1[0] = region2[0] = '0';\n\tregion1[1] = region2[1] = 'x';\n\tif (!(ptr = strtok((char *)buf, \"\\n\"))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (!(retlist = rz_list_new())) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\twhile (ptr) {\n\t\tut64 map_start, map_end, offset;\n\t\tbool map_is_shared = false;\n\t\tline_len = strlen(ptr);\n\t\t// maps files should not have empty lines\n\t\tif (line_len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// We assume Linux target, for now, so -\n\t\t// 7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 265428 /usr/lib/ld-2.25.so\n\t\tret = sscanf(ptr, \"%\" RZ_STR_DEF(PROC_REGION_LEFT_SZ) \"s %\" RZ_STR_DEF(PROC_PERM_SZ) \"s %\" PFMT64x \" %*s %*s %\" RZ_STR_DEF(PROC_NAME_SZ) \"[^\\n]\",\n\t\t\t&region1[2], perms, &offset, name);\n\t\tif (ret == 3) {\n\t\t\tname[0] = '\\0';\n\t\t} else if (ret != 4) {\n\t\t\teprintf(\"%s: Unable to parse \\\"%s\\\"\\nContent:\\n%s\\n\",\n\t\t\t\t__func__, path, buf);\n\t\t\tgdbr_close_file(ctx->desc);\n\t\t\tfree(buf);\n\t\t\trz_list_free(retlist);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(pos_1 = strchr(&region1[2], '-'))) {\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tstrncpy(&region2[2], pos_1 + 1, sizeof(region2) - 2 - 1);\n\t\tif (!*name) {\n\t\t\tsnprintf(name, sizeof(name), \"unk%d\", unk++);\n\t\t}\n\t\tperm = 0;\n\t\tfor (i = 0; i < 5 && perms[i]; i++) {\n\t\t\tswitch (perms[i]) {\n\t\t\tcase 'r': perm |= RZ_PERM_R; break;\n\t\t\tcase 'w': perm |= RZ_PERM_W; break;\n\t\t\tcase 'x': perm |= RZ_PERM_X; break;\n\t\t\tcase 'p': map_is_shared = false; break;\n\t\t\tcase 's': map_is_shared = true; break;\n\t\t\t}\n\t\t}\n\t\tmap_start = rz_num_get(NULL, region1);\n\t\tmap_end = rz_num_get(NULL, region2);\n\t\tif (map_start == map_end || map_end == 0) {\n\t\t\teprintf(\"%s: ignoring invalid map size: %s - %s\\n\",\n\t\t\t\t__func__, region1, region2);\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(map = rz_debug_map_new(name, map_start, map_end, perm, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tmap->offset = offset;\n\t\tmap->shared = map_is_shared;\n\t\tmap->file = strdup(name);\n\t\trz_list_append(retlist, map);\n\t\tptr = strtok(NULL, \"\\n\");\n\t}\n\tgdbr_close_file(ctx->desc);\n\tfree(buf);\n\treturn retlist;\n}\n\nstatic RzList /*<RzDebugMap *>*/ *rz_debug_gdb_modules_get(RzDebug *dbg) {\n\tchar *lastname = NULL;\n\tRzDebugMap *map;\n\tRzListIter *iter, *iter2;\n\tRzList *list, *last;\n\tbool must_delete;\n\tif (!(list = rz_debug_gdb_map_get(dbg))) {\n\t\treturn NULL;\n\t}\n\tif (!(last = rz_list_newf((RzListFree)rz_debug_map_free))) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\trz_list_foreach_safe (list, iter, iter2, map) {\n\t\tconst char *file = map->file;\n\t\tif (!map->file) {\n\t\t\tfile = map->file = strdup(map->name);\n\t\t}\n\t\tmust_delete = true;\n\t\tif (file && *file == '/') {\n\t\t\tif (!lastname || strcmp(lastname, file)) {\n\t\t\t\tmust_delete = false;\n\t\t\t}\n\t\t}\n\t\tif (must_delete) {\n\t\t\trz_list_delete(list, iter);\n\t\t} else {\n\t\t\trz_list_append(last, map);\n\t\t\tfree(lastname);\n\t\t\tlastname = strdup(file);\n\t\t}\n\t}\n\tlist->free = NULL;\n\tfree(lastname);\n\trz_list_free(list);\n\treturn last;\n}\n\nstatic int rz_debug_gdb_reg_write(RzDebug *dbg, int type, const ut8 *buf, int size) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tif (!ctx->reg_buf) {\n\t\t// we cannot write registers before we once read them\n\t\treturn -1;\n\t}\n\tint buflen = 0;\n\tint bits = dbg->analysis->bits;\n\tconst char *pcname = rz_reg_get_name(dbg->analysis->reg, RZ_REG_NAME_PC);\n\tRzRegItem *reg = rz_reg_get(dbg->analysis->reg, pcname, 0);\n\tif (reg) {\n\t\tif (dbg->analysis->bits != reg->size) {\n\t\t\tbits = reg->size;\n\t\t}\n\t}\n\tfree(rz_reg_get_bytes(dbg->reg, type, &buflen));\n\t// some implementations of the gdb protocol are acting weird.\n\t// so winedbg is not able to write registers through the <G> packet\n\t// and also it does not return the whole gdb register profile after\n\t// calling <g>\n\t// so this workaround resizes the small register profile buffer\n\t// to the whole set and fills the rest with 0\n\tif (ctx->buf_size < buflen) {\n\t\tut8 *new_buf = realloc(ctx->reg_buf, buflen * sizeof(ut8));\n\t\tif (!new_buf) {\n\t\t\treturn -1;\n\t\t}\n\t\tctx->reg_buf = new_buf;\n\t\tmemset(new_buf + ctx->buf_size, 0, buflen - ctx->buf_size);\n\t}\n\n\tRzRegItem *current = NULL;\n\t// We default to little endian if there's no way to get the configuration,\n\t// since this was the behaviour prior to the change.\n\tRzRegArena *arena = dbg->reg->regset[type].arena;\n\tfor (;;) {\n\t\tcurrent = rz_reg_next_diff(dbg->reg, type, ctx->reg_buf, buflen, current, bits);\n\t\tif (!current) {\n\t\t\tbreak;\n\t\t}\n\t\tgdbr_write_reg(ctx->desc, current->name, (char *)arena->bytes + (current->offset / 8), current->size / 8);\n\t}\n\treturn true;\n}\n\nstatic int rz_debug_gdb_continue(RzDebug *dbg, int pid, int tid, int sig) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tgdbr_continue(ctx->desc, pid, -1, sig); // Continue all threads\n\tif (ctx->desc->stop_reason.is_valid && ctx->desc->stop_reason.thread.present) {\n\t\t// if (desc->tid != desc->stop_reason.thread.tid) {\n\t\t//\teprintf (\"thread id (%d) in reason differs from current thread id (%d)\\n\", dbg->pid, dbg->tid);\n\t\t// }\n\t\tctx->desc->tid = ctx->desc->stop_reason.thread.tid;\n\t}\n\treturn ctx->desc->tid;\n}\n\nstatic RzDebugReasonType rz_debug_gdb_wait(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc) {\n\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t}\n\tif (!ctx->desc->stop_reason.is_valid) {\n\t\tif (gdbr_stop_reason(ctx->desc) < 0) {\n\t\t\tdbg->reason.type = RZ_DEBUG_REASON_UNKNOWN;\n\t\t\treturn RZ_DEBUG_REASON_UNKNOWN;\n\t\t}\n\t}\n\tif (ctx->desc->stop_reason.thread.present) {\n\t\tdbg->reason.tid = ctx->desc->stop_reason.thread.tid;\n\t\tdbg->pid = ctx->desc->stop_reason.thread.pid;\n\t\tdbg->tid = ctx->desc->stop_reason.thread.tid;\n\t\tif (dbg->pid != ctx->desc->pid || dbg->tid != ctx->desc->tid) {\n\t\t\t// eprintf (\"= attach %d %d\\n\", dbg->pid, dbg->tid);\n\t\t\tgdbr_select(ctx->desc, dbg->pid, dbg->tid);\n\t\t}\n\t}\n\tdbg->reason.signum = ctx->desc->stop_reason.signum;\n\tdbg->reason.type = ctx->desc->stop_reason.reason;\n\treturn ctx->desc->stop_reason.reason;\n}\n\nstatic int rz_debug_gdb_attach(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tRzIODesc *d = dbg->iob.io->desc;\n\t// TODO: the core must update the dbg.swstep config var when this var is changed\n\tdbg->swstep = false;\n\t// eprintf (\"XWJSTEP TOFALSE\\n\");\n\tif (d && d->plugin && d->plugin->name && d->data) {\n\t\tif (!strcmp(\"gdb\", d->plugin->name)) {\n\t\t\tRzIOGdb *g = d->data;\n\t\t\tctx->origrziogdb = (RzIOGdb **)&d->data; // TODO bit of a hack, please improve\n\t\t\tctx->support_sw_bp = UNKNOWN;\n\t\t\tctx->support_hw_bp = UNKNOWN;\n\t\t\tctx->desc = &g->desc;\n\t\t\tint arch = rz_sys_arch_id(dbg->arch);\n\t\t\tint bits = dbg->analysis->bits;\n\t\t\tgdbr_set_architecture(ctx->desc, arch, bits);\n\t\t} else {\n\t\t\teprintf(\"ERROR: Underlying IO descriptor is not a GDB one..\\n\");\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int rz_debug_gdb_detach(RzDebug *dbg, int pid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tint ret = 0;\n\n\tif (pid <= 0 || !ctx->desc->stub_features.multiprocess) {\n\t\tgdbr_detach(ctx->desc);\n\t}\n\tret = gdbr_detach_pid(ctx->desc, pid);\n\n\tif (dbg->pid == pid) {\n\t\tctx->desc = NULL;\n\t}\n\treturn ret;\n}\n\nstatic const char *rz_debug_gdb_reg_profile(RzDebug *dbg) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tint arch = rz_sys_arch_id(dbg->arch);\n\tint bits = dbg->analysis->bits;\n\t// XXX This happens when rizin set dbg.backend before opening io_gdb\n\tif (!ctx->desc) {\n\t\treturn gdbr_get_reg_profile(arch, bits);\n\t}\n\tif (!ctx->desc->target.valid) {\n\t\tgdbr_set_architecture(ctx->desc, arch, bits);\n\t}\n\tif (ctx->desc->target.regprofile) {\n\t\treturn strdup(ctx->desc->target.regprofile);\n\t}\n\treturn NULL;\n}\n\nstatic int rz_debug_gdb_set_reg_profile(RzDebug *dbg, const char *str) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tif (ctx->desc && str) {\n\t\treturn gdbr_set_reg_profile(ctx->desc, str);\n\t}\n\treturn false;\n}\n\nstatic int rz_debug_gdb_breakpoint(RzBreakpoint *bp, RzBreakpointItem *b, bool set) {\n\tRzDebug *dbg = bp->user;\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tint ret = 0, bpsize;\n\tif (!b) {\n\t\treturn false;\n\t}\n\tbpsize = b->size;\n\t// TODO handle conditions\n\tswitch (b->perm) {\n\tcase RZ_PERM_X: {\n\t\tif (set) {\n\t\t\tret = b->hw ? gdbr_set_hwbp(ctx->desc, b->addr, \"\", bpsize) : gdbr_set_bp(ctx->desc, b->addr, \"\", bpsize);\n\t\t} else {\n\t\t\tret = b->hw ? gdbr_remove_hwbp(ctx->desc, b->addr, bpsize) : gdbr_remove_bp(ctx->desc, b->addr, bpsize);\n\t\t}\n\t\tbreak;\n\t}\n\t// TODO handle size (area of watch in upper layer and then bpsize. For the moment watches are set on exact on byte\n\tcase RZ_PERM_W: {\n\t\tif (set) {\n\t\t\tgdbr_set_hww(ctx->desc, b->addr, \"\", 1);\n\t\t} else {\n\t\t\tgdbr_remove_hww(ctx->desc, b->addr, 1);\n\t\t}\n\t\tbreak;\n\t}\n\tcase RZ_PERM_R: {\n\t\tif (set) {\n\t\t\tgdbr_set_hwr(ctx->desc, b->addr, \"\", 1);\n\t\t} else {\n\t\t\tgdbr_remove_hwr(ctx->desc, b->addr, 1);\n\t\t}\n\t\tbreak;\n\t}\n\tcase RZ_PERM_ACCESS: {\n\t\tif (set) {\n\t\t\tgdbr_set_hwa(ctx->desc, b->addr, \"\", 1);\n\t\t} else {\n\t\t\tgdbr_remove_hwa(ctx->desc, b->addr, 1);\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\treturn !ret;\n}\n\nstatic bool rz_debug_gdb_kill(RzDebug *dbg, int pid, int tid, int sig) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\t// TODO kill based on pid and signal\n\tif (sig != 0) {\n\t\tif (gdbr_kill(ctx->desc) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int rz_debug_gdb_select(RzDebug *dbg, int pid, int tid) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tif (!ctx->desc || !*ctx->origrziogdb) {\n\t\tctx->desc = NULL; // TODO hacky fix, please improve. I would suggest using a **desc instead of a *desc, so it is automatically updated\n\t\treturn false;\n\t}\n\n\treturn gdbr_select(ctx->desc, pid, tid) >= 0;\n}\n\nstatic RzDebugInfo *rz_debug_gdb_info(RzDebug *dbg, const char *arg) {\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tRzDebugInfo *rdi;\n\tif (!(rdi = RZ_NEW0(RzDebugInfo))) {\n\t\treturn NULL;\n\t}\n\tRzList *th_list;\n\tbool list_alloc = false;\n\tif (dbg->threads) {\n\t\tth_list = dbg->threads;\n\t} else {\n\t\tth_list = rz_debug_gdb_threads(dbg, dbg->pid);\n\t\tlist_alloc = true;\n\t}\n\tRzDebugPid *th;\n\tRzListIter *it;\n\tbool found = false;\n\trz_list_foreach (th_list, it, th) {\n\t\tif (th->pid == dbg->pid) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trdi->pid = dbg->pid;\n\trdi->tid = dbg->tid;\n\trdi->exe = gdbr_exec_file_read(ctx->desc, dbg->pid);\n\trdi->status = found ? th->status : RZ_DBG_PROC_STOP;\n\trdi->uid = found ? th->uid : -1;\n\trdi->gid = found ? th->gid : -1;\n\tif (gdbr_stop_reason(ctx->desc) >= 0) {\n\t\teprintf(\"signal: %d\\n\", ctx->desc->stop_reason.signum);\n\t\trdi->signum = ctx->desc->stop_reason.signum;\n\t}\n\tif (list_alloc) {\n\t\trz_list_free(th_list);\n\t}\n\treturn rdi;\n}\n\n#include \"native/bt.c\"\n\nstatic RzList /*<RzDebugFrame *>*/ *rz_debug_gdb_frames(RzDebug *dbg, ut64 at) {\n\treturn rz_debug_native_frames(dbg, at);\n}\n\nRzDebugPlugin rz_debug_plugin_gdb = {\n\t.name = \"gdb\",\n\t/* TODO: Add support for more architectures here */\n\t.license = \"LGPL3\",\n\t.arch = \"x86,arm,sh,mips,avr,lm32,v850,ba2\",\n\t.bits = RZ_SYS_BITS_16 | RZ_SYS_BITS_32 | RZ_SYS_BITS_64,\n\t.init = rz_debug_gdb_init,\n\t.fini = rz_debug_gdb_fini,\n\t.step = rz_debug_gdb_step,\n\t.cont = rz_debug_gdb_continue,\n\t.attach = &rz_debug_gdb_attach,\n\t.detach = &rz_debug_gdb_detach,\n\t.threads = &rz_debug_gdb_threads,\n\t.pids = &rz_debug_gdb_pids,\n\t.canstep = 1,\n\t.wait = &rz_debug_gdb_wait,\n\t.map_get = rz_debug_gdb_map_get,\n\t.modules_get = rz_debug_gdb_modules_get,\n\t.breakpoint = &rz_debug_gdb_breakpoint,\n\t.reg_read = &rz_debug_gdb_reg_read,\n\t.reg_write = &rz_debug_gdb_reg_write,\n\t.reg_profile = (void *)rz_debug_gdb_reg_profile,\n\t.set_reg_profile = &rz_debug_gdb_set_reg_profile,\n\t.kill = &rz_debug_gdb_kill,\n\t.info = &rz_debug_gdb_info,\n\t.select = &rz_debug_gdb_select,\n\t.frames = &rz_debug_gdb_frames,\n\t//.bp_write = &rz_debug_gdb_bp_write,\n\t//.bp_read = &rz_debug_gdb_bp_read,\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n\t.type = RZ_LIB_TYPE_DBG,\n\t.data = &rz_debug_plugin_gdb,\n\t.version = RZ_VERSION\n};\n#endif\n", "// SPDX-FileCopyrightText: 2016-2018 pancake <pancake@nopcode.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <rz_io.h>\n#include <rz_debug.h>\n\n#define IO_MAPS_PERM_SZ 32\n#define IO_MAPS_NAME_SZ 512\n\nstatic int __io_step(RzDebug *dbg) {\n\tfree(dbg->iob.system(dbg->iob.io, \"ds\"));\n\treturn true;\n}\n\nstatic int __io_step_over(RzDebug *dbg) {\n\tfree(dbg->iob.system(dbg->iob.io, \"dso\"));\n\treturn true;\n}\n\nstatic RzList /*<RzDebugMap *>*/ *__io_maps(RzDebug *dbg) {\n\tRzList *list = rz_list_new();\n\tchar *str = dbg->iob.system(dbg->iob.io, \"dm\");\n\tif (!str) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\tchar *ostr = str;\n\tut64 map_start, map_end;\n\tchar perm[IO_MAPS_PERM_SZ + 1];\n\tchar name[IO_MAPS_NAME_SZ + 1];\n\tfor (;;) {\n\t\tchar *nl = strchr(str, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\t*name = 0;\n\t\t\t*perm = 0;\n\t\t\tmap_start = map_end = 0LL;\n\t\t\tif (!strncmp(str, \"sys \", 4)) {\n\t\t\t\tchar *sp = strchr(str + 4, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\tstr = sp + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *_s_ = strstr(str, \" s \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\t_s_ = strstr(str, \" ? \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %\" RZ_STR_DEF(IO_MAPS_PERM_SZ) \"s %\" RZ_STR_DEF(IO_MAPS_NAME_SZ) \"s\",\n\t\t\t\t&map_start, &map_end, perm, name);\n\t\t\tif (map_end != 0LL) {\n\t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0);\n\t\t\t\trz_list_append(list, map);\n\t\t\t}\n\t\t\tstr = nl + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(ostr);\n\trz_cons_reset();\n\treturn list;\n}\n\nstatic RzDebugReasonType __io_wait(RzDebug *dbg, int pid) {\n\t/* do nothing */\n\treturn RZ_DEBUG_REASON_NONE;\n}\n\nstatic int __io_attach(RzDebug *dbg, int pid) {\n\treturn true;\n}\n\n// \"drp\" register profile\nstatic char *__io_reg_profile(RzDebug *dbg) {\n\trz_cons_push();\n\tchar *drp = dbg->iob.system(dbg->iob.io, \"drp\");\n\tif (drp) {\n\t\treturn drp;\n\t}\n\tchar *buf = rz_cons_get_buffer_dup();\n\tif (RZ_STR_ISNOTEMPTY(buf)) {\n\t\trz_cons_pop();\n\t\treturn buf;\n\t}\n\tfree(buf);\n\trz_cons_pop();\n\treturn rz_analysis_get_reg_profile(dbg->analysis);\n}\n\n// \"dr8\" read register state\nstatic int __reg_read(RzDebug *dbg, int type, ut8 *buf, int size) {\n\tchar *dr8 = dbg->iob.system(dbg->iob.io, \"dr8\");\n\tif (!dr8) {\n\t\tchar *fb = rz_cons_get_buffer_dup();\n\t\tif (RZ_STR_ISEMPTY(fb)) {\n\t\t\tfree(fb);\n\t\t\teprintf(\"debug.io: Failed to get dr8 from io\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tdr8 = fb;\n\t\trz_cons_reset();\n\t}\n\tut8 *bregs = calloc(1, strlen(dr8));\n\tif (!bregs) {\n\t\tfree(dr8);\n\t\treturn -1;\n\t}\n\trz_str_trim((char *)bregs);\n\tint sz = rz_hex_str2bin(dr8, bregs);\n\tif (sz > 0) {\n\t\tmemcpy(buf, bregs, RZ_MIN(size, sz));\n\t\tfree(bregs);\n\t\tfree(dr8);\n\t\treturn size;\n\t} else {\n\t\t// eprintf (\"SIZE %d (%s)\\n\", sz, regs);\n\t}\n\tfree(bregs);\n\tfree(dr8);\n\treturn -1;\n}\n\n// \"dc\" continue execution\nstatic int __io_continue(RzDebug *dbg, int pid, int tid, int sig) {\n\tdbg->iob.system(dbg->iob.io, \"dc\");\n\trz_cons_flush();\n\treturn true;\n}\n\n// \"dk\" send kill signal\nstatic bool __io_kill(RzDebug *dbg, int pid, int tid, int sig) {\n\tconst char *cmd = sdb_fmt(\"dk %d\", sig);\n\tdbg->iob.system(dbg->iob.io, cmd);\n\trz_cons_flush();\n\treturn true;\n}\n\nRzDebugPlugin rz_debug_plugin_io = {\n\t.name = \"io\",\n\t.license = \"MIT\",\n\t.arch = \"any\", // TODO: exception!\n\t.bits = RZ_SYS_BITS_32 | RZ_SYS_BITS_64,\n\t.step = __io_step,\n\t.map_get = __io_maps,\n\t.attach = &__io_attach,\n\t.wait = &__io_wait,\n\t.reg_read = __reg_read,\n\t.cont = __io_continue,\n\t.kill = __io_kill,\n\t.reg_profile = __io_reg_profile,\n\t.step_over = __io_step_over,\n\t.canstep = 1,\n#if 0\n\t.init = __esil_init,\n\t.contsc = __esil_continue_syscall,\n\t.detach = &__esil_detach,\n\t.stop = __esil_stop,\n\t.breakpoint = &__esil_breakpoint,\n#endif\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n\t.type = RZ_LIB_TYPE_DBG,\n\t.data = &rz_debug_plugin_io,\n\t.version = RZ_VERSION\n};\n#endif\n", "#ifndef RZ_TYPES_BASE_H\n#define RZ_TYPES_BASE_H\n\n#include <ctype.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <math.h>\n\n#define cut8  const unsigned char\n#define ut64  unsigned long long\n#define st64  long long\n#define ut32  unsigned int\n#define st32  int\n#define ut16  unsigned short\n#define st16  short\n#define ut8   unsigned char\n#define st8   signed char\n#define boolt int\n\n#if defined(_MSC_VER)\ntypedef intptr_t ssize_t;\n#endif\n\n#if defined(_MSC_VER)\n#define RZ_ALIGNED(x) __declspec(align(x))\n#else\n#define RZ_ALIGNED(x) __attribute__((aligned(x)))\n#endif\n\ntypedef struct _ut80 {\n\tut64 Low;\n\tut16 High;\n} ut80;\ntypedef struct _ut96 {\n\tut64 Low;\n\tut32 High;\n} ut96;\ntypedef struct _ut128 {\n\tut64 Low;\n\tst64 High;\n} ut128;\ntypedef struct _ut256 {\n\tut128 Low;\n\tut128 High;\n} ut256;\ntypedef struct _utX {\n\tut80 v80;\n\tut96 v96;\n\tut128 v128;\n\tut256 v256;\n} utX;\n\n#include <stdbool.h>\n\n#define RZ_EMPTY \\\n\t{ 0 }\n#define RZ_EMPTY2 \\\n\t{ \\\n\t\t{ 0 } \\\n\t}\n\n/* limits */\n#undef UT64_MAX\n#undef UT64_GT0\n#undef UT64_LT0\n#undef UT64_MIN\n#undef UT32_MAX\n#undef UT32_MIN\n#undef UT16_MIN\n#undef UT8_MIN\n#define ST64_MAX  ((st64)0x7FFFFFFFFFFFFFFFULL)\n#define ST64_MIN  ((st64)(-ST64_MAX - 1))\n#define UT64_MAX  0xFFFFFFFFFFFFFFFFULL\n#define UT64_GT0  0x8000000000000000ULL\n#define UT64_LT0  0x7FFFFFFFFFFFFFFFULL\n#define UT64_MIN  0ULL\n#define UT64_32U  0xFFFFFFFF00000000ULL\n#define UT64_16U  0xFFFFFFFFFFFF0000ULL\n#define UT64_8U   0xFFFFFFFFFFFFFF00ULL\n#define UT32_MIN  0U\n#define UT16_MIN  0U\n#define UT32_GT0  0x80000000U\n#define UT32_LT0  0x7FFFFFFFU\n#define ST32_MAX  0x7FFFFFFF\n#define ST32_MIN  (-ST32_MAX - 1)\n#define UT32_MAX  0xFFFFFFFFU\n#define ST16_MAX  0x7FFF\n#define ST16_MIN  (-ST16_MAX - 1)\n#define UT16_GT0  0x8000U\n#define UT16_MAX  0xFFFFU\n#define ST8_MAX   0x7F\n#define ST8_MIN   (-ST8_MAX - 1)\n#define UT8_GT0   0x80U\n#define UT8_MAX   0xFFU\n#define UT8_MIN   0x00U\n#define ASCII_MIN 32\n#define ASCII_MAX 127\n\n#if SSIZE_MAX == ST32_MAX\n#define SZT_MAX  UT32_MAX\n#define SZT_MIN  UT32_MIN\n#define SSZT_MAX ST32_MAX\n#define SSZT_MIN ST32_MIN\n#else\n#define SZT_MAX  UT64_MAX\n#define SZT_MIN  UT64_MIN\n#define SSZT_MAX ST64_MAX\n#define SSZT_MIN ST64_MIN\n#endif\n\n#define UT64_ALIGN(x) (x + (x - (x % sizeof(ut64))))\n#define UT32_ALIGN(x) (x + (x - (x % sizeof(ut32))))\n#define UT16_ALIGN(x) (x + (x - (x % sizeof(ut16))))\n\n#define UT32_LO(x) ((ut32)((x)&UT32_MAX))\n#define UT32_HI(x) ((ut32)(((ut64)(x)) >> 32) & UT32_MAX)\n\n#define RZ_BETWEEN(x, y, z) (((y) >= (x)) && ((y) <= (z)))\n#define RZ_ROUND(x, y)      ((x) % (y)) ? (x) + ((y) - ((x) % (y))) : (x)\n#define RZ_DIM(x, y, z)     (((x) < (y)) ? (y) : ((x) > (z)) ? (z) \\\n\t\t\t\t\t\t\t     : (x))\n#ifndef RZ_MAX_DEFINED\n#define RZ_MAX(x, y) (((x) > (y)) ? (x) : (y))\n#define RZ_MAX_DEFINED\n#endif\n#ifndef RZ_MIN_DEFINED\n#define RZ_MIN(x, y) (((x) > (y)) ? (y) : (x))\n#define RZ_MIN_DEFINED\n#endif\n#define RZ_ABS(x)       (((x) < 0) ? -(x) : (x))\n#define RZ_BTW(x, y, z) (((x) >= (y)) && ((y) <= (z))) ? y : x\n\n#include \"rz_types_overflow.h\"\n\n/* copied from bithacks.h */\n#define B_IS_SET(x, n) (((x) & (1ULL << (n))) ? 1 : 0)\n#define B_SET(x, n)    ((x) |= (1ULL << (n)))\n#define B_EVEN(x)      (((x)&1) == 0)\n#define B_ODD(x)       (!B_EVEN((x)))\n#define B_UNSET(x, n)  ((x) &= ~(1ULL << (n)))\n#define B_TOGGLE(x, n) ((x) ^= (1ULL << (n)))\n\n#define B11111 31\n#define B11110 30\n#define B11101 29\n#define B11100 28\n#define B11011 27\n#define B11010 26\n#define B11001 25\n#define B11000 24\n#define B10111 23\n#define B10110 22\n#define B10101 21\n#define B10100 20\n#define B10011 19\n#define B10010 18\n#define B10001 17\n#define B10000 16\n#define B1111  15\n#define B1110  14\n#define B1101  13\n#define B1100  12\n#define B1011  11\n#define B1010  10\n#define B1001  9\n#define B1000  8\n#define B0111  7\n#define B0110  6\n#define B0101  5\n#define B0100  4\n#define B0011  3\n#define B0010  2\n#define B0001  1\n#define B0000  0\n#undef B\n#define B4(a, b, c, d) ((a << 12) | (b << 8) | (c << 4) | (d))\n\n/* portable non-c99 inf/nan types */\n#if !defined(INFINITY)\n#define INFINITY (1.0f / 0.0f)\n#endif\n\n#if !defined(NAN)\n#define NAN (0.0f / 0.0f)\n#endif\n\n/* A workaround against libc headers redefinition of __attribute__:\n * Standard include has lines like\n * #if (GCC_VERSION < 2007)\n * # define __attribute__(x)\n * #endif\n * So we have do remove this define for TinyCC compiler\n */\n#if defined(__TINYC__) && (GCC_VERSION < 2007)\n#undef __attribute__\n#endif\n\n#ifdef _MSC_VER\n#define RZ_PACKED(__Declaration__) __pragma(pack(push, 1)) __Declaration__ __pragma(pack(pop))\n#undef INFINITY\n#undef NAN\n#elif defined(__GNUC__) || defined(__TINYC__)\n#define RZ_PACKED(__Declaration__) __Declaration__ __attribute__((__packed__))\n#endif\n\n#if APPLE_SDK_IPHONESIMULATOR\n#undef DEBUGGER\n#define DEBUGGER 0\n#endif\n\n#define HEAPTYPE(x) \\\n\tstatic x *x##_new(x n) { \\\n\t\tx *m = malloc(sizeof(x)); \\\n\t\treturn m ? *m = n, m : m; \\\n\t}\n\n#define RZ_STR_DEF(s) RZ_STR(s)\n#define RZ_STR(s)     #s\n\n#endif // RZ_TYPES_BASE_H\n", "// SPDX-FileCopyrightText: 2009-2020 pancake <pancake@nopcode.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <rz_list.h>\n#include <rz_util/rz_log.h>\n#include <rz_util/rz_str.h>\n#include <rz_reg.h>\n#include <rz_util.h>\n#include <rz_util/rz_assert.h>\n#include <rz_lib.h>\n#include <string.h>\n\n#define GDB_NAME_SZ   16\n#define GDB_TYPE_SZ   16\n#define GDB_GROUPS_SZ 128\n\nstatic void rz_reg_profile_def_free(RzRegProfileDef *def) {\n\tif (!def) {\n\t\treturn;\n\t}\n\tfree(def->name);\n\tfree(def->comment);\n\tfree(def->flags);\n\tfree(def);\n}\n\nstatic void rz_reg_profile_alias_free(RzRegProfileAlias *alias) {\n\tif (!alias) {\n\t\treturn;\n\t}\n\tfree(alias->reg_name);\n\tfree(alias->alias);\n\tfree(alias);\n}\n\n/**\n * Like rz_reg_type_by_name, but warn if non-existent\n */\nstatic int expect_reg_type_by_name(const char *str) {\n\tint r = rz_reg_type_by_name(str);\n\tif (r < 0) {\n\t\tRZ_LOG_WARN(\"No register type for type abbreviation \\\"%s\\\".\\n\", str);\n\t}\n\treturn r;\n}\n\n/**\n * \\brief Parses a register type string.\n *\n * The type string must be of the following form:\n *\n * <sub-type>@<main-type>\n *\n * \"<sub-type>@\" is optional.\n *\n * \\param item Register item whichs types are set.\n * \\param type_str The type string.\n * \\return true On success.\n * \\return false On failure.\n */\nstatic bool parse_type(RZ_OUT RzRegProfileDef *def, const char *type_str) {\n\trz_return_val_if_fail(def && type_str, false);\n\tchar *s = strdup(type_str);\n\tchar *at = strchr(s, '@');\n\tif (at) {\n\t\t// This register has a secondary type e.g. xmm@fpu\n\t\tdef->arena_type = expect_reg_type_by_name(at + 1);\n\t\ts[at - s] = '\\0';\n\t\tdef->type = expect_reg_type_by_name(s);\n\t} else {\n\t\tdef->type = expect_reg_type_by_name(s);\n\t\tdef->arena_type = def->type;\n\t\tif (def->type == RZ_REG_TYPE_FLG) { // Hack to put flgs into gpr arena.\n\t\t\tdef->arena_type = RZ_REG_TYPE_GPR;\n\t\t} else {\n\t\t\tdef->arena_type = def->type;\n\t\t}\n\t}\n\tbool res = true;\n\tif (def->type < 0 || def->arena_type < 0) {\n\t\tRZ_LOG_ERROR(\"Illegal type abbreviation \\\"%s\\\"\\n\", s);\n\t\tres = false;\n\t}\n\tfree(s);\n\treturn res;\n}\n\n/**\n * \\brief Parses the size of a register definition.\n * Sizes with . in front are in bits. Otherwise in bytes.\n *\n * \\param s Size string.\n * \\return ut32 The size as integer or UT64_MAX if it fails.\n */\nstatic ut32 parse_size(char *s) {\n\trz_return_val_if_fail(s, UT32_MAX);\n\tif (s[0] == '.') {\n\t\treturn strtoul(s + 1, NULL, 0);\n\t} else {\n\t\treturn strtoul(s, NULL, 0) * 8;\n\t}\n}\n\n/**\n * \\brief Parses the offset of a register defintion and sets the offset in \\p def->offset.\n *\n * Offset is of the form: <byte>.<bit>\n * .<bit> is optional.\n *\n * \\param s Offset string.\n * \\param def The defintion item to store the offset into \\p def->offset in bits.\n * \\return false On failure (sets def->offset = UT32_MAX).\n * \\return true On success.\n */\nstatic bool parse_offset(const char *s, RZ_OUT RzRegProfileDef *def) {\n\trz_return_val_if_fail(s && def, false);\n\tif (s[0] == '?') {\n\t\tdef->offset = UT32_MAX;\n\t\treturn true;\n\t} else if (s[0] == '.') {\n\t\tdef->offset = strtoul(s + 1, NULL, 0);\n\t\treturn true;\n\t}\n\tdef->offset = strtoul(s, NULL, 0) * 8;\n\n\tconst char *bi = strchr(s, '.');\n\tif (!bi) {\n\t\t// No bit offset given.\n\t\treturn true;\n\t}\n\n\tut8 bit_offset = strtoul(bi + 1, NULL, 0);\n\tdef->offset += bit_offset;\n\treturn true;\n}\n\n/**\n * \\brief Parses a register alias.\n *\n * The alias is of the form:\n * \"=<alias>  <reg name>\"\n *\n * \\param reg The RzReg struct with the register profile.\n * \\param tokens A list with both tokens of the alias string.\n * \\return true On success.\n * \\return false On Failure.\n */\nstatic bool parse_alias(RZ_OUT RzList /*<RzRegProfileAlias *>*/ *alias_list, RZ_BORROW RzList /*<char *>*/ *tokens) {\n\trz_return_val_if_fail(alias_list && tokens, false);\n\tRzRegProfileAlias *pa = RZ_NEW0(RzRegProfileAlias);\n\tif (!pa) {\n\t\tRZ_LOG_WARN(\"Unable to allocate memory.\\n\");\n\t\treturn false;\n\t}\n\n\tconst char *real_name = rz_list_get_n(tokens, 1);\n\tconst char *alias = rz_list_get_n(tokens, 0);\n\tif (!alias) {\n\t\tRZ_LOG_WARN(\"Failed to get alias name from token.\\n\");\n\t\tfree(pa);\n\t\treturn false;\n\t}\n\n\tRzRegisterId role = rz_reg_get_name_idx(alias + 1);\n\tif (!(role >= 0 && role < RZ_REG_NAME_LAST)) {\n\t\tRZ_LOG_WARN(\"Invalid alias\\n\");\n\t\tfree(pa);\n\t\treturn false;\n\t}\n\n\tpa->alias = strdup(alias);\n\tpa->reg_name = strdup(real_name);\n\tpa->role = role;\n\trz_list_append(alias_list, pa);\n\n\treturn true;\n}\n\n/**\n * \\brief Parses a register definition.\n *\n * \\param reg Register struct with the register profile.\n * \\param tokens List of strings of a single register definition.\n * \\return false On failure.\n * \\return true On success.\n */\nstatic bool parse_def(RZ_OUT RzList /*<RzRegProfileDef *>*/ *def_list, RZ_BORROW RzList /*<char *>*/ *tokens) {\n\trz_return_val_if_fail(def_list && tokens, false);\n\n\tRzRegProfileDef *def = RZ_NEW0(RzRegProfileDef);\n\tif (!def) {\n\t\tRZ_LOG_WARN(\"Unable to allocate memory.\\n\");\n\t\treturn false;\n\t}\n\tconst char *name = rz_list_get_n(tokens, 1);\n\tif (!name) {\n\t\tgoto reg_parse_error;\n\t}\n\tdef->name = strdup(name);\n\n\tif (!parse_type(def, rz_list_get_n(tokens, 0))) {\n\t\tRZ_LOG_WARN(\"Invalid register type.\\n\");\n\t\tgoto reg_parse_error;\n\t}\n\n\tdef->size = parse_size(rz_list_get_n(tokens, 2));\n\tif (def->size == UT32_MAX || def->size == 0) {\n\t\tRZ_LOG_WARN(\"Invalid register size.\\n\");\n\t\tgoto reg_parse_error;\n\t}\n\n\tdef->packed = parse_size(rz_list_get_n(tokens, 4));\n\tif (def->packed == UT32_MAX) {\n\t\tRZ_LOG_WARN(\"Invalid register packed size.\\n\");\n\t\tgoto reg_parse_error;\n\t}\n\n\tif (!parse_offset(rz_list_get_n(tokens, 3), def)) {\n\t\tRZ_LOG_WARN(\"Invalid register offset.\\n\");\n\t\tgoto reg_parse_error;\n\t}\n\n\t// Comments and flags are optional\n\tif (rz_list_length(tokens) == 6) {\n\t\tconst char *comment_flag = rz_list_get_n(tokens, 5);\n\t\tif (!comment_flag) {\n\t\t\tgoto reg_parse_error;\n\t\t}\n\t\tif (comment_flag[0] == '#') {\n\t\t\t// Remove # from the comment\n\t\t\tdef->comment = strdup(comment_flag + 1);\n\t\t} else {\n\t\t\tdef->flags = strdup(comment_flag);\n\t\t}\n\t}\n\tRZ_LOG_DEBUG(\"profile: register def: %s %d %d %s\\n\", def->name, def->size, def->offset, def->flags);\n\trz_list_append(def_list, def);\n\n\treturn true;\n\nreg_parse_error:\n\trz_reg_profile_def_free(def);\n\treturn false;\n}\n\n/**\n * \\brief Parses a register profile string. Each line is either a register alias or a register definiton.\n *\n * A register alias string is of the following form:\n * \"=<alias>  <name>\\n\"\n *\n * A register definition string is of the following form:\n * \"(<sub-type>@)main-type  <name>  .<size>  <byte offset>(.<bit offset>)  <packed>  (# <comment> OR <flags>)\\n\"\n *\n * Elements in \"()\" are optional.\n * Each \"<...>\" token is separated by tab or space characters.\n *\n * * alias: Register alias (e.g. PC, A1 etc.)\n * * name: Register name.\n * * size: Register size in bits.\n * * main-type: Register type: gpr, fpr, ctr, flg etc.\n * * sub-type: The second register type (e.g. xmm@fpu : xmm is sub-type of fpu)\n * * byte offset: Offset into register profile in bytes.\n * * bit offset: Offset into the byte offset in bits.\n * * packed: Packed size of the register in bytes.\n * * comment: A comment about the register.\n * * Flags this register holds.\n *\n * \\param reg Register struct which holds all register items.\n * \\param profile Register profile string.\n * \\return false On failure.\n * \\return true On success.\n */\nstatic bool parse_reg_profile_str(RZ_OUT RzList /*<RzRegProfileAlias *>*/ *alias_list, RZ_OUT RzList /*<RzRegProfileDef *>*/ *def_list, const char *profile_str) {\n\trz_return_val_if_fail(alias_list && def_list && profile_str, false);\n\n\tRzList *def_lines = rz_str_split_duplist_n(profile_str, \"\\n\", 0, true);\n\trz_return_val_if_fail(def_lines, false);\n\n\tst32 l = 0; // Line number\n\tconst char *line;\n\tbool is_alias = false;\n\tRzListIter *it;\n\tRzList *toks = NULL;\n\trz_list_foreach (def_lines, it, line) {\n\t\t++l;\n\t\tif (RZ_STR_ISEMPTY(line)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rz_str_strchr(line, \"#\")) {\n\t\t\tRzList *line_and_cmt = rz_str_split_duplist_n_regex(line, \"#\", 0, true);\n\t\t\tchar *raw_comment = strdup(rz_list_get_top(line_and_cmt));\n\t\t\tif (!raw_comment) {\n\t\t\t\tRZ_LOG_WARN(\"Comment could not be split from register definition. Line: \\\"%s\\\"\\n\", line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *tmp = rz_str_prepend(raw_comment, \"#\");\n\t\t\tif (!tmp) {\n\t\t\t\tRZ_LOG_WARN(\"Could not prepend # to comment. Line: \\\"%s\\\".\\n\", line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *comment = strdup(tmp);\n\t\t\ttoks = rz_str_split_duplist_n_regex(rz_list_get_bottom(line_and_cmt), \"[[:blank:]]+\", 0, true);\n\t\t\trz_list_append(toks, comment);\n\t\t\trz_list_free(line_and_cmt);\n\t\t} else {\n\t\t\ttoks = rz_str_split_duplist_n_regex(line, \"[[:blank:]]+\", 0, true);\n\t\t}\n\t\tut32 toks_len = rz_list_length(toks);\n\t\tif (rz_list_empty(toks)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst char *first_tok = rz_list_get_n(toks, 0);\n\t\tif (first_tok[0] == '#') { // Comment line\n\t\t\tcontinue;\n\t\t} else if (first_tok[0] == '=') { // Alias\n\t\t\tif (toks_len != 2) {\n\t\t\t\tRZ_LOG_WARN(\"Invalid number of %d columns in alias \\\"%s\\\" at line %d. 2 needed.\\n\", toks_len, line, l);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tis_alias = true;\n\t\t} else if (isalpha(first_tok[0])) {\n\t\t\tif (toks_len != 5 && toks_len != 6) {\n\t\t\t\tRZ_LOG_WARN(\"Invalid number of %d columns in definition \\\"%s\\\" at line %d. 5 or 6 needed.\\n\", toks_len, line, l);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tRZ_LOG_WARN(\"Invalid line \\\"%s\\\" at register profiles line %d.\\n\", line, l);\n\t\t\tcontinue;\n\t\t}\n\t\tbool success = is_alias\n\t\t\t? parse_alias(alias_list, toks)\n\t\t\t: parse_def(def_list, toks);\n\t\tif (!success) {\n\t\t\tRZ_LOG_WARN(\"Parsing error in \\\"%s\\\" at line %d.\\n\", line, l);\n\t\t\trz_list_free(toks);\n\t\t\trz_list_free(def_lines);\n\t\t\treturn false;\n\t\t}\n\t\tis_alias = false;\n\t\trz_list_free(toks);\n\t}\n\trz_list_free(def_lines);\n\n\treturn true;\n}\n\nstatic void add_item_to_regset(RZ_BORROW RzReg *reg, RZ_BORROW RzRegItem *item) {\n\trz_return_if_fail(reg && item);\n\tRzRegisterType t = item->arena;\n\n\tif (!reg->regset[t].regs) {\n\t\treg->regset[t].regs = rz_list_newf((RzListFree)rz_reg_item_free);\n\t}\n\tif (!reg->regset[t].ht_regs) {\n\t\treg->regset[t].ht_regs = ht_pp_new0();\n\t}\n\n\t// Dynamically update the list of supported bit sizes\n\treg->bits |= item->size;\n\trz_list_append(reg->regset[t].regs, item);\n\tht_pp_insert(reg->regset[t].ht_regs, item->name, item);\n\n\t// Update the overall type of registers into a regset\n\tif (item->type == RZ_REG_TYPE_ANY) {\n\t\treg->regset[t].maskregstype = UT32_MAX;\n\t\treturn;\n\t}\n\treg->regset[t].maskregstype |= ((int)1 << item->type);\n}\n\n/**\n * \\brief Fills \\p reg->regset with the definitions and alias of the register profile.\n *\n * \\param reg The RzReg struct which holds the register profile and an empty \\p reg->regset\n * \\return false On failure.\n * \\return true On success.\n */\nRZ_API bool rz_reg_set_reg_profile(RZ_BORROW RzReg *reg) {\n\trz_return_val_if_fail(reg, false);\n\trz_return_val_if_fail(reg->reg_profile.alias && reg->reg_profile.defs, false);\n\n\tRzListIter *it;\n\tRzRegProfileAlias *alias;\n\trz_list_foreach (reg->reg_profile.alias, it, alias) {\n\t\tif (!rz_reg_set_name(reg, alias->role, alias->reg_name)) {\n\t\t\tRZ_LOG_WARN(\"Invalid alias gviven.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tRzRegProfileDef *def;\n\trz_list_foreach (reg->reg_profile.defs, it, def) {\n\t\tRzRegItem *item = RZ_NEW0(RzRegItem);\n\t\tif (!item) {\n\t\t\tRZ_LOG_WARN(\"Unable to allocate memory.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\titem->name = strdup(def->name);\n\n\t\titem->type = def->type;\n\t\titem->arena = def->arena_type;\n\n\t\titem->size = def->size;\n\t\titem->offset = def->offset;\n\t\t// Update the overall profile size\n\t\tif (item->offset + item->size > reg->size) {\n\t\t\treg->size = item->offset + item->size;\n\t\t}\n\n\t\titem->packed_size = def->packed;\n\n\t\tif (def->comment) {\n\t\t\titem->comment = strdup(def->comment);\n\t\t}\n\t\tif (def->flags) {\n\t\t\titem->flags = strdup(def->flags);\n\t\t}\n\n\t\tadd_item_to_regset(reg, item);\n\t}\n\n\treturn true;\n}\n\n/**\n * \\brief Parses a register profile string and sets up all registers accordingly in \\p reg.\n *\n * \\param reg The RzReg struct which should hold the register data.\n * \\param profile The register profile string.\n * \\return false On failure;\n * \\return true On success.\n */\nRZ_API bool rz_reg_set_profile_string(RZ_NONNULL RzReg *reg, RZ_NONNULL const char *profile_str) {\n\trz_return_val_if_fail(reg && profile_str, false);\n\t// Same profile, no need to change\n\tif (reg->reg_profile_str && !strcmp(reg->reg_profile_str, profile_str)) {\n\t\treturn true;\n\t}\n\n\t// we should reset all the arenas before setting the new reg profile\n\trz_reg_arena_pop(reg);\n\t// Purge the old registers\n\trz_reg_free_internal(reg, true);\n\trz_reg_arena_shrink(reg);\n\n\t// Cache the profile string\n\treg->reg_profile_str = strdup(profile_str);\n\treg->reg_profile.defs = rz_list_newf((RzListFree)rz_reg_profile_def_free);\n\treg->reg_profile.alias = rz_list_newf((RzListFree)rz_reg_profile_alias_free);\n\trz_return_val_if_fail(reg->reg_profile.defs && reg->reg_profile.alias, true);\n\n\tif (!parse_reg_profile_str(reg->reg_profile.alias, reg->reg_profile.defs, profile_str)) {\n\t\tRZ_LOG_WARN(\"Could not parse register profile string.\\n\");\n\t\trz_reg_free_internal(reg, false);\n\t\treturn false;\n\t}\n\n\t// Check for duplicates\n\tRzListIter *it, *tmp;\n\tRzRegProfileDef *def;\n\trz_list_foreach_safe (reg->reg_profile.defs, it, tmp, def) {\n\t\tif (rz_reg_get(reg, def->name, RZ_REG_TYPE_ANY)) {\n\t\t\tRZ_LOG_WARN(\"Ignoring duplicated register definition '%s'.\\n\", def->name);\n\t\t\trz_list_delete(reg->reg_profile.defs, it);\n\t\t}\n\t}\n\n\tif (!rz_reg_set_reg_profile(reg)) {\n\t\tRZ_LOG_WARN(\"Could not set reg profile.\\n\");\n\t\treturn false;\n\t}\n\n\treg->size = 0;\n\tfor (ut32 i = 0; i < RZ_REG_TYPE_LAST; i++) {\n\t\tRzRegSet *rs = &reg->regset[i];\n\t\tif (rs && rs->arena) {\n\t\t\treg->size += rs->arena->size; // Sums minimum arena size.\n\t\t}\n\t}\n\n\trz_reg_fit_arena(reg);\n\t// dup the last arena to allow regdiffing\n\trz_reg_arena_push(reg);\n\trz_reg_reindex(reg);\n\treturn true;\n}\n\nRZ_API bool rz_reg_set_profile(RzReg *reg, const char *profile) {\n\trz_return_val_if_fail(reg && profile, false);\n\tchar *base, *file;\n\tchar *str = rz_file_slurp(profile, NULL);\n\tif (!str) {\n\t\tbase = rz_sys_getenv(RZ_LIB_ENV);\n\t\tif (base) {\n\t\t\tfile = rz_str_append(base, profile);\n\t\t\tstr = rz_file_slurp(file, NULL);\n\t\t\tfree(file);\n\t\t}\n\t}\n\tif (!str) {\n\t\teprintf(\"rz_reg_set_profile: Cannot find '%s'\\n\", profile);\n\t\treturn false;\n\t}\n\tbool ret = rz_reg_set_profile_string(reg, str);\n\tfree(str);\n\treturn ret;\n}\n\nstatic char *gdb_to_rz_profile(const char *gdb) {\n\trz_return_val_if_fail(gdb, NULL);\n\tRzStrBuf *sb = rz_strbuf_new(\"\");\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\tchar *ptr1, *gptr, *gptr1;\n\tchar name[GDB_NAME_SZ + 1], groups[GDB_GROUPS_SZ + 1], type[GDB_TYPE_SZ + 1];\n\tconst int all = 1, gpr = 2, save = 4, restore = 8, float_ = 16,\n\t\t  sse = 32, vector = 64, system = 128, mmx = 256;\n\tint number, rel, offset, size, type_bits, ret;\n\t// Every line is -\n\t// Name Number Rel Offset Size Type Groups\n\tconst char *ptr = rz_str_trim_head_ro(gdb);\n\n\t// It's possible someone includes the heading line too. Skip it\n\tif (rz_str_startswith(ptr, \"Name\")) {\n\t\tif (!(ptr = strchr(ptr, '\\n'))) {\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr++;\n\t}\n\tfor (;;) {\n\t\t// Skip whitespace at beginning of line and empty lines\n\t\twhile (isspace((ut8)*ptr)) {\n\t\t\tptr++;\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ptr1 = strchr(ptr, '\\n'))) {\n\t\t\t*ptr1 = '\\0';\n\t\t} else {\n\t\t\teprintf(\"Could not parse line: %s (missing \\\\n)\\n\", ptr);\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn false;\n\t\t}\n\t\tret = sscanf(ptr, \" %\" RZ_STR_DEF(GDB_NAME_SZ) \"s %d %d %d %d %\" RZ_STR_DEF(GDB_TYPE_SZ) \"s %\" RZ_STR_DEF(GDB_GROUPS_SZ) \"s\",\n\t\t\tname, &number, &rel, &offset, &size, type, groups);\n\t\t// Groups is optional, others not\n\t\tif (ret < 6) {\n\t\t\tif (*ptr != '*') {\n\t\t\t\teprintf(\"Could not parse line: %s\\n\", ptr);\n\t\t\t\trz_strbuf_free(sb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If name is '', then skip\n\t\tif (rz_str_startswith(name, \"''\")) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If size is 0, skip\n\t\tif (size == 0) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\ttype_bits = 0;\n\t\t// Parse group\n\t\tif (ret >= 7) {\n\t\t\tgptr = groups;\n\t\t\twhile (1) {\n\t\t\t\tif ((gptr1 = strchr(gptr, ','))) {\n\t\t\t\t\t*gptr1 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (rz_str_startswith(gptr, \"general\")) {\n\t\t\t\t\ttype_bits |= gpr;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"all\")) {\n\t\t\t\t\ttype_bits |= all;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"save\")) {\n\t\t\t\t\ttype_bits |= save;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"restore\")) {\n\t\t\t\t\ttype_bits |= restore;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"float\")) {\n\t\t\t\t\ttype_bits |= float_;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"sse\")) {\n\t\t\t\t\ttype_bits |= sse;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"mmx\")) {\n\t\t\t\t\ttype_bits |= mmx;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"vector\")) {\n\t\t\t\t\ttype_bits |= vector;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"system\")) {\n\t\t\t\t\ttype_bits |= system;\n\t\t\t\t}\n\t\t\t\tif (!gptr1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgptr = gptr1 + 1;\n\t\t\t}\n\t\t}\n\t\t// If type is not defined, skip\n\t\tif (!*type) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: More mappings between gdb and rizin reg groups. For now, either fpu or gpr\n\t\tif (!(type_bits & sse) && !(type_bits & float_)) {\n\t\t\ttype_bits |= gpr;\n\t\t}\n\t\t// Print line\n\t\trz_strbuf_appendf(sb, \"%s\\t%s\\t.%d\\t%d\\t0\\n\",\n\t\t\t// Ref: Comment above about more register type mappings\n\t\t\t((type_bits & mmx) || (type_bits & float_) || (type_bits & sse)) ? \"fpu\" : \"gpr\",\n\t\t\tname, size * 8, offset);\n\t\t// Go to next line\n\t\tif (!ptr1) {\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr1 + 1;\n\t\tcontinue;\n\t}\n\treturn rz_strbuf_drain(sb);\n}\n\nRZ_API char *rz_reg_parse_gdb_profile(const char *profile_file) {\n\tchar *str = NULL;\n\tif (!(str = rz_file_slurp(profile_file, NULL))) {\n\t\tchar *base = rz_sys_getenv(RZ_LIB_ENV);\n\t\tif (base) {\n\t\t\tchar *file = rz_str_appendf(base, RZ_SYS_DIR \"%s\", profile_file);\n\t\t\tif (file) {\n\t\t\t\tstr = rz_file_slurp(file, NULL);\n\t\t\t\tfree(file);\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tchar *ret = gdb_to_rz_profile(str);\n\t\tfree(str);\n\t\treturn ret;\n\t}\n\teprintf(\"rz_reg_parse_gdb_profile: Cannot find '%s'\\n\", profile_file);\n\treturn NULL;\n}\n\nRZ_API char *rz_reg_profile_to_cc(RzReg *reg) {\n\tconst char *r0 = rz_reg_get_name_by_type(reg, \"R0\");\n\tconst char *a0 = rz_reg_get_name_by_type(reg, \"A0\");\n\tconst char *a1 = rz_reg_get_name_by_type(reg, \"A1\");\n\tconst char *a2 = rz_reg_get_name_by_type(reg, \"A2\");\n\tconst char *a3 = rz_reg_get_name_by_type(reg, \"A3\");\n\n\tif (!a0) {\n\t\tRZ_LOG_WARN(\"It is mandatory to have at least one argument register defined in the register profile.\\n\");\n\t\treturn NULL;\n\t}\n\tif (!r0) {\n\t\tr0 = a0;\n\t}\n\tif (a3 && a2 && a1) {\n\t\treturn rz_str_newf(\"%s reg(%s, %s, %s, %s)\", r0, a0, a1, a2, a3);\n\t}\n\tif (a2 && a1) {\n\t\treturn rz_str_newf(\"%s reg(%s, %s, %s)\", r0, a0, a1, a2);\n\t}\n\tif (a1) {\n\t\treturn rz_str_newf(\"%s reg(%s, %s)\", r0, a0, a1);\n\t}\n\treturn rz_str_newf(\"%s reg(%s)\", r0, a0);\n}\n"], "filenames": ["librz/debug/p/debug_gdb.c", "librz/debug/p/debug_io.c", "librz/include/rz_types_base.h", "librz/reg/profile.c"], "buggy_code_start_loc": [16, 5, 216, 11], "buggy_code_end_loc": [218, 52, 216, 547], "fixing_code_start_loc": [17, 6, 217, 12], "fixing_code_end_loc": [225, 55, 220, 551], "type": "CWE-787", "message": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. In version 0.5.1 and prior, converting a GDB registers profile file into a Rizin register profile can result in a stack-based buffer overflow when the `name`, `type`, or `groups` fields have longer values than expected. Users opening untrusted GDB registers files (e.g. with the `drpg` or `arpg` commands) are affected by this flaw. Commit d6196703d89c84467b600ba2692534579dc25ed4 contains a patch for this issue. As a workaround, review the GDB register profiles before loading them with `drpg`/`arpg` commands.", "other": {"cve": {"id": "CVE-2023-27590", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-14T21:15:10.763", "lastModified": "2023-03-21T15:00:44.043", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. In version 0.5.1 and prior, converting a GDB registers profile file into a Rizin register profile can result in a stack-based buffer overflow when the `name`, `type`, or `groups` fields have longer values than expected. Users opening untrusted GDB registers files (e.g. with the `drpg` or `arpg` commands) are affected by this flaw. Commit d6196703d89c84467b600ba2692534579dc25ed4 contains a patch for this issue. As a workaround, review the GDB register profiles before loading them with `drpg`/`arpg` commands."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}, {"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.1", "matchCriteriaId": "C26825BC-A697-45A5-9574-D88FE11A4319"}]}]}], "references": [{"url": "https://github.com/rizinorg/rizin/blob/3a7d5116244beb678ad9950bb9dd27d28ed2691f/librz/reg/profile.c#L514", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/rizinorg/rizin/blob/3a7d5116244beb678ad9950bb9dd27d28ed2691f/librz/reg/profile.c#L545", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/rizinorg/rizin/commit/d6196703d89c84467b600ba2692534579dc25ed4", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rizinorg/rizin/pull/3422", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/rizinorg/rizin/security/advisories/GHSA-rqcp-m8m2-jcqf", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/rizinorg/rizin/commit/d6196703d89c84467b600ba2692534579dc25ed4"}}