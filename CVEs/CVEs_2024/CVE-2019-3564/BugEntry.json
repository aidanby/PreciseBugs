{"buggy_code": ["/*\n * Copyright 2019-present Facebook, Inc.\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage thrift\n\nimport (\n\t\"testing\"\n)\n\nfunc TestReadWriteBinaryProtocol(t *testing.T) {\n\tReadWriteProtocolTest(t, NewBinaryProtocolFactoryDefault())\n}\n", "/*\n * Copyright 2019-present Facebook, Inc.\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage thrift\n\nimport (\n\t\"errors\"\n)\n\ntype ProtocolID int16\n\nconst (\n\tProtocolIDBinary     ProtocolID = 0\n\tProtocolIDJSON       ProtocolID = 1\n\tProtocolIDCompact    ProtocolID = 2\n\tProtocolIDDebug      ProtocolID = 3\n\tProtocolIDVirtual    ProtocolID = 4\n\tProtocolIDSimpleJSON ProtocolID = 5\n)\n\nfunc (p ProtocolID) String() string {\n\tswitch p {\n\tcase ProtocolIDBinary:\n\t\treturn \"binary\"\n\tcase ProtocolIDJSON:\n\t\treturn \"json\"\n\tcase ProtocolIDCompact:\n\t\treturn \"compact\"\n\tcase ProtocolIDDebug:\n\t\treturn \"debug\"\n\tcase ProtocolIDVirtual:\n\t\treturn \"virtual\"\n\tcase ProtocolIDSimpleJSON:\n\t\treturn \"simplejson\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\nconst (\n\tVERSION_MASK = 0xffff0000\n\tVERSION_1    = 0x80010000\n)\n\ntype Protocol interface {\n\tWriteMessageBegin(name string, typeId MessageType, seqid int32) error\n\tWriteMessageEnd() error\n\tWriteStructBegin(name string) error\n\tWriteStructEnd() error\n\tWriteFieldBegin(name string, typeId Type, id int16) error\n\tWriteFieldEnd() error\n\tWriteFieldStop() error\n\tWriteMapBegin(keyType Type, valueType Type, size int) error\n\tWriteMapEnd() error\n\tWriteListBegin(elemType Type, size int) error\n\tWriteListEnd() error\n\tWriteSetBegin(elemType Type, size int) error\n\tWriteSetEnd() error\n\tWriteBool(value bool) error\n\tWriteByte(value byte) error\n\tWriteI16(value int16) error\n\tWriteI32(value int32) error\n\tWriteI64(value int64) error\n\tWriteDouble(value float64) error\n\tWriteFloat(value float32) error\n\tWriteString(value string) error\n\tWriteBinary(value []byte) error\n\n\tReadMessageBegin() (name string, typeId MessageType, seqid int32, err error)\n\tReadMessageEnd() error\n\tReadStructBegin() (name string, err error)\n\tReadStructEnd() error\n\tReadFieldBegin() (name string, typeId Type, id int16, err error)\n\tReadFieldEnd() error\n\tReadMapBegin() (keyType Type, valueType Type, size int, err error)\n\tReadMapEnd() error\n\tReadListBegin() (elemType Type, size int, err error)\n\tReadListEnd() error\n\tReadSetBegin() (elemType Type, size int, err error)\n\tReadSetEnd() error\n\tReadBool() (value bool, err error)\n\tReadByte() (value byte, err error)\n\tReadI16() (value int16, err error)\n\tReadI32() (value int32, err error)\n\tReadI64() (value int64, err error)\n\tReadDouble() (value float64, err error)\n\tReadFloat() (value float32, err error)\n\tReadString() (value string, err error)\n\tReadBinary() (value []byte, err error)\n\n\tSkip(fieldType Type) (err error)\n\tFlush() (err error)\n\n\tTransport() Transport\n}\n\n// The maximum recursive depth the skip() function will traverse\nconst DEFAULT_RECURSION_DEPTH = 64\n\n// Skips over the next data element from the provided input Protocol object.\nfunc SkipDefaultDepth(prot Protocol, typeId Type) (err error) {\n\treturn Skip(prot, typeId, DEFAULT_RECURSION_DEPTH)\n}\n\n// Skips over the next data element from the provided input Protocol object.\nfunc Skip(self Protocol, fieldType Type, maxDepth int) (err error) {\n\n\tif maxDepth <= 0 {\n\t\treturn NewProtocolExceptionWithType(DEPTH_LIMIT, errors.New(\"Depth limit exceeded\"))\n\t}\n\n\tswitch fieldType {\n\tcase STOP:\n\t\treturn\n\tcase BOOL:\n\t\t_, err = self.ReadBool()\n\t\treturn\n\tcase BYTE:\n\t\t_, err = self.ReadByte()\n\t\treturn\n\tcase I16:\n\t\t_, err = self.ReadI16()\n\t\treturn\n\tcase I32:\n\t\t_, err = self.ReadI32()\n\t\treturn\n\tcase I64:\n\t\t_, err = self.ReadI64()\n\t\treturn\n\tcase DOUBLE:\n\t\t_, err = self.ReadDouble()\n\t\treturn\n\tcase FLOAT:\n\t\t_, err = self.ReadFloat()\n\t\treturn\n\tcase STRING:\n\t\t_, err = self.ReadString()\n\t\treturn\n\tcase STRUCT:\n\t\tif _, err = self.ReadStructBegin(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor {\n\t\t\t_, typeId, _, _ := self.ReadFieldBegin()\n\t\t\tif typeId == STOP {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr := Skip(self, typeId, maxDepth-1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tself.ReadFieldEnd()\n\t\t}\n\t\treturn self.ReadStructEnd()\n\tcase MAP:\n\t\tkeyType, valueType, size, err := self.ReadMapBegin()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i < size; i++ {\n\t\t\terr := Skip(self, keyType, maxDepth-1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tself.Skip(valueType)\n\t\t}\n\t\treturn self.ReadMapEnd()\n\tcase SET:\n\t\telemType, size, err := self.ReadSetBegin()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i < size; i++ {\n\t\t\terr := Skip(self, elemType, maxDepth-1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn self.ReadSetEnd()\n\tcase LIST:\n\t\telemType, size, err := self.ReadListBegin()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i < size; i++ {\n\t\t\terr := Skip(self, elemType, maxDepth-1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn self.ReadListEnd()\n\t}\n\treturn nil\n}\n"], "fixing_code": ["/*\n * Copyright 2019-present Facebook, Inc.\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage thrift\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestReadWriteBinaryProtocol(t *testing.T) {\n\tReadWriteProtocolTest(t, NewBinaryProtocolFactoryDefault())\n}\n\nfunc TestSkipUnknownTypeBinaryProtocol(t *testing.T) {\n\tvar m MyTestStruct\n\td := NewDeserializer()\n\tf := NewBinaryProtocolFactoryDefault()\n\td.Protocol = f.GetProtocol(d.Transport)\n\t// skip over a map with invalid key/value type and 1.7B entries\n\tdata := []byte(\"\\n\\x10\\rO\\t6\\x03\\n\\n\\n\\x10\\r\\n\\tslice\\x00\")\n\tstart := time.Now()\n\terr := d.Read(&m, data)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"unknown type\") {\n\t\tt.Fatalf(\"Failed for reason besides unknown type\")\n\t}\n\n\tif time.Now().Sub(start).Seconds() > 5 {\n\t\tt.Fatalf(\"It should not take seconds to parse a small message\")\n\t}\n}\n", "/*\n * Copyright 2019-present Facebook, Inc.\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage thrift\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype ProtocolID int16\n\nconst (\n\tProtocolIDBinary     ProtocolID = 0\n\tProtocolIDJSON       ProtocolID = 1\n\tProtocolIDCompact    ProtocolID = 2\n\tProtocolIDDebug      ProtocolID = 3\n\tProtocolIDVirtual    ProtocolID = 4\n\tProtocolIDSimpleJSON ProtocolID = 5\n)\n\nfunc (p ProtocolID) String() string {\n\tswitch p {\n\tcase ProtocolIDBinary:\n\t\treturn \"binary\"\n\tcase ProtocolIDJSON:\n\t\treturn \"json\"\n\tcase ProtocolIDCompact:\n\t\treturn \"compact\"\n\tcase ProtocolIDDebug:\n\t\treturn \"debug\"\n\tcase ProtocolIDVirtual:\n\t\treturn \"virtual\"\n\tcase ProtocolIDSimpleJSON:\n\t\treturn \"simplejson\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\nconst (\n\tVERSION_MASK = 0xffff0000\n\tVERSION_1    = 0x80010000\n)\n\ntype Protocol interface {\n\tWriteMessageBegin(name string, typeId MessageType, seqid int32) error\n\tWriteMessageEnd() error\n\tWriteStructBegin(name string) error\n\tWriteStructEnd() error\n\tWriteFieldBegin(name string, typeId Type, id int16) error\n\tWriteFieldEnd() error\n\tWriteFieldStop() error\n\tWriteMapBegin(keyType Type, valueType Type, size int) error\n\tWriteMapEnd() error\n\tWriteListBegin(elemType Type, size int) error\n\tWriteListEnd() error\n\tWriteSetBegin(elemType Type, size int) error\n\tWriteSetEnd() error\n\tWriteBool(value bool) error\n\tWriteByte(value byte) error\n\tWriteI16(value int16) error\n\tWriteI32(value int32) error\n\tWriteI64(value int64) error\n\tWriteDouble(value float64) error\n\tWriteFloat(value float32) error\n\tWriteString(value string) error\n\tWriteBinary(value []byte) error\n\n\tReadMessageBegin() (name string, typeId MessageType, seqid int32, err error)\n\tReadMessageEnd() error\n\tReadStructBegin() (name string, err error)\n\tReadStructEnd() error\n\tReadFieldBegin() (name string, typeId Type, id int16, err error)\n\tReadFieldEnd() error\n\tReadMapBegin() (keyType Type, valueType Type, size int, err error)\n\tReadMapEnd() error\n\tReadListBegin() (elemType Type, size int, err error)\n\tReadListEnd() error\n\tReadSetBegin() (elemType Type, size int, err error)\n\tReadSetEnd() error\n\tReadBool() (value bool, err error)\n\tReadByte() (value byte, err error)\n\tReadI16() (value int16, err error)\n\tReadI32() (value int32, err error)\n\tReadI64() (value int64, err error)\n\tReadDouble() (value float64, err error)\n\tReadFloat() (value float32, err error)\n\tReadString() (value string, err error)\n\tReadBinary() (value []byte, err error)\n\n\tSkip(fieldType Type) (err error)\n\tFlush() (err error)\n\n\tTransport() Transport\n}\n\n// The maximum recursive depth the skip() function will traverse\nconst DEFAULT_RECURSION_DEPTH = 64\n\n// Skips over the next data element from the provided input Protocol object.\nfunc SkipDefaultDepth(prot Protocol, typeId Type) (err error) {\n\treturn Skip(prot, typeId, DEFAULT_RECURSION_DEPTH)\n}\n\n// Skips over the next data element from the provided input Protocol object.\nfunc Skip(self Protocol, fieldType Type, maxDepth int) (err error) {\n\n\tif maxDepth <= 0 {\n\t\treturn NewProtocolExceptionWithType(DEPTH_LIMIT, errors.New(\"Depth limit exceeded\"))\n\t}\n\n\tswitch fieldType {\n\tcase BOOL:\n\t\t_, err = self.ReadBool()\n\t\treturn\n\tcase BYTE:\n\t\t_, err = self.ReadByte()\n\t\treturn\n\tcase I16:\n\t\t_, err = self.ReadI16()\n\t\treturn\n\tcase I32:\n\t\t_, err = self.ReadI32()\n\t\treturn\n\tcase I64:\n\t\t_, err = self.ReadI64()\n\t\treturn\n\tcase DOUBLE:\n\t\t_, err = self.ReadDouble()\n\t\treturn\n\tcase FLOAT:\n\t\t_, err = self.ReadFloat()\n\t\treturn\n\tcase STRING:\n\t\t_, err = self.ReadString()\n\t\treturn\n\tcase STRUCT:\n\t\tif _, err = self.ReadStructBegin(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor {\n\t\t\t_, typeId, _, _ := self.ReadFieldBegin()\n\t\t\tif typeId == STOP {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr := Skip(self, typeId, maxDepth-1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tself.ReadFieldEnd()\n\t\t}\n\t\treturn self.ReadStructEnd()\n\tcase MAP:\n\t\tkeyType, valueType, size, err := self.ReadMapBegin()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i < size; i++ {\n\t\t\terr := Skip(self, keyType, maxDepth-1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tself.Skip(valueType)\n\t\t}\n\t\treturn self.ReadMapEnd()\n\tcase SET:\n\t\telemType, size, err := self.ReadSetBegin()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i < size; i++ {\n\t\t\terr := Skip(self, elemType, maxDepth-1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn self.ReadSetEnd()\n\tcase LIST:\n\t\telemType, size, err := self.ReadListBegin()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i < size; i++ {\n\t\t\terr := Skip(self, elemType, maxDepth-1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn self.ReadListEnd()\n\tdefault:\n\t\treturn fmt.Errorf(\"unable to skip over unknown type id %d\", fieldType)\n\t}\n}\n"], "filenames": ["thrift/lib/go/thrift/binary_protocol_test.go", "thrift/lib/go/thrift/protocol.go"], "buggy_code_start_loc": [23, 24], "buggy_code_end_loc": [29, 212], "fixing_code_start_loc": [24, 25], "fixing_code_end_loc": [52, 212], "type": "CWE-755", "message": "Go Facebook Thrift servers would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.03.04.00.", "other": {"cve": {"id": "CVE-2019-3564", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-05-06T16:29:01.210", "lastModified": "2021-11-02T20:19:42.100", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Go Facebook Thrift servers would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.03.04.00."}, {"lang": "es", "value": "Los servidores Thrift de Go Facebook no emitir\u00edan errores al  recibir mensajes con contenedores de campos de tipo desconocido. En consecuencia, los clientes maliciosos podr\u00edan enviar mensajes cortos, lo que llevar\u00eda mucho tiempo para que el servidor los analice, esto conllevar\u00eda a una Denegaci\u00f3n de Servicio. Este problema afecta a Facebook Thrift antes de versi\u00f3n 2019.03.04.00."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:thrift:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.03.04.00", "matchCriteriaId": "AB2CB7BA-9067-42CC-883E-533547C95A12"}]}]}], "references": [{"url": "https://github.com/facebook/fbthrift/commit/c461c1bd1a3e130b181aa9c854da3030cd4b5156", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd0e44e8ef71eeaaa3cf3d1b8b41eb25894372e2995ec908ce7624d26@%3Ccommits.pulsar.apache.org%3E", "source": "cve-assign@fb.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-3564", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/fbthrift/commit/c461c1bd1a3e130b181aa9c854da3030cd4b5156"}}