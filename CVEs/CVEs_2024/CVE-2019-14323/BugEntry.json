{"buggy_code": ["/* SSDP responder\n *\n * Copyright (c) 2017  Joachim Nilsson <troglobit@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.a\n */\n\n#include <config.h>\n#include <ctype.h>\n#include <err.h>\n#include <errno.h>\n#include <getopt.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <paths.h>\n#include <poll.h>\n#include <stdio.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <sys/param.h>\t\t/* MIN() */\n#include <sys/socket.h>\n\n#include \"ssdp.h\"\n#include \"queue.h\"\n\nstruct ifsock {\n\tLIST_ENTRY(ifsock) link;\n\n\tint stale;\n\tint mod;\n\n\t/*\n\t * Sockets for inbound and outbound\n\t *\n\t * - The inbound is the multicast socket, shared between all ifaces\n\t * - The outbound is bound to the iface address and a random port\n\t */\n\tint in, out;\n\n\t/* Interface address and netmask */\n\tstruct sockaddr_in addr;\n\tstruct sockaddr_in mask;\n\n\tvoid (*cb)(int);\n};\n\nLIST_HEAD(, ifsock) il = LIST_HEAD_INITIALIZER();\n\nstatic char *supported_types[] = {\n\tSSDP_ST_ALL,\n\t\"upnp:rootdevice\",\n\t\"urn:schemas-upnp-org:device:InternetGatewayDevice:1\",\n\tuuid,\n\tNULL\n};\n\nint      debug = 0;\nint      running = 1;\n\nchar uuid[42];\nchar hostname[64];\nchar *os = NULL, *ver = NULL;\nchar server_string[64] = \"POSIX UPnP/1.0 \" PACKAGE_NAME \"/\" PACKAGE_VERSION;\n\n/* Find interface in same subnet as sa */\nstatic struct ifsock *find_outbound(struct sockaddr *sa)\n{\n\tin_addr_t cand;\n\tstruct ifsock *ifs;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)sa;\n\n\tcand = addr->sin_addr.s_addr;\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tin_addr_t a, m;\n\n\t\ta = ifs->addr.sin_addr.s_addr;\n\t\tm = ifs->mask.sin_addr.s_addr;\n\t\tif (a == htonl(INADDR_ANY) || m == htonl(INADDR_ANY))\n\t\t\tcontinue;\n\n\t\tif ((a & m) == (cand & m))\n\t\t\treturn ifs;\n\t}\n\n\treturn NULL;\n}\n\n/* Exact match, must be same ifaddr as sa */\nstatic struct ifsock *find_iface(struct sockaddr *sa)\n{\n\tstruct ifsock *ifs;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)sa;\n\n\tif (!sa)\n\t\treturn NULL;\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tif (ifs->addr.sin_addr.s_addr == addr->sin_addr.s_addr)\n\t\t\treturn ifs;\n\t}\n\n\treturn NULL;\n}\n\nint register_socket(int in, int out, struct sockaddr *addr, struct sockaddr *mask, void (*cb)(int sd))\n{\n\tstruct ifsock *ifs;\n\tstruct sockaddr_in *address = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in *netmask = (struct sockaddr_in *)mask;\n\n\tifs = calloc(1, sizeof(*ifs));\n\tif (!ifs) {\n\t\tchar *host = inet_ntoa(address->sin_addr);\n\n\t\tlogit(LOG_ERR, \"Failed registering host %s socket: %s\", host, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tifs->in   = in;\n\tifs->out  = out;\n\tifs->mod  = 1;\n\tifs->cb   = cb;\n\tifs->addr = *address;\n\tif (mask)\n\t\tifs->mask = *netmask;\n\tLIST_INSERT_HEAD(&il, ifs, link);\n\n\treturn 0;\n}\n\nstatic int open_socket(char *ifname, struct sockaddr *addr, int port)\n{\n\tint sd, val, rc;\n\tchar loop;\n\tstruct ip_mreqn mreq;\n\tstruct sockaddr_in sin, *address = (struct sockaddr_in *)addr;\n\n\tsd = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);\n\tif (sd < 0)\n\t\treturn -1;\n\n\tsin.sin_family = AF_INET;\n\tsin.sin_port = htons(port);\n\tsin.sin_addr = address->sin_addr;\n\tif (bind(sd, (struct sockaddr *)&sin, sizeof(sin)) < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed binding to %s:%d: %s\", inet_ntoa(address->sin_addr), port, strerror(errno));\n\t\treturn -1;\n\t}\n#if 0\n        ENABLE_SOCKOPT(sd, SOL_SOCKET, SO_REUSEADDR);\n#ifdef SO_REUSEPORT\n        ENABLE_SOCKOPT(sd, SOL_SOCKET, SO_REUSEPORT);\n#endif\n#endif\n\tmemset(&mreq, 0, sizeof(mreq));\n\tmreq.imr_address = address->sin_addr;\n\tmreq.imr_multiaddr.s_addr = inet_addr(MC_SSDP_GROUP);\n        if (setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq))) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed joining group %s: %s\", MC_SSDP_GROUP, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tval = 2;\t\t/* Default 2, but should be configurable */\n\trc = setsockopt(sd, IPPROTO_IP, IP_MULTICAST_TTL, &val, sizeof(val));\n\tif (rc < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed setting multicast TTL: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tloop = 0;\n\trc = setsockopt(sd, IPPROTO_IP, IP_MULTICAST_LOOP, &loop, sizeof(loop));\n\tif (rc < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed disabing multicast loop: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\trc = setsockopt(sd, IPPROTO_IP, IP_MULTICAST_IF, &address->sin_addr, sizeof(address->sin_addr));\n\tif (rc < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed setting multicast interface: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlogit(LOG_DEBUG, \"Adding new interface %s with address %s\", ifname, inet_ntoa(address->sin_addr));\n\n\treturn sd;\n}\n\nstatic int close_socket(void)\n{\n\tint ret = 0;\n\tstruct ifsock *ifs, *tmp;\n\n\tLIST_FOREACH_SAFE(ifs, &il, link, tmp) {\n\t\tLIST_REMOVE(ifs, link);\n\t\tif (ifs->out != -1)\n\t\t\tret |= close(ifs->out);\n\t\telse\n\t\t\tret |= close(ifs->in);\n\t\tfree(ifs);\n\t}\n\n\treturn ret;\n}\n\nstatic int filter_addr(struct sockaddr *sa)\n{\n\tstruct ifsock *ifs;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\n\tif (!sa)\n\t\treturn 1;\n\n\tif (sa->sa_family != AF_INET)\n\t\treturn 1;\n\n\tif (sin->sin_addr.s_addr == htonl(INADDR_ANY))\n\t\treturn 1;\n\n\tif (sin->sin_addr.s_addr == htonl(INADDR_LOOPBACK))\n\t\treturn 1;\n\n\tifs = find_outbound(sa);\n\tif (ifs) {\n\t\tif (ifs->addr.sin_addr.s_addr != htonl(INADDR_ANY))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int filter_iface(char *ifname, char *iflist[], size_t num)\n{\n\tsize_t i;\n\n\tif (!num) {\n\t\tlogit(LOG_DEBUG, \"No interfaces to filter, using all with an IP address.\");\n\t\treturn 0;\n\t}\n\n\tlogit(LOG_DEBUG, \"Filter %s?  Comparing %zd entries ...\", ifname, num);\n\tfor (i = 0; i < num; i++) {\n\t\tlogit(LOG_DEBUG, \"Filter %s?  Comparing with %s ...\", ifname, iflist[i]);\n\t\tif (!strcmp(ifname, iflist[i]))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void compose_addr(struct sockaddr_in *sin, char *group, int port)\n{\n\tmemset(sin, 0, sizeof(*sin));\n\tsin->sin_family      = AF_INET;\n\tsin->sin_port        = htons(port);\n\tsin->sin_addr.s_addr = inet_addr(group);\n}\n\nstatic void compose_response(char *type, char *host, char *buf, size_t len)\n{\n\tchar usn[256];\n\tchar date[42];\n\ttime_t now;\n\n\t/* RFC1123 date, as specified in RFC2616 */\n\tnow = time(NULL);\n\tstrftime(date, sizeof(date), \"%a, %d %b %Y %T %Z\", gmtime(&now));\n\n\tif (type) {\n\t\tif (!strcmp(type, uuid))\n\t\t\ttype = NULL;\n\t\telse\n\t\t\tsnprintf(usn, sizeof(usn), \"%s::%s\", uuid, type);\n\t}\n\n\tif (!type)\n\t\tstrncpy(usn, uuid, sizeof(usn));\n\n\tsnprintf(buf, len, \"HTTP/1.1 200 OK\\r\\n\"\n\t\t \"Server: %s\\r\\n\"\n\t\t \"Date: %s\\r\\n\"\n\t\t \"Location: http://%s:%d%s\\r\\n\"\n\t\t \"ST: %s\\r\\n\"\n\t\t \"EXT: \\r\\n\"\n\t\t \"USN: %s\\r\\n\"\n\t\t \"Cache-Control: max-age=%d\\r\\n\"\n\t\t \"\\r\\n\",\n\t\t server_string,\n\t\t date,\n\t\t host, LOCATION_PORT, LOCATION_DESC,\n\t\t type,\n\t\t usn,\n\t\t CACHE_TIMEOUT);\n}\n\nstatic void compose_search(char *type, char *buf, size_t len)\n{\n\tsnprintf(buf, len, \"M-SEARCH * HTTP/1.1\\r\\n\"\n\t\t \"Host: %s:%d\\r\\n\"\n\t\t \"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n\t\t \"MX: 1\\r\\n\"\n\t\t \"ST: %s\\r\\n\"\n\t\t \"User-Agent: %s\\r\\n\"\n\t\t \"\\r\\n\",\n\t\t MC_SSDP_GROUP, MC_SSDP_PORT,\n\t\t type,\n\t\t server_string);\n}\n\nstatic void compose_notify(char *type, char *host, char *buf, size_t len)\n{\n\tchar usn[256];\n\n\tif (type) {\n\t\tif (!strcmp(type, SSDP_ST_ALL))\n\t\t\ttype = NULL;\n\t\telse\n\t\t\tsnprintf(usn, sizeof(usn), \"%s::%s\", uuid, type);\n\t}\n\n\tif (!type) {\n\t\ttype = usn;\n\t\tstrncpy(usn, uuid, sizeof(usn));\n\t}\n\n\tsnprintf(buf, len, \"NOTIFY * HTTP/1.1\\r\\n\"\n\t\t \"Host: %s:%d\\r\\n\"\n\t\t \"Server: %s\\r\\n\"\n\t\t \"Location: http://%s:%d%s\\r\\n\"\n\t\t \"NT: %s\\r\\n\"\n\t\t \"NTS: ssdp:alive\\r\\n\"\n\t\t \"USN: %s\\r\\n\"\n\t\t \"Cache-Control: max-age=%d\\r\\n\"\n\t\t \"\\r\\n\",\n\t\t MC_SSDP_GROUP, MC_SSDP_PORT,\n\t\t server_string,\n\t\t host, LOCATION_PORT, LOCATION_DESC,\n\t\t type,\n\t\t usn,\n\t\t CACHE_TIMEOUT);\n}\n\nsize_t pktlen(unsigned char *buf)\n{\n\tsize_t hdr = sizeof(struct udphdr);\n\n\treturn strlen((char *)buf + hdr) + hdr;\n}\n\nstatic void send_search(struct ifsock *ifs, char *type)\n{\n\tssize_t num;\n\tchar buf[MAX_PKT_SIZE];\n\tstruct sockaddr dest;\n\n\tmemset(buf, 0, sizeof(buf));\n\tcompose_search(type, buf, sizeof(buf));\n\tcompose_addr((struct sockaddr_in *)&dest, MC_SSDP_GROUP, MC_SSDP_PORT);\n\n\tlogit(LOG_DEBUG, \"Sending M-SEARCH ...\");\n\tnum = sendto(ifs->out, buf, strlen(buf), 0, &dest, sizeof(struct sockaddr_in));\n\tif (num < 0)\n\t\tlogit(LOG_WARNING, \"Failed sending SSDP M-SEARCH\");\n}\n\nstatic void send_message(struct ifsock *ifs, char *type, struct sockaddr *sa)\n{\n\tint s;\n\tsize_t i, len, note = 0;\n\tssize_t num;\n\tchar host[NI_MAXHOST];\n\tchar buf[MAX_PKT_SIZE];\n\tstruct sockaddr dest;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\n\tgethostname(hostname, sizeof(hostname));\n\ts = getnameinfo((struct sockaddr *)&ifs->addr, sizeof(struct sockaddr_in), host, sizeof(host), NULL, 0, NI_NUMERICHOST);\n\tif (s) {\n\t\tlogit(LOG_WARNING, \"Failed getnameinfo(): %s\", gai_strerror(s));\n\t\treturn;\n\t}\n\n\tif (ifs->addr.sin_addr.s_addr == htonl(INADDR_ANY))\n\t\treturn;\n\tif (ifs->out == -1)\n\t\treturn;\n\n\tif (!strcmp(type, SSDP_ST_ALL))\n\t\ttype = NULL;\n\n\tmemset(buf, 0, sizeof(buf));\n\tif (sin)\n\t\tcompose_response(type, host, buf, sizeof(buf));\n\telse\n\t\tcompose_notify(type, host, buf, sizeof(buf));\n\n\tif (!sin) {\n\t\tnote = 1;\n\t\tcompose_addr((struct sockaddr_in *)&dest, MC_SSDP_GROUP, MC_SSDP_PORT);\n\t\tsin = (struct sockaddr_in *)&dest;\n\t}\n\n\tlogit(LOG_DEBUG, \"Sending %s from %s ...\", !note ? \"reply\" : \"notify\", host);\n\tnum = sendto(ifs->out, buf, strlen(buf), 0, sin, sizeof(struct sockaddr_in));\n\tif (num < 0)\n\t\tlogit(LOG_WARNING, \"Failed sending SSDP %s, type: %s: %s\", !note ? \"reply\" : \"notify\", type, strerror(errno));\n}\n\nstatic void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}\n\nstatic int multicast_init(void)\n{\n\tint sd;\n\tstruct sockaddr sa;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\tsd = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);\n\tif (sd < 0) {\n\t\tlogit(LOG_ERR, \"Failed opening multicast socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsin->sin_family = AF_INET;\n\tsin->sin_addr.s_addr = inet_addr(MC_SSDP_GROUP);\n\tsin->sin_port = htons(MC_SSDP_PORT);\n\n\tif (bind(sd, &sa, sizeof(*sin)) < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed binding to %s:%d: %s\", inet_ntoa(sin->sin_addr), MC_SSDP_PORT, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tregister_socket(sd, -1, &sa, NULL, ssdp_recv);\n\n\treturn sd;\n}\n\nstatic int multicast_join(int sd, struct sockaddr *sa)\n{\n\tstruct ip_mreqn mreq;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\n\tmemset(&mreq, 0, sizeof(mreq));\n\tmreq.imr_address = sin->sin_addr;\n\tmreq.imr_multiaddr.s_addr = inet_addr(MC_SSDP_GROUP);\n        if (setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq))) {\n\t\tif (EADDRINUSE == errno)\n\t\t\treturn 0;\n\n\t\tlogit(LOG_ERR, \"Failed joining group %s: %s\", MC_SSDP_GROUP, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void mark(void)\n{\n\tstruct ifsock *ifs;\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tif (ifs->out != -1)\n\t\t\tifs->stale = 1;\n\t\telse\n\t\t\tifs->stale = 0;\n\t}\n}\n\nstatic int sweep(void)\n{\n\tint modified = 0;\n\tstruct ifsock *ifs, *tmp;\n\n\tLIST_FOREACH_SAFE(ifs, &il, link, tmp) {\n\t\tif (!ifs->stale)\n\t\t\tcontinue;\n\n\t\tmodified++;\n\t\tlogit(LOG_DEBUG, \"Removing stale ifs %s\", inet_ntoa(ifs->addr.sin_addr));\n\n\t\tLIST_REMOVE(ifs, link);\n\t\tclose(ifs->out);\n\t\tfree(ifs);\n\t}\n\n\treturn modified;\n}\n\nstatic int ssdp_init(int in, char *iflist[], size_t num)\n{\n\tint modified;\n\tsize_t i;\n\tstruct ifaddrs *ifaddrs, *ifa;\n\n\tlogit(LOG_INFO, \"Updating interfaces ...\");\n\n\tif (getifaddrs(&ifaddrs) < 0) {\n\t\tlogit(LOG_ERR, \"Failed getifaddrs(): %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\t/* Mark all outbound interfaces as stale */\n\tmark();\n\n\t/* First pass, clear stale marker from exact matches */\n\tfor (ifa = ifaddrs; ifa; ifa = ifa->ifa_next) {\n\t\tstruct ifsock *ifs;\n\n\t\t/* Do we already have it? */\n\t\tifs = find_iface(ifa->ifa_addr);\n\t\tif (ifs) {\n\t\t\tifs->stale = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t/* Clean out any stale interface addresses */\n\tmodified = sweep();\n\n\t/* Second pass, add new ones */\n\tfor (ifa = ifaddrs; ifa; ifa = ifa->ifa_next) {\n\t\tint sd;\n\n\t\t/* Interface filtering, optional command line argument */\n\t\tif (filter_iface(ifa->ifa_name, iflist, num)) {\n\t\t\tlogit(LOG_DEBUG, \"Skipping %s, not in iflist.\", ifa->ifa_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do we have another in the same subnet? */\n\t\tif (filter_addr(ifa->ifa_addr))\n\t\t\tcontinue;\n\n\t\tsd = open_socket(ifa->ifa_name, ifa->ifa_addr, MC_SSDP_PORT);\n\t\tif (sd < 0)\n\t\t\tcontinue;\n\n\t\tmulticast_join(in, ifa->ifa_addr);\n\n\t\tif (register_socket(in, sd, ifa->ifa_addr, ifa->ifa_netmask, ssdp_recv)) {\n\t\t\tclose(sd);\n\t\t\tbreak;\n\t\t}\n\t\tmodified++;\n\t}\n\n\tfreeifaddrs(ifaddrs);\n\n\treturn modified;\n}\n\nstatic void handle_message(int sd)\n{\n\tstruct ifsock *ifs;\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tif (ifs->in != sd)\n\t\t\tcontinue;\n\n\t\tif (ifs->cb)\n\t\t\tifs->cb(sd);\n\t}\n}\n\nstatic void wait_message(time_t tmo)\n{\n\tint num = 1, timeout;\n\tsize_t ifnum = 0;\n\tstruct pollfd pfd[MAX_NUM_IFACES];\n\tstruct ifsock *ifs;\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tif (ifs->out != -1)\n\t\t\tcontinue;\n\n\t\tpfd[ifnum].fd = ifs->in;\n\t\tpfd[ifnum].events = POLLIN | POLLHUP;\n\t\tifnum++;\n\t}\n\n\twhile (1) {\n\t\tsize_t i;\n\n\t\ttimeout = tmo - time(NULL);\n\t\tif (timeout < 0)\n\t\t\tbreak;\n\n\t\tnum = poll(pfd, ifnum, timeout * 1000);\n\t\tif (num < 0) {\n\t\t\tif (EINTR == errno)\n\t\t\t\tbreak;\n\n\t\t\terr(1, \"Unrecoverable error\");\n\t\t}\n\n\t\tif (num == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; num > 0 && i < ifnum; i++) {\n\t\t\tif (pfd[i].revents & POLLIN) {\n\t\t\t\thandle_message(pfd[i].fd);\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void announce(int mod)\n{\n\tstruct ifsock *ifs;\n\n\tlogit(LOG_INFO, \"Sending SSDP NOTIFY new:%d ...\", mod);\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tsize_t i;\n\n\t\tif (mod && !ifs->mod)\n\t\t\tcontinue;\n\t\tifs->mod = 0;\n\n//\t\tsend_search(ifs, \"upnp:rootdevice\");\n\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t/* UUID sent in SSDP_ST_ALL, first announce */\n\t\t\tif (!strcmp(supported_types[i], uuid))\n\t\t\t\tcontinue;\n\n\t\t\tsend_message(ifs, supported_types[i], NULL);\n\t\t}\n\t}\n}\n\nstatic void lsb_init(void)\n{\n\tFILE *fp;\n\tchar *ptr;\n\tchar line[80];\n\tconst char *file = \"/etc/lsb-release\";\n\n\tfp = fopen(file, \"r\");\n\tif (!fp) {\n\tfallback:\n\t\tlogit(LOG_WARNING, \"No %s found on system, using built-in server string.\", file);\n\t\treturn;\n\t}\n\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tline[strlen(line) - 1] = 0;\n\n\t\tptr = strstr(line, \"DISTRIB_ID\");\n\t\tif (ptr && (ptr = strchr(ptr, '=')))\n\t\t\tos = strdup(++ptr);\n\n\t\tptr = strstr(line, \"DISTRIB_RELEASE\");\n\t\tif (ptr && (ptr = strchr(ptr, '=')))\n\t\t\tver = strdup(++ptr);\n\t}\n\tfclose(fp);\n\n\tif (os && ver)\n\t\tsnprintf(server_string, sizeof(server_string), \"%s/%s UPnP/1.0 %s/%s\",\n\t\t\t os, ver, PACKAGE_NAME, PACKAGE_VERSION);\n\telse\n\t\tgoto fallback;\n\n\tlogit(LOG_DEBUG, \"Server: %s\", server_string);\n}\n\n/* https://en.wikipedia.org/wiki/Universally_unique_identifier */\nstatic void uuidgen(void)\n{\n\tFILE *fp;\n\tchar buf[42];\n\tconst char *file = _PATH_VARDB PACKAGE_NAME \".cache\";\n\n\tfp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfp = fopen(file, \"w\");\n\t\tif (!fp)\n\t\t\tlogit(LOG_WARNING, \"Cannot create UUID cache, %s: %s\", file, strerror(errno));\n\n\tgenerate:\n\t\tsrand(time(NULL));\n\t\tsnprintf(buf, sizeof(buf), \"uuid:%8.8x-%4.4x-%4.4x-%4.4x-%6.6x%6.6x\",\n\t\t\t rand() & 0xFFFFFFFF,\n\t\t\t rand() & 0xFFFF,\n\t\t\t (rand() & 0x0FFF) | 0x4000, /* M  4 MSB version => version 4 */\n\t\t\t (rand() & 0x1FFF) | 0x8000, /* N: 3 MSB variant => variant 1 */\n\t\t\t rand() & 0xFFFFFF, rand() & 0xFFFFFF);\n\n\t\tif (fp) {\n\t\t\tlogit(LOG_DEBUG, \"Creating new UUID cache file, %s\", file);\n\t\t\tfprintf(fp, \"%s\\n\", buf);\n\t\t\tfclose(fp);\n\t\t}\n\t} else {\n\t\tif (!fgets(buf, sizeof(buf), fp)) {\n\t\t\tfclose(fp);\n\t\t\tgoto generate;\n\t\t}\n\t\tbuf[strlen(buf) - 1] = 0;\n\t\tfclose(fp);\n\t}\n\n\tstrcpy(uuid, buf);\n\tlogit(LOG_DEBUG, \"URN: %s\", uuid);\n}\n\nstatic void exit_handler(int signo)\n{\n\t(void)signo;\n\trunning = 0;\n}\n\nstatic void signal_init(void)\n{\n\tsignal(SIGTERM, exit_handler);\n\tsignal(SIGINT,  exit_handler);\n\tsignal(SIGHUP,  exit_handler);\n\tsignal(SIGQUIT, exit_handler);\n}\n\nstatic int usage(int code)\n{\n\tprintf(\"Usage: %s [-dhv] [-i SEC] [IFACE [IFACE ...]]\\n\"\n\t       \"\\n\"\n\t       \"    -d        Developer debug mode\\n\"\n\t       \"    -h        This help text\\n\"\n\t       \"    -i SEC    SSDP notify interval (30-900), default %d sec\\n\"\n\t       \"    -r SEC    Interface refresh interval (5-1800), default %d sec\\n\"\n\t       \"    -v        Show program version\\n\"\n\t       \"\\n\"\n\t       \"Bug report address: %-40s\\n\", PACKAGE_NAME, NOTIFY_INTERVAL, REFRESH_INTERVAL, PACKAGE_BUGREPORT);\n\n\treturn code;\n}\n\nint main(int argc, char *argv[])\n{\n\tint i, c, sd;\n\tint log_level = LOG_NOTICE;\n\tint log_opts = LOG_CONS | LOG_PID;\n\tint interval = NOTIFY_INTERVAL;\n\tint refresh = REFRESH_INTERVAL;\n\ttime_t now, rtmo = 0, itmo = 0;\n\n\twhile ((c = getopt(argc, argv, \"dhi:r:v\")) != EOF) {\n\t\tswitch (c) {\n\t\tcase 'd':\n\t\t\tdebug = 1;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\treturn usage(0);\n\n\t\tcase 'i':\n\t\t\tinterval = atoi(optarg);\n\t\t\tif (interval < 30 || interval > 900)\n\t\t\t\terrx(1, \"Invalid announcement interval (30-900).\");\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\trefresh = atoi(optarg);\n\t\t\tif (refresh < 5 || refresh > 1800)\n\t\t\t\terrx(1, \"Invalid refresh interval (5-1800).\");\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tputs(PACKAGE_VERSION);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsignal_init();\n\n        if (debug) {\n\t\tlog_level = LOG_DEBUG;\n                log_opts |= LOG_PERROR;\n\t}\n\n        openlog(PACKAGE_NAME, log_opts, LOG_DAEMON);\n        setlogmask(LOG_UPTO(log_level));\n\n\tuuidgen();\n\tlsb_init();\n\tweb_init();\n\n\tsd = multicast_init();\n\tif (sd < 0)\n\t\terr(1, \"Failed creating multicast socket\");\n\n\twhile (running) {\n\t\tnow = time(NULL);\n\n\t\tif (rtmo <= now) {\n\t\t\tif (ssdp_init(sd, &argv[optind], argc - optind) > 0)\n\t\t\t\tannounce(1);\n\t\t\trtmo = now + refresh;\n\t\t}\n\n\t\tif (itmo <= now) {\n\t\t\tannounce(0);\n\t\t\titmo = now + interval;\n\t\t}\n\n\t\twait_message(MIN(rtmo, itmo));\n\t}\n\n\tcloselog();\n\treturn close_socket();\n}\n\n/**\n * Local Variables:\n *  indent-tabs-mode: t\n *  c-file-style: \"linux\"\n * End:\n */\n"], "fixing_code": ["/* SSDP responder\n *\n * Copyright (c) 2017  Joachim Nilsson <troglobit@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.a\n */\n\n#include <config.h>\n#include <ctype.h>\n#include <err.h>\n#include <errno.h>\n#include <getopt.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <paths.h>\n#include <poll.h>\n#include <stdio.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <sys/param.h>\t\t/* MIN() */\n#include <sys/socket.h>\n\n#include \"ssdp.h\"\n#include \"queue.h\"\n\nstruct ifsock {\n\tLIST_ENTRY(ifsock) link;\n\n\tint stale;\n\tint mod;\n\n\t/*\n\t * Sockets for inbound and outbound\n\t *\n\t * - The inbound is the multicast socket, shared between all ifaces\n\t * - The outbound is bound to the iface address and a random port\n\t */\n\tint in, out;\n\n\t/* Interface address and netmask */\n\tstruct sockaddr_in addr;\n\tstruct sockaddr_in mask;\n\n\tvoid (*cb)(int);\n};\n\nLIST_HEAD(, ifsock) il = LIST_HEAD_INITIALIZER();\n\nstatic char *supported_types[] = {\n\tSSDP_ST_ALL,\n\t\"upnp:rootdevice\",\n\t\"urn:schemas-upnp-org:device:InternetGatewayDevice:1\",\n\tuuid,\n\tNULL\n};\n\nint      debug = 0;\nint      running = 1;\n\nchar uuid[42];\nchar hostname[64];\nchar *os = NULL, *ver = NULL;\nchar server_string[64] = \"POSIX UPnP/1.0 \" PACKAGE_NAME \"/\" PACKAGE_VERSION;\n\n/* Find interface in same subnet as sa */\nstatic struct ifsock *find_outbound(struct sockaddr *sa)\n{\n\tin_addr_t cand;\n\tstruct ifsock *ifs;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)sa;\n\n\tcand = addr->sin_addr.s_addr;\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tin_addr_t a, m;\n\n\t\ta = ifs->addr.sin_addr.s_addr;\n\t\tm = ifs->mask.sin_addr.s_addr;\n\t\tif (a == htonl(INADDR_ANY) || m == htonl(INADDR_ANY))\n\t\t\tcontinue;\n\n\t\tif ((a & m) == (cand & m))\n\t\t\treturn ifs;\n\t}\n\n\treturn NULL;\n}\n\n/* Exact match, must be same ifaddr as sa */\nstatic struct ifsock *find_iface(struct sockaddr *sa)\n{\n\tstruct ifsock *ifs;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)sa;\n\n\tif (!sa)\n\t\treturn NULL;\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tif (ifs->addr.sin_addr.s_addr == addr->sin_addr.s_addr)\n\t\t\treturn ifs;\n\t}\n\n\treturn NULL;\n}\n\nint register_socket(int in, int out, struct sockaddr *addr, struct sockaddr *mask, void (*cb)(int sd))\n{\n\tstruct ifsock *ifs;\n\tstruct sockaddr_in *address = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in *netmask = (struct sockaddr_in *)mask;\n\n\tifs = calloc(1, sizeof(*ifs));\n\tif (!ifs) {\n\t\tchar *host = inet_ntoa(address->sin_addr);\n\n\t\tlogit(LOG_ERR, \"Failed registering host %s socket: %s\", host, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tifs->in   = in;\n\tifs->out  = out;\n\tifs->mod  = 1;\n\tifs->cb   = cb;\n\tifs->addr = *address;\n\tif (mask)\n\t\tifs->mask = *netmask;\n\tLIST_INSERT_HEAD(&il, ifs, link);\n\n\treturn 0;\n}\n\nstatic int open_socket(char *ifname, struct sockaddr *addr, int port)\n{\n\tint sd, val, rc;\n\tchar loop;\n\tstruct ip_mreqn mreq;\n\tstruct sockaddr_in sin, *address = (struct sockaddr_in *)addr;\n\n\tsd = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);\n\tif (sd < 0)\n\t\treturn -1;\n\n\tsin.sin_family = AF_INET;\n\tsin.sin_port = htons(port);\n\tsin.sin_addr = address->sin_addr;\n\tif (bind(sd, (struct sockaddr *)&sin, sizeof(sin)) < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed binding to %s:%d: %s\", inet_ntoa(address->sin_addr), port, strerror(errno));\n\t\treturn -1;\n\t}\n#if 0\n        ENABLE_SOCKOPT(sd, SOL_SOCKET, SO_REUSEADDR);\n#ifdef SO_REUSEPORT\n        ENABLE_SOCKOPT(sd, SOL_SOCKET, SO_REUSEPORT);\n#endif\n#endif\n\tmemset(&mreq, 0, sizeof(mreq));\n\tmreq.imr_address = address->sin_addr;\n\tmreq.imr_multiaddr.s_addr = inet_addr(MC_SSDP_GROUP);\n        if (setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq))) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed joining group %s: %s\", MC_SSDP_GROUP, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tval = 2;\t\t/* Default 2, but should be configurable */\n\trc = setsockopt(sd, IPPROTO_IP, IP_MULTICAST_TTL, &val, sizeof(val));\n\tif (rc < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed setting multicast TTL: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tloop = 0;\n\trc = setsockopt(sd, IPPROTO_IP, IP_MULTICAST_LOOP, &loop, sizeof(loop));\n\tif (rc < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed disabing multicast loop: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\trc = setsockopt(sd, IPPROTO_IP, IP_MULTICAST_IF, &address->sin_addr, sizeof(address->sin_addr));\n\tif (rc < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed setting multicast interface: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlogit(LOG_DEBUG, \"Adding new interface %s with address %s\", ifname, inet_ntoa(address->sin_addr));\n\n\treturn sd;\n}\n\nstatic int close_socket(void)\n{\n\tint ret = 0;\n\tstruct ifsock *ifs, *tmp;\n\n\tLIST_FOREACH_SAFE(ifs, &il, link, tmp) {\n\t\tLIST_REMOVE(ifs, link);\n\t\tif (ifs->out != -1)\n\t\t\tret |= close(ifs->out);\n\t\telse\n\t\t\tret |= close(ifs->in);\n\t\tfree(ifs);\n\t}\n\n\treturn ret;\n}\n\nstatic int filter_addr(struct sockaddr *sa)\n{\n\tstruct ifsock *ifs;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\n\tif (!sa)\n\t\treturn 1;\n\n\tif (sa->sa_family != AF_INET)\n\t\treturn 1;\n\n\tif (sin->sin_addr.s_addr == htonl(INADDR_ANY))\n\t\treturn 1;\n\n\tif (sin->sin_addr.s_addr == htonl(INADDR_LOOPBACK))\n\t\treturn 1;\n\n\tifs = find_outbound(sa);\n\tif (ifs) {\n\t\tif (ifs->addr.sin_addr.s_addr != htonl(INADDR_ANY))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int filter_iface(char *ifname, char *iflist[], size_t num)\n{\n\tsize_t i;\n\n\tif (!num) {\n\t\tlogit(LOG_DEBUG, \"No interfaces to filter, using all with an IP address.\");\n\t\treturn 0;\n\t}\n\n\tlogit(LOG_DEBUG, \"Filter %s?  Comparing %zd entries ...\", ifname, num);\n\tfor (i = 0; i < num; i++) {\n\t\tlogit(LOG_DEBUG, \"Filter %s?  Comparing with %s ...\", ifname, iflist[i]);\n\t\tif (!strcmp(ifname, iflist[i]))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void compose_addr(struct sockaddr_in *sin, char *group, int port)\n{\n\tmemset(sin, 0, sizeof(*sin));\n\tsin->sin_family      = AF_INET;\n\tsin->sin_port        = htons(port);\n\tsin->sin_addr.s_addr = inet_addr(group);\n}\n\nstatic void compose_response(char *type, char *host, char *buf, size_t len)\n{\n\tchar usn[256];\n\tchar date[42];\n\ttime_t now;\n\n\t/* RFC1123 date, as specified in RFC2616 */\n\tnow = time(NULL);\n\tstrftime(date, sizeof(date), \"%a, %d %b %Y %T %Z\", gmtime(&now));\n\n\tif (type) {\n\t\tif (!strcmp(type, uuid))\n\t\t\ttype = NULL;\n\t\telse\n\t\t\tsnprintf(usn, sizeof(usn), \"%s::%s\", uuid, type);\n\t}\n\n\tif (!type)\n\t\tstrncpy(usn, uuid, sizeof(usn));\n\n\tsnprintf(buf, len, \"HTTP/1.1 200 OK\\r\\n\"\n\t\t \"Server: %s\\r\\n\"\n\t\t \"Date: %s\\r\\n\"\n\t\t \"Location: http://%s:%d%s\\r\\n\"\n\t\t \"ST: %s\\r\\n\"\n\t\t \"EXT: \\r\\n\"\n\t\t \"USN: %s\\r\\n\"\n\t\t \"Cache-Control: max-age=%d\\r\\n\"\n\t\t \"\\r\\n\",\n\t\t server_string,\n\t\t date,\n\t\t host, LOCATION_PORT, LOCATION_DESC,\n\t\t type,\n\t\t usn,\n\t\t CACHE_TIMEOUT);\n}\n\nstatic void compose_search(char *type, char *buf, size_t len)\n{\n\tsnprintf(buf, len, \"M-SEARCH * HTTP/1.1\\r\\n\"\n\t\t \"Host: %s:%d\\r\\n\"\n\t\t \"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n\t\t \"MX: 1\\r\\n\"\n\t\t \"ST: %s\\r\\n\"\n\t\t \"User-Agent: %s\\r\\n\"\n\t\t \"\\r\\n\",\n\t\t MC_SSDP_GROUP, MC_SSDP_PORT,\n\t\t type,\n\t\t server_string);\n}\n\nstatic void compose_notify(char *type, char *host, char *buf, size_t len)\n{\n\tchar usn[256];\n\n\tif (type) {\n\t\tif (!strcmp(type, SSDP_ST_ALL))\n\t\t\ttype = NULL;\n\t\telse\n\t\t\tsnprintf(usn, sizeof(usn), \"%s::%s\", uuid, type);\n\t}\n\n\tif (!type) {\n\t\ttype = usn;\n\t\tstrncpy(usn, uuid, sizeof(usn));\n\t}\n\n\tsnprintf(buf, len, \"NOTIFY * HTTP/1.1\\r\\n\"\n\t\t \"Host: %s:%d\\r\\n\"\n\t\t \"Server: %s\\r\\n\"\n\t\t \"Location: http://%s:%d%s\\r\\n\"\n\t\t \"NT: %s\\r\\n\"\n\t\t \"NTS: ssdp:alive\\r\\n\"\n\t\t \"USN: %s\\r\\n\"\n\t\t \"Cache-Control: max-age=%d\\r\\n\"\n\t\t \"\\r\\n\",\n\t\t MC_SSDP_GROUP, MC_SSDP_PORT,\n\t\t server_string,\n\t\t host, LOCATION_PORT, LOCATION_DESC,\n\t\t type,\n\t\t usn,\n\t\t CACHE_TIMEOUT);\n}\n\nsize_t pktlen(unsigned char *buf)\n{\n\tsize_t hdr = sizeof(struct udphdr);\n\n\treturn strlen((char *)buf + hdr) + hdr;\n}\n\nstatic void send_search(struct ifsock *ifs, char *type)\n{\n\tssize_t num;\n\tchar buf[MAX_PKT_SIZE];\n\tstruct sockaddr dest;\n\n\tmemset(buf, 0, sizeof(buf));\n\tcompose_search(type, buf, sizeof(buf));\n\tcompose_addr((struct sockaddr_in *)&dest, MC_SSDP_GROUP, MC_SSDP_PORT);\n\n\tlogit(LOG_DEBUG, \"Sending M-SEARCH ...\");\n\tnum = sendto(ifs->out, buf, strlen(buf), 0, &dest, sizeof(struct sockaddr_in));\n\tif (num < 0)\n\t\tlogit(LOG_WARNING, \"Failed sending SSDP M-SEARCH\");\n}\n\nstatic void send_message(struct ifsock *ifs, char *type, struct sockaddr *sa)\n{\n\tint s;\n\tsize_t i, len, note = 0;\n\tssize_t num;\n\tchar host[NI_MAXHOST];\n\tchar buf[MAX_PKT_SIZE];\n\tstruct sockaddr dest;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\n\tgethostname(hostname, sizeof(hostname));\n\ts = getnameinfo((struct sockaddr *)&ifs->addr, sizeof(struct sockaddr_in), host, sizeof(host), NULL, 0, NI_NUMERICHOST);\n\tif (s) {\n\t\tlogit(LOG_WARNING, \"Failed getnameinfo(): %s\", gai_strerror(s));\n\t\treturn;\n\t}\n\n\tif (ifs->addr.sin_addr.s_addr == htonl(INADDR_ANY))\n\t\treturn;\n\tif (ifs->out == -1)\n\t\treturn;\n\n\tif (!strcmp(type, SSDP_ST_ALL))\n\t\ttype = NULL;\n\n\tmemset(buf, 0, sizeof(buf));\n\tif (sin)\n\t\tcompose_response(type, host, buf, sizeof(buf));\n\telse\n\t\tcompose_notify(type, host, buf, sizeof(buf));\n\n\tif (!sin) {\n\t\tnote = 1;\n\t\tcompose_addr((struct sockaddr_in *)&dest, MC_SSDP_GROUP, MC_SSDP_PORT);\n\t\tsin = (struct sockaddr_in *)&dest;\n\t}\n\n\tlogit(LOG_DEBUG, \"Sending %s from %s ...\", !note ? \"reply\" : \"notify\", host);\n\tnum = sendto(ifs->out, buf, strlen(buf), 0, sin, sizeof(struct sockaddr_in));\n\tif (num < 0)\n\t\tlogit(LOG_WARNING, \"Failed sending SSDP %s, type: %s: %s\", !note ? \"reply\" : \"notify\", type, strerror(errno));\n}\n\nstatic void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE + 1];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}\n\nstatic int multicast_init(void)\n{\n\tint sd;\n\tstruct sockaddr sa;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\tsd = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);\n\tif (sd < 0) {\n\t\tlogit(LOG_ERR, \"Failed opening multicast socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsin->sin_family = AF_INET;\n\tsin->sin_addr.s_addr = inet_addr(MC_SSDP_GROUP);\n\tsin->sin_port = htons(MC_SSDP_PORT);\n\n\tif (bind(sd, &sa, sizeof(*sin)) < 0) {\n\t\tclose(sd);\n\t\tlogit(LOG_ERR, \"Failed binding to %s:%d: %s\", inet_ntoa(sin->sin_addr), MC_SSDP_PORT, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tregister_socket(sd, -1, &sa, NULL, ssdp_recv);\n\n\treturn sd;\n}\n\nstatic int multicast_join(int sd, struct sockaddr *sa)\n{\n\tstruct ip_mreqn mreq;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\n\tmemset(&mreq, 0, sizeof(mreq));\n\tmreq.imr_address = sin->sin_addr;\n\tmreq.imr_multiaddr.s_addr = inet_addr(MC_SSDP_GROUP);\n        if (setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq))) {\n\t\tif (EADDRINUSE == errno)\n\t\t\treturn 0;\n\n\t\tlogit(LOG_ERR, \"Failed joining group %s: %s\", MC_SSDP_GROUP, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void mark(void)\n{\n\tstruct ifsock *ifs;\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tif (ifs->out != -1)\n\t\t\tifs->stale = 1;\n\t\telse\n\t\t\tifs->stale = 0;\n\t}\n}\n\nstatic int sweep(void)\n{\n\tint modified = 0;\n\tstruct ifsock *ifs, *tmp;\n\n\tLIST_FOREACH_SAFE(ifs, &il, link, tmp) {\n\t\tif (!ifs->stale)\n\t\t\tcontinue;\n\n\t\tmodified++;\n\t\tlogit(LOG_DEBUG, \"Removing stale ifs %s\", inet_ntoa(ifs->addr.sin_addr));\n\n\t\tLIST_REMOVE(ifs, link);\n\t\tclose(ifs->out);\n\t\tfree(ifs);\n\t}\n\n\treturn modified;\n}\n\nstatic int ssdp_init(int in, char *iflist[], size_t num)\n{\n\tint modified;\n\tsize_t i;\n\tstruct ifaddrs *ifaddrs, *ifa;\n\n\tlogit(LOG_INFO, \"Updating interfaces ...\");\n\n\tif (getifaddrs(&ifaddrs) < 0) {\n\t\tlogit(LOG_ERR, \"Failed getifaddrs(): %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\t/* Mark all outbound interfaces as stale */\n\tmark();\n\n\t/* First pass, clear stale marker from exact matches */\n\tfor (ifa = ifaddrs; ifa; ifa = ifa->ifa_next) {\n\t\tstruct ifsock *ifs;\n\n\t\t/* Do we already have it? */\n\t\tifs = find_iface(ifa->ifa_addr);\n\t\tif (ifs) {\n\t\t\tifs->stale = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t/* Clean out any stale interface addresses */\n\tmodified = sweep();\n\n\t/* Second pass, add new ones */\n\tfor (ifa = ifaddrs; ifa; ifa = ifa->ifa_next) {\n\t\tint sd;\n\n\t\t/* Interface filtering, optional command line argument */\n\t\tif (filter_iface(ifa->ifa_name, iflist, num)) {\n\t\t\tlogit(LOG_DEBUG, \"Skipping %s, not in iflist.\", ifa->ifa_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do we have another in the same subnet? */\n\t\tif (filter_addr(ifa->ifa_addr))\n\t\t\tcontinue;\n\n\t\tsd = open_socket(ifa->ifa_name, ifa->ifa_addr, MC_SSDP_PORT);\n\t\tif (sd < 0)\n\t\t\tcontinue;\n\n\t\tmulticast_join(in, ifa->ifa_addr);\n\n\t\tif (register_socket(in, sd, ifa->ifa_addr, ifa->ifa_netmask, ssdp_recv)) {\n\t\t\tclose(sd);\n\t\t\tbreak;\n\t\t}\n\t\tmodified++;\n\t}\n\n\tfreeifaddrs(ifaddrs);\n\n\treturn modified;\n}\n\nstatic void handle_message(int sd)\n{\n\tstruct ifsock *ifs;\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tif (ifs->in != sd)\n\t\t\tcontinue;\n\n\t\tif (ifs->cb)\n\t\t\tifs->cb(sd);\n\t}\n}\n\nstatic void wait_message(time_t tmo)\n{\n\tint num = 1, timeout;\n\tsize_t ifnum = 0;\n\tstruct pollfd pfd[MAX_NUM_IFACES];\n\tstruct ifsock *ifs;\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tif (ifs->out != -1)\n\t\t\tcontinue;\n\n\t\tpfd[ifnum].fd = ifs->in;\n\t\tpfd[ifnum].events = POLLIN | POLLHUP;\n\t\tifnum++;\n\t}\n\n\twhile (1) {\n\t\tsize_t i;\n\n\t\ttimeout = tmo - time(NULL);\n\t\tif (timeout < 0)\n\t\t\tbreak;\n\n\t\tnum = poll(pfd, ifnum, timeout * 1000);\n\t\tif (num < 0) {\n\t\t\tif (EINTR == errno)\n\t\t\t\tbreak;\n\n\t\t\terr(1, \"Unrecoverable error\");\n\t\t}\n\n\t\tif (num == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; num > 0 && i < ifnum; i++) {\n\t\t\tif (pfd[i].revents & POLLIN) {\n\t\t\t\thandle_message(pfd[i].fd);\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void announce(int mod)\n{\n\tstruct ifsock *ifs;\n\n\tlogit(LOG_INFO, \"Sending SSDP NOTIFY new:%d ...\", mod);\n\n\tLIST_FOREACH(ifs, &il, link) {\n\t\tsize_t i;\n\n\t\tif (mod && !ifs->mod)\n\t\t\tcontinue;\n\t\tifs->mod = 0;\n\n//\t\tsend_search(ifs, \"upnp:rootdevice\");\n\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t/* UUID sent in SSDP_ST_ALL, first announce */\n\t\t\tif (!strcmp(supported_types[i], uuid))\n\t\t\t\tcontinue;\n\n\t\t\tsend_message(ifs, supported_types[i], NULL);\n\t\t}\n\t}\n}\n\nstatic void lsb_init(void)\n{\n\tFILE *fp;\n\tchar *ptr;\n\tchar line[80];\n\tconst char *file = \"/etc/lsb-release\";\n\n\tfp = fopen(file, \"r\");\n\tif (!fp) {\n\tfallback:\n\t\tlogit(LOG_WARNING, \"No %s found on system, using built-in server string.\", file);\n\t\treturn;\n\t}\n\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tline[strlen(line) - 1] = 0;\n\n\t\tptr = strstr(line, \"DISTRIB_ID\");\n\t\tif (ptr && (ptr = strchr(ptr, '=')))\n\t\t\tos = strdup(++ptr);\n\n\t\tptr = strstr(line, \"DISTRIB_RELEASE\");\n\t\tif (ptr && (ptr = strchr(ptr, '=')))\n\t\t\tver = strdup(++ptr);\n\t}\n\tfclose(fp);\n\n\tif (os && ver)\n\t\tsnprintf(server_string, sizeof(server_string), \"%s/%s UPnP/1.0 %s/%s\",\n\t\t\t os, ver, PACKAGE_NAME, PACKAGE_VERSION);\n\telse\n\t\tgoto fallback;\n\n\tlogit(LOG_DEBUG, \"Server: %s\", server_string);\n}\n\n/* https://en.wikipedia.org/wiki/Universally_unique_identifier */\nstatic void uuidgen(void)\n{\n\tFILE *fp;\n\tchar buf[42];\n\tconst char *file = _PATH_VARDB PACKAGE_NAME \".cache\";\n\n\tfp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfp = fopen(file, \"w\");\n\t\tif (!fp)\n\t\t\tlogit(LOG_WARNING, \"Cannot create UUID cache, %s: %s\", file, strerror(errno));\n\n\tgenerate:\n\t\tsrand(time(NULL));\n\t\tsnprintf(buf, sizeof(buf), \"uuid:%8.8x-%4.4x-%4.4x-%4.4x-%6.6x%6.6x\",\n\t\t\t rand() & 0xFFFFFFFF,\n\t\t\t rand() & 0xFFFF,\n\t\t\t (rand() & 0x0FFF) | 0x4000, /* M  4 MSB version => version 4 */\n\t\t\t (rand() & 0x1FFF) | 0x8000, /* N: 3 MSB variant => variant 1 */\n\t\t\t rand() & 0xFFFFFF, rand() & 0xFFFFFF);\n\n\t\tif (fp) {\n\t\t\tlogit(LOG_DEBUG, \"Creating new UUID cache file, %s\", file);\n\t\t\tfprintf(fp, \"%s\\n\", buf);\n\t\t\tfclose(fp);\n\t\t}\n\t} else {\n\t\tif (!fgets(buf, sizeof(buf), fp)) {\n\t\t\tfclose(fp);\n\t\t\tgoto generate;\n\t\t}\n\t\tbuf[strlen(buf) - 1] = 0;\n\t\tfclose(fp);\n\t}\n\n\tstrcpy(uuid, buf);\n\tlogit(LOG_DEBUG, \"URN: %s\", uuid);\n}\n\nstatic void exit_handler(int signo)\n{\n\t(void)signo;\n\trunning = 0;\n}\n\nstatic void signal_init(void)\n{\n\tsignal(SIGTERM, exit_handler);\n\tsignal(SIGINT,  exit_handler);\n\tsignal(SIGHUP,  exit_handler);\n\tsignal(SIGQUIT, exit_handler);\n}\n\nstatic int usage(int code)\n{\n\tprintf(\"Usage: %s [-dhv] [-i SEC] [IFACE [IFACE ...]]\\n\"\n\t       \"\\n\"\n\t       \"    -d        Developer debug mode\\n\"\n\t       \"    -h        This help text\\n\"\n\t       \"    -i SEC    SSDP notify interval (30-900), default %d sec\\n\"\n\t       \"    -r SEC    Interface refresh interval (5-1800), default %d sec\\n\"\n\t       \"    -v        Show program version\\n\"\n\t       \"\\n\"\n\t       \"Bug report address: %-40s\\n\", PACKAGE_NAME, NOTIFY_INTERVAL, REFRESH_INTERVAL, PACKAGE_BUGREPORT);\n\n\treturn code;\n}\n\nint main(int argc, char *argv[])\n{\n\tint i, c, sd;\n\tint log_level = LOG_NOTICE;\n\tint log_opts = LOG_CONS | LOG_PID;\n\tint interval = NOTIFY_INTERVAL;\n\tint refresh = REFRESH_INTERVAL;\n\ttime_t now, rtmo = 0, itmo = 0;\n\n\twhile ((c = getopt(argc, argv, \"dhi:r:v\")) != EOF) {\n\t\tswitch (c) {\n\t\tcase 'd':\n\t\t\tdebug = 1;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\treturn usage(0);\n\n\t\tcase 'i':\n\t\t\tinterval = atoi(optarg);\n\t\t\tif (interval < 30 || interval > 900)\n\t\t\t\terrx(1, \"Invalid announcement interval (30-900).\");\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\trefresh = atoi(optarg);\n\t\t\tif (refresh < 5 || refresh > 1800)\n\t\t\t\terrx(1, \"Invalid refresh interval (5-1800).\");\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tputs(PACKAGE_VERSION);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsignal_init();\n\n        if (debug) {\n\t\tlog_level = LOG_DEBUG;\n                log_opts |= LOG_PERROR;\n\t}\n\n        openlog(PACKAGE_NAME, log_opts, LOG_DAEMON);\n        setlogmask(LOG_UPTO(log_level));\n\n\tuuidgen();\n\tlsb_init();\n\tweb_init();\n\n\tsd = multicast_init();\n\tif (sd < 0)\n\t\terr(1, \"Failed creating multicast socket\");\n\n\twhile (running) {\n\t\tnow = time(NULL);\n\n\t\tif (rtmo <= now) {\n\t\t\tif (ssdp_init(sd, &argv[optind], argc - optind) > 0)\n\t\t\t\tannounce(1);\n\t\t\trtmo = now + refresh;\n\t\t}\n\n\t\tif (itmo <= now) {\n\t\t\tannounce(0);\n\t\t\titmo = now + interval;\n\t\t}\n\n\t\twait_message(MIN(rtmo, itmo));\n\t}\n\n\tcloselog();\n\treturn close_socket();\n}\n\n/**\n * Local Variables:\n *  indent-tabs-mode: t\n *  c-file-style: \"linux\"\n * End:\n */\n"], "filenames": ["ssdpd.c"], "buggy_code_start_loc": [435], "buggy_code_end_loc": [442], "fixing_code_start_loc": [435], "fixing_code_end_loc": [439], "type": "CWE-193", "message": "SSDP Responder 1.x through 1.5 mishandles incoming network messages, leading to a stack-based buffer overflow by 1 byte. This results in a crash of the server, but only when strict stack checking is enabled. This is caused by an off-by-one error in ssdp_recv in ssdpd.c.", "other": {"cve": {"id": "CVE-2019-14323", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-28T13:15:10.783", "lastModified": "2020-12-16T18:55:56.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SSDP Responder 1.x through 1.5 mishandles incoming network messages, leading to a stack-based buffer overflow by 1 byte. This results in a crash of the server, but only when strict stack checking is enabled. This is caused by an off-by-one error in ssdp_recv in ssdpd.c."}, {"lang": "es", "value": "Responder de SSDP versiones 1.x hasta 1.5 maneja inapropiadamente los mensajes entrantes de la red, lo que conlleva a un desbordamiento de b\u00fafer basado en pila por 1 byte. Esto resulta en una bloqueo del servidor, pero solo cuando se habilita la comprobaci\u00f3n estricta de la pila. Esto es causado mediante un error por un paso en la funci\u00f3n ssdp_recv en el archivo ssdpd.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simple_service_discovery_protocol_responder_project:simple_service_discovery_protocol_responder:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0", "versionEndIncluding": "1.5", "matchCriteriaId": "FF328879-523C-4685-ACE7-5AC9E0E8CA63"}]}]}], "references": [{"url": "https://github.com/troglobit/ssdp-responder/commit/ce04b1f29a137198182f60bbb628d5ceb8171765", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/troglobit/ssdp-responder/issues/1", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/troglobit/ssdp-responder/commit/ce04b1f29a137198182f60bbb628d5ceb8171765"}}