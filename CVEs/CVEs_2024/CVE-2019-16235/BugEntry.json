{"buggy_code": ["namespace Xmpp.Xep.MessageCarbons {\n\nprivate const string NS_URI = \"urn:xmpp:carbons:2\";\n\npublic class Module : XmppStreamModule {\n    public static ModuleIdentity<Module> IDENTITY = new ModuleIdentity<Module>(NS_URI, \"0280_message_carbons_module\");\n\n    private ReceivedPipelineListener received_pipeline_listener = new ReceivedPipelineListener();\n\n    public void enable(XmppStream stream) {\n        Iq.Stanza iq = new Iq.Stanza.set(new StanzaNode.build(\"enable\", NS_URI).add_self_xmlns());\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq);\n    }\n\n    public void disable(XmppStream stream) {\n        Iq.Stanza iq = new Iq.Stanza.set(new StanzaNode.build(\"disable\", NS_URI).add_self_xmlns());\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq);\n    }\n\n    public override void attach(XmppStream stream) {\n        stream.stream_negotiated.connect(enable);\n        stream.get_module(MessageModule.IDENTITY).received_pipeline.connect(received_pipeline_listener);\n        stream.get_module(ServiceDiscovery.Module.IDENTITY).add_feature(stream, NS_URI);\n    }\n\n    public override void detach(XmppStream stream) {\n        stream.stream_negotiated.disconnect(enable);\n        stream.get_module(MessageModule.IDENTITY).received_pipeline.disconnect(received_pipeline_listener);\n    }\n\n    public override string get_ns() {\n        return NS_URI;\n    }\n\n    public override string get_id() {\n        return IDENTITY.id;\n    }\n}\n\npublic class ReceivedPipelineListener : StanzaListener<MessageStanza> {\n\n    private const string[] after_actions_const = {\"EXTRACT_MESSAGE_1\"};\n\n    public override string action_group { get { return \"EXTRACT_MESSAGE_2\"; } }\n    public override string[] after_actions { get { return after_actions_const; } }\n\n    public override async bool run(XmppStream stream, MessageStanza message) {\n        StanzaNode? received_node = message.stanza.get_subnode(\"received\", NS_URI);\n        StanzaNode? sent_node = received_node == null ? message.stanza.get_subnode(\"sent\", NS_URI) : null;\n        StanzaNode? carbons_node = received_node != null ? received_node : sent_node;\n        if (carbons_node != null) {\n            StanzaNode? forwarded_node = carbons_node.get_subnode(\"forwarded\", \"urn:xmpp:forward:0\");\n            if (forwarded_node != null) {\n                StanzaNode? message_node = forwarded_node.get_subnode(\"message\", Xmpp.NS_URI);\n                string? from_attribute = message_node.get_attribute(\"from\", Xmpp.NS_URI);\n                // Any forwarded copies received by a Carbons-enabled client MUST be from that user's bare JID; any copies that do not meet this requirement MUST be ignored.\n                if (from_attribute != null && from_attribute == stream.get_flag(Bind.Flag.IDENTITY).my_jid.bare_jid.to_string()) {\n                    return true;\n                }\n                if (received_node != null) {\n                    message.add_flag(new MessageFlag(MessageFlag.TYPE_RECEIVED));\n                } else if (sent_node != null) {\n                    message.add_flag(new MessageFlag(MessageFlag.TYPE_SENT));\n                }\n                message.stanza = message_node;\n                message.rerun_parsing = true;\n            }\n        }\n        return false;\n    }\n}\n\npublic class MessageFlag : Xmpp.MessageFlag {\n    public const string ID = \"message_carbons\";\n\n    public const string TYPE_RECEIVED = \"received\";\n    public const string TYPE_SENT = \"sent\";\n    private string type_;\n\n    public MessageFlag(string type) {\n        this.type_ = type;\n    }\n\n    public static MessageFlag? get_flag(MessageStanza message) {\n        return (MessageFlag) message.get_flag(NS_URI, ID);\n    }\n\n    public override string get_ns() {\n        return NS_URI;\n    }\n\n    public override string get_id() {\n        return ID;\n    }\n}\n\n}\n"], "fixing_code": ["namespace Xmpp.Xep.MessageCarbons {\n\nprivate const string NS_URI = \"urn:xmpp:carbons:2\";\n\npublic class Module : XmppStreamModule {\n    public static ModuleIdentity<Module> IDENTITY = new ModuleIdentity<Module>(NS_URI, \"0280_message_carbons_module\");\n\n    private ReceivedPipelineListener received_pipeline_listener = new ReceivedPipelineListener();\n\n    public void enable(XmppStream stream) {\n        Iq.Stanza iq = new Iq.Stanza.set(new StanzaNode.build(\"enable\", NS_URI).add_self_xmlns());\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq);\n    }\n\n    public void disable(XmppStream stream) {\n        Iq.Stanza iq = new Iq.Stanza.set(new StanzaNode.build(\"disable\", NS_URI).add_self_xmlns());\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq);\n    }\n\n    public override void attach(XmppStream stream) {\n        stream.stream_negotiated.connect(enable);\n        stream.get_module(MessageModule.IDENTITY).received_pipeline.connect(received_pipeline_listener);\n        stream.get_module(ServiceDiscovery.Module.IDENTITY).add_feature(stream, NS_URI);\n    }\n\n    public override void detach(XmppStream stream) {\n        stream.stream_negotiated.disconnect(enable);\n        stream.get_module(MessageModule.IDENTITY).received_pipeline.disconnect(received_pipeline_listener);\n    }\n\n    public override string get_ns() {\n        return NS_URI;\n    }\n\n    public override string get_id() {\n        return IDENTITY.id;\n    }\n}\n\npublic class ReceivedPipelineListener : StanzaListener<MessageStanza> {\n\n    private const string[] after_actions_const = {\"EXTRACT_MESSAGE_1\"};\n\n    public override string action_group { get { return \"EXTRACT_MESSAGE_2\"; } }\n    public override string[] after_actions { get { return after_actions_const; } }\n\n    public override async bool run(XmppStream stream, MessageStanza message) {\n        StanzaNode? received_node = message.stanza.get_subnode(\"received\", NS_URI);\n        StanzaNode? sent_node = received_node == null ? message.stanza.get_subnode(\"sent\", NS_URI) : null;\n        StanzaNode? carbons_node = received_node != null ? received_node : sent_node;\n        if (carbons_node != null) {\n            StanzaNode? forwarded_node = carbons_node.get_subnode(\"forwarded\", \"urn:xmpp:forward:0\");\n            if (forwarded_node != null) {\n                StanzaNode? message_node = forwarded_node.get_subnode(\"message\", Xmpp.NS_URI);\n                // Any forwarded copies received by a Carbons-enabled client MUST be from that user's bare JID; any copies that do not meet this requirement MUST be ignored.\n                if (!message.from.equals(stream.get_flag(Bind.Flag.IDENTITY).my_jid.bare_jid)) {\n                    warning(\"Received alleged carbon message from %s, ignoring\", message.from.to_string());\n                    return true;\n                }\n                if (received_node != null) {\n                    message.add_flag(new MessageFlag(MessageFlag.TYPE_RECEIVED));\n                } else if (sent_node != null) {\n                    message.add_flag(new MessageFlag(MessageFlag.TYPE_SENT));\n                }\n                message.stanza = message_node;\n                message.rerun_parsing = true;\n            }\n        }\n        return false;\n    }\n}\n\npublic class MessageFlag : Xmpp.MessageFlag {\n    public const string ID = \"message_carbons\";\n\n    public const string TYPE_RECEIVED = \"received\";\n    public const string TYPE_SENT = \"sent\";\n    private string type_;\n\n    public MessageFlag(string type) {\n        this.type_ = type;\n    }\n\n    public static MessageFlag? get_flag(MessageStanza message) {\n        return (MessageFlag) message.get_flag(NS_URI, ID);\n    }\n\n    public override string get_ns() {\n        return NS_URI;\n    }\n\n    public override string get_id() {\n        return ID;\n    }\n}\n\n}\n"], "filenames": ["xmpp-vala/src/module/xep/0280_message_carbons.vala"], "buggy_code_start_loc": [55], "buggy_code_end_loc": [58], "fixing_code_start_loc": [54], "fixing_code_end_loc": [58], "type": "CWE-346", "message": "Dino before 2019-09-10 does not properly check the source of a carbons message in module/xep/0280_message_carbons.vala.", "other": {"cve": {"id": "CVE-2019-16235", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-11T19:15:11.750", "lastModified": "2020-09-14T14:26:01.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dino before 2019-09-10 does not properly check the source of a carbons message in module/xep/0280_message_carbons.vala."}, {"lang": "es", "value": "Dino antes del 10-09-2019, no comprueba correctamente la fuente de un mensaje carbons en el archivo module/xep/0280_message_carbons.vala."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dino:dino:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.1.0", "matchCriteriaId": "01FE0CAC-943E-461D-93F3-734FFCE3BC79"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/09/12/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/dino/dino/commit/e84f2c49567e86d2a261ea264d65c4adc549c930", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gultsch.de/dino_multiple.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5TMGQ5Q6QMIFG4NVUWMOWW3GIPGWQZVF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WZBNQAOBWTIOKNO4PIYNX624ACGUXSXQ/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YUBM7GDZBB6MZZALDWYRAPNV6HJNLNMC/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Sep/31", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4306-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4524", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dino/dino/commit/e84f2c49567e86d2a261ea264d65c4adc549c930"}}