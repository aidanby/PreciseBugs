{"buggy_code": ["/* CAN driver for Geschwister Schneider USB/CAN devices\n * and bytewerk.org candleLight USB CAN interfaces.\n *\n * Copyright (C) 2013-2016 Geschwister Schneider Technologie-,\n * Entwicklungs- und Vertriebs UG (Haftungsbeschr\u00e4nkt).\n * Copyright (C) 2016 Hubert Denkmair\n *\n * Many thanks to all socketcan devs!\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published\n * by the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n */\n\n#include <linux/init.h>\n#include <linux/signal.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n/* Device specific constants */\n#define USB_GSUSB_1_VENDOR_ID      0x1d50\n#define USB_GSUSB_1_PRODUCT_ID     0x606f\n\n#define USB_CANDLELIGHT_VENDOR_ID  0x1209\n#define USB_CANDLELIGHT_PRODUCT_ID 0x2323\n\n#define GSUSB_ENDPOINT_IN          1\n#define GSUSB_ENDPOINT_OUT         2\n\n/* Device specific constants */\nenum gs_usb_breq {\n\tGS_USB_BREQ_HOST_FORMAT = 0,\n\tGS_USB_BREQ_BITTIMING,\n\tGS_USB_BREQ_MODE,\n\tGS_USB_BREQ_BERR,\n\tGS_USB_BREQ_BT_CONST,\n\tGS_USB_BREQ_DEVICE_CONFIG,\n\tGS_USB_BREQ_TIMESTAMP,\n\tGS_USB_BREQ_IDENTIFY,\n};\n\nenum gs_can_mode {\n\t/* reset a channel. turns it off */\n\tGS_CAN_MODE_RESET = 0,\n\t/* starts a channel */\n\tGS_CAN_MODE_START\n};\n\nenum gs_can_state {\n\tGS_CAN_STATE_ERROR_ACTIVE = 0,\n\tGS_CAN_STATE_ERROR_WARNING,\n\tGS_CAN_STATE_ERROR_PASSIVE,\n\tGS_CAN_STATE_BUS_OFF,\n\tGS_CAN_STATE_STOPPED,\n\tGS_CAN_STATE_SLEEPING\n};\n\nenum gs_can_identify_mode {\n\tGS_CAN_IDENTIFY_OFF = 0,\n\tGS_CAN_IDENTIFY_ON\n};\n\n/* data types passed between host and device */\nstruct gs_host_config {\n\tu32 byte_order;\n} __packed;\n/* All data exchanged between host and device is exchanged in host byte order,\n * thanks to the struct gs_host_config byte_order member, which is sent first\n * to indicate the desired byte order.\n */\n\nstruct gs_device_config {\n\tu8 reserved1;\n\tu8 reserved2;\n\tu8 reserved3;\n\tu8 icount;\n\tu32 sw_version;\n\tu32 hw_version;\n} __packed;\n\n#define GS_CAN_MODE_NORMAL               0\n#define GS_CAN_MODE_LISTEN_ONLY          BIT(0)\n#define GS_CAN_MODE_LOOP_BACK            BIT(1)\n#define GS_CAN_MODE_TRIPLE_SAMPLE        BIT(2)\n#define GS_CAN_MODE_ONE_SHOT             BIT(3)\n\nstruct gs_device_mode {\n\tu32 mode;\n\tu32 flags;\n} __packed;\n\nstruct gs_device_state {\n\tu32 state;\n\tu32 rxerr;\n\tu32 txerr;\n} __packed;\n\nstruct gs_device_bittiming {\n\tu32 prop_seg;\n\tu32 phase_seg1;\n\tu32 phase_seg2;\n\tu32 sjw;\n\tu32 brp;\n} __packed;\n\nstruct gs_identify_mode {\n\tu32 mode;\n} __packed;\n\n#define GS_CAN_FEATURE_LISTEN_ONLY      BIT(0)\n#define GS_CAN_FEATURE_LOOP_BACK        BIT(1)\n#define GS_CAN_FEATURE_TRIPLE_SAMPLE    BIT(2)\n#define GS_CAN_FEATURE_ONE_SHOT         BIT(3)\n#define GS_CAN_FEATURE_HW_TIMESTAMP     BIT(4)\n#define GS_CAN_FEATURE_IDENTIFY         BIT(5)\n\nstruct gs_device_bt_const {\n\tu32 feature;\n\tu32 fclk_can;\n\tu32 tseg1_min;\n\tu32 tseg1_max;\n\tu32 tseg2_min;\n\tu32 tseg2_max;\n\tu32 sjw_max;\n\tu32 brp_min;\n\tu32 brp_max;\n\tu32 brp_inc;\n} __packed;\n\n#define GS_CAN_FLAG_OVERFLOW 1\n\nstruct gs_host_frame {\n\tu32 echo_id;\n\tu32 can_id;\n\n\tu8 can_dlc;\n\tu8 channel;\n\tu8 flags;\n\tu8 reserved;\n\n\tu8 data[8];\n} __packed;\n/* The GS USB devices make use of the same flags and masks as in\n * linux/can.h and linux/can/error.h, and no additional mapping is necessary.\n */\n\n/* Only send a max of GS_MAX_TX_URBS frames per channel at a time. */\n#define GS_MAX_TX_URBS 10\n/* Only launch a max of GS_MAX_RX_URBS usb requests at a time. */\n#define GS_MAX_RX_URBS 30\n/* Maximum number of interfaces the driver supports per device.\n * Current hardware only supports 2 interfaces. The future may vary.\n */\n#define GS_MAX_INTF 2\n\nstruct gs_tx_context {\n\tstruct gs_can *dev;\n\tunsigned int echo_id;\n};\n\nstruct gs_can {\n\tstruct can_priv can; /* must be the first member */\n\n\tstruct gs_usb *parent;\n\n\tstruct net_device *netdev;\n\tstruct usb_device *udev;\n\tstruct usb_interface *iface;\n\n\tstruct can_bittiming_const bt_const;\n\tunsigned int channel;\t/* channel number */\n\n\t/* This lock prevents a race condition between xmit and receive. */\n\tspinlock_t tx_ctx_lock;\n\tstruct gs_tx_context tx_context[GS_MAX_TX_URBS];\n\n\tstruct usb_anchor tx_submitted;\n\tatomic_t active_tx_urbs;\n};\n\n/* usb interface struct */\nstruct gs_usb {\n\tstruct gs_can *canch[GS_MAX_INTF];\n\tstruct usb_anchor rx_submitted;\n\tatomic_t active_channels;\n\tstruct usb_device *udev;\n};\n\n/* 'allocate' a tx context.\n * returns a valid tx context or NULL if there is no space.\n */\nstatic struct gs_tx_context *gs_alloc_tx_context(struct gs_can *dev)\n{\n\tint i = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\n\tfor (; i < GS_MAX_TX_URBS; i++) {\n\t\tif (dev->tx_context[i].echo_id == GS_MAX_TX_URBS) {\n\t\t\tdev->tx_context[i].echo_id = i;\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[i];\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\treturn NULL;\n}\n\n/* releases a tx context\n */\nstatic void gs_free_tx_context(struct gs_tx_context *txc)\n{\n\ttxc->echo_id = GS_MAX_TX_URBS;\n}\n\n/* Get a tx context by id.\n */\nstatic struct gs_tx_context *gs_get_tx_context(struct gs_can *dev,\n\t\t\t\t\t       unsigned int id)\n{\n\tunsigned long flags;\n\n\tif (id < GS_MAX_TX_URBS) {\n\t\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\t\tif (dev->tx_context[id].echo_id == id) {\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[id];\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t}\n\treturn NULL;\n}\n\nstatic int gs_cmd_reset(struct gs_usb *gsusb, struct gs_can *gsdev)\n{\n\tstruct gs_device_mode *dm;\n\tstruct usb_interface *intf = gsdev->iface;\n\tint rc;\n\n\tdm = kzalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\tdm->mode = GS_CAN_MODE_RESET;\n\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     gsdev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\treturn rc;\n}\n\nstatic void gs_update_state(struct gs_can *dev, struct can_frame *cf)\n{\n\tstruct can_device_stats *can_stats = &dev->can.can_stats;\n\n\tif (cf->can_id & CAN_ERR_RESTARTED) {\n\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tcan_stats->restarts++;\n\t} else if (cf->can_id & CAN_ERR_BUSOFF) {\n\t\tdev->can.state = CAN_STATE_BUS_OFF;\n\t\tcan_stats->bus_off++;\n\t} else if (cf->can_id & CAN_ERR_CRTL) {\n\t\tif ((cf->data[1] & CAN_ERR_CRTL_TX_WARNING) ||\n\t\t    (cf->data[1] & CAN_ERR_CRTL_RX_WARNING)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_WARNING;\n\t\t\tcan_stats->error_warning++;\n\t\t} else if ((cf->data[1] & CAN_ERR_CRTL_TX_PASSIVE) ||\n\t\t\t   (cf->data[1] & CAN_ERR_CRTL_RX_PASSIVE)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\t\tcan_stats->error_passive++;\n\t\t} else {\n\t\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n}\n\nstatic void gs_usb_receive_bulk_callback(struct urb *urb)\n{\n\tstruct gs_usb *usbcan = urb->context;\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct net_device_stats *stats;\n\tstruct gs_host_frame *hf = urb->transfer_buffer;\n\tstruct gs_tx_context *txc;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(!usbcan);\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t/* do not resubmit aborted urbs. eg: when device goes down */\n\t\treturn;\n\t}\n\n\t/* device reports out of range channel id */\n\tif (hf->channel >= GS_MAX_INTF)\n\t\tgoto resubmit_urb;\n\n\tdev = usbcan->canch[hf->channel];\n\n\tnetdev = dev->netdev;\n\tstats = &netdev->stats;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (hf->echo_id == -1) { /* normal rx */\n\t\tskb = alloc_can_skb(dev->netdev, &cf);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tcf->can_id = hf->can_id;\n\n\t\tcf->can_dlc = get_can_dlc(hf->can_dlc);\n\t\tmemcpy(cf->data, hf->data, 8);\n\n\t\t/* ERROR frames tell us information about the controller */\n\t\tif (hf->can_id & CAN_ERR_FLAG)\n\t\t\tgs_update_state(dev, cf);\n\n\t\tnetdev->stats.rx_packets++;\n\t\tnetdev->stats.rx_bytes += hf->can_dlc;\n\n\t\tnetif_rx(skb);\n\t} else { /* echo_id == hf->echo_id */\n\t\tif (hf->echo_id >= GS_MAX_TX_URBS) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected out of range echo id %d\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += hf->can_dlc;\n\n\t\ttxc = gs_get_tx_context(dev, hf->echo_id);\n\n\t\t/* bad devices send bad echo_ids. */\n\t\tif (!txc) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected unused echo id %d\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tcan_get_echo_skb(netdev, hf->echo_id);\n\n\t\tgs_free_tx_context(txc);\n\n\t\tnetif_wake_queue(netdev);\n\t}\n\n\tif (hf->flags & GS_CAN_FLAG_OVERFLOW) {\n\t\tskb = alloc_can_err_skb(netdev, &cf);\n\t\tif (!skb)\n\t\t\tgoto resubmit_urb;\n\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->can_dlc = CAN_ERR_DLC;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t\tnetif_rx(skb);\n\t}\n\n resubmit_urb:\n\tusb_fill_bulk_urb(urb,\n\t\t\t  usbcan->udev,\n\t\t\t  usb_rcvbulkpipe(usbcan->udev, GSUSB_ENDPOINT_IN),\n\t\t\t  hf,\n\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t  usbcan\n\t\t\t  );\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t/* USB failure take down all interfaces */\n\tif (rc == -ENODEV) {\n\t\tfor (rc = 0; rc < GS_MAX_INTF; rc++) {\n\t\t\tif (usbcan->canch[rc])\n\t\t\t\tnetif_device_detach(usbcan->canch[rc]->netdev);\n\t\t}\n\t}\n}\n\nstatic int gs_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &dev->can.bittiming;\n\tstruct usb_interface *intf = dev->iface;\n\tint rc;\n\tstruct gs_device_bittiming *dbt;\n\n\tdbt = kmalloc(sizeof(*dbt), GFP_KERNEL);\n\tif (!dbt)\n\t\treturn -ENOMEM;\n\n\tdbt->prop_seg = bt->prop_seg;\n\tdbt->phase_seg1 = bt->phase_seg1;\n\tdbt->phase_seg2 = bt->phase_seg2;\n\tdbt->sjw = bt->sjw;\n\tdbt->brp = bt->brp;\n\n\t/* request bit timings */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_BITTIMING,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dbt,\n\t\t\t     sizeof(*dbt),\n\t\t\t     1000);\n\n\tkfree(dbt);\n\n\tif (rc < 0)\n\t\tdev_err(netdev->dev.parent, \"Couldn't set bittimings (err=%d)\",\n\t\t\trc);\n\n\treturn rc;\n}\n\nstatic void gs_usb_xmit_callback(struct urb *urb)\n{\n\tstruct gs_tx_context *txc = urb->context;\n\tstruct gs_can *dev = txc->dev;\n\tstruct net_device *netdev = dev->netdev;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"usb xmit fail %d\\n\", txc->echo_id);\n\n\tusb_free_coherent(urb->dev,\n\t\t\t  urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer,\n\t\t\t  urb->transfer_dma);\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (netif_queue_stopped(netdev))\n\t\tnetif_wake_queue(netdev);\n}\n\nstatic netdev_tx_t gs_can_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &dev->netdev->stats;\n\tstruct urb *urb;\n\tstruct gs_host_frame *hf;\n\tstruct can_frame *cf;\n\tint rc;\n\tunsigned int idx;\n\tstruct gs_tx_context *txc;\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* find an empty context to keep track of transmission */\n\ttxc = gs_alloc_tx_context(dev);\n\tif (!txc)\n\t\treturn NETDEV_TX_BUSY;\n\n\t/* create a URB, and a buffer for it */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem_urb;\n\n\thf = usb_alloc_coherent(dev->udev, sizeof(*hf), GFP_ATOMIC,\n\t\t\t\t&urb->transfer_dma);\n\tif (!hf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomem_hf;\n\t}\n\n\tidx = txc->echo_id;\n\n\tif (idx >= GS_MAX_TX_URBS) {\n\t\tnetdev_err(netdev, \"Invalid tx context %d\\n\", idx);\n\t\tgoto badidx;\n\t}\n\n\thf->echo_id = idx;\n\thf->channel = dev->channel;\n\n\tcf = (struct can_frame *)skb->data;\n\n\thf->can_id = cf->can_id;\n\thf->can_dlc = cf->can_dlc;\n\tmemcpy(hf->data, cf->data, cf->can_dlc);\n\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev, GSUSB_ENDPOINT_OUT),\n\t\t\t  hf,\n\t\t\t  sizeof(*hf),\n\t\t\t  gs_usb_xmit_callback,\n\t\t\t  txc);\n\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, idx);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(rc)) {\t\t\t/* usb send failed */\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tcan_free_echo_skb(netdev, idx);\n\t\tgs_free_tx_context(txc);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev,\n\t\t\t\t  sizeof(*hf),\n\t\t\t\t  hf,\n\t\t\t\t  urb->transfer_dma);\n\n\n\t\tif (rc == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_err(netdev, \"usb_submit failed (err=%d)\\n\", rc);\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= GS_MAX_TX_URBS)\n\t\t\tnetif_stop_queue(netdev);\n\t}\n\n\t/* let usb core take care of this urb */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\n badidx:\n\tusb_free_coherent(dev->udev,\n\t\t\t  sizeof(*hf),\n\t\t\t  hf,\n\t\t\t  urb->transfer_dma);\n nomem_hf:\n\tusb_free_urb(urb);\n\n nomem_urb:\n\tgs_free_tx_context(txc);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"No memory left for USB buffer\\n\");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tkfree(dm);\n\t\treturn rc;\n\t}\n\n\tkfree(dm);\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic int gs_can_close(struct net_device *netdev)\n{\n\tint rc;\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\n\tnetif_stop_queue(netdev);\n\n\t/* Stop polling */\n\tif (atomic_dec_and_test(&parent->active_channels))\n\t\tusb_kill_anchored_urbs(&parent->rx_submitted);\n\n\t/* Stop sending URBs */\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\t/* reset the device */\n\trc = gs_cmd_reset(parent, dev);\n\tif (rc < 0)\n\t\tnetdev_warn(netdev, \"Couldn't shutdown device (err=%d)\", rc);\n\n\t/* reset tx contexts */\n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\t/* close the netdev */\n\tclose_candev(netdev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops gs_usb_netdev_ops = {\n\t.ndo_open = gs_can_open,\n\t.ndo_stop = gs_can_close,\n\t.ndo_start_xmit = gs_can_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic int gs_usb_set_identify(struct net_device *netdev, bool do_identify)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_identify_mode imode;\n\tint rc;\n\n\tif (do_identify)\n\t\timode.mode = GS_CAN_IDENTIFY_ON;\n\telse\n\t\timode.mode = GS_CAN_IDENTIFY_OFF;\n\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface),\n\t\t\t\t\t     0),\n\t\t\t     GS_USB_BREQ_IDENTIFY,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     &imode,\n\t\t\t     sizeof(imode),\n\t\t\t     100);\n\n\treturn (rc > 0) ? 0 : rc;\n}\n\n/* blink LED's for finding the this interface */\nstatic int gs_usb_set_phys_id(struct net_device *dev,\n\t\t\t      enum ethtool_phys_id_state state)\n{\n\tint rc = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\trc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_ON);\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\trc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_OFF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic const struct ethtool_ops gs_usb_ethtool_ops = {\n\t.set_phys_id = gs_usb_set_phys_id,\n};\n\nstatic struct gs_can *gs_make_candev(unsigned int channel,\n\t\t\t\t     struct usb_interface *intf,\n\t\t\t\t     struct gs_device_config *dconf)\n{\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct gs_device_bt_const *bt_const;\n\n\tbt_const = kmalloc(sizeof(*bt_const), GFP_KERNEL);\n\tif (!bt_const)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* fetch bit timing constants */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_BT_CONST,\n\t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     channel,\n\t\t\t     0,\n\t\t\t     bt_const,\n\t\t\t     sizeof(*bt_const),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Couldn't get bit timing const for channel (err=%d)\\n\",\n\t\t\trc);\n\t\tkfree(bt_const);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t/* create netdev */\n\tnetdev = alloc_candev(sizeof(struct gs_can), GS_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't allocate candev\\n\");\n\t\tkfree(bt_const);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &gs_usb_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support full roundtrip echo */\n\n\t/* dev settup */\n\tstrcpy(dev->bt_const.name, \"gs_usb\");\n\tdev->bt_const.tseg1_min = bt_const->tseg1_min;\n\tdev->bt_const.tseg1_max = bt_const->tseg1_max;\n\tdev->bt_const.tseg2_min = bt_const->tseg2_min;\n\tdev->bt_const.tseg2_max = bt_const->tseg2_max;\n\tdev->bt_const.sjw_max = bt_const->sjw_max;\n\tdev->bt_const.brp_min = bt_const->brp_min;\n\tdev->bt_const.brp_max = bt_const->brp_max;\n\tdev->bt_const.brp_inc = bt_const->brp_inc;\n\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->iface = intf;\n\tdev->netdev = netdev;\n\tdev->channel = channel;\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\tspin_lock_init(&dev->tx_ctx_lock);\n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\t/* can settup */\n\tdev->can.state = CAN_STATE_STOPPED;\n\tdev->can.clock.freq = bt_const->fclk_can;\n\tdev->can.bittiming_const = &dev->bt_const;\n\tdev->can.do_set_bittiming = gs_usb_set_bittiming;\n\n\tdev->can.ctrlmode_supported = 0;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_LISTEN_ONLY)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_LOOP_BACK)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LOOPBACK;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_TRIPLE_SAMPLE)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_ONE_SHOT)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\tif (dconf->sw_version > 1)\n\t\tif (bt_const->feature & GS_CAN_FEATURE_IDENTIFY)\n\t\t\tnetdev->ethtool_ops = &gs_usb_ethtool_ops;\n\n\tkfree(bt_const);\n\n\trc = register_candev(dev->netdev);\n\tif (rc) {\n\t\tfree_candev(dev->netdev);\n\t\tdev_err(&intf->dev, \"Couldn't register candev (err=%d)\\n\", rc);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn dev;\n}\n\nstatic void gs_destroy_candev(struct gs_can *dev)\n{\n\tunregister_candev(dev->netdev);\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tfree_candev(dev->netdev);\n}\n\nstatic int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config hconf = {\n\t\t.byte_order = 0x0000beef,\n\t};\n\tstruct gs_device_config dconf;\n\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     &hconf,\n\t\t\t     sizeof(hconf),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\t/* read device config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     &dconf,\n\t\t\t     sizeof(dconf),\n\t\t\t     1000);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\ticount = dconf.icount + 1;\n\tdev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);\n\n\tif (icount > GS_MAX_INTF) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Driver cannot handle more that %d CAN interfaces\\n\",\n\t\t\tGS_MAX_INTF);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tatomic_set(&dev->active_channels, 0);\n\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\n\tfor (i = 0; i < icount; i++) {\n\t\tdev->canch[i] = gs_make_candev(i, intf, &dconf);\n\t\tif (IS_ERR_OR_NULL(dev->canch[i])) {\n\t\t\t/* save error code to return later */\n\t\t\trc = PTR_ERR(dev->canch[i]);\n\n\t\t\t/* on failure destroy previously created candevs */\n\t\t\ticount = i;\n\t\t\tfor (i = 0; i < icount; i++)\n\t\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\t\t\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\t\t\tkfree(dev);\n\t\t\treturn rc;\n\t\t}\n\t\tdev->canch[i]->parent = dev;\n\t}\n\n\treturn 0;\n}\n\nstatic void gs_usb_disconnect(struct usb_interface *intf)\n{\n\tunsigned i;\n\tstruct gs_usb *dev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\n\tif (!dev) {\n\t\tdev_err(&intf->dev, \"Disconnect (nodata)\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < GS_MAX_INTF; i++)\n\t\tif (dev->canch[i])\n\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\tkfree(dev);\n}\n\nstatic const struct usb_device_id gs_usb_table[] = {\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_GSUSB_1_VENDOR_ID,\n\t\t\t\t      USB_GSUSB_1_PRODUCT_ID, 0) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_CANDLELIGHT_VENDOR_ID,\n\t\t\t\t      USB_CANDLELIGHT_PRODUCT_ID, 0) },\n\t{} /* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, gs_usb_table);\n\nstatic struct usb_driver gs_usb_driver = {\n\t.name       = \"gs_usb\",\n\t.probe      = gs_usb_probe,\n\t.disconnect = gs_usb_disconnect,\n\t.id_table   = gs_usb_table,\n};\n\nmodule_usb_driver(gs_usb_driver);\n\nMODULE_AUTHOR(\"Maximilian Schneider <mws@schneidersoft.net>\");\nMODULE_DESCRIPTION(\n\"Socket CAN device driver for Geschwister Schneider Technologie-, \"\n\"Entwicklungs- und Vertriebs UG. USB2.0 to CAN interfaces\\n\"\n\"and bytewerk.org candleLight USB CAN interfaces.\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["/* CAN driver for Geschwister Schneider USB/CAN devices\n * and bytewerk.org candleLight USB CAN interfaces.\n *\n * Copyright (C) 2013-2016 Geschwister Schneider Technologie-,\n * Entwicklungs- und Vertriebs UG (Haftungsbeschr\u00e4nkt).\n * Copyright (C) 2016 Hubert Denkmair\n *\n * Many thanks to all socketcan devs!\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published\n * by the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n */\n\n#include <linux/init.h>\n#include <linux/signal.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n/* Device specific constants */\n#define USB_GSUSB_1_VENDOR_ID      0x1d50\n#define USB_GSUSB_1_PRODUCT_ID     0x606f\n\n#define USB_CANDLELIGHT_VENDOR_ID  0x1209\n#define USB_CANDLELIGHT_PRODUCT_ID 0x2323\n\n#define GSUSB_ENDPOINT_IN          1\n#define GSUSB_ENDPOINT_OUT         2\n\n/* Device specific constants */\nenum gs_usb_breq {\n\tGS_USB_BREQ_HOST_FORMAT = 0,\n\tGS_USB_BREQ_BITTIMING,\n\tGS_USB_BREQ_MODE,\n\tGS_USB_BREQ_BERR,\n\tGS_USB_BREQ_BT_CONST,\n\tGS_USB_BREQ_DEVICE_CONFIG,\n\tGS_USB_BREQ_TIMESTAMP,\n\tGS_USB_BREQ_IDENTIFY,\n};\n\nenum gs_can_mode {\n\t/* reset a channel. turns it off */\n\tGS_CAN_MODE_RESET = 0,\n\t/* starts a channel */\n\tGS_CAN_MODE_START\n};\n\nenum gs_can_state {\n\tGS_CAN_STATE_ERROR_ACTIVE = 0,\n\tGS_CAN_STATE_ERROR_WARNING,\n\tGS_CAN_STATE_ERROR_PASSIVE,\n\tGS_CAN_STATE_BUS_OFF,\n\tGS_CAN_STATE_STOPPED,\n\tGS_CAN_STATE_SLEEPING\n};\n\nenum gs_can_identify_mode {\n\tGS_CAN_IDENTIFY_OFF = 0,\n\tGS_CAN_IDENTIFY_ON\n};\n\n/* data types passed between host and device */\nstruct gs_host_config {\n\tu32 byte_order;\n} __packed;\n/* All data exchanged between host and device is exchanged in host byte order,\n * thanks to the struct gs_host_config byte_order member, which is sent first\n * to indicate the desired byte order.\n */\n\nstruct gs_device_config {\n\tu8 reserved1;\n\tu8 reserved2;\n\tu8 reserved3;\n\tu8 icount;\n\tu32 sw_version;\n\tu32 hw_version;\n} __packed;\n\n#define GS_CAN_MODE_NORMAL               0\n#define GS_CAN_MODE_LISTEN_ONLY          BIT(0)\n#define GS_CAN_MODE_LOOP_BACK            BIT(1)\n#define GS_CAN_MODE_TRIPLE_SAMPLE        BIT(2)\n#define GS_CAN_MODE_ONE_SHOT             BIT(3)\n\nstruct gs_device_mode {\n\tu32 mode;\n\tu32 flags;\n} __packed;\n\nstruct gs_device_state {\n\tu32 state;\n\tu32 rxerr;\n\tu32 txerr;\n} __packed;\n\nstruct gs_device_bittiming {\n\tu32 prop_seg;\n\tu32 phase_seg1;\n\tu32 phase_seg2;\n\tu32 sjw;\n\tu32 brp;\n} __packed;\n\nstruct gs_identify_mode {\n\tu32 mode;\n} __packed;\n\n#define GS_CAN_FEATURE_LISTEN_ONLY      BIT(0)\n#define GS_CAN_FEATURE_LOOP_BACK        BIT(1)\n#define GS_CAN_FEATURE_TRIPLE_SAMPLE    BIT(2)\n#define GS_CAN_FEATURE_ONE_SHOT         BIT(3)\n#define GS_CAN_FEATURE_HW_TIMESTAMP     BIT(4)\n#define GS_CAN_FEATURE_IDENTIFY         BIT(5)\n\nstruct gs_device_bt_const {\n\tu32 feature;\n\tu32 fclk_can;\n\tu32 tseg1_min;\n\tu32 tseg1_max;\n\tu32 tseg2_min;\n\tu32 tseg2_max;\n\tu32 sjw_max;\n\tu32 brp_min;\n\tu32 brp_max;\n\tu32 brp_inc;\n} __packed;\n\n#define GS_CAN_FLAG_OVERFLOW 1\n\nstruct gs_host_frame {\n\tu32 echo_id;\n\tu32 can_id;\n\n\tu8 can_dlc;\n\tu8 channel;\n\tu8 flags;\n\tu8 reserved;\n\n\tu8 data[8];\n} __packed;\n/* The GS USB devices make use of the same flags and masks as in\n * linux/can.h and linux/can/error.h, and no additional mapping is necessary.\n */\n\n/* Only send a max of GS_MAX_TX_URBS frames per channel at a time. */\n#define GS_MAX_TX_URBS 10\n/* Only launch a max of GS_MAX_RX_URBS usb requests at a time. */\n#define GS_MAX_RX_URBS 30\n/* Maximum number of interfaces the driver supports per device.\n * Current hardware only supports 2 interfaces. The future may vary.\n */\n#define GS_MAX_INTF 2\n\nstruct gs_tx_context {\n\tstruct gs_can *dev;\n\tunsigned int echo_id;\n};\n\nstruct gs_can {\n\tstruct can_priv can; /* must be the first member */\n\n\tstruct gs_usb *parent;\n\n\tstruct net_device *netdev;\n\tstruct usb_device *udev;\n\tstruct usb_interface *iface;\n\n\tstruct can_bittiming_const bt_const;\n\tunsigned int channel;\t/* channel number */\n\n\t/* This lock prevents a race condition between xmit and receive. */\n\tspinlock_t tx_ctx_lock;\n\tstruct gs_tx_context tx_context[GS_MAX_TX_URBS];\n\n\tstruct usb_anchor tx_submitted;\n\tatomic_t active_tx_urbs;\n};\n\n/* usb interface struct */\nstruct gs_usb {\n\tstruct gs_can *canch[GS_MAX_INTF];\n\tstruct usb_anchor rx_submitted;\n\tatomic_t active_channels;\n\tstruct usb_device *udev;\n};\n\n/* 'allocate' a tx context.\n * returns a valid tx context or NULL if there is no space.\n */\nstatic struct gs_tx_context *gs_alloc_tx_context(struct gs_can *dev)\n{\n\tint i = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\n\tfor (; i < GS_MAX_TX_URBS; i++) {\n\t\tif (dev->tx_context[i].echo_id == GS_MAX_TX_URBS) {\n\t\t\tdev->tx_context[i].echo_id = i;\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[i];\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\treturn NULL;\n}\n\n/* releases a tx context\n */\nstatic void gs_free_tx_context(struct gs_tx_context *txc)\n{\n\ttxc->echo_id = GS_MAX_TX_URBS;\n}\n\n/* Get a tx context by id.\n */\nstatic struct gs_tx_context *gs_get_tx_context(struct gs_can *dev,\n\t\t\t\t\t       unsigned int id)\n{\n\tunsigned long flags;\n\n\tif (id < GS_MAX_TX_URBS) {\n\t\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\t\tif (dev->tx_context[id].echo_id == id) {\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[id];\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t}\n\treturn NULL;\n}\n\nstatic int gs_cmd_reset(struct gs_usb *gsusb, struct gs_can *gsdev)\n{\n\tstruct gs_device_mode *dm;\n\tstruct usb_interface *intf = gsdev->iface;\n\tint rc;\n\n\tdm = kzalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\tdm->mode = GS_CAN_MODE_RESET;\n\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     gsdev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\treturn rc;\n}\n\nstatic void gs_update_state(struct gs_can *dev, struct can_frame *cf)\n{\n\tstruct can_device_stats *can_stats = &dev->can.can_stats;\n\n\tif (cf->can_id & CAN_ERR_RESTARTED) {\n\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tcan_stats->restarts++;\n\t} else if (cf->can_id & CAN_ERR_BUSOFF) {\n\t\tdev->can.state = CAN_STATE_BUS_OFF;\n\t\tcan_stats->bus_off++;\n\t} else if (cf->can_id & CAN_ERR_CRTL) {\n\t\tif ((cf->data[1] & CAN_ERR_CRTL_TX_WARNING) ||\n\t\t    (cf->data[1] & CAN_ERR_CRTL_RX_WARNING)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_WARNING;\n\t\t\tcan_stats->error_warning++;\n\t\t} else if ((cf->data[1] & CAN_ERR_CRTL_TX_PASSIVE) ||\n\t\t\t   (cf->data[1] & CAN_ERR_CRTL_RX_PASSIVE)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\t\tcan_stats->error_passive++;\n\t\t} else {\n\t\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n}\n\nstatic void gs_usb_receive_bulk_callback(struct urb *urb)\n{\n\tstruct gs_usb *usbcan = urb->context;\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct net_device_stats *stats;\n\tstruct gs_host_frame *hf = urb->transfer_buffer;\n\tstruct gs_tx_context *txc;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(!usbcan);\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t/* do not resubmit aborted urbs. eg: when device goes down */\n\t\treturn;\n\t}\n\n\t/* device reports out of range channel id */\n\tif (hf->channel >= GS_MAX_INTF)\n\t\tgoto resubmit_urb;\n\n\tdev = usbcan->canch[hf->channel];\n\n\tnetdev = dev->netdev;\n\tstats = &netdev->stats;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (hf->echo_id == -1) { /* normal rx */\n\t\tskb = alloc_can_skb(dev->netdev, &cf);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tcf->can_id = hf->can_id;\n\n\t\tcf->can_dlc = get_can_dlc(hf->can_dlc);\n\t\tmemcpy(cf->data, hf->data, 8);\n\n\t\t/* ERROR frames tell us information about the controller */\n\t\tif (hf->can_id & CAN_ERR_FLAG)\n\t\t\tgs_update_state(dev, cf);\n\n\t\tnetdev->stats.rx_packets++;\n\t\tnetdev->stats.rx_bytes += hf->can_dlc;\n\n\t\tnetif_rx(skb);\n\t} else { /* echo_id == hf->echo_id */\n\t\tif (hf->echo_id >= GS_MAX_TX_URBS) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected out of range echo id %d\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += hf->can_dlc;\n\n\t\ttxc = gs_get_tx_context(dev, hf->echo_id);\n\n\t\t/* bad devices send bad echo_ids. */\n\t\tif (!txc) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected unused echo id %d\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tcan_get_echo_skb(netdev, hf->echo_id);\n\n\t\tgs_free_tx_context(txc);\n\n\t\tnetif_wake_queue(netdev);\n\t}\n\n\tif (hf->flags & GS_CAN_FLAG_OVERFLOW) {\n\t\tskb = alloc_can_err_skb(netdev, &cf);\n\t\tif (!skb)\n\t\t\tgoto resubmit_urb;\n\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->can_dlc = CAN_ERR_DLC;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t\tnetif_rx(skb);\n\t}\n\n resubmit_urb:\n\tusb_fill_bulk_urb(urb,\n\t\t\t  usbcan->udev,\n\t\t\t  usb_rcvbulkpipe(usbcan->udev, GSUSB_ENDPOINT_IN),\n\t\t\t  hf,\n\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t  usbcan\n\t\t\t  );\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t/* USB failure take down all interfaces */\n\tif (rc == -ENODEV) {\n\t\tfor (rc = 0; rc < GS_MAX_INTF; rc++) {\n\t\t\tif (usbcan->canch[rc])\n\t\t\t\tnetif_device_detach(usbcan->canch[rc]->netdev);\n\t\t}\n\t}\n}\n\nstatic int gs_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &dev->can.bittiming;\n\tstruct usb_interface *intf = dev->iface;\n\tint rc;\n\tstruct gs_device_bittiming *dbt;\n\n\tdbt = kmalloc(sizeof(*dbt), GFP_KERNEL);\n\tif (!dbt)\n\t\treturn -ENOMEM;\n\n\tdbt->prop_seg = bt->prop_seg;\n\tdbt->phase_seg1 = bt->phase_seg1;\n\tdbt->phase_seg2 = bt->phase_seg2;\n\tdbt->sjw = bt->sjw;\n\tdbt->brp = bt->brp;\n\n\t/* request bit timings */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_BITTIMING,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dbt,\n\t\t\t     sizeof(*dbt),\n\t\t\t     1000);\n\n\tkfree(dbt);\n\n\tif (rc < 0)\n\t\tdev_err(netdev->dev.parent, \"Couldn't set bittimings (err=%d)\",\n\t\t\trc);\n\n\treturn rc;\n}\n\nstatic void gs_usb_xmit_callback(struct urb *urb)\n{\n\tstruct gs_tx_context *txc = urb->context;\n\tstruct gs_can *dev = txc->dev;\n\tstruct net_device *netdev = dev->netdev;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"usb xmit fail %d\\n\", txc->echo_id);\n\n\tusb_free_coherent(urb->dev,\n\t\t\t  urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer,\n\t\t\t  urb->transfer_dma);\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (netif_queue_stopped(netdev))\n\t\tnetif_wake_queue(netdev);\n}\n\nstatic netdev_tx_t gs_can_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &dev->netdev->stats;\n\tstruct urb *urb;\n\tstruct gs_host_frame *hf;\n\tstruct can_frame *cf;\n\tint rc;\n\tunsigned int idx;\n\tstruct gs_tx_context *txc;\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* find an empty context to keep track of transmission */\n\ttxc = gs_alloc_tx_context(dev);\n\tif (!txc)\n\t\treturn NETDEV_TX_BUSY;\n\n\t/* create a URB, and a buffer for it */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem_urb;\n\n\thf = usb_alloc_coherent(dev->udev, sizeof(*hf), GFP_ATOMIC,\n\t\t\t\t&urb->transfer_dma);\n\tif (!hf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomem_hf;\n\t}\n\n\tidx = txc->echo_id;\n\n\tif (idx >= GS_MAX_TX_URBS) {\n\t\tnetdev_err(netdev, \"Invalid tx context %d\\n\", idx);\n\t\tgoto badidx;\n\t}\n\n\thf->echo_id = idx;\n\thf->channel = dev->channel;\n\n\tcf = (struct can_frame *)skb->data;\n\n\thf->can_id = cf->can_id;\n\thf->can_dlc = cf->can_dlc;\n\tmemcpy(hf->data, cf->data, cf->can_dlc);\n\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev, GSUSB_ENDPOINT_OUT),\n\t\t\t  hf,\n\t\t\t  sizeof(*hf),\n\t\t\t  gs_usb_xmit_callback,\n\t\t\t  txc);\n\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, idx);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(rc)) {\t\t\t/* usb send failed */\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tcan_free_echo_skb(netdev, idx);\n\t\tgs_free_tx_context(txc);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev,\n\t\t\t\t  sizeof(*hf),\n\t\t\t\t  hf,\n\t\t\t\t  urb->transfer_dma);\n\n\n\t\tif (rc == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_err(netdev, \"usb_submit failed (err=%d)\\n\", rc);\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= GS_MAX_TX_URBS)\n\t\t\tnetif_stop_queue(netdev);\n\t}\n\n\t/* let usb core take care of this urb */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\n badidx:\n\tusb_free_coherent(dev->udev,\n\t\t\t  sizeof(*hf),\n\t\t\t  hf,\n\t\t\t  urb->transfer_dma);\n nomem_hf:\n\tusb_free_urb(urb);\n\n nomem_urb:\n\tgs_free_tx_context(txc);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"No memory left for USB buffer\\n\");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tkfree(dm);\n\t\treturn rc;\n\t}\n\n\tkfree(dm);\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic int gs_can_close(struct net_device *netdev)\n{\n\tint rc;\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\n\tnetif_stop_queue(netdev);\n\n\t/* Stop polling */\n\tif (atomic_dec_and_test(&parent->active_channels))\n\t\tusb_kill_anchored_urbs(&parent->rx_submitted);\n\n\t/* Stop sending URBs */\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\t/* reset the device */\n\trc = gs_cmd_reset(parent, dev);\n\tif (rc < 0)\n\t\tnetdev_warn(netdev, \"Couldn't shutdown device (err=%d)\", rc);\n\n\t/* reset tx contexts */\n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\t/* close the netdev */\n\tclose_candev(netdev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops gs_usb_netdev_ops = {\n\t.ndo_open = gs_can_open,\n\t.ndo_stop = gs_can_close,\n\t.ndo_start_xmit = gs_can_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic int gs_usb_set_identify(struct net_device *netdev, bool do_identify)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_identify_mode imode;\n\tint rc;\n\n\tif (do_identify)\n\t\timode.mode = GS_CAN_IDENTIFY_ON;\n\telse\n\t\timode.mode = GS_CAN_IDENTIFY_OFF;\n\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface),\n\t\t\t\t\t     0),\n\t\t\t     GS_USB_BREQ_IDENTIFY,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     &imode,\n\t\t\t     sizeof(imode),\n\t\t\t     100);\n\n\treturn (rc > 0) ? 0 : rc;\n}\n\n/* blink LED's for finding the this interface */\nstatic int gs_usb_set_phys_id(struct net_device *dev,\n\t\t\t      enum ethtool_phys_id_state state)\n{\n\tint rc = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\trc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_ON);\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\trc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_OFF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic const struct ethtool_ops gs_usb_ethtool_ops = {\n\t.set_phys_id = gs_usb_set_phys_id,\n};\n\nstatic struct gs_can *gs_make_candev(unsigned int channel,\n\t\t\t\t     struct usb_interface *intf,\n\t\t\t\t     struct gs_device_config *dconf)\n{\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct gs_device_bt_const *bt_const;\n\n\tbt_const = kmalloc(sizeof(*bt_const), GFP_KERNEL);\n\tif (!bt_const)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* fetch bit timing constants */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_BT_CONST,\n\t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     channel,\n\t\t\t     0,\n\t\t\t     bt_const,\n\t\t\t     sizeof(*bt_const),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Couldn't get bit timing const for channel (err=%d)\\n\",\n\t\t\trc);\n\t\tkfree(bt_const);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t/* create netdev */\n\tnetdev = alloc_candev(sizeof(struct gs_can), GS_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't allocate candev\\n\");\n\t\tkfree(bt_const);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &gs_usb_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support full roundtrip echo */\n\n\t/* dev settup */\n\tstrcpy(dev->bt_const.name, \"gs_usb\");\n\tdev->bt_const.tseg1_min = bt_const->tseg1_min;\n\tdev->bt_const.tseg1_max = bt_const->tseg1_max;\n\tdev->bt_const.tseg2_min = bt_const->tseg2_min;\n\tdev->bt_const.tseg2_max = bt_const->tseg2_max;\n\tdev->bt_const.sjw_max = bt_const->sjw_max;\n\tdev->bt_const.brp_min = bt_const->brp_min;\n\tdev->bt_const.brp_max = bt_const->brp_max;\n\tdev->bt_const.brp_inc = bt_const->brp_inc;\n\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->iface = intf;\n\tdev->netdev = netdev;\n\tdev->channel = channel;\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\tspin_lock_init(&dev->tx_ctx_lock);\n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\t/* can settup */\n\tdev->can.state = CAN_STATE_STOPPED;\n\tdev->can.clock.freq = bt_const->fclk_can;\n\tdev->can.bittiming_const = &dev->bt_const;\n\tdev->can.do_set_bittiming = gs_usb_set_bittiming;\n\n\tdev->can.ctrlmode_supported = 0;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_LISTEN_ONLY)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_LOOP_BACK)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LOOPBACK;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_TRIPLE_SAMPLE)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_ONE_SHOT)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\tif (dconf->sw_version > 1)\n\t\tif (bt_const->feature & GS_CAN_FEATURE_IDENTIFY)\n\t\t\tnetdev->ethtool_ops = &gs_usb_ethtool_ops;\n\n\tkfree(bt_const);\n\n\trc = register_candev(dev->netdev);\n\tif (rc) {\n\t\tfree_candev(dev->netdev);\n\t\tdev_err(&intf->dev, \"Couldn't register candev (err=%d)\\n\", rc);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn dev;\n}\n\nstatic void gs_destroy_candev(struct gs_can *dev)\n{\n\tunregister_candev(dev->netdev);\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tfree_candev(dev->netdev);\n}\n\nstatic int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config *hconf;\n\tstruct gs_device_config *dconf;\n\n\thconf = kmalloc(sizeof(*hconf), GFP_KERNEL);\n\tif (!hconf)\n\t\treturn -ENOMEM;\n\n\thconf->byte_order = 0x0000beef;\n\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     hconf,\n\t\t\t     sizeof(*hconf),\n\t\t\t     1000);\n\n\tkfree(hconf);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tdconf = kmalloc(sizeof(*dconf), GFP_KERNEL);\n\tif (!dconf)\n\t\treturn -ENOMEM;\n\n\t/* read device config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     dconf,\n\t\t\t     sizeof(*dconf),\n\t\t\t     1000);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",\n\t\t\trc);\n\t\tkfree(dconf);\n\t\treturn rc;\n\t}\n\n\ticount = dconf->icount + 1;\n\tdev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);\n\n\tif (icount > GS_MAX_INTF) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Driver cannot handle more that %d CAN interfaces\\n\",\n\t\t\tGS_MAX_INTF);\n\t\tkfree(dconf);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tkfree(dconf);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tatomic_set(&dev->active_channels, 0);\n\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\n\tfor (i = 0; i < icount; i++) {\n\t\tdev->canch[i] = gs_make_candev(i, intf, dconf);\n\t\tif (IS_ERR_OR_NULL(dev->canch[i])) {\n\t\t\t/* save error code to return later */\n\t\t\trc = PTR_ERR(dev->canch[i]);\n\n\t\t\t/* on failure destroy previously created candevs */\n\t\t\ticount = i;\n\t\t\tfor (i = 0; i < icount; i++)\n\t\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\t\t\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\t\t\tkfree(dconf);\n\t\t\tkfree(dev);\n\t\t\treturn rc;\n\t\t}\n\t\tdev->canch[i]->parent = dev;\n\t}\n\n\tkfree(dconf);\n\n\treturn 0;\n}\n\nstatic void gs_usb_disconnect(struct usb_interface *intf)\n{\n\tunsigned i;\n\tstruct gs_usb *dev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\n\tif (!dev) {\n\t\tdev_err(&intf->dev, \"Disconnect (nodata)\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < GS_MAX_INTF; i++)\n\t\tif (dev->canch[i])\n\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\tkfree(dev);\n}\n\nstatic const struct usb_device_id gs_usb_table[] = {\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_GSUSB_1_VENDOR_ID,\n\t\t\t\t      USB_GSUSB_1_PRODUCT_ID, 0) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_CANDLELIGHT_VENDOR_ID,\n\t\t\t\t      USB_CANDLELIGHT_PRODUCT_ID, 0) },\n\t{} /* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, gs_usb_table);\n\nstatic struct usb_driver gs_usb_driver = {\n\t.name       = \"gs_usb\",\n\t.probe      = gs_usb_probe,\n\t.disconnect = gs_usb_disconnect,\n\t.id_table   = gs_usb_table,\n};\n\nmodule_usb_driver(gs_usb_driver);\n\nMODULE_AUTHOR(\"Maximilian Schneider <mws@schneidersoft.net>\");\nMODULE_DESCRIPTION(\n\"Socket CAN device driver for Geschwister Schneider Technologie-, \"\n\"Entwicklungs- und Vertriebs UG. USB2.0 to CAN interfaces\\n\"\n\"and bytewerk.org candleLight USB CAN interfaces.\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["drivers/net/can/usb/gs_usb.c"], "buggy_code_start_loc": [911], "buggy_code_end_loc": [985], "fixing_code_start_loc": [911], "fixing_code_end_loc": [1004], "type": "CWE-119", "message": "drivers/net/can/usb/gs_usb.c in the Linux kernel 4.9.x and 4.10.x before 4.10.2 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-8066", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T05:59:00.397", "lastModified": "2017-04-27T18:30:39.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/net/can/usb/gs_usb.c in the Linux kernel 4.9.x and 4.10.x before 4.10.2 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "drivers/net/can/usb/gs_usb.c en el kernel de Linux 4.9.x y 4.10.x en versiones anteriores a 4.10.2 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, que permite a usuarios locales provocar una denegaci\u00f3n de servicio (bloqueo del sistema o corrupci\u00f3n de memoria) o posiblemente tiene otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para la lista de dispersi\u00f3n DMA."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "27B10B33-5F64-4039-8351-694A7AB6E4E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "686DF390-3DCA-4D64-9858-FF699FA21D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "D24EF446-2120-4F2F-9D84-F782BF1D85CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "DA879AFB-E995-458B-ABD2-87477376A70D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "719F2C9D-1897-480A-93CE-C2AC987B80AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "F1516D1D-261D-421C-83FF-05DD90DAEB50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "8A944C6C-C1BF-472D-8BC2-B112EEDF3BD5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "29F4F9E6-4EE0-43C4-9B72-03D773AF5719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "D249C5D2-9186-498C-9AF7-100162D856EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "783F5C9D-D179-4194-965E-F9A153EAE3B1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "79EC10DA-54C8-405F-B0AC-A0E8130B5AA2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.12:*:*:*:*:*:*:*", "matchCriteriaId": "7AD95130-C8F6-4372-BB45-15C664D4E941"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.13:*:*:*:*:*:*:*", "matchCriteriaId": "BBB9620C-F4B3-47D1-951F-33E8CD39D516"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.14:*:*:*:*:*:*:*", "matchCriteriaId": "99E1E52C-8A19-4D3D-B890-8A7DE0745E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.15:*:*:*:*:*:*:*", "matchCriteriaId": "341DB6BF-E05C-478B-86E7-4466B9A64745"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.16:*:*:*:*:*:*:*", "matchCriteriaId": "26B28AFB-C8D8-401F-A7A1-F47A66B74CD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.17:*:*:*:*:*:*:*", "matchCriteriaId": "70525107-9C8E-4694-B7F3-98E0FA401C0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.18:*:*:*:*:*:*:*", "matchCriteriaId": "E41C688F-5EE3-4C71-9A76-3A7E12769335"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.19:*:*:*:*:*:*:*", "matchCriteriaId": "C3B8B635-4125-4BB7-92FE-E5AEBBB3730A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10:*:*:*:*:*:*:*", "matchCriteriaId": "1DCB26E2-5F19-4F9C-9FF3-184EF7262D6D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "3B614F17-FC57-4689-B875-33C2915432CB"}]}]}], "references": [{"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.10.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/04/16/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97992", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c919a3069c775c1c876bec55e00b2305d5125caa", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/c919a3069c775c1c876bec55e00b2305d5125caa", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c919a3069c775c1c876bec55e00b2305d5125caa"}}