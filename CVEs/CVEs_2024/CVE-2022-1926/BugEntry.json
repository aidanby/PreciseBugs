{"buggy_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst _ = require('lodash')\nconst xss = require('xss')\nconst fs = require('fs')\nconst piexifjs = require('piexifjs')\n\nconst MAX_FIELD_TEXT_LENGTH = 255\nconst MAX_SHORT_FIELD_TEXT_LENGTH = 25\n\nmodule.exports.applyMaxTextLength = function (text) {\n  return text.toString().substring(0, MAX_FIELD_TEXT_LENGTH)\n}\n\nmodule.exports.applyMaxShortTextLength = function (text) {\n  return text.toString().substring(0, MAX_SHORT_FIELD_TEXT_LENGTH)\n}\n\nmodule.exports.sanitizeFieldPlainText = function (text) {\n  return xss(text, {\n    whileList: {},\n    stripIgnoreTag: true,\n    stripIgnoreTagBody: ['script']\n  })\n}\n\nmodule.exports.stripExifData = function (path) {\n  const imgData = fs.readFileSync(path).toString('binary')\n  const newImgData = piexifjs.remove(imgData)\n  fs.writeFileSync(path, newImgData, 'binary')\n}\n\nmodule.exports.sendToSelf = function (socket, method, data) {\n  socket.emit(method, data)\n}\n\nmodule.exports._sendToSelf = function (io, socketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id === socketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.sendToAllConnectedClients = function (io, method, data) {\n  io.sockets.emit(method, data)\n}\n\nmodule.exports.sendToAllClientsInRoom = function (io, room, method, data) {\n  io.sockets.in(room).emit(method, data)\n}\n\nmodule.exports.sendToUser = function (socketList, userList, username, method, data) {\n  let userOnline = null\n  _.forEach(userList, function (v, k) {\n    if (k.toLowerCase() === username.toLowerCase()) {\n      userOnline = v\n      return true\n    }\n  })\n\n  if (_.isNull(userOnline)) return true\n\n  _.forEach(userOnline.sockets, function (socket) {\n    const o = _.findKey(socketList, { id: socket })\n    const i = socketList[o]\n    if (_.isUndefined(i)) return true\n    i.emit(method, data)\n  })\n}\n\nmodule.exports.sendToAllExcept = function (io, exceptSocketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id !== exceptSocketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.disconnectAllClients = function (io) {\n  Object.keys(io.sockets.sockets).forEach(function (sock) {\n    io.sockets.sockets[sock].disconnect(true)\n  })\n}\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/21/19 2:04 AM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar mongoose = require('mongoose')\nvar _ = require('lodash')\n\nvar COLLECTION = 'messages'\n\nvar messageSchema = mongoose.Schema(\n  {\n    conversation: {\n      type: mongoose.Schema.Types.ObjectId,\n      required: true,\n      index: true\n    },\n    owner: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'accounts',\n      required: true,\n      index: true\n    },\n    body: { type: String, required: true }\n  },\n  { timestamps: true }\n)\n\nmessageSchema.statics.getFullConversation = function (convoId, callback) {\n  return this.model(COLLECTION)\n    .find({ conversation: convoId })\n    .select('createdAt body owner')\n    .sort('-createdAt')\n    .populate({\n      path: 'owner',\n      select: '_id username fullname email image lastOnline'\n    })\n    .exec(callback)\n}\n\nmessageSchema.statics.getConversation = function (convoId, callback) {\n  return this.model(COLLECTION)\n    .find({ conversation: convoId })\n    .select('createdAt body owner')\n    .sort('-createdAt')\n    .limit(25)\n    .populate({\n      path: 'owner',\n      select: '_id username fullname email image lastOnline'\n    })\n    .exec(callback)\n}\n\nmessageSchema.statics.getConversationWithObject = function (object, callback) {\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must by of type Object) - MessageSchema.GetUserWithObject()', null)\n  }\n\n  var self = this\n  var deletedAt = null\n\n  var limit = object.limit === null ? 25 : object.limit\n  var page = object.page === null ? 0 : object.page\n\n  if (object.requestingUser) {\n    var userMetaIdx = _.findIndex(object.userMeta, function (item) {\n      return item.userId.toString() === object.requestingUser._id.toString()\n    })\n    if (userMetaIdx !== -1 && object.userMeta[userMetaIdx].deletedAt) {\n      deletedAt = new Date(object.userMeta[userMetaIdx].deletedAt)\n    }\n  }\n\n  var q = self\n    .model(COLLECTION)\n    .find({})\n    .sort('-createdAt')\n    .skip(page * limit)\n    .populate({\n      path: 'owner',\n      select: '_id username fullname email image lastOnline'\n    })\n\n  if (limit !== -1) {\n    q.limit(limit)\n  }\n\n  if (object.cid !== null) {\n    q.where({ conversation: object.cid })\n  }\n\n  if (deletedAt) {\n    q.where({ createdAt: { $gte: deletedAt } })\n  }\n\n  return q.exec(callback)\n}\n\nmessageSchema.statics.getMostRecentMessage = function (convoId, callback) {\n  return this.model(COLLECTION)\n    .find({ conversation: convoId })\n    .sort('-createdAt')\n    .limit(1)\n    .populate({\n      path: 'owner',\n      select: '_id username fullname image lastOnline'\n    })\n    .exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, messageSchema)\n"], "fixing_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst _ = require('lodash')\nconst xss = require('xss')\nconst fs = require('fs')\nconst piexifjs = require('piexifjs')\n\nconst MAX_FIELD_TEXT_LENGTH = 255\nconst MAX_SHORT_FIELD_TEXT_LENGTH = 25\nconst MAX_EXTREME_TEXT_LENGTH = 2000\n\nmodule.exports.applyMaxTextLength = function (text) {\n  return text.toString().substring(0, MAX_FIELD_TEXT_LENGTH)\n}\n\nmodule.exports.applyMaxShortTextLength = function (text) {\n  return text.toString().substring(0, MAX_SHORT_FIELD_TEXT_LENGTH)\n}\n\nmodule.exports.applyExtremeTextLength = function (text) {\n  return text.toString().substring(0, MAX_EXTREME_TEXT_LENGTH)\n}\n\nmodule.exports.sanitizeFieldPlainText = function (text) {\n  return xss(text, {\n    whileList: {},\n    stripIgnoreTag: true,\n    stripIgnoreTagBody: ['script']\n  })\n}\n\nmodule.exports.stripExifData = function (path) {\n  const imgData = fs.readFileSync(path).toString('binary')\n  const newImgData = piexifjs.remove(imgData)\n  fs.writeFileSync(path, newImgData, 'binary')\n}\n\nmodule.exports.sendToSelf = function (socket, method, data) {\n  socket.emit(method, data)\n}\n\nmodule.exports._sendToSelf = function (io, socketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id === socketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.sendToAllConnectedClients = function (io, method, data) {\n  io.sockets.emit(method, data)\n}\n\nmodule.exports.sendToAllClientsInRoom = function (io, room, method, data) {\n  io.sockets.in(room).emit(method, data)\n}\n\nmodule.exports.sendToUser = function (socketList, userList, username, method, data) {\n  let userOnline = null\n  _.forEach(userList, function (v, k) {\n    if (k.toLowerCase() === username.toLowerCase()) {\n      userOnline = v\n      return true\n    }\n  })\n\n  if (_.isNull(userOnline)) return true\n\n  _.forEach(userOnline.sockets, function (socket) {\n    const o = _.findKey(socketList, { id: socket })\n    const i = socketList[o]\n    if (_.isUndefined(i)) return true\n    i.emit(method, data)\n  })\n}\n\nmodule.exports.sendToAllExcept = function (io, exceptSocketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id !== exceptSocketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.disconnectAllClients = function (io) {\n  Object.keys(io.sockets.sockets).forEach(function (sock) {\n    io.sockets.sockets[sock].disconnect(true)\n  })\n}\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/21/19 2:04 AM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst mongoose = require('mongoose')\nconst _ = require('lodash')\nconst utils = require('../../helpers/utils')\n\nconst COLLECTION = 'messages'\n\nconst messageSchema = mongoose.Schema(\n  {\n    conversation: {\n      type: mongoose.Schema.Types.ObjectId,\n      required: true,\n      index: true\n    },\n    owner: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'accounts',\n      required: true,\n      index: true\n    },\n    body: { type: String, required: true }\n  },\n  { timestamps: true }\n)\n\nmessageSchema.pre('save', function (next) {\n  this.body = utils.sanitizeFieldPlainText(utils.applyExtremeTextLength(this.body))\n\n  next()\n})\n\nmessageSchema.statics.getFullConversation = function (convoId, callback) {\n  return this.model(COLLECTION)\n    .find({ conversation: convoId })\n    .select('createdAt body owner')\n    .sort('-createdAt')\n    .populate({\n      path: 'owner',\n      select: '_id username fullname email image lastOnline'\n    })\n    .exec(callback)\n}\n\nmessageSchema.statics.getConversation = function (convoId, callback) {\n  return this.model(COLLECTION)\n    .find({ conversation: convoId })\n    .select('createdAt body owner')\n    .sort('-createdAt')\n    .limit(25)\n    .populate({\n      path: 'owner',\n      select: '_id username fullname email image lastOnline'\n    })\n    .exec(callback)\n}\n\nmessageSchema.statics.getConversationWithObject = function (object, callback) {\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must by of type Object) - MessageSchema.GetUserWithObject()', null)\n  }\n\n  const self = this\n  let deletedAt = null\n\n  const limit = object.limit === null ? 25 : object.limit\n  const page = object.page === null ? 0 : object.page\n\n  if (object.requestingUser) {\n    const userMetaIdx = _.findIndex(object.userMeta, function (item) {\n      return item.userId.toString() === object.requestingUser._id.toString()\n    })\n    if (userMetaIdx !== -1 && object.userMeta[userMetaIdx].deletedAt) {\n      deletedAt = new Date(object.userMeta[userMetaIdx].deletedAt)\n    }\n  }\n\n  const q = self\n    .model(COLLECTION)\n    .find({})\n    .sort('-createdAt')\n    .skip(page * limit)\n    .populate({\n      path: 'owner',\n      select: '_id username fullname email image lastOnline'\n    })\n\n  if (limit !== -1) {\n    q.limit(limit)\n  }\n\n  if (object.cid !== null) {\n    q.where({ conversation: object.cid })\n  }\n\n  if (deletedAt) {\n    q.where({ createdAt: { $gte: deletedAt } })\n  }\n\n  return q.exec(callback)\n}\n\nmessageSchema.statics.getMostRecentMessage = function (convoId, callback) {\n  return this.model(COLLECTION)\n    .find({ conversation: convoId })\n    .sort('-createdAt')\n    .limit(1)\n    .populate({\n      path: 'owner',\n      select: '_id username fullname image lastOnline'\n    })\n    .exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, messageSchema)\n"], "filenames": ["src/helpers/utils/index.js", "src/models/chat/message.js"], "buggy_code_start_loc": [21, 15], "buggy_code_end_loc": [28, 84], "fixing_code_start_loc": [22, 15], "fixing_code_end_loc": [34, 91], "type": "CWE-190", "message": "Integer Overflow or Wraparound in GitHub repository polonel/trudesk prior to 1.2.3.", "other": {"cve": {"id": "CVE-2022-1926", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-31T09:15:07.983", "lastModified": "2022-06-08T17:08:33.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer Overflow or Wraparound in GitHub repository polonel/trudesk prior to 1.2.3."}, {"lang": "es", "value": "Un Desbordamiento de enteros o Wraparound en el repositorio de GitHub polonel/trudesk versiones anteriores a 1.2.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:H/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trudesk_project:trudesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.3", "matchCriteriaId": "D498F5B4-C37B-4226-A1FF-580B69B2AB0E"}]}]}], "references": [{"url": "https://github.com/polonel/trudesk/commit/b7c15180b6d4e556ad05d0881eb72d8b2f1637a0", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/3fda8902-68ee-4734-86a3-9551ab17c893", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/polonel/trudesk/commit/b7c15180b6d4e556ad05d0881eb72d8b2f1637a0"}}