{"buggy_code": ["/*\n *\tIPv6 output functions\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/net/ipv4/ip_output.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *\tChanges:\n *\tA.N.Kuznetsov\t:\tairthmetics in fragmentation.\n *\t\t\t\textension headers are implemented.\n *\t\t\t\troute changes now work.\n *\t\t\t\tip6_forward does not confuse sniffers.\n *\t\t\t\tetc.\n *\n *      H. von Brand    :       Added missing #include <linux/string.h>\n *\tImran Patel\t: \tfrag id should be in NBO\n *      Kazunori MIYAZAWA @USAGI\n *\t\t\t:       add ip6_append_data and related functions\n *\t\t\t\tfor datagram xmit\n */\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/tcp.h>\n#include <linux/route.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/rawv6.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/checksum.h>\n#include <linux/mroute6.h>\n\nint __ip6_local_out(struct sk_buff *skb)\n{\n\tint len;\n\n\tlen = skb->len - sizeof(struct ipv6hdr);\n\tif (len > IPV6_MAXPLEN)\n\t\tlen = 0;\n\tipv6_hdr(skb)->payload_len = htons(len);\n\n\treturn nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,\n\t\t       skb_dst(skb)->dev, dst_output);\n}\n\nint ip6_local_out(struct sk_buff *skb)\n{\n\tint err;\n\n\terr = __ip6_local_out(skb);\n\tif (likely(err == 1))\n\t\terr = dst_output(skb);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_local_out);\n\nstatic int ip6_finish_output2(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *dev = dst->dev;\n\tstruct neighbour *neigh;\n\tstruct in6_addr *nexthop;\n\tint ret;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->dev = dev;\n\n\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr)) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\t\tif (!(dev->flags & IFF_LOOPBACK) && sk_mc_loop(skb->sk) &&\n\t\t    ((mroute6_socket(dev_net(dev), skb) &&\n\t\t     !(IP6CB(skb)->flags & IP6SKB_FORWARDED)) ||\n\t\t     ipv6_chk_mcast_addr(dev, &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t &ipv6_hdr(skb)->saddr))) {\n\t\t\tstruct sk_buff *newskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Do not check for IFF_ALLMULTI; multicast routing\n\t\t\t   is not supported in any case.\n\t\t\t */\n\t\t\tif (newskb)\n\t\t\t\tNF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t\t\tnewskb, NULL, newskb->dev,\n\t\t\t\t\tdev_loopback_xmit);\n\n\t\t\tif (ipv6_hdr(skb)->hop_limit == 0) {\n\t\t\t\tIP6_INC_STATS(dev_net(dev), idev,\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tIP6_UPD_PO_STATS(dev_net(dev), idev, IPSTATS_MIB_OUTMCAST,\n\t\t\t\tskb->len);\n\n\t\tif (IPV6_ADDR_MC_SCOPE(&ipv6_hdr(skb)->daddr) <=\n\t\t    IPV6_ADDR_SCOPE_NODELOCAL &&\n\t\t    !(dev->flags & IFF_LOOPBACK)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trcu_read_lock_bh();\n\tnexthop = rt6_nexthop((struct rt6_info *)dst, &ipv6_hdr(skb)->daddr);\n\tneigh = __ipv6_neigh_lookup_noref(dst->dev, nexthop);\n\tif (unlikely(!neigh))\n\t\tneigh = __neigh_create(&nd_tbl, nexthop, dst->dev, false);\n\tif (!IS_ERR(neigh)) {\n\t\tret = dst_neigh_output(dst, neigh, skb);\n\t\trcu_read_unlock_bh();\n\t\treturn ret;\n\t}\n\trcu_read_unlock_bh();\n\n\tIP6_INC_STATS_BH(dev_net(dst->dev),\n\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int ip6_finish_output(struct sk_buff *skb)\n{\n\tif ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||\n\t    dst_allfrag(skb_dst(skb)))\n\t\treturn ip6_fragment(skb, ip6_finish_output2);\n\telse\n\t\treturn ip6_finish_output2(skb);\n}\n\nint ip6_output(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb_dst(skb)->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\tif (unlikely(idev->cnf.disable_ipv6)) {\n\t\tIP6_INC_STATS(dev_net(dev), idev,\n\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\treturn NF_HOOK_COND(NFPROTO_IPV6, NF_INET_POST_ROUTING, skb, NULL, dev,\n\t\t\t    ip6_finish_output,\n\t\t\t    !(IP6CB(skb)->flags & IP6SKB_REROUTED));\n}\n\n/*\n *\txmit an sk_buff (used by TCP, SCTP and DCCP)\n */\n\nint ip6_xmit(struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,\n\t     struct ipv6_txoptions *opt, int tclass)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *first_hop = &fl6->daddr;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr;\n\tu8  proto = fl6->flowi6_proto;\n\tint seg_len = skb->len;\n\tint hlimit = -1;\n\tu32 mtu;\n\n\tif (opt) {\n\t\tunsigned int head_room;\n\n\t\t/* First: exthdrs may take lots of space (~8K for now)\n\t\t   MAX_HEADER is not enough.\n\t\t */\n\t\thead_room = opt->opt_nflen + opt->opt_flen;\n\t\tseg_len += head_room;\n\t\thead_room += sizeof(struct ipv6hdr) + LL_RESERVED_SPACE(dst->dev);\n\n\t\tif (skb_headroom(skb) < head_room) {\n\t\t\tstruct sk_buff *skb2 = skb_realloc_headroom(skb, head_room);\n\t\t\tif (skb2 == NULL) {\n\t\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t\tconsume_skb(skb);\n\t\t\tskb = skb2;\n\t\t\tskb_set_owner_w(skb, sk);\n\t\t}\n\t\tif (opt->opt_flen)\n\t\t\tipv6_push_frag_opts(skb, opt, &proto);\n\t\tif (opt->opt_nflen)\n\t\t\tipv6_push_nfrag_opts(skb, opt, &proto, &first_hop);\n\t}\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\t/*\n\t *\tFill in the IPv6 header\n\t */\n\tif (np)\n\t\thlimit = np->hop_limit;\n\tif (hlimit < 0)\n\t\thlimit = ip6_dst_hoplimit(dst);\n\n\tip6_flow_hdr(hdr, tclass, fl6->flowlabel);\n\n\thdr->payload_len = htons(seg_len);\n\thdr->nexthdr = proto;\n\thdr->hop_limit = hlimit;\n\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *first_hop;\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tmtu = dst_mtu(dst);\n\tif ((skb->len <= mtu) || skb->local_df || skb_is_gso(skb)) {\n\t\tIP6_UPD_PO_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_OUT, skb->len);\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,\n\t\t\t       dst->dev, dst_output);\n\t}\n\n\tskb->dev = dst->dev;\n\tipv6_local_error(sk, EMSGSIZE, fl6, mtu);\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn -EMSGSIZE;\n}\n\nEXPORT_SYMBOL(ip6_xmit);\n\nstatic int ip6_call_ra_chain(struct sk_buff *skb, int sel)\n{\n\tstruct ip6_ra_chain *ra;\n\tstruct sock *last = NULL;\n\n\tread_lock(&ip6_ra_lock);\n\tfor (ra = ip6_ra_chain; ra; ra = ra->next) {\n\t\tstruct sock *sk = ra->sk;\n\t\tif (sk && ra->sel == sel &&\n\t\t    (!sk->sk_bound_dev_if ||\n\t\t     sk->sk_bound_dev_if == skb->dev->ifindex)) {\n\t\t\tif (last) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\trawv6_rcv(last, skb2);\n\t\t\t}\n\t\t\tlast = sk;\n\t\t}\n\t}\n\n\tif (last) {\n\t\trawv6_rcv(last, skb);\n\t\tread_unlock(&ip6_ra_lock);\n\t\treturn 1;\n\t}\n\tread_unlock(&ip6_ra_lock);\n\treturn 0;\n}\n\nstatic int ip6_forward_proxy_check(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tu8 nexthdr = hdr->nexthdr;\n\t__be16 frag_off;\n\tint offset;\n\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\toffset = ipv6_skip_exthdr(skb, sizeof(*hdr), &nexthdr, &frag_off);\n\t\tif (offset < 0)\n\t\t\treturn 0;\n\t} else\n\t\toffset = sizeof(struct ipv6hdr);\n\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tstruct icmp6hdr *icmp6;\n\n\t\tif (!pskb_may_pull(skb, (skb_network_header(skb) +\n\t\t\t\t\t offset + 1 - skb->data)))\n\t\t\treturn 0;\n\n\t\ticmp6 = (struct icmp6hdr *)(skb_network_header(skb) + offset);\n\n\t\tswitch (icmp6->icmp6_type) {\n\t\tcase NDISC_ROUTER_SOLICITATION:\n\t\tcase NDISC_ROUTER_ADVERTISEMENT:\n\t\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\t\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\t\tcase NDISC_REDIRECT:\n\t\t\t/* For reaction involving unicast neighbor discovery\n\t\t\t * message destined to the proxied address, pass it to\n\t\t\t * input function.\n\t\t\t */\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * The proxying router can't forward traffic sent to a link-local\n\t * address, so signal the sender and discard the packet. This\n\t * behavior is clarified by the MIPv6 specification.\n\t */\n\tif (ipv6_addr_type(&hdr->daddr) & IPV6_ADDR_LINKLOCAL) {\n\t\tdst_link_failure(skb);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ip6_forward_finish(struct sk_buff *skb)\n{\n\treturn dst_output(skb);\n}\n\nint ip6_forward(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tu32 mtu;\n\n\tif (net->ipv6.devconf_all->forwarding == 0)\n\t\tgoto error;\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_FWD, skb)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto drop;\n\n\tskb_forward_csum(skb);\n\n\t/*\n\t *\tWe DO NOT make any processing on\n\t *\tRA packets, pushing them to user level AS IS\n\t *\twithout ane WARRANTY that application will be able\n\t *\tto interpret them. The reason is that we\n\t *\tcannot make anything clever here.\n\t *\n\t *\tWe are not end-node, so that if packet contains\n\t *\tAH/ESP, we cannot make anything.\n\t *\tDefragmentation also would be mistake, RA packets\n\t *\tcannot be fragmented, because there is no warranty\n\t *\tthat different fragments will go along one path. --ANK\n\t */\n\tif (unlikely(opt->flags & IP6SKB_ROUTERALERT)) {\n\t\tif (ip6_call_ra_chain(skb, ntohs(opt->ra)))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t *\tcheck and decrement ttl\n\t */\n\tif (hdr->hop_limit <= 1) {\n\t\t/* Force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);\n\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* XXX: idev->cnf.proxy_ndp? */\n\tif (net->ipv6.devconf_all->proxy_ndp &&\n\t    pneigh_lookup(&nd_tbl, net, &hdr->daddr, skb->dev, 0)) {\n\t\tint proxied = ip6_forward_proxy_check(skb);\n\t\tif (proxied > 0)\n\t\t\treturn ip6_input(skb);\n\t\telse if (proxied < 0) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\t      IPSTATS_MIB_INDISCARDS);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!xfrm6_route_forward(skb)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tdst = skb_dst(skb);\n\n\t/* IPv6 specs say nothing about it, but it is clear that we cannot\n\t   send redirects to source routed frames.\n\t   We don't send redirects to frames decapsulated from IPsec.\n\t */\n\tif (skb->dev == dst->dev && opt->srcrt == 0 && !skb_sec_path(skb)) {\n\t\tstruct in6_addr *target = NULL;\n\t\tstruct inet_peer *peer;\n\t\tstruct rt6_info *rt;\n\n\t\t/*\n\t\t *\tincoming and outgoing devices are the same\n\t\t *\tsend a redirect.\n\t\t */\n\n\t\trt = (struct rt6_info *) dst;\n\t\tif (rt->rt6i_flags & RTF_GATEWAY)\n\t\t\ttarget = &rt->rt6i_gateway;\n\t\telse\n\t\t\ttarget = &hdr->daddr;\n\n\t\tpeer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);\n\n\t\t/* Limit redirects both by destination (here)\n\t\t   and by source (inside ndisc_send_redirect)\n\t\t */\n\t\tif (inet_peer_xrlim_allow(peer, 1*HZ))\n\t\t\tndisc_send_redirect(skb, target);\n\t\tif (peer)\n\t\t\tinet_putpeer(peer);\n\t} else {\n\t\tint addrtype = ipv6_addr_type(&hdr->saddr);\n\n\t\t/* This check is security critical. */\n\t\tif (addrtype == IPV6_ADDR_ANY ||\n\t\t    addrtype & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LOOPBACK))\n\t\t\tgoto error;\n\t\tif (addrtype & IPV6_ADDR_LINKLOCAL) {\n\t\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH,\n\t\t\t\t    ICMPV6_NOT_NEIGHBOUR, 0);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tmtu = dst_mtu(dst);\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\n\tif ((!skb->local_df && skb->len > mtu && !skb_is_gso(skb)) ||\n\t    (IP6CB(skb)->frag_max_size && IP6CB(skb)->frag_max_size > mtu)) {\n\t\t/* Again, force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INTOOBIGERRORS);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (skb_cow(skb, dst->dev->hard_header_len)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTDISCARDS);\n\t\tgoto drop;\n\t}\n\n\thdr = ipv6_hdr(skb);\n\n\t/* Mangling hops number delayed to point after skb COW */\n\n\thdr->hop_limit--;\n\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTFORWDATAGRAMS);\n\tIP6_ADD_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTOCTETS, skb->len);\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD, skb, skb->dev, dst->dev,\n\t\t       ip6_forward_finish);\n\nerror:\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_INADDRERRORS);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic void ip6_copy_metadata(struct sk_buff *to, struct sk_buff *from)\n{\n\tto->pkt_type = from->pkt_type;\n\tto->priority = from->priority;\n\tto->protocol = from->protocol;\n\tskb_dst_drop(to);\n\tskb_dst_set(to, dst_clone(skb_dst(from)));\n\tto->dev = from->dev;\n\tto->mark = from->mark;\n\n#ifdef CONFIG_NET_SCHED\n\tto->tc_index = from->tc_index;\n#endif\n\tnf_copy(to, from);\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\tto->nf_trace = from->nf_trace;\n#endif\n\tskb_copy_secmark(to, from);\n}\n\nint ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))\n{\n\tstruct sk_buff *frag;\n\tstruct rt6_info *rt = (struct rt6_info*)skb_dst(skb);\n\tstruct ipv6_pinfo *np = skb->sk ? inet6_sk(skb->sk) : NULL;\n\tstruct ipv6hdr *tmp_hdr;\n\tstruct frag_hdr *fh;\n\tunsigned int mtu, hlen, left, len;\n\tint hroom, troom;\n\t__be32 frag_id = 0;\n\tint ptr, offset = 0, err=0;\n\tu8 *prevhdr, nexthdr = 0;\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\thlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\n\tmtu = ip6_skb_dst_mtu(skb);\n\n\t/* We must not fragment if the socket is set to force MTU discovery\n\t * or if the skb it not generated by a local socket.\n\t */\n\tif (unlikely(!skb->local_df && skb->len > mtu) ||\n\t\t     (IP6CB(skb)->frag_max_size &&\n\t\t      IP6CB(skb)->frag_max_size > mtu)) {\n\t\tif (skb->sk && dst_allfrag(skb_dst(skb)))\n\t\t\tsk_nocaps_add(skb->sk, NETIF_F_GSO_MASK);\n\n\t\tskb->dev = skb_dst(skb)->dev;\n\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (np && np->frag_size < mtu) {\n\t\tif (np->frag_size)\n\t\t\tmtu = np->frag_size;\n\t}\n\tmtu -= hlen + sizeof(struct frag_hdr);\n\n\tif (skb_has_frag_list(skb)) {\n\t\tint first_len = skb_pagelen(skb);\n\t\tstruct sk_buff *frag2;\n\n\t\tif (first_len - hlen > mtu ||\n\t\t    ((first_len - hlen) & 7) ||\n\t\t    skb_cloned(skb))\n\t\t\tgoto slow_path;\n\n\t\tskb_walk_frags(skb, frag) {\n\t\t\t/* Correct geometry. */\n\t\t\tif (frag->len > mtu ||\n\t\t\t    ((frag->len & 7) && frag->next) ||\n\t\t\t    skb_headroom(frag) < hlen)\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\t/* Partially cloned skb? */\n\t\t\tif (skb_shared(frag))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\tBUG_ON(frag->sk);\n\t\t\tif (skb->sk) {\n\t\t\t\tfrag->sk = skb->sk;\n\t\t\t\tfrag->destructor = sock_wfree;\n\t\t\t}\n\t\t\tskb->truesize -= frag->truesize;\n\t\t}\n\n\t\terr = 0;\n\t\toffset = 0;\n\t\tfrag = skb_shinfo(skb)->frag_list;\n\t\tskb_frag_list_init(skb);\n\t\t/* BUILD HEADER */\n\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\ttmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);\n\t\tif (!tmp_hdr) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t__skb_pull(skb, hlen);\n\t\tfh = (struct frag_hdr*)__skb_push(skb, sizeof(struct frag_hdr));\n\t\t__skb_push(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tmemcpy(skb_network_header(skb), tmp_hdr, hlen);\n\n\t\tipv6_select_ident(fh, rt);\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->frag_off = htons(IP6_MF);\n\t\tfrag_id = fh->identification;\n\n\t\tfirst_len = skb_pagelen(skb);\n\t\tskb->data_len = first_len - skb_headlen(skb);\n\t\tskb->len = first_len;\n\t\tipv6_hdr(skb)->payload_len = htons(first_len -\n\t\t\t\t\t\t   sizeof(struct ipv6hdr));\n\n\t\tdst_hold(&rt->dst);\n\n\t\tfor (;;) {\n\t\t\t/* Prepare header of the next frame,\n\t\t\t * before previous one went down. */\n\t\t\tif (frag) {\n\t\t\t\tfrag->ip_summed = CHECKSUM_NONE;\n\t\t\t\tskb_reset_transport_header(frag);\n\t\t\t\tfh = (struct frag_hdr*)__skb_push(frag, sizeof(struct frag_hdr));\n\t\t\t\t__skb_push(frag, hlen);\n\t\t\t\tskb_reset_network_header(frag);\n\t\t\t\tmemcpy(skb_network_header(frag), tmp_hdr,\n\t\t\t\t       hlen);\n\t\t\t\toffset += skb->len - hlen - sizeof(struct frag_hdr);\n\t\t\t\tfh->nexthdr = nexthdr;\n\t\t\t\tfh->reserved = 0;\n\t\t\t\tfh->frag_off = htons(offset);\n\t\t\t\tif (frag->next != NULL)\n\t\t\t\t\tfh->frag_off |= htons(IP6_MF);\n\t\t\t\tfh->identification = frag_id;\n\t\t\t\tipv6_hdr(frag)->payload_len =\n\t\t\t\t\t\thtons(frag->len -\n\t\t\t\t\t\t      sizeof(struct ipv6hdr));\n\t\t\t\tip6_copy_metadata(frag, skb);\n\t\t\t}\n\n\t\t\terr = output(skb);\n\t\t\tif(!err)\n\t\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\n\t\t\tif (err || !frag)\n\t\t\t\tbreak;\n\n\t\t\tskb = frag;\n\t\t\tfrag = skb->next;\n\t\t\tskb->next = NULL;\n\t\t}\n\n\t\tkfree(tmp_hdr);\n\n\t\tif (err == 0) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t      IPSTATS_MIB_FRAGOKS);\n\t\t\tip6_rt_put(rt);\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (frag) {\n\t\t\tskb = frag->next;\n\t\t\tkfree_skb(frag);\n\t\t\tfrag = skb;\n\t\t}\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\tip6_rt_put(rt);\n\t\treturn err;\n\nslow_path_clean:\n\t\tskb_walk_frags(skb, frag2) {\n\t\t\tif (frag2 == frag)\n\t\t\t\tbreak;\n\t\t\tfrag2->sk = NULL;\n\t\t\tfrag2->destructor = NULL;\n\t\t\tskb->truesize += frag2->truesize;\n\t\t}\n\t}\n\nslow_path:\n\tif ((skb->ip_summed == CHECKSUM_PARTIAL) &&\n\t    skb_checksum_help(skb))\n\t\tgoto fail;\n\n\tleft = skb->len - hlen;\t\t/* Space per frame */\n\tptr = hlen;\t\t\t/* Where to start from */\n\n\t/*\n\t *\tFragment the datagram.\n\t */\n\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\throom = LL_RESERVED_SPACE(rt->dst.dev);\n\ttroom = rt->dst.dev->needed_tailroom;\n\n\t/*\n\t *\tKeep copying data until we run out.\n\t */\n\twhile(left > 0)\t{\n\t\tlen = left;\n\t\t/* IF: it doesn't fit, use 'mtu' - the data space left */\n\t\tif (len > mtu)\n\t\t\tlen = mtu;\n\t\t/* IF: we are not sending up to and including the packet end\n\t\t   then align the next start on an eight byte boundary */\n\t\tif (len < left)\t{\n\t\t\tlen &= ~7;\n\t\t}\n\t\t/*\n\t\t *\tAllocate buffer.\n\t\t */\n\n\t\tif ((frag = alloc_skb(len + hlen + sizeof(struct frag_hdr) +\n\t\t\t\t      hroom + troom, GFP_ATOMIC)) == NULL) {\n\t\t\tNETDEBUG(KERN_INFO \"IPv6: frag: no memory for new fragment!\\n\");\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t *\tSet up data on packet\n\t\t */\n\n\t\tip6_copy_metadata(frag, skb);\n\t\tskb_reserve(frag, hroom);\n\t\tskb_put(frag, len + hlen + sizeof(struct frag_hdr));\n\t\tskb_reset_network_header(frag);\n\t\tfh = (struct frag_hdr *)(skb_network_header(frag) + hlen);\n\t\tfrag->transport_header = (frag->network_header + hlen +\n\t\t\t\t\t  sizeof(struct frag_hdr));\n\n\t\t/*\n\t\t *\tCharge the memory for the fragment to any owner\n\t\t *\tit might possess\n\t\t */\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(frag, skb->sk);\n\n\t\t/*\n\t\t *\tCopy the packet header into the new buffer.\n\t\t */\n\t\tskb_copy_from_linear_data(skb, skb_network_header(frag), hlen);\n\n\t\t/*\n\t\t *\tBuild fragment header.\n\t\t */\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tif (!frag_id) {\n\t\t\tipv6_select_ident(fh, rt);\n\t\t\tfrag_id = fh->identification;\n\t\t} else\n\t\t\tfh->identification = frag_id;\n\n\t\t/*\n\t\t *\tCopy a block of the IP datagram.\n\t\t */\n\t\tif (skb_copy_bits(skb, ptr, skb_transport_header(frag), len))\n\t\t\tBUG();\n\t\tleft -= len;\n\n\t\tfh->frag_off = htons(offset);\n\t\tif (left > 0)\n\t\t\tfh->frag_off |= htons(IP6_MF);\n\t\tipv6_hdr(frag)->payload_len = htons(frag->len -\n\t\t\t\t\t\t    sizeof(struct ipv6hdr));\n\n\t\tptr += len;\n\t\toffset += len;\n\n\t\t/*\n\t\t *\tPut this fragment into the sending queue.\n\t\t */\n\t\terr = output(frag);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\t}\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGOKS);\n\tconsume_skb(skb);\n\treturn err;\n\nfail:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic inline int ip6_rt_check(const struct rt6key *rt_key,\n\t\t\t       const struct in6_addr *fl_addr,\n\t\t\t       const struct in6_addr *addr_cache)\n{\n\treturn (rt_key->plen != 128 || !ipv6_addr_equal(fl_addr, &rt_key->addr)) &&\n\t\t(addr_cache == NULL || !ipv6_addr_equal(fl_addr, addr_cache));\n}\n\nstatic struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\n\tif (!dst)\n\t\tgoto out;\n\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.\n\t *    We do not want to save whole address now,\n\t *    (because main consumer of this service\n\t *    is tcp, which has not this problem),\n\t *    so that the last trick works only on connected\n\t *    sockets.\n\t * 2. oif also should be the same.\n\t */\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}\n\nstatic int ip6_dst_lookup_tail(struct sock *sk,\n\t\t\t       struct dst_entry **dst, struct flowi6 *fl6)\n{\n\tstruct net *net = sock_net(sk);\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tstruct neighbour *n;\n\tstruct rt6_info *rt;\n#endif\n\tint err;\n\n\tif (*dst == NULL)\n\t\t*dst = ip6_route_output(net, sk, fl6);\n\n\tif ((err = (*dst)->error))\n\t\tgoto out_err_release;\n\n\tif (ipv6_addr_any(&fl6->saddr)) {\n\t\tstruct rt6_info *rt = (struct rt6_info *) *dst;\n\t\terr = ip6_route_get_saddr(net, rt, &fl6->daddr,\n\t\t\t\t\t  sk ? inet6_sk(sk)->srcprefs : 0,\n\t\t\t\t\t  &fl6->saddr);\n\t\tif (err)\n\t\t\tgoto out_err_release;\n\t}\n\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t/*\n\t * Here if the dst entry we've looked up\n\t * has a neighbour entry that is in the INCOMPLETE\n\t * state and the src address from the flow is\n\t * marked as OPTIMISTIC, we release the found\n\t * dst entry and replace it instead with the\n\t * dst entry of the nexthop router\n\t */\n\trt = (struct rt6_info *) *dst;\n\trcu_read_lock_bh();\n\tn = __ipv6_neigh_lookup_noref(rt->dst.dev, rt6_nexthop(rt, &fl6->daddr));\n\terr = n && !(n->nud_state & NUD_VALID) ? -EINVAL : 0;\n\trcu_read_unlock_bh();\n\n\tif (err) {\n\t\tstruct inet6_ifaddr *ifp;\n\t\tstruct flowi6 fl_gw6;\n\t\tint redirect;\n\n\t\tifp = ipv6_get_ifaddr(net, &fl6->saddr,\n\t\t\t\t      (*dst)->dev, 1);\n\n\t\tredirect = (ifp && ifp->flags & IFA_F_OPTIMISTIC);\n\t\tif (ifp)\n\t\t\tin6_ifa_put(ifp);\n\n\t\tif (redirect) {\n\t\t\t/*\n\t\t\t * We need to get the dst entry for the\n\t\t\t * default router instead\n\t\t\t */\n\t\t\tdst_release(*dst);\n\t\t\tmemcpy(&fl_gw6, fl6, sizeof(struct flowi6));\n\t\t\tmemset(&fl_gw6.daddr, 0, sizeof(struct in6_addr));\n\t\t\t*dst = ip6_route_output(net, sk, &fl_gw6);\n\t\t\tif ((err = (*dst)->error))\n\t\t\t\tgoto out_err_release;\n\t\t}\n\t}\n#endif\n\n\treturn 0;\n\nout_err_release:\n\tif (err == -ENETUNREACH)\n\t\tIP6_INC_STATS_BH(net, NULL, IPSTATS_MIB_OUTNOROUTES);\n\tdst_release(*dst);\n\t*dst = NULL;\n\treturn err;\n}\n\n/**\n *\tip6_dst_lookup - perform route lookup on flow\n *\t@sk: socket which provides route info\n *\t@dst: pointer to dst_entry * for result\n *\t@fl6: flow to lookup\n *\n *\tThis function performs a route lookup on the given flow.\n *\n *\tIt returns zero on success, or a standard errno code on error.\n */\nint ip6_dst_lookup(struct sock *sk, struct dst_entry **dst, struct flowi6 *fl6)\n{\n\t*dst = NULL;\n\treturn ip6_dst_lookup_tail(sk, dst, fl6);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup);\n\n/**\n *\tip6_dst_lookup_flow - perform route lookup on flow with ipsec\n *\t@sk: socket which provides route info\n *\t@fl6: flow to lookup\n *\t@final_dst: final destination address for ipsec lookup\n *\t@can_sleep: we are in a sleepable context\n *\n *\tThis function performs a route lookup on the given flow.\n *\n *\tIt returns a valid dst pointer on success, or a pointer encoded\n *\terror code.\n */\nstruct dst_entry *ip6_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t      const struct in6_addr *final_dst,\n\t\t\t\t      bool can_sleep)\n{\n\tstruct dst_entry *dst = NULL;\n\tint err;\n\n\terr = ip6_dst_lookup_tail(sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (final_dst)\n\t\tfl6->daddr = *final_dst;\n\tif (can_sleep)\n\t\tfl6->flowi6_flags |= FLOWI_FLAG_CAN_SLEEP;\n\n\treturn xfrm_lookup(sock_net(sk), dst, flowi6_to_flowi(fl6), sk, 0);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup_flow);\n\n/**\n *\tip6_sk_dst_lookup_flow - perform socket cached route lookup on flow\n *\t@sk: socket which provides the dst cache and route info\n *\t@fl6: flow to lookup\n *\t@final_dst: final destination address for ipsec lookup\n *\t@can_sleep: we are in a sleepable context\n *\n *\tThis function performs a route lookup on the given flow with the\n *\tpossibility of using the cached route in the socket if it is valid.\n *\tIt will take the socket dst lock when operating on the dst cache.\n *\tAs a result, this function can only be used in process context.\n *\n *\tIt returns a valid dst pointer on success, or a pointer encoded\n *\terror code.\n */\nstruct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t\t const struct in6_addr *final_dst,\n\t\t\t\t\t bool can_sleep)\n{\n\tstruct dst_entry *dst = sk_dst_check(sk, inet6_sk(sk)->dst_cookie);\n\tint err;\n\n\tdst = ip6_sk_dst_check(sk, dst, fl6);\n\n\terr = ip6_dst_lookup_tail(sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (final_dst)\n\t\tfl6->daddr = *final_dst;\n\tif (can_sleep)\n\t\tfl6->flowi6_flags |= FLOWI_FLAG_CAN_SLEEP;\n\n\treturn xfrm_lookup(sock_net(sk), dst, flowi6_to_flowi(fl6), sk, 0);\n}\nEXPORT_SYMBOL_GPL(ip6_sk_dst_lookup_flow);\n\nstatic inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t}\n\n\terr = skb_append_datato_frags(sk,skb, getfrag, from,\n\t\t\t\t      (length - transhdrlen));\n\tif (!err) {\n\t\tstruct frag_hdr fhdr;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\n\t\treturn 0;\n\t}\n\t/* There is not enough support do UPD LSO,\n\t * so follow normal path\n\t */\n\tkfree_skb(skb);\n\n\treturn err;\n}\n\nstatic inline struct ipv6_opt_hdr *ip6_opt_dup(struct ipv6_opt_hdr *src,\n\t\t\t\t\t       gfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic inline struct ipv6_rt_hdr *ip6_rthdr_dup(struct ipv6_rt_hdr *src,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t/* first fragment, reserve header_len */\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * this fragment is not first, the headers\n\t\t\t * space is regarded as data space.\n\t\t\t */\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}\n\nint ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint mtu;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif (length > mtu) {\n\t\tint proto = sk->sk_protocol;\n\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_append_data);\n\nstatic void ip6_cork_release(struct inet_sock *inet, struct ipv6_pinfo *np)\n{\n\tif (np->cork.opt) {\n\t\tkfree(np->cork.opt->dst0opt);\n\t\tkfree(np->cork.opt->dst1opt);\n\t\tkfree(np->cork.opt->hopopt);\n\t\tkfree(np->cork.opt->srcrt);\n\t\tkfree(np->cork.opt);\n\t\tnp->cork.opt = NULL;\n\t}\n\n\tif (inet->cork.base.dst) {\n\t\tdst_release(inet->cork.base.dst);\n\t\tinet->cork.base.dst = NULL;\n\t\tinet->cork.base.flags &= ~IPCORK_ALLFRAG;\n\t}\n\tmemset(&inet->cork.fl, 0, sizeof(inet->cork.fl));\n}\n\nint ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb, *tmp_skb;\n\tstruct sk_buff **tail_skb;\n\tstruct in6_addr final_dst_buf, *final_dst = &final_dst_buf;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6hdr *hdr;\n\tstruct ipv6_txoptions *opt = np->cork.opt;\n\tstruct rt6_info *rt = (struct rt6_info *)inet->cork.base.dst;\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tunsigned char proto = fl6->flowi6_proto;\n\tint err = 0;\n\n\tif ((skb = __skb_dequeue(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\ttail_skb = &(skb_shinfo(skb)->frag_list);\n\n\t/* move skb->data to ip header from ext header */\n\tif (skb->data < skb_network_header(skb))\n\t\t__skb_pull(skb, skb_network_offset(skb));\n\twhile ((tmp_skb = __skb_dequeue(&sk->sk_write_queue)) != NULL) {\n\t\t__skb_pull(tmp_skb, skb_network_header_len(skb));\n\t\t*tail_skb = tmp_skb;\n\t\ttail_skb = &(tmp_skb->next);\n\t\tskb->len += tmp_skb->len;\n\t\tskb->data_len += tmp_skb->len;\n\t\tskb->truesize += tmp_skb->truesize;\n\t\ttmp_skb->destructor = NULL;\n\t\ttmp_skb->sk = NULL;\n\t}\n\n\t/* Allow local fragmentation. */\n\tif (np->pmtudisc < IPV6_PMTUDISC_DO)\n\t\tskb->local_df = 1;\n\n\t*final_dst = fl6->daddr;\n\t__skb_pull(skb, skb_network_header_len(skb));\n\tif (opt && opt->opt_flen)\n\t\tipv6_push_frag_opts(skb, opt, &proto);\n\tif (opt && opt->opt_nflen)\n\t\tipv6_push_nfrag_opts(skb, opt, &proto, &final_dst);\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\tip6_flow_hdr(hdr, np->cork.tclass, fl6->flowlabel);\n\thdr->hop_limit = np->cork.hop_limit;\n\thdr->nexthdr = proto;\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *final_dst;\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\tIP6_UPD_PO_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);\n\tif (proto == IPPROTO_ICMPV6) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\t\tICMP6MSGOUT_INC_STATS_BH(net, idev, icmp6_hdr(skb)->icmp6_type);\n\t\tICMP6_INC_STATS_BH(net, idev, ICMP6_MIB_OUTMSGS);\n\t}\n\n\terr = ip6_local_out(skb);\n\tif (err) {\n\t\tif (err > 0)\n\t\t\terr = net_xmit_errno(err);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\nout:\n\tip6_cork_release(inet, np);\n\treturn err;\nerror:\n\tIP6_INC_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(ip6_push_pending_frames);\n\nvoid ip6_flush_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue_tail(&sk->sk_write_queue)) != NULL) {\n\t\tif (skb_dst(skb))\n\t\t\tIP6_INC_STATS(sock_net(sk), ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb(skb);\n\t}\n\n\tip6_cork_release(inet_sk(sk), inet6_sk(sk));\n}\nEXPORT_SYMBOL_GPL(ip6_flush_pending_frames);\n"], "fixing_code": ["/*\n *\tIPv6 output functions\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/net/ipv4/ip_output.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *\tChanges:\n *\tA.N.Kuznetsov\t:\tairthmetics in fragmentation.\n *\t\t\t\textension headers are implemented.\n *\t\t\t\troute changes now work.\n *\t\t\t\tip6_forward does not confuse sniffers.\n *\t\t\t\tetc.\n *\n *      H. von Brand    :       Added missing #include <linux/string.h>\n *\tImran Patel\t: \tfrag id should be in NBO\n *      Kazunori MIYAZAWA @USAGI\n *\t\t\t:       add ip6_append_data and related functions\n *\t\t\t\tfor datagram xmit\n */\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/tcp.h>\n#include <linux/route.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/rawv6.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/checksum.h>\n#include <linux/mroute6.h>\n\nint __ip6_local_out(struct sk_buff *skb)\n{\n\tint len;\n\n\tlen = skb->len - sizeof(struct ipv6hdr);\n\tif (len > IPV6_MAXPLEN)\n\t\tlen = 0;\n\tipv6_hdr(skb)->payload_len = htons(len);\n\n\treturn nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,\n\t\t       skb_dst(skb)->dev, dst_output);\n}\n\nint ip6_local_out(struct sk_buff *skb)\n{\n\tint err;\n\n\terr = __ip6_local_out(skb);\n\tif (likely(err == 1))\n\t\terr = dst_output(skb);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_local_out);\n\nstatic int ip6_finish_output2(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *dev = dst->dev;\n\tstruct neighbour *neigh;\n\tstruct in6_addr *nexthop;\n\tint ret;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->dev = dev;\n\n\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr)) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\t\tif (!(dev->flags & IFF_LOOPBACK) && sk_mc_loop(skb->sk) &&\n\t\t    ((mroute6_socket(dev_net(dev), skb) &&\n\t\t     !(IP6CB(skb)->flags & IP6SKB_FORWARDED)) ||\n\t\t     ipv6_chk_mcast_addr(dev, &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t &ipv6_hdr(skb)->saddr))) {\n\t\t\tstruct sk_buff *newskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Do not check for IFF_ALLMULTI; multicast routing\n\t\t\t   is not supported in any case.\n\t\t\t */\n\t\t\tif (newskb)\n\t\t\t\tNF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t\t\tnewskb, NULL, newskb->dev,\n\t\t\t\t\tdev_loopback_xmit);\n\n\t\t\tif (ipv6_hdr(skb)->hop_limit == 0) {\n\t\t\t\tIP6_INC_STATS(dev_net(dev), idev,\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tIP6_UPD_PO_STATS(dev_net(dev), idev, IPSTATS_MIB_OUTMCAST,\n\t\t\t\tskb->len);\n\n\t\tif (IPV6_ADDR_MC_SCOPE(&ipv6_hdr(skb)->daddr) <=\n\t\t    IPV6_ADDR_SCOPE_NODELOCAL &&\n\t\t    !(dev->flags & IFF_LOOPBACK)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trcu_read_lock_bh();\n\tnexthop = rt6_nexthop((struct rt6_info *)dst, &ipv6_hdr(skb)->daddr);\n\tneigh = __ipv6_neigh_lookup_noref(dst->dev, nexthop);\n\tif (unlikely(!neigh))\n\t\tneigh = __neigh_create(&nd_tbl, nexthop, dst->dev, false);\n\tif (!IS_ERR(neigh)) {\n\t\tret = dst_neigh_output(dst, neigh, skb);\n\t\trcu_read_unlock_bh();\n\t\treturn ret;\n\t}\n\trcu_read_unlock_bh();\n\n\tIP6_INC_STATS_BH(dev_net(dst->dev),\n\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int ip6_finish_output(struct sk_buff *skb)\n{\n\tif ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||\n\t    dst_allfrag(skb_dst(skb)))\n\t\treturn ip6_fragment(skb, ip6_finish_output2);\n\telse\n\t\treturn ip6_finish_output2(skb);\n}\n\nint ip6_output(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb_dst(skb)->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\tif (unlikely(idev->cnf.disable_ipv6)) {\n\t\tIP6_INC_STATS(dev_net(dev), idev,\n\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\treturn NF_HOOK_COND(NFPROTO_IPV6, NF_INET_POST_ROUTING, skb, NULL, dev,\n\t\t\t    ip6_finish_output,\n\t\t\t    !(IP6CB(skb)->flags & IP6SKB_REROUTED));\n}\n\n/*\n *\txmit an sk_buff (used by TCP, SCTP and DCCP)\n */\n\nint ip6_xmit(struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,\n\t     struct ipv6_txoptions *opt, int tclass)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *first_hop = &fl6->daddr;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr;\n\tu8  proto = fl6->flowi6_proto;\n\tint seg_len = skb->len;\n\tint hlimit = -1;\n\tu32 mtu;\n\n\tif (opt) {\n\t\tunsigned int head_room;\n\n\t\t/* First: exthdrs may take lots of space (~8K for now)\n\t\t   MAX_HEADER is not enough.\n\t\t */\n\t\thead_room = opt->opt_nflen + opt->opt_flen;\n\t\tseg_len += head_room;\n\t\thead_room += sizeof(struct ipv6hdr) + LL_RESERVED_SPACE(dst->dev);\n\n\t\tif (skb_headroom(skb) < head_room) {\n\t\t\tstruct sk_buff *skb2 = skb_realloc_headroom(skb, head_room);\n\t\t\tif (skb2 == NULL) {\n\t\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t\tconsume_skb(skb);\n\t\t\tskb = skb2;\n\t\t\tskb_set_owner_w(skb, sk);\n\t\t}\n\t\tif (opt->opt_flen)\n\t\t\tipv6_push_frag_opts(skb, opt, &proto);\n\t\tif (opt->opt_nflen)\n\t\t\tipv6_push_nfrag_opts(skb, opt, &proto, &first_hop);\n\t}\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\t/*\n\t *\tFill in the IPv6 header\n\t */\n\tif (np)\n\t\thlimit = np->hop_limit;\n\tif (hlimit < 0)\n\t\thlimit = ip6_dst_hoplimit(dst);\n\n\tip6_flow_hdr(hdr, tclass, fl6->flowlabel);\n\n\thdr->payload_len = htons(seg_len);\n\thdr->nexthdr = proto;\n\thdr->hop_limit = hlimit;\n\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *first_hop;\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tmtu = dst_mtu(dst);\n\tif ((skb->len <= mtu) || skb->local_df || skb_is_gso(skb)) {\n\t\tIP6_UPD_PO_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_OUT, skb->len);\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,\n\t\t\t       dst->dev, dst_output);\n\t}\n\n\tskb->dev = dst->dev;\n\tipv6_local_error(sk, EMSGSIZE, fl6, mtu);\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn -EMSGSIZE;\n}\n\nEXPORT_SYMBOL(ip6_xmit);\n\nstatic int ip6_call_ra_chain(struct sk_buff *skb, int sel)\n{\n\tstruct ip6_ra_chain *ra;\n\tstruct sock *last = NULL;\n\n\tread_lock(&ip6_ra_lock);\n\tfor (ra = ip6_ra_chain; ra; ra = ra->next) {\n\t\tstruct sock *sk = ra->sk;\n\t\tif (sk && ra->sel == sel &&\n\t\t    (!sk->sk_bound_dev_if ||\n\t\t     sk->sk_bound_dev_if == skb->dev->ifindex)) {\n\t\t\tif (last) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\trawv6_rcv(last, skb2);\n\t\t\t}\n\t\t\tlast = sk;\n\t\t}\n\t}\n\n\tif (last) {\n\t\trawv6_rcv(last, skb);\n\t\tread_unlock(&ip6_ra_lock);\n\t\treturn 1;\n\t}\n\tread_unlock(&ip6_ra_lock);\n\treturn 0;\n}\n\nstatic int ip6_forward_proxy_check(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tu8 nexthdr = hdr->nexthdr;\n\t__be16 frag_off;\n\tint offset;\n\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\toffset = ipv6_skip_exthdr(skb, sizeof(*hdr), &nexthdr, &frag_off);\n\t\tif (offset < 0)\n\t\t\treturn 0;\n\t} else\n\t\toffset = sizeof(struct ipv6hdr);\n\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tstruct icmp6hdr *icmp6;\n\n\t\tif (!pskb_may_pull(skb, (skb_network_header(skb) +\n\t\t\t\t\t offset + 1 - skb->data)))\n\t\t\treturn 0;\n\n\t\ticmp6 = (struct icmp6hdr *)(skb_network_header(skb) + offset);\n\n\t\tswitch (icmp6->icmp6_type) {\n\t\tcase NDISC_ROUTER_SOLICITATION:\n\t\tcase NDISC_ROUTER_ADVERTISEMENT:\n\t\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\t\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\t\tcase NDISC_REDIRECT:\n\t\t\t/* For reaction involving unicast neighbor discovery\n\t\t\t * message destined to the proxied address, pass it to\n\t\t\t * input function.\n\t\t\t */\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * The proxying router can't forward traffic sent to a link-local\n\t * address, so signal the sender and discard the packet. This\n\t * behavior is clarified by the MIPv6 specification.\n\t */\n\tif (ipv6_addr_type(&hdr->daddr) & IPV6_ADDR_LINKLOCAL) {\n\t\tdst_link_failure(skb);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ip6_forward_finish(struct sk_buff *skb)\n{\n\treturn dst_output(skb);\n}\n\nint ip6_forward(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tu32 mtu;\n\n\tif (net->ipv6.devconf_all->forwarding == 0)\n\t\tgoto error;\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_FWD, skb)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto drop;\n\n\tskb_forward_csum(skb);\n\n\t/*\n\t *\tWe DO NOT make any processing on\n\t *\tRA packets, pushing them to user level AS IS\n\t *\twithout ane WARRANTY that application will be able\n\t *\tto interpret them. The reason is that we\n\t *\tcannot make anything clever here.\n\t *\n\t *\tWe are not end-node, so that if packet contains\n\t *\tAH/ESP, we cannot make anything.\n\t *\tDefragmentation also would be mistake, RA packets\n\t *\tcannot be fragmented, because there is no warranty\n\t *\tthat different fragments will go along one path. --ANK\n\t */\n\tif (unlikely(opt->flags & IP6SKB_ROUTERALERT)) {\n\t\tif (ip6_call_ra_chain(skb, ntohs(opt->ra)))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t *\tcheck and decrement ttl\n\t */\n\tif (hdr->hop_limit <= 1) {\n\t\t/* Force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);\n\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* XXX: idev->cnf.proxy_ndp? */\n\tif (net->ipv6.devconf_all->proxy_ndp &&\n\t    pneigh_lookup(&nd_tbl, net, &hdr->daddr, skb->dev, 0)) {\n\t\tint proxied = ip6_forward_proxy_check(skb);\n\t\tif (proxied > 0)\n\t\t\treturn ip6_input(skb);\n\t\telse if (proxied < 0) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\t      IPSTATS_MIB_INDISCARDS);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!xfrm6_route_forward(skb)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tdst = skb_dst(skb);\n\n\t/* IPv6 specs say nothing about it, but it is clear that we cannot\n\t   send redirects to source routed frames.\n\t   We don't send redirects to frames decapsulated from IPsec.\n\t */\n\tif (skb->dev == dst->dev && opt->srcrt == 0 && !skb_sec_path(skb)) {\n\t\tstruct in6_addr *target = NULL;\n\t\tstruct inet_peer *peer;\n\t\tstruct rt6_info *rt;\n\n\t\t/*\n\t\t *\tincoming and outgoing devices are the same\n\t\t *\tsend a redirect.\n\t\t */\n\n\t\trt = (struct rt6_info *) dst;\n\t\tif (rt->rt6i_flags & RTF_GATEWAY)\n\t\t\ttarget = &rt->rt6i_gateway;\n\t\telse\n\t\t\ttarget = &hdr->daddr;\n\n\t\tpeer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);\n\n\t\t/* Limit redirects both by destination (here)\n\t\t   and by source (inside ndisc_send_redirect)\n\t\t */\n\t\tif (inet_peer_xrlim_allow(peer, 1*HZ))\n\t\t\tndisc_send_redirect(skb, target);\n\t\tif (peer)\n\t\t\tinet_putpeer(peer);\n\t} else {\n\t\tint addrtype = ipv6_addr_type(&hdr->saddr);\n\n\t\t/* This check is security critical. */\n\t\tif (addrtype == IPV6_ADDR_ANY ||\n\t\t    addrtype & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LOOPBACK))\n\t\t\tgoto error;\n\t\tif (addrtype & IPV6_ADDR_LINKLOCAL) {\n\t\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH,\n\t\t\t\t    ICMPV6_NOT_NEIGHBOUR, 0);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tmtu = dst_mtu(dst);\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\n\tif ((!skb->local_df && skb->len > mtu && !skb_is_gso(skb)) ||\n\t    (IP6CB(skb)->frag_max_size && IP6CB(skb)->frag_max_size > mtu)) {\n\t\t/* Again, force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INTOOBIGERRORS);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (skb_cow(skb, dst->dev->hard_header_len)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTDISCARDS);\n\t\tgoto drop;\n\t}\n\n\thdr = ipv6_hdr(skb);\n\n\t/* Mangling hops number delayed to point after skb COW */\n\n\thdr->hop_limit--;\n\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTFORWDATAGRAMS);\n\tIP6_ADD_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTOCTETS, skb->len);\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD, skb, skb->dev, dst->dev,\n\t\t       ip6_forward_finish);\n\nerror:\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_INADDRERRORS);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic void ip6_copy_metadata(struct sk_buff *to, struct sk_buff *from)\n{\n\tto->pkt_type = from->pkt_type;\n\tto->priority = from->priority;\n\tto->protocol = from->protocol;\n\tskb_dst_drop(to);\n\tskb_dst_set(to, dst_clone(skb_dst(from)));\n\tto->dev = from->dev;\n\tto->mark = from->mark;\n\n#ifdef CONFIG_NET_SCHED\n\tto->tc_index = from->tc_index;\n#endif\n\tnf_copy(to, from);\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\tto->nf_trace = from->nf_trace;\n#endif\n\tskb_copy_secmark(to, from);\n}\n\nint ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))\n{\n\tstruct sk_buff *frag;\n\tstruct rt6_info *rt = (struct rt6_info*)skb_dst(skb);\n\tstruct ipv6_pinfo *np = skb->sk ? inet6_sk(skb->sk) : NULL;\n\tstruct ipv6hdr *tmp_hdr;\n\tstruct frag_hdr *fh;\n\tunsigned int mtu, hlen, left, len;\n\tint hroom, troom;\n\t__be32 frag_id = 0;\n\tint ptr, offset = 0, err=0;\n\tu8 *prevhdr, nexthdr = 0;\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\thlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\n\tmtu = ip6_skb_dst_mtu(skb);\n\n\t/* We must not fragment if the socket is set to force MTU discovery\n\t * or if the skb it not generated by a local socket.\n\t */\n\tif (unlikely(!skb->local_df && skb->len > mtu) ||\n\t\t     (IP6CB(skb)->frag_max_size &&\n\t\t      IP6CB(skb)->frag_max_size > mtu)) {\n\t\tif (skb->sk && dst_allfrag(skb_dst(skb)))\n\t\t\tsk_nocaps_add(skb->sk, NETIF_F_GSO_MASK);\n\n\t\tskb->dev = skb_dst(skb)->dev;\n\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (np && np->frag_size < mtu) {\n\t\tif (np->frag_size)\n\t\t\tmtu = np->frag_size;\n\t}\n\tmtu -= hlen + sizeof(struct frag_hdr);\n\n\tif (skb_has_frag_list(skb)) {\n\t\tint first_len = skb_pagelen(skb);\n\t\tstruct sk_buff *frag2;\n\n\t\tif (first_len - hlen > mtu ||\n\t\t    ((first_len - hlen) & 7) ||\n\t\t    skb_cloned(skb))\n\t\t\tgoto slow_path;\n\n\t\tskb_walk_frags(skb, frag) {\n\t\t\t/* Correct geometry. */\n\t\t\tif (frag->len > mtu ||\n\t\t\t    ((frag->len & 7) && frag->next) ||\n\t\t\t    skb_headroom(frag) < hlen)\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\t/* Partially cloned skb? */\n\t\t\tif (skb_shared(frag))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\tBUG_ON(frag->sk);\n\t\t\tif (skb->sk) {\n\t\t\t\tfrag->sk = skb->sk;\n\t\t\t\tfrag->destructor = sock_wfree;\n\t\t\t}\n\t\t\tskb->truesize -= frag->truesize;\n\t\t}\n\n\t\terr = 0;\n\t\toffset = 0;\n\t\tfrag = skb_shinfo(skb)->frag_list;\n\t\tskb_frag_list_init(skb);\n\t\t/* BUILD HEADER */\n\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\ttmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);\n\t\tif (!tmp_hdr) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t__skb_pull(skb, hlen);\n\t\tfh = (struct frag_hdr*)__skb_push(skb, sizeof(struct frag_hdr));\n\t\t__skb_push(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tmemcpy(skb_network_header(skb), tmp_hdr, hlen);\n\n\t\tipv6_select_ident(fh, rt);\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->frag_off = htons(IP6_MF);\n\t\tfrag_id = fh->identification;\n\n\t\tfirst_len = skb_pagelen(skb);\n\t\tskb->data_len = first_len - skb_headlen(skb);\n\t\tskb->len = first_len;\n\t\tipv6_hdr(skb)->payload_len = htons(first_len -\n\t\t\t\t\t\t   sizeof(struct ipv6hdr));\n\n\t\tdst_hold(&rt->dst);\n\n\t\tfor (;;) {\n\t\t\t/* Prepare header of the next frame,\n\t\t\t * before previous one went down. */\n\t\t\tif (frag) {\n\t\t\t\tfrag->ip_summed = CHECKSUM_NONE;\n\t\t\t\tskb_reset_transport_header(frag);\n\t\t\t\tfh = (struct frag_hdr*)__skb_push(frag, sizeof(struct frag_hdr));\n\t\t\t\t__skb_push(frag, hlen);\n\t\t\t\tskb_reset_network_header(frag);\n\t\t\t\tmemcpy(skb_network_header(frag), tmp_hdr,\n\t\t\t\t       hlen);\n\t\t\t\toffset += skb->len - hlen - sizeof(struct frag_hdr);\n\t\t\t\tfh->nexthdr = nexthdr;\n\t\t\t\tfh->reserved = 0;\n\t\t\t\tfh->frag_off = htons(offset);\n\t\t\t\tif (frag->next != NULL)\n\t\t\t\t\tfh->frag_off |= htons(IP6_MF);\n\t\t\t\tfh->identification = frag_id;\n\t\t\t\tipv6_hdr(frag)->payload_len =\n\t\t\t\t\t\thtons(frag->len -\n\t\t\t\t\t\t      sizeof(struct ipv6hdr));\n\t\t\t\tip6_copy_metadata(frag, skb);\n\t\t\t}\n\n\t\t\terr = output(skb);\n\t\t\tif(!err)\n\t\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\n\t\t\tif (err || !frag)\n\t\t\t\tbreak;\n\n\t\t\tskb = frag;\n\t\t\tfrag = skb->next;\n\t\t\tskb->next = NULL;\n\t\t}\n\n\t\tkfree(tmp_hdr);\n\n\t\tif (err == 0) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t      IPSTATS_MIB_FRAGOKS);\n\t\t\tip6_rt_put(rt);\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (frag) {\n\t\t\tskb = frag->next;\n\t\t\tkfree_skb(frag);\n\t\t\tfrag = skb;\n\t\t}\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\tip6_rt_put(rt);\n\t\treturn err;\n\nslow_path_clean:\n\t\tskb_walk_frags(skb, frag2) {\n\t\t\tif (frag2 == frag)\n\t\t\t\tbreak;\n\t\t\tfrag2->sk = NULL;\n\t\t\tfrag2->destructor = NULL;\n\t\t\tskb->truesize += frag2->truesize;\n\t\t}\n\t}\n\nslow_path:\n\tif ((skb->ip_summed == CHECKSUM_PARTIAL) &&\n\t    skb_checksum_help(skb))\n\t\tgoto fail;\n\n\tleft = skb->len - hlen;\t\t/* Space per frame */\n\tptr = hlen;\t\t\t/* Where to start from */\n\n\t/*\n\t *\tFragment the datagram.\n\t */\n\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\throom = LL_RESERVED_SPACE(rt->dst.dev);\n\ttroom = rt->dst.dev->needed_tailroom;\n\n\t/*\n\t *\tKeep copying data until we run out.\n\t */\n\twhile(left > 0)\t{\n\t\tlen = left;\n\t\t/* IF: it doesn't fit, use 'mtu' - the data space left */\n\t\tif (len > mtu)\n\t\t\tlen = mtu;\n\t\t/* IF: we are not sending up to and including the packet end\n\t\t   then align the next start on an eight byte boundary */\n\t\tif (len < left)\t{\n\t\t\tlen &= ~7;\n\t\t}\n\t\t/*\n\t\t *\tAllocate buffer.\n\t\t */\n\n\t\tif ((frag = alloc_skb(len + hlen + sizeof(struct frag_hdr) +\n\t\t\t\t      hroom + troom, GFP_ATOMIC)) == NULL) {\n\t\t\tNETDEBUG(KERN_INFO \"IPv6: frag: no memory for new fragment!\\n\");\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t *\tSet up data on packet\n\t\t */\n\n\t\tip6_copy_metadata(frag, skb);\n\t\tskb_reserve(frag, hroom);\n\t\tskb_put(frag, len + hlen + sizeof(struct frag_hdr));\n\t\tskb_reset_network_header(frag);\n\t\tfh = (struct frag_hdr *)(skb_network_header(frag) + hlen);\n\t\tfrag->transport_header = (frag->network_header + hlen +\n\t\t\t\t\t  sizeof(struct frag_hdr));\n\n\t\t/*\n\t\t *\tCharge the memory for the fragment to any owner\n\t\t *\tit might possess\n\t\t */\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(frag, skb->sk);\n\n\t\t/*\n\t\t *\tCopy the packet header into the new buffer.\n\t\t */\n\t\tskb_copy_from_linear_data(skb, skb_network_header(frag), hlen);\n\n\t\t/*\n\t\t *\tBuild fragment header.\n\t\t */\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tif (!frag_id) {\n\t\t\tipv6_select_ident(fh, rt);\n\t\t\tfrag_id = fh->identification;\n\t\t} else\n\t\t\tfh->identification = frag_id;\n\n\t\t/*\n\t\t *\tCopy a block of the IP datagram.\n\t\t */\n\t\tif (skb_copy_bits(skb, ptr, skb_transport_header(frag), len))\n\t\t\tBUG();\n\t\tleft -= len;\n\n\t\tfh->frag_off = htons(offset);\n\t\tif (left > 0)\n\t\t\tfh->frag_off |= htons(IP6_MF);\n\t\tipv6_hdr(frag)->payload_len = htons(frag->len -\n\t\t\t\t\t\t    sizeof(struct ipv6hdr));\n\n\t\tptr += len;\n\t\toffset += len;\n\n\t\t/*\n\t\t *\tPut this fragment into the sending queue.\n\t\t */\n\t\terr = output(frag);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\t}\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGOKS);\n\tconsume_skb(skb);\n\treturn err;\n\nfail:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic inline int ip6_rt_check(const struct rt6key *rt_key,\n\t\t\t       const struct in6_addr *fl_addr,\n\t\t\t       const struct in6_addr *addr_cache)\n{\n\treturn (rt_key->plen != 128 || !ipv6_addr_equal(fl_addr, &rt_key->addr)) &&\n\t\t(addr_cache == NULL || !ipv6_addr_equal(fl_addr, addr_cache));\n}\n\nstatic struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\trt = (struct rt6_info *)dst;\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.\n\t *    We do not want to save whole address now,\n\t *    (because main consumer of this service\n\t *    is tcp, which has not this problem),\n\t *    so that the last trick works only on connected\n\t *    sockets.\n\t * 2. oif also should be the same.\n\t */\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}\n\nstatic int ip6_dst_lookup_tail(struct sock *sk,\n\t\t\t       struct dst_entry **dst, struct flowi6 *fl6)\n{\n\tstruct net *net = sock_net(sk);\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tstruct neighbour *n;\n\tstruct rt6_info *rt;\n#endif\n\tint err;\n\n\tif (*dst == NULL)\n\t\t*dst = ip6_route_output(net, sk, fl6);\n\n\tif ((err = (*dst)->error))\n\t\tgoto out_err_release;\n\n\tif (ipv6_addr_any(&fl6->saddr)) {\n\t\tstruct rt6_info *rt = (struct rt6_info *) *dst;\n\t\terr = ip6_route_get_saddr(net, rt, &fl6->daddr,\n\t\t\t\t\t  sk ? inet6_sk(sk)->srcprefs : 0,\n\t\t\t\t\t  &fl6->saddr);\n\t\tif (err)\n\t\t\tgoto out_err_release;\n\t}\n\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t/*\n\t * Here if the dst entry we've looked up\n\t * has a neighbour entry that is in the INCOMPLETE\n\t * state and the src address from the flow is\n\t * marked as OPTIMISTIC, we release the found\n\t * dst entry and replace it instead with the\n\t * dst entry of the nexthop router\n\t */\n\trt = (struct rt6_info *) *dst;\n\trcu_read_lock_bh();\n\tn = __ipv6_neigh_lookup_noref(rt->dst.dev, rt6_nexthop(rt, &fl6->daddr));\n\terr = n && !(n->nud_state & NUD_VALID) ? -EINVAL : 0;\n\trcu_read_unlock_bh();\n\n\tif (err) {\n\t\tstruct inet6_ifaddr *ifp;\n\t\tstruct flowi6 fl_gw6;\n\t\tint redirect;\n\n\t\tifp = ipv6_get_ifaddr(net, &fl6->saddr,\n\t\t\t\t      (*dst)->dev, 1);\n\n\t\tredirect = (ifp && ifp->flags & IFA_F_OPTIMISTIC);\n\t\tif (ifp)\n\t\t\tin6_ifa_put(ifp);\n\n\t\tif (redirect) {\n\t\t\t/*\n\t\t\t * We need to get the dst entry for the\n\t\t\t * default router instead\n\t\t\t */\n\t\t\tdst_release(*dst);\n\t\t\tmemcpy(&fl_gw6, fl6, sizeof(struct flowi6));\n\t\t\tmemset(&fl_gw6.daddr, 0, sizeof(struct in6_addr));\n\t\t\t*dst = ip6_route_output(net, sk, &fl_gw6);\n\t\t\tif ((err = (*dst)->error))\n\t\t\t\tgoto out_err_release;\n\t\t}\n\t}\n#endif\n\n\treturn 0;\n\nout_err_release:\n\tif (err == -ENETUNREACH)\n\t\tIP6_INC_STATS_BH(net, NULL, IPSTATS_MIB_OUTNOROUTES);\n\tdst_release(*dst);\n\t*dst = NULL;\n\treturn err;\n}\n\n/**\n *\tip6_dst_lookup - perform route lookup on flow\n *\t@sk: socket which provides route info\n *\t@dst: pointer to dst_entry * for result\n *\t@fl6: flow to lookup\n *\n *\tThis function performs a route lookup on the given flow.\n *\n *\tIt returns zero on success, or a standard errno code on error.\n */\nint ip6_dst_lookup(struct sock *sk, struct dst_entry **dst, struct flowi6 *fl6)\n{\n\t*dst = NULL;\n\treturn ip6_dst_lookup_tail(sk, dst, fl6);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup);\n\n/**\n *\tip6_dst_lookup_flow - perform route lookup on flow with ipsec\n *\t@sk: socket which provides route info\n *\t@fl6: flow to lookup\n *\t@final_dst: final destination address for ipsec lookup\n *\t@can_sleep: we are in a sleepable context\n *\n *\tThis function performs a route lookup on the given flow.\n *\n *\tIt returns a valid dst pointer on success, or a pointer encoded\n *\terror code.\n */\nstruct dst_entry *ip6_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t      const struct in6_addr *final_dst,\n\t\t\t\t      bool can_sleep)\n{\n\tstruct dst_entry *dst = NULL;\n\tint err;\n\n\terr = ip6_dst_lookup_tail(sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (final_dst)\n\t\tfl6->daddr = *final_dst;\n\tif (can_sleep)\n\t\tfl6->flowi6_flags |= FLOWI_FLAG_CAN_SLEEP;\n\n\treturn xfrm_lookup(sock_net(sk), dst, flowi6_to_flowi(fl6), sk, 0);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup_flow);\n\n/**\n *\tip6_sk_dst_lookup_flow - perform socket cached route lookup on flow\n *\t@sk: socket which provides the dst cache and route info\n *\t@fl6: flow to lookup\n *\t@final_dst: final destination address for ipsec lookup\n *\t@can_sleep: we are in a sleepable context\n *\n *\tThis function performs a route lookup on the given flow with the\n *\tpossibility of using the cached route in the socket if it is valid.\n *\tIt will take the socket dst lock when operating on the dst cache.\n *\tAs a result, this function can only be used in process context.\n *\n *\tIt returns a valid dst pointer on success, or a pointer encoded\n *\terror code.\n */\nstruct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t\t const struct in6_addr *final_dst,\n\t\t\t\t\t bool can_sleep)\n{\n\tstruct dst_entry *dst = sk_dst_check(sk, inet6_sk(sk)->dst_cookie);\n\tint err;\n\n\tdst = ip6_sk_dst_check(sk, dst, fl6);\n\n\terr = ip6_dst_lookup_tail(sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (final_dst)\n\t\tfl6->daddr = *final_dst;\n\tif (can_sleep)\n\t\tfl6->flowi6_flags |= FLOWI_FLAG_CAN_SLEEP;\n\n\treturn xfrm_lookup(sock_net(sk), dst, flowi6_to_flowi(fl6), sk, 0);\n}\nEXPORT_SYMBOL_GPL(ip6_sk_dst_lookup_flow);\n\nstatic inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t}\n\n\terr = skb_append_datato_frags(sk,skb, getfrag, from,\n\t\t\t\t      (length - transhdrlen));\n\tif (!err) {\n\t\tstruct frag_hdr fhdr;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\n\t\treturn 0;\n\t}\n\t/* There is not enough support do UPD LSO,\n\t * so follow normal path\n\t */\n\tkfree_skb(skb);\n\n\treturn err;\n}\n\nstatic inline struct ipv6_opt_hdr *ip6_opt_dup(struct ipv6_opt_hdr *src,\n\t\t\t\t\t       gfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic inline struct ipv6_rt_hdr *ip6_rthdr_dup(struct ipv6_rt_hdr *src,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t/* first fragment, reserve header_len */\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * this fragment is not first, the headers\n\t\t\t * space is regarded as data space.\n\t\t\t */\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}\n\nint ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint mtu;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif (length > mtu) {\n\t\tint proto = sk->sk_protocol;\n\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_append_data);\n\nstatic void ip6_cork_release(struct inet_sock *inet, struct ipv6_pinfo *np)\n{\n\tif (np->cork.opt) {\n\t\tkfree(np->cork.opt->dst0opt);\n\t\tkfree(np->cork.opt->dst1opt);\n\t\tkfree(np->cork.opt->hopopt);\n\t\tkfree(np->cork.opt->srcrt);\n\t\tkfree(np->cork.opt);\n\t\tnp->cork.opt = NULL;\n\t}\n\n\tif (inet->cork.base.dst) {\n\t\tdst_release(inet->cork.base.dst);\n\t\tinet->cork.base.dst = NULL;\n\t\tinet->cork.base.flags &= ~IPCORK_ALLFRAG;\n\t}\n\tmemset(&inet->cork.fl, 0, sizeof(inet->cork.fl));\n}\n\nint ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb, *tmp_skb;\n\tstruct sk_buff **tail_skb;\n\tstruct in6_addr final_dst_buf, *final_dst = &final_dst_buf;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6hdr *hdr;\n\tstruct ipv6_txoptions *opt = np->cork.opt;\n\tstruct rt6_info *rt = (struct rt6_info *)inet->cork.base.dst;\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tunsigned char proto = fl6->flowi6_proto;\n\tint err = 0;\n\n\tif ((skb = __skb_dequeue(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\ttail_skb = &(skb_shinfo(skb)->frag_list);\n\n\t/* move skb->data to ip header from ext header */\n\tif (skb->data < skb_network_header(skb))\n\t\t__skb_pull(skb, skb_network_offset(skb));\n\twhile ((tmp_skb = __skb_dequeue(&sk->sk_write_queue)) != NULL) {\n\t\t__skb_pull(tmp_skb, skb_network_header_len(skb));\n\t\t*tail_skb = tmp_skb;\n\t\ttail_skb = &(tmp_skb->next);\n\t\tskb->len += tmp_skb->len;\n\t\tskb->data_len += tmp_skb->len;\n\t\tskb->truesize += tmp_skb->truesize;\n\t\ttmp_skb->destructor = NULL;\n\t\ttmp_skb->sk = NULL;\n\t}\n\n\t/* Allow local fragmentation. */\n\tif (np->pmtudisc < IPV6_PMTUDISC_DO)\n\t\tskb->local_df = 1;\n\n\t*final_dst = fl6->daddr;\n\t__skb_pull(skb, skb_network_header_len(skb));\n\tif (opt && opt->opt_flen)\n\t\tipv6_push_frag_opts(skb, opt, &proto);\n\tif (opt && opt->opt_nflen)\n\t\tipv6_push_nfrag_opts(skb, opt, &proto, &final_dst);\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\tip6_flow_hdr(hdr, np->cork.tclass, fl6->flowlabel);\n\thdr->hop_limit = np->cork.hop_limit;\n\thdr->nexthdr = proto;\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *final_dst;\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\tIP6_UPD_PO_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);\n\tif (proto == IPPROTO_ICMPV6) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\t\tICMP6MSGOUT_INC_STATS_BH(net, idev, icmp6_hdr(skb)->icmp6_type);\n\t\tICMP6_INC_STATS_BH(net, idev, ICMP6_MIB_OUTMSGS);\n\t}\n\n\terr = ip6_local_out(skb);\n\tif (err) {\n\t\tif (err > 0)\n\t\t\terr = net_xmit_errno(err);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\nout:\n\tip6_cork_release(inet, np);\n\treturn err;\nerror:\n\tIP6_INC_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(ip6_push_pending_frames);\n\nvoid ip6_flush_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue_tail(&sk->sk_write_queue)) != NULL) {\n\t\tif (skb_dst(skb))\n\t\t\tIP6_INC_STATS(sock_net(sk), ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb(skb);\n\t}\n\n\tip6_cork_release(inet_sk(sk), inet6_sk(sk));\n}\nEXPORT_SYMBOL_GPL(ip6_flush_pending_frames);\n"], "filenames": ["net/ipv6/ip6_output.c"], "buggy_code_start_loc": [824], "buggy_code_end_loc": [828], "fixing_code_start_loc": [824], "fixing_code_end_loc": [835], "type": "CWE-20", "message": "The ip6_sk_dst_check function in net/ipv6/ip6_output.c in the Linux kernel before 3.10 allows local users to cause a denial of service (system crash) by using an AF_INET6 socket for a connection to an IPv4 interface.", "other": {"cve": {"id": "CVE-2013-2232", "sourceIdentifier": "secalert@redhat.com", "published": "2013-07-04T21:55:01.063", "lastModified": "2023-02-13T04:44:14.673", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ip6_sk_dst_check function in net/ipv6/ip6_output.c in the Linux kernel before 3.10 allows local users to cause a denial of service (system crash) by using an AF_INET6 socket for a connection to an IPv4 interface."}, {"lang": "es", "value": "La funci\u00f3n ip6_sk_dst_check en net/ipv6/ip6_output.c en el kernel de Linux antes de v3.10 permite a usuarios locales causar una denegaci\u00f3n de servicios (ca\u00edda del sistema) mediante el uso de un socket AF_INET6 para una conexi\u00f3n a una interfaz IPv4."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.9.9", "matchCriteriaId": "8979C85B-174F-44E6-A866-6511EC2470E5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:x86:*", "matchCriteriaId": "7D47A395-821D-4BFF-996E-E849D9A40217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:x86:*", "matchCriteriaId": "8A603291-33B4-4195-B52D-D2A9938089C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:x86:*", "matchCriteriaId": "8C3D9C66-933A-469E-9073-75015A8AD17D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:x86:*", "matchCriteriaId": "C92F29A0-DEFF-49E4-AE86-5DBDAD51C677"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:x86:*", "matchCriteriaId": "5690A703-390D-4D8A-9258-2F47116DAB4F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:x86:*", "matchCriteriaId": "AB1EDDA7-15AF-4B45-A931-DFCBB1EEB701"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:x86:*", "matchCriteriaId": "952FE0DC-B2ED-4080-BF29-A2C265E83FEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:x86:*", "matchCriteriaId": "1CE7ABDB-6572-40E8-B952-CBE52C999858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:x86:*", "matchCriteriaId": "0F417186-D1ED-4A31-92B2-83DEDA1AF272"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:x86:*", "matchCriteriaId": "3D4FCFAE-918C-4886-9A17-08A5B94D35F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:x86:*", "matchCriteriaId": "830D2914-C9FE-406F-AFCE-7A04BB9E2896"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:x86:*", "matchCriteriaId": "F4B791B5-2EB5-403A-90CC-B219F6277D1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:x86:*", "matchCriteriaId": "2BA5F34D-7490-4B2B-A7E6-8450F9C1FC31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:x86:*", "matchCriteriaId": "B803FE64-FC8D-4650-9FB9-FEEED4340416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:x86:*", "matchCriteriaId": "4C560A9A-2388-4980-9E88-118C5EB806B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=a963a37d384d71ad43b3e9e79d68d42fbe0901f3", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-09/msg00003.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-09/msg00004.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-12/msg00129.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1166.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1173.html", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2013/dsa-2766", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/07/02/5", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1912-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1913-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1938-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1941-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1942-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1943-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1944-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1945-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1946-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1947-1", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/a963a37d384d71ad43b3e9e79d68d42fbe0901f3", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v3.x/patch-3.10.bz2", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a963a37d384d71ad43b3e9e79d68d42fbe0901f3"}}