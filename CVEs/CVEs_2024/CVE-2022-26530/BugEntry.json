{"buggy_code": ["#ifndef _SWAYLOCK_H\n#define _SWAYLOCK_H\n#include <stdbool.h>\n#include <stdint.h>\n#include <wayland-client.h>\n#include \"background-image.h\"\n#include \"cairo.h\"\n#include \"pool-buffer.h\"\n#include \"seat.h\"\n#include \"wlr-layer-shell-unstable-v1-client-protocol.h\"\n\nenum auth_state {\n\tAUTH_STATE_IDLE,\n\tAUTH_STATE_CLEAR,\n\tAUTH_STATE_INPUT,\n\tAUTH_STATE_INPUT_NOP,\n\tAUTH_STATE_BACKSPACE,\n\tAUTH_STATE_VALIDATING,\n\tAUTH_STATE_INVALID,\n};\n\nstruct swaylock_colorset {\n\tuint32_t input;\n\tuint32_t cleared;\n\tuint32_t caps_lock;\n\tuint32_t verifying;\n\tuint32_t wrong;\n};\n\nstruct swaylock_colors {\n\tuint32_t background;\n\tuint32_t bs_highlight;\n\tuint32_t key_highlight;\n\tuint32_t caps_lock_bs_highlight;\n\tuint32_t caps_lock_key_highlight;\n\tuint32_t separator;\n\tuint32_t layout_background;\n\tuint32_t layout_border;\n\tuint32_t layout_text;\n\tstruct swaylock_colorset inside;\n\tstruct swaylock_colorset line;\n\tstruct swaylock_colorset ring;\n\tstruct swaylock_colorset text;\n};\n\nstruct swaylock_args {\n\tstruct swaylock_colors colors;\n\tenum background_mode mode;\n\tchar *font;\n\tuint32_t font_size;\n\tuint32_t radius;\n\tuint32_t thickness;\n\tuint32_t indicator_x_position;\n\tuint32_t indicator_y_position;\n\tbool override_indicator_x_position;\n\tbool override_indicator_y_position;\n\tbool ignore_empty;\n\tbool show_indicator;\n\tbool show_caps_lock_text;\n\tbool show_caps_lock_indicator;\n\tbool show_keyboard_layout;\n\tbool hide_keyboard_layout;\n\tbool show_failed_attempts;\n\tbool daemonize;\n\tbool indicator_idle_visible;\n};\n\nstruct swaylock_password {\n\tsize_t len;\n\tchar buffer[1024];\n};\n\nstruct swaylock_state {\n\tstruct loop *eventloop;\n\tstruct loop_timer *clear_indicator_timer; // clears the indicator\n\tstruct loop_timer *clear_password_timer;  // clears the password buffer\n\tstruct wl_display *display;\n\tstruct wl_compositor *compositor;\n\tstruct wl_subcompositor *subcompositor;\n\tstruct zwlr_layer_shell_v1 *layer_shell;\n\tstruct zwlr_input_inhibit_manager_v1 *input_inhibit_manager;\n\tstruct wl_shm *shm;\n\tstruct wl_list surfaces;\n\tstruct wl_list images;\n\tstruct swaylock_args args;\n\tstruct swaylock_password password;\n\tstruct swaylock_xkb xkb;\n\tenum auth_state auth_state;\n\tint failed_attempts;\n\tbool run_display;\n\tstruct zxdg_output_manager_v1 *zxdg_output_manager;\n};\n\nstruct swaylock_surface {\n\tcairo_surface_t *image;\n\tstruct swaylock_state *state;\n\tstruct wl_output *output;\n\tuint32_t output_global_name;\n\tstruct zxdg_output_v1 *xdg_output;\n\tstruct wl_surface *surface;\n\tstruct wl_surface *child; // surface made into subsurface\n\tstruct wl_subsurface *subsurface;\n\tstruct zwlr_layer_surface_v1 *layer_surface;\n\tstruct pool_buffer buffers[2];\n\tstruct pool_buffer indicator_buffers[2];\n\tstruct pool_buffer *current_buffer;\n\tbool frame_pending, dirty;\n\tuint32_t width, height;\n\tuint32_t indicator_width, indicator_height;\n\tint32_t scale;\n\tenum wl_output_subpixel subpixel;\n\tchar *output_name;\n\tstruct wl_list link;\n};\n\n// There is exactly one swaylock_image for each -i argument\nstruct swaylock_image {\n\tchar *path;\n\tchar *output_name;\n\tcairo_surface_t *cairo_surface;\n\tstruct wl_list link;\n};\n\nvoid swaylock_handle_key(struct swaylock_state *state,\n\t\txkb_keysym_t keysym, uint32_t codepoint);\nvoid render_frame_background(struct swaylock_surface *surface);\nvoid render_frame(struct swaylock_surface *surface);\nvoid render_frames(struct swaylock_state *state);\nvoid damage_surface(struct swaylock_surface *surface);\nvoid damage_state(struct swaylock_state *state);\nvoid clear_password_buffer(struct swaylock_password *pw);\nvoid schedule_indicator_clear(struct swaylock_state *state);\n\nvoid initialize_pw_backend(int argc, char **argv);\nvoid run_pw_backend_child(void);\nvoid clear_buffer(char *buf, size_t size);\n\n#endif\n", "#define _POSIX_C_SOURCE 200809L\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <poll.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include <wayland-client.h>\n#include <wordexp.h>\n#include \"background-image.h\"\n#include \"cairo.h\"\n#include \"comm.h\"\n#include \"log.h\"\n#include \"loop.h\"\n#include \"pool-buffer.h\"\n#include \"seat.h\"\n#include \"swaylock.h\"\n#include \"wlr-input-inhibitor-unstable-v1-client-protocol.h\"\n#include \"wlr-layer-shell-unstable-v1-client-protocol.h\"\n#include \"xdg-output-unstable-v1-client-protocol.h\"\n\nstatic uint32_t parse_color(const char *color) {\n\tif (color[0] == '#') {\n\t\t++color;\n\t}\n\n\tint len = strlen(color);\n\tif (len != 6 && len != 8) {\n\t\tswaylock_log(LOG_DEBUG, \"Invalid color %s, defaulting to 0xFFFFFFFF\",\n\t\t\t\tcolor);\n\t\treturn 0xFFFFFFFF;\n\t}\n\tuint32_t res = (uint32_t)strtoul(color, NULL, 16);\n\tif (strlen(color) == 6) {\n\t\tres = (res << 8) | 0xFF;\n\t}\n\treturn res;\n}\n\nint lenient_strcmp(char *a, char *b) {\n\tif (a == b) {\n\t\treturn 0;\n\t} else if (!a) {\n\t\treturn -1;\n\t} else if (!b) {\n\t\treturn 1;\n\t} else {\n\t\treturn strcmp(a, b);\n\t}\n}\n\nstatic void daemonize(void) {\n\tint fds[2];\n\tif (pipe(fds) != 0) {\n\t\tswaylock_log(LOG_ERROR, \"Failed to pipe\");\n\t\texit(1);\n\t}\n\tif (fork() == 0) {\n\t\tsetsid();\n\t\tclose(fds[0]);\n\t\tint devnull = open(\"/dev/null\", O_RDWR);\n\t\tdup2(STDOUT_FILENO, devnull);\n\t\tdup2(STDERR_FILENO, devnull);\n\t\tclose(devnull);\n\t\tuint8_t success = 0;\n\t\tif (chdir(\"/\") != 0) {\n\t\t\twrite(fds[1], &success, 1);\n\t\t\texit(1);\n\t\t}\n\t\tsuccess = 1;\n\t\tif (write(fds[1], &success, 1) != 1) {\n\t\t\texit(1);\n\t\t}\n\t\tclose(fds[1]);\n\t} else {\n\t\tclose(fds[1]);\n\t\tuint8_t success;\n\t\tif (read(fds[0], &success, 1) != 1 || !success) {\n\t\t\tswaylock_log(LOG_ERROR, \"Failed to daemonize\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fds[0]);\n\t\texit(0);\n\t}\n}\n\nstatic void destroy_surface(struct swaylock_surface *surface) {\n\twl_list_remove(&surface->link);\n\tif (surface->layer_surface != NULL) {\n\t\tzwlr_layer_surface_v1_destroy(surface->layer_surface);\n\t}\n\tif (surface->surface != NULL) {\n\t\twl_surface_destroy(surface->surface);\n\t}\n\tdestroy_buffer(&surface->buffers[0]);\n\tdestroy_buffer(&surface->buffers[1]);\n\tdestroy_buffer(&surface->indicator_buffers[0]);\n\tdestroy_buffer(&surface->indicator_buffers[1]);\n\twl_output_destroy(surface->output);\n\tfree(surface);\n}\n\nstatic const struct zwlr_layer_surface_v1_listener layer_surface_listener;\n\nstatic cairo_surface_t *select_image(struct swaylock_state *state,\n\t\tstruct swaylock_surface *surface);\n\nstatic bool surface_is_opaque(struct swaylock_surface *surface) {\n\tif (surface->image) {\n\t\treturn cairo_surface_get_content(surface->image) == CAIRO_CONTENT_COLOR;\n\t}\n\treturn (surface->state->args.colors.background & 0xff) == 0xff;\n}\n\nstatic void create_layer_surface(struct swaylock_surface *surface) {\n\tstruct swaylock_state *state = surface->state;\n\n\tsurface->image = select_image(state, surface);\n\n\tsurface->surface = wl_compositor_create_surface(state->compositor);\n\tassert(surface->surface);\n\n\tsurface->child = wl_compositor_create_surface(state->compositor);\n\tassert(surface->child);\n\tsurface->subsurface = wl_subcompositor_get_subsurface(state->subcompositor, surface->child, surface->surface);\n\tassert(surface->subsurface);\n\twl_subsurface_set_sync(surface->subsurface);\n\n\tsurface->layer_surface = zwlr_layer_shell_v1_get_layer_surface(\n\t\t\tstate->layer_shell, surface->surface, surface->output,\n\t\t\tZWLR_LAYER_SHELL_V1_LAYER_OVERLAY, \"lockscreen\");\n\tassert(surface->layer_surface);\n\n\tzwlr_layer_surface_v1_set_size(surface->layer_surface, 0, 0);\n\tzwlr_layer_surface_v1_set_anchor(surface->layer_surface,\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);\n\tzwlr_layer_surface_v1_set_exclusive_zone(surface->layer_surface, -1);\n\tzwlr_layer_surface_v1_set_keyboard_interactivity(\n\t\t\tsurface->layer_surface, true);\n\tzwlr_layer_surface_v1_add_listener(surface->layer_surface,\n\t\t\t&layer_surface_listener, surface);\n\n\tif (surface_is_opaque(surface) &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_CENTER &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_FIT) {\n\t\tstruct wl_region *region =\n\t\t\twl_compositor_create_region(surface->state->compositor);\n\t\twl_region_add(region, 0, 0, INT32_MAX, INT32_MAX);\n\t\twl_surface_set_opaque_region(surface->surface, region);\n\t\twl_region_destroy(region);\n\t}\n\n\twl_surface_commit(surface->surface);\n}\n\nstatic void layer_surface_configure(void *data,\n\t\tstruct zwlr_layer_surface_v1 *layer_surface,\n\t\tuint32_t serial, uint32_t width, uint32_t height) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->width = width;\n\tsurface->height = height;\n\tsurface->indicator_width = 0;\n\tsurface->indicator_height = 0;\n\tzwlr_layer_surface_v1_ack_configure(layer_surface, serial);\n\trender_frame_background(surface);\n\trender_frame(surface);\n}\n\nstatic void layer_surface_closed(void *data,\n\t\tstruct zwlr_layer_surface_v1 *layer_surface) {\n\tstruct swaylock_surface *surface = data;\n\tdestroy_surface(surface);\n}\n\nstatic const struct zwlr_layer_surface_v1_listener layer_surface_listener = {\n\t.configure = layer_surface_configure,\n\t.closed = layer_surface_closed,\n};\n\nstatic const struct wl_callback_listener surface_frame_listener;\n\nstatic void surface_frame_handle_done(void *data, struct wl_callback *callback,\n\t\tuint32_t time) {\n\tstruct swaylock_surface *surface = data;\n\n\twl_callback_destroy(callback);\n\tsurface->frame_pending = false;\n\n\tif (surface->dirty) {\n\t\t// Schedule a frame in case the surface is damaged again\n\t\tstruct wl_callback *callback = wl_surface_frame(surface->surface);\n\t\twl_callback_add_listener(callback, &surface_frame_listener, surface);\n\t\tsurface->frame_pending = true;\n\n\t\trender_frame(surface);\n\t\tsurface->dirty = false;\n\t}\n}\n\nstatic const struct wl_callback_listener surface_frame_listener = {\n\t.done = surface_frame_handle_done,\n};\n\nvoid damage_surface(struct swaylock_surface *surface) {\n\tsurface->dirty = true;\n\tif (surface->frame_pending) {\n\t\treturn;\n\t}\n\n\tstruct wl_callback *callback = wl_surface_frame(surface->surface);\n\twl_callback_add_listener(callback, &surface_frame_listener, surface);\n\tsurface->frame_pending = true;\n\twl_surface_commit(surface->surface);\n}\n\nvoid damage_state(struct swaylock_state *state) {\n\tstruct swaylock_surface *surface;\n\twl_list_for_each(surface, &state->surfaces, link) {\n\t\tdamage_surface(surface);\n\t}\n}\n\nstatic void handle_wl_output_geometry(void *data, struct wl_output *wl_output,\n\t\tint32_t x, int32_t y, int32_t width_mm, int32_t height_mm,\n\t\tint32_t subpixel, const char *make, const char *model,\n\t\tint32_t transform) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->subpixel = subpixel;\n\tif (surface->state->run_display) {\n\t\tdamage_surface(surface);\n\t}\n}\n\nstatic void handle_wl_output_mode(void *data, struct wl_output *output,\n\t\tuint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n\t// Who cares\n}\n\nstatic void handle_wl_output_done(void *data, struct wl_output *output) {\n\t// Who cares\n}\n\nstatic void handle_wl_output_scale(void *data, struct wl_output *output,\n\t\tint32_t factor) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->scale = factor;\n\tif (surface->state->run_display) {\n\t\tdamage_surface(surface);\n\t}\n}\n\nstruct wl_output_listener _wl_output_listener = {\n\t.geometry = handle_wl_output_geometry,\n\t.mode = handle_wl_output_mode,\n\t.done = handle_wl_output_done,\n\t.scale = handle_wl_output_scale,\n};\n\nstatic void handle_xdg_output_logical_size(void *data, struct zxdg_output_v1 *output,\n\t\tint width, int height) {\n\t// Who cares\n}\n\nstatic void handle_xdg_output_logical_position(void *data,\n\t\tstruct zxdg_output_v1 *output, int x, int y) {\n\t// Who cares\n}\n\nstatic void handle_xdg_output_name(void *data, struct zxdg_output_v1 *output,\n\t\tconst char *name) {\n\tswaylock_log(LOG_DEBUG, \"output name is %s\", name);\n\tstruct swaylock_surface *surface = data;\n\tsurface->xdg_output = output;\n\tsurface->output_name = strdup(name);\n}\n\nstatic void handle_xdg_output_description(void *data, struct zxdg_output_v1 *output,\n\t\tconst char *description) {\n\t// Who cares\n}\n\nstatic void handle_xdg_output_done(void *data, struct zxdg_output_v1 *output) {\n\t// Who cares\n}\n\nstruct zxdg_output_v1_listener _xdg_output_listener = {\n\t.logical_position = handle_xdg_output_logical_position,\n\t.logical_size = handle_xdg_output_logical_size,\n\t.done = handle_xdg_output_done,\n\t.name = handle_xdg_output_name,\n\t.description = handle_xdg_output_description,\n};\n\nstatic void handle_global(void *data, struct wl_registry *registry,\n\t\tuint32_t name, const char *interface, uint32_t version) {\n\tstruct swaylock_state *state = data;\n\tif (strcmp(interface, wl_compositor_interface.name) == 0) {\n\t\tstate->compositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_compositor_interface, 4);\n\t} else if (strcmp(interface, wl_subcompositor_interface.name) == 0) {\n\t\tstate->subcompositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_subcompositor_interface, 1);\n\t} else if (strcmp(interface, wl_shm_interface.name) == 0) {\n\t\tstate->shm = wl_registry_bind(registry, name,\n\t\t\t\t&wl_shm_interface, 1);\n\t} else if (strcmp(interface, wl_seat_interface.name) == 0) {\n\t\tstruct wl_seat *seat = wl_registry_bind(\n\t\t\t\tregistry, name, &wl_seat_interface, 4);\n\t\tstruct swaylock_seat *swaylock_seat =\n\t\t\tcalloc(1, sizeof(struct swaylock_seat));\n\t\tswaylock_seat->state = state;\n\t\twl_seat_add_listener(seat, &seat_listener, swaylock_seat);\n\t} else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) {\n\t\tstate->layer_shell = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_layer_shell_v1_interface, 1);\n\t} else if (strcmp(interface, zwlr_input_inhibit_manager_v1_interface.name) == 0) {\n\t\tstate->input_inhibit_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_input_inhibit_manager_v1_interface, 1);\n\t} else if (strcmp(interface, zxdg_output_manager_v1_interface.name) == 0) {\n\t\tstate->zxdg_output_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zxdg_output_manager_v1_interface, 2);\n\t} else if (strcmp(interface, wl_output_interface.name) == 0) {\n\t\tstruct swaylock_surface *surface =\n\t\t\tcalloc(1, sizeof(struct swaylock_surface));\n\t\tsurface->state = state;\n\t\tsurface->output = wl_registry_bind(registry, name,\n\t\t\t\t&wl_output_interface, 3);\n\t\tsurface->output_global_name = name;\n\t\twl_output_add_listener(surface->output, &_wl_output_listener, surface);\n\t\twl_list_insert(&state->surfaces, &surface->link);\n\n\t\tif (state->run_display) {\n\t\t\tcreate_layer_surface(surface);\n\t\t\twl_display_roundtrip(state->display);\n\t\t}\n\t}\n}\n\nstatic void handle_global_remove(void *data, struct wl_registry *registry,\n\t\tuint32_t name) {\n\tstruct swaylock_state *state = data;\n\tstruct swaylock_surface *surface;\n\twl_list_for_each(surface, &state->surfaces, link) {\n\t\tif (surface->output_global_name == name) {\n\t\t\tdestroy_surface(surface);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic const struct wl_registry_listener registry_listener = {\n\t.global = handle_global,\n\t.global_remove = handle_global_remove,\n};\n\nstatic cairo_surface_t *select_image(struct swaylock_state *state,\n\t\tstruct swaylock_surface *surface) {\n\tstruct swaylock_image *image;\n\tcairo_surface_t *default_image = NULL;\n\twl_list_for_each(image, &state->images, link) {\n\t\tif (lenient_strcmp(image->output_name, surface->output_name) == 0) {\n\t\t\treturn image->cairo_surface;\n\t\t} else if (!image->output_name) {\n\t\t\tdefault_image = image->cairo_surface;\n\t\t}\n\t}\n\treturn default_image;\n}\n\nstatic char *join_args(char **argv, int argc) {\n\tassert(argc > 0);\n\tint len = 0, i;\n\tfor (i = 0; i < argc; ++i) {\n\t\tlen += strlen(argv[i]) + 1;\n\t}\n\tchar *res = malloc(len);\n\tlen = 0;\n\tfor (i = 0; i < argc; ++i) {\n\t\tstrcpy(res + len, argv[i]);\n\t\tlen += strlen(argv[i]);\n\t\tres[len++] = ' ';\n\t}\n\tres[len - 1] = '\\0';\n\treturn res;\n}\n\nstatic void load_image(char *arg, struct swaylock_state *state) {\n\t// [[<output>]:]<path>\n\tstruct swaylock_image *image = calloc(1, sizeof(struct swaylock_image));\n\tchar *separator = strchr(arg, ':');\n\tif (separator) {\n\t\t*separator = '\\0';\n\t\timage->output_name = separator == arg ? NULL : strdup(arg);\n\t\timage->path = strdup(separator + 1);\n\t} else {\n\t\timage->output_name = NULL;\n\t\timage->path = strdup(arg);\n\t}\n\n\tstruct swaylock_image *iter_image, *temp;\n\twl_list_for_each_safe(iter_image, temp, &state->images, link) {\n\t\tif (lenient_strcmp(iter_image->output_name, image->output_name) == 0) {\n\t\t\tif (image->output_name) {\n\t\t\t\tswaylock_log(LOG_DEBUG,\n\t\t\t\t\t\t\"Replacing image defined for output %s with %s\",\n\t\t\t\t\t\timage->output_name, image->path);\n\t\t\t} else {\n\t\t\t\tswaylock_log(LOG_DEBUG, \"Replacing default image with %s\",\n\t\t\t\t\t\timage->path);\n\t\t\t}\n\t\t\twl_list_remove(&iter_image->link);\n\t\t\tfree(iter_image->cairo_surface);\n\t\t\tfree(iter_image->output_name);\n\t\t\tfree(iter_image->path);\n\t\t\tfree(iter_image);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// The shell will not expand ~ to the value of $HOME when an output name is\n\t// given. Also, any image paths given in the config file need to have shell\n\t// expansions performed\n\twordexp_t p;\n\twhile (strstr(image->path, \"  \")) {\n\t\timage->path = realloc(image->path, strlen(image->path) + 2);\n\t\tchar *ptr = strstr(image->path, \"  \") + 1;\n\t\tmemmove(ptr + 1, ptr, strlen(ptr) + 1);\n\t\t*ptr = '\\\\';\n\t}\n\tif (wordexp(image->path, &p, 0) == 0) {\n\t\tfree(image->path);\n\t\timage->path = join_args(p.we_wordv, p.we_wordc);\n\t\twordfree(&p);\n\t}\n\n\t// Load the actual image\n\timage->cairo_surface = load_background_image(image->path);\n\tif (!image->cairo_surface) {\n\t\tfree(image);\n\t\treturn;\n\t}\n\twl_list_insert(&state->images, &image->link);\n\tswaylock_log(LOG_DEBUG, \"Loaded image %s for output %s\", image->path,\n\t\t\timage->output_name ? image->output_name : \"*\");\n}\n\nstatic void set_default_colors(struct swaylock_colors *colors) {\n\tcolors->background = 0xFFFFFFFF;\n\tcolors->bs_highlight = 0xDB3300FF;\n\tcolors->key_highlight = 0x33DB00FF;\n\tcolors->caps_lock_bs_highlight = 0xDB3300FF;\n\tcolors->caps_lock_key_highlight = 0x33DB00FF;\n\tcolors->separator = 0x000000FF;\n\tcolors->layout_background = 0x000000C0;\n\tcolors->layout_border = 0x00000000;\n\tcolors->layout_text = 0xFFFFFFFF;\n\tcolors->inside = (struct swaylock_colorset){\n\t\t.input = 0x000000C0,\n\t\t.cleared = 0xE5A445C0,\n\t\t.caps_lock = 0x000000C0,\n\t\t.verifying = 0x0072FFC0,\n\t\t.wrong = 0xFA0000C0,\n\t};\n\tcolors->line = (struct swaylock_colorset){\n\t\t.input = 0x000000FF,\n\t\t.cleared = 0x000000FF,\n\t\t.caps_lock = 0x000000FF,\n\t\t.verifying = 0x000000FF,\n\t\t.wrong = 0x000000FF,\n\t};\n\tcolors->ring = (struct swaylock_colorset){\n\t\t.input = 0x337D00FF,\n\t\t.cleared = 0xE5A445FF,\n\t\t.caps_lock = 0xE5A445FF,\n\t\t.verifying = 0x3300FFFF,\n\t\t.wrong = 0x7D3300FF,\n\t};\n\tcolors->text = (struct swaylock_colorset){\n\t\t.input = 0xE5A445FF,\n\t\t.cleared = 0x000000FF,\n\t\t.caps_lock = 0xE5A445FF,\n\t\t.verifying = 0x000000FF,\n\t\t.wrong = 0x000000FF,\n\t};\n}\n\nenum line_mode {\n\tLM_LINE,\n\tLM_INSIDE,\n\tLM_RING,\n};\n\nstatic int parse_options(int argc, char **argv, struct swaylock_state *state,\n\t\tenum line_mode *line_mode, char **config_path) {\n\tenum long_option_codes {\n\t\tLO_BS_HL_COLOR = 256,\n\t\tLO_CAPS_LOCK_BS_HL_COLOR,\n\t\tLO_CAPS_LOCK_KEY_HL_COLOR,\n\t\tLO_FONT,\n\t\tLO_FONT_SIZE,\n\t\tLO_IND_IDLE_VISIBLE,\n\t\tLO_IND_RADIUS,\n\t\tLO_IND_X_POSITION,\n\t\tLO_IND_Y_POSITION,\n\t\tLO_IND_THICKNESS,\n\t\tLO_INSIDE_COLOR,\n\t\tLO_INSIDE_CLEAR_COLOR,\n\t\tLO_INSIDE_CAPS_LOCK_COLOR,\n\t\tLO_INSIDE_VER_COLOR,\n\t\tLO_INSIDE_WRONG_COLOR,\n\t\tLO_KEY_HL_COLOR,\n\t\tLO_LAYOUT_TXT_COLOR,\n\t\tLO_LAYOUT_BG_COLOR,\n\t\tLO_LAYOUT_BORDER_COLOR,\n\t\tLO_LINE_COLOR,\n\t\tLO_LINE_CLEAR_COLOR,\n\t\tLO_LINE_CAPS_LOCK_COLOR,\n\t\tLO_LINE_VER_COLOR,\n\t\tLO_LINE_WRONG_COLOR,\n\t\tLO_RING_COLOR,\n\t\tLO_RING_CLEAR_COLOR,\n\t\tLO_RING_CAPS_LOCK_COLOR,\n\t\tLO_RING_VER_COLOR,\n\t\tLO_RING_WRONG_COLOR,\n\t\tLO_SEP_COLOR,\n\t\tLO_TEXT_COLOR,\n\t\tLO_TEXT_CLEAR_COLOR,\n\t\tLO_TEXT_CAPS_LOCK_COLOR,\n\t\tLO_TEXT_VER_COLOR,\n\t\tLO_TEXT_WRONG_COLOR,\n\t};\n\n\tstatic struct option long_options[] = {\n\t\t{\"config\", required_argument, NULL, 'C'},\n\t\t{\"color\", required_argument, NULL, 'c'},\n\t\t{\"debug\", no_argument, NULL, 'd'},\n\t\t{\"ignore-empty-password\", no_argument, NULL, 'e'},\n\t\t{\"daemonize\", no_argument, NULL, 'f'},\n\t\t{\"help\", no_argument, NULL, 'h'},\n\t\t{\"image\", required_argument, NULL, 'i'},\n\t\t{\"disable-caps-lock-text\", no_argument, NULL, 'L'},\n\t\t{\"indicator-caps-lock\", no_argument, NULL, 'l'},\n\t\t{\"line-uses-inside\", no_argument, NULL, 'n'},\n\t\t{\"line-uses-ring\", no_argument, NULL, 'r'},\n\t\t{\"scaling\", required_argument, NULL, 's'},\n\t\t{\"tiling\", no_argument, NULL, 't'},\n\t\t{\"no-unlock-indicator\", no_argument, NULL, 'u'},\n\t\t{\"show-keyboard-layout\", no_argument, NULL, 'k'},\n\t\t{\"hide-keyboard-layout\", no_argument, NULL, 'K'},\n\t\t{\"show-failed-attempts\", no_argument, NULL, 'F'},\n\t\t{\"version\", no_argument, NULL, 'v'},\n\t\t{\"bs-hl-color\", required_argument, NULL, LO_BS_HL_COLOR},\n\t\t{\"caps-lock-bs-hl-color\", required_argument, NULL, LO_CAPS_LOCK_BS_HL_COLOR},\n\t\t{\"caps-lock-key-hl-color\", required_argument, NULL, LO_CAPS_LOCK_KEY_HL_COLOR},\n\t\t{\"font\", required_argument, NULL, LO_FONT},\n\t\t{\"font-size\", required_argument, NULL, LO_FONT_SIZE},\n\t\t{\"indicator-idle-visible\", no_argument, NULL, LO_IND_IDLE_VISIBLE},\n\t\t{\"indicator-radius\", required_argument, NULL, LO_IND_RADIUS},\n\t\t{\"indicator-thickness\", required_argument, NULL, LO_IND_THICKNESS},\n\t\t{\"indicator-x-position\", required_argument, NULL, LO_IND_X_POSITION},\n\t\t{\"indicator-y-position\", required_argument, NULL, LO_IND_Y_POSITION},\n\t\t{\"inside-color\", required_argument, NULL, LO_INSIDE_COLOR},\n\t\t{\"inside-clear-color\", required_argument, NULL, LO_INSIDE_CLEAR_COLOR},\n\t\t{\"inside-caps-lock-color\", required_argument, NULL, LO_INSIDE_CAPS_LOCK_COLOR},\n\t\t{\"inside-ver-color\", required_argument, NULL, LO_INSIDE_VER_COLOR},\n\t\t{\"inside-wrong-color\", required_argument, NULL, LO_INSIDE_WRONG_COLOR},\n\t\t{\"key-hl-color\", required_argument, NULL, LO_KEY_HL_COLOR},\n\t\t{\"layout-bg-color\", required_argument, NULL, LO_LAYOUT_BG_COLOR},\n\t\t{\"layout-border-color\", required_argument, NULL, LO_LAYOUT_BORDER_COLOR},\n\t\t{\"layout-text-color\", required_argument, NULL, LO_LAYOUT_TXT_COLOR},\n\t\t{\"line-color\", required_argument, NULL, LO_LINE_COLOR},\n\t\t{\"line-clear-color\", required_argument, NULL, LO_LINE_CLEAR_COLOR},\n\t\t{\"line-caps-lock-color\", required_argument, NULL, LO_LINE_CAPS_LOCK_COLOR},\n\t\t{\"line-ver-color\", required_argument, NULL, LO_LINE_VER_COLOR},\n\t\t{\"line-wrong-color\", required_argument, NULL, LO_LINE_WRONG_COLOR},\n\t\t{\"ring-color\", required_argument, NULL, LO_RING_COLOR},\n\t\t{\"ring-clear-color\", required_argument, NULL, LO_RING_CLEAR_COLOR},\n\t\t{\"ring-caps-lock-color\", required_argument, NULL, LO_RING_CAPS_LOCK_COLOR},\n\t\t{\"ring-ver-color\", required_argument, NULL, LO_RING_VER_COLOR},\n\t\t{\"ring-wrong-color\", required_argument, NULL, LO_RING_WRONG_COLOR},\n\t\t{\"separator-color\", required_argument, NULL, LO_SEP_COLOR},\n\t\t{\"text-color\", required_argument, NULL, LO_TEXT_COLOR},\n\t\t{\"text-clear-color\", required_argument, NULL, LO_TEXT_CLEAR_COLOR},\n\t\t{\"text-caps-lock-color\", required_argument, NULL, LO_TEXT_CAPS_LOCK_COLOR},\n\t\t{\"text-ver-color\", required_argument, NULL, LO_TEXT_VER_COLOR},\n\t\t{\"text-wrong-color\", required_argument, NULL, LO_TEXT_WRONG_COLOR},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tconst char usage[] =\n\t\t\"Usage: swaylock [options...]\\n\"\n\t\t\"\\n\"\n\t\t\"  -C, --config <config_file>       \"\n\t\t\t\"Path to the config file.\\n\"\n\t\t\"  -c, --color <color>              \"\n\t\t\t\"Turn the screen into the given color instead of white.\\n\"\n\t\t\"  -d, --debug                      \"\n\t\t\t\"Enable debugging output.\\n\"\n\t\t\"  -e, --ignore-empty-password      \"\n\t\t\t\"When an empty password is provided, do not validate it.\\n\"\n\t\t\"  -F, --show-failed-attempts       \"\n\t\t\t\"Show current count of failed authentication attempts.\\n\"\n\t\t\"  -f, --daemonize                  \"\n\t\t\t\"Detach from the controlling terminal after locking.\\n\"\n\t\t\"  -h, --help                       \"\n\t\t\t\"Show help message and quit.\\n\"\n\t\t\"  -i, --image [[<output>]:]<path>  \"\n\t\t\t\"Display the given image, optionally only on the given output.\\n\"\n\t\t\"  -k, --show-keyboard-layout       \"\n\t\t\t\"Display the current xkb layout while typing.\\n\"\n\t\t\"  -K, --hide-keyboard-layout       \"\n\t\t\t\"Hide the current xkb layout while typing.\\n\"\n\t\t\"  -L, --disable-caps-lock-text     \"\n\t\t\t\"Disable the Caps Lock text.\\n\"\n\t\t\"  -l, --indicator-caps-lock        \"\n\t\t\t\"Show the current Caps Lock state also on the indicator.\\n\"\n\t\t\"  -s, --scaling <mode>             \"\n\t\t\t\"Image scaling mode: stretch, fill, fit, center, tile, solid_color.\\n\"\n\t\t\"  -t, --tiling                     \"\n\t\t\t\"Same as --scaling=tile.\\n\"\n\t\t\"  -u, --no-unlock-indicator        \"\n\t\t\t\"Disable the unlock indicator.\\n\"\n\t\t\"  -v, --version                    \"\n\t\t\t\"Show the version number and quit.\\n\"\n\t\t\"  --bs-hl-color <color>            \"\n\t\t\t\"Sets the color of backspace highlight segments.\\n\"\n\t\t\"  --caps-lock-bs-hl-color <color>  \"\n\t\t\t\"Sets the color of backspace highlight segments when Caps Lock \"\n\t\t\t\"is active.\\n\"\n\t\t\"  --caps-lock-key-hl-color <color> \"\n\t\t\t\"Sets the color of the key press highlight segments when \"\n\t\t\t\"Caps Lock is active.\\n\"\n\t\t\"  --font <font>                    \"\n\t\t\t\"Sets the font of the text.\\n\"\n\t\t\"  --font-size <size>               \"\n\t\t\t\"Sets a fixed font size for the indicator text.\\n\"\n\t\t\"  --indicator-idle-visible         \"\n\t\t\t\"Sets the indicator to show even if idle.\\n\"\n\t\t\"  --indicator-radius <radius>      \"\n\t\t\t\"Sets the indicator radius.\\n\"\n\t\t\"  --indicator-thickness <thick>    \"\n\t\t\t\"Sets the indicator thickness.\\n\"\n\t\t\"  --indicator-x-position <x>       \"\n\t\t\t\"Sets the horizontal position of the indicator.\\n\"\n\t\t\"  --indicator-y-position <y>       \"\n\t\t\t\"Sets the vertical position of the indicator.\\n\"\n\t\t\"  --inside-color <color>           \"\n\t\t\t\"Sets the color of the inside of the indicator.\\n\"\n\t\t\"  --inside-clear-color <color>     \"\n\t\t\t\"Sets the color of the inside of the indicator when cleared.\\n\"\n\t\t\"  --inside-caps-lock-color <color> \"\n\t\t\t\"Sets the color of the inside of the indicator when Caps Lock \"\n\t\t\t\"is active.\\n\"\n\t\t\"  --inside-ver-color <color>       \"\n\t\t\t\"Sets the color of the inside of the indicator when verifying.\\n\"\n\t\t\"  --inside-wrong-color <color>     \"\n\t\t\t\"Sets the color of the inside of the indicator when invalid.\\n\"\n\t\t\"  --key-hl-color <color>           \"\n\t\t\t\"Sets the color of the key press highlight segments.\\n\"\n\t\t\"  --layout-bg-color <color>        \"\n\t\t\t\"Sets the background color of the box containing the layout text.\\n\"\n\t\t\"  --layout-border-color <color>    \"\n\t\t\t\"Sets the color of the border of the box containing the layout text.\\n\"\n\t\t\"  --layout-text-color <color>      \"\n\t\t\t\"Sets the color of the layout text.\\n\"\n\t\t\"  --line-color <color>             \"\n\t\t\t\"Sets the color of the line between the inside and ring.\\n\"\n\t\t\"  --line-clear-color <color>       \"\n\t\t\t\"Sets the color of the line between the inside and ring when \"\n\t\t\t\"cleared.\\n\"\n\t\t\"  --line-caps-lock-color <color>   \"\n\t\t\t\"Sets the color of the line between the inside and ring when \"\n\t\t\t\"Caps Lock is active.\\n\"\n\t\t\"  --line-ver-color <color>         \"\n\t\t\t\"Sets the color of the line between the inside and ring when \"\n\t\t\t\"verifying.\\n\"\n\t\t\"  --line-wrong-color <color>       \"\n\t\t\t\"Sets the color of the line between the inside and ring when \"\n\t\t\t\"invalid.\\n\"\n\t\t\"  -n, --line-uses-inside           \"\n\t\t\t\"Use the inside color for the line between the inside and ring.\\n\"\n\t\t\"  -r, --line-uses-ring             \"\n\t\t\t\"Use the ring color for the line between the inside and ring.\\n\"\n\t\t\"  --ring-color <color>             \"\n\t\t\t\"Sets the color of the ring of the indicator.\\n\"\n\t\t\"  --ring-clear-color <color>       \"\n\t\t\t\"Sets the color of the ring of the indicator when cleared.\\n\"\n\t\t\"  --ring-caps-lock-color <color>   \"\n\t\t\t\"Sets the color of the ring of the indicator when Caps Lock \"\n\t\t\t\"is active.\\n\"\n\t\t\"  --ring-ver-color <color>         \"\n\t\t\t\"Sets the color of the ring of the indicator when verifying.\\n\"\n\t\t\"  --ring-wrong-color <color>       \"\n\t\t\t\"Sets the color of the ring of the indicator when invalid.\\n\"\n\t\t\"  --separator-color <color>        \"\n\t\t\t\"Sets the color of the lines that separate highlight segments.\\n\"\n\t\t\"  --text-color <color>             \"\n\t\t\t\"Sets the color of the text.\\n\"\n\t\t\"  --text-clear-color <color>       \"\n\t\t\t\"Sets the color of the text when cleared.\\n\"\n\t\t\"  --text-caps-lock-color <color>   \"\n\t\t\t\"Sets the color of the text when Caps Lock is active.\\n\"\n\t\t\"  --text-ver-color <color>         \"\n\t\t\t\"Sets the color of the text when verifying.\\n\"\n\t\t\"  --text-wrong-color <color>       \"\n\t\t\t\"Sets the color of the text when invalid.\\n\"\n\t\t\"\\n\"\n\t\t\"All <color> options are of the form <rrggbb[aa]>.\\n\";\n\n\tint c;\n\toptind = 1;\n\twhile (1) {\n\t\tint opt_idx = 0;\n\t\tc = getopt_long(argc, argv, \"c:deFfhi:kKLlnrs:tuvC:\", long_options,\n\t\t\t\t&opt_idx);\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tif (config_path) {\n\t\t\t\t*config_path = strdup(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.background = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tswaylock_log_init(LOG_DEBUG);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (state) {\n\t\t\t\tstate->args.ignore_empty = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_failed_attempts = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (state) {\n\t\t\t\tstate->args.daemonize = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (state) {\n\t\t\t\tload_image(optarg, state);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_keyboard_layout = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tif (state) {\n\t\t\t\tstate->args.hide_keyboard_layout = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_caps_lock_text = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_caps_lock_indicator = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (line_mode) {\n\t\t\t\t*line_mode = LM_INSIDE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (line_mode) {\n\t\t\t\t*line_mode = LM_RING;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (state) {\n\t\t\t\tstate->args.mode = parse_background_mode(optarg);\n\t\t\t\tif (state->args.mode == BACKGROUND_MODE_INVALID) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (state) {\n\t\t\t\tstate->args.mode = BACKGROUND_MODE_TILE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_indicator = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tfprintf(stdout, \"swaylock version \" SWAYLOCK_VERSION \"\\n\");\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase LO_BS_HL_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.bs_highlight = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_CAPS_LOCK_BS_HL_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.caps_lock_bs_highlight = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_CAPS_LOCK_KEY_HL_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.caps_lock_key_highlight = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_FONT:\n\t\t\tif (state) {\n\t\t\t\tfree(state->args.font);\n\t\t\t\tstate->args.font = strdup(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_FONT_SIZE:\n\t\t\tif (state) {\n\t\t\t\tstate->args.font_size = atoi(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_IDLE_VISIBLE:\n\t\t\tif (state) {\n\t\t\t\tstate->args.indicator_idle_visible = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_RADIUS:\n\t\t\tif (state) {\n\t\t\t\tstate->args.radius = strtol(optarg, NULL, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_THICKNESS:\n\t\t\tif (state) {\n\t\t\t\tstate->args.thickness = strtol(optarg, NULL, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_X_POSITION:\n\t\t\tif (state) {\n\t\t\t\tstate->args.override_indicator_x_position = true;\n\t\t\t\tstate->args.indicator_x_position = atoi(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_Y_POSITION:\n\t\t\tif (state) {\n\t\t\t\tstate->args.override_indicator_y_position = true;\n\t\t\t\tstate->args.indicator_y_position = atoi(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.input = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_CLEAR_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.cleared = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_CAPS_LOCK_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.caps_lock = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_VER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.verifying = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_WRONG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.wrong = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_KEY_HL_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.key_highlight = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LAYOUT_BG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.layout_background = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LAYOUT_BORDER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.layout_border = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LAYOUT_TXT_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.layout_text = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.input = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_CLEAR_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.cleared = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_CAPS_LOCK_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.caps_lock = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_VER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.verifying = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_WRONG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.wrong = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.input = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_CLEAR_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.cleared = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_CAPS_LOCK_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.caps_lock = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_VER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.verifying = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_WRONG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.wrong = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_SEP_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.separator = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.input = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_CLEAR_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.cleared = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_CAPS_LOCK_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.caps_lock = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_VER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.verifying = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_WRONG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.wrong = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"%s\", usage);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool file_exists(const char *path) {\n\treturn path && access(path, R_OK) != -1;\n}\n\nstatic char *get_config_path(void) {\n\tstatic const char *config_paths[] = {\n\t\t\"$HOME/.swaylock/config\",\n\t\t\"$XDG_CONFIG_HOME/swaylock/config\",\n\t\tSYSCONFDIR \"/swaylock/config\",\n\t};\n\n\tchar *config_home = getenv(\"XDG_CONFIG_HOME\");\n\tif (!config_home || config_home[0] == '\\0') {\n\t\tconfig_paths[1] = \"$HOME/.config/swaylock/config\";\n\t}\n\n\twordexp_t p;\n\tchar *path;\n\tfor (size_t i = 0; i < sizeof(config_paths) / sizeof(char *); ++i) {\n\t\tif (wordexp(config_paths[i], &p, 0) == 0) {\n\t\t\tpath = strdup(p.we_wordv[0]);\n\t\t\twordfree(&p);\n\t\t\tif (file_exists(path)) {\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tfree(path);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int load_config(char *path, struct swaylock_state *state,\n\t\tenum line_mode *line_mode) {\n\tFILE *config = fopen(path, \"r\");\n\tif (!config) {\n\t\tswaylock_log(LOG_ERROR, \"Failed to read config. Running without it.\");\n\t\treturn 0;\n\t}\n\tchar *line = NULL;\n\tsize_t line_size = 0;\n\tssize_t nread;\n\tint line_number = 0;\n\tint result = 0;\n\twhile ((nread = getline(&line, &line_size, config)) != -1) {\n\t\tline_number++;\n\n\t\tif (line[nread - 1] == '\\n') {\n\t\t\tline[--nread] = '\\0';\n\t\t}\n\n\t\tif (!*line || line[0] == '#') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswaylock_log(LOG_DEBUG, \"Config Line #%d: %s\", line_number, line);\n\t\tchar *flag = malloc(nread + 3);\n\t\tif (flag == NULL) {\n\t\t\tfree(line);\n\t\t\tfclose(config);\n\t\t\tswaylock_log(LOG_ERROR, \"Failed to allocate memory\");\n\t\t\treturn 0;\n\t\t}\n\t\tsprintf(flag, \"--%s\", line);\n\t\tchar *argv[] = {\"swaylock\", flag};\n\t\tresult = parse_options(2, argv, state, line_mode, NULL);\n\t\tfree(flag);\n\t\tif (result != 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(line);\n\tfclose(config);\n\treturn 0;\n}\n\nstatic struct swaylock_state state;\n\nstatic void display_in(int fd, short mask, void *data) {\n\tif (wl_display_dispatch(state.display) == -1) {\n\t\tstate.run_display = false;\n\t}\n}\n\nstatic void comm_in(int fd, short mask, void *data) {\n\tif (read_comm_reply()) {\n\t\t// Authentication succeeded\n\t\tstate.run_display = false;\n\t} else {\n\t\tstate.auth_state = AUTH_STATE_INVALID;\n\t\tschedule_indicator_clear(&state);\n\t\t++state.failed_attempts;\n\t\tdamage_state(&state);\n\t}\n}\n\nint main(int argc, char **argv) {\n\tswaylock_log_init(LOG_ERROR);\n\tinitialize_pw_backend(argc, argv);\n\tsrand(time(NULL));\n\n\tenum line_mode line_mode = LM_LINE;\n\tstate.failed_attempts = 0;\n\tstate.args = (struct swaylock_args){\n\t\t.mode = BACKGROUND_MODE_FILL,\n\t\t.font = strdup(\"sans-serif\"),\n\t\t.font_size = 0,\n\t\t.radius = 50,\n\t\t.thickness = 10,\n\t\t.indicator_x_position = 0,\n\t\t.indicator_y_position = 0,\n\t\t.override_indicator_x_position = false,\n\t\t.override_indicator_y_position = false,\n\t\t.ignore_empty = false,\n\t\t.show_indicator = true,\n\t\t.show_caps_lock_indicator = false,\n\t\t.show_caps_lock_text = true,\n\t\t.show_keyboard_layout = false,\n\t\t.hide_keyboard_layout = false,\n\t\t.show_failed_attempts = false,\n\t\t.indicator_idle_visible = false\n\t};\n\twl_list_init(&state.images);\n\tset_default_colors(&state.args.colors);\n\n\tchar *config_path = NULL;\n\tint result = parse_options(argc, argv, NULL, NULL, &config_path);\n\tif (result != 0) {\n\t\tfree(config_path);\n\t\treturn result;\n\t}\n\tif (!config_path) {\n\t\tconfig_path = get_config_path();\n\t}\n\n\tif (config_path) {\n\t\tswaylock_log(LOG_DEBUG, \"Found config at %s\", config_path);\n\t\tint config_status = load_config(config_path, &state, &line_mode);\n\t\tfree(config_path);\n\t\tif (config_status != 0) {\n\t\t\tfree(state.args.font);\n\t\t\treturn config_status;\n\t\t}\n\t}\n\n\tif (argc > 1) {\n\t\tswaylock_log(LOG_DEBUG, \"Parsing CLI Args\");\n\t\tint result = parse_options(argc, argv, &state, &line_mode, NULL);\n\t\tif (result != 0) {\n\t\t\tfree(state.args.font);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (line_mode == LM_INSIDE) {\n\t\tstate.args.colors.line = state.args.colors.inside;\n\t} else if (line_mode == LM_RING) {\n\t\tstate.args.colors.line = state.args.colors.ring;\n\t}\n\n#ifdef __linux__\n\t// Most non-linux platforms require root to mlock()\n\tif (mlock(state.password.buffer, sizeof(state.password.buffer)) != 0) {\n\t\tswaylock_log(LOG_ERROR, \"Unable to mlock() password memory.\");\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\n\twl_list_init(&state.surfaces);\n\tstate.xkb.context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);\n\tstate.display = wl_display_connect(NULL);\n\tif (!state.display) {\n\t\tfree(state.args.font);\n\t\tswaylock_log(LOG_ERROR, \"Unable to connect to the compositor. \"\n\t\t\t\t\"If your compositor is running, check or set the \"\n\t\t\t\t\"WAYLAND_DISPLAY environment variable.\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tstruct wl_registry *registry = wl_display_get_registry(state.display);\n\twl_registry_add_listener(registry, &registry_listener, &state);\n\twl_display_roundtrip(state.display);\n\tassert(state.compositor && state.layer_shell && state.shm);\n\tif (!state.input_inhibit_manager) {\n\t\tfree(state.args.font);\n\t\tswaylock_log(LOG_ERROR, \"Compositor does not support the input \"\n\t\t\t\t\"inhibitor protocol, refusing to run insecurely\");\n\t\treturn 1;\n\t}\n\n\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);\n\tif (wl_display_roundtrip(state.display) == -1) {\n\t\tfree(state.args.font);\n\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"\n\t\t\t\t\" is another lockscreen already running?\");\n\t\treturn 2;\n\t}\n\n\tif (state.zxdg_output_manager) {\n\t\tstruct swaylock_surface *surface;\n\t\twl_list_for_each(surface, &state.surfaces, link) {\n\t\t\tsurface->xdg_output = zxdg_output_manager_v1_get_xdg_output(\n\t\t\t\t\t\tstate.zxdg_output_manager, surface->output);\n\t\t\tzxdg_output_v1_add_listener(\n\t\t\t\t\tsurface->xdg_output, &_xdg_output_listener, surface);\n\t\t}\n\t\twl_display_roundtrip(state.display);\n\t} else {\n\t\tswaylock_log(LOG_INFO, \"Compositor does not support zxdg output \"\n\t\t\t\t\"manager, images assigned to named outputs will not work\");\n\t}\n\n\tstruct swaylock_surface *surface;\n\twl_list_for_each(surface, &state.surfaces, link) {\n\t\tcreate_layer_surface(surface);\n\t}\n\n\tif (state.args.daemonize) {\n\t\twl_display_roundtrip(state.display);\n\t\tdaemonize();\n\t}\n\n\tstate.eventloop = loop_create();\n\tloop_add_fd(state.eventloop, wl_display_get_fd(state.display), POLLIN,\n\t\t\tdisplay_in, NULL);\n\n\tloop_add_fd(state.eventloop, get_comm_reply_fd(), POLLIN, comm_in, NULL);\n\n\tstate.run_display = true;\n\twhile (state.run_display) {\n\t\terrno = 0;\n\t\tif (wl_display_flush(state.display) == -1 && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t\tloop_poll(state.eventloop);\n\t}\n\n\tfree(state.args.font);\n\treturn 0;\n}\n", "project(\n\t'swaylock',\n\t'c',\n\tversion: '1.6',\n\tlicense: 'MIT',\n\tmeson_version: '>=0.58.0',\n\tdefault_options: [\n\t\t'c_std=c11',\n\t\t'warning_level=2',\n\t\t'werror=true',\n\t],\n)\n\nadd_project_arguments(\n\t[\n\t\t'-Wno-unused-parameter',\n\t\t'-Wno-unused-result',\n\t\t'-Wundef',\n\t\t'-Wvla',\n\t],\n\tlanguage: 'c',\n)\n\ncc = meson.get_compiler('c')\n\nsysconfdir = get_option('sysconfdir')\nprefix = get_option('prefix')\nis_freebsd = host_machine.system().startswith('freebsd')\n\nadd_project_arguments(\n\t'-DSYSCONFDIR=\"/@0@\"'.format(join_paths(prefix, sysconfdir)),\n\tlanguage : 'c')\n\nif is_freebsd\n\tadd_project_arguments('-D_C11_SOURCE', language: 'c')\nendif\n\nwayland_client = dependency('wayland-client')\nwayland_protos = dependency('wayland-protocols', version: '>=1.14', fallback: 'wayland-protocols')\nxkbcommon      = dependency('xkbcommon')\ncairo          = dependency('cairo')\ngdk_pixbuf     = dependency('gdk-pixbuf-2.0', required: get_option('gdk-pixbuf'))\nbash_comp      = dependency('bash-completion', required: false)\nfish_comp      = dependency('fish', required: false)\nlibpam         = cc.find_library('pam', required: get_option('pam'))\ncrypt          = cc.find_library('crypt', required: not libpam.found())\nmath           = cc.find_library('m')\n\ngit = find_program('git', required: false)\nscdoc = find_program('scdoc', required: get_option('man-pages'))\nwayland_scanner = find_program('wayland-scanner')\n\nversion = '\"@0@\"'.format(meson.project_version())\nif git.found()\n\tgit_commit_hash = run_command([git, 'describe', '--always', '--tags'])\n\tgit_branch = run_command([git, 'rev-parse', '--abbrev-ref', 'HEAD'])\n\tif git_commit_hash.returncode() == 0 and git_branch.returncode() == 0\n\t\tversion = '\"@0@ (\" __DATE__ \", branch \\'@1@\\')\"'.format(git_commit_hash.stdout().strip(), git_branch.stdout().strip())\n\tendif\nendif\nadd_project_arguments('-DSWAYLOCK_VERSION=@0@'.format(version), language: 'c')\n\nwl_protocol_dir = wayland_protos.get_variable('pkgdatadir')\n\nif wayland_client.version().version_compare('>=1.14.91')\n\tcode_type = 'private-code'\nelse\n\tcode_type = 'code'\nendif\n\nwayland_scanner_code = generator(\n\twayland_scanner,\n\toutput: '@BASENAME@-protocol.c',\n\targuments: [code_type, '@INPUT@', '@OUTPUT@'],\n)\n\nwayland_scanner_client = generator(\n\twayland_scanner,\n\toutput: '@BASENAME@-client-protocol.h',\n\targuments: ['client-header', '@INPUT@', '@OUTPUT@'],\n)\n\nclient_protos_src = []\nclient_protos_headers = []\n\nclient_protocols = [\n\t[wl_protocol_dir, 'stable/xdg-shell/xdg-shell.xml'],\n\t[wl_protocol_dir, 'unstable/xdg-output/xdg-output-unstable-v1.xml'],\n\t['wlr-layer-shell-unstable-v1.xml'],\n\t['wlr-input-inhibitor-unstable-v1.xml'],\n]\n\nforeach p : client_protocols\n\txml = join_paths(p)\n\tclient_protos_src += wayland_scanner_code.process(xml)\n\tclient_protos_headers += wayland_scanner_client.process(xml)\nendforeach\n\nlib_client_protos = static_library(\n\t'client_protos',\n\tclient_protos_src + client_protos_headers,\n\tdependencies: [wayland_client]\n) # for the include directory\n\nclient_protos = declare_dependency(\n\tlink_with: lib_client_protos,\n\tsources: client_protos_headers,\n)\n\nconf_data = configuration_data()\nconf_data.set10('HAVE_GDK_PIXBUF', gdk_pixbuf.found())\n\nsubdir('include')\n\ndependencies = [\n\tcairo,\n\tclient_protos,\n\tgdk_pixbuf,\n\tmath,\n\txkbcommon,\n\twayland_client,\n]\n\nsources = [\n\t'background-image.c',\n\t'cairo.c',\n\t'comm.c',\n\t'log.c',\n\t'loop.c',\n\t'main.c',\n\t'password.c',\n\t'pool-buffer.c',\n\t'render.c',\n\t'seat.c',\n\t'unicode.c',\n]\n\nif libpam.found()\n\tsources += ['pam.c']\n\tdependencies += [libpam]\nelse\n\twarning('The swaylock binary must be setuid when compiled without libpam')\n\twarning('You must do this manually post-install: chmod a+s /path/to/swaylock')\n\tsources += ['shadow.c']\n\tdependencies += [crypt]\nendif\n\nswaylock_inc = include_directories('include')\n\nexecutable('swaylock',\n\tsources,\n\tinclude_directories: [swaylock_inc],\n\tdependencies: dependencies,\n\tinstall: true\n)\n\ninstall_data(\n\t'pam/swaylock',\n\tinstall_dir: sysconfdir + '/pam.d/'\n)\n\nif scdoc.found()\n\tsh = find_program('sh')\n\tmandir = get_option('mandir')\n\tman_files = [\n\t\t'swaylock.1.scd',\n\t]\n\tforeach filename : man_files\n\t\ttopic = filename.split('.')[-3].split('/')[-1]\n\t\tsection = filename.split('.')[-2]\n\t\toutput = '@0@.@1@'.format(topic, section)\n\n\t\tcustom_target(\n\t\t\toutput,\n\t\t\tinput: filename,\n\t\t\toutput: output,\n\t\t\tcommand: [\n\t\t\t\tsh, '-c', '@0@ < @INPUT@ > @1@'.format(scdoc.full_path(), output)\n\t\t\t],\n\t\t\tinstall: true,\n\t\t\tinstall_dir: '@0@/man@1@'.format(mandir, section)\n\t\t)\n\tendforeach\nendif\n\ndatadir = get_option('datadir')\n\nif get_option('zsh-completions')\n\tzsh_files = files(\n\t\t'completions/zsh/_swaylock',\n\t)\n\tzsh_install_dir = datadir + '/zsh/site-functions'\n\n\tinstall_data(zsh_files, install_dir: zsh_install_dir)\nendif\n\nif get_option('bash-completions')\n\tbash_files = files(\n\t\t'completions/bash/swaylock',\n\t)\n\tif bash_comp.found()\n\t\tbash_install_dir = bash_comp.get_variable('completionsdir')\n\telse\n\t\tbash_install_dir = datadir + '/bash-completion/completions'\n\tendif\n\n\tinstall_data(bash_files, install_dir: bash_install_dir)\nendif\n\nif get_option('fish-completions')\n\tfish_files = files(\n\t\t'completions/fish/swaylock.fish',\n\t)\n\tif fish_comp.found()\n\t\tfish_install_dir = fish_comp.get_variable('completionsdir')\n\telse\n\t\tfish_install_dir = datadir + '/fish/vendor_completions.d'\n\tendif\n\n\tinstall_data(fish_files, install_dir: fish_install_dir)\nendif\n"], "fixing_code": ["#ifndef _SWAYLOCK_H\n#define _SWAYLOCK_H\n#include <stdbool.h>\n#include <stdint.h>\n#include <wayland-client.h>\n#include \"background-image.h\"\n#include \"cairo.h\"\n#include \"pool-buffer.h\"\n#include \"seat.h\"\n#include \"wlr-layer-shell-unstable-v1-client-protocol.h\"\n\nenum auth_state {\n\tAUTH_STATE_IDLE,\n\tAUTH_STATE_CLEAR,\n\tAUTH_STATE_INPUT,\n\tAUTH_STATE_INPUT_NOP,\n\tAUTH_STATE_BACKSPACE,\n\tAUTH_STATE_VALIDATING,\n\tAUTH_STATE_INVALID,\n};\n\nstruct swaylock_colorset {\n\tuint32_t input;\n\tuint32_t cleared;\n\tuint32_t caps_lock;\n\tuint32_t verifying;\n\tuint32_t wrong;\n};\n\nstruct swaylock_colors {\n\tuint32_t background;\n\tuint32_t bs_highlight;\n\tuint32_t key_highlight;\n\tuint32_t caps_lock_bs_highlight;\n\tuint32_t caps_lock_key_highlight;\n\tuint32_t separator;\n\tuint32_t layout_background;\n\tuint32_t layout_border;\n\tuint32_t layout_text;\n\tstruct swaylock_colorset inside;\n\tstruct swaylock_colorset line;\n\tstruct swaylock_colorset ring;\n\tstruct swaylock_colorset text;\n};\n\nstruct swaylock_args {\n\tstruct swaylock_colors colors;\n\tenum background_mode mode;\n\tchar *font;\n\tuint32_t font_size;\n\tuint32_t radius;\n\tuint32_t thickness;\n\tuint32_t indicator_x_position;\n\tuint32_t indicator_y_position;\n\tbool override_indicator_x_position;\n\tbool override_indicator_y_position;\n\tbool ignore_empty;\n\tbool show_indicator;\n\tbool show_caps_lock_text;\n\tbool show_caps_lock_indicator;\n\tbool show_keyboard_layout;\n\tbool hide_keyboard_layout;\n\tbool show_failed_attempts;\n\tbool daemonize;\n\tbool indicator_idle_visible;\n};\n\nstruct swaylock_password {\n\tsize_t len;\n\tchar buffer[1024];\n};\n\nstruct swaylock_state {\n\tstruct loop *eventloop;\n\tstruct loop_timer *clear_indicator_timer; // clears the indicator\n\tstruct loop_timer *clear_password_timer;  // clears the password buffer\n\tstruct wl_display *display;\n\tstruct wl_compositor *compositor;\n\tstruct wl_subcompositor *subcompositor;\n\tstruct zwlr_layer_shell_v1 *layer_shell;\n\tstruct zwlr_input_inhibit_manager_v1 *input_inhibit_manager;\n\tstruct wl_shm *shm;\n\tstruct wl_list surfaces;\n\tstruct wl_list images;\n\tstruct swaylock_args args;\n\tstruct swaylock_password password;\n\tstruct swaylock_xkb xkb;\n\tenum auth_state auth_state;\n\tint failed_attempts;\n\tbool run_display;\n\tstruct zxdg_output_manager_v1 *zxdg_output_manager;\n\tstruct ext_session_lock_manager_v1 *ext_session_lock_manager_v1;\n\tstruct ext_session_lock_v1 *ext_session_lock_v1;\n};\n\nstruct swaylock_surface {\n\tcairo_surface_t *image;\n\tstruct swaylock_state *state;\n\tstruct wl_output *output;\n\tuint32_t output_global_name;\n\tstruct zxdg_output_v1 *xdg_output;\n\tstruct wl_surface *surface;\n\tstruct wl_surface *child; // surface made into subsurface\n\tstruct wl_subsurface *subsurface;\n\tstruct zwlr_layer_surface_v1 *layer_surface;\n\tstruct ext_session_lock_surface_v1 *ext_session_lock_surface_v1;\n\tstruct pool_buffer buffers[2];\n\tstruct pool_buffer indicator_buffers[2];\n\tstruct pool_buffer *current_buffer;\n\tbool frame_pending, dirty;\n\tuint32_t width, height;\n\tuint32_t indicator_width, indicator_height;\n\tint32_t scale;\n\tenum wl_output_subpixel subpixel;\n\tchar *output_name;\n\tstruct wl_list link;\n};\n\n// There is exactly one swaylock_image for each -i argument\nstruct swaylock_image {\n\tchar *path;\n\tchar *output_name;\n\tcairo_surface_t *cairo_surface;\n\tstruct wl_list link;\n};\n\nvoid swaylock_handle_key(struct swaylock_state *state,\n\t\txkb_keysym_t keysym, uint32_t codepoint);\nvoid render_frame_background(struct swaylock_surface *surface);\nvoid render_frame(struct swaylock_surface *surface);\nvoid render_frames(struct swaylock_state *state);\nvoid damage_surface(struct swaylock_surface *surface);\nvoid damage_state(struct swaylock_state *state);\nvoid clear_password_buffer(struct swaylock_password *pw);\nvoid schedule_indicator_clear(struct swaylock_state *state);\n\nvoid initialize_pw_backend(int argc, char **argv);\nvoid run_pw_backend_child(void);\nvoid clear_buffer(char *buf, size_t size);\n\n#endif\n", "#define _POSIX_C_SOURCE 200809L\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <poll.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include <wayland-client.h>\n#include <wordexp.h>\n#include \"background-image.h\"\n#include \"cairo.h\"\n#include \"comm.h\"\n#include \"log.h\"\n#include \"loop.h\"\n#include \"pool-buffer.h\"\n#include \"seat.h\"\n#include \"swaylock.h\"\n#include \"wlr-input-inhibitor-unstable-v1-client-protocol.h\"\n#include \"wlr-layer-shell-unstable-v1-client-protocol.h\"\n#include \"xdg-output-unstable-v1-client-protocol.h\"\n#include \"ext-session-lock-v1-client-protocol.h\"\n\nstatic uint32_t parse_color(const char *color) {\n\tif (color[0] == '#') {\n\t\t++color;\n\t}\n\n\tint len = strlen(color);\n\tif (len != 6 && len != 8) {\n\t\tswaylock_log(LOG_DEBUG, \"Invalid color %s, defaulting to 0xFFFFFFFF\",\n\t\t\t\tcolor);\n\t\treturn 0xFFFFFFFF;\n\t}\n\tuint32_t res = (uint32_t)strtoul(color, NULL, 16);\n\tif (strlen(color) == 6) {\n\t\tres = (res << 8) | 0xFF;\n\t}\n\treturn res;\n}\n\nint lenient_strcmp(char *a, char *b) {\n\tif (a == b) {\n\t\treturn 0;\n\t} else if (!a) {\n\t\treturn -1;\n\t} else if (!b) {\n\t\treturn 1;\n\t} else {\n\t\treturn strcmp(a, b);\n\t}\n}\n\nstatic void daemonize(void) {\n\tint fds[2];\n\tif (pipe(fds) != 0) {\n\t\tswaylock_log(LOG_ERROR, \"Failed to pipe\");\n\t\texit(1);\n\t}\n\tif (fork() == 0) {\n\t\tsetsid();\n\t\tclose(fds[0]);\n\t\tint devnull = open(\"/dev/null\", O_RDWR);\n\t\tdup2(STDOUT_FILENO, devnull);\n\t\tdup2(STDERR_FILENO, devnull);\n\t\tclose(devnull);\n\t\tuint8_t success = 0;\n\t\tif (chdir(\"/\") != 0) {\n\t\t\twrite(fds[1], &success, 1);\n\t\t\texit(1);\n\t\t}\n\t\tsuccess = 1;\n\t\tif (write(fds[1], &success, 1) != 1) {\n\t\t\texit(1);\n\t\t}\n\t\tclose(fds[1]);\n\t} else {\n\t\tclose(fds[1]);\n\t\tuint8_t success;\n\t\tif (read(fds[0], &success, 1) != 1 || !success) {\n\t\t\tswaylock_log(LOG_ERROR, \"Failed to daemonize\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fds[0]);\n\t\texit(0);\n\t}\n}\n\nstatic void destroy_surface(struct swaylock_surface *surface) {\n\twl_list_remove(&surface->link);\n\tif (surface->layer_surface != NULL) {\n\t\tzwlr_layer_surface_v1_destroy(surface->layer_surface);\n\t}\n\tif (surface->ext_session_lock_surface_v1 != NULL) {\n\t\text_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);\n\t}\n\tif (surface->surface != NULL) {\n\t\twl_surface_destroy(surface->surface);\n\t}\n\tdestroy_buffer(&surface->buffers[0]);\n\tdestroy_buffer(&surface->buffers[1]);\n\tdestroy_buffer(&surface->indicator_buffers[0]);\n\tdestroy_buffer(&surface->indicator_buffers[1]);\n\twl_output_destroy(surface->output);\n\tfree(surface);\n}\n\nstatic const struct zwlr_layer_surface_v1_listener layer_surface_listener;\nstatic const struct ext_session_lock_surface_v1_listener ext_session_lock_surface_v1_listener;\n\nstatic cairo_surface_t *select_image(struct swaylock_state *state,\n\t\tstruct swaylock_surface *surface);\n\nstatic bool surface_is_opaque(struct swaylock_surface *surface) {\n\tif (surface->image) {\n\t\treturn cairo_surface_get_content(surface->image) == CAIRO_CONTENT_COLOR;\n\t}\n\treturn (surface->state->args.colors.background & 0xff) == 0xff;\n}\n\nstatic void create_surface(struct swaylock_surface *surface) {\n\tstruct swaylock_state *state = surface->state;\n\n\tsurface->image = select_image(state, surface);\n\n\tsurface->surface = wl_compositor_create_surface(state->compositor);\n\tassert(surface->surface);\n\n\tsurface->child = wl_compositor_create_surface(state->compositor);\n\tassert(surface->child);\n\tsurface->subsurface = wl_subcompositor_get_subsurface(state->subcompositor, surface->child, surface->surface);\n\tassert(surface->subsurface);\n\twl_subsurface_set_sync(surface->subsurface);\n\n\tif (state->ext_session_lock_v1) {\n\t\tsurface->ext_session_lock_surface_v1 = ext_session_lock_v1_get_lock_surface(\n\t\t\t\tstate->ext_session_lock_v1, surface->surface, surface->output);\n\t\text_session_lock_surface_v1_add_listener(surface->ext_session_lock_surface_v1,\n\t\t\t\t&ext_session_lock_surface_v1_listener, surface);\n\t} else {\n\t\tsurface->layer_surface = zwlr_layer_shell_v1_get_layer_surface(\n\t\t\t\tstate->layer_shell, surface->surface, surface->output,\n\t\t\t\tZWLR_LAYER_SHELL_V1_LAYER_OVERLAY, \"lockscreen\");\n\n\t\tzwlr_layer_surface_v1_set_size(surface->layer_surface, 0, 0);\n\t\tzwlr_layer_surface_v1_set_anchor(surface->layer_surface,\n\t\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n\t\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |\n\t\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n\t\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);\n\t\tzwlr_layer_surface_v1_set_exclusive_zone(surface->layer_surface, -1);\n\t\tzwlr_layer_surface_v1_set_keyboard_interactivity(\n\t\t\t\tsurface->layer_surface, true);\n\t\tzwlr_layer_surface_v1_add_listener(surface->layer_surface,\n\t\t\t\t&layer_surface_listener, surface);\n\t}\n\n\tif (surface_is_opaque(surface) &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_CENTER &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_FIT) {\n\t\tstruct wl_region *region =\n\t\t\twl_compositor_create_region(surface->state->compositor);\n\t\twl_region_add(region, 0, 0, INT32_MAX, INT32_MAX);\n\t\twl_surface_set_opaque_region(surface->surface, region);\n\t\twl_region_destroy(region);\n\t}\n\n\tif (!state->ext_session_lock_v1) {\n\t\twl_surface_commit(surface->surface);\n\t}\n}\n\nstatic void layer_surface_configure(void *data,\n\t\tstruct zwlr_layer_surface_v1 *layer_surface,\n\t\tuint32_t serial, uint32_t width, uint32_t height) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->width = width;\n\tsurface->height = height;\n\tsurface->indicator_width = 0;\n\tsurface->indicator_height = 0;\n\tzwlr_layer_surface_v1_ack_configure(layer_surface, serial);\n\trender_frame_background(surface);\n\trender_frame(surface);\n}\n\nstatic void layer_surface_closed(void *data,\n\t\tstruct zwlr_layer_surface_v1 *layer_surface) {\n\tstruct swaylock_surface *surface = data;\n\tdestroy_surface(surface);\n}\n\nstatic const struct zwlr_layer_surface_v1_listener layer_surface_listener = {\n\t.configure = layer_surface_configure,\n\t.closed = layer_surface_closed,\n};\n\nstatic void ext_session_lock_surface_v1_handle_configure(void *data,\n\t\tstruct ext_session_lock_surface_v1 *lock_surface, uint32_t serial,\n\t\tuint32_t width, uint32_t height) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->width = width;\n\tsurface->height = height;\n\tsurface->indicator_width = 0;\n\tsurface->indicator_height = 0;\n\text_session_lock_surface_v1_ack_configure(lock_surface, serial);\n\trender_frame_background(surface);\n\trender_frame(surface);\n}\n\nstatic const struct ext_session_lock_surface_v1_listener ext_session_lock_surface_v1_listener = {\n\t.configure = ext_session_lock_surface_v1_handle_configure,\n};\n\nstatic const struct wl_callback_listener surface_frame_listener;\n\nstatic void surface_frame_handle_done(void *data, struct wl_callback *callback,\n\t\tuint32_t time) {\n\tstruct swaylock_surface *surface = data;\n\n\twl_callback_destroy(callback);\n\tsurface->frame_pending = false;\n\n\tif (surface->dirty) {\n\t\t// Schedule a frame in case the surface is damaged again\n\t\tstruct wl_callback *callback = wl_surface_frame(surface->surface);\n\t\twl_callback_add_listener(callback, &surface_frame_listener, surface);\n\t\tsurface->frame_pending = true;\n\n\t\trender_frame(surface);\n\t\tsurface->dirty = false;\n\t}\n}\n\nstatic const struct wl_callback_listener surface_frame_listener = {\n\t.done = surface_frame_handle_done,\n};\n\nvoid damage_surface(struct swaylock_surface *surface) {\n\tsurface->dirty = true;\n\tif (surface->frame_pending) {\n\t\treturn;\n\t}\n\n\tstruct wl_callback *callback = wl_surface_frame(surface->surface);\n\twl_callback_add_listener(callback, &surface_frame_listener, surface);\n\tsurface->frame_pending = true;\n\twl_surface_commit(surface->surface);\n}\n\nvoid damage_state(struct swaylock_state *state) {\n\tstruct swaylock_surface *surface;\n\twl_list_for_each(surface, &state->surfaces, link) {\n\t\tdamage_surface(surface);\n\t}\n}\n\nstatic void handle_wl_output_geometry(void *data, struct wl_output *wl_output,\n\t\tint32_t x, int32_t y, int32_t width_mm, int32_t height_mm,\n\t\tint32_t subpixel, const char *make, const char *model,\n\t\tint32_t transform) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->subpixel = subpixel;\n\tif (surface->state->run_display) {\n\t\tdamage_surface(surface);\n\t}\n}\n\nstatic void handle_wl_output_mode(void *data, struct wl_output *output,\n\t\tuint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n\t// Who cares\n}\n\nstatic void handle_wl_output_done(void *data, struct wl_output *output) {\n\t// Who cares\n}\n\nstatic void handle_wl_output_scale(void *data, struct wl_output *output,\n\t\tint32_t factor) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->scale = factor;\n\tif (surface->state->run_display) {\n\t\tdamage_surface(surface);\n\t}\n}\n\nstruct wl_output_listener _wl_output_listener = {\n\t.geometry = handle_wl_output_geometry,\n\t.mode = handle_wl_output_mode,\n\t.done = handle_wl_output_done,\n\t.scale = handle_wl_output_scale,\n};\n\nstatic void handle_xdg_output_logical_size(void *data, struct zxdg_output_v1 *output,\n\t\tint width, int height) {\n\t// Who cares\n}\n\nstatic void handle_xdg_output_logical_position(void *data,\n\t\tstruct zxdg_output_v1 *output, int x, int y) {\n\t// Who cares\n}\n\nstatic void handle_xdg_output_name(void *data, struct zxdg_output_v1 *output,\n\t\tconst char *name) {\n\tswaylock_log(LOG_DEBUG, \"output name is %s\", name);\n\tstruct swaylock_surface *surface = data;\n\tsurface->xdg_output = output;\n\tsurface->output_name = strdup(name);\n}\n\nstatic void handle_xdg_output_description(void *data, struct zxdg_output_v1 *output,\n\t\tconst char *description) {\n\t// Who cares\n}\n\nstatic void handle_xdg_output_done(void *data, struct zxdg_output_v1 *output) {\n\t// Who cares\n}\n\nstruct zxdg_output_v1_listener _xdg_output_listener = {\n\t.logical_position = handle_xdg_output_logical_position,\n\t.logical_size = handle_xdg_output_logical_size,\n\t.done = handle_xdg_output_done,\n\t.name = handle_xdg_output_name,\n\t.description = handle_xdg_output_description,\n};\n\nstatic void ext_session_lock_v1_handle_locked(void *data, struct ext_session_lock_v1 *lock) {\n\t// Who cares\n}\n\nstatic void ext_session_lock_v1_handle_finished(void *data, struct ext_session_lock_v1 *lock) {\n\tswaylock_log(LOG_ERROR, \"Failed to lock session -- \"\n\t\t\t\"is another lockscreen running?\");\n\texit(2);\n}\n\nstatic const struct ext_session_lock_v1_listener ext_session_lock_v1_listener = {\n\t.locked = ext_session_lock_v1_handle_locked,\n\t.finished = ext_session_lock_v1_handle_finished,\n};\n\nstatic void handle_global(void *data, struct wl_registry *registry,\n\t\tuint32_t name, const char *interface, uint32_t version) {\n\tstruct swaylock_state *state = data;\n\tif (strcmp(interface, wl_compositor_interface.name) == 0) {\n\t\tstate->compositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_compositor_interface, 4);\n\t} else if (strcmp(interface, wl_subcompositor_interface.name) == 0) {\n\t\tstate->subcompositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_subcompositor_interface, 1);\n\t} else if (strcmp(interface, wl_shm_interface.name) == 0) {\n\t\tstate->shm = wl_registry_bind(registry, name,\n\t\t\t\t&wl_shm_interface, 1);\n\t} else if (strcmp(interface, wl_seat_interface.name) == 0) {\n\t\tstruct wl_seat *seat = wl_registry_bind(\n\t\t\t\tregistry, name, &wl_seat_interface, 4);\n\t\tstruct swaylock_seat *swaylock_seat =\n\t\t\tcalloc(1, sizeof(struct swaylock_seat));\n\t\tswaylock_seat->state = state;\n\t\twl_seat_add_listener(seat, &seat_listener, swaylock_seat);\n\t} else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) {\n\t\tstate->layer_shell = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_layer_shell_v1_interface, 1);\n\t} else if (strcmp(interface, zwlr_input_inhibit_manager_v1_interface.name) == 0) {\n\t\tstate->input_inhibit_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_input_inhibit_manager_v1_interface, 1);\n\t} else if (strcmp(interface, zxdg_output_manager_v1_interface.name) == 0) {\n\t\tstate->zxdg_output_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zxdg_output_manager_v1_interface, 2);\n\t} else if (strcmp(interface, wl_output_interface.name) == 0) {\n\t\tstruct swaylock_surface *surface =\n\t\t\tcalloc(1, sizeof(struct swaylock_surface));\n\t\tsurface->state = state;\n\t\tsurface->output = wl_registry_bind(registry, name,\n\t\t\t\t&wl_output_interface, 3);\n\t\tsurface->output_global_name = name;\n\t\twl_output_add_listener(surface->output, &_wl_output_listener, surface);\n\t\twl_list_insert(&state->surfaces, &surface->link);\n\n\t\tif (state->run_display) {\n\t\t\tcreate_surface(surface);\n\t\t\twl_display_roundtrip(state->display);\n\t\t}\n\t} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {\n\t\tstate->ext_session_lock_manager_v1 = wl_registry_bind(registry, name,\n\t\t\t\t&ext_session_lock_manager_v1_interface, 1);\n\t}\n}\n\nstatic void handle_global_remove(void *data, struct wl_registry *registry,\n\t\tuint32_t name) {\n\tstruct swaylock_state *state = data;\n\tstruct swaylock_surface *surface;\n\twl_list_for_each(surface, &state->surfaces, link) {\n\t\tif (surface->output_global_name == name) {\n\t\t\tdestroy_surface(surface);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic const struct wl_registry_listener registry_listener = {\n\t.global = handle_global,\n\t.global_remove = handle_global_remove,\n};\n\nstatic cairo_surface_t *select_image(struct swaylock_state *state,\n\t\tstruct swaylock_surface *surface) {\n\tstruct swaylock_image *image;\n\tcairo_surface_t *default_image = NULL;\n\twl_list_for_each(image, &state->images, link) {\n\t\tif (lenient_strcmp(image->output_name, surface->output_name) == 0) {\n\t\t\treturn image->cairo_surface;\n\t\t} else if (!image->output_name) {\n\t\t\tdefault_image = image->cairo_surface;\n\t\t}\n\t}\n\treturn default_image;\n}\n\nstatic char *join_args(char **argv, int argc) {\n\tassert(argc > 0);\n\tint len = 0, i;\n\tfor (i = 0; i < argc; ++i) {\n\t\tlen += strlen(argv[i]) + 1;\n\t}\n\tchar *res = malloc(len);\n\tlen = 0;\n\tfor (i = 0; i < argc; ++i) {\n\t\tstrcpy(res + len, argv[i]);\n\t\tlen += strlen(argv[i]);\n\t\tres[len++] = ' ';\n\t}\n\tres[len - 1] = '\\0';\n\treturn res;\n}\n\nstatic void load_image(char *arg, struct swaylock_state *state) {\n\t// [[<output>]:]<path>\n\tstruct swaylock_image *image = calloc(1, sizeof(struct swaylock_image));\n\tchar *separator = strchr(arg, ':');\n\tif (separator) {\n\t\t*separator = '\\0';\n\t\timage->output_name = separator == arg ? NULL : strdup(arg);\n\t\timage->path = strdup(separator + 1);\n\t} else {\n\t\timage->output_name = NULL;\n\t\timage->path = strdup(arg);\n\t}\n\n\tstruct swaylock_image *iter_image, *temp;\n\twl_list_for_each_safe(iter_image, temp, &state->images, link) {\n\t\tif (lenient_strcmp(iter_image->output_name, image->output_name) == 0) {\n\t\t\tif (image->output_name) {\n\t\t\t\tswaylock_log(LOG_DEBUG,\n\t\t\t\t\t\t\"Replacing image defined for output %s with %s\",\n\t\t\t\t\t\timage->output_name, image->path);\n\t\t\t} else {\n\t\t\t\tswaylock_log(LOG_DEBUG, \"Replacing default image with %s\",\n\t\t\t\t\t\timage->path);\n\t\t\t}\n\t\t\twl_list_remove(&iter_image->link);\n\t\t\tfree(iter_image->cairo_surface);\n\t\t\tfree(iter_image->output_name);\n\t\t\tfree(iter_image->path);\n\t\t\tfree(iter_image);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// The shell will not expand ~ to the value of $HOME when an output name is\n\t// given. Also, any image paths given in the config file need to have shell\n\t// expansions performed\n\twordexp_t p;\n\twhile (strstr(image->path, \"  \")) {\n\t\timage->path = realloc(image->path, strlen(image->path) + 2);\n\t\tchar *ptr = strstr(image->path, \"  \") + 1;\n\t\tmemmove(ptr + 1, ptr, strlen(ptr) + 1);\n\t\t*ptr = '\\\\';\n\t}\n\tif (wordexp(image->path, &p, 0) == 0) {\n\t\tfree(image->path);\n\t\timage->path = join_args(p.we_wordv, p.we_wordc);\n\t\twordfree(&p);\n\t}\n\n\t// Load the actual image\n\timage->cairo_surface = load_background_image(image->path);\n\tif (!image->cairo_surface) {\n\t\tfree(image);\n\t\treturn;\n\t}\n\twl_list_insert(&state->images, &image->link);\n\tswaylock_log(LOG_DEBUG, \"Loaded image %s for output %s\", image->path,\n\t\t\timage->output_name ? image->output_name : \"*\");\n}\n\nstatic void set_default_colors(struct swaylock_colors *colors) {\n\tcolors->background = 0xFFFFFFFF;\n\tcolors->bs_highlight = 0xDB3300FF;\n\tcolors->key_highlight = 0x33DB00FF;\n\tcolors->caps_lock_bs_highlight = 0xDB3300FF;\n\tcolors->caps_lock_key_highlight = 0x33DB00FF;\n\tcolors->separator = 0x000000FF;\n\tcolors->layout_background = 0x000000C0;\n\tcolors->layout_border = 0x00000000;\n\tcolors->layout_text = 0xFFFFFFFF;\n\tcolors->inside = (struct swaylock_colorset){\n\t\t.input = 0x000000C0,\n\t\t.cleared = 0xE5A445C0,\n\t\t.caps_lock = 0x000000C0,\n\t\t.verifying = 0x0072FFC0,\n\t\t.wrong = 0xFA0000C0,\n\t};\n\tcolors->line = (struct swaylock_colorset){\n\t\t.input = 0x000000FF,\n\t\t.cleared = 0x000000FF,\n\t\t.caps_lock = 0x000000FF,\n\t\t.verifying = 0x000000FF,\n\t\t.wrong = 0x000000FF,\n\t};\n\tcolors->ring = (struct swaylock_colorset){\n\t\t.input = 0x337D00FF,\n\t\t.cleared = 0xE5A445FF,\n\t\t.caps_lock = 0xE5A445FF,\n\t\t.verifying = 0x3300FFFF,\n\t\t.wrong = 0x7D3300FF,\n\t};\n\tcolors->text = (struct swaylock_colorset){\n\t\t.input = 0xE5A445FF,\n\t\t.cleared = 0x000000FF,\n\t\t.caps_lock = 0xE5A445FF,\n\t\t.verifying = 0x000000FF,\n\t\t.wrong = 0x000000FF,\n\t};\n}\n\nenum line_mode {\n\tLM_LINE,\n\tLM_INSIDE,\n\tLM_RING,\n};\n\nstatic int parse_options(int argc, char **argv, struct swaylock_state *state,\n\t\tenum line_mode *line_mode, char **config_path) {\n\tenum long_option_codes {\n\t\tLO_BS_HL_COLOR = 256,\n\t\tLO_CAPS_LOCK_BS_HL_COLOR,\n\t\tLO_CAPS_LOCK_KEY_HL_COLOR,\n\t\tLO_FONT,\n\t\tLO_FONT_SIZE,\n\t\tLO_IND_IDLE_VISIBLE,\n\t\tLO_IND_RADIUS,\n\t\tLO_IND_X_POSITION,\n\t\tLO_IND_Y_POSITION,\n\t\tLO_IND_THICKNESS,\n\t\tLO_INSIDE_COLOR,\n\t\tLO_INSIDE_CLEAR_COLOR,\n\t\tLO_INSIDE_CAPS_LOCK_COLOR,\n\t\tLO_INSIDE_VER_COLOR,\n\t\tLO_INSIDE_WRONG_COLOR,\n\t\tLO_KEY_HL_COLOR,\n\t\tLO_LAYOUT_TXT_COLOR,\n\t\tLO_LAYOUT_BG_COLOR,\n\t\tLO_LAYOUT_BORDER_COLOR,\n\t\tLO_LINE_COLOR,\n\t\tLO_LINE_CLEAR_COLOR,\n\t\tLO_LINE_CAPS_LOCK_COLOR,\n\t\tLO_LINE_VER_COLOR,\n\t\tLO_LINE_WRONG_COLOR,\n\t\tLO_RING_COLOR,\n\t\tLO_RING_CLEAR_COLOR,\n\t\tLO_RING_CAPS_LOCK_COLOR,\n\t\tLO_RING_VER_COLOR,\n\t\tLO_RING_WRONG_COLOR,\n\t\tLO_SEP_COLOR,\n\t\tLO_TEXT_COLOR,\n\t\tLO_TEXT_CLEAR_COLOR,\n\t\tLO_TEXT_CAPS_LOCK_COLOR,\n\t\tLO_TEXT_VER_COLOR,\n\t\tLO_TEXT_WRONG_COLOR,\n\t};\n\n\tstatic struct option long_options[] = {\n\t\t{\"config\", required_argument, NULL, 'C'},\n\t\t{\"color\", required_argument, NULL, 'c'},\n\t\t{\"debug\", no_argument, NULL, 'd'},\n\t\t{\"ignore-empty-password\", no_argument, NULL, 'e'},\n\t\t{\"daemonize\", no_argument, NULL, 'f'},\n\t\t{\"help\", no_argument, NULL, 'h'},\n\t\t{\"image\", required_argument, NULL, 'i'},\n\t\t{\"disable-caps-lock-text\", no_argument, NULL, 'L'},\n\t\t{\"indicator-caps-lock\", no_argument, NULL, 'l'},\n\t\t{\"line-uses-inside\", no_argument, NULL, 'n'},\n\t\t{\"line-uses-ring\", no_argument, NULL, 'r'},\n\t\t{\"scaling\", required_argument, NULL, 's'},\n\t\t{\"tiling\", no_argument, NULL, 't'},\n\t\t{\"no-unlock-indicator\", no_argument, NULL, 'u'},\n\t\t{\"show-keyboard-layout\", no_argument, NULL, 'k'},\n\t\t{\"hide-keyboard-layout\", no_argument, NULL, 'K'},\n\t\t{\"show-failed-attempts\", no_argument, NULL, 'F'},\n\t\t{\"version\", no_argument, NULL, 'v'},\n\t\t{\"bs-hl-color\", required_argument, NULL, LO_BS_HL_COLOR},\n\t\t{\"caps-lock-bs-hl-color\", required_argument, NULL, LO_CAPS_LOCK_BS_HL_COLOR},\n\t\t{\"caps-lock-key-hl-color\", required_argument, NULL, LO_CAPS_LOCK_KEY_HL_COLOR},\n\t\t{\"font\", required_argument, NULL, LO_FONT},\n\t\t{\"font-size\", required_argument, NULL, LO_FONT_SIZE},\n\t\t{\"indicator-idle-visible\", no_argument, NULL, LO_IND_IDLE_VISIBLE},\n\t\t{\"indicator-radius\", required_argument, NULL, LO_IND_RADIUS},\n\t\t{\"indicator-thickness\", required_argument, NULL, LO_IND_THICKNESS},\n\t\t{\"indicator-x-position\", required_argument, NULL, LO_IND_X_POSITION},\n\t\t{\"indicator-y-position\", required_argument, NULL, LO_IND_Y_POSITION},\n\t\t{\"inside-color\", required_argument, NULL, LO_INSIDE_COLOR},\n\t\t{\"inside-clear-color\", required_argument, NULL, LO_INSIDE_CLEAR_COLOR},\n\t\t{\"inside-caps-lock-color\", required_argument, NULL, LO_INSIDE_CAPS_LOCK_COLOR},\n\t\t{\"inside-ver-color\", required_argument, NULL, LO_INSIDE_VER_COLOR},\n\t\t{\"inside-wrong-color\", required_argument, NULL, LO_INSIDE_WRONG_COLOR},\n\t\t{\"key-hl-color\", required_argument, NULL, LO_KEY_HL_COLOR},\n\t\t{\"layout-bg-color\", required_argument, NULL, LO_LAYOUT_BG_COLOR},\n\t\t{\"layout-border-color\", required_argument, NULL, LO_LAYOUT_BORDER_COLOR},\n\t\t{\"layout-text-color\", required_argument, NULL, LO_LAYOUT_TXT_COLOR},\n\t\t{\"line-color\", required_argument, NULL, LO_LINE_COLOR},\n\t\t{\"line-clear-color\", required_argument, NULL, LO_LINE_CLEAR_COLOR},\n\t\t{\"line-caps-lock-color\", required_argument, NULL, LO_LINE_CAPS_LOCK_COLOR},\n\t\t{\"line-ver-color\", required_argument, NULL, LO_LINE_VER_COLOR},\n\t\t{\"line-wrong-color\", required_argument, NULL, LO_LINE_WRONG_COLOR},\n\t\t{\"ring-color\", required_argument, NULL, LO_RING_COLOR},\n\t\t{\"ring-clear-color\", required_argument, NULL, LO_RING_CLEAR_COLOR},\n\t\t{\"ring-caps-lock-color\", required_argument, NULL, LO_RING_CAPS_LOCK_COLOR},\n\t\t{\"ring-ver-color\", required_argument, NULL, LO_RING_VER_COLOR},\n\t\t{\"ring-wrong-color\", required_argument, NULL, LO_RING_WRONG_COLOR},\n\t\t{\"separator-color\", required_argument, NULL, LO_SEP_COLOR},\n\t\t{\"text-color\", required_argument, NULL, LO_TEXT_COLOR},\n\t\t{\"text-clear-color\", required_argument, NULL, LO_TEXT_CLEAR_COLOR},\n\t\t{\"text-caps-lock-color\", required_argument, NULL, LO_TEXT_CAPS_LOCK_COLOR},\n\t\t{\"text-ver-color\", required_argument, NULL, LO_TEXT_VER_COLOR},\n\t\t{\"text-wrong-color\", required_argument, NULL, LO_TEXT_WRONG_COLOR},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tconst char usage[] =\n\t\t\"Usage: swaylock [options...]\\n\"\n\t\t\"\\n\"\n\t\t\"  -C, --config <config_file>       \"\n\t\t\t\"Path to the config file.\\n\"\n\t\t\"  -c, --color <color>              \"\n\t\t\t\"Turn the screen into the given color instead of white.\\n\"\n\t\t\"  -d, --debug                      \"\n\t\t\t\"Enable debugging output.\\n\"\n\t\t\"  -e, --ignore-empty-password      \"\n\t\t\t\"When an empty password is provided, do not validate it.\\n\"\n\t\t\"  -F, --show-failed-attempts       \"\n\t\t\t\"Show current count of failed authentication attempts.\\n\"\n\t\t\"  -f, --daemonize                  \"\n\t\t\t\"Detach from the controlling terminal after locking.\\n\"\n\t\t\"  -h, --help                       \"\n\t\t\t\"Show help message and quit.\\n\"\n\t\t\"  -i, --image [[<output>]:]<path>  \"\n\t\t\t\"Display the given image, optionally only on the given output.\\n\"\n\t\t\"  -k, --show-keyboard-layout       \"\n\t\t\t\"Display the current xkb layout while typing.\\n\"\n\t\t\"  -K, --hide-keyboard-layout       \"\n\t\t\t\"Hide the current xkb layout while typing.\\n\"\n\t\t\"  -L, --disable-caps-lock-text     \"\n\t\t\t\"Disable the Caps Lock text.\\n\"\n\t\t\"  -l, --indicator-caps-lock        \"\n\t\t\t\"Show the current Caps Lock state also on the indicator.\\n\"\n\t\t\"  -s, --scaling <mode>             \"\n\t\t\t\"Image scaling mode: stretch, fill, fit, center, tile, solid_color.\\n\"\n\t\t\"  -t, --tiling                     \"\n\t\t\t\"Same as --scaling=tile.\\n\"\n\t\t\"  -u, --no-unlock-indicator        \"\n\t\t\t\"Disable the unlock indicator.\\n\"\n\t\t\"  -v, --version                    \"\n\t\t\t\"Show the version number and quit.\\n\"\n\t\t\"  --bs-hl-color <color>            \"\n\t\t\t\"Sets the color of backspace highlight segments.\\n\"\n\t\t\"  --caps-lock-bs-hl-color <color>  \"\n\t\t\t\"Sets the color of backspace highlight segments when Caps Lock \"\n\t\t\t\"is active.\\n\"\n\t\t\"  --caps-lock-key-hl-color <color> \"\n\t\t\t\"Sets the color of the key press highlight segments when \"\n\t\t\t\"Caps Lock is active.\\n\"\n\t\t\"  --font <font>                    \"\n\t\t\t\"Sets the font of the text.\\n\"\n\t\t\"  --font-size <size>               \"\n\t\t\t\"Sets a fixed font size for the indicator text.\\n\"\n\t\t\"  --indicator-idle-visible         \"\n\t\t\t\"Sets the indicator to show even if idle.\\n\"\n\t\t\"  --indicator-radius <radius>      \"\n\t\t\t\"Sets the indicator radius.\\n\"\n\t\t\"  --indicator-thickness <thick>    \"\n\t\t\t\"Sets the indicator thickness.\\n\"\n\t\t\"  --indicator-x-position <x>       \"\n\t\t\t\"Sets the horizontal position of the indicator.\\n\"\n\t\t\"  --indicator-y-position <y>       \"\n\t\t\t\"Sets the vertical position of the indicator.\\n\"\n\t\t\"  --inside-color <color>           \"\n\t\t\t\"Sets the color of the inside of the indicator.\\n\"\n\t\t\"  --inside-clear-color <color>     \"\n\t\t\t\"Sets the color of the inside of the indicator when cleared.\\n\"\n\t\t\"  --inside-caps-lock-color <color> \"\n\t\t\t\"Sets the color of the inside of the indicator when Caps Lock \"\n\t\t\t\"is active.\\n\"\n\t\t\"  --inside-ver-color <color>       \"\n\t\t\t\"Sets the color of the inside of the indicator when verifying.\\n\"\n\t\t\"  --inside-wrong-color <color>     \"\n\t\t\t\"Sets the color of the inside of the indicator when invalid.\\n\"\n\t\t\"  --key-hl-color <color>           \"\n\t\t\t\"Sets the color of the key press highlight segments.\\n\"\n\t\t\"  --layout-bg-color <color>        \"\n\t\t\t\"Sets the background color of the box containing the layout text.\\n\"\n\t\t\"  --layout-border-color <color>    \"\n\t\t\t\"Sets the color of the border of the box containing the layout text.\\n\"\n\t\t\"  --layout-text-color <color>      \"\n\t\t\t\"Sets the color of the layout text.\\n\"\n\t\t\"  --line-color <color>             \"\n\t\t\t\"Sets the color of the line between the inside and ring.\\n\"\n\t\t\"  --line-clear-color <color>       \"\n\t\t\t\"Sets the color of the line between the inside and ring when \"\n\t\t\t\"cleared.\\n\"\n\t\t\"  --line-caps-lock-color <color>   \"\n\t\t\t\"Sets the color of the line between the inside and ring when \"\n\t\t\t\"Caps Lock is active.\\n\"\n\t\t\"  --line-ver-color <color>         \"\n\t\t\t\"Sets the color of the line between the inside and ring when \"\n\t\t\t\"verifying.\\n\"\n\t\t\"  --line-wrong-color <color>       \"\n\t\t\t\"Sets the color of the line between the inside and ring when \"\n\t\t\t\"invalid.\\n\"\n\t\t\"  -n, --line-uses-inside           \"\n\t\t\t\"Use the inside color for the line between the inside and ring.\\n\"\n\t\t\"  -r, --line-uses-ring             \"\n\t\t\t\"Use the ring color for the line between the inside and ring.\\n\"\n\t\t\"  --ring-color <color>             \"\n\t\t\t\"Sets the color of the ring of the indicator.\\n\"\n\t\t\"  --ring-clear-color <color>       \"\n\t\t\t\"Sets the color of the ring of the indicator when cleared.\\n\"\n\t\t\"  --ring-caps-lock-color <color>   \"\n\t\t\t\"Sets the color of the ring of the indicator when Caps Lock \"\n\t\t\t\"is active.\\n\"\n\t\t\"  --ring-ver-color <color>         \"\n\t\t\t\"Sets the color of the ring of the indicator when verifying.\\n\"\n\t\t\"  --ring-wrong-color <color>       \"\n\t\t\t\"Sets the color of the ring of the indicator when invalid.\\n\"\n\t\t\"  --separator-color <color>        \"\n\t\t\t\"Sets the color of the lines that separate highlight segments.\\n\"\n\t\t\"  --text-color <color>             \"\n\t\t\t\"Sets the color of the text.\\n\"\n\t\t\"  --text-clear-color <color>       \"\n\t\t\t\"Sets the color of the text when cleared.\\n\"\n\t\t\"  --text-caps-lock-color <color>   \"\n\t\t\t\"Sets the color of the text when Caps Lock is active.\\n\"\n\t\t\"  --text-ver-color <color>         \"\n\t\t\t\"Sets the color of the text when verifying.\\n\"\n\t\t\"  --text-wrong-color <color>       \"\n\t\t\t\"Sets the color of the text when invalid.\\n\"\n\t\t\"\\n\"\n\t\t\"All <color> options are of the form <rrggbb[aa]>.\\n\";\n\n\tint c;\n\toptind = 1;\n\twhile (1) {\n\t\tint opt_idx = 0;\n\t\tc = getopt_long(argc, argv, \"c:deFfhi:kKLlnrs:tuvC:\", long_options,\n\t\t\t\t&opt_idx);\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tif (config_path) {\n\t\t\t\t*config_path = strdup(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.background = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tswaylock_log_init(LOG_DEBUG);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (state) {\n\t\t\t\tstate->args.ignore_empty = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_failed_attempts = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (state) {\n\t\t\t\tstate->args.daemonize = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (state) {\n\t\t\t\tload_image(optarg, state);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_keyboard_layout = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tif (state) {\n\t\t\t\tstate->args.hide_keyboard_layout = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_caps_lock_text = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_caps_lock_indicator = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (line_mode) {\n\t\t\t\t*line_mode = LM_INSIDE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (line_mode) {\n\t\t\t\t*line_mode = LM_RING;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (state) {\n\t\t\t\tstate->args.mode = parse_background_mode(optarg);\n\t\t\t\tif (state->args.mode == BACKGROUND_MODE_INVALID) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (state) {\n\t\t\t\tstate->args.mode = BACKGROUND_MODE_TILE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (state) {\n\t\t\t\tstate->args.show_indicator = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tfprintf(stdout, \"swaylock version \" SWAYLOCK_VERSION \"\\n\");\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase LO_BS_HL_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.bs_highlight = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_CAPS_LOCK_BS_HL_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.caps_lock_bs_highlight = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_CAPS_LOCK_KEY_HL_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.caps_lock_key_highlight = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_FONT:\n\t\t\tif (state) {\n\t\t\t\tfree(state->args.font);\n\t\t\t\tstate->args.font = strdup(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_FONT_SIZE:\n\t\t\tif (state) {\n\t\t\t\tstate->args.font_size = atoi(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_IDLE_VISIBLE:\n\t\t\tif (state) {\n\t\t\t\tstate->args.indicator_idle_visible = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_RADIUS:\n\t\t\tif (state) {\n\t\t\t\tstate->args.radius = strtol(optarg, NULL, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_THICKNESS:\n\t\t\tif (state) {\n\t\t\t\tstate->args.thickness = strtol(optarg, NULL, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_X_POSITION:\n\t\t\tif (state) {\n\t\t\t\tstate->args.override_indicator_x_position = true;\n\t\t\t\tstate->args.indicator_x_position = atoi(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_IND_Y_POSITION:\n\t\t\tif (state) {\n\t\t\t\tstate->args.override_indicator_y_position = true;\n\t\t\t\tstate->args.indicator_y_position = atoi(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.input = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_CLEAR_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.cleared = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_CAPS_LOCK_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.caps_lock = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_VER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.verifying = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_INSIDE_WRONG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.inside.wrong = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_KEY_HL_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.key_highlight = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LAYOUT_BG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.layout_background = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LAYOUT_BORDER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.layout_border = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LAYOUT_TXT_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.layout_text = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.input = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_CLEAR_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.cleared = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_CAPS_LOCK_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.caps_lock = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_VER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.verifying = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_LINE_WRONG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.line.wrong = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.input = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_CLEAR_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.cleared = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_CAPS_LOCK_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.caps_lock = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_VER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.verifying = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_RING_WRONG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.ring.wrong = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_SEP_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.separator = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.input = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_CLEAR_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.cleared = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_CAPS_LOCK_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.caps_lock = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_VER_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.verifying = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LO_TEXT_WRONG_COLOR:\n\t\t\tif (state) {\n\t\t\t\tstate->args.colors.text.wrong = parse_color(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"%s\", usage);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool file_exists(const char *path) {\n\treturn path && access(path, R_OK) != -1;\n}\n\nstatic char *get_config_path(void) {\n\tstatic const char *config_paths[] = {\n\t\t\"$HOME/.swaylock/config\",\n\t\t\"$XDG_CONFIG_HOME/swaylock/config\",\n\t\tSYSCONFDIR \"/swaylock/config\",\n\t};\n\n\tchar *config_home = getenv(\"XDG_CONFIG_HOME\");\n\tif (!config_home || config_home[0] == '\\0') {\n\t\tconfig_paths[1] = \"$HOME/.config/swaylock/config\";\n\t}\n\n\twordexp_t p;\n\tchar *path;\n\tfor (size_t i = 0; i < sizeof(config_paths) / sizeof(char *); ++i) {\n\t\tif (wordexp(config_paths[i], &p, 0) == 0) {\n\t\t\tpath = strdup(p.we_wordv[0]);\n\t\t\twordfree(&p);\n\t\t\tif (file_exists(path)) {\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tfree(path);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int load_config(char *path, struct swaylock_state *state,\n\t\tenum line_mode *line_mode) {\n\tFILE *config = fopen(path, \"r\");\n\tif (!config) {\n\t\tswaylock_log(LOG_ERROR, \"Failed to read config. Running without it.\");\n\t\treturn 0;\n\t}\n\tchar *line = NULL;\n\tsize_t line_size = 0;\n\tssize_t nread;\n\tint line_number = 0;\n\tint result = 0;\n\twhile ((nread = getline(&line, &line_size, config)) != -1) {\n\t\tline_number++;\n\n\t\tif (line[nread - 1] == '\\n') {\n\t\t\tline[--nread] = '\\0';\n\t\t}\n\n\t\tif (!*line || line[0] == '#') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswaylock_log(LOG_DEBUG, \"Config Line #%d: %s\", line_number, line);\n\t\tchar *flag = malloc(nread + 3);\n\t\tif (flag == NULL) {\n\t\t\tfree(line);\n\t\t\tfclose(config);\n\t\t\tswaylock_log(LOG_ERROR, \"Failed to allocate memory\");\n\t\t\treturn 0;\n\t\t}\n\t\tsprintf(flag, \"--%s\", line);\n\t\tchar *argv[] = {\"swaylock\", flag};\n\t\tresult = parse_options(2, argv, state, line_mode, NULL);\n\t\tfree(flag);\n\t\tif (result != 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(line);\n\tfclose(config);\n\treturn 0;\n}\n\nstatic struct swaylock_state state;\n\nstatic void display_in(int fd, short mask, void *data) {\n\tif (wl_display_dispatch(state.display) == -1) {\n\t\tstate.run_display = false;\n\t}\n}\n\nstatic void comm_in(int fd, short mask, void *data) {\n\tif (read_comm_reply()) {\n\t\t// Authentication succeeded\n\t\tstate.run_display = false;\n\t} else {\n\t\tstate.auth_state = AUTH_STATE_INVALID;\n\t\tschedule_indicator_clear(&state);\n\t\t++state.failed_attempts;\n\t\tdamage_state(&state);\n\t}\n}\n\nint main(int argc, char **argv) {\n\tswaylock_log_init(LOG_ERROR);\n\tinitialize_pw_backend(argc, argv);\n\tsrand(time(NULL));\n\n\tenum line_mode line_mode = LM_LINE;\n\tstate.failed_attempts = 0;\n\tstate.args = (struct swaylock_args){\n\t\t.mode = BACKGROUND_MODE_FILL,\n\t\t.font = strdup(\"sans-serif\"),\n\t\t.font_size = 0,\n\t\t.radius = 50,\n\t\t.thickness = 10,\n\t\t.indicator_x_position = 0,\n\t\t.indicator_y_position = 0,\n\t\t.override_indicator_x_position = false,\n\t\t.override_indicator_y_position = false,\n\t\t.ignore_empty = false,\n\t\t.show_indicator = true,\n\t\t.show_caps_lock_indicator = false,\n\t\t.show_caps_lock_text = true,\n\t\t.show_keyboard_layout = false,\n\t\t.hide_keyboard_layout = false,\n\t\t.show_failed_attempts = false,\n\t\t.indicator_idle_visible = false\n\t};\n\twl_list_init(&state.images);\n\tset_default_colors(&state.args.colors);\n\n\tchar *config_path = NULL;\n\tint result = parse_options(argc, argv, NULL, NULL, &config_path);\n\tif (result != 0) {\n\t\tfree(config_path);\n\t\treturn result;\n\t}\n\tif (!config_path) {\n\t\tconfig_path = get_config_path();\n\t}\n\n\tif (config_path) {\n\t\tswaylock_log(LOG_DEBUG, \"Found config at %s\", config_path);\n\t\tint config_status = load_config(config_path, &state, &line_mode);\n\t\tfree(config_path);\n\t\tif (config_status != 0) {\n\t\t\tfree(state.args.font);\n\t\t\treturn config_status;\n\t\t}\n\t}\n\n\tif (argc > 1) {\n\t\tswaylock_log(LOG_DEBUG, \"Parsing CLI Args\");\n\t\tint result = parse_options(argc, argv, &state, &line_mode, NULL);\n\t\tif (result != 0) {\n\t\t\tfree(state.args.font);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (line_mode == LM_INSIDE) {\n\t\tstate.args.colors.line = state.args.colors.inside;\n\t} else if (line_mode == LM_RING) {\n\t\tstate.args.colors.line = state.args.colors.ring;\n\t}\n\n#ifdef __linux__\n\t// Most non-linux platforms require root to mlock()\n\tif (mlock(state.password.buffer, sizeof(state.password.buffer)) != 0) {\n\t\tswaylock_log(LOG_ERROR, \"Unable to mlock() password memory.\");\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\n\twl_list_init(&state.surfaces);\n\tstate.xkb.context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);\n\tstate.display = wl_display_connect(NULL);\n\tif (!state.display) {\n\t\tfree(state.args.font);\n\t\tswaylock_log(LOG_ERROR, \"Unable to connect to the compositor. \"\n\t\t\t\t\"If your compositor is running, check or set the \"\n\t\t\t\t\"WAYLAND_DISPLAY environment variable.\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tstruct wl_registry *registry = wl_display_get_registry(state.display);\n\twl_registry_add_listener(registry, &registry_listener, &state);\n\twl_display_roundtrip(state.display);\n\n\tif (!state.compositor || !state.shm) {\n\t\tswaylock_log(LOG_ERROR, \"Missing wl_compositor or wl_shm\");\n\t\treturn 1;\n\t}\n\n\tif (state.ext_session_lock_manager_v1) {\n\t\tswaylock_log(LOG_DEBUG, \"Using ext-session-lock-v1\");\n\t\tstate.ext_session_lock_v1 = ext_session_lock_manager_v1_lock(state.ext_session_lock_manager_v1);\n\t\text_session_lock_v1_add_listener(state.ext_session_lock_v1,\n\t\t\t\t&ext_session_lock_v1_listener, &state);\n\t} else if (state.layer_shell && state.input_inhibit_manager) {\n\t\tswaylock_log(LOG_DEBUG, \"Using wlr-layer-shell + wlr-input-inhibitor\");\n\t\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);\n\t} else {\n\t\tswaylock_log(LOG_ERROR, \"Missing ext-session-lock-v1, wlr-layer-shell \"\n\t\t\t\t\"and wlr-input-inhibitor\");\n\t\treturn 1;\n\t}\n\n\tif (wl_display_roundtrip(state.display) == -1) {\n\t\tfree(state.args.font);\n\t\tif (state.input_inhibit_manager) {\n\t\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"\n\t\t\t\t\t\" is another lockscreen already running?\");\n\t\t\treturn 2;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (state.zxdg_output_manager) {\n\t\tstruct swaylock_surface *surface;\n\t\twl_list_for_each(surface, &state.surfaces, link) {\n\t\t\tsurface->xdg_output = zxdg_output_manager_v1_get_xdg_output(\n\t\t\t\t\t\tstate.zxdg_output_manager, surface->output);\n\t\t\tzxdg_output_v1_add_listener(\n\t\t\t\t\tsurface->xdg_output, &_xdg_output_listener, surface);\n\t\t}\n\t\twl_display_roundtrip(state.display);\n\t} else {\n\t\tswaylock_log(LOG_INFO, \"Compositor does not support zxdg output \"\n\t\t\t\t\"manager, images assigned to named outputs will not work\");\n\t}\n\n\tstruct swaylock_surface *surface;\n\twl_list_for_each(surface, &state.surfaces, link) {\n\t\tcreate_surface(surface);\n\t}\n\n\tif (state.args.daemonize) {\n\t\twl_display_roundtrip(state.display);\n\t\tdaemonize();\n\t}\n\n\tstate.eventloop = loop_create();\n\tloop_add_fd(state.eventloop, wl_display_get_fd(state.display), POLLIN,\n\t\t\tdisplay_in, NULL);\n\n\tloop_add_fd(state.eventloop, get_comm_reply_fd(), POLLIN, comm_in, NULL);\n\n\tstate.run_display = true;\n\twhile (state.run_display) {\n\t\terrno = 0;\n\t\tif (wl_display_flush(state.display) == -1 && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t\tloop_poll(state.eventloop);\n\t}\n\n\tif (state.ext_session_lock_v1) {\n\t\text_session_lock_v1_unlock_and_destroy(state.ext_session_lock_v1);\n\t\twl_display_flush(state.display);\n\t}\n\n\tfree(state.args.font);\n\treturn 0;\n}\n", "project(\n\t'swaylock',\n\t'c',\n\tversion: '1.6',\n\tlicense: 'MIT',\n\tmeson_version: '>=0.58.0',\n\tdefault_options: [\n\t\t'c_std=c11',\n\t\t'warning_level=2',\n\t\t'werror=true',\n\t],\n)\n\nadd_project_arguments(\n\t[\n\t\t'-Wno-unused-parameter',\n\t\t'-Wno-unused-result',\n\t\t'-Wundef',\n\t\t'-Wvla',\n\t],\n\tlanguage: 'c',\n)\n\ncc = meson.get_compiler('c')\n\nsysconfdir = get_option('sysconfdir')\nprefix = get_option('prefix')\nis_freebsd = host_machine.system().startswith('freebsd')\n\nadd_project_arguments(\n\t'-DSYSCONFDIR=\"/@0@\"'.format(join_paths(prefix, sysconfdir)),\n\tlanguage : 'c')\n\nif is_freebsd\n\tadd_project_arguments('-D_C11_SOURCE', language: 'c')\nendif\n\nwayland_client = dependency('wayland-client')\nwayland_protos = dependency('wayland-protocols', version: '>=1.25', fallback: 'wayland-protocols')\nxkbcommon      = dependency('xkbcommon')\ncairo          = dependency('cairo')\ngdk_pixbuf     = dependency('gdk-pixbuf-2.0', required: get_option('gdk-pixbuf'))\nbash_comp      = dependency('bash-completion', required: false)\nfish_comp      = dependency('fish', required: false)\nlibpam         = cc.find_library('pam', required: get_option('pam'))\ncrypt          = cc.find_library('crypt', required: not libpam.found())\nmath           = cc.find_library('m')\n\ngit = find_program('git', required: false)\nscdoc = find_program('scdoc', required: get_option('man-pages'))\nwayland_scanner = find_program('wayland-scanner')\n\nversion = '\"@0@\"'.format(meson.project_version())\nif git.found()\n\tgit_commit_hash = run_command([git, 'describe', '--always', '--tags'])\n\tgit_branch = run_command([git, 'rev-parse', '--abbrev-ref', 'HEAD'])\n\tif git_commit_hash.returncode() == 0 and git_branch.returncode() == 0\n\t\tversion = '\"@0@ (\" __DATE__ \", branch \\'@1@\\')\"'.format(git_commit_hash.stdout().strip(), git_branch.stdout().strip())\n\tendif\nendif\nadd_project_arguments('-DSWAYLOCK_VERSION=@0@'.format(version), language: 'c')\n\nwl_protocol_dir = wayland_protos.get_variable('pkgdatadir')\n\nif wayland_client.version().version_compare('>=1.14.91')\n\tcode_type = 'private-code'\nelse\n\tcode_type = 'code'\nendif\n\nwayland_scanner_code = generator(\n\twayland_scanner,\n\toutput: '@BASENAME@-protocol.c',\n\targuments: [code_type, '@INPUT@', '@OUTPUT@'],\n)\n\nwayland_scanner_client = generator(\n\twayland_scanner,\n\toutput: '@BASENAME@-client-protocol.h',\n\targuments: ['client-header', '@INPUT@', '@OUTPUT@'],\n)\n\nclient_protos_src = []\nclient_protos_headers = []\n\nclient_protocols = [\n\t[wl_protocol_dir, 'stable/xdg-shell/xdg-shell.xml'],\n\t[wl_protocol_dir, 'unstable/xdg-output/xdg-output-unstable-v1.xml'],\n\t[wl_protocol_dir, 'staging/ext-session-lock/ext-session-lock-v1.xml'],\n\t['wlr-layer-shell-unstable-v1.xml'],\n\t['wlr-input-inhibitor-unstable-v1.xml'],\n]\n\nforeach p : client_protocols\n\txml = join_paths(p)\n\tclient_protos_src += wayland_scanner_code.process(xml)\n\tclient_protos_headers += wayland_scanner_client.process(xml)\nendforeach\n\nlib_client_protos = static_library(\n\t'client_protos',\n\tclient_protos_src + client_protos_headers,\n\tdependencies: [wayland_client]\n) # for the include directory\n\nclient_protos = declare_dependency(\n\tlink_with: lib_client_protos,\n\tsources: client_protos_headers,\n)\n\nconf_data = configuration_data()\nconf_data.set10('HAVE_GDK_PIXBUF', gdk_pixbuf.found())\n\nsubdir('include')\n\ndependencies = [\n\tcairo,\n\tclient_protos,\n\tgdk_pixbuf,\n\tmath,\n\txkbcommon,\n\twayland_client,\n]\n\nsources = [\n\t'background-image.c',\n\t'cairo.c',\n\t'comm.c',\n\t'log.c',\n\t'loop.c',\n\t'main.c',\n\t'password.c',\n\t'pool-buffer.c',\n\t'render.c',\n\t'seat.c',\n\t'unicode.c',\n]\n\nif libpam.found()\n\tsources += ['pam.c']\n\tdependencies += [libpam]\nelse\n\twarning('The swaylock binary must be setuid when compiled without libpam')\n\twarning('You must do this manually post-install: chmod a+s /path/to/swaylock')\n\tsources += ['shadow.c']\n\tdependencies += [crypt]\nendif\n\nswaylock_inc = include_directories('include')\n\nexecutable('swaylock',\n\tsources,\n\tinclude_directories: [swaylock_inc],\n\tdependencies: dependencies,\n\tinstall: true\n)\n\ninstall_data(\n\t'pam/swaylock',\n\tinstall_dir: sysconfdir + '/pam.d/'\n)\n\nif scdoc.found()\n\tsh = find_program('sh')\n\tmandir = get_option('mandir')\n\tman_files = [\n\t\t'swaylock.1.scd',\n\t]\n\tforeach filename : man_files\n\t\ttopic = filename.split('.')[-3].split('/')[-1]\n\t\tsection = filename.split('.')[-2]\n\t\toutput = '@0@.@1@'.format(topic, section)\n\n\t\tcustom_target(\n\t\t\toutput,\n\t\t\tinput: filename,\n\t\t\toutput: output,\n\t\t\tcommand: [\n\t\t\t\tsh, '-c', '@0@ < @INPUT@ > @1@'.format(scdoc.full_path(), output)\n\t\t\t],\n\t\t\tinstall: true,\n\t\t\tinstall_dir: '@0@/man@1@'.format(mandir, section)\n\t\t)\n\tendforeach\nendif\n\ndatadir = get_option('datadir')\n\nif get_option('zsh-completions')\n\tzsh_files = files(\n\t\t'completions/zsh/_swaylock',\n\t)\n\tzsh_install_dir = datadir + '/zsh/site-functions'\n\n\tinstall_data(zsh_files, install_dir: zsh_install_dir)\nendif\n\nif get_option('bash-completions')\n\tbash_files = files(\n\t\t'completions/bash/swaylock',\n\t)\n\tif bash_comp.found()\n\t\tbash_install_dir = bash_comp.get_variable('completionsdir')\n\telse\n\t\tbash_install_dir = datadir + '/bash-completion/completions'\n\tendif\n\n\tinstall_data(bash_files, install_dir: bash_install_dir)\nendif\n\nif get_option('fish-completions')\n\tfish_files = files(\n\t\t'completions/fish/swaylock.fish',\n\t)\n\tif fish_comp.found()\n\t\tfish_install_dir = fish_comp.get_variable('completionsdir')\n\telse\n\t\tfish_install_dir = datadir + '/fish/vendor_completions.d'\n\tendif\n\n\tinstall_data(fish_files, install_dir: fish_install_dir)\nendif\n"], "filenames": ["include/swaylock.h", "main.c", "meson.build"], "buggy_code_start_loc": [91, 28, 39], "buggy_code_end_loc": [103, 1239, 88], "fixing_code_start_loc": [92, 29, 39], "fixing_code_end_loc": [107, 1307, 90], "type": "NVD-CWE-noinfo", "message": "swaylock before 1.6 allows attackers to trigger a crash and achieve unlocked access to a Wayland compositor.", "other": {"cve": {"id": "CVE-2022-26530", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-03T23:15:08.103", "lastModified": "2022-04-19T03:08:06.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "swaylock before 1.6 allows attackers to trigger a crash and achieve unlocked access to a Wayland compositor."}, {"lang": "es", "value": "swaylock versiones hasta 1.6, permite a atacantes desencadenar un fallo y conseguir un acceso desbloqueado a un compositor de Wayland"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:swaywm:swaylock:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6", "matchCriteriaId": "29FE0228-9B5D-4FD4-8E38-769D3C123C85"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2066596", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/swaywm/swaylock/commit/1d1c75b6316d21933069a9d201f966d84099f6ca", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/swaywm/swaylock/pull/219", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/swaywm/swaylock/commit/1d1c75b6316d21933069a9d201f966d84099f6ca"}}