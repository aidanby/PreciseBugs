{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * File: pep.c\n *\n * Phonet pipe protocol end point socket\n *\n * Copyright (C) 2008 Nokia Corporation.\n *\n * Author: R\u00e9mi Denis-Courmont\n */\n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <asm/ioctls.h>\n\n#include <linux/phonet.h>\n#include <linux/module.h>\n#include <net/phonet/phonet.h>\n#include <net/phonet/pep.h>\n#include <net/phonet/gprs.h>\n\n/* sk_state values:\n * TCP_CLOSE\t\tsock not in use yet\n * TCP_CLOSE_WAIT\tdisconnected pipe\n * TCP_LISTEN\t\tlistening pipe endpoint\n * TCP_SYN_RECV\t\tconnected pipe in disabled state\n * TCP_ESTABLISHED\tconnected pipe in enabled state\n *\n * pep_sock locking:\n *  - sk_state, hlist: sock lock needed\n *  - listener: read only\n *  - pipe_handle: read only\n */\n\n#define CREDITS_MAX\t10\n#define CREDITS_THR\t7\n\n#define pep_sb_size(s) (((s) + 5) & ~3) /* 2-bytes head, 32-bits aligned */\n\n/* Get the next TLV sub-block. */\nstatic unsigned char *pep_get_sb(struct sk_buff *skb, u8 *ptype, u8 *plen,\n\t\t\t\t\tvoid *buf)\n{\n\tvoid *data = NULL;\n\tstruct {\n\t\tu8 sb_type;\n\t\tu8 sb_len;\n\t} *ph, h;\n\tint buflen = *plen;\n\n\tph = skb_header_pointer(skb, 0, 2, &h);\n\tif (ph == NULL || ph->sb_len < 2 || !pskb_may_pull(skb, ph->sb_len))\n\t\treturn NULL;\n\tph->sb_len -= 2;\n\t*ptype = ph->sb_type;\n\t*plen = ph->sb_len;\n\n\tif (buflen > ph->sb_len)\n\t\tbuflen = ph->sb_len;\n\tdata = skb_header_pointer(skb, 2, buflen, buf);\n\t__skb_pull(skb, 2 + ph->sb_len);\n\treturn data;\n}\n\nstatic struct sk_buff *pep_alloc_skb(struct sock *sk, const void *payload,\n\t\t\t\t\tint len, gfp_t priority)\n{\n\tstruct sk_buff *skb = alloc_skb(MAX_PNPIPE_HEADER + len, priority);\n\tif (!skb)\n\t\treturn NULL;\n\tskb_set_owner_w(skb, sk);\n\n\tskb_reserve(skb, MAX_PNPIPE_HEADER);\n\t__skb_put(skb, len);\n\tskb_copy_to_linear_data(skb, payload, len);\n\t__skb_push(skb, sizeof(struct pnpipehdr));\n\tskb_reset_transport_header(skb);\n\treturn skb;\n}\n\nstatic int pep_reply(struct sock *sk, struct sk_buff *oskb, u8 code,\n\t\t\tconst void *data, int len, gfp_t priority)\n{\n\tconst struct pnpipehdr *oph = pnp_hdr(oskb);\n\tstruct pnpipehdr *ph;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_pn peer;\n\n\tskb = pep_alloc_skb(sk, data, len, priority);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = oph->utid;\n\tph->message_id = oph->message_id + 1; /* REQ -> RESP */\n\tph->pipe_handle = oph->pipe_handle;\n\tph->error_code = code;\n\n\tpn_skb_get_src_sockaddr(oskb, &peer);\n\treturn pn_skb_send(sk, skb, &peer);\n}\n\nstatic int pep_indicate(struct sock *sk, u8 id, u8 code,\n\t\t\tconst void *data, int len, gfp_t priority)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *ph;\n\tstruct sk_buff *skb;\n\n\tskb = pep_alloc_skb(sk, data, len, priority);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = 0;\n\tph->message_id = id;\n\tph->pipe_handle = pn->pipe_handle;\n\tph->error_code = code;\n\treturn pn_skb_send(sk, skb, NULL);\n}\n\n#define PAD 0x00\n\nstatic int pipe_handler_request(struct sock *sk, u8 id, u8 code,\n\t\t\t\tconst void *data, int len)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *ph;\n\tstruct sk_buff *skb;\n\n\tskb = pep_alloc_skb(sk, data, len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = id; /* whatever */\n\tph->message_id = id;\n\tph->pipe_handle = pn->pipe_handle;\n\tph->error_code = code;\n\treturn pn_skb_send(sk, skb, NULL);\n}\n\nstatic int pipe_handler_send_created_ind(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tu8 data[4] = {\n\t\tPN_PIPE_SB_NEGOTIATED_FC, pep_sb_size(2),\n\t\tpn->tx_fc, pn->rx_fc,\n\t};\n\n\treturn pep_indicate(sk, PNS_PIPE_CREATED_IND, 1 /* sub-blocks */,\n\t\t\t\tdata, 4, GFP_ATOMIC);\n}\n\nstatic int pep_accept_conn(struct sock *sk, struct sk_buff *skb)\n{\n\tstatic const u8 data[20] = {\n\t\tPAD, PAD, PAD, 2 /* sub-blocks */,\n\t\tPN_PIPE_SB_REQUIRED_FC_TX, pep_sb_size(5), 3, PAD,\n\t\t\tPN_MULTI_CREDIT_FLOW_CONTROL,\n\t\t\tPN_ONE_CREDIT_FLOW_CONTROL,\n\t\t\tPN_LEGACY_FLOW_CONTROL,\n\t\t\tPAD,\n\t\tPN_PIPE_SB_PREFERRED_FC_RX, pep_sb_size(5), 3, PAD,\n\t\t\tPN_MULTI_CREDIT_FLOW_CONTROL,\n\t\t\tPN_ONE_CREDIT_FLOW_CONTROL,\n\t\t\tPN_LEGACY_FLOW_CONTROL,\n\t\t\tPAD,\n\t};\n\n\tmight_sleep();\n\treturn pep_reply(sk, skb, PN_PIPE_NO_ERROR, data, sizeof(data),\n\t\t\t\tGFP_KERNEL);\n}\n\nstatic int pep_reject_conn(struct sock *sk, struct sk_buff *skb, u8 code,\n\t\t\t\tgfp_t priority)\n{\n\tstatic const u8 data[4] = { PAD, PAD, PAD, 0 /* sub-blocks */ };\n\tWARN_ON(code == PN_PIPE_NO_ERROR);\n\treturn pep_reply(sk, skb, code, data, sizeof(data), priority);\n}\n\n/* Control requests are not sent by the pipe service and have a specific\n * message format. */\nstatic int pep_ctrlreq_error(struct sock *sk, struct sk_buff *oskb, u8 code,\n\t\t\t\tgfp_t priority)\n{\n\tconst struct pnpipehdr *oph = pnp_hdr(oskb);\n\tstruct sk_buff *skb;\n\tstruct pnpipehdr *ph;\n\tstruct sockaddr_pn dst;\n\tu8 data[4] = {\n\t\toph->pep_type, /* PEP type */\n\t\tcode, /* error code, at an unusual offset */\n\t\tPAD, PAD,\n\t};\n\n\tskb = pep_alloc_skb(sk, data, 4, priority);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = oph->utid;\n\tph->message_id = PNS_PEP_CTRL_RESP;\n\tph->pipe_handle = oph->pipe_handle;\n\tph->data0 = oph->data[0]; /* CTRL id */\n\n\tpn_skb_get_src_sockaddr(oskb, &dst);\n\treturn pn_skb_send(sk, skb, &dst);\n}\n\nstatic int pipe_snd_status(struct sock *sk, u8 type, u8 status, gfp_t priority)\n{\n\tu8 data[4] = { type, PAD, PAD, status };\n\n\treturn pep_indicate(sk, PNS_PEP_STATUS_IND, PN_PEP_TYPE_COMMON,\n\t\t\t\tdata, 4, priority);\n}\n\n/* Send our RX flow control information to the sender.\n * Socket must be locked. */\nstatic void pipe_grant_credits(struct sock *sk, gfp_t priority)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\tBUG_ON(sk->sk_state != TCP_ESTABLISHED);\n\n\tswitch (pn->rx_fc) {\n\tcase PN_LEGACY_FLOW_CONTROL: /* TODO */\n\t\tbreak;\n\tcase PN_ONE_CREDIT_FLOW_CONTROL:\n\t\tif (pipe_snd_status(sk, PN_PEP_IND_FLOW_CONTROL,\n\t\t\t\t\tPEP_IND_READY, priority) == 0)\n\t\t\tpn->rx_credits = 1;\n\t\tbreak;\n\tcase PN_MULTI_CREDIT_FLOW_CONTROL:\n\t\tif ((pn->rx_credits + CREDITS_THR) > CREDITS_MAX)\n\t\t\tbreak;\n\t\tif (pipe_snd_status(sk, PN_PEP_IND_ID_MCFC_GRANT_CREDITS,\n\t\t\t\t\tCREDITS_MAX - pn->rx_credits,\n\t\t\t\t\tpriority) == 0)\n\t\t\tpn->rx_credits = CREDITS_MAX;\n\t\tbreak;\n\t}\n}\n\nstatic int pipe_rcv_status(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr;\n\tint wake = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\n\t\treturn -EINVAL;\n\n\thdr = pnp_hdr(skb);\n\tif (hdr->pep_type != PN_PEP_TYPE_COMMON) {\n\t\tnet_dbg_ratelimited(\"Phonet unknown PEP type: %u\\n\",\n\t\t\t\t    (unsigned int)hdr->pep_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (hdr->data[0]) {\n\tcase PN_PEP_IND_FLOW_CONTROL:\n\t\tswitch (pn->tx_fc) {\n\t\tcase PN_LEGACY_FLOW_CONTROL:\n\t\t\tswitch (hdr->data[3]) {\n\t\t\tcase PEP_IND_BUSY:\n\t\t\t\tatomic_set(&pn->tx_credits, 0);\n\t\t\t\tbreak;\n\t\t\tcase PEP_IND_READY:\n\t\t\t\tatomic_set(&pn->tx_credits, wake = 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PN_ONE_CREDIT_FLOW_CONTROL:\n\t\t\tif (hdr->data[3] == PEP_IND_READY)\n\t\t\t\tatomic_set(&pn->tx_credits, wake = 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PN_PEP_IND_ID_MCFC_GRANT_CREDITS:\n\t\tif (pn->tx_fc != PN_MULTI_CREDIT_FLOW_CONTROL)\n\t\t\tbreak;\n\t\tatomic_add(wake = hdr->data[3], &pn->tx_credits);\n\t\tbreak;\n\n\tdefault:\n\t\tnet_dbg_ratelimited(\"Phonet unknown PEP indication: %u\\n\",\n\t\t\t\t    (unsigned int)hdr->data[0]);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (wake)\n\t\tsk->sk_write_space(sk);\n\treturn 0;\n}\n\nstatic int pipe_rcv_created(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr = pnp_hdr(skb);\n\tu8 n_sb = hdr->data0;\n\n\tpn->rx_fc = pn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\t__skb_pull(skb, sizeof(*hdr));\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[2], len = sizeof(buf);\n\t\tu8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\treturn -EINVAL;\n\t\tswitch (type) {\n\t\tcase PN_PIPE_SB_NEGOTIATED_FC:\n\t\t\tif (len < 2 || (data[0] | data[1]) > 3)\n\t\t\t\tbreak;\n\t\t\tpn->tx_fc = data[0] & 3;\n\t\t\tpn->rx_fc = data[1] & 3;\n\t\t\tbreak;\n\t\t}\n\t\tn_sb--;\n\t}\n\treturn 0;\n}\n\n/* Queue an skb to a connected sock.\n * Socket lock must be held. */\nstatic int pipe_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr = pnp_hdr(skb);\n\tstruct sk_buff_head *queue;\n\tint err = 0;\n\n\tBUG_ON(sk->sk_state == TCP_CLOSE_WAIT);\n\n\tswitch (hdr->message_id) {\n\tcase PNS_PEP_CONNECT_REQ:\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_DISCONNECT_REQ:\n\t\tpep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\n\t\tsk->sk_state = TCP_CLOSE_WAIT;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\n\tcase PNS_PEP_ENABLE_REQ:\n\t\t/* Wait for PNS_PIPE_(ENABLED|REDIRECTED)_IND */\n\t\tpep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_RESET_REQ:\n\t\tswitch (hdr->state_after_reset) {\n\t\tcase PN_PIPE_DISABLE:\n\t\t\tpn->init_enable = 0;\n\t\t\tbreak;\n\t\tcase PN_PIPE_ENABLE:\n\t\t\tpn->init_enable = 1;\n\t\t\tbreak;\n\t\tdefault: /* not allowed to send an error here!? */\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfallthrough;\n\tcase PNS_PEP_DISABLE_REQ:\n\t\tatomic_set(&pn->tx_credits, 0);\n\t\tpep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_CTRL_REQ:\n\t\tif (skb_queue_len(&pn->ctrlreq_queue) >= PNPIPE_CTRLREQ_MAX) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tbreak;\n\t\t}\n\t\t__skb_pull(skb, 4);\n\t\tqueue = &pn->ctrlreq_queue;\n\t\tgoto queue;\n\n\tcase PNS_PIPE_ALIGNED_DATA:\n\t\t__skb_pull(skb, 1);\n\t\tfallthrough;\n\tcase PNS_PIPE_DATA:\n\t\t__skb_pull(skb, 3); /* Pipe data header */\n\t\tif (!pn_flow_safe(pn->rx_fc)) {\n\t\t\terr = sock_queue_rcv_skb(sk, skb);\n\t\t\tif (!err)\n\t\t\t\treturn NET_RX_SUCCESS;\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pn->rx_credits == 0) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tpn->rx_credits--;\n\t\tqueue = &sk->sk_receive_queue;\n\t\tgoto queue;\n\n\tcase PNS_PEP_STATUS_IND:\n\t\tpipe_rcv_status(sk, skb);\n\t\tbreak;\n\n\tcase PNS_PIPE_REDIRECTED_IND:\n\t\terr = pipe_rcv_created(sk, skb);\n\t\tbreak;\n\n\tcase PNS_PIPE_CREATED_IND:\n\t\terr = pipe_rcv_created(sk, skb);\n\t\tif (err)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PNS_PIPE_RESET_IND:\n\t\tif (!pn->init_enable)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PNS_PIPE_ENABLED_IND:\n\t\tif (!pn_flow_safe(pn->tx_fc)) {\n\t\t\tatomic_set(&pn->tx_credits, 1);\n\t\t\tsk->sk_write_space(sk);\n\t\t}\n\t\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\t\tbreak; /* Nothing to do */\n\t\tsk->sk_state = TCP_ESTABLISHED;\n\t\tpipe_grant_credits(sk, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PIPE_DISABLED_IND:\n\t\tsk->sk_state = TCP_SYN_RECV;\n\t\tpn->rx_credits = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tnet_dbg_ratelimited(\"Phonet unknown PEP message: %u\\n\",\n\t\t\t\t    hdr->message_id);\n\t\terr = -EINVAL;\n\t}\nout:\n\tkfree_skb(skb);\n\treturn (err == -ENOBUFS) ? NET_RX_DROP : NET_RX_SUCCESS;\n\nqueue:\n\tskb->dev = NULL;\n\tskb_set_owner_r(skb, sk);\n\tskb_queue_tail(queue, skb);\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\treturn NET_RX_SUCCESS;\n}\n\n/* Destroy connected sock. */\nstatic void pipe_destruct(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&pn->ctrlreq_queue);\n}\n\nstatic u8 pipe_negotiate_fc(const u8 *fcs, unsigned int n)\n{\n\tunsigned int i;\n\tu8 final_fc = PN_NO_FLOW_CONTROL;\n\n\tfor (i = 0; i < n; i++) {\n\t\tu8 fc = fcs[i];\n\n\t\tif (fc > final_fc && fc < PN_MAX_FLOW_CONTROL)\n\t\t\tfinal_fc = fc;\n\t}\n\treturn final_fc;\n}\n\nstatic int pep_connresp_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr;\n\tu8 n_sb;\n\n\tif (!pskb_pull(skb, sizeof(*hdr) + 4))\n\t\treturn -EINVAL;\n\n\thdr = pnp_hdr(skb);\n\tif (hdr->error_code != PN_PIPE_NO_ERROR)\n\t\treturn -ECONNREFUSED;\n\n\t/* Parse sub-blocks */\n\tn_sb = hdr->data[3];\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[6], len = sizeof(buf);\n\t\tconst u8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (type) {\n\t\tcase PN_PIPE_SB_REQUIRED_FC_TX:\n\t\t\tif (len < 2 || len < data[0])\n\t\t\t\tbreak;\n\t\t\tpn->tx_fc = pipe_negotiate_fc(data + 2, len - 2);\n\t\t\tbreak;\n\n\t\tcase PN_PIPE_SB_PREFERRED_FC_RX:\n\t\t\tif (len < 2 || len < data[0])\n\t\t\t\tbreak;\n\t\t\tpn->rx_fc = pipe_negotiate_fc(data + 2, len - 2);\n\t\t\tbreak;\n\n\t\t}\n\t\tn_sb--;\n\t}\n\n\treturn pipe_handler_send_created_ind(sk);\n}\n\nstatic int pep_enableresp_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pnpipehdr *hdr = pnp_hdr(skb);\n\n\tif (hdr->error_code != PN_PIPE_NO_ERROR)\n\t\treturn -ECONNREFUSED;\n\n\treturn pep_indicate(sk, PNS_PIPE_ENABLED_IND, 0 /* sub-blocks */,\n\t\tNULL, 0, GFP_ATOMIC);\n\n}\n\nstatic void pipe_start_flow_control(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\tif (!pn_flow_safe(pn->tx_fc)) {\n\t\tatomic_set(&pn->tx_credits, 1);\n\t\tsk->sk_write_space(sk);\n\t}\n\tpipe_grant_credits(sk, GFP_ATOMIC);\n}\n\n/* Queue an skb to an actively connected sock.\n * Socket lock must be held. */\nstatic int pipe_handler_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr = pnp_hdr(skb);\n\tint err = NET_RX_SUCCESS;\n\n\tswitch (hdr->message_id) {\n\tcase PNS_PIPE_ALIGNED_DATA:\n\t\t__skb_pull(skb, 1);\n\t\tfallthrough;\n\tcase PNS_PIPE_DATA:\n\t\t__skb_pull(skb, 3); /* Pipe data header */\n\t\tif (!pn_flow_safe(pn->rx_fc)) {\n\t\t\terr = sock_queue_rcv_skb(sk, skb);\n\t\t\tif (!err)\n\t\t\t\treturn NET_RX_SUCCESS;\n\t\t\terr = NET_RX_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pn->rx_credits == 0) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\terr = NET_RX_DROP;\n\t\t\tbreak;\n\t\t}\n\t\tpn->rx_credits--;\n\t\tskb->dev = NULL;\n\t\tskb_set_owner_r(skb, sk);\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_data_ready(sk);\n\t\treturn NET_RX_SUCCESS;\n\n\tcase PNS_PEP_CONNECT_RESP:\n\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\tbreak;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_state_change(sk);\n\t\tif (pep_connresp_rcv(sk, skb)) {\n\t\t\tsk->sk_state = TCP_CLOSE_WAIT;\n\t\t\tbreak;\n\t\t}\n\t\tif (pn->init_enable == PN_PIPE_DISABLE)\n\t\t\tsk->sk_state = TCP_SYN_RECV;\n\t\telse {\n\t\t\tsk->sk_state = TCP_ESTABLISHED;\n\t\t\tpipe_start_flow_control(sk);\n\t\t}\n\t\tbreak;\n\n\tcase PNS_PEP_ENABLE_RESP:\n\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\tbreak;\n\n\t\tif (pep_enableresp_rcv(sk, skb)) {\n\t\t\tsk->sk_state = TCP_CLOSE_WAIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsk->sk_state = TCP_ESTABLISHED;\n\t\tpipe_start_flow_control(sk);\n\t\tbreak;\n\n\tcase PNS_PEP_DISCONNECT_RESP:\n\t\t/* sock should already be dead, nothing to do */\n\t\tbreak;\n\n\tcase PNS_PEP_STATUS_IND:\n\t\tpipe_rcv_status(sk, skb);\n\t\tbreak;\n\t}\n\tkfree_skb(skb);\n\treturn err;\n}\n\n/* Listening sock must be locked */\nstatic struct sock *pep_find_pipe(const struct hlist_head *hlist,\n\t\t\t\t\tconst struct sockaddr_pn *dst,\n\t\t\t\t\tu8 pipe_handle)\n{\n\tstruct sock *sknode;\n\tu16 dobj = pn_sockaddr_get_object(dst);\n\n\tsk_for_each(sknode, hlist) {\n\t\tstruct pep_sock *pnnode = pep_sk(sknode);\n\n\t\t/* Ports match, but addresses might not: */\n\t\tif (pnnode->pn_sk.sobject != dobj)\n\t\t\tcontinue;\n\t\tif (pnnode->pipe_handle != pipe_handle)\n\t\t\tcontinue;\n\t\tif (sknode->sk_state == TCP_CLOSE_WAIT)\n\t\t\tcontinue;\n\n\t\tsock_hold(sknode);\n\t\treturn sknode;\n\t}\n\treturn NULL;\n}\n\n/*\n * Deliver an skb to a listening sock.\n * Socket lock must be held.\n * We then queue the skb to the right connected sock (if any).\n */\nstatic int pep_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct sock *sknode;\n\tstruct pnpipehdr *hdr;\n\tstruct sockaddr_pn dst;\n\tu8 pipe_handle;\n\n\tif (!pskb_may_pull(skb, sizeof(*hdr)))\n\t\tgoto drop;\n\n\thdr = pnp_hdr(skb);\n\tpipe_handle = hdr->pipe_handle;\n\tif (pipe_handle == PN_PIPE_INVALID_HANDLE)\n\t\tgoto drop;\n\n\tpn_skb_get_dst_sockaddr(skb, &dst);\n\n\t/* Look for an existing pipe handle */\n\tsknode = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\n\tif (sknode)\n\t\treturn sk_receive_skb(sknode, skb, 1);\n\n\tswitch (hdr->message_id) {\n\tcase PNS_PEP_CONNECT_REQ:\n\t\tif (sk->sk_state != TCP_LISTEN || sk_acceptq_is_full(sk)) {\n\t\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\tsk_acceptq_added(sk);\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_data_ready(sk);\n\t\treturn NET_RX_SUCCESS;\n\n\tcase PNS_PEP_DISCONNECT_REQ:\n\t\tpep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_CTRL_REQ:\n\t\tpep_ctrlreq_error(sk, skb, PN_PIPE_INVALID_HANDLE, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_RESET_REQ:\n\tcase PNS_PEP_ENABLE_REQ:\n\tcase PNS_PEP_DISABLE_REQ:\n\t\t/* invalid handle is not even allowed here! */\n\t\tbreak;\n\n\tdefault:\n\t\tif ((1 << sk->sk_state)\n\t\t\t\t& ~(TCPF_CLOSE|TCPF_LISTEN|TCPF_CLOSE_WAIT))\n\t\t\t/* actively connected socket */\n\t\t\treturn pipe_handler_do_rcv(sk, skb);\n\t}\ndrop:\n\tkfree_skb(skb);\n\treturn NET_RX_SUCCESS;\n}\n\nstatic int pipe_do_remove(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *ph;\n\tstruct sk_buff *skb;\n\n\tskb = pep_alloc_skb(sk, NULL, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = 0;\n\tph->message_id = PNS_PIPE_REMOVE_REQ;\n\tph->pipe_handle = pn->pipe_handle;\n\tph->data0 = PAD;\n\treturn pn_skb_send(sk, skb, NULL);\n}\n\n/* associated socket ceases to exist */\nstatic void pep_sock_close(struct sock *sk, long timeout)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint ifindex = 0;\n\n\tsock_hold(sk); /* keep a reference after sk_common_release() */\n\tsk_common_release(sk);\n\n\tlock_sock(sk);\n\tif ((1 << sk->sk_state) & (TCPF_SYN_RECV|TCPF_ESTABLISHED)) {\n\t\tif (sk->sk_backlog_rcv == pipe_do_rcv)\n\t\t\t/* Forcefully remove dangling Phonet pipe */\n\t\t\tpipe_do_remove(sk);\n\t\telse\n\t\t\tpipe_handler_request(sk, PNS_PEP_DISCONNECT_REQ, PAD,\n\t\t\t\t\t\tNULL, 0);\n\t}\n\tsk->sk_state = TCP_CLOSE;\n\n\tifindex = pn->ifindex;\n\tpn->ifindex = 0;\n\trelease_sock(sk);\n\n\tif (ifindex)\n\t\tgprs_detach(sk);\n\tsock_put(sk);\n}\n\nstatic struct sock *pep_sock_accept(struct sock *sk, int flags, int *errp,\n\t\t\t\t    bool kern)\n{\n\tstruct pep_sock *pn = pep_sk(sk), *newpn;\n\tstruct sock *newsk = NULL;\n\tstruct sk_buff *skb;\n\tstruct pnpipehdr *hdr;\n\tstruct sockaddr_pn dst, src;\n\tint err;\n\tu16 peer_type;\n\tu8 pipe_handle, enabled, n_sb;\n\tu8 aligned = 0;\n\n\tskb = skb_recv_datagram(sk, 0, flags & O_NONBLOCK, errp);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto drop;\n\t}\n\tsk_acceptq_removed(sk);\n\n\terr = -EPROTO;\n\tif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\n\t\tgoto drop;\n\n\thdr = pnp_hdr(skb);\n\tpipe_handle = hdr->pipe_handle;\n\tswitch (hdr->state_after_connect) {\n\tcase PN_PIPE_DISABLE:\n\t\tenabled = 0;\n\t\tbreak;\n\tcase PN_PIPE_ENABLE:\n\t\tenabled = 1;\n\t\tbreak;\n\tdefault:\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_INVALID_PARAM,\n\t\t\t\tGFP_KERNEL);\n\t\tgoto drop;\n\t}\n\tpeer_type = hdr->other_pep_type << 8;\n\n\t/* Parse sub-blocks (options) */\n\tn_sb = hdr->data[3];\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[1], len = sizeof(buf);\n\t\tconst u8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\tgoto drop;\n\t\tswitch (type) {\n\t\tcase PN_PIPE_SB_CONNECT_REQ_PEP_SUB_TYPE:\n\t\t\tif (len < 1)\n\t\t\t\tgoto drop;\n\t\t\tpeer_type = (peer_type & 0xff00) | data[0];\n\t\t\tbreak;\n\t\tcase PN_PIPE_SB_ALIGNED_DATA:\n\t\t\taligned = data[0] != 0;\n\t\t\tbreak;\n\t\t}\n\t\tn_sb--;\n\t}\n\n\t/* Check for duplicate pipe handle */\n\tnewsk = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\n\tif (unlikely(newsk)) {\n\t\t__sock_put(newsk);\n\t\tnewsk = NULL;\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_KERNEL);\n\t\tgoto drop;\n\t}\n\n\t/* Create a new to-be-accepted sock */\n\tnewsk = sk_alloc(sock_net(sk), PF_PHONET, GFP_KERNEL, sk->sk_prot,\n\t\t\t kern);\n\tif (!newsk) {\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_OVERLOAD, GFP_KERNEL);\n\t\terr = -ENOBUFS;\n\t\tgoto drop;\n\t}\n\n\tsock_init_data(NULL, newsk);\n\tnewsk->sk_state = TCP_SYN_RECV;\n\tnewsk->sk_backlog_rcv = pipe_do_rcv;\n\tnewsk->sk_protocol = sk->sk_protocol;\n\tnewsk->sk_destruct = pipe_destruct;\n\n\tnewpn = pep_sk(newsk);\n\tpn_skb_get_dst_sockaddr(skb, &dst);\n\tpn_skb_get_src_sockaddr(skb, &src);\n\tnewpn->pn_sk.sobject = pn_sockaddr_get_object(&dst);\n\tnewpn->pn_sk.dobject = pn_sockaddr_get_object(&src);\n\tnewpn->pn_sk.resource = pn_sockaddr_get_resource(&dst);\n\tsock_hold(sk);\n\tnewpn->listener = sk;\n\tskb_queue_head_init(&newpn->ctrlreq_queue);\n\tnewpn->pipe_handle = pipe_handle;\n\tatomic_set(&newpn->tx_credits, 0);\n\tnewpn->ifindex = 0;\n\tnewpn->peer_type = peer_type;\n\tnewpn->rx_credits = 0;\n\tnewpn->rx_fc = newpn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\tnewpn->init_enable = enabled;\n\tnewpn->aligned = aligned;\n\n\terr = pep_accept_conn(newsk, skb);\n\tif (err) {\n\t\tsock_put(newsk);\n\t\tnewsk = NULL;\n\t\tgoto drop;\n\t}\n\tsk_add_node(newsk, &pn->hlist);\ndrop:\n\trelease_sock(sk);\n\tkfree_skb(skb);\n\t*errp = err;\n\treturn newsk;\n}\n\nstatic int pep_sock_connect(struct sock *sk, struct sockaddr *addr, int len)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint err;\n\tu8 data[4] = { 0 /* sub-blocks */, PAD, PAD, PAD };\n\n\tif (pn->pipe_handle == PN_PIPE_INVALID_HANDLE)\n\t\tpn->pipe_handle = 1; /* anything but INVALID_HANDLE */\n\n\terr = pipe_handler_request(sk, PNS_PEP_CONNECT_REQ,\n\t\t\t\tpn->init_enable, data, 4);\n\tif (err) {\n\t\tpn->pipe_handle = PN_PIPE_INVALID_HANDLE;\n\t\treturn err;\n\t}\n\n\tsk->sk_state = TCP_SYN_SENT;\n\n\treturn 0;\n}\n\nstatic int pep_sock_enable(struct sock *sk, struct sockaddr *addr, int len)\n{\n\tint err;\n\n\terr = pipe_handler_request(sk, PNS_PEP_ENABLE_REQ, PAD,\n\t\t\t\tNULL, 0);\n\tif (err)\n\t\treturn err;\n\n\tsk->sk_state = TCP_SYN_SENT;\n\n\treturn 0;\n}\n\nstatic int pep_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint answ;\n\tint ret = -ENOIOCTLCMD;\n\n\tswitch (cmd) {\n\tcase SIOCINQ:\n\t\tif (sk->sk_state == TCP_LISTEN) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tlock_sock(sk);\n\t\tif (sock_flag(sk, SOCK_URGINLINE) &&\n\t\t    !skb_queue_empty(&pn->ctrlreq_queue))\n\t\t\tansw = skb_peek(&pn->ctrlreq_queue)->len;\n\t\telse if (!skb_queue_empty(&sk->sk_receive_queue))\n\t\t\tansw = skb_peek(&sk->sk_receive_queue)->len;\n\t\telse\n\t\t\tansw = 0;\n\t\trelease_sock(sk);\n\t\tret = put_user(answ, (int __user *)arg);\n\t\tbreak;\n\n\tcase SIOCPNENABLEPIPE:\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state == TCP_SYN_SENT)\n\t\t\tret =  -EBUSY;\n\t\telse if (sk->sk_state == TCP_ESTABLISHED)\n\t\t\tret = -EISCONN;\n\t\telse\n\t\t\tret = pep_sock_enable(sk, NULL, 0);\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int pep_init(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\tsk->sk_destruct = pipe_destruct;\n\tINIT_HLIST_HEAD(&pn->hlist);\n\tpn->listener = NULL;\n\tskb_queue_head_init(&pn->ctrlreq_queue);\n\tatomic_set(&pn->tx_credits, 0);\n\tpn->ifindex = 0;\n\tpn->peer_type = 0;\n\tpn->pipe_handle = PN_PIPE_INVALID_HANDLE;\n\tpn->rx_credits = 0;\n\tpn->rx_fc = pn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\tpn->init_enable = 1;\n\tpn->aligned = 0;\n\treturn 0;\n}\n\nstatic int pep_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint val = 0, err = 0;\n\n\tif (level != SOL_PNPIPE)\n\t\treturn -ENOPROTOOPT;\n\tif (optlen >= sizeof(int)) {\n\t\tif (copy_from_sockptr(&val, optval, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase PNPIPE_ENCAP:\n\t\tif (val && val != PNPIPE_ENCAP_IP) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pn->ifindex == !val)\n\t\t\tbreak; /* Nothing to do! */\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (val) {\n\t\t\trelease_sock(sk);\n\t\t\terr = gprs_attach(sk);\n\t\t\tif (err > 0) {\n\t\t\t\tpn->ifindex = err;\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tpn->ifindex = 0;\n\t\t\trelease_sock(sk);\n\t\t\tgprs_detach(sk);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out_norel;\n\n\tcase PNPIPE_HANDLE:\n\t\tif ((sk->sk_state == TCP_CLOSE) &&\n\t\t\t(val >= 0) && (val < PN_PIPE_INVALID_HANDLE))\n\t\t\tpn->pipe_handle = val;\n\t\telse\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\n\tcase PNPIPE_INITSTATE:\n\t\tpn->init_enable = !!val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\nout_norel:\n\treturn err;\n}\n\nstatic int pep_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint len, val;\n\n\tif (level != SOL_PNPIPE)\n\t\treturn -ENOPROTOOPT;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase PNPIPE_ENCAP:\n\t\tval = pn->ifindex ? PNPIPE_ENCAP_IP : PNPIPE_ENCAP_NONE;\n\t\tbreak;\n\n\tcase PNPIPE_IFINDEX:\n\t\tval = pn->ifindex;\n\t\tbreak;\n\n\tcase PNPIPE_HANDLE:\n\t\tval = pn->pipe_handle;\n\t\tif (val == PN_PIPE_INVALID_HANDLE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PNPIPE_INITSTATE:\n\t\tval = pn->init_enable;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, sizeof(int), len);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(val, (int __user *) optval))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int pipe_skb_send(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *ph;\n\tint err;\n\n\tif (pn_flow_safe(pn->tx_fc) &&\n\t    !atomic_add_unless(&pn->tx_credits, -1, 0)) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOBUFS;\n\t}\n\n\tskb_push(skb, 3 + pn->aligned);\n\tskb_reset_transport_header(skb);\n\tph = pnp_hdr(skb);\n\tph->utid = 0;\n\tif (pn->aligned) {\n\t\tph->message_id = PNS_PIPE_ALIGNED_DATA;\n\t\tph->data0 = 0; /* padding */\n\t} else\n\t\tph->message_id = PNS_PIPE_DATA;\n\tph->pipe_handle = pn->pipe_handle;\n\terr = pn_skb_send(sk, skb, NULL);\n\n\tif (err && pn_flow_safe(pn->tx_fc))\n\t\tatomic_inc(&pn->tx_credits);\n\treturn err;\n\n}\n\nstatic int pep_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint flags = msg->msg_flags;\n\tint err, done;\n\n\tif (len > USHRT_MAX)\n\t\treturn -EMSGSIZE;\n\n\tif ((msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_NOSIGNAL|\n\t\t\t\tMSG_CMSG_COMPAT)) ||\n\t\t\t!(msg->msg_flags & MSG_EOR))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = sock_alloc_send_skb(sk, MAX_PNPIPE_HEADER + len,\n\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tskb_reserve(skb, MAX_PHONET_HEADER + 3 + pn->aligned);\n\terr = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (err < 0)\n\t\tgoto outfree;\n\n\tlock_sock(sk);\n\ttimeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN|TCPF_CLOSE)) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t/* Wait until the pipe gets to enabled state */\ndisabled:\n\t\terr = sk_stream_wait_connect(sk, &timeo);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (sk->sk_state == TCP_CLOSE_WAIT) {\n\t\t\terr = -ECONNRESET;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tBUG_ON(sk->sk_state != TCP_ESTABLISHED);\n\n\t/* Wait until flow control allows TX */\n\tdone = atomic_read(&pn->tx_credits);\n\twhile (!done) {\n\t\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tgoto out;\n\t\t}\n\n\t\tadd_wait_queue(sk_sleep(sk), &wait);\n\t\tdone = sk_wait_event(sk, &timeo, atomic_read(&pn->tx_credits), &wait);\n\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto disabled;\n\t}\n\n\terr = pipe_skb_send(sk, skb);\n\tif (err >= 0)\n\t\terr = len; /* success! */\n\tskb = NULL;\nout:\n\trelease_sock(sk);\noutfree:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nint pep_writeable(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\treturn atomic_read(&pn->tx_credits);\n}\n\nint pep_write(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sk_buff *rskb, *fs;\n\tint flen = 0;\n\n\tif (pep_sk(sk)->aligned)\n\t\treturn pipe_skb_send(sk, skb);\n\n\trskb = alloc_skb(MAX_PNPIPE_HEADER, GFP_ATOMIC);\n\tif (!rskb) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\tskb_shinfo(rskb)->frag_list = skb;\n\trskb->len += skb->len;\n\trskb->data_len += rskb->len;\n\trskb->truesize += rskb->len;\n\n\t/* Avoid nested fragments */\n\tskb_walk_frags(skb, fs)\n\t\tflen += fs->len;\n\tskb->next = skb_shinfo(skb)->frag_list;\n\tskb_frag_list_init(skb);\n\tskb->len -= flen;\n\tskb->data_len -= flen;\n\tskb->truesize -= flen;\n\n\tskb_reserve(rskb, MAX_PHONET_HEADER + 3);\n\treturn pipe_skb_send(sk, rskb);\n}\n\nstruct sk_buff *pep_read(struct sock *sk)\n{\n\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\n\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tpipe_grant_credits(sk, GFP_ATOMIC);\n\treturn skb;\n}\n\nstatic int pep_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t       int noblock, int flags, int *addr_len)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (flags & ~(MSG_OOB|MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_WAITALL|\n\t\t\tMSG_NOSIGNAL|MSG_CMSG_COMPAT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (unlikely(1 << sk->sk_state & (TCPF_LISTEN | TCPF_CLOSE)))\n\t\treturn -ENOTCONN;\n\n\tif ((flags & MSG_OOB) || sock_flag(sk, SOCK_URGINLINE)) {\n\t\t/* Dequeue and acknowledge control request */\n\t\tstruct pep_sock *pn = pep_sk(sk);\n\n\t\tif (flags & MSG_PEEK)\n\t\t\treturn -EOPNOTSUPP;\n\t\tskb = skb_dequeue(&pn->ctrlreq_queue);\n\t\tif (skb) {\n\t\t\tpep_ctrlreq_error(sk, skb, PN_PIPE_NO_ERROR,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tmsg->msg_flags |= MSG_OOB;\n\t\t\tgoto copy;\n\t\t}\n\t\tif (flags & MSG_OOB)\n\t\t\treturn -EINVAL;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tlock_sock(sk);\n\tif (skb == NULL) {\n\t\tif (err == -ENOTCONN && sk->sk_state == TCP_CLOSE_WAIT)\n\t\t\terr = -ECONNRESET;\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tpipe_grant_credits(sk, GFP_KERNEL);\n\trelease_sock(sk);\ncopy:\n\tmsg->msg_flags |= MSG_EOR;\n\tif (skb->len > len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\telse\n\t\tlen = skb->len;\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, len);\n\tif (!err)\n\t\terr = (flags & MSG_TRUNC) ? skb->len : len;\n\n\tskb_free_datagram(sk, skb);\n\treturn err;\n}\n\nstatic void pep_sock_unhash(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct sock *skparent = NULL;\n\n\tlock_sock(sk);\n\n\tif (pn->listener != NULL) {\n\t\tskparent = pn->listener;\n\t\tpn->listener = NULL;\n\t\trelease_sock(sk);\n\n\t\tpn = pep_sk(skparent);\n\t\tlock_sock(skparent);\n\t\tsk_del_node_init(sk);\n\t\tsk = skparent;\n\t}\n\n\t/* Unhash a listening sock only when it is closed\n\t * and all of its active connected pipes are closed. */\n\tif (hlist_empty(&pn->hlist))\n\t\tpn_sock_unhash(&pn->pn_sk.sk);\n\trelease_sock(sk);\n\n\tif (skparent)\n\t\tsock_put(skparent);\n}\n\nstatic struct proto pep_proto = {\n\t.close\t\t= pep_sock_close,\n\t.accept\t\t= pep_sock_accept,\n\t.connect\t= pep_sock_connect,\n\t.ioctl\t\t= pep_ioctl,\n\t.init\t\t= pep_init,\n\t.setsockopt\t= pep_setsockopt,\n\t.getsockopt\t= pep_getsockopt,\n\t.sendmsg\t= pep_sendmsg,\n\t.recvmsg\t= pep_recvmsg,\n\t.backlog_rcv\t= pep_do_rcv,\n\t.hash\t\t= pn_sock_hash,\n\t.unhash\t\t= pep_sock_unhash,\n\t.get_port\t= pn_sock_get_port,\n\t.obj_size\t= sizeof(struct pep_sock),\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"PNPIPE\",\n};\n\nstatic const struct phonet_protocol pep_pn_proto = {\n\t.ops\t\t= &phonet_stream_ops,\n\t.prot\t\t= &pep_proto,\n\t.sock_type\t= SOCK_SEQPACKET,\n};\n\nstatic int __init pep_register(void)\n{\n\treturn phonet_proto_register(PN_PROTO_PIPE, &pep_pn_proto);\n}\n\nstatic void __exit pep_unregister(void)\n{\n\tphonet_proto_unregister(PN_PROTO_PIPE, &pep_pn_proto);\n}\n\nmodule_init(pep_register);\nmodule_exit(pep_unregister);\nMODULE_AUTHOR(\"Remi Denis-Courmont, Nokia\");\nMODULE_DESCRIPTION(\"Phonet pipe protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO(PF_PHONET, PN_PROTO_PIPE);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * File: pep.c\n *\n * Phonet pipe protocol end point socket\n *\n * Copyright (C) 2008 Nokia Corporation.\n *\n * Author: R\u00e9mi Denis-Courmont\n */\n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <asm/ioctls.h>\n\n#include <linux/phonet.h>\n#include <linux/module.h>\n#include <net/phonet/phonet.h>\n#include <net/phonet/pep.h>\n#include <net/phonet/gprs.h>\n\n/* sk_state values:\n * TCP_CLOSE\t\tsock not in use yet\n * TCP_CLOSE_WAIT\tdisconnected pipe\n * TCP_LISTEN\t\tlistening pipe endpoint\n * TCP_SYN_RECV\t\tconnected pipe in disabled state\n * TCP_ESTABLISHED\tconnected pipe in enabled state\n *\n * pep_sock locking:\n *  - sk_state, hlist: sock lock needed\n *  - listener: read only\n *  - pipe_handle: read only\n */\n\n#define CREDITS_MAX\t10\n#define CREDITS_THR\t7\n\n#define pep_sb_size(s) (((s) + 5) & ~3) /* 2-bytes head, 32-bits aligned */\n\n/* Get the next TLV sub-block. */\nstatic unsigned char *pep_get_sb(struct sk_buff *skb, u8 *ptype, u8 *plen,\n\t\t\t\t\tvoid *buf)\n{\n\tvoid *data = NULL;\n\tstruct {\n\t\tu8 sb_type;\n\t\tu8 sb_len;\n\t} *ph, h;\n\tint buflen = *plen;\n\n\tph = skb_header_pointer(skb, 0, 2, &h);\n\tif (ph == NULL || ph->sb_len < 2 || !pskb_may_pull(skb, ph->sb_len))\n\t\treturn NULL;\n\tph->sb_len -= 2;\n\t*ptype = ph->sb_type;\n\t*plen = ph->sb_len;\n\n\tif (buflen > ph->sb_len)\n\t\tbuflen = ph->sb_len;\n\tdata = skb_header_pointer(skb, 2, buflen, buf);\n\t__skb_pull(skb, 2 + ph->sb_len);\n\treturn data;\n}\n\nstatic struct sk_buff *pep_alloc_skb(struct sock *sk, const void *payload,\n\t\t\t\t\tint len, gfp_t priority)\n{\n\tstruct sk_buff *skb = alloc_skb(MAX_PNPIPE_HEADER + len, priority);\n\tif (!skb)\n\t\treturn NULL;\n\tskb_set_owner_w(skb, sk);\n\n\tskb_reserve(skb, MAX_PNPIPE_HEADER);\n\t__skb_put(skb, len);\n\tskb_copy_to_linear_data(skb, payload, len);\n\t__skb_push(skb, sizeof(struct pnpipehdr));\n\tskb_reset_transport_header(skb);\n\treturn skb;\n}\n\nstatic int pep_reply(struct sock *sk, struct sk_buff *oskb, u8 code,\n\t\t\tconst void *data, int len, gfp_t priority)\n{\n\tconst struct pnpipehdr *oph = pnp_hdr(oskb);\n\tstruct pnpipehdr *ph;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_pn peer;\n\n\tskb = pep_alloc_skb(sk, data, len, priority);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = oph->utid;\n\tph->message_id = oph->message_id + 1; /* REQ -> RESP */\n\tph->pipe_handle = oph->pipe_handle;\n\tph->error_code = code;\n\n\tpn_skb_get_src_sockaddr(oskb, &peer);\n\treturn pn_skb_send(sk, skb, &peer);\n}\n\nstatic int pep_indicate(struct sock *sk, u8 id, u8 code,\n\t\t\tconst void *data, int len, gfp_t priority)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *ph;\n\tstruct sk_buff *skb;\n\n\tskb = pep_alloc_skb(sk, data, len, priority);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = 0;\n\tph->message_id = id;\n\tph->pipe_handle = pn->pipe_handle;\n\tph->error_code = code;\n\treturn pn_skb_send(sk, skb, NULL);\n}\n\n#define PAD 0x00\n\nstatic int pipe_handler_request(struct sock *sk, u8 id, u8 code,\n\t\t\t\tconst void *data, int len)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *ph;\n\tstruct sk_buff *skb;\n\n\tskb = pep_alloc_skb(sk, data, len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = id; /* whatever */\n\tph->message_id = id;\n\tph->pipe_handle = pn->pipe_handle;\n\tph->error_code = code;\n\treturn pn_skb_send(sk, skb, NULL);\n}\n\nstatic int pipe_handler_send_created_ind(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tu8 data[4] = {\n\t\tPN_PIPE_SB_NEGOTIATED_FC, pep_sb_size(2),\n\t\tpn->tx_fc, pn->rx_fc,\n\t};\n\n\treturn pep_indicate(sk, PNS_PIPE_CREATED_IND, 1 /* sub-blocks */,\n\t\t\t\tdata, 4, GFP_ATOMIC);\n}\n\nstatic int pep_accept_conn(struct sock *sk, struct sk_buff *skb)\n{\n\tstatic const u8 data[20] = {\n\t\tPAD, PAD, PAD, 2 /* sub-blocks */,\n\t\tPN_PIPE_SB_REQUIRED_FC_TX, pep_sb_size(5), 3, PAD,\n\t\t\tPN_MULTI_CREDIT_FLOW_CONTROL,\n\t\t\tPN_ONE_CREDIT_FLOW_CONTROL,\n\t\t\tPN_LEGACY_FLOW_CONTROL,\n\t\t\tPAD,\n\t\tPN_PIPE_SB_PREFERRED_FC_RX, pep_sb_size(5), 3, PAD,\n\t\t\tPN_MULTI_CREDIT_FLOW_CONTROL,\n\t\t\tPN_ONE_CREDIT_FLOW_CONTROL,\n\t\t\tPN_LEGACY_FLOW_CONTROL,\n\t\t\tPAD,\n\t};\n\n\tmight_sleep();\n\treturn pep_reply(sk, skb, PN_PIPE_NO_ERROR, data, sizeof(data),\n\t\t\t\tGFP_KERNEL);\n}\n\nstatic int pep_reject_conn(struct sock *sk, struct sk_buff *skb, u8 code,\n\t\t\t\tgfp_t priority)\n{\n\tstatic const u8 data[4] = { PAD, PAD, PAD, 0 /* sub-blocks */ };\n\tWARN_ON(code == PN_PIPE_NO_ERROR);\n\treturn pep_reply(sk, skb, code, data, sizeof(data), priority);\n}\n\n/* Control requests are not sent by the pipe service and have a specific\n * message format. */\nstatic int pep_ctrlreq_error(struct sock *sk, struct sk_buff *oskb, u8 code,\n\t\t\t\tgfp_t priority)\n{\n\tconst struct pnpipehdr *oph = pnp_hdr(oskb);\n\tstruct sk_buff *skb;\n\tstruct pnpipehdr *ph;\n\tstruct sockaddr_pn dst;\n\tu8 data[4] = {\n\t\toph->pep_type, /* PEP type */\n\t\tcode, /* error code, at an unusual offset */\n\t\tPAD, PAD,\n\t};\n\n\tskb = pep_alloc_skb(sk, data, 4, priority);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = oph->utid;\n\tph->message_id = PNS_PEP_CTRL_RESP;\n\tph->pipe_handle = oph->pipe_handle;\n\tph->data0 = oph->data[0]; /* CTRL id */\n\n\tpn_skb_get_src_sockaddr(oskb, &dst);\n\treturn pn_skb_send(sk, skb, &dst);\n}\n\nstatic int pipe_snd_status(struct sock *sk, u8 type, u8 status, gfp_t priority)\n{\n\tu8 data[4] = { type, PAD, PAD, status };\n\n\treturn pep_indicate(sk, PNS_PEP_STATUS_IND, PN_PEP_TYPE_COMMON,\n\t\t\t\tdata, 4, priority);\n}\n\n/* Send our RX flow control information to the sender.\n * Socket must be locked. */\nstatic void pipe_grant_credits(struct sock *sk, gfp_t priority)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\tBUG_ON(sk->sk_state != TCP_ESTABLISHED);\n\n\tswitch (pn->rx_fc) {\n\tcase PN_LEGACY_FLOW_CONTROL: /* TODO */\n\t\tbreak;\n\tcase PN_ONE_CREDIT_FLOW_CONTROL:\n\t\tif (pipe_snd_status(sk, PN_PEP_IND_FLOW_CONTROL,\n\t\t\t\t\tPEP_IND_READY, priority) == 0)\n\t\t\tpn->rx_credits = 1;\n\t\tbreak;\n\tcase PN_MULTI_CREDIT_FLOW_CONTROL:\n\t\tif ((pn->rx_credits + CREDITS_THR) > CREDITS_MAX)\n\t\t\tbreak;\n\t\tif (pipe_snd_status(sk, PN_PEP_IND_ID_MCFC_GRANT_CREDITS,\n\t\t\t\t\tCREDITS_MAX - pn->rx_credits,\n\t\t\t\t\tpriority) == 0)\n\t\t\tpn->rx_credits = CREDITS_MAX;\n\t\tbreak;\n\t}\n}\n\nstatic int pipe_rcv_status(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr;\n\tint wake = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\n\t\treturn -EINVAL;\n\n\thdr = pnp_hdr(skb);\n\tif (hdr->pep_type != PN_PEP_TYPE_COMMON) {\n\t\tnet_dbg_ratelimited(\"Phonet unknown PEP type: %u\\n\",\n\t\t\t\t    (unsigned int)hdr->pep_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (hdr->data[0]) {\n\tcase PN_PEP_IND_FLOW_CONTROL:\n\t\tswitch (pn->tx_fc) {\n\t\tcase PN_LEGACY_FLOW_CONTROL:\n\t\t\tswitch (hdr->data[3]) {\n\t\t\tcase PEP_IND_BUSY:\n\t\t\t\tatomic_set(&pn->tx_credits, 0);\n\t\t\t\tbreak;\n\t\t\tcase PEP_IND_READY:\n\t\t\t\tatomic_set(&pn->tx_credits, wake = 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PN_ONE_CREDIT_FLOW_CONTROL:\n\t\t\tif (hdr->data[3] == PEP_IND_READY)\n\t\t\t\tatomic_set(&pn->tx_credits, wake = 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PN_PEP_IND_ID_MCFC_GRANT_CREDITS:\n\t\tif (pn->tx_fc != PN_MULTI_CREDIT_FLOW_CONTROL)\n\t\t\tbreak;\n\t\tatomic_add(wake = hdr->data[3], &pn->tx_credits);\n\t\tbreak;\n\n\tdefault:\n\t\tnet_dbg_ratelimited(\"Phonet unknown PEP indication: %u\\n\",\n\t\t\t\t    (unsigned int)hdr->data[0]);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (wake)\n\t\tsk->sk_write_space(sk);\n\treturn 0;\n}\n\nstatic int pipe_rcv_created(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr = pnp_hdr(skb);\n\tu8 n_sb = hdr->data0;\n\n\tpn->rx_fc = pn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\t__skb_pull(skb, sizeof(*hdr));\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[2], len = sizeof(buf);\n\t\tu8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\treturn -EINVAL;\n\t\tswitch (type) {\n\t\tcase PN_PIPE_SB_NEGOTIATED_FC:\n\t\t\tif (len < 2 || (data[0] | data[1]) > 3)\n\t\t\t\tbreak;\n\t\t\tpn->tx_fc = data[0] & 3;\n\t\t\tpn->rx_fc = data[1] & 3;\n\t\t\tbreak;\n\t\t}\n\t\tn_sb--;\n\t}\n\treturn 0;\n}\n\n/* Queue an skb to a connected sock.\n * Socket lock must be held. */\nstatic int pipe_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr = pnp_hdr(skb);\n\tstruct sk_buff_head *queue;\n\tint err = 0;\n\n\tBUG_ON(sk->sk_state == TCP_CLOSE_WAIT);\n\n\tswitch (hdr->message_id) {\n\tcase PNS_PEP_CONNECT_REQ:\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_DISCONNECT_REQ:\n\t\tpep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\n\t\tsk->sk_state = TCP_CLOSE_WAIT;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\n\tcase PNS_PEP_ENABLE_REQ:\n\t\t/* Wait for PNS_PIPE_(ENABLED|REDIRECTED)_IND */\n\t\tpep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_RESET_REQ:\n\t\tswitch (hdr->state_after_reset) {\n\t\tcase PN_PIPE_DISABLE:\n\t\t\tpn->init_enable = 0;\n\t\t\tbreak;\n\t\tcase PN_PIPE_ENABLE:\n\t\t\tpn->init_enable = 1;\n\t\t\tbreak;\n\t\tdefault: /* not allowed to send an error here!? */\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfallthrough;\n\tcase PNS_PEP_DISABLE_REQ:\n\t\tatomic_set(&pn->tx_credits, 0);\n\t\tpep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_CTRL_REQ:\n\t\tif (skb_queue_len(&pn->ctrlreq_queue) >= PNPIPE_CTRLREQ_MAX) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tbreak;\n\t\t}\n\t\t__skb_pull(skb, 4);\n\t\tqueue = &pn->ctrlreq_queue;\n\t\tgoto queue;\n\n\tcase PNS_PIPE_ALIGNED_DATA:\n\t\t__skb_pull(skb, 1);\n\t\tfallthrough;\n\tcase PNS_PIPE_DATA:\n\t\t__skb_pull(skb, 3); /* Pipe data header */\n\t\tif (!pn_flow_safe(pn->rx_fc)) {\n\t\t\terr = sock_queue_rcv_skb(sk, skb);\n\t\t\tif (!err)\n\t\t\t\treturn NET_RX_SUCCESS;\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pn->rx_credits == 0) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tpn->rx_credits--;\n\t\tqueue = &sk->sk_receive_queue;\n\t\tgoto queue;\n\n\tcase PNS_PEP_STATUS_IND:\n\t\tpipe_rcv_status(sk, skb);\n\t\tbreak;\n\n\tcase PNS_PIPE_REDIRECTED_IND:\n\t\terr = pipe_rcv_created(sk, skb);\n\t\tbreak;\n\n\tcase PNS_PIPE_CREATED_IND:\n\t\terr = pipe_rcv_created(sk, skb);\n\t\tif (err)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PNS_PIPE_RESET_IND:\n\t\tif (!pn->init_enable)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PNS_PIPE_ENABLED_IND:\n\t\tif (!pn_flow_safe(pn->tx_fc)) {\n\t\t\tatomic_set(&pn->tx_credits, 1);\n\t\t\tsk->sk_write_space(sk);\n\t\t}\n\t\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\t\tbreak; /* Nothing to do */\n\t\tsk->sk_state = TCP_ESTABLISHED;\n\t\tpipe_grant_credits(sk, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PIPE_DISABLED_IND:\n\t\tsk->sk_state = TCP_SYN_RECV;\n\t\tpn->rx_credits = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tnet_dbg_ratelimited(\"Phonet unknown PEP message: %u\\n\",\n\t\t\t\t    hdr->message_id);\n\t\terr = -EINVAL;\n\t}\nout:\n\tkfree_skb(skb);\n\treturn (err == -ENOBUFS) ? NET_RX_DROP : NET_RX_SUCCESS;\n\nqueue:\n\tskb->dev = NULL;\n\tskb_set_owner_r(skb, sk);\n\tskb_queue_tail(queue, skb);\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\treturn NET_RX_SUCCESS;\n}\n\n/* Destroy connected sock. */\nstatic void pipe_destruct(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&pn->ctrlreq_queue);\n}\n\nstatic u8 pipe_negotiate_fc(const u8 *fcs, unsigned int n)\n{\n\tunsigned int i;\n\tu8 final_fc = PN_NO_FLOW_CONTROL;\n\n\tfor (i = 0; i < n; i++) {\n\t\tu8 fc = fcs[i];\n\n\t\tif (fc > final_fc && fc < PN_MAX_FLOW_CONTROL)\n\t\t\tfinal_fc = fc;\n\t}\n\treturn final_fc;\n}\n\nstatic int pep_connresp_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr;\n\tu8 n_sb;\n\n\tif (!pskb_pull(skb, sizeof(*hdr) + 4))\n\t\treturn -EINVAL;\n\n\thdr = pnp_hdr(skb);\n\tif (hdr->error_code != PN_PIPE_NO_ERROR)\n\t\treturn -ECONNREFUSED;\n\n\t/* Parse sub-blocks */\n\tn_sb = hdr->data[3];\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[6], len = sizeof(buf);\n\t\tconst u8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (type) {\n\t\tcase PN_PIPE_SB_REQUIRED_FC_TX:\n\t\t\tif (len < 2 || len < data[0])\n\t\t\t\tbreak;\n\t\t\tpn->tx_fc = pipe_negotiate_fc(data + 2, len - 2);\n\t\t\tbreak;\n\n\t\tcase PN_PIPE_SB_PREFERRED_FC_RX:\n\t\t\tif (len < 2 || len < data[0])\n\t\t\t\tbreak;\n\t\t\tpn->rx_fc = pipe_negotiate_fc(data + 2, len - 2);\n\t\t\tbreak;\n\n\t\t}\n\t\tn_sb--;\n\t}\n\n\treturn pipe_handler_send_created_ind(sk);\n}\n\nstatic int pep_enableresp_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pnpipehdr *hdr = pnp_hdr(skb);\n\n\tif (hdr->error_code != PN_PIPE_NO_ERROR)\n\t\treturn -ECONNREFUSED;\n\n\treturn pep_indicate(sk, PNS_PIPE_ENABLED_IND, 0 /* sub-blocks */,\n\t\tNULL, 0, GFP_ATOMIC);\n\n}\n\nstatic void pipe_start_flow_control(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\tif (!pn_flow_safe(pn->tx_fc)) {\n\t\tatomic_set(&pn->tx_credits, 1);\n\t\tsk->sk_write_space(sk);\n\t}\n\tpipe_grant_credits(sk, GFP_ATOMIC);\n}\n\n/* Queue an skb to an actively connected sock.\n * Socket lock must be held. */\nstatic int pipe_handler_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr = pnp_hdr(skb);\n\tint err = NET_RX_SUCCESS;\n\n\tswitch (hdr->message_id) {\n\tcase PNS_PIPE_ALIGNED_DATA:\n\t\t__skb_pull(skb, 1);\n\t\tfallthrough;\n\tcase PNS_PIPE_DATA:\n\t\t__skb_pull(skb, 3); /* Pipe data header */\n\t\tif (!pn_flow_safe(pn->rx_fc)) {\n\t\t\terr = sock_queue_rcv_skb(sk, skb);\n\t\t\tif (!err)\n\t\t\t\treturn NET_RX_SUCCESS;\n\t\t\terr = NET_RX_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pn->rx_credits == 0) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\terr = NET_RX_DROP;\n\t\t\tbreak;\n\t\t}\n\t\tpn->rx_credits--;\n\t\tskb->dev = NULL;\n\t\tskb_set_owner_r(skb, sk);\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_data_ready(sk);\n\t\treturn NET_RX_SUCCESS;\n\n\tcase PNS_PEP_CONNECT_RESP:\n\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\tbreak;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_state_change(sk);\n\t\tif (pep_connresp_rcv(sk, skb)) {\n\t\t\tsk->sk_state = TCP_CLOSE_WAIT;\n\t\t\tbreak;\n\t\t}\n\t\tif (pn->init_enable == PN_PIPE_DISABLE)\n\t\t\tsk->sk_state = TCP_SYN_RECV;\n\t\telse {\n\t\t\tsk->sk_state = TCP_ESTABLISHED;\n\t\t\tpipe_start_flow_control(sk);\n\t\t}\n\t\tbreak;\n\n\tcase PNS_PEP_ENABLE_RESP:\n\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\tbreak;\n\n\t\tif (pep_enableresp_rcv(sk, skb)) {\n\t\t\tsk->sk_state = TCP_CLOSE_WAIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsk->sk_state = TCP_ESTABLISHED;\n\t\tpipe_start_flow_control(sk);\n\t\tbreak;\n\n\tcase PNS_PEP_DISCONNECT_RESP:\n\t\t/* sock should already be dead, nothing to do */\n\t\tbreak;\n\n\tcase PNS_PEP_STATUS_IND:\n\t\tpipe_rcv_status(sk, skb);\n\t\tbreak;\n\t}\n\tkfree_skb(skb);\n\treturn err;\n}\n\n/* Listening sock must be locked */\nstatic struct sock *pep_find_pipe(const struct hlist_head *hlist,\n\t\t\t\t\tconst struct sockaddr_pn *dst,\n\t\t\t\t\tu8 pipe_handle)\n{\n\tstruct sock *sknode;\n\tu16 dobj = pn_sockaddr_get_object(dst);\n\n\tsk_for_each(sknode, hlist) {\n\t\tstruct pep_sock *pnnode = pep_sk(sknode);\n\n\t\t/* Ports match, but addresses might not: */\n\t\tif (pnnode->pn_sk.sobject != dobj)\n\t\t\tcontinue;\n\t\tif (pnnode->pipe_handle != pipe_handle)\n\t\t\tcontinue;\n\t\tif (sknode->sk_state == TCP_CLOSE_WAIT)\n\t\t\tcontinue;\n\n\t\tsock_hold(sknode);\n\t\treturn sknode;\n\t}\n\treturn NULL;\n}\n\n/*\n * Deliver an skb to a listening sock.\n * Socket lock must be held.\n * We then queue the skb to the right connected sock (if any).\n */\nstatic int pep_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct sock *sknode;\n\tstruct pnpipehdr *hdr;\n\tstruct sockaddr_pn dst;\n\tu8 pipe_handle;\n\n\tif (!pskb_may_pull(skb, sizeof(*hdr)))\n\t\tgoto drop;\n\n\thdr = pnp_hdr(skb);\n\tpipe_handle = hdr->pipe_handle;\n\tif (pipe_handle == PN_PIPE_INVALID_HANDLE)\n\t\tgoto drop;\n\n\tpn_skb_get_dst_sockaddr(skb, &dst);\n\n\t/* Look for an existing pipe handle */\n\tsknode = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\n\tif (sknode)\n\t\treturn sk_receive_skb(sknode, skb, 1);\n\n\tswitch (hdr->message_id) {\n\tcase PNS_PEP_CONNECT_REQ:\n\t\tif (sk->sk_state != TCP_LISTEN || sk_acceptq_is_full(sk)) {\n\t\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\tsk_acceptq_added(sk);\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_data_ready(sk);\n\t\treturn NET_RX_SUCCESS;\n\n\tcase PNS_PEP_DISCONNECT_REQ:\n\t\tpep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_CTRL_REQ:\n\t\tpep_ctrlreq_error(sk, skb, PN_PIPE_INVALID_HANDLE, GFP_ATOMIC);\n\t\tbreak;\n\n\tcase PNS_PEP_RESET_REQ:\n\tcase PNS_PEP_ENABLE_REQ:\n\tcase PNS_PEP_DISABLE_REQ:\n\t\t/* invalid handle is not even allowed here! */\n\t\tbreak;\n\n\tdefault:\n\t\tif ((1 << sk->sk_state)\n\t\t\t\t& ~(TCPF_CLOSE|TCPF_LISTEN|TCPF_CLOSE_WAIT))\n\t\t\t/* actively connected socket */\n\t\t\treturn pipe_handler_do_rcv(sk, skb);\n\t}\ndrop:\n\tkfree_skb(skb);\n\treturn NET_RX_SUCCESS;\n}\n\nstatic int pipe_do_remove(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *ph;\n\tstruct sk_buff *skb;\n\n\tskb = pep_alloc_skb(sk, NULL, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tph = pnp_hdr(skb);\n\tph->utid = 0;\n\tph->message_id = PNS_PIPE_REMOVE_REQ;\n\tph->pipe_handle = pn->pipe_handle;\n\tph->data0 = PAD;\n\treturn pn_skb_send(sk, skb, NULL);\n}\n\n/* associated socket ceases to exist */\nstatic void pep_sock_close(struct sock *sk, long timeout)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint ifindex = 0;\n\n\tsock_hold(sk); /* keep a reference after sk_common_release() */\n\tsk_common_release(sk);\n\n\tlock_sock(sk);\n\tif ((1 << sk->sk_state) & (TCPF_SYN_RECV|TCPF_ESTABLISHED)) {\n\t\tif (sk->sk_backlog_rcv == pipe_do_rcv)\n\t\t\t/* Forcefully remove dangling Phonet pipe */\n\t\t\tpipe_do_remove(sk);\n\t\telse\n\t\t\tpipe_handler_request(sk, PNS_PEP_DISCONNECT_REQ, PAD,\n\t\t\t\t\t\tNULL, 0);\n\t}\n\tsk->sk_state = TCP_CLOSE;\n\n\tifindex = pn->ifindex;\n\tpn->ifindex = 0;\n\trelease_sock(sk);\n\n\tif (ifindex)\n\t\tgprs_detach(sk);\n\tsock_put(sk);\n}\n\nstatic struct sock *pep_sock_accept(struct sock *sk, int flags, int *errp,\n\t\t\t\t    bool kern)\n{\n\tstruct pep_sock *pn = pep_sk(sk), *newpn;\n\tstruct sock *newsk = NULL;\n\tstruct sk_buff *skb;\n\tstruct pnpipehdr *hdr;\n\tstruct sockaddr_pn dst, src;\n\tint err;\n\tu16 peer_type;\n\tu8 pipe_handle, enabled, n_sb;\n\tu8 aligned = 0;\n\n\tskb = skb_recv_datagram(sk, 0, flags & O_NONBLOCK, errp);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto drop;\n\t}\n\tsk_acceptq_removed(sk);\n\n\terr = -EPROTO;\n\tif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\n\t\tgoto drop;\n\n\thdr = pnp_hdr(skb);\n\tpipe_handle = hdr->pipe_handle;\n\tswitch (hdr->state_after_connect) {\n\tcase PN_PIPE_DISABLE:\n\t\tenabled = 0;\n\t\tbreak;\n\tcase PN_PIPE_ENABLE:\n\t\tenabled = 1;\n\t\tbreak;\n\tdefault:\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_INVALID_PARAM,\n\t\t\t\tGFP_KERNEL);\n\t\tgoto drop;\n\t}\n\tpeer_type = hdr->other_pep_type << 8;\n\n\t/* Parse sub-blocks (options) */\n\tn_sb = hdr->data[3];\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[1], len = sizeof(buf);\n\t\tconst u8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\tgoto drop;\n\t\tswitch (type) {\n\t\tcase PN_PIPE_SB_CONNECT_REQ_PEP_SUB_TYPE:\n\t\t\tif (len < 1)\n\t\t\t\tgoto drop;\n\t\t\tpeer_type = (peer_type & 0xff00) | data[0];\n\t\t\tbreak;\n\t\tcase PN_PIPE_SB_ALIGNED_DATA:\n\t\t\taligned = data[0] != 0;\n\t\t\tbreak;\n\t\t}\n\t\tn_sb--;\n\t}\n\n\t/* Check for duplicate pipe handle */\n\tnewsk = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\n\tif (unlikely(newsk)) {\n\t\t__sock_put(newsk);\n\t\tnewsk = NULL;\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_KERNEL);\n\t\tgoto drop;\n\t}\n\n\t/* Create a new to-be-accepted sock */\n\tnewsk = sk_alloc(sock_net(sk), PF_PHONET, GFP_KERNEL, sk->sk_prot,\n\t\t\t kern);\n\tif (!newsk) {\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_OVERLOAD, GFP_KERNEL);\n\t\terr = -ENOBUFS;\n\t\tgoto drop;\n\t}\n\n\tsock_init_data(NULL, newsk);\n\tnewsk->sk_state = TCP_SYN_RECV;\n\tnewsk->sk_backlog_rcv = pipe_do_rcv;\n\tnewsk->sk_protocol = sk->sk_protocol;\n\tnewsk->sk_destruct = pipe_destruct;\n\n\tnewpn = pep_sk(newsk);\n\tpn_skb_get_dst_sockaddr(skb, &dst);\n\tpn_skb_get_src_sockaddr(skb, &src);\n\tnewpn->pn_sk.sobject = pn_sockaddr_get_object(&dst);\n\tnewpn->pn_sk.dobject = pn_sockaddr_get_object(&src);\n\tnewpn->pn_sk.resource = pn_sockaddr_get_resource(&dst);\n\tsock_hold(sk);\n\tnewpn->listener = sk;\n\tskb_queue_head_init(&newpn->ctrlreq_queue);\n\tnewpn->pipe_handle = pipe_handle;\n\tatomic_set(&newpn->tx_credits, 0);\n\tnewpn->ifindex = 0;\n\tnewpn->peer_type = peer_type;\n\tnewpn->rx_credits = 0;\n\tnewpn->rx_fc = newpn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\tnewpn->init_enable = enabled;\n\tnewpn->aligned = aligned;\n\n\terr = pep_accept_conn(newsk, skb);\n\tif (err) {\n\t\t__sock_put(sk);\n\t\tsock_put(newsk);\n\t\tnewsk = NULL;\n\t\tgoto drop;\n\t}\n\tsk_add_node(newsk, &pn->hlist);\ndrop:\n\trelease_sock(sk);\n\tkfree_skb(skb);\n\t*errp = err;\n\treturn newsk;\n}\n\nstatic int pep_sock_connect(struct sock *sk, struct sockaddr *addr, int len)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint err;\n\tu8 data[4] = { 0 /* sub-blocks */, PAD, PAD, PAD };\n\n\tif (pn->pipe_handle == PN_PIPE_INVALID_HANDLE)\n\t\tpn->pipe_handle = 1; /* anything but INVALID_HANDLE */\n\n\terr = pipe_handler_request(sk, PNS_PEP_CONNECT_REQ,\n\t\t\t\tpn->init_enable, data, 4);\n\tif (err) {\n\t\tpn->pipe_handle = PN_PIPE_INVALID_HANDLE;\n\t\treturn err;\n\t}\n\n\tsk->sk_state = TCP_SYN_SENT;\n\n\treturn 0;\n}\n\nstatic int pep_sock_enable(struct sock *sk, struct sockaddr *addr, int len)\n{\n\tint err;\n\n\terr = pipe_handler_request(sk, PNS_PEP_ENABLE_REQ, PAD,\n\t\t\t\tNULL, 0);\n\tif (err)\n\t\treturn err;\n\n\tsk->sk_state = TCP_SYN_SENT;\n\n\treturn 0;\n}\n\nstatic int pep_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint answ;\n\tint ret = -ENOIOCTLCMD;\n\n\tswitch (cmd) {\n\tcase SIOCINQ:\n\t\tif (sk->sk_state == TCP_LISTEN) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tlock_sock(sk);\n\t\tif (sock_flag(sk, SOCK_URGINLINE) &&\n\t\t    !skb_queue_empty(&pn->ctrlreq_queue))\n\t\t\tansw = skb_peek(&pn->ctrlreq_queue)->len;\n\t\telse if (!skb_queue_empty(&sk->sk_receive_queue))\n\t\t\tansw = skb_peek(&sk->sk_receive_queue)->len;\n\t\telse\n\t\t\tansw = 0;\n\t\trelease_sock(sk);\n\t\tret = put_user(answ, (int __user *)arg);\n\t\tbreak;\n\n\tcase SIOCPNENABLEPIPE:\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state == TCP_SYN_SENT)\n\t\t\tret =  -EBUSY;\n\t\telse if (sk->sk_state == TCP_ESTABLISHED)\n\t\t\tret = -EISCONN;\n\t\telse\n\t\t\tret = pep_sock_enable(sk, NULL, 0);\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int pep_init(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\tsk->sk_destruct = pipe_destruct;\n\tINIT_HLIST_HEAD(&pn->hlist);\n\tpn->listener = NULL;\n\tskb_queue_head_init(&pn->ctrlreq_queue);\n\tatomic_set(&pn->tx_credits, 0);\n\tpn->ifindex = 0;\n\tpn->peer_type = 0;\n\tpn->pipe_handle = PN_PIPE_INVALID_HANDLE;\n\tpn->rx_credits = 0;\n\tpn->rx_fc = pn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\tpn->init_enable = 1;\n\tpn->aligned = 0;\n\treturn 0;\n}\n\nstatic int pep_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint val = 0, err = 0;\n\n\tif (level != SOL_PNPIPE)\n\t\treturn -ENOPROTOOPT;\n\tif (optlen >= sizeof(int)) {\n\t\tif (copy_from_sockptr(&val, optval, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase PNPIPE_ENCAP:\n\t\tif (val && val != PNPIPE_ENCAP_IP) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pn->ifindex == !val)\n\t\t\tbreak; /* Nothing to do! */\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (val) {\n\t\t\trelease_sock(sk);\n\t\t\terr = gprs_attach(sk);\n\t\t\tif (err > 0) {\n\t\t\t\tpn->ifindex = err;\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tpn->ifindex = 0;\n\t\t\trelease_sock(sk);\n\t\t\tgprs_detach(sk);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out_norel;\n\n\tcase PNPIPE_HANDLE:\n\t\tif ((sk->sk_state == TCP_CLOSE) &&\n\t\t\t(val >= 0) && (val < PN_PIPE_INVALID_HANDLE))\n\t\t\tpn->pipe_handle = val;\n\t\telse\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\n\tcase PNPIPE_INITSTATE:\n\t\tpn->init_enable = !!val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\nout_norel:\n\treturn err;\n}\n\nstatic int pep_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tint len, val;\n\n\tif (level != SOL_PNPIPE)\n\t\treturn -ENOPROTOOPT;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase PNPIPE_ENCAP:\n\t\tval = pn->ifindex ? PNPIPE_ENCAP_IP : PNPIPE_ENCAP_NONE;\n\t\tbreak;\n\n\tcase PNPIPE_IFINDEX:\n\t\tval = pn->ifindex;\n\t\tbreak;\n\n\tcase PNPIPE_HANDLE:\n\t\tval = pn->pipe_handle;\n\t\tif (val == PN_PIPE_INVALID_HANDLE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PNPIPE_INITSTATE:\n\t\tval = pn->init_enable;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, sizeof(int), len);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(val, (int __user *) optval))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int pipe_skb_send(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *ph;\n\tint err;\n\n\tif (pn_flow_safe(pn->tx_fc) &&\n\t    !atomic_add_unless(&pn->tx_credits, -1, 0)) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOBUFS;\n\t}\n\n\tskb_push(skb, 3 + pn->aligned);\n\tskb_reset_transport_header(skb);\n\tph = pnp_hdr(skb);\n\tph->utid = 0;\n\tif (pn->aligned) {\n\t\tph->message_id = PNS_PIPE_ALIGNED_DATA;\n\t\tph->data0 = 0; /* padding */\n\t} else\n\t\tph->message_id = PNS_PIPE_DATA;\n\tph->pipe_handle = pn->pipe_handle;\n\terr = pn_skb_send(sk, skb, NULL);\n\n\tif (err && pn_flow_safe(pn->tx_fc))\n\t\tatomic_inc(&pn->tx_credits);\n\treturn err;\n\n}\n\nstatic int pep_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint flags = msg->msg_flags;\n\tint err, done;\n\n\tif (len > USHRT_MAX)\n\t\treturn -EMSGSIZE;\n\n\tif ((msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_NOSIGNAL|\n\t\t\t\tMSG_CMSG_COMPAT)) ||\n\t\t\t!(msg->msg_flags & MSG_EOR))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = sock_alloc_send_skb(sk, MAX_PNPIPE_HEADER + len,\n\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tskb_reserve(skb, MAX_PHONET_HEADER + 3 + pn->aligned);\n\terr = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (err < 0)\n\t\tgoto outfree;\n\n\tlock_sock(sk);\n\ttimeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN|TCPF_CLOSE)) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t/* Wait until the pipe gets to enabled state */\ndisabled:\n\t\terr = sk_stream_wait_connect(sk, &timeo);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (sk->sk_state == TCP_CLOSE_WAIT) {\n\t\t\terr = -ECONNRESET;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tBUG_ON(sk->sk_state != TCP_ESTABLISHED);\n\n\t/* Wait until flow control allows TX */\n\tdone = atomic_read(&pn->tx_credits);\n\twhile (!done) {\n\t\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tgoto out;\n\t\t}\n\n\t\tadd_wait_queue(sk_sleep(sk), &wait);\n\t\tdone = sk_wait_event(sk, &timeo, atomic_read(&pn->tx_credits), &wait);\n\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto disabled;\n\t}\n\n\terr = pipe_skb_send(sk, skb);\n\tif (err >= 0)\n\t\terr = len; /* success! */\n\tskb = NULL;\nout:\n\trelease_sock(sk);\noutfree:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nint pep_writeable(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\n\treturn atomic_read(&pn->tx_credits);\n}\n\nint pep_write(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sk_buff *rskb, *fs;\n\tint flen = 0;\n\n\tif (pep_sk(sk)->aligned)\n\t\treturn pipe_skb_send(sk, skb);\n\n\trskb = alloc_skb(MAX_PNPIPE_HEADER, GFP_ATOMIC);\n\tif (!rskb) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\tskb_shinfo(rskb)->frag_list = skb;\n\trskb->len += skb->len;\n\trskb->data_len += rskb->len;\n\trskb->truesize += rskb->len;\n\n\t/* Avoid nested fragments */\n\tskb_walk_frags(skb, fs)\n\t\tflen += fs->len;\n\tskb->next = skb_shinfo(skb)->frag_list;\n\tskb_frag_list_init(skb);\n\tskb->len -= flen;\n\tskb->data_len -= flen;\n\tskb->truesize -= flen;\n\n\tskb_reserve(rskb, MAX_PHONET_HEADER + 3);\n\treturn pipe_skb_send(sk, rskb);\n}\n\nstruct sk_buff *pep_read(struct sock *sk)\n{\n\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\n\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tpipe_grant_credits(sk, GFP_ATOMIC);\n\treturn skb;\n}\n\nstatic int pep_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t       int noblock, int flags, int *addr_len)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (flags & ~(MSG_OOB|MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_WAITALL|\n\t\t\tMSG_NOSIGNAL|MSG_CMSG_COMPAT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (unlikely(1 << sk->sk_state & (TCPF_LISTEN | TCPF_CLOSE)))\n\t\treturn -ENOTCONN;\n\n\tif ((flags & MSG_OOB) || sock_flag(sk, SOCK_URGINLINE)) {\n\t\t/* Dequeue and acknowledge control request */\n\t\tstruct pep_sock *pn = pep_sk(sk);\n\n\t\tif (flags & MSG_PEEK)\n\t\t\treturn -EOPNOTSUPP;\n\t\tskb = skb_dequeue(&pn->ctrlreq_queue);\n\t\tif (skb) {\n\t\t\tpep_ctrlreq_error(sk, skb, PN_PIPE_NO_ERROR,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tmsg->msg_flags |= MSG_OOB;\n\t\t\tgoto copy;\n\t\t}\n\t\tif (flags & MSG_OOB)\n\t\t\treturn -EINVAL;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tlock_sock(sk);\n\tif (skb == NULL) {\n\t\tif (err == -ENOTCONN && sk->sk_state == TCP_CLOSE_WAIT)\n\t\t\terr = -ECONNRESET;\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tpipe_grant_credits(sk, GFP_KERNEL);\n\trelease_sock(sk);\ncopy:\n\tmsg->msg_flags |= MSG_EOR;\n\tif (skb->len > len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\telse\n\t\tlen = skb->len;\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, len);\n\tif (!err)\n\t\terr = (flags & MSG_TRUNC) ? skb->len : len;\n\n\tskb_free_datagram(sk, skb);\n\treturn err;\n}\n\nstatic void pep_sock_unhash(struct sock *sk)\n{\n\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct sock *skparent = NULL;\n\n\tlock_sock(sk);\n\n\tif (pn->listener != NULL) {\n\t\tskparent = pn->listener;\n\t\tpn->listener = NULL;\n\t\trelease_sock(sk);\n\n\t\tpn = pep_sk(skparent);\n\t\tlock_sock(skparent);\n\t\tsk_del_node_init(sk);\n\t\tsk = skparent;\n\t}\n\n\t/* Unhash a listening sock only when it is closed\n\t * and all of its active connected pipes are closed. */\n\tif (hlist_empty(&pn->hlist))\n\t\tpn_sock_unhash(&pn->pn_sk.sk);\n\trelease_sock(sk);\n\n\tif (skparent)\n\t\tsock_put(skparent);\n}\n\nstatic struct proto pep_proto = {\n\t.close\t\t= pep_sock_close,\n\t.accept\t\t= pep_sock_accept,\n\t.connect\t= pep_sock_connect,\n\t.ioctl\t\t= pep_ioctl,\n\t.init\t\t= pep_init,\n\t.setsockopt\t= pep_setsockopt,\n\t.getsockopt\t= pep_getsockopt,\n\t.sendmsg\t= pep_sendmsg,\n\t.recvmsg\t= pep_recvmsg,\n\t.backlog_rcv\t= pep_do_rcv,\n\t.hash\t\t= pn_sock_hash,\n\t.unhash\t\t= pep_sock_unhash,\n\t.get_port\t= pn_sock_get_port,\n\t.obj_size\t= sizeof(struct pep_sock),\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"PNPIPE\",\n};\n\nstatic const struct phonet_protocol pep_pn_proto = {\n\t.ops\t\t= &phonet_stream_ops,\n\t.prot\t\t= &pep_proto,\n\t.sock_type\t= SOCK_SEQPACKET,\n};\n\nstatic int __init pep_register(void)\n{\n\treturn phonet_proto_register(PN_PROTO_PIPE, &pep_pn_proto);\n}\n\nstatic void __exit pep_unregister(void)\n{\n\tphonet_proto_unregister(PN_PROTO_PIPE, &pep_pn_proto);\n}\n\nmodule_init(pep_register);\nmodule_exit(pep_unregister);\nMODULE_AUTHOR(\"Remi Denis-Courmont, Nokia\");\nMODULE_DESCRIPTION(\"Phonet pipe protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO(PF_PHONET, PN_PROTO_PIPE);\n"], "filenames": ["net/phonet/pep.c"], "buggy_code_start_loc": [870], "buggy_code_end_loc": [870], "fixing_code_start_loc": [871], "fixing_code_end_loc": [872], "type": "CWE-200", "message": "pep_sock_accept in net/phonet/pep.c in the Linux kernel through 5.15.8 has a refcount leak.", "other": {"cve": {"id": "CVE-2021-45095", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-16T04:15:06.803", "lastModified": "2022-04-06T13:56:27.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "pep_sock_accept in net/phonet/pep.c in the Linux kernel through 5.15.8 has a refcount leak."}, {"lang": "es", "value": "La funci\u00f3n pep_sock_accept en el archivo net/phonet/pep.c en el kernel de Linux versiones hasta 5.15.8, presenta un filtrado de refcount"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.15.8", "matchCriteriaId": "8173A5D6-121D-4B12-9C0C-593FA8C29479"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=bcd0f93353326954817a4f9fa55ec57fb38acbb0", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/bcd0f93353326954817a4f9fa55ec57fb38acbb0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5050", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5096", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bcd0f93353326954817a4f9fa55ec57fb38acbb0"}}