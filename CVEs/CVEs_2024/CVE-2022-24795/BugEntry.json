{"buggy_code": ["/*\n * Copyright 2010, Lloyd Hilaiel.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n * \n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * \n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n * \n *  3. Neither the name of Lloyd Hilaiel nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */ \n\n/**\n * \\file yajl_gen.h\n * Interface to YAJL's JSON generation facilities.\n */\n\n#include \"api/yajl_common.h\"\n\n#ifndef __YAJL_GEN_H__\n#define __YAJL_GEN_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif    \n    /** generator status codes */\n    typedef enum {\n        /** no error */\n        yajl_gen_status_ok = 0,\n        /** at a point where a map key is generated, a function other than\n         *  yajl_gen_string was called */\n        yajl_gen_keys_must_be_strings,\n        /** YAJL's maximum generation depth was exceeded.  see\n         *  YAJL_MAX_DEPTH */\n        yajl_max_depth_exceeded,\n        /** A generator function (yajl_gen_XXX) was called while in an error\n         *  state */\n        yajl_gen_in_error_state,\n        /** A complete JSON document has been generated */\n        yajl_gen_generation_complete,                \n        /** yajl_gen_double was passed an invalid floating point value\n         *  (infinity or NaN). */\n        yajl_gen_invalid_number,\n        /** A print callback was passed in, so there is no internal\n         * buffer to get from */\n        yajl_gen_no_buf\n    } yajl_gen_status;\n\n    /** an opaque handle to a generator */\n    typedef struct yajl_gen_t * yajl_gen;\n\n    /** a callback used for \"printing\" the results. */\n    typedef void (*yajl_print_t)(void * ctx,\n                                 const char * str,\n                                 unsigned int len);\n\n    /** configuration structure for the generator */\n    typedef struct {\n        /** generate indented (beautiful) output */\n        unsigned int beautify;\n        /** an opportunity to define an indent string.  such as \\\\t or\n         *  some number of spaces.  default is four spaces '    '.  This\n         *  member is only relevant when beautify is true */\n        const char * indentString;\n        /** escape the '/' character */\n        unsigned int htmlSafe;\n    } yajl_gen_config;\n\n    /** allocate a generator handle\n     *  \\param config a pointer to a structure containing parameters which\n     *                configure the behavior of the json generator\n     *  \\param allocFuncs an optional pointer to a structure which allows\n     *                    the client to overide the memory allocation\n     *                    used by yajl.  May be NULL, in which case\n     *                    malloc/free/realloc will be used.\n     *\n     *  \\returns an allocated handle on success, NULL on failure (bad params)\n     */\n    YAJL_API yajl_gen yajl_gen_alloc(const yajl_gen_config * config,\n                                     const yajl_alloc_funcs * allocFuncs);\n\n    /** allocate a generator handle that will print to the specified\n     *  callback rather than storing the results in an internal buffer.\n     *  \\param callback   a pointer to a printer function.  May be NULL\n     *                    in which case, the results will be store in an\n     *                    internal buffer.\n     *  \\param config     a pointer to a structure containing parameters\n     *                    which configure the behavior of the json\n     *                    generator.\n     *  \\param allocFuncs an optional pointer to a structure which allows\n     *                    the client to overide the memory allocation\n     *                    used by yajl.  May be NULL, in which case\n     *                    malloc/free/realloc will be used.\n     *  \\param ctx        a context pointer that will be passed to the\n     *                    printer callback.\n     *\n     *  \\returns an allocated handle on success, NULL on failure (bad params)\n     */\n    YAJL_API yajl_gen yajl_gen_alloc2(const yajl_print_t callback,\n                                      const yajl_gen_config * config,\n                                      const yajl_alloc_funcs * allocFuncs,\n                                      void * ctx);\n\n    /** free a generator handle */    \n    YAJL_API void yajl_gen_free(yajl_gen handle);\n\n    YAJL_API yajl_gen_status yajl_gen_integer(yajl_gen hand, long int number);\n    /** generate a floating point number.  number may not be infinity or\n     *  NaN, as these have no representation in JSON.  In these cases the\n     *  generator will return 'yajl_gen_invalid_number' */\n    YAJL_API yajl_gen_status yajl_gen_double(yajl_gen hand, double number);\n    YAJL_API yajl_gen_status yajl_gen_long(yajl_gen hand, long value);\n    YAJL_API yajl_gen_status yajl_gen_number(yajl_gen hand,\n                                             const char * num,\n                                             unsigned int len);\n    YAJL_API yajl_gen_status yajl_gen_string(yajl_gen hand,\n                                             const unsigned char * str,\n                                             unsigned int len);\n    YAJL_API yajl_gen_status yajl_gen_null(yajl_gen hand);\n    YAJL_API yajl_gen_status yajl_gen_bool(yajl_gen hand, int boolean);\n    YAJL_API yajl_gen_status yajl_gen_map_open(yajl_gen hand);\n    YAJL_API yajl_gen_status yajl_gen_map_close(yajl_gen hand);\n    YAJL_API yajl_gen_status yajl_gen_array_open(yajl_gen hand);\n    YAJL_API yajl_gen_status yajl_gen_array_close(yajl_gen hand);\n\n    /** access the null terminated generator buffer.  If incrementally\n     *  outputing JSON, one should call yajl_gen_clear to clear the\n     *  buffer.  This allows stream generation. */\n    YAJL_API yajl_gen_status yajl_gen_get_buf(yajl_gen hand,\n                                              const unsigned char ** buf,\n                                              unsigned int * len);\n\n    /** clear yajl's output buffer, but maintain all internal generation\n     *  state.  This function will not \"reset\" the generator state, and is\n     *  intended to enable incremental JSON outputing. */\n    YAJL_API void yajl_gen_clear(yajl_gen hand);\n\n#ifdef __cplusplus\n}\n#endif    \n\n#endif\n", "/*\n * Copyright 2010, Lloyd Hilaiel.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n * \n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * \n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n * \n *  3. Neither the name of Lloyd Hilaiel nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */ \n\n#include \"api/yajl_gen.h\"\n#include \"yajl_buf.h\"\n#include \"yajl_encode.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n\ntypedef enum {\n    yajl_gen_start,\n    yajl_gen_map_start,\n    yajl_gen_map_key,\n    yajl_gen_map_val,\n    yajl_gen_array_start,\n    yajl_gen_in_array,\n    yajl_gen_complete,\n    yajl_gen_error\n} yajl_gen_state;\n\nstruct yajl_gen_t \n{\n    unsigned int depth;\n    unsigned int pretty;\n    const char * indentString;\n    yajl_gen_state state[YAJL_MAX_DEPTH];\n    yajl_print_t print;\n    void * ctx; /* yajl_buf */\n    /* memory allocation routines */\n    yajl_alloc_funcs alloc;\n    unsigned int htmlSafe;\n};\n\nyajl_gen\nyajl_gen_alloc(const yajl_gen_config * config,\n               const yajl_alloc_funcs * afs)\n{\n    return yajl_gen_alloc2(NULL, config, afs, NULL);\n}\n\nyajl_gen\nyajl_gen_alloc2(const yajl_print_t callback,\n                const yajl_gen_config * config,\n                const yajl_alloc_funcs * afs,\n                void * ctx)\n{\n    yajl_gen g = NULL;\n    yajl_alloc_funcs afsBuffer;\n\n    /* first order of business is to set up memory allocation routines */\n    if (afs != NULL) {\n        if (afs->malloc == NULL || afs->realloc == NULL || afs->free == NULL)\n        {\n            return NULL;\n        }\n    } else {\n        yajl_set_default_alloc_funcs(&afsBuffer);\n        afs = &afsBuffer;\n    }\n\n    g = (yajl_gen) YA_MALLOC(afs, sizeof(struct yajl_gen_t));\n    if (!g) return NULL;\n\n    memset((void *) g, 0, sizeof(struct yajl_gen_t));\n    /* copy in pointers to allocation routines */\n    memcpy((void *) &(g->alloc), (void *) afs, sizeof(yajl_alloc_funcs));\n\n    if (config) {\n        const char *indent = config->indentString;\n        g->pretty = config->beautify;\n        g->indentString = config->indentString;\n        if (indent) {\n          for (; *indent; indent++) {\n            if (*indent != '\\n'\n                && *indent != '\\v'\n                && *indent != '\\f'\n                && *indent != '\\t'\n                && *indent != '\\r'\n                && *indent != ' ') {\n              g->indentString = NULL;\n              break;\n            }\n          }\n        }\n        if (!g->indentString) {\n          g->indentString = \"  \";\n        }\n        g->htmlSafe = config->htmlSafe;\n    }\n\n    if (callback) {\n        g->print = callback;\n        g->ctx = ctx;\n    } else {\n        g->print = (yajl_print_t)&yajl_buf_append;\n        g->ctx = yajl_buf_alloc(&(g->alloc));\n    }\n\n    return g;\n}\n\nvoid\nyajl_gen_free(yajl_gen g)\n{\n    if (g->print == (yajl_print_t)&yajl_buf_append) yajl_buf_free((yajl_buf)g->ctx);\n    YA_FREE(&(g->alloc), g);\n}\n\n#define INSERT_SEP \\\n    if (g->state[g->depth] == yajl_gen_map_key ||               \\\n        g->state[g->depth] == yajl_gen_in_array) {              \\\n        g->print(g->ctx, \",\", 1);                               \\\n        if (g->pretty) g->print(g->ctx, \"\\n\", 1);               \\\n    } else if (g->state[g->depth] == yajl_gen_map_val) {        \\\n        g->print(g->ctx, \":\", 1);                               \\\n        if (g->pretty) g->print(g->ctx, \" \", 1);                \\\n   } \n\n#define INSERT_WHITESPACE                                               \\\n    if (g->pretty) {                                                    \\\n        if (g->state[g->depth] != yajl_gen_map_val) {                   \\\n            unsigned int _i;                                            \\\n            for (_i=0;_i<g->depth;_i++)                                 \\\n                g->print(g->ctx,                                        \\\n                         g->indentString,                               \\\n                         (unsigned int)strlen(g->indentString));        \\\n        }                                                               \\\n    }\n\n#define ENSURE_NOT_KEY \\\n    if (g->state[g->depth] == yajl_gen_map_key ||       \\\n        g->state[g->depth] == yajl_gen_map_start)  {    \\\n        return yajl_gen_keys_must_be_strings;           \\\n    }                                                   \\\n\n/* check that we're not complete, or in error state.  in a valid state\n * to be generating */\n#define ENSURE_VALID_STATE \\\n    if (g->state[g->depth] == yajl_gen_error) {   \\\n        return yajl_gen_in_error_state;\\\n    } else if (g->state[g->depth] == yajl_gen_complete) {   \\\n        return yajl_gen_generation_complete;                \\\n    }\n\n#define INCREMENT_DEPTH \\\n    if (++(g->depth) >= YAJL_MAX_DEPTH) return yajl_max_depth_exceeded;\n\n#define DECREMENT_DEPTH \\\n    if (--(g->depth) >= YAJL_MAX_DEPTH) return yajl_gen_error;\n\n#define APPENDED_ATOM \\\n    switch (g->state[g->depth]) {                   \\\n        case yajl_gen_map_start:                    \\\n        case yajl_gen_map_key:                      \\\n            g->state[g->depth] = yajl_gen_map_val;  \\\n            break;                                  \\\n        case yajl_gen_array_start:                  \\\n            g->state[g->depth] = yajl_gen_in_array; \\\n            break;                                  \\\n        case yajl_gen_map_val:                      \\\n            g->state[g->depth] = yajl_gen_map_key;  \\\n            break;                                  \\\n        default:                                    \\\n            break;                                  \\\n    }                                               \\\n\n#define FINAL_NEWLINE\n    \nyajl_gen_status\nyajl_gen_integer(yajl_gen g, long int number)\n{\n    char i[32];\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    sprintf(i, \"%ld\", number);\n    g->print(g->ctx, i, (unsigned int)strlen(i));\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\n#ifdef WIN32\n#include <float.h>\n#define isnan _isnan\n#define isinf !_finite\n#endif\n\nyajl_gen_status\nyajl_gen_double(yajl_gen g, double number)\n{\n    char i[32];\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; \n    if (isnan(number) || isinf(number)) return yajl_gen_invalid_number;\n    INSERT_SEP; INSERT_WHITESPACE;\n    sprintf(i, \"%.20g\", number);\n    g->print(g->ctx, i, (unsigned int)strlen(i));\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_long(yajl_gen g, long val)\n{\n    char buf[32], *b = buf + sizeof buf;\n    unsigned int len = 0;\n    unsigned long uval;\n\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n\n    if (val < 0) {\n        g->print(g->ctx, \"-\", 1);\n        // Avoid overflow. This shouldn't happen because FIXNUMs are 1 bit less\n        // than LONGs, but good to be safe.\n        uval = 1 + (unsigned long)(-(val + 1));\n    } else {\n        uval = val;\n    }\n\n    do {\n        *--b = \"0123456789\"[uval % 10];\n        uval /= 10;\n        len++;\n    } while(uval);\n    g->print(g->ctx, b, len);\n\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_number(yajl_gen g, const char * s, unsigned int l)\n{\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    g->print(g->ctx, s, l);\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_string(yajl_gen g, const unsigned char * str,\n                unsigned int len)\n{\n    ENSURE_VALID_STATE; INSERT_SEP; INSERT_WHITESPACE;\n    g->print(g->ctx, \"\\\"\", 1);\n    yajl_string_encode2(g->print, g->ctx, str, len, g->htmlSafe);\n    g->print(g->ctx, \"\\\"\", 1);\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_null(yajl_gen g)\n{\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    g->print(g->ctx, \"null\", strlen(\"null\"));\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_bool(yajl_gen g, int boolean)\n{\n    const char * val = boolean ? \"true\" : \"false\";\n\n\tENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    g->print(g->ctx, val, (unsigned int)strlen(val));\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_map_open(yajl_gen g)\n{\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    INCREMENT_DEPTH; \n    \n    g->state[g->depth] = yajl_gen_map_start;\n    g->print(g->ctx, \"{\", 1);\n    if (g->pretty) g->print(g->ctx, \"\\n\", 1);\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_map_close(yajl_gen g)\n{\n    ENSURE_VALID_STATE; \n    DECREMENT_DEPTH;\n    \n    if (g->pretty) g->print(g->ctx, \"\\n\", 1);\n    APPENDED_ATOM;\n    INSERT_WHITESPACE;\n    g->print(g->ctx, \"}\", 1);\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_array_open(yajl_gen g)\n{\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    INCREMENT_DEPTH; \n    g->state[g->depth] = yajl_gen_array_start;\n    g->print(g->ctx, \"[\", 1);\n    if (g->pretty) g->print(g->ctx, \"\\n\", 1);\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_array_close(yajl_gen g)\n{\n    ENSURE_VALID_STATE;\n    DECREMENT_DEPTH;\n    if (g->pretty) g->print(g->ctx, \"\\n\", 1);\n    APPENDED_ATOM;\n    INSERT_WHITESPACE;\n    g->print(g->ctx, \"]\", 1);\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_get_buf(yajl_gen g, const unsigned char ** buf,\n                 unsigned int * len)\n{\n    if (g->print != (yajl_print_t)&yajl_buf_append) return yajl_gen_no_buf;\n    *buf = yajl_buf_data((yajl_buf)g->ctx);\n    *len = yajl_buf_len((yajl_buf)g->ctx);\n    return yajl_gen_status_ok;\n}\n\nvoid\nyajl_gen_clear(yajl_gen g)\n{\n    if (g->print == (yajl_print_t)&yajl_buf_append) yajl_buf_clear((yajl_buf)g->ctx);\n}\n", "/*\n * Copyright 2010, Lloyd Hilaiel.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n * \n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * \n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n * \n *  3. Neither the name of Lloyd Hilaiel nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */ \n\n#include \"yajl_lex.h\"\n#include \"yajl_buf.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nconst char *yajl_tok_name(yajl_tok tok) {\n    switch (tok) {\n        case yajl_tok_bool: return \"bool\";\n        case yajl_tok_colon: return \"colon\";\n        case yajl_tok_comma: return \"comma\";\n        case yajl_tok_eof: return \"eof\";\n        case yajl_tok_error: return \"error\";\n        case yajl_tok_left_brace: return \"open_array\";\n        case yajl_tok_left_bracket: return \"open_object\";\n        case yajl_tok_null: return \"null\";\n        case yajl_tok_integer: return \"integer\";\n        case yajl_tok_double: return \"double\";\n        case yajl_tok_right_brace: return \"close_array\";\n        case yajl_tok_right_bracket: return \"close_object\";\n        case yajl_tok_string: return \"string\";\n        case yajl_tok_string_with_escapes: return \"string_with_escapes\";\n    }\n    return \"unknown\";\n}\n\n/* Impact of the stream parsing feature on the lexer:\n *\n * YAJL support stream parsing.  That is, the ability to parse the first\n * bits of a chunk of JSON before the last bits are available (still on\n * the network or disk).  This makes the lexer more complex.  The\n * responsibility of the lexer is to handle transparently the case where\n * a chunk boundary falls in the middle of a token.  This is\n * accomplished is via a buffer and a character reading abstraction. \n *\n * Overview of implementation\n *\n * When we lex to end of input string before end of token is hit, we\n * copy all of the input text composing the token into our lexBuf.\n * \n * Every time we read a character, we do so through the readChar function.\n * readChar's responsibility is to handle pulling all chars from the buffer\n * before pulling chars from input text\n */\n\nstruct yajl_lexer_t {\n    /* the overal line and char offset into the data */\n    unsigned int lineOff;\n    unsigned int charOff;\n\n    /* error */\n    yajl_lex_error error;\n\n    /* a input buffer to handle the case where a token is spread over\n     * multiple chunks */ \n    yajl_buf buf;\n\n    /* in the case where we have data in the lexBuf, bufOff holds\n     * the current offset into the lexBuf. */\n    unsigned int bufOff;\n\n    /* are we using the lex buf? */\n    unsigned int bufInUse;\n\n    /* shall we allow comments? */\n    unsigned int allowComments;\n\n    /* shall we validate utf8 inside strings? */\n    unsigned int validateUTF8;\n\n    yajl_alloc_funcs * alloc;\n};\n\n#define readChar(lxr, txt, off)                      \\\n    (((lxr)->bufInUse && yajl_buf_len((lxr)->buf) && lxr->bufOff < yajl_buf_len((lxr)->buf)) ? \\\n     (*((const unsigned char *) yajl_buf_data((lxr)->buf) + ((lxr)->bufOff)++)) : \\\n     ((txt)[(*(off))++]))\n\n#define unreadChar(lxr, off) ((*(off) > 0) ? (*(off))-- : ((lxr)->bufOff--))\n\nyajl_lexer\nyajl_lex_alloc(yajl_alloc_funcs * alloc,\n               unsigned int allowComments, unsigned int validateUTF8)\n{\n    yajl_lexer lxr = (yajl_lexer) YA_MALLOC(alloc, sizeof(struct yajl_lexer_t));\n    memset((void *) lxr, 0, sizeof(struct yajl_lexer_t));\n    lxr->buf = yajl_buf_alloc(alloc);\n    lxr->allowComments = allowComments;\n    lxr->validateUTF8 = validateUTF8;\n    lxr->alloc = alloc;\n    return lxr;\n}\n\nyajl_lexer\nyajl_lex_realloc(yajl_lexer orig) {\n    orig->lineOff = 0;\n    orig->charOff = 0;\n    orig->error = yajl_lex_e_ok;\n    yajl_buf_clear(orig->buf);\n    orig->bufOff = 0;\n    orig->bufInUse = 0;\n    return orig;\n}\n\nvoid\nyajl_lex_free(yajl_lexer lxr)\n{\n    yajl_buf_free(lxr->buf);\n    YA_FREE(lxr->alloc, lxr);\n    return;\n}\n\n/* a lookup table which lets us quickly determine three things:\n * VEC - valid escaped conrol char\n * IJC - invalid json char\n * VHC - valid hex char\n * note.  the solidus '/' may be escaped or not.\n * note.  the\n */\n#define VEC 1\n#define IJC 2\n#define VHC 4\nstatic const char charLookupTable[256] =\n{\n/*00*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,\n/*08*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,\n/*10*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,\n/*18*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,\n\n/*20*/ 0      , 0      , VEC|IJC, 0      , 0      , 0      , 0      , 0      ,\n/*28*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , VEC    ,\n/*30*/ VHC    , VHC    , VHC    , VHC    , VHC    , VHC    , VHC    , VHC    ,\n/*38*/ VHC    , VHC    , 0      , 0      , 0      , 0      , 0      , 0      ,\n\n/*40*/ 0      , VHC    , VHC    , VHC    , VHC    , VHC    , VHC    , 0      ,\n/*48*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      ,\n/*50*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      ,\n/*58*/ 0      , 0      , 0      , 0      , VEC|IJC, 0      , 0      , 0      ,\n\n/*60*/ 0      , VHC    , VEC|VHC, VHC    , VHC    , VHC    , VEC|VHC, 0      ,\n/*68*/ 0      , 0      , 0      , 0      , 0      , 0      , VEC    , 0      ,\n/*70*/ 0      , 0      , VEC    , 0      , VEC    , 0      , 0      , 0      ,\n/*78*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      ,\n\n/* include these so we don't have to always check the range of the char */\n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n\n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n\n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n\n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0\n};\n\n/** process a variable length utf8 encoded codepoint.\n *\n *  returns:\n *    yajl_tok_string - if valid utf8 char was parsed and offset was\n *                      advanced\n *    yajl_tok_eof - if end of input was hit before validation could\n *                   complete\n *    yajl_tok_error - if invalid utf8 was encountered\n * \n *  NOTE: on error the offset will point to the first char of the\n *  invalid utf8 */\n#define UTF8_CHECK_EOF if (*offset >= jsonTextLen) { return yajl_tok_eof; }\n\nstatic yajl_tok\nyajl_lex_utf8_char(yajl_lexer lexer, const unsigned char * jsonText,\n                   unsigned int jsonTextLen, unsigned int * offset,\n                   unsigned char curChar)\n{\n    if (curChar <= 0x7f) {\n        /* single byte */\n        return yajl_tok_string;\n    } else if ((curChar >> 5) == 0x6) {\n        /* two byte */ \n        UTF8_CHECK_EOF;\n        curChar = readChar(lexer, jsonText, offset);\n        if ((curChar >> 6) == 0x2) return yajl_tok_string;\n    } else if ((curChar >> 4) == 0x0e) {\n        /* three byte */\n        UTF8_CHECK_EOF;\n        curChar = readChar(lexer, jsonText, offset);\n        if ((curChar >> 6) == 0x2) {\n            UTF8_CHECK_EOF;\n            curChar = readChar(lexer, jsonText, offset);\n            if ((curChar >> 6) == 0x2) return yajl_tok_string;\n        }\n    } else if ((curChar >> 3) == 0x1e) {\n        /* four byte */\n        UTF8_CHECK_EOF;\n        curChar = readChar(lexer, jsonText, offset);\n        if ((curChar >> 6) == 0x2) {\n            UTF8_CHECK_EOF;\n            curChar = readChar(lexer, jsonText, offset);\n            if ((curChar >> 6) == 0x2) {\n                UTF8_CHECK_EOF;\n                curChar = readChar(lexer, jsonText, offset);\n                if ((curChar >> 6) == 0x2) return yajl_tok_string;\n            }\n        }\n    } \n\n    return yajl_tok_error;\n}\n\n/* lex a string.  input is the lexer, pointer to beginning of\n * json text, and start of string (offset).\n * a token is returned which has the following meanings:\n * yajl_tok_string: lex of string was successful.  offset points to\n *                  terminating '\"'.\n * yajl_tok_eof: end of text was encountered before we could complete\n *               the lex.\n * yajl_tok_error: embedded in the string were unallowable chars.  offset\n *               points to the offending char\n */\n#define STR_CHECK_EOF \\\nif (*offset >= jsonTextLen) { \\\n   tok = yajl_tok_eof; \\\n   goto finish_string_lex; \\\n}\n\nstatic yajl_tok\nyajl_lex_string(yajl_lexer lexer, const unsigned char * jsonText,\n                unsigned int jsonTextLen, unsigned int * offset)\n{\n    yajl_tok tok = yajl_tok_error;\n    int hasEscapes = 0;\n\n    for (;;) {\n\t\tunsigned char curChar;\n\n\t\tSTR_CHECK_EOF;\n\n        curChar = readChar(lexer, jsonText, offset);\n\n        /* quote terminates */\n        if (curChar == '\"') {\n            tok = yajl_tok_string;\n            break;\n        }\n        /* backslash escapes a set of control chars, */\n        else if (curChar == '\\\\') {\n            hasEscapes = 1;\n            STR_CHECK_EOF;\n\n            /* special case \\u */\n            curChar = readChar(lexer, jsonText, offset);\n            if (curChar == 'u') {\n                unsigned int i = 0;\n\n                for (i=0;i<4;i++) {\n                    STR_CHECK_EOF;                \n                    curChar = readChar(lexer, jsonText, offset);                \n                    if (!(charLookupTable[curChar] & VHC)) {\n                        /* back up to offending char */\n                        unreadChar(lexer, offset);\n                        lexer->error = yajl_lex_string_invalid_hex_char;\n                        goto finish_string_lex;\n                    }\n                }\n            } else if (!(charLookupTable[curChar] & VEC)) {\n                /* back up to offending char */\n                unreadChar(lexer, offset);\n                lexer->error = yajl_lex_string_invalid_escaped_char;\n                goto finish_string_lex;                \n            } \n        }\n        /* when not validating UTF8 it's a simple table lookup to determine\n         * if the present character is invalid */\n        else if(charLookupTable[curChar] & IJC) {\n            /* back up to offending char */\n            unreadChar(lexer, offset);\n            lexer->error = yajl_lex_string_invalid_json_char;\n            goto finish_string_lex;                \n        }\n        /* when in validate UTF8 mode we need to do some extra work */\n        else if (lexer->validateUTF8) {\n            yajl_tok t = yajl_lex_utf8_char(lexer, jsonText, jsonTextLen,\n                                            offset, curChar);\n            \n            if (t == yajl_tok_eof) {\n                tok = yajl_tok_eof;\n                goto finish_string_lex;\n            } else if (t == yajl_tok_error) {\n                lexer->error = yajl_lex_string_invalid_utf8;\n                goto finish_string_lex;\n            } \n        }\n        /* accept it, and move on */ \n    }\n  finish_string_lex:\n    /* tell our buddy, the parser, wether he needs to process this string\n     * again */\n    if (hasEscapes && tok == yajl_tok_string) {\n        tok = yajl_tok_string_with_escapes;\n    } \n\n    return tok;\n}\n\n#define RETURN_IF_EOF if (*offset >= jsonTextLen) return yajl_tok_eof;\n\nstatic yajl_tok\nyajl_lex_number(yajl_lexer lexer, const unsigned char * jsonText,\n                unsigned int jsonTextLen, unsigned int * offset)\n{\n    /** XXX: numbers are the only entities in json that we must lex\n     *       _beyond_ in order to know that they are complete.  There\n     *       is an ambiguous case for integers at EOF. */\n\n    unsigned char c;\n\n    yajl_tok tok = yajl_tok_integer;\n\n    RETURN_IF_EOF;    \n    c = readChar(lexer, jsonText, offset);\n\n    /* optional leading minus */\n    if (c == '-') {\n        RETURN_IF_EOF;    \n        c = readChar(lexer, jsonText, offset); \n    }\n\n    /* a single zero, or a series of integers */\n    if (c == '0') {\n        RETURN_IF_EOF;    \n        c = readChar(lexer, jsonText, offset); \n    } else if (c >= '1' && c <= '9') {\n        do {\n            RETURN_IF_EOF;    \n            c = readChar(lexer, jsonText, offset); \n        } while (c >= '0' && c <= '9');\n    } else {\n        unreadChar(lexer, offset);\n        lexer->error = yajl_lex_missing_integer_after_minus;\n        return yajl_tok_error;\n    }\n\n    /* optional fraction (indicates this is floating point) */\n    if (c == '.') {\n        int numRd = 0;\n        \n        RETURN_IF_EOF;\n        c = readChar(lexer, jsonText, offset); \n\n        while (c >= '0' && c <= '9') {\n            numRd++;\n            RETURN_IF_EOF;\n            c = readChar(lexer, jsonText, offset); \n        } \n\n        if (!numRd) {\n            unreadChar(lexer, offset);\n            lexer->error = yajl_lex_missing_integer_after_decimal;\n            return yajl_tok_error;\n        }\n        tok = yajl_tok_double;\n    }\n\n    /* optional exponent (indicates this is floating point) */\n    if (c == 'e' || c == 'E') {\n        RETURN_IF_EOF;\n        c = readChar(lexer, jsonText, offset); \n\n        /* optional sign */\n        if (c == '+' || c == '-') {\n            RETURN_IF_EOF;\n            c = readChar(lexer, jsonText, offset); \n        }\n\n        if (c >= '0' && c <= '9') {\n            do {\n                RETURN_IF_EOF;\n                c = readChar(lexer, jsonText, offset); \n            } while (c >= '0' && c <= '9');\n        } else {\n            unreadChar(lexer, offset);\n            lexer->error = yajl_lex_missing_integer_after_exponent;\n            return yajl_tok_error;\n        }\n        tok = yajl_tok_double;\n    }\n    \n    /* we always go \"one too far\" */\n    unreadChar(lexer, offset);\n    \n    return tok;\n}\n\nstatic yajl_tok\nyajl_lex_comment(yajl_lexer lexer, const unsigned char * jsonText,\n                 unsigned int jsonTextLen, unsigned int * offset)\n{\n    unsigned char c;\n\n    yajl_tok tok = yajl_tok_comment;\n\n    RETURN_IF_EOF;    \n    c = readChar(lexer, jsonText, offset);\n\n    /* either slash or star expected */\n    if (c == '/') {\n        /* now we throw away until end of line */\n        do {\n            RETURN_IF_EOF;    \n            c = readChar(lexer, jsonText, offset); \n        } while (c != '\\n');\n    } else if (c == '*') {\n        /* now we throw away until end of comment */        \n        for (;;) {\n            RETURN_IF_EOF;    \n            c = readChar(lexer, jsonText, offset); \n            if (c == '*') {\n                RETURN_IF_EOF;    \n                c = readChar(lexer, jsonText, offset);                 \n                if (c == '/') {\n                    break;\n                } else {\n                    unreadChar(lexer, offset);\n                }\n            }\n        }\n    } else {\n        lexer->error = yajl_lex_invalid_char;\n        tok = yajl_tok_error;\n    }\n    \n    return tok;\n}\n\nyajl_tok\nyajl_lex_lex(yajl_lexer lexer, const unsigned char * jsonText,\n             unsigned int jsonTextLen, unsigned int * offset,\n             const unsigned char ** outBuf, unsigned int * outLen)\n{\n    yajl_tok tok = yajl_tok_error;\n    unsigned char c;\n    unsigned int startOffset = *offset;\n\n    *outBuf = NULL;\n    *outLen = 0;\n\n    for (;;) {\n        assert(*offset <= jsonTextLen);\n\n        if (*offset >= jsonTextLen) {\n            tok = yajl_tok_eof;\n            goto lexed;\n        }\n\n        c = readChar(lexer, jsonText, offset);\n\n        switch (c) {\n            case '{':\n                tok = yajl_tok_left_bracket;\n                goto lexed;\n            case '}':\n                tok = yajl_tok_right_bracket;\n                goto lexed;\n            case '[':\n                tok = yajl_tok_left_brace;\n                goto lexed;\n            case ']':\n                tok = yajl_tok_right_brace;\n                goto lexed;\n            case ',':\n                tok = yajl_tok_comma;\n                goto lexed;\n            case ':':\n                tok = yajl_tok_colon;\n                goto lexed;\n            case '\\t': case '\\n': case '\\v': case '\\f': case '\\r': case ' ':\n                startOffset++;\n                break;\n            case 't': {\n                const char * want = \"rue\";\n                do {\n                    if (*offset >= jsonTextLen) {\n                        tok = yajl_tok_eof;\n                        goto lexed;\n                    }\n                    c = readChar(lexer, jsonText, offset);\n                    if (c != *want) {\n                        unreadChar(lexer, offset);\n                        lexer->error = yajl_lex_invalid_string;\n                        tok = yajl_tok_error;\n                        goto lexed;\n                    }\n                } while (*(++want));\n                tok = yajl_tok_bool;\n                goto lexed;\n            }\n            case 'f': {\n                const char * want = \"alse\";\n                do {\n                    if (*offset >= jsonTextLen) {\n                        tok = yajl_tok_eof;\n                        goto lexed;\n                    }\n                    c = readChar(lexer, jsonText, offset);\n                    if (c != *want) {\n                        unreadChar(lexer, offset);\n                        lexer->error = yajl_lex_invalid_string;\n                        tok = yajl_tok_error;\n                        goto lexed;\n                    }\n                } while (*(++want));\n                tok = yajl_tok_bool;\n                goto lexed;\n            }\n            case 'n': {\n                const char * want = \"ull\";\n                do {\n                    if (*offset >= jsonTextLen) {\n                        tok = yajl_tok_eof;\n                        goto lexed;\n                    }\n                    c = readChar(lexer, jsonText, offset);\n                    if (c != *want) {\n                        unreadChar(lexer, offset);\n                        lexer->error = yajl_lex_invalid_string;\n                        tok = yajl_tok_error;\n                        goto lexed;\n                    }\n                } while (*(++want));\n                tok = yajl_tok_null;\n                goto lexed;\n            }\n            case '\"': {\n                tok = yajl_lex_string(lexer, (const unsigned char *) jsonText,\n                                      jsonTextLen, offset);\n                goto lexed;\n            }\n            case '-':\n            case '0': case '1': case '2': case '3': case '4': \n            case '5': case '6': case '7': case '8': case '9': {\n                /* integer parsing wants to start from the beginning */\n                unreadChar(lexer, offset);\n                tok = yajl_lex_number(lexer, (const unsigned char *) jsonText,\n                                      jsonTextLen, offset);\n                goto lexed;\n            }\n            case '/':\n                /* hey, look, a probable comment!  If comments are disabled\n                 * it's an error. */\n                if (!lexer->allowComments) {\n                    unreadChar(lexer, offset);\n                    lexer->error = yajl_lex_unallowed_comment;\n                    tok = yajl_tok_error;\n                    goto lexed;\n                }\n                /* if comments are enabled, then we should try to lex\n                 * the thing.  possible outcomes are\n                 * - successful lex (tok_comment, which means continue),\n                 * - malformed comment opening (slash not followed by\n                 *   '*' or '/') (tok_error)\n                 * - eof hit. (tok_eof) */\n                tok = yajl_lex_comment(lexer, (const unsigned char *) jsonText,\n                                       jsonTextLen, offset);\n                if (tok == yajl_tok_comment) {\n                    /* \"error\" is silly, but that's the initial\n                     * state of tok.  guilty until proven innocent. */  \n                    tok = yajl_tok_error;\n                    yajl_buf_clear(lexer->buf);\n                    lexer->bufInUse = 0;\n                    startOffset = *offset; \n                    break;\n                }\n                /* hit error or eof, bail */\n                goto lexed;\n            default:\n                lexer->error = yajl_lex_invalid_char;\n                tok = yajl_tok_error;\n                goto lexed;\n        }\n    }\n\n\n  lexed:\n    /* need to append to buffer if the buffer is in use or\n     * if it's an EOF token */\n    if (tok == yajl_tok_eof || lexer->bufInUse) {\n        if (!lexer->bufInUse) yajl_buf_clear(lexer->buf);\n        lexer->bufInUse = 1;\n        yajl_buf_append(lexer->buf, jsonText + startOffset, *offset - startOffset);\n        lexer->bufOff = 0;\n        \n        if (tok != yajl_tok_eof) {\n            *outBuf = yajl_buf_data(lexer->buf);\n            *outLen = yajl_buf_len(lexer->buf);\n            lexer->bufInUse = 0;\n        }\n    } else if (tok != yajl_tok_error) {\n        *outBuf = jsonText + startOffset;\n        *outLen = *offset - startOffset;\n    }\n\n    /* special case for strings. skip the quotes. */\n    if (tok == yajl_tok_string || tok == yajl_tok_string_with_escapes)\n    {\n        assert(*outLen >= 2);\n        (*outBuf)++;\n        *outLen -= 2; \n    }\n\n\n#ifdef YAJL_LEXER_DEBUG\n    if (tok == yajl_tok_error) {\n        printf(\"lexical error: %s\\n\",\n               yajl_lex_error_to_string(yajl_lex_get_error(lexer)));\n    } else if (tok == yajl_tok_eof) {\n        printf(\"EOF hit\\n\");\n    } else {\n        printf(\"lexed %s: '\", tokToStr(tok));\n        fwrite(*outBuf, 1, *outLen, stdout);\n        printf(\"'\\n\");\n    }\n#endif\n\n    return tok;\n}\n\nconst char *\nyajl_lex_error_to_string(yajl_lex_error error)\n{\n    switch (error) {\n        case yajl_lex_e_ok:\n            return \"ok, no error\";\n        case yajl_lex_string_invalid_utf8:\n            return \"invalid bytes in UTF8 string.\";\n        case yajl_lex_string_invalid_escaped_char:\n            return \"inside a string, '\\\\' occurs before a character \"\n                   \"which it may not.\";\n        case yajl_lex_string_invalid_json_char:            \n            return \"invalid character inside string.\";\n        case yajl_lex_string_invalid_hex_char:\n            return \"invalid (non-hex) character occurs after '\\\\u' inside \"\n                   \"string.\";\n        case yajl_lex_invalid_char:\n            return \"invalid char in json text.\";\n        case yajl_lex_invalid_string:\n            return \"invalid string in json text.\";\n        case yajl_lex_missing_integer_after_exponent:\n            return \"malformed number, a digit is required after the exponent.\";\n        case yajl_lex_missing_integer_after_decimal:\n            return \"malformed number, a digit is required after the \"\n                   \"decimal point.\";\n        case yajl_lex_missing_integer_after_minus:\n            return \"malformed number, a digit is required after the \"\n                   \"minus sign.\";\n        case yajl_lex_unallowed_comment:\n            return \"probable comment found in input text, comments are \"\n                   \"not enabled.\";\n    }\n    return \"unknown error code\";\n}\n\n\n/** allows access to more specific information about the lexical\n *  error when yajl_lex_lex returns yajl_tok_error. */\nyajl_lex_error\nyajl_lex_get_error(yajl_lexer lexer)\n{\n    if (lexer == NULL) return (yajl_lex_error) -1;\n    return lexer->error;\n}\n\nunsigned int yajl_lex_current_line(yajl_lexer lexer)\n{\n    return lexer->lineOff;\n}\n\nunsigned int yajl_lex_current_char(yajl_lexer lexer)\n{\n    return lexer->charOff;\n}\n\nyajl_tok yajl_lex_peek(yajl_lexer lexer, const unsigned char * jsonText,\n                       unsigned int jsonTextLen, unsigned int offset)\n{\n    const unsigned char * outBuf;\n    unsigned int outLen;\n    unsigned int bufLen = yajl_buf_len(lexer->buf);\n    unsigned int bufOff = lexer->bufOff;\n    unsigned int bufInUse = lexer->bufInUse;\n    yajl_tok tok;\n    \n    tok = yajl_lex_lex(lexer, jsonText, jsonTextLen, &offset,\n                       &outBuf, &outLen);\n\n    if (tok == yajl_tok_eof) {\n        return tok;\n    }\n\n    lexer->bufOff = bufOff;\n    lexer->bufInUse = bufInUse;\n    yajl_buf_truncate(lexer->buf, bufLen);\n    \n    return tok;\n}\n"], "fixing_code": ["/*\n * Copyright 2010, Lloyd Hilaiel.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n * \n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * \n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n * \n *  3. Neither the name of Lloyd Hilaiel nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */ \n\n/**\n * \\file yajl_gen.h\n * Interface to YAJL's JSON generation facilities.\n */\n\n#include \"api/yajl_common.h\"\n\n#ifndef __YAJL_GEN_H__\n#define __YAJL_GEN_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif    \n    /** generator status codes */\n    typedef enum {\n        /** no error */\n        yajl_gen_status_ok = 0,\n        /** at a point where a map key is generated, a function other than\n         *  yajl_gen_string was called */\n        yajl_gen_keys_must_be_strings,\n        /** YAJL's maximum generation depth was exceeded.  see\n         *  YAJL_MAX_DEPTH */\n        yajl_max_depth_exceeded,\n        /** A generator function (yajl_gen_XXX) was called while in an error\n         *  state */\n        yajl_gen_in_error_state,\n        /** A complete JSON document has been generated */\n        yajl_gen_generation_complete,                \n        /** yajl_gen_double was passed an invalid floating point value\n         *  (infinity or NaN). */\n        yajl_gen_invalid_number,\n        /** A print callback was passed in, so there is no internal\n         * buffer to get from */\n        yajl_gen_no_buf,\n        /** Tried to decrement at depth 0 */\n        yajl_depth_underflow\n    } yajl_gen_status;\n\n    /** an opaque handle to a generator */\n    typedef struct yajl_gen_t * yajl_gen;\n\n    /** a callback used for \"printing\" the results. */\n    typedef void (*yajl_print_t)(void * ctx,\n                                 const char * str,\n                                 unsigned int len);\n\n    /** configuration structure for the generator */\n    typedef struct {\n        /** generate indented (beautiful) output */\n        unsigned int beautify;\n        /** an opportunity to define an indent string.  such as \\\\t or\n         *  some number of spaces.  default is four spaces '    '.  This\n         *  member is only relevant when beautify is true */\n        const char * indentString;\n        /** escape the '/' character */\n        unsigned int htmlSafe;\n    } yajl_gen_config;\n\n    /** allocate a generator handle\n     *  \\param config a pointer to a structure containing parameters which\n     *                configure the behavior of the json generator\n     *  \\param allocFuncs an optional pointer to a structure which allows\n     *                    the client to overide the memory allocation\n     *                    used by yajl.  May be NULL, in which case\n     *                    malloc/free/realloc will be used.\n     *\n     *  \\returns an allocated handle on success, NULL on failure (bad params)\n     */\n    YAJL_API yajl_gen yajl_gen_alloc(const yajl_gen_config * config,\n                                     const yajl_alloc_funcs * allocFuncs);\n\n    /** allocate a generator handle that will print to the specified\n     *  callback rather than storing the results in an internal buffer.\n     *  \\param callback   a pointer to a printer function.  May be NULL\n     *                    in which case, the results will be store in an\n     *                    internal buffer.\n     *  \\param config     a pointer to a structure containing parameters\n     *                    which configure the behavior of the json\n     *                    generator.\n     *  \\param allocFuncs an optional pointer to a structure which allows\n     *                    the client to overide the memory allocation\n     *                    used by yajl.  May be NULL, in which case\n     *                    malloc/free/realloc will be used.\n     *  \\param ctx        a context pointer that will be passed to the\n     *                    printer callback.\n     *\n     *  \\returns an allocated handle on success, NULL on failure (bad params)\n     */\n    YAJL_API yajl_gen yajl_gen_alloc2(const yajl_print_t callback,\n                                      const yajl_gen_config * config,\n                                      const yajl_alloc_funcs * allocFuncs,\n                                      void * ctx);\n\n    /** free a generator handle */    \n    YAJL_API void yajl_gen_free(yajl_gen handle);\n\n    YAJL_API yajl_gen_status yajl_gen_integer(yajl_gen hand, long int number);\n    /** generate a floating point number.  number may not be infinity or\n     *  NaN, as these have no representation in JSON.  In these cases the\n     *  generator will return 'yajl_gen_invalid_number' */\n    YAJL_API yajl_gen_status yajl_gen_double(yajl_gen hand, double number);\n    YAJL_API yajl_gen_status yajl_gen_long(yajl_gen hand, long value);\n    YAJL_API yajl_gen_status yajl_gen_number(yajl_gen hand,\n                                             const char * num,\n                                             unsigned int len);\n    YAJL_API yajl_gen_status yajl_gen_string(yajl_gen hand,\n                                             const unsigned char * str,\n                                             unsigned int len);\n    YAJL_API yajl_gen_status yajl_gen_null(yajl_gen hand);\n    YAJL_API yajl_gen_status yajl_gen_bool(yajl_gen hand, int boolean);\n    YAJL_API yajl_gen_status yajl_gen_map_open(yajl_gen hand);\n    YAJL_API yajl_gen_status yajl_gen_map_close(yajl_gen hand);\n    YAJL_API yajl_gen_status yajl_gen_array_open(yajl_gen hand);\n    YAJL_API yajl_gen_status yajl_gen_array_close(yajl_gen hand);\n\n    /** access the null terminated generator buffer.  If incrementally\n     *  outputing JSON, one should call yajl_gen_clear to clear the\n     *  buffer.  This allows stream generation. */\n    YAJL_API yajl_gen_status yajl_gen_get_buf(yajl_gen hand,\n                                              const unsigned char ** buf,\n                                              unsigned int * len);\n\n    /** clear yajl's output buffer, but maintain all internal generation\n     *  state.  This function will not \"reset\" the generator state, and is\n     *  intended to enable incremental JSON outputing. */\n    YAJL_API void yajl_gen_clear(yajl_gen hand);\n\n#ifdef __cplusplus\n}\n#endif    \n\n#endif\n", "/*\n * Copyright 2010, Lloyd Hilaiel.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n * \n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * \n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n * \n *  3. Neither the name of Lloyd Hilaiel nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */ \n\n#include \"api/yajl_gen.h\"\n#include \"yajl_buf.h\"\n#include \"yajl_encode.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n\ntypedef enum {\n    yajl_gen_start,\n    yajl_gen_map_start,\n    yajl_gen_map_key,\n    yajl_gen_map_val,\n    yajl_gen_array_start,\n    yajl_gen_in_array,\n    yajl_gen_complete,\n    yajl_gen_error\n} yajl_gen_state;\n\nstruct yajl_gen_t \n{\n    unsigned int depth;\n    unsigned int pretty;\n    const char * indentString;\n    yajl_gen_state state[YAJL_MAX_DEPTH];\n    yajl_print_t print;\n    void * ctx; /* yajl_buf */\n    /* memory allocation routines */\n    yajl_alloc_funcs alloc;\n    unsigned int htmlSafe;\n};\n\nyajl_gen\nyajl_gen_alloc(const yajl_gen_config * config,\n               const yajl_alloc_funcs * afs)\n{\n    return yajl_gen_alloc2(NULL, config, afs, NULL);\n}\n\nyajl_gen\nyajl_gen_alloc2(const yajl_print_t callback,\n                const yajl_gen_config * config,\n                const yajl_alloc_funcs * afs,\n                void * ctx)\n{\n    yajl_gen g = NULL;\n    yajl_alloc_funcs afsBuffer;\n\n    /* first order of business is to set up memory allocation routines */\n    if (afs != NULL) {\n        if (afs->malloc == NULL || afs->realloc == NULL || afs->free == NULL)\n        {\n            return NULL;\n        }\n    } else {\n        yajl_set_default_alloc_funcs(&afsBuffer);\n        afs = &afsBuffer;\n    }\n\n    g = (yajl_gen) YA_MALLOC(afs, sizeof(struct yajl_gen_t));\n    if (!g) return NULL;\n\n    memset((void *) g, 0, sizeof(struct yajl_gen_t));\n    /* copy in pointers to allocation routines */\n    memcpy((void *) &(g->alloc), (void *) afs, sizeof(yajl_alloc_funcs));\n\n    if (config) {\n        const char *indent = config->indentString;\n        g->pretty = config->beautify;\n        g->indentString = config->indentString;\n        if (indent) {\n          for (; *indent; indent++) {\n            if (*indent != '\\n'\n                && *indent != '\\v'\n                && *indent != '\\f'\n                && *indent != '\\t'\n                && *indent != '\\r'\n                && *indent != ' ') {\n              g->indentString = NULL;\n              break;\n            }\n          }\n        }\n        if (!g->indentString) {\n          g->indentString = \"  \";\n        }\n        g->htmlSafe = config->htmlSafe;\n    }\n\n    if (callback) {\n        g->print = callback;\n        g->ctx = ctx;\n    } else {\n        g->print = (yajl_print_t)&yajl_buf_append;\n        g->ctx = yajl_buf_alloc(&(g->alloc));\n    }\n\n    return g;\n}\n\nvoid\nyajl_gen_free(yajl_gen g)\n{\n    if (g->print == (yajl_print_t)&yajl_buf_append) yajl_buf_free((yajl_buf)g->ctx);\n    YA_FREE(&(g->alloc), g);\n}\n\n#define INSERT_SEP \\\n    if (g->state[g->depth] == yajl_gen_map_key ||               \\\n        g->state[g->depth] == yajl_gen_in_array) {              \\\n        g->print(g->ctx, \",\", 1);                               \\\n        if (g->pretty) g->print(g->ctx, \"\\n\", 1);               \\\n    } else if (g->state[g->depth] == yajl_gen_map_val) {        \\\n        g->print(g->ctx, \":\", 1);                               \\\n        if (g->pretty) g->print(g->ctx, \" \", 1);                \\\n   } \n\n#define INSERT_WHITESPACE                                               \\\n    if (g->pretty) {                                                    \\\n        if (g->state[g->depth] != yajl_gen_map_val) {                   \\\n            unsigned int _i;                                            \\\n            for (_i=0;_i<g->depth;_i++)                                 \\\n                g->print(g->ctx,                                        \\\n                         g->indentString,                               \\\n                         (unsigned int)strlen(g->indentString));        \\\n        }                                                               \\\n    }\n\n#define ENSURE_NOT_KEY \\\n    if (g->state[g->depth] == yajl_gen_map_key ||       \\\n        g->state[g->depth] == yajl_gen_map_start)  {    \\\n        return yajl_gen_keys_must_be_strings;           \\\n    }                                                   \\\n\n/* check that we're not complete, or in error state.  in a valid state\n * to be generating */\n#define ENSURE_VALID_STATE \\\n    if (g->state[g->depth] == yajl_gen_error) {   \\\n        return yajl_gen_in_error_state;\\\n    } else if (g->state[g->depth] == yajl_gen_complete) {   \\\n        return yajl_gen_generation_complete;                \\\n    }\n\n#define INCREMENT_DEPTH \\\n    if (++(g->depth) >= YAJL_MAX_DEPTH) return yajl_max_depth_exceeded;\n\n#define DECREMENT_DEPTH \\\n    if (--(g->depth) >= YAJL_MAX_DEPTH) return yajl_depth_underflow;\n\n#define APPENDED_ATOM \\\n    switch (g->state[g->depth]) {                   \\\n        case yajl_gen_map_start:                    \\\n        case yajl_gen_map_key:                      \\\n            g->state[g->depth] = yajl_gen_map_val;  \\\n            break;                                  \\\n        case yajl_gen_array_start:                  \\\n            g->state[g->depth] = yajl_gen_in_array; \\\n            break;                                  \\\n        case yajl_gen_map_val:                      \\\n            g->state[g->depth] = yajl_gen_map_key;  \\\n            break;                                  \\\n        default:                                    \\\n            break;                                  \\\n    }                                               \\\n\n#define FINAL_NEWLINE\n    \nyajl_gen_status\nyajl_gen_integer(yajl_gen g, long int number)\n{\n    char i[32];\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    sprintf(i, \"%ld\", number);\n    g->print(g->ctx, i, (unsigned int)strlen(i));\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\n#ifdef WIN32\n#include <float.h>\n#define isnan _isnan\n#define isinf !_finite\n#endif\n\nyajl_gen_status\nyajl_gen_double(yajl_gen g, double number)\n{\n    char i[32];\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; \n    if (isnan(number) || isinf(number)) return yajl_gen_invalid_number;\n    INSERT_SEP; INSERT_WHITESPACE;\n    sprintf(i, \"%.20g\", number);\n    g->print(g->ctx, i, (unsigned int)strlen(i));\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_long(yajl_gen g, long val)\n{\n    char buf[32], *b = buf + sizeof buf;\n    unsigned int len = 0;\n    unsigned long uval;\n\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n\n    if (val < 0) {\n        g->print(g->ctx, \"-\", 1);\n        // Avoid overflow. This shouldn't happen because FIXNUMs are 1 bit less\n        // than LONGs, but good to be safe.\n        uval = 1 + (unsigned long)(-(val + 1));\n    } else {\n        uval = val;\n    }\n\n    do {\n        *--b = \"0123456789\"[uval % 10];\n        uval /= 10;\n        len++;\n    } while(uval);\n    g->print(g->ctx, b, len);\n\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_number(yajl_gen g, const char * s, unsigned int l)\n{\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    g->print(g->ctx, s, l);\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_string(yajl_gen g, const unsigned char * str,\n                unsigned int len)\n{\n    ENSURE_VALID_STATE; INSERT_SEP; INSERT_WHITESPACE;\n    g->print(g->ctx, \"\\\"\", 1);\n    yajl_string_encode2(g->print, g->ctx, str, len, g->htmlSafe);\n    g->print(g->ctx, \"\\\"\", 1);\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_null(yajl_gen g)\n{\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    g->print(g->ctx, \"null\", strlen(\"null\"));\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_bool(yajl_gen g, int boolean)\n{\n    const char * val = boolean ? \"true\" : \"false\";\n\n\tENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    g->print(g->ctx, val, (unsigned int)strlen(val));\n    APPENDED_ATOM;\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_map_open(yajl_gen g)\n{\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    INCREMENT_DEPTH; \n    \n    g->state[g->depth] = yajl_gen_map_start;\n    g->print(g->ctx, \"{\", 1);\n    if (g->pretty) g->print(g->ctx, \"\\n\", 1);\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_map_close(yajl_gen g)\n{\n    ENSURE_VALID_STATE; \n    DECREMENT_DEPTH;\n    \n    if (g->pretty) g->print(g->ctx, \"\\n\", 1);\n    APPENDED_ATOM;\n    INSERT_WHITESPACE;\n    g->print(g->ctx, \"}\", 1);\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_array_open(yajl_gen g)\n{\n    ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;\n    INCREMENT_DEPTH; \n    g->state[g->depth] = yajl_gen_array_start;\n    g->print(g->ctx, \"[\", 1);\n    if (g->pretty) g->print(g->ctx, \"\\n\", 1);\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_array_close(yajl_gen g)\n{\n    ENSURE_VALID_STATE;\n    DECREMENT_DEPTH;\n    if (g->pretty) g->print(g->ctx, \"\\n\", 1);\n    APPENDED_ATOM;\n    INSERT_WHITESPACE;\n    g->print(g->ctx, \"]\", 1);\n    FINAL_NEWLINE;\n    return yajl_gen_status_ok;\n}\n\nyajl_gen_status\nyajl_gen_get_buf(yajl_gen g, const unsigned char ** buf,\n                 unsigned int * len)\n{\n    if (g->print != (yajl_print_t)&yajl_buf_append) return yajl_gen_no_buf;\n    *buf = yajl_buf_data((yajl_buf)g->ctx);\n    *len = yajl_buf_len((yajl_buf)g->ctx);\n    return yajl_gen_status_ok;\n}\n\nvoid\nyajl_gen_clear(yajl_gen g)\n{\n    if (g->print == (yajl_print_t)&yajl_buf_append) yajl_buf_clear((yajl_buf)g->ctx);\n}\n", "/*\n * Copyright 2010, Lloyd Hilaiel.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n * \n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * \n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n * \n *  3. Neither the name of Lloyd Hilaiel nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */ \n\n#include \"yajl_lex.h\"\n#include \"yajl_buf.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nconst char *yajl_tok_name(yajl_tok tok) {\n    switch (tok) {\n        case yajl_tok_bool: return \"bool\";\n        case yajl_tok_colon: return \"colon\";\n        case yajl_tok_comma: return \"comma\";\n        case yajl_tok_comment: return \"comment\";\n        case yajl_tok_eof: return \"eof\";\n        case yajl_tok_error: return \"error\";\n        case yajl_tok_left_brace: return \"open_array\";\n        case yajl_tok_left_bracket: return \"open_object\";\n        case yajl_tok_null: return \"null\";\n        case yajl_tok_integer: return \"integer\";\n        case yajl_tok_double: return \"double\";\n        case yajl_tok_right_brace: return \"close_array\";\n        case yajl_tok_right_bracket: return \"close_object\";\n        case yajl_tok_string: return \"string\";\n        case yajl_tok_string_with_escapes: return \"string_with_escapes\";\n    }\n    return \"unknown\";\n}\n\n/* Impact of the stream parsing feature on the lexer:\n *\n * YAJL support stream parsing.  That is, the ability to parse the first\n * bits of a chunk of JSON before the last bits are available (still on\n * the network or disk).  This makes the lexer more complex.  The\n * responsibility of the lexer is to handle transparently the case where\n * a chunk boundary falls in the middle of a token.  This is\n * accomplished is via a buffer and a character reading abstraction. \n *\n * Overview of implementation\n *\n * When we lex to end of input string before end of token is hit, we\n * copy all of the input text composing the token into our lexBuf.\n * \n * Every time we read a character, we do so through the readChar function.\n * readChar's responsibility is to handle pulling all chars from the buffer\n * before pulling chars from input text\n */\n\nstruct yajl_lexer_t {\n    /* the overal line and char offset into the data */\n    unsigned int lineOff;\n    unsigned int charOff;\n\n    /* error */\n    yajl_lex_error error;\n\n    /* a input buffer to handle the case where a token is spread over\n     * multiple chunks */ \n    yajl_buf buf;\n\n    /* in the case where we have data in the lexBuf, bufOff holds\n     * the current offset into the lexBuf. */\n    unsigned int bufOff;\n\n    /* are we using the lex buf? */\n    unsigned int bufInUse;\n\n    /* shall we allow comments? */\n    unsigned int allowComments;\n\n    /* shall we validate utf8 inside strings? */\n    unsigned int validateUTF8;\n\n    yajl_alloc_funcs * alloc;\n};\n\n#define readChar(lxr, txt, off)                      \\\n    (((lxr)->bufInUse && yajl_buf_len((lxr)->buf) && lxr->bufOff < yajl_buf_len((lxr)->buf)) ? \\\n     (*((const unsigned char *) yajl_buf_data((lxr)->buf) + ((lxr)->bufOff)++)) : \\\n     ((txt)[(*(off))++]))\n\n#define unreadChar(lxr, off) ((*(off) > 0) ? (*(off))-- : ((lxr)->bufOff--))\n\nyajl_lexer\nyajl_lex_alloc(yajl_alloc_funcs * alloc,\n               unsigned int allowComments, unsigned int validateUTF8)\n{\n    yajl_lexer lxr = (yajl_lexer) YA_MALLOC(alloc, sizeof(struct yajl_lexer_t));\n    memset((void *) lxr, 0, sizeof(struct yajl_lexer_t));\n    lxr->buf = yajl_buf_alloc(alloc);\n    lxr->allowComments = allowComments;\n    lxr->validateUTF8 = validateUTF8;\n    lxr->alloc = alloc;\n    return lxr;\n}\n\nyajl_lexer\nyajl_lex_realloc(yajl_lexer orig) {\n    orig->lineOff = 0;\n    orig->charOff = 0;\n    orig->error = yajl_lex_e_ok;\n    yajl_buf_clear(orig->buf);\n    orig->bufOff = 0;\n    orig->bufInUse = 0;\n    return orig;\n}\n\nvoid\nyajl_lex_free(yajl_lexer lxr)\n{\n    yajl_buf_free(lxr->buf);\n    YA_FREE(lxr->alloc, lxr);\n    return;\n}\n\n/* a lookup table which lets us quickly determine three things:\n * VEC - valid escaped conrol char\n * IJC - invalid json char\n * VHC - valid hex char\n * note.  the solidus '/' may be escaped or not.\n * note.  the\n */\n#define VEC 1\n#define IJC 2\n#define VHC 4\nstatic const char charLookupTable[256] =\n{\n/*00*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,\n/*08*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,\n/*10*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,\n/*18*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,\n\n/*20*/ 0      , 0      , VEC|IJC, 0      , 0      , 0      , 0      , 0      ,\n/*28*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , VEC    ,\n/*30*/ VHC    , VHC    , VHC    , VHC    , VHC    , VHC    , VHC    , VHC    ,\n/*38*/ VHC    , VHC    , 0      , 0      , 0      , 0      , 0      , 0      ,\n\n/*40*/ 0      , VHC    , VHC    , VHC    , VHC    , VHC    , VHC    , 0      ,\n/*48*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      ,\n/*50*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      ,\n/*58*/ 0      , 0      , 0      , 0      , VEC|IJC, 0      , 0      , 0      ,\n\n/*60*/ 0      , VHC    , VEC|VHC, VHC    , VHC    , VHC    , VEC|VHC, 0      ,\n/*68*/ 0      , 0      , 0      , 0      , 0      , 0      , VEC    , 0      ,\n/*70*/ 0      , 0      , VEC    , 0      , VEC    , 0      , 0      , 0      ,\n/*78*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      ,\n\n/* include these so we don't have to always check the range of the char */\n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n\n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n\n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n\n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      , \n       0      , 0      , 0      , 0      , 0      , 0      , 0      , 0\n};\n\n/** process a variable length utf8 encoded codepoint.\n *\n *  returns:\n *    yajl_tok_string - if valid utf8 char was parsed and offset was\n *                      advanced\n *    yajl_tok_eof - if end of input was hit before validation could\n *                   complete\n *    yajl_tok_error - if invalid utf8 was encountered\n * \n *  NOTE: on error the offset will point to the first char of the\n *  invalid utf8 */\n#define UTF8_CHECK_EOF if (*offset >= jsonTextLen) { return yajl_tok_eof; }\n\nstatic yajl_tok\nyajl_lex_utf8_char(yajl_lexer lexer, const unsigned char * jsonText,\n                   unsigned int jsonTextLen, unsigned int * offset,\n                   unsigned char curChar)\n{\n    if (curChar <= 0x7f) {\n        /* single byte */\n        return yajl_tok_string;\n    } else if ((curChar >> 5) == 0x6) {\n        /* two byte */ \n        UTF8_CHECK_EOF;\n        curChar = readChar(lexer, jsonText, offset);\n        if ((curChar >> 6) == 0x2) return yajl_tok_string;\n    } else if ((curChar >> 4) == 0x0e) {\n        /* three byte */\n        UTF8_CHECK_EOF;\n        curChar = readChar(lexer, jsonText, offset);\n        if ((curChar >> 6) == 0x2) {\n            UTF8_CHECK_EOF;\n            curChar = readChar(lexer, jsonText, offset);\n            if ((curChar >> 6) == 0x2) return yajl_tok_string;\n        }\n    } else if ((curChar >> 3) == 0x1e) {\n        /* four byte */\n        UTF8_CHECK_EOF;\n        curChar = readChar(lexer, jsonText, offset);\n        if ((curChar >> 6) == 0x2) {\n            UTF8_CHECK_EOF;\n            curChar = readChar(lexer, jsonText, offset);\n            if ((curChar >> 6) == 0x2) {\n                UTF8_CHECK_EOF;\n                curChar = readChar(lexer, jsonText, offset);\n                if ((curChar >> 6) == 0x2) return yajl_tok_string;\n            }\n        }\n    } \n\n    return yajl_tok_error;\n}\n\n/* lex a string.  input is the lexer, pointer to beginning of\n * json text, and start of string (offset).\n * a token is returned which has the following meanings:\n * yajl_tok_string: lex of string was successful.  offset points to\n *                  terminating '\"'.\n * yajl_tok_eof: end of text was encountered before we could complete\n *               the lex.\n * yajl_tok_error: embedded in the string were unallowable chars.  offset\n *               points to the offending char\n */\n#define STR_CHECK_EOF \\\nif (*offset >= jsonTextLen) { \\\n   tok = yajl_tok_eof; \\\n   goto finish_string_lex; \\\n}\n\nstatic yajl_tok\nyajl_lex_string(yajl_lexer lexer, const unsigned char * jsonText,\n                unsigned int jsonTextLen, unsigned int * offset)\n{\n    yajl_tok tok = yajl_tok_error;\n    int hasEscapes = 0;\n\n    for (;;) {\n\t\tunsigned char curChar;\n\n\t\tSTR_CHECK_EOF;\n\n        curChar = readChar(lexer, jsonText, offset);\n\n        /* quote terminates */\n        if (curChar == '\"') {\n            tok = yajl_tok_string;\n            break;\n        }\n        /* backslash escapes a set of control chars, */\n        else if (curChar == '\\\\') {\n            hasEscapes = 1;\n            STR_CHECK_EOF;\n\n            /* special case \\u */\n            curChar = readChar(lexer, jsonText, offset);\n            if (curChar == 'u') {\n                unsigned int i = 0;\n\n                for (i=0;i<4;i++) {\n                    STR_CHECK_EOF;                \n                    curChar = readChar(lexer, jsonText, offset);                \n                    if (!(charLookupTable[curChar] & VHC)) {\n                        /* back up to offending char */\n                        unreadChar(lexer, offset);\n                        lexer->error = yajl_lex_string_invalid_hex_char;\n                        goto finish_string_lex;\n                    }\n                }\n            } else if (!(charLookupTable[curChar] & VEC)) {\n                /* back up to offending char */\n                unreadChar(lexer, offset);\n                lexer->error = yajl_lex_string_invalid_escaped_char;\n                goto finish_string_lex;                \n            } \n        }\n        /* when not validating UTF8 it's a simple table lookup to determine\n         * if the present character is invalid */\n        else if(charLookupTable[curChar] & IJC) {\n            /* back up to offending char */\n            unreadChar(lexer, offset);\n            lexer->error = yajl_lex_string_invalid_json_char;\n            goto finish_string_lex;                \n        }\n        /* when in validate UTF8 mode we need to do some extra work */\n        else if (lexer->validateUTF8) {\n            yajl_tok t = yajl_lex_utf8_char(lexer, jsonText, jsonTextLen,\n                                            offset, curChar);\n            \n            if (t == yajl_tok_eof) {\n                tok = yajl_tok_eof;\n                goto finish_string_lex;\n            } else if (t == yajl_tok_error) {\n                lexer->error = yajl_lex_string_invalid_utf8;\n                goto finish_string_lex;\n            } \n        }\n        /* accept it, and move on */ \n    }\n  finish_string_lex:\n    /* tell our buddy, the parser, wether he needs to process this string\n     * again */\n    if (hasEscapes && tok == yajl_tok_string) {\n        tok = yajl_tok_string_with_escapes;\n    } \n\n    return tok;\n}\n\n#define RETURN_IF_EOF if (*offset >= jsonTextLen) return yajl_tok_eof;\n\nstatic yajl_tok\nyajl_lex_number(yajl_lexer lexer, const unsigned char * jsonText,\n                unsigned int jsonTextLen, unsigned int * offset)\n{\n    /** XXX: numbers are the only entities in json that we must lex\n     *       _beyond_ in order to know that they are complete.  There\n     *       is an ambiguous case for integers at EOF. */\n\n    unsigned char c;\n\n    yajl_tok tok = yajl_tok_integer;\n\n    RETURN_IF_EOF;    \n    c = readChar(lexer, jsonText, offset);\n\n    /* optional leading minus */\n    if (c == '-') {\n        RETURN_IF_EOF;    \n        c = readChar(lexer, jsonText, offset); \n    }\n\n    /* a single zero, or a series of integers */\n    if (c == '0') {\n        RETURN_IF_EOF;    \n        c = readChar(lexer, jsonText, offset); \n    } else if (c >= '1' && c <= '9') {\n        do {\n            RETURN_IF_EOF;    \n            c = readChar(lexer, jsonText, offset); \n        } while (c >= '0' && c <= '9');\n    } else {\n        unreadChar(lexer, offset);\n        lexer->error = yajl_lex_missing_integer_after_minus;\n        return yajl_tok_error;\n    }\n\n    /* optional fraction (indicates this is floating point) */\n    if (c == '.') {\n        int numRd = 0;\n        \n        RETURN_IF_EOF;\n        c = readChar(lexer, jsonText, offset); \n\n        while (c >= '0' && c <= '9') {\n            numRd++;\n            RETURN_IF_EOF;\n            c = readChar(lexer, jsonText, offset); \n        } \n\n        if (!numRd) {\n            unreadChar(lexer, offset);\n            lexer->error = yajl_lex_missing_integer_after_decimal;\n            return yajl_tok_error;\n        }\n        tok = yajl_tok_double;\n    }\n\n    /* optional exponent (indicates this is floating point) */\n    if (c == 'e' || c == 'E') {\n        RETURN_IF_EOF;\n        c = readChar(lexer, jsonText, offset); \n\n        /* optional sign */\n        if (c == '+' || c == '-') {\n            RETURN_IF_EOF;\n            c = readChar(lexer, jsonText, offset); \n        }\n\n        if (c >= '0' && c <= '9') {\n            do {\n                RETURN_IF_EOF;\n                c = readChar(lexer, jsonText, offset); \n            } while (c >= '0' && c <= '9');\n        } else {\n            unreadChar(lexer, offset);\n            lexer->error = yajl_lex_missing_integer_after_exponent;\n            return yajl_tok_error;\n        }\n        tok = yajl_tok_double;\n    }\n    \n    /* we always go \"one too far\" */\n    unreadChar(lexer, offset);\n    \n    return tok;\n}\n\nstatic yajl_tok\nyajl_lex_comment(yajl_lexer lexer, const unsigned char * jsonText,\n                 unsigned int jsonTextLen, unsigned int * offset)\n{\n    unsigned char c;\n\n    yajl_tok tok = yajl_tok_comment;\n\n    RETURN_IF_EOF;    \n    c = readChar(lexer, jsonText, offset);\n\n    /* either slash or star expected */\n    if (c == '/') {\n        /* now we throw away until end of line */\n        do {\n            RETURN_IF_EOF;    \n            c = readChar(lexer, jsonText, offset); \n        } while (c != '\\n');\n    } else if (c == '*') {\n        /* now we throw away until end of comment */        \n        for (;;) {\n            RETURN_IF_EOF;    \n            c = readChar(lexer, jsonText, offset); \n            if (c == '*') {\n                RETURN_IF_EOF;    \n                c = readChar(lexer, jsonText, offset);                 \n                if (c == '/') {\n                    break;\n                } else {\n                    unreadChar(lexer, offset);\n                }\n            }\n        }\n    } else {\n        lexer->error = yajl_lex_invalid_char;\n        tok = yajl_tok_error;\n    }\n    \n    return tok;\n}\n\nyajl_tok\nyajl_lex_lex(yajl_lexer lexer, const unsigned char * jsonText,\n             unsigned int jsonTextLen, unsigned int * offset,\n             const unsigned char ** outBuf, unsigned int * outLen)\n{\n    yajl_tok tok = yajl_tok_error;\n    unsigned char c;\n    unsigned int startOffset = *offset;\n\n    *outBuf = NULL;\n    *outLen = 0;\n\n    for (;;) {\n        assert(*offset <= jsonTextLen);\n\n        if (*offset >= jsonTextLen) {\n            tok = yajl_tok_eof;\n            goto lexed;\n        }\n\n        c = readChar(lexer, jsonText, offset);\n\n        switch (c) {\n            case '{':\n                tok = yajl_tok_left_bracket;\n                goto lexed;\n            case '}':\n                tok = yajl_tok_right_bracket;\n                goto lexed;\n            case '[':\n                tok = yajl_tok_left_brace;\n                goto lexed;\n            case ']':\n                tok = yajl_tok_right_brace;\n                goto lexed;\n            case ',':\n                tok = yajl_tok_comma;\n                goto lexed;\n            case ':':\n                tok = yajl_tok_colon;\n                goto lexed;\n            case '\\t': case '\\n': case '\\v': case '\\f': case '\\r': case ' ':\n                startOffset++;\n                break;\n            case 't': {\n                const char * want = \"rue\";\n                do {\n                    if (*offset >= jsonTextLen) {\n                        tok = yajl_tok_eof;\n                        goto lexed;\n                    }\n                    c = readChar(lexer, jsonText, offset);\n                    if (c != *want) {\n                        unreadChar(lexer, offset);\n                        lexer->error = yajl_lex_invalid_string;\n                        tok = yajl_tok_error;\n                        goto lexed;\n                    }\n                } while (*(++want));\n                tok = yajl_tok_bool;\n                goto lexed;\n            }\n            case 'f': {\n                const char * want = \"alse\";\n                do {\n                    if (*offset >= jsonTextLen) {\n                        tok = yajl_tok_eof;\n                        goto lexed;\n                    }\n                    c = readChar(lexer, jsonText, offset);\n                    if (c != *want) {\n                        unreadChar(lexer, offset);\n                        lexer->error = yajl_lex_invalid_string;\n                        tok = yajl_tok_error;\n                        goto lexed;\n                    }\n                } while (*(++want));\n                tok = yajl_tok_bool;\n                goto lexed;\n            }\n            case 'n': {\n                const char * want = \"ull\";\n                do {\n                    if (*offset >= jsonTextLen) {\n                        tok = yajl_tok_eof;\n                        goto lexed;\n                    }\n                    c = readChar(lexer, jsonText, offset);\n                    if (c != *want) {\n                        unreadChar(lexer, offset);\n                        lexer->error = yajl_lex_invalid_string;\n                        tok = yajl_tok_error;\n                        goto lexed;\n                    }\n                } while (*(++want));\n                tok = yajl_tok_null;\n                goto lexed;\n            }\n            case '\"': {\n                tok = yajl_lex_string(lexer, (const unsigned char *) jsonText,\n                                      jsonTextLen, offset);\n                goto lexed;\n            }\n            case '-':\n            case '0': case '1': case '2': case '3': case '4': \n            case '5': case '6': case '7': case '8': case '9': {\n                /* integer parsing wants to start from the beginning */\n                unreadChar(lexer, offset);\n                tok = yajl_lex_number(lexer, (const unsigned char *) jsonText,\n                                      jsonTextLen, offset);\n                goto lexed;\n            }\n            case '/':\n                /* hey, look, a probable comment!  If comments are disabled\n                 * it's an error. */\n                if (!lexer->allowComments) {\n                    unreadChar(lexer, offset);\n                    lexer->error = yajl_lex_unallowed_comment;\n                    tok = yajl_tok_error;\n                    goto lexed;\n                }\n                /* if comments are enabled, then we should try to lex\n                 * the thing.  possible outcomes are\n                 * - successful lex (tok_comment, which means continue),\n                 * - malformed comment opening (slash not followed by\n                 *   '*' or '/') (tok_error)\n                 * - eof hit. (tok_eof) */\n                tok = yajl_lex_comment(lexer, (const unsigned char *) jsonText,\n                                       jsonTextLen, offset);\n                if (tok == yajl_tok_comment) {\n                    /* \"error\" is silly, but that's the initial\n                     * state of tok.  guilty until proven innocent. */  \n                    tok = yajl_tok_error;\n                    yajl_buf_clear(lexer->buf);\n                    lexer->bufInUse = 0;\n                    startOffset = *offset; \n                    break;\n                }\n                /* hit error or eof, bail */\n                goto lexed;\n            default:\n                lexer->error = yajl_lex_invalid_char;\n                tok = yajl_tok_error;\n                goto lexed;\n        }\n    }\n\n\n  lexed:\n    /* need to append to buffer if the buffer is in use or\n     * if it's an EOF token */\n    if (tok == yajl_tok_eof || lexer->bufInUse) {\n        if (!lexer->bufInUse) yajl_buf_clear(lexer->buf);\n        lexer->bufInUse = 1;\n        yajl_buf_append(lexer->buf, jsonText + startOffset, *offset - startOffset);\n        lexer->bufOff = 0;\n        \n        if (tok != yajl_tok_eof) {\n            *outBuf = yajl_buf_data(lexer->buf);\n            *outLen = yajl_buf_len(lexer->buf);\n            lexer->bufInUse = 0;\n        }\n    } else if (tok != yajl_tok_error) {\n        *outBuf = jsonText + startOffset;\n        *outLen = *offset - startOffset;\n    }\n\n    /* special case for strings. skip the quotes. */\n    if (tok == yajl_tok_string || tok == yajl_tok_string_with_escapes)\n    {\n        assert(*outLen >= 2);\n        (*outBuf)++;\n        *outLen -= 2; \n    }\n\n\n#ifdef YAJL_LEXER_DEBUG\n    if (tok == yajl_tok_error) {\n        printf(\"lexical error: %s\\n\",\n               yajl_lex_error_to_string(yajl_lex_get_error(lexer)));\n    } else if (tok == yajl_tok_eof) {\n        printf(\"EOF hit\\n\");\n    } else {\n        printf(\"lexed %s: '\", tokToStr(tok));\n        fwrite(*outBuf, 1, *outLen, stdout);\n        printf(\"'\\n\");\n    }\n#endif\n\n    return tok;\n}\n\nconst char *\nyajl_lex_error_to_string(yajl_lex_error error)\n{\n    switch (error) {\n        case yajl_lex_e_ok:\n            return \"ok, no error\";\n        case yajl_lex_string_invalid_utf8:\n            return \"invalid bytes in UTF8 string.\";\n        case yajl_lex_string_invalid_escaped_char:\n            return \"inside a string, '\\\\' occurs before a character \"\n                   \"which it may not.\";\n        case yajl_lex_string_invalid_json_char:            \n            return \"invalid character inside string.\";\n        case yajl_lex_string_invalid_hex_char:\n            return \"invalid (non-hex) character occurs after '\\\\u' inside \"\n                   \"string.\";\n        case yajl_lex_invalid_char:\n            return \"invalid char in json text.\";\n        case yajl_lex_invalid_string:\n            return \"invalid string in json text.\";\n        case yajl_lex_missing_integer_after_exponent:\n            return \"malformed number, a digit is required after the exponent.\";\n        case yajl_lex_missing_integer_after_decimal:\n            return \"malformed number, a digit is required after the \"\n                   \"decimal point.\";\n        case yajl_lex_missing_integer_after_minus:\n            return \"malformed number, a digit is required after the \"\n                   \"minus sign.\";\n        case yajl_lex_unallowed_comment:\n            return \"probable comment found in input text, comments are \"\n                   \"not enabled.\";\n    }\n    return \"unknown error code\";\n}\n\n\n/** allows access to more specific information about the lexical\n *  error when yajl_lex_lex returns yajl_tok_error. */\nyajl_lex_error\nyajl_lex_get_error(yajl_lexer lexer)\n{\n    if (lexer == NULL) return (yajl_lex_error) -1;\n    return lexer->error;\n}\n\nunsigned int yajl_lex_current_line(yajl_lexer lexer)\n{\n    return lexer->lineOff;\n}\n\nunsigned int yajl_lex_current_char(yajl_lexer lexer)\n{\n    return lexer->charOff;\n}\n\nyajl_tok yajl_lex_peek(yajl_lexer lexer, const unsigned char * jsonText,\n                       unsigned int jsonTextLen, unsigned int offset)\n{\n    const unsigned char * outBuf;\n    unsigned int outLen;\n    unsigned int bufLen = yajl_buf_len(lexer->buf);\n    unsigned int bufOff = lexer->bufOff;\n    unsigned int bufInUse = lexer->bufInUse;\n    yajl_tok tok;\n    \n    tok = yajl_lex_lex(lexer, jsonText, jsonTextLen, &offset,\n                       &outBuf, &outLen);\n\n    if (tok == yajl_tok_eof) {\n        return tok;\n    }\n\n    lexer->bufOff = bufOff;\n    lexer->bufInUse = bufInUse;\n    yajl_buf_truncate(lexer->buf, bufLen);\n    \n    return tok;\n}\n"], "filenames": ["ext/yajl/api/yajl_gen.h", "ext/yajl/yajl_gen.c", "ext/yajl/yajl_lex.c"], "buggy_code_start_loc": [66, 181, 45], "buggy_code_end_loc": [67, 182, 45], "fixing_code_start_loc": [66, 181, 46], "fixing_code_end_loc": [69, 182, 47], "type": "CWE-122", "message": "yajl-ruby is a C binding to the YAJL JSON parsing and generation library. The 1.x branch and the 2.x branch of `yajl` contain an integer overflow which leads to subsequent heap memory corruption when dealing with large (~2GB) inputs. The reallocation logic at `yajl_buf.c#L64` may result in the `need` 32bit integer wrapping to 0 when `need` approaches a value of 0x80000000 (i.e. ~2GB of data), which results in a reallocation of buf->alloc into a small heap chunk. These integers are declared as `size_t` in the 2.x branch of `yajl`, which practically prevents the issue from triggering on 64bit platforms, however this does not preclude this issue triggering on 32bit builds on which `size_t` is a 32bit integer. Subsequent population of this under-allocated heap chunk is based on the original buffer size, leading to heap memory corruption. This vulnerability mostly impacts process availability. Maintainers believe exploitation for arbitrary code execution is unlikely. A patch is available and anticipated to be part of yajl-ruby version 1.4.2. As a workaround, avoid passing large inputs to YAJL.", "other": {"cve": {"id": "CVE-2022-24795", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-05T16:15:14.050", "lastModified": "2022-04-18T10:05:33.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "yajl-ruby is a C binding to the YAJL JSON parsing and generation library. The 1.x branch and the 2.x branch of `yajl` contain an integer overflow which leads to subsequent heap memory corruption when dealing with large (~2GB) inputs. The reallocation logic at `yajl_buf.c#L64` may result in the `need` 32bit integer wrapping to 0 when `need` approaches a value of 0x80000000 (i.e. ~2GB of data), which results in a reallocation of buf->alloc into a small heap chunk. These integers are declared as `size_t` in the 2.x branch of `yajl`, which practically prevents the issue from triggering on 64bit platforms, however this does not preclude this issue triggering on 32bit builds on which `size_t` is a 32bit integer. Subsequent population of this under-allocated heap chunk is based on the original buffer size, leading to heap memory corruption. This vulnerability mostly impacts process availability. Maintainers believe exploitation for arbitrary code execution is unlikely. A patch is available and anticipated to be part of yajl-ruby version 1.4.2. As a workaround, avoid passing large inputs to YAJL."}, {"lang": "es", "value": "yajl-riuby es un enlace en C a la biblioteca de an\u00e1lisis y generaci\u00f3n de JSON YAJL. La rama 1.x y la rama 2.x de yajl contienen un desbordamiento de enteros que conlleva a una posterior corrupci\u00f3n de la memoria de la pila cuando trata con entradas grandes (~2GB). La l\u00f3gica de reasignaci\u00f3n en \"yajl_buf.c#L64\" puede hacer que el entero de 32 bits \"need\" sea convertido en 0 cuando \"need\" es acercado a un valor de 0x80000000 (es decir, ~2GB de datos), lo que resulta en una reasignaci\u00f3n de buf-)alloc en un peque\u00f1o trozo de pila. Estos enteros est\u00e1n declarados como \"size_t\" en la rama 2.x de \"yajl\", lo que pr\u00e1cticamente evita que el problema ses desencadenado en plataformas de 64 bits, sin embargo esto no impide que este problema sea desencadenado en construcciones de 32 bits en las que \"size_t\" es un entero de 32 bits. El poblamiento posterior de este trozo de pila infra asignado es basado en el tama\u00f1o original del buffer, conllevando una corrupci\u00f3n de la memoria de la pila. Esta vulnerabilidad afecta principalmente a la disponibilidad de los procesos. Los mantenedores creen que la explotaci\u00f3n para una ejecuci\u00f3n de c\u00f3digo arbitrario es poco probable. Se presenta un parche disponible y se espera que forme parte de la versi\u00f3n 1.4.2. Como medida de mitigaci\u00f3n, evite pasar entradas grandes a YAJL"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}, {"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yajl-ruby_project:yajl-ruby:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.4.2", "matchCriteriaId": "FDF3C5E8-7062-41C0-9909-EB5D52893A75"}]}]}], "references": [{"url": "https://github.com/brianmario/yajl-ruby/blob/7168bd79b888900aa94523301126f968a93eb3a6/ext/yajl/yajl_buf.c#L64", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/brianmario/yajl-ruby/commit/7168bd79b888900aa94523301126f968a93eb3a6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/brianmario/yajl-ruby/security/advisories/GHSA-jj47-x69x-mxrm", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/brianmario/yajl-ruby/commit/7168bd79b888900aa94523301126f968a93eb3a6"}}