{"buggy_code": ["# Changelog\nAll notable changes to this project will be documented in this file.\n\n## v2.6-dev - Unreleased\n\n### Improvements\n- Improve layout in \"My Checks\" for checks with long ping URLs (#745)\n- Add support for communicating with signal-cli over TCP (#732)\n- Add /api/v2/ (changes the status reporting of checks in started state) (#633)\n- Update settings.py to read the ADMINS setting from an environment variable\n- Add \"Start Keyword\" filtering for inbound emails (#716)\n\n### Bug Fixes\n- Fix the Signal integration to handle unexpected RPC messages better (#763)\n- Fix special character encoding in Signal notifications (#767)\n- Fix project sort order to be case-insensitive everywhere in the UI (#768)\n- Fix special character encoding in project invite emails\n- Fix check transfer between same account's projects when at check limit\n- Fix wording in the invite email when inviting read-only users\n\n## v2.5 - 2022-12-14\n\n### Improvements\n- Upgrade to fido2 1.1.0 and simplify hc.lib.webauthn\n- Add handling for ipv4address:port values in the X-Forwarded-For header (#714)\n- Add a form for submitting Signal CAPTCHA solutions\n- Add Duration field in the Ping Details dialog (#720)\n- Update Mattermost setup instructions\n- Add support for specifying a run ID via a \"rid\" query parameter (#722)\n- Add last ping body in Slack notifications (#735)\n- Add ntfy integration (#728)\n- Add \".txt\" suffix to the filename when downloading ping body (#738)\n- Add API support for fetching ping bodies (#737)\n- Change \"Settings - Email Reports\" page to allow manual timezone selection\n\n### Bug Fixes\n- Fix the most recent ping lookup in the \"Ping Details\" dialog\n- Fix binary data handling in the hc.front.views.ping_body view\n- Fix downtime summaries in weekly reports (#736)\n- Fix week, month boundary calculation to use user's timezone\n\n## v2.4.1 - 2022-10-18\n\n### Bug Fixes\n- Fix the GHA workflow for building arm/v7 docker image\n\n## v2.4 - 2022-10-18\n\n### Improvements\n- Add support for EMAIL_USE_SSL environment variable (#685)\n- Switch from requests to pycurl\n- Implement documentation search\n- Add date filters in the Log page\n- Upgrade to cronsim 2.3\n- Add support for the $BODY placeholder in webhook payloads (#708)\n- Implement the \"Clear Events\" function\n- Add support for custom topics in Zulip notifications (#583)\n\n### Bug Fixes\n- Fix the handling of TooManyRedirects exceptions\n- Fix MySQL 8 support in the Docker image (upgrade from buster to bullseye) (#717)\n\n## v2.3 - 2022-08-05\n\n### Improvements\n- Update Dockerfile to start SMTP listener (#668)\n- Implement the \"Add Check\" dialog\n- Include last ping type in Slack, Mattermost, Discord notifications\n- Upgrade to cron-descriptor 1.2.30\n- Add \"Filter by keywords in the message body\" feature (#653)\n- Upgrade to HiDPI screenshots in the documentation\n- Add support for the $JSON placeholder in webhook payloads\n- Add ping endpoints for \"log\" events\n- Add the \"Badges\" page in docs\n- Add support for multiple recipients in incoming email (#669)\n- Upgrade to fido2 1.0.0, requests 2.28.1, segno 1.5.2\n- Implement auto-refresh and running indicator in the My Projects page (#681)\n- Upgrade to Django 4.1 and django-compressor 4.1\n- Add API support for resuming paused checks (#687)\n\n### Bug Fixes\n- Fix the display of ignored pings with non-zero exit status\n- Fix a race condition in the \"Change Email\" flow\n- Fix grouping and sorting in the text version of the report/nag emails (#679)\n- Fix the update_timeout and pause views to create flips (for downtime bookkeeping)\n- Fix the checks list to preserve selected filters when adding/updating checks (#684)\n- Fix duration calculation to skip \"log\" and \"ign\" events\n\n## v2.2.1 - 2022-06-13\n\n### Improvements\n- Improve the text version of the alert email template\n\n### Bug Fixes\n- Fix the version number displayed in the footer\n\n## v2.2 - 2022-06-13\n\n### Improvements\n- Add address verification step in the \"Change Email\" flow\n- Reduce logging output from sendalerts and sendreports management commands (#656)\n- Add Ctrl+C handler in sendalerts and sendreports management commands\n- Add notes in docs about configuring uWSGI via UWSGI_ env vars (#656)\n- Implement login link expiration (login links will now expire in 1 hour)\n- Add Gotify integration (#270)\n- Add API support for reading/writing the subject and subject_fail fields (#659)\n- Add \"Disabled\" priority for Pushover notifications (#663)\n\n### Bug Fixes\n- Update hc.front.views.channels to handle empty strings in settings (#635)\n- Add logic to handle ContentDecodingError exceptions\n\n## v2.1 - 2022-05-10\n\n### Improvements\n- Add logic to alert ADMINS when Signal transport hits a CAPTCHA challenge\n- Implement the \"started\" progress spinner in the details pages\n- Add \"hc_check_started\" metric in the Prometheus metrics endpoint (#630)\n- Add a management command for submitting Signal rate limit challenges\n- Upgrade to django-compressor 4.0\n- Update the C# snippet\n- Increase max displayed duration from 24h to 72h (#644)\n- Add \"Ping-Body-Limit\" response header in ping API responses\n\n### Bug Fixes\n- Fix unwanted localization in badge SVG generation (#629)\n- Update email template to handle not yet uploaded ping bodies\n- Add small delay in transports.Email.notify to allow ping body to upload\n- Fix prunenotifications to handle checks with missing pings (#636)\n- Fix \"Send Test Notification\" for integrations that only send \"up\" notifications\n\n## v2.0.1 - 2022-03-18\n\n### Bug Fixes\n- Fix the GHA workflow for building arm/v7 docker image\n\n## v2.0 - 2022-03-18\n\nThis release contains a backwards-incompatible change to the Signal integration\n(hence the major version number bump). Healthchecks uses signal-cli to deliver\nSignal notifications. In the past versions, Healthchecks interfaced with\nsignal-cli over DBus. Starting from this version, Healthchecks interfaces\nwith signal-cli using JSON RPC. Please see README for details on how to set\nthis up.\n\n### Improvements\n- Update Telegram integration to treat \"group chat was deleted\" as permanent error\n- Update email bounce handler to mark email channels as disabled (#446)\n- Update Signal integration to use JSON RPC over UNIX socket\n- Update the \"Add TOTP\" form to display plaintext TOTP secret (#602)\n- Improve PagerDuty notifications\n- Add Ping.body_raw field for storing body as bytes\n- Add support for storing ping bodies in S3-compatible object storage (#609)\n- Add a \"Download Original\" link in the \"Ping Details\" dialog\n\n### Bug Fixes\n- Fix unwanted special character escaping in notification messages (#606)\n- Fix JS error after copying a code snippet\n- Make email non-editable in the \"Invite Member\" dialog when team limit reached\n- Fix Telegram bot to handle TransportError exceptions\n- Fix Signal integration to handle UNREGISTERED_FAILURE errors\n- Fix unwanted localization of period and grace values in data- attributes (#617)\n- Fix Mattermost integration to treat 404 as a transient error (#613)\n\n## v1.25.0 - 2022-01-07\n\n### Improvements\n- Implement Pushover emergency alert cancellation when check goes up\n- Add \"The following checks are also down\" section in Telegram notifications\n- Add \"The following checks are also down\" section in Signal notifications\n- Upgrade to django-compressor 3.0\n- Add support for Telegram channels (#592)\n- Implement Telegram group to supergroup migration (#132)\n- Update the Slack integration to not retry when Slack returns 404\n- Refactor transport classes to raise exceptions on delivery problems\n- Add Channel.disabled field, for disabling integrations on permanent errors\n- Upgrade to Django 4\n- Bump the min. Python version from 3.6 to 3.8 (as required by Django 4)\n\n### Bug Fixes\n- Fix report templates to not show the \"started\" status (show UP or DOWN instead)\n- Update Dockerfile to avoid running \"pip wheel\" more than once (#594)\n\n## v1.24.1 - 2021-11-10\n\n### Bug Fixes\n- Fix Dockerfile for arm/v7 - install all dependencies from piwheels\n\n## v1.24.0 - 2021-11-10\n\n### Improvements\n- Switch from croniter to cronsim\n- Change outgoing webhook timeout to 10s, but cap the total time to 20s\n- Implement automatic `api_ping` and `api_notification` pruning (#556)\n- Update Dockerfile to install apprise (#581)\n- Improve period and grace controls, allow up to 365 day periods (#281)\n- Add SIGTERM handling in sendalerts and sendreports\n- Remove the \"welcome\" landing page, direct users to the sign in form instead\n\n### Bug Fixes\n- Fix hc.api.views.ping to handle non-utf8 data in request body (#574)\n- Fix a crash when hc.api.views.pause receives a single integer in request body\n\n## v1.23.1 - 2021-10-13\n\n### Bug Fixes\n- Fix missing uwsgi dependencies in arm/v7 Docker image\n\n## v1.23.0 - 2021-10-13\n\n### Improvements\n- Add /api/v1/badges/ endpoint (#552)\n- Add ability to edit existing email, Signal, SMS, WhatsApp integrations\n- Add new ping URL format: /{ping_key}/{slug} (#491)\n- Reduce Docker image size by using slim base image and multi-stage Dockerfile\n- Upgrade to Bootstrap 3.4.1\n- Upgrade to jQuery 3.6.0\n\n### Bug Fixes\n- Add handling for non-latin-1 characters in webhook headers\n- Fix dark mode bug in selectpicker widgets\n- Fix a crash during login when user's profile does not exist (#77)\n- Drop API support for GET, DELETE requests with a request body\n- Add missing @csrf_exempt annotations in API views\n- Fix the ping handler to reject status codes > 255\n- Add 'schemaVersion' field in the shields.io endpoint (#566)\n\n## v1.22.0 - 2021-08-06\n\n### Improvements\n- Use multicolor channel icons for better appearance in the dark mode\n- Add SITE_LOGO_URL setting (#323)\n- Add admin action to log in as any user\n- Add a \"Manager\" role (#484)\n- Add support for 2FA using TOTP (#354)\n- Add Whitenoise (#548)\n\n### Bug Fixes\n- Fix dark mode styling issues in Cron Syntax Cheatsheet\n- Fix a 403 when transferring a project to a read-only team member\n- Security: fix allow_redirect function to reject absolute URLs\n\n## v1.21.0 - 2021-07-02\n\n### Improvements\n- Increase \"Success / Failure Keywords\" field lengths to 200\n- Django 3.2.4\n- Improve the handling of unknown email addresses in the Sign In form\n- Add support for \"... is UP\" SMS notifications\n- Add an option for weekly reports (in addition to monthly)\n- Implement PagerDuty Simple Install Flow, remove PD Connect\n- Implement dark mode\n\n### Bug Fixes\n- Fix off-by-one-month error in monthly reports, downtime columns (#539)\n\n## v1.20.0 - 2021-04-22\n\n### Improvements\n- Django 3.2\n- Rename VictorOps -> Splunk On-Call\n- Implement email body decoding in the \"Ping Details\" dialog\n- Add a \"Subject\" field in the \"Ping Details\" dialog\n- Improve HTML email display in the \"Ping Details\" dialog\n- Add a link to check's details page in Slack notifications\n- Replace details_url with cloaked_url in email and chat notifications\n- In the \"My Projects\" page, show projects with failing checks first\n\n### Bug Fixes\n- Fix downtime summary to handle months when the check didn't exist yet (#472)\n- Relax cron expression validation: accept all expressions that croniter accepts\n- Fix sendalerts to clear Profile.next_nag_date if all checks up\n- Fix the pause action to clear Profile.next_nag_date if all checks up\n- Fix the \"Email Reports\" screen to clear Profile.next_nag_date if all checks up\n- Fix the month boundary calculation in monthly reports (#497)\n\n## v1.19.0 - 2021-02-03\n\n### Improvements\n- Add tighter parameter checks in hc.front.views.serve_doc\n- Update OpsGenie instructions (#450)\n- Update the email notification template to include more check and last ping details\n- Improve the crontab snippet in the \"Check Details\" page (#465)\n- Add Signal integration (#428)\n- Change Zulip onboarding, ask for the zuliprc file (#202)\n- Add a section in Docs about running self-hosted instances\n- Add experimental Dockerfile and docker-compose.yml\n- Add rate limiting for Pushover notifications (6 notifications / user / minute)\n- Add support for disabling specific integration types (#471)\n\n### Bug Fixes\n- Fix unwanted HTML escaping in SMS and WhatsApp notifications\n- Fix a crash when adding an integration for an empty Trello account\n- Change icon CSS class prefix to 'ic-' to work around Fanboy's filter list\n\n## v1.18.0 - 2020-12-09\n\n### Improvements\n- Add a tooltip to the 'confirmation link' label (#436)\n- Update API to allow specifying channels by names (#440)\n- When saving a phone number, remove any invisible unicode characers\n- Update the read-only dashboard's CSS for better mobile support (#442)\n- Reduce the number of SQL queries used in the \"Get Checks\" API call\n- Add support for script's exit status in ping URLs (#429)\n- Improve phone number sanitization: remove spaces and hyphens\n- Change the \"Test Integration\" behavior for webhooks: don't retry failed requests\n- Add retries to the the email sending logic\n- Require confirmation codes (sent to email) before sensitive actions\n- Implement WebAuthn two-factor authentication\n- Implement badge mode (up/down vs up/late/down) selector (#282)\n- Add Ping.exitstatus field, store client's reported exit status values (#455)\n- Implement header-based authentication (#457)\n- Add a \"Lost password?\" link with instructions in the Sign In page\n\n### Bug Fixes\n- Fix db field overflow when copying a check with a long name\n\n## v1.17.0 - 2020-10-14\n\n### Improvements\n- Django 3.1\n- Handle status callbacks from Twilio, show delivery failures in Integrations\n- Removing unused /api/v1/notifications/{uuid}/bounce endpoint\n- Less verbose output in the `senddeletionnotices` command\n- Host a read-only dashboard (from github.com/healthchecks/dashboard/)\n- LINE Notify integration (#412)\n- Read-only team members\n- API support for setting the allowed HTTP methods for making ping requests\n\n### Bug Fixes\n- Handle excessively long email addresses in the signup form\n- Handle excessively long email addresses in the team member invite form\n- Don't allow duplicate team memberships\n- When copying a check, copy all fields from the \"Filtering Rules\" dialog (#417)\n- Fix missing Resume button (#421)\n- When decoding inbound emails, decode encoded headers (#420)\n- Escape markdown in MS Teams notifications (#426)\n- Set the \"title\" and \"summary\" fields in MS Teams notifications (#435)\n\n## v1.16.0 - 2020-08-04\n\n### Improvements\n- Paused ping handling can be controlled via API (#376)\n- Add \"Get a list of checks's logged pings\" API call (#371)\n- The /api/v1/checks/ endpoint now accepts either UUID or `unique_key` (#370)\n- Added /api/v1/checks/uuid/flips/ endpoint (#349)\n- In the cron expression dialog, show a human-friendly version of the expression\n- Indicate a started check with a progress spinner under status icon (#338)\n- Added \"Docs > Reliability Tips\" page\n- Spike.sh integration (#402)\n- Updated Discord integration to use discord.com instead of discordapp.com\n- Add \"Failure Keyword\" filtering for inbound emails (#396)\n- Add support for multiple, comma-separated keywords (#396)\n- New integration: phone calls (#403)\n\n### Bug Fixes\n- Removing Pager Team integration, project appears to be discontinued\n- Sending a test notification updates Channel.last_error (#391)\n- Handle HTTP 429 responses from Matrix server when joining a Matrix room\n\n## v1.15.0 - 2020-06-04\n\n### Improvements\n- Rate limiting for Telegram notifications (10 notifications per chat per minute)\n- Use Slack V2 OAuth flow\n- Users can edit their existing webhook integrations (#176)\n- Add a \"Transfer Ownership\" feature in Project Settings\n- In checks list, the pause button asks for confirmation (#356)\n- Added /api/v1/metrics/ endpoint, useful for monitoring the service itself\n- Added \"When paused, ignore pings\" option in the Filtering Rules dialog (#369)\n\n### Bug Fixes\n- \"Get a single check\" API call now supports read-only API keys (#346)\n- Don't escape HTML in the subject line of notification emails\n- Don't let users clone checks if the account is at check limit\n\n## v1.14.0 - 2020-03-23\n\n### Improvements\n- Improved UI to invite users from account's other projects (#258)\n- Experimental Prometheus metrics endpoint (#300)\n- Don't store user's current project in DB, put it explicitly in page URLs (#336)\n- API reference in Markdown\n- Use Selectize.js for entering tags (#324)\n- Zulip integration (#202)\n- OpsGenie integration returns more detailed error messages\n- Telegram integration returns more detailed error messages\n- Added the \"Get a single check\" API call (#337)\n- Display project name in Slack notifications (#342)\n\n### Bug Fixes\n- The \"render_docs\" command checks if markdown and pygments is installed (#329)\n- The team size limit is applied to the n. of distinct users across all projects (#332)\n- API: don't let SuspiciousOperation bubble up when validating channel ids\n- API security: check channel ownership when setting check's channels\n- API: update check's \"alert_after\" field when changing schedule\n- API: validate channel identifiers before creating/updating a check (#335)\n- Fix redirect after login when adding Telegram integration\n\n## v1.13.0 - 2020-02-13\n\n### Improvements\n- Show a red \"!\" in project's top navigation if any integration is not working\n- createsuperuser management command requires an unique email address (#318)\n- For superusers, show \"Site Administration\" in top navigation, note in README (#317)\n- Make Ping.body size limit configurable (#301)\n- Show sub-second durations with higher precision, 2 digits after decimal point (#321)\n- Replace the gear icon with three horizontal dots icon (#322)\n- Add a Pause button in the checks list (#312)\n- Documentation in Markdown\n- Added an example of capturing and submitting log output (#315)\n- The sendalerts commands measures dwell time and reports it over statsd protocol\n- Django 3.0.3\n- Show a warning in top navigation if the project has no integrations (#327)\n\n### Bug Fixes\n- Increase the allowable length of Matrix room alias to 100 (#320)\n- Make sure Check.last_ping and Ping.created timestamps match exactly\n- Don't trigger \"down\" notifications when changing schedule interactively in web UI\n- Fix sendalerts crash loop when encountering a bad cron schedule\n- Stricter cron validation, reject schedules like \"At midnight of February 31\"\n- In hc.front.views.ping_details, if a ping does not exist, return a friendly message\n\n## v1.12.0 - 2020-01-02\n\n### Improvements\n- Django 3.0\n- \"Filtering Rules\" dialog, an option to require HTTP POST (#297)\n- Show Healthchecks version in Django admin header (#306)\n- Added JSON endpoint for Shields.io (#304)\n- `senddeletionnotices` command skips profiles with recent last_active_date\n- The \"Update Check\" API call can update check's description (#311)\n\n### Bug Fixes\n- Don't set CSRF cookie on first visit. Signup is exempt from CSRF protection\n- Fix List-Unsubscribe email header value: add angle brackets\n- Unsubscribe links serve a form, and require HTTP POST to actually unsubscribe\n- For webhook integration, validate each header line separately\n- Fix \"Send Test Notification\" for webhooks that only fire on checks going up\n- Don't allow adding webhook integrations with both URLs blank\n- Don't allow adding email integrations with both \"up\" and \"down\" unchecked\n\n\n## v1.11.0 - 2019-11-22\n\n### Improvements\n- In monthly reports, no downtime stats for the current month (month has just started)\n- Add Microsoft Teams integration (#135)\n- Add Profile.last_active_date field for more accurate inactive user detection\n- Add \"Shell Commands\" integration (#302)\n- PagerDuty integration works with or without PD_VENDOR_KEY (#303)\n\n### Bug Fixes\n - On mobile, \"My Checks\" page, always show the gear (Details) button (#286)\n - Make log events fit better on mobile screens\n\n\n## v1.10.0 - 2019-10-21\n\n### Improvements\n- Add the \"Last Duration\" field in the \"My Checks\" page (#257)\n- Add \"last_duration\" attribute to the Check API resource (#257)\n- Upgrade to psycopg2 2.8.3\n- Add Go usage example\n- Send monthly reports on 1st of every month, not randomly during the month\n- Signup form sets the \"auto-login\" cookie to avoid an extra click during first login\n- Autofocus the email field in the signup form, and submit on enter key\n- Add support for OpsGenie EU region (#294)\n- Update OpsGenie logo and setup illustrations\n- Add a \"Create a Copy\" function for cloning checks (#288)\n- Send email notification when monthly SMS sending limit is reached (#292)\n\n### Bug Fixes\n- Prevent double-clicking the submit button in signup form\n- Upgrade to Django 2.2.6 \u2013 fixes sqlite migrations (#284)\n\n\n## v1.9.0 - 2019-09-03\n\n### Improvements\n- Show the number of downtimes and total downtime minutes in monthly reports (#104)\n- Show the number of downtimes and total downtime minutes in \"Check Details\" page\n- Add the `pruneflips` management command\n- Add Mattermost integration (#276)\n- Three choices in timezone switcher (UTC / check's timezone / browser's timezone) (#278)\n- After adding a new check redirect to the \"Check Details\" page\n\n### Bug Fixes\n- Fix javascript code to construct correct URLs when running from a subdirectory (#273)\n- Don't show the \"Sign Up\" link in the login page if registration is closed (#280)\n\n## v1.8.0 - 2019-07-08\n\n### Improvements\n- Add the `prunetokenbucket` management command\n- Show check counts in JSON \"badges\" (#251)\n- Webhooks support HTTP PUT (#249)\n- Webhooks can use different req. bodies and headers for \"up\" and \"down\" events (#249)\n- Show check's code instead of full URL on 992px - 1200px wide screens (#253)\n- Add WhatsApp integration (uses Twilio same as the SMS integration)\n- Webhooks support the $TAGS placeholder\n- Don't include ping URLs in API responses when the read-only key is used\n\n### Bug Fixes\n- Fix badges for tags containing special characters (#240, #237)\n- Fix the \"Integrations\" page for when the user has no active project\n- Prevent email clients from opening the one-time login links (#255)\n- Fix `prunepings` and `prunepingsslow`, they got broken when adding Projects (#264)\n\n\n## v1.7.0 - 2019-05-02\n\n### Improvements\n- Add the EMAIL_USE_VERIFICATION configuration setting (#232)\n- Show \"Badges\" and \"Settings\" in top navigation (#234)\n- Upgrade to Django 2.2\n- Can configure the email integration to only report the \"down\" events (#231)\n- Add \"Test!\" function in the Integrations page (#207)\n- Rate limiting for the log in attempts\n- Password strength meter and length check in the \"Set Password\" form\n- Show the Description section even if the description is missing. (#246)\n- Include the description in email alerts. (#247)\n\n\n## v1.6.0 - 2019-04-01\n\n### Improvements\n- Add the \"desc\" field (check's description) to API responses\n- Add maxlength attribute to HTML input=text elements\n- Improved logic for displaying job execution times in log (#219)\n- Add Matrix integration\n- Add Pager Team integration\n- Add a management command for sending inactive account notifications\n\n### Bug Fixes\n- Fix refreshing of the checks page filtered by tags (#221)\n- Escape asterisks in Slack messages (#223)\n- Fix a \"invalid time format\" in front.views.status_single on Windows hosts\n\n\n## v1.5.0 - 2019-02-04\n\n### Improvements\n- Database schema: add uniqueness constraint to Check.code\n- Database schema: add Ping.kind field. Remove \"start\" and \"fail\" fields\n- Add \"Email Settings...\" dialog and \"Subject Must Contain\" setting\n- Database schema: add the Project model\n- Move project-specific settings to a new \"Project Settings\" page\n- Add a \"Transfer to Another Project...\" dialog\n- Add the \"My Projects\" page\n\n\n## v1.4.0 - 2018-12-25\n\n### Improvements\n- Set Pushover alert priorities for \"down\" and \"up\" events separately\n- Additional python usage examples\n- Allow simultaneous access to checks from different teams\n- Add CORS support to API endpoints\n- Flip model, for tracking status changes of the Check objects\n- Add `/ping/<code>/start` API endpoint\n- When using the `/start` endpoint, show elapsed times in ping log\n\n### Bug Fixes\n- Fix after-login redirects (the \"?next=\" query parameter)\n- Update Check.status field when user edits timeout & grace settings\n- Use timezone-aware datetimes with croniter, avoid ambiguities around DST\n- Validate and reject cron schedules with six components\n\n\n## v1.3.0 - 2018-11-21\n\n### Improvements\n- Load settings from environment variables\n- Add \"List-Unsubscribe\" header to alert and report emails\n- Don't send monthly reports to inactive accounts (no pings in 6 months)\n- Add search box in the \"My Checks\" page\n- Add read-only API key support\n- Remove Profile.bill_to field (obsolete)\n- Show a warning when running with DEBUG=True\n- Add \"channels\" attribute to the Check API resource\n- Can specify channel codes when updating a check via API\n- Add a workaround for email agents automatically opening \"Unsubscribe\" links\n- Add Channel.name field, users can now name integrations\n- Add \"Get a List of Existing Integrations\" API call\n\n### Bug Fixes\n- During DST transition, handle ambiguous dates as pre-transition\n\n\n## v1.2.0 - 2018-10-20\n\n### Improvements\n- Content updates in the \"Welcome\" page.\n- Added \"Docs > Third-Party Resources\" page.\n- Improved  layout and styling in \"Login\" page.\n- Separate \"Sign Up\" and \"Log In\" forms.\n- \"My Checks\" page: support filtering checks by query string parameters.\n- Added Trello integration\n\n### Bug Fixes\n- Timezones were missing in the \"Change Schedule\" dialog, fixed.\n- Fix hamburger menu button in \"Login\" page.\n\n\n## v1.1.0 - 2018-08-20\n\n### Improvements\n- A new \"Check Details\" page.\n- Updated django-compressor, psycopg2, pytz, requests package versions.\n- C# usage example.\n- Checks have a \"Description\" field.\n", "from __future__ import annotations\n\nfrom datetime import timedelta as td\n\nfrom django import forms\nfrom django.contrib.auth import authenticate\nfrom django.contrib.auth.models import User\n\nfrom hc.accounts.models import REPORT_CHOICES, Member\nfrom hc.api.models import TokenBucket\nfrom hc.lib.tz import all_timezones\n\n\nclass LowercaseEmailField(forms.EmailField):\n    def clean(self, value):\n        value = super(LowercaseEmailField, self).clean(value)\n        return value.lower()\n\n\nclass SignupForm(forms.Form):\n    # Call it \"identity\" instead of \"email\"\n    # to avoid some of the dumber bots\n    identity = LowercaseEmailField(\n        error_messages={\"required\": \"Please enter your email address.\"}\n    )\n    tz = forms.CharField(required=False)\n\n    def clean_identity(self):\n        v = self.cleaned_data[\"identity\"]\n        if len(v) > 254:\n            raise forms.ValidationError(\"Address is too long.\")\n\n        if User.objects.filter(email=v).exists():\n            raise forms.ValidationError(\n                \"An account with this email address already exists.\"\n            )\n\n        return v\n\n    def clean_tz(self):\n        # Declare tz as \"clean\" only if we can find it in hc.lib.tz.all_timezones\n        if self.cleaned_data[\"tz\"] in all_timezones:\n            return self.cleaned_data[\"tz\"]\n\n        # Otherwise, return None, and *don't* throw a validation exception:\n        # If user's browser reports a timezone we don't recognize, we\n        # should ignore the timezone but still save the rest of the form.\n\n\nclass EmailLoginForm(forms.Form):\n    # Call it \"identity\" instead of \"email\"\n    # to avoid some of the dumber bots\n    identity = LowercaseEmailField()\n\n    def clean_identity(self):\n        v = self.cleaned_data[\"identity\"]\n        if not TokenBucket.authorize_login_email(v):\n            raise forms.ValidationError(\"Too many attempts, please try later.\")\n\n        try:\n            self.user = User.objects.get(email=v)\n        except User.DoesNotExist:\n            raise forms.ValidationError(\"Unknown email address.\")\n\n        return v\n\n\nclass PasswordLoginForm(forms.Form):\n    email = LowercaseEmailField()\n    password = forms.CharField()\n\n    def clean(self):\n        username = self.cleaned_data.get(\"email\")\n        password = self.cleaned_data.get(\"password\")\n\n        if username and password:\n            if not TokenBucket.authorize_login_password(username):\n                raise forms.ValidationError(\"Too many attempts, please try later.\")\n\n            self.user = authenticate(username=username, password=password)\n            if self.user is None or not self.user.is_active:\n                raise forms.ValidationError(\"Incorrect email or password.\")\n\n        return self.cleaned_data\n\n\nclass ReportSettingsForm(forms.Form):\n    reports = forms.ChoiceField(choices=REPORT_CHOICES)\n    nag_period = forms.IntegerField(min_value=0, max_value=86400)\n    tz = forms.CharField()\n\n    def clean_nag_period(self):\n        seconds = self.cleaned_data[\"nag_period\"]\n\n        if seconds not in (0, 3600, 86400):\n            raise forms.ValidationError(\"Bad nag_period: %d\" % seconds)\n\n        return td(seconds=seconds)\n\n    def clean_tz(self):\n        # Declare tz as \"clean\" only if we can find it in hc.lib.tz.all_timezones\n        if self.cleaned_data[\"tz\"] in all_timezones:\n            return self.cleaned_data[\"tz\"]\n\n        # Otherwise, return None, and *don't* throw a validation exception:\n        # If user's browser reports a timezone we don't recognize, we\n        # should ignore the timezone but still save the rest of the form.\n\n\nclass SetPasswordForm(forms.Form):\n    password = forms.CharField(min_length=8)\n\n\nclass ChangeEmailForm(forms.Form):\n    error_css_class = \"has-error\"\n    email = LowercaseEmailField()\n\n    def clean_email(self):\n        v = self.cleaned_data[\"email\"]\n        if User.objects.filter(email=v).exists():\n            raise forms.ValidationError(\"%s is already registered\" % v)\n\n        return v\n\n\nclass InviteTeamMemberForm(forms.Form):\n    email = LowercaseEmailField(max_length=254)\n    role = forms.ChoiceField(choices=Member.Role.choices)\n\n\nclass RemoveTeamMemberForm(forms.Form):\n    email = LowercaseEmailField()\n\n\nclass ProjectNameForm(forms.Form):\n    name = forms.CharField(max_length=60)\n\n\nclass TransferForm(forms.Form):\n    email = LowercaseEmailField()\n\n\nclass AddWebAuthnForm(forms.Form):\n    name = forms.CharField(max_length=100)\n    response = forms.CharField()\n\n\nclass WebAuthnForm(forms.Form):\n    response = forms.CharField()\n\n\nclass TotpForm(forms.Form):\n    error_css_class = \"has-error\"\n    code = forms.RegexField(regex=r\"^\\d{6}$\")\n\n    def __init__(self, totp, post=None, files=None):\n        self.totp = totp\n        super(TotpForm, self).__init__(post, files)\n\n    def clean_code(self):\n        if not self.totp.verify(self.cleaned_data[\"code\"], valid_window=1):\n            raise forms.ValidationError(\"The code you entered was incorrect.\")\n\n        return self.cleaned_data[\"code\"]\n", "from __future__ import annotations\n\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.test.utils import override_settings\n\nfrom hc.accounts.models import Credential\nfrom hc.api.models import Check, TokenBucket\nfrom hc.test import BaseTestCase\n\n\nclass LoginTestCase(BaseTestCase):\n    def setUp(self):\n        super().setUp()\n        self.checks_url = f\"/projects/{self.project.code}/checks/\"\n\n    def test_it_shows_form(self):\n        r = self.client.get(\"/accounts/login/\")\n        self.assertContains(r, \"Email Me a Link\")\n\n    def test_it_redirects_authenticated_get(self):\n        self.client.login(username=\"alice@example.org\", password=\"password\")\n\n        r = self.client.get(\"/accounts/login/\")\n        self.assertRedirects(r, self.checks_url)\n\n    @override_settings(SITE_ROOT=\"http://testserver\", SITE_LOGO_URL=None)\n    def test_it_sends_link(self):\n        form = {\"identity\": \"alice@example.org\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(r, \"/accounts/login_link_sent/\")\n\n        # And email should have been sent\n        self.assertEqual(len(mail.outbox), 1)\n        message = mail.outbox[0]\n        self.assertEqual(message.subject, f\"Log in to {settings.SITE_NAME}\")\n        html = message.alternatives[0][0]\n        self.assertIn(\"http://testserver/static/img/logo.png\", html)\n        self.assertIn(\"http://testserver/docs/\", html)\n\n    @override_settings(SITE_LOGO_URL=\"https://example.org/logo.svg\")\n    def test_it_uses_custom_logo(self):\n        self.client.post(\"/accounts/login/\", {\"identity\": \"alice@example.org\"})\n        html = mail.outbox[0].alternatives[0][0]\n        self.assertIn(\"https://example.org/logo.svg\", html)\n\n    def test_it_sends_link_with_next(self):\n        form = {\"identity\": \"alice@example.org\"}\n\n        r = self.client.post(\"/accounts/login/?next=\" + self.channels_url, form)\n        self.assertRedirects(r, \"/accounts/login_link_sent/\")\n        self.assertIn(\"auto-login\", r.cookies)\n\n        # The check_token link should have a ?next= query parameter:\n        self.assertEqual(len(mail.outbox), 1)\n        body = mail.outbox[0].body\n        self.assertTrue(\"/?next=\" + self.channels_url in body)\n\n    @override_settings(SECRET_KEY=\"test-secret\")\n    def test_it_rate_limits_emails(self):\n        # \"d60d...\" is sha1(\"alice@example.orgtest-secret\")\n        obj = TokenBucket(value=\"em-d60db3b2343e713a4de3e92d4eb417e4f05f06ab\")\n        obj.tokens = 0\n        obj.save()\n\n        form = {\"identity\": \"alice@example.org\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertContains(r, \"Too many attempts\")\n\n        # No email should have been sent\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_it_pops_bad_link_from_session(self):\n        self.client.session[\"bad_link\"] = True\n        self.client.get(\"/accounts/login/\")\n        assert \"bad_link\" not in self.client.session\n\n    def test_it_ignores_case(self):\n        form = {\"identity\": \"ALICE@EXAMPLE.ORG\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(r, \"/accounts/login_link_sent/\")\n\n        self.profile.refresh_from_db()\n        self.assertTrue(self.profile.token)\n\n    def test_it_handles_password(self):\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(r, self.checks_url)\n\n    @override_settings(SECRET_KEY=\"test-secret\")\n    def test_it_rate_limits_password_attempts(self):\n        # \"d60d...\" is sha1(\"alice@example.orgtest-secret\")\n        obj = TokenBucket(value=\"pw-d60db3b2343e713a4de3e92d4eb417e4f05f06ab\")\n        obj.tokens = 0\n        obj.save()\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertContains(r, \"Too many attempts\")\n\n    def test_it_handles_password_login_with_redirect(self):\n        check = Check.objects.create(project=self.project)\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        samples = [self.channels_url, \"/checks/%s/details/\" % check.code]\n\n        for s in samples:\n            r = self.client.post(\"/accounts/login/?next=%s\" % s, form)\n            self.assertRedirects(r, s)\n\n    def test_it_handles_bad_next_parameter(self):\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        samples = [\n            \"/evil/\",\n            f\"https://example.org/projects/{self.project.code}/checks/\",\n        ]\n\n        for sample in samples:\n            r = self.client.post(\"/accounts/login/?next=\" + sample, form)\n            self.assertRedirects(r, self.checks_url)\n\n    def test_it_handles_wrong_password(self):\n        form = {\n            \"action\": \"login\",\n            \"email\": \"alice@example.org\",\n            \"password\": \"wrong password\",\n        }\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertContains(r, \"Incorrect email or password\")\n\n    @override_settings(REGISTRATION_OPEN=False)\n    def test_it_obeys_registration_open(self):\n        r = self.client.get(\"/accounts/login/\")\n        self.assertNotContains(r, \"Create Your Account\")\n\n    def test_it_redirects_to_webauthn_form(self):\n        Credential.objects.create(user=self.alice, name=\"Alices Key\")\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(\n            r, \"/accounts/login/two_factor/\", fetch_redirect_response=False\n        )\n\n        # It should not log the user in yet\n        self.assertNotIn(\"_auth_user_id\", self.client.session)\n\n        # Instead, it should set 2fa_user_id in the session\n        user_id, email, valid_until = self.client.session[\"2fa_user\"]\n        self.assertEqual(user_id, self.alice.id)\n\n    def test_it_redirects_to_totp_form(self):\n        self.profile.totp = \"0\" * 32\n        self.profile.save()\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(\n            r, \"/accounts/login/two_factor/totp/\", fetch_redirect_response=False\n        )\n\n        # It should not log the user in yet\n        self.assertNotIn(\"_auth_user_id\", self.client.session)\n\n        # Instead, it should set 2fa_user_id in the session\n        user_id, email, valid_until = self.client.session[\"2fa_user\"]\n        self.assertEqual(user_id, self.alice.id)\n\n    def test_it_handles_missing_profile(self):\n        self.profile.delete()\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(r, self.checks_url)\n", "from __future__ import annotations\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import User\nfrom django.core import mail\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\n\nfrom hc.accounts.models import Profile, Project\nfrom hc.api.models import Channel, Check\n\n\nclass SignupTestCase(TestCase):\n    @override_settings(USE_PAYMENTS=False)\n    def test_it_works(self):\n        form = {\"identity\": \"alice@example.org\", \"tz\": \"Europe/Riga\"}\n\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"Account created\")\n        self.assertIn(\"auto-login\", r.cookies)\n\n        # An user should have been created\n        user = User.objects.get()\n\n        # A profile should have been created\n        profile = Profile.objects.get()\n        self.assertEqual(profile.check_limit, 10000)\n        self.assertEqual(profile.sms_limit, 10000)\n        self.assertEqual(profile.call_limit, 10000)\n        self.assertEqual(profile.tz, \"Europe/Riga\")\n\n        # And email sent\n        self.assertEqual(len(mail.outbox), 1)\n        subject = \"Log in to %s\" % settings.SITE_NAME\n        self.assertEqual(mail.outbox[0].subject, subject)\n\n        # A project should have been created\n        project = Project.objects.get()\n        self.assertEqual(project.owner, user)\n        self.assertEqual(project.badge_key, user.username)\n\n        # And check should be associated with the new user\n        check = Check.objects.get()\n        self.assertEqual(check.name, \"My First Check\")\n        self.assertEqual(check.slug, \"my-first-check\")\n        self.assertEqual(check.project, project)\n\n        # A channel should have been created\n        channel = Channel.objects.get()\n        self.assertEqual(channel.project, project)\n\n    @override_settings(USE_PAYMENTS=True)\n    def test_it_sets_limits(self):\n        form = {\"identity\": \"alice@example.org\", \"tz\": \"\"}\n\n        self.client.post(\"/accounts/signup/\", form)\n\n        profile = Profile.objects.get()\n        self.assertEqual(profile.check_limit, 20)\n        self.assertEqual(profile.sms_limit, 5)\n        self.assertEqual(profile.call_limit, 0)\n\n    @override_settings(REGISTRATION_OPEN=False)\n    def test_it_obeys_registration_open(self):\n        form = {\"identity\": \"dan@example.org\", \"tz\": \"\"}\n\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertEqual(r.status_code, 403)\n\n    def test_it_ignores_case(self):\n        form = {\"identity\": \"ALICE@EXAMPLE.ORG\", \"tz\": \"\"}\n        self.client.post(\"/accounts/signup/\", form)\n\n        # There should be exactly one user:\n        q = User.objects.filter(email=\"alice@example.org\")\n        self.assertTrue(q.exists)\n\n    def test_it_checks_for_existing_users(self):\n        alice = User(username=\"alice\", email=\"alice@example.org\")\n        alice.save()\n\n        form = {\"identity\": \"alice@example.org\", \"tz\": \"\"}\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"already exists\")\n\n    def test_it_checks_syntax(self):\n        form = {\"identity\": \"alice at example org\", \"tz\": \"\"}\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"Enter a valid email address\")\n\n    def test_it_checks_length(self):\n        aaa = \"a\" * 300\n        form = {\"identity\": f\"alice+{aaa}@example.org\", \"tz\": \"\"}\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"Address is too long.\")\n\n        self.assertFalse(User.objects.exists())\n\n    @override_settings(USE_PAYMENTS=False)\n    def test_it_ignores_bad_tz(self):\n        form = {\"identity\": \"alice@example.org\", \"tz\": \"Foo/Bar\"}\n\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"Account created\")\n        self.assertIn(\"auto-login\", r.cookies)\n\n        profile = Profile.objects.get()\n        self.assertEqual(profile.tz, \"UTC\")\n", "from __future__ import annotations\n\nimport time\nimport uuid\nfrom datetime import timedelta as td\nfrom secrets import token_urlsafe\nfrom urllib.parse import urlparse\n\nimport pyotp\nimport segno\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import authenticate\nfrom django.contrib.auth import login as auth_login\nfrom django.contrib.auth import logout as auth_logout\nfrom django.contrib.auth import update_session_auth_hash\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.models import User\nfrom django.core.signing import BadSignature, SignatureExpired, TimestampSigner\nfrom django.db import transaction\nfrom django.db.models.functions import Lower\nfrom django.http import HttpResponse, HttpResponseBadRequest, HttpResponseForbidden\nfrom django.shortcuts import get_object_or_404, redirect, render\nfrom django.urls import Resolver404, resolve, reverse\nfrom django.utils.timezone import now\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.http import require_POST\n\nfrom hc.accounts import forms\nfrom hc.accounts.decorators import require_sudo_mode\nfrom hc.accounts.models import Credential, Member, Profile, Project\nfrom hc.api.models import Channel, Check, TokenBucket\nfrom hc.lib.tz import all_timezones\nfrom hc.lib.webauthn import CreateHelper, GetHelper\nfrom hc.payments.models import Subscription\n\nPOST_LOGIN_ROUTES = (\n    \"hc-checks\",\n    \"hc-details\",\n    \"hc-log\",\n    \"hc-channels\",\n    \"hc-add-slack\",\n    \"hc-add-pushover\",\n    \"hc-add-telegram\",\n    \"hc-project-settings\",\n    \"hc-uncloak\",\n)\n\n\ndef _allow_redirect(redirect_url):\n    if not redirect_url:\n        return False\n\n    parsed = urlparse(redirect_url)\n    if parsed.netloc:\n        # Allow redirects only to relative URLs\n        return False\n\n    try:\n        match = resolve(parsed.path)\n    except Resolver404:\n        return False\n\n    return match.url_name in POST_LOGIN_ROUTES\n\n\ndef _make_user(email, tz=None, with_project=True):\n    username = str(uuid.uuid4())[:30]\n    user = User(username=username, email=email)\n    user.set_unusable_password()\n    user.save()\n\n    project = None\n    if with_project:\n        project = Project(owner=user)\n        project.badge_key = user.username\n        project.save()\n\n        check = Check(project=project)\n        check.set_name_slug(\"My First Check\")\n        check.save()\n\n        channel = Channel(project=project)\n        channel.kind = \"email\"\n        channel.value = email\n        channel.email_verified = True\n        channel.save()\n\n        channel.checks.add(check)\n\n    # Ensure a profile gets created\n    profile = Profile.objects.for_user(user)\n    if tz:\n        profile.tz = tz\n        profile.save()\n\n    return user\n\n\ndef _redirect_after_login(request):\n    \"\"\"Redirect to the URL indicated in ?next= query parameter.\"\"\"\n\n    redirect_url = request.GET.get(\"next\")\n    if _allow_redirect(redirect_url):\n        return redirect(redirect_url)\n\n    if request.user.project_set.count() == 1:\n        project = request.user.project_set.first()\n        return redirect(\"hc-checks\", project.code)\n\n    return redirect(\"hc-index\")\n\n\ndef _check_2fa(request, user):\n    have_keys = user.credentials.exists()\n    profile = Profile.objects.for_user(user)\n    if have_keys or profile.totp:\n        # We have verified user's password or token, and now must\n        # verify their security key. We store the following in user's session:\n        # - user.id, to look up the user in the login_webauthn view\n        # - user.email, to make sure email was not changed between the auth steps\n        # - timestamp, to limit the max time between the auth steps\n        request.session[\"2fa_user\"] = [user.id, user.email, int(time.time())]\n\n        if have_keys:\n            path = reverse(\"hc-login-webauthn\")\n        else:\n            path = reverse(\"hc-login-totp\")\n\n        redirect_url = request.GET.get(\"next\")\n        if _allow_redirect(redirect_url):\n            path += \"?next=%s\" % redirect_url\n\n        return redirect(path)\n\n    auth_login(request, user)\n    return _redirect_after_login(request)\n\n\ndef _new_key(nbytes=24):\n    while True:\n        candidate = token_urlsafe(nbytes)\n        if candidate[0] not in \"-_\" and candidate[-1] not in \"-_\":\n            return candidate\n\n\ndef login(request):\n    form = forms.PasswordLoginForm()\n    magic_form = forms.EmailLoginForm()\n\n    if request.method == \"POST\":\n        if request.POST.get(\"action\") == \"login\":\n            form = forms.PasswordLoginForm(request.POST)\n            if form.is_valid():\n                return _check_2fa(request, form.user)\n\n        else:\n            magic_form = forms.EmailLoginForm(request.POST)\n            if magic_form.is_valid():\n                redirect_url = request.GET.get(\"next\")\n                if not _allow_redirect(redirect_url):\n                    redirect_url = None\n\n                profile = Profile.objects.for_user(magic_form.user)\n                profile.send_instant_login_link(redirect_url=redirect_url)\n                response = redirect(\"hc-login-link-sent\")\n\n                # check_token looks for this cookie to decide if\n                # it needs to do the extra POST step.\n                response.set_cookie(\"auto-login\", \"1\", max_age=300, httponly=True)\n                return response\n\n    if request.user.is_authenticated:\n        return _redirect_after_login(request)\n\n    bad_link = request.session.pop(\"bad_link\", None)\n    ctx = {\n        \"page\": \"login\",\n        \"form\": form,\n        \"magic_form\": magic_form,\n        \"bad_link\": bad_link,\n        \"registration_open\": settings.REGISTRATION_OPEN,\n        \"support_email\": settings.SUPPORT_EMAIL,\n    }\n    return render(request, \"accounts/login.html\", ctx)\n\n\n@require_POST\ndef logout(request):\n    auth_logout(request)\n    return redirect(\"hc-index\")\n\n\n@require_POST\n@csrf_exempt\ndef signup(request):\n    if not settings.REGISTRATION_OPEN:\n        return HttpResponseForbidden()\n\n    ctx = {}\n    form = forms.SignupForm(request.POST)\n    if form.is_valid():\n        email = form.cleaned_data[\"identity\"]\n        tz = form.cleaned_data[\"tz\"]\n        user = _make_user(email, tz)\n        profile = Profile.objects.for_user(user)\n        profile.send_instant_login_link()\n        ctx[\"created\"] = True\n    else:\n        ctx = {\"form\": form}\n\n    response = render(request, \"accounts/signup_result.html\", ctx)\n    if ctx.get(\"created\"):\n        response.set_cookie(\"auto-login\", \"1\", max_age=300, httponly=True)\n\n    return response\n\n\ndef login_link_sent(request):\n    return render(request, \"accounts/login_link_sent.html\")\n\n\ndef check_token(request, username, token, new_email=None):\n    if request.user.is_authenticated:\n        auth_logout(request)\n\n    # Some email servers open links in emails to check for malicious content.\n    # To work around this, we sign user in if the method is POST\n    # *or* if the browser presents a cookie we had set when sending the login link.\n    #\n    # If the method is GET and the auto-login cookie isn't present, we serve\n    # a HTML form with a submit button.\n    if request.method != \"POST\" and \"auto-login\" not in request.COOKIES:\n        return render(request, \"accounts/check_token_submit.html\")\n\n    user = authenticate(username=username, token=token)\n    if user is not None and user.is_active:\n        if new_email:\n            if User.objects.filter(email=new_email).exists():\n                request.session[\"bad_link\"] = True\n                return redirect(\"hc-login\")\n\n            user.email = new_email\n            user.set_unusable_password()\n            user.save()\n\n        user.profile.token = \"\"\n        user.profile.save()\n        return _check_2fa(request, user)\n\n    request.session[\"bad_link\"] = True\n    return redirect(\"hc-login\")\n\n\n@login_required\ndef profile(request):\n    profile = request.profile\n\n    ctx = {\n        \"page\": \"profile\",\n        \"profile\": profile,\n        \"my_projects_status\": \"default\",\n        \"2fa_status\": \"default\",\n        \"added_credential_name\": request.session.pop(\"added_credential_name\", \"\"),\n        \"removed_credential_name\": request.session.pop(\"removed_credential_name\", \"\"),\n        \"enabled_totp\": request.session.pop(\"enabled_totp\", False),\n        \"disabled_totp\": request.session.pop(\"disabled_totp\", False),\n        \"credentials\": list(request.user.credentials.order_by(\"id\")),\n        \"use_webauthn\": settings.RP_ID,\n    }\n\n    if ctx[\"added_credential_name\"] or ctx[\"enabled_totp\"]:\n        ctx[\"2fa_status\"] = \"success\"\n\n    if ctx[\"removed_credential_name\"] or ctx[\"disabled_totp\"]:\n        ctx[\"2fa_status\"] = \"info\"\n\n    if request.session.pop(\"changed_password\", False):\n        ctx[\"changed_password\"] = True\n        ctx[\"email_password_status\"] = \"success\"\n\n    if request.method == \"POST\" and \"leave_project\" in request.POST:\n        code = request.POST[\"code\"]\n        try:\n            project = Project.objects.get(code=code, member__user=request.user)\n        except Project.DoesNotExist:\n            return HttpResponseBadRequest()\n\n        Member.objects.filter(project=project, user=request.user).delete()\n\n        ctx[\"left_project\"] = project\n        ctx[\"my_projects_status\"] = \"info\"\n\n    ctx[\"ownerships\"] = request.user.project_set.order_by(Lower(\"name\"))\n    ctx[\"memberships\"] = request.user.memberships.order_by(Lower(\"project__name\"))\n    return render(request, \"accounts/profile.html\", ctx)\n\n\n@login_required\n@require_POST\ndef add_project(request):\n    form = forms.ProjectNameForm(request.POST)\n    if not form.is_valid():\n        return HttpResponseBadRequest()\n\n    project = Project(owner=request.user)\n    project.code = project.badge_key = str(uuid.uuid4())\n    project.name = form.cleaned_data[\"name\"]\n    project.save()\n\n    return redirect(\"hc-checks\", project.code)\n\n\n@login_required\ndef project(request, code):\n    project = get_object_or_404(Project, code=code)\n    is_owner = project.owner_id == request.user.id\n\n    if request.user.is_superuser or is_owner:\n        is_manager = True\n        rw = True\n    else:\n        membership = get_object_or_404(Member, project=project, user=request.user)\n        is_manager = membership.role == Member.Role.MANAGER\n        rw = membership.is_rw\n\n    ctx = {\n        \"page\": \"project\",\n        \"rw\": rw,\n        \"project\": project,\n        \"is_owner\": is_owner,\n        \"is_manager\": is_manager,\n        \"show_api_keys\": \"show_api_keys\" in request.GET,\n        \"enable_prometheus\": settings.PROMETHEUS_ENABLED is True,\n    }\n\n    if request.method == \"POST\":\n        if \"create_key\" in request.POST:\n            if not rw:\n                return HttpResponseForbidden()\n\n            if request.POST[\"create_key\"] == \"api_key\":\n                project.api_key = _new_key(24)\n            elif request.POST[\"create_key\"] == \"api_key_readonly\":\n                project.api_key_readonly = _new_key(24)\n            elif request.POST[\"create_key\"] == \"ping_key\":\n                project.ping_key = _new_key(16)\n            project.save()\n\n            ctx[\"key_created\"] = True\n            ctx[\"api_status\"] = \"success\"\n            ctx[\"show_keys\"] = True\n        elif \"revoke_key\" in request.POST:\n            if not rw:\n                return HttpResponseForbidden()\n\n            if request.POST[\"revoke_key\"] == \"api_key\":\n                project.api_key = \"\"\n            elif request.POST[\"revoke_key\"] == \"api_key_readonly\":\n                project.api_key_readonly = \"\"\n            elif request.POST[\"revoke_key\"] == \"ping_key\":\n                project.ping_key = None\n            project.save()\n\n            ctx[\"key_revoked\"] = True\n            ctx[\"api_status\"] = \"info\"\n        elif \"show_keys\" in request.POST:\n            if not rw:\n                return HttpResponseForbidden()\n\n            ctx[\"show_keys\"] = True\n        elif \"invite_team_member\" in request.POST:\n            if not is_manager:\n                return HttpResponseForbidden()\n\n            form = forms.InviteTeamMemberForm(request.POST)\n            if form.is_valid():\n                email = form.cleaned_data[\"email\"]\n\n                invite_suggestions = project.invite_suggestions()\n                if not invite_suggestions.filter(email=email).exists():\n                    # We're inviting a new user. Are we within team size limit?\n                    if not project.can_invite_new_users():\n                        return HttpResponseForbidden()\n\n                    # And are we not hitting a rate limit?\n                    if not TokenBucket.authorize_invite(request.user):\n                        return render(request, \"try_later.html\")\n\n                try:\n                    user = User.objects.get(email=email)\n                except User.DoesNotExist:\n                    user = _make_user(email, with_project=False)\n\n                if project.invite(user, role=form.cleaned_data[\"role\"]):\n                    ctx[\"team_member_invited\"] = email\n                    ctx[\"team_status\"] = \"success\"\n                else:\n                    ctx[\"team_member_duplicate\"] = email\n                    ctx[\"team_status\"] = \"info\"\n\n        elif \"remove_team_member\" in request.POST:\n            if not is_manager:\n                return HttpResponseForbidden()\n\n            form = forms.RemoveTeamMemberForm(request.POST)\n            if form.is_valid():\n                q = User.objects\n                q = q.filter(email=form.cleaned_data[\"email\"])\n                q = q.filter(memberships__project=project)\n                farewell_user = q.first()\n                if farewell_user is None:\n                    return HttpResponseBadRequest()\n\n                if farewell_user == request.user:\n                    return HttpResponseBadRequest()\n\n                Member.objects.filter(project=project, user=farewell_user).delete()\n\n                ctx[\"team_member_removed\"] = form.cleaned_data[\"email\"]\n                ctx[\"team_status\"] = \"info\"\n        elif \"set_project_name\" in request.POST:\n            if not rw:\n                return HttpResponseForbidden()\n\n            form = forms.ProjectNameForm(request.POST)\n            if form.is_valid():\n                project.name = form.cleaned_data[\"name\"]\n                project.save()\n\n                ctx[\"project_name_updated\"] = True\n                ctx[\"project_name_status\"] = \"success\"\n\n        elif \"transfer_project\" in request.POST:\n            if not is_owner:\n                return HttpResponseForbidden()\n\n            form = forms.TransferForm(request.POST)\n            if form.is_valid():\n                # Look up the proposed new owner\n                email = form.cleaned_data[\"email\"]\n                try:\n                    membership = project.member_set.filter(user__email=email).get()\n                except Member.DoesNotExist:\n                    return HttpResponseBadRequest()\n\n                # Revoke any previous transfer requests\n                project.member_set.update(transfer_request_date=None)\n\n                # Initiate the new request\n                membership.transfer_request_date = now()\n                membership.save()\n\n                # Send an email notification\n                profile = Profile.objects.for_user(membership.user)\n                profile.send_transfer_request(project)\n\n                ctx[\"transfer_initiated\"] = True\n                ctx[\"transfer_status\"] = \"success\"\n\n        elif \"cancel_transfer\" in request.POST:\n            if not is_owner:\n                return HttpResponseForbidden()\n\n            project.member_set.update(transfer_request_date=None)\n            ctx[\"transfer_cancelled\"] = True\n            ctx[\"transfer_status\"] = \"success\"\n\n        elif \"accept_transfer\" in request.POST:\n            tr = project.transfer_request()\n            if not tr or tr.user != request.user:\n                return HttpResponseForbidden()\n\n            if not tr.can_accept():\n                return HttpResponseBadRequest()\n\n            with transaction.atomic():\n                # 1. Reuse the existing membership, and change its user\n                tr.user = project.owner\n                tr.transfer_request_date = None\n                # The previous owner becomes a regular member\n                # (not readonly, not manager):\n                tr.role = Member.Role.REGULAR\n                tr.save()\n\n                # 2. Change project's owner\n                project.owner = request.user\n                project.save()\n\n            ctx[\"is_owner\"] = True\n            ctx[\"is_manager\"] = True\n            messages.success(request, \"You are now the owner of this project!\")\n\n        elif \"reject_transfer\" in request.POST:\n            tr = project.transfer_request()\n            if not tr or tr.user != request.user:\n                return HttpResponseForbidden()\n\n            tr.transfer_request_date = None\n            tr.save()\n\n    q = project.member_set.select_related(\"user\").order_by(\"user__email\")\n    ctx[\"memberships\"] = list(q)\n    ctx[\"can_invite_new_users\"] = project.can_invite_new_users()\n    return render(request, \"accounts/project.html\", ctx)\n\n\n@login_required\ndef notifications(request):\n    profile = request.profile\n\n    ctx = {\n        \"status\": \"default\",\n        \"page\": \"profile\",\n        \"profile\": profile,\n        \"timezones\": all_timezones,\n    }\n\n    if request.method == \"POST\":\n        form = forms.ReportSettingsForm(request.POST)\n        if form.is_valid():\n            if form.cleaned_data[\"tz\"]:\n                profile.tz = form.cleaned_data[\"tz\"]\n            profile.reports = form.cleaned_data[\"reports\"]\n            profile.next_report_date = profile.choose_next_report_date()\n\n            if profile.nag_period != form.cleaned_data[\"nag_period\"]:\n                # Set the new nag period\n                profile.nag_period = form.cleaned_data[\"nag_period\"]\n                # and update next_nag_date:\n                if profile.nag_period:\n                    profile.update_next_nag_date()\n                else:\n                    profile.next_nag_date = None\n\n            profile.save()\n            ctx[\"status\"] = \"info\"\n\n    return render(request, \"accounts/notifications.html\", ctx)\n\n\n@login_required\n@require_sudo_mode\ndef set_password(request):\n    if request.method == \"POST\":\n        form = forms.SetPasswordForm(request.POST)\n        if form.is_valid():\n            password = form.cleaned_data[\"password\"]\n            request.user.set_password(password)\n            request.user.save()\n\n            request.profile.token = \"\"\n            request.profile.save()\n\n            # update the session with the new password hash so that\n            # the user doesn't  get logged out\n            update_session_auth_hash(request, request.user)\n\n            request.session[\"changed_password\"] = True\n            return redirect(\"hc-profile\")\n\n    return render(request, \"accounts/set_password.html\", {})\n\n\n@login_required\n@require_sudo_mode\ndef change_email(request):\n    if \"sent\" in request.session:\n        ctx = {\"email\": request.session.pop(\"sent\")}\n        return render(request, \"accounts/change_email_instructions.html\", ctx)\n\n    if request.method == \"POST\":\n        form = forms.ChangeEmailForm(request.POST)\n        if form.is_valid():\n            # The user has entered a valid-looking new email address.\n            # Send a special login link to the new address. When the user\n            # clicks the special login link, hc.accounts.views.change_email_verify\n            # unpacks the payload, and passes it to hc.accounts.views.check_token,\n            # which finally updates user's email address.\n            email = form.cleaned_data[\"email\"]\n            request.profile.send_change_email_link(email)\n            request.session[\"sent\"] = email\n\n            response = redirect(reverse(\"hc-change-email\"))\n            # check_token looks for this cookie to decide if\n            # it needs to do the extra POST step.\n            response.set_cookie(\"auto-login\", \"1\", max_age=900, httponly=True)\n            return response\n    else:\n        form = forms.ChangeEmailForm()\n\n    return render(request, \"accounts/change_email.html\", {\"form\": form})\n\n\ndef change_email_verify(request, signed_payload):\n    try:\n        payload = TimestampSigner().unsign_object(signed_payload, max_age=900)\n    except BadSignature:\n        return render(request, \"bad_link.html\")\n\n    return check_token(request, payload[\"u\"], payload[\"t\"], payload[\"e\"])\n\n\n@csrf_exempt\ndef unsubscribe_reports(request, signed_username):\n    # Some email servers open links in emails to check for malicious content.\n    # To work around this, for GET requests we serve a confirmation form.\n    # If the signature is more than 5 minutes old, we also include JS code to\n    # auto-submit the form.\n\n    signer = TimestampSigner(salt=\"reports\")\n    # First, check the signature without looking at the timestamp:\n    try:\n        username = signer.unsign(signed_username)\n    except BadSignature:\n        return render(request, \"bad_link.html\")\n\n    try:\n        user = User.objects.get(username=username)\n    except User.DoesNotExist:\n        # This is likely an old unsubscribe link, and the user account has already\n        # been deleted. Show the \"Unsubscribed!\" page nevertheless.\n        return render(request, \"accounts/unsubscribed.html\")\n\n    if request.method != \"POST\":\n        # Unsign again, now with max_age set,\n        # to see if the timestamp is older than 5 minutes\n        try:\n            autosubmit = False\n            username = signer.unsign(signed_username, max_age=300)\n        except SignatureExpired:\n            autosubmit = True\n\n        ctx = {\"autosubmit\": autosubmit}\n        return render(request, \"accounts/unsubscribe_submit.html\", ctx)\n\n    profile = Profile.objects.for_user(user)\n    profile.reports = \"off\"\n    profile.next_report_date = None\n    profile.nag_period = td()\n    profile.next_nag_date = None\n    profile.save()\n\n    return render(request, \"accounts/unsubscribed.html\")\n\n\n@login_required\n@require_sudo_mode\ndef close(request):\n    user = request.user\n\n    if request.method == \"POST\":\n        if request.POST.get(\"confirmation\") == request.user.email:\n            # Cancel their subscription:\n            if sub := Subscription.objects.filter(user=user).first():\n                sub.cancel()\n\n            # Deleting user also deletes its profile, checks, channels etc.\n            user.delete()\n\n            request.session.flush()\n            return redirect(\"hc-login\")\n\n    ctx = {}\n    if \"confirmation\" in request.POST:\n        ctx[\"wrong_confirmation\"] = True\n\n    return render(request, \"accounts/close_account.html\", ctx)\n\n\n@require_POST\n@login_required\ndef remove_project(request, code):\n    project = get_object_or_404(Project, code=code, owner=request.user)\n    project.delete()\n    return redirect(\"hc-index\")\n\n\n@login_required\n@require_sudo_mode\ndef add_webauthn(request):\n    if not settings.RP_ID:\n        return HttpResponse(status=404)\n\n    credentials = request.user.credentials.values_list(\"data\", flat=True)\n    helper = CreateHelper(settings.RP_ID, credentials)\n\n    if request.method == \"POST\":\n        form = forms.AddWebAuthnForm(request.POST)\n        if not form.is_valid():\n            return HttpResponseBadRequest()\n\n        state = request.session[\"state\"]\n        credential_bytes = helper.verify(state, form.cleaned_data[\"response\"])\n        if credential_bytes is None:\n            return HttpResponseBadRequest()\n\n        c = Credential(user=request.user)\n        c.name = form.cleaned_data[\"name\"]\n        c.data = credential_bytes\n        c.save()\n\n        request.session.pop(\"state\")\n        request.session[\"added_credential_name\"] = c.name\n        return redirect(\"hc-profile\")\n\n    options, request.session[\"state\"] = helper.prepare(request.user.email)\n    return render(request, \"accounts/add_credential.html\", {\"options\": options})\n\n\n@login_required\n@require_sudo_mode\ndef add_totp(request):\n    if request.profile.totp:\n        # TOTP is already configured, refuse to continue\n        return HttpResponseBadRequest()\n\n    if \"totp_secret\" not in request.session:\n        request.session[\"totp_secret\"] = pyotp.random_base32()\n\n    totp = pyotp.totp.TOTP(request.session[\"totp_secret\"])\n\n    if request.method == \"POST\":\n        form = forms.TotpForm(totp, request.POST)\n        if form.is_valid():\n            request.profile.totp = request.session[\"totp_secret\"]\n            request.profile.totp_created = now()\n            request.profile.save()\n\n            request.session[\"enabled_totp\"] = True\n            request.session.pop(\"totp_secret\")\n            return redirect(\"hc-profile\")\n    else:\n        form = forms.TotpForm(totp)\n\n    uri = totp.provisioning_uri(name=request.user.email, issuer_name=settings.SITE_NAME)\n    qr_data_uri = segno.make(uri).png_data_uri(scale=8)\n    ctx = {\n        \"form\": form,\n        \"qr_data_uri\": qr_data_uri,\n        \"secret\": request.session[\"totp_secret\"],\n    }\n    return render(request, \"accounts/add_totp.html\", ctx)\n\n\n@login_required\n@require_sudo_mode\ndef remove_totp(request):\n    if request.method == \"POST\" and \"disable_totp\" in request.POST:\n        request.profile.totp = None\n        request.profile.totp_created = None\n        request.profile.save()\n        request.session[\"disabled_totp\"] = True\n        return redirect(\"hc-profile\")\n\n    ctx = {\"is_last\": not request.user.credentials.exists()}\n    return render(request, \"accounts/remove_totp.html\", ctx)\n\n\n@login_required\n@require_sudo_mode\ndef remove_credential(request, code):\n    if not settings.RP_ID:\n        return HttpResponse(status=404)\n\n    try:\n        credential = Credential.objects.get(user=request.user, code=code)\n    except Credential.DoesNotExist:\n        return HttpResponseBadRequest()\n\n    if request.method == \"POST\" and \"remove_credential\" in request.POST:\n        request.session[\"removed_credential_name\"] = credential.name\n        credential.delete()\n        return redirect(\"hc-profile\")\n\n    if request.profile.totp:\n        is_last = False\n    else:\n        is_last = request.user.credentials.count() == 1\n\n    ctx = {\"credential\": credential, \"is_last\": is_last}\n    return render(request, \"accounts/remove_credential.html\", ctx)\n\n\ndef login_webauthn(request):\n    # We require RP_ID. Fail predicably if it is not set:\n    if not settings.RP_ID:\n        return HttpResponse(status=500)\n\n    # Expect an unauthenticated user\n    if request.user.is_authenticated:\n        return HttpResponseBadRequest()\n\n    if \"2fa_user\" not in request.session:\n        return HttpResponseBadRequest()\n\n    user_id, email, timestamp = request.session[\"2fa_user\"]\n    if timestamp + 300 < time.time():\n        return redirect(\"hc-login\")\n\n    try:\n        user = User.objects.get(id=user_id, email=email)\n    except User.DoesNotExist:\n        return HttpResponseBadRequest()\n\n    credentials = user.credentials.values_list(\"data\", flat=True)\n    helper = GetHelper(settings.RP_ID, credentials)\n\n    if request.method == \"POST\":\n        form = forms.WebAuthnForm(request.POST)\n        if not form.is_valid():\n            return HttpResponseBadRequest()\n\n        if not helper.verify(request.session[\"state\"], form.cleaned_data[\"response\"]):\n            return HttpResponseBadRequest()\n\n        request.session.pop(\"state\")\n        request.session.pop(\"2fa_user\")\n        auth_login(request, user, \"hc.accounts.backends.EmailBackend\")\n        return _redirect_after_login(request)\n\n    options, request.session[\"state\"] = helper.prepare()\n\n    totp_url = None\n    if user.profile.totp:\n        totp_url = reverse(\"hc-login-totp\")\n        redirect_url = request.GET.get(\"next\")\n        if _allow_redirect(redirect_url):\n            totp_url += \"?next=%s\" % redirect_url\n\n    ctx = {\n        \"options\": options,\n        \"totp_url\": totp_url,\n    }\n    return render(request, \"accounts/login_webauthn.html\", ctx)\n\n\ndef login_totp(request):\n    # Expect an unauthenticated user\n    if request.user.is_authenticated:\n        return HttpResponseBadRequest()\n\n    if \"2fa_user\" not in request.session:\n        return HttpResponseBadRequest()\n\n    user_id, email, timestamp = request.session[\"2fa_user\"]\n    if timestamp + 300 < time.time():\n        return redirect(\"hc-login\")\n\n    try:\n        user = User.objects.get(id=user_id, email=email)\n    except User.DoesNotExist:\n        return HttpResponseBadRequest()\n\n    if not user.profile.totp:\n        return HttpResponseBadRequest()\n\n    totp = pyotp.totp.TOTP(user.profile.totp)\n    if request.method == \"POST\":\n        # To guard against brute-forcing TOTP codes, we allow\n        # 96 attempts per user per 24h.\n        if not TokenBucket.authorize_totp_attempt(user):\n            return render(request, \"try_later.html\")\n\n        form = forms.TotpForm(totp, request.POST)\n        if form.is_valid():\n            # We blacklist an used TOTP code for 90 seconds,\n            # so an attacker cannot reuse a stolen code.\n            if not TokenBucket.authorize_totp_code(user, form.cleaned_data[\"code\"]):\n                return render(request, \"try_later.html\")\n\n            request.session.pop(\"2fa_user\")\n            auth_login(request, user, \"hc.accounts.backends.EmailBackend\")\n            return _redirect_after_login(request)\n    else:\n        form = forms.TotpForm(totp)\n\n    return render(request, \"accounts/login_totp.html\", {\"form\": form})\n\n\n@login_required\ndef appearance(request):\n    profile = request.profile\n\n    ctx = {\n        \"page\": \"appearance\",\n        \"profile\": profile,\n        \"status\": \"default\",\n    }\n\n    if request.method == \"POST\":\n        theme = request.POST.get(\"theme\", \"\")\n        if theme in (\"\", \"dark\"):\n            profile.theme = theme\n            profile.save()\n            ctx[\"status\"] = \"info\"\n\n    return render(request, \"accounts/appearance.html\", ctx)\n", "{% extends \"base.html\" %}\n\n{% block content %}\n<div class=\"row\">\n    <div class=\"col-sm-6 col-sm-offset-3\">\n        <div class=\"hc-dialog\">\n            <h1>Login Link Sent!</h1>\n            <br />\n            <p>\n                We've sent you an email with login instructions.\n                Please check your inbox!\n            </p>\n\n        </div>\n    </div>\n</div>\n\n{% endblock %}\n", "{% for error in form.identity.errors %}\n<p class=\"text-danger\">{{ error }}</p>\n{% endfor %}\n\n{% if created %}\n<p class=\"text-success\">Account created, please check your email!</p>\n{% endif %}"], "fixing_code": ["# Changelog\nAll notable changes to this project will be documented in this file.\n\n## v2.6-dev - Unreleased\n\n### Improvements\n- Improve layout in \"My Checks\" for checks with long ping URLs (#745)\n- Add support for communicating with signal-cli over TCP (#732)\n- Add /api/v2/ (changes the status reporting of checks in started state) (#633)\n- Update settings.py to read the ADMINS setting from an environment variable\n- Add \"Start Keyword\" filtering for inbound emails (#716)\n\n### Bug Fixes\n- Fix the Signal integration to handle unexpected RPC messages better (#763)\n- Fix special character encoding in Signal notifications (#767)\n- Fix project sort order to be case-insensitive everywhere in the UI (#768)\n- Fix special character encoding in project invite emails\n- Fix check transfer between same account's projects when at check limit\n- Fix wording in the invite email when inviting read-only users\n- Fix login and signup views to make email enumeration harder\n\n## v2.5 - 2022-12-14\n\n### Improvements\n- Upgrade to fido2 1.1.0 and simplify hc.lib.webauthn\n- Add handling for ipv4address:port values in the X-Forwarded-For header (#714)\n- Add a form for submitting Signal CAPTCHA solutions\n- Add Duration field in the Ping Details dialog (#720)\n- Update Mattermost setup instructions\n- Add support for specifying a run ID via a \"rid\" query parameter (#722)\n- Add last ping body in Slack notifications (#735)\n- Add ntfy integration (#728)\n- Add \".txt\" suffix to the filename when downloading ping body (#738)\n- Add API support for fetching ping bodies (#737)\n- Change \"Settings - Email Reports\" page to allow manual timezone selection\n\n### Bug Fixes\n- Fix the most recent ping lookup in the \"Ping Details\" dialog\n- Fix binary data handling in the hc.front.views.ping_body view\n- Fix downtime summaries in weekly reports (#736)\n- Fix week, month boundary calculation to use user's timezone\n\n## v2.4.1 - 2022-10-18\n\n### Bug Fixes\n- Fix the GHA workflow for building arm/v7 docker image\n\n## v2.4 - 2022-10-18\n\n### Improvements\n- Add support for EMAIL_USE_SSL environment variable (#685)\n- Switch from requests to pycurl\n- Implement documentation search\n- Add date filters in the Log page\n- Upgrade to cronsim 2.3\n- Add support for the $BODY placeholder in webhook payloads (#708)\n- Implement the \"Clear Events\" function\n- Add support for custom topics in Zulip notifications (#583)\n\n### Bug Fixes\n- Fix the handling of TooManyRedirects exceptions\n- Fix MySQL 8 support in the Docker image (upgrade from buster to bullseye) (#717)\n\n## v2.3 - 2022-08-05\n\n### Improvements\n- Update Dockerfile to start SMTP listener (#668)\n- Implement the \"Add Check\" dialog\n- Include last ping type in Slack, Mattermost, Discord notifications\n- Upgrade to cron-descriptor 1.2.30\n- Add \"Filter by keywords in the message body\" feature (#653)\n- Upgrade to HiDPI screenshots in the documentation\n- Add support for the $JSON placeholder in webhook payloads\n- Add ping endpoints for \"log\" events\n- Add the \"Badges\" page in docs\n- Add support for multiple recipients in incoming email (#669)\n- Upgrade to fido2 1.0.0, requests 2.28.1, segno 1.5.2\n- Implement auto-refresh and running indicator in the My Projects page (#681)\n- Upgrade to Django 4.1 and django-compressor 4.1\n- Add API support for resuming paused checks (#687)\n\n### Bug Fixes\n- Fix the display of ignored pings with non-zero exit status\n- Fix a race condition in the \"Change Email\" flow\n- Fix grouping and sorting in the text version of the report/nag emails (#679)\n- Fix the update_timeout and pause views to create flips (for downtime bookkeeping)\n- Fix the checks list to preserve selected filters when adding/updating checks (#684)\n- Fix duration calculation to skip \"log\" and \"ign\" events\n\n## v2.2.1 - 2022-06-13\n\n### Improvements\n- Improve the text version of the alert email template\n\n### Bug Fixes\n- Fix the version number displayed in the footer\n\n## v2.2 - 2022-06-13\n\n### Improvements\n- Add address verification step in the \"Change Email\" flow\n- Reduce logging output from sendalerts and sendreports management commands (#656)\n- Add Ctrl+C handler in sendalerts and sendreports management commands\n- Add notes in docs about configuring uWSGI via UWSGI_ env vars (#656)\n- Implement login link expiration (login links will now expire in 1 hour)\n- Add Gotify integration (#270)\n- Add API support for reading/writing the subject and subject_fail fields (#659)\n- Add \"Disabled\" priority for Pushover notifications (#663)\n\n### Bug Fixes\n- Update hc.front.views.channels to handle empty strings in settings (#635)\n- Add logic to handle ContentDecodingError exceptions\n\n## v2.1 - 2022-05-10\n\n### Improvements\n- Add logic to alert ADMINS when Signal transport hits a CAPTCHA challenge\n- Implement the \"started\" progress spinner in the details pages\n- Add \"hc_check_started\" metric in the Prometheus metrics endpoint (#630)\n- Add a management command for submitting Signal rate limit challenges\n- Upgrade to django-compressor 4.0\n- Update the C# snippet\n- Increase max displayed duration from 24h to 72h (#644)\n- Add \"Ping-Body-Limit\" response header in ping API responses\n\n### Bug Fixes\n- Fix unwanted localization in badge SVG generation (#629)\n- Update email template to handle not yet uploaded ping bodies\n- Add small delay in transports.Email.notify to allow ping body to upload\n- Fix prunenotifications to handle checks with missing pings (#636)\n- Fix \"Send Test Notification\" for integrations that only send \"up\" notifications\n\n## v2.0.1 - 2022-03-18\n\n### Bug Fixes\n- Fix the GHA workflow for building arm/v7 docker image\n\n## v2.0 - 2022-03-18\n\nThis release contains a backwards-incompatible change to the Signal integration\n(hence the major version number bump). Healthchecks uses signal-cli to deliver\nSignal notifications. In the past versions, Healthchecks interfaced with\nsignal-cli over DBus. Starting from this version, Healthchecks interfaces\nwith signal-cli using JSON RPC. Please see README for details on how to set\nthis up.\n\n### Improvements\n- Update Telegram integration to treat \"group chat was deleted\" as permanent error\n- Update email bounce handler to mark email channels as disabled (#446)\n- Update Signal integration to use JSON RPC over UNIX socket\n- Update the \"Add TOTP\" form to display plaintext TOTP secret (#602)\n- Improve PagerDuty notifications\n- Add Ping.body_raw field for storing body as bytes\n- Add support for storing ping bodies in S3-compatible object storage (#609)\n- Add a \"Download Original\" link in the \"Ping Details\" dialog\n\n### Bug Fixes\n- Fix unwanted special character escaping in notification messages (#606)\n- Fix JS error after copying a code snippet\n- Make email non-editable in the \"Invite Member\" dialog when team limit reached\n- Fix Telegram bot to handle TransportError exceptions\n- Fix Signal integration to handle UNREGISTERED_FAILURE errors\n- Fix unwanted localization of period and grace values in data- attributes (#617)\n- Fix Mattermost integration to treat 404 as a transient error (#613)\n\n## v1.25.0 - 2022-01-07\n\n### Improvements\n- Implement Pushover emergency alert cancellation when check goes up\n- Add \"The following checks are also down\" section in Telegram notifications\n- Add \"The following checks are also down\" section in Signal notifications\n- Upgrade to django-compressor 3.0\n- Add support for Telegram channels (#592)\n- Implement Telegram group to supergroup migration (#132)\n- Update the Slack integration to not retry when Slack returns 404\n- Refactor transport classes to raise exceptions on delivery problems\n- Add Channel.disabled field, for disabling integrations on permanent errors\n- Upgrade to Django 4\n- Bump the min. Python version from 3.6 to 3.8 (as required by Django 4)\n\n### Bug Fixes\n- Fix report templates to not show the \"started\" status (show UP or DOWN instead)\n- Update Dockerfile to avoid running \"pip wheel\" more than once (#594)\n\n## v1.24.1 - 2021-11-10\n\n### Bug Fixes\n- Fix Dockerfile for arm/v7 - install all dependencies from piwheels\n\n## v1.24.0 - 2021-11-10\n\n### Improvements\n- Switch from croniter to cronsim\n- Change outgoing webhook timeout to 10s, but cap the total time to 20s\n- Implement automatic `api_ping` and `api_notification` pruning (#556)\n- Update Dockerfile to install apprise (#581)\n- Improve period and grace controls, allow up to 365 day periods (#281)\n- Add SIGTERM handling in sendalerts and sendreports\n- Remove the \"welcome\" landing page, direct users to the sign in form instead\n\n### Bug Fixes\n- Fix hc.api.views.ping to handle non-utf8 data in request body (#574)\n- Fix a crash when hc.api.views.pause receives a single integer in request body\n\n## v1.23.1 - 2021-10-13\n\n### Bug Fixes\n- Fix missing uwsgi dependencies in arm/v7 Docker image\n\n## v1.23.0 - 2021-10-13\n\n### Improvements\n- Add /api/v1/badges/ endpoint (#552)\n- Add ability to edit existing email, Signal, SMS, WhatsApp integrations\n- Add new ping URL format: /{ping_key}/{slug} (#491)\n- Reduce Docker image size by using slim base image and multi-stage Dockerfile\n- Upgrade to Bootstrap 3.4.1\n- Upgrade to jQuery 3.6.0\n\n### Bug Fixes\n- Add handling for non-latin-1 characters in webhook headers\n- Fix dark mode bug in selectpicker widgets\n- Fix a crash during login when user's profile does not exist (#77)\n- Drop API support for GET, DELETE requests with a request body\n- Add missing @csrf_exempt annotations in API views\n- Fix the ping handler to reject status codes > 255\n- Add 'schemaVersion' field in the shields.io endpoint (#566)\n\n## v1.22.0 - 2021-08-06\n\n### Improvements\n- Use multicolor channel icons for better appearance in the dark mode\n- Add SITE_LOGO_URL setting (#323)\n- Add admin action to log in as any user\n- Add a \"Manager\" role (#484)\n- Add support for 2FA using TOTP (#354)\n- Add Whitenoise (#548)\n\n### Bug Fixes\n- Fix dark mode styling issues in Cron Syntax Cheatsheet\n- Fix a 403 when transferring a project to a read-only team member\n- Security: fix allow_redirect function to reject absolute URLs\n\n## v1.21.0 - 2021-07-02\n\n### Improvements\n- Increase \"Success / Failure Keywords\" field lengths to 200\n- Django 3.2.4\n- Improve the handling of unknown email addresses in the Sign In form\n- Add support for \"... is UP\" SMS notifications\n- Add an option for weekly reports (in addition to monthly)\n- Implement PagerDuty Simple Install Flow, remove PD Connect\n- Implement dark mode\n\n### Bug Fixes\n- Fix off-by-one-month error in monthly reports, downtime columns (#539)\n\n## v1.20.0 - 2021-04-22\n\n### Improvements\n- Django 3.2\n- Rename VictorOps -> Splunk On-Call\n- Implement email body decoding in the \"Ping Details\" dialog\n- Add a \"Subject\" field in the \"Ping Details\" dialog\n- Improve HTML email display in the \"Ping Details\" dialog\n- Add a link to check's details page in Slack notifications\n- Replace details_url with cloaked_url in email and chat notifications\n- In the \"My Projects\" page, show projects with failing checks first\n\n### Bug Fixes\n- Fix downtime summary to handle months when the check didn't exist yet (#472)\n- Relax cron expression validation: accept all expressions that croniter accepts\n- Fix sendalerts to clear Profile.next_nag_date if all checks up\n- Fix the pause action to clear Profile.next_nag_date if all checks up\n- Fix the \"Email Reports\" screen to clear Profile.next_nag_date if all checks up\n- Fix the month boundary calculation in monthly reports (#497)\n\n## v1.19.0 - 2021-02-03\n\n### Improvements\n- Add tighter parameter checks in hc.front.views.serve_doc\n- Update OpsGenie instructions (#450)\n- Update the email notification template to include more check and last ping details\n- Improve the crontab snippet in the \"Check Details\" page (#465)\n- Add Signal integration (#428)\n- Change Zulip onboarding, ask for the zuliprc file (#202)\n- Add a section in Docs about running self-hosted instances\n- Add experimental Dockerfile and docker-compose.yml\n- Add rate limiting for Pushover notifications (6 notifications / user / minute)\n- Add support for disabling specific integration types (#471)\n\n### Bug Fixes\n- Fix unwanted HTML escaping in SMS and WhatsApp notifications\n- Fix a crash when adding an integration for an empty Trello account\n- Change icon CSS class prefix to 'ic-' to work around Fanboy's filter list\n\n## v1.18.0 - 2020-12-09\n\n### Improvements\n- Add a tooltip to the 'confirmation link' label (#436)\n- Update API to allow specifying channels by names (#440)\n- When saving a phone number, remove any invisible unicode characers\n- Update the read-only dashboard's CSS for better mobile support (#442)\n- Reduce the number of SQL queries used in the \"Get Checks\" API call\n- Add support for script's exit status in ping URLs (#429)\n- Improve phone number sanitization: remove spaces and hyphens\n- Change the \"Test Integration\" behavior for webhooks: don't retry failed requests\n- Add retries to the the email sending logic\n- Require confirmation codes (sent to email) before sensitive actions\n- Implement WebAuthn two-factor authentication\n- Implement badge mode (up/down vs up/late/down) selector (#282)\n- Add Ping.exitstatus field, store client's reported exit status values (#455)\n- Implement header-based authentication (#457)\n- Add a \"Lost password?\" link with instructions in the Sign In page\n\n### Bug Fixes\n- Fix db field overflow when copying a check with a long name\n\n## v1.17.0 - 2020-10-14\n\n### Improvements\n- Django 3.1\n- Handle status callbacks from Twilio, show delivery failures in Integrations\n- Removing unused /api/v1/notifications/{uuid}/bounce endpoint\n- Less verbose output in the `senddeletionnotices` command\n- Host a read-only dashboard (from github.com/healthchecks/dashboard/)\n- LINE Notify integration (#412)\n- Read-only team members\n- API support for setting the allowed HTTP methods for making ping requests\n\n### Bug Fixes\n- Handle excessively long email addresses in the signup form\n- Handle excessively long email addresses in the team member invite form\n- Don't allow duplicate team memberships\n- When copying a check, copy all fields from the \"Filtering Rules\" dialog (#417)\n- Fix missing Resume button (#421)\n- When decoding inbound emails, decode encoded headers (#420)\n- Escape markdown in MS Teams notifications (#426)\n- Set the \"title\" and \"summary\" fields in MS Teams notifications (#435)\n\n## v1.16.0 - 2020-08-04\n\n### Improvements\n- Paused ping handling can be controlled via API (#376)\n- Add \"Get a list of checks's logged pings\" API call (#371)\n- The /api/v1/checks/ endpoint now accepts either UUID or `unique_key` (#370)\n- Added /api/v1/checks/uuid/flips/ endpoint (#349)\n- In the cron expression dialog, show a human-friendly version of the expression\n- Indicate a started check with a progress spinner under status icon (#338)\n- Added \"Docs > Reliability Tips\" page\n- Spike.sh integration (#402)\n- Updated Discord integration to use discord.com instead of discordapp.com\n- Add \"Failure Keyword\" filtering for inbound emails (#396)\n- Add support for multiple, comma-separated keywords (#396)\n- New integration: phone calls (#403)\n\n### Bug Fixes\n- Removing Pager Team integration, project appears to be discontinued\n- Sending a test notification updates Channel.last_error (#391)\n- Handle HTTP 429 responses from Matrix server when joining a Matrix room\n\n## v1.15.0 - 2020-06-04\n\n### Improvements\n- Rate limiting for Telegram notifications (10 notifications per chat per minute)\n- Use Slack V2 OAuth flow\n- Users can edit their existing webhook integrations (#176)\n- Add a \"Transfer Ownership\" feature in Project Settings\n- In checks list, the pause button asks for confirmation (#356)\n- Added /api/v1/metrics/ endpoint, useful for monitoring the service itself\n- Added \"When paused, ignore pings\" option in the Filtering Rules dialog (#369)\n\n### Bug Fixes\n- \"Get a single check\" API call now supports read-only API keys (#346)\n- Don't escape HTML in the subject line of notification emails\n- Don't let users clone checks if the account is at check limit\n\n## v1.14.0 - 2020-03-23\n\n### Improvements\n- Improved UI to invite users from account's other projects (#258)\n- Experimental Prometheus metrics endpoint (#300)\n- Don't store user's current project in DB, put it explicitly in page URLs (#336)\n- API reference in Markdown\n- Use Selectize.js for entering tags (#324)\n- Zulip integration (#202)\n- OpsGenie integration returns more detailed error messages\n- Telegram integration returns more detailed error messages\n- Added the \"Get a single check\" API call (#337)\n- Display project name in Slack notifications (#342)\n\n### Bug Fixes\n- The \"render_docs\" command checks if markdown and pygments is installed (#329)\n- The team size limit is applied to the n. of distinct users across all projects (#332)\n- API: don't let SuspiciousOperation bubble up when validating channel ids\n- API security: check channel ownership when setting check's channels\n- API: update check's \"alert_after\" field when changing schedule\n- API: validate channel identifiers before creating/updating a check (#335)\n- Fix redirect after login when adding Telegram integration\n\n## v1.13.0 - 2020-02-13\n\n### Improvements\n- Show a red \"!\" in project's top navigation if any integration is not working\n- createsuperuser management command requires an unique email address (#318)\n- For superusers, show \"Site Administration\" in top navigation, note in README (#317)\n- Make Ping.body size limit configurable (#301)\n- Show sub-second durations with higher precision, 2 digits after decimal point (#321)\n- Replace the gear icon with three horizontal dots icon (#322)\n- Add a Pause button in the checks list (#312)\n- Documentation in Markdown\n- Added an example of capturing and submitting log output (#315)\n- The sendalerts commands measures dwell time and reports it over statsd protocol\n- Django 3.0.3\n- Show a warning in top navigation if the project has no integrations (#327)\n\n### Bug Fixes\n- Increase the allowable length of Matrix room alias to 100 (#320)\n- Make sure Check.last_ping and Ping.created timestamps match exactly\n- Don't trigger \"down\" notifications when changing schedule interactively in web UI\n- Fix sendalerts crash loop when encountering a bad cron schedule\n- Stricter cron validation, reject schedules like \"At midnight of February 31\"\n- In hc.front.views.ping_details, if a ping does not exist, return a friendly message\n\n## v1.12.0 - 2020-01-02\n\n### Improvements\n- Django 3.0\n- \"Filtering Rules\" dialog, an option to require HTTP POST (#297)\n- Show Healthchecks version in Django admin header (#306)\n- Added JSON endpoint for Shields.io (#304)\n- `senddeletionnotices` command skips profiles with recent last_active_date\n- The \"Update Check\" API call can update check's description (#311)\n\n### Bug Fixes\n- Don't set CSRF cookie on first visit. Signup is exempt from CSRF protection\n- Fix List-Unsubscribe email header value: add angle brackets\n- Unsubscribe links serve a form, and require HTTP POST to actually unsubscribe\n- For webhook integration, validate each header line separately\n- Fix \"Send Test Notification\" for webhooks that only fire on checks going up\n- Don't allow adding webhook integrations with both URLs blank\n- Don't allow adding email integrations with both \"up\" and \"down\" unchecked\n\n\n## v1.11.0 - 2019-11-22\n\n### Improvements\n- In monthly reports, no downtime stats for the current month (month has just started)\n- Add Microsoft Teams integration (#135)\n- Add Profile.last_active_date field for more accurate inactive user detection\n- Add \"Shell Commands\" integration (#302)\n- PagerDuty integration works with or without PD_VENDOR_KEY (#303)\n\n### Bug Fixes\n - On mobile, \"My Checks\" page, always show the gear (Details) button (#286)\n - Make log events fit better on mobile screens\n\n\n## v1.10.0 - 2019-10-21\n\n### Improvements\n- Add the \"Last Duration\" field in the \"My Checks\" page (#257)\n- Add \"last_duration\" attribute to the Check API resource (#257)\n- Upgrade to psycopg2 2.8.3\n- Add Go usage example\n- Send monthly reports on 1st of every month, not randomly during the month\n- Signup form sets the \"auto-login\" cookie to avoid an extra click during first login\n- Autofocus the email field in the signup form, and submit on enter key\n- Add support for OpsGenie EU region (#294)\n- Update OpsGenie logo and setup illustrations\n- Add a \"Create a Copy\" function for cloning checks (#288)\n- Send email notification when monthly SMS sending limit is reached (#292)\n\n### Bug Fixes\n- Prevent double-clicking the submit button in signup form\n- Upgrade to Django 2.2.6 \u2013 fixes sqlite migrations (#284)\n\n\n## v1.9.0 - 2019-09-03\n\n### Improvements\n- Show the number of downtimes and total downtime minutes in monthly reports (#104)\n- Show the number of downtimes and total downtime minutes in \"Check Details\" page\n- Add the `pruneflips` management command\n- Add Mattermost integration (#276)\n- Three choices in timezone switcher (UTC / check's timezone / browser's timezone) (#278)\n- After adding a new check redirect to the \"Check Details\" page\n\n### Bug Fixes\n- Fix javascript code to construct correct URLs when running from a subdirectory (#273)\n- Don't show the \"Sign Up\" link in the login page if registration is closed (#280)\n\n## v1.8.0 - 2019-07-08\n\n### Improvements\n- Add the `prunetokenbucket` management command\n- Show check counts in JSON \"badges\" (#251)\n- Webhooks support HTTP PUT (#249)\n- Webhooks can use different req. bodies and headers for \"up\" and \"down\" events (#249)\n- Show check's code instead of full URL on 992px - 1200px wide screens (#253)\n- Add WhatsApp integration (uses Twilio same as the SMS integration)\n- Webhooks support the $TAGS placeholder\n- Don't include ping URLs in API responses when the read-only key is used\n\n### Bug Fixes\n- Fix badges for tags containing special characters (#240, #237)\n- Fix the \"Integrations\" page for when the user has no active project\n- Prevent email clients from opening the one-time login links (#255)\n- Fix `prunepings` and `prunepingsslow`, they got broken when adding Projects (#264)\n\n\n## v1.7.0 - 2019-05-02\n\n### Improvements\n- Add the EMAIL_USE_VERIFICATION configuration setting (#232)\n- Show \"Badges\" and \"Settings\" in top navigation (#234)\n- Upgrade to Django 2.2\n- Can configure the email integration to only report the \"down\" events (#231)\n- Add \"Test!\" function in the Integrations page (#207)\n- Rate limiting for the log in attempts\n- Password strength meter and length check in the \"Set Password\" form\n- Show the Description section even if the description is missing. (#246)\n- Include the description in email alerts. (#247)\n\n\n## v1.6.0 - 2019-04-01\n\n### Improvements\n- Add the \"desc\" field (check's description) to API responses\n- Add maxlength attribute to HTML input=text elements\n- Improved logic for displaying job execution times in log (#219)\n- Add Matrix integration\n- Add Pager Team integration\n- Add a management command for sending inactive account notifications\n\n### Bug Fixes\n- Fix refreshing of the checks page filtered by tags (#221)\n- Escape asterisks in Slack messages (#223)\n- Fix a \"invalid time format\" in front.views.status_single on Windows hosts\n\n\n## v1.5.0 - 2019-02-04\n\n### Improvements\n- Database schema: add uniqueness constraint to Check.code\n- Database schema: add Ping.kind field. Remove \"start\" and \"fail\" fields\n- Add \"Email Settings...\" dialog and \"Subject Must Contain\" setting\n- Database schema: add the Project model\n- Move project-specific settings to a new \"Project Settings\" page\n- Add a \"Transfer to Another Project...\" dialog\n- Add the \"My Projects\" page\n\n\n## v1.4.0 - 2018-12-25\n\n### Improvements\n- Set Pushover alert priorities for \"down\" and \"up\" events separately\n- Additional python usage examples\n- Allow simultaneous access to checks from different teams\n- Add CORS support to API endpoints\n- Flip model, for tracking status changes of the Check objects\n- Add `/ping/<code>/start` API endpoint\n- When using the `/start` endpoint, show elapsed times in ping log\n\n### Bug Fixes\n- Fix after-login redirects (the \"?next=\" query parameter)\n- Update Check.status field when user edits timeout & grace settings\n- Use timezone-aware datetimes with croniter, avoid ambiguities around DST\n- Validate and reject cron schedules with six components\n\n\n## v1.3.0 - 2018-11-21\n\n### Improvements\n- Load settings from environment variables\n- Add \"List-Unsubscribe\" header to alert and report emails\n- Don't send monthly reports to inactive accounts (no pings in 6 months)\n- Add search box in the \"My Checks\" page\n- Add read-only API key support\n- Remove Profile.bill_to field (obsolete)\n- Show a warning when running with DEBUG=True\n- Add \"channels\" attribute to the Check API resource\n- Can specify channel codes when updating a check via API\n- Add a workaround for email agents automatically opening \"Unsubscribe\" links\n- Add Channel.name field, users can now name integrations\n- Add \"Get a List of Existing Integrations\" API call\n\n### Bug Fixes\n- During DST transition, handle ambiguous dates as pre-transition\n\n\n## v1.2.0 - 2018-10-20\n\n### Improvements\n- Content updates in the \"Welcome\" page.\n- Added \"Docs > Third-Party Resources\" page.\n- Improved  layout and styling in \"Login\" page.\n- Separate \"Sign Up\" and \"Log In\" forms.\n- \"My Checks\" page: support filtering checks by query string parameters.\n- Added Trello integration\n\n### Bug Fixes\n- Timezones were missing in the \"Change Schedule\" dialog, fixed.\n- Fix hamburger menu button in \"Login\" page.\n\n\n## v1.1.0 - 2018-08-20\n\n### Improvements\n- A new \"Check Details\" page.\n- Updated django-compressor, psycopg2, pytz, requests package versions.\n- C# usage example.\n- Checks have a \"Description\" field.\n", "from __future__ import annotations\n\nfrom datetime import timedelta as td\n\nfrom django import forms\nfrom django.contrib.auth import authenticate\nfrom django.contrib.auth.models import User\n\nfrom hc.accounts.models import REPORT_CHOICES, Member\nfrom hc.api.models import TokenBucket\nfrom hc.lib.tz import all_timezones\n\n\nclass LowercaseEmailField(forms.EmailField):\n    def clean(self, value):\n        value = super(LowercaseEmailField, self).clean(value)\n        return value.lower()\n\n\nclass SignupForm(forms.Form):\n    # Call it \"identity\" instead of \"email\"\n    # to avoid some of the dumber bots\n    identity = LowercaseEmailField(\n        error_messages={\"required\": \"Please enter your email address.\"}\n    )\n    tz = forms.CharField(required=False)\n\n    def clean_identity(self):\n        v = self.cleaned_data[\"identity\"]\n        if len(v) > 254:\n            raise forms.ValidationError(\"Address is too long.\")\n\n        return v\n\n    def clean_tz(self):\n        # Declare tz as \"clean\" only if we can find it in hc.lib.tz.all_timezones\n        if self.cleaned_data[\"tz\"] in all_timezones:\n            return self.cleaned_data[\"tz\"]\n\n        # Otherwise, return None, and *don't* throw a validation exception:\n        # If user's browser reports a timezone we don't recognize, we\n        # should ignore the timezone but still save the rest of the form.\n\n\nclass EmailLoginForm(forms.Form):\n    # Call it \"identity\" instead of \"email\"\n    # to avoid some of the dumber bots\n    identity = LowercaseEmailField()\n\n    def clean_identity(self):\n        v = self.cleaned_data[\"identity\"]\n        if not TokenBucket.authorize_login_email(v):\n            raise forms.ValidationError(\"Too many attempts, please try later.\")\n\n        try:\n            self.user = User.objects.get(email=v)\n        except User.DoesNotExist:\n            self.user = None\n\n        return v\n\n\nclass PasswordLoginForm(forms.Form):\n    email = LowercaseEmailField()\n    password = forms.CharField()\n\n    def clean(self):\n        username = self.cleaned_data.get(\"email\")\n        password = self.cleaned_data.get(\"password\")\n\n        if username and password:\n            if not TokenBucket.authorize_login_password(username):\n                raise forms.ValidationError(\"Too many attempts, please try later.\")\n\n            self.user = authenticate(username=username, password=password)\n            if self.user is None or not self.user.is_active:\n                raise forms.ValidationError(\"Incorrect email or password.\")\n\n        return self.cleaned_data\n\n\nclass ReportSettingsForm(forms.Form):\n    reports = forms.ChoiceField(choices=REPORT_CHOICES)\n    nag_period = forms.IntegerField(min_value=0, max_value=86400)\n    tz = forms.CharField()\n\n    def clean_nag_period(self):\n        seconds = self.cleaned_data[\"nag_period\"]\n\n        if seconds not in (0, 3600, 86400):\n            raise forms.ValidationError(\"Bad nag_period: %d\" % seconds)\n\n        return td(seconds=seconds)\n\n    def clean_tz(self):\n        # Declare tz as \"clean\" only if we can find it in hc.lib.tz.all_timezones\n        if self.cleaned_data[\"tz\"] in all_timezones:\n            return self.cleaned_data[\"tz\"]\n\n        # Otherwise, return None, and *don't* throw a validation exception:\n        # If user's browser reports a timezone we don't recognize, we\n        # should ignore the timezone but still save the rest of the form.\n\n\nclass SetPasswordForm(forms.Form):\n    password = forms.CharField(min_length=8)\n\n\nclass ChangeEmailForm(forms.Form):\n    error_css_class = \"has-error\"\n    email = LowercaseEmailField()\n\n    def clean_email(self):\n        v = self.cleaned_data[\"email\"]\n        if User.objects.filter(email=v).exists():\n            raise forms.ValidationError(\"%s is already registered\" % v)\n\n        return v\n\n\nclass InviteTeamMemberForm(forms.Form):\n    email = LowercaseEmailField(max_length=254)\n    role = forms.ChoiceField(choices=Member.Role.choices)\n\n\nclass RemoveTeamMemberForm(forms.Form):\n    email = LowercaseEmailField()\n\n\nclass ProjectNameForm(forms.Form):\n    name = forms.CharField(max_length=60)\n\n\nclass TransferForm(forms.Form):\n    email = LowercaseEmailField()\n\n\nclass AddWebAuthnForm(forms.Form):\n    name = forms.CharField(max_length=100)\n    response = forms.CharField()\n\n\nclass WebAuthnForm(forms.Form):\n    response = forms.CharField()\n\n\nclass TotpForm(forms.Form):\n    error_css_class = \"has-error\"\n    code = forms.RegexField(regex=r\"^\\d{6}$\")\n\n    def __init__(self, totp, post=None, files=None):\n        self.totp = totp\n        super(TotpForm, self).__init__(post, files)\n\n    def clean_code(self):\n        if not self.totp.verify(self.cleaned_data[\"code\"], valid_window=1):\n            raise forms.ValidationError(\"The code you entered was incorrect.\")\n\n        return self.cleaned_data[\"code\"]\n", "from __future__ import annotations\n\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.test.utils import override_settings\n\nfrom hc.accounts.models import Credential\nfrom hc.api.models import Check, TokenBucket\nfrom hc.test import BaseTestCase\n\n\nclass LoginTestCase(BaseTestCase):\n    def setUp(self):\n        super().setUp()\n        self.checks_url = f\"/projects/{self.project.code}/checks/\"\n\n    def test_it_shows_form(self):\n        r = self.client.get(\"/accounts/login/\")\n        self.assertContains(r, \"Email Me a Link\")\n\n    def test_it_redirects_authenticated_get(self):\n        self.client.login(username=\"alice@example.org\", password=\"password\")\n\n        r = self.client.get(\"/accounts/login/\")\n        self.assertRedirects(r, self.checks_url)\n\n    @override_settings(SITE_ROOT=\"http://testserver\", SITE_LOGO_URL=None)\n    def test_it_sends_link(self):\n        form = {\"identity\": \"alice@example.org\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(r, \"/accounts/login_link_sent/\")\n\n        # And email should have been sent\n        self.assertEqual(len(mail.outbox), 1)\n        message = mail.outbox[0]\n        self.assertEqual(message.subject, f\"Log in to {settings.SITE_NAME}\")\n        html = message.alternatives[0][0]\n        self.assertIn(\"http://testserver/static/img/logo.png\", html)\n        self.assertIn(\"http://testserver/docs/\", html)\n\n    @override_settings(SITE_LOGO_URL=\"https://example.org/logo.svg\")\n    def test_it_uses_custom_logo(self):\n        self.client.post(\"/accounts/login/\", {\"identity\": \"alice@example.org\"})\n        html = mail.outbox[0].alternatives[0][0]\n        self.assertIn(\"https://example.org/logo.svg\", html)\n\n    def test_it_sends_link_with_next(self):\n        form = {\"identity\": \"alice@example.org\"}\n\n        r = self.client.post(\"/accounts/login/?next=\" + self.channels_url, form)\n        self.assertRedirects(r, \"/accounts/login_link_sent/\")\n        self.assertIn(\"auto-login\", r.cookies)\n\n        # The check_token link should have a ?next= query parameter:\n        self.assertEqual(len(mail.outbox), 1)\n        body = mail.outbox[0].body\n        self.assertTrue(\"/?next=\" + self.channels_url in body)\n\n    def test_it_handles_unknown_email(self):\n        form = {\"identity\": \"surprise@example.org\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(r, \"/accounts/login_link_sent/\")\n        self.assertIn(\"auto-login\", r.cookies)\n\n        # There should be no sent emails.\n        self.assertEqual(len(mail.outbox), 0)\n\n    @override_settings(SECRET_KEY=\"test-secret\")\n    def test_it_rate_limits_emails(self):\n        # \"d60d...\" is sha1(\"alice@example.orgtest-secret\")\n        obj = TokenBucket(value=\"em-d60db3b2343e713a4de3e92d4eb417e4f05f06ab\")\n        obj.tokens = 0\n        obj.save()\n\n        form = {\"identity\": \"alice@example.org\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertContains(r, \"Too many attempts\")\n\n        # No email should have been sent\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_it_pops_bad_link_from_session(self):\n        self.client.session[\"bad_link\"] = True\n        self.client.get(\"/accounts/login/\")\n        assert \"bad_link\" not in self.client.session\n\n    def test_it_ignores_case(self):\n        form = {\"identity\": \"ALICE@EXAMPLE.ORG\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(r, \"/accounts/login_link_sent/\")\n\n        self.profile.refresh_from_db()\n        self.assertTrue(self.profile.token)\n\n    def test_it_handles_password(self):\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(r, self.checks_url)\n\n    @override_settings(SECRET_KEY=\"test-secret\")\n    def test_it_rate_limits_password_attempts(self):\n        # \"d60d...\" is sha1(\"alice@example.orgtest-secret\")\n        obj = TokenBucket(value=\"pw-d60db3b2343e713a4de3e92d4eb417e4f05f06ab\")\n        obj.tokens = 0\n        obj.save()\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertContains(r, \"Too many attempts\")\n\n    def test_it_handles_password_login_with_redirect(self):\n        check = Check.objects.create(project=self.project)\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        samples = [self.channels_url, \"/checks/%s/details/\" % check.code]\n\n        for s in samples:\n            r = self.client.post(\"/accounts/login/?next=%s\" % s, form)\n            self.assertRedirects(r, s)\n\n    def test_it_handles_bad_next_parameter(self):\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        samples = [\n            \"/evil/\",\n            f\"https://example.org/projects/{self.project.code}/checks/\",\n        ]\n\n        for sample in samples:\n            r = self.client.post(\"/accounts/login/?next=\" + sample, form)\n            self.assertRedirects(r, self.checks_url)\n\n    def test_it_handles_wrong_password(self):\n        form = {\n            \"action\": \"login\",\n            \"email\": \"alice@example.org\",\n            \"password\": \"wrong password\",\n        }\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertContains(r, \"Incorrect email or password\")\n\n    @override_settings(REGISTRATION_OPEN=False)\n    def test_it_obeys_registration_open(self):\n        r = self.client.get(\"/accounts/login/\")\n        self.assertNotContains(r, \"Create Your Account\")\n\n    def test_it_redirects_to_webauthn_form(self):\n        Credential.objects.create(user=self.alice, name=\"Alices Key\")\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(\n            r, \"/accounts/login/two_factor/\", fetch_redirect_response=False\n        )\n\n        # It should not log the user in yet\n        self.assertNotIn(\"_auth_user_id\", self.client.session)\n\n        # Instead, it should set 2fa_user_id in the session\n        user_id, email, valid_until = self.client.session[\"2fa_user\"]\n        self.assertEqual(user_id, self.alice.id)\n\n    def test_it_redirects_to_totp_form(self):\n        self.profile.totp = \"0\" * 32\n        self.profile.save()\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(\n            r, \"/accounts/login/two_factor/totp/\", fetch_redirect_response=False\n        )\n\n        # It should not log the user in yet\n        self.assertNotIn(\"_auth_user_id\", self.client.session)\n\n        # Instead, it should set 2fa_user_id in the session\n        user_id, email, valid_until = self.client.session[\"2fa_user\"]\n        self.assertEqual(user_id, self.alice.id)\n\n    def test_it_handles_missing_profile(self):\n        self.profile.delete()\n\n        form = {\"action\": \"login\", \"email\": \"alice@example.org\", \"password\": \"password\"}\n\n        r = self.client.post(\"/accounts/login/\", form)\n        self.assertRedirects(r, self.checks_url)\n", "from __future__ import annotations\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import User\nfrom django.core import mail\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\n\nfrom hc.accounts.models import Profile, Project\nfrom hc.api.models import Channel, Check\n\n\nclass SignupTestCase(TestCase):\n    @override_settings(USE_PAYMENTS=False)\n    def test_it_works(self):\n        form = {\"identity\": \"alice@example.org\", \"tz\": \"Europe/Riga\"}\n\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"check your email\")\n        self.assertIn(\"auto-login\", r.cookies)\n\n        # An user should have been created\n        user = User.objects.get()\n\n        # A profile should have been created\n        profile = Profile.objects.get()\n        self.assertEqual(profile.check_limit, 10000)\n        self.assertEqual(profile.sms_limit, 10000)\n        self.assertEqual(profile.call_limit, 10000)\n        self.assertEqual(profile.tz, \"Europe/Riga\")\n\n        # And email sent\n        self.assertEqual(len(mail.outbox), 1)\n        subject = \"Log in to %s\" % settings.SITE_NAME\n        self.assertEqual(mail.outbox[0].subject, subject)\n\n        # A project should have been created\n        project = Project.objects.get()\n        self.assertEqual(project.owner, user)\n        self.assertEqual(project.badge_key, user.username)\n\n        # And check should be associated with the new user\n        check = Check.objects.get()\n        self.assertEqual(check.name, \"My First Check\")\n        self.assertEqual(check.slug, \"my-first-check\")\n        self.assertEqual(check.project, project)\n\n        # A channel should have been created\n        channel = Channel.objects.get()\n        self.assertEqual(channel.project, project)\n\n    @override_settings(USE_PAYMENTS=True)\n    def test_it_sets_limits(self):\n        form = {\"identity\": \"alice@example.org\", \"tz\": \"\"}\n\n        self.client.post(\"/accounts/signup/\", form)\n\n        profile = Profile.objects.get()\n        self.assertEqual(profile.check_limit, 20)\n        self.assertEqual(profile.sms_limit, 5)\n        self.assertEqual(profile.call_limit, 0)\n\n    @override_settings(REGISTRATION_OPEN=False)\n    def test_it_obeys_registration_open(self):\n        form = {\"identity\": \"dan@example.org\", \"tz\": \"\"}\n\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertEqual(r.status_code, 403)\n\n    def test_it_ignores_case(self):\n        form = {\"identity\": \"ALICE@EXAMPLE.ORG\", \"tz\": \"\"}\n        self.client.post(\"/accounts/signup/\", form)\n\n        # There should be exactly one user:\n        q = User.objects.filter(email=\"alice@example.org\")\n        self.assertTrue(q.exists)\n\n    def test_it_handles_existing_users(self):\n        alice = User(username=\"alice\", email=\"alice@example.org\")\n        alice.save()\n\n        form = {\"identity\": \"alice@example.org\", \"tz\": \"\"}\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"check your email\")\n        self.assertIn(\"auto-login\", r.cookies)\n\n        # It should not send an email\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_it_checks_syntax(self):\n        form = {\"identity\": \"alice at example org\", \"tz\": \"\"}\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"Enter a valid email address\")\n\n    def test_it_checks_length(self):\n        aaa = \"a\" * 300\n        form = {\"identity\": f\"alice+{aaa}@example.org\", \"tz\": \"\"}\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"Address is too long.\")\n\n        self.assertFalse(User.objects.exists())\n\n    @override_settings(USE_PAYMENTS=False)\n    def test_it_ignores_bad_tz(self):\n        form = {\"identity\": \"alice@example.org\", \"tz\": \"Foo/Bar\"}\n\n        r = self.client.post(\"/accounts/signup/\", form)\n        self.assertContains(r, \"check your email\")\n        self.assertIn(\"auto-login\", r.cookies)\n\n        profile = Profile.objects.get()\n        self.assertEqual(profile.tz, \"UTC\")\n", "from __future__ import annotations\n\nimport time\nimport uuid\nfrom datetime import timedelta as td\nfrom secrets import token_urlsafe\nfrom urllib.parse import urlparse\n\nimport pyotp\nimport segno\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import authenticate\nfrom django.contrib.auth import login as auth_login\nfrom django.contrib.auth import logout as auth_logout\nfrom django.contrib.auth import update_session_auth_hash\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.models import User\nfrom django.core.signing import BadSignature, SignatureExpired, TimestampSigner\nfrom django.db import transaction\nfrom django.db.models.functions import Lower\nfrom django.http import HttpResponse, HttpResponseBadRequest, HttpResponseForbidden\nfrom django.shortcuts import get_object_or_404, redirect, render\nfrom django.urls import Resolver404, resolve, reverse\nfrom django.utils.timezone import now\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.http import require_POST\n\nfrom hc.accounts import forms\nfrom hc.accounts.decorators import require_sudo_mode\nfrom hc.accounts.models import Credential, Member, Profile, Project\nfrom hc.api.models import Channel, Check, TokenBucket\nfrom hc.lib.tz import all_timezones\nfrom hc.lib.webauthn import CreateHelper, GetHelper\nfrom hc.payments.models import Subscription\n\nPOST_LOGIN_ROUTES = (\n    \"hc-checks\",\n    \"hc-details\",\n    \"hc-log\",\n    \"hc-channels\",\n    \"hc-add-slack\",\n    \"hc-add-pushover\",\n    \"hc-add-telegram\",\n    \"hc-project-settings\",\n    \"hc-uncloak\",\n)\n\n\ndef _allow_redirect(redirect_url):\n    if not redirect_url:\n        return False\n\n    parsed = urlparse(redirect_url)\n    if parsed.netloc:\n        # Allow redirects only to relative URLs\n        return False\n\n    try:\n        match = resolve(parsed.path)\n    except Resolver404:\n        return False\n\n    return match.url_name in POST_LOGIN_ROUTES\n\n\ndef _make_user(email, tz=None, with_project=True):\n    username = str(uuid.uuid4())[:30]\n    user = User(username=username, email=email)\n    user.set_unusable_password()\n    user.save()\n\n    project = None\n    if with_project:\n        project = Project(owner=user)\n        project.badge_key = user.username\n        project.save()\n\n        check = Check(project=project)\n        check.set_name_slug(\"My First Check\")\n        check.save()\n\n        channel = Channel(project=project)\n        channel.kind = \"email\"\n        channel.value = email\n        channel.email_verified = True\n        channel.save()\n\n        channel.checks.add(check)\n\n    # Ensure a profile gets created\n    profile = Profile.objects.for_user(user)\n    if tz:\n        profile.tz = tz\n        profile.save()\n\n    return user\n\n\ndef _redirect_after_login(request):\n    \"\"\"Redirect to the URL indicated in ?next= query parameter.\"\"\"\n\n    redirect_url = request.GET.get(\"next\")\n    if _allow_redirect(redirect_url):\n        return redirect(redirect_url)\n\n    if request.user.project_set.count() == 1:\n        project = request.user.project_set.first()\n        return redirect(\"hc-checks\", project.code)\n\n    return redirect(\"hc-index\")\n\n\ndef _check_2fa(request, user):\n    have_keys = user.credentials.exists()\n    profile = Profile.objects.for_user(user)\n    if have_keys or profile.totp:\n        # We have verified user's password or token, and now must\n        # verify their security key. We store the following in user's session:\n        # - user.id, to look up the user in the login_webauthn view\n        # - user.email, to make sure email was not changed between the auth steps\n        # - timestamp, to limit the max time between the auth steps\n        request.session[\"2fa_user\"] = [user.id, user.email, int(time.time())]\n\n        if have_keys:\n            path = reverse(\"hc-login-webauthn\")\n        else:\n            path = reverse(\"hc-login-totp\")\n\n        redirect_url = request.GET.get(\"next\")\n        if _allow_redirect(redirect_url):\n            path += \"?next=%s\" % redirect_url\n\n        return redirect(path)\n\n    auth_login(request, user)\n    return _redirect_after_login(request)\n\n\ndef _new_key(nbytes=24):\n    while True:\n        candidate = token_urlsafe(nbytes)\n        if candidate[0] not in \"-_\" and candidate[-1] not in \"-_\":\n            return candidate\n\n\ndef login(request):\n    form = forms.PasswordLoginForm()\n    magic_form = forms.EmailLoginForm()\n\n    if request.method == \"POST\":\n        if request.POST.get(\"action\") == \"login\":\n            form = forms.PasswordLoginForm(request.POST)\n            if form.is_valid():\n                return _check_2fa(request, form.user)\n\n        else:\n            magic_form = forms.EmailLoginForm(request.POST)\n            if magic_form.is_valid():\n                redirect_url = request.GET.get(\"next\")\n                if not _allow_redirect(redirect_url):\n                    redirect_url = None\n\n                if magic_form.user:\n                    profile = Profile.objects.for_user(magic_form.user)\n                    profile.send_instant_login_link(redirect_url=redirect_url)\n\n                response = redirect(\"hc-login-link-sent\")\n                # check_token looks for this cookie to decide if\n                # it needs to do the extra POST step.\n                response.set_cookie(\"auto-login\", \"1\", max_age=300, httponly=True)\n                return response\n\n    if request.user.is_authenticated:\n        return _redirect_after_login(request)\n\n    bad_link = request.session.pop(\"bad_link\", None)\n    ctx = {\n        \"page\": \"login\",\n        \"form\": form,\n        \"magic_form\": magic_form,\n        \"bad_link\": bad_link,\n        \"registration_open\": settings.REGISTRATION_OPEN,\n        \"support_email\": settings.SUPPORT_EMAIL,\n    }\n    return render(request, \"accounts/login.html\", ctx)\n\n\n@require_POST\ndef logout(request):\n    auth_logout(request)\n    return redirect(\"hc-index\")\n\n\n@require_POST\n@csrf_exempt\ndef signup(request):\n    if not settings.REGISTRATION_OPEN:\n        return HttpResponseForbidden()\n\n    ctx = {}\n    form = forms.SignupForm(request.POST)\n    if form.is_valid():\n        email = form.cleaned_data[\"identity\"]\n        if not User.objects.filter(email=email).exists():\n            tz = form.cleaned_data[\"tz\"]\n            user = _make_user(email, tz)\n            profile = Profile.objects.for_user(user)\n            profile.send_instant_login_link()\n    else:\n        ctx = {\"form\": form}\n\n    response = render(request, \"accounts/signup_result.html\", ctx)\n    if \"form\" not in ctx:\n        response.set_cookie(\"auto-login\", \"1\", max_age=300, httponly=True)\n\n    return response\n\n\ndef login_link_sent(request):\n    return render(request, \"accounts/login_link_sent.html\")\n\n\ndef check_token(request, username, token, new_email=None):\n    if request.user.is_authenticated:\n        auth_logout(request)\n\n    # Some email servers open links in emails to check for malicious content.\n    # To work around this, we sign user in if the method is POST\n    # *or* if the browser presents a cookie we had set when sending the login link.\n    #\n    # If the method is GET and the auto-login cookie isn't present, we serve\n    # a HTML form with a submit button.\n    if request.method != \"POST\" and \"auto-login\" not in request.COOKIES:\n        return render(request, \"accounts/check_token_submit.html\")\n\n    user = authenticate(username=username, token=token)\n    if user is not None and user.is_active:\n        if new_email:\n            if User.objects.filter(email=new_email).exists():\n                request.session[\"bad_link\"] = True\n                return redirect(\"hc-login\")\n\n            user.email = new_email\n            user.set_unusable_password()\n            user.save()\n\n        user.profile.token = \"\"\n        user.profile.save()\n        return _check_2fa(request, user)\n\n    request.session[\"bad_link\"] = True\n    return redirect(\"hc-login\")\n\n\n@login_required\ndef profile(request):\n    profile = request.profile\n\n    ctx = {\n        \"page\": \"profile\",\n        \"profile\": profile,\n        \"my_projects_status\": \"default\",\n        \"2fa_status\": \"default\",\n        \"added_credential_name\": request.session.pop(\"added_credential_name\", \"\"),\n        \"removed_credential_name\": request.session.pop(\"removed_credential_name\", \"\"),\n        \"enabled_totp\": request.session.pop(\"enabled_totp\", False),\n        \"disabled_totp\": request.session.pop(\"disabled_totp\", False),\n        \"credentials\": list(request.user.credentials.order_by(\"id\")),\n        \"use_webauthn\": settings.RP_ID,\n    }\n\n    if ctx[\"added_credential_name\"] or ctx[\"enabled_totp\"]:\n        ctx[\"2fa_status\"] = \"success\"\n\n    if ctx[\"removed_credential_name\"] or ctx[\"disabled_totp\"]:\n        ctx[\"2fa_status\"] = \"info\"\n\n    if request.session.pop(\"changed_password\", False):\n        ctx[\"changed_password\"] = True\n        ctx[\"email_password_status\"] = \"success\"\n\n    if request.method == \"POST\" and \"leave_project\" in request.POST:\n        code = request.POST[\"code\"]\n        try:\n            project = Project.objects.get(code=code, member__user=request.user)\n        except Project.DoesNotExist:\n            return HttpResponseBadRequest()\n\n        Member.objects.filter(project=project, user=request.user).delete()\n\n        ctx[\"left_project\"] = project\n        ctx[\"my_projects_status\"] = \"info\"\n\n    ctx[\"ownerships\"] = request.user.project_set.order_by(Lower(\"name\"))\n    ctx[\"memberships\"] = request.user.memberships.order_by(Lower(\"project__name\"))\n    return render(request, \"accounts/profile.html\", ctx)\n\n\n@login_required\n@require_POST\ndef add_project(request):\n    form = forms.ProjectNameForm(request.POST)\n    if not form.is_valid():\n        return HttpResponseBadRequest()\n\n    project = Project(owner=request.user)\n    project.code = project.badge_key = str(uuid.uuid4())\n    project.name = form.cleaned_data[\"name\"]\n    project.save()\n\n    return redirect(\"hc-checks\", project.code)\n\n\n@login_required\ndef project(request, code):\n    project = get_object_or_404(Project, code=code)\n    is_owner = project.owner_id == request.user.id\n\n    if request.user.is_superuser or is_owner:\n        is_manager = True\n        rw = True\n    else:\n        membership = get_object_or_404(Member, project=project, user=request.user)\n        is_manager = membership.role == Member.Role.MANAGER\n        rw = membership.is_rw\n\n    ctx = {\n        \"page\": \"project\",\n        \"rw\": rw,\n        \"project\": project,\n        \"is_owner\": is_owner,\n        \"is_manager\": is_manager,\n        \"show_api_keys\": \"show_api_keys\" in request.GET,\n        \"enable_prometheus\": settings.PROMETHEUS_ENABLED is True,\n    }\n\n    if request.method == \"POST\":\n        if \"create_key\" in request.POST:\n            if not rw:\n                return HttpResponseForbidden()\n\n            if request.POST[\"create_key\"] == \"api_key\":\n                project.api_key = _new_key(24)\n            elif request.POST[\"create_key\"] == \"api_key_readonly\":\n                project.api_key_readonly = _new_key(24)\n            elif request.POST[\"create_key\"] == \"ping_key\":\n                project.ping_key = _new_key(16)\n            project.save()\n\n            ctx[\"key_created\"] = True\n            ctx[\"api_status\"] = \"success\"\n            ctx[\"show_keys\"] = True\n        elif \"revoke_key\" in request.POST:\n            if not rw:\n                return HttpResponseForbidden()\n\n            if request.POST[\"revoke_key\"] == \"api_key\":\n                project.api_key = \"\"\n            elif request.POST[\"revoke_key\"] == \"api_key_readonly\":\n                project.api_key_readonly = \"\"\n            elif request.POST[\"revoke_key\"] == \"ping_key\":\n                project.ping_key = None\n            project.save()\n\n            ctx[\"key_revoked\"] = True\n            ctx[\"api_status\"] = \"info\"\n        elif \"show_keys\" in request.POST:\n            if not rw:\n                return HttpResponseForbidden()\n\n            ctx[\"show_keys\"] = True\n        elif \"invite_team_member\" in request.POST:\n            if not is_manager:\n                return HttpResponseForbidden()\n\n            form = forms.InviteTeamMemberForm(request.POST)\n            if form.is_valid():\n                email = form.cleaned_data[\"email\"]\n\n                invite_suggestions = project.invite_suggestions()\n                if not invite_suggestions.filter(email=email).exists():\n                    # We're inviting a new user. Are we within team size limit?\n                    if not project.can_invite_new_users():\n                        return HttpResponseForbidden()\n\n                    # And are we not hitting a rate limit?\n                    if not TokenBucket.authorize_invite(request.user):\n                        return render(request, \"try_later.html\")\n\n                try:\n                    user = User.objects.get(email=email)\n                except User.DoesNotExist:\n                    user = _make_user(email, with_project=False)\n\n                if project.invite(user, role=form.cleaned_data[\"role\"]):\n                    ctx[\"team_member_invited\"] = email\n                    ctx[\"team_status\"] = \"success\"\n                else:\n                    ctx[\"team_member_duplicate\"] = email\n                    ctx[\"team_status\"] = \"info\"\n\n        elif \"remove_team_member\" in request.POST:\n            if not is_manager:\n                return HttpResponseForbidden()\n\n            form = forms.RemoveTeamMemberForm(request.POST)\n            if form.is_valid():\n                q = User.objects\n                q = q.filter(email=form.cleaned_data[\"email\"])\n                q = q.filter(memberships__project=project)\n                farewell_user = q.first()\n                if farewell_user is None:\n                    return HttpResponseBadRequest()\n\n                if farewell_user == request.user:\n                    return HttpResponseBadRequest()\n\n                Member.objects.filter(project=project, user=farewell_user).delete()\n\n                ctx[\"team_member_removed\"] = form.cleaned_data[\"email\"]\n                ctx[\"team_status\"] = \"info\"\n        elif \"set_project_name\" in request.POST:\n            if not rw:\n                return HttpResponseForbidden()\n\n            form = forms.ProjectNameForm(request.POST)\n            if form.is_valid():\n                project.name = form.cleaned_data[\"name\"]\n                project.save()\n\n                ctx[\"project_name_updated\"] = True\n                ctx[\"project_name_status\"] = \"success\"\n\n        elif \"transfer_project\" in request.POST:\n            if not is_owner:\n                return HttpResponseForbidden()\n\n            form = forms.TransferForm(request.POST)\n            if form.is_valid():\n                # Look up the proposed new owner\n                email = form.cleaned_data[\"email\"]\n                try:\n                    membership = project.member_set.filter(user__email=email).get()\n                except Member.DoesNotExist:\n                    return HttpResponseBadRequest()\n\n                # Revoke any previous transfer requests\n                project.member_set.update(transfer_request_date=None)\n\n                # Initiate the new request\n                membership.transfer_request_date = now()\n                membership.save()\n\n                # Send an email notification\n                profile = Profile.objects.for_user(membership.user)\n                profile.send_transfer_request(project)\n\n                ctx[\"transfer_initiated\"] = True\n                ctx[\"transfer_status\"] = \"success\"\n\n        elif \"cancel_transfer\" in request.POST:\n            if not is_owner:\n                return HttpResponseForbidden()\n\n            project.member_set.update(transfer_request_date=None)\n            ctx[\"transfer_cancelled\"] = True\n            ctx[\"transfer_status\"] = \"success\"\n\n        elif \"accept_transfer\" in request.POST:\n            tr = project.transfer_request()\n            if not tr or tr.user != request.user:\n                return HttpResponseForbidden()\n\n            if not tr.can_accept():\n                return HttpResponseBadRequest()\n\n            with transaction.atomic():\n                # 1. Reuse the existing membership, and change its user\n                tr.user = project.owner\n                tr.transfer_request_date = None\n                # The previous owner becomes a regular member\n                # (not readonly, not manager):\n                tr.role = Member.Role.REGULAR\n                tr.save()\n\n                # 2. Change project's owner\n                project.owner = request.user\n                project.save()\n\n            ctx[\"is_owner\"] = True\n            ctx[\"is_manager\"] = True\n            messages.success(request, \"You are now the owner of this project!\")\n\n        elif \"reject_transfer\" in request.POST:\n            tr = project.transfer_request()\n            if not tr or tr.user != request.user:\n                return HttpResponseForbidden()\n\n            tr.transfer_request_date = None\n            tr.save()\n\n    q = project.member_set.select_related(\"user\").order_by(\"user__email\")\n    ctx[\"memberships\"] = list(q)\n    ctx[\"can_invite_new_users\"] = project.can_invite_new_users()\n    return render(request, \"accounts/project.html\", ctx)\n\n\n@login_required\ndef notifications(request):\n    profile = request.profile\n\n    ctx = {\n        \"status\": \"default\",\n        \"page\": \"profile\",\n        \"profile\": profile,\n        \"timezones\": all_timezones,\n    }\n\n    if request.method == \"POST\":\n        form = forms.ReportSettingsForm(request.POST)\n        if form.is_valid():\n            if form.cleaned_data[\"tz\"]:\n                profile.tz = form.cleaned_data[\"tz\"]\n            profile.reports = form.cleaned_data[\"reports\"]\n            profile.next_report_date = profile.choose_next_report_date()\n\n            if profile.nag_period != form.cleaned_data[\"nag_period\"]:\n                # Set the new nag period\n                profile.nag_period = form.cleaned_data[\"nag_period\"]\n                # and update next_nag_date:\n                if profile.nag_period:\n                    profile.update_next_nag_date()\n                else:\n                    profile.next_nag_date = None\n\n            profile.save()\n            ctx[\"status\"] = \"info\"\n\n    return render(request, \"accounts/notifications.html\", ctx)\n\n\n@login_required\n@require_sudo_mode\ndef set_password(request):\n    if request.method == \"POST\":\n        form = forms.SetPasswordForm(request.POST)\n        if form.is_valid():\n            password = form.cleaned_data[\"password\"]\n            request.user.set_password(password)\n            request.user.save()\n\n            request.profile.token = \"\"\n            request.profile.save()\n\n            # update the session with the new password hash so that\n            # the user doesn't  get logged out\n            update_session_auth_hash(request, request.user)\n\n            request.session[\"changed_password\"] = True\n            return redirect(\"hc-profile\")\n\n    return render(request, \"accounts/set_password.html\", {})\n\n\n@login_required\n@require_sudo_mode\ndef change_email(request):\n    if \"sent\" in request.session:\n        ctx = {\"email\": request.session.pop(\"sent\")}\n        return render(request, \"accounts/change_email_instructions.html\", ctx)\n\n    if request.method == \"POST\":\n        form = forms.ChangeEmailForm(request.POST)\n        if form.is_valid():\n            # The user has entered a valid-looking new email address.\n            # Send a special login link to the new address. When the user\n            # clicks the special login link, hc.accounts.views.change_email_verify\n            # unpacks the payload, and passes it to hc.accounts.views.check_token,\n            # which finally updates user's email address.\n            email = form.cleaned_data[\"email\"]\n            request.profile.send_change_email_link(email)\n            request.session[\"sent\"] = email\n\n            response = redirect(reverse(\"hc-change-email\"))\n            # check_token looks for this cookie to decide if\n            # it needs to do the extra POST step.\n            response.set_cookie(\"auto-login\", \"1\", max_age=900, httponly=True)\n            return response\n    else:\n        form = forms.ChangeEmailForm()\n\n    return render(request, \"accounts/change_email.html\", {\"form\": form})\n\n\ndef change_email_verify(request, signed_payload):\n    try:\n        payload = TimestampSigner().unsign_object(signed_payload, max_age=900)\n    except BadSignature:\n        return render(request, \"bad_link.html\")\n\n    return check_token(request, payload[\"u\"], payload[\"t\"], payload[\"e\"])\n\n\n@csrf_exempt\ndef unsubscribe_reports(request, signed_username):\n    # Some email servers open links in emails to check for malicious content.\n    # To work around this, for GET requests we serve a confirmation form.\n    # If the signature is more than 5 minutes old, we also include JS code to\n    # auto-submit the form.\n\n    signer = TimestampSigner(salt=\"reports\")\n    # First, check the signature without looking at the timestamp:\n    try:\n        username = signer.unsign(signed_username)\n    except BadSignature:\n        return render(request, \"bad_link.html\")\n\n    try:\n        user = User.objects.get(username=username)\n    except User.DoesNotExist:\n        # This is likely an old unsubscribe link, and the user account has already\n        # been deleted. Show the \"Unsubscribed!\" page nevertheless.\n        return render(request, \"accounts/unsubscribed.html\")\n\n    if request.method != \"POST\":\n        # Unsign again, now with max_age set,\n        # to see if the timestamp is older than 5 minutes\n        try:\n            autosubmit = False\n            username = signer.unsign(signed_username, max_age=300)\n        except SignatureExpired:\n            autosubmit = True\n\n        ctx = {\"autosubmit\": autosubmit}\n        return render(request, \"accounts/unsubscribe_submit.html\", ctx)\n\n    profile = Profile.objects.for_user(user)\n    profile.reports = \"off\"\n    profile.next_report_date = None\n    profile.nag_period = td()\n    profile.next_nag_date = None\n    profile.save()\n\n    return render(request, \"accounts/unsubscribed.html\")\n\n\n@login_required\n@require_sudo_mode\ndef close(request):\n    user = request.user\n\n    if request.method == \"POST\":\n        if request.POST.get(\"confirmation\") == request.user.email:\n            # Cancel their subscription:\n            if sub := Subscription.objects.filter(user=user).first():\n                sub.cancel()\n\n            # Deleting user also deletes its profile, checks, channels etc.\n            user.delete()\n\n            request.session.flush()\n            return redirect(\"hc-login\")\n\n    ctx = {}\n    if \"confirmation\" in request.POST:\n        ctx[\"wrong_confirmation\"] = True\n\n    return render(request, \"accounts/close_account.html\", ctx)\n\n\n@require_POST\n@login_required\ndef remove_project(request, code):\n    project = get_object_or_404(Project, code=code, owner=request.user)\n    project.delete()\n    return redirect(\"hc-index\")\n\n\n@login_required\n@require_sudo_mode\ndef add_webauthn(request):\n    if not settings.RP_ID:\n        return HttpResponse(status=404)\n\n    credentials = request.user.credentials.values_list(\"data\", flat=True)\n    helper = CreateHelper(settings.RP_ID, credentials)\n\n    if request.method == \"POST\":\n        form = forms.AddWebAuthnForm(request.POST)\n        if not form.is_valid():\n            return HttpResponseBadRequest()\n\n        state = request.session[\"state\"]\n        credential_bytes = helper.verify(state, form.cleaned_data[\"response\"])\n        if credential_bytes is None:\n            return HttpResponseBadRequest()\n\n        c = Credential(user=request.user)\n        c.name = form.cleaned_data[\"name\"]\n        c.data = credential_bytes\n        c.save()\n\n        request.session.pop(\"state\")\n        request.session[\"added_credential_name\"] = c.name\n        return redirect(\"hc-profile\")\n\n    options, request.session[\"state\"] = helper.prepare(request.user.email)\n    return render(request, \"accounts/add_credential.html\", {\"options\": options})\n\n\n@login_required\n@require_sudo_mode\ndef add_totp(request):\n    if request.profile.totp:\n        # TOTP is already configured, refuse to continue\n        return HttpResponseBadRequest()\n\n    if \"totp_secret\" not in request.session:\n        request.session[\"totp_secret\"] = pyotp.random_base32()\n\n    totp = pyotp.totp.TOTP(request.session[\"totp_secret\"])\n\n    if request.method == \"POST\":\n        form = forms.TotpForm(totp, request.POST)\n        if form.is_valid():\n            request.profile.totp = request.session[\"totp_secret\"]\n            request.profile.totp_created = now()\n            request.profile.save()\n\n            request.session[\"enabled_totp\"] = True\n            request.session.pop(\"totp_secret\")\n            return redirect(\"hc-profile\")\n    else:\n        form = forms.TotpForm(totp)\n\n    uri = totp.provisioning_uri(name=request.user.email, issuer_name=settings.SITE_NAME)\n    qr_data_uri = segno.make(uri).png_data_uri(scale=8)\n    ctx = {\n        \"form\": form,\n        \"qr_data_uri\": qr_data_uri,\n        \"secret\": request.session[\"totp_secret\"],\n    }\n    return render(request, \"accounts/add_totp.html\", ctx)\n\n\n@login_required\n@require_sudo_mode\ndef remove_totp(request):\n    if request.method == \"POST\" and \"disable_totp\" in request.POST:\n        request.profile.totp = None\n        request.profile.totp_created = None\n        request.profile.save()\n        request.session[\"disabled_totp\"] = True\n        return redirect(\"hc-profile\")\n\n    ctx = {\"is_last\": not request.user.credentials.exists()}\n    return render(request, \"accounts/remove_totp.html\", ctx)\n\n\n@login_required\n@require_sudo_mode\ndef remove_credential(request, code):\n    if not settings.RP_ID:\n        return HttpResponse(status=404)\n\n    try:\n        credential = Credential.objects.get(user=request.user, code=code)\n    except Credential.DoesNotExist:\n        return HttpResponseBadRequest()\n\n    if request.method == \"POST\" and \"remove_credential\" in request.POST:\n        request.session[\"removed_credential_name\"] = credential.name\n        credential.delete()\n        return redirect(\"hc-profile\")\n\n    if request.profile.totp:\n        is_last = False\n    else:\n        is_last = request.user.credentials.count() == 1\n\n    ctx = {\"credential\": credential, \"is_last\": is_last}\n    return render(request, \"accounts/remove_credential.html\", ctx)\n\n\ndef login_webauthn(request):\n    # We require RP_ID. Fail predicably if it is not set:\n    if not settings.RP_ID:\n        return HttpResponse(status=500)\n\n    # Expect an unauthenticated user\n    if request.user.is_authenticated:\n        return HttpResponseBadRequest()\n\n    if \"2fa_user\" not in request.session:\n        return HttpResponseBadRequest()\n\n    user_id, email, timestamp = request.session[\"2fa_user\"]\n    if timestamp + 300 < time.time():\n        return redirect(\"hc-login\")\n\n    try:\n        user = User.objects.get(id=user_id, email=email)\n    except User.DoesNotExist:\n        return HttpResponseBadRequest()\n\n    credentials = user.credentials.values_list(\"data\", flat=True)\n    helper = GetHelper(settings.RP_ID, credentials)\n\n    if request.method == \"POST\":\n        form = forms.WebAuthnForm(request.POST)\n        if not form.is_valid():\n            return HttpResponseBadRequest()\n\n        if not helper.verify(request.session[\"state\"], form.cleaned_data[\"response\"]):\n            return HttpResponseBadRequest()\n\n        request.session.pop(\"state\")\n        request.session.pop(\"2fa_user\")\n        auth_login(request, user, \"hc.accounts.backends.EmailBackend\")\n        return _redirect_after_login(request)\n\n    options, request.session[\"state\"] = helper.prepare()\n\n    totp_url = None\n    if user.profile.totp:\n        totp_url = reverse(\"hc-login-totp\")\n        redirect_url = request.GET.get(\"next\")\n        if _allow_redirect(redirect_url):\n            totp_url += \"?next=%s\" % redirect_url\n\n    ctx = {\n        \"options\": options,\n        \"totp_url\": totp_url,\n    }\n    return render(request, \"accounts/login_webauthn.html\", ctx)\n\n\ndef login_totp(request):\n    # Expect an unauthenticated user\n    if request.user.is_authenticated:\n        return HttpResponseBadRequest()\n\n    if \"2fa_user\" not in request.session:\n        return HttpResponseBadRequest()\n\n    user_id, email, timestamp = request.session[\"2fa_user\"]\n    if timestamp + 300 < time.time():\n        return redirect(\"hc-login\")\n\n    try:\n        user = User.objects.get(id=user_id, email=email)\n    except User.DoesNotExist:\n        return HttpResponseBadRequest()\n\n    if not user.profile.totp:\n        return HttpResponseBadRequest()\n\n    totp = pyotp.totp.TOTP(user.profile.totp)\n    if request.method == \"POST\":\n        # To guard against brute-forcing TOTP codes, we allow\n        # 96 attempts per user per 24h.\n        if not TokenBucket.authorize_totp_attempt(user):\n            return render(request, \"try_later.html\")\n\n        form = forms.TotpForm(totp, request.POST)\n        if form.is_valid():\n            # We blacklist an used TOTP code for 90 seconds,\n            # so an attacker cannot reuse a stolen code.\n            if not TokenBucket.authorize_totp_code(user, form.cleaned_data[\"code\"]):\n                return render(request, \"try_later.html\")\n\n            request.session.pop(\"2fa_user\")\n            auth_login(request, user, \"hc.accounts.backends.EmailBackend\")\n            return _redirect_after_login(request)\n    else:\n        form = forms.TotpForm(totp)\n\n    return render(request, \"accounts/login_totp.html\", {\"form\": form})\n\n\n@login_required\ndef appearance(request):\n    profile = request.profile\n\n    ctx = {\n        \"page\": \"appearance\",\n        \"profile\": profile,\n        \"status\": \"default\",\n    }\n\n    if request.method == \"POST\":\n        theme = request.POST.get(\"theme\", \"\")\n        if theme in (\"\", \"dark\"):\n            profile.theme = theme\n            profile.save()\n            ctx[\"status\"] = \"info\"\n\n    return render(request, \"accounts/appearance.html\", ctx)\n", "{% extends \"base.html\" %}\n{% load hc_extras %}\n\n{% block content %}\n<div class=\"row\">\n    <div class=\"col-sm-6 col-sm-offset-3\">\n        <div class=\"hc-dialog\">\n            <h1>Check Your Email!</h1>\n            <br />\n            <p>\n                If a {% site_name %} account exists for this email address,\n                you will receive a login link in your email shortly.\n            </p>\n        </div>\n    </div>\n</div>\n\n{% endblock %}\n", "{% for error in form.identity.errors %}\n<p class=\"text-danger\">{{ error }}</p>\n{% empty %}\n<p class=\"text-success\">Please check your email!</p>\n{% endfor %}"], "filenames": ["CHANGELOG.md", "hc/accounts/forms.py", "hc/accounts/tests/test_login.py", "hc/accounts/tests/test_signup.py", "hc/accounts/views.py", "templates/accounts/login_link_sent.html", "templates/accounts/signup_result.html"], "buggy_code_start_loc": [19, 33, 58, 19, 164, 1, 3], "buggy_code_end_loc": [19, 64, 58, 105, 214, 14, 8], "fixing_code_start_loc": [20, 32, 59, 19, 164, 2, 3], "fixing_code_end_loc": [21, 59, 69, 109, 215, 13, 6], "type": "CWE-203", "message": "Observable Discrepancy in GitHub repository healthchecks/healthchecks prior to v2.6.", "other": {"cve": {"id": "CVE-2023-0440", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-23T14:15:11.720", "lastModified": "2023-03-02T02:15:41.507", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Observable Discrepancy in GitHub repository healthchecks/healthchecks prior to v2.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:healthchecks:healthchecks:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6", "matchCriteriaId": "67ABA56D-6361-4668-A210-5DC5EDF49E0A"}]}]}], "references": [{"url": "https://github.com/healthchecks/healthchecks/commit/359edbd2709e27b60687061a32e19322bc971c1f", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/208a096f-7986-4eed-8629-b7285348a686", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/healthchecks/healthchecks/commit/359edbd2709e27b60687061a32e19322bc971c1f"}}