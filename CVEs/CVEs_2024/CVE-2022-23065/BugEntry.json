{"buggy_code": ["import { MiddlewareConsumer, NestModule, OnApplicationBootstrap } from '@nestjs/common';\nimport { Type } from '@vendure/common/lib/shared-types';\nimport {\n    AssetStorageStrategy,\n    Logger,\n    PluginCommonModule,\n    ProcessContext,\n    registerPluginStartupMessage,\n    RuntimeVendureConfig,\n    VendurePlugin,\n} from '@vendure/core';\nimport { createHash } from 'crypto';\nimport express, { NextFunction, Request, Response } from 'express';\nimport { fromBuffer } from 'file-type';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { loggerCtx } from './constants';\nimport { defaultAssetStorageStrategyFactory } from './default-asset-storage-strategy-factory';\nimport { HashedAssetNamingStrategy } from './hashed-asset-naming-strategy';\nimport { SharpAssetPreviewStrategy } from './sharp-asset-preview-strategy';\nimport { transformImage } from './transform-image';\nimport { AssetServerOptions, ImageTransformPreset } from './types';\n\n/**\n * @description\n * The `AssetServerPlugin` serves assets (images and other files) from the local file system, and can also be configured to use\n * other storage strategies (e.g. {@link S3AssetStorageStrategy}. It can also perform on-the-fly image transformations\n * and caches the results for subsequent calls.\n *\n * ## Installation\n *\n * `yarn add \\@vendure/asset-server-plugin`\n *\n * or\n *\n * `npm install \\@vendure/asset-server-plugin`\n *\n * @example\n * ```ts\n * import { AssetServerPlugin } from '\\@vendure/asset-server-plugin';\n *\n * const config: VendureConfig = {\n *   // Add an instance of the plugin to the plugins array\n *   plugins: [\n *     AssetServerPlugin.init({\n *       route: 'assets',\n *       assetUploadDir: path.join(__dirname, 'assets'),\n *     }),\n *   ],\n * };\n * ```\n *\n * The full configuration is documented at [AssetServerOptions]({{< relref \"asset-server-options\" >}})\n *\n * ## Image transformation\n *\n * Asset preview images can be transformed (resized & cropped) on the fly by appending query parameters to the url:\n *\n * `http://localhost:3000/assets/some-asset.jpg?w=500&h=300&mode=resize`\n *\n * The above URL will return `some-asset.jpg`, resized to fit in the bounds of a 500px x 300px rectangle.\n *\n * ### Preview mode\n *\n * The `mode` parameter can be either `crop` or `resize`. See the [ImageTransformMode]({{< relref \"image-transform-mode\" >}}) docs for details.\n *\n * ### Focal point\n *\n * When cropping an image (`mode=crop`), Vendure will attempt to keep the most \"interesting\" area of the image in the cropped frame. It does this\n * by finding the area of the image with highest entropy (the busiest area of the image). However, sometimes this does not yield a satisfactory\n * result - part or all of the main subject may still be cropped out.\n *\n * This is where specifying the focal point can help. The focal point of the image may be specified by passing the `fpx` and `fpy` query parameters.\n * These are normalized coordinates (i.e. a number between 0 and 1), so the `fpx=0&fpy=0` corresponds to the top left of the image.\n *\n * For example, let's say there is a very wide landscape image which we want to crop to be square. The main subject is a house to the far left of the\n * image. The following query would crop it to a square with the house centered:\n *\n * `http://localhost:3000/assets/landscape.jpg?w=150&h=150&mode=crop&fpx=0.2&fpy=0.7`\n *\n * ### Transform presets\n *\n * Presets can be defined which allow a single preset name to be used instead of specifying the width, height and mode. Presets are\n * configured via the AssetServerOptions [presets property]({{< relref \"asset-server-options\" >}}#presets).\n *\n * For example, defining the following preset:\n *\n * ```ts\n * AssetServerPlugin.init({\n *   // ...\n *   presets: [\n *     { name: 'my-preset', width: 85, height: 85, mode: 'crop' },\n *   ],\n * }),\n * ```\n *\n * means that a request to:\n *\n * `http://localhost:3000/assets/some-asset.jpg?preset=my-preset`\n *\n * is equivalent to:\n *\n * `http://localhost:3000/assets/some-asset.jpg?w=85&h=85&mode=crop`\n *\n * The AssetServerPlugin comes pre-configured with the following presets:\n *\n * name | width | height | mode\n * -----|-------|--------|-----\n * tiny | 50px | 50px | crop\n * thumb | 150px | 150px | crop\n * small | 300px | 300px | resize\n * medium | 500px | 500px | resize\n * large | 800px | 800px | resize\n *\n * ### Caching\n * By default, the AssetServerPlugin will cache every transformed image, so that the transformation only needs to be performed a single time for\n * a given configuration. Caching can be disabled per-request by setting the `?cache=false` query parameter.\n *\n * @docsCategory AssetServerPlugin\n */\n@VendurePlugin({\n    imports: [PluginCommonModule],\n    configuration: config => AssetServerPlugin.configure(config),\n})\nexport class AssetServerPlugin implements NestModule, OnApplicationBootstrap {\n    private static assetStorage: AssetStorageStrategy;\n    private readonly cacheDir = 'cache';\n    private presets: ImageTransformPreset[] = [\n        { name: 'tiny', width: 50, height: 50, mode: 'crop' },\n        { name: 'thumb', width: 150, height: 150, mode: 'crop' },\n        { name: 'small', width: 300, height: 300, mode: 'resize' },\n        { name: 'medium', width: 500, height: 500, mode: 'resize' },\n        { name: 'large', width: 800, height: 800, mode: 'resize' },\n    ];\n    private static options: AssetServerOptions;\n\n    /**\n     * @description\n     * Set the plugin options.\n     */\n    static init(options: AssetServerOptions): Type<AssetServerPlugin> {\n        AssetServerPlugin.options = options;\n        return this;\n    }\n\n    /** @internal */\n    static async configure(config: RuntimeVendureConfig) {\n        const storageStrategyFactory =\n            this.options.storageStrategyFactory || defaultAssetStorageStrategyFactory;\n        this.assetStorage = await storageStrategyFactory(this.options);\n        config.assetOptions.assetPreviewStrategy = new SharpAssetPreviewStrategy({\n            maxWidth: this.options.previewMaxWidth || 1600,\n            maxHeight: this.options.previewMaxHeight || 1600,\n        });\n        config.assetOptions.assetStorageStrategy = this.assetStorage;\n        config.assetOptions.assetNamingStrategy =\n            this.options.namingStrategy || new HashedAssetNamingStrategy();\n        return config;\n    }\n\n    constructor(private processContext: ProcessContext) {}\n\n    /** @internal */\n    onApplicationBootstrap(): void | Promise<void> {\n        if (this.processContext.isWorker) {\n            return;\n        }\n        if (AssetServerPlugin.options.presets) {\n            for (const preset of AssetServerPlugin.options.presets) {\n                const existingIndex = this.presets.findIndex(p => p.name === preset.name);\n                if (-1 < existingIndex) {\n                    this.presets.splice(existingIndex, 1, preset);\n                } else {\n                    this.presets.push(preset);\n                }\n            }\n        }\n\n        const cachePath = path.join(AssetServerPlugin.options.assetUploadDir, this.cacheDir);\n        fs.ensureDirSync(cachePath);\n    }\n\n    configure(consumer: MiddlewareConsumer) {\n        if (this.processContext.isWorker) {\n            return;\n        }\n        Logger.info('Creating asset server middleware', loggerCtx);\n        consumer.apply(this.createAssetServer()).forRoutes(AssetServerPlugin.options.route);\n        registerPluginStartupMessage('Asset server', AssetServerPlugin.options.route);\n    }\n\n    /**\n     * Creates the image server instance\n     */\n    private createAssetServer() {\n        const assetServer = express.Router();\n        assetServer.use(this.sendAsset(), this.generateTransformedImage());\n        return assetServer;\n    }\n\n    /**\n     * Reads the file requested and send the response to the browser.\n     */\n    private sendAsset() {\n        return async (req: Request, res: Response, next: NextFunction) => {\n            const key = this.getFileNameFromRequest(req);\n            try {\n                const file = await AssetServerPlugin.assetStorage.readFileToBuffer(key);\n                let mimeType = this.getMimeType(key);\n                if (!mimeType) {\n                    mimeType = (await fromBuffer(file))?.mime || 'application/octet-stream';\n                }\n                res.contentType(mimeType);\n                res.send(file);\n            } catch (e) {\n                const err = new Error('File not found');\n                (err as any).status = 404;\n                return next(err);\n            }\n        };\n    }\n\n    /**\n     * If an exception was thrown by the first handler, then it may be because a transformed image\n     * is being requested which does not yet exist. In this case, this handler will generate the\n     * transformed image, save it to cache, and serve the result as a response.\n     */\n    private generateTransformedImage() {\n        return async (err: any, req: Request, res: Response, next: NextFunction) => {\n            if (err && (err.status === 404 || err.statusCode === 404)) {\n                if (req.query) {\n                    const decodedReqPath = decodeURIComponent(req.path);\n                    Logger.debug(`Pre-cached Asset not found: ${decodedReqPath}`, loggerCtx);\n                    let file: Buffer;\n                    try {\n                        file = await AssetServerPlugin.assetStorage.readFileToBuffer(decodedReqPath);\n                    } catch (err) {\n                        res.status(404).send('Resource not found');\n                        return;\n                    }\n                    const image = await transformImage(file, req.query as any, this.presets || []);\n                    try {\n                        const imageBuffer = await image.toBuffer();\n                        if (!req.query.cache || req.query.cache === 'true') {\n                            const cachedFileName = this.getFileNameFromRequest(req);\n                            await AssetServerPlugin.assetStorage.writeFileFromBuffer(\n                                cachedFileName,\n                                imageBuffer,\n                            );\n                            Logger.debug(`Saved cached asset: ${cachedFileName}`, loggerCtx);\n                        }\n                        res.set('Content-Type', `image/${(await image.metadata()).format}`);\n                        res.send(imageBuffer);\n                        return;\n                    } catch (e) {\n                        Logger.error(e, 'AssetServerPlugin', e.stack);\n                        res.status(500).send(e.message);\n                        return;\n                    }\n                }\n            }\n            next();\n        };\n    }\n\n    private getFileNameFromRequest(req: Request): string {\n        const { w, h, mode, preset, fpx, fpy } = req.query;\n        const focalPoint = fpx && fpy ? `_fpx${fpx}_fpy${fpy}` : '';\n        let imageParamHash: string | null = null;\n        if (w || h) {\n            const width = w || '';\n            const height = h || '';\n            imageParamHash = this.md5(`_transform_w${width}_h${height}_m${mode}${focalPoint}`);\n        } else if (preset) {\n            if (this.presets && !!this.presets.find(p => p.name === preset)) {\n                imageParamHash = this.md5(`_transform_pre_${preset}${focalPoint}`);\n            }\n        }\n\n        const decodedReqPath = decodeURIComponent(req.path);\n        if (imageParamHash) {\n            return path.join(this.cacheDir, this.addSuffix(decodedReqPath, imageParamHash));\n        } else {\n            return decodedReqPath;\n        }\n    }\n\n    private md5(input: string): string {\n        return createHash('md5').update(input).digest('hex');\n    }\n\n    private addSuffix(fileName: string, suffix: string): string {\n        const ext = path.extname(fileName);\n        const baseName = path.basename(fileName, ext);\n        const dirName = path.dirname(fileName);\n        return path.join(dirName, `${baseName}${suffix}${ext}`);\n    }\n\n    /**\n     * Attempt to get the mime type from the file name.\n     */\n    private getMimeType(fileName: string): string | undefined {\n        const ext = path.extname(fileName);\n        switch (ext) {\n            case '.jpg':\n            case '.jpeg':\n                return 'image/jpeg';\n            case '.png':\n                return 'image/png';\n            case '.gif':\n                return 'image/gif';\n            case '.svg':\n                return 'image/svg+xml';\n            case '.tiff':\n                return 'image/tiff';\n            case '.webp':\n                return 'image/webp';\n        }\n    }\n}\n"], "fixing_code": ["import { MiddlewareConsumer, NestModule, OnApplicationBootstrap } from '@nestjs/common';\nimport { Type } from '@vendure/common/lib/shared-types';\nimport {\n    AssetStorageStrategy,\n    Logger,\n    PluginCommonModule,\n    ProcessContext,\n    registerPluginStartupMessage,\n    RuntimeVendureConfig,\n    VendurePlugin,\n} from '@vendure/core';\nimport { createHash } from 'crypto';\nimport express, { NextFunction, Request, Response } from 'express';\nimport { fromBuffer } from 'file-type';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { loggerCtx } from './constants';\nimport { defaultAssetStorageStrategyFactory } from './default-asset-storage-strategy-factory';\nimport { HashedAssetNamingStrategy } from './hashed-asset-naming-strategy';\nimport { SharpAssetPreviewStrategy } from './sharp-asset-preview-strategy';\nimport { transformImage } from './transform-image';\nimport { AssetServerOptions, ImageTransformPreset } from './types';\n\n/**\n * @description\n * The `AssetServerPlugin` serves assets (images and other files) from the local file system, and can also be configured to use\n * other storage strategies (e.g. {@link S3AssetStorageStrategy}. It can also perform on-the-fly image transformations\n * and caches the results for subsequent calls.\n *\n * ## Installation\n *\n * `yarn add \\@vendure/asset-server-plugin`\n *\n * or\n *\n * `npm install \\@vendure/asset-server-plugin`\n *\n * @example\n * ```ts\n * import { AssetServerPlugin } from '\\@vendure/asset-server-plugin';\n *\n * const config: VendureConfig = {\n *   // Add an instance of the plugin to the plugins array\n *   plugins: [\n *     AssetServerPlugin.init({\n *       route: 'assets',\n *       assetUploadDir: path.join(__dirname, 'assets'),\n *     }),\n *   ],\n * };\n * ```\n *\n * The full configuration is documented at [AssetServerOptions]({{< relref \"asset-server-options\" >}})\n *\n * ## Image transformation\n *\n * Asset preview images can be transformed (resized & cropped) on the fly by appending query parameters to the url:\n *\n * `http://localhost:3000/assets/some-asset.jpg?w=500&h=300&mode=resize`\n *\n * The above URL will return `some-asset.jpg`, resized to fit in the bounds of a 500px x 300px rectangle.\n *\n * ### Preview mode\n *\n * The `mode` parameter can be either `crop` or `resize`. See the [ImageTransformMode]({{< relref \"image-transform-mode\" >}}) docs for details.\n *\n * ### Focal point\n *\n * When cropping an image (`mode=crop`), Vendure will attempt to keep the most \"interesting\" area of the image in the cropped frame. It does this\n * by finding the area of the image with highest entropy (the busiest area of the image). However, sometimes this does not yield a satisfactory\n * result - part or all of the main subject may still be cropped out.\n *\n * This is where specifying the focal point can help. The focal point of the image may be specified by passing the `fpx` and `fpy` query parameters.\n * These are normalized coordinates (i.e. a number between 0 and 1), so the `fpx=0&fpy=0` corresponds to the top left of the image.\n *\n * For example, let's say there is a very wide landscape image which we want to crop to be square. The main subject is a house to the far left of the\n * image. The following query would crop it to a square with the house centered:\n *\n * `http://localhost:3000/assets/landscape.jpg?w=150&h=150&mode=crop&fpx=0.2&fpy=0.7`\n *\n * ### Transform presets\n *\n * Presets can be defined which allow a single preset name to be used instead of specifying the width, height and mode. Presets are\n * configured via the AssetServerOptions [presets property]({{< relref \"asset-server-options\" >}}#presets).\n *\n * For example, defining the following preset:\n *\n * ```ts\n * AssetServerPlugin.init({\n *   // ...\n *   presets: [\n *     { name: 'my-preset', width: 85, height: 85, mode: 'crop' },\n *   ],\n * }),\n * ```\n *\n * means that a request to:\n *\n * `http://localhost:3000/assets/some-asset.jpg?preset=my-preset`\n *\n * is equivalent to:\n *\n * `http://localhost:3000/assets/some-asset.jpg?w=85&h=85&mode=crop`\n *\n * The AssetServerPlugin comes pre-configured with the following presets:\n *\n * name | width | height | mode\n * -----|-------|--------|-----\n * tiny | 50px | 50px | crop\n * thumb | 150px | 150px | crop\n * small | 300px | 300px | resize\n * medium | 500px | 500px | resize\n * large | 800px | 800px | resize\n *\n * ### Caching\n * By default, the AssetServerPlugin will cache every transformed image, so that the transformation only needs to be performed a single time for\n * a given configuration. Caching can be disabled per-request by setting the `?cache=false` query parameter.\n *\n * @docsCategory AssetServerPlugin\n */\n@VendurePlugin({\n    imports: [PluginCommonModule],\n    configuration: config => AssetServerPlugin.configure(config),\n})\nexport class AssetServerPlugin implements NestModule, OnApplicationBootstrap {\n    private static assetStorage: AssetStorageStrategy;\n    private readonly cacheDir = 'cache';\n    private presets: ImageTransformPreset[] = [\n        { name: 'tiny', width: 50, height: 50, mode: 'crop' },\n        { name: 'thumb', width: 150, height: 150, mode: 'crop' },\n        { name: 'small', width: 300, height: 300, mode: 'resize' },\n        { name: 'medium', width: 500, height: 500, mode: 'resize' },\n        { name: 'large', width: 800, height: 800, mode: 'resize' },\n    ];\n    private static options: AssetServerOptions;\n\n    /**\n     * @description\n     * Set the plugin options.\n     */\n    static init(options: AssetServerOptions): Type<AssetServerPlugin> {\n        AssetServerPlugin.options = options;\n        return this;\n    }\n\n    /** @internal */\n    static async configure(config: RuntimeVendureConfig) {\n        const storageStrategyFactory =\n            this.options.storageStrategyFactory || defaultAssetStorageStrategyFactory;\n        this.assetStorage = await storageStrategyFactory(this.options);\n        config.assetOptions.assetPreviewStrategy = new SharpAssetPreviewStrategy({\n            maxWidth: this.options.previewMaxWidth || 1600,\n            maxHeight: this.options.previewMaxHeight || 1600,\n        });\n        config.assetOptions.assetStorageStrategy = this.assetStorage;\n        config.assetOptions.assetNamingStrategy =\n            this.options.namingStrategy || new HashedAssetNamingStrategy();\n        return config;\n    }\n\n    constructor(private processContext: ProcessContext) {}\n\n    /** @internal */\n    onApplicationBootstrap(): void | Promise<void> {\n        if (this.processContext.isWorker) {\n            return;\n        }\n        if (AssetServerPlugin.options.presets) {\n            for (const preset of AssetServerPlugin.options.presets) {\n                const existingIndex = this.presets.findIndex(p => p.name === preset.name);\n                if (-1 < existingIndex) {\n                    this.presets.splice(existingIndex, 1, preset);\n                } else {\n                    this.presets.push(preset);\n                }\n            }\n        }\n\n        const cachePath = path.join(AssetServerPlugin.options.assetUploadDir, this.cacheDir);\n        fs.ensureDirSync(cachePath);\n    }\n\n    configure(consumer: MiddlewareConsumer) {\n        if (this.processContext.isWorker) {\n            return;\n        }\n        Logger.info('Creating asset server middleware', loggerCtx);\n        consumer.apply(this.createAssetServer()).forRoutes(AssetServerPlugin.options.route);\n        registerPluginStartupMessage('Asset server', AssetServerPlugin.options.route);\n    }\n\n    /**\n     * Creates the image server instance\n     */\n    private createAssetServer() {\n        const assetServer = express.Router();\n        assetServer.use(this.sendAsset(), this.generateTransformedImage());\n        return assetServer;\n    }\n\n    /**\n     * Reads the file requested and send the response to the browser.\n     */\n    private sendAsset() {\n        return async (req: Request, res: Response, next: NextFunction) => {\n            const key = this.getFileNameFromRequest(req);\n            try {\n                const file = await AssetServerPlugin.assetStorage.readFileToBuffer(key);\n                let mimeType = this.getMimeType(key);\n                if (!mimeType) {\n                    mimeType = (await fromBuffer(file))?.mime || 'application/octet-stream';\n                }\n                res.contentType(mimeType);\n                res.setHeader('content-security-policy', `default-src 'self'`);\n                res.send(file);\n            } catch (e) {\n                const err = new Error('File not found');\n                (err as any).status = 404;\n                return next(err);\n            }\n        };\n    }\n\n    /**\n     * If an exception was thrown by the first handler, then it may be because a transformed image\n     * is being requested which does not yet exist. In this case, this handler will generate the\n     * transformed image, save it to cache, and serve the result as a response.\n     */\n    private generateTransformedImage() {\n        return async (err: any, req: Request, res: Response, next: NextFunction) => {\n            if (err && (err.status === 404 || err.statusCode === 404)) {\n                if (req.query) {\n                    const decodedReqPath = decodeURIComponent(req.path);\n                    Logger.debug(`Pre-cached Asset not found: ${decodedReqPath}`, loggerCtx);\n                    let file: Buffer;\n                    try {\n                        file = await AssetServerPlugin.assetStorage.readFileToBuffer(decodedReqPath);\n                    } catch (err) {\n                        res.status(404).send('Resource not found');\n                        return;\n                    }\n                    const image = await transformImage(file, req.query as any, this.presets || []);\n                    try {\n                        const imageBuffer = await image.toBuffer();\n                        if (!req.query.cache || req.query.cache === 'true') {\n                            const cachedFileName = this.getFileNameFromRequest(req);\n                            await AssetServerPlugin.assetStorage.writeFileFromBuffer(\n                                cachedFileName,\n                                imageBuffer,\n                            );\n                            Logger.debug(`Saved cached asset: ${cachedFileName}`, loggerCtx);\n                        }\n                        res.set('Content-Type', `image/${(await image.metadata()).format}`);\n                        res.setHeader('content-security-policy', `default-src 'self'`);\n                        res.send(imageBuffer);\n                        return;\n                    } catch (e) {\n                        Logger.error(e, 'AssetServerPlugin', e.stack);\n                        res.status(500).send(e.message);\n                        return;\n                    }\n                }\n            }\n            next();\n        };\n    }\n\n    private getFileNameFromRequest(req: Request): string {\n        const { w, h, mode, preset, fpx, fpy } = req.query;\n        const focalPoint = fpx && fpy ? `_fpx${fpx}_fpy${fpy}` : '';\n        let imageParamHash: string | null = null;\n        if (w || h) {\n            const width = w || '';\n            const height = h || '';\n            imageParamHash = this.md5(`_transform_w${width}_h${height}_m${mode}${focalPoint}`);\n        } else if (preset) {\n            if (this.presets && !!this.presets.find(p => p.name === preset)) {\n                imageParamHash = this.md5(`_transform_pre_${preset}${focalPoint}`);\n            }\n        }\n\n        const decodedReqPath = decodeURIComponent(req.path);\n        if (imageParamHash) {\n            return path.join(this.cacheDir, this.addSuffix(decodedReqPath, imageParamHash));\n        } else {\n            return decodedReqPath;\n        }\n    }\n\n    private md5(input: string): string {\n        return createHash('md5').update(input).digest('hex');\n    }\n\n    private addSuffix(fileName: string, suffix: string): string {\n        const ext = path.extname(fileName);\n        const baseName = path.basename(fileName, ext);\n        const dirName = path.dirname(fileName);\n        return path.join(dirName, `${baseName}${suffix}${ext}`);\n    }\n\n    /**\n     * Attempt to get the mime type from the file name.\n     */\n    private getMimeType(fileName: string): string | undefined {\n        const ext = path.extname(fileName);\n        switch (ext) {\n            case '.jpg':\n            case '.jpeg':\n                return 'image/jpeg';\n            case '.png':\n                return 'image/png';\n            case '.gif':\n                return 'image/gif';\n            case '.svg':\n                return 'image/svg+xml';\n            case '.tiff':\n                return 'image/tiff';\n            case '.webp':\n                return 'image/webp';\n        }\n    }\n}\n"], "filenames": ["packages/asset-server-plugin/src/plugin.ts"], "buggy_code_start_loc": [214], "buggy_code_end_loc": [253], "fixing_code_start_loc": [215], "fixing_code_end_loc": [256], "type": "CWE-79", "message": "In Vendure versions 0.1.0-alpha.2 to 1.5.1 are affected by Stored XSS vulnerability, where an attacker having catalog permission can upload a SVG file that contains malicious JavaScript into the \u201cAssets\u201d tab. The uploaded file will affect administrators as well as regular users.", "other": {"cve": {"id": "CVE-2022-23065", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2022-05-02T13:15:08.247", "lastModified": "2022-05-10T16:34:27.263", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Vendure versions 0.1.0-alpha.2 to 1.5.1 are affected by Stored XSS vulnerability, where an attacker having catalog permission can upload a SVG file that contains malicious JavaScript into the \u201cAssets\u201d tab. The uploaded file will affect administrators as well as regular users."}, {"lang": "es", "value": "En Vendure versiones 0.1.0-alpha.2 a 1.5.1, est\u00e1n afectadas por una vulnerabilidad de tipo XSS almacenado, donde un atacante que tenga permiso de cat\u00e1logo puede subir un archivo SVG que contenga JavaScript malicioso en la pesta\u00f1a \"Assets\". El archivo subido afectar\u00e1 tanto a administradores como a usuarios normales"}], "metrics": {"cvssMetricV31": [{"source": "vulnerabilitylab@mend.io", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "vulnerabilitylab@mend.io", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.1.2", "versionEndIncluding": "1.5.1", "matchCriteriaId": "942E486B-0E5B-482B-B5AD-5C21EB1AC73B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha10:*:*:*:*:*:*", "matchCriteriaId": "61A62862-F19E-48C9-BB25-123EE8C8D6E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha11:*:*:*:*:*:*", "matchCriteriaId": "763F7985-F48A-407E-9C96-96FA1F38E534"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha12:*:*:*:*:*:*", "matchCriteriaId": "D22953B9-DCCE-4254-ACE7-BD9183A59449"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha13:*:*:*:*:*:*", "matchCriteriaId": "4DD08957-E008-4D44-997F-A2EEC3E5B66D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha14:*:*:*:*:*:*", "matchCriteriaId": "80D154FB-87F9-4C11-A662-1726FFA53755"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha15:*:*:*:*:*:*", "matchCriteriaId": "E166C100-CC9B-4741-A5EA-74DD35E1B0FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha16:*:*:*:*:*:*", "matchCriteriaId": "5BD1F5C5-F9B9-4246-90FF-05F2C909B41C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha18:*:*:*:*:*:*", "matchCriteriaId": "BA2053B5-64D2-46D3-9D92-F3C7F7C313FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "457A3442-17DC-456B-A1A8-40884B670F95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "1AAF4576-29AA-4C10-9B03-CDE5AA4DE6F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha4:*:*:*:*:*:*", "matchCriteriaId": "851C8FD6-F4C2-4221-8AB8-A650F25CA593"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha5:*:*:*:*:*:*", "matchCriteriaId": "D3BC9BCD-FE96-4E3B-B042-640B89A7C0E0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha6:*:*:*:*:*:*", "matchCriteriaId": "2C6E25E2-3C99-44EF-8AA7-30531E184601"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha7:*:*:*:*:*:*", "matchCriteriaId": "0ADC4F1C-DF60-4F16-97E2-3EA3D18E9ECD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha8:*:*:*:*:*:*", "matchCriteriaId": "B41FDFE7-6B15-42A6-9617-5321D7C441CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vendure:vendure:0.1.0:alpha9:*:*:*:*:*:*", "matchCriteriaId": "B9007357-5B4E-4707-AC46-EEC90948B747"}]}]}], "references": [{"url": "https://github.com/vendure-ecommerce/vendure/commit/69a44869112c0a5b836e2ddd3969ea9b533f51f0", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2022-23065", "source": "vulnerabilitylab@mend.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vendure-ecommerce/vendure/commit/69a44869112c0a5b836e2ddd3969ea9b533f51f0"}}