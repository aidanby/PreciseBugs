{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *          Authors: Cyril Concolato / Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Box *meta_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MetaBox, GF_ISOM_BOX_TYPE_META);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid meta_reset(GF_Box *s)\n{\n\tGF_MetaBox *ptr = (GF_MetaBox *)s;\n\tif (ptr == NULL) return;\n\n\t//destroy all boxes\n\tif (ptr->child_boxes) gf_isom_box_array_del(ptr->child_boxes);\n\tptr->child_boxes = NULL;\n\n\t//reset pointers (destroyed above)\n\tptr->handler = NULL;\n\tptr->primary_resource = NULL;\n\tptr->file_locations = NULL;\n\tptr->item_locations = NULL;\n\tptr->protections = NULL;\n\tptr->item_infos = NULL;\n\tptr->IPMP_control = NULL;\n\tptr->item_refs = NULL;\n\tptr->item_props = NULL;\n\tptr->groups_list = NULL;\n}\n\nvoid meta_box_del(GF_Box *s)\n{\n\tmeta_reset(s);\n\tgf_free(s);\n}\n\n\nGF_Err meta_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MetaBox *ptr = (GF_MetaBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tBOX_FIELD_ASSIGN(handler, GF_HandlerBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PITM:\n\t\tBOX_FIELD_ASSIGN(primary_resource, GF_PrimaryItemBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tBOX_FIELD_ASSIGN(file_locations, GF_DataInformationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_ILOC:\n\t\tBOX_FIELD_ASSIGN(item_locations, GF_ItemLocationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_IPRO:\n\t\tBOX_FIELD_ASSIGN(protections, GF_ItemProtectionBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_IINF:\n\t\tBOX_FIELD_ASSIGN(item_infos, GF_ItemInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_IREF:\n\t\tBOX_FIELD_ASSIGN(item_refs, GF_ItemReferenceBox);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_IPRP:\n\t\tBOX_FIELD_ASSIGN(item_props, GF_ItemPropertiesBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_GRPL:\n\t\tBOX_FIELD_ASSIGN(groups_list, GF_GroupListBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err meta_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 pos = gf_bs_get_position(bs);\n\tu64 size = s->size;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\t/*try to hack around QT files which don't use a full box for meta, rewind 4 bytes*/\n\tif (e && (pos>4) ) {\n\t\tgf_bs_seek(bs, pos-4);\n\t\tmeta_reset(s);\n\t\ts->size = size+4;\n\t\te = gf_isom_box_array_read(s, bs);\n\t}\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err meta_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err meta_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MetaBox *ptr = (GF_MetaBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->handler, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->primary_resource, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->file_locations, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->item_locations, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->protections, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->item_infos, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->item_refs, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->item_props, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups_list, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *xml_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_XMLBox, GF_ISOM_BOX_TYPE_XML);\n\treturn (GF_Box *)tmp;\n}\n\nvoid xml_box_del(GF_Box *s)\n{\n\tGF_XMLBox *ptr = (GF_XMLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->xml) gf_free(ptr->xml);\n\tgf_free(ptr);\n}\n\nGF_Err xml_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XMLBox *ptr = (GF_XMLBox *)s;\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->xml);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err xml_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_XMLBox *ptr = (GF_XMLBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->xml) gf_bs_write_data(bs, ptr->xml, (u32) strlen(ptr->xml));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err xml_box_size(GF_Box *s)\n{\n\tGF_XMLBox *ptr = (GF_XMLBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n    ptr->size += (ptr->xml ? strlen(ptr->xml) : 0) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *bxml_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BinaryXMLBox, GF_ISOM_BOX_TYPE_BXML);\n\treturn (GF_Box *)tmp;\n}\n\nvoid bxml_box_del(GF_Box *s)\n{\n\tGF_BinaryXMLBox *ptr = (GF_BinaryXMLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err bxml_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_BinaryXMLBox *ptr = (GF_BinaryXMLBox *)s;\n\n\tptr->data_length = (u32)(ptr->size);\n\tptr->data = (char*)gf_malloc(sizeof(char)*ptr->data_length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err bxml_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_BinaryXMLBox *ptr = (GF_BinaryXMLBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->data_length) gf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err bxml_box_size(GF_Box *s)\n{\n\tGF_BinaryXMLBox *ptr = (GF_BinaryXMLBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += ptr->data_length;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *iloc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemLocationBox, GF_ISOM_BOX_TYPE_ILOC);\n\ttmp->location_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid iloc_entry_del(GF_ItemLocationEntry *location)\n{\n\tu32 j, extent_count;\n\textent_count = gf_list_count(location->extent_entries);\n\tfor (j = 0; j < extent_count; j++) {\n\t\tGF_ItemExtentEntry *extent = (GF_ItemExtentEntry *)gf_list_get(location->extent_entries, j);\n\t\tgf_free(extent);\n\t}\n\tgf_list_del(location->extent_entries);\n\tgf_free(location);\n}\n\nvoid iloc_box_del(GF_Box *s)\n{\n\tu32 i, item_count;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (ptr == NULL) return;\n\titem_count = gf_list_count(ptr->location_entries);\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\tiloc_entry_del(location);\n\t}\n\tgf_list_del(ptr->location_entries);\n\tgf_free(ptr);\n}\n\nGF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 item_count, extent_count, i, j;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2)\n\tptr->offset_size = gf_bs_read_int(bs, 4);\n\tptr->length_size = gf_bs_read_int(bs, 4);\n\tptr->base_offset_size = gf_bs_read_int(bs, 4);\n\tif (ptr->version == 1 || ptr->version == 2) {\n\t\tptr->index_size = gf_bs_read_int(bs, 4);\n\t} else {\n\t\tgf_bs_read_int(bs, 4);\n\t}\n\tif (ptr->version < 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\titem_count = gf_bs_read_u16(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\titem_count = gf_bs_read_u32(bs);\n\t}\n\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));\n\t\tif (!location_entry) return GF_OUT_OF_MEM;\n\n\t\tgf_list_add(ptr->location_entries, location_entry);\n\t\tif (ptr->version < 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u16(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u32(bs);\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->construction_method = gf_bs_read_u16(bs);\n\t\t}\n\t\telse {\n\t\t\tlocation_entry->construction_method = 0;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )\n\t\tlocation_entry->data_reference_index = gf_bs_read_u16(bs);\n\t\tlocation_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tlocation_entry->original_base_offset = location_entry->base_offset;\n#endif\n\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\textent_count = gf_bs_read_u16(bs);\n\t\tlocation_entry->extent_entries = gf_list_new();\n\t\tfor (j = 0; j < extent_count; j++) {\n\t\t\tGF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));\n\t\t\tif (!extent_entry) return GF_OUT_OF_MEM;\n\t\t\t\n\t\t\tgf_list_add(location_entry->extent_entries, extent_entry);\n\t\t\tif ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->index_size)\n\t\t\t\textent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\textent_entry->extent_index = 0;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )\n\n\t\t\textent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);\n\t\t\textent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\textent_entry->original_extent_offset = extent_entry->extent_offset;\n#endif\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iloc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, item_count, extent_count;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->offset_size, 4);\n\tgf_bs_write_int(bs, ptr->length_size, 4);\n\tgf_bs_write_int(bs, ptr->base_offset_size, 4);\n\tgf_bs_write_int(bs, ptr->index_size, 4);\n\titem_count = gf_list_count(ptr->location_entries);\n\tif (ptr->version < 2) {\n\t\tgf_bs_write_u16(bs, item_count);\n\t}\n\telse {\n\t\tgf_bs_write_u32(bs, item_count);\n\t}\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\tif (ptr->version < 2) {\n\t\t\tgf_bs_write_u16(bs, location->item_ID);\n\t\t}\n\t\telse {\n\t\t\tgf_bs_write_u32(bs, location->item_ID);\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tgf_bs_write_u16(bs, location->construction_method);\n\t\t}\n\t\tgf_bs_write_u16(bs, location->data_reference_index);\n\t\tgf_bs_write_long_int(bs, location->base_offset, 8*ptr->base_offset_size);\n\t\textent_count = gf_list_count(location->extent_entries);\n\t\tgf_bs_write_u16(bs, extent_count);\n\t\tfor (j=0; j<extent_count; j++) {\n\t\t\tGF_ItemExtentEntry *extent = (GF_ItemExtentEntry *)gf_list_get(location->extent_entries, j);\n\t\t\tif ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {\n\t\t\t\tgf_bs_write_long_int(bs, extent->extent_index, 8 * ptr->index_size);\n\t\t\t}\n\t\t\tgf_bs_write_long_int(bs, extent->extent_offset, 8*ptr->offset_size);\n\t\t\tgf_bs_write_long_int(bs, extent->extent_length, 8*ptr->length_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err iloc_box_size(GF_Box *s)\n{\n\tu32 i, item_count, extent_count;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->index_size) {\n\t\tptr->version = 1;\n\t}\n\titem_count = gf_list_count(ptr->location_entries);\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\tif (location->construction_method) {\n\t\t\tptr->version = 1;\n\t\t}\n\t\tif (location->item_ID > 0xFFFF) {\n\t\t\tptr->version = 2;\n\t\t}\n\t}\n\tptr->size += 4;\n\tif (ptr->version == 2) {\n\t\tptr->size += 2; // 32 bits item count instead of 16 bits\n\t}\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\textent_count = gf_list_count(location->extent_entries);\n\t\tptr->size += 6 + ptr->base_offset_size + extent_count*(ptr->offset_size + ptr->length_size);\n\t\tif (ptr->version == 2) {\n\t\t\tptr->size += 2; //32 bits item ID instead of 16 bits\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tptr->size += 2; // construction_method\n\t\t\tptr->size += extent_count*ptr->index_size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pitm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PrimaryItemBox, GF_ISOM_BOX_TYPE_PITM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pitm_box_del(GF_Box *s)\n{\n\tGF_PrimaryItemBox *ptr = (GF_PrimaryItemBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err pitm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PrimaryItemBox *ptr = (GF_PrimaryItemBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 2)\n\tptr->item_ID = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pitm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PrimaryItemBox *ptr = (GF_PrimaryItemBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->item_ID);\n\treturn GF_OK;\n}\n\nGF_Err pitm_box_size(GF_Box *s)\n{\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 2;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *ipro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemProtectionBox, GF_ISOM_BOX_TYPE_IPRO);\n\ttmp->protection_information = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid ipro_box_del(GF_Box *s)\n{\n\tGF_ItemProtectionBox *ptr = (GF_ItemProtectionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->protection_information);\n\tgf_free(ptr);\n}\n\nGF_Err ipro_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_ItemProtectionBox *ptr = (GF_ItemProtectionBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_SINF) {\n\t\tBOX_FIELD_LIST_ASSIGN(protection_information)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err ipro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tISOM_DECREASE_SIZE(s, 2)\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ipro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 count;\n\tGF_Err e;\n\tGF_ItemProtectionBox *ptr = (GF_ItemProtectionBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = gf_list_count(ptr->protection_information);\n\tgf_bs_write_u16(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err ipro_box_size(GF_Box *s)\n{\n\tGF_ItemProtectionBox *ptr = (GF_ItemProtectionBox *)s;\n\tu32 pos=0;\n\tgf_isom_check_position_list(s, ptr->protection_information, &pos);\n\ts->size += 2;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *infe_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemInfoEntryBox, GF_ISOM_BOX_TYPE_INFE);\n\treturn (GF_Box *)tmp;\n}\n\nvoid infe_box_del(GF_Box *s)\n{\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->item_name) gf_free(ptr->item_name);\n\tif (ptr->full_path) gf_free(ptr->full_path);\n\tif (ptr->content_type) gf_free(ptr->content_type);\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tgf_free(ptr);\n}\n\nGF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_encoding) {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\t//we could throw an error but we silently accept this infe\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err infe_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 3) {\n\t\tgf_bs_write_u32(bs, ptr->item_ID);\n\t}\n\telse {\n\t\tgf_bs_write_u16(bs, ptr->item_ID);\n\t}\n\tgf_bs_write_u16(bs, ptr->item_protection_index);\n\tif (ptr->version >= 2) {\n\t\tgf_bs_write_u32(bs, ptr->item_type);\n\t}\n\tif (ptr->item_name) {\n\t\tlen = (u32) strlen(ptr->item_name)+1;\n\t\tgf_bs_write_data(bs, ptr->item_name, len);\n\t} else {\n\t\tgf_bs_write_byte(bs, 0, 1);\n\t}\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME || ptr->item_type == GF_META_ITEM_TYPE_URI) {\n\t\tif (ptr->content_type) {\n\t\t\tlen = (u32)strlen(ptr->content_type) + 1;\n\t\t\tgf_bs_write_data(bs, ptr->content_type, len);\n\t\t}\n\t\telse {\n\t\t\tgf_bs_write_byte(bs, 0, 1);\n\t\t}\n\t}\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME) {\n\t\tif (ptr->content_encoding) {\n\t\t\tlen = (u32)strlen(ptr->content_encoding) + 1;\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, len);\n\t\t}\n\t\telse {\n\t\t\tgf_bs_write_byte(bs, 0, 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err infe_box_size(GF_Box *s)\n{\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->item_type) {\n\t\tptr->version = 2;\n\t\tif (ptr->item_ID > 0xFFFF) {\n\t\t\tptr->version = 3;\n\t\t}\n\t}\n\telse {\n\t\tptr->version = 0;\n\t}\n\tptr->size += 4;\n\tif (ptr->version == 3) {\n\t\tptr->size += 2; // item_ID on 32 bits (+2 bytes)\n\t}\n\tif (ptr->version >= 2) {\n\t\tptr->size += 4; // item_type size\n\t}\n\tif (ptr->item_name) ptr->size += strlen(ptr->item_name)+1;\n\telse ptr->size += 1;\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME || ptr->item_type == GF_META_ITEM_TYPE_URI) {\n\t\tif (ptr->content_type) ptr->size += strlen(ptr->content_type) + 1;\n\t\telse ptr->size += 1;\n\t}\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME) {\n\t\tif (ptr->content_encoding) ptr->size += strlen(ptr->content_encoding) + 1;\n\t\telse ptr->size += 1;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *iinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemInfoBox, GF_ISOM_BOX_TYPE_IINF);\n\ttmp->item_infos = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid iinf_box_del(GF_Box *s)\n{\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->item_infos);\n\tgf_free(ptr);\n}\n\nGF_Err iinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_INFE) {\n\t\tBOX_FIELD_LIST_ASSIGN(item_infos)\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_OK;\n\t}\n}\n\nGF_Err iinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\n\tif (ptr->version == 0) {\n\t\tISOM_DECREASE_SIZE(s, 2)\n\t\tgf_bs_read_u16(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tgf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 count;\n\tGF_Err e;\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = gf_list_count(ptr->item_infos);\n\tif (ptr->version == 0)\n\t\tgf_bs_write_u16(bs, count);\n\telse\n\t\tgf_bs_write_u32(bs, count);\n\n\treturn GF_OK;\n}\n\nGF_Err iinf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += (ptr->version == 0) ? 2 : 4;\n\tgf_isom_check_position_list(s, ptr->item_infos, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err iref_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_ItemReferenceBox *ptr = (GF_ItemReferenceBox *)s;\n\tBOX_FIELD_LIST_ASSIGN(references)\n\treturn GF_OK;\n}\n\nvoid iref_box_del(GF_Box *s)\n{\n\tGF_ItemReferenceBox *ptr = (GF_ItemReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->references);\n\tgf_free(ptr);\n}\n\n\nGF_Err iref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\nGF_Box *iref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemReferenceBox, GF_ISOM_BOX_TYPE_IREF);\n\ttmp->references = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err iref_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_ItemReferenceBox *ptr = (GF_ItemReferenceBox *)s;\n\tgf_isom_check_position_list(s, ptr->references, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ireftype_box_del(GF_Box *s)\n{\n\tGF_ItemReferenceTypeBox *ptr = (GF_ItemReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->to_item_IDs) gf_free(ptr->to_item_IDs);\n\tgf_free(ptr);\n}\n\nGF_Err ireftype_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ItemReferenceTypeBox *ptr = (GF_ItemReferenceTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->from_item_id = gf_bs_read_u16(bs);\n\tptr->reference_count = gf_bs_read_u16(bs);\n\tif (ptr->size / 2 < ptr->reference_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->to_item_IDs = (u32 *)gf_malloc(ptr->reference_count * sizeof(u32));\n\tif (!ptr->to_item_IDs) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i < ptr->reference_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\tptr->to_item_IDs[i] = gf_bs_read_u16(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ireftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemReferenceTypeBox, GF_ISOM_BOX_TYPE_REFI);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ireftype_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ItemReferenceTypeBox *ptr = (GF_ItemReferenceTypeBox *)s;\n\tptr->type = ptr->reference_type;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFI;\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->from_item_id);\n\tgf_bs_write_u16(bs, ptr->reference_count);\n\tfor (i = 0; i < ptr->reference_count; i++) {\n\t\tgf_bs_write_u16(bs, ptr->to_item_IDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err ireftype_box_size(GF_Box *s)\n{\n\tGF_ItemReferenceTypeBox *ptr = (GF_ItemReferenceTypeBox *)s;\n\tptr->size += 4 + (ptr->reference_count * sizeof(u16));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n#endif /*GPAC_DISABLE_ISOM*/\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *          Authors: Cyril Concolato / Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Box *meta_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MetaBox, GF_ISOM_BOX_TYPE_META);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid meta_reset(GF_Box *s)\n{\n\tGF_MetaBox *ptr = (GF_MetaBox *)s;\n\tif (ptr == NULL) return;\n\n\t//destroy all boxes\n\tif (ptr->child_boxes) gf_isom_box_array_del(ptr->child_boxes);\n\tptr->child_boxes = NULL;\n\n\t//reset pointers (destroyed above)\n\tptr->handler = NULL;\n\tptr->primary_resource = NULL;\n\tptr->file_locations = NULL;\n\tptr->item_locations = NULL;\n\tptr->protections = NULL;\n\tptr->item_infos = NULL;\n\tptr->IPMP_control = NULL;\n\tptr->item_refs = NULL;\n\tptr->item_props = NULL;\n\tptr->groups_list = NULL;\n}\n\nvoid meta_box_del(GF_Box *s)\n{\n\tmeta_reset(s);\n\tgf_free(s);\n}\n\n\nGF_Err meta_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MetaBox *ptr = (GF_MetaBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tBOX_FIELD_ASSIGN(handler, GF_HandlerBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PITM:\n\t\tBOX_FIELD_ASSIGN(primary_resource, GF_PrimaryItemBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tBOX_FIELD_ASSIGN(file_locations, GF_DataInformationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_ILOC:\n\t\tBOX_FIELD_ASSIGN(item_locations, GF_ItemLocationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_IPRO:\n\t\tBOX_FIELD_ASSIGN(protections, GF_ItemProtectionBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_IINF:\n\t\tBOX_FIELD_ASSIGN(item_infos, GF_ItemInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_IREF:\n\t\tBOX_FIELD_ASSIGN(item_refs, GF_ItemReferenceBox);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_IPRP:\n\t\tBOX_FIELD_ASSIGN(item_props, GF_ItemPropertiesBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_GRPL:\n\t\tBOX_FIELD_ASSIGN(groups_list, GF_GroupListBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err meta_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 pos = gf_bs_get_position(bs);\n\tu64 size = s->size;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\t/*try to hack around QT files which don't use a full box for meta, rewind 4 bytes*/\n\tif (e && (pos>4) ) {\n\t\tgf_bs_seek(bs, pos-4);\n\t\tmeta_reset(s);\n\t\ts->size = size+4;\n\t\te = gf_isom_box_array_read(s, bs);\n\t}\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err meta_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err meta_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MetaBox *ptr = (GF_MetaBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->handler, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->primary_resource, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->file_locations, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->item_locations, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->protections, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->item_infos, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->item_refs, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->item_props, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups_list, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *xml_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_XMLBox, GF_ISOM_BOX_TYPE_XML);\n\treturn (GF_Box *)tmp;\n}\n\nvoid xml_box_del(GF_Box *s)\n{\n\tGF_XMLBox *ptr = (GF_XMLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->xml) gf_free(ptr->xml);\n\tgf_free(ptr);\n}\n\nGF_Err xml_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XMLBox *ptr = (GF_XMLBox *)s;\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->xml);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err xml_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_XMLBox *ptr = (GF_XMLBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->xml) gf_bs_write_data(bs, ptr->xml, (u32) strlen(ptr->xml));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err xml_box_size(GF_Box *s)\n{\n\tGF_XMLBox *ptr = (GF_XMLBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n    ptr->size += (ptr->xml ? strlen(ptr->xml) : 0) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *bxml_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BinaryXMLBox, GF_ISOM_BOX_TYPE_BXML);\n\treturn (GF_Box *)tmp;\n}\n\nvoid bxml_box_del(GF_Box *s)\n{\n\tGF_BinaryXMLBox *ptr = (GF_BinaryXMLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err bxml_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_BinaryXMLBox *ptr = (GF_BinaryXMLBox *)s;\n\n\tptr->data_length = (u32)(ptr->size);\n\tptr->data = (char*)gf_malloc(sizeof(char)*ptr->data_length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err bxml_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_BinaryXMLBox *ptr = (GF_BinaryXMLBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->data_length) gf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err bxml_box_size(GF_Box *s)\n{\n\tGF_BinaryXMLBox *ptr = (GF_BinaryXMLBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += ptr->data_length;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *iloc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemLocationBox, GF_ISOM_BOX_TYPE_ILOC);\n\ttmp->location_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid iloc_entry_del(GF_ItemLocationEntry *location)\n{\n\tu32 j, extent_count;\n\textent_count = gf_list_count(location->extent_entries);\n\tfor (j = 0; j < extent_count; j++) {\n\t\tGF_ItemExtentEntry *extent = (GF_ItemExtentEntry *)gf_list_get(location->extent_entries, j);\n\t\tgf_free(extent);\n\t}\n\tgf_list_del(location->extent_entries);\n\tgf_free(location);\n}\n\nvoid iloc_box_del(GF_Box *s)\n{\n\tu32 i, item_count;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (ptr == NULL) return;\n\titem_count = gf_list_count(ptr->location_entries);\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\tiloc_entry_del(location);\n\t}\n\tgf_list_del(ptr->location_entries);\n\tgf_free(ptr);\n}\n\nGF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 item_count, extent_count, i, j;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2)\n\tptr->offset_size = gf_bs_read_int(bs, 4);\n\tptr->length_size = gf_bs_read_int(bs, 4);\n\tptr->base_offset_size = gf_bs_read_int(bs, 4);\n\tif (ptr->version == 1 || ptr->version == 2) {\n\t\tptr->index_size = gf_bs_read_int(bs, 4);\n\t} else {\n\t\tgf_bs_read_int(bs, 4);\n\t}\n\tif (ptr->version < 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\titem_count = gf_bs_read_u16(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\titem_count = gf_bs_read_u32(bs);\n\t}\n\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location_entry;\n\t\tGF_SAFEALLOC(location_entry, GF_ItemLocationEntry);\n\t\tif (!location_entry) return GF_OUT_OF_MEM;\n\n\t\tgf_list_add(ptr->location_entries, location_entry);\n\t\tif (ptr->version < 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u16(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u32(bs);\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->construction_method = gf_bs_read_u16(bs);\n\t\t}\n\t\telse {\n\t\t\tlocation_entry->construction_method = 0;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )\n\t\tlocation_entry->data_reference_index = gf_bs_read_u16(bs);\n\t\tlocation_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tlocation_entry->original_base_offset = location_entry->base_offset;\n#endif\n\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\textent_count = gf_bs_read_u16(bs);\n\t\tlocation_entry->extent_entries = gf_list_new();\n\t\tfor (j = 0; j < extent_count; j++) {\n\t\t\tGF_ItemExtentEntry *extent_entry;\n\t\t\tGF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);\n\t\t\tif (!extent_entry) return GF_OUT_OF_MEM;\n\t\t\t\n\t\t\tgf_list_add(location_entry->extent_entries, extent_entry);\n\t\t\tif ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->index_size)\n\t\t\t\textent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\textent_entry->extent_index = 0;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )\n\n\t\t\textent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);\n\t\t\textent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\textent_entry->original_extent_offset = extent_entry->extent_offset;\n#endif\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iloc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, item_count, extent_count;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->offset_size, 4);\n\tgf_bs_write_int(bs, ptr->length_size, 4);\n\tgf_bs_write_int(bs, ptr->base_offset_size, 4);\n\tgf_bs_write_int(bs, ptr->index_size, 4);\n\titem_count = gf_list_count(ptr->location_entries);\n\tif (ptr->version < 2) {\n\t\tgf_bs_write_u16(bs, item_count);\n\t}\n\telse {\n\t\tgf_bs_write_u32(bs, item_count);\n\t}\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\tif (ptr->version < 2) {\n\t\t\tgf_bs_write_u16(bs, location->item_ID);\n\t\t}\n\t\telse {\n\t\t\tgf_bs_write_u32(bs, location->item_ID);\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tgf_bs_write_u16(bs, location->construction_method);\n\t\t}\n\t\tgf_bs_write_u16(bs, location->data_reference_index);\n\t\tgf_bs_write_long_int(bs, location->base_offset, 8*ptr->base_offset_size);\n\t\textent_count = gf_list_count(location->extent_entries);\n\t\tgf_bs_write_u16(bs, extent_count);\n\t\tfor (j=0; j<extent_count; j++) {\n\t\t\tGF_ItemExtentEntry *extent = (GF_ItemExtentEntry *)gf_list_get(location->extent_entries, j);\n\t\t\tif ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {\n\t\t\t\tgf_bs_write_long_int(bs, extent->extent_index, 8 * ptr->index_size);\n\t\t\t}\n\t\t\tgf_bs_write_long_int(bs, extent->extent_offset, 8*ptr->offset_size);\n\t\t\tgf_bs_write_long_int(bs, extent->extent_length, 8*ptr->length_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err iloc_box_size(GF_Box *s)\n{\n\tu32 i, item_count, extent_count;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->index_size) {\n\t\tptr->version = 1;\n\t}\n\titem_count = gf_list_count(ptr->location_entries);\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\tif (location->construction_method) {\n\t\t\tptr->version = 1;\n\t\t}\n\t\tif (location->item_ID > 0xFFFF) {\n\t\t\tptr->version = 2;\n\t\t}\n\t}\n\tptr->size += 4;\n\tif (ptr->version == 2) {\n\t\tptr->size += 2; // 32 bits item count instead of 16 bits\n\t}\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\textent_count = gf_list_count(location->extent_entries);\n\t\tptr->size += 6 + ptr->base_offset_size + extent_count*(ptr->offset_size + ptr->length_size);\n\t\tif (ptr->version == 2) {\n\t\t\tptr->size += 2; //32 bits item ID instead of 16 bits\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tptr->size += 2; // construction_method\n\t\t\tptr->size += extent_count*ptr->index_size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pitm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PrimaryItemBox, GF_ISOM_BOX_TYPE_PITM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pitm_box_del(GF_Box *s)\n{\n\tGF_PrimaryItemBox *ptr = (GF_PrimaryItemBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err pitm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PrimaryItemBox *ptr = (GF_PrimaryItemBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 2)\n\tptr->item_ID = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pitm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PrimaryItemBox *ptr = (GF_PrimaryItemBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->item_ID);\n\treturn GF_OK;\n}\n\nGF_Err pitm_box_size(GF_Box *s)\n{\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 2;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *ipro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemProtectionBox, GF_ISOM_BOX_TYPE_IPRO);\n\ttmp->protection_information = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid ipro_box_del(GF_Box *s)\n{\n\tGF_ItemProtectionBox *ptr = (GF_ItemProtectionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->protection_information);\n\tgf_free(ptr);\n}\n\nGF_Err ipro_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_ItemProtectionBox *ptr = (GF_ItemProtectionBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_SINF) {\n\t\tBOX_FIELD_LIST_ASSIGN(protection_information)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err ipro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tISOM_DECREASE_SIZE(s, 2)\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ipro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 count;\n\tGF_Err e;\n\tGF_ItemProtectionBox *ptr = (GF_ItemProtectionBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = gf_list_count(ptr->protection_information);\n\tgf_bs_write_u16(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err ipro_box_size(GF_Box *s)\n{\n\tGF_ItemProtectionBox *ptr = (GF_ItemProtectionBox *)s;\n\tu32 pos=0;\n\tgf_isom_check_position_list(s, ptr->protection_information, &pos);\n\ts->size += 2;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *infe_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemInfoEntryBox, GF_ISOM_BOX_TYPE_INFE);\n\treturn (GF_Box *)tmp;\n}\n\nvoid infe_box_del(GF_Box *s)\n{\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->item_name) gf_free(ptr->item_name);\n\tif (ptr->full_path) gf_free(ptr->full_path);\n\tif (ptr->content_type) gf_free(ptr->content_type);\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tgf_free(ptr);\n}\n\nGF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_encoding) {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\t//we could throw an error but we silently accept this infe\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err infe_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 3) {\n\t\tgf_bs_write_u32(bs, ptr->item_ID);\n\t}\n\telse {\n\t\tgf_bs_write_u16(bs, ptr->item_ID);\n\t}\n\tgf_bs_write_u16(bs, ptr->item_protection_index);\n\tif (ptr->version >= 2) {\n\t\tgf_bs_write_u32(bs, ptr->item_type);\n\t}\n\tif (ptr->item_name) {\n\t\tlen = (u32) strlen(ptr->item_name)+1;\n\t\tgf_bs_write_data(bs, ptr->item_name, len);\n\t} else {\n\t\tgf_bs_write_byte(bs, 0, 1);\n\t}\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME || ptr->item_type == GF_META_ITEM_TYPE_URI) {\n\t\tif (ptr->content_type) {\n\t\t\tlen = (u32)strlen(ptr->content_type) + 1;\n\t\t\tgf_bs_write_data(bs, ptr->content_type, len);\n\t\t}\n\t\telse {\n\t\t\tgf_bs_write_byte(bs, 0, 1);\n\t\t}\n\t}\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME) {\n\t\tif (ptr->content_encoding) {\n\t\t\tlen = (u32)strlen(ptr->content_encoding) + 1;\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, len);\n\t\t}\n\t\telse {\n\t\t\tgf_bs_write_byte(bs, 0, 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err infe_box_size(GF_Box *s)\n{\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->item_type) {\n\t\tptr->version = 2;\n\t\tif (ptr->item_ID > 0xFFFF) {\n\t\t\tptr->version = 3;\n\t\t}\n\t}\n\telse {\n\t\tptr->version = 0;\n\t}\n\tptr->size += 4;\n\tif (ptr->version == 3) {\n\t\tptr->size += 2; // item_ID on 32 bits (+2 bytes)\n\t}\n\tif (ptr->version >= 2) {\n\t\tptr->size += 4; // item_type size\n\t}\n\tif (ptr->item_name) ptr->size += strlen(ptr->item_name)+1;\n\telse ptr->size += 1;\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME || ptr->item_type == GF_META_ITEM_TYPE_URI) {\n\t\tif (ptr->content_type) ptr->size += strlen(ptr->content_type) + 1;\n\t\telse ptr->size += 1;\n\t}\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME) {\n\t\tif (ptr->content_encoding) ptr->size += strlen(ptr->content_encoding) + 1;\n\t\telse ptr->size += 1;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *iinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemInfoBox, GF_ISOM_BOX_TYPE_IINF);\n\ttmp->item_infos = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid iinf_box_del(GF_Box *s)\n{\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->item_infos);\n\tgf_free(ptr);\n}\n\nGF_Err iinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_INFE) {\n\t\tBOX_FIELD_LIST_ASSIGN(item_infos)\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_OK;\n\t}\n}\n\nGF_Err iinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\n\tif (ptr->version == 0) {\n\t\tISOM_DECREASE_SIZE(s, 2)\n\t\tgf_bs_read_u16(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tgf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 count;\n\tGF_Err e;\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = gf_list_count(ptr->item_infos);\n\tif (ptr->version == 0)\n\t\tgf_bs_write_u16(bs, count);\n\telse\n\t\tgf_bs_write_u32(bs, count);\n\n\treturn GF_OK;\n}\n\nGF_Err iinf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_ItemInfoBox *ptr = (GF_ItemInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += (ptr->version == 0) ? 2 : 4;\n\tgf_isom_check_position_list(s, ptr->item_infos, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err iref_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_ItemReferenceBox *ptr = (GF_ItemReferenceBox *)s;\n\tBOX_FIELD_LIST_ASSIGN(references)\n\treturn GF_OK;\n}\n\nvoid iref_box_del(GF_Box *s)\n{\n\tGF_ItemReferenceBox *ptr = (GF_ItemReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->references);\n\tgf_free(ptr);\n}\n\n\nGF_Err iref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\nGF_Box *iref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemReferenceBox, GF_ISOM_BOX_TYPE_IREF);\n\ttmp->references = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err iref_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_ItemReferenceBox *ptr = (GF_ItemReferenceBox *)s;\n\tgf_isom_check_position_list(s, ptr->references, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ireftype_box_del(GF_Box *s)\n{\n\tGF_ItemReferenceTypeBox *ptr = (GF_ItemReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->to_item_IDs) gf_free(ptr->to_item_IDs);\n\tgf_free(ptr);\n}\n\nGF_Err ireftype_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ItemReferenceTypeBox *ptr = (GF_ItemReferenceTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->from_item_id = gf_bs_read_u16(bs);\n\tptr->reference_count = gf_bs_read_u16(bs);\n\tif (ptr->size / 2 < ptr->reference_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->to_item_IDs = (u32 *)gf_malloc(ptr->reference_count * sizeof(u32));\n\tif (!ptr->to_item_IDs) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i < ptr->reference_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\tptr->to_item_IDs[i] = gf_bs_read_u16(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ireftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemReferenceTypeBox, GF_ISOM_BOX_TYPE_REFI);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ireftype_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ItemReferenceTypeBox *ptr = (GF_ItemReferenceTypeBox *)s;\n\tptr->type = ptr->reference_type;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFI;\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->from_item_id);\n\tgf_bs_write_u16(bs, ptr->reference_count);\n\tfor (i = 0; i < ptr->reference_count; i++) {\n\t\tgf_bs_write_u16(bs, ptr->to_item_IDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err ireftype_box_size(GF_Box *s)\n{\n\tGF_ItemReferenceTypeBox *ptr = (GF_ItemReferenceTypeBox *)s;\n\tptr->size += 4 + (ptr->reference_count * sizeof(u16));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n#endif /*GPAC_DISABLE_ISOM*/\n\n"], "filenames": ["src/isomedia/box_code_meta.c"], "buggy_code_start_loc": [285], "buggy_code_end_loc": [315], "fixing_code_start_loc": [285], "fixing_code_end_loc": [317], "type": "CWE-415", "message": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_list_del function in list.c, which allows attackers to cause a denial of service.", "other": {"cve": {"id": "CVE-2021-40573", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-13T19:15:08.267", "lastModified": "2022-01-14T16:37:25.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_list_del function in list.c, which allows attackers to cause a denial of service."}, {"lang": "es", "value": "El binario MP4Box en Gpac versi\u00f3n 1.0.1, presenta una vulnerabilidad de doble liberaci\u00f3n en la funci\u00f3n gf_list_del en el archivo list.c, que permite a atacantes causar una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/b03c9f252526bb42fbd1b87b9f5e339c3cf2390a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1891", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/b03c9f252526bb42fbd1b87b9f5e339c3cf2390a"}}