{"buggy_code": ["#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#include \"../../handler/settings.h\"\n#include \"../../handler/webget.h\"\n#include \"../../parser/config/proxy.h\"\n#include \"../../parser/infoparser.h\"\n#include \"../../parser/subparser.h\"\n#include \"../../script/script_quickjs.h\"\n#include \"../../utils/file_extra.h\"\n#include \"../../utils/logger.h\"\n#include \"../../utils/map_extra.h\"\n#include \"../../utils/network.h\"\n#include \"../../utils/regexp.h\"\n#include \"../../utils/urlencode.h\"\n#include \"nodemanip.h\"\n#include \"subexport.h\"\n\nextern Settings global;\n\nbool applyMatcher(const std::string &rule, std::string &real_rule, const Proxy &node);\n\nint explodeConf(const std::string &filepath, std::vector<Proxy> &nodes)\n{\n    return explodeConfContent(fileGet(filepath), nodes);\n}\n\nvoid copyNodes(std::vector<Proxy> &source, std::vector<Proxy> &dest)\n{\n    std::move(source.begin(), source.end(), std::back_inserter(dest));\n}\n\nint addNodes(std::string link, std::vector<Proxy> &allNodes, int groupID, parse_settings &parse_set)\n{\n    std::string &proxy = *parse_set.proxy, &subInfo = *parse_set.sub_info;\n    string_array &exclude_remarks = *parse_set.exclude_remarks;\n    string_array &include_remarks = *parse_set.include_remarks;\n    RegexMatchConfigs &stream_rules = *parse_set.stream_rules;\n    RegexMatchConfigs &time_rules = *parse_set.time_rules;\n    string_icase_map *request_headers = parse_set.request_header;\n    bool &authorized = parse_set.authorized;\n\n    ConfType linkType = ConfType::Unknow;\n    std::vector<Proxy> nodes;\n    Proxy node;\n    std::string strSub, extra_headers, custom_group;\n\n    // TODO: replace with startsWith if appropriate\n    link = replaceAllDistinct(link, \"\\\"\", \"\");\n\n    /// script:filepath,arg1,arg2,...\n    script_safe_runner(parse_set.js_runtime, parse_set.js_context, [&](qjs::Context &ctx)\n    {\n        if(startsWith(link, \"script:\")) /// process subscription with script\n        {\n            writeLog(0, \"Found script link. Start running...\", LOG_LEVEL_INFO);\n            string_array args = split(link.substr(7), \",\");\n            if(args.size() >= 1)\n            {\n                std::string script = fileGet(args[0], false);\n                try\n                {\n                    ctx.eval(script);\n                    args.erase(args.begin()); /// remove script path\n                    auto parse = (std::function<std::string(const std::string&, const string_array&)>) ctx.eval(\"parse\");\n                    switch(args.size())\n                    {\n                    case 0:\n                        link = parse(std::string(), string_array());\n                        break;\n                    case 1:\n                        link = parse(args[0], string_array());\n                        break;\n                    default:\n                        {\n                            std::string first = args[0];\n                            args.erase(args.begin());\n                            link = parse(first, args);\n                            break;\n                        }\n                    }\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }\n        }\n    }, global.scriptCleanContext);\n            /*\n            duk_context *ctx = duktape_init();\n            defer(duk_destroy_heap(ctx);)\n            duktape_peval(ctx, script);\n            duk_get_global_string(ctx, \"parse\");\n            for(size_t i = 1; i < args.size(); i++)\n                duk_push_string(ctx, trim(args[i]).c_str());\n            if(duk_pcall(ctx, args.size() - 1) == 0)\n                link = duktape_get_res_str(ctx);\n            else\n            {\n                writeLog(0, \"Error when trying to evaluate script:\\n\" + duktape_get_err_stack(ctx), LOG_LEVEL_ERROR);\n                duk_pop(ctx); /// pop err\n            }\n            */\n\n    /// tag:group_name,link\n    if(startsWith(link, \"tag:\"))\n    {\n        string_size pos = link.find(\",\");\n        if(pos != link.npos)\n        {\n            custom_group = link.substr(4, pos - 4);\n            link.erase(0, pos + 1);\n        }\n    }\n\n    if(link == \"nullnode\")\n    {\n        node.GroupId = 0;\n        writeLog(0, \"Adding node placeholder...\");\n        allNodes.emplace_back(std::move(node));\n        return 0;\n    }\n\n    writeLog(LOG_TYPE_INFO, \"Received Link.\");\n    if(startsWith(link, \"https://t.me/socks\") || startsWith(link, \"tg://socks\"))\n        linkType = ConfType::SOCKS;\n    else if(startsWith(link, \"https://t.me/http\") || startsWith(link, \"tg://http\"))\n        linkType = ConfType::HTTP;\n    else if(isLink(link) || startsWith(link, \"surge:///install-config\"))\n        linkType = ConfType::SUB;\n    else if(startsWith(link, \"Netch://\"))\n        linkType = ConfType::Netch;\n    else if(fileExist(link))\n        linkType = ConfType::Local;\n\n    switch(linkType)\n    {\n    case ConfType::SUB:\n        writeLog(LOG_TYPE_INFO, \"Downloading subscription data...\");\n        if(startsWith(link, \"surge:///install-config\")) //surge config link\n            link = urlDecode(getUrlArg(link, \"url\"));\n        strSub = webGet(link, proxy, global.cacheSubscription, &extra_headers, request_headers);\n        /*\n        if(strSub.size() == 0)\n        {\n            //try to get it again with system proxy\n            writeLog(LOG_TYPE_WARN, \"Cannot download subscription directly. Using system proxy.\");\n            strProxy = getSystemProxy();\n            if(strProxy != \"\")\n            {\n                strSub = webGet(link, strProxy);\n            }\n            else\n                writeLog(LOG_TYPE_WARN, \"No system proxy is set. Skipping.\");\n        }\n        */\n        if(strSub.size())\n        {\n            writeLog(LOG_TYPE_INFO, \"Parsing subscription data...\");\n            if(explodeConfContent(strSub, nodes) == 0)\n            {\n                writeLog(LOG_TYPE_ERROR, \"Invalid subscription: '\" + link + \"'!\");\n                return -1;\n            }\n            if(startsWith(strSub, \"ssd://\"))\n            {\n                getSubInfoFromSSD(strSub, subInfo);\n            }\n            else\n            {\n                if(!getSubInfoFromHeader(extra_headers, subInfo))\n                    getSubInfoFromNodes(nodes, stream_rules, time_rules, subInfo);\n            }\n            filterNodes(nodes, exclude_remarks, include_remarks, groupID);\n            for(Proxy &x : nodes)\n            {\n                x.GroupId = groupID;\n                if(custom_group.size())\n                    x.Group = custom_group;\n            }\n            copyNodes(nodes, allNodes);\n        }\n        else\n        {\n            writeLog(LOG_TYPE_ERROR, \"Cannot download subscription data.\");\n            return -1;\n        }\n        break;\n    case ConfType::Local:\n        if(!authorized)\n            return -1;\n        writeLog(LOG_TYPE_INFO, \"Parsing configuration file data...\");\n        if(explodeConf(link, nodes) == 0)\n        {\n            writeLog(LOG_TYPE_ERROR, \"Invalid configuration file!\");\n            return -1;\n        }\n        if(startsWith(strSub, \"ssd://\"))\n        {\n            getSubInfoFromSSD(strSub, subInfo);\n        }\n        else\n        {\n            getSubInfoFromNodes(nodes, stream_rules, time_rules, subInfo);\n        }\n        filterNodes(nodes, exclude_remarks, include_remarks, groupID);\n        for(Proxy &x : nodes)\n        {\n            x.GroupId = groupID;\n            if(custom_group.size())\n                x.Group = custom_group;\n        }\n        copyNodes(nodes, allNodes);\n        break;\n    default:\n        explode(link, node);\n        if(node.Type == -1)\n        {\n            writeLog(LOG_TYPE_ERROR, \"No valid link found.\");\n            return -1;\n        }\n        node.GroupId = groupID;\n        if(custom_group.size())\n            node.Group = custom_group;\n        allNodes.emplace_back(std::move(node));\n    }\n    return 0;\n}\n\nbool chkIgnore(const Proxy &node, string_array &exclude_remarks, string_array &include_remarks)\n{\n    bool excluded = false, included = false;\n    //std::string remarks = UTF8ToACP(node.remarks);\n    //std::string remarks = node.remarks;\n    //writeLog(LOG_TYPE_INFO, \"Comparing exclude remarks...\");\n    excluded = std::any_of(exclude_remarks.cbegin(), exclude_remarks.cend(), [&node](const auto &x)\n    {\n        std::string real_rule;\n        if(applyMatcher(x, real_rule, node))\n        {\n            if(real_rule.empty()) return true;\n            return regFind(node.Remark, real_rule);\n        }\n        else\n            return false;\n    });\n    if(include_remarks.size() != 0)\n    {\n        //writeLog(LOG_TYPE_INFO, \"Comparing include remarks...\");\n        included = std::any_of(include_remarks.cbegin(), include_remarks.cend(), [&node](const auto &x)\n        {\n            std::string real_rule;\n            if(applyMatcher(x, real_rule, node))\n            {\n                if(real_rule.empty()) return true;\n                return regFind(node.Remark, real_rule);\n            }\n            else\n                return false;\n        });\n    }\n    else\n    {\n        included = true;\n    }\n\n    return excluded || !included;\n}\n\nvoid filterNodes(std::vector<Proxy> &nodes, string_array &exclude_remarks, string_array &include_remarks, int groupID)\n{\n    int node_index = 0;\n    std::vector<Proxy>::iterator iter = nodes.begin();\n    while(iter != nodes.end())\n    {\n        if(chkIgnore(*iter, exclude_remarks, include_remarks))\n        {\n            writeLog(LOG_TYPE_INFO, \"Node  \" + iter->Group + \" - \" + iter->Remark + \"  has been ignored and will not be added.\");\n            nodes.erase(iter);\n        }\n        else\n        {\n            writeLog(LOG_TYPE_INFO, \"Node  \" + iter->Group + \" - \" + iter->Remark + \"  has been added.\");\n            iter->Id = node_index;\n            iter->GroupId = groupID;\n            ++node_index;\n            ++iter;\n        }\n    }\n    /*\n    std::vector<std::unique_ptr<pcre2_code, decltype(&pcre2_code_free)>> exclude_patterns, include_patterns;\n    std::vector<std::unique_ptr<pcre2_match_data, decltype(&pcre2_match_data_free)>> exclude_match_data, include_match_data;\n    unsigned int i = 0;\n    PCRE2_SIZE erroroffset;\n    int errornumber, rc;\n\n    for(i = 0; i < exclude_remarks.size(); i++)\n    {\n        std::unique_ptr<pcre2_code, decltype(&pcre2_code_free)> pattern(pcre2_compile(reinterpret_cast<const unsigned char*>(exclude_remarks[i].c_str()), exclude_remarks[i].size(), PCRE2_UTF | PCRE2_MULTILINE | PCRE2_ALT_BSUX, &errornumber, &erroroffset, NULL), &pcre2_code_free);\n        if(!pattern)\n            return;\n        exclude_patterns.emplace_back(std::move(pattern));\n        pcre2_jit_compile(exclude_patterns[i].get(), 0);\n        std::unique_ptr<pcre2_match_data, decltype(&pcre2_match_data_free)> match_data(pcre2_match_data_create_from_pattern(exclude_patterns[i].get(), NULL), &pcre2_match_data_free);\n        exclude_match_data.emplace_back(std::move(match_data));\n    }\n    for(i = 0; i < include_remarks.size(); i++)\n    {\n        std::unique_ptr<pcre2_code, decltype(&pcre2_code_free)> pattern(pcre2_compile(reinterpret_cast<const unsigned char*>(include_remarks[i].c_str()), include_remarks[i].size(), PCRE2_UTF | PCRE2_MULTILINE | PCRE2_ALT_BSUX, &errornumber, &erroroffset, NULL), &pcre2_code_free);\n        if(!pattern)\n            return;\n        include_patterns.emplace_back(std::move(pattern));\n        pcre2_jit_compile(include_patterns[i].get(), 0);\n        std::unique_ptr<pcre2_match_data, decltype(&pcre2_match_data_free)> match_data(pcre2_match_data_create_from_pattern(include_patterns[i].get(), NULL), &pcre2_match_data_free);\n        include_match_data.emplace_back(std::move(match_data));\n    }\n    writeLog(LOG_TYPE_INFO, \"Filter started.\");\n    while(iter != nodes.end())\n    {\n        bool excluded = false, included = false;\n        for(i = 0; i < exclude_patterns.size(); i++)\n        {\n            rc = pcre2_match(exclude_patterns[i].get(), reinterpret_cast<const unsigned char*>(iter->remarks.c_str()), iter->remarks.size(), 0, 0, exclude_match_data[i].get(), NULL);\n            if (rc < 0)\n            {\n                switch(rc)\n                {\n                case PCRE2_ERROR_NOMATCH:\n                    break;\n                default:\n                    return;\n                }\n            }\n            else\n                excluded = true;\n        }\n        if(include_patterns.size() > 0)\n            for(i = 0; i < include_patterns.size(); i++)\n            {\n                rc = pcre2_match(include_patterns[i].get(), reinterpret_cast<const unsigned char*>(iter->remarks.c_str()), iter->remarks.size(), 0, 0, include_match_data[i].get(), NULL);\n                if (rc < 0)\n                {\n                    switch(rc)\n                    {\n                    case PCRE2_ERROR_NOMATCH:\n                        break;\n                    default:\n                        return;\n                    }\n                }\n                else\n                    included = true;\n            }\n        else\n            included = true;\n        if(excluded || !included)\n        {\n            writeLog(LOG_TYPE_INFO, \"Node  \" + iter->group + \" - \" + iter->remarks + \"  has been ignored and will not be added.\");\n            nodes.erase(iter);\n        }\n        else\n        {\n            writeLog(LOG_TYPE_INFO, \"Node  \" + iter->group + \" - \" + iter->remarks + \"  has been added.\");\n            iter->id = node_index;\n            iter->groupID = groupID;\n            ++node_index;\n            ++iter;\n        }\n    }\n    */\n    writeLog(LOG_TYPE_INFO, \"Filter done.\");\n}\n\nvoid nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settings &ext)\n{\n    std::string &remark = node.Remark, original_remark = node.Remark, returned_remark, real_rule;\n\n    for(const RegexMatchConfig &x : rename_array)\n    {\n        if(!x.Script.empty())\n        {\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto rename = (std::function<std::string(const Proxy&)>) ctx.eval(\"rename\");\n                    returned_remark = rename(node);\n                    if(!returned_remark.empty())\n                        remark = returned_remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            continue;\n        }\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size())\n            remark = regReplace(remark, real_rule, x.Replace);\n    }\n    if(remark.empty())\n        remark = original_remark;\n    return;\n}\n\nstd::string removeEmoji(const std::string &orig_remark)\n{\n    char emoji_id[2] = {(char)-16, (char)-97};\n    std::string remark = orig_remark;\n    while(true)\n    {\n        if(remark[0] == emoji_id[0] && remark[1] == emoji_id[1])\n            remark.erase(0, 4);\n        else\n            break;\n    }\n    if(remark.empty())\n        return orig_remark;\n    return remark;\n}\n\nstd::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, extra_settings &ext)\n{\n    std::string real_rule, ret;\n\n    for(const RegexMatchConfig &x : emoji_array)\n    {\n        if(!x.Script.empty())\n        {\n            std::string result;\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto getEmoji = (std::function<std::string(const Proxy&)>) ctx.eval(\"getEmoji\");\n                    ret = getEmoji(node);\n                    if(!ret.empty())\n                        result = ret + \" \" + node.Remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            if(!result.empty())\n                return result;\n            continue;\n        }\n        if(x.Replace.empty())\n            continue;\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size() && regFind(node.Remark, real_rule))\n            return x.Replace + \" \" + node.Remark;\n    }\n    return node.Remark;\n}\n\nvoid preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x)\n    {\n        if(ext.remove_emoji)\n            x.Remark = trim(removeEmoji(x.Remark));\n\n        nodeRename(x, ext.rename_array, ext);\n\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size())\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");\n                    auto comparer = [&](const Proxy &a, const Proxy &b)\n                    {\n                        if(a.Type == ProxyType::Unknow)\n                            return 1;\n                        if(b.Type == ProxyType::Unknow)\n                            return 0;\n                        return compare(a, b);\n                    };\n                    std::stable_sort(nodes.begin(), nodes.end(), comparer);\n                    failed = false;\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n        }\n        if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)\n        {\n            return a.Remark < b.Remark;\n        });\n    }\n}\n", "#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <cmath>\n#include <climits>\n\n#include \"../../config/regmatch.h\"\n#include \"../../generator/config/subexport.h\"\n#include \"../../generator/template/templates.h\"\n#include \"../../handler/settings.h\"\n#include \"../../parser/config/proxy.h\"\n#include \"../../script/script_quickjs.h\"\n#include \"../../utils/bitwise.h\"\n#include \"../../utils/file_extra.h\"\n#include \"../../utils/ini_reader/ini_reader.h\"\n#include \"../../utils/logger.h\"\n#include \"../../utils/network.h\"\n#include \"../../utils/rapidjson_extra.h\"\n#include \"../../utils/regexp.h\"\n#include \"../../utils/stl_extra.h\"\n#include \"../../utils/urlencode.h\"\n#include \"../../utils/yamlcpp_extra.h\"\n#include \"nodemanip.h\"\n#include \"ruleconvert.h\"\n\nextern string_array ss_ciphers, ssr_ciphers;\n\nconst string_array clashr_protocols = {\"origin\", \"auth_sha1_v4\", \"auth_aes128_md5\", \"auth_aes128_sha1\", \"auth_chain_a\", \"auth_chain_b\"};\nconst string_array clashr_obfs = {\"plain\", \"http_simple\", \"http_post\", \"random_head\", \"tls1.2_ticket_auth\", \"tls1.2_ticket_fastauth\"};\nconst string_array clash_ssr_ciphers = {\"rc4-md5\", \"aes-128-ctr\", \"aes-192-ctr\", \"aes-256-ctr\", \"aes-128-cfb\", \"aes-192-cfb\", \"aes-256-cfb\", \"chacha20-ietf\", \"xchacha20\", \"none\"};\n\nstd::string vmessLinkConstruct(const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &path, const std::string &host, const std::string &tls)\n{\n    rapidjson::StringBuffer sb;\n    rapidjson::Writer<rapidjson::StringBuffer> writer(sb);\n    writer.StartObject();\n    writer.Key(\"v\");\n    writer.String(\"2\");\n    writer.Key(\"ps\");\n    writer.String(remarks.data());\n    writer.Key(\"add\");\n    writer.String(add.data());\n    writer.Key(\"port\");\n    writer.String(port.data());\n    writer.Key(\"type\");\n    writer.String(type.empty() ? \"none\" : type.data());\n    writer.Key(\"id\");\n    writer.String(id.data());\n    writer.Key(\"aid\");\n    writer.String(aid.data());\n    writer.Key(\"net\");\n    writer.String(net.empty() ? \"tcp\" : net.data());\n    writer.Key(\"path\");\n    writer.String(path.data());\n    writer.Key(\"host\");\n    writer.String(host.data());\n    writer.Key(\"tls\");\n    writer.String(tls.data());\n    writer.EndObject();\n    return sb.GetString();\n}\n\nbool matchRange(const std::string &range, int target)\n{\n    string_array vArray = split(range, \",\");\n    bool match = false;\n    std::string range_begin_str, range_end_str;\n    int range_begin, range_end;\n    static const std::string reg_num = \"-?\\\\d+\", reg_range = \"(\\\\d+)-(\\\\d+)\", reg_not = \"\\\\!-?(\\\\d+)\", reg_not_range = \"\\\\!(\\\\d+)-(\\\\d+)\", reg_less = \"(\\\\d+)-\", reg_more = \"(\\\\d+)\\\\+\";\n    for(std::string &x : vArray)\n    {\n        if(regMatch(x, reg_num))\n        {\n            if(to_int(x, INT_MAX) == target)\n                match = true;\n        }\n        else if(regMatch(x, reg_range))\n        {\n            regGetMatch(x, reg_range, 3, 0, &range_begin_str, &range_end_str);\n            range_begin = to_int(range_begin_str, INT_MAX);\n            range_end = to_int(range_end_str, INT_MIN);\n            if(target >= range_begin && target <= range_end)\n                match = true;\n        }\n        else if(regMatch(x, reg_not))\n        {\n            match = true;\n            if(to_int(regReplace(x, reg_not, \"$1\"), INT_MAX) == target)\n                match = false;\n        }\n        else if(regMatch(x, reg_not_range))\n        {\n            match = true;\n            regGetMatch(x, reg_range, 3, 0, &range_begin_str, &range_end_str);\n            range_begin = to_int(range_begin_str, INT_MAX);\n            range_end = to_int(range_end_str, INT_MIN);\n            if(target >= range_begin && target <= range_end)\n                match = false;\n        }\n        else if(regMatch(x, reg_less))\n        {\n            if(to_int(regReplace(x, reg_less, \"$1\"), INT_MAX) >= target)\n                match = true;\n        }\n        else if(regMatch(x, reg_more))\n        {\n            if(to_int(regReplace(x, reg_more, \"$1\"), INT_MIN) <= target)\n                match = true;\n        }\n    }\n    return match;\n}\n\nbool applyMatcher(const std::string &rule, std::string &real_rule, const Proxy &node)\n{\n    std::string target, ret_real_rule;\n    static const std::string groupid_regex = R\"(^!!(?:GROUPID|INSERT)=([\\d\\-+!,]+)(?:!!(.*))?$)\", group_regex = R\"(^!!(?:GROUP)=(.+?)(?:!!(.*))?$)\";\n    static const std::string type_regex = R\"(^!!(?:TYPE)=(.+?)(?:!!(.*))?$)\", port_regex = R\"(^!!(?:PORT)=(.+?)(?:!!(.*))?$)\", server_regex = R\"(^!!(?:SERVER)=(.+?)(?:!!(.*))?$)\";\n    static const string_array types = {\"\", \"SS\", \"SSR\", \"VMESS\", \"TROJAN\", \"SNELL\", \"HTTP\", \"HTTPS\", \"SOCKS5\"};\n    if(startsWith(rule, \"!!GROUP=\"))\n    {\n        regGetMatch(rule, group_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        return regFind(node.Group, target);\n    }\n    else if(startsWith(rule, \"!!GROUPID=\") || startsWith(rule, \"!!INSERT=\"))\n    {\n        int dir = startsWith(rule, \"!!INSERT=\") ? -1 : 1;\n        regGetMatch(rule, groupid_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        return matchRange(target, dir * node.GroupId);\n    }\n    else if(startsWith(rule, \"!!TYPE=\"))\n    {\n        regGetMatch(rule, type_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        if(node.Type == ProxyType::Unknow)\n            return false;\n        return regMatch(types[node.Type], target);\n    }\n    else if(startsWith(rule, \"!!PORT=\"))\n    {\n        regGetMatch(rule, port_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        return matchRange(target, node.Port);\n    }\n    else if(startsWith(rule, \"!!SERVER=\"))\n    {\n        regGetMatch(rule, server_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        return regFind(node.Hostname, target);\n    }\n    else\n        real_rule = rule;\n    return true;\n}\n\nvoid processRemark(std::string &oldremark, std::string &newremark, string_array &remarks_list, bool proc_comma = true)\n{\n    if(proc_comma)\n    {\n        if(oldremark.find(',') != oldremark.npos)\n        {\n            oldremark.insert(0, \"\\\"\");\n            oldremark.append(\"\\\"\");\n        }\n    }\n    newremark = oldremark;\n    int cnt = 2;\n    while(std::find(remarks_list.begin(), remarks_list.end(), newremark) != remarks_list.end())\n    {\n        newremark = oldremark + \" \" + std::to_string(cnt);\n        cnt++;\n    }\n    oldremark = newremark;\n}\n\nvoid groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)\n{\n    std::string real_rule;\n    if(startsWith(rule, \"[]\") && add_direct)\n    {\n        filtered_nodelist.emplace_back(rule.substr(2));\n    }\n#ifndef NO_JS_RUNTIME\n    else if(startsWith(rule, \"script:\"))\n    {\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){\n            std::string script = fileGet(rule.substr(7), true);\n            try\n            {\n                ctx.eval(script);\n                auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(\"filter\");\n                std::string result_list = filter(nodelist);\n                filtered_nodelist = split(regTrim(result_list), \"\\n\");\n            }\n            catch (qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n#endif // NO_JS_RUNTIME\n    else\n    {\n        for(Proxy &x : nodelist)\n        {\n            if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())\n                filtered_nodelist.emplace_back(x.Remark);\n        }\n    }\n}\n\nvoid proxyToClash(std::vector<Proxy> &nodes, YAML::Node &yamlnode, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext)\n{\n    YAML::Node proxies, singleproxy, singlegroup, original_groups;\n    std::vector<Proxy> nodelist;\n    string_array remarks_list, filtered_nodelist;\n    /// proxies style\n    bool block = false, compact = false;\n    switch(hash_(ext.clash_proxies_style))\n    {\n    case \"block\"_hash:\n        block = true;\n        break;\n    default:\n    case \"flow\"_hash:\n        break;\n    case \"compact\"_hash:\n        compact = true;\n        break;\n    }\n\n    for(Proxy &x : nodes)\n    {\n        singleproxy.reset();\n\n        std::string type = getProxyTypeName(x.Type);\n        std::string remark, pluginopts = replaceAllDistinct(x.PluginOption, \";\", \"&\");\n        if(ext.append_proxy_type)\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n\n        processRemark(x.Remark, remark, remarks_list, false);\n\n        tribool udp = ext.udp;\n        tribool scv = ext.skip_cert_verify;\n        udp.define(x.UDP);\n        scv.define(x.AllowInsecure);\n\n        singleproxy[\"name\"] = remark;\n        singleproxy[\"server\"] = x.Hostname;\n        singleproxy[\"port\"] = x.Port;\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            //latest clash core removed support for chacha20 encryption\n            if(ext.filter_deprecated && x.EncryptMethod == \"chacha20\")\n                continue;\n            singleproxy[\"type\"] = \"ss\";\n            singleproxy[\"cipher\"] = x.EncryptMethod;\n            singleproxy[\"password\"] = x.Password;\n            if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())\n                singleproxy[\"password\"].SetTag(\"str\");\n            switch(hash_(x.Plugin))\n            {\n            case \"simple-obfs\"_hash:\n            case \"obfs-local\"_hash:\n                singleproxy[\"plugin\"] = \"obfs\";\n                singleproxy[\"plugin-opts\"][\"mode\"] = urlDecode(getUrlArg(pluginopts, \"obfs\"));\n                singleproxy[\"plugin-opts\"][\"host\"] = urlDecode(getUrlArg(pluginopts, \"obfs-host\"));\n                break;\n            case \"v2ray-plugin\"_hash:\n                singleproxy[\"plugin\"] = \"v2ray-plugin\";\n                singleproxy[\"plugin-opts\"][\"mode\"] = getUrlArg(pluginopts, \"mode\");\n                singleproxy[\"plugin-opts\"][\"host\"] = getUrlArg(pluginopts, \"host\");\n                singleproxy[\"plugin-opts\"][\"path\"] = getUrlArg(pluginopts, \"path\");\n                singleproxy[\"plugin-opts\"][\"tls\"] = pluginopts.find(\"tls\") != std::string::npos;\n                singleproxy[\"plugin-opts\"][\"mux\"] = pluginopts.find(\"mux\") != std::string::npos;\n                if(!scv.is_undef())\n                    singleproxy[\"plugin-opts\"][\"skip-cert-verify\"] = scv.get();\n                break;\n            }\n            break;\n        case ProxyType::VMess:\n            singleproxy[\"type\"] = \"vmess\";\n            singleproxy[\"uuid\"] = x.UserId;\n            singleproxy[\"alterId\"] = x.AlterId;\n            singleproxy[\"cipher\"] = x.EncryptMethod;\n            singleproxy[\"tls\"] = x.TLSSecure;\n            if(!scv.is_undef())\n                singleproxy[\"skip-cert-verify\"] = scv.get();\n            if(!x.ServerName.empty())\n                singleproxy[\"servername\"] = x.ServerName;\n            switch(hash_(x.TransferProtocol))\n            {\n            case \"tcp\"_hash:\n                break;\n            case \"ws\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                if(ext.clash_new_field_name)\n                {\n                    singleproxy[\"ws-opts\"][\"path\"] = x.Path;\n                    if(!x.Host.empty())\n                        singleproxy[\"ws-opts\"][\"headers\"][\"Host\"] = x.Host;\n                    if(!x.Edge.empty())\n                        singleproxy[\"ws-opts\"][\"headers\"][\"Edge\"] = x.Edge;\n                }\n                else\n                {\n                    singleproxy[\"ws-path\"] = x.Path;\n                    if(!x.Host.empty())\n                        singleproxy[\"ws-headers\"][\"Host\"] = x.Host;\n                    if(!x.Edge.empty())\n                        singleproxy[\"ws-headers\"][\"Edge\"] = x.Edge;\n                }\n                break;\n            case \"http\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                singleproxy[\"http-opts\"][\"method\"] = \"GET\";\n                singleproxy[\"http-opts\"][\"path\"].push_back(x.Path);\n                if(!x.Host.empty())\n                    singleproxy[\"http-opts\"][\"headers\"][\"Host\"].push_back(x.Host);\n                if(!x.Edge.empty())\n                    singleproxy[\"http-opts\"][\"headers\"][\"Edge\"].push_back(x.Edge);\n                break;\n            case \"h2\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                singleproxy[\"h2-opts\"][\"path\"] = x.Path;\n                if(!x.Host.empty())\n                    singleproxy[\"h2-opts\"][\"host\"].push_back(x.Host);\n                break;\n            case \"grpc\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                singleproxy[\"servername\"] = x.Host;\n                singleproxy[\"grpc-opts\"][\"grpc-service-name\"] = x.Path;\n                break;\n            default:\n                continue;\n            }\n            break;\n        case ProxyType::ShadowsocksR:\n            //ignoring all nodes with unsupported obfs, protocols and encryption\n            if(ext.filter_deprecated)\n            {\n                if(!clashR && std::find(clash_ssr_ciphers.cbegin(), clash_ssr_ciphers.cend(), x.EncryptMethod) == clash_ssr_ciphers.cend())\n                    continue;\n                if(std::find(clashr_protocols.cbegin(), clashr_protocols.cend(), x.Protocol) == clashr_protocols.cend())\n                    continue;\n                if(std::find(clashr_obfs.cbegin(), clashr_obfs.cend(), x.OBFS) == clashr_obfs.cend())\n                    continue;\n            }\n\n            singleproxy[\"type\"] = \"ssr\";\n            singleproxy[\"cipher\"] = x.EncryptMethod == \"none\" ? \"dummy\" : x.EncryptMethod;\n            singleproxy[\"password\"] = x.Password;\n            if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())\n                singleproxy[\"password\"].SetTag(\"str\");\n            singleproxy[\"protocol\"] = x.Protocol;\n            singleproxy[\"obfs\"] = x.OBFS;\n            if(clashR)\n            {\n                singleproxy[\"protocolparam\"] = x.ProtocolParam;\n                singleproxy[\"obfsparam\"] = x.OBFSParam;\n            }\n            else\n            {\n                singleproxy[\"protocol-param\"] = x.ProtocolParam;\n                singleproxy[\"obfs-param\"] = x.OBFSParam;\n            }\n            break;\n        case ProxyType::SOCKS5:\n            singleproxy[\"type\"] = \"socks5\";\n            if(!x.Username.empty())\n                singleproxy[\"username\"] = x.Username;\n            if(!x.Password.empty())\n            {\n                singleproxy[\"password\"] = x.Password;\n                if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit))\n                    singleproxy[\"password\"].SetTag(\"str\");\n            }\n            if(!scv.is_undef())\n                singleproxy[\"skip-cert-verify\"] = scv.get();\n            break;\n        case ProxyType::HTTP:\n        case ProxyType::HTTPS:\n            singleproxy[\"type\"] = \"http\";\n            if(!x.Username.empty())\n                singleproxy[\"username\"] = x.Username;\n            if(!x.Password.empty())\n            {\n                singleproxy[\"password\"] = x.Password;\n                if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit))\n                    singleproxy[\"password\"].SetTag(\"str\");\n            }\n            singleproxy[\"tls\"] = x.TLSSecure;\n            if(!scv.is_undef())\n                singleproxy[\"skip-cert-verify\"] = scv.get();\n            break;\n        case ProxyType::Trojan:\n            singleproxy[\"type\"] = \"trojan\";\n            singleproxy[\"password\"] = x.Password;\n            if(!x.Host.empty())\n                singleproxy[\"sni\"] = x.Host;\n            if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())\n                singleproxy[\"password\"].SetTag(\"str\");\n            if(!scv.is_undef())\n                singleproxy[\"skip-cert-verify\"] = scv.get();\n            switch(hash_(x.TransferProtocol))\n            {\n            case \"tcp\"_hash:\n                break;\n            case \"grpc\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                if(!x.Path.empty())\n                    singleproxy[\"grpc-opts\"][\"grpc-service-name\"] = x.Path;\n                break;\n            case \"ws\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                singleproxy[\"ws-opts\"][\"path\"] = x.Path;\n                if(!x.Host.empty())\n                    singleproxy[\"ws-opts\"][\"headers\"][\"Host\"] = x.Host;\n                break;\n            }\n            break;\n        case ProxyType::Snell:\n            singleproxy[\"type\"] = \"snell\";\n            singleproxy[\"psk\"] = x.Password;\n            if(x.SnellVersion != 0)\n                singleproxy[\"version\"] = x.SnellVersion;\n            if(!x.OBFS.empty())\n            {\n                singleproxy[\"obfs-opts\"][\"mode\"] = x.OBFS;\n                if(!x.Host.empty())\n                    singleproxy[\"obfs-opts\"][\"host\"] = x.Host;\n            }\n            if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())\n                singleproxy[\"password\"].SetTag(\"str\");\n            break;\n        default:\n            continue;\n        }\n\n        if(udp)\n            singleproxy[\"udp\"] = true;\n        if(block)\n            singleproxy.SetStyle(YAML::EmitterStyle::Block);\n        else\n            singleproxy.SetStyle(YAML::EmitterStyle::Flow);\n        proxies.push_back(singleproxy);\n        remarks_list.emplace_back(std::move(remark));\n        nodelist.emplace_back(x);\n    }\n\n    if(compact)\n        proxies.SetStyle(YAML::EmitterStyle::Flow);\n\n    if(ext.nodelist)\n    {\n        YAML::Node provider;\n        provider[\"proxies\"] = proxies;\n        yamlnode.reset(provider);\n        return;\n    }\n\n    if(ext.clash_new_field_name)\n        yamlnode[\"proxies\"] = proxies;\n    else\n        yamlnode[\"Proxy\"] = proxies;\n\n\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        singlegroup.reset();\n        eraseElements(filtered_nodelist);\n\n        singlegroup[\"name\"] = x.Name;\n        singlegroup[\"type\"] = x.TypeStr();\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::Relay:\n            break;\n        case ProxyGroupType::LoadBalance:\n            singlegroup[\"strategy\"] = x.StrategyStr();\n            [[fallthrough]];\n        case ProxyGroupType::URLTest:\n            if(!x.Lazy.is_undef())\n                singlegroup[\"lazy\"] = x.Lazy.get();\n            [[fallthrough]];\n        case ProxyGroupType::Fallback:\n            singlegroup[\"url\"] = x.Url;\n            if(x.Interval > 0)\n                singlegroup[\"interval\"] = x.Interval;\n            if(x.Tolerance > 0)\n                singlegroup[\"tolerance\"] = x.Tolerance;\n            break;\n        default:\n            continue;\n        }\n        if(!x.DisableUdp.is_undef())\n            singlegroup[\"disable-udp\"] = x.DisableUdp.get();\n\n        for(const auto& y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n        if(!x.UsingProvider.empty())\n            singlegroup[\"use\"] = x.UsingProvider;\n        else\n        {\n            if(filtered_nodelist.empty())\n                filtered_nodelist.emplace_back(\"DIRECT\");\n        }\n        if(!filtered_nodelist.empty())\n            singlegroup[\"proxies\"] = filtered_nodelist;\n        //singlegroup.SetStyle(YAML::EmitterStyle::Flow);\n\n        bool replace_flag = false;\n        for(unsigned int i = 0; i < original_groups.size(); i++)\n        {\n            if(original_groups[i][\"name\"].as<std::string>() == x.Name)\n            {\n                original_groups[i] = singlegroup;\n                replace_flag = true;\n                break;\n            }\n        }\n        if(!replace_flag)\n            original_groups.push_back(singlegroup);\n    }\n\n    if(ext.clash_new_field_name)\n        yamlnode[\"proxy-groups\"] = original_groups;\n    else\n        yamlnode[\"Proxy Group\"] = original_groups;\n}\n\nstd::string proxyToClash(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext)\n{\n    YAML::Node yamlnode;\n\n    try\n    {\n        yamlnode = YAML::Load(base_conf);\n    }\n    catch (std::exception &e)\n    {\n        writeLog(0, std::string(\"Clash base loader failed with error: \") + e.what(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    proxyToClash(nodes, yamlnode, extra_proxy_group, clashR, ext);\n\n    if(ext.nodelist)\n        return YAML::Dump(yamlnode);\n\n    /*\n    if(ext.enable_rule_generator)\n        rulesetToClash(yamlnode, ruleset_content_array, ext.overwrite_original_rules, ext.clash_new_field_name);\n\n    return YAML::Dump(yamlnode);\n    */\n    if(!ext.enable_rule_generator)\n        return YAML::Dump(yamlnode);\n\n    if(!ext.managed_config_prefix.empty() || ext.clash_script)\n    {\n        if(yamlnode[\"mode\"].IsDefined())\n        {\n            if(ext.clash_new_field_name)\n                yamlnode[\"mode\"] = ext.clash_script ? \"script\" : \"rule\";\n            else\n                yamlnode[\"mode\"] = ext.clash_script ? \"Script\" : \"Rule\";\n        }\n\n        renderClashScript(yamlnode, ruleset_content_array, ext.managed_config_prefix, ext.clash_script, ext.overwrite_original_rules, ext.clash_classical_ruleset);\n        return YAML::Dump(yamlnode);\n    }\n\n    std::string output_content = rulesetToClashStr(yamlnode, ruleset_content_array, ext.overwrite_original_rules, ext.clash_new_field_name);\n    output_content.insert(0, YAML::Dump(yamlnode));\n\n    return output_content;\n}\n\nstd::string proxyToSurge(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, int surge_ver, extra_settings &ext)\n{\n    INIReader ini;\n    std::string proxy;\n    std::string output_nodelist;\n    tribool udp, tfo, scv, tls13;\n    std::vector<Proxy> nodelist;\n    unsigned short local_port = 1080;\n\n    string_array remarks_list, filtered_nodelist, args;\n\n    ini.store_any_line = true;\n    // filter out sections that requires direct-save\n    ini.AddDirectSaveSection(\"General\");\n    ini.AddDirectSaveSection(\"Replica\");\n    ini.AddDirectSaveSection(\"Rule\");\n    ini.AddDirectSaveSection(\"MITM\");\n    ini.AddDirectSaveSection(\"Script\");\n    ini.AddDirectSaveSection(\"Host\");\n    ini.AddDirectSaveSection(\"URL Rewrite\");\n    ini.AddDirectSaveSection(\"Header Rewrite\");\n    if(ini.Parse(base_conf) != 0 && !ext.nodelist)\n    {\n        writeLog(0, \"Surge base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    ini.SetCurrentSection(\"Proxy\");\n    ini.EraseSection();\n    ini.Set(\"{NONAME}\", \"DIRECT = direct\");\n\n    for(Proxy &x : nodes)\n    {\n        std::string remark;\n        if(ext.append_proxy_type)\n        {\n            std::string type = getProxyTypeName(x.Type);\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n        }\n\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname, &username = x.Username, &password = x.Password, &method = x.EncryptMethod, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &edge = x.Edge, &path = x.Path, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &plugin = x.Plugin, &pluginopts = x.PluginOption;\n        std::string port = std::to_string(x.Port);\n        bool &tlssecure = x.TLSSecure;\n\n        udp = ext.udp;\n        tfo = ext.tfo;\n        scv = ext.skip_cert_verify;\n        tls13 = ext.tls13;\n        udp.define(x.UDP);\n        tfo.define(x.TCPFastOpen);\n        scv.define(x.AllowInsecure);\n        tls13.define(x.TLS13);\n\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(surge_ver >= 3 || surge_ver == -3)\n            {\n                proxy = \"ss, \" + hostname + \", \" + port + \", encrypt-method=\" + method + \", password=\" + password;\n            }\n            else\n            {\n                proxy = \"custom, \"  + hostname + \", \" + port + \", \" + method + \", \" + password + \", https://github.com/pobizhe/SSEncrypt/raw/master/SSEncrypt.module\";\n            }\n            if(!plugin.empty())\n            {\n                switch(hash_(plugin))\n                {\n                case \"simple-obfs\"_hash:\n                case \"obfs-local\"_hash:\n                    if(!pluginopts.empty())\n                        proxy += \",\" + replaceAllDistinct(pluginopts, \";\", \",\");\n                    break;\n                default:\n                    continue;\n                }\n            }\n            break;\n        case ProxyType::VMess:\n            if(surge_ver < 4 && surge_ver != -3)\n                continue;\n            proxy = \"vmess, \" + hostname + \", \" + port + \", username=\" + id + \", tls=\" + (tlssecure ? \"true\" : \"false\") +  \", vmess-aead=\" + (x.AlterId == 0 ? \"true\" : \"false\");\n            if(tlssecure && !tls13.is_undef())\n                proxy += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n            switch(hash_(transproto))\n            {\n            case \"tcp\"_hash:\n                break;\n            case \"ws\"_hash:\n                proxy += \", ws=true, ws-path=\" + path + \", sni=\" + host + \", ws-headers=Host:\" + host;\n                if(!edge.empty())\n                    proxy += \"|Edge:\" + edge;\n                break;\n            default:\n                continue;\n            }\n            if(!scv.is_undef())\n                proxy += \", skip-cert-verify=\" + scv.get_str();\n            break;\n        case ProxyType::ShadowsocksR:\n            if(ext.surge_ssr_path.empty() || surge_ver < 2)\n                continue;\n            proxy = \"external, exec=\\\"\" + ext.surge_ssr_path + \"\\\", args=\\\"\";\n            args = {\"-l\", std::to_string(local_port), \"-s\", hostname, \"-p\", port, \"-m\", method, \"-k\", password, \"-o\", obfs, \"-O\", protocol};\n            if(!obfsparam.empty())\n            {\n                args.emplace_back(\"-g\");\n                args.emplace_back(std::move(obfsparam));\n            }\n            if(!protoparam.empty())\n            {\n                args.emplace_back(\"-G\");\n                args.emplace_back(std::move(protoparam));\n            }\n            proxy += join(args, \"\\\", args=\\\"\");\n            proxy += \"\\\", local-port=\" + std::to_string(local_port);\n            if(isIPv4(hostname) || isIPv6(hostname))\n                proxy += \", addresses=\" + hostname;\n            else if(global.surgeResolveHostname)\n                proxy += \", addresses=\" + hostnameToIPAddr(hostname);\n            local_port++;\n            break;\n        case ProxyType::SOCKS5:\n            proxy = \"socks5, \" + hostname + \", \" + port;\n            if(!username.empty())\n                proxy += \", username=\" + username;\n            if(!password.empty())\n                proxy += \", password=\" + password;\n            if(!scv.is_undef())\n                proxy += \", skip-cert-verify=\" + scv.get_str();\n            break;\n        case ProxyType::HTTPS:\n            if(surge_ver == -3)\n            {\n                proxy = \"https, \" + hostname + \", \" + port + \", \" + username + \", \" + password;\n                if(!scv.is_undef())\n                    proxy += \", skip-cert-verify=\" + scv.get_str();\n                break;\n            }\n            [[fallthrough]];\n        case ProxyType::HTTP:\n            proxy = \"http, \" + hostname + \", \" + port;\n            if(!username.empty())\n                proxy += \", username=\" + username;\n            if(!password.empty())\n                proxy += \", password=\" + password;\n            proxy += std::string(\", tls=\") + (x.TLSSecure ? \"true\" : \"false\");\n            if(!scv.is_undef())\n                proxy += \", skip-cert-verify=\" + scv.get_str();\n            break;\n        case ProxyType::Trojan:\n            if(surge_ver < 4 && surge_ver != -3)\n                continue;\n            proxy = \"trojan, \" + hostname + \", \" + port + \", password=\" + password;\n            if(x.SnellVersion != 0)\n                proxy += \", version=\" + std::to_string(x.SnellVersion);\n            if(!host.empty())\n                proxy += \", sni=\" + host;\n            if(!scv.is_undef())\n                proxy += \", skip-cert-verify=\" + scv.get_str();\n            break;\n        case ProxyType::Snell:\n            proxy = \"snell, \" + hostname + \", \" + port + \", psk=\" + password;\n            if(!obfs.empty())\n                proxy += \", obfs=\" + obfs + \", obfs-host=\" + host;\n            break;\n        default:\n            continue;\n        }\n\n        if(!tfo.is_undef())\n            proxy += \", tfo=\" + tfo.get_str();\n        if(!udp.is_undef())\n            proxy += \", udp-relay=\" + udp.get_str();\n\n        if(ext.nodelist)\n            output_nodelist += remark + \" = \" + proxy + \"\\n\";\n        else\n        {\n            ini.Set(\"{NONAME}\", remark + \" = \" + proxy);\n            nodelist.emplace_back(x);\n        }\n        remarks_list.emplace_back(std::move(remark));\n    }\n\n    if(ext.nodelist)\n        return output_nodelist;\n\n    ini.SetCurrentSection(\"Proxy Group\");\n    ini.EraseSection();\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::URLTest:\n        case ProxyGroupType::Fallback:\n            break;\n        case ProxyGroupType::LoadBalance:\n            if(surge_ver < 1)\n                continue;\n            [[fallthrough]];\n        case ProxyGroupType::SSID:\n            proxy = x.TypeStr() + \",default=\" + x.Proxies[0] + \",\";\n            proxy += join(x.Proxies.begin() + 1, x.Proxies.end(), \",\");\n            ini.Set(\"{NONAME}\", x.Name + \" = \" + proxy); //insert order\n            continue;\n        default:\n            continue;\n        }\n\n        for(const auto &y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n        if(filtered_nodelist.empty())\n            filtered_nodelist.emplace_back(\"DIRECT\");\n\n        if(filtered_nodelist.size() == 1)\n        {\n            proxy = toLower(filtered_nodelist[0]);\n            switch(hash_(proxy))\n            {\n            case \"direct\"_hash:\n            case \"reject\"_hash:\n            case \"reject-tinygif\"_hash:\n                ini.Set(\"Proxy\", \"{NONAME}\", x.Name + \" = \" + proxy);\n                continue;\n            }\n        }\n\n        proxy = x.TypeStr() + \",\";\n        proxy += join(filtered_nodelist, \",\");\n        if(x.Type == ProxyGroupType::URLTest || x.Type == ProxyGroupType::Fallback)\n        {\n            proxy += \",url=\" + x.Url + \",interval=\" + std::to_string(x.Interval);\n            if(x.Tolerance > 0)\n                proxy += \",tolerance=\" + std::to_string(x.Tolerance);\n            if(x.Timeout > 0)\n                proxy += \",timeout=\" + std::to_string(x.Timeout);\n        }\n        else if(x.Type == ProxyGroupType::LoadBalance)\n            proxy += \",url=\" + x.Url;\n\n        ini.Set(\"{NONAME}\", x.Name + \" = \" + proxy); //insert order\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, surge_ver, ext.overwrite_original_rules, ext.managed_config_prefix);\n\n    return ini.ToString();\n}\n\nstd::string proxyToSingle(std::vector<Proxy> &nodes, int types, extra_settings &ext)\n{\n    /// types: SS=1 SSR=2 VMess=4 Trojan=8\n    std::string remark, hostname, port, password, method;\n    std::string plugin, pluginopts;\n    std::string protocol, protoparam, obfs, obfsparam;\n    std::string id, aid, transproto, faketype, host, path, quicsecure, quicsecret;\n    std::string proxyStr, allLinks;\n    bool ss = GETBIT(types, 1), ssr = GETBIT(types, 2), vmess = GETBIT(types, 3), trojan = GETBIT(types, 4);\n\n    for(Proxy &x : nodes)\n    {\n        remark = x.Remark;\n        std::string &hostname = x.Hostname, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &faketype = x.FakeType;\n        bool &tlssecure = x.TLSSecure;\n        std::string port = std::to_string(x.Port);\n        std::string aid = std::to_string(x.AlterId);\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(ss)\n            {\n                proxyStr = \"ss://\" + urlSafeBase64Encode(method + \":\" + password) + \"@\" + hostname + \":\" + port;\n                if(!plugin.empty() && !pluginopts.empty())\n                {\n                    proxyStr += \"/?plugin=\" + urlEncode(plugin + \";\" + pluginopts);\n                }\n                proxyStr += \"#\" + urlEncode(remark);\n            }\n            else if(ssr)\n            {\n                if(std::find(ssr_ciphers.begin(), ssr_ciphers.end(), method) != ssr_ciphers.end() && plugin.empty())\n                    proxyStr = \"ssr://\" + urlSafeBase64Encode(hostname + \":\" + port + \":origin:\" + method + \":plain:\" + urlSafeBase64Encode(password) \\\n                               + \"/?group=\" + urlSafeBase64Encode(x.Group) + \"&remarks=\" + urlSafeBase64Encode(remark));\n            }\n            else\n                continue;\n            break;\n        case ProxyType::ShadowsocksR:\n            if(ssr)\n            {\n                proxyStr = \"ssr://\" + urlSafeBase64Encode(hostname + \":\" + port + \":\" + protocol + \":\" + method + \":\" + obfs + \":\" + urlSafeBase64Encode(password) \\\n                           + \"/?group=\" + urlSafeBase64Encode(x.Group) + \"&remarks=\" + urlSafeBase64Encode(remark) \\\n                           + \"&obfsparam=\" + urlSafeBase64Encode(obfsparam) + \"&protoparam=\" + urlSafeBase64Encode(protoparam));\n            }\n            else if(ss)\n            {\n                if(std::find(ss_ciphers.begin(), ss_ciphers.end(), method) != ss_ciphers.end() && protocol == \"origin\" && obfs == \"plain\")\n                    proxyStr = \"ss://\" + urlSafeBase64Encode(method + \":\" + password) + \"@\" + hostname + \":\" + port + \"#\" + urlEncode(remark);\n            }\n            else\n                continue;\n            break;\n        case ProxyType::VMess:\n            if(!vmess)\n                continue;\n            proxyStr = \"vmess://\" + base64Encode(vmessLinkConstruct(remark, hostname, port, faketype, id, aid, transproto, path, host, tlssecure ? \"tls\" : \"\"));\n            break;\n        case ProxyType::Trojan:\n            if(!trojan)\n                continue;\n            proxyStr = \"trojan://\" + password + \"@\" + hostname + \":\" + port + \"?allowInsecure=\" + (x.AllowInsecure.get() ? \"1\" : \"0\");\n            if(!host.empty())\n                proxyStr += \"&sni=\" + host;\n            if(transproto == \"ws\")\n            {\n                proxyStr += \"&ws=1\";\n                if(!path.empty())\n                    proxyStr += \"&wspath=\" + urlEncode(path);\n            }\n            proxyStr += \"#\" + urlEncode(remark);\n            break;\n        default:\n            continue;\n        }\n        allLinks += proxyStr + \"\\n\";\n    }\n\n    if(ext.nodelist)\n        return allLinks;\n    else\n        return base64Encode(allLinks);\n}\n\nstd::string proxyToSSSub(std::string base_conf, std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    rapidjson::Document json, base;\n    std::string remark, hostname, password, method;\n    std::string plugin, pluginopts;\n    std::string protocol, obfs;\n    std::string output_content;\n\n    rapidjson::Document::AllocatorType &alloc = json.GetAllocator();\n    json.SetObject();\n    json.AddMember(\"remarks\", \"\", alloc);\n    json.AddMember(\"server\", \"\", alloc);\n    json.AddMember(\"server_port\", 0, alloc);\n    json.AddMember(\"method\", \"\", alloc);\n    json.AddMember(\"password\", \"\", alloc);\n    json.AddMember(\"plugin\", \"\", alloc);\n    json.AddMember(\"plugin_opts\", \"\", alloc);\n\n    base_conf = trimWhitespace(base_conf);\n    if(base_conf.empty())\n        base_conf = \"{}\";\n    rapidjson::ParseResult result = base.Parse(base_conf.data());\n    if(result)\n    {\n        for(auto iter = base.MemberBegin(); iter != base.MemberEnd(); iter++)\n            json.AddMember(iter->name, iter->value, alloc);\n    }\n    else\n        writeLog(0, std::string(\"SIP008 base loader failed with error: \") + rapidjson::GetParseError_En(result.Code()) + \" (\" + std::to_string(result.Offset()) + \")\", LOG_LEVEL_ERROR);\n\n    rapidjson::Value jsondata;\n    jsondata = json.Move();\n\n    output_content = \"[\";\n    for(Proxy &x : nodes)\n    {\n        remark = x.Remark;\n        hostname = x.Hostname;\n        std::string &password = x.Password;\n        std::string &method = x.EncryptMethod;\n        std::string &plugin = x.Plugin;\n        std::string &pluginopts = x.PluginOption;\n        std::string &protocol = x.Protocol;\n        std::string &obfs = x.OBFS;\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(plugin == \"simple-obfs\")\n                plugin = \"obfs-local\";\n            break;\n        case ProxyType::ShadowsocksR:\n            if(std::find(ss_ciphers.begin(), ss_ciphers.end(), method) == ss_ciphers.end() || protocol != \"origin\" || obfs != \"plain\")\n                continue;\n            break;\n        default:\n            continue;\n        }\n        jsondata[\"remarks\"].SetString(rapidjson::StringRef(remark.c_str(), remark.size()));\n        jsondata[\"server\"].SetString(rapidjson::StringRef(hostname.c_str(), hostname.size()));\n        jsondata[\"server_port\"] = x.Port;\n        jsondata[\"password\"].SetString(rapidjson::StringRef(password.c_str(), password.size()));\n        jsondata[\"method\"].SetString(rapidjson::StringRef(method.c_str(), method.size()));\n        jsondata[\"plugin\"].SetString(rapidjson::StringRef(plugin.c_str(), plugin.size()));\n        jsondata[\"plugin_opts\"].SetString(rapidjson::StringRef(pluginopts.c_str(), pluginopts.size()));\n        output_content += SerializeObject(jsondata) + \",\";\n    }\n    if(output_content.size() > 1)\n        output_content.erase(output_content.size() - 1);\n    output_content += \"]\";\n    return output_content;\n}\n\nstd::string proxyToQuan(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    INIReader ini;\n    ini.store_any_line = true;\n    if(!ext.nodelist && ini.Parse(base_conf) != 0)\n    {\n        writeLog(0, \"Quantumult base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    proxyToQuan(nodes, ini, ruleset_content_array, extra_proxy_group, ext);\n\n    if(ext.nodelist)\n    {\n        string_array allnodes;\n        std::string allLinks;\n        ini.GetAll(\"SERVER\", \"{NONAME}\", allnodes);\n        if(!allnodes.empty())\n            allLinks = join(allnodes, \"\\n\");\n        return base64Encode(allLinks);\n    }\n    return ini.ToString();\n}\n\nvoid proxyToQuan(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    std::string type, proxyStr;\n    tribool scv;\n    std::vector<Proxy> nodelist;\n    string_array remarks_list;\n\n    ini.SetCurrentSection(\"SERVER\");\n    ini.EraseSection();\n    for(Proxy &x : nodes)\n    {\n        std::string remark = x.Remark;\n\n        if(ext.append_proxy_type)\n        {\n            std::string type = getProxyTypeName(x.Type);\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n        }\n\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname, &method = x.EncryptMethod, &password = x.Password, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &edge = x.Edge, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &plugin = x.Plugin, &pluginopts = x.PluginOption, &username = x.Username;\n        std::string port = std::to_string(x.Port);\n        bool &tlssecure = x.TLSSecure;\n\n        switch(x.Type)\n        {\n        case ProxyType::VMess:\n            scv = ext.skip_cert_verify;\n            scv.define(x.AllowInsecure);\n\n            if(method == \"auto\")\n                method = \"chacha20-ietf-poly1305\";\n            proxyStr = remark + \" = vmess, \" + hostname + \", \" + port + \", \" + method + \", \\\"\" + id + \"\\\", group=\" + x.Group;\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true, tls-host=\" + host;\n                if(!scv.is_undef())\n                    proxyStr += \", certificate=\" + std::string(scv.get() ? \"0\" : \"1\");\n            }\n            if(transproto == \"ws\")\n            {\n                proxyStr += \", obfs=ws, obfs-path=\\\"\" + path + \"\\\", obfs-header=\\\"Host: \" + host;\n                if(!edge.empty())\n                    proxyStr += \"[Rr][Nn]Edge: \" + edge;\n                proxyStr += \"\\\"\";\n            }\n\n            if(ext.nodelist)\n                proxyStr = \"vmess://\" + urlSafeBase64Encode(proxyStr);\n            break;\n        case ProxyType::ShadowsocksR:\n            if(ext.nodelist)\n            {\n                proxyStr = \"ssr://\" + urlSafeBase64Encode(hostname + \":\" + port + \":\" + protocol + \":\" + method + \":\" + obfs + \":\" + urlSafeBase64Encode(password) \\\n                           + \"/?group=\" + urlSafeBase64Encode(x.Group) + \"&remarks=\" + urlSafeBase64Encode(remark) \\\n                           + \"&obfsparam=\" + urlSafeBase64Encode(obfsparam) + \"&protoparam=\" + urlSafeBase64Encode(protoparam));\n            }\n            else\n            {\n                proxyStr = remark + \" = shadowsocksr, \" + hostname + \", \" + port + \", \" + method + \", \\\"\" + password + \"\\\", group=\" + x.Group + \", protocol=\" + protocol + \", obfs=\" + obfs;\n                if(!protoparam.empty())\n                    proxyStr += \", protocol_param=\" + protoparam;\n                if(!obfsparam.empty())\n                    proxyStr += \", obfs_param=\" + obfsparam;\n            }\n            break;\n        case ProxyType::Shadowsocks:\n            if(ext.nodelist)\n            {\n                proxyStr = \"ss://\" + urlSafeBase64Encode(method + \":\" + password) + \"@\" + hostname + \":\" + port;\n                if(!plugin.empty() && !pluginopts.empty())\n                {\n                    proxyStr += \"/?plugin=\" + urlEncode(plugin + \";\" + pluginopts);\n                }\n                proxyStr += \"&group=\" + urlSafeBase64Encode(x.Group) + \"#\" + urlEncode(remark);\n            }\n            else\n            {\n                proxyStr = remark + \" = shadowsocks, \" + hostname + \", \" + port + \", \" + method + \", \\\"\" + password + \"\\\", group=\" + x.Group;\n                if(plugin == \"obfs-local\" && !pluginopts.empty())\n                {\n                    proxyStr += \", \" + replaceAllDistinct(pluginopts, \";\", \", \");\n                }\n            }\n            break;\n        case ProxyType::HTTP:\n        case ProxyType::HTTPS:\n            proxyStr = remark + \" = http, upstream-proxy-address=\" + hostname + \", upstream-proxy-port=\" + port + \", group=\" + x.Group;\n            if(!username.empty() && !password.empty())\n                proxyStr += \", upstream-proxy-auth=true, upstream-proxy-username=\" + username + \", upstream-proxy-password=\" + password;\n            else\n                proxyStr += \", upstream-proxy-auth=false\";\n\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true\";\n                if(!host.empty())\n                    proxyStr += \", tls-host=\" + host;\n                if(!scv.is_undef())\n                    proxyStr += \", certificate=\" + std::string(scv.get() ? \"0\" : \"1\");\n            }\n\n            if(ext.nodelist)\n                proxyStr = \"http://\" + urlSafeBase64Encode(proxyStr);\n            break;\n        case ProxyType::SOCKS5:\n            proxyStr = remark + \" = socks, upstream-proxy-address=\" + hostname + \", upstream-proxy-port=\" + port + \", group=\" + x.Group;\n            if(!username.empty() && !password.empty())\n                proxyStr += \", upstream-proxy-auth=true, upstream-proxy-username=\" + username + \", upstream-proxy-password=\" + password;\n            else\n                proxyStr += \", upstream-proxy-auth=false\";\n\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true\";\n                if(!host.empty())\n                    proxyStr += \", tls-host=\" + host;\n                if(!scv.is_undef())\n                    proxyStr += \", certificate=\" + std::string(scv.get() ? \"0\" : \"1\");\n            }\n\n            if(ext.nodelist)\n                proxyStr = \"socks://\" + urlSafeBase64Encode(proxyStr);\n            break;\n        default:\n            continue;\n        }\n\n        ini.Set(\"{NONAME}\", proxyStr);\n        remarks_list.emplace_back(std::move(remark));\n        nodelist.emplace_back(x);\n    }\n\n    if(ext.nodelist)\n        return;\n\n    string_array filtered_nodelist;\n    ini.SetCurrentSection(\"POLICY\");\n    ini.EraseSection();\n\n    std::string singlegroup;\n    std::string name, proxies;\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::Fallback:\n            type = \"static\";\n            break;\n        case ProxyGroupType::URLTest:\n            type = \"auto\";\n            break;\n        case ProxyGroupType::LoadBalance:\n            type = \"balance, round-robin\";\n            break;\n        case ProxyGroupType::SSID:\n            {\n                singlegroup = x.Name + \" : wifi = \" + x.Proxies[0];\n                std::string content, celluar, celluar_matcher = R\"(^(.*?),?celluar\\s?=\\s?(.*?)(,.*)$)\", rem_a, rem_b;\n                for(auto iter = x.Proxies.begin() + 1; iter != x.Proxies.end(); iter++)\n                {\n                    if(regGetMatch(*iter, celluar_matcher, 4, 0, &rem_a, &celluar, &rem_b))\n                    {\n                        content += *iter + \"\\n\";\n                        continue;\n                    }\n                    content += rem_a + rem_b + \"\\n\";\n                }\n                if(!celluar.empty())\n                    singlegroup += \", celluar = \" + celluar;\n                singlegroup += \"\\n\" + replaceAllDistinct(trimOf(content, ','), \",\", \"\\n\");\n                ini.Set(\"{NONAME}\", base64Encode(singlegroup)); //insert order\n            }\n            continue;\n        default:\n            continue;\n        }\n\n        for(const auto &y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n        if(filtered_nodelist.empty())\n            filtered_nodelist.emplace_back(\"direct\");\n\n        if(filtered_nodelist.size() < 2) // force groups with 1 node to be static\n            type = \"static\";\n\n        proxies = join(filtered_nodelist, \"\\n\");\n\n        singlegroup = x.Name + \" : \" + type;\n        if(type == \"static\")\n            singlegroup += \", \" + filtered_nodelist[0];\n        singlegroup += \"\\n\" + proxies + \"\\n\";\n        ini.Set(\"{NONAME}\", base64Encode(singlegroup));\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, -2, ext.overwrite_original_rules, std::string());\n}\n\nstd::string proxyToQuanX(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    INIReader ini;\n    ini.store_any_line = true;\n    ini.AddDirectSaveSection(\"general\");\n    ini.AddDirectSaveSection(\"dns\");\n    ini.AddDirectSaveSection(\"rewrite_remote\");\n    ini.AddDirectSaveSection(\"rewrite_local\");\n    ini.AddDirectSaveSection(\"task_local\");\n    ini.AddDirectSaveSection(\"mitm\");\n    ini.AddDirectSaveSection(\"server_remote\");\n    if(!ext.nodelist && ini.Parse(base_conf) != 0)\n    {\n        writeLog(0, \"QuantumultX base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    proxyToQuanX(nodes, ini, ruleset_content_array, extra_proxy_group, ext);\n\n    if(ext.nodelist)\n    {\n        string_array allnodes;\n        std::string allLinks;\n        ini.GetAll(\"server_local\", \"{NONAME}\", allnodes);\n        if(!allnodes.empty())\n            allLinks = join(allnodes, \"\\n\");\n        return allLinks;\n    }\n    return ini.ToString();\n}\n\nvoid proxyToQuanX(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    std::string type;\n    std::string remark, hostname, port, method;\n    std::string password, plugin, pluginopts;\n    std::string id, transproto, host, path;\n    std::string protocol, protoparam, obfs, obfsparam;\n    std::string proxyStr;\n    tribool udp, tfo, scv, tls13;\n    std::vector<Proxy> nodelist;\n    string_array remarks_list;\n\n    ini.SetCurrentSection(\"server_local\");\n    ini.EraseSection();\n    for(Proxy &x : nodes)\n    {\n        if(ext.append_proxy_type)\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname, &method = x.EncryptMethod, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &password = x.Password, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &username = x.Username;\n        std::string port = std::to_string(x.Port);\n        bool &tlssecure = x.TLSSecure;\n\n        udp = ext.udp;\n        tfo = ext.tfo;\n        scv = ext.skip_cert_verify;\n        tls13 = ext.tls13;\n        udp.define(x.UDP);\n        tfo.define(x.TCPFastOpen);\n        scv.define(x.AllowInsecure);\n        tls13.define(x.TLS13);\n\n        switch(x.Type)\n        {\n        case ProxyType::VMess:\n            if(method == \"auto\")\n                method = \"chacha20-ietf-poly1305\";\n            proxyStr = \"vmess = \" + hostname + \":\" + port + \", method=\" + method + \", password=\" + id + \", aead=\" + (x.AlterId == 0 ? \"true\" : \"false\");\n            if(tlssecure && !tls13.is_undef())\n                proxyStr += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n            if(transproto == \"ws\")\n            {\n                if(tlssecure)\n                    proxyStr += \", obfs=wss\";\n                else\n                    proxyStr += \", obfs=ws\";\n                proxyStr += \", obfs-host=\" + host + \", obfs-uri=\" + path;\n            }\n            else if(tlssecure)\n                proxyStr += \", obfs=over-tls, obfs-host=\" + host;\n            break;\n        case ProxyType::Shadowsocks:\n            proxyStr = \"shadowsocks = \" + hostname + \":\" + port + \", method=\" + method + \", password=\" + password;\n            if(!plugin.empty())\n            {\n                switch(hash_(plugin))\n                {\n                    case \"simple-obfs\"_hash:\n                    case \"obfs-local\"_hash:\n                        if(!pluginopts.empty())\n                            proxyStr += \", \" + replaceAllDistinct(pluginopts, \";\", \", \");\n                        break;\n                    case \"v2ray-plugin\"_hash:\n                        pluginopts = replaceAllDistinct(pluginopts, \";\", \"&\");\n                        plugin = getUrlArg(pluginopts, \"mode\") == \"websocket\" ? \"ws\" : \"\";\n                        host = getUrlArg(pluginopts, \"host\");\n                        path = getUrlArg(pluginopts, \"path\");\n                        tlssecure = pluginopts.find(\"tls\") != pluginopts.npos;\n                        if(tlssecure && plugin == \"ws\")\n                        {\n                            plugin += 's';\n                            if(!tls13.is_undef())\n                                proxyStr += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n                        }\n                        proxyStr += \", obfs=\" + plugin;\n                        if(!host.empty())\n                            proxyStr += \", obfs-host=\" + host;\n                        if(!path.empty())\n                            proxyStr += \", obfs-uri=\" + path;\n                        break;\n                    default: continue;\n                }\n            }\n\n            break;\n        case ProxyType::ShadowsocksR:\n            proxyStr = \"shadowsocks = \" + hostname + \":\" + port + \", method=\" + method + \", password=\" + password + \", ssr-protocol=\" + protocol;\n            if(!protoparam.empty())\n                proxyStr += \", ssr-protocol-param=\" + protoparam;\n            proxyStr += \", obfs=\" + obfs;\n            if(!obfsparam.empty())\n                proxyStr += \", obfs-host=\" + obfsparam;\n            break;\n        case ProxyType::HTTP:\n        case ProxyType::HTTPS:\n            proxyStr = \"http = \" + hostname + \":\" + port + \", username=\" + (username.empty() ? \"none\" : username) + \", password=\" + (password.empty() ? \"none\" : password);\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true\";\n                if(!tls13.is_undef())\n                    proxyStr += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n            }\n            else\n            {\n                proxyStr += \", over-tls=false\";\n            }\n            break;\n        case ProxyType::Trojan:\n            proxyStr = \"trojan = \" + hostname + \":\" + port + \", password=\" + password;\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true, tls-host=\" + host;\n                if(!tls13.is_undef())\n                    proxyStr += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n            }\n            else\n            {\n                proxyStr += \", over-tls=false\";\n            }\n            break;\n        default:\n            continue;\n        }\n        if(!tfo.is_undef())\n            proxyStr += \", fast-open=\" + tfo.get_str();\n        if(!udp.is_undef())\n            proxyStr += \", udp-relay=\" + udp.get_str();\n        if(tlssecure && !scv.is_undef() && (x.Type == ProxyType::HTTP || x.Type == ProxyType::Trojan))\n            proxyStr += \", tls-verification=\" + scv.reverse().get_str();\n        proxyStr += \", tag=\" + remark;\n\n        ini.Set(\"{NONAME}\", proxyStr);\n        remarks_list.emplace_back(std::move(remark));\n        nodelist.emplace_back(x);\n    }\n\n    if(ext.nodelist)\n        return;\n\n    string_multimap original_groups;\n    string_array filtered_nodelist;\n    ini.SetCurrentSection(\"policy\");\n    ini.GetItems(original_groups);\n    ini.EraseSection();\n\n    std::string singlegroup;\n    std::string proxies;\n    string_array vArray;\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n            type = \"static\";\n            break;\n        case ProxyGroupType::URLTest:\n            type = \"url-latency-benchmark\";\n            break;\n        case ProxyGroupType::Fallback:\n            type = \"available\";\n            break;\n        case ProxyGroupType::LoadBalance:\n            type = \"round-robin\";\n            break;\n        case ProxyGroupType::SSID:\n            type = \"ssid\";\n            for(auto iter = x.Proxies.begin(); iter != x.Proxies.end(); iter++)\n                filtered_nodelist.emplace_back(replaceAllDistinct(*iter, \"=\", \":\"));\n            break;\n        default:\n            continue;\n        }\n\n        if(x.Type != ProxyGroupType::SSID)\n        {\n            for(const auto &y : x.Proxies)\n                groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n            if(filtered_nodelist.empty())\n                filtered_nodelist.emplace_back(\"direct\");\n\n            if(filtered_nodelist.size() < 2) // force groups with 1 node to be static\n                type = \"static\";\n        }\n\n        auto iter = std::find_if(original_groups.begin(), original_groups.end(), [&](const string_multimap::value_type &n)\n        {\n            std::string groupdata = n.second;\n            std::string::size_type cpos = groupdata.find(\",\");\n            if(cpos != groupdata.npos)\n                return trim(groupdata.substr(0, cpos)) == x.Name;\n            else\n                return false;\n        });\n        if(iter != original_groups.end())\n        {\n            vArray = split(iter->second, \",\");\n            if(vArray.size() > 1)\n            {\n                if(trim(vArray[vArray.size() - 1]).find(\"img-url\") == 0)\n                    filtered_nodelist.emplace_back(trim(vArray[vArray.size() - 1]));\n            }\n        }\n\n        proxies = join(filtered_nodelist, \", \");\n\n        singlegroup = type + \"=\" + x.Name + \", \" + proxies;\n        ini.Set(\"{NONAME}\", singlegroup);\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, -1, ext.overwrite_original_rules, ext.managed_config_prefix);\n\n    //process scripts\n    string_multimap scripts;\n    std::string content, title, url;\n    const std::string pattern = \"^(.*? url script-.*? )(.*?)$\";\n    if(ini.SectionExist(\"rewrite_local\") && !ext.quanx_dev_id.empty())\n    {\n        ini.GetItems(\"rewrite_local\", scripts);\n        ini.EraseSection(\"rewrite_local\");\n        ini.SetCurrentSection(\"rewrite_local\");\n        for(auto &x : scripts)\n        {\n            title = x.first;\n            if(title != \"{NONAME}\")\n                content = title + \"=\" + x.second;\n            else\n                content = x.second;\n\n            if(regMatch(content, pattern))\n            {\n                url = regReplace(content, pattern, \"$2\");\n                if(isLink(url))\n                {\n                    url = ext.managed_config_prefix + \"/qx-script?id=\" + ext.quanx_dev_id + \"&url=\" + urlSafeBase64Encode(url);\n                    content = regReplace(content, pattern, \"$1\") + url;\n                }\n            }\n            ini.Set(\"{NONAME}\", content);\n        }\n    }\n    eraseElements(scripts);\n    string_size pos;\n    if(ini.SectionExist(\"rewrite_remote\") && !ext.quanx_dev_id.empty())\n    {\n        ini.GetItems(\"rewrite_remote\", scripts);\n        ini.EraseSection(\"rewrite_remote\");\n        ini.SetCurrentSection(\"rewrite_remote\");\n        for(auto &x : scripts)\n        {\n            title = x.first;\n            if(title != \"{NONAME}\")\n                content = title + \"=\" + x.second;\n            else\n                content = x.second;\n\n            if(isLink(content))\n            {\n                pos = content.find(\",\");\n                url = ext.managed_config_prefix + \"/qx-rewrite?id=\" + ext.quanx_dev_id + \"&url=\" + urlSafeBase64Encode(content.substr(0, pos));\n                if(pos != content.npos)\n                    url += content.substr(pos);\n                content = url;\n            }\n            ini.Set(\"{NONAME}\", content);\n        }\n    }\n}\n\nstd::string proxyToSSD(std::vector<Proxy> &nodes, std::string &group, std::string &userinfo, extra_settings &ext)\n{\n    rapidjson::StringBuffer sb;\n    rapidjson::Writer<rapidjson::StringBuffer> writer(sb);\n    size_t index = 0;\n\n    if(group.empty())\n        group = \"SSD\";\n\n    writer.StartObject();\n    writer.Key(\"airport\");\n    writer.String(group.data());\n    writer.Key(\"port\");\n    writer.Int(1);\n    writer.Key(\"encryption\");\n    writer.String(\"aes-128-gcm\");\n    writer.Key(\"password\");\n    writer.String(\"password\");\n    if(!userinfo.empty())\n    {\n        std::string data = replaceAllDistinct(userinfo, \"; \", \"&\");\n        std::string upload = getUrlArg(data, \"upload\"), download = getUrlArg(data, \"download\"), total = getUrlArg(data, \"total\"), expiry = getUrlArg(data, \"expire\");\n        double used = (to_number(upload, 0.0) + to_number(download, 0.0)) / std::pow(1024, 3) * 1.0, tot = to_number(total, 0.0) / std::pow(1024, 3) * 1.0;\n        writer.Key(\"traffic_used\");\n        writer.Double(used);\n        writer.Key(\"traffic_total\");\n        writer.Double(tot);\n        if(!expiry.empty())\n        {\n            const time_t rawtime = to_int(expiry);\n            char buffer[30];\n            struct tm *dt = localtime(&rawtime);\n            strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M\", dt);\n            writer.Key(\"expiry\");\n            writer.String(buffer);\n        }\n    }\n    writer.Key(\"servers\");\n    writer.StartArray();\n\n    for(Proxy &x : nodes)\n    {\n        std::string &hostname = x.Hostname, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &obfs = x.OBFS;\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(plugin == \"obfs-local\")\n                plugin = \"simple-obfs\";\n            writer.StartObject();\n            writer.Key(\"server\");\n            writer.String(hostname.data());\n            writer.Key(\"port\");\n            writer.Int(x.Port);\n            writer.Key(\"encryption\");\n            writer.String(method.data());\n            writer.Key(\"password\");\n            writer.String(password.data());\n            writer.Key(\"plugin\");\n            writer.String(plugin.data());\n            writer.Key(\"plugin_options\");\n            writer.String(pluginopts.data());\n            writer.Key(\"remarks\");\n            writer.String(x.Remark.data());\n            writer.Key(\"id\");\n            writer.Int(index);\n            writer.EndObject();\n            break;\n        case ProxyType::ShadowsocksR:\n            if(std::count(ss_ciphers.begin(), ss_ciphers.end(), method) > 0 && protocol == \"origin\" && obfs == \"plain\")\n            {\n                writer.StartObject();\n                writer.Key(\"server\");\n                writer.String(hostname.data());\n                writer.Key(\"port\");\n                writer.Int(x.Port);\n                writer.Key(\"encryption\");\n                writer.String(method.data());\n                writer.Key(\"password\");\n                writer.String(password.data());\n                writer.Key(\"remarks\");\n                writer.String(x.Remark.data());\n                writer.Key(\"id\");\n                writer.Int(index);\n                writer.EndObject();\n                break;\n            }\n            else\n                continue;\n        default:\n            continue;\n        }\n        index++;\n    }\n    writer.EndArray();\n    writer.EndObject();\n    return \"ssd://\" + base64Encode(sb.GetString());\n}\n\nstd::string proxyToMellow(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    INIReader ini;\n    ini.store_any_line = true;\n    if(ini.Parse(base_conf) != 0)\n    {\n        writeLog(0, \"Mellow base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    proxyToMellow(nodes, ini, ruleset_content_array, extra_proxy_group, ext);\n\n    return ini.ToString();\n}\n\nvoid proxyToMellow(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    std::string proxy;\n    std::string type, remark, hostname, port, username, password, method;\n    std::string plugin, pluginopts;\n    std::string id, aid, transproto, faketype, host, path, quicsecure, quicsecret, tlssecure;\n    std::string url;\n    tribool tfo, scv;\n    std::vector<Proxy> nodelist;\n    string_array vArray, remarks_list, filtered_nodelist;\n\n    ini.SetCurrentSection(\"Endpoint\");\n\n    for(Proxy &x : nodes)\n    {\n        if(ext.append_proxy_type)\n        {\n            std::string type = getProxyTypeName(x.Type);\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n        }\n\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname;\n        port = std::to_string(x.Port);\n\n        tfo = ext.tfo;\n        scv = ext.skip_cert_verify;\n        tfo.define(x.TCPFastOpen);\n        scv.define(x.AllowInsecure);\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(!x.Plugin.empty())\n                continue;\n            proxy = remark + \", ss, ss://\" + urlSafeBase64Encode(method + \":\" + password) + \"@\" + hostname + \":\" + port;\n            break;\n        case ProxyType::VMess:\n            proxy = remark + \", vmess1, vmess1://\" + id + \"@\" + hostname + \":\" + port;\n            if(!path.empty())\n                proxy += path;\n            proxy += \"?network=\" + transproto;\n            switch(hash_(transproto))\n            {\n            case \"ws\"_hash:\n                proxy += \"&ws.host=\" + urlEncode(host);\n                break;\n            case \"http\"_hash:\n                if(!host.empty())\n                    proxy += \"&http.host=\" + urlEncode(host);\n                break;\n            case \"quic\"_hash:\n                if(!quicsecure.empty())\n                    proxy += \"&quic.security=\" + quicsecure + \"&quic.key=\" + quicsecret;\n                break;\n            case \"kcp\"_hash:\n                break;\n            case \"tcp\"_hash:\n                break;\n            }\n            proxy += \"&tls=\" + tlssecure;\n            if(tlssecure == \"true\")\n            {\n                if(!host.empty())\n                    proxy += \"&tls.servername=\" + urlEncode(host);\n            }\n            if(!scv.is_undef())\n                proxy += \"&tls.allowinsecure=\" + scv.get_str();\n            if(!tfo.is_undef())\n                proxy += \"&sockopt.tcpfastopen=\" + tfo.get_str();\n            break;\n        case ProxyType::SOCKS5:\n            proxy = remark + \", builtin, socks, address=\" + hostname + \", port=\" + port + \", user=\" + username + \", pass=\" + password;\n            break;\n        case ProxyType::HTTP:\n            proxy = remark + \", builtin, http, address=\" + hostname + \", port=\" + port + \", user=\" + username + \", pass=\" + password;\n            break;\n        default:\n            continue;\n        }\n\n        ini.Set(\"{NONAME}\", proxy);\n        remarks_list.emplace_back(std::move(remark));\n        nodelist.emplace_back(x);\n    }\n\n    ini.SetCurrentSection(\"EndpointGroup\");\n\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n        url.clear();\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::URLTest:\n        case ProxyGroupType::Fallback:\n        case ProxyGroupType::LoadBalance:\n            break;\n        default:\n            continue;\n        }\n\n        for(const auto &y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, false, ext);\n\n        if(filtered_nodelist.empty())\n        {\n            if(remarks_list.empty())\n                filtered_nodelist.emplace_back(\"DIRECT\");\n            else\n                filtered_nodelist = remarks_list;\n        }\n\n        //don't process these for now\n        /*\n        proxy = vArray[1];\n        for(std::string &x : filtered_nodelist)\n            proxy += \",\" + x;\n        if(vArray[1] == \"url-test\" || vArray[1] == \"fallback\" || vArray[1] == \"load-balance\")\n            proxy += \",url=\" + url;\n        */\n\n        proxy = x.Name + \", \";\n        /*\n        for(std::string &y : filtered_nodelist)\n            proxy += y + \":\";\n        proxy = proxy.substr(0, proxy.size() - 1);\n        */\n        proxy += join(filtered_nodelist, \":\");\n        proxy += \", latency, interval=300, timeout=6\"; //use hard-coded values for now\n\n        ini.Set(\"{NONAME}\", proxy); //insert order\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, 0, ext.overwrite_original_rules, std::string());\n}\n\nstd::string proxyToLoon(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    rapidjson::Document json;\n    INIReader ini;\n    std::string proxy;\n    std::string output_nodelist;\n    tribool scv;\n    std::vector<Proxy> nodelist;\n\n    string_array vArray, remarks_list, filtered_nodelist;\n\n    ini.store_any_line = true;\n    if(ini.Parse(base_conf) != INIREADER_EXCEPTION_NONE && !ext.nodelist)\n    {\n        writeLog(0, \"Loon base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n\n    ini.SetCurrentSection(\"Proxy\");\n    ini.EraseSection();\n\n    for(Proxy &x : nodes)\n    {\n        if(ext.append_proxy_type)\n        {\n            std::string type = getProxyTypeName(x.Type);\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n        }\n        std::string remark = x.Remark;\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname, &username = x.Username, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam;\n        std::string port = std::to_string(x.Port), aid = std::to_string(x.AlterId);\n        bool &tlssecure = x.TLSSecure;\n\n        tribool scv = ext.skip_cert_verify;\n        scv.define(x.AllowInsecure);\n\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            proxy = \"Shadowsocks,\" + hostname + \",\" + port + \",\" + method + \",\\\"\" + password + \"\\\"\";\n            if(plugin == \"simple-obfs\" || plugin == \"obfs-local\")\n            {\n                if(!pluginopts.empty())\n                    proxy += \",\" + replaceAllDistinct(replaceAllDistinct(pluginopts, \";obfs-host=\", \",\"), \"obfs=\", \"\");\n            }\n            else if(!plugin.empty())\n                continue;\n            break;\n        case ProxyType::VMess:\n            if(method == \"auto\")\n                method = \"chacha20-ietf-poly1305\";\n\n            proxy = \"vmess,\" + hostname + \",\" + port + \",\" + method + \",\\\"\" + id + \"\\\",over-tls:\" + (tlssecure ? \"true\" : \"false\");\n            if(tlssecure)\n                proxy += \",tls-name:\" + host;\n            switch(hash_(transproto))\n            {\n            case \"tcp\"_hash:\n                proxy += \",transport:tcp\";\n                break;\n            case \"ws\"_hash:\n                proxy += \",transport:ws,path:\" + path + \",host:\" + host;\n                break;\n            default:\n                continue;\n            }\n            if(!scv.is_undef())\n                proxy += \",skip-cert-verify:\" + std::string(scv.get() ? \"1\" : \"0\");\n            break;\n        case ProxyType::ShadowsocksR:\n            proxy = \"ShadowsocksR,\" + hostname + \",\" + port + \",\" + method + \",\\\"\" + password + \"\\\",\" + protocol + \",{\" + protoparam + \"},\" + obfs + \",{\" + obfsparam + \"}\";\n            break;\n        /*\n        case ProxyType::SOCKS5:\n            proxy = \"socks5, \" + hostname + \", \" + port + \", \" + username + \", \" + password;\n            if(ext.skip_cert_verify)\n                proxy += \", skip-cert-verify:1\";\n            break;\n        */\n        case ProxyType::HTTP:\n            proxy = \"http,\" + hostname + \",\" + port + \",\" + username + \",\" + password;\n            break;\n        case ProxyType::Trojan:\n            proxy = \"trojan,\" + hostname + \",\" + port + \",\" + password;\n            if(!host.empty())\n                proxy += \",tls-name:\" + host;\n            if(!scv.is_undef())\n                proxy += \",skip-cert-verify:\" + std::string(scv.get() ? \"1\" : \"0\");\n            break;\n        default:\n            continue;\n        }\n\n        /*\n        if(ext.tfo)\n            proxy += \", tfo=true\";\n        if(ext.udp)\n            proxy += \", udp-relay=true\";\n        */\n\n        if(ext.nodelist)\n            output_nodelist += remark + \" = \" + proxy + \"\\n\";\n        else\n        {\n            ini.Set(\"{NONAME}\", remark + \" = \" + proxy);\n            nodelist.emplace_back(x);\n            remarks_list.emplace_back(std::move(remark));\n        }\n    }\n\n    if(ext.nodelist)\n        return output_nodelist;\n\n    ini.SetCurrentSection(\"Proxy Group\");\n    ini.EraseSection();\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::URLTest:\n        case ProxyGroupType::Fallback:\n            break;\n        case ProxyGroupType::SSID:\n            if(x.Proxies.size() < 2)\n                continue;\n            proxy = x.TypeStr() + \",default=\" + x.Proxies[0] + \",\";\n            proxy += join(x.Proxies.begin() + 1, x.Proxies.end(), \",\");\n            ini.Set(\"{NONAME}\", x.Name + \" = \" + proxy); //insert order\n            continue;\n        default:\n            continue;\n        }\n\n        for(const auto &y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n        if(filtered_nodelist.empty())\n            filtered_nodelist.emplace_back(\"DIRECT\");\n\n        proxy = x.TypeStr() + \",\";\n        /*\n        for(std::string &y : filtered_nodelist)\n            proxy += \",\" + y;\n        */\n        proxy += join(filtered_nodelist, \",\");\n        if(x.Type == ProxyGroupType::URLTest || x.Type == ProxyGroupType::Fallback)\n            proxy += \",url=\" + x.Url + \",interval=\" + std::to_string(x.Interval);\n\n        ini.Set(\"{NONAME}\", x.Name + \" = \" + proxy); //insert order\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, -4, ext.overwrite_original_rules, ext.managed_config_prefix);\n\n    return ini.ToString();\n}\n", "#ifndef SUBEXPORT_H_INCLUDED\n#define SUBEXPORT_H_INCLUDED\n\n#include <string>\n\n#ifndef NO_JS_RUNTIME\n#include <quickjspp.hpp>\n#endif // NO_JS_RUNTIME\n\n#include \"../../config/proxygroup.h\"\n#include \"../../config/regmatch.h\"\n#include \"../../parser/config/proxy.h\"\n#include \"../../utils/ini_reader/ini_reader.h\"\n#include \"../../utils/string.h\"\n#include \"../../utils/yamlcpp_extra.h\"\n#include \"ruleconvert.h\"\n\nstruct extra_settings\n{\n    bool enable_rule_generator = true;\n    bool overwrite_original_rules = true;\n    RegexMatchConfigs rename_array;\n    RegexMatchConfigs emoji_array;\n    bool add_emoji = false;\n    bool remove_emoji = false;\n    bool append_proxy_type = false;\n    bool nodelist = false;\n    bool sort_flag = false;\n    bool filter_deprecated = false;\n    bool clash_new_field_name = false;\n    bool clash_script = false;\n    std::string surge_ssr_path;\n    std::string managed_config_prefix;\n    std::string quanx_dev_id;\n    tribool udp = tribool();\n    tribool tfo = tribool();\n    tribool skip_cert_verify = tribool();\n    tribool tls13 = tribool();\n    bool clash_classical_ruleset = false;\n    std::string sort_script = \"\";\n    std::string clash_proxies_style = \"flow\";\n\n    extra_settings() {};\n    extra_settings(const extra_settings&) = delete;\n    extra_settings(extra_settings&&) = delete;\n\n#ifndef NO_JS_RUNTIME\n    qjs::Runtime *js_runtime = nullptr;\n    qjs::Context *js_context = nullptr;\n\n    ~extra_settings()\n    {\n        delete js_context;\n        delete js_runtime;\n    }\n#endif // NO_JS_RUNTIME\n};\n\nvoid rulesetToClash(YAML::Node &base_rule, std::vector<RulesetContent> &ruleset_content_array, bool overwrite_original_rules, bool new_field_name);\nvoid rulesetToSurge(INIReader &base_rule, std::vector<RulesetContent> &ruleset_content_array, int surge_ver, bool overwrite_original_rules, std::string remote_path_prefix);\n\nstd::string proxyToClash(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext);\nvoid proxyToClash(std::vector<Proxy> &nodes, YAML::Node &yamlnode, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext);\nstd::string proxyToSurge(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, int surge_ver, extra_settings &ext);\nstd::string proxyToMellow(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nvoid proxyToMellow(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nstd::string proxyToLoon(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nstd::string proxyToSSSub(std::string base_conf, std::vector<Proxy> &nodes, extra_settings &ext);\nstd::string proxyToSingle(std::vector<Proxy> &nodes, int types, extra_settings &ext);\nstd::string proxyToQuanX(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nvoid proxyToQuanX(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nstd::string proxyToQuan(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nvoid proxyToQuan(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nstd::string proxyToSSD(std::vector<Proxy> &nodes, std::string &group, std::string &userinfo, extra_settings &ext);\n\n#endif // SUBEXPORT_H_INCLUDED\n", "#include <iostream>\n#include <string>\n#include <mutex>\n#include <numeric>\n\n#include <inja.hpp>\n#include <yaml-cpp/yaml.h>\n\n#include \"../config/binding.h\"\n#include \"../generator/config/nodemanip.h\"\n#include \"../generator/config/ruleconvert.h\"\n#include \"../generator/config/subexport.h\"\n#include \"../generator/template/templates.h\"\n#include \"../script/cron.h\"\n#include \"../script/script_quickjs.h\"\n#include \"../server/webserver.h\"\n#include \"../utils/base64/base64.h\"\n#include \"../utils/file_extra.h\"\n#include \"../utils/ini_reader/ini_reader.h\"\n#include \"../utils/logger.h\"\n#include \"../utils/network.h\"\n#include \"../utils/regexp.h\"\n#include \"../utils/stl_extra.h\"\n#include \"../utils/string.h\"\n#include \"../utils/string_hash.h\"\n#include \"../utils/system.h\"\n#include \"../utils/system.h\"\n#include \"../utils/urlencode.h\"\n#include \"../utils/yamlcpp_extra.h\"\n#include \"interfaces.h\"\n#include \"multithread.h\"\n#include \"settings.h\"\n#include \"upload.h\"\n#include \"webget.h\"\n\nextern WebServer webServer;\n\nstring_array gRegexBlacklist = {\"(.*)*\"};\n\nvoid refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array);\n\nstd::string parseProxy(const std::string &source)\n{\n    std::string proxy = source;\n    if(source == \"SYSTEM\")\n        proxy = getSystemProxy();\n    else if(source == \"NONE\")\n        proxy = \"\";\n    return proxy;\n}\n\nextern string_array ClashRuleTypes, SurgeRuleTypes, QuanXRuleTypes;\n\nstruct UAProfile\n{\n    std::string head;\n    std::string version_match;\n    std::string version_target;\n    std::string target;\n    tribool clash_new_name = tribool();\n    int surge_ver = -1;\n};\n\nconst std::vector<UAProfile> UAMatchList = {\n    {\"ClashForAndroid\",\"\\\\/([0-9.]+)\",\"2.0\",\"clash\",true},\n    {\"ClashForAndroid\",\"\\\\/([0-9.]+)R\",\"\",\"clashr\",false},\n    {\"ClashForAndroid\",\"\",\"\",\"clash\",false},\n    {\"ClashforWindows\",\"\\\\/([0-9.]+)\",\"0.11\",\"clash\",true},\n    {\"ClashforWindows\",\"\",\"\",\"clash\",false},\n    {\"ClashX Pro\",\"\",\"\",\"clash\",true},\n    {\"ClashX\",\"\\\\/([0-9.]+)\",\"0.13\",\"clash\",true},\n    {\"Clash\",\"\",\"\",\"clash\",true},\n    {\"Kitsunebi\",\"\",\"\",\"v2ray\"},\n    {\"Loon\",\"\",\"\",\"loon\"},\n    {\"Pharos\",\"\",\"\",\"mixed\"},\n    {\"Potatso\",\"\",\"\",\"mixed\"},\n    {\"Quantumult%20X\",\"\",\"\",\"quanx\"},\n    {\"Quantumult\",\"\",\"\",\"quan\"},\n    {\"Qv2ray\",\"\",\"\",\"v2ray\"},\n    {\"Shadowrocket\",\"\",\"\",\"mixed\"},\n    {\"Surfboard\",\"\",\"\",\"surfboard\"},\n    {\"Surge\",\"\\\\/([0-9.]+).*x86\",\"906\",\"surge\",false,4}, /// Surge for Mac (supports VMess)\n    {\"Surge\",\"\\\\/([0-9.]+).*x86\",\"368\",\"surge\",false,3}, /// Surge for Mac (supports new rule types and Shadowsocks without plugin)\n    {\"Surge\",\"\\\\/([0-9.]+)\",\"1419\",\"surge\",false,4}, /// Surge iOS 4 (first version)\n    {\"Surge\",\"\\\\/([0-9.]+)\",\"900\",\"surge\",false,3}, /// Surge iOS 3 (approx)\n    {\"Surge\",\"\",\"\",\"surge\",false,2}, /// any version of Surge as fallback\n    {\"Trojan-Qt5\",\"\",\"\",\"trojan\"},\n    {\"V2rayU\",\"\",\"\",\"v2ray\"},\n    {\"V2RayX\",\"\",\"\",\"v2ray\"}\n};\n\nbool verGreaterEqual(const std::string &src_ver, const std::string &target_ver)\n{\n    string_size src_pos_beg = 0, src_pos_end, target_pos_beg = 0, target_pos_end;\n    while(true)\n    {\n        src_pos_end = src_ver.find('.', src_pos_beg);\n        if(src_pos_end == src_ver.npos)\n            src_pos_end = src_ver.size();\n        int part_src = std::stoi(src_ver.substr(src_pos_beg, src_pos_end - src_pos_beg));\n        target_pos_end = target_ver.find('.', target_pos_beg);\n        if(target_pos_end == target_ver.npos)\n            target_pos_end = target_ver.size();\n        int part_target = std::stoi(target_ver.substr(target_pos_beg, target_pos_end - target_pos_beg));\n        if(part_src > part_target)\n            break;\n        else if(part_src < part_target)\n            return false;\n        else if(src_pos_end >= src_ver.size() - 1 || target_pos_end >= target_ver.size() - 1)\n            break;\n        src_pos_beg = src_pos_end + 1;\n        target_pos_beg = target_pos_end + 1;\n    }\n    return true;\n\n}\n\nvoid matchUserAgent(const std::string &user_agent, std::string &target, tribool &clash_new_name, int &surge_ver)\n{\n    if(user_agent.empty())\n        return;\n    for(const UAProfile &x : UAMatchList)\n    {\n        if(startsWith(user_agent, x.head))\n        {\n            if(!x.version_match.empty())\n            {\n                std::string version;\n                if(regGetMatch(user_agent, x.version_match, 2, 0, &version))\n                    continue;\n                if(!x.version_target.empty() && !verGreaterEqual(version, x.version_target))\n                    continue;\n            }\n            target = x.target;\n            clash_new_name = x.clash_new_name;\n            if(x.surge_ver != -1)\n                surge_ver = x.surge_ver;\n            return;\n        }\n    }\n    return;\n}\n\nstd::string getConvertedRuleset(RESPONSE_CALLBACK_ARGS)\n{\n    std::string url = urlDecode(getUrlArg(request.argument, \"url\")), type = getUrlArg(request.argument, \"type\");\n    return convertRuleset(fetchFile(url, parseProxy(global.proxyRuleset), global.cacheRuleset), to_int(type));\n}\n\nstd::string getRuleset(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n    /// type: 1 for Surge, 2 for Quantumult X, 3 for Clash domain rule-provider, 4 for Clash ipcidr rule-provider, 5 for Surge DOMAIN-SET, 6 for Clash classical ruleset\n    std::string url = urlSafeBase64Decode(getUrlArg(argument, \"url\")), type = getUrlArg(argument, \"type\"), group = urlSafeBase64Decode(getUrlArg(argument, \"group\"));\n    std::string output_content, dummy;\n    int type_int = to_int(type, 0);\n\n    if(!url.size() || !type.size() || (type_int == 2 && !group.size()) || (type_int < 1 || type_int > 6))\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n\n    std::string proxy = parseProxy(global.proxyRuleset);\n    string_array vArray = split(url, \"|\");\n    for(std::string &x : vArray)\n        x.insert(0, \"ruleset,\");\n    std::vector<RulesetContent> rca;\n    RulesetConfigs confs = INIBinding::from<RulesetConfig>::from_ini(vArray);\n    refreshRulesets(confs, rca);\n    for(RulesetContent &x : rca)\n    {\n        std::string content = x.rule_content.get();\n        output_content += convertRuleset(content, x.rule_type);\n    }\n\n    if(!output_content.size())\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n\n    std::string strLine;\n    std::stringstream ss;\n    const std::string rule_match_regex = \"^(.*?,.*?)(,.*)(,.*)$\";\n\n    ss << output_content;\n    char delimiter = getLineBreak(output_content);\n    std::string::size_type lineSize, posb, pose;\n    auto filterLine = [&]()\n    {\n        posb = 0;\n        pose = strLine.find(',');\n        if(pose == strLine.npos)\n            return 1;\n        posb = pose + 1;\n        pose = strLine.find(',', posb);\n        if(pose == strLine.npos)\n        {\n            pose = strLine.size();\n            if(strLine[pose - 1] == '\\r')\n                pose--;\n        }\n        pose -= posb;\n        return 0;\n    };\n\n    lineSize = output_content.size();\n    output_content.clear();\n    output_content.reserve(lineSize);\n\n    if(type_int == 3 || type_int == 4 || type_int == 6)\n        output_content = \"payload:\\n\";\n\n    while(getline(ss, strLine, delimiter))\n    {\n        if(strFind(strLine, \"//\"))\n        {\n            strLine.erase(strLine.find(\"//\"));\n            strLine = trimWhitespace(strLine);\n        }\n        switch(type_int)\n        {\n        case 2:\n            if(!std::any_of(QuanXRuleTypes.begin(), QuanXRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))\n                continue;\n            break;\n        case 1:\n            if(!std::any_of(SurgeRuleTypes.begin(), SurgeRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))\n                continue;\n            break;\n        case 3:\n            if(!startsWith(strLine, \"DOMAIN-SUFFIX,\") && !startsWith(strLine, \"DOMAIN,\"))\n                continue;\n            if(filterLine())\n                continue;\n            output_content += \"  - '\";\n            if(strLine[posb - 2] == 'X')\n                output_content += \"+.\";\n            output_content += strLine.substr(posb, pose);\n            output_content += \"'\\n\";\n            continue;\n        case 4:\n            if(!startsWith(strLine, \"IP-CIDR,\") && !startsWith(strLine, \"IP-CIDR6,\"))\n                continue;\n            if(filterLine())\n                continue;\n            output_content += \"  - '\";\n            output_content += strLine.substr(posb, pose);\n            output_content += \"'\\n\";\n            continue;\n        case 5:\n            if(!startsWith(strLine, \"DOMAIN-SUFFIX,\") && !startsWith(strLine, \"DOMAIN,\"))\n                continue;\n            if(filterLine())\n                continue;\n            output_content += strLine.substr(posb, pose);\n            output_content += '\\n';\n            continue;\n        case 6:\n            if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))\n                continue;\n            output_content += \"  - \";\n        }\n\n        lineSize = strLine.size();\n        if(lineSize && strLine[lineSize - 1] == '\\r') //remove line break\n            strLine.erase(--lineSize);\n\n        if(!strLine.empty() && (strLine[0] != ';' && strLine[0] != '#' && !(lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')))\n        {\n            if(type_int == 2)\n            {\n                if(startsWith(strLine, \"IP-CIDR6\"))\n                    strLine.replace(0, 8, \"IP6-CIDR\");\n                strLine += \",\" + group;\n                if(count_least(strLine, ',', 3) && regReplace(strLine, rule_match_regex, \"$2\") == \",no-resolve\")\n                    strLine = regReplace(strLine, rule_match_regex, \"$1$3$2\");\n                else\n                    strLine = regReplace(strLine, rule_match_regex, \"$1$3\");\n            }\n        }\n        output_content += strLine;\n        output_content += '\\n';\n    }\n\n    if(output_content == \"payload:\\n\")\n    {\n        switch(type_int)\n        {\n        case 3:\n            output_content += \"  - '--placeholder--'\";\n            break;\n        case 4:\n            output_content += \"  - '0.0.0.0/32'\";\n            break;\n        case 6:\n            output_content += \"  - 'DOMAIN,--placeholder--'\";\n            break;\n        }\n    }\n    return output_content;\n}\n\nvoid checkExternalBase(const std::string &path, std::string &dest)\n{\n    if(isLink(path) || (startsWith(path, global.basePath) && fileExist(path)))\n        dest = path;\n}\n\nstd::string subconverter(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    std::string argTarget = getUrlArg(argument, \"target\"), argSurgeVer = getUrlArg(argument, \"ver\");\n    tribool argClashNewField = getUrlArg(argument, \"new_name\");\n    int intSurgeVer = argSurgeVer.size() ? to_int(argSurgeVer, 3) : 3;\n    if(argTarget == \"auto\")\n        matchUserAgent(request.headers[\"User-Agent\"], argTarget, argClashNewField, intSurgeVer);\n\n    /// don't try to load groups or rulesets when generating simple subscriptions\n    bool lSimpleSubscription = false;\n    switch(hash_(argTarget))\n    {\n    case \"ss\"_hash: case \"ssd\"_hash: case \"ssr\"_hash: case \"sssub\"_hash: case \"v2ray\"_hash: case \"trojan\"_hash: case \"mixed\"_hash:\n        lSimpleSubscription = true;\n        break;\n    case \"clash\"_hash: case \"clashr\"_hash: case \"surge\"_hash: case \"quan\"_hash: case \"quanx\"_hash: case \"loon\"_hash: case \"surfboard\"_hash: case \"mellow\"_hash:\n        break;\n    default:\n        *status_code = 400;\n        return \"Invalid target!\";\n    }\n    //check if we need to read configuration\n    if((!global.APIMode || global.CFWChildProcess) && !global.generatorMode)\n        readConf();\n\n    /// string values\n    std::string argUrl = urlDecode(getUrlArg(argument, \"url\"));\n    std::string argGroupName = urlDecode(getUrlArg(argument, \"group\")), argUploadPath = getUrlArg(argument, \"upload_path\");\n    std::string argIncludeRemark = urlDecode(getUrlArg(argument, \"include\")), argExcludeRemark = urlDecode(getUrlArg(argument, \"exclude\"));\n    std::string argCustomGroups = urlSafeBase64Decode(getUrlArg(argument, \"groups\")), argCustomRulesets = urlSafeBase64Decode(getUrlArg(argument, \"ruleset\")), argExternalConfig = urlDecode(getUrlArg(argument, \"config\"));\n    std::string argDeviceID = getUrlArg(argument, \"dev_id\"), argFilename = urlDecode(getUrlArg(argument, \"filename\")), argUpdateInterval = getUrlArg(argument, \"interval\"), argUpdateStrict = getUrlArg(argument, \"strict\");\n    std::string argRenames = urlDecode(getUrlArg(argument, \"rename\")), argFilterScript = urlDecode(getUrlArg(argument, \"filter_script\"));\n\n    /// switches with default value\n    tribool argUpload = getUrlArg(argument, \"upload\"), argEmoji = getUrlArg(argument, \"emoji\"), argAddEmoji = getUrlArg(argument, \"add_emoji\"), argRemoveEmoji = getUrlArg(argument, \"remove_emoji\");\n    tribool argAppendType = getUrlArg(argument, \"append_type\"), argTFO = getUrlArg(argument, \"tfo\"), argUDP = getUrlArg(argument, \"udp\"), argGenNodeList = getUrlArg(argument, \"list\");\n    tribool argSort = getUrlArg(argument, \"sort\"), argUseSortScript = getUrlArg(argument, \"sort_script\");\n    tribool argGenClashScript = getUrlArg(argument, \"script\"), argEnableInsert = getUrlArg(argument, \"insert\");\n    tribool argSkipCertVerify = getUrlArg(argument, \"scv\"), argFilterDeprecated = getUrlArg(argument, \"fdn\"), argExpandRulesets = getUrlArg(argument, \"expand\"), argAppendUserinfo = getUrlArg(argument, \"append_info\");\n    tribool argPrependInsert = getUrlArg(argument, \"prepend\"), argGenClassicalRuleProvider = getUrlArg(argument, \"classic\"), argTLS13 = getUrlArg(argument, \"tls13\");\n\n    std::string base_content, output_content;\n    ProxyGroupConfigs lCustomProxyGroups = global.customProxyGroups;\n    RulesetConfigs lCustomRulesets = global.customRulesets;\n    string_array lIncludeRemarks = global.includeRemarks, lExcludeRemarks = global.excludeRemarks;\n    std::vector<RulesetContent> lRulesetContent;\n    extra_settings ext;\n    std::string subInfo, dummy;\n    int interval = argUpdateInterval.size() ? to_int(argUpdateInterval, global.updateInterval) : global.updateInterval;\n    bool authorized = !global.APIMode || getUrlArg(argument, \"token\") == global.accessToken, strict = argUpdateStrict.size() ? argUpdateStrict == \"true\" : global.updateStrict;\n\n    if(std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argIncludeRemark) != gRegexBlacklist.cend() || std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argExcludeRemark) != gRegexBlacklist.cend())\n        return \"Invalid request!\";\n\n    /// for external configuration\n    std::string lClashBase = global.clashBase, lSurgeBase = global.surgeBase, lMellowBase = global.mellowBase, lSurfboardBase = global.surfboardBase;\n    std::string lQuanBase = global.quanBase, lQuanXBase = global.quanXBase, lLoonBase = global.loonBase, lSSSubBase = global.SSSubBase;\n\n    /// validate urls\n    argEnableInsert.define(global.enableInsert);\n    if(!argUrl.size() && (!global.APIMode || authorized))\n        argUrl = global.defaultUrls;\n    if((!argUrl.size() && !(global.insertUrls.size() && argEnableInsert)) || !argTarget.size())\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n\n    /// load request arguments as template variables\n    string_array req_args = split(argument, \"&\");\n    string_map req_arg_map;\n    for(std::string &x : req_args)\n    {\n        string_size pos = x.find(\"=\");\n        if(pos == x.npos)\n        {\n            req_arg_map[x] = \"\";\n            continue;\n        }\n        if(x.substr(0, pos) == \"token\")\n            continue;\n        req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);\n    }\n    req_arg_map[\"target\"] = argTarget;\n    req_arg_map[\"ver\"] = std::to_string(intSurgeVer);\n\n    /// save template variables\n    template_args tpl_args;\n    tpl_args.global_vars = global.templateVars;\n    tpl_args.request_params = req_arg_map;\n\n    /// check for proxy settings\n    std::string proxy = parseProxy(global.proxySubscription);\n\n    /// check other flags\n    ext.append_proxy_type = argAppendType.get(global.appendType);\n    if((argTarget == \"clash\" || argTarget == \"clashr\") && argGenClashScript.is_undef())\n        argExpandRulesets.define(true);\n\n    ext.clash_proxies_style = global.clashProxiesStyle;\n\n    /// read preference from argument, assign global var if not in argument\n    ext.tfo.define(argTFO).define(global.TFOFlag);\n    ext.udp.define(argUDP).define(global.UDPFlag);\n    ext.skip_cert_verify.define(argSkipCertVerify).define(global.skipCertVerify);\n    ext.tls13.define(argTLS13).define(global.TLS13Flag);\n\n    ext.sort_flag = argSort.get(global.enableSort);\n    argUseSortScript.define(global.sortScript.size() != 0);\n    if(ext.sort_flag && argUseSortScript)\n        ext.sort_script = global.sortScript;\n    ext.filter_deprecated = argFilterDeprecated.get(global.filterDeprecated);\n    ext.clash_new_field_name = argClashNewField.get(global.clashUseNewField);\n    ext.clash_script = argGenClashScript.get();\n    ext.clash_classical_ruleset = argGenClassicalRuleProvider.get();\n    if(!argExpandRulesets)\n        ext.clash_new_field_name = true;\n    else\n        ext.clash_script = false;\n\n    ext.nodelist = argGenNodeList;\n    ext.surge_ssr_path = global.surgeSSRPath;\n    ext.quanx_dev_id = argDeviceID.size() ? argDeviceID : global.quanXDevID;\n    ext.enable_rule_generator = global.enableRuleGen;\n    ext.overwrite_original_rules = global.overwriteOriginalRules;\n    if(!argExpandRulesets)\n        ext.managed_config_prefix = global.managedConfigPrefix;\n\n    /// load external configuration\n    if(argExternalConfig.empty())\n        argExternalConfig = global.defaultExtConfig;\n    if(argExternalConfig.size())\n    {\n        //std::cerr<<\"External configuration file provided. Loading...\\n\";\n        writeLog(0, \"External configuration file provided. Loading...\", LOG_LEVEL_INFO);\n        ExternalConfig extconf;\n        extconf.tpl_args = &tpl_args;\n        if(loadExternalConfig(argExternalConfig, extconf) == 0)\n        {\n            if(!ext.nodelist)\n            {\n                checkExternalBase(extconf.sssub_rule_base, lSSSubBase);\n                if(!lSimpleSubscription)\n                {\n                    checkExternalBase(extconf.clash_rule_base, lClashBase);\n                    checkExternalBase(extconf.surge_rule_base, lSurgeBase);\n                    checkExternalBase(extconf.surfboard_rule_base, lSurfboardBase);\n                    checkExternalBase(extconf.mellow_rule_base, lMellowBase);\n                    checkExternalBase(extconf.quan_rule_base, lQuanBase);\n                    checkExternalBase(extconf.quanx_rule_base, lQuanXBase);\n                    checkExternalBase(extconf.loon_rule_base, lLoonBase);\n\n                    if(extconf.surge_ruleset.size())\n                        lCustomRulesets = extconf.surge_ruleset;\n                    if(extconf.custom_proxy_group.size())\n                        lCustomProxyGroups = extconf.custom_proxy_group;\n                    ext.enable_rule_generator = extconf.enable_rule_generator;\n                    ext.overwrite_original_rules = extconf.overwrite_original_rules;\n                }\n            }\n            if(extconf.rename.size())\n                ext.rename_array = extconf.rename;\n            if(extconf.emoji.size())\n                ext.emoji_array = extconf.emoji;\n            if(extconf.include.size())\n                lIncludeRemarks = extconf.include;\n            if(extconf.exclude.size())\n                lExcludeRemarks = extconf.exclude;\n            argAddEmoji.define(extconf.add_emoji);\n            argRemoveEmoji.define(extconf.remove_old_emoji);\n        }\n    }\n    else\n    {\n        if(!lSimpleSubscription)\n        {\n            /// loading custom groups\n            if(argCustomGroups.size() && !ext.nodelist)\n            {\n                string_array vArray = split(argCustomGroups, \"@\");\n                lCustomProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n            }\n\n            /// loading custom rulesets\n            if(argCustomRulesets.size() && !ext.nodelist)\n            {\n                string_array vArray = split(argCustomRulesets, \"@\");\n                lCustomRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n            }\n        }\n    }\n    if(ext.enable_rule_generator && !ext.nodelist && !lSimpleSubscription)\n    {\n        if(lCustomRulesets != global.customRulesets)\n            refreshRulesets(lCustomRulesets, lRulesetContent);\n        else\n        {\n            if(global.updateRulesetOnRequest)\n                refreshRulesets(global.customRulesets, global.rulesetsContent);\n            lRulesetContent = global.rulesetsContent;\n        }\n    }\n\n    if(!argEmoji.is_undef())\n    {\n        argAddEmoji.set(argEmoji);\n        argRemoveEmoji.set(true);\n    }\n    ext.add_emoji = argAddEmoji.get(global.addEmoji);\n    ext.remove_emoji = argRemoveEmoji.get(global.removeEmoji);\n    if(ext.add_emoji && ext.emoji_array.empty())\n        ext.emoji_array = safe_get_emojis();\n    if(argRenames.size())\n        ext.rename_array = INIBinding::from<RegexMatchConfig>::from_ini(split(argRenames, \"`\"), \"@\");\n    else if(ext.rename_array.empty())\n        ext.rename_array = safe_get_renames();\n\n    /// check custom include/exclude settings\n    if(argIncludeRemark.size() && regValid(argIncludeRemark))\n        lIncludeRemarks = string_array{argIncludeRemark};\n    if(argExcludeRemark.size() && regValid(argExcludeRemark))\n        lExcludeRemarks = string_array{argExcludeRemark};\n\n    /// initialize script runtime\n    if(authorized && !global.scriptCleanContext)\n    {\n        ext.js_runtime = new qjs::Runtime();\n        script_runtime_init(*ext.js_runtime);\n        ext.js_context = new qjs::Context(*ext.js_runtime);\n        script_context_init(*ext.js_context);\n    }\n\n    //start parsing urls\n    RegexMatchConfigs stream_temp = safe_get_streams(), time_temp = safe_get_times();\n\n    //loading urls\n    string_array urls;\n    std::vector<Proxy> nodes, insert_nodes;\n    int groupID = 0;\n\n    parse_settings parse_set;\n    parse_set.proxy = &proxy;\n    parse_set.exclude_remarks = &lExcludeRemarks;\n    parse_set.include_remarks = &lIncludeRemarks;\n    parse_set.stream_rules = &stream_temp;\n    parse_set.time_rules = &time_temp;\n    parse_set.sub_info = &subInfo;\n    parse_set.authorized = authorized;\n    parse_set.request_header = &request.headers;\n    parse_set.js_runtime = ext.js_runtime;\n    parse_set.js_context = ext.js_context;\n\n    if(global.insertUrls.size() && argEnableInsert)\n    {\n        groupID = -1;\n        urls = split(global.insertUrls, \"|\");\n        importItems(urls, true);\n        for(std::string &x : urls)\n        {\n            x = regTrim(x);\n            writeLog(0, \"Fetching node data from url '\" + x + \"'.\", LOG_LEVEL_INFO);\n            if(addNodes(x, insert_nodes, groupID, parse_set) == -1)\n            {\n                if(global.skipFailedLinks)\n                    writeLog(0, \"The following link doesn't contain any valid node info: \" + x, LOG_LEVEL_WARNING);\n                else\n                {\n                    *status_code = 400;\n                    return \"The following link doesn't contain any valid node info: \" + x;\n                }\n            }\n            groupID--;\n        }\n    }\n    urls = split(argUrl, \"|\");\n    importItems(urls, true);\n    groupID = 0;\n    for(std::string &x : urls)\n    {\n        x = regTrim(x);\n        //std::cerr<<\"Fetching node data from url '\"<<x<<\"'.\"<<std::endl;\n        writeLog(0, \"Fetching node data from url '\" + x + \"'.\", LOG_LEVEL_INFO);\n        if(addNodes(x, nodes, groupID, parse_set) == -1)\n        {\n            if(global.skipFailedLinks)\n                writeLog(0, \"The following link doesn't contain any valid node info: \" + x, LOG_LEVEL_WARNING);\n            else\n            {\n                *status_code = 400;\n                return \"The following link doesn't contain any valid node info: \" + x;\n            }\n        }\n        groupID++;\n    }\n    //exit if found nothing\n    if(!nodes.size() && !insert_nodes.size())\n    {\n        *status_code = 400;\n        return \"No nodes were found!\";\n    }\n    if(subInfo.size() && argAppendUserinfo.get(global.appendUserinfo))\n        response.headers.emplace(\"Subscription-UserInfo\", subInfo);\n\n    if(request.method == \"HEAD\")\n        return \"\";\n\n    argPrependInsert.define(global.prependInsert);\n    if(argPrependInsert)\n    {\n        std::move(nodes.begin(), nodes.end(), std::back_inserter(insert_nodes));\n        nodes.swap(insert_nodes);\n    }\n    else\n    {\n        std::move(insert_nodes.begin(), insert_nodes.end(), std::back_inserter(nodes));\n    }\n    //run filter script\n    std::string filterScript = global.filterScript;\n    if(authorized && !argFilterScript.empty())\n        filterScript = argFilterScript;\n    if(filterScript.size())\n    {\n        if(startsWith(filterScript, \"path:\"))\n            filterScript = fileGet(filterScript.substr(5), false);\n        /*\n        duk_context *ctx = duktape_init();\n        if(ctx)\n        {\n            defer(duk_destroy_heap(ctx);)\n            if(duktape_peval(ctx, filterScript) == 0)\n            {\n                auto filter = [&](const Proxy &x)\n                {\n                    duk_get_global_string(ctx, \"filter\");\n                    duktape_push_Proxy(ctx, x);\n                    duk_pcall(ctx, 1);\n                    return !duktape_get_res_bool(ctx);\n                };\n                nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());\n            }\n            else\n            {\n                writeLog(0, \"Error when trying to parse script:\\n\" + duktape_get_err_stack(ctx), LOG_LEVEL_ERROR);\n                duk_pop(ctx); /// pop err\n            }\n        }\n        */\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n        {\n            try\n            {\n                ctx.eval(filterScript);\n                auto filter = (std::function<bool(const Proxy&)>) ctx.eval(\"filter\");\n                nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());\n            }\n            catch(qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n\n    //check custom group name\n    if(argGroupName.size())\n        for(Proxy &x : nodes)\n            x.Group = argGroupName;\n\n    //do pre-process now\n    preprocessNodes(nodes, ext);\n\n    /*\n    //insert node info to template\n    int index = 0;\n    std::string template_node_prefix;\n    for(Proxy &x : nodes)\n    {\n        template_node_prefix = std::to_string(index) + \".\";\n        tpl_args.node_list[template_node_prefix + \"remarks\"] = x.remarks;\n        tpl_args.node_list[template_node_prefix + \"group\"] = x.Group;\n        tpl_args.node_list[template_node_prefix + \"groupid\"] = std::to_string(x.GroupId);\n        index++;\n    }\n    */\n\n    ProxyGroupConfigs dummy_group;\n    std::vector<RulesetContent> dummy_ruleset;\n    std::string managed_url = base64Decode(urlDecode(getUrlArg(argument, \"profile_data\")));\n    if(managed_url.empty())\n        managed_url = global.managedConfigPrefix + \"/sub?\" + argument;\n\n    //std::cerr<<\"Generate target: \";\n    proxy = parseProxy(global.proxyConfig);\n    switch(hash_(argTarget))\n    {\n    case \"clash\"_hash: case \"clashr\"_hash:\n        writeLog(0, argTarget == \"clashr\" ? \"Generate target: ClashR\" : \"Generate target: Clash\", LOG_LEVEL_INFO);\n        tpl_args.local_vars[\"clash.new_field_name\"] = ext.clash_new_field_name ? \"true\" : \"false\";\n        response.headers[\"profile-update-interval\"] = std::to_string(interval / 3600);\n        if(ext.nodelist)\n        {\n            YAML::Node yamlnode;\n            proxyToClash(nodes, yamlnode, dummy_group, argTarget == \"clashr\", ext);\n            output_content = YAML::Dump(yamlnode);\n        }\n        else\n        {\n            if(render_template(fetchFile(lClashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n            output_content = proxyToClash(nodes, base_content, lRulesetContent, lCustomProxyGroups, argTarget == \"clashr\", ext);\n        }\n\n        if(argUpload)\n            uploadGist(argTarget, argUploadPath, output_content, false);\n        break;\n    case \"surge\"_hash:\n\n        writeLog(0, \"Generate target: Surge \" + std::to_string(intSurgeVer), LOG_LEVEL_INFO);\n\n        if(ext.nodelist)\n        {\n            output_content = proxyToSurge(nodes, base_content, dummy_ruleset, dummy_group, intSurgeVer, ext);\n\n            if(argUpload)\n                uploadGist(\"surge\" + argSurgeVer + \"list\", argUploadPath, output_content, true);\n        }\n        else\n        {\n            if(render_template(fetchFile(lSurgeBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n            output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, intSurgeVer, ext);\n\n            if(argUpload)\n                uploadGist(\"surge\" + argSurgeVer, argUploadPath, output_content, true);\n\n            if(global.writeManagedConfig && global.managedConfigPrefix.size())\n                output_content = \"#!MANAGED-CONFIG \" + managed_url + (interval ? \" interval=\" + std::to_string(interval) : \"\") \\\n                 + \" strict=\" + std::string(strict ? \"true\" : \"false\") + \"\\n\\n\" + output_content;\n        }\n        break;\n    case \"surfboard\"_hash:\n        writeLog(0, \"Generate target: Surfboard\", LOG_LEVEL_INFO);\n\n        if(render_template(fetchFile(lSurfboardBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n        {\n            *status_code = 400;\n            return base_content;\n        }\n        output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, -3, ext);\n        if(argUpload)\n            uploadGist(\"surfboard\", argUploadPath, output_content, true);\n\n        if(global.writeManagedConfig && global.managedConfigPrefix.size())\n            output_content = \"#!MANAGED-CONFIG \" + managed_url + (interval ? \" interval=\" + std::to_string(interval) : \"\") \\\n                 + \" strict=\" + std::string(strict ? \"true\" : \"false\") + \"\\n\\n\" + output_content;\n        break;\n    case \"mellow\"_hash:\n        writeLog(0, \"Generate target: Mellow\", LOG_LEVEL_INFO);\n\n        if(render_template(fetchFile(lMellowBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n        {\n            *status_code = 400;\n            return base_content;\n        }\n        output_content = proxyToMellow(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"mellow\", argUploadPath, output_content, true);\n        break;\n    case \"sssub\"_hash:\n        writeLog(0, \"Generate target: SS Subscription\", LOG_LEVEL_INFO);\n\n        if(render_template(fetchFile(lSSSubBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n        {\n            *status_code = 400;\n            return base_content;\n        }\n        output_content = proxyToSSSub(base_content, nodes, ext);\n        if(argUpload)\n            uploadGist(\"sssub\", argUploadPath, output_content, false);\n        break;\n    case \"ss\"_hash:\n        writeLog(0, \"Generate target: SS\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 1, ext);\n        if(argUpload)\n            uploadGist(\"ss\", argUploadPath, output_content, false);\n        break;\n    case \"ssr\"_hash:\n        writeLog(0, \"Generate target: SSR\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 2, ext);\n        if(argUpload)\n            uploadGist(\"ssr\", argUploadPath, output_content, false);\n        break;\n    case \"v2ray\"_hash:\n        writeLog(0, \"Generate target: v2rayN\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 4, ext);\n        if(argUpload)\n            uploadGist(\"v2ray\", argUploadPath, output_content, false);\n        break;\n    case \"trojan\"_hash:\n        writeLog(0, \"Generate target: Trojan\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 8, ext);\n        if(argUpload)\n            uploadGist(\"trojan\", argUploadPath, output_content, false);\n        break;\n    case \"mixed\"_hash:\n        writeLog(0, \"Generate target: Standard Subscription\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 15, ext);\n        if(argUpload)\n            uploadGist(\"sub\", argUploadPath, output_content, false);\n        break;\n    case \"quan\"_hash:\n        writeLog(0, \"Generate target: Quantumult\", LOG_LEVEL_INFO);\n        if(!ext.nodelist)\n        {\n            if(render_template(fetchFile(lQuanBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n        }\n\n        output_content = proxyToQuan(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"quan\", argUploadPath, output_content, false);\n        break;\n    case \"quanx\"_hash:\n        writeLog(0, \"Generate target: Quantumult X\", LOG_LEVEL_INFO);\n        if(!ext.nodelist)\n        {\n            if(render_template(fetchFile(lQuanXBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n        }\n\n        output_content = proxyToQuanX(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"quanx\", argUploadPath, output_content, false);\n        break;\n    case \"loon\"_hash:\n        writeLog(0, \"Generate target: Loon\", LOG_LEVEL_INFO);\n        if(!ext.nodelist)\n        {\n            if(render_template(fetchFile(lLoonBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n        }\n\n        output_content = proxyToLoon(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"loon\", argUploadPath, output_content, false);\n        break;\n    case \"ssd\"_hash:\n        writeLog(0, \"Generate target: SSD\", LOG_LEVEL_INFO);\n        output_content = proxyToSSD(nodes, argGroupName, subInfo, ext);\n        if(argUpload)\n            uploadGist(\"ssd\", argUploadPath, output_content, false);\n        break;\n    default:\n        writeLog(0, \"Generate target: Unspecified\", LOG_LEVEL_INFO);\n        *status_code = 500;\n        return \"Unrecognized target\";\n    }\n    writeLog(0, \"Generate completed.\", LOG_LEVEL_INFO);\n    if(argFilename.size())\n        response.headers.emplace(\"Content-Disposition\", \"attachment; filename=\\\"\" + argFilename + \"\\\"; filename*=utf-8''\" + urlEncode(argFilename));\n    return output_content;\n}\n\nstd::string simpleToClashR(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    std::string url = argument.size() <= 8 ? \"\" : argument.substr(8);\n    if(!url.size() || argument.substr(0, 8) != \"sublink=\")\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n    if(url == \"sublink\")\n    {\n        *status_code = 400;\n        return \"Please insert your subscription link instead of clicking the default link.\";\n    }\n    request.argument = \"target=clashr&url=\" + urlEncode(url);\n    return subconverter(request, response);\n}\n\nstd::string surgeConfToClash(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    INIReader ini;\n    string_array dummy_str_array;\n    std::vector<Proxy> nodes;\n    std::string base_content, url = argument.size() <= 5 ? \"\" : argument.substr(5);\n    const std::string proxygroup_name = global.clashUseNewField ? \"proxy-groups\" : \"Proxy Group\", rule_name = global.clashUseNewField ? \"rules\" : \"Rule\";\n\n    ini.store_any_line = true;\n\n    if(!url.size())\n        url = global.defaultUrls;\n    if(!url.size() || argument.substr(0, 5) != \"link=\")\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n    if(url == \"link\")\n    {\n        *status_code = 400;\n        return \"Please insert your subscription link instead of clicking the default link.\";\n    }\n    writeLog(0, \"SurgeConfToClash called with url '\" + url + \"'.\", LOG_LEVEL_INFO);\n\n    std::string proxy = parseProxy(global.proxyConfig);\n    YAML::Node clash;\n    template_args tpl_args;\n    tpl_args.global_vars = global.templateVars;\n    tpl_args.local_vars[\"clash.new_field_name\"] = global.clashUseNewField ? \"true\" : \"false\";\n    tpl_args.request_params[\"target\"] = \"clash\";\n    tpl_args.request_params[\"url\"] = url;\n\n    if(render_template(fetchFile(global.clashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n    {\n        *status_code = 400;\n        return base_content;\n    }\n    clash = YAML::Load(base_content);\n\n    base_content = fetchFile(url, proxy, global.cacheConfig);\n\n    if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)\n    {\n        std::string errmsg = \"Parsing Surge config failed! Reason: \" + ini.GetLastError();\n        //std::cerr<<errmsg<<\"\\n\";\n        writeLog(0, errmsg, LOG_LEVEL_ERROR);\n        *status_code = 400;\n        return errmsg;\n    }\n    if(!ini.SectionExist(\"Proxy\") || !ini.SectionExist(\"Proxy Group\") || !ini.SectionExist(\"Rule\"))\n    {\n        std::string errmsg = \"Incomplete surge config! Missing critical sections!\";\n        //std::cerr<<errmsg<<\"\\n\";\n        writeLog(0, errmsg, LOG_LEVEL_ERROR);\n        *status_code = 400;\n        return errmsg;\n    }\n\n    //scan groups first, get potential policy-path\n    string_multimap section;\n    ini.GetItems(\"Proxy Group\", section);\n    std::string name, type, content;\n    string_array links;\n    links.emplace_back(url);\n    YAML::Node singlegroup;\n    for(auto &x : section)\n    {\n        singlegroup.reset();\n        name = x.first;\n        content = x.second;\n        dummy_str_array = split(content, \",\");\n        if(!dummy_str_array.size())\n            continue;\n        type = dummy_str_array[0];\n        if(!(type == \"select\" || type == \"url-test\" || type == \"fallback\" || type == \"load-balance\")) //remove unsupported types\n            continue;\n        singlegroup[\"name\"] = name;\n        singlegroup[\"type\"] = type;\n        for(unsigned int i = 1; i < dummy_str_array.size(); i++)\n        {\n            if(startsWith(dummy_str_array[i], \"url\"))\n                singlegroup[\"url\"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find(\"=\") + 1));\n            else if(startsWith(dummy_str_array[i], \"interval\"))\n                singlegroup[\"interval\"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find(\"=\") + 1));\n            else if(startsWith(dummy_str_array[i], \"policy-path\"))\n                links.emplace_back(trim(dummy_str_array[i].substr(dummy_str_array[i].find(\"=\") + 1)));\n            else\n                singlegroup[\"proxies\"].push_back(trim(dummy_str_array[i]));\n        }\n        clash[proxygroup_name].push_back(singlegroup);\n    }\n\n    proxy = parseProxy(global.proxySubscription);\n    eraseElements(dummy_str_array);\n\n    RegexMatchConfigs dummy_regex_array;\n    std::string subInfo;\n    parse_settings parse_set;\n    parse_set.proxy = &proxy;\n    parse_set.exclude_remarks = parse_set.include_remarks = &dummy_str_array;\n    parse_set.stream_rules = parse_set.time_rules = &dummy_regex_array;\n    parse_set.request_header = &request.headers;\n    parse_set.sub_info = &subInfo;\n    parse_set.authorized = !global.APIMode;\n    for(std::string &x : links)\n    {\n        //std::cerr<<\"Fetching node data from url '\"<<x<<\"'.\"<<std::endl;\n        writeLog(0, \"Fetching node data from url '\" + x + \"'.\", LOG_LEVEL_INFO);\n        if(addNodes(x, nodes, 0, parse_set) == -1)\n        {\n            if(global.skipFailedLinks)\n                writeLog(0, \"The following link doesn't contain any valid node info: \" + x, LOG_LEVEL_WARNING);\n            else\n            {\n                *status_code = 400;\n                return \"The following link doesn't contain any valid node info: \" + x;\n            }\n        }\n    }\n\n    //exit if found nothing\n    if(!nodes.size())\n    {\n        *status_code = 400;\n        return \"No nodes were found!\";\n    }\n\n    extra_settings ext;\n    ext.sort_flag = global.enableSort;\n    ext.filter_deprecated = global.filterDeprecated;\n    ext.clash_new_field_name = global.clashUseNewField;\n    ext.udp = global.UDPFlag;\n    ext.tfo = global.TFOFlag;\n    ext.skip_cert_verify = global.skipCertVerify;\n    ext.tls13 = global.TLS13Flag;\n    ext.clash_proxies_style = global.clashProxiesStyle;\n\n    ProxyGroupConfigs dummy_groups;\n    proxyToClash(nodes, clash, dummy_groups, false, ext);\n\n    section.clear();\n    ini.GetItems(\"Proxy\", section);\n    for(auto &x : section)\n    {\n        singlegroup.reset();\n        name = x.first;\n        content = x.second;\n        dummy_str_array = split(content, \",\");\n        if(!dummy_str_array.size())\n            continue;\n        content = trim(dummy_str_array[0]);\n        switch(hash_(content))\n        {\n        case \"direct\"_hash:\n            singlegroup[\"name\"] = name;\n            singlegroup[\"type\"] = \"select\";\n            singlegroup[\"proxies\"].push_back(\"DIRECT\");\n            break;\n        case \"reject\"_hash:\n        case \"reject-tinygif\"_hash:\n            singlegroup[\"name\"] = name;\n            singlegroup[\"type\"] = \"select\";\n            singlegroup[\"proxies\"].push_back(\"REJECT\");\n            break;\n        default:\n            continue;\n        }\n        clash[proxygroup_name].push_back(singlegroup);\n    }\n\n    eraseElements(dummy_str_array);\n    ini.GetAll(\"Rule\", \"{NONAME}\", dummy_str_array);\n    YAML::Node rule;\n    string_array strArray;\n    std::string strLine;\n    std::stringstream ss;\n    std::string::size_type lineSize;\n    for(std::string &x : dummy_str_array)\n    {\n        if(startsWith(x, \"RULE-SET\"))\n        {\n            strArray = split(x, \",\");\n            if(strArray.size() != 3)\n                continue;\n            content = webGet(strArray[1], proxy, global.cacheRuleset);\n            if(!content.size())\n                continue;\n\n            ss << content;\n            char delimiter = getLineBreak(content);\n\n            while(getline(ss, strLine, delimiter))\n            {\n                lineSize = strLine.size();\n                if(lineSize && strLine[lineSize - 1] == '\\r') //remove line break\n                    strLine.erase(--lineSize);\n                if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) //empty lines and comments are ignored\n                    continue;\n                else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);})) //remove unsupported types\n                    continue;\n                strLine += strArray[2];\n                if(count_least(strLine, ',', 3))\n                    strLine = regReplace(strLine, \"^(.*?,.*?)(,.*)(,.*)$\", \"$1$3$2\");\n                rule.push_back(strLine);\n            }\n            ss.clear();\n            continue;\n        }\n        else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))\n            continue;\n        rule.push_back(x);\n    }\n    clash[rule_name] = rule;\n\n    response.headers[\"profile-update-interval\"] = std::to_string(global.updateInterval / 3600);\n    writeLog(0, \"Conversion completed.\", LOG_LEVEL_INFO);\n    return YAML::Dump(clash);\n}\n\nstd::string getProfile(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    std::string name = urlDecode(getUrlArg(argument, \"name\")), token = urlDecode(getUrlArg(argument, \"token\"));\n    string_array profiles = split(name, \"|\");\n    name = profiles[0];\n    if(token.empty() || name.empty())\n    {\n        *status_code = 403;\n        return \"Forbidden\";\n    }\n    std::string profile_content;\n    /*if(vfs::vfs_exist(name))\n    {\n        profile_content = vfs::vfs_get(name);\n    }\n    else */if(fileExist(name))\n    {\n        profile_content = fileGet(name, true);\n    }\n    else\n    {\n        *status_code = 404;\n        return \"Profile not found\";\n    }\n    //std::cerr<<\"Trying to load profile '\" + name + \"'.\\n\";\n    writeLog(0, \"Trying to load profile '\" + name + \"'.\", LOG_LEVEL_INFO);\n    INIReader ini;\n    if(ini.Parse(profile_content) != INIREADER_EXCEPTION_NONE && !ini.SectionExist(\"Profile\"))\n    {\n        //std::cerr<<\"Load profile failed! Reason: \"<<ini.GetLastError()<<\"\\n\";\n        writeLog(0, \"Load profile failed! Reason: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        *status_code = 500;\n        return \"Broken profile!\";\n    }\n    //std::cerr<<\"Trying to parse profile '\" + name + \"'.\\n\";\n    writeLog(0, \"Trying to parse profile '\" + name + \"'.\", LOG_LEVEL_INFO);\n    string_multimap contents;\n    ini.GetItems(\"Profile\", contents);\n    if(!contents.size())\n    {\n        //std::cerr<<\"Load profile failed! Reason: Empty Profile section\\n\";\n        writeLog(0, \"Load profile failed! Reason: Empty Profile section\", LOG_LEVEL_ERROR);\n        *status_code = 500;\n        return \"Broken profile!\";\n    }\n    auto profile_token = contents.find(\"profile_token\");\n    if(profiles.size() == 1 && profile_token != contents.end())\n    {\n        if(token != profile_token->second)\n        {\n            *status_code = 403;\n            return \"Forbidden\";\n        }\n        token = global.accessToken;\n    }\n    else\n    {\n        if(token != global.accessToken)\n        {\n            *status_code = 403;\n            return \"Forbidden\";\n        }\n    }\n    /// check if more than one profile is provided\n    if(profiles.size() > 1)\n    {\n        writeLog(0, \"Multiple profiles are provided. Trying to combine profiles...\", LOG_TYPE_INFO);\n        std::string all_urls, url;\n        auto iter = contents.find(\"url\");\n        if(iter != contents.end())\n            all_urls = iter->second;\n        for(size_t i = 1; i < profiles.size(); i++)\n        {\n            name = profiles[i];\n            if(!fileExist(name))\n            {\n                writeLog(0, \"Ignoring non-exist profile '\" + name + \"'...\", LOG_LEVEL_WARNING);\n                continue;\n            }\n            if(ini.ParseFile(name) != INIREADER_EXCEPTION_NONE && !ini.SectionExist(\"Profile\"))\n            {\n                writeLog(0, \"Ignoring broken profile '\" + name + \"'...\", LOG_LEVEL_WARNING);\n                continue;\n            }\n            url = ini.Get(\"Profile\", \"url\");\n            if(url.size())\n            {\n                all_urls += \"|\" + url;\n                writeLog(0, \"Profile url from '\" + name + \"' added.\", LOG_LEVEL_INFO);\n            }\n            else\n            {\n                writeLog(0, \"Profile '\" + name + \"' does not have url key. Skipping...\", LOG_LEVEL_INFO);\n            }\n        }\n        iter->second = all_urls;\n    }\n\n    contents.emplace(\"token\", token);\n    contents.emplace(\"profile_data\", base64Encode(global.managedConfigPrefix + \"/getprofile?\" + argument));\n    std::string query = std::accumulate(contents.begin(), contents.end(), std::string(), [](const std::string &x, auto y){ return x + y.first + \"=\" + urlEncode(y.second) + \"&\"; });\n    query += argument;\n    request.argument = query;\n    return subconverter(request, response);\n}\n\nstd::string getScript(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n\n    std::string url = urlSafeBase64Decode(getUrlArg(argument, \"url\")), dev_id = getUrlArg(argument, \"id\");\n    std::string output_content;\n\n    std::string proxy = parseProxy(global.proxyConfig);\n\n    output_content = fetchFile(url, proxy, global.cacheConfig);\n\n    if(!dev_id.size())\n        dev_id = global.quanXDevID;\n\n    const std::string pattern = \"(\\\\/\\\\*[\\\\s\\\\S]*?)^(.*?@supported )(.*?\\\\s?)$([\\\\s\\\\S]*\\\\*\\\\/\\\\s?\";\n    if(dev_id.size())\n    {\n        if(regFind(output_content, pattern))\n            output_content = regReplace(output_content, pattern, \"$1$2\" + dev_id + \"$4\");\n        else\n            output_content = \"/**\\n * @supported \" + dev_id + \"\\n * THIS COMMENT IS GENERATED BY SUBCONVERTER\\n */\\n\\n\" + output_content;\n    }\n    return output_content;\n}\n\nstd::string getRewriteRemote(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n\n    std::string url = urlSafeBase64Decode(getUrlArg(argument, \"url\")), dev_id = getUrlArg(argument, \"id\");\n    std::string output_content;\n\n    std::string proxy = parseProxy(global.proxyConfig);\n\n    output_content = fetchFile(url, proxy, global.cacheConfig);\n\n    if(!dev_id.size())\n        dev_id = global.quanXDevID;\n\n    if(dev_id.size())\n    {\n        std::stringstream ss;\n        std::string strLine;\n        const std::string pattern = \"^(.*? url script-.*? )(.*?)$\";\n        string_size lineSize;\n        char delimiter = getLineBreak(output_content);\n\n        ss << output_content;\n        output_content.clear();\n        while(getline(ss, strLine, delimiter))\n        {\n            lineSize = strLine.size();\n            if(lineSize && strLine[lineSize - 1] == '\\r') //remove line break\n                strLine.erase(--lineSize);\n\n            if(!strLine.empty() && regMatch(strLine, pattern))\n            {\n                url = global.managedConfigPrefix + \"/qx-script?id=\" + dev_id + \"&url=\" + urlSafeBase64Encode(regReplace(strLine, pattern, \"$2\"));\n                strLine = regReplace(strLine, pattern, \"$1\") + url;\n            }\n            output_content.append(strLine + \"\\n\");\n        }\n    }\n    return output_content;\n}\n\n/*\nstd::string jinja2_webGet(const std::string &url)\n{\n    std::string proxy = parseProxy(global.proxyConfig);\n    writeLog(0, \"Template called fetch with url '\" + url + \"'.\", LOG_LEVEL_INFO);\n    return webGet(url, proxy, global.cacheConfig);\n}*/\n\ninline std::string intToStream(unsigned long long stream)\n{\n    char chrs[16] = {}, units[6] = {' ', 'K', 'M', 'G', 'T', 'P'};\n    double streamval = stream;\n    unsigned int level = 0;\n    while(streamval > 1024.0)\n    {\n        if(level >= 5)\n            break;\n        level++;\n        streamval /= 1024.0;\n    }\n    snprintf(chrs, 15, \"%.2f %cB\", streamval, units[level]);\n    return std::string(chrs);\n}\n\nstd::string subInfoToMessage(std::string subinfo)\n{\n    using ull = unsigned long long;\n    subinfo = replaceAllDistinct(subinfo, \"; \", \"&\");\n    std::string retdata, useddata = \"N/A\", totaldata = \"N/A\", expirydata = \"N/A\";\n    std::string upload = getUrlArg(subinfo, \"upload\"), download = getUrlArg(subinfo, \"download\"), total = getUrlArg(subinfo, \"total\"), expire = getUrlArg(subinfo, \"expire\");\n    ull used = to_number<ull>(upload, 0) + to_number<ull>(download, 0), tot = to_number<ull>(total, 0);\n    time_t expiry = to_number<time_t>(expire, 0);\n    if(used != 0)\n        useddata = intToStream(used);\n    if(tot != 0)\n        totaldata = intToStream(tot);\n    if(expiry != 0)\n    {\n        char buffer[30];\n        struct tm *dt = localtime(&expiry);\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M\", dt);\n        expirydata.assign(buffer);\n    }\n    if(useddata == \"N/A\" && totaldata == \"N/A\" && expirydata == \"N/A\")\n        retdata = \"Not Available\";\n    else\n        retdata += \"Stream Used: \" + useddata + \" Stream Total: \" + totaldata + \" Expiry Time: \" + expirydata;\n    return retdata;\n}\n\nint simpleGenerator()\n{\n    //std::cerr<<\"\\nReading generator configuration...\\n\";\n    writeLog(0, \"Reading generator configuration...\", LOG_LEVEL_INFO);\n    std::string config = fileGet(\"generate.ini\"), path, profile, arguments, content;\n    if(config.empty())\n    {\n        //std::cerr<<\"Generator configuration not found or empty!\\n\";\n        writeLog(0, \"Generator configuration not found or empty!\", LOG_LEVEL_ERROR);\n        return -1;\n    }\n\n    INIReader ini;\n    if(ini.Parse(config) != INIREADER_EXCEPTION_NONE)\n    {\n        //std::cerr<<\"Generator configuration broken! Reason:\"<<ini.GetLastError()<<\"\\n\";\n        writeLog(0, \"Generator configuration broken! Reason:\" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return -2;\n    }\n    //std::cerr<<\"Read generator configuration completed.\\n\\n\";\n    writeLog(0, \"Read generator configuration completed.\\n\", LOG_LEVEL_INFO);\n\n    string_array sections = ini.GetSections();\n    if(global.generateProfiles.size())\n    {\n        //std::cerr<<\"Generating with specific artifacts: \\\"\"<<gen_profile<<\"\\\"...\\n\";\n        writeLog(0, \"Generating with specific artifacts: \\\"\" + global.generateProfiles + \"\\\"...\", LOG_LEVEL_INFO);\n        string_array targets = split(global.generateProfiles, \",\"), new_targets;\n        for(std::string &x : targets)\n        {\n            x = trim(x);\n            if(std::find(sections.cbegin(), sections.cend(), x) != sections.cend())\n                new_targets.emplace_back(std::move(x));\n            else\n            {\n                //std::cerr<<\"Artifact \\\"\"<<x<<\"\\\" not found in generator settings!\\n\";\n                writeLog(0, \"Artifact \\\"\" + x + \"\\\" not found in generator settings!\", LOG_LEVEL_ERROR);\n                return -3;\n            }\n        }\n        sections = new_targets;\n        sections.shrink_to_fit();\n    }\n    else\n        //std::cerr<<\"Generating all artifacts...\\n\";\n        writeLog(0, \"Generating all artifacts...\", LOG_LEVEL_INFO);\n\n    string_multimap allItems;\n    std::string proxy = parseProxy(global.proxySubscription);\n    Request request;\n    Response response;\n    for(std::string &x : sections)\n    {\n        arguments.clear();\n        response.status_code = 200;\n        //std::cerr<<\"Generating artifact '\"<<x<<\"'...\\n\";\n        writeLog(0, \"Generating artifact '\" + x + \"'...\", LOG_LEVEL_INFO);\n        ini.EnterSection(x);\n        if(ini.ItemExist(\"path\"))\n            path = ini.Get(\"path\");\n        else\n        {\n            //std::cerr<<\"Artifact '\"<<x<<\"' output path missing! Skipping...\\n\\n\";\n            writeLog(0, \"Artifact '\" + x + \"' output path missing! Skipping...\\n\", LOG_LEVEL_ERROR);\n            continue;\n        }\n        if(ini.ItemExist(\"profile\"))\n        {\n            profile = ini.Get(\"profile\");\n            request.argument = \"name=\" + urlEncode(profile) + \"&token=\" + global.accessToken + \"&expand=true\";\n            content = getProfile(request, response);\n        }\n        else\n        {\n            if(ini.GetBool(\"direct\") == true)\n            {\n                std::string url = ini.Get(\"url\");\n                content = fetchFile(url, proxy, global.cacheSubscription);\n                if(content.empty())\n                {\n                    //std::cerr<<\"Artifact '\"<<x<<\"' generate ERROR! Please check your link.\\n\\n\";\n                    writeLog(0, \"Artifact '\" + x + \"' generate ERROR! Please check your link.\\n\", LOG_LEVEL_ERROR);\n                    if(sections.size() == 1)\n                        return -1;\n                }\n                // add UTF-8 BOM\n                fileWrite(path, \"\\xEF\\xBB\\xBF\" + content, true);\n                continue;\n            }\n            ini.GetItems(allItems);\n            allItems.emplace(\"expand\", \"true\");\n            for(auto &y : allItems)\n            {\n                if(y.first == \"path\")\n                    continue;\n                arguments += y.first + \"=\" + urlEncode(y.second) + \"&\";\n            }\n            arguments.erase(arguments.size() - 1);\n            request.argument = arguments;\n            content = subconverter(request, response);\n        }\n        if(response.status_code != 200)\n        {\n            //std::cerr<<\"Artifact '\"<<x<<\"' generate ERROR! Reason: \"<<content<<\"\\n\\n\";\n            writeLog(0, \"Artifact '\" + x + \"' generate ERROR! Reason: \" + content + \"\\n\", LOG_LEVEL_ERROR);\n            if(sections.size() == 1)\n                return -1;\n            continue;\n        }\n        fileWrite(path, content, true);\n        auto iter = std::find_if(response.headers.begin(), response.headers.end(), [](auto y){ return y.first == \"Subscription-UserInfo\"; });\n        if(iter != response.headers.end())\n            writeLog(0, \"User Info for artifact '\" + x + \"': \" + subInfoToMessage(iter->second), LOG_LEVEL_INFO);\n        //std::cerr<<\"Artifact '\"<<x<<\"' generate SUCCESS!\\n\\n\";\n        writeLog(0, \"Artifact '\" + x + \"' generate SUCCESS!\\n\", LOG_LEVEL_INFO);\n        eraseElements(response.headers);\n    }\n    //std::cerr<<\"All artifact generated. Exiting...\\n\";\n    writeLog(0, \"All artifact generated. Exiting...\", LOG_LEVEL_INFO);\n    return 0;\n}\n\nstd::string renderTemplate(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    std::string path = urlDecode(getUrlArg(argument, \"path\"));\n    writeLog(0, \"Trying to render template '\" + path + \"'...\", LOG_LEVEL_INFO);\n\n    if(!startsWith(path, global.templatePath) || !fileExist(path))\n    {\n        *status_code = 404;\n        return \"Not found\";\n    }\n    std::string template_content = fetchFile(path, parseProxy(global.proxyConfig), global.cacheConfig);\n    if(template_content.empty())\n    {\n        *status_code = 400;\n        return \"File empty or out of scope\";\n    }\n    template_args tpl_args;\n    tpl_args.global_vars = global.templateVars;\n\n    //load request arguments as template variables\n    string_array req_args = split(argument, \"&\");\n    string_size pos;\n    string_map req_arg_map;\n    for(std::string &x : req_args)\n    {\n        pos = x.find(\"=\");\n        if(pos == x.npos)\n            req_arg_map[x] = \"\";\n        else\n            req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);\n    }\n    tpl_args.request_params = req_arg_map;\n\n    std::string output_content;\n    if(render_template(template_content, tpl_args, output_content, global.templatePath) != 0)\n    {\n        *status_code = 400;\n        writeLog(0, \"Render failed with error.\", LOG_LEVEL_WARNING);\n    }\n    else\n        writeLog(0, \"Render completed.\", LOG_LEVEL_INFO);\n\n    return output_content;\n}\n", "#include <string>\n#include <mutex>\n#include <toml.hpp>\n\n#include \"../config/binding.h\"\n#include \"../handler/webget.h\"\n#include \"../script/cron.h\"\n#include \"../server/webserver.h\"\n#include \"../utils/logger.h\"\n#include \"../utils/network.h\"\n#include \"interfaces.h\"\n#include \"multithread.h\"\n#include \"settings.h\"\n\n//multi-thread lock\nstd::mutex gMutexConfigure;\n\nSettings global;\n\nextern WebServer webServer;\n\nconst std::map<std::string, ruleset_type> RulesetTypes = {{\"clash-domain:\", RULESET_CLASH_DOMAIN}, {\"clash-ipcidr:\", RULESET_CLASH_IPCIDR}, {\"clash-classic:\", RULESET_CLASH_CLASSICAL}, \\\n            {\"quanx:\", RULESET_QUANX}, {\"surge:\", RULESET_SURGE}};\n\nint importItems(string_array &target, bool scope_limit)\n{\n    string_array result;\n    std::stringstream ss;\n    std::string path, content, strLine;\n    unsigned int itemCount = 0;\n    for(std::string &x : target)\n    {\n        if(x.find(\"!!import:\") == x.npos)\n        {\n            result.emplace_back(x);\n            continue;\n        }\n        path = x.substr(x.find(\":\") + 1);\n        writeLog(0, \"Trying to import items from \" + path);\n\n        std::string proxy = parseProxy(global.proxyConfig);\n\n        if(fileExist(path))\n            content = fileGet(path, scope_limit);\n        else if(isLink(path))\n            content = webGet(path, proxy, global.cacheConfig);\n        else\n            writeLog(0, \"File not found or not a valid URL: \" + path, LOG_LEVEL_ERROR);\n        if(!content.size())\n            return -1;\n\n        ss << content;\n        char delimiter = getLineBreak(content);\n        std::string::size_type lineSize;\n        while(getline(ss, strLine, delimiter))\n        {\n            lineSize = strLine.size();\n            if(lineSize && strLine[lineSize - 1] == '\\r') //remove line break\n                strLine.erase(--lineSize);\n            if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) //empty lines and comments are ignored\n                continue;\n            result.emplace_back(std::move(strLine));\n            itemCount++;\n        }\n        ss.clear();\n    }\n    target.swap(result);\n    writeLog(0, \"Imported \" + std::to_string(itemCount) + \" item(s).\");\n    return 0;\n}\n\ntoml::value parseToml(const std::string &content, const std::string &fname)\n{\n    std::istringstream is(content);\n    return toml::parse(is, fname);\n}\n\nvoid importItems(std::vector<toml::value> &root, const std::string &import_key, bool scope_limit = true)\n{\n    std::string content;\n    std::vector<toml::value> newRoot;\n    auto iter = root.begin();\n    size_t count = 0;\n\n    std::string proxy = parseProxy(global.proxyConfig);\n    while(iter != root.end())\n    {\n        auto& table = iter->as_table();\n        if(table.find(\"import\") == table.end())\n            newRoot.emplace_back(std::move(*iter));\n        else\n        {\n            const std::string &path = toml::get<std::string>(table.at(\"import\"));\n            writeLog(0, \"Trying to import items from \" + path);\n            if(fileExist(path))\n                content = fileGet(path, scope_limit);\n            else if(isLink(path))\n                content = webGet(path, proxy, global.cacheConfig);\n            else\n                writeLog(0, \"File not found or not a valid URL: \" + path, LOG_LEVEL_ERROR);\n            if(content.size())\n            {\n                auto items = parseToml(content, path);\n                auto list = toml::find<std::vector<toml::value>>(items, import_key);\n                count += list.size();\n                std::move(list.begin(), list.end(), std::back_inserter(newRoot));\n            }\n        }\n        iter++;\n    }\n    root.swap(newRoot);\n    writeLog(0, \"Imported \" + std::to_string(count) + \" item(s).\");\n    return;\n}\n\nvoid readRegexMatch(YAML::Node node, const std::string &delimiter, string_array &dest, bool scope_limit = true)\n{\n    YAML::Node object;\n    std::string script, url, match, rep, strLine;\n\n    for(unsigned i = 0; i < node.size(); i++)\n    {\n        object = node[i];\n        object[\"script\"] >>= script;\n        if(script.size())\n        {\n            dest.emplace_back(\"!!script:\" + script);\n            continue;\n        }\n        object[\"import\"] >>= url;\n        if(url.size())\n        {\n            dest.emplace_back(\"!!import:\" + url);\n            continue;\n        }\n        object[\"match\"] >>= match;\n        object[\"replace\"] >>= rep;\n        if(match.size() && rep.size())\n            strLine = match + delimiter + rep;\n        else\n            continue;\n        dest.emplace_back(std::move(strLine));\n    }\n    importItems(dest, scope_limit);\n}\n\nvoid readEmoji(YAML::Node node, string_array &dest, bool scope_limit = true)\n{\n    YAML::Node object;\n    std::string script, url, match, rep, strLine;\n\n    for(unsigned i = 0; i < node.size(); i++)\n    {\n        object = node[i];\n        object[\"script\"] >>= script;\n        if(script.size())\n        {\n            dest.emplace_back(\"!!script:\" + script);\n            continue;\n        }\n        object[\"import\"] >>= url;\n        if(url.size())\n        {\n            url = \"!!import:\" + url;\n            dest.emplace_back(url);\n            continue;\n        }\n        object[\"match\"] >>= match;\n        object[\"emoji\"] >>= rep;\n        if(match.size() && rep.size())\n            strLine = match + \",\" + rep;\n        else\n            continue;\n        dest.emplace_back(std::move(strLine));\n    }\n    importItems(dest, scope_limit);\n}\n\nvoid readGroup(YAML::Node node, string_array &dest, bool scope_limit = true)\n{\n    std::string strLine, name, type;\n    string_array tempArray;\n    YAML::Node object;\n    unsigned int i, j;\n\n    for(i = 0; i < node.size(); i++)\n    {\n        eraseElements(tempArray);\n        object = node[i];\n        object[\"import\"] >>= name;\n        if(name.size())\n        {\n            dest.emplace_back(\"!!import:\" + name);\n            continue;\n        }\n        std::string url = \"http://www.gstatic.com/generate_204\", interval = \"300\", tolerance, timeout;\n        object[\"name\"] >>= name;\n        object[\"type\"] >>= type;\n        tempArray.emplace_back(name);\n        tempArray.emplace_back(type);\n        object[\"url\"] >>= url;\n        object[\"interval\"] >>= interval;\n        object[\"tolerance\"] >>= tolerance;\n        object[\"timeout\"] >>= timeout;\n        for(j = 0; j < object[\"rule\"].size(); j++)\n            tempArray.emplace_back(safe_as<std::string>(object[\"rule\"][j]));\n        switch(hash_(type))\n        {\n        case \"select\"_hash:\n            if(tempArray.size() < 3)\n                continue;\n            break;\n        case \"ssid\"_hash:\n            if(tempArray.size() < 4)\n                continue;\n            break;\n        default:\n            if(tempArray.size() < 3)\n                continue;\n            tempArray.emplace_back(url);\n            tempArray.emplace_back(interval + \",\" + timeout + \",\" + tolerance);\n        }\n\n        strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b) -> std::string\n        {\n            return std::move(a) + \"`\" + std::move(b);\n        });\n        dest.emplace_back(std::move(strLine));\n    }\n    importItems(dest, scope_limit);\n}\n\nvoid readRuleset(YAML::Node node, string_array &dest, bool scope_limit = true)\n{\n    std::string strLine, name, url, group, interval;\n    YAML::Node object;\n\n    for(unsigned int i = 0; i < node.size(); i++)\n    {\n        object = node[i];\n        object[\"import\"] >>= name;\n        if(name.size())\n        {\n            dest.emplace_back(\"!!import:\" + name);\n            continue;\n        }\n        object[\"ruleset\"] >>= url;\n        object[\"group\"] >>= group;\n        object[\"rule\"] >>= name;\n        object[\"interval\"] >>= interval;\n        if(url.size())\n        {\n            strLine = group + \",\" + url;\n            if(interval.size())\n                strLine += \",\" + interval;\n        }\n        else if(name.size())\n            strLine = group + \",[]\" + name;\n        else\n            continue;\n        dest.emplace_back(std::move(strLine));\n    }\n    importItems(dest, scope_limit);\n}\n\nvoid refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array)\n{\n    eraseElements(ruleset_content_array);\n    std::string rule_group, rule_url, rule_url_typed, interval;\n    RulesetContent rc;\n\n    std::string proxy = parseProxy(global.proxyRuleset);\n\n    for(RulesetConfig &x : ruleset_list)\n    {\n        rule_group = x.Group;\n        rule_url = x.Url;\n        std::string::size_type pos = x.Url.find(\"[]\");\n        if(pos != std::string::npos)\n        {\n            writeLog(0, \"Adding rule '\" + rule_url.substr(pos + 2) + \",\" + rule_group + \"'.\", LOG_LEVEL_INFO);\n            rc = {rule_group, \"\", \"\", RULESET_SURGE, std::async(std::launch::async, [=](){return rule_url.substr(pos);}), 0};\n        }\n        else\n        {\n            ruleset_type type = RULESET_SURGE;\n            rule_url_typed = rule_url;\n            auto iter = std::find_if(RulesetTypes.begin(), RulesetTypes.end(), [rule_url](auto y){ return startsWith(rule_url, y.first); });\n            if(iter != RulesetTypes.end())\n            {\n                rule_url.erase(0, iter->first.size());\n                type = iter->second;\n            }\n            writeLog(0, \"Updating ruleset url '\" + rule_url + \"' with group '\" + rule_group + \"'.\", LOG_LEVEL_INFO);\n            rc = {rule_group, rule_url, rule_url_typed, type, fetchFileAsync(rule_url, proxy, global.cacheRuleset, global.asyncFetchRuleset), x.Interval};\n        }\n        ruleset_content_array.emplace_back(std::move(rc));\n    }\n    ruleset_content_array.shrink_to_fit();\n}\n\nvoid readYAMLConf(YAML::Node &node)\n{\n    YAML::Node section = node[\"common\"];\n    std::string strLine;\n    string_array tempArray;\n\n    section[\"api_mode\"] >> global.APIMode;\n    section[\"api_access_token\"] >> global.accessToken;\n    if(section[\"default_url\"].IsSequence())\n    {\n        section[\"default_url\"] >> tempArray;\n        if(tempArray.size())\n        {\n            strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)\n            {\n                return std::move(a) + \"|\" + std::move(b);\n            });\n            global.defaultUrls = strLine;\n            eraseElements(tempArray);\n        }\n    }\n    global.enableInsert = safe_as<std::string>(section[\"enable_insert\"]);\n    if(section[\"insert_url\"].IsSequence())\n    {\n        section[\"insert_url\"] >> tempArray;\n        if(tempArray.size())\n        {\n            strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)\n            {\n                return std::move(a) + \"|\" + std::move(b);\n            });\n            global.insertUrls = strLine;\n            eraseElements(tempArray);\n        }\n    }\n    section[\"prepend_insert_url\"] >> global.prependInsert;\n    if(section[\"exclude_remarks\"].IsSequence())\n        section[\"exclude_remarks\"] >> global.excludeRemarks;\n    if(section[\"include_remarks\"].IsSequence())\n        section[\"include_remarks\"] >> global.includeRemarks;\n    global.filterScript = safe_as<bool>(section[\"enable_filter\"]) ? safe_as<std::string>(section[\"filter_script\"]) : \"\";\n    section[\"base_path\"] >> global.basePath;\n    section[\"clash_rule_base\"] >> global.clashBase;\n    section[\"surge_rule_base\"] >> global.surgeBase;\n    section[\"surfboard_rule_base\"] >> global.surfboardBase;\n    section[\"mellow_rule_base\"] >> global.mellowBase;\n    section[\"quan_rule_base\"] >> global.quanBase;\n    section[\"quanx_rule_base\"] >> global.quanXBase;\n    section[\"loon_rule_base\"] >> global.loonBase;\n    section[\"sssub_rule_base\"] >> global.SSSubBase;\n\n    section[\"default_external_config\"] >> global.defaultExtConfig;\n    section[\"append_proxy_type\"] >> global.appendType;\n    section[\"proxy_config\"] >> global.proxyConfig;\n    section[\"proxy_ruleset\"] >> global.proxyRuleset;\n    section[\"proxy_subscription\"] >> global.proxySubscription;\n\n    if(node[\"userinfo\"].IsDefined())\n    {\n        section = node[\"userinfo\"];\n        if(section[\"stream_rule\"].IsSequence())\n        {\n            readRegexMatch(section[\"stream_rule\"], \"|\", tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_streams(configs);\n            eraseElements(tempArray);\n        }\n        if(section[\"time_rule\"].IsSequence())\n        {\n            readRegexMatch(section[\"time_rule\"], \"|\", tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_times(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    if(node[\"node_pref\"].IsDefined())\n    {\n        section = node[\"node_pref\"];\n        /*\n        section[\"udp_flag\"] >> udp_flag;\n        section[\"tcp_fast_open_flag\"] >> tfo_flag;\n        section[\"skip_cert_verify_flag\"] >> scv_flag;\n        */\n        global.UDPFlag.set(safe_as<std::string>(section[\"udp_flag\"]));\n        global.TFOFlag.set(safe_as<std::string>(section[\"tcp_fast_open_flag\"]));\n        global.skipCertVerify.set(safe_as<std::string>(section[\"skip_cert_verify_flag\"]));\n        global.TLS13Flag.set(safe_as<std::string>(section[\"tls13_flag\"]));\n        section[\"sort_flag\"] >> global.enableSort;\n        section[\"sort_script\"] >> global.sortScript;\n        section[\"filter_deprecated_nodes\"] >> global.filterDeprecated;\n        section[\"append_sub_userinfo\"] >> global.appendUserinfo;\n        section[\"clash_use_new_field_name\"] >> global.clashUseNewField;\n        section[\"clash_proxies_style\"] >> global.clashProxiesStyle;\n    }\n\n    if(section[\"rename_node\"].IsSequence())\n    {\n        readRegexMatch(section[\"rename_node\"], \"@\", tempArray, false);\n        auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"@\");\n        safe_set_renames(configs);\n        eraseElements(tempArray);\n    }\n\n    if(node[\"managed_config\"].IsDefined())\n    {\n        section = node[\"managed_config\"];\n        section[\"write_managed_config\"] >> global.writeManagedConfig;\n        section[\"managed_config_prefix\"] >> global.managedConfigPrefix;\n        section[\"config_update_interval\"] >> global.updateInterval;\n        section[\"config_update_strict\"] >> global.updateStrict;\n        section[\"quanx_device_id\"] >> global.quanXDevID;\n    }\n\n    if(node[\"surge_external_proxy\"].IsDefined())\n    {\n        node[\"surge_external_proxy\"][\"surge_ssr_path\"] >> global.surgeSSRPath;\n        node[\"surge_external_proxy\"][\"resolve_hostname\"] >> global.surgeResolveHostname;\n    }\n\n    if(node[\"emojis\"].IsDefined())\n    {\n        section = node[\"emojis\"];\n        section[\"add_emoji\"] >> global.addEmoji;\n        section[\"remove_old_emoji\"] >> global.removeEmoji;\n        if(section[\"rules\"].IsSequence())\n        {\n            readEmoji(section[\"rules\"], tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \",\");\n            safe_set_emojis(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    const char *rulesets_title = node[\"rulesets\"].IsDefined() ? \"rulesets\" : \"ruleset\";\n    if(node[rulesets_title].IsDefined())\n    {\n        section = node[rulesets_title];\n        section[\"enabled\"] >> global.enableRuleGen;\n        if(!global.enableRuleGen)\n        {\n            global.overwriteOriginalRules = false;\n            global.updateRulesetOnRequest = false;\n        }\n        else\n        {\n            section[\"overwrite_original_rules\"] >> global.overwriteOriginalRules;\n            section[\"update_ruleset_on_request\"] >> global.updateRulesetOnRequest;\n        }\n        const char *ruleset_title = section[\"rulesets\"].IsDefined() ? \"rulesets\" : \"surge_ruleset\";\n        if(section[ruleset_title].IsSequence())\n        {\n            string_array vArray;\n            readRuleset(section[ruleset_title], vArray, false);\n            global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n        }\n    }\n\n    const char *groups_title = node[\"proxy_groups\"].IsDefined() ? \"proxy_groups\" : \"proxy_group\";\n    if(node[groups_title].IsDefined() && node[groups_title][\"custom_proxy_group\"].IsDefined())\n    {\n        string_array vArray;\n        readGroup(node[groups_title][\"custom_proxy_group\"], vArray, false);\n        global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n\n    if(node[\"template\"].IsDefined())\n    {\n        node[\"template\"][\"template_path\"] >> global.templatePath;\n        if(node[\"template\"][\"globals\"].IsSequence())\n        {\n            eraseElements(global.templateVars);\n            for(size_t i = 0; i < node[\"template\"][\"globals\"].size(); i++)\n            {\n                std::string key, value;\n                node[\"template\"][\"globals\"][i][\"key\"] >> key;\n                node[\"template\"][\"globals\"][i][\"value\"] >> value;\n                global.templateVars[key] = value;\n            }\n        }\n    }\n\n    if(node[\"aliases\"].IsSequence())\n    {\n        webServer.reset_redirect();\n        for(size_t i = 0; i < node[\"aliases\"].size(); i++)\n        {\n            std::string uri, target;\n            node[\"aliases\"][i][\"uri\"] >> uri;\n            node[\"aliases\"][i][\"target\"] >> target;\n            webServer.append_redirect(uri, target);\n        }\n    }\n\n    if(node[\"tasks\"].IsSequence())\n    {\n        string_array vArray;\n        for(size_t i = 0; i < node[\"tasks\"].size(); i++)\n        {\n            std::string name, exp, path, timeout;\n            node[\"tasks\"][i][\"import\"] >> name;\n            if(name.size())\n            {\n                vArray.emplace_back(\"!!import:\" + name);\n                continue;\n            }\n            node[\"tasks\"][i][\"name\"] >> name;\n            node[\"tasks\"][i][\"cronexp\"] >> exp;\n            node[\"tasks\"][i][\"path\"] >> path;\n            node[\"tasks\"][i][\"timeout\"] >> timeout;\n            strLine = name + \"`\" + exp + \"`\" + path + \"`\" + timeout;\n            vArray.emplace_back(std::move(strLine));\n        }\n        importItems(vArray, false);\n        global.enableCron = !vArray.empty();\n        global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);\n        refresh_schedule();\n    }\n\n    if(node[\"server\"].IsDefined())\n    {\n        node[\"server\"][\"listen\"] >> global.listenAddress;\n        node[\"server\"][\"port\"] >> global.listenPort;\n        node[\"server\"][\"serve_file_root\"] >>= webServer.serve_file_root;\n        webServer.serve_file = !webServer.serve_file_root.empty();\n    }\n\n    if(node[\"advanced\"].IsDefined())\n    {\n        std::string log_level;\n        node[\"advanced\"][\"log_level\"] >> log_level;\n        node[\"advanced\"][\"print_debug_info\"] >> global.printDbgInfo;\n        if(global.printDbgInfo)\n            global.logLevel = LOG_LEVEL_VERBOSE;\n        else\n        {\n            switch(hash_(log_level))\n            {\n            case \"warn\"_hash:\n                global.logLevel = LOG_LEVEL_WARNING;\n                break;\n            case \"error\"_hash:\n                global.logLevel = LOG_LEVEL_ERROR;\n                break;\n            case \"fatal\"_hash:\n                global.logLevel = LOG_LEVEL_FATAL;\n                break;\n            case \"verbose\"_hash:\n                global.logLevel = LOG_LEVEL_VERBOSE;\n                break;\n            case \"debug\"_hash:\n                global.logLevel = LOG_LEVEL_DEBUG;\n                break;\n            default:\n                global.logLevel = LOG_LEVEL_INFO;\n            }\n        }\n        node[\"advanced\"][\"max_pending_connections\"] >> global.maxPendingConns;\n        node[\"advanced\"][\"max_concurrent_threads\"] >> global.maxConcurThreads;\n        node[\"advanced\"][\"max_allowed_rulesets\"] >> global.maxAllowedRulesets;\n        node[\"advanced\"][\"max_allowed_rules\"] >> global.maxAllowedRules;\n        node[\"advanced\"][\"max_allowed_download_size\"] >> global.maxAllowedDownloadSize;\n        if(node[\"advanced\"][\"enable_cache\"].IsDefined())\n        {\n            if(safe_as<bool>(node[\"advanced\"][\"enable_cache\"]))\n            {\n                node[\"advanced\"][\"cache_subscription\"] >> global.cacheSubscription;\n                node[\"advanced\"][\"cache_config\"] >> global.cacheConfig;\n                node[\"advanced\"][\"cache_ruleset\"] >> global.cacheRuleset;\n                node[\"advanced\"][\"serve_cache_on_fetch_fail\"] >> global.serveCacheOnFetchFail;\n            }\n            else\n                global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; //disable cache\n        }\n        node[\"advanced\"][\"script_clean_context\"] >> global.scriptCleanContext;\n        node[\"advanced\"][\"async_fetch_ruleset\"] >> global.asyncFetchRuleset;\n        node[\"advanced\"][\"skip_failed_links\"] >> global.skipFailedLinks;\n    }\n}\n\ntemplate <class T, class... U>\nvoid find_if_exist(const toml::value &v, const toml::key &k, T& target, U&&... args)\n{\n    if(v.contains(k)) target = toml::find<T>(v, k);\n    if constexpr (sizeof...(args) > 0) find_if_exist(v, std::forward<U>(args)...);\n}\n\nvoid operate_toml_kv_table(const std::vector<toml::table> &arr, const toml::key &key_name, const toml::key &value_name, std::function<void (const toml::value&, const toml::value&)> binary_op)\n{\n    for(const toml::table &table : arr)\n    {\n        const auto &key = table.at(key_name), value = table.at(value_name);\n        binary_op(key, value);\n    }\n}\n\nvoid readTOMLConf(toml::value &root)\n{\n    const auto &section_common = toml::find(root, \"common\");\n    string_array default_url, insert_url;\n\n    find_if_exist(section_common, \"default_url\", default_url, \"insert_url\", insert_url);\n    global.defaultUrls = join(default_url, \"|\");\n    global.insertUrls = join(insert_url, \"|\");\n\n    bool filter = false;\n    find_if_exist(section_common,\n                  \"api_mode\", global.APIMode,\n                  \"api_access_token\", global.accessToken,\n                  \"exclude_remarks\", global.excludeRemarks,\n                  \"include_remarks\", global.includeRemarks,\n                  \"enable_insert\", global.enableInsert,\n                  \"prepend_insert_url\", global.prependInsert,\n                  \"enable_filter\", filter,\n                  \"default_external_config\", global.defaultExtConfig,\n                  \"base_path\", global.basePath,\n                  \"clash_rule_base\", global.clashBase,\n                  \"surge_rule_base\", global.surgeBase,\n                  \"surfboard_rule_base\", global.surfboardBase,\n                  \"mellow_rule_base\", global.mellowBase,\n                  \"quan_rule_base\", global.quanBase,\n                  \"quanx_rule_base\", global.quanXBase,\n                  \"loon_rule_base\", global.loonBase,\n                  \"proxy_config\", global.proxyConfig,\n                  \"proxy_ruleset\", global.proxyRuleset,\n                  \"proxy_subscription\", global.proxySubscription,\n                  \"append_proxy_type\", global.appendType\n    );\n\n    if(filter)\n        find_if_exist(section_common, \"filter_script\", global.filterScript);\n    else\n        global.filterScript.clear();\n\n    safe_set_streams(toml::find_or<RegexMatchConfigs>(root, \"userinfo\", \"stream_rule\", RegexMatchConfigs{}));\n    safe_set_times(toml::find_or<RegexMatchConfigs>(root, \"userinfo\", \"time_rule\", RegexMatchConfigs{}));\n\n    const auto &section_node_pref = toml::find(root, \"node_pref\");\n\n    find_if_exist(section_node_pref,\n                  \"udp_flag\", global.UDPFlag,\n                  \"tcp_fast_open_flag\", global.TFOFlag,\n                  \"skip_cert_verify_flag\", global.skipCertVerify,\n                  \"tls13_flag\", global.TLS13Flag,\n                  \"sort_flag\", global.enableSort,\n                  \"sort_script\", global.sortScript,\n                  \"filter_deprecated_nodes\", global.filterDeprecated,\n                  \"append_sub_userinfo\", global.appendUserinfo,\n                  \"clash_use_new_field_name\", global.clashUseNewField,\n                  \"clash_proxies_style\", global.clashProxiesStyle\n    );\n\n    auto renameconfs = toml::find_or<std::vector<toml::value>>(section_node_pref, \"rename_node\", {});\n    importItems(renameconfs, \"rename_node\", false);\n    safe_set_renames(toml::get<RegexMatchConfigs>(toml::value(renameconfs)));\n\n    const auto &section_managed = toml::find(root, \"managed_config\");\n\n    find_if_exist(section_managed,\n                  \"write_managed_config\", global.writeManagedConfig,\n                  \"managed_config_prefix\", global.managedConfigPrefix,\n                  \"config_update_interval\", global.updateInterval,\n                  \"config_update_strict\", global.updateStrict,\n                  \"quanx_device_id\", global.quanXDevID\n    );\n\n    const auto &section_surge_external = toml::find(root, \"surge_external_proxy\");\n    find_if_exist(section_surge_external,\n                  \"surge_ssr_path\", global.surgeSSRPath,\n                  \"resolve_hostname\", global.surgeResolveHostname\n    );\n\n    const auto &section_emojis = toml::find(root, \"emojis\");\n\n    find_if_exist(section_emojis,\n                  \"add_emoji\", global.addEmoji,\n                  \"remove_old_emoji\", global.removeEmoji\n    );\n\n    auto emojiconfs = toml::find_or<std::vector<toml::value>>(section_emojis, \"emoji\", {});\n    importItems(emojiconfs, \"emoji\", false);\n    safe_set_emojis(toml::get<RegexMatchConfigs>(toml::value(emojiconfs)));\n\n    auto groups = toml::find_or<std::vector<toml::value>>(root, \"custom_groups\", {});\n    importItems(groups, \"custom_groups\", false);\n    global.customProxyGroups = toml::get<ProxyGroupConfigs>(toml::value(groups));\n\n    const auto &section_ruleset = toml::find(root, \"ruleset\");\n\n    find_if_exist(section_ruleset,\n                  \"enabled\", global.enableRuleGen,\n                  \"overwrite_original_rules\", global.overwriteOriginalRules,\n                  \"update_ruleset_on_request\", global.updateRulesetOnRequest\n    );\n\n    auto rulesets = toml::find_or<std::vector<toml::value>>(root, \"rulesets\", {});\n    importItems(rulesets, \"rulesets\", false);\n    global.customRulesets = toml::get<RulesetConfigs>(toml::value(rulesets));\n\n    const auto &section_template = toml::find(root, \"template\");\n\n    global.templatePath = toml::find_or(section_template, \"template_path\", \"template\");\n\n    eraseElements(global.templateVars);\n    operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section_template, \"globals\", {}), \"key\", \"value\", [&](const toml::value &key, const toml::value &value)\n    {\n        global.templateVars[key.as_string()] = value.as_string();\n    });\n\n    webServer.reset_redirect();\n    operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(root, \"aliases\", {}), \"uri\", \"target\", [&](const toml::value &key, const toml::value &value)\n    {\n        webServer.append_redirect(key.as_string(), value.as_string());\n    });\n\n    auto tasks = toml::find_or<std::vector<toml::value>>(root, \"tasks\", {});\n    importItems(tasks, \"tasks\", false);\n    global.cronTasks = toml::get<CronTaskConfigs>(toml::value(tasks));\n\n    const auto &section_server = toml::find(root, \"server\");\n\n    find_if_exist(section_server,\n                  \"listen\", global.listenAddress,\n                  \"port\", global.listenPort,\n                  \"serve_file_root\", webServer.serve_file_root\n    );\n    webServer.serve_file = !webServer.serve_file_root.empty();\n\n    const auto &section_advanced = toml::find(root, \"advanced\");\n\n    std::string log_level;\n    bool enable_cache = true;\n    int cache_subscription = global.cacheSubscription, cache_config = global.cacheConfig, cache_ruleset = global.cacheRuleset;\n\n    find_if_exist(section_advanced,\n                  \"log_level\", log_level,\n                  \"print_debug_info\", global.printDbgInfo,\n                  \"max_pending_connections\", global.maxPendingConns,\n                  \"max_concurrent_threads\", global.maxConcurThreads,\n                  \"max_allowed_rulesets\", global.maxAllowedRulesets,\n                  \"max_allowed_rules\", global.maxAllowedRules,\n                  \"max_allowed_download_size\", global.maxAllowedDownloadSize,\n                  \"enable_cache\", enable_cache,\n                  \"cache_subscription\", cache_subscription,\n                  \"cache_config\", cache_config,\n                  \"cache_ruleset\", cache_ruleset,\n                  \"script_clean_context\", global.scriptCleanContext,\n                  \"async_fetch_ruleset\", global.asyncFetchRuleset,\n                  \"skip_failed_links\", global.skipFailedLinks\n    );\n\n    if(global.printDbgInfo)\n        global.logLevel = LOG_LEVEL_VERBOSE;\n    else\n    {\n        switch(hash_(log_level))\n        {\n        case \"warn\"_hash:\n            global.logLevel = LOG_LEVEL_WARNING;\n            break;\n        case \"error\"_hash:\n            global.logLevel = LOG_LEVEL_ERROR;\n            break;\n        case \"fatal\"_hash:\n            global.logLevel = LOG_LEVEL_FATAL;\n            break;\n        case \"verbose\"_hash:\n            global.logLevel = LOG_LEVEL_VERBOSE;\n            break;\n        case \"debug\"_hash:\n            global.logLevel = LOG_LEVEL_DEBUG;\n            break;\n        default:\n            global.logLevel = LOG_LEVEL_INFO;\n        }\n    }\n\n    if(enable_cache)\n    {\n        global.cacheSubscription = cache_subscription;\n        global.cacheConfig = cache_config;\n        global.cacheRuleset = cache_ruleset;\n    }\n    else\n    {\n        global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;\n    }\n}\n\nvoid readConf()\n{\n    guarded_mutex guard(gMutexConfigure);\n    //std::cerr<<\"Reading preference settings...\"<<std::endl;\n    writeLog(0, \"Reading preference settings...\", LOG_LEVEL_INFO);\n\n    eraseElements(global.excludeRemarks);\n    eraseElements(global.includeRemarks);\n    eraseElements(global.customProxyGroups);\n    eraseElements(global.customRulesets);\n\n    try\n    {\n        std::string prefdata = fileGet(global.prefPath, false);\n        if(prefdata.find(\"common:\") != prefdata.npos)\n        {\n            YAML::Node yaml = YAML::Load(prefdata);\n            if(yaml.size() && yaml[\"common\"])\n                return readYAMLConf(yaml);\n        }\n        toml::value conf = parseToml(prefdata, global.prefPath);\n        if(!conf.is_uninitialized() && toml::find_or<int>(conf, \"version\", 0))\n            return readTOMLConf(conf);\n    }\n    catch (YAML::Exception &e)\n    {\n        //ignore yaml parse error\n    }\n    catch (toml::exception &e)\n    {\n        //ignore toml parse error\n        writeLog(0, e.what(), LOG_LEVEL_DEBUG);\n    }\n\n    INIReader ini;\n    ini.allow_dup_section_titles = true;\n    //ini.do_utf8_to_gbk = true;\n    int retVal = ini.ParseFile(global.prefPath);\n    if(retVal != INIREADER_EXCEPTION_NONE)\n    {\n        //std::cerr<<\"Unable to load preference settings. Reason: \"<<ini.GetLastError()<<\"\\n\";\n        writeLog(0, \"Unable to load preference settings. Reason: \" + ini.GetLastError(), LOG_LEVEL_FATAL);\n        return;\n    }\n\n    string_array tempArray;\n\n    ini.EnterSection(\"common\");\n    ini.GetBoolIfExist(\"api_mode\", global.APIMode);\n    ini.GetIfExist(\"api_access_token\", global.accessToken);\n    ini.GetIfExist(\"default_url\", global.defaultUrls);\n    global.enableInsert = ini.Get(\"enable_insert\");\n    ini.GetIfExist(\"insert_url\", global.insertUrls);\n    ini.GetBoolIfExist(\"prepend_insert_url\", global.prependInsert);\n    if(ini.ItemPrefixExist(\"exclude_remarks\"))\n        ini.GetAll(\"exclude_remarks\", global.excludeRemarks);\n    if(ini.ItemPrefixExist(\"include_remarks\"))\n        ini.GetAll(\"include_remarks\", global.includeRemarks);\n    global.filterScript = ini.GetBool(\"enable_filter\") ? ini.Get(\"filter_script\"): \"\";\n    ini.GetIfExist(\"base_path\", global.basePath);\n    ini.GetIfExist(\"clash_rule_base\", global.clashBase);\n    ini.GetIfExist(\"surge_rule_base\", global.surgeBase);\n    ini.GetIfExist(\"surfboard_rule_base\", global.surfboardBase);\n    ini.GetIfExist(\"mellow_rule_base\", global.mellowBase);\n    ini.GetIfExist(\"quan_rule_base\", global.quanBase);\n    ini.GetIfExist(\"quanx_rule_base\", global.quanXBase);\n    ini.GetIfExist(\"loon_rule_base\", global.loonBase);\n    ini.GetIfExist(\"default_external_config\", global.defaultExtConfig);\n    ini.GetBoolIfExist(\"append_proxy_type\", global.appendType);\n    ini.GetIfExist(\"proxy_config\", global.proxyConfig);\n    ini.GetIfExist(\"proxy_ruleset\", global.proxyRuleset);\n    ini.GetIfExist(\"proxy_subscription\", global.proxySubscription);\n\n    if(ini.SectionExist(\"surge_external_proxy\"))\n    {\n        ini.EnterSection(\"surge_external_proxy\");\n        ini.GetIfExist(\"surge_ssr_path\", global.surgeSSRPath);\n        ini.GetBoolIfExist(\"resolve_hostname\", global.surgeResolveHostname);\n    }\n\n    if(ini.SectionExist(\"node_pref\"))\n    {\n        ini.EnterSection(\"node_pref\");\n        /*\n        ini.GetBoolIfExist(\"udp_flag\", udp_flag);\n        ini.GetBoolIfExist(\"tcp_fast_open_flag\", tfo_flag);\n        ini.GetBoolIfExist(\"skip_cert_verify_flag\", scv_flag);\n        */\n        global.UDPFlag.set(ini.Get(\"udp_flag\"));\n        global.TFOFlag.set(ini.Get(\"tcp_fast_open_flag\"));\n        global.skipCertVerify.set(ini.Get(\"skip_cert_verify_flag\"));\n        global.TLS13Flag.set(ini.Get(\"tls13_flag\"));\n        ini.GetBoolIfExist(\"sort_flag\", global.enableSort);\n        global.sortScript = ini.Get(\"sort_script\");\n        ini.GetBoolIfExist(\"filter_deprecated_nodes\", global.filterDeprecated);\n        ini.GetBoolIfExist(\"append_sub_userinfo\", global.appendUserinfo);\n        ini.GetBoolIfExist(\"clash_use_new_field_name\", global.clashUseNewField);\n        ini.GetIfExist(\"clash_proxies_style\", global.clashProxiesStyle);\n        if(ini.ItemPrefixExist(\"rename_node\"))\n        {\n            ini.GetAll(\"rename_node\", tempArray);\n            importItems(tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"@\");\n            safe_set_renames(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    if(ini.SectionExist(\"userinfo\"))\n    {\n        ini.EnterSection(\"userinfo\");\n        if(ini.ItemPrefixExist(\"stream_rule\"))\n        {\n            ini.GetAll(\"stream_rule\", tempArray);\n            importItems(tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_streams(configs);\n            eraseElements(tempArray);\n        }\n        if(ini.ItemPrefixExist(\"time_rule\"))\n        {\n            ini.GetAll(\"time_rule\", tempArray);\n            importItems(tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_times(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    ini.EnterSection(\"managed_config\");\n    ini.GetBoolIfExist(\"write_managed_config\", global.writeManagedConfig);\n    ini.GetIfExist(\"managed_config_prefix\", global.managedConfigPrefix);\n    ini.GetIntIfExist(\"config_update_interval\", global.updateInterval);\n    ini.GetBoolIfExist(\"config_update_strict\", global.updateStrict);\n    ini.GetIfExist(\"quanx_device_id\", global.quanXDevID);\n\n    ini.EnterSection(\"emojis\");\n    ini.GetBoolIfExist(\"add_emoji\", global.addEmoji);\n    ini.GetBoolIfExist(\"remove_old_emoji\", global.removeEmoji);\n    if(ini.ItemPrefixExist(\"rule\"))\n    {\n        ini.GetAll(\"rule\", tempArray);\n        importItems(tempArray, false);\n        auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \",\");\n        safe_set_emojis(configs);\n        eraseElements(tempArray);\n    }\n\n    if(ini.SectionExist(\"rulesets\"))\n        ini.EnterSection(\"rulesets\");\n    else\n        ini.EnterSection(\"ruleset\");\n    global.enableRuleGen = ini.GetBool(\"enabled\");\n    if(global.enableRuleGen)\n    {\n        ini.GetBoolIfExist(\"overwrite_original_rules\", global.overwriteOriginalRules);\n        ini.GetBoolIfExist(\"update_ruleset_on_request\", global.updateRulesetOnRequest);\n        if(ini.ItemPrefixExist(\"ruleset\"))\n        {\n            string_array vArray;\n            ini.GetAll(\"ruleset\", vArray);\n            importItems(vArray, false);\n            global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n        }\n        else if(ini.ItemPrefixExist(\"surge_ruleset\"))\n        {\n            string_array vArray;\n            ini.GetAll(\"surge_ruleset\", vArray);\n            importItems(vArray, false);\n            global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n        }\n    }\n    else\n    {\n        global.overwriteOriginalRules = false;\n        global.updateRulesetOnRequest = false;\n    }\n\n    if(ini.SectionExist(\"proxy_groups\"))\n        ini.EnterSection(\"proxy_groups\");\n    else\n        ini.EnterSection(\"clash_proxy_group\");\n    if(ini.ItemPrefixExist(\"custom_proxy_group\"))\n    {\n        string_array vArray;\n        ini.GetAll(\"custom_proxy_group\", vArray);\n        importItems(vArray, false);\n        global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n\n    ini.EnterSection(\"template\");\n    ini.GetIfExist(\"template_path\", global.templatePath);\n    string_multimap tempmap;\n    ini.GetItems(tempmap);\n    eraseElements(global.templateVars);\n    for(auto &x : tempmap)\n    {\n        if(x.first == \"template_path\")\n            continue;\n        global.templateVars[x.first] = x.second;\n    }\n    global.templateVars[\"managed_config_prefix\"] = global.managedConfigPrefix;\n\n    if(ini.SectionExist(\"aliases\"))\n    {\n        ini.EnterSection(\"aliases\");\n        ini.GetItems(tempmap);\n        webServer.reset_redirect();\n        for(auto &x : tempmap)\n            webServer.append_redirect(x.first, x.second);\n    }\n\n    if(ini.SectionExist(\"tasks\"))\n    {\n        string_array vArray;\n        ini.EnterSection(\"tasks\");\n        ini.GetAll(\"task\", vArray);\n        importItems(vArray, false);\n        global.enableCron = !vArray.empty();\n        global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);\n        refresh_schedule();\n    }\n\n    ini.EnterSection(\"server\");\n    ini.GetIfExist(\"listen\", global.listenAddress);\n    ini.GetIntIfExist(\"port\", global.listenPort);\n    webServer.serve_file_root = ini.Get(\"serve_file_root\");\n    webServer.serve_file = !webServer.serve_file_root.empty();\n\n    ini.EnterSection(\"advanced\");\n    std::string log_level;\n    ini.GetIfExist(\"log_level\", log_level);\n    ini.GetBoolIfExist(\"print_debug_info\", global.printDbgInfo);\n    if(global.printDbgInfo)\n        global.logLevel = LOG_LEVEL_VERBOSE;\n    else\n    {\n        switch(hash_(log_level))\n        {\n        case \"warn\"_hash:\n            global.logLevel = LOG_LEVEL_WARNING;\n            break;\n        case \"error\"_hash:\n            global.logLevel = LOG_LEVEL_ERROR;\n            break;\n        case \"fatal\"_hash:\n            global.logLevel = LOG_LEVEL_FATAL;\n            break;\n        case \"verbose\"_hash:\n            global.logLevel = LOG_LEVEL_VERBOSE;\n            break;\n        case \"debug\"_hash:\n            global.logLevel = LOG_LEVEL_DEBUG;\n            break;\n        default:\n            global.logLevel = LOG_LEVEL_INFO;\n        }\n    }\n    ini.GetIntIfExist(\"max_pending_connections\", global.maxPendingConns);\n    ini.GetIntIfExist(\"max_concurrent_threads\", global.maxConcurThreads);\n    ini.GetNumberIfExist(\"max_allowed_rulesets\", global.maxAllowedRulesets);\n    ini.GetNumberIfExist(\"max_allowed_rules\", global.maxAllowedRules);\n    ini.GetNumberIfExist(\"max_allowed_download_size\", global.maxAllowedDownloadSize);\n    if(ini.ItemExist(\"enable_cache\"))\n    {\n        if(ini.GetBool(\"enable_cache\"))\n        {\n            ini.GetIntIfExist(\"cache_subscription\", global.cacheSubscription);\n            ini.GetIntIfExist(\"cache_config\", global.cacheConfig);\n            ini.GetIntIfExist(\"cache_ruleset\", global.cacheRuleset);\n            ini.GetBoolIfExist(\"serve_cache_on_fetch_fail\", global.serveCacheOnFetchFail);\n        }\n        else\n        {\n            global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; //disable cache\n            global.serveCacheOnFetchFail = false;\n        }\n    }\n    ini.GetBoolIfExist(\"script_clean_context\", global.scriptCleanContext);\n    ini.GetBoolIfExist(\"async_fetch_ruleset\", global.asyncFetchRuleset);\n    ini.GetBoolIfExist(\"skip_failed_links\", global.skipFailedLinks);\n\n    //std::cerr<<\"Read preference settings completed.\"<<std::endl;\n    writeLog(0, \"Read preference settings completed.\", LOG_LEVEL_INFO);\n}\n\nint loadExternalYAML(YAML::Node &node, ExternalConfig &ext)\n{\n    YAML::Node section = node[\"custom\"], object;\n    std::string name, type, url, interval;\n    std::string group, strLine;\n\n    section[\"clash_rule_base\"] >> ext.clash_rule_base;\n    section[\"surge_rule_base\"] >> ext.surge_rule_base;\n    section[\"surfboard_rule_base\"] >> ext.surfboard_rule_base;\n    section[\"mellow_rule_base\"] >> ext.mellow_rule_base;\n    section[\"quan_rule_base\"] >> ext.quan_rule_base;\n    section[\"quanx_rule_base\"] >> ext.quanx_rule_base;\n    section[\"loon_rule_base\"] >> ext.loon_rule_base;\n    section[\"sssub_rule_base\"] >> ext.sssub_rule_base;\n\n    section[\"enable_rule_generator\"] >> ext.enable_rule_generator;\n    section[\"overwrite_original_rules\"] >> ext.overwrite_original_rules;\n\n    const char *group_name = section[\"proxy_groups\"].IsDefined() ? \"proxy_groups\" : \"custom_proxy_group\";\n    if(section[group_name].size())\n    {\n        string_array vArray;\n        readGroup(section[group_name], vArray, global.APIMode);\n        ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n\n    const char *ruleset_name = section[\"rulesets\"].IsDefined() ? \"rulesets\" : \"surge_ruleset\";\n    if(section[ruleset_name].size())\n    {\n        string_array vArray;\n        readRuleset(section[ruleset_name], vArray, global.APIMode);\n        if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)\n        {\n            writeLog(0, \"Ruleset count in external config has exceeded limit.\", LOG_LEVEL_WARNING);\n            return -1;\n        }\n        ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);\n    }\n\n    if(section[\"rename_node\"].size())\n    {\n        string_array vArray;\n        readRegexMatch(section[\"rename_node\"], \"@\", vArray, global.APIMode);\n        ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, \"@\");\n    }\n\n    ext.add_emoji = safe_as<std::string>(section[\"add_emoji\"]);\n    ext.remove_old_emoji = safe_as<std::string>(section[\"remove_old_emoji\"]);\n    const char *emoji_name = section[\"emojis\"].IsDefined() ? \"emojis\" : \"emoji\";\n    if(section[emoji_name].size())\n    {\n        string_array vArray;\n        readEmoji(section[emoji_name], vArray, global.APIMode);\n        ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, \",\");\n    }\n\n    section[\"include_remarks\"] >> ext.include;\n    section[\"exclude_remarks\"] >> ext.exclude;\n\n    if(node[\"template_args\"].IsSequence() && ext.tpl_args != NULL)\n    {\n        std::string key, value;\n        for(size_t i = 0; i < node[\"template_args\"].size(); i++)\n        {\n            node[\"template_args\"][i][\"key\"] >> key;\n            node[\"template_args\"][i][\"value\"] >> value;\n            ext.tpl_args->local_vars[key] = value;\n        }\n    }\n\n    return 0;\n}\n\nint loadExternalTOML(toml::value &root, ExternalConfig &ext)\n{\n    const auto &section = toml::find(root, \"custom\");\n\n    find_if_exist(section,\n                  \"enable_rule_generator\", ext.enable_rule_generator,\n                  \"overwrite_original_rules\", ext.overwrite_original_rules,\n                  \"clash_rule_base\", ext.clash_rule_base,\n                  \"surge_rule_base\", ext.surge_rule_base,\n                  \"surfboard_rule_base\", ext.surfboard_rule_base,\n                  \"mellow_rule_base\", ext.mellow_rule_base,\n                  \"quan_rule_base\", ext.quan_rule_base,\n                  \"quanx_rule_base\", ext.quanx_rule_base,\n                  \"sssub_rule_base\", ext.sssub_rule_base,\n                  \"add_emoji\", ext.add_emoji,\n                  \"remove_old_emoji\", ext.remove_old_emoji,\n                  \"include_remarks\", ext.include,\n                  \"exclude_remarks\", ext.exclude\n    );\n\n    if(ext.tpl_args != nullptr) operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section, \"template_args\", {}), \"key\", \"value\",\n                                                      [&](const toml::value &key, const toml::value &value)\n    {\n        std::string val = toml::format(value);\n        ext.tpl_args->local_vars[key.as_string()] = val;\n    });\n\n    auto groups = toml::find_or<std::vector<toml::value>>(root, \"custom_groups\", {});\n    importItems(groups, \"custom_groups\", false);\n    ext.custom_proxy_group = toml::get<ProxyGroupConfigs>(toml::value(groups));\n\n    auto rulesets = toml::find_or<std::vector<toml::value>>(root, \"rulesets\", {});\n    importItems(rulesets, \"rulesets\", false);\n    if(global.maxAllowedRulesets && rulesets.size() > global.maxAllowedRulesets)\n    {\n        writeLog(0, \"Ruleset count in external config has exceeded limit. \", LOG_LEVEL_WARNING);\n        return -1;\n    }\n    ext.surge_ruleset = toml::get<RulesetConfigs>(toml::value(rulesets));\n\n    auto emojiconfs = toml::find_or<std::vector<toml::value>>(root, \"emoji\", {});\n    importItems(emojiconfs, \"emoji\", false);\n    ext.emoji = toml::get<RegexMatchConfigs>(toml::value(emojiconfs));\n\n    auto renameconfs = toml::find_or<std::vector<toml::value>>(root, \"rename_node\", {});\n    importItems(renameconfs, \"rename_node\", false);\n    ext.rename = toml::get<RegexMatchConfigs>(toml::value(renameconfs));\n\n    return 0;\n}\n\nint loadExternalConfig(std::string &path, ExternalConfig &ext)\n{\n    std::string base_content, proxy = parseProxy(global.proxyConfig), config = fetchFile(path, proxy, global.cacheConfig);\n    if(render_template(config, *ext.tpl_args, base_content, global.templatePath) != 0)\n        base_content = config;\n\n    try\n    {\n        YAML::Node yaml = YAML::Load(base_content);\n        if(yaml.size() && yaml[\"custom\"].IsDefined())\n            return loadExternalYAML(yaml, ext);\n        toml::value conf = parseToml(base_content, path);\n        if(!conf.is_uninitialized() && toml::find_or<int>(conf, \"version\", 0))\n            return loadExternalTOML(conf, ext);\n    }\n    catch (YAML::Exception &e)\n    {\n        //ignore\n    }\n    catch (toml::exception &e)\n    {\n        //ignore\n    }\n\n    INIReader ini;\n    ini.store_isolated_line = true;\n    ini.SetIsolatedItemsSection(\"custom\");\n    if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)\n    {\n        //std::cerr<<\"Load external configuration failed. Reason: \"<<ini.GetLastError()<<\"\\n\";\n        writeLog(0, \"Load external configuration failed. Reason: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return -1;\n    }\n\n    ini.EnterSection(\"custom\");\n    if(ini.ItemPrefixExist(\"custom_proxy_group\"))\n    {\n        string_array vArray;\n        ini.GetAll(\"custom_proxy_group\", vArray);\n        importItems(vArray, global.APIMode);\n        ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n    std::string ruleset_name = ini.ItemPrefixExist(\"ruleset\") ? \"ruleset\" : \"surge_ruleset\";\n    if(ini.ItemPrefixExist(ruleset_name))\n    {\n        string_array vArray;\n        ini.GetAll(ruleset_name, vArray);\n        importItems(vArray, global.APIMode);\n        if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)\n        {\n            writeLog(0, \"Ruleset count in external config has exceeded limit. \", LOG_LEVEL_WARNING);\n            return -1;\n        }\n        ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);\n    }\n\n    ini.GetIfExist(\"clash_rule_base\", ext.clash_rule_base);\n    ini.GetIfExist(\"surge_rule_base\", ext.surge_rule_base);\n    ini.GetIfExist(\"surfboard_rule_base\", ext.surfboard_rule_base);\n    ini.GetIfExist(\"mellow_rule_base\", ext.mellow_rule_base);\n    ini.GetIfExist(\"quan_rule_base\", ext.quan_rule_base);\n    ini.GetIfExist(\"quanx_rule_base\", ext.quanx_rule_base);\n    ini.GetIfExist(\"loon_rule_base\", ext.loon_rule_base);\n    ini.GetIfExist(\"sssub_rule_base\", ext.sssub_rule_base);\n\n    ini.GetBoolIfExist(\"overwrite_original_rules\", ext.overwrite_original_rules);\n    ini.GetBoolIfExist(\"enable_rule_generator\", ext.enable_rule_generator);\n\n    if(ini.ItemPrefixExist(\"rename\"))\n    {\n        string_array vArray;\n        ini.GetAll(\"rename\", vArray);\n        importItems(vArray, global.APIMode);\n        ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, \"@\");\n    }\n    ext.add_emoji = ini.Get(\"add_emoji\");\n    ext.remove_old_emoji = ini.Get(\"remove_old_emoji\");\n    if(ini.ItemPrefixExist(\"emoji\"))\n    {\n        string_array vArray;\n        ini.GetAll(\"emoji\", vArray);\n        importItems(vArray, global.APIMode);\n        ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, \",\");\n    }\n    if(ini.ItemPrefixExist(\"include_remarks\"))\n        ini.GetAll(\"include_remarks\", ext.include);\n    if(ini.ItemPrefixExist(\"exclude_remarks\"))\n        ini.GetAll(\"exclude_remarks\", ext.exclude);\n\n    if(ini.SectionExist(\"template\") && ext.tpl_args != nullptr)\n    {\n        ini.EnterSection(\"template\");\n        string_multimap tempmap;\n        ini.GetItems(tempmap);\n        for(auto &x : tempmap)\n            ext.tpl_args->local_vars[x.first] = x.second;\n    }\n\n    return 0;\n}\n", "#ifndef SETTINGS_H_INCLUDED\n#define SETTINGS_H_INCLUDED\n\n#include <string>\n\n#include \"../config/crontask.h\"\n#include \"../config/regmatch.h\"\n#include \"../config/proxygroup.h\"\n#include \"../config/ruleset.h\"\n#include \"../generator/config/ruleconvert.h\"\n#include \"../generator/template/templates.h\"\n#include \"../utils/logger.h\"\n#include \"../utils/string.h\"\n#include \"../utils/stl_extra.h\"\n#include \"../utils/tribool.h\"\n\nstruct Settings\n{\n    //common settings\n    std::string prefPath = \"pref.ini\", defaultExtConfig;\n    string_array excludeRemarks, includeRemarks;\n    RulesetConfigs customRulesets;\n    RegexMatchConfigs streamNodeRules, timeNodeRules;\n    std::vector<RulesetContent> rulesetsContent;\n    std::string listenAddress = \"127.0.0.1\", defaultUrls, insertUrls, managedConfigPrefix;\n    int listenPort = 25500, maxPendingConns = 10, maxConcurThreads = 4;\n    bool prependInsert = true, skipFailedLinks = false;\n    bool APIMode = true, writeManagedConfig = false, enableRuleGen = true, updateRulesetOnRequest = false, overwriteOriginalRules = true;\n    bool printDbgInfo = false, CFWChildProcess = false, appendUserinfo = true, asyncFetchRuleset = false, surgeResolveHostname = true;\n    std::string accessToken, basePath = \"base\";\n    std::string custom_group;\n    int logLevel = LOG_LEVEL_INFO;\n    long maxAllowedDownloadSize = 1048576L;\n    string_map aliases;\n\n    //global variables for template\n    std::string templatePath = \"templates\";\n    string_map templateVars;\n\n    //generator settings\n    bool generatorMode = false;\n    std::string generateProfiles;\n\n    //preferences\n    RegexMatchConfigs renames, emojis;\n    bool addEmoji = false, removeEmoji = false, appendType = false, filterDeprecated = true;\n    tribool UDPFlag, TFOFlag, skipCertVerify, TLS13Flag, enableInsert;\n    bool enableSort = false, updateStrict = false;\n    bool clashUseNewField = false;\n    std::string clashProxiesStyle = \"flow\";\n    std::string proxyConfig, proxyRuleset, proxySubscription;\n    int updateInterval = 0;\n    std::string sortScript, filterScript;\n\n    std::string clashBase;\n    ProxyGroupConfigs customProxyGroups;\n    std::string surgeBase, surfboardBase, mellowBase, quanBase, quanXBase, loonBase, SSSubBase;\n    std::string surgeSSRPath, quanXDevID;\n\n    //cache system\n    bool serveCacheOnFetchFail = false;\n    int cacheSubscription = 60, cacheConfig = 300, cacheRuleset = 21600;\n\n    //limits\n    size_t maxAllowedRulesets = 64, maxAllowedRules = 32768;\n    bool scriptCleanContext = false;\n\n    //cron system\n    bool enableCron = false;\n    CronTaskConfigs cronTasks;\n};\n\n\nstruct ExternalConfig\n{\n    ProxyGroupConfigs custom_proxy_group;\n    RulesetConfigs surge_ruleset;\n    std::string clash_rule_base;\n    std::string surge_rule_base;\n    std::string surfboard_rule_base;\n    std::string mellow_rule_base;\n    std::string quan_rule_base;\n    std::string quanx_rule_base;\n    std::string loon_rule_base;\n    std::string sssub_rule_base;\n    RegexMatchConfigs rename;\n    RegexMatchConfigs emoji;\n    string_array include;\n    string_array exclude;\n    template_args *tpl_args = nullptr;\n    bool overwrite_original_rules = false;\n    bool enable_rule_generator = true;\n    tribool add_emoji;\n    tribool remove_old_emoji;\n};\n\nextern Settings global;\n\nint importItems(string_array &target, bool scope_limit = true);\nint loadExternalConfig(std::string &path, ExternalConfig &ext);\n\ntemplate <class... Args>\nvoid parseGroupTimes(const std::string &src, Args... args)\n{\n    std::array<int*, sizeof...(args)> ptrs {args...};\n    string_size bpos = 0, epos = src.find(\",\");\n    for(int *x : ptrs)\n    {\n        if(x != nullptr)\n            *x = to_int(src.substr(bpos, epos - bpos), 0);\n        if(epos != src.npos)\n        {\n            bpos = epos + 1;\n            epos = src.find(\",\", bpos);\n        }\n        else\n            return;\n    }\n    return;\n}\n\n#endif // SETTINGS_H_INCLUDED\n"], "fixing_code": ["#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#include \"../../handler/settings.h\"\n#include \"../../handler/webget.h\"\n#include \"../../parser/config/proxy.h\"\n#include \"../../parser/infoparser.h\"\n#include \"../../parser/subparser.h\"\n#include \"../../script/script_quickjs.h\"\n#include \"../../utils/file_extra.h\"\n#include \"../../utils/logger.h\"\n#include \"../../utils/map_extra.h\"\n#include \"../../utils/network.h\"\n#include \"../../utils/regexp.h\"\n#include \"../../utils/urlencode.h\"\n#include \"nodemanip.h\"\n#include \"subexport.h\"\n\nextern Settings global;\n\nbool applyMatcher(const std::string &rule, std::string &real_rule, const Proxy &node);\n\nint explodeConf(const std::string &filepath, std::vector<Proxy> &nodes)\n{\n    return explodeConfContent(fileGet(filepath), nodes);\n}\n\nvoid copyNodes(std::vector<Proxy> &source, std::vector<Proxy> &dest)\n{\n    std::move(source.begin(), source.end(), std::back_inserter(dest));\n}\n\nint addNodes(std::string link, std::vector<Proxy> &allNodes, int groupID, parse_settings &parse_set)\n{\n    std::string &proxy = *parse_set.proxy, &subInfo = *parse_set.sub_info;\n    string_array &exclude_remarks = *parse_set.exclude_remarks;\n    string_array &include_remarks = *parse_set.include_remarks;\n    RegexMatchConfigs &stream_rules = *parse_set.stream_rules;\n    RegexMatchConfigs &time_rules = *parse_set.time_rules;\n    string_icase_map *request_headers = parse_set.request_header;\n    bool &authorized = parse_set.authorized;\n\n    ConfType linkType = ConfType::Unknow;\n    std::vector<Proxy> nodes;\n    Proxy node;\n    std::string strSub, extra_headers, custom_group;\n\n    // TODO: replace with startsWith if appropriate\n    link = replaceAllDistinct(link, \"\\\"\", \"\");\n\n    /// script:filepath,arg1,arg2,...\n    if(authorized) script_safe_runner(parse_set.js_runtime, parse_set.js_context, [&](qjs::Context &ctx)\n    {\n        if(startsWith(link, \"script:\")) /// process subscription with script\n        {\n            writeLog(0, \"Found script link. Start running...\", LOG_LEVEL_INFO);\n            string_array args = split(link.substr(7), \",\");\n            if(args.size() >= 1)\n            {\n                std::string script = fileGet(args[0], false);\n                try\n                {\n                    ctx.eval(script);\n                    args.erase(args.begin()); /// remove script path\n                    auto parse = (std::function<std::string(const std::string&, const string_array&)>) ctx.eval(\"parse\");\n                    switch(args.size())\n                    {\n                    case 0:\n                        link = parse(std::string(), string_array());\n                        break;\n                    case 1:\n                        link = parse(args[0], string_array());\n                        break;\n                    default:\n                        {\n                            std::string first = args[0];\n                            args.erase(args.begin());\n                            link = parse(first, args);\n                            break;\n                        }\n                    }\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }\n        }\n    }, global.scriptCleanContext);\n            /*\n            duk_context *ctx = duktape_init();\n            defer(duk_destroy_heap(ctx);)\n            duktape_peval(ctx, script);\n            duk_get_global_string(ctx, \"parse\");\n            for(size_t i = 1; i < args.size(); i++)\n                duk_push_string(ctx, trim(args[i]).c_str());\n            if(duk_pcall(ctx, args.size() - 1) == 0)\n                link = duktape_get_res_str(ctx);\n            else\n            {\n                writeLog(0, \"Error when trying to evaluate script:\\n\" + duktape_get_err_stack(ctx), LOG_LEVEL_ERROR);\n                duk_pop(ctx); /// pop err\n            }\n            */\n\n    /// tag:group_name,link\n    if(startsWith(link, \"tag:\"))\n    {\n        string_size pos = link.find(\",\");\n        if(pos != link.npos)\n        {\n            custom_group = link.substr(4, pos - 4);\n            link.erase(0, pos + 1);\n        }\n    }\n\n    if(link == \"nullnode\")\n    {\n        node.GroupId = 0;\n        writeLog(0, \"Adding node placeholder...\");\n        allNodes.emplace_back(std::move(node));\n        return 0;\n    }\n\n    writeLog(LOG_TYPE_INFO, \"Received Link.\");\n    if(startsWith(link, \"https://t.me/socks\") || startsWith(link, \"tg://socks\"))\n        linkType = ConfType::SOCKS;\n    else if(startsWith(link, \"https://t.me/http\") || startsWith(link, \"tg://http\"))\n        linkType = ConfType::HTTP;\n    else if(isLink(link) || startsWith(link, \"surge:///install-config\"))\n        linkType = ConfType::SUB;\n    else if(startsWith(link, \"Netch://\"))\n        linkType = ConfType::Netch;\n    else if(fileExist(link))\n        linkType = ConfType::Local;\n\n    switch(linkType)\n    {\n    case ConfType::SUB:\n        writeLog(LOG_TYPE_INFO, \"Downloading subscription data...\");\n        if(startsWith(link, \"surge:///install-config\")) //surge config link\n            link = urlDecode(getUrlArg(link, \"url\"));\n        strSub = webGet(link, proxy, global.cacheSubscription, &extra_headers, request_headers);\n        /*\n        if(strSub.size() == 0)\n        {\n            //try to get it again with system proxy\n            writeLog(LOG_TYPE_WARN, \"Cannot download subscription directly. Using system proxy.\");\n            strProxy = getSystemProxy();\n            if(strProxy != \"\")\n            {\n                strSub = webGet(link, strProxy);\n            }\n            else\n                writeLog(LOG_TYPE_WARN, \"No system proxy is set. Skipping.\");\n        }\n        */\n        if(strSub.size())\n        {\n            writeLog(LOG_TYPE_INFO, \"Parsing subscription data...\");\n            if(explodeConfContent(strSub, nodes) == 0)\n            {\n                writeLog(LOG_TYPE_ERROR, \"Invalid subscription: '\" + link + \"'!\");\n                return -1;\n            }\n            if(startsWith(strSub, \"ssd://\"))\n            {\n                getSubInfoFromSSD(strSub, subInfo);\n            }\n            else\n            {\n                if(!getSubInfoFromHeader(extra_headers, subInfo))\n                    getSubInfoFromNodes(nodes, stream_rules, time_rules, subInfo);\n            }\n            filterNodes(nodes, exclude_remarks, include_remarks, groupID);\n            for(Proxy &x : nodes)\n            {\n                x.GroupId = groupID;\n                if(custom_group.size())\n                    x.Group = custom_group;\n            }\n            copyNodes(nodes, allNodes);\n        }\n        else\n        {\n            writeLog(LOG_TYPE_ERROR, \"Cannot download subscription data.\");\n            return -1;\n        }\n        break;\n    case ConfType::Local:\n        if(!authorized)\n            return -1;\n        writeLog(LOG_TYPE_INFO, \"Parsing configuration file data...\");\n        if(explodeConf(link, nodes) == 0)\n        {\n            writeLog(LOG_TYPE_ERROR, \"Invalid configuration file!\");\n            return -1;\n        }\n        if(startsWith(strSub, \"ssd://\"))\n        {\n            getSubInfoFromSSD(strSub, subInfo);\n        }\n        else\n        {\n            getSubInfoFromNodes(nodes, stream_rules, time_rules, subInfo);\n        }\n        filterNodes(nodes, exclude_remarks, include_remarks, groupID);\n        for(Proxy &x : nodes)\n        {\n            x.GroupId = groupID;\n            if(custom_group.size())\n                x.Group = custom_group;\n        }\n        copyNodes(nodes, allNodes);\n        break;\n    default:\n        explode(link, node);\n        if(node.Type == -1)\n        {\n            writeLog(LOG_TYPE_ERROR, \"No valid link found.\");\n            return -1;\n        }\n        node.GroupId = groupID;\n        if(custom_group.size())\n            node.Group = custom_group;\n        allNodes.emplace_back(std::move(node));\n    }\n    return 0;\n}\n\nbool chkIgnore(const Proxy &node, string_array &exclude_remarks, string_array &include_remarks)\n{\n    bool excluded = false, included = false;\n    //std::string remarks = UTF8ToACP(node.remarks);\n    //std::string remarks = node.remarks;\n    //writeLog(LOG_TYPE_INFO, \"Comparing exclude remarks...\");\n    excluded = std::any_of(exclude_remarks.cbegin(), exclude_remarks.cend(), [&node](const auto &x)\n    {\n        std::string real_rule;\n        if(applyMatcher(x, real_rule, node))\n        {\n            if(real_rule.empty()) return true;\n            return regFind(node.Remark, real_rule);\n        }\n        else\n            return false;\n    });\n    if(include_remarks.size() != 0)\n    {\n        //writeLog(LOG_TYPE_INFO, \"Comparing include remarks...\");\n        included = std::any_of(include_remarks.cbegin(), include_remarks.cend(), [&node](const auto &x)\n        {\n            std::string real_rule;\n            if(applyMatcher(x, real_rule, node))\n            {\n                if(real_rule.empty()) return true;\n                return regFind(node.Remark, real_rule);\n            }\n            else\n                return false;\n        });\n    }\n    else\n    {\n        included = true;\n    }\n\n    return excluded || !included;\n}\n\nvoid filterNodes(std::vector<Proxy> &nodes, string_array &exclude_remarks, string_array &include_remarks, int groupID)\n{\n    int node_index = 0;\n    std::vector<Proxy>::iterator iter = nodes.begin();\n    while(iter != nodes.end())\n    {\n        if(chkIgnore(*iter, exclude_remarks, include_remarks))\n        {\n            writeLog(LOG_TYPE_INFO, \"Node  \" + iter->Group + \" - \" + iter->Remark + \"  has been ignored and will not be added.\");\n            nodes.erase(iter);\n        }\n        else\n        {\n            writeLog(LOG_TYPE_INFO, \"Node  \" + iter->Group + \" - \" + iter->Remark + \"  has been added.\");\n            iter->Id = node_index;\n            iter->GroupId = groupID;\n            ++node_index;\n            ++iter;\n        }\n    }\n    /*\n    std::vector<std::unique_ptr<pcre2_code, decltype(&pcre2_code_free)>> exclude_patterns, include_patterns;\n    std::vector<std::unique_ptr<pcre2_match_data, decltype(&pcre2_match_data_free)>> exclude_match_data, include_match_data;\n    unsigned int i = 0;\n    PCRE2_SIZE erroroffset;\n    int errornumber, rc;\n\n    for(i = 0; i < exclude_remarks.size(); i++)\n    {\n        std::unique_ptr<pcre2_code, decltype(&pcre2_code_free)> pattern(pcre2_compile(reinterpret_cast<const unsigned char*>(exclude_remarks[i].c_str()), exclude_remarks[i].size(), PCRE2_UTF | PCRE2_MULTILINE | PCRE2_ALT_BSUX, &errornumber, &erroroffset, NULL), &pcre2_code_free);\n        if(!pattern)\n            return;\n        exclude_patterns.emplace_back(std::move(pattern));\n        pcre2_jit_compile(exclude_patterns[i].get(), 0);\n        std::unique_ptr<pcre2_match_data, decltype(&pcre2_match_data_free)> match_data(pcre2_match_data_create_from_pattern(exclude_patterns[i].get(), NULL), &pcre2_match_data_free);\n        exclude_match_data.emplace_back(std::move(match_data));\n    }\n    for(i = 0; i < include_remarks.size(); i++)\n    {\n        std::unique_ptr<pcre2_code, decltype(&pcre2_code_free)> pattern(pcre2_compile(reinterpret_cast<const unsigned char*>(include_remarks[i].c_str()), include_remarks[i].size(), PCRE2_UTF | PCRE2_MULTILINE | PCRE2_ALT_BSUX, &errornumber, &erroroffset, NULL), &pcre2_code_free);\n        if(!pattern)\n            return;\n        include_patterns.emplace_back(std::move(pattern));\n        pcre2_jit_compile(include_patterns[i].get(), 0);\n        std::unique_ptr<pcre2_match_data, decltype(&pcre2_match_data_free)> match_data(pcre2_match_data_create_from_pattern(include_patterns[i].get(), NULL), &pcre2_match_data_free);\n        include_match_data.emplace_back(std::move(match_data));\n    }\n    writeLog(LOG_TYPE_INFO, \"Filter started.\");\n    while(iter != nodes.end())\n    {\n        bool excluded = false, included = false;\n        for(i = 0; i < exclude_patterns.size(); i++)\n        {\n            rc = pcre2_match(exclude_patterns[i].get(), reinterpret_cast<const unsigned char*>(iter->remarks.c_str()), iter->remarks.size(), 0, 0, exclude_match_data[i].get(), NULL);\n            if (rc < 0)\n            {\n                switch(rc)\n                {\n                case PCRE2_ERROR_NOMATCH:\n                    break;\n                default:\n                    return;\n                }\n            }\n            else\n                excluded = true;\n        }\n        if(include_patterns.size() > 0)\n            for(i = 0; i < include_patterns.size(); i++)\n            {\n                rc = pcre2_match(include_patterns[i].get(), reinterpret_cast<const unsigned char*>(iter->remarks.c_str()), iter->remarks.size(), 0, 0, include_match_data[i].get(), NULL);\n                if (rc < 0)\n                {\n                    switch(rc)\n                    {\n                    case PCRE2_ERROR_NOMATCH:\n                        break;\n                    default:\n                        return;\n                    }\n                }\n                else\n                    included = true;\n            }\n        else\n            included = true;\n        if(excluded || !included)\n        {\n            writeLog(LOG_TYPE_INFO, \"Node  \" + iter->group + \" - \" + iter->remarks + \"  has been ignored and will not be added.\");\n            nodes.erase(iter);\n        }\n        else\n        {\n            writeLog(LOG_TYPE_INFO, \"Node  \" + iter->group + \" - \" + iter->remarks + \"  has been added.\");\n            iter->id = node_index;\n            iter->groupID = groupID;\n            ++node_index;\n            ++iter;\n        }\n    }\n    */\n    writeLog(LOG_TYPE_INFO, \"Filter done.\");\n}\n\nvoid nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settings &ext)\n{\n    std::string &remark = node.Remark, original_remark = node.Remark, returned_remark, real_rule;\n\n    for(const RegexMatchConfig &x : rename_array)\n    {\n        if(!x.Script.empty() && ext.authorized)\n        {\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto rename = (std::function<std::string(const Proxy&)>) ctx.eval(\"rename\");\n                    returned_remark = rename(node);\n                    if(!returned_remark.empty())\n                        remark = returned_remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            continue;\n        }\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size())\n            remark = regReplace(remark, real_rule, x.Replace);\n    }\n    if(remark.empty())\n        remark = original_remark;\n    return;\n}\n\nstd::string removeEmoji(const std::string &orig_remark)\n{\n    char emoji_id[2] = {(char)-16, (char)-97};\n    std::string remark = orig_remark;\n    while(true)\n    {\n        if(remark[0] == emoji_id[0] && remark[1] == emoji_id[1])\n            remark.erase(0, 4);\n        else\n            break;\n    }\n    if(remark.empty())\n        return orig_remark;\n    return remark;\n}\n\nstd::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, extra_settings &ext)\n{\n    std::string real_rule, ret;\n\n    for(const RegexMatchConfig &x : emoji_array)\n    {\n        if(!x.Script.empty() && ext.authorized)\n        {\n            std::string result;\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto getEmoji = (std::function<std::string(const Proxy&)>) ctx.eval(\"getEmoji\");\n                    ret = getEmoji(node);\n                    if(!ret.empty())\n                        result = ret + \" \" + node.Remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            if(!result.empty())\n                return result;\n            continue;\n        }\n        if(x.Replace.empty())\n            continue;\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size() && regFind(node.Remark, real_rule))\n            return x.Replace + \" \" + node.Remark;\n    }\n    return node.Remark;\n}\n\nvoid preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x)\n    {\n        if(ext.remove_emoji)\n            x.Remark = trim(removeEmoji(x.Remark));\n\n        nodeRename(x, ext.rename_array, ext);\n\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size() && ext.authorized)\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");\n                    auto comparer = [&](const Proxy &a, const Proxy &b)\n                    {\n                        if(a.Type == ProxyType::Unknow)\n                            return 1;\n                        if(b.Type == ProxyType::Unknow)\n                            return 0;\n                        return compare(a, b);\n                    };\n                    std::stable_sort(nodes.begin(), nodes.end(), comparer);\n                    failed = false;\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n        }\n        if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)\n        {\n            return a.Remark < b.Remark;\n        });\n    }\n}\n", "#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <cmath>\n#include <climits>\n\n#include \"../../config/regmatch.h\"\n#include \"../../generator/config/subexport.h\"\n#include \"../../generator/template/templates.h\"\n#include \"../../handler/settings.h\"\n#include \"../../parser/config/proxy.h\"\n#include \"../../script/script_quickjs.h\"\n#include \"../../utils/bitwise.h\"\n#include \"../../utils/file_extra.h\"\n#include \"../../utils/ini_reader/ini_reader.h\"\n#include \"../../utils/logger.h\"\n#include \"../../utils/network.h\"\n#include \"../../utils/rapidjson_extra.h\"\n#include \"../../utils/regexp.h\"\n#include \"../../utils/stl_extra.h\"\n#include \"../../utils/urlencode.h\"\n#include \"../../utils/yamlcpp_extra.h\"\n#include \"nodemanip.h\"\n#include \"ruleconvert.h\"\n\nextern string_array ss_ciphers, ssr_ciphers;\n\nconst string_array clashr_protocols = {\"origin\", \"auth_sha1_v4\", \"auth_aes128_md5\", \"auth_aes128_sha1\", \"auth_chain_a\", \"auth_chain_b\"};\nconst string_array clashr_obfs = {\"plain\", \"http_simple\", \"http_post\", \"random_head\", \"tls1.2_ticket_auth\", \"tls1.2_ticket_fastauth\"};\nconst string_array clash_ssr_ciphers = {\"rc4-md5\", \"aes-128-ctr\", \"aes-192-ctr\", \"aes-256-ctr\", \"aes-128-cfb\", \"aes-192-cfb\", \"aes-256-cfb\", \"chacha20-ietf\", \"xchacha20\", \"none\"};\n\nstd::string vmessLinkConstruct(const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &path, const std::string &host, const std::string &tls)\n{\n    rapidjson::StringBuffer sb;\n    rapidjson::Writer<rapidjson::StringBuffer> writer(sb);\n    writer.StartObject();\n    writer.Key(\"v\");\n    writer.String(\"2\");\n    writer.Key(\"ps\");\n    writer.String(remarks.data());\n    writer.Key(\"add\");\n    writer.String(add.data());\n    writer.Key(\"port\");\n    writer.String(port.data());\n    writer.Key(\"type\");\n    writer.String(type.empty() ? \"none\" : type.data());\n    writer.Key(\"id\");\n    writer.String(id.data());\n    writer.Key(\"aid\");\n    writer.String(aid.data());\n    writer.Key(\"net\");\n    writer.String(net.empty() ? \"tcp\" : net.data());\n    writer.Key(\"path\");\n    writer.String(path.data());\n    writer.Key(\"host\");\n    writer.String(host.data());\n    writer.Key(\"tls\");\n    writer.String(tls.data());\n    writer.EndObject();\n    return sb.GetString();\n}\n\nbool matchRange(const std::string &range, int target)\n{\n    string_array vArray = split(range, \",\");\n    bool match = false;\n    std::string range_begin_str, range_end_str;\n    int range_begin, range_end;\n    static const std::string reg_num = \"-?\\\\d+\", reg_range = \"(\\\\d+)-(\\\\d+)\", reg_not = \"\\\\!-?(\\\\d+)\", reg_not_range = \"\\\\!(\\\\d+)-(\\\\d+)\", reg_less = \"(\\\\d+)-\", reg_more = \"(\\\\d+)\\\\+\";\n    for(std::string &x : vArray)\n    {\n        if(regMatch(x, reg_num))\n        {\n            if(to_int(x, INT_MAX) == target)\n                match = true;\n        }\n        else if(regMatch(x, reg_range))\n        {\n            regGetMatch(x, reg_range, 3, 0, &range_begin_str, &range_end_str);\n            range_begin = to_int(range_begin_str, INT_MAX);\n            range_end = to_int(range_end_str, INT_MIN);\n            if(target >= range_begin && target <= range_end)\n                match = true;\n        }\n        else if(regMatch(x, reg_not))\n        {\n            match = true;\n            if(to_int(regReplace(x, reg_not, \"$1\"), INT_MAX) == target)\n                match = false;\n        }\n        else if(regMatch(x, reg_not_range))\n        {\n            match = true;\n            regGetMatch(x, reg_range, 3, 0, &range_begin_str, &range_end_str);\n            range_begin = to_int(range_begin_str, INT_MAX);\n            range_end = to_int(range_end_str, INT_MIN);\n            if(target >= range_begin && target <= range_end)\n                match = false;\n        }\n        else if(regMatch(x, reg_less))\n        {\n            if(to_int(regReplace(x, reg_less, \"$1\"), INT_MAX) >= target)\n                match = true;\n        }\n        else if(regMatch(x, reg_more))\n        {\n            if(to_int(regReplace(x, reg_more, \"$1\"), INT_MIN) <= target)\n                match = true;\n        }\n    }\n    return match;\n}\n\nbool applyMatcher(const std::string &rule, std::string &real_rule, const Proxy &node)\n{\n    std::string target, ret_real_rule;\n    static const std::string groupid_regex = R\"(^!!(?:GROUPID|INSERT)=([\\d\\-+!,]+)(?:!!(.*))?$)\", group_regex = R\"(^!!(?:GROUP)=(.+?)(?:!!(.*))?$)\";\n    static const std::string type_regex = R\"(^!!(?:TYPE)=(.+?)(?:!!(.*))?$)\", port_regex = R\"(^!!(?:PORT)=(.+?)(?:!!(.*))?$)\", server_regex = R\"(^!!(?:SERVER)=(.+?)(?:!!(.*))?$)\";\n    static const string_array types = {\"\", \"SS\", \"SSR\", \"VMESS\", \"TROJAN\", \"SNELL\", \"HTTP\", \"HTTPS\", \"SOCKS5\"};\n    if(startsWith(rule, \"!!GROUP=\"))\n    {\n        regGetMatch(rule, group_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        return regFind(node.Group, target);\n    }\n    else if(startsWith(rule, \"!!GROUPID=\") || startsWith(rule, \"!!INSERT=\"))\n    {\n        int dir = startsWith(rule, \"!!INSERT=\") ? -1 : 1;\n        regGetMatch(rule, groupid_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        return matchRange(target, dir * node.GroupId);\n    }\n    else if(startsWith(rule, \"!!TYPE=\"))\n    {\n        regGetMatch(rule, type_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        if(node.Type == ProxyType::Unknow)\n            return false;\n        return regMatch(types[node.Type], target);\n    }\n    else if(startsWith(rule, \"!!PORT=\"))\n    {\n        regGetMatch(rule, port_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        return matchRange(target, node.Port);\n    }\n    else if(startsWith(rule, \"!!SERVER=\"))\n    {\n        regGetMatch(rule, server_regex, 3, 0, &target, &ret_real_rule);\n        real_rule = ret_real_rule;\n        return regFind(node.Hostname, target);\n    }\n    else\n        real_rule = rule;\n    return true;\n}\n\nvoid processRemark(std::string &oldremark, std::string &newremark, string_array &remarks_list, bool proc_comma = true)\n{\n    if(proc_comma)\n    {\n        if(oldremark.find(',') != oldremark.npos)\n        {\n            oldremark.insert(0, \"\\\"\");\n            oldremark.append(\"\\\"\");\n        }\n    }\n    newremark = oldremark;\n    int cnt = 2;\n    while(std::find(remarks_list.begin(), remarks_list.end(), newremark) != remarks_list.end())\n    {\n        newremark = oldremark + \" \" + std::to_string(cnt);\n        cnt++;\n    }\n    oldremark = newremark;\n}\n\nvoid groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)\n{\n    std::string real_rule;\n    if(startsWith(rule, \"[]\") && add_direct)\n    {\n        filtered_nodelist.emplace_back(rule.substr(2));\n    }\n#ifndef NO_JS_RUNTIME\n    else if(startsWith(rule, \"script:\") && ext.authorized)\n    {\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){\n            std::string script = fileGet(rule.substr(7), true);\n            try\n            {\n                ctx.eval(script);\n                auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(\"filter\");\n                std::string result_list = filter(nodelist);\n                filtered_nodelist = split(regTrim(result_list), \"\\n\");\n            }\n            catch (qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n#endif // NO_JS_RUNTIME\n    else\n    {\n        for(Proxy &x : nodelist)\n        {\n            if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())\n                filtered_nodelist.emplace_back(x.Remark);\n        }\n    }\n}\n\nvoid proxyToClash(std::vector<Proxy> &nodes, YAML::Node &yamlnode, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext)\n{\n    YAML::Node proxies, singleproxy, singlegroup, original_groups;\n    std::vector<Proxy> nodelist;\n    string_array remarks_list, filtered_nodelist;\n    /// proxies style\n    bool block = false, compact = false;\n    switch(hash_(ext.clash_proxies_style))\n    {\n    case \"block\"_hash:\n        block = true;\n        break;\n    default:\n    case \"flow\"_hash:\n        break;\n    case \"compact\"_hash:\n        compact = true;\n        break;\n    }\n\n    for(Proxy &x : nodes)\n    {\n        singleproxy.reset();\n\n        std::string type = getProxyTypeName(x.Type);\n        std::string remark, pluginopts = replaceAllDistinct(x.PluginOption, \";\", \"&\");\n        if(ext.append_proxy_type)\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n\n        processRemark(x.Remark, remark, remarks_list, false);\n\n        tribool udp = ext.udp;\n        tribool scv = ext.skip_cert_verify;\n        udp.define(x.UDP);\n        scv.define(x.AllowInsecure);\n\n        singleproxy[\"name\"] = remark;\n        singleproxy[\"server\"] = x.Hostname;\n        singleproxy[\"port\"] = x.Port;\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            //latest clash core removed support for chacha20 encryption\n            if(ext.filter_deprecated && x.EncryptMethod == \"chacha20\")\n                continue;\n            singleproxy[\"type\"] = \"ss\";\n            singleproxy[\"cipher\"] = x.EncryptMethod;\n            singleproxy[\"password\"] = x.Password;\n            if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())\n                singleproxy[\"password\"].SetTag(\"str\");\n            switch(hash_(x.Plugin))\n            {\n            case \"simple-obfs\"_hash:\n            case \"obfs-local\"_hash:\n                singleproxy[\"plugin\"] = \"obfs\";\n                singleproxy[\"plugin-opts\"][\"mode\"] = urlDecode(getUrlArg(pluginopts, \"obfs\"));\n                singleproxy[\"plugin-opts\"][\"host\"] = urlDecode(getUrlArg(pluginopts, \"obfs-host\"));\n                break;\n            case \"v2ray-plugin\"_hash:\n                singleproxy[\"plugin\"] = \"v2ray-plugin\";\n                singleproxy[\"plugin-opts\"][\"mode\"] = getUrlArg(pluginopts, \"mode\");\n                singleproxy[\"plugin-opts\"][\"host\"] = getUrlArg(pluginopts, \"host\");\n                singleproxy[\"plugin-opts\"][\"path\"] = getUrlArg(pluginopts, \"path\");\n                singleproxy[\"plugin-opts\"][\"tls\"] = pluginopts.find(\"tls\") != std::string::npos;\n                singleproxy[\"plugin-opts\"][\"mux\"] = pluginopts.find(\"mux\") != std::string::npos;\n                if(!scv.is_undef())\n                    singleproxy[\"plugin-opts\"][\"skip-cert-verify\"] = scv.get();\n                break;\n            }\n            break;\n        case ProxyType::VMess:\n            singleproxy[\"type\"] = \"vmess\";\n            singleproxy[\"uuid\"] = x.UserId;\n            singleproxy[\"alterId\"] = x.AlterId;\n            singleproxy[\"cipher\"] = x.EncryptMethod;\n            singleproxy[\"tls\"] = x.TLSSecure;\n            if(!scv.is_undef())\n                singleproxy[\"skip-cert-verify\"] = scv.get();\n            if(!x.ServerName.empty())\n                singleproxy[\"servername\"] = x.ServerName;\n            switch(hash_(x.TransferProtocol))\n            {\n            case \"tcp\"_hash:\n                break;\n            case \"ws\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                if(ext.clash_new_field_name)\n                {\n                    singleproxy[\"ws-opts\"][\"path\"] = x.Path;\n                    if(!x.Host.empty())\n                        singleproxy[\"ws-opts\"][\"headers\"][\"Host\"] = x.Host;\n                    if(!x.Edge.empty())\n                        singleproxy[\"ws-opts\"][\"headers\"][\"Edge\"] = x.Edge;\n                }\n                else\n                {\n                    singleproxy[\"ws-path\"] = x.Path;\n                    if(!x.Host.empty())\n                        singleproxy[\"ws-headers\"][\"Host\"] = x.Host;\n                    if(!x.Edge.empty())\n                        singleproxy[\"ws-headers\"][\"Edge\"] = x.Edge;\n                }\n                break;\n            case \"http\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                singleproxy[\"http-opts\"][\"method\"] = \"GET\";\n                singleproxy[\"http-opts\"][\"path\"].push_back(x.Path);\n                if(!x.Host.empty())\n                    singleproxy[\"http-opts\"][\"headers\"][\"Host\"].push_back(x.Host);\n                if(!x.Edge.empty())\n                    singleproxy[\"http-opts\"][\"headers\"][\"Edge\"].push_back(x.Edge);\n                break;\n            case \"h2\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                singleproxy[\"h2-opts\"][\"path\"] = x.Path;\n                if(!x.Host.empty())\n                    singleproxy[\"h2-opts\"][\"host\"].push_back(x.Host);\n                break;\n            case \"grpc\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                singleproxy[\"servername\"] = x.Host;\n                singleproxy[\"grpc-opts\"][\"grpc-service-name\"] = x.Path;\n                break;\n            default:\n                continue;\n            }\n            break;\n        case ProxyType::ShadowsocksR:\n            //ignoring all nodes with unsupported obfs, protocols and encryption\n            if(ext.filter_deprecated)\n            {\n                if(!clashR && std::find(clash_ssr_ciphers.cbegin(), clash_ssr_ciphers.cend(), x.EncryptMethod) == clash_ssr_ciphers.cend())\n                    continue;\n                if(std::find(clashr_protocols.cbegin(), clashr_protocols.cend(), x.Protocol) == clashr_protocols.cend())\n                    continue;\n                if(std::find(clashr_obfs.cbegin(), clashr_obfs.cend(), x.OBFS) == clashr_obfs.cend())\n                    continue;\n            }\n\n            singleproxy[\"type\"] = \"ssr\";\n            singleproxy[\"cipher\"] = x.EncryptMethod == \"none\" ? \"dummy\" : x.EncryptMethod;\n            singleproxy[\"password\"] = x.Password;\n            if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())\n                singleproxy[\"password\"].SetTag(\"str\");\n            singleproxy[\"protocol\"] = x.Protocol;\n            singleproxy[\"obfs\"] = x.OBFS;\n            if(clashR)\n            {\n                singleproxy[\"protocolparam\"] = x.ProtocolParam;\n                singleproxy[\"obfsparam\"] = x.OBFSParam;\n            }\n            else\n            {\n                singleproxy[\"protocol-param\"] = x.ProtocolParam;\n                singleproxy[\"obfs-param\"] = x.OBFSParam;\n            }\n            break;\n        case ProxyType::SOCKS5:\n            singleproxy[\"type\"] = \"socks5\";\n            if(!x.Username.empty())\n                singleproxy[\"username\"] = x.Username;\n            if(!x.Password.empty())\n            {\n                singleproxy[\"password\"] = x.Password;\n                if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit))\n                    singleproxy[\"password\"].SetTag(\"str\");\n            }\n            if(!scv.is_undef())\n                singleproxy[\"skip-cert-verify\"] = scv.get();\n            break;\n        case ProxyType::HTTP:\n        case ProxyType::HTTPS:\n            singleproxy[\"type\"] = \"http\";\n            if(!x.Username.empty())\n                singleproxy[\"username\"] = x.Username;\n            if(!x.Password.empty())\n            {\n                singleproxy[\"password\"] = x.Password;\n                if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit))\n                    singleproxy[\"password\"].SetTag(\"str\");\n            }\n            singleproxy[\"tls\"] = x.TLSSecure;\n            if(!scv.is_undef())\n                singleproxy[\"skip-cert-verify\"] = scv.get();\n            break;\n        case ProxyType::Trojan:\n            singleproxy[\"type\"] = \"trojan\";\n            singleproxy[\"password\"] = x.Password;\n            if(!x.Host.empty())\n                singleproxy[\"sni\"] = x.Host;\n            if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())\n                singleproxy[\"password\"].SetTag(\"str\");\n            if(!scv.is_undef())\n                singleproxy[\"skip-cert-verify\"] = scv.get();\n            switch(hash_(x.TransferProtocol))\n            {\n            case \"tcp\"_hash:\n                break;\n            case \"grpc\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                if(!x.Path.empty())\n                    singleproxy[\"grpc-opts\"][\"grpc-service-name\"] = x.Path;\n                break;\n            case \"ws\"_hash:\n                singleproxy[\"network\"] = x.TransferProtocol;\n                singleproxy[\"ws-opts\"][\"path\"] = x.Path;\n                if(!x.Host.empty())\n                    singleproxy[\"ws-opts\"][\"headers\"][\"Host\"] = x.Host;\n                break;\n            }\n            break;\n        case ProxyType::Snell:\n            singleproxy[\"type\"] = \"snell\";\n            singleproxy[\"psk\"] = x.Password;\n            if(x.SnellVersion != 0)\n                singleproxy[\"version\"] = x.SnellVersion;\n            if(!x.OBFS.empty())\n            {\n                singleproxy[\"obfs-opts\"][\"mode\"] = x.OBFS;\n                if(!x.Host.empty())\n                    singleproxy[\"obfs-opts\"][\"host\"] = x.Host;\n            }\n            if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())\n                singleproxy[\"password\"].SetTag(\"str\");\n            break;\n        default:\n            continue;\n        }\n\n        if(udp)\n            singleproxy[\"udp\"] = true;\n        if(block)\n            singleproxy.SetStyle(YAML::EmitterStyle::Block);\n        else\n            singleproxy.SetStyle(YAML::EmitterStyle::Flow);\n        proxies.push_back(singleproxy);\n        remarks_list.emplace_back(std::move(remark));\n        nodelist.emplace_back(x);\n    }\n\n    if(compact)\n        proxies.SetStyle(YAML::EmitterStyle::Flow);\n\n    if(ext.nodelist)\n    {\n        YAML::Node provider;\n        provider[\"proxies\"] = proxies;\n        yamlnode.reset(provider);\n        return;\n    }\n\n    if(ext.clash_new_field_name)\n        yamlnode[\"proxies\"] = proxies;\n    else\n        yamlnode[\"Proxy\"] = proxies;\n\n\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        singlegroup.reset();\n        eraseElements(filtered_nodelist);\n\n        singlegroup[\"name\"] = x.Name;\n        singlegroup[\"type\"] = x.TypeStr();\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::Relay:\n            break;\n        case ProxyGroupType::LoadBalance:\n            singlegroup[\"strategy\"] = x.StrategyStr();\n            [[fallthrough]];\n        case ProxyGroupType::URLTest:\n            if(!x.Lazy.is_undef())\n                singlegroup[\"lazy\"] = x.Lazy.get();\n            [[fallthrough]];\n        case ProxyGroupType::Fallback:\n            singlegroup[\"url\"] = x.Url;\n            if(x.Interval > 0)\n                singlegroup[\"interval\"] = x.Interval;\n            if(x.Tolerance > 0)\n                singlegroup[\"tolerance\"] = x.Tolerance;\n            break;\n        default:\n            continue;\n        }\n        if(!x.DisableUdp.is_undef())\n            singlegroup[\"disable-udp\"] = x.DisableUdp.get();\n\n        for(const auto& y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n        if(!x.UsingProvider.empty())\n            singlegroup[\"use\"] = x.UsingProvider;\n        else\n        {\n            if(filtered_nodelist.empty())\n                filtered_nodelist.emplace_back(\"DIRECT\");\n        }\n        if(!filtered_nodelist.empty())\n            singlegroup[\"proxies\"] = filtered_nodelist;\n        //singlegroup.SetStyle(YAML::EmitterStyle::Flow);\n\n        bool replace_flag = false;\n        for(unsigned int i = 0; i < original_groups.size(); i++)\n        {\n            if(original_groups[i][\"name\"].as<std::string>() == x.Name)\n            {\n                original_groups[i] = singlegroup;\n                replace_flag = true;\n                break;\n            }\n        }\n        if(!replace_flag)\n            original_groups.push_back(singlegroup);\n    }\n\n    if(ext.clash_new_field_name)\n        yamlnode[\"proxy-groups\"] = original_groups;\n    else\n        yamlnode[\"Proxy Group\"] = original_groups;\n}\n\nstd::string proxyToClash(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext)\n{\n    YAML::Node yamlnode;\n\n    try\n    {\n        yamlnode = YAML::Load(base_conf);\n    }\n    catch (std::exception &e)\n    {\n        writeLog(0, std::string(\"Clash base loader failed with error: \") + e.what(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    proxyToClash(nodes, yamlnode, extra_proxy_group, clashR, ext);\n\n    if(ext.nodelist)\n        return YAML::Dump(yamlnode);\n\n    /*\n    if(ext.enable_rule_generator)\n        rulesetToClash(yamlnode, ruleset_content_array, ext.overwrite_original_rules, ext.clash_new_field_name);\n\n    return YAML::Dump(yamlnode);\n    */\n    if(!ext.enable_rule_generator)\n        return YAML::Dump(yamlnode);\n\n    if(!ext.managed_config_prefix.empty() || ext.clash_script)\n    {\n        if(yamlnode[\"mode\"].IsDefined())\n        {\n            if(ext.clash_new_field_name)\n                yamlnode[\"mode\"] = ext.clash_script ? \"script\" : \"rule\";\n            else\n                yamlnode[\"mode\"] = ext.clash_script ? \"Script\" : \"Rule\";\n        }\n\n        renderClashScript(yamlnode, ruleset_content_array, ext.managed_config_prefix, ext.clash_script, ext.overwrite_original_rules, ext.clash_classical_ruleset);\n        return YAML::Dump(yamlnode);\n    }\n\n    std::string output_content = rulesetToClashStr(yamlnode, ruleset_content_array, ext.overwrite_original_rules, ext.clash_new_field_name);\n    output_content.insert(0, YAML::Dump(yamlnode));\n\n    return output_content;\n}\n\nstd::string proxyToSurge(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, int surge_ver, extra_settings &ext)\n{\n    INIReader ini;\n    std::string proxy;\n    std::string output_nodelist;\n    tribool udp, tfo, scv, tls13;\n    std::vector<Proxy> nodelist;\n    unsigned short local_port = 1080;\n\n    string_array remarks_list, filtered_nodelist, args;\n\n    ini.store_any_line = true;\n    // filter out sections that requires direct-save\n    ini.AddDirectSaveSection(\"General\");\n    ini.AddDirectSaveSection(\"Replica\");\n    ini.AddDirectSaveSection(\"Rule\");\n    ini.AddDirectSaveSection(\"MITM\");\n    ini.AddDirectSaveSection(\"Script\");\n    ini.AddDirectSaveSection(\"Host\");\n    ini.AddDirectSaveSection(\"URL Rewrite\");\n    ini.AddDirectSaveSection(\"Header Rewrite\");\n    if(ini.Parse(base_conf) != 0 && !ext.nodelist)\n    {\n        writeLog(0, \"Surge base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    ini.SetCurrentSection(\"Proxy\");\n    ini.EraseSection();\n    ini.Set(\"{NONAME}\", \"DIRECT = direct\");\n\n    for(Proxy &x : nodes)\n    {\n        std::string remark;\n        if(ext.append_proxy_type)\n        {\n            std::string type = getProxyTypeName(x.Type);\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n        }\n\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname, &username = x.Username, &password = x.Password, &method = x.EncryptMethod, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &edge = x.Edge, &path = x.Path, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &plugin = x.Plugin, &pluginopts = x.PluginOption;\n        std::string port = std::to_string(x.Port);\n        bool &tlssecure = x.TLSSecure;\n\n        udp = ext.udp;\n        tfo = ext.tfo;\n        scv = ext.skip_cert_verify;\n        tls13 = ext.tls13;\n        udp.define(x.UDP);\n        tfo.define(x.TCPFastOpen);\n        scv.define(x.AllowInsecure);\n        tls13.define(x.TLS13);\n\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(surge_ver >= 3 || surge_ver == -3)\n            {\n                proxy = \"ss, \" + hostname + \", \" + port + \", encrypt-method=\" + method + \", password=\" + password;\n            }\n            else\n            {\n                proxy = \"custom, \"  + hostname + \", \" + port + \", \" + method + \", \" + password + \", https://github.com/pobizhe/SSEncrypt/raw/master/SSEncrypt.module\";\n            }\n            if(!plugin.empty())\n            {\n                switch(hash_(plugin))\n                {\n                case \"simple-obfs\"_hash:\n                case \"obfs-local\"_hash:\n                    if(!pluginopts.empty())\n                        proxy += \",\" + replaceAllDistinct(pluginopts, \";\", \",\");\n                    break;\n                default:\n                    continue;\n                }\n            }\n            break;\n        case ProxyType::VMess:\n            if(surge_ver < 4 && surge_ver != -3)\n                continue;\n            proxy = \"vmess, \" + hostname + \", \" + port + \", username=\" + id + \", tls=\" + (tlssecure ? \"true\" : \"false\") +  \", vmess-aead=\" + (x.AlterId == 0 ? \"true\" : \"false\");\n            if(tlssecure && !tls13.is_undef())\n                proxy += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n            switch(hash_(transproto))\n            {\n            case \"tcp\"_hash:\n                break;\n            case \"ws\"_hash:\n                proxy += \", ws=true, ws-path=\" + path + \", sni=\" + host + \", ws-headers=Host:\" + host;\n                if(!edge.empty())\n                    proxy += \"|Edge:\" + edge;\n                break;\n            default:\n                continue;\n            }\n            if(!scv.is_undef())\n                proxy += \", skip-cert-verify=\" + scv.get_str();\n            break;\n        case ProxyType::ShadowsocksR:\n            if(ext.surge_ssr_path.empty() || surge_ver < 2)\n                continue;\n            proxy = \"external, exec=\\\"\" + ext.surge_ssr_path + \"\\\", args=\\\"\";\n            args = {\"-l\", std::to_string(local_port), \"-s\", hostname, \"-p\", port, \"-m\", method, \"-k\", password, \"-o\", obfs, \"-O\", protocol};\n            if(!obfsparam.empty())\n            {\n                args.emplace_back(\"-g\");\n                args.emplace_back(std::move(obfsparam));\n            }\n            if(!protoparam.empty())\n            {\n                args.emplace_back(\"-G\");\n                args.emplace_back(std::move(protoparam));\n            }\n            proxy += join(args, \"\\\", args=\\\"\");\n            proxy += \"\\\", local-port=\" + std::to_string(local_port);\n            if(isIPv4(hostname) || isIPv6(hostname))\n                proxy += \", addresses=\" + hostname;\n            else if(global.surgeResolveHostname)\n                proxy += \", addresses=\" + hostnameToIPAddr(hostname);\n            local_port++;\n            break;\n        case ProxyType::SOCKS5:\n            proxy = \"socks5, \" + hostname + \", \" + port;\n            if(!username.empty())\n                proxy += \", username=\" + username;\n            if(!password.empty())\n                proxy += \", password=\" + password;\n            if(!scv.is_undef())\n                proxy += \", skip-cert-verify=\" + scv.get_str();\n            break;\n        case ProxyType::HTTPS:\n            if(surge_ver == -3)\n            {\n                proxy = \"https, \" + hostname + \", \" + port + \", \" + username + \", \" + password;\n                if(!scv.is_undef())\n                    proxy += \", skip-cert-verify=\" + scv.get_str();\n                break;\n            }\n            [[fallthrough]];\n        case ProxyType::HTTP:\n            proxy = \"http, \" + hostname + \", \" + port;\n            if(!username.empty())\n                proxy += \", username=\" + username;\n            if(!password.empty())\n                proxy += \", password=\" + password;\n            proxy += std::string(\", tls=\") + (x.TLSSecure ? \"true\" : \"false\");\n            if(!scv.is_undef())\n                proxy += \", skip-cert-verify=\" + scv.get_str();\n            break;\n        case ProxyType::Trojan:\n            if(surge_ver < 4 && surge_ver != -3)\n                continue;\n            proxy = \"trojan, \" + hostname + \", \" + port + \", password=\" + password;\n            if(x.SnellVersion != 0)\n                proxy += \", version=\" + std::to_string(x.SnellVersion);\n            if(!host.empty())\n                proxy += \", sni=\" + host;\n            if(!scv.is_undef())\n                proxy += \", skip-cert-verify=\" + scv.get_str();\n            break;\n        case ProxyType::Snell:\n            proxy = \"snell, \" + hostname + \", \" + port + \", psk=\" + password;\n            if(!obfs.empty())\n                proxy += \", obfs=\" + obfs + \", obfs-host=\" + host;\n            break;\n        default:\n            continue;\n        }\n\n        if(!tfo.is_undef())\n            proxy += \", tfo=\" + tfo.get_str();\n        if(!udp.is_undef())\n            proxy += \", udp-relay=\" + udp.get_str();\n\n        if(ext.nodelist)\n            output_nodelist += remark + \" = \" + proxy + \"\\n\";\n        else\n        {\n            ini.Set(\"{NONAME}\", remark + \" = \" + proxy);\n            nodelist.emplace_back(x);\n        }\n        remarks_list.emplace_back(std::move(remark));\n    }\n\n    if(ext.nodelist)\n        return output_nodelist;\n\n    ini.SetCurrentSection(\"Proxy Group\");\n    ini.EraseSection();\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::URLTest:\n        case ProxyGroupType::Fallback:\n            break;\n        case ProxyGroupType::LoadBalance:\n            if(surge_ver < 1)\n                continue;\n            [[fallthrough]];\n        case ProxyGroupType::SSID:\n            proxy = x.TypeStr() + \",default=\" + x.Proxies[0] + \",\";\n            proxy += join(x.Proxies.begin() + 1, x.Proxies.end(), \",\");\n            ini.Set(\"{NONAME}\", x.Name + \" = \" + proxy); //insert order\n            continue;\n        default:\n            continue;\n        }\n\n        for(const auto &y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n        if(filtered_nodelist.empty())\n            filtered_nodelist.emplace_back(\"DIRECT\");\n\n        if(filtered_nodelist.size() == 1)\n        {\n            proxy = toLower(filtered_nodelist[0]);\n            switch(hash_(proxy))\n            {\n            case \"direct\"_hash:\n            case \"reject\"_hash:\n            case \"reject-tinygif\"_hash:\n                ini.Set(\"Proxy\", \"{NONAME}\", x.Name + \" = \" + proxy);\n                continue;\n            }\n        }\n\n        proxy = x.TypeStr() + \",\";\n        proxy += join(filtered_nodelist, \",\");\n        if(x.Type == ProxyGroupType::URLTest || x.Type == ProxyGroupType::Fallback)\n        {\n            proxy += \",url=\" + x.Url + \",interval=\" + std::to_string(x.Interval);\n            if(x.Tolerance > 0)\n                proxy += \",tolerance=\" + std::to_string(x.Tolerance);\n            if(x.Timeout > 0)\n                proxy += \",timeout=\" + std::to_string(x.Timeout);\n        }\n        else if(x.Type == ProxyGroupType::LoadBalance)\n            proxy += \",url=\" + x.Url;\n\n        ini.Set(\"{NONAME}\", x.Name + \" = \" + proxy); //insert order\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, surge_ver, ext.overwrite_original_rules, ext.managed_config_prefix);\n\n    return ini.ToString();\n}\n\nstd::string proxyToSingle(std::vector<Proxy> &nodes, int types, extra_settings &ext)\n{\n    /// types: SS=1 SSR=2 VMess=4 Trojan=8\n    std::string remark, hostname, port, password, method;\n    std::string plugin, pluginopts;\n    std::string protocol, protoparam, obfs, obfsparam;\n    std::string id, aid, transproto, faketype, host, path, quicsecure, quicsecret;\n    std::string proxyStr, allLinks;\n    bool ss = GETBIT(types, 1), ssr = GETBIT(types, 2), vmess = GETBIT(types, 3), trojan = GETBIT(types, 4);\n\n    for(Proxy &x : nodes)\n    {\n        remark = x.Remark;\n        std::string &hostname = x.Hostname, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &faketype = x.FakeType;\n        bool &tlssecure = x.TLSSecure;\n        std::string port = std::to_string(x.Port);\n        std::string aid = std::to_string(x.AlterId);\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(ss)\n            {\n                proxyStr = \"ss://\" + urlSafeBase64Encode(method + \":\" + password) + \"@\" + hostname + \":\" + port;\n                if(!plugin.empty() && !pluginopts.empty())\n                {\n                    proxyStr += \"/?plugin=\" + urlEncode(plugin + \";\" + pluginopts);\n                }\n                proxyStr += \"#\" + urlEncode(remark);\n            }\n            else if(ssr)\n            {\n                if(std::find(ssr_ciphers.begin(), ssr_ciphers.end(), method) != ssr_ciphers.end() && plugin.empty())\n                    proxyStr = \"ssr://\" + urlSafeBase64Encode(hostname + \":\" + port + \":origin:\" + method + \":plain:\" + urlSafeBase64Encode(password) \\\n                               + \"/?group=\" + urlSafeBase64Encode(x.Group) + \"&remarks=\" + urlSafeBase64Encode(remark));\n            }\n            else\n                continue;\n            break;\n        case ProxyType::ShadowsocksR:\n            if(ssr)\n            {\n                proxyStr = \"ssr://\" + urlSafeBase64Encode(hostname + \":\" + port + \":\" + protocol + \":\" + method + \":\" + obfs + \":\" + urlSafeBase64Encode(password) \\\n                           + \"/?group=\" + urlSafeBase64Encode(x.Group) + \"&remarks=\" + urlSafeBase64Encode(remark) \\\n                           + \"&obfsparam=\" + urlSafeBase64Encode(obfsparam) + \"&protoparam=\" + urlSafeBase64Encode(protoparam));\n            }\n            else if(ss)\n            {\n                if(std::find(ss_ciphers.begin(), ss_ciphers.end(), method) != ss_ciphers.end() && protocol == \"origin\" && obfs == \"plain\")\n                    proxyStr = \"ss://\" + urlSafeBase64Encode(method + \":\" + password) + \"@\" + hostname + \":\" + port + \"#\" + urlEncode(remark);\n            }\n            else\n                continue;\n            break;\n        case ProxyType::VMess:\n            if(!vmess)\n                continue;\n            proxyStr = \"vmess://\" + base64Encode(vmessLinkConstruct(remark, hostname, port, faketype, id, aid, transproto, path, host, tlssecure ? \"tls\" : \"\"));\n            break;\n        case ProxyType::Trojan:\n            if(!trojan)\n                continue;\n            proxyStr = \"trojan://\" + password + \"@\" + hostname + \":\" + port + \"?allowInsecure=\" + (x.AllowInsecure.get() ? \"1\" : \"0\");\n            if(!host.empty())\n                proxyStr += \"&sni=\" + host;\n            if(transproto == \"ws\")\n            {\n                proxyStr += \"&ws=1\";\n                if(!path.empty())\n                    proxyStr += \"&wspath=\" + urlEncode(path);\n            }\n            proxyStr += \"#\" + urlEncode(remark);\n            break;\n        default:\n            continue;\n        }\n        allLinks += proxyStr + \"\\n\";\n    }\n\n    if(ext.nodelist)\n        return allLinks;\n    else\n        return base64Encode(allLinks);\n}\n\nstd::string proxyToSSSub(std::string base_conf, std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    rapidjson::Document json, base;\n    std::string remark, hostname, password, method;\n    std::string plugin, pluginopts;\n    std::string protocol, obfs;\n    std::string output_content;\n\n    rapidjson::Document::AllocatorType &alloc = json.GetAllocator();\n    json.SetObject();\n    json.AddMember(\"remarks\", \"\", alloc);\n    json.AddMember(\"server\", \"\", alloc);\n    json.AddMember(\"server_port\", 0, alloc);\n    json.AddMember(\"method\", \"\", alloc);\n    json.AddMember(\"password\", \"\", alloc);\n    json.AddMember(\"plugin\", \"\", alloc);\n    json.AddMember(\"plugin_opts\", \"\", alloc);\n\n    base_conf = trimWhitespace(base_conf);\n    if(base_conf.empty())\n        base_conf = \"{}\";\n    rapidjson::ParseResult result = base.Parse(base_conf.data());\n    if(result)\n    {\n        for(auto iter = base.MemberBegin(); iter != base.MemberEnd(); iter++)\n            json.AddMember(iter->name, iter->value, alloc);\n    }\n    else\n        writeLog(0, std::string(\"SIP008 base loader failed with error: \") + rapidjson::GetParseError_En(result.Code()) + \" (\" + std::to_string(result.Offset()) + \")\", LOG_LEVEL_ERROR);\n\n    rapidjson::Value jsondata;\n    jsondata = json.Move();\n\n    output_content = \"[\";\n    for(Proxy &x : nodes)\n    {\n        remark = x.Remark;\n        hostname = x.Hostname;\n        std::string &password = x.Password;\n        std::string &method = x.EncryptMethod;\n        std::string &plugin = x.Plugin;\n        std::string &pluginopts = x.PluginOption;\n        std::string &protocol = x.Protocol;\n        std::string &obfs = x.OBFS;\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(plugin == \"simple-obfs\")\n                plugin = \"obfs-local\";\n            break;\n        case ProxyType::ShadowsocksR:\n            if(std::find(ss_ciphers.begin(), ss_ciphers.end(), method) == ss_ciphers.end() || protocol != \"origin\" || obfs != \"plain\")\n                continue;\n            break;\n        default:\n            continue;\n        }\n        jsondata[\"remarks\"].SetString(rapidjson::StringRef(remark.c_str(), remark.size()));\n        jsondata[\"server\"].SetString(rapidjson::StringRef(hostname.c_str(), hostname.size()));\n        jsondata[\"server_port\"] = x.Port;\n        jsondata[\"password\"].SetString(rapidjson::StringRef(password.c_str(), password.size()));\n        jsondata[\"method\"].SetString(rapidjson::StringRef(method.c_str(), method.size()));\n        jsondata[\"plugin\"].SetString(rapidjson::StringRef(plugin.c_str(), plugin.size()));\n        jsondata[\"plugin_opts\"].SetString(rapidjson::StringRef(pluginopts.c_str(), pluginopts.size()));\n        output_content += SerializeObject(jsondata) + \",\";\n    }\n    if(output_content.size() > 1)\n        output_content.erase(output_content.size() - 1);\n    output_content += \"]\";\n    return output_content;\n}\n\nstd::string proxyToQuan(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    INIReader ini;\n    ini.store_any_line = true;\n    if(!ext.nodelist && ini.Parse(base_conf) != 0)\n    {\n        writeLog(0, \"Quantumult base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    proxyToQuan(nodes, ini, ruleset_content_array, extra_proxy_group, ext);\n\n    if(ext.nodelist)\n    {\n        string_array allnodes;\n        std::string allLinks;\n        ini.GetAll(\"SERVER\", \"{NONAME}\", allnodes);\n        if(!allnodes.empty())\n            allLinks = join(allnodes, \"\\n\");\n        return base64Encode(allLinks);\n    }\n    return ini.ToString();\n}\n\nvoid proxyToQuan(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    std::string type, proxyStr;\n    tribool scv;\n    std::vector<Proxy> nodelist;\n    string_array remarks_list;\n\n    ini.SetCurrentSection(\"SERVER\");\n    ini.EraseSection();\n    for(Proxy &x : nodes)\n    {\n        std::string remark = x.Remark;\n\n        if(ext.append_proxy_type)\n        {\n            std::string type = getProxyTypeName(x.Type);\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n        }\n\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname, &method = x.EncryptMethod, &password = x.Password, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &edge = x.Edge, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &plugin = x.Plugin, &pluginopts = x.PluginOption, &username = x.Username;\n        std::string port = std::to_string(x.Port);\n        bool &tlssecure = x.TLSSecure;\n\n        switch(x.Type)\n        {\n        case ProxyType::VMess:\n            scv = ext.skip_cert_verify;\n            scv.define(x.AllowInsecure);\n\n            if(method == \"auto\")\n                method = \"chacha20-ietf-poly1305\";\n            proxyStr = remark + \" = vmess, \" + hostname + \", \" + port + \", \" + method + \", \\\"\" + id + \"\\\", group=\" + x.Group;\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true, tls-host=\" + host;\n                if(!scv.is_undef())\n                    proxyStr += \", certificate=\" + std::string(scv.get() ? \"0\" : \"1\");\n            }\n            if(transproto == \"ws\")\n            {\n                proxyStr += \", obfs=ws, obfs-path=\\\"\" + path + \"\\\", obfs-header=\\\"Host: \" + host;\n                if(!edge.empty())\n                    proxyStr += \"[Rr][Nn]Edge: \" + edge;\n                proxyStr += \"\\\"\";\n            }\n\n            if(ext.nodelist)\n                proxyStr = \"vmess://\" + urlSafeBase64Encode(proxyStr);\n            break;\n        case ProxyType::ShadowsocksR:\n            if(ext.nodelist)\n            {\n                proxyStr = \"ssr://\" + urlSafeBase64Encode(hostname + \":\" + port + \":\" + protocol + \":\" + method + \":\" + obfs + \":\" + urlSafeBase64Encode(password) \\\n                           + \"/?group=\" + urlSafeBase64Encode(x.Group) + \"&remarks=\" + urlSafeBase64Encode(remark) \\\n                           + \"&obfsparam=\" + urlSafeBase64Encode(obfsparam) + \"&protoparam=\" + urlSafeBase64Encode(protoparam));\n            }\n            else\n            {\n                proxyStr = remark + \" = shadowsocksr, \" + hostname + \", \" + port + \", \" + method + \", \\\"\" + password + \"\\\", group=\" + x.Group + \", protocol=\" + protocol + \", obfs=\" + obfs;\n                if(!protoparam.empty())\n                    proxyStr += \", protocol_param=\" + protoparam;\n                if(!obfsparam.empty())\n                    proxyStr += \", obfs_param=\" + obfsparam;\n            }\n            break;\n        case ProxyType::Shadowsocks:\n            if(ext.nodelist)\n            {\n                proxyStr = \"ss://\" + urlSafeBase64Encode(method + \":\" + password) + \"@\" + hostname + \":\" + port;\n                if(!plugin.empty() && !pluginopts.empty())\n                {\n                    proxyStr += \"/?plugin=\" + urlEncode(plugin + \";\" + pluginopts);\n                }\n                proxyStr += \"&group=\" + urlSafeBase64Encode(x.Group) + \"#\" + urlEncode(remark);\n            }\n            else\n            {\n                proxyStr = remark + \" = shadowsocks, \" + hostname + \", \" + port + \", \" + method + \", \\\"\" + password + \"\\\", group=\" + x.Group;\n                if(plugin == \"obfs-local\" && !pluginopts.empty())\n                {\n                    proxyStr += \", \" + replaceAllDistinct(pluginopts, \";\", \", \");\n                }\n            }\n            break;\n        case ProxyType::HTTP:\n        case ProxyType::HTTPS:\n            proxyStr = remark + \" = http, upstream-proxy-address=\" + hostname + \", upstream-proxy-port=\" + port + \", group=\" + x.Group;\n            if(!username.empty() && !password.empty())\n                proxyStr += \", upstream-proxy-auth=true, upstream-proxy-username=\" + username + \", upstream-proxy-password=\" + password;\n            else\n                proxyStr += \", upstream-proxy-auth=false\";\n\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true\";\n                if(!host.empty())\n                    proxyStr += \", tls-host=\" + host;\n                if(!scv.is_undef())\n                    proxyStr += \", certificate=\" + std::string(scv.get() ? \"0\" : \"1\");\n            }\n\n            if(ext.nodelist)\n                proxyStr = \"http://\" + urlSafeBase64Encode(proxyStr);\n            break;\n        case ProxyType::SOCKS5:\n            proxyStr = remark + \" = socks, upstream-proxy-address=\" + hostname + \", upstream-proxy-port=\" + port + \", group=\" + x.Group;\n            if(!username.empty() && !password.empty())\n                proxyStr += \", upstream-proxy-auth=true, upstream-proxy-username=\" + username + \", upstream-proxy-password=\" + password;\n            else\n                proxyStr += \", upstream-proxy-auth=false\";\n\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true\";\n                if(!host.empty())\n                    proxyStr += \", tls-host=\" + host;\n                if(!scv.is_undef())\n                    proxyStr += \", certificate=\" + std::string(scv.get() ? \"0\" : \"1\");\n            }\n\n            if(ext.nodelist)\n                proxyStr = \"socks://\" + urlSafeBase64Encode(proxyStr);\n            break;\n        default:\n            continue;\n        }\n\n        ini.Set(\"{NONAME}\", proxyStr);\n        remarks_list.emplace_back(std::move(remark));\n        nodelist.emplace_back(x);\n    }\n\n    if(ext.nodelist)\n        return;\n\n    string_array filtered_nodelist;\n    ini.SetCurrentSection(\"POLICY\");\n    ini.EraseSection();\n\n    std::string singlegroup;\n    std::string name, proxies;\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::Fallback:\n            type = \"static\";\n            break;\n        case ProxyGroupType::URLTest:\n            type = \"auto\";\n            break;\n        case ProxyGroupType::LoadBalance:\n            type = \"balance, round-robin\";\n            break;\n        case ProxyGroupType::SSID:\n            {\n                singlegroup = x.Name + \" : wifi = \" + x.Proxies[0];\n                std::string content, celluar, celluar_matcher = R\"(^(.*?),?celluar\\s?=\\s?(.*?)(,.*)$)\", rem_a, rem_b;\n                for(auto iter = x.Proxies.begin() + 1; iter != x.Proxies.end(); iter++)\n                {\n                    if(regGetMatch(*iter, celluar_matcher, 4, 0, &rem_a, &celluar, &rem_b))\n                    {\n                        content += *iter + \"\\n\";\n                        continue;\n                    }\n                    content += rem_a + rem_b + \"\\n\";\n                }\n                if(!celluar.empty())\n                    singlegroup += \", celluar = \" + celluar;\n                singlegroup += \"\\n\" + replaceAllDistinct(trimOf(content, ','), \",\", \"\\n\");\n                ini.Set(\"{NONAME}\", base64Encode(singlegroup)); //insert order\n            }\n            continue;\n        default:\n            continue;\n        }\n\n        for(const auto &y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n        if(filtered_nodelist.empty())\n            filtered_nodelist.emplace_back(\"direct\");\n\n        if(filtered_nodelist.size() < 2) // force groups with 1 node to be static\n            type = \"static\";\n\n        proxies = join(filtered_nodelist, \"\\n\");\n\n        singlegroup = x.Name + \" : \" + type;\n        if(type == \"static\")\n            singlegroup += \", \" + filtered_nodelist[0];\n        singlegroup += \"\\n\" + proxies + \"\\n\";\n        ini.Set(\"{NONAME}\", base64Encode(singlegroup));\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, -2, ext.overwrite_original_rules, std::string());\n}\n\nstd::string proxyToQuanX(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    INIReader ini;\n    ini.store_any_line = true;\n    ini.AddDirectSaveSection(\"general\");\n    ini.AddDirectSaveSection(\"dns\");\n    ini.AddDirectSaveSection(\"rewrite_remote\");\n    ini.AddDirectSaveSection(\"rewrite_local\");\n    ini.AddDirectSaveSection(\"task_local\");\n    ini.AddDirectSaveSection(\"mitm\");\n    ini.AddDirectSaveSection(\"server_remote\");\n    if(!ext.nodelist && ini.Parse(base_conf) != 0)\n    {\n        writeLog(0, \"QuantumultX base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    proxyToQuanX(nodes, ini, ruleset_content_array, extra_proxy_group, ext);\n\n    if(ext.nodelist)\n    {\n        string_array allnodes;\n        std::string allLinks;\n        ini.GetAll(\"server_local\", \"{NONAME}\", allnodes);\n        if(!allnodes.empty())\n            allLinks = join(allnodes, \"\\n\");\n        return allLinks;\n    }\n    return ini.ToString();\n}\n\nvoid proxyToQuanX(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    std::string type;\n    std::string remark, hostname, port, method;\n    std::string password, plugin, pluginopts;\n    std::string id, transproto, host, path;\n    std::string protocol, protoparam, obfs, obfsparam;\n    std::string proxyStr;\n    tribool udp, tfo, scv, tls13;\n    std::vector<Proxy> nodelist;\n    string_array remarks_list;\n\n    ini.SetCurrentSection(\"server_local\");\n    ini.EraseSection();\n    for(Proxy &x : nodes)\n    {\n        if(ext.append_proxy_type)\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname, &method = x.EncryptMethod, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &password = x.Password, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &username = x.Username;\n        std::string port = std::to_string(x.Port);\n        bool &tlssecure = x.TLSSecure;\n\n        udp = ext.udp;\n        tfo = ext.tfo;\n        scv = ext.skip_cert_verify;\n        tls13 = ext.tls13;\n        udp.define(x.UDP);\n        tfo.define(x.TCPFastOpen);\n        scv.define(x.AllowInsecure);\n        tls13.define(x.TLS13);\n\n        switch(x.Type)\n        {\n        case ProxyType::VMess:\n            if(method == \"auto\")\n                method = \"chacha20-ietf-poly1305\";\n            proxyStr = \"vmess = \" + hostname + \":\" + port + \", method=\" + method + \", password=\" + id + \", aead=\" + (x.AlterId == 0 ? \"true\" : \"false\");\n            if(tlssecure && !tls13.is_undef())\n                proxyStr += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n            if(transproto == \"ws\")\n            {\n                if(tlssecure)\n                    proxyStr += \", obfs=wss\";\n                else\n                    proxyStr += \", obfs=ws\";\n                proxyStr += \", obfs-host=\" + host + \", obfs-uri=\" + path;\n            }\n            else if(tlssecure)\n                proxyStr += \", obfs=over-tls, obfs-host=\" + host;\n            break;\n        case ProxyType::Shadowsocks:\n            proxyStr = \"shadowsocks = \" + hostname + \":\" + port + \", method=\" + method + \", password=\" + password;\n            if(!plugin.empty())\n            {\n                switch(hash_(plugin))\n                {\n                    case \"simple-obfs\"_hash:\n                    case \"obfs-local\"_hash:\n                        if(!pluginopts.empty())\n                            proxyStr += \", \" + replaceAllDistinct(pluginopts, \";\", \", \");\n                        break;\n                    case \"v2ray-plugin\"_hash:\n                        pluginopts = replaceAllDistinct(pluginopts, \";\", \"&\");\n                        plugin = getUrlArg(pluginopts, \"mode\") == \"websocket\" ? \"ws\" : \"\";\n                        host = getUrlArg(pluginopts, \"host\");\n                        path = getUrlArg(pluginopts, \"path\");\n                        tlssecure = pluginopts.find(\"tls\") != pluginopts.npos;\n                        if(tlssecure && plugin == \"ws\")\n                        {\n                            plugin += 's';\n                            if(!tls13.is_undef())\n                                proxyStr += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n                        }\n                        proxyStr += \", obfs=\" + plugin;\n                        if(!host.empty())\n                            proxyStr += \", obfs-host=\" + host;\n                        if(!path.empty())\n                            proxyStr += \", obfs-uri=\" + path;\n                        break;\n                    default: continue;\n                }\n            }\n\n            break;\n        case ProxyType::ShadowsocksR:\n            proxyStr = \"shadowsocks = \" + hostname + \":\" + port + \", method=\" + method + \", password=\" + password + \", ssr-protocol=\" + protocol;\n            if(!protoparam.empty())\n                proxyStr += \", ssr-protocol-param=\" + protoparam;\n            proxyStr += \", obfs=\" + obfs;\n            if(!obfsparam.empty())\n                proxyStr += \", obfs-host=\" + obfsparam;\n            break;\n        case ProxyType::HTTP:\n        case ProxyType::HTTPS:\n            proxyStr = \"http = \" + hostname + \":\" + port + \", username=\" + (username.empty() ? \"none\" : username) + \", password=\" + (password.empty() ? \"none\" : password);\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true\";\n                if(!tls13.is_undef())\n                    proxyStr += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n            }\n            else\n            {\n                proxyStr += \", over-tls=false\";\n            }\n            break;\n        case ProxyType::Trojan:\n            proxyStr = \"trojan = \" + hostname + \":\" + port + \", password=\" + password;\n            if(tlssecure)\n            {\n                proxyStr += \", over-tls=true, tls-host=\" + host;\n                if(!tls13.is_undef())\n                    proxyStr += \", tls13=\" + std::string(tls13 ? \"true\" : \"false\");\n            }\n            else\n            {\n                proxyStr += \", over-tls=false\";\n            }\n            break;\n        default:\n            continue;\n        }\n        if(!tfo.is_undef())\n            proxyStr += \", fast-open=\" + tfo.get_str();\n        if(!udp.is_undef())\n            proxyStr += \", udp-relay=\" + udp.get_str();\n        if(tlssecure && !scv.is_undef() && (x.Type == ProxyType::HTTP || x.Type == ProxyType::Trojan))\n            proxyStr += \", tls-verification=\" + scv.reverse().get_str();\n        proxyStr += \", tag=\" + remark;\n\n        ini.Set(\"{NONAME}\", proxyStr);\n        remarks_list.emplace_back(std::move(remark));\n        nodelist.emplace_back(x);\n    }\n\n    if(ext.nodelist)\n        return;\n\n    string_multimap original_groups;\n    string_array filtered_nodelist;\n    ini.SetCurrentSection(\"policy\");\n    ini.GetItems(original_groups);\n    ini.EraseSection();\n\n    std::string singlegroup;\n    std::string proxies;\n    string_array vArray;\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n            type = \"static\";\n            break;\n        case ProxyGroupType::URLTest:\n            type = \"url-latency-benchmark\";\n            break;\n        case ProxyGroupType::Fallback:\n            type = \"available\";\n            break;\n        case ProxyGroupType::LoadBalance:\n            type = \"round-robin\";\n            break;\n        case ProxyGroupType::SSID:\n            type = \"ssid\";\n            for(auto iter = x.Proxies.begin(); iter != x.Proxies.end(); iter++)\n                filtered_nodelist.emplace_back(replaceAllDistinct(*iter, \"=\", \":\"));\n            break;\n        default:\n            continue;\n        }\n\n        if(x.Type != ProxyGroupType::SSID)\n        {\n            for(const auto &y : x.Proxies)\n                groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n            if(filtered_nodelist.empty())\n                filtered_nodelist.emplace_back(\"direct\");\n\n            if(filtered_nodelist.size() < 2) // force groups with 1 node to be static\n                type = \"static\";\n        }\n\n        auto iter = std::find_if(original_groups.begin(), original_groups.end(), [&](const string_multimap::value_type &n)\n        {\n            std::string groupdata = n.second;\n            std::string::size_type cpos = groupdata.find(\",\");\n            if(cpos != groupdata.npos)\n                return trim(groupdata.substr(0, cpos)) == x.Name;\n            else\n                return false;\n        });\n        if(iter != original_groups.end())\n        {\n            vArray = split(iter->second, \",\");\n            if(vArray.size() > 1)\n            {\n                if(trim(vArray[vArray.size() - 1]).find(\"img-url\") == 0)\n                    filtered_nodelist.emplace_back(trim(vArray[vArray.size() - 1]));\n            }\n        }\n\n        proxies = join(filtered_nodelist, \", \");\n\n        singlegroup = type + \"=\" + x.Name + \", \" + proxies;\n        ini.Set(\"{NONAME}\", singlegroup);\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, -1, ext.overwrite_original_rules, ext.managed_config_prefix);\n\n    //process scripts\n    string_multimap scripts;\n    std::string content, title, url;\n    const std::string pattern = \"^(.*? url script-.*? )(.*?)$\";\n    if(ini.SectionExist(\"rewrite_local\") && !ext.quanx_dev_id.empty())\n    {\n        ini.GetItems(\"rewrite_local\", scripts);\n        ini.EraseSection(\"rewrite_local\");\n        ini.SetCurrentSection(\"rewrite_local\");\n        for(auto &x : scripts)\n        {\n            title = x.first;\n            if(title != \"{NONAME}\")\n                content = title + \"=\" + x.second;\n            else\n                content = x.second;\n\n            if(regMatch(content, pattern))\n            {\n                url = regReplace(content, pattern, \"$2\");\n                if(isLink(url))\n                {\n                    url = ext.managed_config_prefix + \"/qx-script?id=\" + ext.quanx_dev_id + \"&url=\" + urlSafeBase64Encode(url);\n                    content = regReplace(content, pattern, \"$1\") + url;\n                }\n            }\n            ini.Set(\"{NONAME}\", content);\n        }\n    }\n    eraseElements(scripts);\n    string_size pos;\n    if(ini.SectionExist(\"rewrite_remote\") && !ext.quanx_dev_id.empty())\n    {\n        ini.GetItems(\"rewrite_remote\", scripts);\n        ini.EraseSection(\"rewrite_remote\");\n        ini.SetCurrentSection(\"rewrite_remote\");\n        for(auto &x : scripts)\n        {\n            title = x.first;\n            if(title != \"{NONAME}\")\n                content = title + \"=\" + x.second;\n            else\n                content = x.second;\n\n            if(isLink(content))\n            {\n                pos = content.find(\",\");\n                url = ext.managed_config_prefix + \"/qx-rewrite?id=\" + ext.quanx_dev_id + \"&url=\" + urlSafeBase64Encode(content.substr(0, pos));\n                if(pos != content.npos)\n                    url += content.substr(pos);\n                content = url;\n            }\n            ini.Set(\"{NONAME}\", content);\n        }\n    }\n}\n\nstd::string proxyToSSD(std::vector<Proxy> &nodes, std::string &group, std::string &userinfo, extra_settings &ext)\n{\n    rapidjson::StringBuffer sb;\n    rapidjson::Writer<rapidjson::StringBuffer> writer(sb);\n    size_t index = 0;\n\n    if(group.empty())\n        group = \"SSD\";\n\n    writer.StartObject();\n    writer.Key(\"airport\");\n    writer.String(group.data());\n    writer.Key(\"port\");\n    writer.Int(1);\n    writer.Key(\"encryption\");\n    writer.String(\"aes-128-gcm\");\n    writer.Key(\"password\");\n    writer.String(\"password\");\n    if(!userinfo.empty())\n    {\n        std::string data = replaceAllDistinct(userinfo, \"; \", \"&\");\n        std::string upload = getUrlArg(data, \"upload\"), download = getUrlArg(data, \"download\"), total = getUrlArg(data, \"total\"), expiry = getUrlArg(data, \"expire\");\n        double used = (to_number(upload, 0.0) + to_number(download, 0.0)) / std::pow(1024, 3) * 1.0, tot = to_number(total, 0.0) / std::pow(1024, 3) * 1.0;\n        writer.Key(\"traffic_used\");\n        writer.Double(used);\n        writer.Key(\"traffic_total\");\n        writer.Double(tot);\n        if(!expiry.empty())\n        {\n            const time_t rawtime = to_int(expiry);\n            char buffer[30];\n            struct tm *dt = localtime(&rawtime);\n            strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M\", dt);\n            writer.Key(\"expiry\");\n            writer.String(buffer);\n        }\n    }\n    writer.Key(\"servers\");\n    writer.StartArray();\n\n    for(Proxy &x : nodes)\n    {\n        std::string &hostname = x.Hostname, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &obfs = x.OBFS;\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(plugin == \"obfs-local\")\n                plugin = \"simple-obfs\";\n            writer.StartObject();\n            writer.Key(\"server\");\n            writer.String(hostname.data());\n            writer.Key(\"port\");\n            writer.Int(x.Port);\n            writer.Key(\"encryption\");\n            writer.String(method.data());\n            writer.Key(\"password\");\n            writer.String(password.data());\n            writer.Key(\"plugin\");\n            writer.String(plugin.data());\n            writer.Key(\"plugin_options\");\n            writer.String(pluginopts.data());\n            writer.Key(\"remarks\");\n            writer.String(x.Remark.data());\n            writer.Key(\"id\");\n            writer.Int(index);\n            writer.EndObject();\n            break;\n        case ProxyType::ShadowsocksR:\n            if(std::count(ss_ciphers.begin(), ss_ciphers.end(), method) > 0 && protocol == \"origin\" && obfs == \"plain\")\n            {\n                writer.StartObject();\n                writer.Key(\"server\");\n                writer.String(hostname.data());\n                writer.Key(\"port\");\n                writer.Int(x.Port);\n                writer.Key(\"encryption\");\n                writer.String(method.data());\n                writer.Key(\"password\");\n                writer.String(password.data());\n                writer.Key(\"remarks\");\n                writer.String(x.Remark.data());\n                writer.Key(\"id\");\n                writer.Int(index);\n                writer.EndObject();\n                break;\n            }\n            else\n                continue;\n        default:\n            continue;\n        }\n        index++;\n    }\n    writer.EndArray();\n    writer.EndObject();\n    return \"ssd://\" + base64Encode(sb.GetString());\n}\n\nstd::string proxyToMellow(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    INIReader ini;\n    ini.store_any_line = true;\n    if(ini.Parse(base_conf) != 0)\n    {\n        writeLog(0, \"Mellow base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n    proxyToMellow(nodes, ini, ruleset_content_array, extra_proxy_group, ext);\n\n    return ini.ToString();\n}\n\nvoid proxyToMellow(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    std::string proxy;\n    std::string type, remark, hostname, port, username, password, method;\n    std::string plugin, pluginopts;\n    std::string id, aid, transproto, faketype, host, path, quicsecure, quicsecret, tlssecure;\n    std::string url;\n    tribool tfo, scv;\n    std::vector<Proxy> nodelist;\n    string_array vArray, remarks_list, filtered_nodelist;\n\n    ini.SetCurrentSection(\"Endpoint\");\n\n    for(Proxy &x : nodes)\n    {\n        if(ext.append_proxy_type)\n        {\n            std::string type = getProxyTypeName(x.Type);\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n        }\n\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname;\n        port = std::to_string(x.Port);\n\n        tfo = ext.tfo;\n        scv = ext.skip_cert_verify;\n        tfo.define(x.TCPFastOpen);\n        scv.define(x.AllowInsecure);\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            if(!x.Plugin.empty())\n                continue;\n            proxy = remark + \", ss, ss://\" + urlSafeBase64Encode(method + \":\" + password) + \"@\" + hostname + \":\" + port;\n            break;\n        case ProxyType::VMess:\n            proxy = remark + \", vmess1, vmess1://\" + id + \"@\" + hostname + \":\" + port;\n            if(!path.empty())\n                proxy += path;\n            proxy += \"?network=\" + transproto;\n            switch(hash_(transproto))\n            {\n            case \"ws\"_hash:\n                proxy += \"&ws.host=\" + urlEncode(host);\n                break;\n            case \"http\"_hash:\n                if(!host.empty())\n                    proxy += \"&http.host=\" + urlEncode(host);\n                break;\n            case \"quic\"_hash:\n                if(!quicsecure.empty())\n                    proxy += \"&quic.security=\" + quicsecure + \"&quic.key=\" + quicsecret;\n                break;\n            case \"kcp\"_hash:\n                break;\n            case \"tcp\"_hash:\n                break;\n            }\n            proxy += \"&tls=\" + tlssecure;\n            if(tlssecure == \"true\")\n            {\n                if(!host.empty())\n                    proxy += \"&tls.servername=\" + urlEncode(host);\n            }\n            if(!scv.is_undef())\n                proxy += \"&tls.allowinsecure=\" + scv.get_str();\n            if(!tfo.is_undef())\n                proxy += \"&sockopt.tcpfastopen=\" + tfo.get_str();\n            break;\n        case ProxyType::SOCKS5:\n            proxy = remark + \", builtin, socks, address=\" + hostname + \", port=\" + port + \", user=\" + username + \", pass=\" + password;\n            break;\n        case ProxyType::HTTP:\n            proxy = remark + \", builtin, http, address=\" + hostname + \", port=\" + port + \", user=\" + username + \", pass=\" + password;\n            break;\n        default:\n            continue;\n        }\n\n        ini.Set(\"{NONAME}\", proxy);\n        remarks_list.emplace_back(std::move(remark));\n        nodelist.emplace_back(x);\n    }\n\n    ini.SetCurrentSection(\"EndpointGroup\");\n\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n        url.clear();\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::URLTest:\n        case ProxyGroupType::Fallback:\n        case ProxyGroupType::LoadBalance:\n            break;\n        default:\n            continue;\n        }\n\n        for(const auto &y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, false, ext);\n\n        if(filtered_nodelist.empty())\n        {\n            if(remarks_list.empty())\n                filtered_nodelist.emplace_back(\"DIRECT\");\n            else\n                filtered_nodelist = remarks_list;\n        }\n\n        //don't process these for now\n        /*\n        proxy = vArray[1];\n        for(std::string &x : filtered_nodelist)\n            proxy += \",\" + x;\n        if(vArray[1] == \"url-test\" || vArray[1] == \"fallback\" || vArray[1] == \"load-balance\")\n            proxy += \",url=\" + url;\n        */\n\n        proxy = x.Name + \", \";\n        /*\n        for(std::string &y : filtered_nodelist)\n            proxy += y + \":\";\n        proxy = proxy.substr(0, proxy.size() - 1);\n        */\n        proxy += join(filtered_nodelist, \":\");\n        proxy += \", latency, interval=300, timeout=6\"; //use hard-coded values for now\n\n        ini.Set(\"{NONAME}\", proxy); //insert order\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, 0, ext.overwrite_original_rules, std::string());\n}\n\nstd::string proxyToLoon(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)\n{\n    rapidjson::Document json;\n    INIReader ini;\n    std::string proxy;\n    std::string output_nodelist;\n    tribool scv;\n    std::vector<Proxy> nodelist;\n\n    string_array vArray, remarks_list, filtered_nodelist;\n\n    ini.store_any_line = true;\n    if(ini.Parse(base_conf) != INIREADER_EXCEPTION_NONE && !ext.nodelist)\n    {\n        writeLog(0, \"Loon base loader failed with error: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return std::string();\n    }\n\n\n    ini.SetCurrentSection(\"Proxy\");\n    ini.EraseSection();\n\n    for(Proxy &x : nodes)\n    {\n        if(ext.append_proxy_type)\n        {\n            std::string type = getProxyTypeName(x.Type);\n            x.Remark = \"[\" + type + \"] \" + x.Remark;\n        }\n        std::string remark = x.Remark;\n        processRemark(x.Remark, remark, remarks_list);\n\n        std::string &hostname = x.Hostname, &username = x.Username, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam;\n        std::string port = std::to_string(x.Port), aid = std::to_string(x.AlterId);\n        bool &tlssecure = x.TLSSecure;\n\n        tribool scv = ext.skip_cert_verify;\n        scv.define(x.AllowInsecure);\n\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyType::Shadowsocks:\n            proxy = \"Shadowsocks,\" + hostname + \",\" + port + \",\" + method + \",\\\"\" + password + \"\\\"\";\n            if(plugin == \"simple-obfs\" || plugin == \"obfs-local\")\n            {\n                if(!pluginopts.empty())\n                    proxy += \",\" + replaceAllDistinct(replaceAllDistinct(pluginopts, \";obfs-host=\", \",\"), \"obfs=\", \"\");\n            }\n            else if(!plugin.empty())\n                continue;\n            break;\n        case ProxyType::VMess:\n            if(method == \"auto\")\n                method = \"chacha20-ietf-poly1305\";\n\n            proxy = \"vmess,\" + hostname + \",\" + port + \",\" + method + \",\\\"\" + id + \"\\\",over-tls:\" + (tlssecure ? \"true\" : \"false\");\n            if(tlssecure)\n                proxy += \",tls-name:\" + host;\n            switch(hash_(transproto))\n            {\n            case \"tcp\"_hash:\n                proxy += \",transport:tcp\";\n                break;\n            case \"ws\"_hash:\n                proxy += \",transport:ws,path:\" + path + \",host:\" + host;\n                break;\n            default:\n                continue;\n            }\n            if(!scv.is_undef())\n                proxy += \",skip-cert-verify:\" + std::string(scv.get() ? \"1\" : \"0\");\n            break;\n        case ProxyType::ShadowsocksR:\n            proxy = \"ShadowsocksR,\" + hostname + \",\" + port + \",\" + method + \",\\\"\" + password + \"\\\",\" + protocol + \",{\" + protoparam + \"},\" + obfs + \",{\" + obfsparam + \"}\";\n            break;\n        /*\n        case ProxyType::SOCKS5:\n            proxy = \"socks5, \" + hostname + \", \" + port + \", \" + username + \", \" + password;\n            if(ext.skip_cert_verify)\n                proxy += \", skip-cert-verify:1\";\n            break;\n        */\n        case ProxyType::HTTP:\n            proxy = \"http,\" + hostname + \",\" + port + \",\" + username + \",\" + password;\n            break;\n        case ProxyType::Trojan:\n            proxy = \"trojan,\" + hostname + \",\" + port + \",\" + password;\n            if(!host.empty())\n                proxy += \",tls-name:\" + host;\n            if(!scv.is_undef())\n                proxy += \",skip-cert-verify:\" + std::string(scv.get() ? \"1\" : \"0\");\n            break;\n        default:\n            continue;\n        }\n\n        /*\n        if(ext.tfo)\n            proxy += \", tfo=true\";\n        if(ext.udp)\n            proxy += \", udp-relay=true\";\n        */\n\n        if(ext.nodelist)\n            output_nodelist += remark + \" = \" + proxy + \"\\n\";\n        else\n        {\n            ini.Set(\"{NONAME}\", remark + \" = \" + proxy);\n            nodelist.emplace_back(x);\n            remarks_list.emplace_back(std::move(remark));\n        }\n    }\n\n    if(ext.nodelist)\n        return output_nodelist;\n\n    ini.SetCurrentSection(\"Proxy Group\");\n    ini.EraseSection();\n    for(const ProxyGroupConfig &x : extra_proxy_group)\n    {\n        eraseElements(filtered_nodelist);\n        proxy.clear();\n\n        switch(x.Type)\n        {\n        case ProxyGroupType::Select:\n        case ProxyGroupType::URLTest:\n        case ProxyGroupType::Fallback:\n            break;\n        case ProxyGroupType::SSID:\n            if(x.Proxies.size() < 2)\n                continue;\n            proxy = x.TypeStr() + \",default=\" + x.Proxies[0] + \",\";\n            proxy += join(x.Proxies.begin() + 1, x.Proxies.end(), \",\");\n            ini.Set(\"{NONAME}\", x.Name + \" = \" + proxy); //insert order\n            continue;\n        default:\n            continue;\n        }\n\n        for(const auto &y : x.Proxies)\n            groupGenerate(y, nodelist, filtered_nodelist, true, ext);\n\n        if(filtered_nodelist.empty())\n            filtered_nodelist.emplace_back(\"DIRECT\");\n\n        proxy = x.TypeStr() + \",\";\n        /*\n        for(std::string &y : filtered_nodelist)\n            proxy += \",\" + y;\n        */\n        proxy += join(filtered_nodelist, \",\");\n        if(x.Type == ProxyGroupType::URLTest || x.Type == ProxyGroupType::Fallback)\n            proxy += \",url=\" + x.Url + \",interval=\" + std::to_string(x.Interval);\n\n        ini.Set(\"{NONAME}\", x.Name + \" = \" + proxy); //insert order\n    }\n\n    if(ext.enable_rule_generator)\n        rulesetToSurge(ini, ruleset_content_array, -4, ext.overwrite_original_rules, ext.managed_config_prefix);\n\n    return ini.ToString();\n}\n", "#ifndef SUBEXPORT_H_INCLUDED\n#define SUBEXPORT_H_INCLUDED\n\n#include <string>\n\n#ifndef NO_JS_RUNTIME\n#include <quickjspp.hpp>\n#endif // NO_JS_RUNTIME\n\n#include \"../../config/proxygroup.h\"\n#include \"../../config/regmatch.h\"\n#include \"../../parser/config/proxy.h\"\n#include \"../../utils/ini_reader/ini_reader.h\"\n#include \"../../utils/string.h\"\n#include \"../../utils/yamlcpp_extra.h\"\n#include \"ruleconvert.h\"\n\nstruct extra_settings\n{\n    bool enable_rule_generator = true;\n    bool overwrite_original_rules = true;\n    RegexMatchConfigs rename_array;\n    RegexMatchConfigs emoji_array;\n    bool add_emoji = false;\n    bool remove_emoji = false;\n    bool append_proxy_type = false;\n    bool nodelist = false;\n    bool sort_flag = false;\n    bool filter_deprecated = false;\n    bool clash_new_field_name = false;\n    bool clash_script = false;\n    std::string surge_ssr_path;\n    std::string managed_config_prefix;\n    std::string quanx_dev_id;\n    tribool udp = tribool();\n    tribool tfo = tribool();\n    tribool skip_cert_verify = tribool();\n    tribool tls13 = tribool();\n    bool clash_classical_ruleset = false;\n    std::string sort_script = \"\";\n    std::string clash_proxies_style = \"flow\";\n    bool authorized = false;\n\n    extra_settings() {};\n    extra_settings(const extra_settings&) = delete;\n    extra_settings(extra_settings&&) = delete;\n\n#ifndef NO_JS_RUNTIME\n    qjs::Runtime *js_runtime = nullptr;\n    qjs::Context *js_context = nullptr;\n\n    ~extra_settings()\n    {\n        delete js_context;\n        delete js_runtime;\n    }\n#endif // NO_JS_RUNTIME\n};\n\nvoid rulesetToClash(YAML::Node &base_rule, std::vector<RulesetContent> &ruleset_content_array, bool overwrite_original_rules, bool new_field_name);\nvoid rulesetToSurge(INIReader &base_rule, std::vector<RulesetContent> &ruleset_content_array, int surge_ver, bool overwrite_original_rules, std::string remote_path_prefix);\n\nstd::string proxyToClash(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext);\nvoid proxyToClash(std::vector<Proxy> &nodes, YAML::Node &yamlnode, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext);\nstd::string proxyToSurge(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, int surge_ver, extra_settings &ext);\nstd::string proxyToMellow(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nvoid proxyToMellow(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nstd::string proxyToLoon(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nstd::string proxyToSSSub(std::string base_conf, std::vector<Proxy> &nodes, extra_settings &ext);\nstd::string proxyToSingle(std::vector<Proxy> &nodes, int types, extra_settings &ext);\nstd::string proxyToQuanX(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nvoid proxyToQuanX(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nstd::string proxyToQuan(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nvoid proxyToQuan(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext);\nstd::string proxyToSSD(std::vector<Proxy> &nodes, std::string &group, std::string &userinfo, extra_settings &ext);\n\n#endif // SUBEXPORT_H_INCLUDED\n", "#include <iostream>\n#include <string>\n#include <mutex>\n#include <numeric>\n\n#include <inja.hpp>\n#include <yaml-cpp/yaml.h>\n\n#include \"../config/binding.h\"\n#include \"../generator/config/nodemanip.h\"\n#include \"../generator/config/ruleconvert.h\"\n#include \"../generator/config/subexport.h\"\n#include \"../generator/template/templates.h\"\n#include \"../script/cron.h\"\n#include \"../script/script_quickjs.h\"\n#include \"../server/webserver.h\"\n#include \"../utils/base64/base64.h\"\n#include \"../utils/file_extra.h\"\n#include \"../utils/ini_reader/ini_reader.h\"\n#include \"../utils/logger.h\"\n#include \"../utils/network.h\"\n#include \"../utils/regexp.h\"\n#include \"../utils/stl_extra.h\"\n#include \"../utils/string.h\"\n#include \"../utils/string_hash.h\"\n#include \"../utils/system.h\"\n#include \"../utils/system.h\"\n#include \"../utils/urlencode.h\"\n#include \"../utils/yamlcpp_extra.h\"\n#include \"interfaces.h\"\n#include \"multithread.h\"\n#include \"settings.h\"\n#include \"upload.h\"\n#include \"webget.h\"\n\nextern WebServer webServer;\n\nstring_array gRegexBlacklist = {\"(.*)*\"};\n\nvoid refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array);\n\nstd::string parseProxy(const std::string &source)\n{\n    std::string proxy = source;\n    if(source == \"SYSTEM\")\n        proxy = getSystemProxy();\n    else if(source == \"NONE\")\n        proxy = \"\";\n    return proxy;\n}\n\nextern string_array ClashRuleTypes, SurgeRuleTypes, QuanXRuleTypes;\n\nstruct UAProfile\n{\n    std::string head;\n    std::string version_match;\n    std::string version_target;\n    std::string target;\n    tribool clash_new_name = tribool();\n    int surge_ver = -1;\n};\n\nconst std::vector<UAProfile> UAMatchList = {\n    {\"ClashForAndroid\",\"\\\\/([0-9.]+)\",\"2.0\",\"clash\",true},\n    {\"ClashForAndroid\",\"\\\\/([0-9.]+)R\",\"\",\"clashr\",false},\n    {\"ClashForAndroid\",\"\",\"\",\"clash\",false},\n    {\"ClashforWindows\",\"\\\\/([0-9.]+)\",\"0.11\",\"clash\",true},\n    {\"ClashforWindows\",\"\",\"\",\"clash\",false},\n    {\"ClashX Pro\",\"\",\"\",\"clash\",true},\n    {\"ClashX\",\"\\\\/([0-9.]+)\",\"0.13\",\"clash\",true},\n    {\"Clash\",\"\",\"\",\"clash\",true},\n    {\"Kitsunebi\",\"\",\"\",\"v2ray\"},\n    {\"Loon\",\"\",\"\",\"loon\"},\n    {\"Pharos\",\"\",\"\",\"mixed\"},\n    {\"Potatso\",\"\",\"\",\"mixed\"},\n    {\"Quantumult%20X\",\"\",\"\",\"quanx\"},\n    {\"Quantumult\",\"\",\"\",\"quan\"},\n    {\"Qv2ray\",\"\",\"\",\"v2ray\"},\n    {\"Shadowrocket\",\"\",\"\",\"mixed\"},\n    {\"Surfboard\",\"\",\"\",\"surfboard\"},\n    {\"Surge\",\"\\\\/([0-9.]+).*x86\",\"906\",\"surge\",false,4}, /// Surge for Mac (supports VMess)\n    {\"Surge\",\"\\\\/([0-9.]+).*x86\",\"368\",\"surge\",false,3}, /// Surge for Mac (supports new rule types and Shadowsocks without plugin)\n    {\"Surge\",\"\\\\/([0-9.]+)\",\"1419\",\"surge\",false,4}, /// Surge iOS 4 (first version)\n    {\"Surge\",\"\\\\/([0-9.]+)\",\"900\",\"surge\",false,3}, /// Surge iOS 3 (approx)\n    {\"Surge\",\"\",\"\",\"surge\",false,2}, /// any version of Surge as fallback\n    {\"Trojan-Qt5\",\"\",\"\",\"trojan\"},\n    {\"V2rayU\",\"\",\"\",\"v2ray\"},\n    {\"V2RayX\",\"\",\"\",\"v2ray\"}\n};\n\nbool verGreaterEqual(const std::string &src_ver, const std::string &target_ver)\n{\n    string_size src_pos_beg = 0, src_pos_end, target_pos_beg = 0, target_pos_end;\n    while(true)\n    {\n        src_pos_end = src_ver.find('.', src_pos_beg);\n        if(src_pos_end == src_ver.npos)\n            src_pos_end = src_ver.size();\n        int part_src = std::stoi(src_ver.substr(src_pos_beg, src_pos_end - src_pos_beg));\n        target_pos_end = target_ver.find('.', target_pos_beg);\n        if(target_pos_end == target_ver.npos)\n            target_pos_end = target_ver.size();\n        int part_target = std::stoi(target_ver.substr(target_pos_beg, target_pos_end - target_pos_beg));\n        if(part_src > part_target)\n            break;\n        else if(part_src < part_target)\n            return false;\n        else if(src_pos_end >= src_ver.size() - 1 || target_pos_end >= target_ver.size() - 1)\n            break;\n        src_pos_beg = src_pos_end + 1;\n        target_pos_beg = target_pos_end + 1;\n    }\n    return true;\n\n}\n\nvoid matchUserAgent(const std::string &user_agent, std::string &target, tribool &clash_new_name, int &surge_ver)\n{\n    if(user_agent.empty())\n        return;\n    for(const UAProfile &x : UAMatchList)\n    {\n        if(startsWith(user_agent, x.head))\n        {\n            if(!x.version_match.empty())\n            {\n                std::string version;\n                if(regGetMatch(user_agent, x.version_match, 2, 0, &version))\n                    continue;\n                if(!x.version_target.empty() && !verGreaterEqual(version, x.version_target))\n                    continue;\n            }\n            target = x.target;\n            clash_new_name = x.clash_new_name;\n            if(x.surge_ver != -1)\n                surge_ver = x.surge_ver;\n            return;\n        }\n    }\n    return;\n}\n\nstd::string getConvertedRuleset(RESPONSE_CALLBACK_ARGS)\n{\n    std::string url = urlDecode(getUrlArg(request.argument, \"url\")), type = getUrlArg(request.argument, \"type\");\n    return convertRuleset(fetchFile(url, parseProxy(global.proxyRuleset), global.cacheRuleset), to_int(type));\n}\n\nstd::string getRuleset(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n    /// type: 1 for Surge, 2 for Quantumult X, 3 for Clash domain rule-provider, 4 for Clash ipcidr rule-provider, 5 for Surge DOMAIN-SET, 6 for Clash classical ruleset\n    std::string url = urlSafeBase64Decode(getUrlArg(argument, \"url\")), type = getUrlArg(argument, \"type\"), group = urlSafeBase64Decode(getUrlArg(argument, \"group\"));\n    std::string output_content, dummy;\n    int type_int = to_int(type, 0);\n\n    if(!url.size() || !type.size() || (type_int == 2 && !group.size()) || (type_int < 1 || type_int > 6))\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n\n    std::string proxy = parseProxy(global.proxyRuleset);\n    string_array vArray = split(url, \"|\");\n    for(std::string &x : vArray)\n        x.insert(0, \"ruleset,\");\n    std::vector<RulesetContent> rca;\n    RulesetConfigs confs = INIBinding::from<RulesetConfig>::from_ini(vArray);\n    refreshRulesets(confs, rca);\n    for(RulesetContent &x : rca)\n    {\n        std::string content = x.rule_content.get();\n        output_content += convertRuleset(content, x.rule_type);\n    }\n\n    if(!output_content.size())\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n\n    std::string strLine;\n    std::stringstream ss;\n    const std::string rule_match_regex = \"^(.*?,.*?)(,.*)(,.*)$\";\n\n    ss << output_content;\n    char delimiter = getLineBreak(output_content);\n    std::string::size_type lineSize, posb, pose;\n    auto filterLine = [&]()\n    {\n        posb = 0;\n        pose = strLine.find(',');\n        if(pose == strLine.npos)\n            return 1;\n        posb = pose + 1;\n        pose = strLine.find(',', posb);\n        if(pose == strLine.npos)\n        {\n            pose = strLine.size();\n            if(strLine[pose - 1] == '\\r')\n                pose--;\n        }\n        pose -= posb;\n        return 0;\n    };\n\n    lineSize = output_content.size();\n    output_content.clear();\n    output_content.reserve(lineSize);\n\n    if(type_int == 3 || type_int == 4 || type_int == 6)\n        output_content = \"payload:\\n\";\n\n    while(getline(ss, strLine, delimiter))\n    {\n        if(strFind(strLine, \"//\"))\n        {\n            strLine.erase(strLine.find(\"//\"));\n            strLine = trimWhitespace(strLine);\n        }\n        switch(type_int)\n        {\n        case 2:\n            if(!std::any_of(QuanXRuleTypes.begin(), QuanXRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))\n                continue;\n            break;\n        case 1:\n            if(!std::any_of(SurgeRuleTypes.begin(), SurgeRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))\n                continue;\n            break;\n        case 3:\n            if(!startsWith(strLine, \"DOMAIN-SUFFIX,\") && !startsWith(strLine, \"DOMAIN,\"))\n                continue;\n            if(filterLine())\n                continue;\n            output_content += \"  - '\";\n            if(strLine[posb - 2] == 'X')\n                output_content += \"+.\";\n            output_content += strLine.substr(posb, pose);\n            output_content += \"'\\n\";\n            continue;\n        case 4:\n            if(!startsWith(strLine, \"IP-CIDR,\") && !startsWith(strLine, \"IP-CIDR6,\"))\n                continue;\n            if(filterLine())\n                continue;\n            output_content += \"  - '\";\n            output_content += strLine.substr(posb, pose);\n            output_content += \"'\\n\";\n            continue;\n        case 5:\n            if(!startsWith(strLine, \"DOMAIN-SUFFIX,\") && !startsWith(strLine, \"DOMAIN,\"))\n                continue;\n            if(filterLine())\n                continue;\n            output_content += strLine.substr(posb, pose);\n            output_content += '\\n';\n            continue;\n        case 6:\n            if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))\n                continue;\n            output_content += \"  - \";\n        }\n\n        lineSize = strLine.size();\n        if(lineSize && strLine[lineSize - 1] == '\\r') //remove line break\n            strLine.erase(--lineSize);\n\n        if(!strLine.empty() && (strLine[0] != ';' && strLine[0] != '#' && !(lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')))\n        {\n            if(type_int == 2)\n            {\n                if(startsWith(strLine, \"IP-CIDR6\"))\n                    strLine.replace(0, 8, \"IP6-CIDR\");\n                strLine += \",\" + group;\n                if(count_least(strLine, ',', 3) && regReplace(strLine, rule_match_regex, \"$2\") == \",no-resolve\")\n                    strLine = regReplace(strLine, rule_match_regex, \"$1$3$2\");\n                else\n                    strLine = regReplace(strLine, rule_match_regex, \"$1$3\");\n            }\n        }\n        output_content += strLine;\n        output_content += '\\n';\n    }\n\n    if(output_content == \"payload:\\n\")\n    {\n        switch(type_int)\n        {\n        case 3:\n            output_content += \"  - '--placeholder--'\";\n            break;\n        case 4:\n            output_content += \"  - '0.0.0.0/32'\";\n            break;\n        case 6:\n            output_content += \"  - 'DOMAIN,--placeholder--'\";\n            break;\n        }\n    }\n    return output_content;\n}\n\nvoid checkExternalBase(const std::string &path, std::string &dest)\n{\n    if(isLink(path) || (startsWith(path, global.basePath) && fileExist(path)))\n        dest = path;\n}\n\nstd::string subconverter(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    std::string argTarget = getUrlArg(argument, \"target\"), argSurgeVer = getUrlArg(argument, \"ver\");\n    tribool argClashNewField = getUrlArg(argument, \"new_name\");\n    int intSurgeVer = argSurgeVer.size() ? to_int(argSurgeVer, 3) : 3;\n    if(argTarget == \"auto\")\n        matchUserAgent(request.headers[\"User-Agent\"], argTarget, argClashNewField, intSurgeVer);\n\n    /// don't try to load groups or rulesets when generating simple subscriptions\n    bool lSimpleSubscription = false;\n    switch(hash_(argTarget))\n    {\n    case \"ss\"_hash: case \"ssd\"_hash: case \"ssr\"_hash: case \"sssub\"_hash: case \"v2ray\"_hash: case \"trojan\"_hash: case \"mixed\"_hash:\n        lSimpleSubscription = true;\n        break;\n    case \"clash\"_hash: case \"clashr\"_hash: case \"surge\"_hash: case \"quan\"_hash: case \"quanx\"_hash: case \"loon\"_hash: case \"surfboard\"_hash: case \"mellow\"_hash:\n        break;\n    default:\n        *status_code = 400;\n        return \"Invalid target!\";\n    }\n    //check if we need to read configuration\n    if((!global.APIMode || global.CFWChildProcess) && !global.generatorMode)\n        readConf();\n\n    /// string values\n    std::string argUrl = urlDecode(getUrlArg(argument, \"url\"));\n    std::string argGroupName = urlDecode(getUrlArg(argument, \"group\")), argUploadPath = getUrlArg(argument, \"upload_path\");\n    std::string argIncludeRemark = urlDecode(getUrlArg(argument, \"include\")), argExcludeRemark = urlDecode(getUrlArg(argument, \"exclude\"));\n    std::string argCustomGroups = urlSafeBase64Decode(getUrlArg(argument, \"groups\")), argCustomRulesets = urlSafeBase64Decode(getUrlArg(argument, \"ruleset\")), argExternalConfig = urlDecode(getUrlArg(argument, \"config\"));\n    std::string argDeviceID = getUrlArg(argument, \"dev_id\"), argFilename = urlDecode(getUrlArg(argument, \"filename\")), argUpdateInterval = getUrlArg(argument, \"interval\"), argUpdateStrict = getUrlArg(argument, \"strict\");\n    std::string argRenames = urlDecode(getUrlArg(argument, \"rename\")), argFilterScript = urlDecode(getUrlArg(argument, \"filter_script\"));\n\n    /// switches with default value\n    tribool argUpload = getUrlArg(argument, \"upload\"), argEmoji = getUrlArg(argument, \"emoji\"), argAddEmoji = getUrlArg(argument, \"add_emoji\"), argRemoveEmoji = getUrlArg(argument, \"remove_emoji\");\n    tribool argAppendType = getUrlArg(argument, \"append_type\"), argTFO = getUrlArg(argument, \"tfo\"), argUDP = getUrlArg(argument, \"udp\"), argGenNodeList = getUrlArg(argument, \"list\");\n    tribool argSort = getUrlArg(argument, \"sort\"), argUseSortScript = getUrlArg(argument, \"sort_script\");\n    tribool argGenClashScript = getUrlArg(argument, \"script\"), argEnableInsert = getUrlArg(argument, \"insert\");\n    tribool argSkipCertVerify = getUrlArg(argument, \"scv\"), argFilterDeprecated = getUrlArg(argument, \"fdn\"), argExpandRulesets = getUrlArg(argument, \"expand\"), argAppendUserinfo = getUrlArg(argument, \"append_info\");\n    tribool argPrependInsert = getUrlArg(argument, \"prepend\"), argGenClassicalRuleProvider = getUrlArg(argument, \"classic\"), argTLS13 = getUrlArg(argument, \"tls13\");\n\n    std::string base_content, output_content;\n    ProxyGroupConfigs lCustomProxyGroups = global.customProxyGroups;\n    RulesetConfigs lCustomRulesets = global.customRulesets;\n    string_array lIncludeRemarks = global.includeRemarks, lExcludeRemarks = global.excludeRemarks;\n    std::vector<RulesetContent> lRulesetContent;\n    extra_settings ext;\n    std::string subInfo, dummy;\n    int interval = argUpdateInterval.size() ? to_int(argUpdateInterval, global.updateInterval) : global.updateInterval;\n    bool authorized = !global.APIMode || getUrlArg(argument, \"token\") == global.accessToken, strict = argUpdateStrict.size() ? argUpdateStrict == \"true\" : global.updateStrict;\n\n    if(std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argIncludeRemark) != gRegexBlacklist.cend() || std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argExcludeRemark) != gRegexBlacklist.cend())\n        return \"Invalid request!\";\n\n    /// for external configuration\n    std::string lClashBase = global.clashBase, lSurgeBase = global.surgeBase, lMellowBase = global.mellowBase, lSurfboardBase = global.surfboardBase;\n    std::string lQuanBase = global.quanBase, lQuanXBase = global.quanXBase, lLoonBase = global.loonBase, lSSSubBase = global.SSSubBase;\n\n    /// validate urls\n    argEnableInsert.define(global.enableInsert);\n    if(!argUrl.size() && (!global.APIMode || authorized))\n        argUrl = global.defaultUrls;\n    if((!argUrl.size() && !(global.insertUrls.size() && argEnableInsert)) || !argTarget.size())\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n\n    /// load request arguments as template variables\n    string_array req_args = split(argument, \"&\");\n    string_map req_arg_map;\n    for(std::string &x : req_args)\n    {\n        string_size pos = x.find(\"=\");\n        if(pos == x.npos)\n        {\n            req_arg_map[x] = \"\";\n            continue;\n        }\n        if(x.substr(0, pos) == \"token\")\n            continue;\n        req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);\n    }\n    req_arg_map[\"target\"] = argTarget;\n    req_arg_map[\"ver\"] = std::to_string(intSurgeVer);\n\n    /// save template variables\n    template_args tpl_args;\n    tpl_args.global_vars = global.templateVars;\n    tpl_args.request_params = req_arg_map;\n\n    /// check for proxy settings\n    std::string proxy = parseProxy(global.proxySubscription);\n\n    /// check other flags\n    ext.authorized = authorized;\n    ext.append_proxy_type = argAppendType.get(global.appendType);\n    if((argTarget == \"clash\" || argTarget == \"clashr\") && argGenClashScript.is_undef())\n        argExpandRulesets.define(true);\n\n    ext.clash_proxies_style = global.clashProxiesStyle;\n\n    /// read preference from argument, assign global var if not in argument\n    ext.tfo.define(argTFO).define(global.TFOFlag);\n    ext.udp.define(argUDP).define(global.UDPFlag);\n    ext.skip_cert_verify.define(argSkipCertVerify).define(global.skipCertVerify);\n    ext.tls13.define(argTLS13).define(global.TLS13Flag);\n\n    ext.sort_flag = argSort.get(global.enableSort);\n    argUseSortScript.define(global.sortScript.size() != 0);\n    if(ext.sort_flag && argUseSortScript)\n        ext.sort_script = global.sortScript;\n    ext.filter_deprecated = argFilterDeprecated.get(global.filterDeprecated);\n    ext.clash_new_field_name = argClashNewField.get(global.clashUseNewField);\n    ext.clash_script = argGenClashScript.get();\n    ext.clash_classical_ruleset = argGenClassicalRuleProvider.get();\n    if(!argExpandRulesets)\n        ext.clash_new_field_name = true;\n    else\n        ext.clash_script = false;\n\n    ext.nodelist = argGenNodeList;\n    ext.surge_ssr_path = global.surgeSSRPath;\n    ext.quanx_dev_id = argDeviceID.size() ? argDeviceID : global.quanXDevID;\n    ext.enable_rule_generator = global.enableRuleGen;\n    ext.overwrite_original_rules = global.overwriteOriginalRules;\n    if(!argExpandRulesets)\n        ext.managed_config_prefix = global.managedConfigPrefix;\n\n    /// load external configuration\n    if(argExternalConfig.empty())\n        argExternalConfig = global.defaultExtConfig;\n    if(argExternalConfig.size())\n    {\n        //std::cerr<<\"External configuration file provided. Loading...\\n\";\n        writeLog(0, \"External configuration file provided. Loading...\", LOG_LEVEL_INFO);\n        ExternalConfig extconf;\n        extconf.tpl_args = &tpl_args;\n        if(loadExternalConfig(argExternalConfig, extconf) == 0)\n        {\n            if(!ext.nodelist)\n            {\n                checkExternalBase(extconf.sssub_rule_base, lSSSubBase);\n                if(!lSimpleSubscription)\n                {\n                    checkExternalBase(extconf.clash_rule_base, lClashBase);\n                    checkExternalBase(extconf.surge_rule_base, lSurgeBase);\n                    checkExternalBase(extconf.surfboard_rule_base, lSurfboardBase);\n                    checkExternalBase(extconf.mellow_rule_base, lMellowBase);\n                    checkExternalBase(extconf.quan_rule_base, lQuanBase);\n                    checkExternalBase(extconf.quanx_rule_base, lQuanXBase);\n                    checkExternalBase(extconf.loon_rule_base, lLoonBase);\n\n                    if(extconf.surge_ruleset.size())\n                        lCustomRulesets = extconf.surge_ruleset;\n                    if(extconf.custom_proxy_group.size())\n                        lCustomProxyGroups = extconf.custom_proxy_group;\n                    ext.enable_rule_generator = extconf.enable_rule_generator;\n                    ext.overwrite_original_rules = extconf.overwrite_original_rules;\n                }\n            }\n            if(extconf.rename.size())\n                ext.rename_array = extconf.rename;\n            if(extconf.emoji.size())\n                ext.emoji_array = extconf.emoji;\n            if(extconf.include.size())\n                lIncludeRemarks = extconf.include;\n            if(extconf.exclude.size())\n                lExcludeRemarks = extconf.exclude;\n            argAddEmoji.define(extconf.add_emoji);\n            argRemoveEmoji.define(extconf.remove_old_emoji);\n        }\n    }\n    else\n    {\n        if(!lSimpleSubscription)\n        {\n            /// loading custom groups\n            if(argCustomGroups.size() && !ext.nodelist)\n            {\n                string_array vArray = split(argCustomGroups, \"@\");\n                lCustomProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n            }\n\n            /// loading custom rulesets\n            if(argCustomRulesets.size() && !ext.nodelist)\n            {\n                string_array vArray = split(argCustomRulesets, \"@\");\n                lCustomRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n            }\n        }\n    }\n    if(ext.enable_rule_generator && !ext.nodelist && !lSimpleSubscription)\n    {\n        if(lCustomRulesets != global.customRulesets)\n            refreshRulesets(lCustomRulesets, lRulesetContent);\n        else\n        {\n            if(global.updateRulesetOnRequest)\n                refreshRulesets(global.customRulesets, global.rulesetsContent);\n            lRulesetContent = global.rulesetsContent;\n        }\n    }\n\n    if(!argEmoji.is_undef())\n    {\n        argAddEmoji.set(argEmoji);\n        argRemoveEmoji.set(true);\n    }\n    ext.add_emoji = argAddEmoji.get(global.addEmoji);\n    ext.remove_emoji = argRemoveEmoji.get(global.removeEmoji);\n    if(ext.add_emoji && ext.emoji_array.empty())\n        ext.emoji_array = safe_get_emojis();\n    if(argRenames.size())\n        ext.rename_array = INIBinding::from<RegexMatchConfig>::from_ini(split(argRenames, \"`\"), \"@\");\n    else if(ext.rename_array.empty())\n        ext.rename_array = safe_get_renames();\n\n    /// check custom include/exclude settings\n    if(argIncludeRemark.size() && regValid(argIncludeRemark))\n        lIncludeRemarks = string_array{argIncludeRemark};\n    if(argExcludeRemark.size() && regValid(argExcludeRemark))\n        lExcludeRemarks = string_array{argExcludeRemark};\n\n    /// initialize script runtime\n    if(authorized && !global.scriptCleanContext)\n    {\n        ext.js_runtime = new qjs::Runtime();\n        script_runtime_init(*ext.js_runtime);\n        ext.js_context = new qjs::Context(*ext.js_runtime);\n        script_context_init(*ext.js_context);\n    }\n\n    //start parsing urls\n    RegexMatchConfigs stream_temp = safe_get_streams(), time_temp = safe_get_times();\n\n    //loading urls\n    string_array urls;\n    std::vector<Proxy> nodes, insert_nodes;\n    int groupID = 0;\n\n    parse_settings parse_set;\n    parse_set.proxy = &proxy;\n    parse_set.exclude_remarks = &lExcludeRemarks;\n    parse_set.include_remarks = &lIncludeRemarks;\n    parse_set.stream_rules = &stream_temp;\n    parse_set.time_rules = &time_temp;\n    parse_set.sub_info = &subInfo;\n    parse_set.authorized = authorized;\n    parse_set.request_header = &request.headers;\n    parse_set.js_runtime = ext.js_runtime;\n    parse_set.js_context = ext.js_context;\n\n    if(global.insertUrls.size() && argEnableInsert)\n    {\n        groupID = -1;\n        urls = split(global.insertUrls, \"|\");\n        importItems(urls, true);\n        for(std::string &x : urls)\n        {\n            x = regTrim(x);\n            writeLog(0, \"Fetching node data from url '\" + x + \"'.\", LOG_LEVEL_INFO);\n            if(addNodes(x, insert_nodes, groupID, parse_set) == -1)\n            {\n                if(global.skipFailedLinks)\n                    writeLog(0, \"The following link doesn't contain any valid node info: \" + x, LOG_LEVEL_WARNING);\n                else\n                {\n                    *status_code = 400;\n                    return \"The following link doesn't contain any valid node info: \" + x;\n                }\n            }\n            groupID--;\n        }\n    }\n    urls = split(argUrl, \"|\");\n    importItems(urls, true);\n    groupID = 0;\n    for(std::string &x : urls)\n    {\n        x = regTrim(x);\n        //std::cerr<<\"Fetching node data from url '\"<<x<<\"'.\"<<std::endl;\n        writeLog(0, \"Fetching node data from url '\" + x + \"'.\", LOG_LEVEL_INFO);\n        if(addNodes(x, nodes, groupID, parse_set) == -1)\n        {\n            if(global.skipFailedLinks)\n                writeLog(0, \"The following link doesn't contain any valid node info: \" + x, LOG_LEVEL_WARNING);\n            else\n            {\n                *status_code = 400;\n                return \"The following link doesn't contain any valid node info: \" + x;\n            }\n        }\n        groupID++;\n    }\n    //exit if found nothing\n    if(!nodes.size() && !insert_nodes.size())\n    {\n        *status_code = 400;\n        return \"No nodes were found!\";\n    }\n    if(subInfo.size() && argAppendUserinfo.get(global.appendUserinfo))\n        response.headers.emplace(\"Subscription-UserInfo\", subInfo);\n\n    if(request.method == \"HEAD\")\n        return \"\";\n\n    argPrependInsert.define(global.prependInsert);\n    if(argPrependInsert)\n    {\n        std::move(nodes.begin(), nodes.end(), std::back_inserter(insert_nodes));\n        nodes.swap(insert_nodes);\n    }\n    else\n    {\n        std::move(insert_nodes.begin(), insert_nodes.end(), std::back_inserter(nodes));\n    }\n    //run filter script\n    std::string filterScript = global.filterScript;\n    if(authorized && !argFilterScript.empty())\n        filterScript = argFilterScript;\n    if(filterScript.size())\n    {\n        if(startsWith(filterScript, \"path:\"))\n            filterScript = fileGet(filterScript.substr(5), false);\n        /*\n        duk_context *ctx = duktape_init();\n        if(ctx)\n        {\n            defer(duk_destroy_heap(ctx);)\n            if(duktape_peval(ctx, filterScript) == 0)\n            {\n                auto filter = [&](const Proxy &x)\n                {\n                    duk_get_global_string(ctx, \"filter\");\n                    duktape_push_Proxy(ctx, x);\n                    duk_pcall(ctx, 1);\n                    return !duktape_get_res_bool(ctx);\n                };\n                nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());\n            }\n            else\n            {\n                writeLog(0, \"Error when trying to parse script:\\n\" + duktape_get_err_stack(ctx), LOG_LEVEL_ERROR);\n                duk_pop(ctx); /// pop err\n            }\n        }\n        */\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n        {\n            try\n            {\n                ctx.eval(filterScript);\n                auto filter = (std::function<bool(const Proxy&)>) ctx.eval(\"filter\");\n                nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());\n            }\n            catch(qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n\n    //check custom group name\n    if(argGroupName.size())\n        for(Proxy &x : nodes)\n            x.Group = argGroupName;\n\n    //do pre-process now\n    preprocessNodes(nodes, ext);\n\n    /*\n    //insert node info to template\n    int index = 0;\n    std::string template_node_prefix;\n    for(Proxy &x : nodes)\n    {\n        template_node_prefix = std::to_string(index) + \".\";\n        tpl_args.node_list[template_node_prefix + \"remarks\"] = x.remarks;\n        tpl_args.node_list[template_node_prefix + \"group\"] = x.Group;\n        tpl_args.node_list[template_node_prefix + \"groupid\"] = std::to_string(x.GroupId);\n        index++;\n    }\n    */\n\n    ProxyGroupConfigs dummy_group;\n    std::vector<RulesetContent> dummy_ruleset;\n    std::string managed_url = base64Decode(urlDecode(getUrlArg(argument, \"profile_data\")));\n    if(managed_url.empty())\n        managed_url = global.managedConfigPrefix + \"/sub?\" + argument;\n\n    //std::cerr<<\"Generate target: \";\n    proxy = parseProxy(global.proxyConfig);\n    switch(hash_(argTarget))\n    {\n    case \"clash\"_hash: case \"clashr\"_hash:\n        writeLog(0, argTarget == \"clashr\" ? \"Generate target: ClashR\" : \"Generate target: Clash\", LOG_LEVEL_INFO);\n        tpl_args.local_vars[\"clash.new_field_name\"] = ext.clash_new_field_name ? \"true\" : \"false\";\n        response.headers[\"profile-update-interval\"] = std::to_string(interval / 3600);\n        if(ext.nodelist)\n        {\n            YAML::Node yamlnode;\n            proxyToClash(nodes, yamlnode, dummy_group, argTarget == \"clashr\", ext);\n            output_content = YAML::Dump(yamlnode);\n        }\n        else\n        {\n            if(render_template(fetchFile(lClashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n            output_content = proxyToClash(nodes, base_content, lRulesetContent, lCustomProxyGroups, argTarget == \"clashr\", ext);\n        }\n\n        if(argUpload)\n            uploadGist(argTarget, argUploadPath, output_content, false);\n        break;\n    case \"surge\"_hash:\n\n        writeLog(0, \"Generate target: Surge \" + std::to_string(intSurgeVer), LOG_LEVEL_INFO);\n\n        if(ext.nodelist)\n        {\n            output_content = proxyToSurge(nodes, base_content, dummy_ruleset, dummy_group, intSurgeVer, ext);\n\n            if(argUpload)\n                uploadGist(\"surge\" + argSurgeVer + \"list\", argUploadPath, output_content, true);\n        }\n        else\n        {\n            if(render_template(fetchFile(lSurgeBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n            output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, intSurgeVer, ext);\n\n            if(argUpload)\n                uploadGist(\"surge\" + argSurgeVer, argUploadPath, output_content, true);\n\n            if(global.writeManagedConfig && global.managedConfigPrefix.size())\n                output_content = \"#!MANAGED-CONFIG \" + managed_url + (interval ? \" interval=\" + std::to_string(interval) : \"\") \\\n                 + \" strict=\" + std::string(strict ? \"true\" : \"false\") + \"\\n\\n\" + output_content;\n        }\n        break;\n    case \"surfboard\"_hash:\n        writeLog(0, \"Generate target: Surfboard\", LOG_LEVEL_INFO);\n\n        if(render_template(fetchFile(lSurfboardBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n        {\n            *status_code = 400;\n            return base_content;\n        }\n        output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, -3, ext);\n        if(argUpload)\n            uploadGist(\"surfboard\", argUploadPath, output_content, true);\n\n        if(global.writeManagedConfig && global.managedConfigPrefix.size())\n            output_content = \"#!MANAGED-CONFIG \" + managed_url + (interval ? \" interval=\" + std::to_string(interval) : \"\") \\\n                 + \" strict=\" + std::string(strict ? \"true\" : \"false\") + \"\\n\\n\" + output_content;\n        break;\n    case \"mellow\"_hash:\n        writeLog(0, \"Generate target: Mellow\", LOG_LEVEL_INFO);\n\n        if(render_template(fetchFile(lMellowBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n        {\n            *status_code = 400;\n            return base_content;\n        }\n        output_content = proxyToMellow(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"mellow\", argUploadPath, output_content, true);\n        break;\n    case \"sssub\"_hash:\n        writeLog(0, \"Generate target: SS Subscription\", LOG_LEVEL_INFO);\n\n        if(render_template(fetchFile(lSSSubBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n        {\n            *status_code = 400;\n            return base_content;\n        }\n        output_content = proxyToSSSub(base_content, nodes, ext);\n        if(argUpload)\n            uploadGist(\"sssub\", argUploadPath, output_content, false);\n        break;\n    case \"ss\"_hash:\n        writeLog(0, \"Generate target: SS\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 1, ext);\n        if(argUpload)\n            uploadGist(\"ss\", argUploadPath, output_content, false);\n        break;\n    case \"ssr\"_hash:\n        writeLog(0, \"Generate target: SSR\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 2, ext);\n        if(argUpload)\n            uploadGist(\"ssr\", argUploadPath, output_content, false);\n        break;\n    case \"v2ray\"_hash:\n        writeLog(0, \"Generate target: v2rayN\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 4, ext);\n        if(argUpload)\n            uploadGist(\"v2ray\", argUploadPath, output_content, false);\n        break;\n    case \"trojan\"_hash:\n        writeLog(0, \"Generate target: Trojan\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 8, ext);\n        if(argUpload)\n            uploadGist(\"trojan\", argUploadPath, output_content, false);\n        break;\n    case \"mixed\"_hash:\n        writeLog(0, \"Generate target: Standard Subscription\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 15, ext);\n        if(argUpload)\n            uploadGist(\"sub\", argUploadPath, output_content, false);\n        break;\n    case \"quan\"_hash:\n        writeLog(0, \"Generate target: Quantumult\", LOG_LEVEL_INFO);\n        if(!ext.nodelist)\n        {\n            if(render_template(fetchFile(lQuanBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n        }\n\n        output_content = proxyToQuan(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"quan\", argUploadPath, output_content, false);\n        break;\n    case \"quanx\"_hash:\n        writeLog(0, \"Generate target: Quantumult X\", LOG_LEVEL_INFO);\n        if(!ext.nodelist)\n        {\n            if(render_template(fetchFile(lQuanXBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n        }\n\n        output_content = proxyToQuanX(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"quanx\", argUploadPath, output_content, false);\n        break;\n    case \"loon\"_hash:\n        writeLog(0, \"Generate target: Loon\", LOG_LEVEL_INFO);\n        if(!ext.nodelist)\n        {\n            if(render_template(fetchFile(lLoonBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n        }\n\n        output_content = proxyToLoon(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"loon\", argUploadPath, output_content, false);\n        break;\n    case \"ssd\"_hash:\n        writeLog(0, \"Generate target: SSD\", LOG_LEVEL_INFO);\n        output_content = proxyToSSD(nodes, argGroupName, subInfo, ext);\n        if(argUpload)\n            uploadGist(\"ssd\", argUploadPath, output_content, false);\n        break;\n    default:\n        writeLog(0, \"Generate target: Unspecified\", LOG_LEVEL_INFO);\n        *status_code = 500;\n        return \"Unrecognized target\";\n    }\n    writeLog(0, \"Generate completed.\", LOG_LEVEL_INFO);\n    if(argFilename.size())\n        response.headers.emplace(\"Content-Disposition\", \"attachment; filename=\\\"\" + argFilename + \"\\\"; filename*=utf-8''\" + urlEncode(argFilename));\n    return output_content;\n}\n\nstd::string simpleToClashR(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    std::string url = argument.size() <= 8 ? \"\" : argument.substr(8);\n    if(!url.size() || argument.substr(0, 8) != \"sublink=\")\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n    if(url == \"sublink\")\n    {\n        *status_code = 400;\n        return \"Please insert your subscription link instead of clicking the default link.\";\n    }\n    request.argument = \"target=clashr&url=\" + urlEncode(url);\n    return subconverter(request, response);\n}\n\nstd::string surgeConfToClash(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    INIReader ini;\n    string_array dummy_str_array;\n    std::vector<Proxy> nodes;\n    std::string base_content, url = argument.size() <= 5 ? \"\" : argument.substr(5);\n    const std::string proxygroup_name = global.clashUseNewField ? \"proxy-groups\" : \"Proxy Group\", rule_name = global.clashUseNewField ? \"rules\" : \"Rule\";\n\n    ini.store_any_line = true;\n\n    if(!url.size())\n        url = global.defaultUrls;\n    if(!url.size() || argument.substr(0, 5) != \"link=\")\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n    if(url == \"link\")\n    {\n        *status_code = 400;\n        return \"Please insert your subscription link instead of clicking the default link.\";\n    }\n    writeLog(0, \"SurgeConfToClash called with url '\" + url + \"'.\", LOG_LEVEL_INFO);\n\n    std::string proxy = parseProxy(global.proxyConfig);\n    YAML::Node clash;\n    template_args tpl_args;\n    tpl_args.global_vars = global.templateVars;\n    tpl_args.local_vars[\"clash.new_field_name\"] = global.clashUseNewField ? \"true\" : \"false\";\n    tpl_args.request_params[\"target\"] = \"clash\";\n    tpl_args.request_params[\"url\"] = url;\n\n    if(render_template(fetchFile(global.clashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n    {\n        *status_code = 400;\n        return base_content;\n    }\n    clash = YAML::Load(base_content);\n\n    base_content = fetchFile(url, proxy, global.cacheConfig);\n\n    if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)\n    {\n        std::string errmsg = \"Parsing Surge config failed! Reason: \" + ini.GetLastError();\n        //std::cerr<<errmsg<<\"\\n\";\n        writeLog(0, errmsg, LOG_LEVEL_ERROR);\n        *status_code = 400;\n        return errmsg;\n    }\n    if(!ini.SectionExist(\"Proxy\") || !ini.SectionExist(\"Proxy Group\") || !ini.SectionExist(\"Rule\"))\n    {\n        std::string errmsg = \"Incomplete surge config! Missing critical sections!\";\n        //std::cerr<<errmsg<<\"\\n\";\n        writeLog(0, errmsg, LOG_LEVEL_ERROR);\n        *status_code = 400;\n        return errmsg;\n    }\n\n    //scan groups first, get potential policy-path\n    string_multimap section;\n    ini.GetItems(\"Proxy Group\", section);\n    std::string name, type, content;\n    string_array links;\n    links.emplace_back(url);\n    YAML::Node singlegroup;\n    for(auto &x : section)\n    {\n        singlegroup.reset();\n        name = x.first;\n        content = x.second;\n        dummy_str_array = split(content, \",\");\n        if(!dummy_str_array.size())\n            continue;\n        type = dummy_str_array[0];\n        if(!(type == \"select\" || type == \"url-test\" || type == \"fallback\" || type == \"load-balance\")) //remove unsupported types\n            continue;\n        singlegroup[\"name\"] = name;\n        singlegroup[\"type\"] = type;\n        for(unsigned int i = 1; i < dummy_str_array.size(); i++)\n        {\n            if(startsWith(dummy_str_array[i], \"url\"))\n                singlegroup[\"url\"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find(\"=\") + 1));\n            else if(startsWith(dummy_str_array[i], \"interval\"))\n                singlegroup[\"interval\"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find(\"=\") + 1));\n            else if(startsWith(dummy_str_array[i], \"policy-path\"))\n                links.emplace_back(trim(dummy_str_array[i].substr(dummy_str_array[i].find(\"=\") + 1)));\n            else\n                singlegroup[\"proxies\"].push_back(trim(dummy_str_array[i]));\n        }\n        clash[proxygroup_name].push_back(singlegroup);\n    }\n\n    proxy = parseProxy(global.proxySubscription);\n    eraseElements(dummy_str_array);\n\n    RegexMatchConfigs dummy_regex_array;\n    std::string subInfo;\n    parse_settings parse_set;\n    parse_set.proxy = &proxy;\n    parse_set.exclude_remarks = parse_set.include_remarks = &dummy_str_array;\n    parse_set.stream_rules = parse_set.time_rules = &dummy_regex_array;\n    parse_set.request_header = &request.headers;\n    parse_set.sub_info = &subInfo;\n    parse_set.authorized = !global.APIMode;\n    for(std::string &x : links)\n    {\n        //std::cerr<<\"Fetching node data from url '\"<<x<<\"'.\"<<std::endl;\n        writeLog(0, \"Fetching node data from url '\" + x + \"'.\", LOG_LEVEL_INFO);\n        if(addNodes(x, nodes, 0, parse_set) == -1)\n        {\n            if(global.skipFailedLinks)\n                writeLog(0, \"The following link doesn't contain any valid node info: \" + x, LOG_LEVEL_WARNING);\n            else\n            {\n                *status_code = 400;\n                return \"The following link doesn't contain any valid node info: \" + x;\n            }\n        }\n    }\n\n    //exit if found nothing\n    if(!nodes.size())\n    {\n        *status_code = 400;\n        return \"No nodes were found!\";\n    }\n\n    extra_settings ext;\n    ext.sort_flag = global.enableSort;\n    ext.filter_deprecated = global.filterDeprecated;\n    ext.clash_new_field_name = global.clashUseNewField;\n    ext.udp = global.UDPFlag;\n    ext.tfo = global.TFOFlag;\n    ext.skip_cert_verify = global.skipCertVerify;\n    ext.tls13 = global.TLS13Flag;\n    ext.clash_proxies_style = global.clashProxiesStyle;\n\n    ProxyGroupConfigs dummy_groups;\n    proxyToClash(nodes, clash, dummy_groups, false, ext);\n\n    section.clear();\n    ini.GetItems(\"Proxy\", section);\n    for(auto &x : section)\n    {\n        singlegroup.reset();\n        name = x.first;\n        content = x.second;\n        dummy_str_array = split(content, \",\");\n        if(!dummy_str_array.size())\n            continue;\n        content = trim(dummy_str_array[0]);\n        switch(hash_(content))\n        {\n        case \"direct\"_hash:\n            singlegroup[\"name\"] = name;\n            singlegroup[\"type\"] = \"select\";\n            singlegroup[\"proxies\"].push_back(\"DIRECT\");\n            break;\n        case \"reject\"_hash:\n        case \"reject-tinygif\"_hash:\n            singlegroup[\"name\"] = name;\n            singlegroup[\"type\"] = \"select\";\n            singlegroup[\"proxies\"].push_back(\"REJECT\");\n            break;\n        default:\n            continue;\n        }\n        clash[proxygroup_name].push_back(singlegroup);\n    }\n\n    eraseElements(dummy_str_array);\n    ini.GetAll(\"Rule\", \"{NONAME}\", dummy_str_array);\n    YAML::Node rule;\n    string_array strArray;\n    std::string strLine;\n    std::stringstream ss;\n    std::string::size_type lineSize;\n    for(std::string &x : dummy_str_array)\n    {\n        if(startsWith(x, \"RULE-SET\"))\n        {\n            strArray = split(x, \",\");\n            if(strArray.size() != 3)\n                continue;\n            content = webGet(strArray[1], proxy, global.cacheRuleset);\n            if(!content.size())\n                continue;\n\n            ss << content;\n            char delimiter = getLineBreak(content);\n\n            while(getline(ss, strLine, delimiter))\n            {\n                lineSize = strLine.size();\n                if(lineSize && strLine[lineSize - 1] == '\\r') //remove line break\n                    strLine.erase(--lineSize);\n                if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) //empty lines and comments are ignored\n                    continue;\n                else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);})) //remove unsupported types\n                    continue;\n                strLine += strArray[2];\n                if(count_least(strLine, ',', 3))\n                    strLine = regReplace(strLine, \"^(.*?,.*?)(,.*)(,.*)$\", \"$1$3$2\");\n                rule.push_back(strLine);\n            }\n            ss.clear();\n            continue;\n        }\n        else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))\n            continue;\n        rule.push_back(x);\n    }\n    clash[rule_name] = rule;\n\n    response.headers[\"profile-update-interval\"] = std::to_string(global.updateInterval / 3600);\n    writeLog(0, \"Conversion completed.\", LOG_LEVEL_INFO);\n    return YAML::Dump(clash);\n}\n\nstd::string getProfile(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    std::string name = urlDecode(getUrlArg(argument, \"name\")), token = urlDecode(getUrlArg(argument, \"token\"));\n    string_array profiles = split(name, \"|\");\n    name = profiles[0];\n    if(token.empty() || name.empty())\n    {\n        *status_code = 403;\n        return \"Forbidden\";\n    }\n    std::string profile_content;\n    /*if(vfs::vfs_exist(name))\n    {\n        profile_content = vfs::vfs_get(name);\n    }\n    else */if(fileExist(name))\n    {\n        profile_content = fileGet(name, true);\n    }\n    else\n    {\n        *status_code = 404;\n        return \"Profile not found\";\n    }\n    //std::cerr<<\"Trying to load profile '\" + name + \"'.\\n\";\n    writeLog(0, \"Trying to load profile '\" + name + \"'.\", LOG_LEVEL_INFO);\n    INIReader ini;\n    if(ini.Parse(profile_content) != INIREADER_EXCEPTION_NONE && !ini.SectionExist(\"Profile\"))\n    {\n        //std::cerr<<\"Load profile failed! Reason: \"<<ini.GetLastError()<<\"\\n\";\n        writeLog(0, \"Load profile failed! Reason: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        *status_code = 500;\n        return \"Broken profile!\";\n    }\n    //std::cerr<<\"Trying to parse profile '\" + name + \"'.\\n\";\n    writeLog(0, \"Trying to parse profile '\" + name + \"'.\", LOG_LEVEL_INFO);\n    string_multimap contents;\n    ini.GetItems(\"Profile\", contents);\n    if(!contents.size())\n    {\n        //std::cerr<<\"Load profile failed! Reason: Empty Profile section\\n\";\n        writeLog(0, \"Load profile failed! Reason: Empty Profile section\", LOG_LEVEL_ERROR);\n        *status_code = 500;\n        return \"Broken profile!\";\n    }\n    auto profile_token = contents.find(\"profile_token\");\n    if(profiles.size() == 1 && profile_token != contents.end())\n    {\n        if(token != profile_token->second)\n        {\n            *status_code = 403;\n            return \"Forbidden\";\n        }\n        token = global.accessToken;\n    }\n    else\n    {\n        if(token != global.accessToken)\n        {\n            *status_code = 403;\n            return \"Forbidden\";\n        }\n    }\n    /// check if more than one profile is provided\n    if(profiles.size() > 1)\n    {\n        writeLog(0, \"Multiple profiles are provided. Trying to combine profiles...\", LOG_TYPE_INFO);\n        std::string all_urls, url;\n        auto iter = contents.find(\"url\");\n        if(iter != contents.end())\n            all_urls = iter->second;\n        for(size_t i = 1; i < profiles.size(); i++)\n        {\n            name = profiles[i];\n            if(!fileExist(name))\n            {\n                writeLog(0, \"Ignoring non-exist profile '\" + name + \"'...\", LOG_LEVEL_WARNING);\n                continue;\n            }\n            if(ini.ParseFile(name) != INIREADER_EXCEPTION_NONE && !ini.SectionExist(\"Profile\"))\n            {\n                writeLog(0, \"Ignoring broken profile '\" + name + \"'...\", LOG_LEVEL_WARNING);\n                continue;\n            }\n            url = ini.Get(\"Profile\", \"url\");\n            if(url.size())\n            {\n                all_urls += \"|\" + url;\n                writeLog(0, \"Profile url from '\" + name + \"' added.\", LOG_LEVEL_INFO);\n            }\n            else\n            {\n                writeLog(0, \"Profile '\" + name + \"' does not have url key. Skipping...\", LOG_LEVEL_INFO);\n            }\n        }\n        iter->second = all_urls;\n    }\n\n    contents.emplace(\"token\", token);\n    contents.emplace(\"profile_data\", base64Encode(global.managedConfigPrefix + \"/getprofile?\" + argument));\n    std::string query = std::accumulate(contents.begin(), contents.end(), std::string(), [](const std::string &x, auto y){ return x + y.first + \"=\" + urlEncode(y.second) + \"&\"; });\n    query += argument;\n    request.argument = query;\n    return subconverter(request, response);\n}\n\nstd::string getScript(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n\n    std::string url = urlSafeBase64Decode(getUrlArg(argument, \"url\")), dev_id = getUrlArg(argument, \"id\");\n    std::string output_content;\n\n    std::string proxy = parseProxy(global.proxyConfig);\n\n    output_content = fetchFile(url, proxy, global.cacheConfig);\n\n    if(!dev_id.size())\n        dev_id = global.quanXDevID;\n\n    const std::string pattern = \"(\\\\/\\\\*[\\\\s\\\\S]*?)^(.*?@supported )(.*?\\\\s?)$([\\\\s\\\\S]*\\\\*\\\\/\\\\s?\";\n    if(dev_id.size())\n    {\n        if(regFind(output_content, pattern))\n            output_content = regReplace(output_content, pattern, \"$1$2\" + dev_id + \"$4\");\n        else\n            output_content = \"/**\\n * @supported \" + dev_id + \"\\n * THIS COMMENT IS GENERATED BY SUBCONVERTER\\n */\\n\\n\" + output_content;\n    }\n    return output_content;\n}\n\nstd::string getRewriteRemote(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n\n    std::string url = urlSafeBase64Decode(getUrlArg(argument, \"url\")), dev_id = getUrlArg(argument, \"id\");\n    std::string output_content;\n\n    std::string proxy = parseProxy(global.proxyConfig);\n\n    output_content = fetchFile(url, proxy, global.cacheConfig);\n\n    if(!dev_id.size())\n        dev_id = global.quanXDevID;\n\n    if(dev_id.size())\n    {\n        std::stringstream ss;\n        std::string strLine;\n        const std::string pattern = \"^(.*? url script-.*? )(.*?)$\";\n        string_size lineSize;\n        char delimiter = getLineBreak(output_content);\n\n        ss << output_content;\n        output_content.clear();\n        while(getline(ss, strLine, delimiter))\n        {\n            lineSize = strLine.size();\n            if(lineSize && strLine[lineSize - 1] == '\\r') //remove line break\n                strLine.erase(--lineSize);\n\n            if(!strLine.empty() && regMatch(strLine, pattern))\n            {\n                url = global.managedConfigPrefix + \"/qx-script?id=\" + dev_id + \"&url=\" + urlSafeBase64Encode(regReplace(strLine, pattern, \"$2\"));\n                strLine = regReplace(strLine, pattern, \"$1\") + url;\n            }\n            output_content.append(strLine + \"\\n\");\n        }\n    }\n    return output_content;\n}\n\n/*\nstd::string jinja2_webGet(const std::string &url)\n{\n    std::string proxy = parseProxy(global.proxyConfig);\n    writeLog(0, \"Template called fetch with url '\" + url + \"'.\", LOG_LEVEL_INFO);\n    return webGet(url, proxy, global.cacheConfig);\n}*/\n\ninline std::string intToStream(unsigned long long stream)\n{\n    char chrs[16] = {}, units[6] = {' ', 'K', 'M', 'G', 'T', 'P'};\n    double streamval = stream;\n    unsigned int level = 0;\n    while(streamval > 1024.0)\n    {\n        if(level >= 5)\n            break;\n        level++;\n        streamval /= 1024.0;\n    }\n    snprintf(chrs, 15, \"%.2f %cB\", streamval, units[level]);\n    return std::string(chrs);\n}\n\nstd::string subInfoToMessage(std::string subinfo)\n{\n    using ull = unsigned long long;\n    subinfo = replaceAllDistinct(subinfo, \"; \", \"&\");\n    std::string retdata, useddata = \"N/A\", totaldata = \"N/A\", expirydata = \"N/A\";\n    std::string upload = getUrlArg(subinfo, \"upload\"), download = getUrlArg(subinfo, \"download\"), total = getUrlArg(subinfo, \"total\"), expire = getUrlArg(subinfo, \"expire\");\n    ull used = to_number<ull>(upload, 0) + to_number<ull>(download, 0), tot = to_number<ull>(total, 0);\n    time_t expiry = to_number<time_t>(expire, 0);\n    if(used != 0)\n        useddata = intToStream(used);\n    if(tot != 0)\n        totaldata = intToStream(tot);\n    if(expiry != 0)\n    {\n        char buffer[30];\n        struct tm *dt = localtime(&expiry);\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M\", dt);\n        expirydata.assign(buffer);\n    }\n    if(useddata == \"N/A\" && totaldata == \"N/A\" && expirydata == \"N/A\")\n        retdata = \"Not Available\";\n    else\n        retdata += \"Stream Used: \" + useddata + \" Stream Total: \" + totaldata + \" Expiry Time: \" + expirydata;\n    return retdata;\n}\n\nint simpleGenerator()\n{\n    //std::cerr<<\"\\nReading generator configuration...\\n\";\n    writeLog(0, \"Reading generator configuration...\", LOG_LEVEL_INFO);\n    std::string config = fileGet(\"generate.ini\"), path, profile, arguments, content;\n    if(config.empty())\n    {\n        //std::cerr<<\"Generator configuration not found or empty!\\n\";\n        writeLog(0, \"Generator configuration not found or empty!\", LOG_LEVEL_ERROR);\n        return -1;\n    }\n\n    INIReader ini;\n    if(ini.Parse(config) != INIREADER_EXCEPTION_NONE)\n    {\n        //std::cerr<<\"Generator configuration broken! Reason:\"<<ini.GetLastError()<<\"\\n\";\n        writeLog(0, \"Generator configuration broken! Reason:\" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return -2;\n    }\n    //std::cerr<<\"Read generator configuration completed.\\n\\n\";\n    writeLog(0, \"Read generator configuration completed.\\n\", LOG_LEVEL_INFO);\n\n    string_array sections = ini.GetSections();\n    if(global.generateProfiles.size())\n    {\n        //std::cerr<<\"Generating with specific artifacts: \\\"\"<<gen_profile<<\"\\\"...\\n\";\n        writeLog(0, \"Generating with specific artifacts: \\\"\" + global.generateProfiles + \"\\\"...\", LOG_LEVEL_INFO);\n        string_array targets = split(global.generateProfiles, \",\"), new_targets;\n        for(std::string &x : targets)\n        {\n            x = trim(x);\n            if(std::find(sections.cbegin(), sections.cend(), x) != sections.cend())\n                new_targets.emplace_back(std::move(x));\n            else\n            {\n                //std::cerr<<\"Artifact \\\"\"<<x<<\"\\\" not found in generator settings!\\n\";\n                writeLog(0, \"Artifact \\\"\" + x + \"\\\" not found in generator settings!\", LOG_LEVEL_ERROR);\n                return -3;\n            }\n        }\n        sections = new_targets;\n        sections.shrink_to_fit();\n    }\n    else\n        //std::cerr<<\"Generating all artifacts...\\n\";\n        writeLog(0, \"Generating all artifacts...\", LOG_LEVEL_INFO);\n\n    string_multimap allItems;\n    std::string proxy = parseProxy(global.proxySubscription);\n    Request request;\n    Response response;\n    for(std::string &x : sections)\n    {\n        arguments.clear();\n        response.status_code = 200;\n        //std::cerr<<\"Generating artifact '\"<<x<<\"'...\\n\";\n        writeLog(0, \"Generating artifact '\" + x + \"'...\", LOG_LEVEL_INFO);\n        ini.EnterSection(x);\n        if(ini.ItemExist(\"path\"))\n            path = ini.Get(\"path\");\n        else\n        {\n            //std::cerr<<\"Artifact '\"<<x<<\"' output path missing! Skipping...\\n\\n\";\n            writeLog(0, \"Artifact '\" + x + \"' output path missing! Skipping...\\n\", LOG_LEVEL_ERROR);\n            continue;\n        }\n        if(ini.ItemExist(\"profile\"))\n        {\n            profile = ini.Get(\"profile\");\n            request.argument = \"name=\" + urlEncode(profile) + \"&token=\" + global.accessToken + \"&expand=true\";\n            content = getProfile(request, response);\n        }\n        else\n        {\n            if(ini.GetBool(\"direct\") == true)\n            {\n                std::string url = ini.Get(\"url\");\n                content = fetchFile(url, proxy, global.cacheSubscription);\n                if(content.empty())\n                {\n                    //std::cerr<<\"Artifact '\"<<x<<\"' generate ERROR! Please check your link.\\n\\n\";\n                    writeLog(0, \"Artifact '\" + x + \"' generate ERROR! Please check your link.\\n\", LOG_LEVEL_ERROR);\n                    if(sections.size() == 1)\n                        return -1;\n                }\n                // add UTF-8 BOM\n                fileWrite(path, \"\\xEF\\xBB\\xBF\" + content, true);\n                continue;\n            }\n            ini.GetItems(allItems);\n            allItems.emplace(\"expand\", \"true\");\n            for(auto &y : allItems)\n            {\n                if(y.first == \"path\")\n                    continue;\n                arguments += y.first + \"=\" + urlEncode(y.second) + \"&\";\n            }\n            arguments.erase(arguments.size() - 1);\n            request.argument = arguments;\n            content = subconverter(request, response);\n        }\n        if(response.status_code != 200)\n        {\n            //std::cerr<<\"Artifact '\"<<x<<\"' generate ERROR! Reason: \"<<content<<\"\\n\\n\";\n            writeLog(0, \"Artifact '\" + x + \"' generate ERROR! Reason: \" + content + \"\\n\", LOG_LEVEL_ERROR);\n            if(sections.size() == 1)\n                return -1;\n            continue;\n        }\n        fileWrite(path, content, true);\n        auto iter = std::find_if(response.headers.begin(), response.headers.end(), [](auto y){ return y.first == \"Subscription-UserInfo\"; });\n        if(iter != response.headers.end())\n            writeLog(0, \"User Info for artifact '\" + x + \"': \" + subInfoToMessage(iter->second), LOG_LEVEL_INFO);\n        //std::cerr<<\"Artifact '\"<<x<<\"' generate SUCCESS!\\n\\n\";\n        writeLog(0, \"Artifact '\" + x + \"' generate SUCCESS!\\n\", LOG_LEVEL_INFO);\n        eraseElements(response.headers);\n    }\n    //std::cerr<<\"All artifact generated. Exiting...\\n\";\n    writeLog(0, \"All artifact generated. Exiting...\", LOG_LEVEL_INFO);\n    return 0;\n}\n\nstd::string renderTemplate(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    std::string path = urlDecode(getUrlArg(argument, \"path\"));\n    writeLog(0, \"Trying to render template '\" + path + \"'...\", LOG_LEVEL_INFO);\n\n    if(!startsWith(path, global.templatePath) || !fileExist(path))\n    {\n        *status_code = 404;\n        return \"Not found\";\n    }\n    std::string template_content = fetchFile(path, parseProxy(global.proxyConfig), global.cacheConfig);\n    if(template_content.empty())\n    {\n        *status_code = 400;\n        return \"File empty or out of scope\";\n    }\n    template_args tpl_args;\n    tpl_args.global_vars = global.templateVars;\n\n    //load request arguments as template variables\n    string_array req_args = split(argument, \"&\");\n    string_size pos;\n    string_map req_arg_map;\n    for(std::string &x : req_args)\n    {\n        pos = x.find(\"=\");\n        if(pos == x.npos)\n            req_arg_map[x] = \"\";\n        else\n            req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);\n    }\n    tpl_args.request_params = req_arg_map;\n\n    std::string output_content;\n    if(render_template(template_content, tpl_args, output_content, global.templatePath) != 0)\n    {\n        *status_code = 400;\n        writeLog(0, \"Render failed with error.\", LOG_LEVEL_WARNING);\n    }\n    else\n        writeLog(0, \"Render completed.\", LOG_LEVEL_INFO);\n\n    return output_content;\n}\n", "#include <string>\n#include <mutex>\n#include <toml.hpp>\n\n#include \"../config/binding.h\"\n#include \"../handler/webget.h\"\n#include \"../script/cron.h\"\n#include \"../server/webserver.h\"\n#include \"../utils/logger.h\"\n#include \"../utils/network.h\"\n#include \"interfaces.h\"\n#include \"multithread.h\"\n#include \"settings.h\"\n\n//multi-thread lock\nstd::mutex gMutexConfigure;\n\nSettings global;\n\nextern WebServer webServer;\n\nconst std::map<std::string, ruleset_type> RulesetTypes = {{\"clash-domain:\", RULESET_CLASH_DOMAIN}, {\"clash-ipcidr:\", RULESET_CLASH_IPCIDR}, {\"clash-classic:\", RULESET_CLASH_CLASSICAL}, \\\n            {\"quanx:\", RULESET_QUANX}, {\"surge:\", RULESET_SURGE}};\n\nint importItems(string_array &target, bool scope_limit)\n{\n    string_array result;\n    std::stringstream ss;\n    std::string path, content, strLine;\n    unsigned int itemCount = 0;\n    for(std::string &x : target)\n    {\n        if(x.find(\"!!import:\") == x.npos)\n        {\n            result.emplace_back(x);\n            continue;\n        }\n        path = x.substr(x.find(\":\") + 1);\n        writeLog(0, \"Trying to import items from \" + path);\n\n        std::string proxy = parseProxy(global.proxyConfig);\n\n        if(fileExist(path))\n            content = fileGet(path, scope_limit);\n        else if(isLink(path))\n            content = webGet(path, proxy, global.cacheConfig);\n        else\n            writeLog(0, \"File not found or not a valid URL: \" + path, LOG_LEVEL_ERROR);\n        if(!content.size())\n            return -1;\n\n        ss << content;\n        char delimiter = getLineBreak(content);\n        std::string::size_type lineSize;\n        while(getline(ss, strLine, delimiter))\n        {\n            lineSize = strLine.size();\n            if(lineSize && strLine[lineSize - 1] == '\\r') //remove line break\n                strLine.erase(--lineSize);\n            if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) //empty lines and comments are ignored\n                continue;\n            result.emplace_back(std::move(strLine));\n            itemCount++;\n        }\n        ss.clear();\n    }\n    target.swap(result);\n    writeLog(0, \"Imported \" + std::to_string(itemCount) + \" item(s).\");\n    return 0;\n}\n\ntoml::value parseToml(const std::string &content, const std::string &fname)\n{\n    std::istringstream is(content);\n    return toml::parse(is, fname);\n}\n\nvoid importItems(std::vector<toml::value> &root, const std::string &import_key, bool scope_limit = true)\n{\n    std::string content;\n    std::vector<toml::value> newRoot;\n    auto iter = root.begin();\n    size_t count = 0;\n\n    std::string proxy = parseProxy(global.proxyConfig);\n    while(iter != root.end())\n    {\n        auto& table = iter->as_table();\n        if(table.find(\"import\") == table.end())\n            newRoot.emplace_back(std::move(*iter));\n        else\n        {\n            const std::string &path = toml::get<std::string>(table.at(\"import\"));\n            writeLog(0, \"Trying to import items from \" + path);\n            if(fileExist(path))\n                content = fileGet(path, scope_limit);\n            else if(isLink(path))\n                content = webGet(path, proxy, global.cacheConfig);\n            else\n                writeLog(0, \"File not found or not a valid URL: \" + path, LOG_LEVEL_ERROR);\n            if(content.size())\n            {\n                auto items = parseToml(content, path);\n                auto list = toml::find<std::vector<toml::value>>(items, import_key);\n                count += list.size();\n                std::move(list.begin(), list.end(), std::back_inserter(newRoot));\n            }\n        }\n        iter++;\n    }\n    root.swap(newRoot);\n    writeLog(0, \"Imported \" + std::to_string(count) + \" item(s).\");\n    return;\n}\n\nvoid readRegexMatch(YAML::Node node, const std::string &delimiter, string_array &dest, bool scope_limit = true)\n{\n    YAML::Node object;\n    std::string script, url, match, rep, strLine;\n\n    for(unsigned i = 0; i < node.size(); i++)\n    {\n        object = node[i];\n        object[\"script\"] >>= script;\n        if(script.size())\n        {\n            dest.emplace_back(\"!!script:\" + script);\n            continue;\n        }\n        object[\"import\"] >>= url;\n        if(url.size())\n        {\n            dest.emplace_back(\"!!import:\" + url);\n            continue;\n        }\n        object[\"match\"] >>= match;\n        object[\"replace\"] >>= rep;\n        if(match.size() && rep.size())\n            strLine = match + delimiter + rep;\n        else\n            continue;\n        dest.emplace_back(std::move(strLine));\n    }\n    importItems(dest, scope_limit);\n}\n\nvoid readEmoji(YAML::Node node, string_array &dest, bool scope_limit = true)\n{\n    YAML::Node object;\n    std::string script, url, match, rep, strLine;\n\n    for(unsigned i = 0; i < node.size(); i++)\n    {\n        object = node[i];\n        object[\"script\"] >>= script;\n        if(script.size())\n        {\n            dest.emplace_back(\"!!script:\" + script);\n            continue;\n        }\n        object[\"import\"] >>= url;\n        if(url.size())\n        {\n            url = \"!!import:\" + url;\n            dest.emplace_back(url);\n            continue;\n        }\n        object[\"match\"] >>= match;\n        object[\"emoji\"] >>= rep;\n        if(match.size() && rep.size())\n            strLine = match + \",\" + rep;\n        else\n            continue;\n        dest.emplace_back(std::move(strLine));\n    }\n    importItems(dest, scope_limit);\n}\n\nvoid readGroup(YAML::Node node, string_array &dest, bool scope_limit = true)\n{\n    std::string strLine, name, type;\n    string_array tempArray;\n    YAML::Node object;\n    unsigned int i, j;\n\n    for(i = 0; i < node.size(); i++)\n    {\n        eraseElements(tempArray);\n        object = node[i];\n        object[\"import\"] >>= name;\n        if(name.size())\n        {\n            dest.emplace_back(\"!!import:\" + name);\n            continue;\n        }\n        std::string url = \"http://www.gstatic.com/generate_204\", interval = \"300\", tolerance, timeout;\n        object[\"name\"] >>= name;\n        object[\"type\"] >>= type;\n        tempArray.emplace_back(name);\n        tempArray.emplace_back(type);\n        object[\"url\"] >>= url;\n        object[\"interval\"] >>= interval;\n        object[\"tolerance\"] >>= tolerance;\n        object[\"timeout\"] >>= timeout;\n        for(j = 0; j < object[\"rule\"].size(); j++)\n            tempArray.emplace_back(safe_as<std::string>(object[\"rule\"][j]));\n        switch(hash_(type))\n        {\n        case \"select\"_hash:\n            if(tempArray.size() < 3)\n                continue;\n            break;\n        case \"ssid\"_hash:\n            if(tempArray.size() < 4)\n                continue;\n            break;\n        default:\n            if(tempArray.size() < 3)\n                continue;\n            tempArray.emplace_back(url);\n            tempArray.emplace_back(interval + \",\" + timeout + \",\" + tolerance);\n        }\n\n        strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b) -> std::string\n        {\n            return std::move(a) + \"`\" + std::move(b);\n        });\n        dest.emplace_back(std::move(strLine));\n    }\n    importItems(dest, scope_limit);\n}\n\nvoid readRuleset(YAML::Node node, string_array &dest, bool scope_limit = true)\n{\n    std::string strLine, name, url, group, interval;\n    YAML::Node object;\n\n    for(unsigned int i = 0; i < node.size(); i++)\n    {\n        object = node[i];\n        object[\"import\"] >>= name;\n        if(name.size())\n        {\n            dest.emplace_back(\"!!import:\" + name);\n            continue;\n        }\n        object[\"ruleset\"] >>= url;\n        object[\"group\"] >>= group;\n        object[\"rule\"] >>= name;\n        object[\"interval\"] >>= interval;\n        if(url.size())\n        {\n            strLine = group + \",\" + url;\n            if(interval.size())\n                strLine += \",\" + interval;\n        }\n        else if(name.size())\n            strLine = group + \",[]\" + name;\n        else\n            continue;\n        dest.emplace_back(std::move(strLine));\n    }\n    importItems(dest, scope_limit);\n}\n\nvoid refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array)\n{\n    eraseElements(ruleset_content_array);\n    std::string rule_group, rule_url, rule_url_typed, interval;\n    RulesetContent rc;\n\n    std::string proxy = parseProxy(global.proxyRuleset);\n\n    for(RulesetConfig &x : ruleset_list)\n    {\n        rule_group = x.Group;\n        rule_url = x.Url;\n        std::string::size_type pos = x.Url.find(\"[]\");\n        if(pos != std::string::npos)\n        {\n            writeLog(0, \"Adding rule '\" + rule_url.substr(pos + 2) + \",\" + rule_group + \"'.\", LOG_LEVEL_INFO);\n            rc = {rule_group, \"\", \"\", RULESET_SURGE, std::async(std::launch::async, [=](){return rule_url.substr(pos);}), 0};\n        }\n        else\n        {\n            ruleset_type type = RULESET_SURGE;\n            rule_url_typed = rule_url;\n            auto iter = std::find_if(RulesetTypes.begin(), RulesetTypes.end(), [rule_url](auto y){ return startsWith(rule_url, y.first); });\n            if(iter != RulesetTypes.end())\n            {\n                rule_url.erase(0, iter->first.size());\n                type = iter->second;\n            }\n            writeLog(0, \"Updating ruleset url '\" + rule_url + \"' with group '\" + rule_group + \"'.\", LOG_LEVEL_INFO);\n            rc = {rule_group, rule_url, rule_url_typed, type, fetchFileAsync(rule_url, proxy, global.cacheRuleset, global.asyncFetchRuleset), x.Interval};\n        }\n        ruleset_content_array.emplace_back(std::move(rc));\n    }\n    ruleset_content_array.shrink_to_fit();\n}\n\nvoid readYAMLConf(YAML::Node &node)\n{\n    YAML::Node section = node[\"common\"];\n    std::string strLine;\n    string_array tempArray;\n\n    section[\"api_mode\"] >> global.APIMode;\n    section[\"api_access_token\"] >> global.accessToken;\n    if(section[\"default_url\"].IsSequence())\n    {\n        section[\"default_url\"] >> tempArray;\n        if(tempArray.size())\n        {\n            strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)\n            {\n                return std::move(a) + \"|\" + std::move(b);\n            });\n            global.defaultUrls = strLine;\n            eraseElements(tempArray);\n        }\n    }\n    global.enableInsert = safe_as<std::string>(section[\"enable_insert\"]);\n    if(section[\"insert_url\"].IsSequence())\n    {\n        section[\"insert_url\"] >> tempArray;\n        if(tempArray.size())\n        {\n            strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)\n            {\n                return std::move(a) + \"|\" + std::move(b);\n            });\n            global.insertUrls = strLine;\n            eraseElements(tempArray);\n        }\n    }\n    section[\"prepend_insert_url\"] >> global.prependInsert;\n    if(section[\"exclude_remarks\"].IsSequence())\n        section[\"exclude_remarks\"] >> global.excludeRemarks;\n    if(section[\"include_remarks\"].IsSequence())\n        section[\"include_remarks\"] >> global.includeRemarks;\n    global.filterScript = safe_as<bool>(section[\"enable_filter\"]) ? safe_as<std::string>(section[\"filter_script\"]) : \"\";\n    section[\"base_path\"] >> global.basePath;\n    section[\"clash_rule_base\"] >> global.clashBase;\n    section[\"surge_rule_base\"] >> global.surgeBase;\n    section[\"surfboard_rule_base\"] >> global.surfboardBase;\n    section[\"mellow_rule_base\"] >> global.mellowBase;\n    section[\"quan_rule_base\"] >> global.quanBase;\n    section[\"quanx_rule_base\"] >> global.quanXBase;\n    section[\"loon_rule_base\"] >> global.loonBase;\n    section[\"sssub_rule_base\"] >> global.SSSubBase;\n\n    section[\"default_external_config\"] >> global.defaultExtConfig;\n    section[\"append_proxy_type\"] >> global.appendType;\n    section[\"proxy_config\"] >> global.proxyConfig;\n    section[\"proxy_ruleset\"] >> global.proxyRuleset;\n    section[\"proxy_subscription\"] >> global.proxySubscription;\n\n    if(node[\"userinfo\"].IsDefined())\n    {\n        section = node[\"userinfo\"];\n        if(section[\"stream_rule\"].IsSequence())\n        {\n            readRegexMatch(section[\"stream_rule\"], \"|\", tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_streams(configs);\n            eraseElements(tempArray);\n        }\n        if(section[\"time_rule\"].IsSequence())\n        {\n            readRegexMatch(section[\"time_rule\"], \"|\", tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_times(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    if(node[\"node_pref\"].IsDefined())\n    {\n        section = node[\"node_pref\"];\n        /*\n        section[\"udp_flag\"] >> udp_flag;\n        section[\"tcp_fast_open_flag\"] >> tfo_flag;\n        section[\"skip_cert_verify_flag\"] >> scv_flag;\n        */\n        global.UDPFlag.set(safe_as<std::string>(section[\"udp_flag\"]));\n        global.TFOFlag.set(safe_as<std::string>(section[\"tcp_fast_open_flag\"]));\n        global.skipCertVerify.set(safe_as<std::string>(section[\"skip_cert_verify_flag\"]));\n        global.TLS13Flag.set(safe_as<std::string>(section[\"tls13_flag\"]));\n        section[\"sort_flag\"] >> global.enableSort;\n        section[\"sort_script\"] >> global.sortScript;\n        section[\"filter_deprecated_nodes\"] >> global.filterDeprecated;\n        section[\"append_sub_userinfo\"] >> global.appendUserinfo;\n        section[\"clash_use_new_field_name\"] >> global.clashUseNewField;\n        section[\"clash_proxies_style\"] >> global.clashProxiesStyle;\n    }\n\n    if(section[\"rename_node\"].IsSequence())\n    {\n        readRegexMatch(section[\"rename_node\"], \"@\", tempArray, false);\n        auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"@\");\n        safe_set_renames(configs);\n        eraseElements(tempArray);\n    }\n\n    if(node[\"managed_config\"].IsDefined())\n    {\n        section = node[\"managed_config\"];\n        section[\"write_managed_config\"] >> global.writeManagedConfig;\n        section[\"managed_config_prefix\"] >> global.managedConfigPrefix;\n        section[\"config_update_interval\"] >> global.updateInterval;\n        section[\"config_update_strict\"] >> global.updateStrict;\n        section[\"quanx_device_id\"] >> global.quanXDevID;\n    }\n\n    if(node[\"surge_external_proxy\"].IsDefined())\n    {\n        node[\"surge_external_proxy\"][\"surge_ssr_path\"] >> global.surgeSSRPath;\n        node[\"surge_external_proxy\"][\"resolve_hostname\"] >> global.surgeResolveHostname;\n    }\n\n    if(node[\"emojis\"].IsDefined())\n    {\n        section = node[\"emojis\"];\n        section[\"add_emoji\"] >> global.addEmoji;\n        section[\"remove_old_emoji\"] >> global.removeEmoji;\n        if(section[\"rules\"].IsSequence())\n        {\n            readEmoji(section[\"rules\"], tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \",\");\n            safe_set_emojis(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    const char *rulesets_title = node[\"rulesets\"].IsDefined() ? \"rulesets\" : \"ruleset\";\n    if(node[rulesets_title].IsDefined())\n    {\n        section = node[rulesets_title];\n        section[\"enabled\"] >> global.enableRuleGen;\n        if(!global.enableRuleGen)\n        {\n            global.overwriteOriginalRules = false;\n            global.updateRulesetOnRequest = false;\n        }\n        else\n        {\n            section[\"overwrite_original_rules\"] >> global.overwriteOriginalRules;\n            section[\"update_ruleset_on_request\"] >> global.updateRulesetOnRequest;\n        }\n        const char *ruleset_title = section[\"rulesets\"].IsDefined() ? \"rulesets\" : \"surge_ruleset\";\n        if(section[ruleset_title].IsSequence())\n        {\n            string_array vArray;\n            readRuleset(section[ruleset_title], vArray, false);\n            global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n        }\n    }\n\n    const char *groups_title = node[\"proxy_groups\"].IsDefined() ? \"proxy_groups\" : \"proxy_group\";\n    if(node[groups_title].IsDefined() && node[groups_title][\"custom_proxy_group\"].IsDefined())\n    {\n        string_array vArray;\n        readGroup(node[groups_title][\"custom_proxy_group\"], vArray, false);\n        global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n\n    if(node[\"template\"].IsDefined())\n    {\n        node[\"template\"][\"template_path\"] >> global.templatePath;\n        if(node[\"template\"][\"globals\"].IsSequence())\n        {\n            eraseElements(global.templateVars);\n            for(size_t i = 0; i < node[\"template\"][\"globals\"].size(); i++)\n            {\n                std::string key, value;\n                node[\"template\"][\"globals\"][i][\"key\"] >> key;\n                node[\"template\"][\"globals\"][i][\"value\"] >> value;\n                global.templateVars[key] = value;\n            }\n        }\n    }\n\n    if(node[\"aliases\"].IsSequence())\n    {\n        webServer.reset_redirect();\n        for(size_t i = 0; i < node[\"aliases\"].size(); i++)\n        {\n            std::string uri, target;\n            node[\"aliases\"][i][\"uri\"] >> uri;\n            node[\"aliases\"][i][\"target\"] >> target;\n            webServer.append_redirect(uri, target);\n        }\n    }\n\n    if(node[\"tasks\"].IsSequence())\n    {\n        string_array vArray;\n        for(size_t i = 0; i < node[\"tasks\"].size(); i++)\n        {\n            std::string name, exp, path, timeout;\n            node[\"tasks\"][i][\"import\"] >> name;\n            if(name.size())\n            {\n                vArray.emplace_back(\"!!import:\" + name);\n                continue;\n            }\n            node[\"tasks\"][i][\"name\"] >> name;\n            node[\"tasks\"][i][\"cronexp\"] >> exp;\n            node[\"tasks\"][i][\"path\"] >> path;\n            node[\"tasks\"][i][\"timeout\"] >> timeout;\n            strLine = name + \"`\" + exp + \"`\" + path + \"`\" + timeout;\n            vArray.emplace_back(std::move(strLine));\n        }\n        importItems(vArray, false);\n        global.enableCron = !vArray.empty();\n        global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);\n        refresh_schedule();\n    }\n\n    if(node[\"server\"].IsDefined())\n    {\n        node[\"server\"][\"listen\"] >> global.listenAddress;\n        node[\"server\"][\"port\"] >> global.listenPort;\n        node[\"server\"][\"serve_file_root\"] >>= webServer.serve_file_root;\n        webServer.serve_file = !webServer.serve_file_root.empty();\n    }\n\n    if(node[\"advanced\"].IsDefined())\n    {\n        std::string log_level;\n        node[\"advanced\"][\"log_level\"] >> log_level;\n        node[\"advanced\"][\"print_debug_info\"] >> global.printDbgInfo;\n        if(global.printDbgInfo)\n            global.logLevel = LOG_LEVEL_VERBOSE;\n        else\n        {\n            switch(hash_(log_level))\n            {\n            case \"warn\"_hash:\n                global.logLevel = LOG_LEVEL_WARNING;\n                break;\n            case \"error\"_hash:\n                global.logLevel = LOG_LEVEL_ERROR;\n                break;\n            case \"fatal\"_hash:\n                global.logLevel = LOG_LEVEL_FATAL;\n                break;\n            case \"verbose\"_hash:\n                global.logLevel = LOG_LEVEL_VERBOSE;\n                break;\n            case \"debug\"_hash:\n                global.logLevel = LOG_LEVEL_DEBUG;\n                break;\n            default:\n                global.logLevel = LOG_LEVEL_INFO;\n            }\n        }\n        node[\"advanced\"][\"max_pending_connections\"] >> global.maxPendingConns;\n        node[\"advanced\"][\"max_concurrent_threads\"] >> global.maxConcurThreads;\n        node[\"advanced\"][\"max_allowed_rulesets\"] >> global.maxAllowedRulesets;\n        node[\"advanced\"][\"max_allowed_rules\"] >> global.maxAllowedRules;\n        node[\"advanced\"][\"max_allowed_download_size\"] >> global.maxAllowedDownloadSize;\n        if(node[\"advanced\"][\"enable_cache\"].IsDefined())\n        {\n            if(safe_as<bool>(node[\"advanced\"][\"enable_cache\"]))\n            {\n                node[\"advanced\"][\"cache_subscription\"] >> global.cacheSubscription;\n                node[\"advanced\"][\"cache_config\"] >> global.cacheConfig;\n                node[\"advanced\"][\"cache_ruleset\"] >> global.cacheRuleset;\n                node[\"advanced\"][\"serve_cache_on_fetch_fail\"] >> global.serveCacheOnFetchFail;\n            }\n            else\n                global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; //disable cache\n        }\n        node[\"advanced\"][\"script_clean_context\"] >> global.scriptCleanContext;\n        node[\"advanced\"][\"async_fetch_ruleset\"] >> global.asyncFetchRuleset;\n        node[\"advanced\"][\"skip_failed_links\"] >> global.skipFailedLinks;\n    }\n    writeLog(0, \"Load preference settings in YAML format completed.\", LOG_LEVEL_INFO);\n}\n\ntemplate <class T, class... U>\nvoid find_if_exist(const toml::value &v, const toml::key &k, T& target, U&&... args)\n{\n    if(v.contains(k)) target = toml::find<T>(v, k);\n    if constexpr (sizeof...(args) > 0) find_if_exist(v, std::forward<U>(args)...);\n}\n\nvoid operate_toml_kv_table(const std::vector<toml::table> &arr, const toml::key &key_name, const toml::key &value_name, std::function<void (const toml::value&, const toml::value&)> binary_op)\n{\n    for(const toml::table &table : arr)\n    {\n        const auto &key = table.at(key_name), value = table.at(value_name);\n        binary_op(key, value);\n    }\n}\n\nvoid readTOMLConf(toml::value &root)\n{\n    const auto &section_common = toml::find(root, \"common\");\n    string_array default_url, insert_url;\n\n    find_if_exist(section_common, \"default_url\", default_url, \"insert_url\", insert_url);\n    global.defaultUrls = join(default_url, \"|\");\n    global.insertUrls = join(insert_url, \"|\");\n\n    bool filter = false;\n    find_if_exist(section_common,\n                  \"api_mode\", global.APIMode,\n                  \"api_access_token\", global.accessToken,\n                  \"exclude_remarks\", global.excludeRemarks,\n                  \"include_remarks\", global.includeRemarks,\n                  \"enable_insert\", global.enableInsert,\n                  \"prepend_insert_url\", global.prependInsert,\n                  \"enable_filter\", filter,\n                  \"default_external_config\", global.defaultExtConfig,\n                  \"base_path\", global.basePath,\n                  \"clash_rule_base\", global.clashBase,\n                  \"surge_rule_base\", global.surgeBase,\n                  \"surfboard_rule_base\", global.surfboardBase,\n                  \"mellow_rule_base\", global.mellowBase,\n                  \"quan_rule_base\", global.quanBase,\n                  \"quanx_rule_base\", global.quanXBase,\n                  \"loon_rule_base\", global.loonBase,\n                  \"proxy_config\", global.proxyConfig,\n                  \"proxy_ruleset\", global.proxyRuleset,\n                  \"proxy_subscription\", global.proxySubscription,\n                  \"append_proxy_type\", global.appendType\n    );\n\n    if(filter)\n        find_if_exist(section_common, \"filter_script\", global.filterScript);\n    else\n        global.filterScript.clear();\n\n    safe_set_streams(toml::find_or<RegexMatchConfigs>(root, \"userinfo\", \"stream_rule\", RegexMatchConfigs{}));\n    safe_set_times(toml::find_or<RegexMatchConfigs>(root, \"userinfo\", \"time_rule\", RegexMatchConfigs{}));\n\n    const auto &section_node_pref = toml::find(root, \"node_pref\");\n\n    find_if_exist(section_node_pref,\n                  \"udp_flag\", global.UDPFlag,\n                  \"tcp_fast_open_flag\", global.TFOFlag,\n                  \"skip_cert_verify_flag\", global.skipCertVerify,\n                  \"tls13_flag\", global.TLS13Flag,\n                  \"sort_flag\", global.enableSort,\n                  \"sort_script\", global.sortScript,\n                  \"filter_deprecated_nodes\", global.filterDeprecated,\n                  \"append_sub_userinfo\", global.appendUserinfo,\n                  \"clash_use_new_field_name\", global.clashUseNewField,\n                  \"clash_proxies_style\", global.clashProxiesStyle\n    );\n\n    auto renameconfs = toml::find_or<std::vector<toml::value>>(section_node_pref, \"rename_node\", {});\n    importItems(renameconfs, \"rename_node\", false);\n    safe_set_renames(toml::get<RegexMatchConfigs>(toml::value(renameconfs)));\n\n    const auto &section_managed = toml::find(root, \"managed_config\");\n\n    find_if_exist(section_managed,\n                  \"write_managed_config\", global.writeManagedConfig,\n                  \"managed_config_prefix\", global.managedConfigPrefix,\n                  \"config_update_interval\", global.updateInterval,\n                  \"config_update_strict\", global.updateStrict,\n                  \"quanx_device_id\", global.quanXDevID\n    );\n\n    const auto &section_surge_external = toml::find(root, \"surge_external_proxy\");\n    find_if_exist(section_surge_external,\n                  \"surge_ssr_path\", global.surgeSSRPath,\n                  \"resolve_hostname\", global.surgeResolveHostname\n    );\n\n    const auto &section_emojis = toml::find(root, \"emojis\");\n\n    find_if_exist(section_emojis,\n                  \"add_emoji\", global.addEmoji,\n                  \"remove_old_emoji\", global.removeEmoji\n    );\n\n    auto emojiconfs = toml::find_or<std::vector<toml::value>>(section_emojis, \"emoji\", {});\n    importItems(emojiconfs, \"emoji\", false);\n    safe_set_emojis(toml::get<RegexMatchConfigs>(toml::value(emojiconfs)));\n\n    auto groups = toml::find_or<std::vector<toml::value>>(root, \"custom_groups\", {});\n    importItems(groups, \"custom_groups\", false);\n    global.customProxyGroups = toml::get<ProxyGroupConfigs>(toml::value(groups));\n\n    const auto &section_ruleset = toml::find(root, \"ruleset\");\n\n    find_if_exist(section_ruleset,\n                  \"enabled\", global.enableRuleGen,\n                  \"overwrite_original_rules\", global.overwriteOriginalRules,\n                  \"update_ruleset_on_request\", global.updateRulesetOnRequest\n    );\n\n    auto rulesets = toml::find_or<std::vector<toml::value>>(root, \"rulesets\", {});\n    importItems(rulesets, \"rulesets\", false);\n    global.customRulesets = toml::get<RulesetConfigs>(toml::value(rulesets));\n\n    const auto &section_template = toml::find(root, \"template\");\n\n    global.templatePath = toml::find_or(section_template, \"template_path\", \"template\");\n\n    eraseElements(global.templateVars);\n    operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section_template, \"globals\", {}), \"key\", \"value\", [&](const toml::value &key, const toml::value &value)\n    {\n        global.templateVars[key.as_string()] = value.as_string();\n    });\n\n    webServer.reset_redirect();\n    operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(root, \"aliases\", {}), \"uri\", \"target\", [&](const toml::value &key, const toml::value &value)\n    {\n        webServer.append_redirect(key.as_string(), value.as_string());\n    });\n\n    auto tasks = toml::find_or<std::vector<toml::value>>(root, \"tasks\", {});\n    importItems(tasks, \"tasks\", false);\n    global.cronTasks = toml::get<CronTaskConfigs>(toml::value(tasks));\n\n    const auto &section_server = toml::find(root, \"server\");\n\n    find_if_exist(section_server,\n                  \"listen\", global.listenAddress,\n                  \"port\", global.listenPort,\n                  \"serve_file_root\", webServer.serve_file_root\n    );\n    webServer.serve_file = !webServer.serve_file_root.empty();\n\n    const auto &section_advanced = toml::find(root, \"advanced\");\n\n    std::string log_level;\n    bool enable_cache = true;\n    int cache_subscription = global.cacheSubscription, cache_config = global.cacheConfig, cache_ruleset = global.cacheRuleset;\n\n    find_if_exist(section_advanced,\n                  \"log_level\", log_level,\n                  \"print_debug_info\", global.printDbgInfo,\n                  \"max_pending_connections\", global.maxPendingConns,\n                  \"max_concurrent_threads\", global.maxConcurThreads,\n                  \"max_allowed_rulesets\", global.maxAllowedRulesets,\n                  \"max_allowed_rules\", global.maxAllowedRules,\n                  \"max_allowed_download_size\", global.maxAllowedDownloadSize,\n                  \"enable_cache\", enable_cache,\n                  \"cache_subscription\", cache_subscription,\n                  \"cache_config\", cache_config,\n                  \"cache_ruleset\", cache_ruleset,\n                  \"script_clean_context\", global.scriptCleanContext,\n                  \"async_fetch_ruleset\", global.asyncFetchRuleset,\n                  \"skip_failed_links\", global.skipFailedLinks\n    );\n\n    if(global.printDbgInfo)\n        global.logLevel = LOG_LEVEL_VERBOSE;\n    else\n    {\n        switch(hash_(log_level))\n        {\n        case \"warn\"_hash:\n            global.logLevel = LOG_LEVEL_WARNING;\n            break;\n        case \"error\"_hash:\n            global.logLevel = LOG_LEVEL_ERROR;\n            break;\n        case \"fatal\"_hash:\n            global.logLevel = LOG_LEVEL_FATAL;\n            break;\n        case \"verbose\"_hash:\n            global.logLevel = LOG_LEVEL_VERBOSE;\n            break;\n        case \"debug\"_hash:\n            global.logLevel = LOG_LEVEL_DEBUG;\n            break;\n        default:\n            global.logLevel = LOG_LEVEL_INFO;\n        }\n    }\n\n    if(enable_cache)\n    {\n        global.cacheSubscription = cache_subscription;\n        global.cacheConfig = cache_config;\n        global.cacheRuleset = cache_ruleset;\n    }\n    else\n    {\n        global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;\n    }\n\n    writeLog(0, \"Load preference settings in TOML format completed.\", LOG_LEVEL_INFO);\n}\n\nvoid readConf()\n{\n    guarded_mutex guard(gMutexConfigure);\n    writeLog(0, \"Loading preference settings...\", LOG_LEVEL_INFO);\n\n    eraseElements(global.excludeRemarks);\n    eraseElements(global.includeRemarks);\n    eraseElements(global.customProxyGroups);\n    eraseElements(global.customRulesets);\n\n    try\n    {\n        std::string prefdata = fileGet(global.prefPath, false);\n        if(prefdata.find(\"common:\") != prefdata.npos)\n        {\n            YAML::Node yaml = YAML::Load(prefdata);\n            if(yaml.size() && yaml[\"common\"])\n                return readYAMLConf(yaml);\n        }\n        toml::value conf = parseToml(prefdata, global.prefPath);\n        if(!conf.is_uninitialized() && toml::find_or<int>(conf, \"version\", 0))\n            return readTOMLConf(conf);\n    }\n    catch (YAML::Exception &e)\n    {\n        //ignore yaml parse error\n        writeLog(0, e.what(), LOG_LEVEL_DEBUG);\n        writeLog(0, \"Unable to load preference settings as YAML.\", LOG_LEVEL_DEBUG);\n    }\n    catch (toml::exception &e)\n    {\n        //ignore toml parse error\n        writeLog(0, e.what(), LOG_LEVEL_DEBUG);\n        writeLog(0, \"Unable to load preference settings as TOML.\", LOG_LEVEL_DEBUG);\n    }\n\n    INIReader ini;\n    ini.allow_dup_section_titles = true;\n    //ini.do_utf8_to_gbk = true;\n    int retVal = ini.ParseFile(global.prefPath);\n    if(retVal != INIREADER_EXCEPTION_NONE)\n    {\n        writeLog(0, \"Unable to load preference settings as INI. Reason: \" + ini.GetLastError(), LOG_LEVEL_FATAL);\n        return;\n    }\n\n    string_array tempArray;\n\n    ini.EnterSection(\"common\");\n    ini.GetBoolIfExist(\"api_mode\", global.APIMode);\n    ini.GetIfExist(\"api_access_token\", global.accessToken);\n    ini.GetIfExist(\"default_url\", global.defaultUrls);\n    global.enableInsert = ini.Get(\"enable_insert\");\n    ini.GetIfExist(\"insert_url\", global.insertUrls);\n    ini.GetBoolIfExist(\"prepend_insert_url\", global.prependInsert);\n    if(ini.ItemPrefixExist(\"exclude_remarks\"))\n        ini.GetAll(\"exclude_remarks\", global.excludeRemarks);\n    if(ini.ItemPrefixExist(\"include_remarks\"))\n        ini.GetAll(\"include_remarks\", global.includeRemarks);\n    global.filterScript = ini.GetBool(\"enable_filter\") ? ini.Get(\"filter_script\"): \"\";\n    ini.GetIfExist(\"base_path\", global.basePath);\n    ini.GetIfExist(\"clash_rule_base\", global.clashBase);\n    ini.GetIfExist(\"surge_rule_base\", global.surgeBase);\n    ini.GetIfExist(\"surfboard_rule_base\", global.surfboardBase);\n    ini.GetIfExist(\"mellow_rule_base\", global.mellowBase);\n    ini.GetIfExist(\"quan_rule_base\", global.quanBase);\n    ini.GetIfExist(\"quanx_rule_base\", global.quanXBase);\n    ini.GetIfExist(\"loon_rule_base\", global.loonBase);\n    ini.GetIfExist(\"default_external_config\", global.defaultExtConfig);\n    ini.GetBoolIfExist(\"append_proxy_type\", global.appendType);\n    ini.GetIfExist(\"proxy_config\", global.proxyConfig);\n    ini.GetIfExist(\"proxy_ruleset\", global.proxyRuleset);\n    ini.GetIfExist(\"proxy_subscription\", global.proxySubscription);\n\n    if(ini.SectionExist(\"surge_external_proxy\"))\n    {\n        ini.EnterSection(\"surge_external_proxy\");\n        ini.GetIfExist(\"surge_ssr_path\", global.surgeSSRPath);\n        ini.GetBoolIfExist(\"resolve_hostname\", global.surgeResolveHostname);\n    }\n\n    if(ini.SectionExist(\"node_pref\"))\n    {\n        ini.EnterSection(\"node_pref\");\n        /*\n        ini.GetBoolIfExist(\"udp_flag\", udp_flag);\n        ini.GetBoolIfExist(\"tcp_fast_open_flag\", tfo_flag);\n        ini.GetBoolIfExist(\"skip_cert_verify_flag\", scv_flag);\n        */\n        global.UDPFlag.set(ini.Get(\"udp_flag\"));\n        global.TFOFlag.set(ini.Get(\"tcp_fast_open_flag\"));\n        global.skipCertVerify.set(ini.Get(\"skip_cert_verify_flag\"));\n        global.TLS13Flag.set(ini.Get(\"tls13_flag\"));\n        ini.GetBoolIfExist(\"sort_flag\", global.enableSort);\n        global.sortScript = ini.Get(\"sort_script\");\n        ini.GetBoolIfExist(\"filter_deprecated_nodes\", global.filterDeprecated);\n        ini.GetBoolIfExist(\"append_sub_userinfo\", global.appendUserinfo);\n        ini.GetBoolIfExist(\"clash_use_new_field_name\", global.clashUseNewField);\n        ini.GetIfExist(\"clash_proxies_style\", global.clashProxiesStyle);\n        if(ini.ItemPrefixExist(\"rename_node\"))\n        {\n            ini.GetAll(\"rename_node\", tempArray);\n            importItems(tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"@\");\n            safe_set_renames(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    if(ini.SectionExist(\"userinfo\"))\n    {\n        ini.EnterSection(\"userinfo\");\n        if(ini.ItemPrefixExist(\"stream_rule\"))\n        {\n            ini.GetAll(\"stream_rule\", tempArray);\n            importItems(tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_streams(configs);\n            eraseElements(tempArray);\n        }\n        if(ini.ItemPrefixExist(\"time_rule\"))\n        {\n            ini.GetAll(\"time_rule\", tempArray);\n            importItems(tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_times(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    ini.EnterSection(\"managed_config\");\n    ini.GetBoolIfExist(\"write_managed_config\", global.writeManagedConfig);\n    ini.GetIfExist(\"managed_config_prefix\", global.managedConfigPrefix);\n    ini.GetIntIfExist(\"config_update_interval\", global.updateInterval);\n    ini.GetBoolIfExist(\"config_update_strict\", global.updateStrict);\n    ini.GetIfExist(\"quanx_device_id\", global.quanXDevID);\n\n    ini.EnterSection(\"emojis\");\n    ini.GetBoolIfExist(\"add_emoji\", global.addEmoji);\n    ini.GetBoolIfExist(\"remove_old_emoji\", global.removeEmoji);\n    if(ini.ItemPrefixExist(\"rule\"))\n    {\n        ini.GetAll(\"rule\", tempArray);\n        importItems(tempArray, false);\n        auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \",\");\n        safe_set_emojis(configs);\n        eraseElements(tempArray);\n    }\n\n    if(ini.SectionExist(\"rulesets\"))\n        ini.EnterSection(\"rulesets\");\n    else\n        ini.EnterSection(\"ruleset\");\n    global.enableRuleGen = ini.GetBool(\"enabled\");\n    if(global.enableRuleGen)\n    {\n        ini.GetBoolIfExist(\"overwrite_original_rules\", global.overwriteOriginalRules);\n        ini.GetBoolIfExist(\"update_ruleset_on_request\", global.updateRulesetOnRequest);\n        if(ini.ItemPrefixExist(\"ruleset\"))\n        {\n            string_array vArray;\n            ini.GetAll(\"ruleset\", vArray);\n            importItems(vArray, false);\n            global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n        }\n        else if(ini.ItemPrefixExist(\"surge_ruleset\"))\n        {\n            string_array vArray;\n            ini.GetAll(\"surge_ruleset\", vArray);\n            importItems(vArray, false);\n            global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n        }\n    }\n    else\n    {\n        global.overwriteOriginalRules = false;\n        global.updateRulesetOnRequest = false;\n    }\n\n    if(ini.SectionExist(\"proxy_groups\"))\n        ini.EnterSection(\"proxy_groups\");\n    else\n        ini.EnterSection(\"clash_proxy_group\");\n    if(ini.ItemPrefixExist(\"custom_proxy_group\"))\n    {\n        string_array vArray;\n        ini.GetAll(\"custom_proxy_group\", vArray);\n        importItems(vArray, false);\n        global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n\n    ini.EnterSection(\"template\");\n    ini.GetIfExist(\"template_path\", global.templatePath);\n    string_multimap tempmap;\n    ini.GetItems(tempmap);\n    eraseElements(global.templateVars);\n    for(auto &x : tempmap)\n    {\n        if(x.first == \"template_path\")\n            continue;\n        global.templateVars[x.first] = x.second;\n    }\n    global.templateVars[\"managed_config_prefix\"] = global.managedConfigPrefix;\n\n    if(ini.SectionExist(\"aliases\"))\n    {\n        ini.EnterSection(\"aliases\");\n        ini.GetItems(tempmap);\n        webServer.reset_redirect();\n        for(auto &x : tempmap)\n            webServer.append_redirect(x.first, x.second);\n    }\n\n    if(ini.SectionExist(\"tasks\"))\n    {\n        string_array vArray;\n        ini.EnterSection(\"tasks\");\n        ini.GetAll(\"task\", vArray);\n        importItems(vArray, false);\n        global.enableCron = !vArray.empty();\n        global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);\n        refresh_schedule();\n    }\n\n    ini.EnterSection(\"server\");\n    ini.GetIfExist(\"listen\", global.listenAddress);\n    ini.GetIntIfExist(\"port\", global.listenPort);\n    webServer.serve_file_root = ini.Get(\"serve_file_root\");\n    webServer.serve_file = !webServer.serve_file_root.empty();\n\n    ini.EnterSection(\"advanced\");\n    std::string log_level;\n    ini.GetIfExist(\"log_level\", log_level);\n    ini.GetBoolIfExist(\"print_debug_info\", global.printDbgInfo);\n    if(global.printDbgInfo)\n        global.logLevel = LOG_LEVEL_VERBOSE;\n    else\n    {\n        switch(hash_(log_level))\n        {\n        case \"warn\"_hash:\n            global.logLevel = LOG_LEVEL_WARNING;\n            break;\n        case \"error\"_hash:\n            global.logLevel = LOG_LEVEL_ERROR;\n            break;\n        case \"fatal\"_hash:\n            global.logLevel = LOG_LEVEL_FATAL;\n            break;\n        case \"verbose\"_hash:\n            global.logLevel = LOG_LEVEL_VERBOSE;\n            break;\n        case \"debug\"_hash:\n            global.logLevel = LOG_LEVEL_DEBUG;\n            break;\n        default:\n            global.logLevel = LOG_LEVEL_INFO;\n        }\n    }\n    ini.GetIntIfExist(\"max_pending_connections\", global.maxPendingConns);\n    ini.GetIntIfExist(\"max_concurrent_threads\", global.maxConcurThreads);\n    ini.GetNumberIfExist(\"max_allowed_rulesets\", global.maxAllowedRulesets);\n    ini.GetNumberIfExist(\"max_allowed_rules\", global.maxAllowedRules);\n    ini.GetNumberIfExist(\"max_allowed_download_size\", global.maxAllowedDownloadSize);\n    if(ini.ItemExist(\"enable_cache\"))\n    {\n        if(ini.GetBool(\"enable_cache\"))\n        {\n            ini.GetIntIfExist(\"cache_subscription\", global.cacheSubscription);\n            ini.GetIntIfExist(\"cache_config\", global.cacheConfig);\n            ini.GetIntIfExist(\"cache_ruleset\", global.cacheRuleset);\n            ini.GetBoolIfExist(\"serve_cache_on_fetch_fail\", global.serveCacheOnFetchFail);\n        }\n        else\n        {\n            global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; //disable cache\n            global.serveCacheOnFetchFail = false;\n        }\n    }\n    ini.GetBoolIfExist(\"script_clean_context\", global.scriptCleanContext);\n    ini.GetBoolIfExist(\"async_fetch_ruleset\", global.asyncFetchRuleset);\n    ini.GetBoolIfExist(\"skip_failed_links\", global.skipFailedLinks);\n\n    writeLog(0, \"Load preference settings in INI format completed.\", LOG_LEVEL_INFO);\n}\n\nint loadExternalYAML(YAML::Node &node, ExternalConfig &ext)\n{\n    YAML::Node section = node[\"custom\"], object;\n    std::string name, type, url, interval;\n    std::string group, strLine;\n\n    section[\"clash_rule_base\"] >> ext.clash_rule_base;\n    section[\"surge_rule_base\"] >> ext.surge_rule_base;\n    section[\"surfboard_rule_base\"] >> ext.surfboard_rule_base;\n    section[\"mellow_rule_base\"] >> ext.mellow_rule_base;\n    section[\"quan_rule_base\"] >> ext.quan_rule_base;\n    section[\"quanx_rule_base\"] >> ext.quanx_rule_base;\n    section[\"loon_rule_base\"] >> ext.loon_rule_base;\n    section[\"sssub_rule_base\"] >> ext.sssub_rule_base;\n\n    section[\"enable_rule_generator\"] >> ext.enable_rule_generator;\n    section[\"overwrite_original_rules\"] >> ext.overwrite_original_rules;\n\n    const char *group_name = section[\"proxy_groups\"].IsDefined() ? \"proxy_groups\" : \"custom_proxy_group\";\n    if(section[group_name].size())\n    {\n        string_array vArray;\n        readGroup(section[group_name], vArray, global.APIMode);\n        ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n\n    const char *ruleset_name = section[\"rulesets\"].IsDefined() ? \"rulesets\" : \"surge_ruleset\";\n    if(section[ruleset_name].size())\n    {\n        string_array vArray;\n        readRuleset(section[ruleset_name], vArray, global.APIMode);\n        if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)\n        {\n            writeLog(0, \"Ruleset count in external config has exceeded limit.\", LOG_LEVEL_WARNING);\n            return -1;\n        }\n        ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);\n    }\n\n    if(section[\"rename_node\"].size())\n    {\n        string_array vArray;\n        readRegexMatch(section[\"rename_node\"], \"@\", vArray, global.APIMode);\n        ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, \"@\");\n    }\n\n    ext.add_emoji = safe_as<std::string>(section[\"add_emoji\"]);\n    ext.remove_old_emoji = safe_as<std::string>(section[\"remove_old_emoji\"]);\n    const char *emoji_name = section[\"emojis\"].IsDefined() ? \"emojis\" : \"emoji\";\n    if(section[emoji_name].size())\n    {\n        string_array vArray;\n        readEmoji(section[emoji_name], vArray, global.APIMode);\n        ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, \",\");\n    }\n\n    section[\"include_remarks\"] >> ext.include;\n    section[\"exclude_remarks\"] >> ext.exclude;\n\n    if(node[\"template_args\"].IsSequence() && ext.tpl_args != NULL)\n    {\n        std::string key, value;\n        for(size_t i = 0; i < node[\"template_args\"].size(); i++)\n        {\n            node[\"template_args\"][i][\"key\"] >> key;\n            node[\"template_args\"][i][\"value\"] >> value;\n            ext.tpl_args->local_vars[key] = value;\n        }\n    }\n\n    return 0;\n}\n\nint loadExternalTOML(toml::value &root, ExternalConfig &ext)\n{\n    const auto &section = toml::find(root, \"custom\");\n\n    find_if_exist(section,\n                  \"enable_rule_generator\", ext.enable_rule_generator,\n                  \"overwrite_original_rules\", ext.overwrite_original_rules,\n                  \"clash_rule_base\", ext.clash_rule_base,\n                  \"surge_rule_base\", ext.surge_rule_base,\n                  \"surfboard_rule_base\", ext.surfboard_rule_base,\n                  \"mellow_rule_base\", ext.mellow_rule_base,\n                  \"quan_rule_base\", ext.quan_rule_base,\n                  \"quanx_rule_base\", ext.quanx_rule_base,\n                  \"sssub_rule_base\", ext.sssub_rule_base,\n                  \"add_emoji\", ext.add_emoji,\n                  \"remove_old_emoji\", ext.remove_old_emoji,\n                  \"include_remarks\", ext.include,\n                  \"exclude_remarks\", ext.exclude\n    );\n\n    if(ext.tpl_args != nullptr) operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section, \"template_args\", {}), \"key\", \"value\",\n                                                      [&](const toml::value &key, const toml::value &value)\n    {\n        std::string val = toml::format(value);\n        ext.tpl_args->local_vars[key.as_string()] = val;\n    });\n\n    auto groups = toml::find_or<std::vector<toml::value>>(root, \"custom_groups\", {});\n    importItems(groups, \"custom_groups\", false);\n    ext.custom_proxy_group = toml::get<ProxyGroupConfigs>(toml::value(groups));\n\n    auto rulesets = toml::find_or<std::vector<toml::value>>(root, \"rulesets\", {});\n    importItems(rulesets, \"rulesets\", false);\n    if(global.maxAllowedRulesets && rulesets.size() > global.maxAllowedRulesets)\n    {\n        writeLog(0, \"Ruleset count in external config has exceeded limit. \", LOG_LEVEL_WARNING);\n        return -1;\n    }\n    ext.surge_ruleset = toml::get<RulesetConfigs>(toml::value(rulesets));\n\n    auto emojiconfs = toml::find_or<std::vector<toml::value>>(root, \"emoji\", {});\n    importItems(emojiconfs, \"emoji\", false);\n    ext.emoji = toml::get<RegexMatchConfigs>(toml::value(emojiconfs));\n\n    auto renameconfs = toml::find_or<std::vector<toml::value>>(root, \"rename_node\", {});\n    importItems(renameconfs, \"rename_node\", false);\n    ext.rename = toml::get<RegexMatchConfigs>(toml::value(renameconfs));\n\n    return 0;\n}\n\nint loadExternalConfig(std::string &path, ExternalConfig &ext)\n{\n    std::string base_content, proxy = parseProxy(global.proxyConfig), config = fetchFile(path, proxy, global.cacheConfig);\n    if(render_template(config, *ext.tpl_args, base_content, global.templatePath) != 0)\n        base_content = config;\n\n    try\n    {\n        YAML::Node yaml = YAML::Load(base_content);\n        if(yaml.size() && yaml[\"custom\"].IsDefined())\n            return loadExternalYAML(yaml, ext);\n        toml::value conf = parseToml(base_content, path);\n        if(!conf.is_uninitialized() && toml::find_or<int>(conf, \"version\", 0))\n            return loadExternalTOML(conf, ext);\n    }\n    catch (YAML::Exception &e)\n    {\n        //ignore\n    }\n    catch (toml::exception &e)\n    {\n        //ignore\n    }\n\n    INIReader ini;\n    ini.store_isolated_line = true;\n    ini.SetIsolatedItemsSection(\"custom\");\n    if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)\n    {\n        //std::cerr<<\"Load external configuration failed. Reason: \"<<ini.GetLastError()<<\"\\n\";\n        writeLog(0, \"Load external configuration failed. Reason: \" + ini.GetLastError(), LOG_LEVEL_ERROR);\n        return -1;\n    }\n\n    ini.EnterSection(\"custom\");\n    if(ini.ItemPrefixExist(\"custom_proxy_group\"))\n    {\n        string_array vArray;\n        ini.GetAll(\"custom_proxy_group\", vArray);\n        importItems(vArray, global.APIMode);\n        ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n    std::string ruleset_name = ini.ItemPrefixExist(\"ruleset\") ? \"ruleset\" : \"surge_ruleset\";\n    if(ini.ItemPrefixExist(ruleset_name))\n    {\n        string_array vArray;\n        ini.GetAll(ruleset_name, vArray);\n        importItems(vArray, global.APIMode);\n        if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)\n        {\n            writeLog(0, \"Ruleset count in external config has exceeded limit. \", LOG_LEVEL_WARNING);\n            return -1;\n        }\n        ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);\n    }\n\n    ini.GetIfExist(\"clash_rule_base\", ext.clash_rule_base);\n    ini.GetIfExist(\"surge_rule_base\", ext.surge_rule_base);\n    ini.GetIfExist(\"surfboard_rule_base\", ext.surfboard_rule_base);\n    ini.GetIfExist(\"mellow_rule_base\", ext.mellow_rule_base);\n    ini.GetIfExist(\"quan_rule_base\", ext.quan_rule_base);\n    ini.GetIfExist(\"quanx_rule_base\", ext.quanx_rule_base);\n    ini.GetIfExist(\"loon_rule_base\", ext.loon_rule_base);\n    ini.GetIfExist(\"sssub_rule_base\", ext.sssub_rule_base);\n\n    ini.GetBoolIfExist(\"overwrite_original_rules\", ext.overwrite_original_rules);\n    ini.GetBoolIfExist(\"enable_rule_generator\", ext.enable_rule_generator);\n\n    if(ini.ItemPrefixExist(\"rename\"))\n    {\n        string_array vArray;\n        ini.GetAll(\"rename\", vArray);\n        importItems(vArray, global.APIMode);\n        ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, \"@\");\n    }\n    ext.add_emoji = ini.Get(\"add_emoji\");\n    ext.remove_old_emoji = ini.Get(\"remove_old_emoji\");\n    if(ini.ItemPrefixExist(\"emoji\"))\n    {\n        string_array vArray;\n        ini.GetAll(\"emoji\", vArray);\n        importItems(vArray, global.APIMode);\n        ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, \",\");\n    }\n    if(ini.ItemPrefixExist(\"include_remarks\"))\n        ini.GetAll(\"include_remarks\", ext.include);\n    if(ini.ItemPrefixExist(\"exclude_remarks\"))\n        ini.GetAll(\"exclude_remarks\", ext.exclude);\n\n    if(ini.SectionExist(\"template\") && ext.tpl_args != nullptr)\n    {\n        ini.EnterSection(\"template\");\n        string_multimap tempmap;\n        ini.GetItems(tempmap);\n        for(auto &x : tempmap)\n            ext.tpl_args->local_vars[x.first] = x.second;\n    }\n\n    return 0;\n}\n", "#ifndef SETTINGS_H_INCLUDED\n#define SETTINGS_H_INCLUDED\n\n#include <string>\n\n#include \"../config/crontask.h\"\n#include \"../config/regmatch.h\"\n#include \"../config/proxygroup.h\"\n#include \"../config/ruleset.h\"\n#include \"../generator/config/ruleconvert.h\"\n#include \"../generator/template/templates.h\"\n#include \"../utils/logger.h\"\n#include \"../utils/string.h\"\n#include \"../utils/stl_extra.h\"\n#include \"../utils/tribool.h\"\n\nstruct Settings\n{\n    //common settings\n    std::string prefPath = \"pref.ini\", defaultExtConfig;\n    string_array excludeRemarks, includeRemarks;\n    RulesetConfigs customRulesets;\n    RegexMatchConfigs streamNodeRules, timeNodeRules;\n    std::vector<RulesetContent> rulesetsContent;\n    std::string listenAddress = \"127.0.0.1\", defaultUrls, insertUrls, managedConfigPrefix;\n    int listenPort = 25500, maxPendingConns = 10, maxConcurThreads = 4;\n    bool prependInsert = true, skipFailedLinks = false;\n    bool APIMode = true, writeManagedConfig = false, enableRuleGen = true, updateRulesetOnRequest = false, overwriteOriginalRules = true;\n    bool printDbgInfo = false, CFWChildProcess = false, appendUserinfo = true, asyncFetchRuleset = false, surgeResolveHostname = true;\n    std::string accessToken, basePath = \"base\";\n    std::string custom_group;\n    int logLevel = LOG_LEVEL_VERBOSE;\n    long maxAllowedDownloadSize = 1048576L;\n    string_map aliases;\n\n    //global variables for template\n    std::string templatePath = \"templates\";\n    string_map templateVars;\n\n    //generator settings\n    bool generatorMode = false;\n    std::string generateProfiles;\n\n    //preferences\n    RegexMatchConfigs renames, emojis;\n    bool addEmoji = false, removeEmoji = false, appendType = false, filterDeprecated = true;\n    tribool UDPFlag, TFOFlag, skipCertVerify, TLS13Flag, enableInsert;\n    bool enableSort = false, updateStrict = false;\n    bool clashUseNewField = false;\n    std::string clashProxiesStyle = \"flow\";\n    std::string proxyConfig, proxyRuleset, proxySubscription;\n    int updateInterval = 0;\n    std::string sortScript, filterScript;\n\n    std::string clashBase;\n    ProxyGroupConfigs customProxyGroups;\n    std::string surgeBase, surfboardBase, mellowBase, quanBase, quanXBase, loonBase, SSSubBase;\n    std::string surgeSSRPath, quanXDevID;\n\n    //cache system\n    bool serveCacheOnFetchFail = false;\n    int cacheSubscription = 60, cacheConfig = 300, cacheRuleset = 21600;\n\n    //limits\n    size_t maxAllowedRulesets = 64, maxAllowedRules = 32768;\n    bool scriptCleanContext = false;\n\n    //cron system\n    bool enableCron = false;\n    CronTaskConfigs cronTasks;\n};\n\n\nstruct ExternalConfig\n{\n    ProxyGroupConfigs custom_proxy_group;\n    RulesetConfigs surge_ruleset;\n    std::string clash_rule_base;\n    std::string surge_rule_base;\n    std::string surfboard_rule_base;\n    std::string mellow_rule_base;\n    std::string quan_rule_base;\n    std::string quanx_rule_base;\n    std::string loon_rule_base;\n    std::string sssub_rule_base;\n    RegexMatchConfigs rename;\n    RegexMatchConfigs emoji;\n    string_array include;\n    string_array exclude;\n    template_args *tpl_args = nullptr;\n    bool overwrite_original_rules = false;\n    bool enable_rule_generator = true;\n    tribool add_emoji;\n    tribool remove_old_emoji;\n};\n\nextern Settings global;\n\nint importItems(string_array &target, bool scope_limit = true);\nint loadExternalConfig(std::string &path, ExternalConfig &ext);\n\ntemplate <class... Args>\nvoid parseGroupTimes(const std::string &src, Args... args)\n{\n    std::array<int*, sizeof...(args)> ptrs {args...};\n    string_size bpos = 0, epos = src.find(\",\");\n    for(int *x : ptrs)\n    {\n        if(x != nullptr)\n            *x = to_int(src.substr(bpos, epos - bpos), 0);\n        if(epos != src.npos)\n        {\n            bpos = epos + 1;\n            epos = src.find(\",\", bpos);\n        }\n        else\n            return;\n    }\n    return;\n}\n\n#endif // SETTINGS_H_INCLUDED\n"], "filenames": ["src/generator/config/nodemanip.cpp", "src/generator/config/subexport.cpp", "src/generator/config/subexport.h", "src/handler/interfaces.cpp", "src/handler/settings.cpp", "src/handler/settings.h"], "buggy_code_start_loc": [54, 186, 41, 409, 579, 32], "buggy_code_end_loc": [485, 187, 41, 409, 1075, 33], "fixing_code_start_loc": [54, 186, 42, 410, 580, 32], "fixing_code_end_loc": [485, 187, 43, 411, 1078, 33], "type": "CWE-434", "message": "A remote code execution (RCE) vulnerability in Subconverter v0.7.2 allows attackers to execute arbitrary code via crafted config and url parameters.", "other": {"cve": {"id": "CVE-2022-28927", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-19T16:15:07.963", "lastModified": "2022-05-26T20:03:42.837", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A remote code execution (RCE) vulnerability in Subconverter v0.7.2 allows attackers to execute arbitrary code via crafted config and url parameters."}, {"lang": "es", "value": "Una vulnerabilidad de ejecuci\u00f3n de c\u00f3digo remota (RCE) en Subconverter versi\u00f3n v0.7.2, permite a atacantes ejecutar c\u00f3digo arbitrario por medio de par\u00e1metros de configuraci\u00f3n y url dise\u00f1ados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:subconverter_project:subconverter:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F1DB9CE8-B932-4B57-BAF2-38E79B00E3A6"}]}]}], "references": [{"url": "https://gist.github.com/CwithW/01a726e5af709655d6ee0b2067cdae03", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/tindy2013/subconverter/commit/ce8d2bd0f13f05fcbd2ed90755d097f402393dd3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tindy2013/subconverter/commit/ce8d2bd0f13f05fcbd2ed90755d097f402393dd3"}}