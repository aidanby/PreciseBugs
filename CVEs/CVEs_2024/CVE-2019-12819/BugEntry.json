{"buggy_code": ["/* MDIO Bus interface\n *\n * Author: Andy Fleming\n *\n * Copyright (c) 2004 Freescale Semiconductor, Inc.\n *\n * This program is free software; you can redistribute  it and/or modify it\n * under  the terms of  the GNU General  Public License as published by the\n * Free Software Foundation;  either version 2 of the  License, or (at your\n * option) any later version.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <linux/of_mdio.h>\n#include <linux/of_gpio.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include <asm/irq.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/mdio.h>\n\n#include \"mdio-boardinfo.h\"\n\nstatic int mdiobus_register_gpiod(struct mdio_device *mdiodev)\n{\n\tstruct gpio_desc *gpiod = NULL;\n\n\t/* Deassert the optional reset signal */\n\tif (mdiodev->dev.of_node)\n\t\tgpiod = fwnode_get_named_gpiod(&mdiodev->dev.of_node->fwnode,\n\t\t\t\t\t       \"reset-gpios\", 0, GPIOD_OUT_LOW,\n\t\t\t\t\t       \"PHY reset\");\n\tif (PTR_ERR(gpiod) == -ENOENT ||\n\t    PTR_ERR(gpiod) == -ENOSYS)\n\t\tgpiod = NULL;\n\telse if (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tmdiodev->reset = gpiod;\n\n\t/* Assert the reset signal again */\n\tmdio_device_reset(mdiodev, 1);\n\n\treturn 0;\n}\n\nint mdiobus_register_device(struct mdio_device *mdiodev)\n{\n\tint err;\n\n\tif (mdiodev->bus->mdio_map[mdiodev->addr])\n\t\treturn -EBUSY;\n\n\tif (mdiodev->flags & MDIO_DEVICE_FLAG_PHY) {\n\t\terr = mdiobus_register_gpiod(mdiodev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmdiodev->bus->mdio_map[mdiodev->addr] = mdiodev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mdiobus_register_device);\n\nint mdiobus_unregister_device(struct mdio_device *mdiodev)\n{\n\tif (mdiodev->bus->mdio_map[mdiodev->addr] != mdiodev)\n\t\treturn -EINVAL;\n\n\tmdiodev->bus->mdio_map[mdiodev->addr] = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mdiobus_unregister_device);\n\nstruct phy_device *mdiobus_get_phy(struct mii_bus *bus, int addr)\n{\n\tstruct mdio_device *mdiodev = bus->mdio_map[addr];\n\n\tif (!mdiodev)\n\t\treturn NULL;\n\n\tif (!(mdiodev->flags & MDIO_DEVICE_FLAG_PHY))\n\t\treturn NULL;\n\n\treturn container_of(mdiodev, struct phy_device, mdio);\n}\nEXPORT_SYMBOL(mdiobus_get_phy);\n\nbool mdiobus_is_registered_device(struct mii_bus *bus, int addr)\n{\n\treturn bus->mdio_map[addr];\n}\nEXPORT_SYMBOL(mdiobus_is_registered_device);\n\n/**\n * mdiobus_alloc_size - allocate a mii_bus structure\n * @size: extra amount of memory to allocate for private storage.\n * If non-zero, then bus->priv is points to that memory.\n *\n * Description: called by a bus driver to allocate an mii_bus\n * structure to fill in.\n */\nstruct mii_bus *mdiobus_alloc_size(size_t size)\n{\n\tstruct mii_bus *bus;\n\tsize_t aligned_size = ALIGN(sizeof(*bus), NETDEV_ALIGN);\n\tsize_t alloc_size;\n\tint i;\n\n\t/* If we alloc extra space, it should be aligned */\n\tif (size)\n\t\talloc_size = aligned_size + size;\n\telse\n\t\talloc_size = sizeof(*bus);\n\n\tbus = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!bus)\n\t\treturn NULL;\n\n\tbus->state = MDIOBUS_ALLOCATED;\n\tif (size)\n\t\tbus->priv = (void *)bus + aligned_size;\n\n\t/* Initialise the interrupts to polling */\n\tfor (i = 0; i < PHY_MAX_ADDR; i++)\n\t\tbus->irq[i] = PHY_POLL;\n\n\treturn bus;\n}\nEXPORT_SYMBOL(mdiobus_alloc_size);\n\nstatic void _devm_mdiobus_free(struct device *dev, void *res)\n{\n\tmdiobus_free(*(struct mii_bus **)res);\n}\n\nstatic int devm_mdiobus_match(struct device *dev, void *res, void *data)\n{\n\tstruct mii_bus **r = res;\n\n\tif (WARN_ON(!r || !*r))\n\t\treturn 0;\n\n\treturn *r == data;\n}\n\n/**\n * devm_mdiobus_alloc_size - Resource-managed mdiobus_alloc_size()\n * @dev:\t\tDevice to allocate mii_bus for\n * @sizeof_priv:\tSpace to allocate for private structure.\n *\n * Managed mdiobus_alloc_size. mii_bus allocated with this function is\n * automatically freed on driver detach.\n *\n * If an mii_bus allocated with this function needs to be freed separately,\n * devm_mdiobus_free() must be used.\n *\n * RETURNS:\n * Pointer to allocated mii_bus on success, NULL on failure.\n */\nstruct mii_bus *devm_mdiobus_alloc_size(struct device *dev, int sizeof_priv)\n{\n\tstruct mii_bus **ptr, *bus;\n\n\tptr = devres_alloc(_devm_mdiobus_free, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn NULL;\n\n\t/* use raw alloc_dr for kmalloc caller tracing */\n\tbus = mdiobus_alloc_size(sizeof_priv);\n\tif (bus) {\n\t\t*ptr = bus;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn bus;\n}\nEXPORT_SYMBOL_GPL(devm_mdiobus_alloc_size);\n\n/**\n * devm_mdiobus_free - Resource-managed mdiobus_free()\n * @dev:\t\tDevice this mii_bus belongs to\n * @bus:\t\tthe mii_bus associated with the device\n *\n * Free mii_bus allocated with devm_mdiobus_alloc_size().\n */\nvoid devm_mdiobus_free(struct device *dev, struct mii_bus *bus)\n{\n\tint rc;\n\n\trc = devres_release(dev, _devm_mdiobus_free,\n\t\t\t    devm_mdiobus_match, bus);\n\tWARN_ON(rc);\n}\nEXPORT_SYMBOL_GPL(devm_mdiobus_free);\n\n/**\n * mdiobus_release - mii_bus device release callback\n * @d: the target struct device that contains the mii_bus\n *\n * Description: called when the last reference to an mii_bus is\n * dropped, to free the underlying memory.\n */\nstatic void mdiobus_release(struct device *d)\n{\n\tstruct mii_bus *bus = to_mii_bus(d);\n\tBUG_ON(bus->state != MDIOBUS_RELEASED &&\n\t       /* for compatibility with error handling in drivers */\n\t       bus->state != MDIOBUS_ALLOCATED);\n\tkfree(bus);\n}\n\nstatic struct class mdio_bus_class = {\n\t.name\t\t= \"mdio_bus\",\n\t.dev_release\t= mdiobus_release,\n};\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\n/* Helper function for of_mdio_find_bus */\nstatic int of_mdio_bus_match(struct device *dev, const void *mdio_bus_np)\n{\n\treturn dev->of_node == mdio_bus_np;\n}\n/**\n * of_mdio_find_bus - Given an mii_bus node, find the mii_bus.\n * @mdio_bus_np: Pointer to the mii_bus.\n *\n * Returns a reference to the mii_bus, or NULL if none found.  The\n * embedded struct device will have its reference count incremented,\n * and this must be put once the bus is finished with.\n *\n * Because the association of a device_node and mii_bus is made via\n * of_mdiobus_register(), the mii_bus cannot be found before it is\n * registered with of_mdiobus_register().\n *\n */\nstruct mii_bus *of_mdio_find_bus(struct device_node *mdio_bus_np)\n{\n\tstruct device *d;\n\n\tif (!mdio_bus_np)\n\t\treturn NULL;\n\n\td = class_find_device(&mdio_bus_class, NULL,  mdio_bus_np,\n\t\t\t      of_mdio_bus_match);\n\n\treturn d ? to_mii_bus(d) : NULL;\n}\nEXPORT_SYMBOL(of_mdio_find_bus);\n\n/* Walk the list of subnodes of a mdio bus and look for a node that\n * matches the mdio device's address with its 'reg' property. If\n * found, set the of_node pointer for the mdio device. This allows\n * auto-probed phy devices to be supplied with information passed in\n * via DT.\n */\nstatic void of_mdiobus_link_mdiodev(struct mii_bus *bus,\n\t\t\t\t    struct mdio_device *mdiodev)\n{\n\tstruct device *dev = &mdiodev->dev;\n\tstruct device_node *child;\n\n\tif (dev->of_node || !bus->dev.of_node)\n\t\treturn;\n\n\tfor_each_available_child_of_node(bus->dev.of_node, child) {\n\t\tint addr;\n\n\t\taddr = of_mdio_parse_addr(dev, child);\n\t\tif (addr < 0)\n\t\t\tcontinue;\n\n\t\tif (addr == mdiodev->addr) {\n\t\t\tdev->of_node = child;\n\t\t\tdev->fwnode = of_fwnode_handle(child);\n\t\t\treturn;\n\t\t}\n\t}\n}\n#else /* !IS_ENABLED(CONFIG_OF_MDIO) */\nstatic inline void of_mdiobus_link_mdiodev(struct mii_bus *mdio,\n\t\t\t\t\t   struct mdio_device *mdiodev)\n{\n}\n#endif\n\n/**\n * mdiobus_create_device_from_board_info - create a full MDIO device given\n * a mdio_board_info structure\n * @bus: MDIO bus to create the devices on\n * @bi: mdio_board_info structure describing the devices\n *\n * Returns 0 on success or < 0 on error.\n */\nstatic int mdiobus_create_device(struct mii_bus *bus,\n\t\t\t\t struct mdio_board_info *bi)\n{\n\tstruct mdio_device *mdiodev;\n\tint ret = 0;\n\n\tmdiodev = mdio_device_create(bus, bi->mdio_addr);\n\tif (IS_ERR(mdiodev))\n\t\treturn -ENODEV;\n\n\tstrncpy(mdiodev->modalias, bi->modalias,\n\t\tsizeof(mdiodev->modalias));\n\tmdiodev->bus_match = mdio_device_bus_match;\n\tmdiodev->dev.platform_data = (void *)bi->platform_data;\n\n\tret = mdio_device_register(mdiodev);\n\tif (ret)\n\t\tmdio_device_free(mdiodev);\n\n\treturn ret;\n}\n\n/**\n * __mdiobus_register - bring up all the PHYs on a given bus and attach them to bus\n * @bus: target mii_bus\n * @owner: module containing bus accessor functions\n *\n * Description: Called by a bus driver to bring up all the PHYs\n *   on a given bus, and attach them to the bus. Drivers should use\n *   mdiobus_register() rather than __mdiobus_register() unless they\n *   need to pass a specific owner module. MDIO devices which are not\n *   PHYs will not be brought up by this function. They are expected to\n *   to be explicitly listed in DT and instantiated by of_mdiobus_register().\n *\n * Returns 0 on success or < 0 on error.\n */\nint __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n\terr = device_register(&bus->dev);\n\tif (err) {\n\t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\tput_device(&bus->dev);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}\nEXPORT_SYMBOL(__mdiobus_register);\n\nvoid mdiobus_unregister(struct mii_bus *bus)\n{\n\tstruct mdio_device *mdiodev;\n\tint i;\n\n\tBUG_ON(bus->state != MDIOBUS_REGISTERED);\n\tbus->state = MDIOBUS_UNREGISTERED;\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tif (mdiodev->reset)\n\t\t\tgpiod_put(mdiodev->reset);\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n}\nEXPORT_SYMBOL(mdiobus_unregister);\n\n/**\n * mdiobus_free - free a struct mii_bus\n * @bus: mii_bus to free\n *\n * This function releases the reference to the underlying device\n * object in the mii_bus.  If this is the last reference, the mii_bus\n * will be freed.\n */\nvoid mdiobus_free(struct mii_bus *bus)\n{\n\t/* For compatibility with error handling in drivers. */\n\tif (bus->state == MDIOBUS_ALLOCATED) {\n\t\tkfree(bus);\n\t\treturn;\n\t}\n\n\tBUG_ON(bus->state != MDIOBUS_UNREGISTERED);\n\tbus->state = MDIOBUS_RELEASED;\n\n\tput_device(&bus->dev);\n}\nEXPORT_SYMBOL(mdiobus_free);\n\n/**\n * mdiobus_scan - scan a bus for MDIO devices.\n * @bus: mii_bus to scan\n * @addr: address on bus to scan\n *\n * This function scans the MDIO bus, looking for devices which can be\n * identified using a vendor/product ID in registers 2 and 3. Not all\n * MDIO devices have such registers, but PHY devices typically\n * do. Hence this function assumes anything found is a PHY, or can be\n * treated as a PHY. Other MDIO devices, such as switches, will\n * probably not be found during the scan.\n */\nstruct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)\n{\n\tstruct phy_device *phydev;\n\tint err;\n\n\tphydev = get_phy_device(bus, addr, false);\n\tif (IS_ERR(phydev))\n\t\treturn phydev;\n\n\t/*\n\t * For DT, see if the auto-probed phy has a correspoding child\n\t * in the bus node, and set the of_node pointer in this case.\n\t */\n\tof_mdiobus_link_mdiodev(bus, &phydev->mdio);\n\n\terr = phy_device_register(phydev);\n\tif (err) {\n\t\tphy_device_free(phydev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn phydev;\n}\nEXPORT_SYMBOL(mdiobus_scan);\n\n/**\n * __mdiobus_read - Unlocked version of the mdiobus_read function\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to read\n *\n * Read a MDIO bus register. Caller must hold the mdio bus lock.\n *\n * NOTE: MUST NOT be called from interrupt context.\n */\nint __mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&bus->mdio_lock));\n\n\tretval = bus->read(bus, addr, regnum);\n\n\ttrace_mdio_access(bus, 1, addr, regnum, retval, retval);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(__mdiobus_read);\n\n/**\n * __mdiobus_write - Unlocked version of the mdiobus_write function\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to write\n * @val: value to write to @regnum\n *\n * Write a MDIO bus register. Caller must hold the mdio bus lock.\n *\n * NOTE: MUST NOT be called from interrupt context.\n */\nint __mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val)\n{\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&bus->mdio_lock));\n\n\terr = bus->write(bus, addr, regnum, val);\n\n\ttrace_mdio_access(bus, 0, addr, regnum, val, err);\n\n\treturn err;\n}\nEXPORT_SYMBOL(__mdiobus_write);\n\n/**\n * mdiobus_read_nested - Nested version of the mdiobus_read function\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to read\n *\n * In case of nested MDIO bus access avoid lockdep false positives by\n * using mutex_lock_nested().\n *\n * NOTE: MUST NOT be called from interrupt context,\n * because the bus read/write functions may wait for an interrupt\n * to conclude the operation.\n */\nint mdiobus_read_nested(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\tretval = __mdiobus_read(bus, addr, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(mdiobus_read_nested);\n\n/**\n * mdiobus_read - Convenience function for reading a given MII mgmt register\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to read\n *\n * NOTE: MUST NOT be called from interrupt context,\n * because the bus read/write functions may wait for an interrupt\n * to conclude the operation.\n */\nint mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock(&bus->mdio_lock);\n\tretval = __mdiobus_read(bus, addr, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(mdiobus_read);\n\n/**\n * mdiobus_write_nested - Nested version of the mdiobus_write function\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to write\n * @val: value to write to @regnum\n *\n * In case of nested MDIO bus access avoid lockdep false positives by\n * using mutex_lock_nested().\n *\n * NOTE: MUST NOT be called from interrupt context,\n * because the bus read/write functions may wait for an interrupt\n * to conclude the operation.\n */\nint mdiobus_write_nested(struct mii_bus *bus, int addr, u32 regnum, u16 val)\n{\n\tint err;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\terr = __mdiobus_write(bus, addr, regnum, val);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mdiobus_write_nested);\n\n/**\n * mdiobus_write - Convenience function for writing a given MII mgmt register\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to write\n * @val: value to write to @regnum\n *\n * NOTE: MUST NOT be called from interrupt context,\n * because the bus read/write functions may wait for an interrupt\n * to conclude the operation.\n */\nint mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val)\n{\n\tint err;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock(&bus->mdio_lock);\n\terr = __mdiobus_write(bus, addr, regnum, val);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mdiobus_write);\n\n/**\n * mdio_bus_match - determine if given MDIO driver supports the given\n *\t\t    MDIO device\n * @dev: target MDIO device\n * @drv: given MDIO driver\n *\n * Description: Given a MDIO device, and a MDIO driver, return 1 if\n *   the driver supports the device.  Otherwise, return 0. This may\n *   require calling the devices own match function, since different classes\n *   of MDIO devices have different match criteria.\n */\nstatic int mdio_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct mdio_device *mdio = to_mdio_device(dev);\n\n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\tif (mdio->bus_match)\n\t\treturn mdio->bus_match(dev, drv);\n\n\treturn 0;\n}\n\nstatic int mdio_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tint rc;\n\n\t/* Some devices have extra OF data and an OF-style MODALIAS */\n\trc = of_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstruct bus_type mdio_bus_type = {\n\t.name\t\t= \"mdio_bus\",\n\t.match\t\t= mdio_bus_match,\n\t.uevent\t\t= mdio_uevent,\n};\nEXPORT_SYMBOL(mdio_bus_type);\n\nint __init mdio_bus_init(void)\n{\n\tint ret;\n\n\tret = class_register(&mdio_bus_class);\n\tif (!ret) {\n\t\tret = bus_register(&mdio_bus_type);\n\t\tif (ret)\n\t\t\tclass_unregister(&mdio_bus_class);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mdio_bus_init);\n\n#if IS_ENABLED(CONFIG_PHYLIB)\nvoid mdio_bus_exit(void)\n{\n\tclass_unregister(&mdio_bus_class);\n\tbus_unregister(&mdio_bus_type);\n}\nEXPORT_SYMBOL_GPL(mdio_bus_exit);\n#else\nmodule_init(mdio_bus_init);\n/* no module_exit, intentional */\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MDIO bus/device layer\");\n#endif\n"], "fixing_code": ["/* MDIO Bus interface\n *\n * Author: Andy Fleming\n *\n * Copyright (c) 2004 Freescale Semiconductor, Inc.\n *\n * This program is free software; you can redistribute  it and/or modify it\n * under  the terms of  the GNU General  Public License as published by the\n * Free Software Foundation;  either version 2 of the  License, or (at your\n * option) any later version.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <linux/of_mdio.h>\n#include <linux/of_gpio.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include <asm/irq.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/mdio.h>\n\n#include \"mdio-boardinfo.h\"\n\nstatic int mdiobus_register_gpiod(struct mdio_device *mdiodev)\n{\n\tstruct gpio_desc *gpiod = NULL;\n\n\t/* Deassert the optional reset signal */\n\tif (mdiodev->dev.of_node)\n\t\tgpiod = fwnode_get_named_gpiod(&mdiodev->dev.of_node->fwnode,\n\t\t\t\t\t       \"reset-gpios\", 0, GPIOD_OUT_LOW,\n\t\t\t\t\t       \"PHY reset\");\n\tif (PTR_ERR(gpiod) == -ENOENT ||\n\t    PTR_ERR(gpiod) == -ENOSYS)\n\t\tgpiod = NULL;\n\telse if (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tmdiodev->reset = gpiod;\n\n\t/* Assert the reset signal again */\n\tmdio_device_reset(mdiodev, 1);\n\n\treturn 0;\n}\n\nint mdiobus_register_device(struct mdio_device *mdiodev)\n{\n\tint err;\n\n\tif (mdiodev->bus->mdio_map[mdiodev->addr])\n\t\treturn -EBUSY;\n\n\tif (mdiodev->flags & MDIO_DEVICE_FLAG_PHY) {\n\t\terr = mdiobus_register_gpiod(mdiodev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmdiodev->bus->mdio_map[mdiodev->addr] = mdiodev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mdiobus_register_device);\n\nint mdiobus_unregister_device(struct mdio_device *mdiodev)\n{\n\tif (mdiodev->bus->mdio_map[mdiodev->addr] != mdiodev)\n\t\treturn -EINVAL;\n\n\tmdiodev->bus->mdio_map[mdiodev->addr] = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mdiobus_unregister_device);\n\nstruct phy_device *mdiobus_get_phy(struct mii_bus *bus, int addr)\n{\n\tstruct mdio_device *mdiodev = bus->mdio_map[addr];\n\n\tif (!mdiodev)\n\t\treturn NULL;\n\n\tif (!(mdiodev->flags & MDIO_DEVICE_FLAG_PHY))\n\t\treturn NULL;\n\n\treturn container_of(mdiodev, struct phy_device, mdio);\n}\nEXPORT_SYMBOL(mdiobus_get_phy);\n\nbool mdiobus_is_registered_device(struct mii_bus *bus, int addr)\n{\n\treturn bus->mdio_map[addr];\n}\nEXPORT_SYMBOL(mdiobus_is_registered_device);\n\n/**\n * mdiobus_alloc_size - allocate a mii_bus structure\n * @size: extra amount of memory to allocate for private storage.\n * If non-zero, then bus->priv is points to that memory.\n *\n * Description: called by a bus driver to allocate an mii_bus\n * structure to fill in.\n */\nstruct mii_bus *mdiobus_alloc_size(size_t size)\n{\n\tstruct mii_bus *bus;\n\tsize_t aligned_size = ALIGN(sizeof(*bus), NETDEV_ALIGN);\n\tsize_t alloc_size;\n\tint i;\n\n\t/* If we alloc extra space, it should be aligned */\n\tif (size)\n\t\talloc_size = aligned_size + size;\n\telse\n\t\talloc_size = sizeof(*bus);\n\n\tbus = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!bus)\n\t\treturn NULL;\n\n\tbus->state = MDIOBUS_ALLOCATED;\n\tif (size)\n\t\tbus->priv = (void *)bus + aligned_size;\n\n\t/* Initialise the interrupts to polling */\n\tfor (i = 0; i < PHY_MAX_ADDR; i++)\n\t\tbus->irq[i] = PHY_POLL;\n\n\treturn bus;\n}\nEXPORT_SYMBOL(mdiobus_alloc_size);\n\nstatic void _devm_mdiobus_free(struct device *dev, void *res)\n{\n\tmdiobus_free(*(struct mii_bus **)res);\n}\n\nstatic int devm_mdiobus_match(struct device *dev, void *res, void *data)\n{\n\tstruct mii_bus **r = res;\n\n\tif (WARN_ON(!r || !*r))\n\t\treturn 0;\n\n\treturn *r == data;\n}\n\n/**\n * devm_mdiobus_alloc_size - Resource-managed mdiobus_alloc_size()\n * @dev:\t\tDevice to allocate mii_bus for\n * @sizeof_priv:\tSpace to allocate for private structure.\n *\n * Managed mdiobus_alloc_size. mii_bus allocated with this function is\n * automatically freed on driver detach.\n *\n * If an mii_bus allocated with this function needs to be freed separately,\n * devm_mdiobus_free() must be used.\n *\n * RETURNS:\n * Pointer to allocated mii_bus on success, NULL on failure.\n */\nstruct mii_bus *devm_mdiobus_alloc_size(struct device *dev, int sizeof_priv)\n{\n\tstruct mii_bus **ptr, *bus;\n\n\tptr = devres_alloc(_devm_mdiobus_free, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn NULL;\n\n\t/* use raw alloc_dr for kmalloc caller tracing */\n\tbus = mdiobus_alloc_size(sizeof_priv);\n\tif (bus) {\n\t\t*ptr = bus;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn bus;\n}\nEXPORT_SYMBOL_GPL(devm_mdiobus_alloc_size);\n\n/**\n * devm_mdiobus_free - Resource-managed mdiobus_free()\n * @dev:\t\tDevice this mii_bus belongs to\n * @bus:\t\tthe mii_bus associated with the device\n *\n * Free mii_bus allocated with devm_mdiobus_alloc_size().\n */\nvoid devm_mdiobus_free(struct device *dev, struct mii_bus *bus)\n{\n\tint rc;\n\n\trc = devres_release(dev, _devm_mdiobus_free,\n\t\t\t    devm_mdiobus_match, bus);\n\tWARN_ON(rc);\n}\nEXPORT_SYMBOL_GPL(devm_mdiobus_free);\n\n/**\n * mdiobus_release - mii_bus device release callback\n * @d: the target struct device that contains the mii_bus\n *\n * Description: called when the last reference to an mii_bus is\n * dropped, to free the underlying memory.\n */\nstatic void mdiobus_release(struct device *d)\n{\n\tstruct mii_bus *bus = to_mii_bus(d);\n\tBUG_ON(bus->state != MDIOBUS_RELEASED &&\n\t       /* for compatibility with error handling in drivers */\n\t       bus->state != MDIOBUS_ALLOCATED);\n\tkfree(bus);\n}\n\nstatic struct class mdio_bus_class = {\n\t.name\t\t= \"mdio_bus\",\n\t.dev_release\t= mdiobus_release,\n};\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\n/* Helper function for of_mdio_find_bus */\nstatic int of_mdio_bus_match(struct device *dev, const void *mdio_bus_np)\n{\n\treturn dev->of_node == mdio_bus_np;\n}\n/**\n * of_mdio_find_bus - Given an mii_bus node, find the mii_bus.\n * @mdio_bus_np: Pointer to the mii_bus.\n *\n * Returns a reference to the mii_bus, or NULL if none found.  The\n * embedded struct device will have its reference count incremented,\n * and this must be put once the bus is finished with.\n *\n * Because the association of a device_node and mii_bus is made via\n * of_mdiobus_register(), the mii_bus cannot be found before it is\n * registered with of_mdiobus_register().\n *\n */\nstruct mii_bus *of_mdio_find_bus(struct device_node *mdio_bus_np)\n{\n\tstruct device *d;\n\n\tif (!mdio_bus_np)\n\t\treturn NULL;\n\n\td = class_find_device(&mdio_bus_class, NULL,  mdio_bus_np,\n\t\t\t      of_mdio_bus_match);\n\n\treturn d ? to_mii_bus(d) : NULL;\n}\nEXPORT_SYMBOL(of_mdio_find_bus);\n\n/* Walk the list of subnodes of a mdio bus and look for a node that\n * matches the mdio device's address with its 'reg' property. If\n * found, set the of_node pointer for the mdio device. This allows\n * auto-probed phy devices to be supplied with information passed in\n * via DT.\n */\nstatic void of_mdiobus_link_mdiodev(struct mii_bus *bus,\n\t\t\t\t    struct mdio_device *mdiodev)\n{\n\tstruct device *dev = &mdiodev->dev;\n\tstruct device_node *child;\n\n\tif (dev->of_node || !bus->dev.of_node)\n\t\treturn;\n\n\tfor_each_available_child_of_node(bus->dev.of_node, child) {\n\t\tint addr;\n\n\t\taddr = of_mdio_parse_addr(dev, child);\n\t\tif (addr < 0)\n\t\t\tcontinue;\n\n\t\tif (addr == mdiodev->addr) {\n\t\t\tdev->of_node = child;\n\t\t\tdev->fwnode = of_fwnode_handle(child);\n\t\t\treturn;\n\t\t}\n\t}\n}\n#else /* !IS_ENABLED(CONFIG_OF_MDIO) */\nstatic inline void of_mdiobus_link_mdiodev(struct mii_bus *mdio,\n\t\t\t\t\t   struct mdio_device *mdiodev)\n{\n}\n#endif\n\n/**\n * mdiobus_create_device_from_board_info - create a full MDIO device given\n * a mdio_board_info structure\n * @bus: MDIO bus to create the devices on\n * @bi: mdio_board_info structure describing the devices\n *\n * Returns 0 on success or < 0 on error.\n */\nstatic int mdiobus_create_device(struct mii_bus *bus,\n\t\t\t\t struct mdio_board_info *bi)\n{\n\tstruct mdio_device *mdiodev;\n\tint ret = 0;\n\n\tmdiodev = mdio_device_create(bus, bi->mdio_addr);\n\tif (IS_ERR(mdiodev))\n\t\treturn -ENODEV;\n\n\tstrncpy(mdiodev->modalias, bi->modalias,\n\t\tsizeof(mdiodev->modalias));\n\tmdiodev->bus_match = mdio_device_bus_match;\n\tmdiodev->dev.platform_data = (void *)bi->platform_data;\n\n\tret = mdio_device_register(mdiodev);\n\tif (ret)\n\t\tmdio_device_free(mdiodev);\n\n\treturn ret;\n}\n\n/**\n * __mdiobus_register - bring up all the PHYs on a given bus and attach them to bus\n * @bus: target mii_bus\n * @owner: module containing bus accessor functions\n *\n * Description: Called by a bus driver to bring up all the PHYs\n *   on a given bus, and attach them to the bus. Drivers should use\n *   mdiobus_register() rather than __mdiobus_register() unless they\n *   need to pass a specific owner module. MDIO devices which are not\n *   PHYs will not be brought up by this function. They are expected to\n *   to be explicitly listed in DT and instantiated by of_mdiobus_register().\n *\n * Returns 0 on success or < 0 on error.\n */\nint __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n\terr = device_register(&bus->dev);\n\tif (err) {\n\t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}\nEXPORT_SYMBOL(__mdiobus_register);\n\nvoid mdiobus_unregister(struct mii_bus *bus)\n{\n\tstruct mdio_device *mdiodev;\n\tint i;\n\n\tBUG_ON(bus->state != MDIOBUS_REGISTERED);\n\tbus->state = MDIOBUS_UNREGISTERED;\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tif (mdiodev->reset)\n\t\t\tgpiod_put(mdiodev->reset);\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n}\nEXPORT_SYMBOL(mdiobus_unregister);\n\n/**\n * mdiobus_free - free a struct mii_bus\n * @bus: mii_bus to free\n *\n * This function releases the reference to the underlying device\n * object in the mii_bus.  If this is the last reference, the mii_bus\n * will be freed.\n */\nvoid mdiobus_free(struct mii_bus *bus)\n{\n\t/* For compatibility with error handling in drivers. */\n\tif (bus->state == MDIOBUS_ALLOCATED) {\n\t\tkfree(bus);\n\t\treturn;\n\t}\n\n\tBUG_ON(bus->state != MDIOBUS_UNREGISTERED);\n\tbus->state = MDIOBUS_RELEASED;\n\n\tput_device(&bus->dev);\n}\nEXPORT_SYMBOL(mdiobus_free);\n\n/**\n * mdiobus_scan - scan a bus for MDIO devices.\n * @bus: mii_bus to scan\n * @addr: address on bus to scan\n *\n * This function scans the MDIO bus, looking for devices which can be\n * identified using a vendor/product ID in registers 2 and 3. Not all\n * MDIO devices have such registers, but PHY devices typically\n * do. Hence this function assumes anything found is a PHY, or can be\n * treated as a PHY. Other MDIO devices, such as switches, will\n * probably not be found during the scan.\n */\nstruct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)\n{\n\tstruct phy_device *phydev;\n\tint err;\n\n\tphydev = get_phy_device(bus, addr, false);\n\tif (IS_ERR(phydev))\n\t\treturn phydev;\n\n\t/*\n\t * For DT, see if the auto-probed phy has a correspoding child\n\t * in the bus node, and set the of_node pointer in this case.\n\t */\n\tof_mdiobus_link_mdiodev(bus, &phydev->mdio);\n\n\terr = phy_device_register(phydev);\n\tif (err) {\n\t\tphy_device_free(phydev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn phydev;\n}\nEXPORT_SYMBOL(mdiobus_scan);\n\n/**\n * __mdiobus_read - Unlocked version of the mdiobus_read function\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to read\n *\n * Read a MDIO bus register. Caller must hold the mdio bus lock.\n *\n * NOTE: MUST NOT be called from interrupt context.\n */\nint __mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&bus->mdio_lock));\n\n\tretval = bus->read(bus, addr, regnum);\n\n\ttrace_mdio_access(bus, 1, addr, regnum, retval, retval);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(__mdiobus_read);\n\n/**\n * __mdiobus_write - Unlocked version of the mdiobus_write function\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to write\n * @val: value to write to @regnum\n *\n * Write a MDIO bus register. Caller must hold the mdio bus lock.\n *\n * NOTE: MUST NOT be called from interrupt context.\n */\nint __mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val)\n{\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&bus->mdio_lock));\n\n\terr = bus->write(bus, addr, regnum, val);\n\n\ttrace_mdio_access(bus, 0, addr, regnum, val, err);\n\n\treturn err;\n}\nEXPORT_SYMBOL(__mdiobus_write);\n\n/**\n * mdiobus_read_nested - Nested version of the mdiobus_read function\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to read\n *\n * In case of nested MDIO bus access avoid lockdep false positives by\n * using mutex_lock_nested().\n *\n * NOTE: MUST NOT be called from interrupt context,\n * because the bus read/write functions may wait for an interrupt\n * to conclude the operation.\n */\nint mdiobus_read_nested(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\tretval = __mdiobus_read(bus, addr, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(mdiobus_read_nested);\n\n/**\n * mdiobus_read - Convenience function for reading a given MII mgmt register\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to read\n *\n * NOTE: MUST NOT be called from interrupt context,\n * because the bus read/write functions may wait for an interrupt\n * to conclude the operation.\n */\nint mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock(&bus->mdio_lock);\n\tretval = __mdiobus_read(bus, addr, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(mdiobus_read);\n\n/**\n * mdiobus_write_nested - Nested version of the mdiobus_write function\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to write\n * @val: value to write to @regnum\n *\n * In case of nested MDIO bus access avoid lockdep false positives by\n * using mutex_lock_nested().\n *\n * NOTE: MUST NOT be called from interrupt context,\n * because the bus read/write functions may wait for an interrupt\n * to conclude the operation.\n */\nint mdiobus_write_nested(struct mii_bus *bus, int addr, u32 regnum, u16 val)\n{\n\tint err;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\terr = __mdiobus_write(bus, addr, regnum, val);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mdiobus_write_nested);\n\n/**\n * mdiobus_write - Convenience function for writing a given MII mgmt register\n * @bus: the mii_bus struct\n * @addr: the phy address\n * @regnum: register number to write\n * @val: value to write to @regnum\n *\n * NOTE: MUST NOT be called from interrupt context,\n * because the bus read/write functions may wait for an interrupt\n * to conclude the operation.\n */\nint mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val)\n{\n\tint err;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock(&bus->mdio_lock);\n\terr = __mdiobus_write(bus, addr, regnum, val);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mdiobus_write);\n\n/**\n * mdio_bus_match - determine if given MDIO driver supports the given\n *\t\t    MDIO device\n * @dev: target MDIO device\n * @drv: given MDIO driver\n *\n * Description: Given a MDIO device, and a MDIO driver, return 1 if\n *   the driver supports the device.  Otherwise, return 0. This may\n *   require calling the devices own match function, since different classes\n *   of MDIO devices have different match criteria.\n */\nstatic int mdio_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct mdio_device *mdio = to_mdio_device(dev);\n\n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\tif (mdio->bus_match)\n\t\treturn mdio->bus_match(dev, drv);\n\n\treturn 0;\n}\n\nstatic int mdio_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tint rc;\n\n\t/* Some devices have extra OF data and an OF-style MODALIAS */\n\trc = of_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstruct bus_type mdio_bus_type = {\n\t.name\t\t= \"mdio_bus\",\n\t.match\t\t= mdio_bus_match,\n\t.uevent\t\t= mdio_uevent,\n};\nEXPORT_SYMBOL(mdio_bus_type);\n\nint __init mdio_bus_init(void)\n{\n\tint ret;\n\n\tret = class_register(&mdio_bus_class);\n\tif (!ret) {\n\t\tret = bus_register(&mdio_bus_type);\n\t\tif (ret)\n\t\t\tclass_unregister(&mdio_bus_class);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mdio_bus_init);\n\n#if IS_ENABLED(CONFIG_PHYLIB)\nvoid mdio_bus_exit(void)\n{\n\tclass_unregister(&mdio_bus_class);\n\tbus_unregister(&mdio_bus_type);\n}\nEXPORT_SYMBOL_GPL(mdio_bus_exit);\n#else\nmodule_init(mdio_bus_init);\n/* no module_exit, intentional */\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MDIO bus/device layer\");\n#endif\n"], "filenames": ["drivers/net/phy/mdio_bus.c"], "buggy_code_start_loc": [382], "buggy_code_end_loc": [383], "fixing_code_start_loc": [381], "fixing_code_end_loc": [381], "type": "CWE-416", "message": "An issue was discovered in the Linux kernel before 5.0. The function __mdiobus_register() in drivers/net/phy/mdio_bus.c calls put_device(), which will trigger a fixed_mdio_bus_init use-after-free. This will cause a denial of service.", "other": {"cve": {"id": "CVE-2019-12819", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-14T02:29:00.330", "lastModified": "2019-06-18T15:15:12.517", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.0. The function __mdiobus_register() in drivers/net/phy/mdio_bus.c calls put_device(), which will trigger a fixed_mdio_bus_init use-after-free. This will cause a denial of service."}, {"lang": "es", "value": "Fue encontrado un problema en el kernel de Linux anterior a versi\u00f3n 5.0. La funci\u00f3n __mdiobus_register() en el archivo drivers/net/phy/mdio_bus.c llama a put_device(), que desencadenar\u00e1 un uso despu\u00e9s de liberar de fix_mdio_bus_init . Esto causar\u00e1 una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0", "matchCriteriaId": "D1C581ED-7982-4D97-89D0-9DD8E7B66D0D"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00039.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00040.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00048.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/154245/Kernel-Live-Patch-Security-Notice-LSN-0054-1.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/108768", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6ff7b060535e87c2ae14dd8548512abfdda528fb", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190710-0002/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4094-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4118-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb"}}