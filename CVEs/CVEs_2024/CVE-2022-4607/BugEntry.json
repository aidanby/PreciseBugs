{"buggy_code": ["Change Log\n==========\n\n### 5.2.0 - 2022-05-23\n\nThis release is based on the Importer/Exporter version 5.2.0 libraries, and thus incorporates all bug fixes and updates\nintroduced in that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v5.2.0)).\n\n##### Additions\n* Added support for 3DCityDB v4.3\n* Added `replaceResourceIds` configuration option to replace all identifiers of features and geometries with UUIDs.\n\n##### Fixes\n* The database port was not correctly set when using the `CITYDB_PORT` environment variable.\n\n##### Miscellaneous\n* Updated PostgreSQL driver to 42.3.4\n* Updated Oracle driver to 21.3.0.0\n* Updated GeoTools to 26.4.\n\n### 5.1.0 - 2022-04-12\n\nThis release is based on the Importer/Exporter version 5.1.1 libraries, and thus incorporates all bug fixes and updates\nintroduced in that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v5.1.1)).\n\n##### Changes\n* Changed the handling of date-time values and timezones. Before this change, `xsd:date` values in exports could be\n  different from the values stored in the database in case different timezone settings were used for the database\n  server and the import and export operations.\n* Simplified database queries used by the `GetFeature` and `GetPropertyValue` operations for top-level features\n  involving many nested features/tables to avoid extremely large result sets causing performance issues.\n\n##### Fixes\n* Fixed bug in parsing of XPath expressions of XML queries that caused a slash `/` being part of a literal value to\n  be interpreted as step operator.\n* Empty strings for gml:id attributes are no longer imported but the `GMLID` column is set to `NULL` instead.\n\n##### Miscellaneous\n* Updated H2 database used for local caching to 2.1.210.\n* Updated PostgreSQL driver to 42.3.1 and PostGIS driver to 2021.1.0.\n* Updated citygml4j to 2.12.0.\n\n### 5.0.0 - 2021-10-08\n\n##### Changes\n* Added Docker files to build your own images for the WFS service. Pre-built Docker images\n  are available from Docker Hub at https://hub.docker.com/r/3dcitydb/wfs. [#9](https://github.com/3dcitydb/web-feature-service/pull/9)\n* Support for the WFS 2.0 operations `GetFeature`, `GetPropertyValue`. `CreateStoredQuery`, `DropStoredQuery`\n  with both XML and KVP encodings.\n* Support for ad-hoc queries and stored queries.\n* New filter capabilities including spatial, thematic and logical filters based on OGC Filter Encoding.\n* Support for XPath expressions in filter expressions to allow queries on complex attributes and nested features.\n* Support for exporting local and global appearances of the requested city objects. Texture images are provided\n  through a separate RESTful service that is included in the WFS package and automatically started with the WFS\n  service.\n* Support for response paging allowing a client to scroll through large sets of features or property values\n  based on the `count` and `startIndex` parameters.\n* The city objects and property values in a response document can now be sorted by thematic attributes.\n* Address attributes and 3DCityDB metadata can be used in query expressions based on corresponding CityGML ADEs\n  like with the Importer/Exporter.\n* Management of stored queries is now possible.\n* Individual WFS operations can now be secured using IP- and token-based access control rules.\n* Support for setting the time zone to be used for queries involving date and time attributes.\n* JDBC drivers are now kept in `WEB-INF/lib` to better support running the WFS in a Docker environment. So, there\n  is no need to copy JDBC drivers to a global or shared lib folder anymore.\n* This release is based on the Importer/Exporter version 5.0.0, and thus incorporates all bug fixes and updates\n  introduced in that version.\n* Added support for providing database connection details via environment variables.\n* CityJSON output now uses the latest CityJSON version 1.0.3.\n* Many bugfixes and improvements.\n\n##### Miscellaneous\n* Updated citygml4j to 2.11.4.\n* Updated PostgreSQL driver to 42.2.23 and Oracle driver to 21.1.0.\n\n\n### 4.3.0 - 2021-04-28\n\n##### Changes\n* Improved export performance (up to 10-15 times faster in case the WFS is not running on the same machine or\n  in the same local network as the database server).\n* The default `config.xml` file and ADE extensions folder can now be changed using the environment variables\n  `VC_WFS_CONFIG_FILE` and `VC_WFS_ADE_EXTENSIONS_PATH`.\n* Enhanced LoD filter constraint with the option to only export the minimum or maximum LoD from the list of\n  selected LoDs.\n* Updated WFS web client UI and added support for XML highlighting to the input and output fields.\n* Added `countDefault` constraint to limit the maximum number of returned features.\n* Added CityJSON output format option `removeDuplicateChildGeometries` to avoid exporting duplicate geometries\n  for nested child objects.\n* This release is based on the Importer/Exporter version 4.3.0, and thus incorporates all bug fixes and updates\n  introduced in that version.\n\n##### Fixes\n* Fixed error when exporting to CityJSON and no top-level feature is returned.\n\n##### Miscellaneous\n* Updated citygml4j to 2.11.3.\n* Upgrade PostgreSQL driver to 42.2.14 and PostGIS to 2.5.0.\n\n### 4.2.3 - 2020-07-16\n\n##### Changes\n* CityJSON output now uses the latest CityJSON version 1.0.1.\n* This release is based on the Importer/Exporter version 4.2.3, and thus incorporates all bug fixes and updates introduced\nin that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v4.2.3)).\n\n##### Miscellaneous\n* Updated citygml4j to 2.10.5.\n* Upgrade to latest PostgreSQL driver 42.2.10\n* Upgrade Oracle driver to 19.3.\n\n### 4.2 - 2019-02-13\n\n##### Changes\n* CityJSON output now uses the latest CityJSON version 0.9.\n\n##### Fixes\n* Using UTF-8 encoding for CityJSON output per default.\n* This release is based on the Importer/Exporter version 4.2.0, and thus incorporates all bug fixes and updates introduced \nin that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v4.2.0)). \n\n##### Miscellaneous \n* Updated citygml4j to 2.9.1.\n\n### 4.1 - 2019-01-09\n\n##### Changes\n* renamed the parameter `<useCityDBADE>` to `<exportCityDBMetadata>` in the `config.xml` file. This parameter controls\nwhether metadata such as the `LINEAGE` attribute of the `CITYOBJECT` table should be written to the response document.\nIf set to `true`, the 3DCityDB ADE will be used for storing the information with the city objects.\n\n##### Fixes\n* This release is based on the Importer/Exporter version 4.1.0, and thus incorporates all bug fixes and updates\nintroduced in that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v4.1.0)).\n\n##### Miscellaneous \n* Upgrade to latest PostgreSQL driver v42.2.5 and PostGIS driver v2.3.0.\n* Upgrade to latest Oracle driver 18.3.\n\n### 4.0 - 2018-09-18\n\n##### Additions\n* Added support for CityGML ADEs through ADE extensions.\n* Added KVP over HTTP GET as additional service binding to simplify the integration with GIS and ETL software such as FME.\n* Added [CityJSON](http://www.cityjson.org/) as additional output format besides CityGML.\n* New LoD filter for WFS responses.\n* Added support for CORS.\n* Database connections are not established at service startup but lazily when required.\n* Major update to Importer/Exporter library 4.0.\n* Switched from Ant to Gradle as build system.\n\n##### Miscellaneous \n* [3DCityDB Docker images](https://github.com/tum-gis/3dcitydb-docker-postgis) are now available for a range of 3DCityDB\nand WFS versions to support continuous integration workflows.\n", "import org.apache.tools.ant.filters.ReplaceTokens\n\nplugins {\n    id 'java'\n    id 'war'\n    id 'distribution'\n}\n\ngroup 'org.citydb.wfs'\nversion '5.2.0'\n\napply from: 'properties.gradle'\n\next {\n    genSrcDir = 'src-gen/main/java'\n}\n\njava {\n    toolchain {\n        languageVersion = JavaLanguageVersion.of(11)\n    }\n    compileJava {\n        options.release = 8\n    }\n    sourceSets {\n        main.java.srcDir genSrcDir\n    }\n}\n\nconfigurations {\n    jdbc\n    jaxb\n}\n\nrepositories {\n    maven {\n        url 'https://repo.osgeo.org/repository/release'\n    }\n    maven {\n        url 'https://citydb.jfrog.io/artifactory/maven'\n    }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.citydb:impexp-core:5.2.0'\n    implementation 'com.github.seancfoley:ipaddress:5.3.4'\n    implementation 'org.glassfish.jersey.containers:jersey-container-servlet:2.35'\n    implementation 'org.glassfish.jersey.inject:jersey-hk2:2.35'\n\n    providedCompile 'javax.servlet:javax.servlet-api:3.1.0'\n\n    jaxb 'org.glassfish.jaxb:jaxb-xjc:2.3.2'\n    jaxb 'org.jvnet.jaxb2_commons:jaxb2-basics:0.12.0'\n    jaxb 'org.jvnet.jaxb2_commons:jaxb2-namespace-prefix:1.3'\n    jaxb 'org.jvnet.jaxb2_commons:jaxb2-basics-annotate:1.1.0'\n    jaxb 'org.slf4j:slf4j-simple:1.7.25'\n}\n\ntask processLicense(type: Copy) {\n    from(\"resources/license/LICENSE.txt\") {\n        filteringCharset = 'UTF-8'\n        filter(ReplaceTokens, tokens: [\n                name: project.citydbWfsName,\n                vendorName: project.vendorName,\n                vendorStreet: project.vendorStreet,\n                vendorTown: project.vendorTown,\n                vendorCountry: project.vendorCountry,\n                vendorCopyright: project.vendorCopyright,\n                vendorWebsiteUrl: project.vendorWebsiteUrl\n        ])\n    }\n    into \"$buildDir/tmp/license\"\n}\n\nprocessResources {\n    filteringCharset = 'ISO-8859-1'\n    filesMatching('**/application.properties') {\n        filter(ReplaceTokens, tokens: [\n                name: project.citydbWfsName,\n                version: project.version,\n                vendorName: project.vendorName,\n                vendorStreet: project.vendorStreet,\n                vendorTown: project.vendorTown,\n                vendorCountry: project.vendorCountry,\n                vendorCopyright: project.vendorCopyright,\n                vendorWebsiteUrl: project.vendorWebsiteUrl\n        ])\n    }\n}\n\ntask generateJaxb(group: 'jaxb') {\n    outputs.dir genSrcDir\n\n    doLast {\n        mkdir genSrcDir\n\n        System.setProperty('javax.xml.accessExternalSchema', 'file')\n        ant.taskdef(name: 'xjc', classname: 'com.sun.tools.xjc.XJC2Task', classpath: configurations.jaxb.asPath)\n        ant.xjc(destdir: genSrcDir,\n                schema: 'resources/jaxb/wfs-jaxb.xsd',\n                binding: 'resources/jaxb/binding.xjb',\n                extension: 'true',\n                encoding: 'UTF-8') {\n            produces(dir: genSrcDir, includes: '**/*.java')\n            arg(line: '-Xnamespace-prefix -Xsetters -Xsetters-mode=direct -Xinheritance -Xannotate -XremoveAnnotation')\n        }\n\n        delete \"$genSrcDir/net/opengis/citygml\"\n        delete \"$genSrcDir/net/opengis/gml\"\n        delete \"$genSrcDir/org\"\n        delete \"$genSrcDir/oasis\"\n    }\n}\n\ntask cleanJaxb(type: Delete, group: 'jaxb') {\n    delete 'src-gen'\n}\n\ndistributions.main {\n    distributionBaseName = project.appName\n    contents {\n        from war\n        from 'CHANGES.md'\n        from 'README.md'\n        into('license') {\n            from \"$rootDir/resources/license/APACHE-2.0.txt\"\n            from processLicense\n        }\n    }\n}\n\nwar {\n    archiveFileName = project.name + '.war'\n    manifest {\n        attributes('Implementation-Title': project.appName,\n                'Implementation-Version': project.version,\n                'Implementation-Vendor': project.vendorName + ', ' + project.vendorWebsiteUrl\n        )\n    }\n    into('META-INF') {\n        from processLicense\n    }\n}", "package vcs.citydb.wfs;\n\nimport net.opengis.wfs._2.*;\nimport org.citydb.config.Config;\nimport org.citydb.core.database.connection.DatabaseConnectionPool;\nimport org.citydb.core.registry.ObjectRegistry;\nimport org.citydb.core.util.Util;\nimport org.citydb.util.concurrent.SingleWorkerPool;\nimport org.citydb.util.log.Logger;\nimport org.citygml4j.builder.jaxb.CityGMLBuilder;\nimport org.citygml4j.xml.schema.SchemaHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.config.operation.EncodingMethod;\nimport vcs.citydb.wfs.exception.AccessControlException;\nimport vcs.citydb.wfs.exception.WFSException;\nimport vcs.citydb.wfs.exception.WFSExceptionCode;\nimport vcs.citydb.wfs.exception.WFSExceptionReportHandler;\nimport vcs.citydb.wfs.kvp.*;\nimport vcs.citydb.wfs.operation.describefeaturetype.DescribeFeatureTypeHandler;\nimport vcs.citydb.wfs.operation.getcapabilities.GetCapabilitiesHandler;\nimport vcs.citydb.wfs.operation.getfeature.GetFeatureHandler;\nimport vcs.citydb.wfs.operation.getpropertyvalue.GetPropertyValueHandler;\nimport vcs.citydb.wfs.operation.storedquery.*;\nimport vcs.citydb.wfs.paging.PageRequest;\nimport vcs.citydb.wfs.paging.PagingCacheManager;\nimport vcs.citydb.wfs.paging.PagingHandler;\nimport vcs.citydb.wfs.security.AccessController;\nimport vcs.citydb.wfs.util.*;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\nimport vcs.citydb.wfs.util.xml.ValidationEventHandlerImpl;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.JAXBElement;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Unmarshaller;\nimport javax.xml.bind.UnmarshallerHandler;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n@WebServlet(Constants.WFS_SERVICE_PATH)\npublic class WFSService extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate final Logger log = Logger.getInstance();\n\tprivate final DatabaseConnectionPool connectionPool = DatabaseConnectionPool.getInstance();\n\n\tprivate CityGMLBuilder cityGMLBuilder;\n\tprivate RequestLimiter limiter;\n\tprivate AccessController accessController;\n\tprivate WFSConfig wfsConfig;\n\tprivate Config config;\n\n\tprivate SAXParserFactory saxParserFactory;\n\tprivate Schema wfsSchema;\n\tprivate SingleWorkerPool<CacheCleanerWork> cacheCleanerPool;\n\tprivate WFSExceptionReportHandler exceptionReportHandler;\n\n\t@Override\n\tpublic void init() throws ServletException {\n\t\t// check whether servlet initialization threw an error\n\t\tObject error = getServletContext().getAttribute(Constants.INIT_ERROR_ATTRNAME);\n\t\tif (error instanceof ServletException)\n\t\t\tthrow (ServletException) error;\n\n\t\tlog.info(\"WFS service is loaded by the servlet container.\");\n\n\t\t// service specific initialization\n\t\tObjectRegistry registry = ObjectRegistry.getInstance();\n\t\tconfig = registry.getConfig();\n\t\tcityGMLBuilder = registry.getCityGMLBuilder();\n\t\tlimiter = registry.lookup(RequestLimiter.class);\n\t\taccessController = registry.lookup(AccessController.class);\n\t\twfsConfig = registry.lookup(WFSConfig.class);\n\n\t\texceptionReportHandler = new WFSExceptionReportHandler(cityGMLBuilder);\n\t\tsaxParserFactory = SAXParserFactory.newInstance();\n\t\tsaxParserFactory.setNamespaceAware(true);\n\n\t\ttry {\n\t\t\tStoredQueryManager storedQueryManager = new StoredQueryManager(cityGMLBuilder, saxParserFactory, getServletContext().getRealPath(Constants.STORED_QUERIES_PATH), wfsConfig);\n\t\t\tregistry.register(storedQueryManager);\n\t\t} catch (Throwable e) {\n\t\t\tString message = \"Failed to initialize stored query manager.\";\n\t\t\tlog.error(message);\n\t\t\tlog.error(e.getMessage());\n\t\t\tthrow new ServletException(message, e);\n\t\t}\n\n\t\t// read WFS 2.0 schema to validate requests\n\t\tif (wfsConfig.getOperations().getRequestEncoding().isUseXMLValidation()) {\n\t\t\ttry {\n\t\t\t\tSchemaHandler schemaHandler = registry.lookup(SchemaHandler.class);\n\t\t\t\tschemaHandler.parseSchema(new File(getServletContext().getRealPath(Constants.SCHEMAS_PATH + \"/ogc/wfs/2.0.2/wfs.xsd\")));\n\t\t\t\tschemaHandler.parseSchema(new File(getServletContext().getRealPath(Constants.SCHEMAS_PATH + \"/ogc/wfs/extensions/wfs-vcs.xsd\")));\n\t\t\t\tSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n\t\t\t\twfsSchema = schemaFactory.newSchema(schemaHandler.getSchemaSources());\n\t\t\t} catch (SAXException e) {\n\t\t\t\tString message = \"Failed to read WFS XML Schema from \" + Constants.SCHEMAS_PATH + \"/ogc/wfs.\";\n\t\t\t\tlog.error(message);\n\t\t\t\tlog.error(e.getMessage());\n\t\t\t\tthrow new ServletException(message, e);\n\t\t\t}\n\t\t}\n\n\t\t// register cache cleaner pool\n\t\tcacheCleanerPool = new SingleWorkerPool<>(\n\t\t\t\t\"cache_cleaner\",\n\t\t\t\tCacheCleanerWorker::new,\n\t\t\t\twfsConfig.getServer().getMaxParallelRequests());\n\n\t\tcacheCleanerPool.prestartCoreWorker();\n\t\tregistry.register(CacheCleanerWorker.class.getName(), cacheCleanerPool);\n\n\t\t// register paging cache manager\n\t\tif (wfsConfig.getConstraints().isUseResultPaging()) {\n\t\t\tPagingCacheManager pagingCacheManager = new PagingCacheManager(cacheCleanerPool, wfsConfig);\n\t\t\tregistry.register(pagingCacheManager);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\tlog.info(\"WFS service is destroyed by the servlet container.\");\n\n\t\t// destroy resources which may otherwise cause memory leaks\n\t\ttry {\n\t\t\tcacheCleanerPool.shutdownAndWait();\n\t\t} catch (InterruptedException e) {\n\t\t\tString message = \"Failed to shutdown cache cleaner pool.\";\n\t\t\tlog.error(message);\n\t\t\tlog.error(e.getMessage());\n\t\t}\n\t}\n\n\t@Override\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t// set CORS http headers\n\t\tif (wfsConfig.getServer().isEnableCORS())\n\t\t\taddCORSHeaders(request, response, false);\n\n\t\tKVPRequestReader reader = null;\n\t\tboolean isPagingRequest = ServerUtil.containsParameter(request, KVPConstants.PAGE_ID);\n\n\t\ttry {\n\t\t\tif (wfsConfig.getOperations().getRequestEncoding().getMethod() == EncodingMethod.XML && !isPagingRequest)\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"KVP encoding of requests is not advertised.\");\n\n\t\t\tif (isPagingRequest && !wfsConfig.getConstraints().isUseResultPaging())\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"Result paging is not advertised.\");\n\n\t\t\t// parse parameters\n\t\t\tMap<String, String> parameters = new HashMap<>();\n\t\t\tfor (Entry<String, String[]> entry : request.getParameterMap().entrySet()) {\n\t\t\t\tString name = entry.getKey().toUpperCase();\n\t\t\t\tString value = entry.getValue()[0];\n\n\t\t\t\tfor (int i = 1; i < entry.getValue().length; i++) {\n\t\t\t\t\tif (!value.equals(entry.getValue()[i]))\n\t\t\t\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"Found inconsistent values for parameter \" + name + \": \" + Util.collection2string(Arrays.asList(entry.getValue()), \", \"), name);\n\t\t\t\t}\n\n\t\t\t\tString previous = parameters.get(name);\n\t\t\t\tif (previous != null && !value.equals(parameters.get(previous)))\n\t\t\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"Found inconsistent values for parameter \" + name + \": \" + value + \", \" + parameters.get(name), name);\n\n\t\t\t\tif (!value.isEmpty())\n\t\t\t\t\tparameters.put(name, value);\n\t\t\t}\n\n\t\t\tString operationName = parameters.get(KVPConstants.REQUEST);\n\t\t\tif (operationName != null) {\n\t\t\t\tswitch (operationName) {\n\t\t\t\t\tcase KVPConstants.GET_CAPABILITIES:\n\t\t\t\t\t\treader = new GetCapabilitiesReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.DESCRIBE_FEATURE_TYPE:\n\t\t\t\t\t\treader = new DescribeFeatureTypeReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.GET_PROPERTY_VALUE:\n\t\t\t\t\t\treader = new GetPropertyValueReader(parameters, wfsSchema, cityGMLBuilder, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.GET_FEATURE:\n\t\t\t\t\t\treader = new GetFeatureReader(parameters, wfsSchema, cityGMLBuilder, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.LIST_STORED_QUERIES:\n\t\t\t\t\t\treader = new ListStoredQueriesReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.DESCRIBE_STORED_QUERIES:\n\t\t\t\t\t\treader = new DescribeStoredQueriesReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.DROP_STORED_QUERY:\n\t\t\t\t\t\treader = new DropStoredQueryReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.CREATE_STORED_QUERY:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"The operation \" + operationName + \" is not supported by this WFS implementation.\", KVPConstants.REQUEST);\n\t\t\t\t}\n\t\t\t} else if (isPagingRequest) {\n\t\t\t\treader = new PagingReader(parameters, wfsConfig);\n\t\t\t} else\n\t\t\t\tthrow new WFSException(WFSExceptionCode.MISSING_PARAMETER_VALUE, \"The request lacks the mandatory \" + KVPConstants.REQUEST + \" parameter.\", KVPConstants.REQUEST);\n\n\t\t\t// parse and process request\n\t\t\tObject wfsRequest = reader.readRequest();\n\t\t\thandleRequest(wfsRequest, reader.getOperationName(), reader.getNamespaces(), request, response);\n\t\t} catch (WFSException e) {\n\t\t\tString operationName = reader != null ? reader.getOperationName() : null;\n\t\t\texceptionReportHandler.sendErrorResponse(e, operationName, request, response);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t// set CORS http headers\n\t\tif (wfsConfig.getServer().isEnableCORS())\n\t\t\taddCORSHeaders(request, response, false);\n\n\t\tString operationName = null;\n\t\ttry {\n\t\t\tif (wfsConfig.getOperations().getRequestEncoding().getMethod() == EncodingMethod.KVP)\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"XML encoding of requests is not advertised.\");\n\n\t\t\tUnmarshaller unmarshaller = cityGMLBuilder.getJAXBContext().createUnmarshaller();\n\t\t\tValidationEventHandlerImpl validationEventHandler = null;\n\n\t\t\t// support XML validation\n\t\t\tif (wfsConfig.getOperations().getRequestEncoding().isUseXMLValidation()) {\n\t\t\t\tunmarshaller.setSchema(wfsSchema);\n\t\t\t\tvalidationEventHandler = new ValidationEventHandlerImpl();\n\t\t\t\tunmarshaller.setEventHandler(validationEventHandler);\n\t\t\t}\n\n\t\t\tUnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n\n\t\t\t// use SAX parser to keep track of namespace declarations\n\t\t\tSAXParser parser = saxParserFactory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\tNamespaceFilter namespaceFilter = new NamespaceFilter(reader);\n\t\t\tnamespaceFilter.setContentHandler(unmarshallerHandler);\n\n\t\t\ttry {\n\t\t\t\tnamespaceFilter.parse(new InputSource(request.getInputStream()));\n\t\t\t} catch (SAXException e) {\n\t\t\t\tif (validationEventHandler != null && !validationEventHandler.isValid())\n\t\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PARSING_FAILED, validationEventHandler.getCause());\n\t\t\t\telse throw e;\n\t\t\t}\n\n\t\t\t// unmarshal WFS request\n\t\t\tObject object = unmarshallerHandler.getResult();\n\t\t\tif (!(object instanceof JAXBElement<?>))\n\t\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"Failed to parse XML document received through HTTP POST.\", KVPConstants.REQUEST);\n\n\t\t\tJAXBElement<?> element = (JAXBElement<?>) object;\n\t\t\toperationName = element.getName().getLocalPart();\n\n\t\t\t// process request\n\t\t\thandleRequest(element.getValue(), operationName, namespaceFilter, request, response);\n\t\t} catch (JAXBException | SAXException | ParserConfigurationException e) {\n\t\t\texceptionReportHandler.sendErrorResponse(new WFSException(WFSExceptionCode.OPERATION_PARSING_FAILED, \"Failed to parse the XML message.\", e), operationName, request, response);\n\t\t} catch (WFSException e) {\n\t\t\texceptionReportHandler.sendErrorResponse(e, operationName, request, response);\n\t\t}\n\t}\n\n\tprivate void handleRequest(Object wfsRequest, String operationName, NamespaceFilter namespaceFilter, HttpServletRequest request, HttpServletResponse response) throws WFSException {\n\t\t// check access permission\n\t\ttry {\n\t\t\taccessController.requireAccess(operationName, request);\n\t\t} catch (AccessControlException e) {\n\t\t\tlog.error(\"Access denied: \" + e.getMessage());\n\t\t\tif (e.getCause() != null)\n\t\t\t\tlog.logStackTrace(e.getCause());\n\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Access denied for client '\" + request.getRemoteHost() + \"'.\");\n\t\t}\n\n\t\t// check database connection\n\t\tif (!connectionPool.isConnected())\n\t\t\tDatabaseConnector.connect(config);\n\n\t\ttry {\n\t\t\tif (wfsRequest instanceof GetFeatureType) {\n\t\t\t\t// make sure we only serve a maximum number of requests in parallel\n\t\t\t\tlimiter.requireServiceSlot(request, operationName);\n\t\t\t\tGetFeatureHandler getFeatureHandler = new GetFeatureHandler(cityGMLBuilder, wfsConfig, config);\n\t\t\t\tgetFeatureHandler.doOperation((GetFeatureType) wfsRequest, namespaceFilter, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof GetPropertyValueType) {\n\t\t\t\t// make sure we only serve a maximum number of requests in parallel\n\t\t\t\tlimiter.requireServiceSlot(request, operationName);\n\t\t\t\tGetPropertyValueHandler getPropertyValueHandler = new GetPropertyValueHandler(cityGMLBuilder, wfsConfig, config);\n\t\t\t\tgetPropertyValueHandler.doOperation((GetPropertyValueType) wfsRequest, namespaceFilter, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof DescribeFeatureTypeType) {\n\t\t\t\tDescribeFeatureTypeHandler describeFeatureTypeHandler = new DescribeFeatureTypeHandler(wfsConfig);\n\t\t\t\tdescribeFeatureTypeHandler.doOperation((DescribeFeatureTypeType)wfsRequest, getServletContext(), request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof GetCapabilitiesType) {\n\t\t\t\tGetCapabilitiesHandler getCapabilitiesHandler = new GetCapabilitiesHandler(cityGMLBuilder, wfsConfig);\n\t\t\t\tgetCapabilitiesHandler.doOperation((GetCapabilitiesType)wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof ListStoredQueriesType) {\n\t\t\t\tListStoredQueriesHandler listStoredQueriesHandler = new ListStoredQueriesHandler(cityGMLBuilder, wfsConfig);\n\t\t\t\tlistStoredQueriesHandler.doOperation((ListStoredQueriesType)wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof DescribeStoredQueriesType) {\n\t\t\t\tDescribeStoredQueriesHandler describeStoredQueriesHandler = new DescribeStoredQueriesHandler(wfsConfig);\n\t\t\t\tdescribeStoredQueriesHandler.doOperation((DescribeStoredQueriesType)wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof CreateStoredQueryType) {\n\t\t\t\tCreateStoredQueryHandler createStoredQueriesHandler = new CreateStoredQueryHandler(cityGMLBuilder, wfsConfig);\n\t\t\t\tcreateStoredQueriesHandler.doOperation((CreateStoredQueryType)wfsRequest, namespaceFilter, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof DropStoredQueryType) {\n\t\t\t\tDropStoredQueryHandler dropStoredQueriesHandler = new DropStoredQueryHandler(cityGMLBuilder, wfsConfig);\n\t\t\t\tdropStoredQueriesHandler.doOperation((DropStoredQueryType)wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof PageRequest) {\n\t\t\t\t// make sure we only serve a maximum number of requests in parallel\n\t\t\t\tlimiter.requireServiceSlot(request, operationName);\n\t\t\t\tPagingHandler pagingHandler = new PagingHandler(cityGMLBuilder, wfsConfig, config);\n\t\t\t\tpagingHandler.doOperation((PageRequest) wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_NOT_SUPPORTED, \"The operation \" + operationName + \" is not supported by this WFS implementation.\", operationName);\n\n\t\t} catch (JAXBException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"A fatal JAXB error occurred whilst processing the request.\", operationName, e);\n\t\t} finally {\n\t\t\t// release slot from limiter\n\t\t\tlimiter.releaseServiceSlot(request);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void doOptions(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t// support CORS preflight requests\n\t\tif (wfsConfig.getServer().isEnableCORS())\n\t\t\taddCORSHeaders(request, response, true);\n\t}\n\n\tprivate void addCORSHeaders(HttpServletRequest request, HttpServletResponse response, boolean isOptions) {\n\t\t// do nothing if this is not a CORS request\n\t\tif (request.getHeader(\"Origin\") == null)\n\t\t\treturn;\n\n\t\tresponse.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n\n\t\t// add preflight headers\n\t\tif (isOptions && request.getHeader(\"Access-Control-Request-Method\") != null) {\n\t\t\tresponse.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST\");\n\t\t\tresponse.setHeader(\"Access-Control-Max-Age\", \"86400\");\n\n\t\t\tString requestCORSHeaders = request.getHeader(\"Access-Control-Request-Headers\");\n\t\t\tif (requestCORSHeaders != null)\n\t\t\t\tresponse.setHeader(\"Access-Control-Allow-Headers\", requestCORSHeaders);\n\t\t}\n\t}\n}\n", "package vcs.citydb.wfs.config;\n\nimport org.citydb.config.ConfigUtil;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.SchemaOutputResolver;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.stream.StreamResult;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class WFSConfigSchemaWriter {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSystem.out.print(\"Generating XML schema in \" + Constants.CONFIG_SCHEMA_FILE + \"... \");\n\t\t\n\t\tJAXBContext ctx = JAXBContext.newInstance(WFSConfig.class);\n\t\tctx.generateSchema(new SchemaOutputResolver() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Result createOutput(String namespaceUri, String suggestedFileName) throws IOException {\n\t\t\t\tFile file;\n\n\t\t\t\tif (namespaceUri.equals(ConfigUtil.CITYDB_CONFIG_NAMESPACE_URI))\n\t\t\t\t\tfile = new File(Constants.CONFIG_SCHEMA_FILE);\n\t\t\t\telse\n\t\t\t\t\tfile = new File(Constants.CONFIG_SCHEMA_PATH + \"/ows/\" + suggestedFileName);\n\t\t\t\t\n\t\t\t\tfile.getAbsoluteFile().getParentFile().mkdirs();\n\t\t\t\t\n\t\t\t\tStreamResult res = new StreamResult();\n\t\t\t\tres.setSystemId(file.toURI().toString());\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tSystem.out.println(\"finished.\");\n\t}\n\n}\n", "package vcs.citydb.wfs.operation.getfeature.citygml;\n\nimport net.opengis.wfs._2.GetFeatureType;\nimport net.opengis.wfs._2.ResultTypeType;\nimport org.citydb.ade.model.module.CityDBADE100Module;\nimport org.citydb.ade.model.module.CityDBADE200Module;\nimport org.citydb.config.Config;\nimport org.citydb.core.database.schema.mapping.FeatureType;\nimport org.citydb.core.operation.common.cache.IdCacheManager;\nimport org.citydb.core.operation.exporter.util.InternalConfig;\nimport org.citydb.core.operation.exporter.writer.FeatureWriteException;\nimport org.citydb.util.log.Logger;\nimport org.citygml4j.model.module.Module;\nimport org.citygml4j.model.module.ModuleContext;\nimport org.citygml4j.model.module.Modules;\nimport org.citygml4j.model.module.ade.ADEModule;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.citygml4j.util.internal.xml.TransformerChainFactory;\nimport org.citygml4j.util.xml.SAXWriter;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.operation.getfeature.FeatureWriter;\nimport vcs.citydb.wfs.operation.getfeature.GetFeatureResponseBuilder;\nimport vcs.citydb.wfs.operation.getfeature.QueryExpression;\nimport vcs.citydb.wfs.util.GeometryStripper;\n\nimport javax.xml.datatype.DatatypeConfigurationException;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.File;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CityGMLWriterBuilder implements GetFeatureResponseBuilder {\n\tprivate final Logger log = Logger.getInstance();\n\tprivate final String PRETTY_PRINT = \"prettyPrint\";\n\n\tprivate CityGMLVersion version;\n\tprivate GeometryStripper geometryStripper;\n\tprivate IdCacheManager idCacheManager;\n\tprivate InternalConfig internalConfig;\n\tprivate Config config;\n\tprivate Object eventChannel;\n\n\tprivate SAXWriter saxWriter;\n\tprivate TransformerChainFactory transformerChainFactory;\n\n\t@Override\n\tpublic String getMimeType() {\n\t\treturn \"text/xml\";\n\t}\n\n\t@Override\n\tpublic boolean supportsHitsResponse() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void initializeContext(\n\t\t\tGetFeatureType wfsRequest,\n\t\t\tList<QueryExpression> queryExpressions,\n\t\t\tMap<String, String> formatOptions,\n\t\t\tGeometryStripper geometryStripper,\n\t\t\tIdCacheManager idCacheManager,\n\t\t\tObject eventChannel,\n\t\t\tInternalConfig internalConfig,\n\t\t\tWFSConfig wfsConfig,\n\t\t\tConfig config) throws FeatureWriteException {\n\t\tthis.geometryStripper = geometryStripper;\n\t\tthis.idCacheManager = idCacheManager;\n\t\tthis.eventChannel = eventChannel;\n\t\tthis.internalConfig = internalConfig;\n\t\tthis.config = config;\n\n\t\tversion = queryExpressions.get(0).getTargetVersion();\n\n\t\tsaxWriter = new SAXWriter();\n\t\tsaxWriter.setWriteEncoding(true);\n\n\t\tif (\"true\".equals(formatOptions.get(PRETTY_PRINT)))\n\t\t\tsaxWriter.setIndentString(\" \");\n\n\t\t// set WFS prefix and schema location in case we do not have to return the bare feature\n\t\tif (queryExpressions.size() > 1 || !queryExpressions.get(0).isGetFeatureById()) {\n\t\t\tsaxWriter.setPrefix(Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\t\t\tsaxWriter.setSchemaLocation(Constants.WFS_NAMESPACE_URI, Constants.WFS_SCHEMA_LOCATION);\n\t\t}\n\n\t\t// set CityGML prefixes and schema locations if we have to return feature instances\n\t\tif (wfsRequest.getResultType() == ResultTypeType.RESULTS) {\n\t\t\t// add default prefixes and schema locations\n\t\t\tModuleContext moduleContext = new ModuleContext(version);\n\n\t\t\tModule core = moduleContext.getModule(CityGMLModuleType.CORE);\n\t\t\tModule generics = moduleContext.getModule(CityGMLModuleType.GENERICS);\n\t\t\tsaxWriter.setPrefix(core.getNamespacePrefix(), core.getNamespaceURI());\n\t\t\tsaxWriter.setPrefix(generics.getNamespacePrefix(), generics.getNamespaceURI());\n\t\t\tsaxWriter.setSchemaLocation(generics.getNamespaceURI(), generics.getSchemaLocation());\n\t\t\tif (wfsConfig.getConstraints().isExportAppearance()) {\n\t\t\t\tModule appearance = moduleContext.getModule(CityGMLModuleType.APPEARANCE);\n\t\t\t\tsaxWriter.setPrefix(appearance.getNamespacePrefix(), appearance.getNamespaceURI());\n\t\t\t\tsaxWriter.setSchemaLocation(appearance.getNamespaceURI(), appearance.getSchemaLocation());\n\t\t\t}\n\n\t\t\t// add XML prefixes and schema locations for non-CityGML modules\n\t\t\tfor (Module module : moduleContext.getModules()) {\n\t\t\t\tif (!(module instanceof CityGMLModule)) {\n\t\t\t\t\t// skip 3DCityDB ADE prefix and namespace if metadata shall not be exported\n\t\t\t\t\tif ((module == CityDBADE200Module.v3_0 || module == CityDBADE100Module.v3_0)\n\t\t\t\t\t\t\t&& !wfsConfig.getConstraints().isExportCityDBMetadata())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tif (module instanceof ADEModule)\n\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set XML prefixes and schema locations for selected feature types\n\t\t\tfor (QueryExpression queryExpression : queryExpressions) {\n\t\t\t\tfor (FeatureType featureType : queryExpression.getFeatureTypeFilter().getFeatureTypes()) {\n\t\t\t\t\tif (featureType.isAvailableForCityGML(version)) {\n\t\t\t\t\t\tCityGMLModule module = Modules.getCityGMLModule(featureType.getSchema().getNamespace(version).getURI());\n\t\t\t\t\t\tif (module != null) {\n\t\t\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build XSLT transformer chain\n\t\t\tif (wfsConfig.getPostProcessing().getXSLTransformation().isEnabled()\n\t\t\t\t\t&& wfsConfig.getPostProcessing().getXSLTransformation().isSetStylesheets()) {\n\t\t\t\ttry {\n\t\t\t\t\tList<String> stylesheets = wfsConfig.getPostProcessing().getXSLTransformation().getStylesheets();\n\t\t\t\t\tSAXTransformerFactory factory = (SAXTransformerFactory) TransformerFactory.newInstance();\n\t\t\t\t\tTemplates[] templates = new Templates[stylesheets.size()];\n\n\t\t\t\t\tfor (int i = 0; i < stylesheets.size(); i++) {\n\t\t\t\t\t\tTemplates template = factory.newTemplates(new StreamSource(new File(stylesheets.get(i))));\n\t\t\t\t\t\ttemplates[i] = template;\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformerChainFactory = new TransformerChainFactory(templates);\n\t\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\t\tlog.error(\"Failed to compile XSLT stylesheets.\");\n\t\t\t\t\tlog.error(\"Cause: \" + e.getMessage());\n\t\t\t\t\tthrow new FeatureWriteException(\"Failed to configure the XSL transformation.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic FeatureWriter buildFeatureWriter(Writer writer) throws FeatureWriteException {\n\t\ttry {\n\t\t\tsaxWriter.setOutput(writer);\n\t\t\treturn new CityGMLWriter(saxWriter, version, transformerChainFactory, geometryStripper, idCacheManager, eventChannel, internalConfig, config);\n\t\t} catch (DatatypeConfigurationException e) {\n\t\t\tthrow new FeatureWriteException(\"Failed to create CityGML response writer.\", e);\n\t\t}\n\t}\n\n}\n", "package vcs.citydb.wfs.operation.getpropertyvalue;\n\nimport net.opengis.wfs._2.GetPropertyValueType;\nimport net.opengis.wfs._2.ResultTypeType;\nimport org.citydb.ade.model.module.CityDBADE100Module;\nimport org.citydb.ade.model.module.CityDBADE200Module;\nimport org.citydb.config.Config;\nimport org.citydb.core.database.schema.mapping.FeatureType;\nimport org.citydb.core.operation.exporter.writer.FeatureWriteException;\nimport org.citydb.util.log.Logger;\nimport org.citygml4j.model.module.Module;\nimport org.citygml4j.model.module.ModuleContext;\nimport org.citygml4j.model.module.Modules;\nimport org.citygml4j.model.module.ade.ADEModule;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.citygml4j.util.internal.xml.TransformerChainFactory;\nimport org.citygml4j.util.xml.SAXWriter;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.util.GeometryStripper;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\n\nimport javax.xml.datatype.DatatypeConfigurationException;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.File;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.Map;\n\npublic class GetPropertyValueResponseBuilder {\n\tprivate final Logger log = Logger.getInstance();\n\tprivate final String PRETTY_PRINT = \"prettyPrint\";\n\t\n\tprivate String valueReference;\n\tprivate NamespaceFilter namespaceFilter;\n\tprivate CityGMLVersion version;\n\tprivate GeometryStripper geometryStripper;\n\tprivate Config config;\n\tprivate Object eventChannel;\n\t\n\tprivate SAXWriter saxWriter;\n\tprivate TransformerChainFactory transformerChainFactory;\n\tprivate boolean useSequentialWriting;\n\t\n\tpublic String getMimeType() {\n\t\treturn \"text/xml\";\n\t}\n\n\tpublic void initializeContext(GetPropertyValueType wfsRequest,\n\t\t\tQueryExpression queryExpression,\n\t\t\tMap<String, String> formatOptions,\n\t\t\tNamespaceFilter namespaceFilter,\n\t\t\tObject eventChannel,\n\t\t\tWFSConfig wfsConfig,\n\t\t\tConfig config) throws FeatureWriteException {\n\t\tthis.namespaceFilter = namespaceFilter;\n\t\tthis.eventChannel = eventChannel;\n\t\tthis.config = config;\n\t\t\n\t\tvalueReference = queryExpression.getValueReference();\n\t\tversion = queryExpression.getTargetVersion();\n\t\tgeometryStripper = wfsConfig.getConstraints().isStripGeometry() ? new GeometryStripper() : null;\n\n\t\t// require sequential writing if a sorting clause is defined for the query\n\t\tuseSequentialWriting = queryExpression.isSetSorting();\n\n\t\tsaxWriter = new SAXWriter();\n\t\tsaxWriter.setWriteEncoding(true);\n\n\t\tif (\"true\".equals(formatOptions.get(PRETTY_PRINT)))\n\t\t\tsaxWriter.setIndentString(\" \");\n\n\t\t// set WFS prefix and schema location\n\t\tsaxWriter.setPrefix(Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\t\tsaxWriter.setSchemaLocation(Constants.WFS_NAMESPACE_URI, Constants.WFS_SCHEMA_LOCATION);\n\n\t\t// set CityGML prefixes and schema locations\n\t\tif (wfsRequest.getResultType() == ResultTypeType.RESULTS) {\n\t\t\t// add default prefixes and schema locations\n\t\t\tModuleContext moduleContext = new ModuleContext(version);\n\n\t\t\tModule core = moduleContext.getModule(CityGMLModuleType.CORE);\n\t\t\tModule generics = moduleContext.getModule(CityGMLModuleType.GENERICS);\n\t\t\tsaxWriter.setPrefix(core.getNamespacePrefix(), core.getNamespaceURI());\n\t\t\tsaxWriter.setPrefix(generics.getNamespacePrefix(), generics.getNamespaceURI());\n\t\t\tsaxWriter.setSchemaLocation(generics.getNamespaceURI(), generics.getSchemaLocation());\n\t\t\tif (wfsConfig.getConstraints().isExportAppearance()) {\n\t\t\t\tModule appearance = moduleContext.getModule(CityGMLModuleType.APPEARANCE);\n\t\t\t\tsaxWriter.setPrefix(appearance.getNamespacePrefix(), appearance.getNamespaceURI());\n\t\t\t\tsaxWriter.setSchemaLocation(appearance.getNamespaceURI(), appearance.getSchemaLocation());\n\t\t\t}\n\n\t\t\t// add XML prefixes and schema locations for non-CityGML modules\n\t\t\tfor (Module module : moduleContext.getModules()) {\n\t\t\t\tif (!(module instanceof CityGMLModule)) {\n\t\t\t\t\t// skip 3DCityDB ADE prefix and namespace if metadata shall not be exported\n\t\t\t\t\tif ((module == CityDBADE200Module.v3_0 || module == CityDBADE100Module.v3_0)\n\t\t\t\t\t\t\t&& !wfsConfig.getConstraints().isExportCityDBMetadata())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tif (module instanceof ADEModule)\n\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set XML prefixes and schema locations for selected feature types\n\t\t\tfor (FeatureType featureType : queryExpression.getFeatureTypeFilter().getFeatureTypes()) {\n\t\t\t\tCityGMLModule module = Modules.getCityGMLModule(featureType.getSchema().getNamespace(version).getURI());\n\t\t\t\tif (module != null) {\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build XSLT transformer chain\n\t\t\tif (wfsConfig.getPostProcessing().getXSLTransformation().isEnabled()\n\t\t\t\t\t&& wfsConfig.getPostProcessing().getXSLTransformation().isSetStylesheets()) {\n\t\t\t\ttry {\n\t\t\t\t\tList<String> stylesheets = wfsConfig.getPostProcessing().getXSLTransformation().getStylesheets();\n\t\t\t\t\tSAXTransformerFactory factory = (SAXTransformerFactory) TransformerFactory.newInstance();\n\t\t\t\t\tTemplates[] templates = new Templates[stylesheets.size()];\n\n\t\t\t\t\tfor (int i = 0; i < stylesheets.size(); i++) {\n\t\t\t\t\t\tTemplates template = factory.newTemplates(new StreamSource(new File(stylesheets.get(i))));\n\t\t\t\t\t\ttemplates[i] = template;\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformerChainFactory = new TransformerChainFactory(templates);\n\t\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\t\tlog.error(\"Failed to compile XSLT stylesheets.\");\n\t\t\t\t\tlog.error(\"Cause: \" + e.getMessage());\n\t\t\t\t\tthrow new FeatureWriteException(\"Failed to configure the XSL transformation.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic PropertyValueWriter buildPropertyValueWriter(Writer writer) throws FeatureWriteException {\n\t\ttry {\n\t\t\tsaxWriter.setOutput(writer);\n\t\t\treturn new PropertyValueWriter(valueReference,\n\t\t\t\t\tsaxWriter,\n\t\t\t\t\tversion,\n\t\t\t\t\ttransformerChainFactory,\n\t\t\t\t\tnamespaceFilter,\n\t\t\t\t\tgeometryStripper,\n\t\t\t\t\tuseSequentialWriting,\n\t\t\t\t\teventChannel,\n\t\t\t\t\tconfig);\n\t\t} catch (DatatypeConfigurationException e) {\n\t\t\tthrow new FeatureWriteException(\"Failed to create CityGML response writer.\", e);\n\t\t}\n\t}\n\n}\n", "package vcs.citydb.wfs.operation.storedquery;\n\nimport net.opengis.fes._2.AbstractQueryExpressionType;\nimport net.opengis.fes._2.FilterType;\nimport net.opengis.fes._2.ResourceIdType;\nimport net.opengis.wfs._2.*;\nimport org.citygml4j.builder.jaxb.CityGMLBuilder;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.*;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.exception.WFSException;\nimport vcs.citydb.wfs.exception.WFSExceptionCode;\nimport vcs.citydb.wfs.kvp.KVPConstants;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLOutputFactory;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StoredQueryManager {\n\tprivate final String GET_FEATURE_BY_ID_NAME = \"http://www.opengis.net/def/query/OGC-WFS/0/GetFeatureById\";\n\tprivate final String DEPRECATED_GET_FEATURE_BY_ID_NAME = \"urn:ogc:def:query:OGC-WFS::GetFeatureById\";\n\n\tprivate final StoredQuery DEFAULT_QUERY;\n\tprivate final CityGMLBuilder cityGMLBuilder;\n\tprivate final SAXParserFactory saxParserFactory;\n\tprivate final TransformerFactory transformerFactory;\n\tprivate final DocumentBuilderFactory documentBuilderFactory;\n\tprivate final XMLOutputFactory xmlOutputFactory;\n\tprivate final Path storedQueriesPath;\n\tprivate final ObjectFactory wfsFactory;\n\tprivate final WFSConfig wfsConfig;\n\tprivate final MessageDigest md5;\n\n\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException {\n\t\tthis.cityGMLBuilder = cityGMLBuilder;\n\t\tthis.saxParserFactory = saxParserFactory;\n\t\tthis.wfsConfig = wfsConfig;\n\n\t\tmd5 = MessageDigest.getInstance(\"MD5\");\n\t\twfsFactory = new ObjectFactory();\n\t\ttransformerFactory = TransformerFactory.newInstance();\n\t\txmlOutputFactory = XMLOutputFactory.newInstance();\n\t\tdocumentBuilderFactory = DocumentBuilderFactory.newInstance();\n\t\tdocumentBuilderFactory.setNamespaceAware(true);\n\n\t\tstoredQueriesPath = Paths.get(path);\n\t\tFiles.createDirectories(storedQueriesPath);\n\t\tif (!Files.isDirectory(storedQueriesPath) || !Files.isReadable(storedQueriesPath))\n\t\t\tthrow new IOException(\"Path for stored queries is not readable.\");\n\n\t\tDEFAULT_QUERY = createDefaultStoredQuery();\n\t}\n\n\tpublic List<StoredQueryAdapter> listStoredQueries(String handle) throws WFSException {\n\t\tList<StoredQueryAdapter> storedQueries = new ArrayList<>();\n\t\tstoredQueries.add(new StoredQueryAdapter(DEFAULT_QUERY.getId()));\n\n\t\ttry {\n\t\t\tfor (Path file : Files.newDirectoryStream(storedQueriesPath)) {\n\t\t\t\tif (Files.isRegularFile(file))\n\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to list stored queries.\", handle, e);\n\t\t}\n\n\t\treturn storedQueries;\n\t}\n\n\tpublic StoredQuery getStoredQuery(StoredQueryAdapter adapter, String handle) throws WFSException {\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(adapter.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(adapter.getId()))\n\t\t\treturn DEFAULT_QUERY;\n\n\t\tPath file = adapter.isSetId() ? storedQueriesPath.resolve(getFileName(adapter.getId())) : adapter.getFile();\n\t\tif (!Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"A stored query with identifier '\" + adapter.getId() + \"' is not offered by this server.\", KVPConstants.STOREDQUERY_ID);\n\n\t\treturn unmarshalStoredQuery(file, handle);\n\t}\n\n\tpublic Element parseStoredQuery(StoredQueryAdapter adapter, String handle) throws WFSException {\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(adapter.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(adapter.getId()))\n\t\t\treturn DEFAULT_QUERY.toDOMElement(handle);\n\n\t\tPath file = adapter.isSetId() ? storedQueriesPath.resolve(getFileName(adapter.getId())) : adapter.getFile();\n\t\tif (!Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"A stored query with identifier '\" + adapter.getId() + \"' is not offered by this server.\", KVPConstants.STOREDQUERY_ID);\n\n\t\treturn parseStoredQuery(file, handle);\n\t}\n\n\tpublic StoredQuery createStoredQuery(StoredQueryDescriptionType description, NamespaceFilter namespaceFilter, String handle) throws WFSException {\t\t\n\t\tif (!description.isSetId())\n\t\t\tthrow new WFSException(WFSExceptionCode.MISSING_PARAMETER_VALUE, \"The stored query description lacks the mandatory identifier.\", KVPConstants.STOREDQUERY_ID);\n\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(description.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(description.getId()))\n\t\t\tthrow new WFSException(WFSExceptionCode.DUPLICATE_STORED_QUERY_ID_VALUE, \"The identifier '\" + description.getId() + \"' is associated to the mandatory GetFeatureById query. Choose another identifier.\", description.getId());\n\n\t\t// serialize stored query to file\n\t\tPath file = storedQueriesPath.resolve(getFileName(description.getId()));\n\t\tif (Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.DUPLICATE_STORED_QUERY_ID_VALUE, \"The identifier '\" + description.getId() + \"' has already been associated with to a stored query. Drop the stored query first or choose another identifier.\", description.getId());\n\n\t\tStoredQuery storedQuery = new StoredQuery(description, namespaceFilter, this);\n\t\tstoredQuery.validate(handle);\n\n\t\ttry {\n\t\t\tDescribeStoredQueriesResponseType response = new DescribeStoredQueriesResponseType();\n\t\t\tresponse.getStoredQueryDescription().add(description);\n\t\t\tJAXBElement<DescribeStoredQueriesResponseType> jaxbElement = wfsFactory.createDescribeStoredQueriesResponse(response);\n\n\t\t\tMarshaller marshaller = cityGMLBuilder.getJAXBContext().createMarshaller();\n\t\t\tmarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n\t\t\tmarshaller.marshal(jaxbElement, file.toFile());\n\t\t} catch (JAXBException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to persist stored query.\", handle, e);\n\t\t}\n\n\t\treturn storedQuery;\n\t}\n\t\n\tpublic void dropStoredQuery(String id, String handle) throws WFSException {\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(id) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(id))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"The mandatory stored query '\" + id + \"' must not be dropped.\", handle);\n\t\t\n\t\tPath file = storedQueriesPath.resolve(getFileName(id));\n\t\tif (!Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"A stored query with identifier '\" + id + \"' is not offered by this server.\", handle);\n\n\t\ttry {\n\t\t\tFiles.delete(file);\n\t\t} catch (IOException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to drop the stored query with identifier '\" + id + \"'.\", handle);\n\t\t}\n\t}\n\n\tpublic void compileQuery(AbstractQueryExpressionType abstractQuery, List<QueryType> queries, NamespaceFilter namespaceFilter, String handle) throws WFSException {\n\t\tif (abstractQuery instanceof QueryType) {\n\t\t\tif (!wfsConfig.getConstraints().isSupportAdHocQueries())\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"Ad hoc queries are not advertised.\", handle);\n\t\t\t\n\t\t\tqueries.add((QueryType)abstractQuery);\n\t\t} \n\n\t\telse if (abstractQuery instanceof StoredQueryType) {\n\t\t\tStoredQueryType query = (StoredQueryType)abstractQuery;\n\n\t\t\tStoredQuery storedQuery = getStoredQuery(new StoredQueryAdapter(query.getId()), handle);\n\t\t\tif (storedQuery != null) {\n\t\t\t\tif (storedQuery.getId().equals(DEFAULT_QUERY.getId())) {\n\t\t\t\t\tQueryType queryType = (QueryType) storedQuery.compile(query, namespaceFilter).iterator().next();\n\n\t\t\t\t\tif (queryType.isSetAbstractSelectionClause() && queryType.getAbstractSelectionClause().getValue() instanceof FilterType) {\n\t\t\t\t\t\tFilterType filter = (FilterType) queryType.getAbstractSelectionClause().getValue();\n\t\t\t\t\t\tif (filter.isSet_Id() && filter.get_Id().get(0).getValue() instanceof ResourceIdType) {\n\t\t\t\t\t\t\tResourceIdType resourceId = (ResourceIdType) filter.get_Id().get(0).getValue();\n\t\t\t\t\t\t\tqueryType.setFeatureIdentifier(resourceId.getRid());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!queryType.isSetFeatureIdentifier())\n\t\t\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Lacking identifier for the '\" + DEFAULT_QUERY.getId() + \"' stored query.\", handle);\n\n\t\t\t\t\tqueries.add(queryType);\n\t\t\t\t} else {\n\t\t\t\t\tfor (AbstractQueryExpressionType compiled : storedQuery.compile(query, namespaceFilter))\n\t\t\t\t\t\tcompileQuery(compiled, queries, namespaceFilter, handle);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"No stored query with identifier '\" + query.getId() + \"' is offered by this server.\", handle);\n\t\t} \n\n\t\telse\n\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"Only ad hoc and stored query expressions are supported.\", handle);\n\t}\n\n\tpublic boolean containsStoredQuery(String id, String handle) {\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\treturn GET_FEATURE_BY_ID_NAME.equals(id)\n\t\t\t\t|| DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(id)\n\t\t\t\t|| Files.exists(storedQueriesPath.resolve(getFileName(id)));\n\t}\n\n\tprivate StoredQuery unmarshalStoredQuery(Path file, String handle) throws WFSException {\n\t\tif (!Files.isReadable(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to read the stored query file.\", handle);\n\n\t\tObject object;\n\t\tNamespaceFilter namespaceFilter;\n\n\t\ttry {\n\t\t\tUnmarshaller unmarshaller = cityGMLBuilder.getJAXBContext().createUnmarshaller();\n\t\t\tUnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\t\t\t\n\n\t\t\t// use SAX parser to keep track of namespace declarations\n\t\t\tSAXParser parser = saxParserFactory.newSAXParser();\t\t\t\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\tnamespaceFilter = new NamespaceFilter(reader);\n\t\t\tnamespaceFilter.setContentHandler(unmarshallerHandler);\n\n\t\t\tnamespaceFilter.parse(new InputSource(new BufferedReader(new FileReader(file.toFile()))));\n\t\t\tobject = unmarshallerHandler.getResult();\n\n\t\t} catch (JAXBException | SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Fatal JAXB error whilst processing the stored query.\", handle, e);\n\t\t}\n\n\t\tif (!(object instanceof JAXBElement<?>))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to parse the stored query file.\", handle);\n\n\t\tJAXBElement<?> jaxbElement = (JAXBElement<?>)object;\n\t\tif (!(jaxbElement.getValue() instanceof DescribeStoredQueriesResponseType))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Invalid content of the stored query file.\", handle);\n\n\t\tDescribeStoredQueriesResponseType response = (DescribeStoredQueriesResponseType)jaxbElement.getValue();\n\t\tif (response.getStoredQueryDescription().size() == 0)\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to parse the stored query file. No stored query description provided.\", handle);\n\n\t\tStoredQueryDescriptionType description = response.getStoredQueryDescription().get(0);\n\t\tif (!file.getFileName().toString().equals(getFileName(description.getId())))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"The stored query identifier '\" + description.getId() + \"' does not match the storage identifier.\", handle);\n\n\t\treturn new StoredQuery(description, namespaceFilter, this);\n\t}\n\n\tprivate Element parseStoredQuery(Path file, String handle) throws WFSException {\n\t\tif (!Files.isReadable(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to read the stored query file.\", handle);\n\n\t\ttry {\n\t\t\tDocument document = documentBuilderFactory.newDocumentBuilder().parse(file.toFile());\n\t\t\treturn processStoredQueryElement(document.getDocumentElement(), handle);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Fatal error whilst processing the stored query.\", handle, e);\n\t\t}\n\t}\n\n\tprotected Element processStoredQueryElement(Element root, String handle) throws WFSException {\n\t\ttry {\n\t\t\tNodeList nodeList = root.getElementsByTagNameNS(Constants.WFS_NAMESPACE_URI, \"StoredQueryDescription\");\n\t\t\tif (nodeList.getLength() == 0 || nodeList.getLength() > 1)\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to parse the stored query file. No stored query description provided.\", handle);\n\n\t\t\tElement description = (Element)nodeList.item(0);\n\n\t\t\t// copy namespace attributes from root element\n\t\t\tNamedNodeMap attributes = root.getAttributes();\n\t\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\t\tAttr attribute = (Attr)attributes.item(i);\n\t\t\t\tif (attribute.getNamespaceURI().equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI)) {\n\t\t\t\t\tif (attribute.getValue().equals(\"http://www.w3.org/2001/SMIL20/\") \n\t\t\t\t\t\t\t|| attribute.getValue().equals(\"http://www.w3.org/2001/SMIL20/Language\"))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdescription.setAttributeNS(attribute.getNamespaceURI(), attribute.getName(), attribute.getValue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove empty text nodes\n\t\t\tXPathFactory xpathFactory = XPathFactory.newInstance();\n\t\t\tXPathExpression xpathExp = xpathFactory.newXPath().compile(\"//text()[normalize-space(.) = '']\");  \n\t\t\tNodeList emptyNodeList = (NodeList)xpathExp.evaluate(root, XPathConstants.NODESET);\n\t\t\tfor (int i = 0; i < emptyNodeList.getLength(); i++) {\n\t\t\t\tNode emptyNode = emptyNodeList.item(i);\n\t\t\t\temptyNode.getParentNode().removeChild(emptyNode);\n\t\t\t}\n\n\t\t\treturn description;\n\t\t} catch (XPathExpressionException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Fatal error whilst processing the stored query.\", handle, e);\n\t\t}\n\t}\n\n\tprivate String getFileName(String id) {\n\t\tbyte[] md5Hash = md5.digest(id.getBytes());\n\n\t\tStringBuilder hexString = new StringBuilder();\n\t\tfor (byte item : md5Hash)\n\t\t\thexString.append(Integer.toString((item & 0xff) + 0x100, 16).substring(1));\n\n\t\treturn hexString.append(\".xml\").toString();\n\t}\n\n\tprotected CityGMLBuilder getCityGMLBuilder() {\n\t\treturn cityGMLBuilder;\n\t}\n\n\tprotected TransformerFactory getTransformerFactory() {\n\t\treturn transformerFactory;\n\t}\n\n\tprotected DocumentBuilderFactory getDocumentBuilderFactory() {\n\t\treturn documentBuilderFactory;\n\t}\n\t\n\tprotected XMLOutputFactory getXMLOutputFactory() {\n\t\treturn xmlOutputFactory;\n\t}\n\n\tprotected ObjectFactory getObjectFactory() {\n\t\treturn wfsFactory;\n\t}\n\t\n\tprotected WFSConfig getWFSConfig() {\n\t\treturn wfsConfig;\n\t}\n\n\tprivate StoredQuery createDefaultStoredQuery() throws ParserConfigurationException, SAXException {\n\t\t// GetFeatureById query according to the WFS 2.0 spec\n\t\tStoredQueryDescriptionType description = new StoredQueryDescriptionType();\n\n\t\tdescription.setId(!Constants.DEFAULT_WFS_VERSION.equals(\"2.0.0\") ?\n\t\t\t\tGET_FEATURE_BY_ID_NAME : DEPRECATED_GET_FEATURE_BY_ID_NAME);\n\n\t\tTitle queryTitle = new Title();\n\t\tqueryTitle.setLang(\"en\");\n\t\tqueryTitle.setValue(\"Get feature by identifier\");\n\t\tdescription.getTitle().add(queryTitle);\n\t\tAbstract queryAbstract = new Abstract();\n\t\tqueryAbstract.setLang(\"en\");\n\t\tqueryAbstract.setValue(\"Retrieves a feature by its gml:id.\");\n\t\tdescription.getAbstract().add(queryAbstract);\n\n\t\tParameterExpressionType parameter = new ParameterExpressionType();\n\t\tparameter.setName(\"id\");\n\t\tparameter.setType(XSDataType.XS_STRING.getName());\n\t\tTitle parameterTitle = new Title();\n\t\tparameterTitle.setLang(\"en\");\n\t\tparameterTitle.setValue(\"Identifier\");\n\t\tparameter.getTitle().add(parameterTitle);\n\t\tAbstract parameterAbstract = new Abstract();\n\t\tparameterAbstract.setLang(\"en\");\n\t\tparameterAbstract.setValue(\"The gml:id of the feature to be retrieved.\");\n\t\tparameter.getAbstract().add(parameterAbstract);\n\t\tdescription.getParameter().add(parameter);\n\n\t\tDocument document = documentBuilderFactory.newDocumentBuilder().newDocument();\n\t\tElement query = document.createElementNS(Constants.WFS_NAMESPACE_URI, Constants.WFS_NAMESPACE_PREFIX + \":Query\");\n\t\tquery.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, \"xmlns:\" + Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\n\t\tNamespaceFilter namespaceFilter = new NamespaceFilter();\n\t\tCityGMLVersion version = wfsConfig.getFeatureTypes().getDefaultVersion();\n\t\tboolean multipleVersions = wfsConfig.getFeatureTypes().getVersions().size() > 1;\n\t\tCityGMLModule module = version.getCityGMLModule(CityGMLModuleType.CORE);\t\t\n\t\tString prefix = module.getNamespacePrefix();\n\t\tif (multipleVersions)\n\t\t\tprefix += (version == CityGMLVersion.v2_0_0) ? \"2\" : \"1\";\n\n\t\tnamespaceFilter.startPrefixMapping(prefix, module.getNamespaceURI());\n\t\tnamespaceFilter.startPrefixMapping(\"xs\", XMLConstants.W3C_XML_SCHEMA_NS_URI);\n\t\tquery.setAttribute(\"typeNames\", \"schema-element(\" + prefix + ':' + \"_CityObject)\");\n\t\tquery.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, \"xmlns:\" + prefix, module.getNamespaceURI());\n\n\t\tElement filter = document.createElementNS(Constants.FES_NAMESPACE_URI, Constants.FES_NAMESPACE_PREFIX + \":Filter\");\n\t\tfilter.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, \"xmlns:\" + Constants.FES_NAMESPACE_PREFIX, Constants.FES_NAMESPACE_URI);\n\t\tElement resourceId = document.createElementNS(Constants.FES_NAMESPACE_URI, Constants.FES_NAMESPACE_PREFIX + \":ResourceId\");\n\t\tresourceId.setAttribute(\"rid\", \"${id}\");\n\t\tfilter.appendChild(resourceId);\n\t\tquery.appendChild(filter);\n\n\t\tQueryExpressionTextType queryExpression = new QueryExpressionTextType();\n\t\tqueryExpression.getContent().add(query);\t\t\n\t\tqueryExpression.setIsPrivate(false);\n\t\tqueryExpression.setLanguage(\"en\");\n\t\tqueryExpression.setReturnFeatureTypes(new ArrayList<>());\n\t\tqueryExpression.setLanguage(StoredQuery.DEFAULT_LANGUAGE);\n\t\tdescription.getQueryExpressionText().add(queryExpression);\n\n\t\treturn new StoredQuery(description, namespaceFilter, this);\n\t}\n\n}\n"], "fixing_code": ["Change Log\n==========\n\n### 5.2.1 - tba\n\n#### Fixes\n*  Fixed XXE vulnerabilities when parsing XML files. [#12](https://github.com/3dcitydb/web-feature-service/pull/12/files)\n\n### 5.2.0 - 2022-05-23\n\nThis release is based on the Importer/Exporter version 5.2.0 libraries, and thus incorporates all bug fixes and updates\nintroduced in that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v5.2.0)).\n\n##### Additions\n* Added support for 3DCityDB v4.3\n* Added `replaceResourceIds` configuration option to replace all identifiers of features and geometries with UUIDs.\n\n##### Fixes\n* The database port was not correctly set when using the `CITYDB_PORT` environment variable.\n\n##### Miscellaneous\n* Updated PostgreSQL driver to 42.3.4\n* Updated Oracle driver to 21.3.0.0\n* Updated GeoTools to 26.4.\n\n### 5.1.0 - 2022-04-12\n\nThis release is based on the Importer/Exporter version 5.1.1 libraries, and thus incorporates all bug fixes and updates\nintroduced in that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v5.1.1)).\n\n##### Changes\n* Changed the handling of date-time values and timezones. Before this change, `xsd:date` values in exports could be\n  different from the values stored in the database in case different timezone settings were used for the database\n  server and the import and export operations.\n* Simplified database queries used by the `GetFeature` and `GetPropertyValue` operations for top-level features\n  involving many nested features/tables to avoid extremely large result sets causing performance issues.\n\n##### Fixes\n* Fixed bug in parsing of XPath expressions of XML queries that caused a slash `/` being part of a literal value to\n  be interpreted as step operator.\n* Empty strings for gml:id attributes are no longer imported but the `GMLID` column is set to `NULL` instead.\n\n##### Miscellaneous\n* Updated H2 database used for local caching to 2.1.210.\n* Updated PostgreSQL driver to 42.3.1 and PostGIS driver to 2021.1.0.\n* Updated citygml4j to 2.12.0.\n\n### 5.0.0 - 2021-10-08\n\n##### Changes\n* Added Docker files to build your own images for the WFS service. Pre-built Docker images\n  are available from Docker Hub at https://hub.docker.com/r/3dcitydb/wfs. [#9](https://github.com/3dcitydb/web-feature-service/pull/9)\n* Support for the WFS 2.0 operations `GetFeature`, `GetPropertyValue`. `CreateStoredQuery`, `DropStoredQuery`\n  with both XML and KVP encodings.\n* Support for ad-hoc queries and stored queries.\n* New filter capabilities including spatial, thematic and logical filters based on OGC Filter Encoding.\n* Support for XPath expressions in filter expressions to allow queries on complex attributes and nested features.\n* Support for exporting local and global appearances of the requested city objects. Texture images are provided\n  through a separate RESTful service that is included in the WFS package and automatically started with the WFS\n  service.\n* Support for response paging allowing a client to scroll through large sets of features or property values\n  based on the `count` and `startIndex` parameters.\n* The city objects and property values in a response document can now be sorted by thematic attributes.\n* Address attributes and 3DCityDB metadata can be used in query expressions based on corresponding CityGML ADEs\n  like with the Importer/Exporter.\n* Management of stored queries is now possible.\n* Individual WFS operations can now be secured using IP- and token-based access control rules.\n* Support for setting the time zone to be used for queries involving date and time attributes.\n* JDBC drivers are now kept in `WEB-INF/lib` to better support running the WFS in a Docker environment. So, there\n  is no need to copy JDBC drivers to a global or shared lib folder anymore.\n* This release is based on the Importer/Exporter version 5.0.0, and thus incorporates all bug fixes and updates\n  introduced in that version.\n* Added support for providing database connection details via environment variables.\n* CityJSON output now uses the latest CityJSON version 1.0.3.\n* Many bugfixes and improvements.\n\n##### Miscellaneous\n* Updated citygml4j to 2.11.4.\n* Updated PostgreSQL driver to 42.2.23 and Oracle driver to 21.1.0.\n\n\n### 4.3.0 - 2021-04-28\n\n##### Changes\n* Improved export performance (up to 10-15 times faster in case the WFS is not running on the same machine or\n  in the same local network as the database server).\n* The default `config.xml` file and ADE extensions folder can now be changed using the environment variables\n  `VC_WFS_CONFIG_FILE` and `VC_WFS_ADE_EXTENSIONS_PATH`.\n* Enhanced LoD filter constraint with the option to only export the minimum or maximum LoD from the list of\n  selected LoDs.\n* Updated WFS web client UI and added support for XML highlighting to the input and output fields.\n* Added `countDefault` constraint to limit the maximum number of returned features.\n* Added CityJSON output format option `removeDuplicateChildGeometries` to avoid exporting duplicate geometries\n  for nested child objects.\n* This release is based on the Importer/Exporter version 4.3.0, and thus incorporates all bug fixes and updates\n  introduced in that version.\n\n##### Fixes\n* Fixed error when exporting to CityJSON and no top-level feature is returned.\n\n##### Miscellaneous\n* Updated citygml4j to 2.11.3.\n* Upgrade PostgreSQL driver to 42.2.14 and PostGIS to 2.5.0.\n\n### 4.2.3 - 2020-07-16\n\n##### Changes\n* CityJSON output now uses the latest CityJSON version 1.0.1.\n* This release is based on the Importer/Exporter version 4.2.3, and thus incorporates all bug fixes and updates introduced\nin that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v4.2.3)).\n\n##### Miscellaneous\n* Updated citygml4j to 2.10.5.\n* Upgrade to latest PostgreSQL driver 42.2.10\n* Upgrade Oracle driver to 19.3.\n\n### 4.2 - 2019-02-13\n\n##### Changes\n* CityJSON output now uses the latest CityJSON version 0.9.\n\n##### Fixes\n* Using UTF-8 encoding for CityJSON output per default.\n* This release is based on the Importer/Exporter version 4.2.0, and thus incorporates all bug fixes and updates introduced \nin that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v4.2.0)). \n\n##### Miscellaneous \n* Updated citygml4j to 2.9.1.\n\n### 4.1 - 2019-01-09\n\n##### Changes\n* renamed the parameter `<useCityDBADE>` to `<exportCityDBMetadata>` in the `config.xml` file. This parameter controls\nwhether metadata such as the `LINEAGE` attribute of the `CITYOBJECT` table should be written to the response document.\nIf set to `true`, the 3DCityDB ADE will be used for storing the information with the city objects.\n\n##### Fixes\n* This release is based on the Importer/Exporter version 4.1.0, and thus incorporates all bug fixes and updates\nintroduced in that version ([more information](https://github.com/3dcitydb/importer-exporter/releases/tag/v4.1.0)).\n\n##### Miscellaneous \n* Upgrade to latest PostgreSQL driver v42.2.5 and PostGIS driver v2.3.0.\n* Upgrade to latest Oracle driver 18.3.\n\n### 4.0 - 2018-09-18\n\n##### Additions\n* Added support for CityGML ADEs through ADE extensions.\n* Added KVP over HTTP GET as additional service binding to simplify the integration with GIS and ETL software such as FME.\n* Added [CityJSON](http://www.cityjson.org/) as additional output format besides CityGML.\n* New LoD filter for WFS responses.\n* Added support for CORS.\n* Database connections are not established at service startup but lazily when required.\n* Major update to Importer/Exporter library 4.0.\n* Switched from Ant to Gradle as build system.\n\n##### Miscellaneous \n* [3DCityDB Docker images](https://github.com/tum-gis/3dcitydb-docker-postgis) are now available for a range of 3DCityDB\nand WFS versions to support continuous integration workflows.\n", "import org.apache.tools.ant.filters.ReplaceTokens\n\nplugins {\n    id 'java'\n    id 'war'\n    id 'distribution'\n}\n\ngroup 'org.citydb.wfs'\nversion '5.2.0'\n\napply from: 'properties.gradle'\n\next {\n    genSrcDir = 'src-gen/main/java'\n}\n\njava {\n    toolchain {\n        languageVersion = JavaLanguageVersion.of(11)\n    }\n    compileJava {\n        options.release = 8\n    }\n    sourceSets {\n        main.java.srcDir genSrcDir\n    }\n}\n\nconfigurations {\n    jdbc\n    jaxb\n}\n\nrepositories {\n    maven {\n        url 'https://repo.osgeo.org/repository/release'\n    }\n    maven {\n        url 'https://citydb.jfrog.io/artifactory/maven'\n    }\n    maven {\n        url 'https://oss.sonatype.org/content/repositories/snapshots/'\n    }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.citydb:impexp-core:5.2.1-SNAPSHOT'\n    implementation 'com.github.seancfoley:ipaddress:5.3.4'\n    implementation 'org.glassfish.jersey.containers:jersey-container-servlet:2.35'\n    implementation 'org.glassfish.jersey.inject:jersey-hk2:2.35'\n\n    providedCompile 'javax.servlet:javax.servlet-api:3.1.0'\n\n    jaxb 'org.glassfish.jaxb:jaxb-xjc:2.3.2'\n    jaxb 'org.jvnet.jaxb2_commons:jaxb2-basics:0.12.0'\n    jaxb 'org.jvnet.jaxb2_commons:jaxb2-namespace-prefix:1.3'\n    jaxb 'org.jvnet.jaxb2_commons:jaxb2-basics-annotate:1.1.0'\n    jaxb 'org.slf4j:slf4j-simple:1.7.25'\n}\n\ntask processLicense(type: Copy) {\n    from(\"resources/license/LICENSE.txt\") {\n        filteringCharset = 'UTF-8'\n        filter(ReplaceTokens, tokens: [\n                name: project.citydbWfsName,\n                vendorName: project.vendorName,\n                vendorStreet: project.vendorStreet,\n                vendorTown: project.vendorTown,\n                vendorCountry: project.vendorCountry,\n                vendorCopyright: project.vendorCopyright,\n                vendorWebsiteUrl: project.vendorWebsiteUrl\n        ])\n    }\n    into \"$buildDir/tmp/license\"\n}\n\nprocessResources {\n    filteringCharset = 'ISO-8859-1'\n    filesMatching('**/application.properties') {\n        filter(ReplaceTokens, tokens: [\n                name: project.citydbWfsName,\n                version: project.version,\n                vendorName: project.vendorName,\n                vendorStreet: project.vendorStreet,\n                vendorTown: project.vendorTown,\n                vendorCountry: project.vendorCountry,\n                vendorCopyright: project.vendorCopyright,\n                vendorWebsiteUrl: project.vendorWebsiteUrl\n        ])\n    }\n}\n\ntask generateJaxb(group: 'jaxb') {\n    outputs.dir genSrcDir\n\n    doLast {\n        mkdir genSrcDir\n\n        System.setProperty('javax.xml.accessExternalSchema', 'file')\n        ant.taskdef(name: 'xjc', classname: 'com.sun.tools.xjc.XJC2Task', classpath: configurations.jaxb.asPath)\n        ant.xjc(destdir: genSrcDir,\n                schema: 'resources/jaxb/wfs-jaxb.xsd',\n                binding: 'resources/jaxb/binding.xjb',\n                extension: 'true',\n                encoding: 'UTF-8') {\n            produces(dir: genSrcDir, includes: '**/*.java')\n            arg(line: '-Xnamespace-prefix -Xsetters -Xsetters-mode=direct -Xinheritance -Xannotate -XremoveAnnotation')\n        }\n\n        delete \"$genSrcDir/net/opengis/citygml\"\n        delete \"$genSrcDir/net/opengis/gml\"\n        delete \"$genSrcDir/org\"\n        delete \"$genSrcDir/oasis\"\n    }\n}\n\ntask cleanJaxb(type: Delete, group: 'jaxb') {\n    delete 'src-gen'\n}\n\ndistributions.main {\n    distributionBaseName = project.appName\n    contents {\n        from war\n        from 'CHANGES.md'\n        from 'README.md'\n        into('license') {\n            from \"$rootDir/resources/license/APACHE-2.0.txt\"\n            from processLicense\n        }\n    }\n}\n\nwar {\n    archiveFileName = project.name + '.war'\n    manifest {\n        attributes('Implementation-Title': project.appName,\n                'Implementation-Version': project.version,\n                'Implementation-Vendor': project.vendorName + ', ' + project.vendorWebsiteUrl\n        )\n    }\n    into('META-INF') {\n        from processLicense\n    }\n}", "package vcs.citydb.wfs;\n\nimport net.opengis.wfs._2.*;\nimport org.citydb.config.Config;\nimport org.citydb.core.database.connection.DatabaseConnectionPool;\nimport org.citydb.core.registry.ObjectRegistry;\nimport org.citydb.core.util.Util;\nimport org.citydb.util.concurrent.SingleWorkerPool;\nimport org.citydb.util.log.Logger;\nimport org.citydb.util.xml.SecureXMLProcessors;\nimport org.citygml4j.builder.jaxb.CityGMLBuilder;\nimport org.citygml4j.xml.schema.SchemaHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.config.operation.EncodingMethod;\nimport vcs.citydb.wfs.exception.AccessControlException;\nimport vcs.citydb.wfs.exception.WFSException;\nimport vcs.citydb.wfs.exception.WFSExceptionCode;\nimport vcs.citydb.wfs.exception.WFSExceptionReportHandler;\nimport vcs.citydb.wfs.kvp.*;\nimport vcs.citydb.wfs.operation.describefeaturetype.DescribeFeatureTypeHandler;\nimport vcs.citydb.wfs.operation.getcapabilities.GetCapabilitiesHandler;\nimport vcs.citydb.wfs.operation.getfeature.GetFeatureHandler;\nimport vcs.citydb.wfs.operation.getpropertyvalue.GetPropertyValueHandler;\nimport vcs.citydb.wfs.operation.storedquery.*;\nimport vcs.citydb.wfs.paging.PageRequest;\nimport vcs.citydb.wfs.paging.PagingCacheManager;\nimport vcs.citydb.wfs.paging.PagingHandler;\nimport vcs.citydb.wfs.security.AccessController;\nimport vcs.citydb.wfs.util.*;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\nimport vcs.citydb.wfs.util.xml.ValidationEventHandlerImpl;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.JAXBElement;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Unmarshaller;\nimport javax.xml.bind.UnmarshallerHandler;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n@WebServlet(Constants.WFS_SERVICE_PATH)\npublic class WFSService extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate final Logger log = Logger.getInstance();\n\tprivate final DatabaseConnectionPool connectionPool = DatabaseConnectionPool.getInstance();\n\n\tprivate CityGMLBuilder cityGMLBuilder;\n\tprivate RequestLimiter limiter;\n\tprivate AccessController accessController;\n\tprivate WFSConfig wfsConfig;\n\tprivate Config config;\n\n\tprivate SAXParserFactory saxParserFactory;\n\tprivate Schema wfsSchema;\n\tprivate SingleWorkerPool<CacheCleanerWork> cacheCleanerPool;\n\tprivate WFSExceptionReportHandler exceptionReportHandler;\n\n\t@Override\n\tpublic void init() throws ServletException {\n\t\t// check whether servlet initialization threw an error\n\t\tObject error = getServletContext().getAttribute(Constants.INIT_ERROR_ATTRNAME);\n\t\tif (error instanceof ServletException)\n\t\t\tthrow (ServletException) error;\n\n\t\tlog.info(\"WFS service is loaded by the servlet container.\");\n\n\t\t// service specific initialization\n\t\tObjectRegistry registry = ObjectRegistry.getInstance();\n\t\tconfig = registry.getConfig();\n\t\tcityGMLBuilder = registry.getCityGMLBuilder();\n\t\tlimiter = registry.lookup(RequestLimiter.class);\n\t\taccessController = registry.lookup(AccessController.class);\n\t\twfsConfig = registry.lookup(WFSConfig.class);\n\n\t\texceptionReportHandler = new WFSExceptionReportHandler(cityGMLBuilder);\n\n\t\ttry {\n\t\t\tsaxParserFactory = SecureXMLProcessors.newSAXParserFactory();\n\t\t\tsaxParserFactory.setNamespaceAware(true);\n\t\t} catch (Throwable e) {\n\t\t\tString message = \"Failed to enable secure processing of XML queries.\";\n\t\t\tlog.error(message);\n\t\t\tlog.error(e.getMessage());\n\t\t\tthrow new ServletException(message, e);\n\t\t}\n\n\t\ttry {\n\t\t\tStoredQueryManager storedQueryManager = new StoredQueryManager(cityGMLBuilder, saxParserFactory, getServletContext().getRealPath(Constants.STORED_QUERIES_PATH), wfsConfig);\n\t\t\tregistry.register(storedQueryManager);\n\t\t} catch (Throwable e) {\n\t\t\tString message = \"Failed to initialize stored query manager.\";\n\t\t\tlog.error(message);\n\t\t\tlog.error(e.getMessage());\n\t\t\tthrow new ServletException(message, e);\n\t\t}\n\n\t\t// read WFS 2.0 schema to validate requests\n\t\tif (wfsConfig.getOperations().getRequestEncoding().isUseXMLValidation()) {\n\t\t\ttry {\n\t\t\t\tSchemaHandler schemaHandler = registry.lookup(SchemaHandler.class);\n\t\t\t\tschemaHandler.parseSchema(new File(getServletContext().getRealPath(Constants.SCHEMAS_PATH + \"/ogc/wfs/2.0.2/wfs.xsd\")));\n\t\t\t\tschemaHandler.parseSchema(new File(getServletContext().getRealPath(Constants.SCHEMAS_PATH + \"/ogc/wfs/extensions/wfs-vcs.xsd\")));\n\t\t\t\tSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n\t\t\t\twfsSchema = schemaFactory.newSchema(schemaHandler.getSchemaSources());\n\t\t\t} catch (SAXException e) {\n\t\t\t\tString message = \"Failed to read WFS XML Schema from \" + Constants.SCHEMAS_PATH + \"/ogc/wfs.\";\n\t\t\t\tlog.error(message);\n\t\t\t\tlog.error(e.getMessage());\n\t\t\t\tthrow new ServletException(message, e);\n\t\t\t}\n\t\t}\n\n\t\t// register cache cleaner pool\n\t\tcacheCleanerPool = new SingleWorkerPool<>(\n\t\t\t\t\"cache_cleaner\",\n\t\t\t\tCacheCleanerWorker::new,\n\t\t\t\twfsConfig.getServer().getMaxParallelRequests());\n\n\t\tcacheCleanerPool.prestartCoreWorker();\n\t\tregistry.register(CacheCleanerWorker.class.getName(), cacheCleanerPool);\n\n\t\t// register paging cache manager\n\t\tif (wfsConfig.getConstraints().isUseResultPaging()) {\n\t\t\tPagingCacheManager pagingCacheManager = new PagingCacheManager(cacheCleanerPool, wfsConfig);\n\t\t\tregistry.register(pagingCacheManager);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\tlog.info(\"WFS service is destroyed by the servlet container.\");\n\n\t\t// destroy resources which may otherwise cause memory leaks\n\t\ttry {\n\t\t\tcacheCleanerPool.shutdownAndWait();\n\t\t} catch (InterruptedException e) {\n\t\t\tString message = \"Failed to shutdown cache cleaner pool.\";\n\t\t\tlog.error(message);\n\t\t\tlog.error(e.getMessage());\n\t\t}\n\t}\n\n\t@Override\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t// set CORS http headers\n\t\tif (wfsConfig.getServer().isEnableCORS())\n\t\t\taddCORSHeaders(request, response, false);\n\n\t\tKVPRequestReader reader = null;\n\t\tboolean isPagingRequest = ServerUtil.containsParameter(request, KVPConstants.PAGE_ID);\n\n\t\ttry {\n\t\t\tif (wfsConfig.getOperations().getRequestEncoding().getMethod() == EncodingMethod.XML && !isPagingRequest)\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"KVP encoding of requests is not advertised.\");\n\n\t\t\tif (isPagingRequest && !wfsConfig.getConstraints().isUseResultPaging())\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"Result paging is not advertised.\");\n\n\t\t\t// parse parameters\n\t\t\tMap<String, String> parameters = new HashMap<>();\n\t\t\tfor (Entry<String, String[]> entry : request.getParameterMap().entrySet()) {\n\t\t\t\tString name = entry.getKey().toUpperCase();\n\t\t\t\tString value = entry.getValue()[0];\n\n\t\t\t\tfor (int i = 1; i < entry.getValue().length; i++) {\n\t\t\t\t\tif (!value.equals(entry.getValue()[i]))\n\t\t\t\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"Found inconsistent values for parameter \" + name + \": \" + Util.collection2string(Arrays.asList(entry.getValue()), \", \"), name);\n\t\t\t\t}\n\n\t\t\t\tString previous = parameters.get(name);\n\t\t\t\tif (previous != null && !value.equals(parameters.get(previous)))\n\t\t\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"Found inconsistent values for parameter \" + name + \": \" + value + \", \" + parameters.get(name), name);\n\n\t\t\t\tif (!value.isEmpty())\n\t\t\t\t\tparameters.put(name, value);\n\t\t\t}\n\n\t\t\tString operationName = parameters.get(KVPConstants.REQUEST);\n\t\t\tif (operationName != null) {\n\t\t\t\tswitch (operationName) {\n\t\t\t\t\tcase KVPConstants.GET_CAPABILITIES:\n\t\t\t\t\t\treader = new GetCapabilitiesReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.DESCRIBE_FEATURE_TYPE:\n\t\t\t\t\t\treader = new DescribeFeatureTypeReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.GET_PROPERTY_VALUE:\n\t\t\t\t\t\treader = new GetPropertyValueReader(parameters, wfsSchema, cityGMLBuilder, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.GET_FEATURE:\n\t\t\t\t\t\treader = new GetFeatureReader(parameters, wfsSchema, cityGMLBuilder, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.LIST_STORED_QUERIES:\n\t\t\t\t\t\treader = new ListStoredQueriesReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.DESCRIBE_STORED_QUERIES:\n\t\t\t\t\t\treader = new DescribeStoredQueriesReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.DROP_STORED_QUERY:\n\t\t\t\t\t\treader = new DropStoredQueryReader(parameters, wfsConfig);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KVPConstants.CREATE_STORED_QUERY:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"The operation \" + operationName + \" is not supported by this WFS implementation.\", KVPConstants.REQUEST);\n\t\t\t\t}\n\t\t\t} else if (isPagingRequest) {\n\t\t\t\treader = new PagingReader(parameters, wfsConfig);\n\t\t\t} else\n\t\t\t\tthrow new WFSException(WFSExceptionCode.MISSING_PARAMETER_VALUE, \"The request lacks the mandatory \" + KVPConstants.REQUEST + \" parameter.\", KVPConstants.REQUEST);\n\n\t\t\t// parse and process request\n\t\t\tObject wfsRequest = reader.readRequest();\n\t\t\thandleRequest(wfsRequest, reader.getOperationName(), reader.getNamespaces(), request, response);\n\t\t} catch (WFSException e) {\n\t\t\tString operationName = reader != null ? reader.getOperationName() : null;\n\t\t\texceptionReportHandler.sendErrorResponse(e, operationName, request, response);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t// set CORS http headers\n\t\tif (wfsConfig.getServer().isEnableCORS())\n\t\t\taddCORSHeaders(request, response, false);\n\n\t\tString operationName = null;\n\t\ttry {\n\t\t\tif (wfsConfig.getOperations().getRequestEncoding().getMethod() == EncodingMethod.KVP)\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"XML encoding of requests is not advertised.\");\n\n\t\t\tUnmarshaller unmarshaller = cityGMLBuilder.getJAXBContext().createUnmarshaller();\n\t\t\tValidationEventHandlerImpl validationEventHandler = null;\n\n\t\t\t// support XML validation\n\t\t\tif (wfsConfig.getOperations().getRequestEncoding().isUseXMLValidation()) {\n\t\t\t\tunmarshaller.setSchema(wfsSchema);\n\t\t\t\tvalidationEventHandler = new ValidationEventHandlerImpl();\n\t\t\t\tunmarshaller.setEventHandler(validationEventHandler);\n\t\t\t}\n\n\t\t\tUnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n\n\t\t\t// use SAX parser to keep track of namespace declarations\n\t\t\tSAXParser parser = saxParserFactory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\tNamespaceFilter namespaceFilter = new NamespaceFilter(reader);\n\t\t\tnamespaceFilter.setContentHandler(unmarshallerHandler);\n\n\t\t\ttry {\n\t\t\t\tnamespaceFilter.parse(new InputSource(request.getInputStream()));\n\t\t\t} catch (SAXException e) {\n\t\t\t\tif (validationEventHandler != null && !validationEventHandler.isValid())\n\t\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PARSING_FAILED, validationEventHandler.getCause());\n\t\t\t\telse throw e;\n\t\t\t}\n\n\t\t\t// unmarshal WFS request\n\t\t\tObject object = unmarshallerHandler.getResult();\n\t\t\tif (!(object instanceof JAXBElement<?>))\n\t\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"Failed to parse XML document received through HTTP POST.\", KVPConstants.REQUEST);\n\n\t\t\tJAXBElement<?> element = (JAXBElement<?>) object;\n\t\t\toperationName = element.getName().getLocalPart();\n\n\t\t\t// process request\n\t\t\thandleRequest(element.getValue(), operationName, namespaceFilter, request, response);\n\t\t} catch (JAXBException | SAXException | ParserConfigurationException e) {\n\t\t\texceptionReportHandler.sendErrorResponse(new WFSException(WFSExceptionCode.OPERATION_PARSING_FAILED, \"Failed to parse the XML message.\", e), operationName, request, response);\n\t\t} catch (WFSException e) {\n\t\t\texceptionReportHandler.sendErrorResponse(e, operationName, request, response);\n\t\t}\n\t}\n\n\tprivate void handleRequest(Object wfsRequest, String operationName, NamespaceFilter namespaceFilter, HttpServletRequest request, HttpServletResponse response) throws WFSException {\n\t\t// check access permission\n\t\ttry {\n\t\t\taccessController.requireAccess(operationName, request);\n\t\t} catch (AccessControlException e) {\n\t\t\tlog.error(\"Access denied: \" + e.getMessage());\n\t\t\tif (e.getCause() != null)\n\t\t\t\tlog.logStackTrace(e.getCause());\n\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Access denied for client '\" + request.getRemoteHost() + \"'.\");\n\t\t}\n\n\t\t// check database connection\n\t\tif (!connectionPool.isConnected())\n\t\t\tDatabaseConnector.connect(config);\n\n\t\ttry {\n\t\t\tif (wfsRequest instanceof GetFeatureType) {\n\t\t\t\t// make sure we only serve a maximum number of requests in parallel\n\t\t\t\tlimiter.requireServiceSlot(request, operationName);\n\t\t\t\tGetFeatureHandler getFeatureHandler = new GetFeatureHandler(cityGMLBuilder, wfsConfig, config);\n\t\t\t\tgetFeatureHandler.doOperation((GetFeatureType) wfsRequest, namespaceFilter, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof GetPropertyValueType) {\n\t\t\t\t// make sure we only serve a maximum number of requests in parallel\n\t\t\t\tlimiter.requireServiceSlot(request, operationName);\n\t\t\t\tGetPropertyValueHandler getPropertyValueHandler = new GetPropertyValueHandler(cityGMLBuilder, wfsConfig, config);\n\t\t\t\tgetPropertyValueHandler.doOperation((GetPropertyValueType) wfsRequest, namespaceFilter, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof DescribeFeatureTypeType) {\n\t\t\t\tDescribeFeatureTypeHandler describeFeatureTypeHandler = new DescribeFeatureTypeHandler(wfsConfig);\n\t\t\t\tdescribeFeatureTypeHandler.doOperation((DescribeFeatureTypeType)wfsRequest, getServletContext(), request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof GetCapabilitiesType) {\n\t\t\t\tGetCapabilitiesHandler getCapabilitiesHandler = new GetCapabilitiesHandler(cityGMLBuilder, wfsConfig);\n\t\t\t\tgetCapabilitiesHandler.doOperation((GetCapabilitiesType)wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof ListStoredQueriesType) {\n\t\t\t\tListStoredQueriesHandler listStoredQueriesHandler = new ListStoredQueriesHandler(cityGMLBuilder, wfsConfig);\n\t\t\t\tlistStoredQueriesHandler.doOperation((ListStoredQueriesType)wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof DescribeStoredQueriesType) {\n\t\t\t\tDescribeStoredQueriesHandler describeStoredQueriesHandler = new DescribeStoredQueriesHandler(wfsConfig);\n\t\t\t\tdescribeStoredQueriesHandler.doOperation((DescribeStoredQueriesType)wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof CreateStoredQueryType) {\n\t\t\t\tCreateStoredQueryHandler createStoredQueriesHandler = new CreateStoredQueryHandler(cityGMLBuilder, wfsConfig);\n\t\t\t\tcreateStoredQueriesHandler.doOperation((CreateStoredQueryType)wfsRequest, namespaceFilter, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof DropStoredQueryType) {\n\t\t\t\tDropStoredQueryHandler dropStoredQueriesHandler = new DropStoredQueryHandler(cityGMLBuilder, wfsConfig);\n\t\t\t\tdropStoredQueriesHandler.doOperation((DropStoredQueryType)wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse if (wfsRequest instanceof PageRequest) {\n\t\t\t\t// make sure we only serve a maximum number of requests in parallel\n\t\t\t\tlimiter.requireServiceSlot(request, operationName);\n\t\t\t\tPagingHandler pagingHandler = new PagingHandler(cityGMLBuilder, wfsConfig, config);\n\t\t\t\tpagingHandler.doOperation((PageRequest) wfsRequest, request, response);\n\t\t\t}\n\n\t\t\telse\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_NOT_SUPPORTED, \"The operation \" + operationName + \" is not supported by this WFS implementation.\", operationName);\n\n\t\t} catch (JAXBException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"A fatal JAXB error occurred whilst processing the request.\", operationName, e);\n\t\t} finally {\n\t\t\t// release slot from limiter\n\t\t\tlimiter.releaseServiceSlot(request);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void doOptions(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t// support CORS preflight requests\n\t\tif (wfsConfig.getServer().isEnableCORS())\n\t\t\taddCORSHeaders(request, response, true);\n\t}\n\n\tprivate void addCORSHeaders(HttpServletRequest request, HttpServletResponse response, boolean isOptions) {\n\t\t// do nothing if this is not a CORS request\n\t\tif (request.getHeader(\"Origin\") == null)\n\t\t\treturn;\n\n\t\tresponse.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n\n\t\t// add preflight headers\n\t\tif (isOptions && request.getHeader(\"Access-Control-Request-Method\") != null) {\n\t\t\tresponse.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST\");\n\t\t\tresponse.setHeader(\"Access-Control-Max-Age\", \"86400\");\n\n\t\t\tString requestCORSHeaders = request.getHeader(\"Access-Control-Request-Headers\");\n\t\t\tif (requestCORSHeaders != null)\n\t\t\t\tresponse.setHeader(\"Access-Control-Allow-Headers\", requestCORSHeaders);\n\t\t}\n\t}\n}\n", "package vcs.citydb.wfs.config;\n\nimport org.citydb.config.util.ConfigConstants;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.SchemaOutputResolver;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.stream.StreamResult;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class WFSConfigSchemaWriter {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSystem.out.print(\"Generating XML schema in \" + Constants.CONFIG_SCHEMA_FILE + \"... \");\n\t\t\n\t\tJAXBContext ctx = JAXBContext.newInstance(WFSConfig.class);\n\t\tctx.generateSchema(new SchemaOutputResolver() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Result createOutput(String namespaceUri, String suggestedFileName) throws IOException {\n\t\t\t\tFile file;\n\n\t\t\t\tif (namespaceUri.equals(ConfigConstants.CITYDB_CONFIG_NAMESPACE_URI))\n\t\t\t\t\tfile = new File(Constants.CONFIG_SCHEMA_FILE);\n\t\t\t\telse\n\t\t\t\t\tfile = new File(Constants.CONFIG_SCHEMA_PATH + \"/ows/\" + suggestedFileName);\n\t\t\t\t\n\t\t\t\tfile.getAbsoluteFile().getParentFile().mkdirs();\n\t\t\t\t\n\t\t\t\tStreamResult res = new StreamResult();\n\t\t\t\tres.setSystemId(file.toURI().toString());\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tSystem.out.println(\"finished.\");\n\t}\n\n}\n", "package vcs.citydb.wfs.operation.getfeature.citygml;\n\nimport net.opengis.wfs._2.GetFeatureType;\nimport net.opengis.wfs._2.ResultTypeType;\nimport org.citydb.ade.model.module.CityDBADE100Module;\nimport org.citydb.ade.model.module.CityDBADE200Module;\nimport org.citydb.config.Config;\nimport org.citydb.core.database.schema.mapping.FeatureType;\nimport org.citydb.core.operation.common.cache.IdCacheManager;\nimport org.citydb.core.operation.exporter.util.InternalConfig;\nimport org.citydb.core.operation.exporter.writer.FeatureWriteException;\nimport org.citydb.util.log.Logger;\nimport org.citydb.util.xml.SecureXMLProcessors;\nimport org.citygml4j.model.module.Module;\nimport org.citygml4j.model.module.ModuleContext;\nimport org.citygml4j.model.module.Modules;\nimport org.citygml4j.model.module.ade.ADEModule;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.citygml4j.util.internal.xml.TransformerChainFactory;\nimport org.citygml4j.util.xml.SAXWriter;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.operation.getfeature.FeatureWriter;\nimport vcs.citydb.wfs.operation.getfeature.GetFeatureResponseBuilder;\nimport vcs.citydb.wfs.operation.getfeature.QueryExpression;\nimport vcs.citydb.wfs.util.GeometryStripper;\n\nimport javax.xml.datatype.DatatypeConfigurationException;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.File;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CityGMLWriterBuilder implements GetFeatureResponseBuilder {\n\tprivate final Logger log = Logger.getInstance();\n\tprivate final String PRETTY_PRINT = \"prettyPrint\";\n\n\tprivate CityGMLVersion version;\n\tprivate GeometryStripper geometryStripper;\n\tprivate IdCacheManager idCacheManager;\n\tprivate InternalConfig internalConfig;\n\tprivate Config config;\n\tprivate Object eventChannel;\n\n\tprivate SAXWriter saxWriter;\n\tprivate TransformerChainFactory transformerChainFactory;\n\n\t@Override\n\tpublic String getMimeType() {\n\t\treturn \"text/xml\";\n\t}\n\n\t@Override\n\tpublic boolean supportsHitsResponse() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void initializeContext(\n\t\t\tGetFeatureType wfsRequest,\n\t\t\tList<QueryExpression> queryExpressions,\n\t\t\tMap<String, String> formatOptions,\n\t\t\tGeometryStripper geometryStripper,\n\t\t\tIdCacheManager idCacheManager,\n\t\t\tObject eventChannel,\n\t\t\tInternalConfig internalConfig,\n\t\t\tWFSConfig wfsConfig,\n\t\t\tConfig config) throws FeatureWriteException {\n\t\tthis.geometryStripper = geometryStripper;\n\t\tthis.idCacheManager = idCacheManager;\n\t\tthis.eventChannel = eventChannel;\n\t\tthis.internalConfig = internalConfig;\n\t\tthis.config = config;\n\n\t\tversion = queryExpressions.get(0).getTargetVersion();\n\n\t\tsaxWriter = new SAXWriter();\n\t\tsaxWriter.setWriteEncoding(true);\n\n\t\tif (\"true\".equals(formatOptions.get(PRETTY_PRINT)))\n\t\t\tsaxWriter.setIndentString(\" \");\n\n\t\t// set WFS prefix and schema location in case we do not have to return the bare feature\n\t\tif (queryExpressions.size() > 1 || !queryExpressions.get(0).isGetFeatureById()) {\n\t\t\tsaxWriter.setPrefix(Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\t\t\tsaxWriter.setSchemaLocation(Constants.WFS_NAMESPACE_URI, Constants.WFS_SCHEMA_LOCATION);\n\t\t}\n\n\t\t// set CityGML prefixes and schema locations if we have to return feature instances\n\t\tif (wfsRequest.getResultType() == ResultTypeType.RESULTS) {\n\t\t\t// add default prefixes and schema locations\n\t\t\tModuleContext moduleContext = new ModuleContext(version);\n\n\t\t\tModule core = moduleContext.getModule(CityGMLModuleType.CORE);\n\t\t\tModule generics = moduleContext.getModule(CityGMLModuleType.GENERICS);\n\t\t\tsaxWriter.setPrefix(core.getNamespacePrefix(), core.getNamespaceURI());\n\t\t\tsaxWriter.setPrefix(generics.getNamespacePrefix(), generics.getNamespaceURI());\n\t\t\tsaxWriter.setSchemaLocation(generics.getNamespaceURI(), generics.getSchemaLocation());\n\t\t\tif (wfsConfig.getConstraints().isExportAppearance()) {\n\t\t\t\tModule appearance = moduleContext.getModule(CityGMLModuleType.APPEARANCE);\n\t\t\t\tsaxWriter.setPrefix(appearance.getNamespacePrefix(), appearance.getNamespaceURI());\n\t\t\t\tsaxWriter.setSchemaLocation(appearance.getNamespaceURI(), appearance.getSchemaLocation());\n\t\t\t}\n\n\t\t\t// add XML prefixes and schema locations for non-CityGML modules\n\t\t\tfor (Module module : moduleContext.getModules()) {\n\t\t\t\tif (!(module instanceof CityGMLModule)) {\n\t\t\t\t\t// skip 3DCityDB ADE prefix and namespace if metadata shall not be exported\n\t\t\t\t\tif ((module == CityDBADE200Module.v3_0 || module == CityDBADE100Module.v3_0)\n\t\t\t\t\t\t\t&& !wfsConfig.getConstraints().isExportCityDBMetadata())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tif (module instanceof ADEModule)\n\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set XML prefixes and schema locations for selected feature types\n\t\t\tfor (QueryExpression queryExpression : queryExpressions) {\n\t\t\t\tfor (FeatureType featureType : queryExpression.getFeatureTypeFilter().getFeatureTypes()) {\n\t\t\t\t\tif (featureType.isAvailableForCityGML(version)) {\n\t\t\t\t\t\tCityGMLModule module = Modules.getCityGMLModule(featureType.getSchema().getNamespace(version).getURI());\n\t\t\t\t\t\tif (module != null) {\n\t\t\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build XSLT transformer chain\n\t\t\tif (wfsConfig.getPostProcessing().getXSLTransformation().isEnabled()\n\t\t\t\t\t&& wfsConfig.getPostProcessing().getXSLTransformation().isSetStylesheets()) {\n\t\t\t\ttry {\n\t\t\t\t\tList<String> stylesheets = wfsConfig.getPostProcessing().getXSLTransformation().getStylesheets();\n\t\t\t\t\tSAXTransformerFactory factory = (SAXTransformerFactory) SecureXMLProcessors.newTransformerFactory();\n\t\t\t\t\tTemplates[] templates = new Templates[stylesheets.size()];\n\n\t\t\t\t\tfor (int i = 0; i < stylesheets.size(); i++) {\n\t\t\t\t\t\tTemplates template = factory.newTemplates(new StreamSource(new File(stylesheets.get(i))));\n\t\t\t\t\t\ttemplates[i] = template;\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformerChainFactory = new TransformerChainFactory(templates);\n\t\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\t\tlog.error(\"Failed to compile XSLT stylesheets.\");\n\t\t\t\t\tlog.error(\"Cause: \" + e.getMessage());\n\t\t\t\t\tthrow new FeatureWriteException(\"Failed to configure the XSL transformation.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic FeatureWriter buildFeatureWriter(Writer writer) throws FeatureWriteException {\n\t\ttry {\n\t\t\tsaxWriter.setOutput(writer);\n\t\t\treturn new CityGMLWriter(saxWriter, version, transformerChainFactory, geometryStripper, idCacheManager, eventChannel, internalConfig, config);\n\t\t} catch (DatatypeConfigurationException e) {\n\t\t\tthrow new FeatureWriteException(\"Failed to create CityGML response writer.\", e);\n\t\t}\n\t}\n\n}\n", "package vcs.citydb.wfs.operation.getpropertyvalue;\n\nimport net.opengis.wfs._2.GetPropertyValueType;\nimport net.opengis.wfs._2.ResultTypeType;\nimport org.citydb.ade.model.module.CityDBADE100Module;\nimport org.citydb.ade.model.module.CityDBADE200Module;\nimport org.citydb.config.Config;\nimport org.citydb.core.database.schema.mapping.FeatureType;\nimport org.citydb.core.operation.exporter.writer.FeatureWriteException;\nimport org.citydb.util.log.Logger;\nimport org.citydb.util.xml.SecureXMLProcessors;\nimport org.citygml4j.model.module.Module;\nimport org.citygml4j.model.module.ModuleContext;\nimport org.citygml4j.model.module.Modules;\nimport org.citygml4j.model.module.ade.ADEModule;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.citygml4j.util.internal.xml.TransformerChainFactory;\nimport org.citygml4j.util.xml.SAXWriter;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.util.GeometryStripper;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\n\nimport javax.xml.datatype.DatatypeConfigurationException;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.File;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.Map;\n\npublic class GetPropertyValueResponseBuilder {\n\tprivate final Logger log = Logger.getInstance();\n\tprivate final String PRETTY_PRINT = \"prettyPrint\";\n\t\n\tprivate String valueReference;\n\tprivate NamespaceFilter namespaceFilter;\n\tprivate CityGMLVersion version;\n\tprivate GeometryStripper geometryStripper;\n\tprivate Config config;\n\tprivate Object eventChannel;\n\t\n\tprivate SAXWriter saxWriter;\n\tprivate TransformerChainFactory transformerChainFactory;\n\tprivate boolean useSequentialWriting;\n\t\n\tpublic String getMimeType() {\n\t\treturn \"text/xml\";\n\t}\n\n\tpublic void initializeContext(GetPropertyValueType wfsRequest,\n\t\t\tQueryExpression queryExpression,\n\t\t\tMap<String, String> formatOptions,\n\t\t\tNamespaceFilter namespaceFilter,\n\t\t\tObject eventChannel,\n\t\t\tWFSConfig wfsConfig,\n\t\t\tConfig config) throws FeatureWriteException {\n\t\tthis.namespaceFilter = namespaceFilter;\n\t\tthis.eventChannel = eventChannel;\n\t\tthis.config = config;\n\t\t\n\t\tvalueReference = queryExpression.getValueReference();\n\t\tversion = queryExpression.getTargetVersion();\n\t\tgeometryStripper = wfsConfig.getConstraints().isStripGeometry() ? new GeometryStripper() : null;\n\n\t\t// require sequential writing if a sorting clause is defined for the query\n\t\tuseSequentialWriting = queryExpression.isSetSorting();\n\n\t\tsaxWriter = new SAXWriter();\n\t\tsaxWriter.setWriteEncoding(true);\n\n\t\tif (\"true\".equals(formatOptions.get(PRETTY_PRINT)))\n\t\t\tsaxWriter.setIndentString(\" \");\n\n\t\t// set WFS prefix and schema location\n\t\tsaxWriter.setPrefix(Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\t\tsaxWriter.setSchemaLocation(Constants.WFS_NAMESPACE_URI, Constants.WFS_SCHEMA_LOCATION);\n\n\t\t// set CityGML prefixes and schema locations\n\t\tif (wfsRequest.getResultType() == ResultTypeType.RESULTS) {\n\t\t\t// add default prefixes and schema locations\n\t\t\tModuleContext moduleContext = new ModuleContext(version);\n\n\t\t\tModule core = moduleContext.getModule(CityGMLModuleType.CORE);\n\t\t\tModule generics = moduleContext.getModule(CityGMLModuleType.GENERICS);\n\t\t\tsaxWriter.setPrefix(core.getNamespacePrefix(), core.getNamespaceURI());\n\t\t\tsaxWriter.setPrefix(generics.getNamespacePrefix(), generics.getNamespaceURI());\n\t\t\tsaxWriter.setSchemaLocation(generics.getNamespaceURI(), generics.getSchemaLocation());\n\t\t\tif (wfsConfig.getConstraints().isExportAppearance()) {\n\t\t\t\tModule appearance = moduleContext.getModule(CityGMLModuleType.APPEARANCE);\n\t\t\t\tsaxWriter.setPrefix(appearance.getNamespacePrefix(), appearance.getNamespaceURI());\n\t\t\t\tsaxWriter.setSchemaLocation(appearance.getNamespaceURI(), appearance.getSchemaLocation());\n\t\t\t}\n\n\t\t\t// add XML prefixes and schema locations for non-CityGML modules\n\t\t\tfor (Module module : moduleContext.getModules()) {\n\t\t\t\tif (!(module instanceof CityGMLModule)) {\n\t\t\t\t\t// skip 3DCityDB ADE prefix and namespace if metadata shall not be exported\n\t\t\t\t\tif ((module == CityDBADE200Module.v3_0 || module == CityDBADE100Module.v3_0)\n\t\t\t\t\t\t\t&& !wfsConfig.getConstraints().isExportCityDBMetadata())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tif (module instanceof ADEModule)\n\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set XML prefixes and schema locations for selected feature types\n\t\t\tfor (FeatureType featureType : queryExpression.getFeatureTypeFilter().getFeatureTypes()) {\n\t\t\t\tCityGMLModule module = Modules.getCityGMLModule(featureType.getSchema().getNamespace(version).getURI());\n\t\t\t\tif (module != null) {\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build XSLT transformer chain\n\t\t\tif (wfsConfig.getPostProcessing().getXSLTransformation().isEnabled()\n\t\t\t\t\t&& wfsConfig.getPostProcessing().getXSLTransformation().isSetStylesheets()) {\n\t\t\t\ttry {\n\t\t\t\t\tList<String> stylesheets = wfsConfig.getPostProcessing().getXSLTransformation().getStylesheets();\n\t\t\t\t\tSAXTransformerFactory factory = (SAXTransformerFactory) SecureXMLProcessors.newTransformerFactory();\n\t\t\t\t\tTemplates[] templates = new Templates[stylesheets.size()];\n\n\t\t\t\t\tfor (int i = 0; i < stylesheets.size(); i++) {\n\t\t\t\t\t\tTemplates template = factory.newTemplates(new StreamSource(new File(stylesheets.get(i))));\n\t\t\t\t\t\ttemplates[i] = template;\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformerChainFactory = new TransformerChainFactory(templates);\n\t\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\t\tlog.error(\"Failed to compile XSLT stylesheets.\");\n\t\t\t\t\tlog.error(\"Cause: \" + e.getMessage());\n\t\t\t\t\tthrow new FeatureWriteException(\"Failed to configure the XSL transformation.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic PropertyValueWriter buildPropertyValueWriter(Writer writer) throws FeatureWriteException {\n\t\ttry {\n\t\t\tsaxWriter.setOutput(writer);\n\t\t\treturn new PropertyValueWriter(valueReference,\n\t\t\t\t\tsaxWriter,\n\t\t\t\t\tversion,\n\t\t\t\t\ttransformerChainFactory,\n\t\t\t\t\tnamespaceFilter,\n\t\t\t\t\tgeometryStripper,\n\t\t\t\t\tuseSequentialWriting,\n\t\t\t\t\teventChannel,\n\t\t\t\t\tconfig);\n\t\t} catch (DatatypeConfigurationException e) {\n\t\t\tthrow new FeatureWriteException(\"Failed to create CityGML response writer.\", e);\n\t\t}\n\t}\n\n}\n", "package vcs.citydb.wfs.operation.storedquery;\n\nimport net.opengis.fes._2.AbstractQueryExpressionType;\nimport net.opengis.fes._2.FilterType;\nimport net.opengis.fes._2.ResourceIdType;\nimport net.opengis.wfs._2.*;\nimport org.citydb.util.xml.SecureXMLProcessors;\nimport org.citygml4j.builder.jaxb.CityGMLBuilder;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.*;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.exception.WFSException;\nimport vcs.citydb.wfs.exception.WFSExceptionCode;\nimport vcs.citydb.wfs.kvp.KVPConstants;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLOutputFactory;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StoredQueryManager {\n\tprivate final String GET_FEATURE_BY_ID_NAME = \"http://www.opengis.net/def/query/OGC-WFS/0/GetFeatureById\";\n\tprivate final String DEPRECATED_GET_FEATURE_BY_ID_NAME = \"urn:ogc:def:query:OGC-WFS::GetFeatureById\";\n\n\tprivate final StoredQuery DEFAULT_QUERY;\n\tprivate final CityGMLBuilder cityGMLBuilder;\n\tprivate final SAXParserFactory saxParserFactory;\n\tprivate final TransformerFactory transformerFactory;\n\tprivate final DocumentBuilderFactory documentBuilderFactory;\n\tprivate final XMLOutputFactory xmlOutputFactory;\n\tprivate final Path storedQueriesPath;\n\tprivate final ObjectFactory wfsFactory;\n\tprivate final WFSConfig wfsConfig;\n\tprivate final MessageDigest md5;\n\n\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException, TransformerConfigurationException {\n\t\tthis.cityGMLBuilder = cityGMLBuilder;\n\t\tthis.saxParserFactory = saxParserFactory;\n\t\tthis.wfsConfig = wfsConfig;\n\n\t\tmd5 = MessageDigest.getInstance(\"MD5\");\n\t\twfsFactory = new ObjectFactory();\n\t\ttransformerFactory = SecureXMLProcessors.newTransformerFactory();\n\t\txmlOutputFactory = XMLOutputFactory.newInstance();\n\t\tdocumentBuilderFactory = SecureXMLProcessors.newDocumentBuilderFactory();\n\t\tdocumentBuilderFactory.setNamespaceAware(true);\n\n\t\tstoredQueriesPath = Paths.get(path);\n\t\tFiles.createDirectories(storedQueriesPath);\n\t\tif (!Files.isDirectory(storedQueriesPath) || !Files.isReadable(storedQueriesPath))\n\t\t\tthrow new IOException(\"Path for stored queries is not readable.\");\n\n\t\tDEFAULT_QUERY = createDefaultStoredQuery();\n\t}\n\n\tpublic List<StoredQueryAdapter> listStoredQueries(String handle) throws WFSException {\n\t\tList<StoredQueryAdapter> storedQueries = new ArrayList<>();\n\t\tstoredQueries.add(new StoredQueryAdapter(DEFAULT_QUERY.getId()));\n\n\t\ttry {\n\t\t\ttry (DirectoryStream<Path> stream = Files.newDirectoryStream(storedQueriesPath)) {\n\t\t\t\tfor (Path file : stream) {\n\t\t\t\t\tif (Files.isRegularFile(file))\n\t\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to list stored queries.\", handle, e);\n\t\t}\n\n\t\treturn storedQueries;\n\t}\n\n\tpublic StoredQuery getStoredQuery(StoredQueryAdapter adapter, String handle) throws WFSException {\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(adapter.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(adapter.getId()))\n\t\t\treturn DEFAULT_QUERY;\n\n\t\tPath file = adapter.isSetId() ? storedQueriesPath.resolve(getFileName(adapter.getId())) : adapter.getFile();\n\t\tif (!Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"A stored query with identifier '\" + adapter.getId() + \"' is not offered by this server.\", KVPConstants.STOREDQUERY_ID);\n\n\t\treturn unmarshalStoredQuery(file, handle);\n\t}\n\n\tpublic Element parseStoredQuery(StoredQueryAdapter adapter, String handle) throws WFSException {\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(adapter.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(adapter.getId()))\n\t\t\treturn DEFAULT_QUERY.toDOMElement(handle);\n\n\t\tPath file = adapter.isSetId() ? storedQueriesPath.resolve(getFileName(adapter.getId())) : adapter.getFile();\n\t\tif (!Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"A stored query with identifier '\" + adapter.getId() + \"' is not offered by this server.\", KVPConstants.STOREDQUERY_ID);\n\n\t\treturn parseStoredQuery(file, handle);\n\t}\n\n\tpublic StoredQuery createStoredQuery(StoredQueryDescriptionType description, NamespaceFilter namespaceFilter, String handle) throws WFSException {\t\t\n\t\tif (!description.isSetId())\n\t\t\tthrow new WFSException(WFSExceptionCode.MISSING_PARAMETER_VALUE, \"The stored query description lacks the mandatory identifier.\", KVPConstants.STOREDQUERY_ID);\n\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(description.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(description.getId()))\n\t\t\tthrow new WFSException(WFSExceptionCode.DUPLICATE_STORED_QUERY_ID_VALUE, \"The identifier '\" + description.getId() + \"' is associated to the mandatory GetFeatureById query. Choose another identifier.\", description.getId());\n\n\t\t// serialize stored query to file\n\t\tPath file = storedQueriesPath.resolve(getFileName(description.getId()));\n\t\tif (Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.DUPLICATE_STORED_QUERY_ID_VALUE, \"The identifier '\" + description.getId() + \"' has already been associated with to a stored query. Drop the stored query first or choose another identifier.\", description.getId());\n\n\t\tStoredQuery storedQuery = new StoredQuery(description, namespaceFilter, this);\n\t\tstoredQuery.validate(handle);\n\n\t\ttry {\n\t\t\tDescribeStoredQueriesResponseType response = new DescribeStoredQueriesResponseType();\n\t\t\tresponse.getStoredQueryDescription().add(description);\n\t\t\tJAXBElement<DescribeStoredQueriesResponseType> jaxbElement = wfsFactory.createDescribeStoredQueriesResponse(response);\n\n\t\t\tMarshaller marshaller = cityGMLBuilder.getJAXBContext().createMarshaller();\n\t\t\tmarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n\t\t\tmarshaller.marshal(jaxbElement, file.toFile());\n\t\t} catch (JAXBException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to persist stored query.\", handle, e);\n\t\t}\n\n\t\treturn storedQuery;\n\t}\n\t\n\tpublic void dropStoredQuery(String id, String handle) throws WFSException {\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(id) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(id))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"The mandatory stored query '\" + id + \"' must not be dropped.\", handle);\n\t\t\n\t\tPath file = storedQueriesPath.resolve(getFileName(id));\n\t\tif (!Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"A stored query with identifier '\" + id + \"' is not offered by this server.\", handle);\n\n\t\ttry {\n\t\t\tFiles.delete(file);\n\t\t} catch (IOException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to drop the stored query with identifier '\" + id + \"'.\", handle);\n\t\t}\n\t}\n\n\tpublic void compileQuery(AbstractQueryExpressionType abstractQuery, List<QueryType> queries, NamespaceFilter namespaceFilter, String handle) throws WFSException {\n\t\tif (abstractQuery instanceof QueryType) {\n\t\t\tif (!wfsConfig.getConstraints().isSupportAdHocQueries())\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"Ad hoc queries are not advertised.\", handle);\n\t\t\t\n\t\t\tqueries.add((QueryType)abstractQuery);\n\t\t} \n\n\t\telse if (abstractQuery instanceof StoredQueryType) {\n\t\t\tStoredQueryType query = (StoredQueryType)abstractQuery;\n\n\t\t\tStoredQuery storedQuery = getStoredQuery(new StoredQueryAdapter(query.getId()), handle);\n\t\t\tif (storedQuery != null) {\n\t\t\t\tif (storedQuery.getId().equals(DEFAULT_QUERY.getId())) {\n\t\t\t\t\tQueryType queryType = (QueryType) storedQuery.compile(query, namespaceFilter).iterator().next();\n\n\t\t\t\t\tif (queryType.isSetAbstractSelectionClause() && queryType.getAbstractSelectionClause().getValue() instanceof FilterType) {\n\t\t\t\t\t\tFilterType filter = (FilterType) queryType.getAbstractSelectionClause().getValue();\n\t\t\t\t\t\tif (filter.isSet_Id() && filter.get_Id().get(0).getValue() instanceof ResourceIdType) {\n\t\t\t\t\t\t\tResourceIdType resourceId = (ResourceIdType) filter.get_Id().get(0).getValue();\n\t\t\t\t\t\t\tqueryType.setFeatureIdentifier(resourceId.getRid());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!queryType.isSetFeatureIdentifier())\n\t\t\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Lacking identifier for the '\" + DEFAULT_QUERY.getId() + \"' stored query.\", handle);\n\n\t\t\t\t\tqueries.add(queryType);\n\t\t\t\t} else {\n\t\t\t\t\tfor (AbstractQueryExpressionType compiled : storedQuery.compile(query, namespaceFilter))\n\t\t\t\t\t\tcompileQuery(compiled, queries, namespaceFilter, handle);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"No stored query with identifier '\" + query.getId() + \"' is offered by this server.\", handle);\n\t\t} \n\n\t\telse\n\t\t\tthrow new WFSException(WFSExceptionCode.OPTION_NOT_SUPPORTED, \"Only ad hoc and stored query expressions are supported.\", handle);\n\t}\n\n\tpublic boolean containsStoredQuery(String id, String handle) {\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\treturn GET_FEATURE_BY_ID_NAME.equals(id)\n\t\t\t\t|| DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(id)\n\t\t\t\t|| Files.exists(storedQueriesPath.resolve(getFileName(id)));\n\t}\n\n\tprivate StoredQuery unmarshalStoredQuery(Path file, String handle) throws WFSException {\n\t\tif (!Files.isReadable(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to read the stored query file.\", handle);\n\n\t\tObject object;\n\t\tNamespaceFilter namespaceFilter;\n\n\t\ttry {\n\t\t\tUnmarshaller unmarshaller = cityGMLBuilder.getJAXBContext().createUnmarshaller();\n\t\t\tUnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\t\t\t\n\n\t\t\t// use SAX parser to keep track of namespace declarations\n\t\t\tSAXParser parser = saxParserFactory.newSAXParser();\t\t\t\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\tnamespaceFilter = new NamespaceFilter(reader);\n\t\t\tnamespaceFilter.setContentHandler(unmarshallerHandler);\n\n\t\t\tnamespaceFilter.parse(new InputSource(new BufferedReader(new FileReader(file.toFile()))));\n\t\t\tobject = unmarshallerHandler.getResult();\n\n\t\t} catch (JAXBException | SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Fatal JAXB error whilst processing the stored query.\", handle, e);\n\t\t}\n\n\t\tif (!(object instanceof JAXBElement<?>))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to parse the stored query file.\", handle);\n\n\t\tJAXBElement<?> jaxbElement = (JAXBElement<?>)object;\n\t\tif (!(jaxbElement.getValue() instanceof DescribeStoredQueriesResponseType))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Invalid content of the stored query file.\", handle);\n\n\t\tDescribeStoredQueriesResponseType response = (DescribeStoredQueriesResponseType)jaxbElement.getValue();\n\t\tif (response.getStoredQueryDescription().size() == 0)\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to parse the stored query file. No stored query description provided.\", handle);\n\n\t\tStoredQueryDescriptionType description = response.getStoredQueryDescription().get(0);\n\t\tif (!file.getFileName().toString().equals(getFileName(description.getId())))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"The stored query identifier '\" + description.getId() + \"' does not match the storage identifier.\", handle);\n\n\t\treturn new StoredQuery(description, namespaceFilter, this);\n\t}\n\n\tprivate Element parseStoredQuery(Path file, String handle) throws WFSException {\n\t\tif (!Files.isReadable(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to read the stored query file.\", handle);\n\n\t\ttry {\n\t\t\tDocument document = documentBuilderFactory.newDocumentBuilder().parse(file.toFile());\n\t\t\treturn processStoredQueryElement(document.getDocumentElement(), handle);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Fatal error whilst processing the stored query.\", handle, e);\n\t\t}\n\t}\n\n\tprotected Element processStoredQueryElement(Element root, String handle) throws WFSException {\n\t\ttry {\n\t\t\tNodeList nodeList = root.getElementsByTagNameNS(Constants.WFS_NAMESPACE_URI, \"StoredQueryDescription\");\n\t\t\tif (nodeList.getLength() == 0 || nodeList.getLength() > 1)\n\t\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to parse the stored query file. No stored query description provided.\", handle);\n\n\t\t\tElement description = (Element)nodeList.item(0);\n\n\t\t\t// copy namespace attributes from root element\n\t\t\tNamedNodeMap attributes = root.getAttributes();\n\t\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\t\tAttr attribute = (Attr)attributes.item(i);\n\t\t\t\tif (attribute.getNamespaceURI().equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI)) {\n\t\t\t\t\tif (attribute.getValue().equals(\"http://www.w3.org/2001/SMIL20/\") \n\t\t\t\t\t\t\t|| attribute.getValue().equals(\"http://www.w3.org/2001/SMIL20/Language\"))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdescription.setAttributeNS(attribute.getNamespaceURI(), attribute.getName(), attribute.getValue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove empty text nodes\n\t\t\tXPathFactory xpathFactory = XPathFactory.newInstance();\n\t\t\tXPathExpression xpathExp = xpathFactory.newXPath().compile(\"//text()[normalize-space(.) = '']\");  \n\t\t\tNodeList emptyNodeList = (NodeList)xpathExp.evaluate(root, XPathConstants.NODESET);\n\t\t\tfor (int i = 0; i < emptyNodeList.getLength(); i++) {\n\t\t\t\tNode emptyNode = emptyNodeList.item(i);\n\t\t\t\temptyNode.getParentNode().removeChild(emptyNode);\n\t\t\t}\n\n\t\t\treturn description;\n\t\t} catch (XPathExpressionException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Fatal error whilst processing the stored query.\", handle, e);\n\t\t}\n\t}\n\n\tprivate String getFileName(String id) {\n\t\tbyte[] md5Hash = md5.digest(id.getBytes());\n\n\t\tStringBuilder hexString = new StringBuilder();\n\t\tfor (byte item : md5Hash)\n\t\t\thexString.append(Integer.toString((item & 0xff) + 0x100, 16).substring(1));\n\n\t\treturn hexString.append(\".xml\").toString();\n\t}\n\n\tprotected CityGMLBuilder getCityGMLBuilder() {\n\t\treturn cityGMLBuilder;\n\t}\n\n\tprotected TransformerFactory getTransformerFactory() {\n\t\treturn transformerFactory;\n\t}\n\n\tprotected DocumentBuilderFactory getDocumentBuilderFactory() {\n\t\treturn documentBuilderFactory;\n\t}\n\t\n\tprotected XMLOutputFactory getXMLOutputFactory() {\n\t\treturn xmlOutputFactory;\n\t}\n\n\tprotected ObjectFactory getObjectFactory() {\n\t\treturn wfsFactory;\n\t}\n\t\n\tprotected WFSConfig getWFSConfig() {\n\t\treturn wfsConfig;\n\t}\n\n\tprivate StoredQuery createDefaultStoredQuery() throws ParserConfigurationException, SAXException {\n\t\t// GetFeatureById query according to the WFS 2.0 spec\n\t\tStoredQueryDescriptionType description = new StoredQueryDescriptionType();\n\n\t\tdescription.setId(!Constants.DEFAULT_WFS_VERSION.equals(\"2.0.0\") ?\n\t\t\t\tGET_FEATURE_BY_ID_NAME : DEPRECATED_GET_FEATURE_BY_ID_NAME);\n\n\t\tTitle queryTitle = new Title();\n\t\tqueryTitle.setLang(\"en\");\n\t\tqueryTitle.setValue(\"Get feature by identifier\");\n\t\tdescription.getTitle().add(queryTitle);\n\t\tAbstract queryAbstract = new Abstract();\n\t\tqueryAbstract.setLang(\"en\");\n\t\tqueryAbstract.setValue(\"Retrieves a feature by its gml:id.\");\n\t\tdescription.getAbstract().add(queryAbstract);\n\n\t\tParameterExpressionType parameter = new ParameterExpressionType();\n\t\tparameter.setName(\"id\");\n\t\tparameter.setType(XSDataType.XS_STRING.getName());\n\t\tTitle parameterTitle = new Title();\n\t\tparameterTitle.setLang(\"en\");\n\t\tparameterTitle.setValue(\"Identifier\");\n\t\tparameter.getTitle().add(parameterTitle);\n\t\tAbstract parameterAbstract = new Abstract();\n\t\tparameterAbstract.setLang(\"en\");\n\t\tparameterAbstract.setValue(\"The gml:id of the feature to be retrieved.\");\n\t\tparameter.getAbstract().add(parameterAbstract);\n\t\tdescription.getParameter().add(parameter);\n\n\t\tDocument document = documentBuilderFactory.newDocumentBuilder().newDocument();\n\t\tElement query = document.createElementNS(Constants.WFS_NAMESPACE_URI, Constants.WFS_NAMESPACE_PREFIX + \":Query\");\n\t\tquery.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, \"xmlns:\" + Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\n\t\tNamespaceFilter namespaceFilter = new NamespaceFilter();\n\t\tCityGMLVersion version = wfsConfig.getFeatureTypes().getDefaultVersion();\n\t\tboolean multipleVersions = wfsConfig.getFeatureTypes().getVersions().size() > 1;\n\t\tCityGMLModule module = version.getCityGMLModule(CityGMLModuleType.CORE);\t\t\n\t\tString prefix = module.getNamespacePrefix();\n\t\tif (multipleVersions)\n\t\t\tprefix += (version == CityGMLVersion.v2_0_0) ? \"2\" : \"1\";\n\n\t\tnamespaceFilter.startPrefixMapping(prefix, module.getNamespaceURI());\n\t\tnamespaceFilter.startPrefixMapping(\"xs\", XMLConstants.W3C_XML_SCHEMA_NS_URI);\n\t\tquery.setAttribute(\"typeNames\", \"schema-element(\" + prefix + ':' + \"_CityObject)\");\n\t\tquery.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, \"xmlns:\" + prefix, module.getNamespaceURI());\n\n\t\tElement filter = document.createElementNS(Constants.FES_NAMESPACE_URI, Constants.FES_NAMESPACE_PREFIX + \":Filter\");\n\t\tfilter.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, \"xmlns:\" + Constants.FES_NAMESPACE_PREFIX, Constants.FES_NAMESPACE_URI);\n\t\tElement resourceId = document.createElementNS(Constants.FES_NAMESPACE_URI, Constants.FES_NAMESPACE_PREFIX + \":ResourceId\");\n\t\tresourceId.setAttribute(\"rid\", \"${id}\");\n\t\tfilter.appendChild(resourceId);\n\t\tquery.appendChild(filter);\n\n\t\tQueryExpressionTextType queryExpression = new QueryExpressionTextType();\n\t\tqueryExpression.getContent().add(query);\t\t\n\t\tqueryExpression.setIsPrivate(false);\n\t\tqueryExpression.setLanguage(\"en\");\n\t\tqueryExpression.setReturnFeatureTypes(new ArrayList<>());\n\t\tqueryExpression.setLanguage(StoredQuery.DEFAULT_LANGUAGE);\n\t\tdescription.getQueryExpressionText().add(queryExpression);\n\n\t\treturn new StoredQuery(description, namespaceFilter, this);\n\t}\n\n}\n"], "filenames": ["CHANGES.md", "build.gradle", "src/main/java/vcs/citydb/wfs/WFSService.java", "src/main/java/vcs/citydb/wfs/config/WFSConfigSchemaWriter.java", "src/main/java/vcs/citydb/wfs/operation/getfeature/citygml/CityGMLWriterBuilder.java", "src/main/java/vcs/citydb/wfs/operation/getpropertyvalue/GetPropertyValueResponseBuilder.java", "src/main/java/vcs/citydb/wfs/operation/storedquery/StoredQueryManager.java"], "buggy_code_start_loc": [2, 41, 9, 3, 12, 10, 6], "buggy_code_end_loc": [2, 47, 95, 25, 144, 128, 89], "fixing_code_start_loc": [3, 42, 10, 3, 13, 11, 7], "fixing_code_end_loc": [8, 50, 104, 25, 144, 128, 94], "type": "CWE-611", "message": "A vulnerability was found in 3D City Database OGC Web Feature Service up to 5.2.0. It has been rated as problematic. This issue affects some unknown processing. The manipulation leads to xml external entity reference. Upgrading to version 5.2.1 is able to address this issue. The name of the patch is 246f4e2a97ad81491c00a7ed72ce5e7c7f75050a. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216215.", "other": {"cve": {"id": "CVE-2022-4607", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-18T22:15:10.723", "lastModified": "2023-01-06T13:57:38.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in 3D City Database OGC Web Feature Service up to 5.2.0. It has been rated as problematic. This issue affects some unknown processing. The manipulation leads to xml external entity reference. Upgrading to version 5.2.1 is able to address this issue. The name of the patch is 246f4e2a97ad81491c00a7ed72ce5e7c7f75050a. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216215."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tum:ogc_web_feature_service:*:*:*:*:*:3dcitydb:*:*", "versionEndExcluding": "5.2.1", "matchCriteriaId": "91401A0C-6623-4254-92C0-89D557C9D5B3"}]}]}], "references": [{"url": "https://github.com/3dcitydb/web-feature-service/commit/246f4e2a97ad81491c00a7ed72ce5e7c7f75050a", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/3dcitydb/web-feature-service/pull/12", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/3dcitydb/web-feature-service/releases/tag/v5.2.1", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216215", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/3dcitydb/web-feature-service/commit/246f4e2a97ad81491c00a7ed72ce5e7c7f75050a"}}