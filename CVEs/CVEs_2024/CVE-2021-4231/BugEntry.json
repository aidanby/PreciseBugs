{"buggy_code": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst END_COMMENT = /-->/g;\nconst END_COMMENT_ESCAPED = '-\\u200B-\\u200B>';\n\n/**\n * Escape the content of the strings so that it can be safely inserted into a comment node.\n *\n * The issue is that HTML does not specify any way to escape comment end text inside the comment.\n * `<!-- The way you close a comment is with \"-->\". -->`. Above the `\"-->\"` is meant to be text not\n * an end to the comment. This can be created programmatically through DOM APIs.\n *\n * ```\n * div.innerHTML = div.innerHTML\n * ```\n *\n * One would expect that the above code would be safe to do, but it turns out that because comment\n * text is not escaped, the comment may contain text which will prematurely close the comment\n * opening up the application for XSS attack. (In SSR we programmatically create comment nodes which\n * may contain such text and expect them to be safe.)\n *\n * This function escapes the comment text by looking for the closing char sequence `-->` and replace\n * it with `-_-_>` where the `_` is a zero width space `\\u200B`. The result is that if a comment\n * contains `-->` text it will render normally but it will not cause the HTML parser to close the\n * comment.\n *\n * @param value text to make safe for comment node by escaping the comment close character sequence\n */\nexport function escapeCommentText(value: string): string {\n  return value.replace(END_COMMENT, END_COMMENT_ESCAPED);\n}", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Component} from '@angular/core';\nimport {TestBed} from '@angular/core/testing';\n\n\ndescribe('comment node text escaping', () => {\n  it('should not be possible to do XSS through comment reflect data', () => {\n    @Component({template: `<div><span *ngIf=\"xssValue\"></span><div>`})\n    class XSSComp {\n      xssValue: string = '--> --><script>\"evil\"</script>';\n    }\n\n    TestBed.configureTestingModule({declarations: [XSSComp]});\n    const fixture = TestBed.createComponent(XSSComp);\n    fixture.detectChanges();\n    const div = fixture.nativeElement.querySelector('div') as HTMLElement;\n    // Serialize into a string to mimic SSR serialization.\n    const html = div.innerHTML;\n    // This must be escaped or we have XSS.\n    expect(html).not.toContain('--><script');\n    // Now parse it back into DOM (from string)\n    div.innerHTML = html;\n    // Verify that we did not accidentally deserialize the `<script>`\n    const script = div.querySelector('script');\n    expect(script).toBeFalsy();\n  });\n});", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {escapeCommentText} from '@angular/core/src/util/dom';\n\ndescribe('comment node text escaping', () => {\n  describe('escapeCommentText', () => {\n    it('should not change anything on basic text', () => {\n      expect(escapeCommentText('text')).toEqual('text');\n    });\n\n    it('should escape end marker', () => {\n      expect(escapeCommentText('before-->after')).toEqual('before-\\u200b-\\u200b>after');\n    });\n\n    it('should escape multiple markers', () => {\n      expect(escapeCommentText('before-->inline-->after'))\n          .toEqual('before-\\u200b-\\u200b>inline-\\u200b-\\u200b>after');\n    });\n  });\n});\n"], "fixing_code": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Disallowed strings in the comment.\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n */\nconst COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;\n/**\n * Delimiter in the disallowed strings which needs to be wrapped with zero with character.\n */\nconst COMMENT_DELIMITER = /(<|>)/;\nconst COMMENT_DELIMITER_ESCAPED = '\\u200B$1\\u200B';\n\n/**\n * Escape the content of comment strings so that it can be safely inserted into a comment node.\n *\n * The issue is that HTML does not specify any way to escape comment end text inside the comment.\n * Consider: `<!-- The way you close a comment is with \">\", and \"->\" at the beginning or by \"-->\" or\n * \"--!>\" at the end. -->`. Above the `\"-->\"` is meant to be text not an end to the comment. This\n * can be created programmatically through DOM APIs. (`<!--` are also disallowed.)\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n *\n * ```\n * div.innerHTML = div.innerHTML\n * ```\n *\n * One would expect that the above code would be safe to do, but it turns out that because comment\n * text is not escaped, the comment may contain text which will prematurely close the comment\n * opening up the application for XSS attack. (In SSR we programmatically create comment nodes which\n * may contain such text and expect them to be safe.)\n *\n * This function escapes the comment text by looking for comment delimiters (`<` and `>`) and\n * surrounding them with `_>_` where the `_` is a zero width space `\\u200B`. The result is that if a\n * comment contains any of the comment start/end delimiters (such as `<!--`, `-->` or `--!>`) the\n * text it will render normally but it will not cause the HTML parser to close/open the comment.\n *\n * @param value text to make safe for comment node by escaping the comment open/close character\n *     sequence.\n */\nexport function escapeCommentText(value: string): string {\n  return value.replace(\n      COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));\n}", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Component} from '@angular/core';\nimport {TestBed} from '@angular/core/testing';\n\n\ndescribe('comment node text escaping', () => {\n  // see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n  ['>',         // self closing\n   '-->',       // standard closing\n   '--!>',      // alternate closing\n   '<!-- -->',  // embedded comment.\n  ].forEach((xssValue) => {\n    it('should not be possible to do XSS through comment reflect data when writing: ' + xssValue,\n       () => {\n         @Component({template: `<div><span *ngIf=\"xssValue\"></span><div>`})\n         class XSSComp {\n           // ngIf serializes the `xssValue` into a comment for debugging purposes.\n           xssValue: string = xssValue + '<script>\"evil\"</script>';\n         }\n\n         TestBed.configureTestingModule({declarations: [XSSComp]});\n         const fixture = TestBed.createComponent(XSSComp);\n         fixture.detectChanges();\n         const div = fixture.nativeElement.querySelector('div') as HTMLElement;\n         // Serialize into a string to mimic SSR serialization.\n         const html = div.innerHTML;\n         // This must be escaped or we have XSS.\n         expect(html).not.toContain('--><script');\n         // Now parse it back into DOM (from string)\n         div.innerHTML = html;\n         // Verify that we did not accidentally deserialize the `<script>`\n         const script = div.querySelector('script');\n         expect(script).toBeFalsy();\n       });\n  });\n});", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {escapeCommentText} from '@angular/core/src/util/dom';\n\ndescribe('comment node text escaping', () => {\n  describe('escapeCommentText', () => {\n    it('should not change anything on basic text', () => {\n      expect(escapeCommentText('text')).toEqual('text');\n    });\n\n    it('should escape \"<\" or \">\"', () => {\n      expect(escapeCommentText('<!--')).toEqual('\\u200b<\\u200b!--');\n      expect(escapeCommentText('<!--<!--')).toEqual('\\u200b<\\u200b!--\\u200b<\\u200b!--');\n      expect(escapeCommentText('>')).toEqual('\\u200b>\\u200b');\n      expect(escapeCommentText('>-->')).toEqual('\\u200b>\\u200b--\\u200b>\\u200b');\n    });\n\n    it('should escape end marker', () => {\n      expect(escapeCommentText('before-->after')).toEqual('before--\\u200b>\\u200bafter');\n    });\n\n    it('should escape multiple markers', () => {\n      expect(escapeCommentText('before-->inline-->after'))\n          .toEqual('before--\\u200b>\\u200binline--\\u200b>\\u200bafter');\n    });\n\n    it('should caver the spec', () => {\n      // https://html.spec.whatwg.org/multipage/syntax.html#comments\n      expect(escapeCommentText('>')).toEqual('\\u200b>\\u200b');\n      expect(escapeCommentText('->')).toEqual('-\\u200b>\\u200b');\n      expect(escapeCommentText('<!--')).toEqual('\\u200b<\\u200b!--');\n      expect(escapeCommentText('-->')).toEqual('--\\u200b>\\u200b');\n      expect(escapeCommentText('--!>')).toEqual('--!\\u200b>\\u200b');\n      expect(escapeCommentText('<!-')).toEqual('\\u200b<\\u200b!-');\n\n      // Things which are OK\n      expect(escapeCommentText('.>')).toEqual('.>');\n      expect(escapeCommentText('.->')).toEqual('.->');\n      expect(escapeCommentText('<!-.')).toEqual('<!-.');\n    });\n  });\n});\n"], "filenames": ["packages/core/src/util/dom.ts", "packages/core/test/acceptance/security_spec.ts", "packages/core/test/util/dom_spec.ts"], "buggy_code_start_loc": [9, 14, 16], "buggy_code_end_loc": [37, 33, 24], "fixing_code_start_loc": [9, 14, 17], "fixing_code_end_loc": [51, 42, 46], "type": "CWE-79", "message": "A vulnerability was found in Angular up to 11.0.4/11.1.0-next.2. It has been classified as problematic. Affected is the handling of comments. The manipulation leads to cross site scripting. It is possible to launch the attack remotely but it might require an authentication first. Upgrading to version 11.0.5 and 11.1.0-next.3 is able to address this issue. The name of the patch is ba8da742e3b243e8f43d4c63aa842b44e14f2b09. It is recommended to upgrade the affected component.", "other": {"cve": {"id": "CVE-2021-4231", "sourceIdentifier": "cna@vuldb.com", "published": "2022-05-26T14:15:07.953", "lastModified": "2022-06-07T19:07:09.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Angular up to 11.0.4/11.1.0-next.2. It has been classified as problematic. Affected is the handling of comments. The manipulation leads to cross site scripting. It is possible to launch the attack remotely but it might require an authentication first. Upgrading to version 11.0.5 and 11.1.0-next.3 is able to address this issue. The name of the patch is ba8da742e3b243e8f43d4c63aa842b44e14f2b09. It is recommended to upgrade the affected component."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad en Angular versiones hasta 11.0.4/11.1.0-next.2. Ha sido clasificada como problem\u00e1tica. Est\u00e1 afectada la manipulaci\u00f3n de los comentarios. La manipulaci\u00f3n conlleva  a un ataque de tipo cross site scripting. Es posible lanzar el ataque de forma remota, pero podr\u00eda requerir una autenticaci\u00f3n previa. La actualizaci\u00f3n a versiones 11.0.5 y 11.1.0-next.3 puede abordar este problema. El nombre del parche es ba8da742e3b243e8f43d4c63aa842b44e14f2b09. Es recomendado actualizar el componente afectado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:angular:angular:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "11.0.5", "matchCriteriaId": "5A6D9CF5-C960-47FC-B102-0C03D7B36E29"}, {"vulnerable": true, "criteria": "cpe:2.3:a:angular:angular:11.1.0:next_0:*:*:*:node.js:*:*", "matchCriteriaId": "1D56DDCF-45E8-4B74-A2EC-67993A8BB983"}, {"vulnerable": true, "criteria": "cpe:2.3:a:angular:angular:11.1.0:next_1:*:*:*:node.js:*:*", "matchCriteriaId": "8F53A2ED-9AC4-43C7-AEC8-39CD29CC5C97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:angular:angular:11.1.0:next_2:*:*:*:node.js:*:*", "matchCriteriaId": "9875CC1E-1DAD-455B-BD9C-C0DEF12E962E"}]}]}], "references": [{"url": "https://github.com/angular/angular/commit/ba8da742e3b243e8f43d4c63aa842b44e14f2b09", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/angular/angular/issues/40136", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-ANGULARCORE-1070902", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.181356", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/angular/angular/commit/ba8da742e3b243e8f43d4c63aa842b44e14f2b09"}}